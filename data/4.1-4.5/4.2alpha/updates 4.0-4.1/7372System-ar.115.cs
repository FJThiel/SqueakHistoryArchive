"Change Set:		7372System-ar.115System-ar.115:Post-closure cleanup and underscore removal."!!ResourceManager class methodsFor: 'private-resources' stamp: 'mir 8/21/2001 15:50'!localizedExternalResources	^LocalizedExternalResources ifNil:[LocalizedExternalResources := Dictionary new]! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!dataBits: anInteger	"Set the number of data bits for this serial port to 5, 6, 7, or 8."	dataBits := anInteger.! !!SARInstaller methodsFor: 'fileIn' stamp: 'nk 10/12/2003 20:41'!installAllMembers	"Try to install all the members, in order, based on their filenames and/or contents."	| uninstalled |	uninstalled := OrderedCollection new.	zip members do: [ :member | self installMember: member ].	uninstalled := self uninstalledMembers.	uninstalled isEmpty ifTrue: [ ^self ].	uninstalled inspect.! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'mdr 8/31/2000 18:43'!testExamplesFromDisk	"verify messages from file on disk"	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm testExamplesFromDisk"	| msg  sig file publicKey |	file := FileStream readOnlyFileNamed: 'dsa.test.out'.	[		[file atEnd] whileFalse: [			sig := file nextChunk.			msg := file nextChunk.			publicKey := Compiler evaluate: file nextChunk.			(self verify: sig isSignatureOf: msg publicKey: publicKey) ifTrue: [				Transcript show: 'SUCCESS: ',msg; cr.			] ifFalse: [				self error: 'ERROR!! Signature verification failed'			].		].	] ensure: [file close]! !!Utilities class methodsFor: 'scraps' stamp: 'sw 8/18/1999 19:56'!addToTrash: aMorph	"Paste the object onto a page of the system Trash book, unless the preference is set to empty the trash immediately."	| aBook aPage |	Preferences preserveTrash ifFalse: [^ self].	aBook := self scrapsBook.	aMorph position: aBook pages first position + (0@40).	aBook pages do: [:pp | 		(pp submorphs size = 1 and: [pp hasProperty: #trash]) ifTrue:  "perhaps remove that property here"			["page is blank"			^ pp addMorph: aMorph]].	aPage := aBook insertPageLabel: Time dateAndTimeNow printString		morphs: (Array with: aMorph).	aPage setProperty: #trash toValue: true! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sd 11/16/2003 12:55'!internalizeChangeLog    		"Smalltalk internalizeChangeLog"	"Bring the changes file into a memory-resident filestream, for faster access and freedom from external file system.  1/31/96 sw"	| reply aName aFile |	reply := self confirm:  'CAUTION -- do not undertake this lightly!!If you have backed up your system andare prepared to face the consequences ofthe requested internalization of sources,hit Yes.  If you have any doubts, hit Noto back out with no harm done.'.	(reply ==  true) ifFalse:		[^ self inform: 'Okay - abandoned'].	aName := SmalltalkImage current changesName.	(aFile := SourceFiles last) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile := FileStream readOnlyFileNamed: aName].	SourceFiles at: 2 put: (ReadWriteStream with: aFile contentsOfEntireFile).	self inform: 'Okay, changes file internalized'! !!ResourceCollector methodsFor: 'accessing' stamp: 'mir 10/29/2003 13:33'!objectForDataStream: refStream fromForm: aForm	"Return a replacement for aForm to be stored instead"	| stub fName copy loc fullSize nameAndSize |	"First check if the form is one of the intrinsic Squeak forms"	stub := internalStubs at: aForm ifAbsent:[nil].	stub ifNotNil:[		refStream replace: aForm with: stub. 		^stub].	"Now see if we have created the stub already 	(this may happen if for instance some form is shared)"	stub := originalMap at: aForm ifAbsent:[nil].	stub ifNotNil:[^aForm].	aForm hibernate.	aForm bits class == FormStub ifTrue:[^nil].	"something is wrong"	"too small to be of interest"	"(aForm bits byteSize < 4096) ifTrue:[^aForm]."	"We'll turn off writing out forms until we figure out how to reliably deal with resources"	true ifTrue: [^aForm].	"Create our stub form"	stub := FormStub 		extent: (aForm width min: 32) @ (aForm height min: 32) 		depth: (aForm depth min: 8).	aForm displayScaledOn: stub.	aForm hibernate.	"Create a copy of the original form which we use to store those bits"	copy := Form extent: aForm extent depth: aForm depth bits: nil.	copy setResourceBits: aForm bits.	"Get the locator for the form (if we have any)"	loc := locatorMap at: aForm ifAbsent:[nil].	"Store the resource file"	nameAndSize := self writeResourceForm: copy locator: loc.	fName := nameAndSize first.	fullSize := nameAndSize second.	ProgressNotification signal: '2:resourceFound' extra: stub.	stub hibernate.	"See if we need to assign a new locator"	(loc notNil and:[loc hasRemoteContents not]) ifTrue:[		"The locator describes some local resource. 		If we're preparing to upload the entire project to a		remote server, make it a remote URL instead.""		(baseUrl isEmpty not and:[baseUrl asUrl hasRemoteContents])			ifTrue:[loc urlString: baseUrl, fName]."		baseUrl isEmpty not			ifTrue:[loc urlString: self resourceDirectory , fName]].	loc ifNil:[		loc := ResourceLocator new urlString: self resourceDirectory , fName.		locatorMap at: aForm put: loc].	loc localFileName: (localDirectory fullNameFor: fName).	loc resourceFileSize: fullSize.	stub locator: loc.	"Map old against stub form"	aForm setResourceBits: stub.	originalMap at: aForm put: copy.	stubMap at: stub put: aForm.	locatorMap at: aForm put: loc.	"note: *must* force aForm in out pointers if 	in IS or else won't get #comeFullyUpOnReload:"	refStream replace: aForm with: aForm.	^aForm! !!HTTPClient class methodsFor: 'post/get' stamp: 'mir 5/11/2001 12:55'!httpGetDocument: url	| stream content | 	^self shouldUsePluginAPI		ifTrue: [			stream := FileStream requestURLStream: url ifError: [self error: 'Error in get from ' , url printString].			stream ifNil: [^''].			stream position: 0.			content := stream upToEnd.			stream close.			MIMEDocument content: content]		ifFalse: [HTTPSocket httpGetDocument: url]! !!SystemDictionary methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 15:50'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to Smalltalk instead."	dp := DiskProxy global: #Smalltalk selector: #yourself			args: #().	refStrm replace: self with: dp.	^ dp! !!DataStream methodsFor: 'write and read' stamp: 'tk 6/8/1998 21:23'!writeStringOld: aString	"PRIVATE -- Write the contents of a String."	| length |	aString size < 16384 		ifTrue: [			(length := aString size) < 192				ifTrue: [byteStream nextPut: length]				ifFalse: 					[byteStream nextPut: (length // 256 + 192).					byteStream nextPut: (length \\ 256)].			aString do: [:char | byteStream nextPut: char asciiValue]]		ifFalse: [self writeByteArray: aString].	"takes more space"! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 11/19/1999 22:36'!add: aClass toList: startUpOrShutDownList after: predecessor	"Add the name of aClass to the startUp or shutDown list.	Add it after the name of predecessor, or at the end if predecessor is nil."	| name earlierName |	name := aClass name.	(self at: name ifAbsent: [nil]) == aClass ifFalse:		[self error: name , ' cannot be found in Smalltalk dictionary.'].	predecessor == nil		ifTrue: ["No-op if alredy in the list."				(startUpOrShutDownList includes: name) ifFalse:					[startUpOrShutDownList == StartUpList						ifTrue: ["Add to end of startUp list"								startUpOrShutDownList addLast: name]						ifFalse: ["Add to front of shutDown list"								startUpOrShutDownList addFirst: name]]]		ifFalse: ["Add after predecessor, moving it if already there."				earlierName := predecessor name.				(self at: earlierName) == predecessor ifFalse:					[self error: earlierName , ' cannot be found in Smalltalk dictionary.'].				(startUpOrShutDownList includes: earlierName) ifFalse:					[self error: earlierName , ' cannot be found in the list.'].				startUpOrShutDownList remove: name ifAbsent:[].				startUpOrShutDownList add: name after: earlierName]! !!Project methodsFor: 'resources' stamp: 'mir 6/26/2001 17:34'!resourceUrl	"compose my base url for resources on the server"	| firstURL | "	primaryServer := self primaryServerIfNil: [^''].	firstURL := primaryServer altUrl ifNil: [primaryServer url]."	firstURL := self downloadUrl.	firstURL isEmpty		ifFalse: [firstURL last == $/ ifFalse: [firstURL := firstURL, '/']].	^ firstURL, self resourceDirectoryName , '/'! !!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'yo 7/5/2004 20:21'!fileOutCategory: categoryName	| internalStream |	internalStream := WriteStream on: (String new: 1000).	self fileOutMethods: (self organization listAtCategoryNamed: categoryName)			on: internalStream.	FileStream writeSourceCodeFrom: internalStream baseName: (self name, '-', categoryName) isSt: true useHtml: false.! !!Utilities class methodsFor: 'identification' stamp: 'yo 12/3/2004 17:04'!methodsWithInitials: targetInitials	"Based on a do-it contributed to the Squeak mailing list by GÃ¶ran Hultgen: Browse methods whose initials (in the time-stamp, as logged to disk) match the given initials. Print out the complete time-stamp table to the Transcript. Answer a list of (initials -> count) associations.CAUTION: It may take several minutes for this to complete."	"Time millisecondsToRun: [Utilities methodsWithInitials: 'bf']"	| initials timeStamp  allSubmitters |	initials := ''.	timeStamp := ''.	allSubmitters := Bag new.	self systemNavigation		browseAllSelect:			[:cm |				timeStamp := Utilities timeStampForMethod: cm.				initials := timeStamp isEmpty					ifTrue:						['']					ifFalse:						[timeStamp substrings first].				initials := initials isEmpty					ifTrue:						['<no time stamp>']					ifFalse:						[initials first isDigit							ifTrue:								['<date>']							ifFalse:								[initials]].				allSubmitters add: initials.				(initials = targetInitials)]		name: ('Methods with initials ', targetInitials)		autoSelect: nil.	allSubmitters sortedCounts do: [:elem | Transcript cr; show: elem asString].	^ allSubmitters! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 22:00'!invokePhase1	| selector changeRecord type elements |	revertable ifFalse: [^ self].	inForce ifTrue: [self error: 'Can invoke only when not in force.'].	"Do the first part of the invoke operation -- no particular hurry."	"Save the outer method dictionary for quick revert of method changes."	priorMD := self realClass methodDict.	"Prepare a methodDictionary for switcheroo."	thisMD := self realClass methodDict copy.	methodChanges associationsDo:		[:assn | selector := assn key. changeRecord := assn value.		type := changeRecord changeType.		type = #remove ifTrue: [thisMD removeKey: selector].		type = #add ifTrue: [thisMD at: selector put: changeRecord currentMethod].		type = #change ifTrue: [thisMD at: selector put: changeRecord currentMethod].		].	"Replace the original organization (and comment)."	priorOrganization := self realClass organization.	thisOrganization elementArray copy do:		[:sel | (thisMD includesKey: sel) ifFalse: [thisOrganization removeElement: sel]].	#(DoIt DoItIn:) do: [:sel | thisMD removeKey: sel ifAbsent: []].	thisOrganization elementArray size = thisMD size ifFalse:		[elements := thisOrganization elementArray asSet.		thisMD keysDo:			[:sel | (elements includes: sel) ifFalse:				[thisOrganization classify: sel					under: (priorOrganization categoryOfElement: sel)]]].	self realClass organization: thisOrganization.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!baudRate: anInteger	"Set the baud rate for this serial port."	baudRate := anInteger.! !!AbstractLauncher methodsFor: 'private' stamp: 'jm 8/20/1999 15:33'!commandLine: aString	"Start up this launcher from within Squeak as if it Squeak been launched the given command line."	| dict tokens cmd arg |	dict := Dictionary new.	tokens := ReadStream on: (aString findTokens: ' ').	[cmd := tokens next.	 arg := tokens next.	 ((cmd ~~ nil) and: [arg ~~ nil])]		whileTrue: [dict at: cmd put: arg].	self parameters: dict.	self startUp.! !!Project methodsFor: 'isolation layers' stamp: 'RAA 6/21/2000 23:01'!isIsolated	^ isolatedHead ifNil: [isolatedHead := false]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ar 4/12/2005 17:37'!fixCapitalizationOfSymbols	"MultiString>>capitalized was not implemented correctly. 	Fix eventual accessors and mutators here."	| sym ms |	1 to: outPointers size do:[:i|		sym := outPointers at: i.		(sym class == WideSymbol and:[sym size > 3]) ifTrue:[			((sym beginsWith: 'get')				and:[(sym at: 4) asInteger < 256				and:[(sym at: 4) isLowercase]]) ifTrue:[					ms := sym asString.					ms at: 4 put: (ms at: 4) asUppercase.					ms := ms asSymbol.					sym becomeForward: ms.			].			((sym beginsWith: 'set')				and:[(sym at: 4) asInteger < 256				and:[(sym at: 4) isLowercase				and:[sym last = $:				and:[(sym occurrencesOf: $:) = 1]]]]) ifTrue:[					ms := sym asString.					ms at: 4 put: (ms at: 4) asUppercase.					ms := ms asSymbol.					sym becomeForward: ms.				].			outPointers at: i put: sym.		].	].! !!PreferenceViewRegistry methodsFor: 'view order' stamp: 'hpt 9/26/2004 16:22'!viewOrder: aNumber	viewOrder := aNumber! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 23:28'!preferenceValue: aValue	"set the value as indicated, and invoke the change selector if appropriate"	| oldValue |	oldValue := value.	value := aValue.	oldValue ~~ value ifTrue:		[self notifyInformeeOfChange]! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 10:05'!getPortList	"Return a string that describes this platform's MIDI ports."	"MidiPrimTester new getPortList"	| s portCount dir directionString |	s := WriteStream on: String new.	s cr; nextPutAll: 'MIDI Ports:'; cr.	portCount := self primMIDIGetPortCount.	0 to: portCount - 1 do: [:i |		s tab.		s print: i; nextPutAll: ': '. 		s nextPutAll: (self primMIDIGetPortName: i).		dir := self primMIDIGetPortDirectionality: i.		directionString := dir printString.  "default"		dir = 1 ifTrue: [directionString := '(in)'].		dir = 2 ifTrue: [directionString := '(out)'].		dir = 3 ifTrue: [directionString := '(in/out)'].		s space; nextPutAll: directionString; cr].	^ s contents! !!ClassChangeRecord methodsFor: 'initialization' stamp: 'di 9/21/2000 12:34'!zapHistory	"Drop all recorded information not needed to simply keep track of what has been changed.	Saves a lot of space."	methodChanges do: [:r | r noteNewMethod: nil].  "Drop all refes to old methods"	thisOrganization := nil.	priorOrganization := nil.	thisComment := nil.	priorComment := nil.	thisMD := nil.	priorMD := nil.! !!Project class methodsFor: 'utilities' stamp: 'jla 5/28/2001 21:48'!allProjectsOrdered	"Answer a list of all projects in hierarchical order, depth first"		| allProjects  |	allProjects := OrderedCollection new.	Project topProject withChildrenDo:		[:p | allProjects add: p].	^ allProjects"Project allProjectsOrdered"! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:59'!safelyUnregisterExternalObject: anObject	"Unregister the given object in the external objects array. Do nothing if it isn't registered.	JMM change to return if we clear the element, since it should only appear once in the array"	| objects |	anObject ifNil: [^ self].	objects := Smalltalk specialObjectsArray at: 39.	1 to: objects size do: [:i |		(objects at: i) == anObject ifTrue: 		[objects at: i put: nil.		^self]].! !!ProjectLauncher methodsFor: 'eToy login' stamp: 'ar 8/24/2001 15:17'!proceedWithLogin	eToyAuthentificationServer := nil.	World submorphsDo:[:m| m show].	WorldState addDeferredUIMessage: [self startUpAfterLogin].! !!RealEstateAgent class methodsFor: 'class initialization' stamp: 'tk 11/26/1998 09:34'!initialize	"Initialize the class variables in the receiver.  5/22/96 sw"	"RealEstateAgent initialize"	StaggerOffset := 6 @ 20.	ReverseStaggerOffset := -6 @ 20.	StaggerOrigin := 200 @ 30.	StandardSize := 600@400.! !!Project methodsFor: 'project parameters' stamp: 'sw 4/12/2001 23:36'!projectPreferenceAt: aSymbol	"Answer the project preference stored at the given symbol.  If there is none in the local preference dictionary, it must be because it was only latterly declared to be a project-local preference, so obtain its initial value instead from the last-known global or default setting"	| aValue |	^ self projectPreferenceAt: aSymbol ifAbsent: 		[aValue := Preferences valueOfFlag: aSymbol.		self projectPreferenceFlagDictionary at: aSymbol put: aValue.		^ aValue]! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 20:06'!expandedBlock: aByteArray	"Convert the given 64 byte buffer into 80 32-bit registers and answer the result." 	| out src v |	out := Array new: 80.	src := 1.	1 to: 16 do: [:i |		out at: i put: (ThirtyTwoBitRegister new loadFrom: aByteArray at: src).		src := src + 4].	17 to: 80 do: [:i |		v := (out at: i - 3) copy.		v	bitXor: (out at: i - 8);			bitXor: (out at: i - 14);			bitXor: (out at: i - 16);			leftRotateBy: 1.		out at: i put: v].	^ out! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'yo 7/5/2004 20:22'!fileOut  "SystemOrganization fileOut"	| internalStream |	internalStream := WriteStream on: (String new: 30000).	internalStream nextPutAll: 'SystemOrganization changeFromCategorySpecs: #('; cr;		print: SystemOrganization;  "ends with a cr"		nextPutAll: ')!!'; cr.	FileStream writeSourceCodeFrom: internalStream baseName: (FileDirectory default nextNameFor: 'SystemOrganization' extension: 'st') isSt: true useHtml: false! !!SystemNavigation class methodsFor: 'accessing' stamp: 'dvf 8/23/2003 12:25'!default	Default isNil ifTrue: [Default := self new].	^Default! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/15/2003 20:32'!browseObsoleteReferences  	"self new browseObsoleteReferences"	| references |	references := OrderedCollection new.	(LookupKey allSubInstances select:		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:		['AnOb*' match: x value class name]]) 		do: [:x | references addAll: (self allCallsOn: x)].	self  		browseMessageList: references 		name: 'References to Obsolete Classes'! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!revokePhase2	revertable ifFalse: [^ self].	"Replace the original organization (and comment)."	thisOrganization := self realClass organization.	self realClass organization: priorOrganization.	inForce := false.! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 15:14'!scanFile: file from: startPosition to: stopPosition	| itemPosition item prevChar changeList |	changeList := OrderedCollection new.	file position: startPosition.'Scanning ', file localName, '...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar |	[file position < stopPosition] whileTrue:[		bar value: file position.		[file atEnd not and: [file peek isSeparator]]			whileTrue: [prevChar := file next].		(file peekFor: $!!) ifTrue:[			(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [changeList addAll: (self scanCategory: file)].		] ifFalse:[			itemPosition := file position.			item := file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:[				changeList add: (ChangeRecord new file: file position: itemPosition type: #doIt).			].		].	]].	^changeList! !!MidiPrimTester class methodsFor: 'class initialization' stamp: 'yo 12/3/2004 17:05'!initialize	"Initialize the MIDI parameter constants."	"MidiPrimTester initialize"	Installed := 1.		"Read-only. Return 1 if a MIDI driver is installed, 0 if not.		 On OMS-based MIDI drivers, this returns 1 only if the OMS		 system is properly installed and configured."	Version := 2.		"Read-only. Return the integer version number of this MIDI driver.		 The version numbering sequence is relative to a particular driver.		 That is, version 3 of the Macintosh MIDI driver is not necessarily		 related to version 3 of the Win95 MIDI driver."	HasBuffer := 3.		"Read-only. Return 1 if this MIDI driver has a time-stamped output		 buffer, 0 otherwise. Such a buffer allows the client to schedule		 MIDI output packets to be sent later. This can allow more precise		 timing, since the driver uses timer interrupts to send the data		 at the right time even if the processor is in the midst of a		 long-running Squeak primitive or is running some other application		 or system task."	HasDurs := 4.		"Read-only. Return 1 if this MIDI driver supports an extended		 primitive for note-playing that includes the note duration and		 schedules both the note-on and the note-off messages in the		 driver. Otherwise, return 0."	CanSetClock := 5.		"Read-only. Return 1 if this MIDI driver's clock can be set		 via an extended primitive, 0 if not."	CanUseSemaphore := 6.		"Read-only. Return 1 if this MIDI driver can signal a semaphore		 when MIDI input arrives. Otherwise, return 0. If this driver		 supports controller caching and it is enabled, then incoming		 controller messages will not signal the semaphore."	EchoOn := 7.		"Read-write. If this flag is set to a non-zero value, and if		 the driver supports echoing, then incoming MIDI events will		 be echoed immediately. If this driver does not support echoing,		 then queries of this parameter will always return 0 and		 attempts to change its value will do nothing."	UseControllerCache := 8.		"Read-write. If this flag is set to a non-zero value, and if		 the driver supports a controller cache, then the driver will		 maintain a cache of the latest value seen for each MIDI controller,		 and control update messages will be filtered out of the incoming		 MIDI stream. An extended MIDI primitive allows the client to		 poll the driver for the current value of each controller. If		 this driver does not support a controller cache, then queries		 of this parameter will always return 0 and attempts to change		 its value will do nothing."	EventsAvailable := 9.		"Read-only. Return the number of MIDI packets in the input queue."	FlushDriver := 10.		"Write-only. Setting this parameter to any value forces the driver		 to flush its I/0 buffer, discarding all unprocessed data. Reading		 this parameter returns 0. Setting this parameter will do nothing		 if the driver does not support buffer flushing."	ClockTicksPerSec := 11.		"Read-only. Return the MIDI clock rate in ticks per second."	HasInputClock := 12.		"Read-only. Return 1 if this MIDI driver timestamps incoming		 MIDI data with the current value of the MIDI clock, 0 otherwise.		 If the driver does not support such timestamping, then the		 client must read input data frequently and provide its own		 timestamping."! !!Utilities class methodsFor: 'recent method submissions' stamp: 'RAA 5/28/2001 10:53'!noteMethodSubmission: selectorName forClass: class	| submission |	self flag: #mref.	"fix for faster references to methods"	self recentMethodSubmissions.	"ensure it is valid"	class wantsChangeSetLogging ifFalse: [^ self].	self purgeRecentSubmissionsOfMissingMethods.	submission := class name asString, ' ', selectorName.	RecentSubmissions removeAllSuchThat: [ :each |		each asStringOrText = submission	].	RecentSubmissions size >= self numberOfRecentSubmissionsToStore ifTrue: [		RecentSubmissions removeFirst	].	RecentSubmissions addLast: (		MethodReference new			setClass: class 			methodSymbol: selectorName 			stringVersion: submission	) ! !!ChangeSet methodsFor: 'class changes' stamp: 'dvf 9/27/2005 19:05'!noteClassStructure: aClass	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."	| clsName |	aClass isBehavior ifFalse: [^ self].		structures ifNil: [structures := Dictionary new.				superclasses := Dictionary new].	clsName := (aClass name asLowercase beginsWith: 'anobsolete') 		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]		ifFalse: [aClass name].	(structures includesKey: clsName) ifFalse: [		structures at: clsName put: 			((Array with: aClass classVersion), (aClass allInstVarNames)).		superclasses at: clsName put: aClass superclass name].	"up the superclass chain"	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].! !!SmartRefStream class methodsFor: 'i/o' stamp: 'RAA 7/9/2000 05:48'!objectFromStreamedRepresentation: someBytes	| file |	file := RWBinaryOrTextStream with: someBytes.	file reset.	^file fileInObjectAndCode! !!Project class methodsFor: 'squeaklet on server' stamp: 'dao 10/1/2004 13:25'!openBlankProjectNamed: projName	| proj projViewer |	proj := Project newMorphicOn: nil.	proj changeSet name: projName.	proj world addMorph: (		TextMorph new 			beAllFont: ((TextStyle default fontOfSize: 26) emphasized: 1);			color: Color red;			contents: 'Welcome to a new project - ',projName	).	proj setParent: self current.	projViewer := (CurrentProject findProjectView: projName) ifNil: [^proj].	(projViewer owner isSystemWindow) ifTrue: [			projViewer owner model: proj].	^ projViewer project: proj! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 3/29/2003 13:01'!registeredClasses	^ registeredClasses ifNil: [registeredClasses := OrderedCollection new]! !!SecurityManager methodsFor: 'fileIn/out' stamp: 'ar 3/5/2001 01:55'!loadSecurityKeys	"SecurityManager default loadSecurityKeys"	"Load the keys file for the current user"	| fd loc file keys |	self isInRestrictedMode ifTrue:[^self]. "no point in even trying"	loc := self secureUserDirectory. "where to get it from"	loc last = FileDirectory pathNameDelimiter ifFalse:[		loc := loc copyWith: FileDirectory pathNameDelimiter.	].	fd := FileDirectory on: loc.	file := [fd readOnlyFileNamed: keysFileName] 			on: FileDoesNotExistException do:[:ex| nil].	file ifNil:[^self]. "no keys file"	keys := Object readFrom: file.	privateKeyPair := keys first.	trustedKeys := keys last.	file close.! !!SARInstaller methodsFor: 'client services' stamp: 'tak 1/24/2005 19:12'!installMember: memberOrName	| memberName extension isGraphic stream member |	member := self memberNamed: memberOrName.	member ifNil: [ ^false ].	memberName := member fileName.	extension := (FileDirectory extensionFor: memberName) asLowercase.	Smalltalk at: #CRDictionary ifPresent: [ :crDictionary |		(extension = crDictionary fileNameSuffix) ifTrue: [  self fileInGenieDictionaryNamed: memberName. ^true ] ].	extension caseOf: {		[ Project projectExtension ] -> [ self fileInProjectNamed: memberName createView: true ].		[ FileStream st ] -> [ self fileInPackageNamed: memberName ].		[ FileStream cs ] -> [  self fileInMemberNamed: memberName  ]."		[ FileStream multiSt ] -> [  self fileInMemberNamedAsUTF8: memberName  ].		[ FileStream multiCs ] -> [  self fileInMemberNamedAsUTF8: memberName  ]."		[ 'mc' ] -> [ self fileInMonticelloPackageNamed: memberName ].		[ 'mcv' ] -> [ self fileInMonticelloVersionNamed: memberName ].		[ 'mcz' ] -> [ self fileInMonticelloZipVersionNamed: memberName ].		[ 'morph' ] -> [ self fileInMorphsNamed: member addToWorld: true ].		[ 'ttf' ] -> [ self fileInTrueTypeFontNamed: memberName ].		[ 'translation' ] -> [  self fileInMemberNamed: memberName  ].	} otherwise: [		('t*xt' match: extension) ifTrue: [ self openTextFile: memberName ]			ifFalse: [ stream := member contentStream.		isGraphic := ImageReadWriter understandsImageFormat: stream.		stream reset.		isGraphic			ifTrue: [ self openGraphicsFile: member ]			ifFalse: [ "now what?" ^false ]]	].	^true! !!SystemNavigation methodsFor: 'query' stamp: 'md 8/27/2005 17:17'!allCallsOn: aSymbol from: aClass	"Answer a SortedCollection of all the methods that call on aSymbol."	| aSortedCollection special byte |	aSortedCollection := SortedCollection new.	special := aClass environment hasSpecialSelector: aSymbol ifTrueSetByte: [:b | byte := b ].	aClass withAllSubclassesDo: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte) do: [:sel |			sel isDoIt ifFalse: [				aSortedCollection add: (					MethodReference new						setStandardClass: class 						methodSymbol: sel				)			]		]	].	^aSortedCollection! !!Project class methodsFor: 'utilities' stamp: 'mir 11/26/2004 16:15'!removeAll: projects	"Project removeAll: (Project allSubInstances copyWithout: Project current)"	AllProjects := nil.	Smalltalk garbageCollect.	ProjectHistory currentHistory initialize.	projects do: [:project |		Project deletingProject: project.		StandardScriptingSystem removePlayersIn: project].	Smalltalk garbageCollect.	Smalltalk garbageCollect.! !!CodeLoader methodsFor: 'loading' stamp: 'ar 12/14/1999 14:40'!loadSourceFiles: anArray	"Load all the source files in the given array."	| loader request |	loader := HTTPLoader default.	sourceFiles := anArray collect:[:name|		request := self createRequestFor: name in: loader.		request].! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 10/13/2000 13:27'!compressFileNamed: aFileName in: aDirectory	"Compress the currently selected file"	| zipped buffer unzipped zipFileName |	unzipped := aDirectory readOnlyFileNamed: (aDirectory fullNameFor: aFileName).	unzipped binary.	zipFileName := aFileName copyUpToLast: $. .	zipped := aDirectory newFileNamed: (zipFileName, FileDirectory dot, ImageSegment compressedFileExtension).	zipped binary.	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	'Compressing ', zipFileName displayProgressAt: Sensor cursorPoint		from: 0 to: unzipped size		during:[:bar|			[unzipped atEnd] whileFalse:[				bar value: unzipped position.				zipped nextPutAll: (unzipped nextInto: buffer)].			zipped close.			unzipped close].! !!MczInstaller methodsFor: 'accessing' stamp: 'avi 2/17/2004 02:55'!stream: aStream	stream := aStream! !!Preference methodsFor: 'user interface' stamp: 'hpt 9/26/2004 16:58'!viewForPanel: aPreferencePanel	| viewClass |	viewClass := self viewClassForPanel: aPreferencePanel.	^viewClass ifNotNil: [viewClass preference: self]! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/29/2000 14:50'!invokePhase2	revertable ifFalse: [^ self].	"Do the second part of the revert operation.  This must be very simple."	"Replace original method dicts if there are method changes."	self realClass methodDictionary: thisMD.  "zap.  Must flush Cache in outer loop."	inForce := true.! !!DataStream methodsFor: 'write and read' stamp: 'tk 2/3/2000 21:11'!readWordLike	| refPosn aSymbol newClass anObject |	"Can be used by any class that is bits and not bytes (WordArray, Bitmap, SoundBuffer, etc)."	refPosn := self getCurrentReference.	aSymbol := self next.	newClass := Smalltalk at: aSymbol asSymbol.	anObject := newClass newFromStream: byteStream.	"Size is number of long words."	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'hh 8/3/2000 18:19'!generateKeySet	"Generate and answer a key set for DSA. The result is a pair (<private key><public key>). Each key is an array of four large integers. The private key is (p, q, g, x); the public one is (p, q, g, y). The signer must be sure to record (p, q, g, x), and must keep x secret to prevent someone from forging their signature."	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"	| qAndPandS q p exp g h x y |	qAndPandS := self generateQandP.	Transcript show: 'Computing g...'.	q := qAndPandS first.	p := qAndPandS second.	exp := (p - 1) / q.	h := 2.	[g := h raisedTo: exp modulo: p. g = 1] whileTrue: [h := h + 1].	Transcript show: 'done.'; cr.	Transcript show: 'Computing x and y...'.	x := self nextRandom160.	y := g raisedTo: x modulo: p.	Transcript show: 'done.'; cr.	Transcript show: 'Key generation complete!!'; cr.	^ Array		with: (Array with: p with: q with: g with: x)		with: (Array with: p with: q with: g with: y)! !!MczInstaller methodsFor: 'installation' stamp: 'yo 8/17/2004 10:03'!installMember: member	 | str |	self useNewChangeSetDuring:		[str := member contentStream text.		str setConverterForCode.		str fileInAnnouncing: 'loading ', member fileName]! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:20'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList := (self allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!Project methodsFor: 'accessing' stamp: 'mir 6/7/2001 16:18'!lastDirectory: aDirectoryOrNil	lastDirectory := aDirectoryOrNil! !!Project class methodsFor: 'utilities' stamp: 'mir 11/26/2004 15:22'!removeAllButCurrent	"Project removeAllButCurrent"	AllProjects := nil.	Smalltalk garbageCollect.	self removeAll: (Project allSubInstances copyWithout: Project current).	AllProjects := nil.	Smalltalk garbageCollect.	Smalltalk garbageCollect.	Project rebuildAllProjects.	^AllProjects! !!Project methodsFor: 'file in/out' stamp: 'tak 6/24/2005 11:30'!writeFileNamed: localFileName fromDirectory: localDirectory toServer: primaryServerDirectory	| local resp gifFileName f |	local := localDirectory oldFileNamed: localFileName.	resp := primaryServerDirectory upLoadProject: local named: localFileName resourceUrl: self resourceUrl retry: false.	local close.	resp == true ifFalse: [		"abandon resources that would've been stored with the project"		self resourceManager abandonResourcesThat:			[:loc| loc urlString beginsWith: self resourceUrl].		self error: 'the primary server of this project seems to be down (',							resp printString,')'. 		^ self	].	gifFileName := self name,'.gif'.	localDirectory deleteFileNamed: gifFileName ifAbsent: [].	local := localDirectory fileNamed: gifFileName.	thumbnail ifNil: [		(thumbnail := Form extent: 100@80) fillColor: Color orange	] ifNotNil: [		thumbnail unhibernate.	].	f := thumbnail colorReduced.  "minimize depth"	f depth > 8 ifTrue: [		f := thumbnail asFormOfDepth: 8	].	GIFReadWriter putForm: f onStream: local.	local close.	[local := StandardFileStream readOnlyFileNamed: (localDirectory fullNameFor: gifFileName).	(primaryServerDirectory isKindOf: FileDirectory)		ifTrue: [primaryServerDirectory deleteFileNamed: gifFileName ifAbsent: []].	resp := primaryServerDirectory putFile: local named: gifFileName retry: false.	] on: Error do: [:ex |].	local close.	primaryServerDirectory updateProjectInfoFor: self.	primaryServerDirectory sleep.	"if ftp, close the connection"! !!Project methodsFor: 'SuperSwiki' stamp: 'yo 2/12/2005 19:25'!tellAFriend: emailAddressOrNil	| urlForLoading |"Project current tellAFriend"	(urlForLoading := self urlForLoading) ifNil: [		urlForLoading := self url		"fallback for dtp servers"	].	urlForLoading isEmptyOrNil ifTrue: [		^self inform: 'Since this project has not been saved yet,I cannot tell someone where it is.' translated	].	HTTPClient tellAFriend: emailAddressOrNil url: urlForLoading name: self name! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 8/22/2001 12:29'!composeMailTo: address subject: subject body: body	"HTTPClient composeMailTo: 'michael.rueger@squeakland.org' subject: 'test subject' body: 'message' "	| mailTo |	mailTo := WriteStream on: String new.	mailTo nextPutAll: 'mailto:'.	mailTo		nextPutAll: address;		nextPut: $?.	subject isEmptyOrNil		ifFalse: [mailTo nextPutAll: 'subject='; nextPutAll: subject; nextPut: $&].	body isEmptyOrNil		ifFalse: [mailTo nextPutAll: 'body='; nextPutAll: body].	self httpGet: mailTo contents! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'ar 9/27/2005 22:41'!conversionMethodsFor: classList	| oldStruct newStruct list |	"Each of these needs a conversion method.  Hard part is the comment in it.  Return a MessageSet."	list := OrderedCollection new.	classList do: [:cls |		oldStruct := structures at: cls name ifAbsent: [#()].		newStruct := (Array with: cls classVersion), (cls allInstVarNames).		self writeConversionMethodIn: cls fromInstVars: oldStruct to: newStruct 				renamedFrom: nil.		list add: cls name, ' convertToCurrentVersion:refStream:'.		].	^list.! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 12/5/2001 14:47'!declareAndPossiblyRename: classThatIsARoot	| existing catInstaller |	"The class just arrived in this segment.  How fit it into the Smalltalk dictionary?  If it had an association, that was installed with associationDeclareAt:."	catInstaller := [		classThatIsARoot superclass name == #Player 			ifTrue: [classThatIsARoot category: Object categoryForUniclasses]			ifFalse: [(classThatIsARoot superclass name beginsWith: 'WonderLandActor')				ifTrue: [classThatIsARoot category: 'Balloon3D-UserObjects']				ifFalse: [classThatIsARoot category: 'Morphic-Imported']].	].	classThatIsARoot superclass addSubclass: classThatIsARoot.	(Smalltalk includesKey: classThatIsARoot name) ifFalse: [		"Class entry in Smalltalk not referred to in Segment, install anyway."		catInstaller value.		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing := Smalltalk at: classThatIsARoot name.	existing xxxClass == ImageSegmentRootStub ifTrue: [		"We are that segment!!  Must ask it carefully!!"		catInstaller value.		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	existing == false | (existing == nil) ifTrue: [		"association is in outPointers, just installed"		catInstaller value.		^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].	"Conflict with existing global or copy of the class"	(existing isKindOf: Class) ifTrue: [		classThatIsARoot isSystemDefined not ifTrue: [			"UniClass.  give it a new name"			classThatIsARoot setName: classThatIsARoot baseUniclass chooseUniqueClassName.			catInstaller value.	"must be after new name"			^ Smalltalk at: classThatIsARoot name put: classThatIsARoot].		"Take the incoming one"		self inform: 'Using newly arrived version of ', classThatIsARoot name.		classThatIsARoot superclass removeSubclass: classThatIsARoot.	"just in case"		(Smalltalk at: classThatIsARoot name) becomeForward: classThatIsARoot.		catInstaller value.		^ classThatIsARoot superclass addSubclass: classThatIsARoot].	self error: 'Name already in use by a non-class: ', classThatIsARoot name.! !!TwoLevelDictionary methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:38'!initialize	firstLevel := Dictionary new.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 7/11/2000 18:33'!writeForExportWithSourcesGZ: fName inDirectory: aDirectory	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk.  Append the source code of any classes in roots.  Target system will quickly transfer the sources to its changes file."	"this is the gzipped version which I have temporarily suspended until I can get resolve the problem with forward references tring to reposition the stream - RAA 11 june 2000"	| fileStream temp allClassesInRoots classesToWriteEntirely methodsWithSource |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(fName includes: $.) ifFalse: [		^ self inform: 'Please use ''.pr'' or ''.extSeg'' at the end of the file name'.].	temp := endMarker.	endMarker := nil.	fileStream := GZipSurrogateStream newFileNamed: fName inDirectory: aDirectory.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker := temp.	"append sources"	allClassesInRoots := arrayOfRoots select: [:cls | cls isKindOf: Behavior].	classesToWriteEntirely := allClassesInRoots select: [ :cls | cls theNonMetaClass isSystemDefined].	methodsWithSource := OrderedCollection new.	allClassesInRoots do: [ :cls |		(classesToWriteEntirely includes: cls) ifFalse: [			cls selectorsAndMethodsDo: [ :sel :meth |				meth sourcePointer = 0 ifFalse: [methodsWithSource add: {cls. sel. meth}].			].		].	].	(classesToWriteEntirely isEmpty and: [methodsWithSource isEmpty]) ifTrue: [		fileStream reallyClose.	"since #close is ignored"		^ self	].	"fileStream reopen; setToEnd."	"<--not required with gzipped surrogate stream"	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	methodsWithSource do: [ :each |		fileStream nextPut: $!!.	"try to pacify ImageSegment>>scanFrom:"		fileStream nextChunkPut: 'RenamedClassSourceReader formerClassName: ',				each first name printString,' methodsFor: ',				(each first organization categoryOfElement: each second) asString printString,				' stamp: ',(Utilities timeStampForMethod: each third) printString; cr.		fileStream nextChunkPut: (each third getSourceFor: each second in: each first) asString.		fileStream nextChunkPut: ' '; cr.	].	classesToWriteEntirely do: [:cls | 		cls isMeta ifFalse: [fileStream nextPutAll: 						(cls name, ' category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do: 			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream reallyClose.	"since #close is ignored"! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'sd 9/30/2003 13:53'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount mcMisses mcHits icHits upTime sendCount tms tmSize upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	mcMisses			:= params at: 15.	mcHits				:= params at: 16.	icHits				:= params at: 17.	upTime := Time millisecondClockValue.	sendCount := mcMisses + mcHits + icHits.	tms := TranslatedMethod allSubInstances.	tmSize := tms inject: 0 into: [:sum :tm | sum + (tm size * 4)].	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	sendCount > 0 ifTrue: [		str	nextPutAll: 'sends			';			nextPutAll: sendCount asStringWithCommas; cr.		str	nextPutAll: '	full			';			nextPutAll: mcMisses asStringWithCommas;			nextPutAll: ' ('; print: ((mcMisses / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	m-cache	';			nextPutAll: mcHits asStringWithCommas;			nextPutAll: ' ('; print: ((mcHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	i-cache		';			nextPutAll: icHits asStringWithCommas;			nextPutAll: ' ('; print: ((icHits / sendCount * 100) roundTo: 0.1); nextPutAll: '%)'; cr].	icHits > 0 ifTrue: [		str	nextPutAll: 'methods			';			nextPutAll: tms size asStringWithCommas; nextPutAll: ' translated'; cr.		str	nextPutAll: '	size			';			nextPutAll: tmSize asStringWithCommas; nextPutAll: ' bytes, avg ';			print: ((tmSize / tms size) roundTo: 0.1); nextPutAll: ' bytes/method'; cr.		str	nextPutAll: '	memory		';			print: ((tmSize / youngSpaceEnd * 100) roundTo: 0.1); nextPutAll: '% of used, ';			print: ((tmSize / memoryEnd * 100) roundTo: 0.1); nextPutAll: '% of available'; cr].	^ str contents! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:50'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."self == SystemOrganization ifTrue: [	dp := DiskProxy global: #SystemOrganization selector: #yourself args: #().	refStrm replace: self with: dp.	^ dp].^ self! !!Imports class methodsFor: 'instance creation' stamp: 'nk 7/12/2003 10:36'!default: anImports	"Set my default instance. Returns the old value if any."	| old |	old := default.	default := anImports.	^old! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/23/2000 12:14'!wither	"The receiver is to be clobbered.  Clear it out.  2/7/96 sw"	self clear.	name := nil! !!Project class methodsFor: 'utilities' stamp: 'mir 6/21/2001 15:44'!versionForFileName: version	"Project versionForFileName: 7"	| v |	^String streamContents:[:s|		v := version printString.		v size < 3 ifTrue:[v := '0', v].		v size < 3 ifTrue:[v := '0', v].		s nextPutAll: v.	]! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample1	"This is the first example from the specification document (FIPS PUB 180-1)"	hash := SecureHashAlgorithm new hashMessage: 'abc'.	self assert: (hash = 16rA9993E364706816ABA3E25717850C26C9CD0D89D).		! !!MessageTally methodsFor: 'reporting' stamp: 'ar 7/18/2001 22:12'!reportGCStatsOn: str	| oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime rootOverflows |	upTime := time.	oldSpaceEnd			:= gcStats at: 1.	youngSpaceEnd		:= gcStats at: 2.	memoryEnd			:= gcStats at: 3.	fullGCs				:= gcStats at: 7.	fullGCTime			:= gcStats at: 8.	incrGCs				:= gcStats at: 9.	incrGCTime			:= gcStats at: 10.	tenureCount			:= gcStats at: 11.	rootOverflows		:= gcStats at: 22.	str cr.	str	nextPutAll: '**Memory**'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommasSigned; nextPutAll: ' bytes'; cr.	str cr.	str	nextPutAll: '**GCs**'; cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	incrGCs = 0 ifFalse:		[str nextPutAll:', avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.	str	nextPutAll: '	root table	';		nextPutAll: rootOverflows asStringWithCommas; nextPutAll:' overflows'.	str cr.! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 23:28'!rawValue: aValue	"set the value as indicated, with no side effects"	value := aValue! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/23/2003 22:31'!allImplementorsOf: aSelector 	"Answer a SortedCollection of all the methods that implement the message 	aSelector."	| aCollection |	aCollection := SortedCollection new.	Cursor wait		showWhile: [self				allBehaviorsDo: [:class | (class includesSelector: aSelector)						ifTrue: [aCollection								add: (MethodReference new setStandardClass: class methodSymbol: aSelector)]]].	^ aCollection! !!CachingCodeLoader methodsFor: 'private' stamp: 'mir 12/22/1999 14:11'!createRequestFor: name in: aLoader	| request |	request := super createRequestFor: name in: aLoader.	request cachedName: cacheDir, name.	^request! !!Project methodsFor: 'language' stamp: 'nk 9/3/2004 13:00'!setFlaps	| flapTabs flapIDs sharedFlapTabs navigationMorph |	flapTabs := ActiveWorld flapTabs.	flapIDs := flapTabs collect: [:tab | tab knownName].	flapTabs		do: [:tab | (tab isMemberOf: ViewerFlapTab)				ifFalse: [tab isGlobalFlap						ifTrue: [Flaps removeFlapTab: tab keepInList: false.							tab currentWorld reformulateUpdatingMenus]						ifFalse: [| referent | 							referent := tab referent.							referent isInWorld								ifTrue: [referent delete].							tab delete]]].	sharedFlapTabs := Flaps classPool at: #SharedFlapTabs.	flapIDs		do: [:id | 			id = 'Navigator' translated				ifTrue: [sharedFlapTabs add: Flaps newNavigatorFlap].			id = 'Widgets' translated				ifTrue: [sharedFlapTabs add: Flaps newWidgetsFlap].			id = 'Tools' translated				ifTrue: [sharedFlapTabs add: Flaps newToolsFlap].			id = 'Squeak' translated				ifTrue: [sharedFlapTabs add: Flaps newSqueakFlap].			id = 'Supplies' translated				ifTrue: [sharedFlapTabs add: Flaps newSuppliesFlap].			id = 'Stack Tools' translated				ifTrue: [sharedFlapTabs add: Flaps newStackToolsFlap].			id = 'Painting' translated				ifTrue: [sharedFlapTabs add: Flaps newPaintingFlap].			id = 'Objects' translated				ifTrue: [sharedFlapTabs add: Flaps newObjectsFlap ]].	2 timesRepeat: [flapIDs do: [:id | Flaps enableDisableGlobalFlapWithID: id]].	ActiveWorld flapTabs		do: [:flapTab | flapTab isCurrentlyTextual				ifTrue: [flapTab changeTabText: flapTab knownName]].	Flaps positionNavigatorAndOtherFlapsAccordingToPreference.	navigationMorph := World findDeeplyA: ProjectNavigationMorph preferredNavigator.	navigationMorph isNil		ifTrue: [^ self].	navigationMorph allMorphs		do: [:morph | morph class == SimpleButtonDelayedMenuMorph				ifTrue: [(morph findA: ImageMorph) isNil						ifTrue: [| label | 							label := morph label.							label isNil								ifFalse: [| name | 									name := morph knownName.									name isNil										ifTrue: [morph name: label.											name := label].									morph label: name translated]]]]! !!HTTPLoader methodsFor: 'requests' stamp: 'mir 4/16/2001 17:48'!retrieveContentsFor: url	| request |	request := self class httpRequestClass for: url in: self.	self addRequest: request.	^request contents! !!Project class methodsFor: 'squeaklet on server' stamp: 'ar 4/10/2005 18:51'!sweep: aServerDirectory	| repository list parts ind entry projectName versions |	"On the server, move all but the three most recent versions of each Squeaklet to a folder called 'older'"	"Project sweep: ((ServerDirectory serverNamed: 'DaniOnJumbo') clone 				directory: '/vol0/people/dani/Squeaklets/2.7')"	"Ensure the 'older' directory"	(aServerDirectory includesKey: 'older') 		ifFalse: [aServerDirectory createDirectory: 'older'].	repository := aServerDirectory clone directory: aServerDirectory directory, '/older'.	"Collect each name, and decide on versions"	list := aServerDirectory fileNames.	list isString ifTrue: [^ self inform: 'server is unavailable'].	list := list asSortedCollection asOrderedCollection.	parts := list collect: [:en | Project parseProjectFileName: en].	parts := parts select: [:en | en third = 'pr'].	ind := 1.	[entry := list at: ind.		projectName := entry first asLowercase.		versions := OrderedCollection new.  versions add: entry.		[(ind := ind + 1) > list size 			ifFalse: [(parts at: ind) first asLowercase = projectName 				ifTrue: [versions add: (parts at: ind).  true]				ifFalse: [false]]			ifTrue: [false]] whileTrue.		aServerDirectory moveYoungest: 3 in: versions to: repository.		ind > list size] whileFalse.! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'ar 5/23/2001 16:16'!storeDataOn: aDataStream	| oldMethod |	oldMethod := currentMethod.	currentMethod := nil.	super storeDataOn: aDataStream.	currentMethod := oldMethod.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'di 3/28/1999 13:47'!extractThenInstall	"For testing only"	| newRoots |	state = #activeCopy ifFalse: [self errorWrongState].	arrayOfRoots elementsForwardIdentityTo:		(arrayOfRoots collect: [:r | r rootStubInImageSegment: self]).	state := #active.	newRoots := self loadSegmentFrom: segment outPointers: outPointers.	state := #inactive.	arrayOfRoots elementsForwardIdentityTo: newRoots.! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 8/21/2001 18:31'!lookupCachedResource: urlString in: candidates ifPresentDo: streamBlock	"See if we have cached the resource described by the given url and if so, evaluate streamBlock with the cached resource."	| sortedCandidates dir file |	(candidates isNil or:[candidates size = 0])		ifTrue:[^false].	"First, try non-zip members (faster since no decompression is involved)"	sortedCandidates := (candidates reject:[:each| each beginsWith: 'zip://']),					(candidates select:[:each| each beginsWith: 'zip://']).	dir := Project squeakletDirectory.	sortedCandidates do:[:fileName|		file := self loadResource: urlString fromCacheFileNamed: fileName in: dir.		file ifNotNil:[			[streamBlock value: file] ensure:[file close].			^true]].	^false! !!SmalltalkImage methodsFor: 'preferences' stamp: 'laza 12/6/2004 13:55'!setPlatformPreferences	"Set some platform specific preferences on system startup"	| platform specs |	Preferences automaticPlatformSettings ifFalse:[^self].	platform := self platformName.	specs := 	#(						(soundStopWhenDone false)					(soundQuickStart false)			).	platform = 'Win32' ifTrue:[		specs := #(						(soundStopWhenDone true)					(soundQuickStart false)				)].	platform = 'Mac OS' ifTrue:[		specs := #(						(soundStopWhenDone false)					(soundQuickStart true)				)].	specs do:[:tuple|		Preferences setPreference: tuple first toValue: (tuple last == true).	].! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 11:41'!hashStream: aPositionableStream	"Hash the contents of the given stream from the current position to the end using the Secure Hash Algorithm. The SHA algorithm is defined in FIPS PUB 180-1. It is also described on p. 442 of 'Applied Cryptography: Protocols, Algorithms, and Source Code in C' by Bruce Scheier, Wiley, 1996."	"SecureHashAlgorithm new hashStream: (ReadStream on: 'foo')"	| startPosition buf bitLength |	self initializeTotals.	aPositionableStream atEnd ifTrue: [self error: 'empty stream'].	startPosition := aPositionableStream position.	[aPositionableStream atEnd] whileFalse: [		buf := aPositionableStream next: 64.		(aPositionableStream atEnd not and: [buf size = 64])			ifTrue: [self processBuffer: buf]			ifFalse: [				bitLength := (aPositionableStream position - startPosition) * 8.				self processFinalBuffer: buf bitLength: bitLength]].	^ self finalHash! !!SystemDictionary methodsFor: 'shrinking' stamp: 'dao 10/1/2004 13:51'!writeImageSegmentsFrom: segmentDictionary withKernel: kernel	"segmentDictionary is associates segmentName -> {classNames. methodNames},	and kernel is another set of classNames determined to be essential.	Add a partition, 'Secondary' with everything not in partitions and not in the kernel.	Then write segments based on this partitioning of classes."	| metas secondary dups segDict overlaps classes n symbolHolder |	"First, put all classes that are in no other partition, and not in kernel into a new partition called 'Secondary'.  Also remove any classes in kernel from putative partitions."	secondary := Smalltalk classNames asIdentitySet.	segmentDictionary keysDo:		[:segName |		secondary removeAllFoundIn: (segmentDictionary at: segName) first.		(segmentDictionary at: segName) first removeAllFoundIn: kernel].	secondary removeAllFoundIn: kernel.	secondary removeAllFoundIn: #(PseudoContext TranslatedMethod Utilities Preferences OutOfScopeNotification FakeClassPool  BlockCannotReturn FormSetFont ExternalSemaphoreTable NetNameResolver ScreenController InterpreterPlugin Command WeakSet).	FileDirectory allSubclassesDo: [:c | secondary remove: c name ifAbsent: []].	segmentDictionary at: 'Secondary' put: {secondary. {}}.	"Now build segDict giving className -> segName, and report any duplicates."	dups := Dictionary new.	segDict := IdentityDictionary new: 3000.	segmentDictionary keysDo:		[:segName | (segmentDictionary at: segName) first do:			[:className |			(segDict includesKey: className) ifTrue:				[(dups includesKey: className) ifFalse: [dups at: className put: Array new].				dups at: className put: (dups at: className) , {segName}].			segDict at: className put: segName]].	dups size > 0 ifTrue: [dups inspect.  ^ self error: 'Duplicate entries'].	"Then for every class in every partition, make sure that neither it	nor any of its superclasses are in any other partition.  If they are,	enter them in a dictionary of overlaps.	If the dictionary is not empty, then stop and report it."	overlaps := Dictionary new.	segmentDictionary keysDo:		[:segName |  		classes := (segmentDictionary at: segName) first asArray collect: [:k | Smalltalk at: k].		classes do:			[:c | (c isKindOf: Class) ifTrue:				[c withAllSuperclasses do:					[:sc | n := segDict at: sc name ifAbsent: [segName].					n ~= segName ifTrue:						[n = 'Secondary'							ifTrue: [(segmentDictionary at: 'Secondary') first										remove: sc name ifAbsent: []]							ifFalse: [overlaps at: c name put: 										(c withAllSuperclasses collect: [:cc | segDict associationAt: cc name ifAbsent: [cc name -> 'Kernel']])]]]]]].	overlaps size > 0 ifTrue: [overlaps inspect.  ^ self error: 'Superclasses in separate segments'].	"If there are no overlaps, then proceed to write the partitioned classes."	symbolHolder := Symbol allInstances.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	segmentDictionary keysDo:		[:segName |  Utilities informUser: segName during:			[classes := (segmentDictionary at: segName) first asArray collect: [:k | Smalltalk at: k].			metas := classes select: [:c | c isKindOf: Class] thenCollect: [:c | c class].			(ImageSegment new copyFromRoots: classes , metas sizeHint: 0) extract; 					writeToFile: segName]].	symbolHolder.  "Keep compiler for getting uppity."! !!ChangeSet class methodsFor: 'defaults' stamp: 'ar 7/15/2005 21:24'!uniqueNameLike: aString	| try |	(self named: aString) ifNil: [^ aString].	1 to: 999999 do:		[:i | try := aString , i printString.		(self named: try) ifNil: [^ try]]! !!ImageSegment methodsFor: 'read/write segment' stamp: 'md 3/16/2006 22:44'!rootsIncludingPlayers	"Return a new roots array with more objects.  (Caller should store into rootArray.) Player (non-systemDefined) gets its class and metaclass put into the Roots array.  Then ask for the segment again."| extras havePresenter players morphs existing |userRootCnt ifNil: [userRootCnt := arrayOfRoots size].extras := OrderedCollection new.arrayOfRoots do: [:root | 	(root isKindOf: Presenter) ifTrue: [havePresenter := root].	(root isKindOf: PasteUpMorph) ifTrue: [			root isWorldMorph ifTrue: [havePresenter := root presenter]].	(root isKindOf: Project) ifTrue: [havePresenter := root world presenter]].havePresenter ifNotNil: [	havePresenter flushPlayerListCache.		"old and outside guys"	morphs := IdentitySet new: 400.	havePresenter associatedMorph allMorphsAndBookPagesInto: morphs.	players := (morphs select: [:m | m player ~~ nil] 				thenCollect: [:m | m player]) asArray.	players := players select: [:ap | (arrayOfRoots includes: ap class) not		& (ap class isSystemDefined not)].	extras addAll: (players collect: [:each | each class]).	extras addAll: (players collect: [:each | each class class]).	extras addAll: morphs.	"Make then ALL roots!!"	].existing := arrayOfRoots asIdentitySet.extras := extras reject: [ :each | existing includes: each].extras isEmpty ifTrue: [^ nil].	"no change"			havePresenter := players := morphs := nil.		^ arrayOfRoots, extras	"will contain multiples of some, but reduced later"! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 11:56'!hashInteger: aPositiveInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in key generation."	| buffer dstIndex |	self initializeTotals.	"pad integer with zeros"	aPositiveInteger highBit <= 512		ifFalse: [self error: 'integer cannot exceed 512 bits'].	buffer := ByteArray new: 64.	dstIndex := 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'yo 2/24/2005 18:34'!imageName: newName	"Set the the full path name for the current image.  All further snapshots will use this."	| encoded |	encoded := (FilePath pathName: newName isEncoded: false) asVmPathName.	self primImageName: encoded.! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 6/21/2001 22:49'!lookupOriginalResourceCacheEntry: resourceFileName for: resourceUrl	"See if we have cached the resource described by the given url in an earlier version of the same project on the same server. In that case we don't need to upload it again but rather link to it."	| candidates resourceBase resourceMatch matchingUrls |		CachedResources ifNil:[^nil].	"Strip the version number from the resource url"	resourceBase := resourceUrl copyFrom: 1 to: (resourceUrl lastIndexOf: $.) .	"Now collect all urls that have the same resource base"	resourceMatch := resourceBase , '*/' , resourceFileName.	matchingUrls := self resourceCache keys		select: [:entry | (resourceMatch match: entry) and: [(entry beginsWith: resourceUrl) not]].	matchingUrls isEmpty		ifTrue: [^nil].	matchingUrls asSortedCollection do: [:entry | 			candidates := (self resourceCache at: entry).			candidates isEmptyOrNil				ifFalse: [candidates do: [:candidate |					candidate = resourceFileName						ifTrue: [^entry]]]].	^nil! !!DataStream methodsFor: 'write and read' stamp: 'tk 10/4/2000 10:35'!nextPut: anObject	"Write anObject to the receiver stream. Answer anObject."	| typeID selector objectToStore |	typeID := self typeIDFor: anObject.	(self tryToPutReference: anObject typeID: typeID)		ifTrue: [^ anObject].	objectToStore := (self objectIfBlocked: anObject) objectForDataStream: self.	objectToStore == anObject ifFalse: [typeID := self typeIDFor: objectToStore].	byteStream nextPut: typeID.	selector := #(writeNil: writeTrue: writeFalse: writeInteger: 		writeStringOld: writeSymbol: writeByteArray:		writeArray: writeInstance: errorWriteReference: writeBitmap:		writeClass: writeUser: writeFloat: writeRectangle: == "<-16 short inst" 		writeString: writeBitmap: writeBitmap: writeWordLike: 		writeInstance: "CompiledMethod") at: typeID.	self perform: selector with: objectToStore.	^ anObject"NOTE: If anObject is a reference type (one that we write cross-references to) but its externalized form (result of objectForDataStream:) isn't (e.g. CompiledMethod and ViewState), then we should remember its externalized form but not add to 'references'. Putting that object again should just put its external form again. That's more compact and avoids seeks when reading. But we just do the simple thing here, allowing backward-references for non-reference types like nil. So objectAt: has to compensate. Objects that externalize nicely won't contain the likes of ViewStates, so this shouldn't hurt much.	 writeReference: -> errorWriteReference:."! !!SystemNavigation methodsFor: 'query' stamp: 'sd 9/23/2004 22:03'!obsoleteBehaviors	"SystemNavigation default obsoleteBehaviors inspect"	"Find all obsolete behaviors including meta classes"	| obs |	obs := OrderedCollection new.	Smalltalk garbageCollect.	self 		allObjectsDo: [:cl | (cl isBehavior					and: [cl isObsolete])				ifTrue: [obs add: cl]].	^ obs asArray! !!Project methodsFor: 'accessing' stamp: 'nk 8/30/2004 08:00'!findProjectView: projectDescription	| pName dpName proj |	"In this world, find the morph that holds onto the project described by projectDescription.  projectDescription can be a project, or the name of a project.  The project may be represented by a DiskProxy.  The holder morph may be at any depth in the world.	Need to fix this if Projects have subclasses, or if a class other than ProjectViewMorph can officially hold onto a project.  (Buttons, links, etc)	If parent is an MVC world, return the ProjectController."	self flag: #bob.		"read the comment"	pName := (projectDescription isString) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	self isMorphic 		ifTrue: [world allMorphsDo: [:pvm |				pvm class == ProjectViewMorph ifTrue: [					(pvm project class == Project and: 						[pvm project name = pName]) ifTrue: [^ pvm].					pvm project class == DiskProxy ifTrue: [ 						dpName := pvm project constructorArgs first.						dpName := (dpName findTokens: '/') last.						dpName := (Project parseProjectFileName: dpName unescapePercents) first.						dpName = pName ifTrue: [^ pvm]]]]]		ifFalse: [world scheduledControllers do: [:cont |				(cont isKindOf: ProjectController) ifTrue: [					((proj := cont model) class == Project and: 						[proj name = pName]) ifTrue: [^ cont view].					proj class == DiskProxy ifTrue: [ 						dpName := proj constructorArgs first.						dpName := (dpName findTokens: '/') last.						dpName := (Project parseProjectFileName: dpName unescapePercents) first.						dpName = pName ifTrue: [^ cont view]]]]			].	^ nil! !!ProjectHistory methodsFor: 'project lifetime' stamp: 'RAA 7/12/2000 10:17'!remember: aProject	| newTuple |	newTuple := self forget: aProject.	mostRecent addFirst: newTuple.	mostRecent size > 10 ifTrue: [mostRecent := mostRecent copyFrom: 1 to: 10].	self changed! !!ReferenceStream class methodsFor: 'examples' stamp: ''!example2"Here is the way to use DataStream and ReferenceStream:	rr := ReferenceStream fileNamed: ''test.obj''.	rr nextPut: <your object>.	rr close.To get it back:	rr := ReferenceStream fileNamed: ''test.obj''.	<your object> := rr next.	rr close.""An example and test of DataStream/ReferenceStream.	 11/19/92 jhm: Use self testWith:."	"ReferenceStream example2"	| input sharedPoint |	"Construct the test data."	input := Array new: 9.	input at: 1 put: nil.	input at: 2 put: true.	input at: 3 put: false.	input at: 4 put: #(-4 -4.0 'four' four).	input at: 5 put: (Form extent: 63 @ 50 depth: 8).		(input at: 5) fillWithColor: Color lightOrange.	input at: 6 put: 1024 @ -2048.	input at: 7 put: input. "a cycle"	input at: 8 put: (Array with: (sharedPoint := 0 @ -30000)).	input at: 9 put: sharedPoint.	"Write it out, read it back, and return it for inspection."	^ self testWith: input! !!ChangeSet methodsFor: 'testing' stamp: 'nk 7/2/2003 10:47'!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified aSelector |	notClassified := {'as yet unclassified' asSymbol. #all}.	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (aClass selectors includes:  (aSelector := mAssoc key)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ChangeRecord methodsFor: 'access' stamp: 'sw 10/20/2002 02:53'!fileOutOn: aFileStream	"File the receiver out on the given file stream"	| aString |	type == #method		ifTrue:			[aFileStream nextPut: $!!.			aString :=  class asString							, (meta ifTrue: [' class methodsFor: ']									ifFalse: [' methodsFor: '])							, category asString printString.			stamp ifNotNil:				[aString := aString, ' stamp: ''', stamp, ''''].			aFileStream nextChunkPut: aString.			aFileStream cr].	type == #preamble ifTrue: [aFileStream nextPut: $!!].	type == #classComment		ifTrue:			[aFileStream nextPut: $!!.			aFileStream nextChunkPut: class asString, ' commentStamp: ', stamp storeString.			aFileStream cr].	aFileStream nextChunkPut: self string.	type == #method ifTrue: [aFileStream nextChunkPut: ' '].	aFileStream cr! !!Project methodsFor: 'file in/out' stamp: 'KR 12/16/2005 11:07'!storeAttributesOn: aStream	| details |	self storeAttributeKey: 'Squeak-Version' value: SystemVersion current version on: aStream.	self storeAttributeKey: 'Squeak-LatestUpdate' value: SystemVersion current highestUpdate printString on: aStream.	self storeAttributeKey: 'File-Name-Encoding' value: LanguageEnvironment defaultFileNameConverter class encodingNames first on: aStream.	details := self world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new].	details associationsDo: [:assoc |		self storeAttributeKey: assoc key asString value: assoc value asString on: aStream.].! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:17'!keysFileName: aFileName	keysFileName := aFileName! !!SystemOrganizer methodsFor: 'query' stamp: 'dtl 8/26/2004 11:18'!commentInventory: categoryName	"SystemOrganization commentInventory: 'Morphic*'"	| classes commentedClasses |	classes := OrderedCollection new.	self categories withIndexCollect: [:cat :idx |		(categoryName match: cat)			ifTrue: [classes addAll: (self listAtCategoryNumber: idx)]			ifFalse: [nil]].	commentedClasses := classes select: [:catCls | (Smalltalk at: catCls) hasComment].	^ 'There are ' , classes size asString , ' classes in ' , categoryName ,		' of which ' , commentedClasses size asString , ' have comments and ',		(classes size - commentedClasses size) asString , ' do not yet have comments.'! !!MessageTally methodsFor: 'initialize-release' stamp: 'sd 9/30/2003 13:42'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	ObservedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current  getVMParameters.	Timer := [[| startTime | 			startTime := Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext by: Time millisecondClockValue - startTime // millisecs.			startTime < endTime] whileTrue.			sem signal]				forkAt: (ObservedProcess priority + 1 min: Processor highestPriority).	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	SmalltalkImage current  getVMParameters keysAndValuesDo:		[:idx :gcVal| gcStats at: idx put: (gcVal - gcStats at: idx)].	time := Time millisecondClockValue - time0! !!MessageTally methodsFor: 'tallying' stamp: ''!tally: context by: count	"Explicitly tally the specified context and its stack."	| root |	context method == method ifTrue: [^self bumpBy: count].	(root := context home sender) == nil		ifTrue: [^ (self bumpBy: count) tallyPath: context by: count].	^ (self tally: root by: count) tallyPath: context by: count! !!ChangeSet methodsFor: 'moving changes' stamp: 'yo 8/30/2002 13:59'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isString)		ifTrue: [ cname := class ]		ifFalse: [ cname := class name ].	changeRecords removeKey: cname ifAbsent: [].	self noteClassForgotten: cname.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/26/1999 13:07'!revert	"Pretend this segment was never brought in.  Check that it has a fileName.  Replace (using become:) all the original roots of a segment with segmentRootStubs.  Thus the original objects will be reclaimed, and the root stubs will remain to bring the segment back in if it is needed.	How to use revert:  In the project, choose 'save for reverting'.	ReEnter the project.  Make changes.	Either exit normally, and change will be kept, or		Choose 'Revert to saved version'."	fileName ifNil: [^ self].	(state = #inactive) | (state = #onFile) ifFalse: [^ self].	Cursor write showWhile: [		arrayOfRoots elementsForwardIdentityTo:			(arrayOfRoots collect: [:r | r rootStubInImageSegment: self]).		state := #onFile.		segment := nil.		endMarker := nil]."Old version:	How to use revert:  In the project, execute (Project current projectParameters at: #frozen put: true)	Leave the project.  Check that the project went out to disk (it is gray in the Jump to Project list).	ReEnter the project.  Hear a plink as it comes in from disk.  Make a change.	Exit the project.  Choose 'Revert to previous version' in the dialog box.	Check that the project went out to disk (it is gray in the Jump to Project list).	ReEnter the project and see that it is in the original state."! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'RAA 5/31/2000 08:46'!timeDecode: count	"Example of signing a message and verifying its signature."	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm timeDecode: 20"	| msg keys sig s dsa |	dsa := DigitalSignatureAlgorithm new.	dsa initRandomFromUser.	#(1 10 100 1000 10000 100000) do: [ :extraLen |		s := String new: extraLen.		1 to: s size do: [ :i | s at: i put: (Character value: 200 atRandom)].		msg := 'This is a test...',s.		keys := self testKeySet.		sig := self sign: msg privateKey: keys first dsa: dsa.		"self inform: 'Signature created'."		self timeDirect: [			count timesRepeat: [				(self verify: sig isSignatureOf: msg publicKey: keys last)					ifFalse: [self error: 'ERROR!! Signature verification failed'].			].		] as: 'verify msgLen = ',msg size printString count: count	].! !!SystemNavigation methodsFor: 'browse' stamp: 'ich. 5/16/2004 01:05'!allMethodsInCategory: category 	| aCollection |	aCollection := SortedCollection new.	Cursor wait showWhile:		[self allBehaviorsDo:			[:x | (x allMethodsInCategory: category) do:				[:sel | aCollection add: x name , ' ' , sel]]].	^aCollection.	! !!SerialPort methodsFor: 'initialization' stamp: 'jm 5/5/1998 15:49'!initialize	"Default port settings."	port := nil.					"set when opened"	baudRate := 9600.			"9600 baud"	stopBitsType := 1.				"one stop bit"	parityType := 0.				"no parity"	dataBits := 8.					"8 bits"	outputFlowControlType := 0.	"none"	inputFlowControlType := 0.	"none"	xOnByte := 19.				"ctrl-S"	xOffByte := 24.				"ctrl-X"! !!CodeLoader methodsFor: 'accessing' stamp: 'ar 12/22/1999 15:07'!publicKey: aPublicKey	publicKey := aPublicKey! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 12/22/1999 11:18'!sign: aStringOrStream privateKey: privateKey	"Sign the given message (a stream or string) and answer a signature string."	"Note: Unguessable random numbers are needed for message signing. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before signing a message. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."	| dsa hasher h sig |	dsa := DigitalSignatureAlgorithm new.	dsa initRandomFromUser.	hasher := SecureHashAlgorithm new.	(aStringOrStream class isBytes)		ifTrue: [h := hasher hashMessage: aStringOrStream]		ifFalse: [h := hasher hashStream: aStringOrStream].	sig := dsa computeSignatureForMessageHash: h privateKey: privateKey.	^ dsa signatureToString: sig! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 2/2/2001 17:59'!uploadFileNamed: aFilename to: baseUrl user: user passwd: passwd	| fileContents remoteFilename |	remoteFilename := (baseUrl endsWith: '/')		ifTrue: [baseUrl , '/' , aFilename]		ifFalse: [baseUrl , aFilename].	fileContents := (StandardFileStream readOnlyFileNamed: aFilename) contentsOfEntireFile.	HTTPSocket httpPut: fileContents to: remoteFilename user: user passwd: passwd! !!LRUCache methodsFor: 'accessing' stamp: 'dgd 2/6/2002 21:43'!at: aKey 	"answer the object for aKey, if not present in the cache creates it"	| element keyHash |	calls := calls + 1.	keyHash := aKey hash.	1		to: size		do: [:index | 			element := values at: index.			(keyHash						= (element at: 2)					and: [aKey							= (element at: 1)])				ifTrue: ["Found!!"					hits := hits + 1.					values						replaceFrom: 2						to: index						with: (values first: index - 1).					values at: 1 put: element.					^ element at: 3]].	"Not found!!"	element := {aKey. keyHash. factory value: aKey}.	values		replaceFrom: 2		to: size		with: values allButLast.	values at: 1 put: element.	^ element at: 3! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/7/2001 18:17'!instVarInfo: anObject	"Return the object to write on the outgoing file that contains the structure of each class we are about to write out.  Must be an Array whose first element is 'class structure'.  Its second element is a Dictionary of pairs of the form #Rectangle -> #(<classVersion> 'origin' 'corner').  "	"Make a pass through the objects, not writing, but recording the classes.  Construct a database of their inst vars and any version info (classVersion)."	| dummy refs cls newSupers |	structures := Dictionary new.	superclasses := Dictionary new.	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	refs := dummy references.	objCount := refs size.		"for progress bar"		"Note that Dictionary must not change its implementation!!  If it does, how do we read this reading information?"	(refs includesKey: #AnImageSegment) 		ifFalse: [			self uniClassInstVarsRefs: dummy.	"catalog the extra objects in UniClass inst vars"			refs keysDo: [:each | 				cls := each class.				"cls isObsolete ifTrue: [self error: 'Trying to write ', cls name]."				(cls class ~~ Metaclass) & (cls isObsolete not) ifTrue: [					structures at: cls name put: false]]]		ifTrue: [self recordImageSegment: refs].	"Save work by only computing inst vars once for each class"	newSupers := Set new.	structures at: #Point put: false.	"writeRectangle: does not put out class pointer"	structures at: #Rectangle put: false.	structures at: #LargePositiveInteger put: false.	"used in slow case of WordArray"	structures keysDo: [:nm | 		cls := (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		cls allSuperclasses do: [:aSuper |			structures at: aSuper name ifAbsent: [newSupers add: aSuper name]]].			"Don't modify structures during iteration"	newSupers do: [:nm | structures at: nm put: 3].	"Get all superclasses into list"	structures keysDo: [:nm | "Nothing added to classes during loop"		cls := (nm endsWith: ' class') 			ifFalse: [Smalltalk at: nm]			ifTrue: [(Smalltalk at: nm substrings first asSymbol) class].		structures at: nm put: 			((Array with: cls classVersion), (cls allInstVarNames)).		superclasses at: nm ifAbsent: [				superclasses at: nm put: cls superclass name]].	(refs includesKey: #AnImageSegment) 		ifTrue: [classInstVars := #()]		ifFalse: [self saveClassInstVars].	"of UniClassses"	^ (Array with: 'class structure' with: structures with: 'superclasses' with: superclasses)! !!Project methodsFor: 'file in/out' stamp: 'tk 7/28/2005 04:58'!restoreReferences	| key newKey extName |	"I just came in from an exported segment.  Take all my players that were in References, and reinstall them."	"*** Note that (world valueOfProperty: #References) is temporary during loading and is not the same as the global References dictionary (in Smalltalk)."	(world valueOfProperty: #References ifAbsent: [#()]) do: [:assoc | "just came in"		key := assoc key.		(References includesKey: key) 			ifTrue: ["must rename" 				extName := assoc value externalName.	"what user sees"				(References at: key) == assoc value ifTrue: [					self error: 'why is this object already present?'].				newKey := assoc value uniqueNameForReference.				References removeKey: newKey.				assoc key: newKey.				References add: assoc.	"use the known association"				Preferences universalTiles					ifTrue: [assoc value renameTo: newKey] 	"change names in scripts"					ifFalse: [(assoc value renameInternal: extName)	"keep externalName the same"								ifNil: [assoc value renameTo: newKey]].									"rename Project itself.  Ignore others"				]			ifFalse: [References add: assoc]].	world removeProperty: #References.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 19:38'!initializeTotals	"Initialize totalA through totalE to their seed values."	"total registers for use when primitives are absent"	totalA := ThirtyTwoBitRegister new load: 16r67452301.	totalB := ThirtyTwoBitRegister new load: 16rEFCDAB89.	totalC := ThirtyTwoBitRegister new load: 16r98BADCFE.	totalD := ThirtyTwoBitRegister new load: 16r10325476.	totalE := ThirtyTwoBitRegister new load: 16rC3D2E1F0.	self initializeTotalsArray.! !!Project methodsFor: 'release' stamp: 'RAA 6/7/2000 09:24'!release	self flag: #bob.	"this can be trouble if Projects are reused before garbage collection"	world == nil ifFalse:		[world release.		world := nil].	^ super release! !!MessageTally class methodsFor: 'spying' stamp: 'tk 5/4/1998 17:01'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"MessageTally tallySends: [3.14159 printString]"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime := Time millisecondClockValue.	tallies := MessageTally new class: aBlock receiver class							method: aBlock method.	prev := aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: 				["call or return"				prev sender == nil ifFalse: 					["call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev := current]].	totalTime := Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(StringHolder new contents:		(String streamContents:			[:s |			s nextPutAll: 'This simulation took ' , totalTime printString							, ' seconds.'; cr.			treeOption				ifTrue: [tallies fullPrintOn: s tallyExact: true orThreshold: 0]				ifFalse: [tallies leavesPrintOn: s tallyExact: true orThreshold: 0].			tallies close]))		openLabel: 'Spy Results'! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:33'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose	name is derived from aName. Leave the 'current change set'	unchanged. Return the new change set or nil on failure."	| oldChanges newName newSet newStream |	oldChanges := ChangeSet current.	PreviousSet := oldChanges name. 		"so a Bumper update can find it"	newName := aName sansPeriodSuffix.	newSet := self basicNewChangeSet: newName.	[newSet ifNotNil:[		(aStream respondsTo: #converter:) ifFalse: [			newStream := MultiByteBinaryOrTextStream with: (aStream contentsOfEntireFile).			newStream reset.		] ifTrue: [			newStream := aStream.		].		self newChanges: newSet.		newStream setConverterForCode.		newStream fileInAnnouncing: 'Loading ', newName, '...'.		Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName].	aStream close] ensure: [self newChanges: oldChanges].	PreviousSet := nil.	^ newSet! !!SystemNavigation methodsFor: 'query' stamp: 'nk 7/3/2003 16:13'!allUnimplementedCalls	"Answer an Array of each message that is sent by an expression in a  	method but is not implemented by any object in the system."	| aStream secondStream all |	all := self allImplementedMessages.	aStream := WriteStream				on: (Array new: 50).	Cursor execute		showWhile: [self				allBehaviorsDo: [:cl | cl						selectorsDo: [:sel | 							secondStream := WriteStream										on: (String new: 5).							(cl compiledMethodAt: sel) messages								do: [:m | (all includes: m)										ifFalse: [secondStream nextPutAll: m;												 space]].							secondStream position = 0								ifFalse: [aStream nextPut: cl name , ' ' , sel , ' calls: ' , secondStream contents]]]].	^ aStream contents! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'yo 7/29/2005 21:48'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  Anobject in the segment is the wrong size for the modern version of theclass.  Construct a fake class that is the old size.  Replace themodern class with the old one in outPointers.  Load the segment.Traverse the instances, making new instances by copying fields, andrunning conversion messages.  Keep the new instances.  Bulk forwardbecome the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.Globalize new classes.  Caller may want to do some special install oncertain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal ccFixups receiverClassesrootsToUnhiberhate myProject existing |	RecentlyRenamedClasses := nil.		"in case old datahanging around"	mapFakeClassesToReal := smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.Substitute them in outPointers."	ccFixups := self remapCompactClasses: mapFakeClassesToReal				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is notcompatible'].	endMarker := segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker := 'End' clone].	self fixCapitalizationOfSymbols.	arrayOfRoots := self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		self reshapeClasses: mapFakeClassesToReal refStream:smartRefStream	].	"When a Project is stored, arrayOfRoots has all objects inthe project, except those in outPointers"	arrayOfRoots do: [:importedObject |		((importedObject isMemberOf: WideString) or: [importedObject isMemberOf: WideSymbol]) ifTrue: [			importedObject mutateJISX0208StringToUnicode.			importedObject class = WideSymbol ifTrue: [				"self halt."				Symbol hasInterned: importedObject asString ifTrue: [:multiSymbol |					multiSymbol == importedObjectifFalse: [						importedObjectbecomeForward: multiSymbol.					].				].			].		].		(importedObject isKindOf: TTCFontSet) ifTrue: [			existing := TTCFontSet familyName:importedObject familyName						pointSize:importedObject pointSize.	"supplies default"			existing == importedObject ifFalse:[importedObject becomeForward: existing].		].	].	"Smalltalk garbageCollect.   MultiSymbol rehash.  These taketime and are not urgent, so don't to them.  In the normal case, nobad MultiSymbols will be found."	receiverClasses := self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject |		importedObject class class == Metaclass ifTrue: [selfdeclare: importedObject]].	arrayOfRoots do: [:importedObject |		(importedObject isKindOf: CompiledMethod) ifTrue: [			importedObject sourcePointer > 0 ifTrue:[importedObject zapSourcePointer]].		(importedObject isKindOf: Project) ifTrue: [			myProject := importedObject.			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences.			self dependentsRestore: importedObject.			ScriptEditorMorph writingUniversalTiles:				((importedObject projectPreferenceAt:#universalTiles) ifNil: [false])]].	rootsToUnhiberhate := arrayOfRoots select: [:importedObject |		importedObject respondsTo: #unhibernate	"ScriptEditors and ViewerFlapTabs"	].	myProject ifNotNil: [		myProject world setProperty: #thingsToUnhibernatetoValue: rootsToUnhiberhate	].	mapFakeClassesToReal isEmpty ifFalse: [		mapFakeClassesToReal keys do: [:aFake |			aFake indexIfCompact > 0 ifTrue: [aFakebecomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!Utilities class methodsFor: 'identification' stamp: 'di 6/13/97 13:52'!fixStamp: changeStamp 	| parts |	parts := changeStamp findTokens: ' '.	(parts size > 0 and: [parts last first isLetter]) ifTrue:		["Put initials first in all time stamps..."		^ String streamContents:				[:s | s nextPutAll: parts last.				parts allButLast do: [:p | s space; nextPutAll: p]]].	^ changeStamp! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 4/29/2001 14:04'!writeList: listContents toStream: strm	"Write a parsed updates.list out as text.	This is the inverse of parseListContents:"	| fileNames version |	strm reset.	listContents do:		[:pair | version := pair first.  fileNames := pair last.		strm nextPut: $#; nextPutAll: version; cr.		fileNames do: [:fileName | strm nextPutAll: fileName; cr]].	strm close! !!Preference methodsFor: 'value' stamp: 'sw 4/18/2002 12:15'!defaultValue: aValue	"Set the receiver's defaultValue"	defaultValue := aValue.! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample2	"This is the second example from the specification document (FIPS PUB 180-1)"	hash := SecureHashAlgorithm new hashMessage:		'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'.	self assert: (hash = 16r84983E441C3BD26EBAAE4AA1F95129E5E54670F1).! !!FileServices class methodsFor: 'accessing' stamp: 'ar 7/16/2005 17:00'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| services suffix |	suffix := self suffixOf: fullName.	services := OrderedCollection new.	self registeredFileReaderClasses do: [:reader |		reader ifNotNil: [services addAll: (reader fileReaderServicesForFile: fullName suffix: suffix)]].	^ services! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/4/2000 11:14'!removeSelectorChanges: selector class: class 	"Remove all memory of changes associated with the argument, selector, in 	this class."	| chgRecord |	(chgRecord := changeRecords at: class name ifAbsent: [^ self])		removeSelector: selector.	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name]! !!ExternalDropHandler class methodsFor: 'private' stamp: 'tak 3/13/2005 21:19'!defaultImageHandler	| image sketch |	^ExternalDropHandler		type: 'image/'		extension: nil		action: [:stream :pasteUp :event |			stream binary.			image := Form fromBinaryStream: ((RWBinaryOrTextStream with: stream contents) reset).			Project current resourceManager 				addResource: image 				url: (FileDirectory urlForFileNamed: stream name) asString.			sketch := World drawingClass withForm: image.			pasteUp addMorph: sketch centeredNear: event position.			image := sketch := nil] fixTemps! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 16:24'!flushSecurityKey: aKey	"Flush a security key"	| n |	n := aKey first.	1 to: n basicSize do:[:i| n basicAt: i put: 0].	n := aKey second.	1 to: n basicSize do:[:i| n basicAt: i put: 0].! !!Project methodsFor: 'accessing' stamp: ''!displayDepth: newDepth	displayDepth := newDepth! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 6/8/2001 09:57'!writeClassRename: newName was: oldName	"Write a method that tells which modern class to map instances to."	| oldVer sel code |	oldVer := self versionSymbol: (structures at: oldName).	sel := oldName asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel := sel, oldVer.	"i.e. #rectangleoc4"	code := WriteStream on: (String new: 500).	code nextPutAll: sel; cr.	code cr; tab; nextPutAll: '^ ', newName.	"Return new class"	self class compile: code contents classified: 'conversion'.! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 23:28'!noteNewMethod: newMethod selector: selector priorMethod: methodOrNil	| methodChange |	methodChange := self findOrMakeMethodChangeAt: selector priorMethod: methodOrNil.	methodOrNil == nil		ifTrue: [methodChange noteChangeType: #add]		ifFalse: [methodChange noteChangeType: #change].	methodChange noteNewMethod: newMethod.! !!Project methodsFor: 'file in/out' stamp: 'ar 10/11/2000 15:25'!currentVersionNumber	version ifNil: [^0].	version isInteger ifTrue:[^version].	version := Base64MimeConverter decodeInteger: version unescapePercents.	^version! !!Utilities class methodsFor: 'miscellaneous' stamp: 'mdr 9/4/2000 11:07'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict := Dictionary new.	report := ReadWriteStream on: ''.	f := FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString := f upTo: Character cr.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f := FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString := f upTo: Character cr.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className := items first.			newInstCount := items third asNumber.			newSpace := items fourth asNumber.			oldPair := instCountDict at: className ifAbsent: [nil].			oldInstCount := oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace := oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'nk 9/6/2004 08:22'!valueStartingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Error so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Error."	| each answer |	startIndex to: self size do: [:index |		each := self at: index.		each isReceiverOrAnyArgumentGarbage ifFalse: [			[answer := each value]				on: Halt, Error				do: [:exc | 						self valueStartingFrom: index + 1.						exc pass]]].	^ answer! !!TwoLevelDictionary methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:40'!twoLevelKeys	| twoLevelSet |	twoLevelSet := TwoLevelSet new.	self keysDo: [ :each | twoLevelSet add: each].	^twoLevelSet! !!SystemVersion methodsFor: 'accessing' stamp: 'mir 3/29/2001 18:01'!resetHighestUpdate	highestUpdate := nil! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:37'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound aChangeSet infoString empty |	notFound := OrderedCollection new.	empty := OrderedCollection new.	nameList do:		[:aName | (aChangeSet := self named: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString := (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString := infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString := infoString, '', aName]].	empty size > 0 ifTrue:		[infoString := infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString := infoString, '', aName]].	self inform: infoString! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:28'!openTextFile: memberOrName	"Open a text window on the given member"	| member |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	StringHolder new		acceptContents: member contents;		openLabel: member fileName.	self installed: member.! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 11/16/2001 14:43'!getterSelectorFor: identifier	"Answer the corresponding getter.  Two idiosyncratic vectorings herein... " 	"Utilities getterSelectorFor: #elvis"	| aSymbol |	(aSymbol := identifier asSymbol) == #isOverColor: ifTrue: [^ #seesColor:].	aSymbol == #copy ifTrue: [^ #getNewClone].	^ ('get', (identifier asString capitalized)) asSymbol! !!Utilities class methodsFor: 'scraps' stamp: 'sw 10/21/1999 17:42'!emptyScrapsBook	"Utilities emptyScrapsBook"	| oldScraps |	oldScraps := ScrapsBook.	ScrapsBook := nil.	self scrapsBook.  "Creates it afresh"	(oldScraps notNil and: [oldScraps owner notNil])		ifTrue:			[ScrapsBook position: oldScraps position.			oldScraps owner replaceSubmorph: oldScraps by: ScrapsBook.			ScrapsBook changed; layoutChanged]! !!Utilities class methodsFor: 'fetching updates' stamp: 'edc 7/28/2007 10:51'!extractThisVersion: list	"Pull out the part of the list that applies to this version."	| listContents version versIndex |	listContents := self parseListContents: list.	version := SystemVersion current version.		versIndex := (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue: [^ Array new].		"abort"	^ (listContents at: versIndex) last! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:28'!removeAllXAndY: aPoint	| deletes |	deletes := OrderedCollection new.	firstLevel removeKey: aPoint x ifAbsent: [].	firstLevel keysAndValuesDo: [ :x :lev2 |		lev2 remove: aPoint y ifAbsent: [].		lev2 isEmpty ifTrue: [deletes add: x].	].	deletes do: [ :each | firstLevel removeKey: each ifAbsent: []].! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/18/2003 08:21'!allCallsOn: firstLiteral and: secondLiteral	"Answer a SortedCollection of all the methods that call on both aLiteral 	and secondLiteral."	| aCollection secondArray firstSpecial secondSpecial firstByte secondByte |	self flag: #ShouldUseAllCallsOn:. "sd"	aCollection := SortedCollection new.	firstSpecial := Smalltalk hasSpecialSelector: firstLiteral ifTrueSetByte: [:b | firstByte := b].	secondSpecial := Smalltalk hasSpecialSelector: secondLiteral ifTrueSetByte: [:b | secondByte := b].	Cursor wait showWhile: [		self allBehaviorsDo: [:class |			secondArray := class 				whichSelectorsReferTo: secondLiteral				special: secondSpecial				byte: secondByte.			((class whichSelectorsReferTo: firstLiteral special: firstSpecial byte: firstByte) select:				[:aSel | (secondArray includes: aSel)]) do:						[:sel | 							aCollection add: (								MethodReference new									setStandardClass: class 									methodSymbol: sel							)						]		]	].	^aCollection! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'al 4/25/2004 11:41'!fileOutCategory: category on: aFileStream initializing: aBool	"Store on the file associated with aFileStream, all the traits and classes associated 	with the category and any requested shared pools in the right order."	| first poolSet tempClass classes traits |	traits := self orderedTraitsIn: category.	classes := self superclassOrder: category.	poolSet := Set new.	classes do:  [:class | class sharedPools do: [:eachPool | poolSet add: eachPool]].	poolSet size > 0 ifTrue: [		tempClass := Class new.		tempClass shouldFileOutPools ifTrue: [			poolSet := poolSet select: [:aPool |				tempClass shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool)].			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].	first := true.	traits, classes do: [:each | 		first			ifTrue: [first := false]			ifFalse: [aFileStream cr; nextPut: Character newPage; cr].		each			fileOutOn: aFileStream			moveSource: false			toFile: 0			initializing: false].	aBool ifTrue: [classes do: [:cls | cls fileOutInitializerOn: aFileStream]].! !!ImageSegment class methodsFor: 'testing' stamp: 'RAA 9/27/2000 18:50'!swapOutProjects  "ImageSegment swapOutProjects"  	"Swap out segments for all projects other than the current one."	| spaceLeft newSpaceLeft |	spaceLeft := Smalltalk garbageCollect.	Project allProjects doWithIndex:		[:p :i | p couldBeSwappedOut ifTrue:			[Transcript cr; cr; nextPutAll: p name.			(ImageSegment new copyFromRoots: (Array with: p) sizeHint: 0)				extract; writeToFile: 'project' , i printString.			newSpaceLeft := Smalltalk garbageCollect.			Transcript cr; print: newSpaceLeft - spaceLeft; endEntry.			spaceLeft := newSpaceLeft]].! !!SmartRefStream methodsFor: 'import image segment' stamp: 'ar 4/12/2005 18:06'!mapClass: newClass origName: originalName	"See if instances changed shape.  If so, make a fake class for the old shape and return it.  Remember the original class name."	| newName oldInstVars fakeClass |	newClass isMeta ifTrue: [^ newClass].	newName := newClass name.	(steady includes: newClass) & (newName == originalName) ifTrue: [^ newClass].		"instances in the segment have the right shape"	oldInstVars := structures at: originalName ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	"Allow mapping from old to new string names"	(newName == #ByteString and:[originalName == #String]) ifTrue:[^newClass].	(newName == #WideString and:[originalName == #MultiString]) ifTrue:[^newClass].	(newName == #WideSymbol and:[originalName == #MultiSymbol]) ifTrue:[^newClass].	fakeClass := Object subclass: ('Fake37', originalName) asSymbol		instanceVariableNames: oldInstVars allButFirst		classVariableNames: ''		poolDictionaries: ''		category: 'Obsolete'.	ChangeSet current removeClassChanges: fakeClass name.	"reduce clutter"	^ fakeClass! !!MczInstaller methodsFor: 'installation' stamp: 'avi 2/17/2004 02:56'!install	| sources |	zip := ZipArchive new.	zip readFrom: stream.	self checkDependencies ifFalse: [^false].	self recordVersionInfo.	sources := (zip membersMatching: 'snapshot/*') 				asSortedCollection: [:a :b | a fileName < b fileName].	sources do: [:src | self installMember: src].! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 16:04'!invoke	"Install all methods changed here into method dictionaries.	Make my versions be the ones that will be called."	isolatedHead ifFalse: [^ self error: 'This isnt an isolation layer.'].	inForce ifTrue: [^ self error: 'This layer is already in force.'].	changeSet invoke.		inForce := true.! !!NaturalLanguageFormTranslator methodsFor: 'i/o' stamp: 'yo 1/13/2005 14:02'!saveFormsOn: aStream	| rr |	rr := ReferenceStream on: aStream.	rr nextPut: {id isoString. generics}.	rr close.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tk 10/16/2001 19:24'!logError: errMsg inContext: aContext to: aFilename	"Log the error message and a stack trace to the given file."	| ff |	FileDirectory default deleteFileNamed: aFilename ifAbsent: [].	(ff := FileStream fileNamed: aFilename) ifNil: [^ self "avoid recursive errors"].  	ff nextPutAll: errMsg; cr.	aContext errorReportOn: ff.	ff close.! !!Project class methodsFor: 'instance creation' stamp: 'RAA 11/16/2000 12:08'!newMorphicOn: aPasteUpOrNil	| newProject |	newProject := self basicNew initMorphic.	self addingProject: newProject.	aPasteUpOrNil ifNotNil: [newProject installPasteUpAsWorld: aPasteUpOrNil].	newProject createViewIfAppropriate.	^newProject! !!Preferences class methodsFor: 'fonts' stamp: 'nk 9/1/2004 10:19'!setDefaultFonts: defaultFontsSpec	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	| fontNames map emphases |	fontNames := defaultFontsSpec collect: [:array | array second].	map := IdentityDictionary new.	emphases := IdentityDictionary new.	fontNames do: [:originalName | | decoded style response |		decoded := TextStyle decodeStyleName: originalName.		style := map at: originalName put: (TextStyle named: decoded second).		emphases at: originalName put: decoded first.		style ifNil: [			response := TextStyle modalStyleSelectorWithTitle: 'Choose replacement for text style ', originalName.			map at: originalName put: (response ifNil: [TextStyle default])]].	defaultFontsSpec do: [:triplet | self		perform: triplet first		with: (((map at: triplet second) fontOfPointSize: triplet third) emphasis: (emphases at: triplet second))]! !!ResourceLocator methodsFor: 'accessing' stamp: 'ar 2/27/2001 19:57'!urlString: aString	urlString := aString.! !!Project methodsFor: 'file in/out' stamp: 'rbb 2/16/2005 17:15'!tryToFindAServerWithMe	| resp primaryServerDirectory |	urlList isEmptyOrNil ifTrue: [urlList := parentProject urlList copy].	[self primaryServer isNil] whileTrue: [		resp := (UIManager default 					chooseFrom: #('Try to find a server' 'Cancel')					title: 'This project thinks it has never been on a server').		resp ~= 1 ifTrue: [^ nil].		(primaryServerDirectory := self findAFolderToLoadProjectFrom) ifNil: [^nil].		self storeNewPrimaryURL: primaryServerDirectory downloadUrl.	].	^self primaryServer! !!ImageSegment class methodsFor: 'testing' stamp: 'di 2/17/2000 22:08'!activeClassesByCategory   "ImageSegment activeClassesByCategory"	"Return a dictionary of active classes by system category.	Useful for finding kernel categories to minimize swapping."	| active dict cat list |	active := self activeClasses.	dict := Dictionary new.	active do:		[:c | cat := c category.		list := dict at: cat ifAbsent: [Array new].		dict at: cat put: (list copyWith: c)].	^ dict"	ImageSegment discoverActiveClasses  <-- do it		-- do something typical --	ImageSegment activeClassesByCategory  <-- inspect it"! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/15/2000 21:49'!fullPrintOn: aStream tallyExact: isExact orThreshold: perCent	| threshold |  	isExact ifFalse: [threshold := (perCent asFloat / 100 * tally) rounded].	aStream nextPutAll: '**Tree**'; cr.	self treePrintOn: aStream		tabs: OrderedCollection new		thisTab: ''		total: tally		totalTime: time		tallyExact: isExact		orThreshold: threshold.	aStream nextPut: Character newPage; cr.	aStream nextPutAll: '**Leaves**'; cr.	self leavesPrintOn: aStream		tallyExact: isExact		orThreshold: threshold! !!Project methodsFor: 'menu messages' stamp: 'sw 4/19/2001 12:58'!installProjectPreferences	"Install the settings of all preferences presently held individually by projects in the receiver's projectPreferenceFlagDictionary"	| localValue |	Preferences allPreferenceObjects do:		[:aPreference | 			aPreference localToProject ifTrue:				[localValue := self projectPreferenceFlagDictionary at: aPreference name ifAbsent: [nil].				localValue ifNotNil:					[aPreference rawValue: localValue]]]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ls 10/21/2001 21:09'!buildMessageForMailOutWithUser: userName	| message compressBuffer compressStream data compressedStream compressTarget |	"prepare the message"	message := MailMessage empty.	message setField: 'from' toString: userName.	message setField: 'to' toString: 'squeak-dev@lists.squeakfoundation.org'.	message setField: 'subject' toString: (self chooseSubjectPrefixForEmail, name). 	message body: (MIMEDocument contentType: 'text/plain' content: (String streamContents: [ :str |		str nextPutAll: 'from preamble:'; cr; cr.		self fileOutPreambleOn: str ])).	"Prepare the gzipped data"	data := WriteStream on: String new.	data header; timeStamp.	self fileOutPreambleOn: data.	self fileOutOn: data.	self fileOutPostscriptOn: data.	data trailer.	data := ReadStream on: data contents.	compressBuffer := ByteArray new: 1000.	compressStream := GZipWriteStream on: (compressTarget := WriteStream on: (ByteArray new: 1000)).	[data atEnd]		whileFalse: [compressStream nextPutAll: (data nextInto: compressBuffer)].	compressStream close.	compressedStream := ReadStream on: compressTarget contents asString.	message addAttachmentFrom: compressedStream withName: (name, '.cs.gz').	^ message! !!ExternalDropHandler class methodsFor: 'accessing' stamp: 'mir 8/24/2004 15:37'!lookupExternalDropHandler: stream	| types extension serviceHandler |	types := stream mimeTypes.	types ifNotNil: [		self registeredHandlers do: [:handler | 			(handler matchesTypes: types)				ifTrue: [^handler]]].	extension := FileDirectory extensionFor: stream name.	self registeredHandlers do: [:handler | 		(handler matchesExtension: extension)				ifTrue: [^handler]].	serviceHandler := self lookupServiceBasedHandler: stream.	^serviceHandler		ifNil: [self defaultHandler]! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/8/2000 10:00'!savePlayerReferences: dictOfAllObjects	| save world |	"Save our associations we own in the shared References table.  They will be installed when the segment is imported."	save := OrderedCollection new.	References associationsDo: [:assoc |		(dictOfAllObjects includesKey: assoc) ifTrue: [save add: assoc]].	1 to: 5 do: [:ii | ((arrayOfRoots at: ii) respondsTo: #isCurrentProject) ifTrue: [					world := (arrayOfRoots at: ii) world]].	world setProperty: #References toValue: save.		"assume it is not refed from outside and will be traced"! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'RAA 7/28/2000 08:38'!streamedRepresentationOf: anObject	| file |	file := (RWBinaryOrTextStream on: (ByteArray new: 5000)).	file binary.	(self on: file) nextPut: anObject.	^file contents! !!ObjectScanner methodsFor: 'scanning' stamp: 'tk 3/15/98 20:22'!scanFrom: aByteStream	"Sieze control of the fileIn.  Put myself in as the context.  If any UniClasses (for just one instance) are defined, they will do it through me, and I will look for conflicting class names.  If so, install the old name as a class var of me, so the compile will work.  Tell my SmartRefStream about renaming the class."	| valWithOddName47 scannerNamed53 chunkNamed117 |	pvt3SmartRefStrm := SmartRefStream on: aByteStream.	aByteStream ascii.	[aByteStream atEnd] whileFalse:		[aByteStream skipSeparators.		valWithOddName47 := (aByteStream peekFor: $!!)			ifTrue: [chunkNamed117 := aByteStream nextChunk.	"debug"					scannerNamed53 := Compiler evaluate: chunkNamed117							for: self logged: false.					scannerNamed53 class == self class 						ifTrue: ["I already am the scanner for this file"]						ifFalse: [scannerNamed53 scanFrom: aByteStream]]			ifFalse: [chunkNamed117 := aByteStream nextChunk.					chunkNamed117 := self lookAhead: chunkNamed117.					Compiler evaluate: chunkNamed117 for: self logged: true].		aByteStream skipStyleChunk].	^ valWithOddName47! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'yo 2/25/2005 09:37'!writeAsMimeString	| fileName fileStream tmpStream s2 gzs |	tmpStream := MultiByteBinaryOrTextStream on: ''.	tmpStream converter: UTF8TextConverter new.	self fileOutOn: tmpStream.	s2 := RWBinaryOrTextStream on: ''.	gzs := GZipWriteStream on: s2.	tmpStream reset.	gzs nextPutAll: (tmpStream binary contentsOfEntireFile asString) contents.	gzs close.	s2 reset.	fileName := id isoString, '.translation.gz.mime'.	fileStream := FileStream newFileNamed: fileName.	fileStream nextPutAll: (Base64MimeConverter mimeEncode: s2) contents.	fileStream close.! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 10:02'!memberNameForProjectNamed: projectName	"Answer my member name for the given project, or nil.	Ignores version numbers and suffixes, and also unescapes percents in filenames."	^self zip memberNames detect: [ :memberName | | triple |		triple := Project parseProjectFileName: memberName unescapePercents.		triple first asLowercase = projectName asLowercase	] ifNone: [ nil ].! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 12:21'!saveAs	"Put up the 'saveAs' prompt, obtain a name, and save the image  under that new name."	| newName |	newName := self getFileNameFromUser.	newName isNil ifTrue: [^ self].	(SourceFiles at: 2) ifNotNil:		[self closeSourceFiles; "so copying the changes file will always work"			 saveChangesInFileNamed: (self fullNameForChangesNamed: newName)].	self saveImageInFileNamed: (self fullNameForImageNamed: newName)! !!RealEstateAgent class methodsFor: 'utilities' stamp: 'di 11/20/2001 00:17'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames y free topLeft viewBox |	grid := 24.  "should be mult of 8, since manual move is gridded by 8"	aSSView isMorph		ifTrue: [otherFrames := (SystemWindow windowsIn: aSSView world satisfying: [:w | true])					collect: [:w | w collapsedFrame]					thenSelect: [:rect | rect notNil].				viewBox := self reduceByFlaps: aSSView world viewBox]		ifFalse: [otherFrames := ScheduledControllers scheduledWindowControllers					collect: [:aController | aController view collapsedFrame]					thenSelect: [:rect | rect notNil].				viewBox := Display boundingBox].	y := viewBox top.	[(y := y + grid) <= (viewBox height - grid)]		whileTrue:		[topLeft := viewBox left@y.		free := true.		otherFrames do: [:w | free := free & (topLeft ~= w topLeft)].		free ifTrue: [^ topLeft]].	"If all else fails..."	^ 0 @ 0! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:25'!testExample3	"This is the third example from the specification document (FIPS PUB 180-1). 	This example may take several minutes."	hash := SecureHashAlgorithm new hashMessage: (String new: 1000000 withAll: $a).	self assert: (hash = 16r34AA973CD4C4DAA4F61EEB2BDBAD27316534016F).! !!Utilities class methodsFor: 'common requests' stamp: 'rbb 2/18/2005 13:11'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].		strings := CommonRequestStrings contents.	normalItemCount := strings asString lineCount.	aMenu := UIManager default 		chooseFrom: (((strings asString, '\edit this menu' withCRs) 						findTokens: Character cr) asArray)		lines: (Array with: normalItemCount).	index := aMenu startUp.	index == 0 ifTrue: [^ self].	reply := aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result := self evaluate: reply in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 20:53'!allObjectsDo: aBlock 	"Evaluate the argument, aBlock, for each object in the system 	excluding SmallIntegers."	| object |	object := self someObject.	[0 == object]		whileFalse: [aBlock value: object.			object := object nextObject]! !!SystemDictionary methodsFor: 'memory space' stamp: 'ar 2/25/2001 18:00'!bytesLeftString	"Return a string describing the amount of memory available"	| availInternal availPhysical availTotal |	self garbageCollect.	availInternal := self primBytesLeft.	availPhysical := self bytesLeft: false.	availTotal := self bytesLeft: true.	(availTotal > (availInternal + 10000)) "compensate for mini allocations inbetween"		ifFalse:[^availInternal asStringWithCommas, ' bytes available'].	^String streamContents:[:s|		s nextPutAll: availInternal asStringWithCommas, 	' bytes (internal) '; cr.		s nextPutAll: availPhysical asStringWithCommas,	' bytes (physical) '; cr.		s nextPutAll: availTotal asStringWithCommas, 	' bytes (total)     '].! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'tk 12/16/1999 23:44'!reclaimObsoleteSegmentFiles  "ImageSegment reclaimObsoleteSegmentFiles"	"Delete segment files that can't be used after this image is saved.	Note that this is never necessary -- it just saves file space."	| aFileName segDir segFiles folderName byName exists |	folderName := FileDirectory default class localNameFor: self folder.	(FileDirectory default includesKey: folderName) ifFalse: [		^ self "don't create if absent"].	segDir := self segmentDirectory.	segFiles := (segDir fileNames select: [:fn | fn endsWith: '.seg']) asSet.	exists := segFiles copy.	segFiles isEmpty ifTrue: [^ self].	byName := Set new.	"Remove (save) every file owned by a segment in memory"	ImageSegment allInstancesDo: [:is | 		(aFileName := is localName) ifNotNil: [			segFiles remove: aFileName ifAbsent: [].			(exists includes: aFileName) ifFalse: [				Transcript cr; show: 'Segment file not found: ', aFileName].			byName add: is segmentName]].	"Of the segments we have seen, delete unclaimed the files."	segFiles do: [:fName | 		"Delete other file versions with same project name as one known to us"		(byName includes: (fName sansPeriodSuffix stemAndNumericSuffix first))			ifTrue: [segDir deleteFileNamed: fName]].! !!FilePackage methodsFor: 'conflict checker' stamp: 'dew 3/30/2004 23:16'!conflictsWithUpdatedMethods	"Check this package for conflicts with methods in the image which are in newer updates."	| localFileName stream updateNumberString updateNumber imageUpdateNumber updateNumberChangeSet conflicts fileStream |	localFileName := FileDirectory localNameFor: fullName.	stream := ReadStream on: sourceSystem.	stream upToAll: 'latest update: #'.	updateNumberString := stream upTo: $].	stream close.		fileStream := FileStream readOnlyFileNamed: fullName.	(fileStream contentsOfEntireFile includes: Character linefeed)		ifTrue: [self notifyWithLabel:  'The changeset file ', localFileName, ' contains linefeeds.  Proceed if...you know that this is okay (e.g. the file contains raw binary data).'].	fileStream close.	updateNumberString isEmpty ifFalse:		"remove prepended junk, if any"		[updateNumberString := (updateNumberString findTokens: Character space) last].	updateNumberString asInteger ifNil:		[(self confirm: 'Error: ', localFileName, ' has no valid Latest Update number in its header.Do you want to enter an update number for this file?')			ifFalse: [^ self]			ifTrue: [updateNumberString := FillInTheBlank						request: 'Please enter the estimated update number (e.g. 4332).']].	updateNumberString asInteger ifNil: [self inform: 'Conflict check cancelled.'. ^ self].	updateNumber := updateNumberString asInteger.	imageUpdateNumber := SystemVersion current highestUpdate.	updateNumber > imageUpdateNumber ifTrue:		[(self confirm: 'Warning: The update number for this file (#', updateNumberString, ')is greater than the highest update number for this image (#', imageUpdateNumber asString, ').This probably means you need to update your image.Should we proceed anyway as if the file update number is #', imageUpdateNumber asString, '?')			ifTrue:				[updateNumber := imageUpdateNumber.				updateNumberString := imageUpdateNumber asString]			ifFalse: [^ self]].	updateNumberChangeSet := self findUpdateChangeSetMatching: updateNumber.	updateNumberChangeSet ifNil: [^ self].	Smalltalk isMorphic ifTrue: [self currentWorld findATranscript: self currentEvent].	self class logCr; logCr; log: 'Checking ', localFileName, ' (#', updateNumberString, ') for method conflicts with changesets after ', updateNumberChangeSet name, ' ...'.	conflicts := OrderedCollection new.	self classes values do: [:pseudoClass |		(Array with: pseudoClass with: pseudoClass metaClass) do: [:classOrMeta |			classOrMeta selectors do: [:selector | | conflict |				conflict := self							checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet							pseudoClass: classOrMeta							selector: selector.				conflict ifNotNil: [conflicts add: conflict].			].		].	].	self class logCr; log: conflicts size asString, (' conflict' asPluralBasedOn: conflicts), ' found.'; logCr.	self class closeLog.	^ conflicts! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/20/2003 14:27'!numberOfImplementorsOf: aSelector 	"Answer a count of the implementors of the given selector found in the  	system"	"self new numberOfImplementorsOf: #contents.  	self new numberOfImplementorsOf: #nobodyImplementsThis.  	self new numberOfimplementorsOf: #numberOfImplementorsOf:."	| aCount |	aCount := 0.	self		allBehaviorsDo: [:class | (class includesSelector: aSelector)				ifTrue: [aCount := aCount + 1]].	^ aCount! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 3/13/98 20:00'!blockers: anIdentDict	"maps objects -> nil if they should not be written.  object -> anotherObject if they need substitution."	anIdentDict class == IdentityDictionary ifFalse: [self error: 'must be IdentityDictionary'].	blockers := anIdentDict! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 1/5/1999 01:30'!reconstructTextWindowsFromFileNamed: aName	"Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'"	| aReferenceStream aDict |	aReferenceStream := ReferenceStream fileNamed: aName.	aDict := aReferenceStream next.	aReferenceStream close.	aDict associationsDo:		[:assoc |			(StringHolder new contents: assoc value) openLabel: assoc key andTerminate: false].	Smalltalk isMorphic ifFalse:		[ScheduledControllers restore.		Processor terminateActive]! !!ChangeSet methodsFor: 'class changes' stamp: 'dvf 9/27/2005 19:04'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |		class isBehavior ifFalse: [^class definition].		newDef := class definition.	oldDef := (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm := ReadStream on: oldDef.	newStrm := ReadStream on: newDef.	outStrm := WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames'; upTo: $'.	outStrm 		nextPutAll: (newStrm upToAll: 'instanceVariableNames'); 		nextPutAll: 'instanceVariableNames:'.	newStrm peek = $: ifTrue: [newStrm next].	"may or may not be there, but already written"	outStrm		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars := (oldStrm upTo: $') findTokens: Character separators.	newVars := (newStrm upTo: $') findTokens: Character separators.	addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars := (oldStrm upTo: $') findTokens: Character separators.		newVars := (newStrm upTo: $') findTokens: Character separators.		addedVars := oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!HTTPLoader methodsFor: 'private' stamp: 'mir 5/12/2003 18:10'!startDownload	| newDownloadProcess |		downloads size >= self maxNrOfConnections ifTrue: [^self].	requests size <= 0 ifTrue: [^self].	newDownloadProcess := [		[			self nextRequest startRetrieval		] on: FTPConnectionException do: [ :ex | 			Cursor normal show.			self removeProcess: Processor activeProcess.			self startDownload		].		self removeProcess: Processor activeProcess.		self startDownload	] newProcess.	downloads add: newDownloadProcess.	newDownloadProcess resume! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'jm 1/11/2000 00:25'!initRandom: randomInteger	"Initialize the the secure random number generator with the given value. The argument should be a positive integer of up to 512 bits chosen randomly to avoid someone being able to predict the sequence of random values generated."	"Note: The random generator must be initialized before generating a key set or signature. Signature verification does not require initialization of the random generator."	randSeed := 16rEFCDAB8998BADCFE10325476C3D2E1F067452301.  "initial seed"	randKey := randomInteger.	Transcript show: 'Random seed: ', randomInteger printString; cr.! !!SystemVersion methodsFor: 'accessing' stamp: 'mir 3/29/2001 18:03'!highestUpdate	| sortedUpdates |	highestUpdate ifNil: [		sortedUpdates := self updates asSortedCollection.		highestUpdate := (sortedUpdates isEmpty			ifTrue: [0]			ifFalse: [sortedUpdates last])].	^highestUpdate! !!SmartRefStream methodsFor: 'read write' stamp: 'ar 4/10/2005 18:52'!mapClass: incoming	"See if the old class named nm exists.  If so, return it.  If not, map it to a new class, and save the mapping in renamed.  "	| cls oldVer sel nm |	self flag: #bobconv.		nm := renamed at: incoming ifAbsent: [incoming].	"allow pre-mapping around collisions"	(nm endsWith: ' class') 		ifFalse: [cls := Smalltalk at: nm ifAbsent: [nil].			cls ifNotNil: [^ cls]]  	"Known class.  It will know how to translate the instance."		ifTrue: [cls := Smalltalk at: nm substrings first asSymbol ifAbsent: [nil].			cls ifNotNil: [^ cls class]]. 	"Known class.  It will know how to translate the instance."	oldVer := self versionSymbol: (structures at: nm).	sel := nm asString.	sel at: 1 put: (sel at: 1) asLowercase.	sel := sel, oldVer.	"i.e. #rectangleoc4"	Symbol hasInterned: sel ifTrue: [:symb | 		(self class canUnderstand: sel asSymbol) ifTrue: [			reshaped ifNil: [reshaped := Dictionary new].			cls := self perform: sel asSymbol]].	"This class will take responsibility"	cls ifNil: [cls := self writeClassRenameMethod: sel was: nm					fromInstVars: (structures at: nm).			   cls isString ifTrue: [cls := nil]].	cls ifNotNil: [renamed at: nm put: cls name].	^ cls! !!ImageSegment class methodsFor: 'testing' stamp: 'tk 11/30/1999 22:27'!swapOutInactiveClasses  "ImageSegment swapOutInactiveClasses"  	"Make up segments by grouping unused classes by system category.	Read about, and execute discoverActiveClasses, and THEN execute this one."	| unused groups i roots |	ImageSegment recoverFromMDFault.	ImageSegmentRootStub recoverFromMDFault.	unused := Smalltalk allClasses select: [:c | (c instVarNamed: 'methodDict') == nil].	unused do: [:c | c recoverFromMDFault].	groups := Dictionary new.	SystemOrganization categories do:		[:cat |		i := (cat findLast: [:c | c = $-]) - 1.		i <= 0 ifTrue: [i := cat size].		groups at: (cat copyFrom: 1 to: i)			put: (groups at: (cat copyFrom: 1 to: i) ifAbsent: [Array new]) ,			((SystemOrganization superclassOrder: cat) select: [:c | 				unused includes: c]) asArray].	groups keys do:		[:cat | roots := groups at: cat.		Transcript cr; cr; show: cat; cr; print: roots; endEntry.		roots := roots , (roots collect: [:c | c class]).		(cat beginsWith: 'Sys' "something here breaks") ifFalse:			[(ImageSegment new copyFromRoots: roots sizeHint: 0) extract; 				writeToFile: cat].		Transcript cr; print: Smalltalk garbageCollect; endEntry]! !!ResourceManager methodsFor: 'accessing' stamp: 'mir 6/21/2001 16:02'!adjustToRename: newName from: oldName	"Adjust the resource manager to the current download location. A project might have been moved manually to a different location or server."	| urlMap oldUrl |	newName isEmptyOrNil ifTrue: [^self].	urlMap := Dictionary new.	self resourceMap		keysDo: [:locator | 			oldUrl := locator urlString.			locator adjustToRename: newName from: oldName.			urlMap at: oldUrl put: locator urlString].	self resourceMap rehash.	unloaded rehash.	urlMap keysAndValuesDo: [:old :new |		ResourceManager renameCachedResource: old to: new]! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'nk 7/29/2004 10:10'!writeConversionMethodIn: newClass fromInstVars: oldList to: newList renamedFrom: oldName	"The method convertToCurrentVersion:refStream: was not found in newClass.  Write a default conversion method for the author to modify.  If method exists, append new info into the end."	| code newOthers oldOthers copied newCode |	newOthers := newList asOrderedCollection "copy".	oldOthers := oldList asOrderedCollection "copy".	copied := OrderedCollection new.	newList do: [:instVar |		(oldList includes: instVar) ifTrue: [			instVar isInteger ifFalse: [copied add: instVar].			newOthers remove: instVar.			oldOthers remove: instVar]].	code := WriteStream on: (String new: 500).	code cr; cr; tab; nextPutAll: '"From ', SystemVersion current version, ' [', SmalltalkImage current lastUpdateString;			nextPutAll: '] on ', Date today printString, '"'; cr.	code tab; nextPutAll: '"These variables are automatically stored into the new instance: '.	code nextPutAll: copied asArray printString; nextPut: $.; cr.	code tab; nextPutAll: 'Test for this particular conversion.'; 		nextPutAll: '  Get values using expressions like (varDict at: ''foo'')."'; cr; cr.	(newOthers size = 0) & (oldOthers size = 0) & (oldName == nil) ifTrue: [^ self].		"Instance variables are the same.  Only the order changed.  No conversion needed."	(newOthers size > 0) ifTrue: [		code tab; nextPutAll: '"New variables: ', newOthers asArray printString, 			'.  If a non-nil value is needed, please assign it."'; cr].	(oldOthers size > 0) ifTrue: [		code tab; nextPutAll: '"These are going away ', oldOthers asArray printString, 			'.  Possibly store their info in some other variable?"'; cr].	oldName ifNotNil: [		code tab; nextPutAll: '"Test for instances of class ', oldName, '.'; cr.		code tab; nextPutAll: 'Instance vars with the same name have been moved here."'; cr.		].	code tab; nextPutAll: '"Move your code above the ^ super...  Delete extra comments."'; cr. 	(newClass includesSelector: #convertToCurrentVersion:refStream:) 		ifTrue: ["append to old methods"			newCode := (newClass sourceCodeAt: #convertToCurrentVersion:refStream:),				code contents]		ifFalse: ["new method"			newCode := 'convertToCurrentVersion: varDict refStream: smartRefStrm',				code contents, 				'	^ super convertToCurrentVersion: varDict refStream: smartRefStrm'].	newClass compile: newCode classified: 'object fileIn'.	"If you write a conversion method beware that the class may need a version number change.  This only happens when two conversion methods in the same class have the same selector name.  (A) The inst var lists of the new and old versions intials as some older set of new and old inst var lists.  or (B) Twice in a row, the class needs a conversion method, but the inst vars stay the same the whole time.  (For an internal format change.)	If either is the case, fileouts already written with the old (wrong) version number, say 2.  Your method must be able to read files that say version 2 but are really 3, until you expunge the erroneous version 2 files from the universe." ! !!Preference methodsFor: 'user interface' stamp: 'hpt 9/26/2004 15:40'!viewRegistry: aRegistry	viewRegistry := aRegistry! !!Project methodsFor: 'file in/out' stamp: 'mir 8/8/2001 17:58'!urlForLoading	"compose a url that will load me in someone's browser"	| myServer serverList myUrl downloadUrl |	serverList := self serverList.	serverList isEmptyOrNil		ifTrue: [			urlList isEmptyOrNil ifTrue: [^nil].			downloadUrl := urlList first asUrl downloadUrl]		ifFalse: [			myServer := serverList first.			myUrl := myServer altUrl.			myUrl last == $/				ifFalse: [myUrl := myUrl , '/'].			downloadUrl := myUrl].	^downloadUrl , (self name, FileDirectory dot,'html') encodeForHTTP! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 3/23/2000 11:52'!absorbMethod: selector class: aClass from: aChangeSet	"Absorb into the receiver all the changes for the method in the class in the other change set."	| info |	info := aChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	self atSelector: selector class: aClass put: (info at: selector).! !!Project methodsFor: 'menu messages' stamp: 'RAA 5/10/2001 16:59'!makeThumbnail	"Make a thumbnail image of this project from the Display."	world isMorph ifTrue: [world displayWorldSafely]. "clean pending damage"	viewSize ifNil: [viewSize := Display extent // 8].	thumbnail := Form extent: viewSize depth: Display depth.	(WarpBlt current toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).	InternalThreadNavigationMorph cacheThumbnailFor: self.	^thumbnail! !!DiskProxy methodsFor: 'i/o' stamp: 'yo 11/14/2002 15:23'!comeFullyUpOnReload: smartRefStream	"Internalize myself into a fully alive object after raw loading from a DataStream. (See my class comment.)  DataStream will substitute the object from this eval for the DiskProxy."	| globalObj symbol pr nn arrayIndex |	symbol := globalObjectName.	"See if class is mapped to another name"	(smartRefStream respondsTo: #renamed) ifTrue: [		"If in outPointers in an ImageSegment, remember original class name.  		 See mapClass:installIn:.  Would be lost otherwise."		((thisContext sender sender sender sender sender sender 			sender sender receiver class == ImageSegment) and: [ 		thisContext sender sender sender sender method == 			(DataStream compiledMethodAt: #readArray)]) ifTrue: [				arrayIndex := (thisContext sender sender sender sender) tempAt: 4.					"index var in readArray.  Later safer to find i on stack of context."				smartRefStream renamedConv at: arrayIndex put: symbol].	"save original name"		symbol := smartRefStream renamed at: symbol ifAbsent: [symbol]].	"map"	globalObj := Smalltalk at: symbol ifAbsent: [		preSelector == nil & (constructorSelector = #yourself) ifTrue: [			Transcript cr; show: symbol, ' is undeclared.'.			(Undeclared includesKey: symbol) ifTrue: [^ Undeclared at: symbol].			Undeclared at: symbol put: nil.			^ nil].		^ self error: 'Global "', symbol, '" not found'].	((symbol == #World) and: [Smalltalk isMorphic not]) ifTrue: [		self inform: 'These objects will work better if opened in a Morphic World.Dismiss and reopen all menus.'].	preSelector ifNotNil: [		Symbol hasInterned: preSelector ifTrue: [:selector |			[globalObj := globalObj perform: selector] on: Error do: [:ex |				ex messageText = 'key not found' ifTrue: [^ nil].				^ ex signal]]	].	symbol == #Project ifTrue: [		(constructorSelector = #fromUrl:) ifTrue: [			nn := (constructorArgs first findTokens: '/') last.			nn := (nn findTokens: '.|') first.			pr := Project named: nn. 			^ pr ifNil: [self] ifNotNil: [pr]].		pr := globalObj perform: constructorSelector withArguments: constructorArgs.		^ pr ifNil: [self] ifNotNil: [pr]].	"keep the Proxy if Project does not exist"	constructorSelector ifNil: [^ globalObj].	Symbol hasInterned: constructorSelector ifTrue: [:selector |		[^ globalObj perform: selector withArguments: constructorArgs] on: Error do: [:ex |			ex messageText = 'key not found' ifTrue: [^ nil].			^ ex signal]	].				"args not checked against Renamed"	^ nil 	"was not in proper form"! !!PluginHTTPDownloadRequest methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:21'!signalAbort	fileStream ifNotNil: [		fileStream close].	fileStream := nil.	super signalAbort.! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/24/2000 09:46'!methodChangeTypes	"Return an old-style dictionary of method change types."	| dict selector record |	dict := IdentityDictionary new.	methodChanges associationsDo:		[:assn | selector := assn key.  record := assn value.		dict at: selector put: record changeType].	^ dict! !!ClassChangeRecord methodsFor: 'rename' stamp: 'di 5/8/2000 20:39'!noteNewName: newName	thisName := newName! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 2/8/2000 13:34'!copyFromRootsLocalFileFor: rootArray sizeHint: segSize	"If the roots include a World, add its Player classes to the roots."	| newRoots |	arrayOfRoots := rootArray.	[(newRoots := self rootsIncludingPlayers) == nil] whileFalse: [		arrayOfRoots := newRoots].		"world, presenter, and all Player classes"	Smalltalk forgetDoIts.  	self copyFromRoots: arrayOfRoots sizeHint: segSize.! !!Preference methodsFor: 'initialization' stamp: 'sw 4/29/2001 23:51'!categoryList: aList	"Set the receiver's categoryList"	categoryList := aList! !!SystemVersion class methodsFor: 'instance creation' stamp: 'mir 3/29/2001 18:06'!newVersion: versionName	| newVersion |	newVersion := self new version: versionName.	newVersion		highestUpdate: self current highestUpdate.	Current := newVersion! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:24'!existingOrNewChangeSetNamed: aName	| newSet |	^(self named: aName) ifNil: [		newSet := self basicNewNamed: aName.		AllChangeSets add: newSet.		newSet	]! !!SystemNavigation methodsFor: 'query' stamp: 'yo 7/16/2003 14:19'!allUnimplementedNonPrimitiveCalls	"Answer an Array of each message that is sent by an expression in a  	method but is not implemented by any object in the system."	| aStream secondStream all meth |	all := self systemNavigation allImplementedMessages.	aStream := WriteStream				on: (Array new: 50).	Cursor execute		showWhile: [self systemNavigation				allBehaviorsDo: [:cl | cl						selectorsDo: [:sel | 							secondStream := WriteStream										on: (String new: 5).							meth := cl compiledMethodAt: sel.							meth primitive = 0 ifTrue: [								meth messages									do: [:m | (all includes: m)											ifFalse: [secondStream nextPutAll: m;													 space]].								secondStream position = 0									ifFalse: [aStream nextPut: cl name , ' ' , sel , ' calls: ' , secondStream contents]]]]].	^ aStream contents! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 13:07'!allUnreferencedClassVariablesOf: aClass	"Answer a list of the names of all the receiver's unreferenced class  	vars, including those defined in superclasses"	| aList |	aList := OrderedCollection new.	aClass withAllSuperclasses		reverseDo: [:aSuperClass | aSuperClass classVarNames				do: [:var | (self allCallsOn: (aSuperClass classPool associationAt: var)) isEmpty						ifTrue: [aList add: var]]].	^ aList! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:13'!noHeader	"Signal that we've already dealt with the version and structure array, and are now reading objects."	topCall := #marked.! !!HTTPClient class methodsFor: 'class initialization' stamp: 'mir 4/2/2002 15:36'!browserSupportsAPI: aBoolean	BrowserSupportsAPI := aBoolean! !!MethodReference methodsFor: 'queries' stamp: 'md 8/27/2005 17:17'!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	methodSymbol isDoIt ifTrue: [^ false].	(aClass := self actualClass) ifNil: [^ false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!Preference methodsFor: 'change notification' stamp: 'sw 4/12/2001 01:39'!changeInformee: informee changeSelector: aSelector	"Set the changeInformee and changeSelector as specified"	changeInformee := informee.	changeSelector := aSelector! !!SystemOrganizer methodsFor: 'query' stamp: 'dtl 8/26/2004 11:23'!uncommentedClassesIn: categoryName	"SystemOrganization uncommentedClassesIn: 'Morphic*'"	| classes |	classes := OrderedCollection new.	self categories withIndexCollect: [:cat :idx |		(categoryName match: cat)			ifTrue: [classes addAll: (self listAtCategoryNumber: idx)]			ifFalse: [nil]].	^ (classes collect: [:clsName | Smalltalk at: clsName]		thenSelect: [:cls | cls hasComment not]) asArray! !!ImageSegment methodsFor: 'statistics' stamp: 'ar 2/21/2001 18:44'!classNameAt: index	| ccIndex |	ccIndex := self compactIndexAt: index.	ccIndex = 0 ifFalse:[^(Smalltalk compactClassesArray at: ccIndex) name].	ccIndex := segment at: index-1.	(ccIndex bitAnd: 16r80000000) = 0 ifTrue:[		"within segment; likely a user object"		^#UserObject].	ccIndex := (ccIndex bitAnd: 16r7FFFFFFF) bitShift: -2.	^(outPointers at: ccIndex) name! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:26'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo := (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | self removeChangeSet: cs].	self inform: toGo size printString, ' change set(s) removed.'! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 15:49'!invokeFrom: otherProject	"Revoke the changes in force for this project, and then invoke those in force for otherProject.  This method shortens the process to the shortest path up then down through the isolation layers."	| pathUp pathDown |	pathUp := otherProject layersToTop.  "Full paths to top"	pathDown := self layersToTop.	"Shorten paths to nearest common ancestor"	[pathUp isEmpty not		and: [pathDown isEmpty not		and: [pathUp last == pathDown last]]]		whileTrue: [pathUp removeLast.  pathDown removeLast].	"Now revoke changes up from otherProject and invoke down to self."	pathUp do: [:p | p revoke].	pathDown reverseDo: [:p | p invoke].! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 10/11/2000 19:12'!exportCodeSegment: exportName classes: aClassList keepSource: keepSources	"Code for writing out a specific category of classes as an external image segment.  Perhaps this should be a method."	| is oldMethods newMethods m oldCodeString argsAndTemps classList symbolHolder fileName |	keepSources		ifTrue: [			self confirm: 'We are going to abandon sources.Quit without saving after this has run.' orCancel: [^self]].	classList := aClassList asArray.	"Strong pointers to symbols"	symbolHolder := Symbol allInstances.	oldMethods := OrderedCollection new: classList size * 150.	newMethods := OrderedCollection new: classList size * 150.	keepSources		ifTrue: [			classList do: [:cl |				cl selectors do:					[:selector |					m := cl compiledMethodAt: selector.					m fileIndex > 0 ifTrue:						[oldCodeString := cl sourceCodeAt: selector.						argsAndTemps := (cl compilerClass new							parse: oldCodeString in: cl notifying: nil) tempNames.						oldMethods addLast: m.						newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	oldMethods := newMethods := m := oldCodeString := argsAndTemps := nil.	Smalltalk garbageCollect.	is := ImageSegment new copyFromRootsForExport: classList.	"Classes and MetaClasses"	fileName := FileDirectory fileName: exportName extension: ImageSegment fileExtension.	is writeForExport: fileName.	self compressFileNamed: fileName! !!CodeLoader methodsFor: 'private' stamp: 'mir 2/2/2001 14:44'!createRequestFor: name in: aLoader	"Create a URL request for the given string, which can be cached locally."	| request |	request := HTTPLoader httpRequestClass for: self baseURL , name in: aLoader.	aLoader addRequest: request. "fetch from URL"	^request! !!Project methodsFor: 'file in/out' stamp: 'mir 6/25/2001 10:55'!url	| firstURL |	"compose my url on the server"	urlList isEmptyOrNil ifTrue: [^''].	firstURL := urlList first.	firstURL isEmpty		ifFalse: [			firstURL last == $/				ifFalse: [firstURL := firstURL, '/']].	^ firstURL, self versionedFileName! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/19/2003 12:15'!browseAllImplementorsOfList: selectorList title: aTitle 	"Create and schedule a message browser on each method that implements 	the message whose selector is in the argument selectorList. For 	example,  	self new browseAllImplementorsOf: #(at:put: size).  	1/16/96 sw: this variant adds the title argument.  	1/24/96 sw: use a SortedCollection  	2/1/96 sw: show normal cursor"	| implementorLists flattenedList |	implementorLists := selectorList				collect: [:each | self allImplementorsOf: each].	flattenedList := SortedCollection new.	implementorLists		do: [:each | flattenedList addAll: each].	Cursor normal show.	^ self browseMessageList: flattenedList name: aTitle! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 5/26/1998 15:09'!moreObjects	"Return true if there appears to be another object following this one on the file."	| byte |	byteStream atEnd ifTrue: [^ false].	"off end of file"	(byte := byteStream peek) ifNil: [^ false].	"off end of file"	byte = 33 "$!! asciiValue" ifTrue: [^ false].	byte = 0 ifTrue: [^ false].	^ byte <= RefTypes size		"between 1 and 16"! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'yo 7/2/2004 13:24'!imageName	"Answer the full path name for the current image."	"SmalltalkImage current imageName"	| str |	str := self primImageName.	^ (FilePath pathName: str isEncoded: true) asSqueakPathName.! !!MczInstaller methodsFor: 'utilities' stamp: 'avi 2/17/2004 02:53'!checkDependencies	| dependencies unmet |	dependencies := (zip membersMatching: 'dependencies/*') 			collect: [:member | self extractInfoFrom: (self parseMember: member)].	unmet := dependencies reject: [:dep |		self versions: Versions anySatisfy: (dep at: #id)].	^ unmet isEmpty or: [		self confirm: (String streamContents: [:s|			s nextPutAll: 'The following dependencies seem to be missing:'; cr.			unmet do: [:each | s nextPutAll: (each at: #name); cr].			s nextPutAll: 'Do you still want to install this package?'])]! !!SystemVersion methodsFor: 'accessing' stamp: ''!highestUpdate: anInteger	highestUpdate := anInteger! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 20:02'!finalHash	"Concatenate the final totals to build the 160-bit integer result."	"Details: If the primitives are supported, the results are in the totals array. Otherwise, they are in the instance variables totalA through totalE."	| r |	totals ifNil: [  "compute final hash when not using primitives"		^ (totalA asInteger bitShift: 128) +		  (totalB asInteger bitShift:  96) +		  (totalC asInteger bitShift:  64) +		  (totalD asInteger bitShift:  32) +		  (totalE asInteger)].	"compute final hash when using primitives"	r := 0.	1 to: 5 do: [:i |		r := r bitOr: ((totals at: i) bitShift: (32 * (5 - i)))].	^ r! !!Preference methodsFor: 'local to project' stamp: 'sw 4/10/2001 11:58'!toggleProjectLocalness	"Toggle whether the preference should be held project-by-project or globally"	localToProject := localToProject not.	PreferencesPanel allInstancesDo:		[:aPanel | aPanel adjustProjectLocalEmphasisFor: name].! !!SystemNavigation methodsFor: 'query' stamp: 'sd 1/16/2004 21:01'!hierarchyOfClassesSurrounding: aClass	"Answer a list of classes in the hierarchy both above and below the given class"	"SystemNavigation default hierarchyOfClassesSurrounding: StringHolder"		| list aClassNonMeta isMeta theClassOrMeta |	aClass ifNil: [^ OrderedCollection new].	aClass ifNil: [^ self].	aClassNonMeta := aClass theNonMetaClass.	isMeta := aClassNonMeta ~~ aClass.	list := OrderedCollection new.	aClass allSuperclasses reverseDo:		[:cl | list addLast: cl].	aClassNonMeta allSubclassesWithLevelDo:		[:cl :level |		theClassOrMeta := isMeta ifTrue: [cl class] ifFalse: [cl].		list addLast: theClassOrMeta]	 	startingLevel: 0.	^ list! !!CodeLoader class methodsFor: 'utilities' stamp: 'ar 2/6/2001 19:17'!verifySignedFileNamed: aFileName	"CodeLoader verifySignedFileNamed: 'signed\dummy1.dsq' "	| secured signedFileStream |	signedFileStream := FileStream fileNamed: aFileName.	secured := SecurityManager default positionToSecureContentsOf: signedFileStream.	signedFileStream close.	Transcript show: aFileName , ' verified: '; show: secured printString; cr.! !!Preferences class methodsFor: 'misc' stamp: 'dgd 9/1/2003 11:43'!themeChoiceButtonOfColor: aColor font: aFont	"Answer a button inviting the user to choose a theme"	| aButton |	aButton := SimpleButtonMorph new target: self; actionSelector: #offerThemesMenu.	aButton label: 'change theme...' translated font: aFont.	aButton color: aColor.	aButton setBalloonText: 'Numerous "Preferences" govern many things about the way Squeak looks and behaves.  Set individual preferences using a "Preferences" panel.  Set an entire "theme" of many Preferences all at the same time by pressing this "change theme" button and choosing a theme to install.  Look in category "themes" in Preferences class to see what each theme does; add your own methods to the "themes" category and they will show up in the list of theme choices.' translated.	^ aButton! !!HTTPDownloadRequest methodsFor: 'accessing' stamp: 'mir 10/7/1999 16:57'!process: aProcess	process := aProcess! !!Project methodsFor: 'file in/out' stamp: 'mir 8/10/2001 17:49'!serverList	| servers server |	"Take my list of server URLs and return a list of ServerDirectories to write on."	urlList isEmptyOrNil ifTrue: [^ nil].	servers := OrderedCollection new.	urlList do: [:url |		server := ServerDirectory serverForURL: url.		server ifNotNil: [servers add: server].		server := ServerDirectory serverForURL: url asUrl downloadUrl.		server ifNotNil: [servers add: server]].	^servers isEmpty		ifTrue: [nil]		ifFalse: [servers]! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 10/17/2000 19:11'!serverDirectoryFromURL: aURLString	| dir |	self flag: #bob.		"need to include swikis in this - hacked for now"	(aURLString findString: '/SuperSwikiProj/') > 0 ifTrue: [		dir := SuperSwikiServer new fullPath: (aURLString copyUpToLast: $/).		^dir	].	^ServerDirectory new fullPath: aURLString! !!AbstractLauncher methodsFor: 'private' stamp: 'mir 9/23/1999 12:09'!parameterAtOneOf: alternateParameterNames	| parameterName |	"Return the parameter named using one of the alternate names or an empty string"	parameterName := self determineParameterNameFrom: alternateParameterNames.	^parameterName isNil		ifTrue: ['']		ifFalse: [self parameterAt: parameterName ifAbsent: ['']]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:40'!forgetAllChangesFoundIn: otherChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner."	otherChangeSet == self ifTrue: [^ self].	otherChangeSet changedClassNames do:		[:className | self forgetChangesForClass: className in: otherChangeSet].	self expungeEmptyClassChangeEntries."  Old code...	aChangeSet changedClassNames do: 		[:className |			(cls := Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges := aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo: [:assoc | 					self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange := self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]].				self noteClassForgotten: className]].	aChangeSet classRemoves do:		[:className | (recorder := changeRecords at: className ifAbsent: [])			ifNotNil: [recorder forgetClassRemoval]].	self expungeEmptyClassChangeEntries"! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 11/21/2001 10:58'!doesMethod: aSelector forClass: aClass bearInitials: initials	"Answer whether a method bears the given initials at the head of its time stamp"	| aTimeStamp implementingClass aMethod |	implementingClass := aClass whichClassIncludesSelector: aSelector.	implementingClass ifNil: [^ false].	(aMethod := implementingClass compiledMethodAt: aSelector)		ifNil: [^ false].	^ (aTimeStamp := self timeStampForMethod: aMethod) notNil and:		[aTimeStamp beginsWith: initials]! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 22:59'!saveTo: aFileName	"| st |	st := SpaceTally new.	st spaceTally: (Array with: TextMorph with: Point).	st saveTo: 'spaceTally2'"	| s |	(FileDirectory default fileExists: aFileName) ifTrue: [		FileDirectory default deleteFileNamed: aFileName].	s := FileDirectory default fileNamed: aFileName.	results do: [:each | s nextPutAll: each analyzedClassName asString ; 						nextPutAll: ' '; nextPutAll: each codeSize printString; 						nextPutAll: ' '; nextPutAll: each instanceCount printString; 						nextPutAll: ' '; nextPutAll: each spaceForInstances printString; cr].	s close! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'md 12/1/2004 23:58'!askForDefault	| menu |	self registeredClasses isEmpty ifTrue:		[self inform: 'There are no ', self appName, ' applications registered.'.		^ default := nil].	self registeredClasses size = 1 ifTrue:		[^ default := self registeredClasses anyOne].		menu := CustomMenu new.	self registeredClasses do: [:c | menu add: c name printString action: c].	default :=  menu startUpWithCaption: 'Which ', self appName, ' would you prefer?'.	default ifNil: [default := self registeredClasses first].	^default.! !!SpaceTally methodsFor: 'class analysis' stamp: 'efc 7/6/2004 00:30'!computeSpaceUsage	| entry c instanceCount |	1 to: results size do: [:i |		entry := results at: i.		c := self class environment at: entry analyzedClassName.		instanceCount := c instanceCount.		entry codeSize: c spaceUsed.		entry instanceCount: instanceCount.		entry spaceForInstances: (self spaceForInstancesOf: c withInstanceCount: instanceCount).		Smalltalk garbageCollectMost].	! !!Project methodsFor: 'menu messages' stamp: 'dgd 4/4/2006 16:40'!finalEnterActions	"Perform the final actions necessary as the receiver project is entered"	| navigator armsLengthCmd navType thingsToUnhibernate fixBlock |	self projectParameters 		at: #projectsToBeDeleted 		ifPresent: [ :projectsToBeDeleted |			self removeParameter: #projectsToBeDeleted.			projectsToBeDeleted do: [ :each | 				Project deletingProject: each.				each removeChangeSetIfPossible]].	Locale switchAndInstallFontToID: self localeID.	thingsToUnhibernate := world valueOfProperty: #thingsToUnhibernate ifAbsent: [#()].	(thingsToUnhibernate anySatisfy:[:each| 		each isMorph and:[each hasProperty: #needsLayoutFixed]]) 			ifTrue:[fixBlock := self displayFontProgress].	thingsToUnhibernate do: [:each | each unhibernate].	world removeProperty: #thingsToUnhibernate.	fixBlock ifNotNil:[		fixBlock value.		world fullRepaintNeeded.	].	navType := ProjectNavigationMorph preferredNavigator.	armsLengthCmd := self parameterAt: #armsLengthCmd ifAbsent: [nil].	navigator := world findA: navType.	(Preferences classicNavigatorEnabled and: [Preferences showProjectNavigator and: [navigator isNil]]) ifTrue:		[(navigator := navType new)			bottomLeft: world bottomLeft;			openInWorld: world].	navigator notNil & armsLengthCmd notNil ifTrue:		[navigator color: Color lightBlue].	armsLengthCmd notNil ifTrue:		[Preferences showFlapsWhenPublishing			ifFalse:				[self flapsSuppressed: true.				navigator ifNotNil:	[navigator visible: false]].		armsLengthCmd openInWorld: world].	Smalltalk isMorphic ifTrue:		[world reformulateUpdatingMenus.		world presenter positionStandardPlayer.		self assureMainDockingBarPresenceMatchesPreference].	WorldState addDeferredUIMessage: [self startResourceLoading].! !!SystemNavigation methodsFor: 'query' stamp: 'nk 7/3/2003 19:49'!allPrimitiveMethodsInCategories: aList 	"Answer an OrderedCollection of all the methods that are implemented by 	primitives in the given categories. 1/26/96 sw"	"SystemNavigation new allPrimitiveMethodsInCategories:  	#('Collections-Streams' 'Files-Streams' 'Files-Abstract' 'Files-Macintosh')"	| aColl method |	aColl := OrderedCollection new: 200.	Cursor execute		showWhile: [self				allBehaviorsDo: [:aClass | (aList includes: (SystemOrganization categoryOfElement: aClass theNonMetaClass name asString) asString)						ifTrue: [aClass								selectorsDo: [:sel | 									method := aClass compiledMethodAt: sel.									method primitive ~= 0										ifTrue: [aColl addLast: aClass name , ' ' , sel , ' ' , method primitive printString]]]]].	^ aColl! !!MessageTally methodsFor: 'collecting leaves' stamp: ''!leavesInto: leafDict fromSender: senderTally	| rcvrs |	rcvrs := self sonsOver: 0.	rcvrs size = 0		ifTrue: [self into: leafDict fromSender: senderTally]		ifFalse: [rcvrs do:				[:node |				node isPrimitives					ifTrue: [node leavesInto: leafDict fromSender: senderTally]					ifFalse: [node leavesInto: leafDict fromSender: self]]]! !!Project class methodsFor: 'utilities' stamp: 'jla 4/2/2001 15:57'!jumpToSelection: selection	"Enter the project corresponding to this menu selection."		"Project jumpToProject"	| nBack prev pr |	selection ifNil: [^ self].	(selection beginsWith: '%back') ifTrue:		[nBack := (selection copyFrom: 6 to: selection size) asNumber.		prev := CurrentProject previousProject.		1 to: nBack-1 do:			[:i | prev ifNotNil: [prev := prev previousProject]].		prev ifNotNil: [prev enter: true revert: false saveForRevert: false]].	selection = #parent ifTrue:		[CurrentProject parent enter: false revert: false saveForRevert: false.		^ self].	(pr := Project namedWithDepth: selection) ifNil: [^ self].	pr enter: false revert: false saveForRevert: false! !!ResourceCollector methodsFor: 'accessing' stamp: 'ar 2/24/2001 22:24'!localDirectory: aDirectory	localDirectory := aDirectory! !!ModifiedEvent methodsFor: 'private-accessing' stamp: 'NS 1/19/2004 15:08'!oldItem: anItem	oldItem := anItem! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'al 1/12/2006 23:56'!classOrTraitNamed: aString 	"aString is either a class or trait name or a class or trait name followed by ' class' or 'classTrait' respectively.	Answer the class or metaclass it names."	| meta baseName baseClass |	(aString endsWith: ' class')		ifTrue: [meta := true.				baseName := aString copyFrom: 1 to: aString size - 6]		ifFalse: [			(aString endsWith: ' classTrait')				ifTrue: [					meta := true.					baseName := aString copyFrom: 1 to: aString size - 11]				ifFalse: [					meta := false.					baseName := aString]].	baseClass := Smalltalk at: baseName asSymbol ifAbsent: [^ nil].	meta		ifTrue: [^ baseClass classSide]		ifFalse: [^ baseClass]! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'nk 9/6/2004 08:22'!valueWithArguments: anArray startingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Error so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Error."	| each answer |	startIndex to: self size do: [:index |		each := self at: index.		each isReceiverOrAnyArgumentGarbage ifFalse: [			[answer := each valueWithArguments: anArray]				on: Halt, Error				do: [:exc | 						self valueWithArguments: anArray startingFrom: index + 1.						exc pass]]].	^ answer! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 23:03'!printSpaceAnalysis: threshold on: fileName	"SpaceTally new printSpaceAnalysis: 1000 on: 'STspace.text1'"	"sd-This method should be rewrote to be more coherent within the rest of the class 	ie using preAllocate and spaceForInstanceOf:"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace := totalInstCount := totalInstSpace := n := 0.	results := OrderedCollection new: Smalltalk classNames size.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during: [:bar |	Smalltalk allClassesDo:		[:cl | codeSpace := cl spaceUsed.		bar value: (n := n+1).		Smalltalk garbageCollectMost.		instCount := cl instanceCount.		instSpace := (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize := cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace := instSpace + (x basicSize*eltSize)]]			ifFalse: [instSpace := instSpace + (cl instSize*instCount*4)].		results add: (SpaceTallyItem analyzedClassName: cl name codeSize: codeSpace instanceCount:  instCount spaceForInstances: instSpace).		totalCodeSpace := totalCodeSpace + codeSpace.		totalInstCount := totalInstCount + instCount.		totalInstSpace := totalInstSpace + instSpace]].	totalPercent := 0.0.	f := FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		results := (results select: [:s | s instanceCount >= threshold or: [s spaceForInstances > (totalInstSpace // 500)]])				asSortedCollection: [:s :s2 | s spaceForInstances > s2 spaceForInstances]].	results do:		[:s | f nextPutAll: (s analyzedClassName padded: #right to: 30 with: $ );			nextPutAll: (s codeSize printString padded: #left to: 12 with: $ );			nextPutAll: (s instanceCount printString padded: #left to: 12 with: $ );			nextPutAll: (s spaceForInstances printString padded: #left to: 14 with: $ ).		percent := s spaceForInstances*100.0/totalInstSpace roundTo: 0.1.		totalPercent := totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ );		nextPutAll: ((totalPercent roundTo: 0.1) printString padded: #left to: 8 with: $ ).	f close! !!Project class methodsFor: 'utilities' stamp: 'tk 10/26/1999 14:25'!advanceToNextProject	| nextProj |	(nextProj := CurrentProject nextProject) ifNotNil:		 [nextProj enter: true revert: false saveForRevert: false]! !!Utilities class methodsFor: 'fetching updates' stamp: 'mir 4/2/2001 16:34'!position: updateStrm atVersion: version	"Set the stream to the end of the last line of updates names for this version.  Usually the end of the file.  We will add a new update name.   Return the contents of the rest of the file."	| char foundIt where data |	updateStrm reset; ascii.	foundIt := false.	[char := updateStrm next.	 updateStrm atEnd] whileFalse: [		(char == Character cr or: [char == Character lf]) ifTrue: [			updateStrm peek == $# ifTrue: [				foundIt ifTrue: ["Next section"					where := updateStrm position.					data := updateStrm upTo: (255 asCharacter).					updateStrm position: where.					^ data].	"won't be found -- copy all the way to the end"				updateStrm next.				(updateStrm nextMatchAll: version) ifTrue: [					(updateStrm atEnd or: [(updateStrm peek = Character cr) | 						(updateStrm peek = Character lf)]) ifTrue: [							foundIt := true					]]]]].	foundIt ifTrue: [		updateStrm setToEnd.		^ ''].	self error: 'The current version does not have a section in the Updates file'.! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 2/14/2000 16:47'!signFiles: fileNames in: dirName key: privateKey	"Sign the files in the current directory and put them into a folder signed."	|  newNames oldNames |	oldNames := fileNames collect:[:fileName | dirName , FileDirectory slash, fileName].	newNames := fileNames collect:[:fileName | dirName , FileDirectory slash, 'signed', FileDirectory slash, fileName].	CodeLoader		signFilesFrom: oldNames		to: newNames		key: privateKey! !!ChangeSet class methodsFor: 'class initialization' stamp: 'ar 7/15/2005 21:12'!initialize	"ChangeSet initialize"	AllChangeSets == nil ifTrue:		[AllChangeSets := OrderedCollection new].	self gatherChangeSets.	FileServices registerFileReader: self.! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!printSenderCountsOn: aStream	| mergedSenders mergedNode |	mergedSenders := IdentityDictionary new.	senders do:		[:node |		mergedNode := mergedSenders at: node method ifAbsent: [nil].		mergedNode == nil			ifTrue: [mergedSenders at: node method put: node]			ifFalse: [mergedNode bump: node tally]].	mergedSenders asSortedCollection do:		[:node | 		10 to: node tally printString size by: -1 do: [:i | aStream space].		node printOn: aStream total: tally totalTime: nil tallyExact: true]! !!SecurityManager methodsFor: 'security operations' stamp: 'sd 1/30/2004 15:22'!fileInObjectAndCode: aStream	| trusted |	trusted := self positionToSecureContentsOf: aStream.	trusted ifFalse:[self enterRestrictedMode ifFalse:[		aStream close.		^nil]].	^aStream fileInObjectAndCode! !!Utilities class methodsFor: 'fetching updates' stamp: 'laza 8/28/2005 04:55'!retrieveUrls: urls ontoQueue: queue withWaitSema: waitSema 	"download the given list of URLs. The queue will be loaded alternately  	with url's and with the retrieved contents. If a download fails, the  	contents will be #failed. If all goes well, a special pair with an empty  	URL and the contents #finished will be put on the queue. waitSema is  	waited on every time before a new document is downloaded; this keeps 	the downloader from getting too far  ahead of the main process"	"kill the existing downloader if there is one"	| doc canPeek front updateCounter |	UpdateDownloader		ifNotNil: [UpdateDownloader terminate].	updateCounter := 0.	"fork a new downloading process"	UpdateDownloader := [		'Downloading updates' displayProgressAt: Sensor cursorPoint from: 0 to: urls size during: [:bar |			urls				do: [:url | 					waitSema wait.					queue nextPut: url.					doc := HTTPClient httpGet: url.					doc isString						ifTrue: [queue nextPut: #failed.							UpdateDownloader := nil.							Processor activeProcess terminate]						ifFalse: [canPeek := 120 min: doc size.							front := doc next: canPeek.  doc skip: -1 * canPeek.							(front beginsWith: '<!!DOCTYPE') ifTrue: [								(front includesSubString: 'Not Found') ifTrue: [									queue nextPut: #failed.									UpdateDownloader := nil.									Processor activeProcess terminate]]].						UpdateDownloader ifNotNil: [queue nextPut: doc. updateCounter := updateCounter + 1. bar value: updateCounter]]].			queue nextPut: ''.			queue nextPut: #finished.			UpdateDownloader := nil] newProcess.	UpdateDownloader priority: Processor userInterruptPriority.	"start the process running"	UpdateDownloader resume! !!HTTPLoader methodsFor: 'initialize/release' stamp: 'mir 10/7/1999 18:14'!initialize	requests := SharedQueue new.	downloads := OrderedCollection new! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/23/2000 08:40'!projectChangeSet	| pr |	"The changeSet of the project we are writing"	(pr := self project) ifNil: [^ nil].	^ pr projectChangeSet! !!Utilities class methodsFor: 'common requests' stamp: 'sw 12/12/96'!commonRequestStrings: aString	"Initialize the common request strings from aString.  "	CommonRequestStrings := StringHolder new contents: aString! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 15:11'!scanFile: file category: cat class: class meta: meta stamp: stamp	| itemPosition method items |	items := OrderedCollection new.	[itemPosition := file position.	method := file nextChunk.	file skipStyleChunk.	method size > 0] whileTrue:[		items add: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: cat meta: meta stamp: stamp)].	^items! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/24/1998 13:41'!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize := string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[ stringSize < 3 				ifTrue:[(string at: 1) asInteger +						((string at: string size) asInteger bitShift: 8)]				ifFalse:[	(string at: 1) asInteger +						((string at: stringSize // 3 + 1) asInteger bitShift: 4) +						((string at: stringSize // 2 + 1) asInteger bitShift: 8) +						((string at: stringSize * 2 // 3 + 1) asInteger bitShift: 12) +						((string at: stringSize) asInteger bitShift: 16)]]] fixTemps! !!ImageSegment methodsFor: 'testing' stamp: 'ar 9/14/2000 16:47'!findOwnerMap: morphs	| st |	"Construct a string that has a printout of the owner chain for every morph in the list.  Need it as a string so not hold onto them."st := ''.morphs do: [:mm |	(st includesSubString: mm printString) ifFalse: [		st := st, '', mm allOwners printString]].Smalltalk at: #Owners put: st.! !!HTTPClient class methodsFor: 'utilities' stamp: 'mir 5/13/2003 10:43'!getDirectoryListing: dirListURL	"HTTPClient getDirectoryListing: 'http://www.squeakalpha.org/uploads' "	| answer ftpEntries |"	answer := self 		httpPostDocument: dirListURL		args: Dictionary new."	"Workaround for Mac IE problem"	answer := self httpGetDocument: dirListURL.	answer isString		ifTrue: [^self error: 'Listing failed: ' , answer]		ifFalse: [answer := answer content].	answer first == $<		ifTrue: [self error: 'Listing failed: ' , answer].	ftpEntries := answer findTokens: String crlf.	^ ftpEntries 		collect:[:ftpEntry | ServerDirectory parseFTPEntry: ftpEntry]		thenSelect: [:entry | entry notNil]! !!SystemNavigation methodsFor: 'browse' stamp: 'ar 9/27/2005 20:34'!browseMethodsWhoseNamesContain: aString	"Launch a tool which shows all methods whose names contain the given string; case-insensitive.Â·	1/16/1996 sw, at the dawn of Squeak: this was the classic implementation that provided the underpinning for the 'method names containing it' (cmd-shift-W) feature that has always been in Squeak -- the feature that later inspired the MethodFinder (aka SelectorBrowser).Â·	sw 7/27/2001:	Switched to showing a MessageNames tool rather than a message-list browser, if in Morphic."	| aList |	Smalltalk isMorphic		ifFalse:			[aList := Symbol selectorsContaining: aString.			aList size > 0 ifTrue:				[self browseAllImplementorsOfList: aList asSortedCollection title: 'Methods whose names contain ''', aString, '''']]		ifTrue:			[ToolSet browseMessageNames: aString]	! !!ResourceManager class methodsFor: 'resource caching' stamp: 'sd 1/30/2004 15:21'!reloadCachedResources	"ResourceManager reloadCachedResources"	"Reload cached resources from the disk"	| fd files stream url localName storeBack archiveName |	CachedResources := Dictionary new.	LocalizedExternalResources := nil.	fd := Project squeakletDirectory.	files := fd fileNames asSet.	stream := [fd readOnlyFileNamed: self resourceCacheName]				on: FileDoesNotExistException 				do:[:ex| fd forceNewFileNamed: self resourceCacheName].	stream size < 50000 ifTrue:[stream := ReadStream on: stream contentsOfEntireFile].	storeBack := false.	[stream atEnd] whileFalse:[		url := stream upTo: Character cr.			localName := stream upTo: Character cr.		(localName beginsWith: 'zip://') ifTrue:[			archiveName := localName copyFrom: 7 to: localName size.			(files includes: archiveName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true].		] ifFalse:[			(files includes: localName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true]		].	].	stream close.	storeBack ifTrue:[		stream := fd forceNewFileNamed: self resourceCacheName.		CachedResources keysAndValuesDo:[:urlString :cacheLocs|			cacheLocs do:[:cacheLoc|				stream nextPutAll: urlString; cr.				stream nextPutAll: cacheLoc; cr].		].		stream close.	].! !!MessageTally methodsFor: 'private' stamp: ''!primitives: anInteger	tally := anInteger.	receivers := nil! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'dgd 4/4/2006 16:42'!maximumUsableAreaInWorld: aWorldOrNil	| allowedArea |	allowedArea := Display usableArea.	aWorldOrNil ifNotNil: [		allowedArea := allowedArea intersect: aWorldOrNil visibleClearArea.	].	^allowedArea! !!ReferenceStream methodsFor: 'writing' stamp: 'jhm 11/15/92'!nextPutWeak: anObject    "Write a weak reference to anObject to the receiver stream. Answer anObject.     If anObject is not a reference type of object, then just put it normally.     A 'weak' reference means: If anObject gets written this stream via nextPut:,     then its weak references will become normal references. Otherwise they'll     read back as nil. -- "    | typeID referencePosn |    "Is it a reference type of object? If not, just write it normally."    typeID := self typeIDFor: anObject.    (self isAReferenceType: typeID) ifFalse: [^ self nextPut: anObject].    "Have we heard of and maybe even written anObject before?"    referencePosn := references at: anObject ifAbsent: [			references at: anObject put: OrderedCollection new].    "If referencePosn is an Integer, it's the stream position of anObject.     Else it's a collection of hopeful weak-references to anObject."    referencePosn isInteger ifFalse:        [referencePosn add: byteStream position - basePos.		"relative"        referencePosn := self vacantRef].    self outputReference: referencePosn.		"relative"    ^ anObject! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:35'!fileIntoNewChangeSet: fullName	"File in all of the contents of the currently selected file, if any, into a new change set." 	| fn ff |	fullName ifNil: [^ Beeper beep].	ff := FileStream readOnlyFileNamed: (fn := GZipReadStream uncompressedFileName: fullName).	ChangeSet newChangesFromStream: ff named: (FileDirectory localNameFor: fn)! !!ImageSegmentRootStub class methodsFor: 'settings' stamp: 'di 2/11/2000 12:31'!startLoggingFaults  "ImageSegmentRootStub startLoggingFaults"	FaultLogs := Dictionary new.	LoggingFaults := true.! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 9/27/2000 11:36'!insideASegment: aBoolean	insideASegment := aBoolean! !!Project class methodsFor: 'class initialization' stamp: 'RAA 12/17/2000 12:37'!rebuildAllProjects	"Project rebuildAllProjects"	AllProjects := nil.	self allProjects.! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 12/3/2001 13:14'!renameCachedResource: urlString to: newUrlString external: isExternal	"A project was renamed. Reflect this change by duplicating the cache entry to the new url."	| candidates |	CachedResources		ifNil:[			isExternal				ifTrue: [self resourceCache "force init" ]				ifFalse: [^self]].	candidates := CachedResources at: urlString ifAbsent:[nil].	(candidates isNil or:[candidates size = 0])		ifFalse: [		candidates do: [:candidate |			self addCacheLocation: candidate for: newUrlString]].	isExternal		ifTrue: [self relocatedExternalResource: urlString to: newUrlString]! !!SmartRefStream class methodsFor: 'initialize-release' stamp: 'dvf 8/23/2003 12:18'!cleanUpCategories	| list valid removed newList newVers |	"Look for all conversion methods that can't be used any longer.  Delete them."	" SmartRefStream cleanUpCategories "	"Two part selectors that begin with convert and end with a digit."	"convertasossfe0: varDict asossfeu0: smartRefStrm"	list := Symbol selectorsContaining: 'convert'.	list := list select: [:symb | (symb beginsWith: 'convert') & (symb allButLast last isDigit)				ifTrue: [(symb numArgs = 2)]				ifFalse: [false]].	valid := 0.  removed := 0.	list do: [:symb |		(self systemNavigation allClassesImplementing: symb) do: [:newClass |			newList := (Array with: newClass classVersion), (newClass allInstVarNames).			newVers := self new versionSymbol: newList.			(symb endsWith: (':',newVers,':')) 				ifFalse: [					"method is useless because can't convert to current shape"					newClass removeSelector: symb.	"get rid of it"					removed := removed + 1]				ifTrue: [valid := valid + 1]]].	Transcript cr; show: 'Removed: '; print: removed; 		show: '		Kept: '; print: valid; show: ' '.! !!ReferenceStream methodsFor: 'reading' stamp: 'RAA 1/18/2001 16:46'!next	"Answer the next object in the stream.  If this object was already read, don't re-read it.  File is positioned just before the object."	| curPosn skipToPosn haveIt theObject wasSkipping |	haveIt := true.	curPosn := byteStream position - basePos.	theObject := objects at: curPosn ifAbsent: [haveIt := false].		"probe in objects is done twice when coming from objectAt:.  This is OK."	skipToPosn := fwdRefEnds at: curPosn ifAbsent: [nil].	haveIt ifFalse: [ ^ super next].	skipToPosn ifNotNil: [		"Skip over the object and return the already-read-in value."		byteStream position: skipToPosn + basePos		"make absolute"	] ifNil: [		"File is not positioned correctly.  Read object and throw it away."		wasSkipping := skipping includes: curPosn.		skipping add: curPosn.		"fake :=" super next.		wasSkipping ifFalse: [skipping remove: curPosn ifAbsent: []].	].	^ theObject		! !!SmartRefStream class methodsFor: 'utilities' stamp: 'tk 5/4/1998 17:34'!tallyOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats are simply the number of instances of each class:	1450->Point   835->Rectangle   549->Array   300->String"	| dummy bag |	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	bag := Bag new.	dummy references keysDo: [:key | bag add: key class name].	"(bag sortedCounts) is the SortedCollection"	(StringHolder new contents: bag sortedCounts printString) 		openLabel: 'ReferenceStream statistics'.! !!ProjectLauncher methodsFor: 'eToy login' stamp: 'ar 9/5/2001 16:32'!doEtoyLogin	"Pop up the eToy login if we have a server that provides us with a known user list"	"Find us a server who could do eToy authentification for us"	eToyAuthentificationServer := 		(ServerDirectory localProjectDirectories, ServerDirectory servers values)			detect:[:any| any hasEToyUserList]			ifNone:[nil].	eToyAuthentificationServer "no server provides user information"		ifNil:[^self startUpAfterLogin].	self prepareForLogin.	EtoyLoginMorph 		loginAndDo:[:userName| self loginAs: userName]		ifCanceled:[self cancelLogin].! !!ResourceManager methodsFor: 'private' stamp: 'yo 1/12/2004 22:54'!fixJISX0208Resource	| keys value url |	keys := resourceMap keys.	keys do: [:key |		value := resourceMap at: key.		url := key urlString copy.		url isOctetString not ifTrue: [url mutateJISX0208StringToUnicode].		resourceMap removeKey: key.		key urlString: url.		resourceMap at: key put: value.	].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/7/97'!versionSymbol: instVarList	"Create the symbolic code (like a version number) for this class in some older version.  First initials of all the inst vars, followed by the class version number.  Returns a string, caller makes it into a compound selector.  "	| str |	str := instVarList size = 1 ifFalse: [''] ifTrue: ['x'].		"at least one letter"	2 to: instVarList size do: [:ind |		str := str, (instVarList at: ind) first asString].	str := str, instVarList first printString.	"the number"	^ str" | list | list := (Array with: Paragraph classVersion), (Paragraph alistInstVarNames).(SmartRefStream  on: (DummyStream on: nil)) versionSymbol: list"! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/5/2002 09:52'!nextAndClose	"Speedy way to grab one object.  Only use when we are inside an object binary file.  If used for the start of a SmartRefStream mixed code-and-object file, tell the user and then do the right thing."	| obj |	byteStream peek = ReferenceStream versionCode "4" ifFalse: [		"OK it is a fileIn afterall..."		self inform: 'Should be using fileInObjectAndCode'.		byteStream ascii.		byteStream fileIn.		obj := SmartRefStream scannedObject.		SmartRefStream scannedObject: nil.		^ obj].	obj := self next.	self close.	^ obj! !!Preferences class methodsFor: 'get/set' stamp: 'sw 4/12/2001 23:29'!disable: aSymbol	"Shorthand access to enabling a preference of the given name.  If there is none in the image, conjure one up"	| aPreference |	aPreference := self preferenceAt: aSymbol ifAbsent:		[self addPreference: aSymbol category: 'unclassified' default: false balloonHelp: 'this preference was added idiosyncratically and has no help message.'.		self preferenceAt: aSymbol].	aPreference preferenceValue: false! !!PluginHTTPDownloadRequest methodsFor: 'accessing' stamp: 'sd 1/30/2004 15:21'!contents	| |	semaphore wait.	(content isNil and:[fileStream notNil]) ifTrue:["		pos := fileStream position."		fileStream position: 0.		content := MIMEDocument content: fileStream upToEnd.		fileStream close.	].	^content! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 19:06'!superclassOrder: category 	"Answer an OrderedCollection containing references to the classes in the 	category whose name is the argument, category (a string). The classes 	are ordered with superclasses first so they can be filed in."	| behaviors classes |	behaviors := (self listAtCategoryNamed: category asSymbol) 			collect: [:title | Smalltalk at: title].	classes := behaviors select: [:each | each isBehavior].	^ChangeSet superclassOrder: classes! !!ResourceManager class methodsFor: 'resource caching' stamp: 'ar 8/23/2001 17:52'!resourceCache	^CachedResources ifNil:[		CachedResources := Dictionary new.		self reloadCachedResources.		CachedResources].! !!CachingCodeLoader methodsFor: 'accessing' stamp: 'mir 12/22/1999 14:10'!cacheDir: aString	cacheDir := aString.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/19/2000 21:22'!checkCrLf	| save isCrLf cc prev loneLf |	"Watch for a file that has had all of its Cr's converted to CrLf's.  Some unpacking programs like Stuffit 5.0 do this by default!!"	save := byteStream position.	isCrLf := false.  loneLf := false.	cc := 0.	350 timesRepeat: [		prev := cc.		(cc := byteStream next) = 16r0A "Lf" ifTrue: [			prev = 16r0D "Cr" ifTrue: [isCrLf := true] ifFalse: [loneLf := true]].		].	isCrLf & (loneLf not) ifTrue: [		self inform: 'Carriage Returns in this file were converted to CrLfs by an evil unpacking utility.  Please set the preferences in StuffIt Expander to "do not convert file formats"'].	byteStream position: save.! !!MczInstaller class methodsFor: 'versionInfo' stamp: 'avi 1/19/2004 13:13'!clearVersionInfo	Versions := Dictionary new! !!SmalltalkImage methodsFor: 'endian' stamp: 'yo 2/18/2004 18:24'!calcEndianness	| bytes word blt |	"What endian-ness is the current hardware?  The String '1234' will be stored into a machine word.  On BigEndian machines (the Mac), $1 will be the high byte if the word.  On LittleEndian machines (the PC), $4 will be the high byte."	"SmalltalkImage current endianness"	bytes := ByteArray withAll: #(0 0 0 0).  "(1 2 3 4) or (4 3 2 1)"	word := WordArray with: 16r01020304.	blt := (BitBlt toForm: (Form new hackBits: bytes)) 				sourceForm: (Form new hackBits: word).	blt combinationRule: Form over.  "store"	blt sourceY: 0; destY: 0; height: 1; width: 4.	blt sourceX: 0; destX: 0.	blt copyBits.  "paste the word into the bytes"	bytes first = 1 ifTrue: [^ #big].	bytes first = 4 ifTrue: [^ #little].	self error: 'Ted is confused'.! !!Project methodsFor: 'language' stamp: 'dgd 4/4/2006 16:38'!chooseNaturalLanguage	"Put up a menu allowing the user to choose the natural language for the project"	| aMenu availableLanguages |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'choose language' translated.	aMenu lastItem setBalloonText: 'This controls the human language in which tiles should be viewed.  It is potentially extensible to be a true localization mechanism, but initially it only works in the classic tile scripting system.  Each project has its own private language choice' translated.	Preferences noviceMode		ifFalse:[aMenu addStayUpItem].	availableLanguages := NaturalLanguageTranslator availableLanguageLocaleIDs										asSortedCollection:[:x :y | x displayName < y displayName].	availableLanguages do:		[:localeID |			aMenu addUpdating: #stringForLanguageNameIs: target: Locale selector:  #switchAndInstallFontToID: argumentList: {localeID}].	aMenu popUpInWorld"Project current chooseNaturalLanguage"! !!ProjectLauncher methodsFor: 'eToy login' stamp: 'ar 9/5/2001 16:05'!loginAs: userName	"Assuming that we have a valid user url; read its contents and see if the user is really there."	| actualName userList |	eToyAuthentificationServer ifNil:[		self proceedWithLogin.		^true].	userList := eToyAuthentificationServer eToyUserList.	userList ifNil:[		self inform:'Sorry, I cannot find the user list.(this may be due to a network problem)Please hit Cancel if you wish to use Squeak.'.		^false].	"case insensitive search"	actualName  := userList detect:[:any| any sameAs: userName] ifNone:[nil].	actualName isNil ifTrue:[		self inform: 'Unknown user: ',userName.		^false].	Utilities authorName: actualName.	eToyAuthentificationServer eToyUserName: actualName.	self proceedWithLogin.	^true! !!ExternalSettings class methodsFor: 'private' stamp: 'mir 6/25/2001 18:46'!registeredClients	RegisteredClients ifNil: [RegisteredClients := Set new].	^RegisteredClients! !!Project methodsFor: 'accessing' stamp: 'ar 4/19/1999 04:26'!addGuard: anObject	"Add the given object to the list of objects receiving #okayToEnterProject on Project entry"	guards ifNil:[guards := WeakArray with: anObject]			ifNotNil:[guards := guards copyWith: anObject].! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:28'!xOnByte: anInteger	"Set the value of the XOn byte to be used if XOn/XOff flow control is enabled."	xOnByte := anInteger.! !!ExternalDropHandler methodsFor: 'initialize' stamp: 'mir 1/10/2002 17:17'!type: aType extension: anExtension action: anAction 	action := anAction.	type := aType.	extension := anExtension! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 14:58'!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  "	| aString |	aString := self preambleString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!Preferences class methodsFor: 'parameters' stamp: 'sw 2/24/1999 12:26'!acceptAnnotationsFrom: aSystemWindow	"This intricate extraction is based on the precise structure of the annotation-request window.  Kindly avert your eyes."	| aList |	aList := aSystemWindow paneMorphs first firstSubmorph submorphs collect:		[:m |  m contents asSymbol].	self defaultAnnotationRequests: aList	! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:41'!bitAnd: aThirtTwoBitRegister	"Replace my contents with the bitwise AND of the given register and my current contents."	hi := hi bitAnd: aThirtTwoBitRegister hi.	low := low bitAnd: aThirtTwoBitRegister low.! !!ExternalDropHandler class methodsFor: 'private' stamp: 'mir 1/10/2002 15:57'!resetRegisteredHandlers	RegisteredHandlers := nil! !!Preferences class methodsFor: 'halos' stamp: 'sw 1/27/2000 16:45'!installHaloSpecsFromArray: anArray	| aColor |	^ Parameters at: #HaloSpecs put: 		(anArray collect:			[:quin |				aColor := Color.				quin fourth do: [:sel | aColor := aColor perform: sel].				HaloSpec new 					horizontalPlacement: quin second					verticalPlacement: quin third 					color: aColor					iconSymbol: quin fifth					addHandleSelector: quin first])! !!DiskProxy methodsFor: 'initialize-release' stamp: 'tk 11/4/1999 19:28'!global: globalNameSymbol selector: selectorSymbol args: argArray	"Initialize self as a DiskProxy constructor with the given	globalNameSymbol, selectorSymbol, and argument Array.	I will internalize by looking up the global object name in the	SystemDictionary (Smalltalk) and sending it this message with	these arguments."	(globalNameSymbol beginsWith: 'AnObsolete') ifTrue: [		self error: 'Trying to write out, ', globalNameSymbol].	globalObjectName := globalNameSymbol asSymbol.	constructorSelector := selectorSymbol asSymbol.	constructorArgs := argArray.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/21/2002 16:17'!dependentsRestore: aProject	"Retrieve the list of dependents from the exporting system, hook them up, and erase the place we stored them."	| dict |	dict := aProject projectParameterAt: #GlobalDependentsInProject.	dict ifNil: [^ self].	dict associationsDo: [:assoc |		assoc value do: [:dd | assoc key addDependent: dd]].	self dependentsCancel: aProject.! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 23:03'!monthDayTimeStringFrom: aSecondCount	| aDate aTime |	"From the date/time represented by aSecondCount, produce a string which indicates the date and time in the form:		ddMMMhhmmPP	  where:							dd is a two-digit day-of-month,							MMM is the alpha month abbreviation,							hhmm is the time,							PP is either am or pm          Utilities monthDayTimeStringFrom: Time primSecondsClock"	aDate := Date fromSeconds: aSecondCount.	aTime := Time fromSeconds: aSecondCount \\ 86400.	^ (aDate dayOfMonth asTwoCharacterString), 		(aDate monthName copyFrom: 1 to: 3), 		((aTime hours \\ 12) asTwoCharacterString), 		(aTime minutes asTwoCharacterString),		(aTime hours > 12 ifTrue: ['pm'] ifFalse: ['am'])! !!MethodReference methodsFor: 'string version' stamp: 'RAA 5/29/2001 14:44'!stringVersion: aString	stringVersion := aString! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'sw 9/5/97 18:30'!removeClassNamed: aName	"Invoked from fileouts:  if there is currently a class in the system named aName, then remove it.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass := self at: aName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Removal of class named ', aName, ' ignored because ', aName, ' does not exist.'.			^ self].	oldClass removeFromSystem! !!DigitalSignatureAlgorithm class methodsFor: 'class initialization' stamp: 'jm 12/21/1999 19:15'!initialize	"DigitalSignatureAlgorithm initialize"	"SmallPrimes is a list of small primes greater than two."	SmallPrimes := Integer primesUpTo: 2000.	SmallPrimes := SmallPrimes copyFrom: 2 to: SmallPrimes size.	"HighBitOfByte maps a byte to the index of its top non-zero bit."	HighBitOfByte := (0 to: 255) collect: [:byte | byte highBit].! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 11:05'!noteMethodInfoFromRemoval: info	"Store an array with the source index of the last version of the method,	and the category in which it was defined (so it can be put back there if	re-accepted from a version browser)."	infoFromRemoval := info! !!StandardSystemFontsTest methodsFor: 'utilities' stamp: 'bp 6/13/2004 21:51'!saveStandardSystemFontsDuring: aBlock	| standardDefaultTextFont standardListFont standardEToysFont standardMenuFont 	windowTitleFont standardBalloonHelpFont standardCodeFont standardButtonFont |	standardDefaultTextFont := Preferences standardDefaultTextFont.	standardListFont := Preferences standardListFont.	standardEToysFont := Preferences standardEToysFont.	standardMenuFont := Preferences standardMenuFont.	windowTitleFont := Preferences windowTitleFont.	standardBalloonHelpFont := Preferences standardBalloonHelpFont.	standardCodeFont := Preferences standardCodeFont.	standardButtonFont := Preferences standardButtonFont.	[aBlock value] ensure: [		Preferences setSystemFontTo: standardDefaultTextFont.		Preferences setListFontTo: standardListFont.		Preferences setEToysFontTo: standardEToysFont.		Preferences setMenuFontTo: standardMenuFont.		Preferences setWindowTitleFontTo: windowTitleFont.		Preferences setBalloonHelpFontTo: standardBalloonHelpFont.		Preferences setCodeFontTo: standardCodeFont.		Preferences setButtonFontTo: standardButtonFont].! !!ReferenceStream methodsFor: 'writing' stamp: '6/9/97 08:24 tk'!setCurrentReference: refPosn    "PRIVATE -- Set currentReference to refPosn.  Always a relative position."    currentReference := refPosn		"relative position"! !!SmartRefStream methodsFor: 'read write' stamp: 'RAA 12/22/2000 15:14'!restoreClassInstVars	"Install the values of the class instance variables of UniClasses(i.e. scripts slotInfo).  classInstVars is ((#Player25 scripts slotInfo)...).  Thank you Mark Wai for the bug fix."	| normal aName newName newCls trans rList start |	self flag: #bobconv.		self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars"	classInstVars := super next.	"Array of arrays"	normal := Object class instSize.	"might give trouble if Player class superclass changes size"	(structures at: #Player ifAbsent: [#()]) = #(0 'dependents' 'costume') ifTrue:		[trans := 1].	"now (0 costume costumes).  Do the conversion of Player class			inst vars in Update 509."	classInstVars do: [:list |		aName := (list at: 1) asSymbol.		rList := list.		newName := renamed at: aName ifAbsent: [aName].		newCls := Smalltalk at: newName				ifAbsent: [self error: 'UniClass definition missing'].		("old conversion" trans == 1 and: [newCls inheritsFrom: Player]) ifTrue: [			"remove costumeDictionary from Player class inst vars"			rList := rList asOrderedCollection.			rList removeAt: 4].	"costumeDictionary's value"		start := list second = 'Update to read classPool' ifTrue: [4] ifFalse: [2].		newCls class instSize = (normal + (rList size) - start + 1) ifFalse:			[self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		start = 4 ifTrue: [newCls instVarAt: normal - 1 "classPool" put: (list at: 3)].		start to: rList size do: [:ii |			newCls instVarAt: normal + ii - start + 1 put: (rList at: ii)]].! !!AutoStart class methodsFor: 'class initialization' stamp: 'bf 11/23/2004 19:01'!startUp: resuming	"The image is either being newly started (resuming is true), or it's just been snapshotted.	If this has just been a snapshot, skip all the startup stuff."	| startupParameters launchers |	self active ifTrue: [^self].	self active: true.	resuming ifFalse: [^self].	HTTPClient determineIfRunningInBrowser.	startupParameters := AbstractLauncher extractParameters.	(startupParameters includesKey: 'apiSupported' asUppercase )		ifTrue: [			HTTPClient browserSupportsAPI: ((startupParameters at: 'apiSupported' asUppercase) asUppercase = 'TRUE').			HTTPClient isRunningInBrowser				ifFalse: [HTTPClient isRunningInBrowser: true]].	self checkForUpdates		ifTrue: [^self].	self checkForPluginUpdate.	launchers := self installedLaunchers collect: [:launcher |		launcher new].	launchers do: [:launcher |		launcher parameters: startupParameters].	launchers do: [:launcher |		Smalltalk at: #WorldState ifPresent: [ :ws | ws addDeferredUIMessage: [launcher startUp] fixTemps]]! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 11:12'!logOfLargestPowerOfTwoDividing: aPositiveInteger	"Answer the base-2 log of the largest power of two that divides the given integer. For example, the largest power of two that divides 24 is 8, whose log base-2 is 3. Do this efficiently even when the given number is a large integer. Assume that the given integer is > 0."	"DigitalSignatureAlgorithm new largestPowerOfTwoDividing: (32 * 3)"	| digitIndex power d |	digitIndex := (1 to: aPositiveInteger digitLength) detect: [:i | (aPositiveInteger digitAt: i) ~= 0].	power := (digitIndex - 1) * 8.	d := aPositiveInteger digitAt: digitIndex.	[d odd] whileFalse: [		power := power + 1.		d := d bitShift: -1].	^ power! !!Preferences class methodsFor: 'window colors' stamp: 'hpt 10/9/2005 23:28'!windowColorPreferenceForClassNamed: aClassName	| aColorSpec wording |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: aClassName.	wording := aColorSpec ifNil: [aClassName] ifNotNil: [aColorSpec wording].	^(wording, 'WindowColor') asLegalSelector asSymbol.! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 5/23/2001 14:22'!objectStrmFromUpdates: fileName	"Go to the known servers and look for this file in the updates folder.  It is an auxillery file, like .morph or a .gif.  Return a RWBinaryOrTextStream on it.    Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."	| urls doc |	Cursor wait showWhile:		[urls := Utilities serverUrls collect: [:url | url, 'updates/', fileName].		urls do: [:aUrl |			doc := HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.			"test here for server being up"			doc class == RWBinaryOrTextStream ifTrue: [^ doc reset]]].	self inform: 'All update servers are unavailable, or bad file name'.	^ nil! !!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:35'!spyOnProcess: aProcess forMilliseconds: msecDuration 	"| p |  	p := [100000 timesRepeat: [3.14159 printString]] fork.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p forMilliseconds: 1000"	| node |	node := self new.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	(StringHolder new		contents: (String				streamContents: [:s | node report: s;						 close]))		openLabel: 'Spy Results'! !!ProjectLoading class methodsFor: 'accessing' stamp: 'RAA 2/20/2001 20:26'!thumbnailFromUrl: urlString	| fileName fileAndDir |	"Load the project, and make a thumbnail to it in the current project.ProjectLoading thumbnailFromUrl: 'http://www.squeak.org/Squeak2.0/2.7segments/SqueakEasy.extSeg'."	Project canWeLoadAProjectNow ifFalse: [^ self].	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			ProgressNotification signal: '1:foundMostRecent'.			fileName := (urlString findTokens: '/') last.			fileAndDir := self bestAccessToFileName: fileName andDirectory: urlString.			self				openName: fileName 				stream: fileAndDir first 				fromDirectory: fileAndDir second				withProjectView: nil.		]! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'ar 6/3/2005 17:01'!noteNewMethod: newMethod	"NEVER do this. It is evil."	currentMethod := nil.! !!ImageSegment methodsFor: 'access' stamp: 'tk 10/4/1999 17:52'!allObjectsDo: aBlock	"Enumerate all objects that came from this segment.  NOTE this assumes that the segment was created (and extracted).  After the segment has been installed (install), this method allows you to enumerate its objects."	| obj |	endMarker == nil ifTrue: [		^ self error: 'Just extract and install, don''t writeToFile:'].	segment size ~= 1 ifTrue: [		^ self error: 'Vestigial segment size must be 1 (version word)'].	obj := segment nextObject.  "Start with the next object after the vestigial header"	[obj == endMarker] whileFalse:  "Stop at the next object after the full segment"		[aBlock value: obj.		obj := obj nextObject].  "Step through the objects installed from the segment."! !!DataStream methodsFor: 'write and read' stamp: '6/9/97 08:32 tk'!readArray	"PRIVATE -- Read the contents of an Array.	 We must do beginReference: here after instantiating the Array	 but before reading its contents, in case the contents reference	 the Array. beginReference: will be sent again when we return to	 next, but that's ok as long as we save and restore the current	 reference position over recursive calls to next."	| count array refPosn |	count := byteStream nextNumber: 4.	refPosn := self beginReference: (array := Array new: count).		"relative pos"	1 to: count do: [:i |		array at: i put: self next].	self setCurrentReference: refPosn.		"relative pos"	^ array! !!DiskProxy methodsFor: 'initialize-release' stamp: 'tk 4/8/1999 12:58'!global: globalNameSymbol preSelector: aSelector selector: selectorSymbol args: argArray	"Initialize self as a DiskProxy constructor with the given	globalNameSymbol, selectorSymbol, and argument Array.	I will internalize by looking up the global object name in the	SystemDictionary (Smalltalk) and sending it this message with	these arguments."	globalObjectName := globalNameSymbol asSymbol.	preSelector := aSelector asSymbol.	constructorSelector := selectorSymbol asSymbol.	constructorArgs := argArray.! !!SARInstaller methodsFor: 'client services' stamp: 'nk 9/26/2003 17:17'!fileInTrueTypeFontNamed: memberOrName	| member description |	member := self memberNamed: memberOrName.	member ifNil: [^self errorNoSuchMember: memberOrName].	description := TTFontDescription addFromTTStream: member contentStream.	TTCFont newTextStyleFromTT: description.	World doOneCycle.	self installed: member! !!DataStream methodsFor: 'write and read' stamp: 'tk 10/6/2000 14:36'!readMethod	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  "	| instSize refPosn newClass className xxHeader nLits byteCodeSizePlusTrailer newMethod lits |	instSize := (byteStream nextNumber: 4) - 1.	refPosn := self getCurrentReference.	className := self next.	newClass := Smalltalk at: className asSymbol.	xxHeader := self next.		"nArgs := (xxHeader >> 24) bitAnd: 16rF."		"nTemps := (xxHeader >> 18) bitAnd: 16r3F."		"largeBit := (xxHeader >> 17) bitAnd: 1."	nLits := (xxHeader >> 9) bitAnd: 16rFF.		"primBits := ((xxHeader >> 19) bitAnd: 16r600) + (xxHeader bitAnd: 16r1FF)."	byteCodeSizePlusTrailer := instSize - (newClass instSize "0") - (nLits + 1 * 4).	newMethod := newClass 		newMethod: byteCodeSizePlusTrailer		header: xxHeader.	self setCurrentReference: refPosn.  "before readDataFrom:size:"	self beginReference: newMethod.	lits := newMethod numLiterals + 1.	"counting header"	2 to: lits do:		[:ii | newMethod objectAt: ii put: self next].	lits*4+1 to: newMethod basicSize do:		[:ii | newMethod basicAt: ii put: byteStream next].			"Get raw bytes directly from the file"	self setCurrentReference: refPosn.  "before returning to next"	^ newMethod! !!HTTPClient class methodsFor: 'utilities' stamp: 'md 2/24/2006 15:17'!tellAFriend: emailAddressOrNil url: urlForLoading name: projectName	| recipient subject body linkToInclude |	recipient := emailAddressOrNil ifNil: ['RECIPIENT.GOESHERE'].	subject := 'New/Updated Squeak project'.	body := 'This is a link to the Squeak project ' , projectName , ': ' , String crlf.	linkToInclude := urlForLoading.	HTTPClient shouldUsePluginAPI		ifTrue: [			self composeMailTo: recipient subject: subject body: body , (linkToInclude copyReplaceAll: '%' with: '%25')]		ifFalse: [FancyMailComposition new				celeste: nil 				to: recipient				subject: subject				initialText: body				theLinkToInclude: linkToInclude;				open].! !!SystemNavigation methodsFor: 'query' stamp: 'md 7/19/2004 16:03'!unimplemented	"Answer an Array of each message that is sent by an expression in a method but is not implemented by any object in the system."	| all unimplemented entry |	all := IdentitySet new: Symbol instanceCount * 2.	Cursor wait showWhile: 		[self allBehaviorsDo: [:cl | cl selectorsDo: [:aSelector | all add: aSelector]]].	unimplemented := IdentityDictionary new.	Cursor execute showWhile: [		self allBehaviorsDo: [:cl |			 cl selectorsDo: [:sel |				(cl compiledMethodAt: sel) messages do: [:m |					(all includes: m) ifFalse: [						entry := unimplemented at: m ifAbsent: [Array new].						entry := entry copyWith: (cl name, '>', sel).						unimplemented at: m put: entry]]]]].	^ unimplemented! !!Project class methodsFor: 'class initialization' stamp: 'RAA 6/3/2000 18:50'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject := super new initialProject.		Project spawnNewProcessAndTerminateOld: true].	"Project initialize"! !!ChangeRecord methodsFor: 'initialization' stamp: 'nk 11/26/2002 12:07'!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it."	| methodClass s aSelector |	Cursor read showWhile:		[(methodClass := self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil.			(aSelector := self methodSelector) ifNotNil:				[Utilities noteMethodSubmission: aSelector forClass: methodClass]].		(type == #doIt) ifTrue:			[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]].		(type == #classComment) ifTrue:			[ | cls | (cls := Smalltalk at: class asSymbol) comment: self text stamp: stamp.			Utilities noteMethodSubmission: #Comment forClass: cls ]]! !!DataStream methodsFor: 'other' stamp: 'tk 5/29/97'!rootObject: anObject	"Return the object at the root of the tree we are filing out.  "	topCall := anObject! !!SystemNavigation methodsFor: 'query' stamp: 'md 8/27/2005 16:44'!allCallsOn: aLiteral 	"Answer a Collection of all the methods that call on aLiteral even deeply embedded in 	literal array."	"self new browseAllCallsOn: #open:label:."	| aCollection special thorough aList byte |	aCollection := OrderedCollection new.	special := Smalltalk				hasSpecialSelector: aLiteral				ifTrueSetByte: [:b | byte := b].	thorough := (aLiteral isSymbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait		showWhile: [self				allBehaviorsDo: [:class | 					aList := thorough								ifTrue: [class										thoroughWhichSelectorsReferTo: aLiteral										special: special										byte: byte]								ifFalse: [class										whichSelectorsReferTo: aLiteral										special: special										byte: byte].					aList						do: [:sel | sel isDoIt								ifFalse: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'tk 10/24/2001 18:21'!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.  Do this by discovering classes that need a startUp message sent to each instance, and sending it.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object sets receiverClasses inSeg noStartUpNeeded startUps cls msg |	object := segment.	sets := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	noStartUpNeeded := IdentitySet new.	"classes that don't have a per-instance startUp message"	startUps := IdentityDictionary new.	"class -> MessageSend of a startUp message"	inSeg := true.	[object := object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: Set) ifTrue: [sets add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class]].			inSeg ifTrue: [				(noStartUpNeeded includes: object class) ifFalse: [					cls := object class.					(msg := startUps at: cls ifAbsent: [nil]) ifNil: [						msg := cls startUpFrom: self.	"a Message, if we need to swap bytes this time"						msg ifNil: [noStartUpNeeded add: cls]							ifNotNil: [startUps at: cls put: msg]].					msg ifNotNil: [msg sentTo: object]]]]. 		object == 0] whileFalse.	sets do: [:each | each rehash].	"our purpose"	^ receiverClasses	"our secondary job"! !!Utilities class methodsFor: 'graphical support' stamp: 'nk 8/30/2004 08:02'!showFormsDictAcrossTopOfScreen: formDict	"Display the given Dictionary of forms across the top of the screen, wrapping to subsequent lines if needed.  Beneath each, put the name of the associated key."	"Utilities showFormsDictAcrossTopOfScreen: HaloIcons"	| position maxHeight screenBox ceiling elem box h labelWidth keyString |	position := 20.	maxHeight := 0.	ceiling := 0.	screenBox := Display boundingBox.	formDict associationsDo:		[:assoc | (elem := assoc value) displayAt: (position @ ceiling).			box := elem boundingBox.			h := box height.			keyString := (assoc key isString) ifTrue: [assoc key] ifFalse: [assoc key printString].			keyString displayAt: (position @ (ceiling + h)).			labelWidth := TextStyle default defaultFont widthOfString: keyString.			maxHeight := maxHeight max: h.			position := position + (box width max: labelWidth) + 5.			position > (screenBox right - 100) ifTrue:				[position := 20.				ceiling := ceiling + maxHeight + 15.				maxHeight := 0]]! !!Project methodsFor: 'flaps support' stamp: 'sw 4/30/2001 20:42'!globalFlapWithIDEnabledString: aFlapID	"Answer the string to be shown in a menu to represent the status of the given flap regarding whether it it should be shown in this project."	| aFlapTab |	aFlapTab := Flaps globalFlapTabWithID: aFlapID.	^ (self isFlapEnabled: aFlapTab)		ifTrue:			['<on>', aFlapTab wording]		ifFalse:			['<off>', aFlapTab wording]! !!ResourceLocator methodsFor: 'accessing' stamp: 'ar 3/2/2001 18:13'!resourceFileSize: aNumber	fileSize := aNumber! !!SystemVersion methodsFor: 'accessing' stamp: ''!version: newVersion	version := newVersion! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:14'!basicNewChangeSet: newName	| newSet |	newName ifNil: [^ nil].	(self named: newName) ifNotNil:		[self inform: 'Sorry that name is already used'.		^ nil].	newSet := self basicNewNamed: newName.	AllChangeSets add: newSet.	^ newSet! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 15:16'!playNoteOnPort: portNum	"MidiPrimTester new playNoteOnPort: 0"	| noteOn noteOff bytesWritten |	noteOn := #(144 60 100) as: ByteArray.	noteOff := #(144 60 0) as: ByteArray.	self openPort: portNum andDo: [		bytesWritten := self primMIDIWritePort: portNum from: noteOn at: 0.		(Delay forMilliseconds: 500) wait.		bytesWritten := bytesWritten + (self primMIDIWritePort: portNum from: noteOff at: 0)].	bytesWritten = 6 ifFalse: [self error: 'not all bytes were sent'].! !!SARInstaller methodsFor: 'client services' stamp: 'yo 8/17/2004 10:05'!fileInPackageNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as DVS packages."	| member current new baseName imagePackageLoader packageInfo streamPackageLoader packageManager |	member := self zip memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	imagePackageLoader := Smalltalk at: #ImagePackageLoader ifAbsent: [].	streamPackageLoader := Smalltalk at: #StreamPackageLoader ifAbsent: [].	packageInfo := Smalltalk at: #PackageInfo ifAbsent: [].	packageManager := Smalltalk at: #FilePackageManager ifAbsent: [].	"If DVS isn't present, do a simple file-in"	(packageInfo isNil or: [imagePackageLoader isNil or: [streamPackageLoader isNil]])		ifTrue: [ ^ self fileInMemberNamed: memberName ].	baseName := memberName copyReplaceAll: '.st' with: '' asTokens: false.	(packageManager allManagers anySatisfy: [ :pm | pm packageName = baseName ])		ifTrue: [			current := imagePackageLoader new package: (packageInfo named: baseName).			new := streamPackageLoader new stream: member contentStream ascii.			(new changesFromBase: current) fileIn ]		ifFalse: [ self class fileIntoChangeSetNamed: baseName fromStream: member contentStream ascii setConverterForCode. ].	packageManager registerPackage: baseName.	self installed: member.! !!SimpleServiceEntry methodsFor: 'performing service' stamp: 'jrp 7/30/2005 22:35'!buttonToTriggerIn: aFileList	"Answer a button that will trigger the receiver service in a file list"	| aButton |	aButton :=  PluggableButtonMorph					on: self					getState: nil					action: #performServiceFor:.	aButton 		arguments: { aFileList }.	aButton		color: Color transparent;		hResizing: #spaceFill;		vResizing: #spaceFill;		label: self buttonLabel;		askBeforeChanging: true;		onColor: Color white offColor: Color white.		aButton setBalloonText: self description.	^ aButton! !!SpaceTally methodsFor: 'instance size' stamp: 'efc 7/6/2004 00:30'!spaceForInstancesOf: aClass withInstanceCount: instCount	"Answer the number of bytes consumed by all instances of the given class, including their object headers."	| isCompact instVarBytes bytesPerElement contentBytes headerBytes total |	instCount = 0 ifTrue: [^ 0].	isCompact := aClass indexIfCompact > 0.	instVarBytes := aClass instSize * 4.	aClass isVariable		ifTrue: [			bytesPerElement := aClass isBytes ifTrue: [1] ifFalse: [4].			total := 0.			aClass allInstancesDo: [:inst |				contentBytes := instVarBytes + (inst size * bytesPerElement).				headerBytes :=					contentBytes > 255						ifTrue: [12]						ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].				total := total + headerBytes + contentBytes].			^ total]		ifFalse: [			headerBytes :=				instVarBytes > 255					ifTrue: [12]					ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].			^ instCount * (headerBytes + instVarBytes)].! !!SystemVersion methodsFor: 'initialize' stamp: ''!initialize	version := 'No version set'.	date := Date today.	updates := Set new.! !!ChangeRecord methodsFor: 'access' stamp: 'tk 9/7/2000 15:09'!stamp: threePartString	stamp := threePartString! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'yo 7/5/2004 20:22'!fileOutCategory: category asHtml: useHtml	"FileOut all the classes in the named system category."	| internalStream |	internalStream := WriteStream on: (String new: 1000).	self fileOutCategory: category on: internalStream initializing: true.	FileStream writeSourceCodeFrom: internalStream baseName: category isSt: true useHtml: useHtml.! !!Preferences class methodsFor: 'halos' stamp: 'dgd 10/21/2004 12:17'!haloSpecificationsForWorld	| desired |	"Answer a list of HaloSpecs that describe which halos are to be used on a world halo, what they should look like, and where they should be situated"	"Preferences resetHaloSpecifications"	desired := #(addDebugHandle: addMenuHandle: addTileHandle: addViewHandle: addHelpHandle: addScriptHandle: addPaintBgdHandle: addRecolorHandle:).	^ self haloSpecifications select:		[:spec | desired includes: spec addHandleSelector]! !!SmalltalkImage methodsFor: 'system attribute' stamp: 'sd 9/24/2003 11:40'!extractParameters	| pName value index globals |	globals := Dictionary new.	index := 3. "Muss bei 3 starten, da 2 documentName ist"	[pName := self  getSystemAttribute: index.	pName isEmptyOrNil] whileFalse:[		index := index + 1.		value := self getSystemAttribute: index.		value ifNil: [value := '']. 		globals at: pName asUppercase put: value.		index := index + 1].	^globals! !!ProjectLauncher methodsFor: 'initialization' stamp: 'mir 8/23/2002 14:52'!setupFromParameters	(self includesParameter: 'showSplash')		ifTrue: [showSplash := (self parameterAt: 'showSplash') asUppercase = 'TRUE'].	(self includesParameter: 'flaps')		ifTrue: [whichFlaps := (self parameterAt: 'flaps')].! !!ResourceManager class methodsFor: 'private-resources' stamp: 'mir 8/21/2001 16:00'!relocatedExternalResource: urlString to: newUrlString	| originalURL |	originalURL := (self localizedExternalResources includesKey: urlString)		ifTrue: [self localizedExternalResources at: urlString]		ifFalse: [urlString].	self localizedExternalResources at: newUrlString put: originalURL! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/29/2000 20:42'!beIsolationSetFor: aProject	self isEmpty ifFalse: [self error: 'Must be empty at the start.'].	isolatedProject := aProject.	revertable := true.! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 2/16/98 16:16'!lastUpdateNum: updatesFileStrm	"Look in the Updates file and see what the last sequence number is.  Warn the user if the version it is under is not this image's version."	| verIndex seqIndex char ver seqNum |	verIndex := seqIndex := 0.	 "last # starting a line and last digit starting a line"	seqNum := 0.	updatesFileStrm reset; ascii.	[char := updatesFileStrm next.	 updatesFileStrm atEnd] whileFalse: [		char == Character cr ifTrue: [			updatesFileStrm peek == $# ifTrue: [verIndex := updatesFileStrm position +1.				seqIndex = 0 ifFalse: ["See if last num of old version if biggest so far"					updatesFileStrm position: seqIndex.					ver := SmallInteger readFrom: updatesFileStrm.					seqNum := seqNum max: ver.					updatesFileStrm position: verIndex-1]].			updatesFileStrm peek isDigit ifTrue: [seqIndex := updatesFileStrm position]]].	seqIndex = 0 ifFalse: ["See if last num of old version if biggest so far"		updatesFileStrm position: seqIndex.		ver := SmallInteger readFrom: updatesFileStrm.		seqNum := seqNum max: ver.		updatesFileStrm setToEnd].	^ seqNum! !!Project methodsFor: 'accessing' stamp: ''!renameTo: newName	| oldBase |	newName = self name		ifFalse: [			oldBase := self resourceDirectoryName.			version := nil.			self resourceManager adjustToRename: self resourceDirectoryName from: oldBase.			self changeSet name: newName.			].! !!Utilities class methodsFor: 'durable menus' stamp: 'di 11/27/1999 08:24'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList wordingSelectors: wordingList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse wordingSelector |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld := MVCWiWPasteUpMorph newWorldForProject: nil.	colorList :=  (1 to: labelList size) collect:		[:ind | Color colorFrom: (colorPattern at: (ind \\ colorPattern size + 1))].				pos := 4 @ 6.	delta := 0 @ 30.	rightmost := 0.	1 to: labelList size do:		[:index |			wordingSelector := wordingList at: index.			aButton := wordingSelector				ifNil:					[SimpleButtonMorph new]				ifNotNil:					[UpdatingSimpleButtonMorph new].			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			wordingSelector ifNotNil: [aButton wordingSelector: wordingSelector].			rightmost := rightmost max: aButton right.			pos := pos + delta.			aWorld addMorphBack: aButton].	widthToUse := rightmost + 10.	aWorld startSteppingSubmorphsOf: aWorld.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!Project methodsFor: 'project parameters' stamp: 'sw 4/24/2001 11:58'!initializeProjectParameters	"Initialize the project parameters."	projectParameters := IdentityDictionary new.	^ projectParameters! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:31'!newChangeSet: aName	"Makes a new change set called aName, add author initials to try to	ensure a unique change set name."	| newName |	newName := aName , FileDirectory dot , Utilities authorInitials.	^ self basicNewChangeSet: newName! !!Utilities class methodsFor: 'durable menus' stamp: 'di 11/27/1999 08:23'!windowMenuWithLabels: labelList colorPattern: colorPattern  targets: targetList selections: selectionList title: aTitle	| aWorld colorList  pos delta aButton  rightmost widthToUse |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aWorld := MVCWiWPasteUpMorph newWorldForProject: nil.	colorList :=  (1 to: labelList size) collect:		[:ind | Color colorFrom: (colorPattern at: (ind \\ colorPattern size + 1))].				pos := 4 @ 6.	delta := 0 @ 30.	rightmost := 0.	1 to: labelList size do:		[:index |			aButton := SimpleButtonMorph new.			aButton label: (labelList at: index); 				color: (colorList at: index); 				target: (targetList at: index);				actionSelector: (selectionList at: index);				position: pos.			rightmost := rightmost max: aButton right.			pos := pos + delta.			aWorld addMorphBack: aButton].	widthToUse := rightmost + 10.	aWorld submorphs do:		[:m | m position: (((widthToUse - m width) // 2) @ m position y)].	aWorld setProperty: #initialExtent toValue: (widthToUse @ (aButton bottom + 10)).	aWorld openWithTitle: aTitle cautionOnClose: false! !!Preferences class methodsFor: 'add preferences' stamp: 'rr 10/1/2005 15:14'!addPreference: aName categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol changeSelector: aChangeSelector viewRegistry: aViewRegistry 	"Add or replace a preference as indicated.  Reuses the preexisting Preference object for this symbol, if there is one, so that UI artifacts that interact with it will remain valid."	| aPreference aPrefSymbol |	aPrefSymbol := aName asSymbol.	aPreference := self dictionaryOfPreferences  at:aPrefSymbol				 ifAbsent:[Preference new].	aPreference 		 name:aPrefSymbol		 defaultValue:aValue		 helpString:helpString		 localToProject:localBoolean		 categoryList:categoryList		 changeInformee:informeeSymbol		 changeSelector:aChangeSelector		 viewRegistry:aViewRegistry.	self dictionaryOfPreferences  at:aPrefSymbol  put:aPreference.	self  compileAccessMethodForPreference:aPreference! !!Preferences class methodsFor: 'initialization' stamp: 'rr 10/1/2005 15:14'!removePreference: aSymbol 	"Remove all memory of the given preference symbol in my various structures."	| pref |	pref := self  preferenceAt:aSymbol  ifAbsent:[^ self].	pref localToProject 		 ifTrue:			[Project  allInstancesDo:					[:proj | 					proj projectPreferenceFlagDictionary  ifNotNil:							[proj projectPreferenceFlagDictionary  removeKey:aSymbol  ifAbsent:[]]]].	self dictionaryOfPreferences  removeKey:aSymbol  ifAbsent:[].	self class  removeSelector:aSymbol	"Preferences removePreference: #tileToggleInBrowsers"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/8/1999 12:23'!writeToFile: shortName	"The short name can't have any fileDelimiter characters in it.  It is remembered in case the segment must be brought in and then sent out again (see ClassDescription updateInstancesFrom:)."	segmentName := (shortName endsWith: '.seg')		ifTrue: [shortName copyFrom: 1 to: shortName size - 4]		ifFalse: [shortName].	segmentName last isDigit ifTrue: [segmentName := segmentName, '-'].	self writeToFile.! !!Project class methodsFor: 'instance creation' stamp: 'RAA 11/16/2000 12:07'!new	| new |	new := super new.	new setProjectHolder: CurrentProject.	self addingProject: new.	^new! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:05'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript := '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'di 3/7/2001 01:26'!send: startUpOrShutDown toClassesNamedIn: startUpOrShutDownList with: argument	"Send the message #startUp: or #shutDown: to each class named in the list.	The argument indicates if the system is about to quit (for #shutDown:) or if	the image is resuming (for #startUp:).	If any name cannot be found, then remove it from the list."	| removals class |	removals := OrderedCollection new.	startUpOrShutDownList do:		[:name |		class := self at: name ifAbsent: [nil].		class == nil			ifTrue: [removals add: name]			ifFalse: [class isInMemory ifTrue:						[class perform: startUpOrShutDown with: argument]]].	"Remove any obsolete entries, but after the iteration"	startUpOrShutDownList removeAll: removals! !!Preferences class methodsFor: 'misc' stamp: 'sw 1/4/2001 06:56'!setFlag: prefSymbol toValue: aBoolean during: aBlock	"Set the flag to the given value for the duration of aBlock"	| existing |	existing := self valueOfFlag: prefSymbol.	existing == aBoolean ifFalse: [self setPreference: prefSymbol toValue: aBoolean].	aBlock value.	existing == aBoolean ifFalse: [self setPreference: prefSymbol toValue: existing]! !!Project methodsFor: 'project parameters' stamp: 'sw 2/16/2001 22:23'!projectPreferenceFlagDictionary	"Answer the dictionary that holds the project preferences, creating it if necessary"	^ projectPreferenceFlagDictionary ifNil: [projectPreferenceFlagDictionary := IdentityDictionary new]! !!Preferences class methodsFor: 'preferences panel' stamp: 'md 2/24/2006 15:55'!initializePreferencePanel: aPanel in: aPasteUpMorph	"Initialize the given Preferences panel. in the given pasteup, which is the top-level panel installed in the container window.  Also used to reset it after some change requires reformulation"	| tabbedPalette controlPage aColor aFont maxEntriesPerCategory tabsMorph anExtent  prefObjects cc |	aPasteUpMorph removeAllMorphs.	aFont := StrikeFont familyName: 'NewYork' size: 19.	aColor := aPanel defaultBackgroundColor.	tabbedPalette := TabbedPalette newSticky.	tabbedPalette dropEnabled: false.	(tabsMorph := tabbedPalette tabsMorph) color: aColor darker;		 highlightColor: Color red regularColor: Color brown darker darker.	tabbedPalette on: #mouseDown send: #yourself to: #().	maxEntriesPerCategory := 0.	self listOfCategories do: 		[:aCat | 			controlPage := AlignmentMorph newColumn beSticky color: aColor.			controlPage on: #mouseDown send: #yourself to: #().			controlPage dropEnabled: false.			cc := Color transparent.			controlPage color: cc.			controlPage borderColor: aColor;				 layoutInset: 4.			(prefObjects := self preferenceObjectsInCategory: aCat) do:				[:aPreference | | button |					button := aPreference representativeButtonWithColor: cc inPanel: aPanel.					button ifNotNil: [controlPage addMorphBack: button]].			controlPage setNameTo: aCat asString.			aCat = #?				ifTrue:	[aPanel addHelpItemsTo: controlPage].			tabbedPalette addTabFor: controlPage font: aFont.			aCat = 'search results' ifTrue:				[(tabbedPalette tabNamed: aCat) setBalloonText:					'Use the ? category to find preferences by keyword; the results of your search will show up here'].		maxEntriesPerCategory := maxEntriesPerCategory max: prefObjects size].	tabbedPalette selectTabNamed: '?'.	tabsMorph rowsNoWiderThan: aPasteUpMorph width.	aPasteUpMorph on: #mouseDown send: #yourself to: #().	anExtent := aPasteUpMorph width @ (490 max: (25 + tabsMorph height + (20 * maxEntriesPerCategory))).	aPasteUpMorph extent: anExtent.	aPasteUpMorph color: aColor.	aPasteUpMorph 	 addMorphBack: tabbedPalette.! !!ChangeSet methodsFor: 'converting' stamp: 'RAA 12/20/2000 16:02'!convertApril2000: varDict using: smartRefStrm	| cls info selector pair classChanges methodChanges methodRemoves classRemoves |	"These variables are automatically stored into the new instance:		('name' 'preamble' 'postscript' 'structures' 'superclasses' ).	This method is for additional changes.	It initializes the isolation variables, and then duplicates the logic fo		assimilateAllChangesFoundIn:."	revertable := false.	isolationSet := nil.	isolatedProject := nil.	changeRecords := Dictionary new.	classChanges := varDict at: 'classChanges'.	classChanges keysDo:		[:className |	  	(cls := Smalltalk classNamed: className) ifNotNil:			[info := classChanges at: className ifAbsent: [Set new].			info do: [:each | self atClass: cls add: each]]].	methodChanges := varDict at: 'methodChanges'.	methodRemoves := varDict at: 'methodRemoves'.	methodChanges keysDo:		[:className |	  	(cls := Smalltalk classNamed: className) ifNotNil:			[info := methodChanges at: className ifAbsent: [Dictionary new].			info associationsDo:				[:assoc | selector := assoc key.				(assoc value == #remove or: [assoc value == #addedThenRemoved])					ifTrue:						[assoc value == #addedThenRemoved							ifTrue: [self atSelector: selector class: cls put: #add].						pair := methodRemoves at: {cls name. selector} ifAbsent: [nil] .						self removeSelector: selector class: cls priorMethod: nil lastMethodInfo: pair]					ifFalse: 						[self atSelector: selector class: cls put: assoc value]]]].	classRemoves := varDict at: 'classRemoves'.	classRemoves do:		[:className | self noteRemovalOf: className].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/13/1999 09:19'!segmentName: aString	"Local file name for this segment."	segmentName := aString! !!ResourceCollector methodsFor: 'accessing' stamp: 'mir 6/21/2001 14:51'!resourceDirectory	resourceDirectory ifNil: [resourceDirectory := self baseUrl copyFrom: 1 to: (self baseUrl lastIndexOf: $/)].	^resourceDirectory! !!FileModifyingSimpleServiceEntry methodsFor: 'as yet unclassified' stamp: 'nk 11/26/2002 12:08'!performServiceFor: anObject	| retval |	retval := super performServiceFor: anObject.	self changed: #fileListChanged.	^retval	"is this used anywhere?"! !!Project methodsFor: 'file in/out' stamp: 'ar 3/17/2001 23:57'!storeSegment	"Store my project out on the disk as an ImageSegment.  Keep the outPointers in memory.  Name it <project name>.seg.  *** Caller must be holding (Project alInstances) to keep subprojects from going out. ***"| is sizeHint |(World == world) ifTrue: [^ false]. 	"self inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ false].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.World checkCurrentHandForObjectToPaste.world releaseSqueakPages.sizeHint := self projectParameters at: #segmentSize ifAbsent: [0].is := ImageSegment new copyFromRootsLocalFileFor: 			(Array with: world presenter with: world)	"world, and all Players"		 sizeHint: sizeHint.is state = #tooBig ifTrue: [^ false].is segment size < 2000 ifTrue: ["debugging" 	Transcript show: self name, ' only ', is segment size printString, 		'bytes in Segment.'; cr].self projectParameters at: #segmentSize put: is segment size.is extract; writeToFile: self name.^ true! !!PowerManagement class methodsFor: 'computing' stamp: 'md 10/26/2003 13:07'!itsyVoltage	"On the Itsy, answer the approximate Vcc voltage. The Itsy will shut 	itself down when this value reaches 2.0 volts. This method allows one to 	build a readout of the current battery condition."	| n |	n := SmalltalkImage current getSystemAttribute: 1200.	n		ifNil: [^ 'no voltage attribute'].	^ (n asNumber / 150.0 roundTo: 0.01) asString , ' volts'! !!PreferenceViewRegistry class methodsFor: 'instance creation' stamp: 'hpt 9/26/2004 15:28'!registries	^registries ifNil: [registries := Dictionary new]! !!CodeLoader methodsFor: 'installing' stamp: 'mir 1/20/2000 13:37'!installSegments	"Install the previously loaded segments"	segments == nil ifTrue:[^self].	segments do:[:req| self installSegment: req].	segments := nil.! !!SmalltalkImage methodsFor: 'sources, change log' stamp: 'ar 4/10/2005 18:02'!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aString := aStringOrText asString.	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile := SourceFiles at: 2).	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!ResourceManager class methodsFor: 'private-resources' stamp: 'mir 11/29/2001 16:19'!addCacheLocation: aString for: urlString	| locations |	locations := CachedResources at: urlString ifAbsentPut: [#()].	(locations includes: aString)		ifFalse: [CachedResources at: urlString put: ({aString} , locations)]! !!Preferences class methodsFor: 'window colors' stamp: 'sw 4/21/2002 02:55'!windowColorHelp	"Provide help for the window-color panel"	| helpString |	helpString := 'The "Window Colors" panel lets you select colors for many kinds of standard Squeak windows.You can change your color preference for any particular tool by clicking on the color swatch and then selecting the desired color from the resulting color-picker.The three buttons entitled "Bright", "Pastel", and "White" let you revert to any of three different standard color schemes.  The choices you make in the Window Colors panel only affect the colors of new windows that you open.You can make other tools have their colors governed by this panel by simply implementing #windowColorSpecification on the class side of the model -- consult implementors of that method to see examples of how to do this.'.	 (StringHolder new contents: helpString)		openLabel: 'About Window Colors'	"Preferences windowColorHelp"! !!ImageSegment methodsFor: 'instance change shape' stamp: 'ar 4/10/2005 22:19'!segUpdateInstancesOf: oldClass toBe: newClass isMeta: isMeta	| withSymbols oldInstances segSize |	"Bring me in, locate instances of oldClass and get them converted.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols := state = #onFileWithSymbols.	"If has instances, they point out at the class"	(outPointers includes: oldClass) ifFalse: [		oldClass == SmallInteger ifTrue: [^ self].	"instance not changable"		oldClass == Symbol ifTrue: [^ self].	"instance is never in a segment"		oldClass == ByteSymbol ifTrue: [^ self].	"instance is never in a segment"		(Smalltalk compactClassesArray includes: oldClass) ifFalse: [^ self]].		"For a compact class, must search the segment.  Instance does not 		 point outward to class"	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize := segment size.	self install.	oldInstances := OrderedCollection new.	self allObjectsDo: [:obj | obj class == oldClass ifTrue: [		oldInstances add: obj]].	newClass updateInstances: oldInstances asArray from: oldClass isMeta: isMeta.	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ChangeRecord methodsFor: 'access' stamp: 'sumim 9/2/2003 13:33'!prior	| currFile preamble prevPos tokens prevFileIndex |	currFile := file readOnlyCopy.	currFile position: (0 max: position - 150).	[currFile position < (position - 1)] whileTrue: [preamble := currFile nextChunk].	currFile close.	prevPos := nil.	(preamble findString: 'methodsFor:' startingAt: 1) > 0		ifTrue: [tokens := Scanner new scanTokens: preamble]		ifFalse: [tokens := Array new].	((tokens size between: 7 and: 8)	and: [(tokens at: tokens size - 5) == #methodsFor:]) ifTrue: [		(tokens at: tokens size - 3) == #stamp:		ifTrue: [			prevPos := tokens last.			prevFileIndex := SourceFiles fileIndexFromSourcePointer: prevPos.			prevPos := SourceFiles filePositionFromSourcePointer: prevPos]		ifFalse: [			prevPos := tokens at: tokens size - 2.			prevFileIndex := tokens last].		(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].	prevPos ifNil: [^ nil].	^ {prevFileIndex. prevPos. 		SourceFiles sourcePointerFromFileIndex: prevFileIndex andPosition: prevPos}! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:49'!spawnNewProcess	UIProcess := [		[World doOneCycle.  Processor yield.  false] whileFalse: [].	] newProcess priority: Processor userSchedulingPriority.	UIProcess resume! !!Project methodsFor: 'file in/out' stamp: 'RAA 10/15/2000 19:10'!versionFrom: aServerFile	"Store the version of the file I actually came from.  My stored version was recorded before I knew the latest version number on the server!!"	| theName serverUrl |	self flag: #bob.		"this may become unnecessary once we get the version before writing"	self flag: #bob.		"need to recognize swiki servers"	serverUrl := aServerFile directoryUrl.	theName := aServerFile localName.	version := (Project parseProjectFileName: theName) second.	(serverUrl beginsWith: 'ftp:') ifTrue: ["update our server location"		self storeNewPrimaryURL: serverUrl	].! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/27/2000 22:08'!notePriorDefinition: oldClass	oldClass ifNil: [^ self].	priorDefinition ifNil: [priorDefinition := oldClass definition]! !!ReferenceStream methodsFor: 'reading' stamp: ' 6/9/97'!objectAt: anInteger    "PRIVATE -- Read & return the object at a given stream position.     If we already read it, just get it from the objects dictionary.     (Reading it again wouldn't work with cycles or sharing.)     If not, go read it and put it in the objects dictionary.     NOTE: This resolves a cross-reference in the ReferenceStream:       1. A backward reference to an object already read (the normal case).       2. A forward reference which is a sated weak reference (we record where          the object ends so when we get to it normally we can fetch it from          'objects' and skip over it).       3. A backward reference to a 'non-reference type' per the long NOTE in          nextPut: (we compensate here--seek back to re-read it and add the object          to 'objects' to avoid seeking back to read it any more times).       4. While reading a foward weak reference (case 2), we may recursively hit an          ordinary backward reference to an object that we haven't yet read because          we temporarily skipped ahead. Such a reference is forward in time so we          treat it much like case 2.     11/16-24/92 jhm: Handle forward refs. Cf. class comment and above NOTE.	08:57 tk   anInteger is a relative position"    | savedPosn refPosn anObject |    ^ objects at: anInteger "relative position.  case 1: It's in 'objects'"        ifAbsent:   "do like super objectAt:, but remember the fwd-ref-end position"            [savedPosn := byteStream position.		"absolute"            refPosn := self getCurrentReference.	"relative position"            byteStream position: anInteger + basePos.	"was relative"            anObject := self next.            (self isAReferenceType: (self typeIDFor: anObject))                ifTrue:  [fwdRefEnds at: anInteger put: byteStream position - basePos] "cases 2, 4"                ifFalse: [objects at: anInteger put: anObject]. "case 3"            self setCurrentReference: refPosn.		"relative position"            byteStream position: savedPosn.		"absolute"            anObject]! !!ProjectLauncher class methodsFor: 'accessing' stamp: 'ar 3/15/2001 23:33'!splashMorph: aMorph	SplashMorph := aMorph.! !!SmartRefStream class methodsFor: 'i/o' stamp: 'tk 5/20/97'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	| me |	me := self on: aByteStream.	ScannedObject := me next.	aByteStream ascii.	aByteStream next == $!! ifFalse: [		aByteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:00'!preamble: aString	"Establish aString as the new contents of the preamble.  "	preamble := aString! !!ResourceManager methodsFor: 'initialize' stamp: 'mir 6/18/2001 22:49'!initializeFrom: aCollector	"Initialize the receiver from the given resource collector. None of the resources have been loaded yet, so make register all resources as unloaded."	| newLoc |	aCollector stubMap keysAndValuesDo:[:stub :res|		newLoc := stub locator.		resourceMap at: newLoc put: res.		"unloaded add: newLoc."	].! !!MessageTally methodsFor: 'collecting leaves' stamp: ''!bump: hitCount	tally := tally + hitCount! !!Project methodsFor: 'file in/out' stamp: 'tk 8/21/1999 07:31'!storeDataOn: aDataStream	"Write me out.  All references to other projects are weak references.  They only go out if they are written for another reason."	| cntInstVars cntIndexedVars localInstVars offset |	cntInstVars := self class instSize.	cntIndexedVars := self basicSize.	localInstVars := Project instVarNames.	offset := Project superclass instSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:ii | 		(ii between: offset+1 and: offset + localInstVars size) 			ifTrue: [(#('parentProject' 'previousProject' 'nextProject') includes: 				(localInstVars at: ii-offset)) 					ifTrue: [aDataStream nextPutWeak: (self instVarAt: ii)]								"owner only written if in our tree"					ifFalse: [aDataStream nextPut: (self instVarAt: ii)]]			ifFalse: [aDataStream nextPut: (self instVarAt: ii)]].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:26'!split: aString by: splitChar	| lines index nextIndex |	lines := OrderedCollection new.	index := 1.	[index <= aString size] whileTrue:[		nextIndex := aString 						indexOf: splitChar 						startingAt: index 						ifAbsent:[aString size+1].		lines add: (aString copyFrom: index to: nextIndex-1).		index := nextIndex+1].	^lines! !!SmartRefStream class methodsFor: 'accessing' stamp: 'tk 3/11/98 09:45'!subObjects: anObject ofClass: aClass	"Return a collection of all instances of aClass that would be written out with anObject.  Does not actually write on the disk.  Inspect the result and ask for 'references to this object'."	| dummy coll |	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	coll := OrderedCollection new.	dummy references keysDo: [:each |		each class == aClass ifTrue: [coll add: each]].	^ coll! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/3/2000 17:59'!readInstance	"Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| instSize className refPosn |	instSize := (byteStream nextNumber: 4) - 1.	refPosn := self getCurrentReference.	className := self next asSymbol.	^ self readInstanceSize: instSize clsname: className refPosn: refPosn! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/6/2000 18:17'!saveClassInstVars	"Install the values of the instance variables of UniClasses.classInstVars is an array of arrays (#Player3 (Player3 class's inst varscripts) (Player3 class's inst var slotInfo) ...) "	| normal mySize list clsPoolIndex |	classInstVars := OrderedCollection new: 100.	normal := Object class instSize.	clsPoolIndex := Object class allInstVarNames indexOf: 'classPool'.	self uniClasesDo: [:aUniClass |		list := OrderedCollection new.		mySize := aUniClass class instSize.		mySize = normal ifFalse:			[list add: aUniClass name.	"a symbol"			list add: 'Update to read classPool'.	"newconvention for saving the classPool"			list add: (aUniClass instVarAt: clsPoolIndex)"classPool".						"write actual value of nilinstead of Dictionary()"			normal + 1 to: mySize do: [:ii |				list addLast: (aUniClass instVarAt: ii)].			classInstVars add: list asArray]].	classInstVars := classInstVars asArray.	! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:27'!fileInMorphsNamed: memberName addToWorld: aBoolean	"This will load the Morph (or Morphs) from the given member.	Answers a Morph, or a list of Morphs, or nil if no such member or error.	If aBoolean is true, also adds them and their models to the World."	| member morphOrList |	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	self installed: member.	morphOrList := member contentStream fileInObjectAndCode.	morphOrList ifNil: [ ^nil ].	aBoolean ifTrue: [ ActiveWorld addMorphsAndModel: morphOrList ].	^morphOrList! !!DataStream methodsFor: 'other' stamp: ''!next: anInteger    "Answer an Array of the next anInteger objects in the stream."    | array |    array := Array new: anInteger.    1 to: anInteger do: [:i |        array at: i put: self next].    ^ array! !!ResourceManager class methodsFor: 'resource caching' stamp: 'ar 5/30/2001 23:21'!cacheResource: urlString inArchive: archiveName	"Remember the given url as residing in the given archive"	| fd file fullName |	fullName := 'zip://', archiveName.	((self resourceCache at: urlString ifAbsent:[#()]) 		anySatisfy:[:cache| cache = fullName]) ifTrue:[^self]. "don't cache twice"	fd := Project squeakletDirectory.	"update cache"	file := [fd oldFileNamed: self resourceCacheName] 			on: FileDoesNotExistException			do:[:ex| fd forceNewFileNamed: self resourceCacheName].	file setToEnd.	file nextPutAll: urlString; cr.	file nextPutAll: fullName; cr.	file close.	self addCacheLocation: fullName for: urlString.! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 9/27/2000 14:11'!namedUrl: urlString	| projName |	"Return project if in, else nil"	"Ted's fix for unreachable projects"	projName := (urlString findTokens: '/') last.	projName := (Project parseProjectFileName: projName unescapePercents) first.	^ Project named: projName! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 23:09'!leftRotateBy: bits	"Rotate my contents left by the given number of bits, retaining exactly 32 bits."	"Details: Perform this operation with as little LargeInteger arithmetic as possible."	| bitCount s1 s2 newHi |	"ensure bitCount is in range [0..32]"	bitCount := bits \\ 32.	bitCount < 0 ifTrue: [bitCount := bitCount + 32].	bitCount > 16		ifTrue: [			s1 := bitCount - 16.			s2 := s1 - 16.			newHi := ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			low := ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			hi := newHi]		ifFalse: [			s1 := bitCount.			s2 := s1 - 16.			newHi := ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			low := ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			hi := newHi]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 7/25/2004 20:03'!attemptToRestoreClassicFonts	"If certain fonts formerly used in early versions of Squeak happen to be present in the image, restore them to their corresponding roles.  Not called by any other method -- intended to be invoked via do-it, possibly in a postscript"	"Preferences attemptToRestoreClassicFonts"	| aTextStyle |	#(	(setButtonFontTo:		NewYork		12)		(setCodeFontTo:			NewYork		12)		(setFlapsFontTo:			ComicBold		16)		(setEToysFontTo:			ComicBold		16)		(setListFontTo:			NewYork		12)		(setMenuFontTo:			NewYork		12)		(setWindowTitleFontTo:	NewYork		15)		(setSystemFontTo:		NewYork		12)) do:			[:triplet |				(aTextStyle := TextStyle named: triplet second) ifNotNil:					[self perform: triplet first with: (aTextStyle fontOfSize: triplet third).					Transcript cr; show: triplet second, ' installed as ', (triplet first copyFrom: 4 to: triplet first size - 3)]]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'nb 6/17/2003 12:25'!revertLastMethodSubmission	| changeRecords lastSubmission theClass theSelector |	"If the most recent method submission was a method change, revert	that change, and if it was a submission of a brand-new method, 	remove that method."	RecentSubmissions isEmptyOrNil ifTrue: [^ Beeper beep].	lastSubmission := RecentSubmissions last.	theClass := lastSubmission actualClass ifNil: [^ Beeper beep].	theSelector := lastSubmission methodSymbol.	changeRecords := theClass changeRecordsAt: theSelector.	changeRecords isEmptyOrNil ifTrue: [^ Beeper beep].	changeRecords size == 1		ifTrue:			["method has no prior version, so reverting in this case means removing"			theClass removeSelector: theSelector]		ifFalse:			[changeRecords second fileIn]."Utilities revertLastMethodSubmission"! !!Utilities class methodsFor: 'fetching updates' stamp: 'th 4/25/2000 12:59'!saveUpdate: doc onFile: fileName	"Save the update on a local file.  With or without the update number on the front, depending on the preference #updateRemoveSequenceNum"	| file fName pos updateDirectory |	(FileDirectory default directoryNames includes: 'updates') ifFalse:		[FileDirectory default createDirectory: 'updates'].	updateDirectory := FileDirectory default directoryNamed: 'updates'.	fName := fileName.	(Preferences valueOfFlag: #updateRemoveSequenceNum) ifTrue:		[pos := fName findFirst: [:c | c isDigit not].		fName := fName copyFrom: pos to: fName size].	doc reset; ascii.	(updateDirectory fileExists: fName) ifFalse:		[file := updateDirectory newFileNamed: fName.		file nextPutAll: doc contents.		file close].! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!setProjectHolder: aProject	self initialize.	world := ControlManager new.! !!SystemNavigation methodsFor: 'browse' stamp: 'md 8/27/2005 16:42'!browseAllAccessesTo: instVarName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."	"self new browseAllAccessesTo: 'contents' from: Collection."		| coll |	coll := OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsAccess: instVarName) do: [:sel |				sel isDoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel					)				]			]		].	].	^ self 		browseMessageList: coll 		name: 'Accesses to ' , instVarName 		autoSelect: instVarName! !!Project class methodsFor: 'utilities' stamp: 'RAA 11/13/2000 17:14'!allProjects	^AllProjects ifNil: [		Smalltalk garbageCollect.		AllProjects := self allSubInstances select: [:p | p name notNil].	].! !!ChangeRecord methodsFor: 'access' stamp: 'ar 7/15/2005 22:57'!originalChangeSetForSelector: methodSelector	"Returns the original changeset which contained this method version.  If it is contained in the .sources file, return #sources.  If it is in neither (e.g. its changeset was deleted), return nil.  (The selector is passed in purely as an optimization.)"	| likelyChangeSets originalChangeSet |	(file localName findTokens: '.') last = 'sources'		ifTrue: [^ #sources].	likelyChangeSets := ChangeSet allChangeSets select: 		[:cs | (cs atSelector: methodSelector class: self methodClass) ~~ #none].	originalChangeSet := likelyChangeSets		detect: [:cs | cs containsMethodAtPosition: position]		ifNone: [nil].	^ originalChangeSet  "(still need to check for sources file)"! !!Utilities class methodsFor: 'summer97 additions' stamp: 'al 1/13/2006 00:50'!classFromPattern: pattern withCaption: aCaption	"If there is a class whose name exactly given by pattern, return it.	If there is only one class in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores tab, space, & cr characters in the pattern"	| toMatch potentialClassNames classNames exactMatch index |	(toMatch :=  pattern copyWithoutAll:			{Character space.  Character cr.  Character tab})		isEmpty ifTrue: [^ nil].	Symbol hasInterned: toMatch ifTrue:		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:			[:maybeClass | (maybeClass isKindOf: Class) ifTrue: [^ maybeClass]]].	toMatch := (toMatch copyWithout: $.) asLowercase.	potentialClassNames := (Smalltalk classNames , Smalltalk traitNames) asOrderedCollection.	classNames := pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ nil].	exactMatch := classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index := classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [UIManager default chooseFrom: classNames lines: #() title: aCaption]			ifNotNil: [classNames addFirst: exactMatch.				UIManager default chooseFrom: classNames lines: #(1) title: aCaption]].	index = 0 ifTrue: [^ nil].	^ Smalltalk at: (classNames at: index) asSymbol"	self classFromPattern: 'CharRecog' withCaption: ''	self classFromPattern: 'rRecog' withCaption: ''	self classFromPattern: 'znak' withCaption: ''	self classFromPattern: 'orph' withCaption: ''	self classFromPattern: 'TCompil' withCaption: ''"! !!MessageTally methodsFor: 'collecting leaves' stamp: ''!into: leafDict fromSender: senderTally	| leafNode |	leafNode := leafDict at: method		ifAbsent: [leafDict at: method			put: (MessageTally new class: class method: method)].	leafNode bump: tally fromSender: senderTally! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/15/2005 21:51'!askRenames: renamed addTo: msgSet using: smart	| list rec ans oldStruct newStruct |	"Go through the renamed classes.  Ask the user if it could be in a project.  Add a method in SmartRefStream, and a conversion method in the new class."	list := OrderedCollection new.	renamed do: [:cls |		rec := changeRecords at: cls name.		rec priorName ifNotNil: [			ans := UIManager default chooseFrom: 					#('Yes, write code to convert those instances'					'No, no instances are in projects')				title: 'You renamed class ', rec priorName, 				' to be ', rec thisName,				'.\Could an instance of ', rec priorName, 				' be in a project on someone''s disk?'.			ans = 1 ifTrue: [					oldStruct := structures at: rec priorName ifAbsent: [nil].					newStruct := (Array with: cls classVersion), (cls allInstVarNames).					oldStruct ifNotNil: [						smart writeConversionMethodIn: cls fromInstVars: oldStruct 								to: newStruct renamedFrom: rec priorName.						smart writeClassRename: cls name was: rec priorName.						list add: cls name, ' convertToCurrentVersion:refStream:']]				ifFalse: [structures removeKey: rec priorName ifAbsent: []]]].	list isEmpty ifTrue: [^ msgSet].	msgSet messageList ifNil: [msgSet initializeMessageList: list]		ifNotNil: [list do: [:item | msgSet addItem: item]].	^ msgSet! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'bf 1/12/2006 19:20'!recordStartupStamp		StartupStamp := '----STARTUP----', Time dateAndTimeNow printString, ' as ', self imageName.! !!SecurityManager methodsFor: 'private' stamp: 'sd 9/30/2003 13:58'!generateLocalKeyPair	"SecurityManager default generateLocalKeyPair"	"Generate a key set on the local machine."	| dsa |	dsa := DigitalSignatureAlgorithm new.	dsa initRandomFromString: 		Time millisecondClockValue printString, 		Date today printString, 		SmalltalkImage current platformName printString.	privateKeyPair := dsa generateKeySet.	self storeSecurityKeys.! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/19/2000 17:06'!next	"Really write three objects: (version, class structure, object). But only when called from the outside.  "	| version ss object |	^ topCall == nil 		ifTrue: 			[topCall := #marked.			version := super next.			version class == SmallInteger ifFalse: [^ version].					"version number, else just a regular object, not in our format, "			self checkCrLf.			ss := super next.			ss class == Array ifFalse: [^ ss].  "just a regular object"			(ss at: 1) = 'class structure' ifFalse: [^ ss].			structures := ss at: 2.			superclasses := (ss size > 3 and: [(ss at: 3) = 'superclasses']) 				ifTrue: [ss at: 4]		"class name -> superclass name"				ifFalse: [Dictionary new].			(self verifyStructure = 'conversion method needed') ifTrue: [^ nil].			object := super next.	"all the action here"			self restoreClassInstVars.		"for UniClasses. version 4"			topCall := nil.	"reset it"			object]		ifFalse:			[super next]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 09:35'!fileOutChangesFor: class on: stream 	"Write out all the method changes for this class."	| changes |	changes := Set new.	(self methodChangesAtClass: class name) associationsDo: 		[:mAssoc | (mAssoc value = #remove or: [mAssoc value = #addedThenRemoved])			ifFalse: [changes add: mAssoc key]].	changes isEmpty ifFalse: 		[class fileOutChangedMessages: changes on: stream.		stream cr]! !!SystemNavigation methodsFor: 'browse' stamp: 'al 12/7/2005 21:11'!methodHierarchyBrowserForClass: aClass selector: sel	"Create and schedule a message set browser on all implementors of the 	currently selected message selector. Do nothing if no message is selected."	"SystemNavigation default 		methodHierarchyBrowserForClass: ParagraphEditor 		selector: #isControlActive"		| list tab stab aClassNonMeta isMeta theClassOrMeta |	aClass ifNil: [^ self].	aClass isTrait ifTrue: [^ self].	sel ifNil: [^ self].	aClassNonMeta := aClass theNonMetaClass.	isMeta := aClassNonMeta ~~ aClass.	list := OrderedCollection new.	tab := ''.	aClass allSuperclasses reverseDo:		[:cl |		(cl includesSelector: sel) ifTrue:			[list addLast: tab , cl name, ' ', sel].		tab := tab , '  '].	aClassNonMeta allSubclassesWithLevelDo:		[:cl :level |		theClassOrMeta := isMeta ifTrue: [cl class] ifFalse: [cl].		(theClassOrMeta includesSelector: sel) ifTrue:			[stab := ''.  1 to: level do: [:i | stab := stab , '  '].			list addLast: tab , stab , theClassOrMeta name, ' ', sel]]	 	startingLevel: 0.	self browseMessageList: list name: 'Inheritance of ' , sel! !!SmartRefStream class methodsFor: 'accessing' stamp: 'tk 5/20/97'!scannedObject: objOrNil	"Used to free up the last object stashed here.  "	ScannedObject := objOrNil! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 11/3/2000 18:04'!readShortInst	"Instance has just one byte of size.  Class symbol is encoded in two bytes of file position.  See readInstance."	| instSize className refPosn |	instSize := (byteStream next) - 1.	"one byte of size"	refPosn := self getCurrentReference.	className := self readShortRef.	"class symbol in two bytes of file pos"	^ self readInstanceSize: instSize clsname: className refPosn: refPosn! !!SecurityManager methodsFor: 'security operations' stamp: 'RAA 3/2/2002 14:33'!positionToSecureContentsOf: aStream	| bytes trusted part1 part2 sig hash dsa okay pos |	aStream binary.	pos := aStream position.	bytes := aStream next: 4.	bytes = 'SPRJ' asByteArray ifFalse:[		"was not signed"		aStream position: pos.		^false].	part1 := (aStream nextInto: (LargePositiveInteger basicNew: 20)) normalize.	part2 := (aStream nextInto: (LargePositiveInteger basicNew: 20)) normalize.	sig := Array with: part1 with: part2.	hash := SecureHashAlgorithm new hashStream: aStream.	dsa := DigitalSignatureAlgorithm new.	trusted := self trustedKeys.	okay := (trusted detect:[:key| dsa verifySignature: sig ofMessageHash: hash publicKey: key]			ifNone:[nil]) notNil.	aStream position: pos+44.	^okay! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:48'!removePostscript	postscript := nil! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 1/10/2001 14:03'!copyFromRoots: aRootArray sizeHint: segSizeHint areUnique: areUnique	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  	[1] For exporting a project.  Objects were enumerated by ReferenceStream and aRootArray has them all.	[2] For exporting some classes.  See copyFromRootsForExport:. (Caller must hold Symbols, or they will not get registered in the target system.)	[3] For 'local segments'.  outPointers are kept in the image.	If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	uniqueRoots := areUnique 		ifTrue: [aRootArray]		ifFalse: [rootSet := IdentitySet new: aRootArray size * 3.			uniqueRoots := OrderedCollection new.			1 to: aRootArray size do: [:ii |	"Don't include any roots twice"				(rootSet includes: (aRootArray at: ii)) 					ifFalse: [						uniqueRoots addLast: (aRootArray at: ii).						rootSet add: (aRootArray at: ii)]					ifTrue: [userRootCnt ifNotNil: ["adjust the count"								ii <= userRootCnt ifTrue: [userRootCnt := userRootCnt - 1]]]].			uniqueRoots].	arrayOfRoots := uniqueRoots asArray.	rootSet := uniqueRoots := nil.	"be clean"	userRootCnt ifNil: [userRootCnt := arrayOfRoots size].	arrayOfRoots do: [:aRoot | 		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root'].		aRoot := nil].	"clean up"	outPointers := nil.	"may have used this instance before"	segSize := segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray := WordArrayForSegment new: segSize.	[outPointerArray := Array new: segSize // 20] ifError: [		state := #tooBig.  ^ self].	"Smalltalk garbageCollect."	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray := outPointerArray := nil.			segSize := segSize * 2].	segment := segmentWordArray.	outPointers := outPointerArray.	state := #activeCopy.	endMarker := segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker := 'End' clone].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForAnyAlienAuthorship	"Check to see if there are any versions of any methods in the receiver that have author initials other than that of the current author, and open a browser on all found"	| aList initials |	(initials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	(aList := self methodsWithAnyInitialsOtherThan: initials) size > 0		ifFalse: [^ self inform: 'All versions of all methods in "', self name, '"have authoring stamps which start with "', initials, '"']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" with any authoring stamps not starting with "', initials, '"']! !!Preferences class methodsFor: 'parameters' stamp: 'sw 6/13/2001 19:40'!editAnnotations	"Put up a window that allows the user to edit annotation specifications"	| aWindow |	self currentWorld addMorphCentered: (aWindow := self annotationEditingWindow).	aWindow activateAndForceLabelToShow	"Preferences editAnnotations"! !!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'yo 7/5/2004 20:21'!fileOutMethod: selector	| internalStream |	internalStream := WriteStream on: (String new: 1000).	self fileOutMethods: (Array with: selector) on: internalStream.	FileStream writeSourceCodeFrom: internalStream baseName: (self name , '-' , (selector copyReplaceAll: ':' with: '')) isSt: true useHtml: false.! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'jm 12/9/1999 21:49'!inverseOf: x mod: n	"Answer the inverse of x modulus n. That is, the integer y such that (x * y) \\ n is 1. Both x and n must be positive, and it is assumed that x < n and that x and n are integers."	"Details: Use the extended Euclidean algorithm, Schneier, p. 247."	| v u k u1 u2 u3 t1 t2 t3 tmp |	((x <= 0) or: [n <= 0]) ifTrue: [self error: 'x and n must be greater than zero'].	x >= n ifTrue: [self error: 'x must be < n'].	v := x.	u := n.	k := 0.	[x even and: [n even and: [u > 0]]] whileTrue: [  "eliminate common factors of two"		k := k + 1.		u := u bitShift: -1.		v := v bitShift: -1].	u1 := 1. u2 := 0. u3 := u.	t1 := v. t2 := u - 1. t3 := v.	[	[u3 even ifTrue: [			((u1 odd) or: [u2 odd]) ifTrue: [				u1 := u1 + v.				u2 := u2 + u].			u1 := u1 bitShift: -1.			u2 := u2 bitShift: -1.			u3 := u3 bitShift: -1].		((t3 even) or: [u3 < t3]) ifTrue: [			tmp := u1. u1 := t1. t1 := tmp.			tmp := u2. u2 := t2. t2 := tmp.			tmp := u3. u3 := t3. t3 := tmp].		u3 even and: [u3 > 0]] whileTrue: ["loop while u3 is even"].		[((u1 < t1) or: [u2 < t2]) and: [u1 > 0]] whileTrue: [			u1 := u1 + v.			u2 := u2 + u].			u1 := u1 - t1.		u2 := u2 - t2.		u3 := u3 - t3.		t3 > 0] whileTrue: ["loop while t3 > 0"].	[u1 >= v and: [u2 >= u]] whileTrue: [		u1 := u1 - v.		u2 := u2 - u].	u1 := u1 bitShift: k.	u2 := u2 bitShift: k.	u3 := u3 bitShift: k.	u3 = 1 ifFalse: [self error: 'no inverse'].	^ u - u2! !!ImageSegment methodsFor: 'testing' stamp: 'di 3/27/1999 22:04'!verify: ob1 matches: ob2 knowing: matchDict	| priorMatch first |	ob1 == ob2 ifTrue:		["If two pointers are same, they must be ints or in outPointers"		((ob1 isMemberOf: SmallInteger) and: [ob1 = ob2]) ifTrue: [^ self].		((ob1 isKindOf: Behavior) and: [ob1 indexIfCompact = ob2 indexIfCompact]) ifTrue: [^ self].		(outPointers includes: ob1) ifTrue: [^ self].		self halt].	priorMatch := matchDict at: ob1 ifAbsent: [nil].	priorMatch == nil		ifTrue: [matchDict at: ob1 put: ob2]		ifFalse: [priorMatch == ob2					ifTrue: [^ self]					ifFalse: [self halt]].	self verify: ob1 class matches: ob2 class knowing: matchDict.	ob1 class isVariable ifTrue: 		[ob1 basicSize = ob2 basicSize ifFalse: [self halt].		first := 1.		(ob1 isMemberOf: CompiledMethod) ifTrue: [first := ob1 initialPC].		first to: ob1 basicSize do:			[:i | self verify: (ob1 basicAt: i) matches: (ob2 basicAt: i) knowing: matchDict]].	ob1 class instSize = ob2 class instSize ifFalse: [self halt].	1 to: ob1 class instSize do:		[:i | self verify: (ob1 instVarAt: i) matches: (ob2 instVarAt: i) knowing: matchDict].	(ob1 isMemberOf: CompiledMethod) ifTrue:		[ob1 header = ob2 header ifFalse: [self halt].		ob1 numLiterals = ob2 numLiterals ifFalse: [self halt].		1 to: ob1 numLiterals do:			[:i | self verify: (ob1 literalAt: i) matches: (ob2 literalAt: i) knowing: matchDict]]! !!SmalltalkImage methodsFor: 'modules' stamp: 'sd 9/30/2003 14:00'!listLoadedModules	"SmalltalkImage current listLoadedModules"	"Return a list of all currently loaded modules (e.g., plugins). Loaded modules are those that currently in use (e.g., active). The list returned will contain all currently active modules regardless of whether they're builtin (that is compiled with the VM) or external (e.g., residing in some external shared library). Note that the returned list is not sorted!!"	| modules index name |	modules := WriteStream on: Array new.	index := 1.	[true] whileTrue:[		name := self listLoadedModule: index.		name ifNil:[^modules contents].		modules nextPut: name.		index := index + 1.	].! !!MessageTally methodsFor: 'initialize-release' stamp: 'nk 3/8/2004 12:29'!initialize	maxClassNameSize := self class defaultMaxClassNameSize.	maxClassPlusSelectorSize := self class defaultMaxClassPlusSelectorSize.	maxTabs := self class defaultMaxTabs.! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/4/2003 19:40'!initialize: size	references := IdentityDictionary new: size.	uniClasses := IdentityDictionary new.	"UniClass -> new UniClass"	"self isItTimeToCheckVariables ifTrue: [self checkVariables]."		"no more checking at runtime"	newUniClasses := true.! !!Project methodsFor: 'file in/out' stamp: 'yo 7/2/2004 17:45'!storeOnServerShowProgressOn: aMorphOrNil forgetURL: forget	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	world setProperty: #optimumExtentFromAuthor toValue: world extent.	self validateProjectNameIfOK: [		self isCurrentProject ifTrue: ["exit, then do the command"			forget				ifTrue: [self forgetExistingURL]				ifFalse: [urlList isEmptyOrNil ifTrue: [urlList := parentProject urlList copy]].			^self				armsLengthCommand: #storeOnServerAssumingNameValid				withDescription: 'Publishing' translated		].		self storeOnServerWithProgressInfoOn: aMorphOrNil.	] fixTemps.! !!CachedHTTPDownloadRequest methodsFor: 'accessing' stamp: 'ar 12/14/1999 15:00'!startRetrieval	| fileStream |	cachedName == nil ifTrue:[^super startRetrieval].	(FileDirectory default fileExists: cachedName) ifTrue:[		fileStream := FileStream concreteStream new open: cachedName forWrite: false.		fileStream == nil ifFalse:[^self content: 			(MIMEDocument 				contentType: 'text/plain' 				content: fileStream contentsOfEntireFile)].		FileDirectory default deleteFileNamed: cachedName ifAbsent:[]].	super startRetrieval. "fetch from URL"	"and cache in file dir"	fileStream := FileStream concreteStream new open: cachedName forWrite: true.	fileStream == nil ifFalse:[		fileStream nextPutAll: (content content).		fileStream close].! !!ImageSegment methodsFor: 'access' stamp: 'tk 12/8/1999 21:12'!arrayOfRoots: array	arrayOfRoots := array! !!AutoStart class methodsFor: 'updating' stamp: 'CdG 10/17/2005 19:34'!processUpdates	"Process update files from a well-known update server.  This method is called at system startup time,   Only if the preference #updateFromServerAtStartup is true is the actual update processing undertaken automatically"	| choice |	(Preferences valueOfFlag: #updateFromServerAtStartup) ifTrue:		[choice := UIManager default chooseFrom: #('Yes, Update' 'No, Not now' 'Don''t ask again')			title: 'Shall I look for new code\updates on the server?' withCRs.		choice = 1 ifTrue: [			Utilities updateFromServer].		choice = 3 ifTrue: [			Preferences setPreference: #updateFromServerAtStartup toValue: false.			self inform: 'Remember to save you image to make this setting permant.']].	^false! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/17/2005 11:13'!checkForConversionMethods	"See if any conversion methods are needed"	| oldStruct newStruct tell choice list needsel smart restore renamed listAdd listDrop msgSet rec nn |	Preferences conversionMethodsAtFileOut ifFalse: [^ self].	"Check preference"	structures ifNil: [^ self].	list := OrderedCollection new.	renamed := OrderedCollection new.	self changedClasses do: [:class |		need := (self atClass: class includes: #new) not.		need ifTrue: ["Renamed classes."			(self atClass: class includes: #rename) ifTrue: [				rec := changeRecords at: class name.				rec priorName ifNotNil: [					(structures includesKey: rec priorName) ifTrue: [						renamed add: class.  need := false]]]].		need ifTrue: [need := (self atClass: class includes: #change)].		need ifTrue: [oldStruct := structures at: class name 									ifAbsent: [need := false.  #()]].		need ifTrue: [			newStruct := (Array with: class classVersion), (class allInstVarNames).			need := (oldStruct ~= newStruct)].		need ifTrue: [sel := #convertToCurrentVersion:refStream:.			(#(add change) includes: (self atSelector: sel class: class)) ifFalse: [				list add: class]].		].	list isEmpty & renamed isEmpty ifTrue: [^ self].	"Ask user if want to do this"	tell := 'If there might be instances of ', (list asArray, renamed asArray) printString,		'\in a project (.pr file) on someone''s disk, \please ask to write a conversion method.\'			withCRs,		'After you edit the conversion method, you''ll need to fileOut again.\' withCRs,		'The preference conversionMethodsAtFileOut in category "fileout" controls this feature.'.	choice := UIManager default chooseFrom:'Write a conversion method by editing a prototypeThese classes are not used in any object file.  fileOut my changes now.I''m too busy.  fileOut my changes now.Don''t ever ask again.  fileOut my changes now.' withCRs title: tell. 	choice = 4 ifTrue: [Preferences disable: #conversionMethodsAtFileOut].	choice = 2 ifTrue: ["Don't consider this class again in the changeSet"			list do: [:cls | structures removeKey: cls name ifAbsent: []].			renamed do: [:cls | 				nn := (changeRecords at: cls name) priorName.				structures removeKey: nn ifAbsent: []]].	choice ~= 1 ifTrue: [^ self].	"exit if choice 2,3,4"	listAdd := self askAddedInstVars: list.	"Go through each inst var that was added"	listDrop := self askRemovedInstVars: list.	"Go through each inst var that was removed"	list := (listAdd, listDrop) asSet asArray.	smart := SmartRefStream on: (RWBinaryOrTextStream on: '12345').	smart structures: structures.	smart superclasses: superclasses.	(restore := self class current) == self ifFalse: [		self class  newChanges: self].	"if not current one"	msgSet := smart conversionMethodsFor: list.		"each new method is added to self (a changeSet).  Then filed out with the rest."	self askRenames: renamed addTo: msgSet using: smart.	"renamed classes, add 2 methods"	restore == self ifFalse: [self class newChanges: restore].	msgSet isEmpty ifTrue: [^ self].	self inform: 'Remember to fileOut again after modifying these methods.'.	ToolSet browseMessageSet: msgSet name: 'Conversion methods for ', self name autoSelect: false.! !!MessageTally methodsFor: 'private' stamp: ''!class: aClass method: aMethod	class := aClass.	method := aMethod.	tally := 0.	receivers := Array new: 0! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 18:49'!signFiles: fileNames key: privateKey	"Sign the files in the current directory and put them into a folder signed."	|  newNames |	newNames := fileNames collect:[:fileName | 'signed', FileDirectory slash, fileName].	CodeLoader		signFilesFrom: fileNames		to: newNames		key: privateKey! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'sd 11/16/2003 12:00'!openSourceFiles	self imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName := self imageName.		Utilities setAuthorInitials: ''].	FileDirectory		openSources: self sourcesName		andChanges: self changesName		forImage: LastImageName.	StandardSourceFileArray install! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 11/5/2001 12:04'!purgeRecentSubmissionsOfMissingMethods	"Utilities purgeRecentSubmissionsOfMissingMethods"	| keep |	self flag: #mref.	"fix for faster references to methods"	RecentSubmissions := RecentSubmissions select:		[:aSubmission | 			Utilities setClassAndSelectorFrom: aSubmission in:				[:aClass :aSelector |					keep := (aClass == nil) not						and: [aClass isInMemory						and: [aSelector == #Comment or: [(aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil]]]].			keep]! !!HTTPClient class methodsFor: 'class initialization' stamp: 'mir 2/2/2001 17:27'!determineIfRunningInBrowser	"HTTPClient determineIfRunningInBrowser"	RunningInBrowser := StandardFileStream isRunningAsBrowserPlugin! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/2/2004 12:41'!writeForExportWithSources: fName inDirectory: aDirectory changeSet:aChangeSetOrNil	"Write the segment on the disk with all info needed toreconstruct it in a new image.  For export.  Out pointers are encodedas normal objects on the disk.  Append the source code of any classesin roots.  Target system will quickly transfer the sources to itschanges file."	"Files out a changeSet first, so that a project can containclasses that are unique to the project."	| fileStream temp tempFileName zipper allClassesInRootsclassesToWriteEntirely methodsWithSource |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(fName includes: $.) ifFalse: [		^ self inform: 'Please use ''.pr'' or ''.extSeg'' atthe end of the file name'.].	temp := endMarker.	endMarker := nil.	tempFileName := aDirectory nextNameFor: 'SqProject' extension: 'temp'.	zipper := [		Preferences debugPrintSpaceLog ifTrue:[			fileStream := aDirectory newFileNamed:				(fName copyFrom: 1 to: (fNamelastIndexOf: $.)), 'space'.			self printSpaceAnalysisOn: fileStream.			fileStream close].		ProgressNotification signal: '3:uncompressedSaveComplete'.		(aDirectory oldFileNamed: tempFileName) compressFile.	"makes xxx.gz"		aDirectory			rename: (tempFileName, FileDirectory dot, 'gz')			toBe: fName.		aDirectory			deleteFileNamed: tempFileName			ifAbsent: []	].	fileStream := aDirectory newFileNamed: tempFileName.	fileStream fileOutChangeSet: aChangeSetOrNil andObject: self.		"remember extra structures.  Note class names."	endMarker := temp.	"append sources"	allClassesInRoots := arrayOfRoots select: [:cls | clsisKindOf: Behavior].	classesToWriteEntirely := allClassesInRoots select: [ :cls |cls theNonMetaClass isSystemDefined].	methodsWithSource := OrderedCollection new.	allClassesInRoots do: [ :cls |		(classesToWriteEntirely includes: cls) ifFalse: [			cls selectorsAndMethodsDo: [ :sel :meth |				meth sourcePointer = 0 ifFalse:[methodsWithSource add: {cls. sel. meth}].			].		].	].	(classesToWriteEntirely isEmpty and: [methodsWithSourceisEmpty]) ifTrue: [zipper value. ^ self].	fileStream reopen; setToEnd.	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	methodsWithSource do: [ :each |		fileStream nextPut: $!!.	"try to pacifyImageSegment>>scanFrom:"		fileStream nextChunkPut: 'RenamedClassSourceReaderformerClassName: ',				each first name printString,' methodsFor: ',				(each first organizationcategoryOfElement: each second) asString printString,				' stamp: ',(UtilitiestimeStampForMethod: each third) printString; cr.		fileStream nextChunkPut: (each third getSourceFor:each second in: each first) asString.		fileStream nextChunkPut: ' '; cr.	].	classesToWriteEntirely do: [:cls |		cls isMeta ifFalse: [fileStream nextPutAll:						(cls name, 'category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do:			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream close.	zipper value.! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 08:53'!browseAllCallsOn: aSymbol from: aClass	"Create and schedule a Message Set browser for all the methods that call 	on aSymbol."	"self new browseAllCallsOn: #/. from: Number"	| key label |	label := (aSymbol isKindOf: LookupKey)			ifTrue: ['Users of ' , (key := aSymbol key)]			ifFalse: ['Senders of ' , (key := aSymbol)].	^ self 		browseMessageList: (self  allCallsOn: aSymbol from: aClass)		name: label		autoSelect: key	! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/1/2000 12:00'!clear 	"Reset the receiver to be empty.  "	changeRecords := Dictionary new.	preamble := nil.	postscript := nil! !!SmalltalkImage methodsFor: 'image cleanup' stamp: 'mir 11/26/2004 15:33'!fixObsoleteReferences	"SmalltalkImage current fixObsoleteReferences"	| informee obsoleteBindings obsName realName realClass |	Smalltalk garbageCollect; garbageCollect.	Preference allInstances do: [:each | 		informee := each instVarNamed: #changeInformee.		((informee isKindOf: Behavior)			and: [informee isObsolete])			ifTrue: [				Transcript show: 'Preference: '; show: each name; cr.				each instVarNamed: #changeInformee put: (Smalltalk at: (informee name copyReplaceAll: 'AnObsolete' with: '') asSymbol)]]. 	CompiledMethod allInstances do: [:method |		obsoleteBindings := method literals select: [:literal |			literal isVariableBinding				and: [literal value isBehavior]				and: [literal value isObsolete]].		obsoleteBindings do: [:binding |			obsName := binding value name.			Transcript show: 'Binding: '; show: obsName; cr.			realName := obsName copyReplaceAll: 'AnObsolete' with: ''.			realClass := Smalltalk at: realName asSymbol ifAbsent: [UndefinedObject].			binding isSpecialWriteBinding				ifTrue: [binding privateSetKey: binding key value: realClass]				ifFalse: [binding key: binding key value: realClass]]].	Behavior flushObsoleteSubclasses.	Smalltalk garbageCollect; garbageCollect.	SystemNavigation default obsoleteBehaviors size > 0		ifTrue: [			SystemNavigation default obsoleteBehaviors inspect.			self error:'Still have obsolete behaviors. See inspector'].! !!Project methodsFor: 'resources' stamp: 'ar 2/27/2001 17:02'!resourceManager	^resourceManager ifNil:[resourceManager := ResourceManager new]! !!SystemVersion class methodsFor: 'accessing' stamp: ''!current	Current ifNil: [Current := SystemVersion new].	^Current! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'SqR 11/14/2000 11:37'!superclassOrder: classes	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in. Do it in sets instead of ordered collections.	SqR 4/12/2000 22:04"	| all list aClass inclusionSet aClassIndex cache |	list := classes copy. "list is indexable"	inclusionSet := list asSet. cache := Dictionary new.	all := OrderedCollection new: list size.	list size timesRepeat:		[			aClassIndex := list findFirst: [:one | one isNil not and: 				[self doWeFileOut: one given: inclusionSet cache: cache]].			aClass := list at: aClassIndex.			all addLast: aClass.			inclusionSet remove: aClass.			list at: aClassIndex put: nil		].	^all! !!Utilities class methodsFor: 'identification' stamp: 'fc 3/11/2004 12:13'!setAuthorInitials: aString	AuthorInitials := aString.	"Case of being reset due to, eg, copy of image."	aString isEmpty ifTrue: [AuthorName := '']! !!SystemNavigation methodsFor: 'query' stamp: 'al 1/13/2006 00:44'!allSentMessagesWithout: classesAndMessagesPair 	"Answer the set of selectors which are sent somewhere in the system,  	computed in the absence of the supplied classes and messages."	| sent absentClasses absentSelectors |	sent := IdentitySet new: CompiledMethod instanceCount.	absentClasses := classesAndMessagesPair first.	absentSelectors := classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute showWhile: [		Smalltalk classNames , Smalltalk traitNames do: [:name |			((absentClasses includes: name)				ifTrue: [{}]				ifFalse: [{Smalltalk at: name. (Smalltalk at: name) classSide}])					do: [:each | (absentSelectors isEmpty						ifTrue: [each selectors]						ifFalse: [each selectors copyWithoutAll: absentSelectors])						do: [:sel | "Include all sels, but not if sent by self"							(each compiledMethodAt: sel) literals								do: [:m | 									(m isSymbol)										ifTrue: ["might be sent"											m == sel												ifFalse: [sent add: m]].									(m isMemberOf: Array)										ifTrue: ["might be performed"											m												do: [:x | (x isSymbol)														ifTrue: [x == sel																ifFalse: [sent add: x]]]]]]]].			"The following may be sent without being in any literal frame"			1				to: Smalltalk specialSelectorSize				do: [:index | sent						add: (Smalltalk specialSelectorAt: index)]].	Smalltalk presumedSentMessages		do: [:sel | sent add: sel].	^ sent! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 2/25/2001 22:34'!reportClassAndMethodRemovalsFor: collectionOfClassNames	| initialClassesAndMethods finalClassesAndMethods |	"Smalltalk reportClassAndMethodRemovalsFor: #(Celeste Scamper MailMessage)"	initialClassesAndMethods := self unusedClassesAndMethodsWithout: {{}. {}}.	finalClassesAndMethods := self unusedClassesAndMethodsWithout: {collectionOfClassNames. {}}.	^ {finalClassesAndMethods first copyWithoutAll: initialClassesAndMethods first.		finalClassesAndMethods second copyWithoutAll: initialClassesAndMethods second}! !!SystemDictionary methodsFor: 'memory space' stamp: ''!installLowSpaceWatcher	"Start a process to watch for low-space conditions."	"Smalltalk installLowSpaceWatcher"	self primSignalAtBytesLeft: 0.  "disable low-space interrupts"	LowSpaceProcess == nil ifFalse: [LowSpaceProcess terminate].	LowSpaceProcess := [self lowSpaceWatcher] newProcess.	LowSpaceProcess priority: Processor lowIOPriority.	LowSpaceProcess resume.! !!ProjectHistory methodsFor: 'initialize-release' stamp: 'RAA 7/10/2000 15:27'!initialize	mostRecent := OrderedCollection new.! !!AutoStart class methodsFor: 'private' stamp: 'mir 7/28/1999 17:43'!installedLaunchers	InstalledLaunchers ifNil: [		InstalledLaunchers := OrderedCollection new].	^InstalledLaunchers! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'RAA 5/31/2000 08:46'!sign: aStringOrStream privateKey: privateKey dsa: dsa	"Sign the given message (a stream or string) and answer a signature string."	"Note: Unguessable random numbers are needed for message signing. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before signing a message. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."	| hasher h sig |	hasher := SecureHashAlgorithm new.	(aStringOrStream class isBytes)		ifTrue: [h := hasher hashMessage: aStringOrStream]		ifFalse: [h := hasher hashStream: aStringOrStream].	sig := dsa computeSignatureForMessageHash: h privateKey: privateKey.	^ dsa signatureToString: sig! !!SARInstaller methodsFor: 'client services' stamp: 'nk 10/14/2003 15:40'!importImage: memberOrName	| member form |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	form := ImageReadWriter formFromStream: member contentStream binary.	form ifNil: [ ^self ].	Imports default importImage: form named: (FileDirectory localNameFor: member fileName) sansPeriodSuffix.	self installed: member.! !!DataStream class methodsFor: 'as yet unclassified' stamp: ''!exampleWithPictures	"DataStream exampleWithPictures"	| file result |	file := FileStream fileNamed: 'Test-Picture'.	file binary.	(DataStream on: file) nextPut: (Form fromUser).	file close.	file := FileStream fileNamed: 'Test-Picture'.	file binary.	result := (DataStream on: file) next.	file close.	result display.	^ result! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:26'!changeSet: aChangeSet containsClass: aClass	| theClass |	theClass := Smalltalk classNamed: aClass.	theClass ifNil: [^ false].	^ aChangeSet containsClass: theClass! !!PseudoClass methodsFor: 'class' stamp: 'LC 10/8/2001 04:46'!definition	| link linkText defText |	^definition ifNil:		[defText := Text fromString: 'There is no class definition for '.		link := TextLink new.		linkText := link analyze: self name with: 'Definition'.		linkText := Text string: (linkText ifNil: ['']) attribute: link.		defText append: linkText; append: ' in this file'].! !!Utilities class methodsFor: 'fetching updates' stamp: 'rbb 2/18/2005 13:16'!readServerUpdatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.A file on the server called updates.list has the names of the last N update files.  We look backwards for the first one we do not have, and start there""* To add a new update:  Name it starting with a new two-digit code.  * Do not use %, /, *, space, or more than one period in the name of an update file.* The update name does not need to have any relation to the version name.* Figure out which versions of the system the update makes sense for.* Add the name of the file to each version's category below.* Put this file and the update file on all of the servers.** To make a new version of the system:  Pick a name for it (no restrictions)* Put # and exactly that name on a new line at the end of this file.* During the release process, fill in exactly that name in the dialog box.* Put this file on the server.""When two sets of updates need to use the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that is the index file used.""Utilities readServerUpdatesThrough: 3922 saveLocally: true updateImage: true"	| failed loaded str res servers triple tryAgain indexPrefix |	Utilities chooseUpdateList ifFalse: [^ self].	"ask the user which kind of updates"	servers := Utilities serverUrls copy.	indexPrefix := (Utilities updateUrlLists first first includes: $*) 		ifTrue: [(Utilities updateUrlLists first first findTokens: ' ') first]						"special for internal updates"		ifFalse: ['']. 	"normal"	[servers isEmpty] whileFalse: [		triple := self readServer: servers special: indexPrefix 					updatesThrough: maxNumber 					saveLocally: saveLocally updateImage: updateImage.		"report to user"		failed := triple first.		loaded := triple second.		tryAgain := false.		failed ifNil: ["is OK"			loaded = 0 ifTrue: ["found no updates"				servers size > 1 ifTrue: ["not the last server"					res := UIManager default 							chooseFrom: #('Stop looking' 'Try next server')							title: 'No new updates on the server', servers first, 'Would you like to try the next server?(Normally, all servers are identical, but sometimes aserver won''t let us store new files, and gets out of date.)' 						.					res = 2 ifFalse: [^ self]						 ifTrue: [servers := servers allButFirst.	"try the next server"							tryAgain := true]]]].		tryAgain ifFalse: [			str := loaded printString ,' new update file(s) processed.'.			^ self inform: str].	].! !!DataStream methodsFor: 'write and read' stamp: 'jm 7/31/97 16:16'!writeRectangle: anObject    "Write the contents of a Rectangle.  See if it can be a compact Rectangle (type=15).  Rectangles with values outside +/- 2047 were stored as normal objects (type=9).  17:22 tk"	| ok right bottom top left acc |	ok := true.	(right := anObject right) > 2047 ifTrue: [ok := false].	right < -2048 ifTrue: [ok := false].	(bottom := anObject bottom) > 2047 ifTrue: [ok := false].	bottom < -2048 ifTrue: [ok := false].	(top := anObject top) > 2047 ifTrue: [ok := false].	top < -2048 ifTrue: [ok := false].	(left := anObject left) > 2047 ifTrue: [ok := false].	left < -2048 ifTrue: [ok := false].	ok := ok & left isInteger & right isInteger & top isInteger & bottom isInteger.	ok ifFalse: [		byteStream skip: -1; nextPut: 9; skip: 0. "rewrite type to be normal instance"	    ^ anObject storeDataOn: self].	acc := ((left bitAnd: 16rFFF) bitShift: 12) + (top bitAnd: 16rFFF).	byteStream nextNumber: 3 put: acc.	acc := ((right bitAnd: 16rFFF) bitShift: 12) + (bottom bitAnd: 16rFFF).	byteStream nextNumber: 3 put: acc.! !!Project class methodsFor: 'utilities' stamp: 'RAA 11/13/2000 17:26'!deletingProject: outgoingProject	ImageSegment allSubInstancesDo: [:seg |		seg ifOutPointer: outgoingProject thenAllObjectsDo: [:obj |			(obj isKindOf: ProjectViewMorph) ifTrue: [				obj deletingProject: outgoingProject.  obj abandon].			obj class == Project ifTrue: [obj deletingProject: outgoingProject]]].	Project allProjects do: [:p | p deletingProject: outgoingProject].	"ones that are in"	ProjectViewMorph allSubInstancesDo: [:p | 		p deletingProject: outgoingProject.		p project == outgoingProject ifTrue: [p abandon]].	AllProjects := self allProjects copyWithout: outgoingProject.! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'nk 7/29/2004 10:09'!systemInformationString	"Identify software version"	^ SystemVersion current version, String cr, self lastUpdateString, String cr, self currentChangeSetString"	(eToySystem := self at: #EToySystem ifAbsent: [nil]) ifNotNil:		[aString := aString, 'Squeak-Central version: ', eToySystem version, ' of ', eToySystem versionDate]."! !!ResourceManager methodsFor: 'loading' stamp: 'nk 4/17/2004 19:50'!loaderProcess	| loader requests req locator resource stream |	loader := HTTPLoader default.	requests := Dictionary new.	self prioritizedUnloadedResources do:[:loc|		req := HTTPLoader httpRequestClass for: (self hackURL: loc urlString) in: loader.		loader addRequest: req.		requests at: req put: loc].	[stopFlag or:[requests isEmpty]] whileFalse:[		stopSemaphore waitTimeoutMSecs: 500.		requests keys "need a copy" do:[:r|			r isSemaphoreSignaled ifTrue:[				locator := requests at: r.				requests removeKey: r.				stream := r contentStream.				resource := resourceMap at: locator ifAbsent:[nil].				self class cacheResource: locator urlString stream: stream.				self installResource: resource					from: stream					locator: locator.				(resource isForm) ifTrue:[					WorldState addDeferredUIMessage: self formChangedReminder]ifFalse: [self halt].			].		].	].	"Either done downloading or terminating process"	stopFlag ifTrue:[loader abort].	loaderProcess := nil.	stopSemaphore := nil.! !!ChangeRecord methodsFor: 'initialization' stamp: ''!file: f position: p type: t	file := f.	position := p.	type := t! !!ImageSegment methodsFor: 'compact classes' stamp: 'ar 2/21/2001 19:26'!compactClassesArray	| ccIndexes ind ccArray hdrBits |	"A copy of the real compactClassesArray, but with only the classes actually used in the segment.  Slow, but OK for export."	ccIndexes := Set new.	ind := 2. 	"skip version word, first object"	"go past extra header words"	(hdrBits := (segment atPin: ind) bitAnd: 3) = 1 ifTrue: [ind := ind+1].	hdrBits = 0 ifTrue: [ind := ind+2].	[ccIndexes add: (self compactIndexAt: ind).	"0 if has class field"	 ind := self objectAfter: ind.	 ind > segment size] whileFalse.	ccArray := Smalltalk compactClassesArray clone.	1 to: ccArray size do: [:ii | "only the ones we use"		(ccIndexes includes: ii) ifFalse: [ccArray at: ii put: nil]].	^ ccArray! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:29'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 11:09'!reshapedClassesIn: outPointers	"Look for classes in the outPointer array that have changed shape.  Make a fake class for the old shape.  Return a dictionary mapping Fake classes to Real classes.  Substitute fake classes for real ones in outPointers."	| mapFakeClassesToReal fakeCls originalName |	self flag: #bobconv.		mapFakeClassesToReal := IdentityDictionary new.	outPointers withIndexDo: [:outp :ind | 		outp isBehavior ifTrue: [			originalName := renamedConv at: ind ifAbsent: [outp name].				"in DiskProxy>>comeFullyUpOnReload: we saved the name at the index"			fakeCls := self mapClass: outp origName: originalName.			fakeCls == outp ifFalse: [				mapFakeClassesToReal at: fakeCls put: outp.				outPointers at: ind put: fakeCls]]].	^ mapFakeClassesToReal! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'RAA 5/25/2000 08:43'!standardPositionsInWorld: aWorldOrNil	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea := self maximumUsableAreaInWorld: aWorldOrNil.	midX := self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY := self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList := OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!SystemNavigation methodsFor: 'query' stamp: 'al 1/13/2006 00:24'!allImplementedMessagesWithout: classesAndMessagesPair 	"Answer a Set of all the messages that are implemented in the system,  	computed in the absence of the supplied classes and messages. Note this  	reports messages that are in the absent selectors set."	| messages absentClasses |	messages := IdentitySet new: CompiledMethod instanceCount.	absentClasses := classesAndMessagesPair first.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:. "sd 29/04/03" 	Cursor execute showWhile: [		Smalltalk classNames , Smalltalk traitNames			do: [:name | ((absentClasses includes: name)				ifTrue: [{}]				ifFalse: [{Smalltalk at: name. (Smalltalk at: name) classSide}])					do: [:each | messages addAll: each selectors]]].	^ messages! !!Project methodsFor: 'file in/out' stamp: 'md 10/22/2003 16:27'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"| is str |(World == world) ifTrue: [^ self].		" inform: 'Can''t send the current world out'."world isInMemory ifFalse: [^ self].  "already done"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ self].	"Only Morphic projects for now"world ifNil: [^ self].  world presenter ifNil: [^ self]."Do this on project enter"World flapTabs do: [:ft | ft referent adaptToWorld: World].	"Hack to keep the Menu flap from pointing at my project""Preferences setPreference: #useGlobalFlaps toValue: false.""Utilities globalFlapTabsIfAny do:	[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].Utilities clobberFlapTabList.	""project world deleteAllFlapArtifacts.""self currentWorld deleteAllFlapArtifacts.	"Utilities emptyScrapsBook.World checkCurrentHandForObjectToPaste2.is := ImageSegment new copyFromRootsLocalFileFor: 		(Array with: world presenter with: world)	"world, and all Players"	sizeHint: 0.is segment size < 800 ifTrue: ["debugging" 	Transcript show: self name, ' did not get enough objects'; cr.  ^ Beeper beep].false ifTrue: [	str := String streamContents: [:strm |		strm nextPutAll: 'Only a tiny part of the project got into the segment'.		strm nextPutAll: '\These are pointed to from the outside:' withCRs.		is outPointers do: [:out |			(out class == Presenter) | (out class == ScriptEditorMorph) ifTrue: [				strm cr. out printOn: strm.				self systemNavigation					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]].			(is arrayOfRoots includes: out class) ifTrue: [strm cr. out printOn: strm.				self systemNavigation					browseAllObjectReferencesTo: out					except: (Array with: is outPointers)					ifNone: [:obj | ]]]].	self inform: str.	^ is inspect].is extract."is instVarAt: 2 put: is segment clone."		"different memory"! !!PseudoClass methodsFor: 'fileIn/fileOut' stamp: 'yo 7/5/2004 20:21'!fileOut	| internalStream |	internalStream := WriteStream on: (String new: 1000).	self fileOutOn: internalStream.	self needsInitialize ifTrue:[		internalStream cr; nextChunkPut: self name,' initialize'.	].	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true useHtml: false.! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14'!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod := self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!Project methodsFor: 'accessing' stamp: 'RAA 5/10/2001 14:57'!setThumbnail: aForm	self flag: #bob.		"no longer used??"	thumbnail := aForm! !!ProjectLoading class methodsFor: 'accessing' stamp: 'ar 2/27/2001 14:33'!projectStreamFromArchive: archive	| ext prFiles entry unzipped |	ext := FileDirectory dot, Project projectExtension.	prFiles := archive members select:[:any| any fileName endsWith: ext].	prFiles isEmpty ifTrue:[^''].	entry := prFiles first.	unzipped := RWBinaryOrTextStream on: (ByteArray new: entry uncompressedSize).	entry extractTo: unzipped.	^unzipped reset! !!ResourceManager class methodsFor: 'resource caching' stamp: 'mir 9/15/2002 15:59'!lookupCachedResource: cachedUrlString ifPresentDo: streamBlock	"See if we have cached the resource described by the given url and if so, evaluate streamBlock with the cached resource."	|  urlString candidates url stream |	CachedResources ifNil:[^self].	candidates := CachedResources at: cachedUrlString ifAbsent:[nil].	(self lookupCachedResource: cachedUrlString in: candidates ifPresentDo: streamBlock)		ifTrue: [^self].	urlString := self relocatedExternalResource: cachedUrlString.	urlString ifNil: [^self].	candidates := CachedResources at: urlString ifAbsent:[nil].	candidates		ifNil: [			(url := urlString asUrl) schemeName = 'file'				ifTrue: [					stream := [FileStream readOnlyFileNamed: url pathForFile] 							on: FileDoesNotExistException do:[:ex| ex return: nil].					stream						ifNotNil: [[streamBlock value: stream] ensure: [stream close]]]]		ifNotNil: [self lookupCachedResource: urlString in: candidates ifPresentDo: streamBlock]! !!Project methodsFor: 'file in/out' stamp: 'md 10/22/2003 17:54'!storeToMakeRoom	"Write out enough projects to fulfill the space goals.	Include the size of the project about to come in."	| params memoryEnd goalFree cnt gain proj skip tried |	GoalFreePercent ifNil: [GoalFreePercent := 33].	GoalNotMoreThan ifNil: [GoalNotMoreThan := 20000000].	params := SmalltalkImage current  getVMParameters.	memoryEnd	:= params at: 3."	youngSpaceEnd	:= params at: 2.	free := memoryEnd - youngSpaceEnd."	goalFree := GoalFreePercent asFloat / 100.0 * memoryEnd.	goalFree := goalFree min: GoalNotMoreThan.	world isInMemory ifFalse: ["enough room to bring it in"		goalFree := goalFree + (self projectParameters at: #segmentSize ifAbsent: [0])].	cnt := 30.	gain := Smalltalk garbageCollectMost.	"skip a random number of projects that are in memory"	proj := self.  skip := 6 atRandom.	[proj := proj nextInstance ifNil: [Project someInstance].		proj world isInMemory ifTrue: [skip := skip - 1].		skip > 0] whileTrue.	cnt := 0.  tried := 0.	[gain > goalFree] whileFalse: [		proj := proj nextInstance ifNil: [Project someInstance].		proj storeSegment ifTrue: ["Yes, did send its morphs to the disk"			gain := gain + (proj projectParameters at: #segmentSize 						ifAbsent: [20000]).	"a guess"			Beeper beep.			(cnt := cnt + 1) > 5 ifTrue: [^ self]].	"put out 5 at most"		(tried := tried + 1) > 23 ifTrue: [^ self]].	"don't get stuck in a loop"! !!Preferences class methodsFor: 'parameters' stamp: 'jhm 10/15/97 17:31'!desktopColor	"Answer the desktop color. Initialize it if necessary."		DesktopColor == nil ifTrue: [DesktopColor := Color gray].	^ DesktopColor! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 3/30/2002 09:13'!methodsWithAnyInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one, even historically"	| slips method aTimeStamp |	slips := Set new.	self changedClasses do: [:aClass |		(self methodChangesAtClass: aClass name) associationsDo: [ :mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[method := aClass compiledMethodAt: mAssoc key ifAbsent: [nil].				method ifNotNil: [					(aClass changeRecordsAt: mAssoc key) do: [ :chg |						aTimeStamp := chg stamp.						(aTimeStamp notNil and: [(aTimeStamp beginsWith: myInits) not])							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]]].	^ slips! !!ImageSegment class methodsFor: 'testing' stamp: 'di 2/17/2000 21:58'!activeClasses   "ImageSegment activeClasses"	"Restore all remaining MD faults and return the active classes"	| unused active |	unused := OrderedCollection new.	active := OrderedCollection new.	Smalltalk allClasses do:		[:c | (c instVarNamed: 'methodDict') 			ifNil: [unused addLast: c]			ifNotNil: [active addLast: c]].	unused do: [:c | c recoverFromMDFault].	^ active! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'md 1/5/2004 18:05'!compressSources		"Copy all the source file to a compressed file. Usually preceded by Smalltalk condenseSources."	"The new file will be created in the default directory, and the code in openSources	will try to open it if it is there, otherwise it will look for normal sources."	"Smalltalk compressSources"	| f cfName cf |	f := SourceFiles first.	(SmalltalkImage current sourcesName endsWith: 'sources')		ifTrue: [cfName := (SmalltalkImage current sourcesName allButLast: 7) , 'stc']		ifFalse: [self error: 'Hey, I thought the sources name ended with ''.sources''.'].	cf := (CompressedSourceStream on: (FileStream newFileNamed: cfName))				segmentSize: 20000 maxSize: f size.	"Copy the sources"'Compressing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: f size	during:		[:bar | f position: 0.		[f atEnd] whileFalse:			[cf nextPutAll: (f next: 20000).			bar value: f position]].	cf close.	self setMacFileInfoOn: cfName.	self inform: 'You now have a compressed sources file!!Squeak will use it the next time you start.'! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 19:04'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList traits classes traitList list |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self inform: 'Warning: no changes to file out'].			traits := self changedClasses reject: [:each | each isBehavior].	classes := self changedClasses select: [:each | each isBehavior].	traitList := self class traitsOrder: traits asOrderedCollection.	classList := self class superclassOrder: classes asOrderedCollection.	list := OrderedCollection new		addAll: traitList;		addAll: classList;		yourself.		"First put out rename, max classDef and comment changes."	list do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	list do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	list reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!MessageTally class methodsFor: 'defaults' stamp: 'nk 3/8/2004 12:41'!defaultPollPeriod	"Answer the number of milliseconds between interrupts for spyOn: and friends.	This should be faster for faster machines."	^DefaultPollPeriod ifNil: [ DefaultPollPeriod := 1 ]! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 11/25/1999 14:37'!isItTimeToCheckVariables	| now isIt |	NextVariableCheckTime ifNil: [		NextVariableCheckTime := Time totalSeconds.		^ true].	now := Time totalSeconds.	isIt := NextVariableCheckTime < now.	isIt ifTrue: ["update time for next check"		NextVariableCheckTime := now + self intervalForChecks].	^isIt! !!SystemNavigation methodsFor: 'query' stamp: 'al 1/13/2006 11:59'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a SortedCollection of all the methods that contain, in source code, aString as a substring.  Search the class comments also"	| list count adder |	list := Set new.	adder := [ :mrClass :mrSel | list add: ( MethodReference new											setStandardClass: mrClass											methodSymbol: mrSel)].	'Searching all source code...'		displayProgressAt: Sensor cursorPoint		from: 0 to: Smalltalk classNames size		during: [:bar |			count := 0.			SystemNavigation default allBehaviorsDo: [:each |				bar value: (count := count + 1).					each selectorsDo: [:sel | 						((each sourceCodeAt: sel) findString: aString 							startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [								sel isDoIt ifFalse: [adder value: each value: sel]]].					(each organization classComment asString findString: aString 							startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [								adder value: each value: #Comment]	]].			^ list asSortedCollection! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 11:24'!playDrumRoll: mSecsBetweenNotes count: tapCount onPort: portNum	"MidiPrimTester new playDrumRoll: 75 count: 64 onPort: 0"	"Play middle-C tapCount times with the given space between notes. This example works best with a short percussive voice, like a drum."	"Details: This test can be used to investigate the real-time performance of your system. On a 110 MHz PowerPC Mac, this method can genererate very fast and smooth drum rolls up to about 100 beats/sec (10 mSecs between notes). However, many factors can prevent one from seeing this level of performance including a slow CPU, lack of a level-2 cache, networking or other background processes stealing chunks of processor time from Squeak, or a sluggish MIDI synthesizer."	"Details: By default, this method does an incremental GC on every note. While not really needed for this example, it illustrates a useful technique for real-time processing in Squeak: do an incremental GC when you know you have a few milliseconds of idle time to avoid triggering one during a time-critical task. In this case, we're also using the GC time to provide a small delay between the note-on and note-off events. If the GC time is too short, as it could be on a fast machine, the note may not sound at all unless you add a few milliseconds of additional delay!!"	"Note: This example works best if the VM's millisecond clock has 1 millisecond resolution."	| gcDuringNote noteOn noteOff endTime waitTime |	gcDuringNote := true.	"these events use running status, so the command byte is omitted"	noteOn := #(60 100) as: ByteArray.	noteOff := #(60 0) as: ByteArray.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: 1000000.	"send an initial event with command byte to initiate running status"	self primMIDIWritePort: portNum from: (#(144 60 0) as: ByteArray) at: 0.	1 to: tapCount do: [:i |		endTime := Time millisecondClockValue + mSecsBetweenNotes.		self primMIDIWritePort: portNum from: noteOn at: 0.		gcDuringNote			ifTrue: [				"do quick GC; takes a few milliseconds and provides the note-down time"				"Note: if GC is too fast on your machine, you need to add a few mSecs delay!!"				Smalltalk garbageCollectMost]			ifFalse: [(Delay forMilliseconds: 3) wait].		self primMIDIWritePort: portNum from: noteOff at: 0.		waitTime := endTime - Time millisecondClockValue.		waitTime > 0 ifTrue: [(Delay forMilliseconds: waitTime) wait]].	self primMIDIClosePort: portNum.! !!DataStream methodsFor: 'other' stamp: 'tk 3/5/2002 09:51'!nextAndClose	"Speedy way to grab one object.  Only use when we are inside an object binary file.  Do not use for the start of a SmartRefStream mixed code-and-object file."	| obj |	obj := self next.	self close.	^ obj! !!SystemNavigation methodsFor: 'ui' stamp: 'edc 11/8/2005 10:58'!showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock withCaption: aCaption	"Show a sorted menu of the given selectors, preceded by firstItem, and all abbreviated to 40 characters.  Use aCaption as the menu title, if it is not nil.  Evaluate choiceBlock if a message is chosen."	| index menuLabels sortedList |	sortedList := selectorCollection asSortedCollection.	menuLabels := String streamContents: 		[:strm | strm nextPutAll: (firstItem contractTo: 40).		sortedList do: [:sel | strm cr; nextPutAll: (sel contractTo: 40)]].	index := UIManager default chooseFrom: (menuLabels substrings) lines: #(1).	index = 1 ifTrue: [choiceBlock value: firstItem].	index > 1 ifTrue: [choiceBlock value: (sortedList at: index - 1)]! !!FontSubstitutionDuringLoading methodsFor: 'accessing' stamp: 'nk 11/8/2004 15:01'!familyName: anObject	"Set the value of familyName"	familyName := anObject! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 4/4/2000 12:49'!forgetChangesIn: otherRecord	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	| cls otherMethodChanges selector actionToSubtract |	(cls := self realClass) == nil ifTrue: [^ self].  "We can do better now, though..."	otherMethodChanges := otherRecord methodChangeTypes.	otherMethodChanges associationsDo:		[:assoc | selector := assoc key. actionToSubtract := assoc value.		(cls includesSelector: selector)			ifTrue: [(#(add change) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]			ifFalse: [(#(remove addedThenRemoved) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]].	changeTypes isEmpty ifFalse:		[changeTypes removeAllFoundIn: otherRecord allChangeTypes.		(changeTypes includes: #rename) ifFalse:			[changeTypes removeAllSuchThat: [:x | x beginsWith: 'oldName: ']]]! !!MczInstaller methodsFor: 'utilities' stamp: 'bf 2/9/2004 13:56'!useNewChangeSetDuring: aBlock	| changeHolder oldChanges newChanges |	changeHolder := (ChangeSet respondsTo: #newChanges:)						ifTrue: [ChangeSet]						ifFalse: [Smalltalk].	oldChanges := (ChangeSet respondsTo: #current)						ifTrue: [ChangeSet current]						ifFalse: [Smalltalk changes].	newChanges := ChangeSet new name: (ChangeSet uniqueNameLike: self extractPackageName).	changeHolder newChanges: newChanges.	[aBlock value] ensure: [changeHolder newChanges: oldChanges].! !!HTTPClient class methodsFor: 'examples' stamp: 'mir 2/2/2001 17:44'!examplePostMultipart	"HTTPClient examplePostMultipart"	| args result |	args := Dictionary new.	args		at: 'arg1' put: #('val1');		at: 'arg2' put: #('val2');		yourself.	result := HTTPClient httpPostMultipart: 'http://www.squeaklet.com/cgi-bin/thrd.pl'  args: args.	Transcript show: result content; cr; cr.! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'di 2/16/2000 10:28'!flushClassNameCache	"Smalltalk flushClassNameCache"	"Forse recomputation of the cached list of class names."	cachedClassNames := nil! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:43'!readString	"Answer a String read from this serial port. Answer the empty String if no data is available. The port must be open."	| buf count |	buf := String new: 1000.	count := self primReadPort: port into: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: count! !!ChangeSet methodsFor: 'accessing' stamp: 'BJP 4/24/2001 00:23'!author	| author |	self assurePreambleExists.	author := self preambleString lineNumber: 3.	author := author copyFrom: 8 to: author size. "Strip the 'Author:' prefix. Ugly ugly."		^author withBlanksTrimmed.	! !!SmartRefStream class methodsFor: 'utilities' stamp: 'tk 5/4/1998 17:34'!statsOfSubObjects: anObject	"Open a window with statistics on what objects would be written out with anObject.  Does not actually write on the disk.  Stats in the form:	ScriptEditorMorph 51		SortedCollection (21->LayoutMorph 15->SimpleButtonMorph 9->Array 4->CompoundTileMorph 2->StringMorph )"	| dummy printOut |	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy rootObject: anObject.	"inform him about the root"	dummy nextPut: anObject.	"(dummy references) is the raw data"	printOut := dummy statisticsOfRefs.	(StringHolder new contents: printOut) 		openLabel: 'ReferenceStream statistics'.! !!SystemVersion class methodsFor: 'accessing' stamp: 'mir 8/10/2001 11:53'!pluginVersion: availableVersionString newerThan: currentVersionString	| currentVersion availableVersion |	(currentVersionString isEmptyOrNil		or: [availableVersionString isEmptyOrNil])		ifTrue: [^true].	currentVersion := self parseVersionString: currentVersionString.	availableVersion := self parseVersionString: availableVersionString.	(currentVersion isNil		or: [availableVersion isNil])		ifTrue: [^false].	^(currentVersion at: 2) < (availableVersion at: 2)! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/17/1999 00:13'!writeToFile	state = #active ifFalse: [self error: 'wrong state'. ^ self].	Cursor write showWhile: [		segmentName ifNil: [			segmentName := (FileDirectory localNameFor: fileName) sansPeriodSuffix].			"OK that still has number on end.  This is an unusual case"		fileName := self class uniqueFileNameFor: segmentName.	"local name"		(self class segmentDirectory newFileNamed: fileName) nextPutAll: segment; close.		segment := nil.		endMarker := nil.		state := #onFile].! !!SystemDictionary class methodsFor: 'initialization' stamp: 'ar 10/5/2007 18:16'!initialize	"SystemDictionary initialize"	| oldList |	oldList := StartUpList.	StartUpList := OrderedCollection new.	"These get processed from the top down..."	#(		Delay		DisplayScreen		Cursor		InputSensor		ProcessorScheduler  "Starts low space watcher and bkground."		FileDirectory  "Enables file stack dump and opens sources."		ShortIntegerArray		ShortRunArray		CrLfFileStream	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].	oldList ifNotNil: [oldList do: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToStartUpList: theClass]]].	#(		ImageSegment		PasteUpMorph		ControlManager	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToStartUpList: cls].	].			oldList := ShutDownList.	ShutDownList := OrderedCollection new.	"These get processed from the bottom up..."	#(		Delay		DisplayScreen		InputSensor		Form		ControlManager		PasteUpMorph		StrikeFont		Color		FileDirectory		SoundPlayer		HttpUrl		Password		PWS		MailDB		ImageSegment	) do:[:clsName|		Smalltalk at: clsName ifPresent:[:cls| Smalltalk addToShutDownList: cls].	].	oldList ifNotNil: [oldList reverseDo: [:className | Smalltalk at: className						ifPresent: [:theClass | Smalltalk addToShutDownList: theClass]]].! !!Utilities class methodsFor: 'fetching updates' stamp: 'sw 2/26/2002 23:19'!fileInFromUpdatesFolder: numberList	"File in a series of updates with the given updates numbers, from the updates folder in the default directory.  The file-ins are done in numeric order, even if numberList was not sorted upon entry.	This is useful for test-driving the retrofitting of a possibly discontinguous list of updates from an alpha version back to a stable release.	Utilities fileInFromUpdatesFolder: #(4745 4746 4747 4748 4749 4750 4751 4752 4754 4755 4761 4762 4767 4769)."	| fileNames fileNamesInOrder file updateDirectory |	updateDirectory := FileDirectory default directoryNamed: 'updates'.	fileNames := updateDirectory fileNames select:		[:n | n first isDigit			and: [numberList includes: n initialIntegerOrNil]].	(file := fileNames select: [:n | (n occurrencesOf: $.) > 1]) size > 0		ifTrue: [self error: file first , ' has multiple periods'].	fileNamesInOrder := fileNames asSortedCollection:		[:a :b | a initialIntegerOrNil < b initialIntegerOrNil].	fileNamesInOrder do:		[:aFileName | (updateDirectory readOnlyFileNamed: aFileName) fileIntoNewChangeSet]! !!CodeLoader methodsFor: 'installing' stamp: 'RAA 2/19/2001 08:23'!installProject	"Assume that we're loading a single file and it's a project"	| aStream |	aStream := sourceFiles first contentStream.	aStream ifNil:[^self error:'Project was not loaded'].	ProjectLoading			openName: nil 		"<--do we want to cache this locally? Need a name if so"			stream: aStream			fromDirectory: nil			withProjectView: nil.! !!Project methodsFor: 'accessing' stamp: 'di 1/21/98 11:06'!setViewSize: aPoint	viewSize := aPoint! !!ImageSegment methodsFor: 'read/write segment' stamp: 'mir 10/11/2000 19:08'!writeForExport: shortName	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk."	| fileStream temp |	state = #activeCopy ifFalse: [self error: 'wrong state'].	temp := endMarker.	endMarker := nil.	fileStream := FileStream newFileNamed: (FileDirectory fileName: shortName extension: self class fileExtension).	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker := temp.! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 16:20'!initialize	privateKeyPair := nil.	trustedKeys := #().	keysFileName := 'Squeak.keys'.! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'yo 7/25/2003 17:50'!reconstructChanges2	"Move all the changes and its histories onto another sources file."	"SmalltalkImage reconstructChanges2"	| f oldChanges classCount |	f := FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.	(SourceFiles at: 2) converter: MacRomanTextConverter new.'Recoding Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount := 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount := classCount + 1).			class moveChangesWithVersionsTo: f.			class putClassCommentToCondensedChangesFile: f.			class class moveChangesWithVersionsTo: f]].	self lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	Smalltalk setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (FileStream oldFileNamed: oldChanges name)! !!DataStream methodsFor: 'write and read' stamp: 'tk 1/5/2000 11:47'!readReference	"Read the contents of an object reference. (Cf. outputReference:)  File is not now positioned at this object."	| referencePosition |	^ (referencePosition := (byteStream nextNumber: 4)) = self vacantRef	"relative"		ifTrue:  [nil]		ifFalse: [self objectAt: referencePosition]		"relative pos"! !!FilePackage class methodsFor: 'conflict checker logging' stamp: 'dew 2/13/2004 23:33'!closeLog	self logFileStream close.	LogFileStream := nil.! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 2/18/2001 01:45'!openFactoredPanelWithWidth: aWidth 	"Open up a preferences panel of the given width"	"Preferences openFactoredPanelWithWidth: 325"	| window playfield aPanel |	aPanel := PreferencesPanel new.	playfield := PasteUpMorph new width: aWidth.	playfield dropEnabled: false.	self initializePreferencePanel: aPanel in: playfield.	self couldOpenInMorphic		ifTrue: [window := (SystemWindow labelled: 'Preferences')						model: aPanel.			window on: #keyStroke send: #keyStroke: to: aPanel.			window				bounds: (100 @ 100 - (0 @ window labelHeight + window borderWidth) extent: playfield extent + (2 * window borderWidth)).			window				addMorph: playfield				frame: (0 @ 0 extent: 1 @ 1).			window updatePaneColors.			window setProperty: #minimumExtent toValue: playfield extent + (12@15).			self currentWorld addMorphFront: window.			window center: self currentWorld center.			window activateAndForceLabelToShow]		ifFalse:			[(window := MVCWiWPasteUpMorph newWorldForProject: nil) addMorph: playfield.			MorphWorldView				openOn: window				label: 'Preferences'				extent: playfield extent]! !!PseudoClass methodsFor: 'accessing' stamp: 'NS 4/6/2004 15:46'!organization	organization ifNil: [organization := PseudoClassOrganizer defaultList: SortedCollection new].	"Making sure that subject is set correctly. It should not be necessary."	organization setSubject: self.	^ organization! !!Project methodsFor: 'accessing' stamp: 'mir 6/22/2001 20:06'!forgetExistingURL	self resourceManager makeAllProjectResourcesLocalTo: self resourceUrl.	urlList := nil! !!SystemNavigation methodsFor: 'query' stamp: 'md 8/27/2005 17:17'!selectAllMethodsNoDoits: aBlock 	"Like allSelect:, but strip out Doits"	| aCollection |	aCollection := SortedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsDo: [:sel | (sel isDoIt not									and: [aBlock											value: (class compiledMethodAt: sel)])								ifTrue: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!SmalltalkImage class methodsFor: 'class initialization' stamp: 'yo 2/18/2004 18:25'!startUp	EndianCache := nil.! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:32'!removePreamble	preamble := nil! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'ar 2/6/2001 18:42'!forceChangesToDisk	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."	| changesFile |	changesFile := SourceFiles at: 2.	(changesFile isKindOf: FileStream) ifTrue: [		changesFile flush.		SecurityManager default hasFileAccess ifTrue:[			changesFile close.			changesFile open: changesFile name forWrite: true].		changesFile setToEnd.	].! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sd 11/16/2003 12:55'!externalizeSources   	"Write the sources and changes streams onto external files." 	"Smalltalk externalizeSources"	"the logic of this method is complex because it uses changesName and self changesName	may be this is normal - sd"		| sourcesName changesName aFile |	sourcesName := SmalltalkImage current sourcesName.	(FileDirectory default fileExists: sourcesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', sourcesName].	changesName := SmalltalkImage current changesName.	(FileDirectory default fileExists: changesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', changesName].	aFile :=  FileStream newFileNamed: sourcesName.	aFile nextPutAll: SourceFiles first originalContents.	aFile close.	self setMacFileInfoOn: sourcesName.	SourceFiles at: 1 put: (FileStream readOnlyFileNamed: sourcesName).	aFile := FileStream newFileNamed: SmalltalkImage current changesName.	aFile nextPutAll: SourceFiles last contents.	aFile close.	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: SmalltalkImage current changesName		type: 'STch'		creator: 'FAST'.	SourceFiles at: 2 put: (FileStream oldFileNamed: changesName).	self inform: 'Sources successfully externalized'.! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:57'!askForDoits	| menu choice choices |	choices := #('do not process' 'at the beginning' 'at the end' 'cancel').	menu := SelectionMenu selections: choices.	choice := nil.	[choices includes: choice] whileFalse: [		choice := menu startUpWithCaption: 'The package contains unprocessed doIts.When would like to process those?'].	^choices indexOf: choice! !!ChangeSet class methodsFor: 'current changeset' stamp: 'NS 1/16/2004 14:49'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet.  Tell the current project that aChangeSet is now its change set.  When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current-change-set from within a project, it's vital"	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: current.	current isolationSet: nil.	current := aChangeSet.	SystemChangeNotifier uniqueInstance notify: aChangeSet ofAllSystemChangesUsing: #event:.	Smalltalk currentProjectDo:		[:proj |		proj setChangeSet: aChangeSet.		aChangeSet isolationSet: proj isolationSet]! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 10/17/2000 19:11'!serverFileFromURL: aURLString	| dir |	self flag: #bob.		"need to include swikis in this - hacked for now"	(aURLString findString: '/SuperSwikiProj/') > 0 ifTrue: [		dir := SuperSwikiServer new fullPath: (aURLString copyUpToLast: $/).		^dir readOnlyFileNamed: (aURLString findTokens: '/') last	].	^ServerFile new fullPath: aURLString! !!AbstractLauncher methodsFor: 'private' stamp: 'mir 1/11/2000 16:53'!parameters	parameters == nil		ifTrue: [parameters := self class extractParameters].	^parameters! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:38'!bitXor: aThirtTwoBitRegister	"Replace my contents with the bitwise exclusive OR of the given register and my current contents."	hi := hi bitXor: aThirtTwoBitRegister hi.	low := low bitXor: aThirtTwoBitRegister low.! !!Project methodsFor: 'menu messages' stamp: 'RAA 5/16/2001 18:00'!validateProjectNameIfOK: aBlock	| details |	details := world valueOfProperty: #ProjectDetails.	details ifNotNil: ["ensure project info matches real project name"		details at: 'projectname' put: self name.	].	self doWeWantToRename ifFalse: [^aBlock value].	EToyProjectDetailsMorph		getFullInfoFor: self 		ifValid: [			World displayWorldSafely.			aBlock value.		] fixTemps		expandedFormat: false! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 3/6/2000 17:15'!uniClasesDo: aBlock	"Examine structures and execute the block with each instance-specific class"	| cls |	structures keysDo: [:clsName | 		(clsName endsWith: ' class') ifFalse: [			(cls := Smalltalk at: clsName) isSystemDefined ifFalse: [					aBlock value: cls]]]! !!HTTPDownloadRequest methodsFor: 'accessing' stamp: 'mir 10/4/1999 18:26'!content: retrievedContent	content := retrievedContent.	semaphore signal! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 20:53'!exportCategoryNamed: catName	"CodeLoader exportCategoryNamed: 'OceanicPanic' "	| list |	list := SystemOrganization listAtCategoryNamed: catName asSymbol.	self exportClassesNamed: list to: catName! !!ChangeRecord methodsFor: 'access' stamp: ''!methodClass 	| methodClass |	type == #method ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	methodClass := Smalltalk at: class asSymbol.	meta ifTrue: [^ methodClass class]		ifFalse: [^ methodClass]! !!Preferences class methodsFor: 'preferences panel' stamp: 'rr 10/1/2005 15:14'!categoryNames	| aSet |	aSet := Set new.	self dictionaryOfPreferences  do:			[:aPreference | 			aSet  addAll:(aPreference categoryList 						 collect:[:aCategory | aCategory asSymbol])].	^ aSet! !!SystemDictionary methodsFor: 'memory space' stamp: 'sma 4/22/2000 19:03'!memoryHogs	"Answer the list of objects to notify with #freeSomeSpace if memory gets full."	^ MemoryHogs ifNil: [MemoryHogs := OrderedCollection new]! !!HTTPLoader methodsFor: 'initialize/release' stamp: 'mir 10/7/1999 16:59'!release	self abort.	downloads := nil.	requests := nil! !!ReferenceStream methodsFor: 'writing' stamp: 'RAA 1/18/2001 11:51'!setStream: aStream	"PRIVATE -- Initialization method."	super setStream: aStream.	references := IdentityDictionary new: 4096 * 5.	objects := IdentityDictionary new: 4096 * 5.	fwdRefEnds := IdentityDictionary new.	skipping := IdentitySet new.	insideASegment := false.	blockers ifNil: [blockers := IdentityDictionary new].	"keep blockers we just passed in"! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'bf 1/12/2006 19:20'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: '----';			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);			nextPutAll: '----';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: ' priorSource: ';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup].	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!Locale class methodsFor: 'notification' stamp: 'mir 6/30/2004 16:15'!localeChangedListeners	^LocaleChangeListeners ifNil: [LocaleChangeListeners := OrderedCollection new]! !!Project methodsFor: 'project parameters' stamp: 'di 11/16/2001 21:08'!initializeProjectPreferences	"Initialize the project's preferences from currently-prevailing preferences that are currently being held in projects in this system"		projectPreferenceFlagDictionary := Project current projectPreferenceFlagDictionary deepCopy.    "Project overrides in the new project start out being the same set of overrides in the calling project"	Preferences allPreferenceObjects do:  "in case we missed some"		[:aPreference |			aPreference localToProject ifTrue:				[(projectPreferenceFlagDictionary includesKey: aPreference name) ifFalse:			[projectPreferenceFlagDictionary at: aPreference name put: aPreference preferenceValue]]].	self isMorphic ifFalse: [self flapsSuppressed: true].	(Project current projectParameterAt: #disabledGlobalFlapIDs  ifAbsent: [nil]) ifNotNilDo:		[:idList | self projectParameterAt: #disabledGlobalFlapIDs put: idList copy]! !!HTTPClient class methodsFor: 'post/get' stamp: 'mir 5/1/2001 15:06'!httpPostDocument: url target: target args: argsDict	| argString stream content |	^self shouldUsePluginAPI		ifTrue: [			argString := argsDict				ifNotNil: [argString := HTTPSocket argString: argsDict]				ifNil: [''].			stream := FileStream post: argString , ' ' target: target url: url , argString ifError: [self error: 'Error in post to ' , url printString].			stream position: 0.			content := stream upToEnd.			stream close.			MIMEDocument content: content]		ifFalse: [HTTPSocket httpPostDocument: url  args: argsDict]! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:29'!parityType: anInteger	"Set the parity type for this serial port, where:		0 - no parity		1 - odd parity		2 - even parity"	parityType := anInteger.! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 20:53'!exportClassesNamed: classNameList to: aFileName	| classList |	classList := OrderedCollection new.	classNameList do: [:nm | classList add: (Smalltalk at: nm); add: (Smalltalk at: nm) class].	self exportCodeSegment: aFileName classes: classList keepSource: true! !!SerialPort methodsFor: 'open/close' stamp: 'jm 5/18/1998 15:40'!close	"Close the serial port. Do nothing if the port is not open."	port ifNotNil: [self primClosePort: port].	port := nil.! !!SimpleServiceEntry methodsFor: 'services menu' stamp: 'hg 8/1/2000 19:54'!useLineAfter: aBoolean	useLineAfter := aBoolean! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 09:37'!absorbClass: className from: otherChangeSet	"Absorb into the receiver all the changes found in the class in the other change set.	*** Classes renamed in otherChangeSet may have problems"	| cls |	(self changeRecorderFor: className)			assimilateAllChangesIn: (otherChangeSet changeRecorderFor: className).	(cls := Smalltalk classNamed: className) ifNotNil:		[self absorbStructureOfClass: cls from: otherChangeSet].! !!MethodReference methodsFor: 'setting' stamp: 'kph 12/16/2006 10:06'!setStandardClass: aClass methodSymbol: methodSym	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := nil.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 23:32'!processBufferUsingPrimitives: aByteArray	"Process given 64-byte buffer using the primitives, accumulating the results in totals."	| w |	"expand and process the buffer"	w := Bitmap new: 80.	self primExpandBlock: aByteArray into: w.	self primHashBlock: w using: totals.! !!SpaceTally methodsFor: 'class analysis' stamp: 'sd 6/20/2003 22:54'!preAllocateResultsFor: classes	results := OrderedCollection new: classes size.	classes do: [:cl | results add: (SpaceTallyItem analyzedClassName: cl name)].	results := results asArray.! !!SerialPort methodsFor: 'open/close' stamp: 'dns 6/27/2000 19:49'!openPort: portNumber	"Open the given serial port, using the settings specified by my instance variables. If the port cannot be opened, such as when it is alreay in use, answer nil."  "(DNS)"	self close.	(self primClosePort: portNumber) isNil ifTrue: [		^ nil ].	(self primOpenPort: portNumber		baudRate: baudRate		stopBitsType: stopBitsType		parityType: parityType		dataBits: dataBits		inFlowControlType: inputFlowControlType		outFlowControlType: outputFlowControlType		xOnByte: xOnByte		xOffByte: xOffByte) isNil ifTrue: [			^ nil ].	port := portNumber! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:31'!newChangeSet	"Prompt the user for a name, and establish a new change set of	that name (if ok), making it the current changeset.  Return nil	of not ok, else return the actual changeset."	| newName newSet |	newName := UIManager default		request: 'Please name the new change set:'		initialAnswer: ChangeSet defaultName.	newName isEmptyOrNil ifTrue:		[^ nil].	newSet := self basicNewChangeSet: newName.	newSet ifNotNil:		[self  newChanges: newSet].	^ newSet! !!ImageSegmentRootStub class methodsFor: 'settings' stamp: 'di 2/7/2000 23:43'!doLogFaults  "ImageSegmentRootStub doLogFaults"	FaultLogs := Dictionary new.	LoggingFaults := true.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'rbb 2/18/2005 14:21'!chooseSubjectPrefixForEmail	| subjectIndex |	subjectIndex :=		(UIManager default chooseFrom: #('Bug fix [FIX]' 'Enhancement [ENH]' 'Goodie [GOODIE]' 'Test suite [TEST]' 'None of the above (will not be archived)')			title: 'What type of change set\are you submitting to the list?' withCRs).	^ #('[CS] ' '[FIX] ' '[ENH] ' '[GOODIE] ' '[TEST] ' '[CS] ') at: subjectIndex + 1! !!CodeLoader methodsFor: 'installing' stamp: 'sd 1/30/2004 15:16'!installSegment: reqEntry	"Install the previously loaded segment"	| contentStream contents trusted |	contentStream := reqEntry value contentStream.	contentStream ifNil:[^self error:'No content to install: ', reqEntry key printString].	trusted := SecurityManager default positionToSecureContentsOf: contentStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) ifFalse:[		contentStream close.		^self error:'Insecure content encountered: ', reqEntry key printString]].	contents := contentStream ascii upToEnd unzipped.	(contentStream respondsTo: #close) ifTrue:[contentStream close].	^(RWBinaryOrTextStream with: contents) reset fileInObjectAndCode install.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/14/1999 11:40'!processFinalBuffer: buffer bitLength: bitLength	"Process given buffer, whose length may be <= 64 bytes, accumulating the results in totalA through totalE. Also process the final padding bits and length."	| out |	out := ByteArray new: 64.	out replaceFrom: 1 to: buffer size with: buffer startingAt: 1.	buffer size < 56 ifTrue: [  "padding and length fit in last data block"		out at: buffer size + 1 put: 128.  "trailing one bit"		self storeLength: bitLength in: out.  "end with length"		self processBuffer: out.		^ self].	"process the final data block"	buffer size < 64 ifTrue: [		out at: buffer size + 1 put: 128].  "trailing one bit"	self processBuffer: out.	"process one additional block of padding ending with the length"	out := ByteArray new: 64.  "filled with zeros"	buffer size = 64 ifTrue: [		"add trailing one bit that didn't fit in final data block"		out at: 1 put: 128].	self storeLength: bitLength in: out.	self processBuffer: out.! !!SystemChangeNotifier methodsFor: 'initialize' stamp: 'NS 1/26/2004 20:41'!initialize	eventSource := SystemEventManager new.	silenceLevel := 0.! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 23:03'!monthDayTime24StringFrom: aSecondCount	| aDate aTime |	"From the date/time represented by aSecondCount, produce a string which indicates the date and time in the compact form             ddMMMhhmm		where dd is a two-digit day-of-month, MMM is the alpha month abbreviation and hhmm is the time on a 24-hr clock.          Utilities monthDayTime24StringFrom: Time primSecondsClock"	aDate := Date fromSeconds: aSecondCount.	aTime := Time fromSeconds: aSecondCount \\ 86400.	^ (aDate dayOfMonth asTwoCharacterString), 		(aDate monthName copyFrom: 1 to: 3), 		(aTime hhmm24)! !!Preferences class methodsFor: 'reacting to change' stamp: 'dgd 9/20/2004 19:50'!setNotificationParametersForStandardPreferences	"Set up the notification parameters for the standard preferences that require need them.  When adding new Preferences that require use of the notification mechanism, users declare the notifcation info as part of the call that adds the preference, or afterwards -- the two relevant methods for doing that are: 	Preferences.addPreference:categories:default:balloonHelp:projectLocal:changeInformee:changeSelector:   and	Preference changeInformee:changeSelector:"		"Preferences setNotificationParametersForStandardPreferences"	| aPreference |	#(			(annotationPanes		annotationPanesChanged)		(eToyFriendly			eToyFriendlyChanged)		(infiniteUndo			infiniteUndoChanged)		(uniTilesClassic			classicTilesSettingToggled)		(optionalButtons			optionalButtonsChanged)		(roundedWindowCorners	roundedWindowCornersChanged)		(showProjectNavigator	showProjectNavigatorChanged)		(smartUpdating			smartUpdatingChanged)		(universalTiles			universalTilesSettingToggled)		(showSharedFlaps		sharedFlapsSettingChanged)		(noviceMode		noviceModeSettingChanged)	)  do:			[:pair |				aPreference := self preferenceAt: pair first.				aPreference changeInformee: self changeSelector: pair second]! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'di 9/29/1999 15:45'!segmentDirectory	"Return a directory object for the folder of segments.	Create such a folder if none exists."	| dir folderName |	dir := FileDirectory default.	folderName := dir class localNameFor: self folder. "imageName:=segs"	(dir includesKey: folderName) ifFalse:		[dir createDirectory: folderName].	"create the folder if necess"	^ dir directoryNamed: folderName! !!Utilities class methodsFor: 'fetching updates' stamp: 'edc 7/28/2007 10:45'!newUpdatesOn: serverList special: indexPrefix throughNumber: aNumber	"Return a list of fully formed URLs of update files we do not yet have.  Go to the listed servers and look at the file 'updates.list' for the names of the last N update files.  We look backwards for the first one we have, and make the list from there.  tk 9/10/97	No updates numbered higher than aNumber (if it is not nil) are returned " 	| existing doc list out ff raw char maxNumber itsNumber |	maxNumber := aNumber ifNil: [99999].	out := OrderedCollection new.	existing := SystemVersion current updates.	serverList do: [:server |		doc := HTTPClient httpGet: 'http://' , server,indexPrefix,'updates.list'.				"test here for server being up"		doc class == RWBinaryOrTextStream ifTrue:			[raw := doc reset; contents.	"one file name per line"			list := self extractThisVersion: raw.			list reverseDo: [:fileName |				ff := (fileName findTokens: '/') last.	"allow subdirectories"				itsNumber := ff initialIntegerOrNil. 				(existing includes: itsNumber)					ifFalse:						[						(itsNumber == nil or: [itsNumber <= maxNumber])							ifTrue:								[out addFirst: 'http://' , server, fileName]]					ifTrue: [^ out]].			((out size > 0) or: [char := doc reset; skipSeparators; next.				(char == $*) | (char == $#)]) ifTrue:					[^ out "we have our list"]].	"else got error msg instead of file"		"Server was down, try next one"].	self inform: 'All code update servers seem to be unavailable'.	^ out! !!ReferenceStream methodsFor: 'writing' stamp: 'RAA 1/18/2001 11:51'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	super setStream: aStream reading: isReading.	"isReading ifFalse: [  when we are sure"	references := IdentityDictionary new: 4096 * 5.	isReading ifTrue: [		objects := IdentityDictionary new: 4096 * 5.		skipping := IdentitySet new.		insideASegment := false.		fwdRefEnds := IdentityDictionary new].	blockers ifNil: [blockers := IdentityDictionary new].	"keep blockers we just passed in"! !!MidiPrimTester methodsFor: 'private' stamp: 'jm 5/18/1998 15:32'!openPort: portNum andDo: aBlock	"Open the given MIDI port, evaluate the block, and close the port again. Answer the value of the block."	| result |	self primMIDIClosePort: portNum.	self primMIDIOpenPort: portNum readSemaIndex: 0 interfaceClockRate: 1000000.	result := aBlock value.	self primMIDIClosePort: portNum.	^ result! !!Preferences class methodsFor: 'personalization' stamp: 'nk 11/17/2002 11:40'!loadPreferencesFrom: aFileName	| stream params dict desktopColor |	stream := ReferenceStream fileNamed: aFileName.	params := stream next.	self assert: (params isKindOf: IdentityDictionary).	params removeKey: #PersonalDictionaryOfPreferences.	dict := stream next.	self assert: (dict isKindOf: IdentityDictionary).	desktopColor := stream next.	stream close.	dict keysAndValuesDo:		[:key :value | (self preferenceAt: key ifAbsent: [nil]) ifNotNilDo:			[:pref | pref preferenceValue: value preferenceValue]].	params keysAndValuesDo: [ :key :value | self setParameter: key to: value ].	Smalltalk isMorphic		ifTrue: [ World fillStyle: desktopColor ]		ifFalse: [ self desktopColor: desktopColor. ScheduledControllers updateGray ].! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'ads 7/31/2003 14:01'!generateKeySet	"Generate and answer a key set for code signing. The result is a pair (<private key><public key>). Each key is an array of four large integers. The signer must be sure to record this keys set and must keep the private key secret to prevent someone from forging their signature."	"Note: Key generation can take some time. Open a transcript so you can see what's happening and take a coffee break!!"	"Note: Unguessable random numbers are needed for key generation. The user will be prompted to type a really long random string (two or three lines) to initialize the random number generator before generating a key set. A different random string should be typed for every session; it is not a password and we wish to produce different random number streams."	"DigitalSignatureAlgorithm generateKeySet"	| dsa |	dsa := DigitalSignatureAlgorithm new.	(self confirm: 'Shall I seed the random generator from the current sound input?')		ifTrue: [dsa initRandomNonInteractively]		ifFalse: [dsa initRandomFromUser].	^ dsa generateKeySet! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'nk 8/21/2004 15:55'!writeRecentCharacters: nCharacters toFileNamed: aFilename	"Schedule an editable text view on the last n characters of changes."	| changes |	changes := SourceFiles at: 2.	changes setToEnd; skip: nCharacters negated.	(StandardFileStream newFileNamed: aFilename) nextPutAll: (changes next: nCharacters); close; open; edit! !!DataStream methodsFor: 'write and read' stamp: 'tk 6/8/1998 21:03'!readString	| str |	byteStream ascii.	str := byteStream nextString.	byteStream binary.	^ str! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 3/6/2000 11:05'!rootsIncludingBlockMethods	"Return a new roots array with more objects.  (Caller should store into rootArray.) Any CompiledMethods that create blocks will be in outPointers if the block is held outside of this segment.  Put such methods into the roots list.  Then ask for the segment again."| extras myClasses gotIt |userRootCnt ifNil: [userRootCnt := arrayOfRoots size].extras := OrderedCollection new.myClasses := OrderedCollection new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [					myClasses add: aRoot]].myClasses isEmpty ifTrue: [^ nil].	"no change"outPointers do: [:anOut | 	anOut class == CompiledMethod ifTrue: [		"specialized version of who"		gotIt := false.		myClasses detect: [:class |			class selectorsDo: [:sel |				(class compiledMethodAt: sel) == anOut 					ifTrue: [extras add: anOut.  gotIt := true]].			gotIt] 			ifNone: []		].	anOut := nil].extras := extras select: [:ea | (arrayOfRoots includes: ea) not].extras isEmpty ifTrue: [^ nil].	"no change"^ arrayOfRoots, extras! !!SmalltalkImage methodsFor: 'modules' stamp: 'sd 9/30/2003 14:00'!listBuiltinModules	"SmalltalkImage current listBuiltinModules"	"Return a list of all builtin modules (e.g., plugins). Builtin plugins are those that are 	compiled with the VM directly, as opposed to plugins residing in an external shared library. 	The list will include all builtin plugins regardless of whether they are currently loaded 	or not. Note that the list returned is not sorted!!"	| modules index name |	modules := WriteStream on: Array new.	index := 1.	[true] whileTrue:[		name := self listBuiltinModule: index.		name ifNil:[^modules contents].		modules nextPut: name.		index := index + 1.	].! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sd 4/17/2003 21:04'!fixUpProblemsWithAllCategory	"Moves all methods that are in formally classified a category named '-- all --' into the default 'as yet unclassified' category"	"Utilities fixUpProblemsWithAllCategory"	| org aCategory methodCount classCount any |	self flag: #ShouldBeMovedInClassOrganization.	methodCount := 0.	classCount := 0.	self systemNavigation allBehaviorsDo:		[:aClass | org := aClass organization.			(org categories includes: #'-- all --') ifTrue:				[any := false.				aClass selectorsDo:					[:aSelector |						aCategory := org categoryOfElement: aSelector.						aCategory = #'-- all --' ifTrue:							[org classify: aSelector under: ClassOrganizer default suppressIfDefault: false.							Transcript cr; show: aClass name, ' >> ', aSelector.							methodCount := methodCount + 1.							any := true]].			any ifTrue: [classCount := classCount + 1].			org removeEmptyCategories]].	Transcript cr; show: methodCount printString, ' methods in ', classCount printString, ' classes moved from "-- all --" to "as yet unclassified"'! !!Utilities class methodsFor: 'common requests' stamp: 'dgd 9/21/2003 13:52'!offerCommonRequestsInMorphic	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| aMenu  strings |	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].	strings := CommonRequestStrings contents.	aMenu := MenuMorph new.	aMenu title: 'Common Requests' translated.	aMenu addStayUpItem.	strings asString linesDo:		[:aString |			aString = '-'				ifTrue:					[aMenu addLine]				ifFalse:					[aString size == 0 ifTrue: [aString := ' '].					aMenu add: aString target: self selector: #eval: argument: aString]].	aMenu addLine.	aMenu add: 'edit this list' translated target: self action: #editCommonRequestStrings.	aMenu popUpInWorld: self currentWorld! !!DataStream class methodsFor: 'as yet unclassified' stamp: ''!fileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr := ReferenceStream fileNamed: 'test.obj'.rr nextPut: <your object>.rr close."	| strm |	strm := self on: (FileStream fileNamed: aString).		"will be binary"	strm byteStream setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	^ strm! !!ProjectLoading class methodsFor: 'loading' stamp: 'RAA 2/20/2001 20:25'!installRemoteNamed: remoteFileName from: aServer named: otherProjectName in: currentProject	| fileAndDir |	"Find the current ProjectViewMorph, fetch the project, install in ProjectViewMorph without changing size, and jump into new project."	ProgressNotification signal: '1:foundMostRecent'.	fileAndDir := self bestAccessToFileName: remoteFileName andDirectory: aServer.	^self 		openName: remoteFileName 		stream: fileAndDir first 		fromDirectory: fileAndDir second		withProjectView: (currentProject findProjectView: otherProjectName).! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'yo 2/24/2005 18:01'!reformatChangesToUTF8	"Smalltalk reformatChangesToUTF8"	| f oldChanges classCount |	f := FileStream fileNamed: 'ST80.temp'.	f converter: (UTF8TextConverter new).	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount := 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount := classCount + 1).			class moveChangesTo: f.			class putClassCommentToCondensedChangesFile: f.			class class moveChangesTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (FileStream oldFileNamed: oldChanges name).	MultiByteFileStream codeConverterClass: UTF8TextConverter.	(SourceFiles at: 2) converter: (UTF8TextConverter new).! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 19:06'!orderedTraitsIn: category 	"Answer an OrderedCollection containing references to the traits in the 	category whose name is the argument, category (a string). The traits 	are ordered so they can be filed in."	| behaviors traits |	behaviors := (self listAtCategoryNamed: category asSymbol) 			collect: [:title | Smalltalk at: title].	traits := behaviors reject: [:each | each isBehavior].	traits := traits asSortedCollection: [:t1 :t2 |		(t2 traitComposition allTraits includes: t1)			or: [(t1 traitComposition allTraits includes: t2) not]].	^traits asArray! !!ChangeSet methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!methodChanges	| methodChangeDict changeTypes |	methodChangeDict := Dictionary new.	changeRecords associationsDo:		[:assn |		changeTypes := assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].	^ methodChangeDict! !!SystemNavigation methodsFor: 'ui' stamp: 'rbb 2/18/2005 14:48'!confirmRemovalOf: aSelector on: aClass 	"Determine if it is okay to remove the given selector. Answer 1 if it  	should be removed, 2 if it should be removed followed by a senders  	browse, and 3 if it should not be removed."	| count answer caption allCalls |	allCalls := self allCallsOn: aSelector.	(count := allCalls size) == 0		ifTrue: [^ 1].	"no senders -- let the removal happen without warning"	count == 1		ifTrue: [(allCalls first actualClass == aClass					and: [allCalls first methodSymbol == aSelector])				ifTrue: [^ 1]].	"only sender is itself"	caption := 'This message has ' , count printString , ' sender'.	count > 1		ifTrue: [caption := caption copyWith: $s].	answer := UIManager default 		chooseFrom: #('Remove it'				'Remove, then browse senders'				'Don''t remove, but show me those senders'				'Forget it -- do nothing -- sorry I asked') title: caption.	answer == 3		ifTrue: [self				browseMessageList: allCalls				name: 'Senders of ' , aSelector				autoSelect: aSelector keywords first].	answer == 0		ifTrue: [answer := 3].	"If user didn't answer, treat it as cancel"	^ answer min: 3! !!Preferences class methodsFor: 'misc' stamp: 'em 3/24/2005 14:11'!offerThemesMenu	"Put up a menu offering the user a choice of themes.  Each theme is represented by a method in category #themes in Preferences class.  The comment at the front of each method is used as the balloon help for the theme"	"Preferences offerThemesMenu"	| selectors aMenu |	selectors := self class allMethodsInCategory: #themes.	selectors := selectors select: [:sel | sel numArgs = 0].	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Choose a theme to install' translated.	selectors do:		[:sel |			aMenu add: sel target: self selector: #installTheme: argument: sel.			aMenu balloonTextForLastItem: (self class firstCommentAt: sel)].	aMenu addLine.	aMenu add: 'browse themes' translated target: self action: #browseThemes.	aMenu balloonTextForLastItem: 'Puts up a tool that will allow you to view and edit the code underlying all of the available themes' translated.	aMenu popUpInWorld.	"(Workspace new contents: 'here is an example of a new window with your new theme installed' translated) openLabel: 'Testing one two three'"! !!Utilities class methodsFor: 'scraps' stamp: 'yo 7/2/2004 21:49'!scrapsBook	| header aButton label |	ScrapsBook ifNil:		[ScrapsBook := BookMorph new pageSize: 200@300; setNameTo: 'scraps' translated.		ScrapsBook color: Color yellow muchLighter.		ScrapsBook borderColor: Color darkGray; borderWidth: 2.		ScrapsBook removeEverything; showPageControls; insertPage.		header := AlignmentMorph newRow wrapCentering: #center; cellPositioning: #leftCenter.		header setProperty: #header toValue: true.		header addMorph: (aButton := SimpleButtonMorph new label: 'O' font: Preferences standardButtonFont).		aButton target: ScrapsBook; color:  Color tan; actionSelector: #delete;				setBalloonText: 'Close the trashcan.(to view again later, click on any trashcan).' translated.		header addMorphBack: AlignmentMorph newVariableTransparentSpacer beSticky.		header addMorphBack: 	(label := UpdatingStringMorph new target: self) beSticky.		label getSelector: #trashTitle; useStringFormat; step.		header addMorphBack: AlignmentMorph newVariableTransparentSpacer beSticky.		header addMorphBack: (aButton := SimpleButtonMorph new label: 'E' translated font: Preferences standardButtonFont).		aButton target: Utilities; color:  Color veryLightGray; actionSelector: #maybeEmptyTrash;				setBalloonText: 'Click here to empty the trash.' translated.		ScrapsBook currentPage addMorph: (TextMorph new contents: 'Objects you drag into the trash will automatically be saved here, one object per page, in case you need them later.  To disable this feature set the "preserveTrash" Preference to false.You can individually expunge objects by hitting the - control, and you can empty out all the objects in the trash can by hitting the "E" button at top right.' translated			wrappedTo: 190).		ScrapsBook addMorphFront: header.		ScrapsBook setProperty: #scraps toValue: true].	^ ScrapsBook	"Utilities emptyScrapsBook"! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/14/1999 11:10'!storeLength: bitLength in: aByteArray	"Fill in the final 8 bytes of the given ByteArray with a 64-bit big-endian representation of the original message length in bits."	| n i |	n := bitLength.	i := aByteArray size.	[n > 0] whileTrue: [		aByteArray at: i put: (n bitAnd: 16rFF).		n := n bitShift: -8.		i := i - 1].! !!ExternalSettings class methodsFor: 'class initialization' stamp: 'mir 11/16/2001 13:29'!startUp	"Look for external defs and load them."	"ExternalSettings startUp"	| prefDir |	prefDir := self preferenceDirectory.	prefDir		ifNil: [^self].	self registeredClients do: [:client | 		client fetchExternalSettingsIn: prefDir]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 9/6/2000 09:06'!cleanseOtherworldlySteppers	"If the current project is a morphic one, then remove from its steplist those morphs that are not really in the world"	| old delta |	Smalltalk isMorphic ifTrue:		[old := self currentWorld stepListSize.		self currentWorld steppingMorphsNotInWorld do: [:m | m delete].		self currentWorld cleanseStepList.		(delta := (old - self currentWorld stepListSize)) > 0 ifTrue:			[Transcript cr; show: (delta asString, ' morphs removed from steplist')]]	"Utilities cleanseOtherworldlySteppers"! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'tk 12/16/1999 22:33'!uniqueFileNameFor: segName	"Choose a unique file name for the segment with this name."	| segDir fileName listOfFiles |	segDir := self segmentDirectory.	listOfFiles := segDir fileNames.	BiggestFileNumber ifNil: [BiggestFileNumber := 1].	BiggestFileNumber > 99 ifTrue: [BiggestFileNumber := 1].	"wrap"	[fileName := segName, BiggestFileNumber printString, '.seg'.	 (listOfFiles includes: fileName)] whileTrue: [		BiggestFileNumber := BiggestFileNumber + 1].	"force a unique file name"	^ fileName! !!DiskProxy methodsFor: 'accessing' stamp: 'tk 4/8/1999 12:54'!preSelector: aSelector	preSelector := aSelector! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:28'!xOffByte: anInteger	"Set the value of the XOff byte to be used if XOn/XOff flow control is enabled."	xOffByte := anInteger.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:38'!outputFlowControlType: anInteger	"Set the type of output flow control, where:		0 - none		1 - XOn/XOff		2 - hardware handshaking"	outputFlowControlType := anInteger.! !!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:34'!spyOn: aBlock toFileNamed: fileName 	"Spy on the evaluation of aBlock. Write the data collected on a file	named fileName."	| file value node |	node := self new.	value := node spyEvery: self defaultPollPeriod on: aBlock.	file := FileStream newFileNamed: fileName.	node report: file; close.	file close.	^value! !!CachedHTTPDownloadRequest methodsFor: 'accessing' stamp: 'ar 12/14/1999 14:53'!cachedName: aString	cachedName := aString.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 12/17/1999 00:03'!localName	| segs ind sep |	"Return the current file name for this segment, a local name in the segments directory."	fileName ifNil: [^ nil].	"^ fileName"		"The following is for backward compatibility.  Remove this part after June 2000.	Check if the fileName is a full path, and make it local.  Regardless of current or previous file system delimiter."	segs := self class folder copyLast: 4.  ":=segs"	ind := 1.	[ind := fileName findString: segs startingAt: ind+1 caseSensitive: false.		ind = 0 ifTrue: [^ fileName].		sep := fileName at: ind + (segs size).		sep isAlphaNumeric ] whileTrue.		"sep is letter or digit, not a separator"	^ fileName := fileName copyFrom: ind+(segs size)+1 "delimiter" to: fileName size! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'rbb 2/18/2005 14:16'!lookForSlips	"Scan the receiver for changes that the user may regard as slips to be remedied"	| slips nameLine msg |	nameLine := '"', self name, '"'.	(slips := self checkForSlips) size == 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg := slips size == 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(UIManager default  chooseFrom: #('Ignore' 'Browse slips') title: msg) = 2		ifTrue: [self systemNavigation  browseMessageList: slips							name: 'Possible slips in ', name]! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'hh 8/3/2000 18:18'!verifySignature: aSignature ofMessageHash: hash publicKey: publicKey	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."	| p q g y r s w u1 u2 v0 v |	p := publicKey first.	q := publicKey second.	g := publicKey third.	y := publicKey fourth.	r := aSignature first.	s := aSignature last.	((r > 0) and: [r < q]) ifFalse: [^ false].  "reject"	((s > 0) and: [s < q]) ifFalse: [^ false].  "reject"	w := self inverseOf: s mod: q.	u1 := (hash * w) \\ q.	u2 := (r * w) \\ q.	v0 := (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).	v := ( v0 \\ p) \\ q.	^ v = r! !!Project methodsFor: 'file in/out' stamp: 'rbb 2/18/2005 08:51'!loadFromServer: newerAutomatically	"If a newer version of me is on the server, load it."	| pair resp server |	self assureIntegerVersion.	self isCurrentProject ifTrue: ["exit, then do the command"		^ self armsLengthCommand: #loadFromServer withDescription: 'Loading' translated	].	server := self tryToFindAServerWithMe ifNil: [^ nil].	pair := self class mostRecent: self name onServer: server.	pair first ifNil: [^ self inform: ('can''t find file on server for {1}' translated format: {self name})].	self currentVersionNumber > pair second ifTrue: [		^ self inform: ('That server has an older version of the project.' translated)].	version = (Project parseProjectFileName: pair first) second ifTrue: [		resp := (UIManager default chooseFrom: 				(Array with: 'Reload anyway' translated 						with: 'Cancel' translated withCRs) 				title:  'The only changes are the ones you made here.' translated).		resp ~= 1 ifTrue: [^ nil]	] ifFalse: [		newerAutomatically ifFalse: [			resp := (UIManager default 						chooseFrom: #('Load it' 'Cancel') 						title:  'A newer version exists on the server.').			resp ~= 1 ifTrue: [^ nil]		].	].	"let's avoid renaming the loaded change set since it will be replacing ours"	self projectParameters at: #loadingNewerVersion put: true.	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			ProjectLoading				installRemoteNamed: pair first				from: server				named: self name				in: parentProject		]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 6/22/2000 17:49'!scanFrom: aStream	"Move source code from a fileIn to the changes file for classes in an ImageSegment.  Do not compile the methods.  They already came in via the image segment.  After the ImageSegment in the file, !!ImageSegment new!! captures control, and scanFrom: is called."	| val chunk |	[aStream atEnd] whileFalse: 		[aStream skipSeparators.		val := (aStream peekFor: $!!)			ifTrue: ["Move (aStream nextChunk), find the method or class 						comment, and install the file location bytes"					(Compiler evaluate: aStream nextChunk logged: false)						scanFromNoCompile: aStream forSegment: self]			ifFalse: [chunk := aStream nextChunk.					aStream checkForPreamble: chunk.					Compiler evaluate: chunk logged: true].		aStream skipStyleChunk].	"regular fileIn will close the file"	^ val! !!PreferenceViewRegistry methodsFor: 'initialize-release' stamp: 'hpt 9/26/2004 16:22'!initialize	viewOrder := 1.! !!SmartRefStream methodsFor: 'accessing' stamp: 'tk 5/19/1999 15:47'!superclasses: anObject	superclasses := anObject! !!SimpleServiceEntry methodsFor: 'accessing' stamp: 'RAA 2/2/2002 08:14'!argumentGetter: aBlock	argumentGetter := aBlock! !!Project class methodsFor: 'utilities' stamp: 'RAA 9/27/2000 18:52'!storeAllInSegments	"Write out all Projects in this Image.	Project storeAllInSegments.		"	| all ff ll |all := Project allProjects.Transcript show: 'Initial Space Left: ', (ff := Smalltalk garbageCollect) printString; cr.all do: [:proj |	Transcript show: proj name; cr.	proj storeSegment  "storeSegmentNoFile"].Transcript show: 'After writing all: ', (ll := Smalltalk garbageCollect) printString; cr.Transcript show: 'Space gained: ', (ll - ff) printString; cr."some will come back in"! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 20:41'!allMethodsSelect: aBlock 	"Answer a SortedCollection of each method that, when used as the block  	argument to aBlock, gives a true result."	| aCollection |	aCollection := SortedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsDo: [:sel | (aBlock									value: (class compiledMethodAt: sel))								ifTrue: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'jm 12/22/1999 11:23'!example	"Example of signing a message and verifying its signature."	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm example"	| msg keys sig |	msg := 'This is a test...'.	keys := self testKeySet.	sig := self sign: msg privateKey: keys first.	self inform: 'Signature created'.	(self verify: sig isSignatureOf: msg publicKey: keys last)		ifTrue: [self inform: 'Signature verified.']		ifFalse: [self error: 'ERROR!! Signature verification failed'].! !!Project methodsFor: 'project parameters' stamp: 'sw 10/27/2000 06:46'!currentStack	"Answer the current stack of the current project.  Called basically as a bail-out when we can't find the stack in the owner chain of a morph, probably because it is on a background that is not currently installed.  This method will always return a stack that is in the world, or nil if no stack is found in the world.  Of course it would be nice to have multiple stacks concurrently open in the same world, but at the moment that is problematical."	| aStack curStack |	curStack := self projectParameterAt: #CurrentStack.	curStack ifNotNil: [curStack isInWorld ifTrue: [^ curStack]].	(aStack := world findA: StackMorph) ifNotNil:		[self currentStack: aStack].	^ aStack! !!SecureHashAlgorithm class methodsFor: 'class initialization' stamp: 'jm 12/7/1999 23:25'!initialize	"SecureHashAlgorithm initialize"	"For the curious, here's where these constants come from:	  #(2 3 5 10) collect: [:x | ((x sqrt / 4.0) * (2.0 raisedTo: 32)) truncated hex]"	K1 := ThirtyTwoBitRegister new load: 16r5A827999.	K2 := ThirtyTwoBitRegister new load: 16r6ED9EBA1.	K3 := ThirtyTwoBitRegister new load: 16r8F1BBCDC.	K4 := ThirtyTwoBitRegister new load: 16rCA62C1D6.! !!Project methodsFor: 'initialization' stamp: 'RAA 10/13/2000 18:21'!setServer	"Mark me as a new project.  See if a server is known, remember it."	self projectParameters at: #exportState put: #nacent.	urlList isEmptyOrNil ifTrue: [urlList := parentProject urlList].! !!CodeLoader methodsFor: 'initialize-release' stamp: 'mir 1/11/2000 13:47'!initialize	publicKey := DefaultKey.	baseURL := self class defaultBaseURL! !!ProjectHistory methodsFor: 'project lifetime' stamp: 'RAA 9/27/2000 20:49'!cleanUp	| proj |	mostRecent := mostRecent reject: [ :each |		proj := each fourth first.		proj isNil or: [proj world isNil]	].	self changed.! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 2/19/2001 07:37'!squeakletDirectory	| squeakletDirectoryName |	squeakletDirectoryName := 'Squeaklets'.	(FileDirectory default directoryExists: squeakletDirectoryName) ifFalse: [		FileDirectory default createDirectory: squeakletDirectoryName	].	^FileDirectory default directoryNamed: squeakletDirectoryName! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 7/2/2003 10:47'!methodsWithoutComments	"Return a collection representing methods in the receiver which have no precode comments"	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[(aClass selectors includes:  mAssoc key) ifTrue:						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutComments) name: 'methods lacking comments'"! !!Imports class methodsFor: 'instance creation' stamp: 'nk 7/12/2003 10:38'!default	"Answer my default instance, creating one if necessary."	"Imports default"	^default ifNil: [ default := self new ]! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/20/2003 14:11'!browseMethodsWithSourceString: aString 	"SystemNavigation new browseMethodsWithSourceString: 'SourceString'"	"Launch a browser on all methods whose source code contains aString as 	a substring."	| caseSensitive suffix |	suffix := (caseSensitive := Sensor shiftPressed)				ifTrue: [' (case-sensitive)']				ifFalse: [' (use shift for case-sensitive)'].	^ self		browseMessageList: (self allMethodsWithSourceString: aString matchCase: caseSensitive)		name: 'Methods containing ' , aString printString , suffix		autoSelect: aString! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 8/18/2000 21:15'!useUpMemoryWithArrays 	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemoryWithArrays"	| b |  "First use up most of memory."	b := String new: self bytesLeft - self lowSpaceThreshold - 100000.	b := b.  "Avoid unused value warning"	(1 to: 10000) collect: [:i | Array new: 10000]! !!ImageSegment methodsFor: 'instance change shape' stamp: 'tk 1/25/2000 21:54'!ifOutPointer: anObject thenAllObjectsDo: aBlock	| withSymbols segSize |	"If I point out to anObject, bring me in, Submit all my objects to the block.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols := state = #onFileWithSymbols.	(outPointers includes: anObject) ifFalse: [^ self].	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize := segment size.	self install.	self allObjectsDo: [:obj | aBlock value: obj].	"do the work"	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!SystemNavigation methodsFor: 'browse' stamp: 'ar 9/27/2005 20:34'!browseMessageList: messageList name: labelString autoSelect: autoSelectString	| title aSize |	"Create and schedule a MessageSet browser on the message list."	messageList size = 0 ifTrue: 		[^ self inform: 'There are no' , labelString].	title := (aSize := messageList size) > 1		ifFalse:	[labelString]		ifTrue:	[ labelString, ' [', aSize printString, ']'].	ToolSet 		browseMessageSet: messageList 		name: title 		autoSelect: autoSelectString! !!ChangeRecord methodsFor: 'initialization' stamp: 'tk 6/24/1999 14:51'!class: clsName category: cat method: method sourceFiles: fileArray	"This should be enough to find all the information for a method, or method deletion"	file := fileArray at: method fileIndex.	position := method filePosition.	type := #method.	class := clsName copyUpTo: $ .	"the non-meta part of a class name"	category := cat.	meta := clsName endsWith: ' class'.	self readStamp.! !!Preferences class methodsFor: 'preferences panel' stamp: 'jrp 7/9/2005 18:51'!preferencesControlPanel	"Answer a Preferences control panel window"	"Preferences preferencesControlPanel openInHand"	| window playfield aPanel |	aPanel := PreferencesPanel new.	playfield := PasteUpMorph new width: 385.	playfield dropEnabled: false.	window := (SystemWindow labelled: 'Preferences') model: aPanel.	self initializePreferencePanel: aPanel in: playfield.	window on: #keyStroke send: #keyStroke: to: aPanel.	window bounds: (100 @ 100 - (0 @ window labelHeight + window borderWidth) extent: playfield extent + (2 * window borderWidth)).	window addMorph: playfield frame: (0 @ 0 extent: 1 @ 1).	window updatePaneColors.	window setProperty: #minimumExtent toValue: playfield extent + (12@15).	^ window! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 17:26'!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy := srcPos copy.	srcPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	dstPosCopy := dstPos copy.	dstPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!DataStream methodsFor: 'other' stamp: ''!close	"Close the stream."	| bytes |	byteStream closed 		ifFalse: [			bytes := byteStream position.			byteStream close]		ifTrue: [bytes := 'unknown'].	^ bytes! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!leavesPrintOn: aStream tallyExact: isExact orThreshold: threshold	| dict |	dict := IdentityDictionary new: 100.	self leavesInto: dict fromSender: nil.	isExact ifTrue: 		[dict asSortedCollection			do: [:node |				node printOn: aStream total: tally totalTime: nil tallyExact: isExact.				node printSenderCountsOn: aStream]]		ifFalse:		[(dict asOrderedCollection				select: [:node | node tally > threshold])			asSortedCollection			do: [:node |				node printOn: aStream total: tally totalTime: time tallyExact: isExact]]! !!Utilities class methodsFor: 'fetching updates' stamp: 'sr 2/12/2001 03:38'!applyUpdatesFromDisk	"Utilities applyUpdatesFromDisk"	"compute highest update number"	| updateDirectory updateNumbers |	updateDirectory := self getUpdateDirectoryOrNil.	updateDirectory		ifNil: [^ self].	updateNumbers := updateDirectory fileNames				collect: [:fn | fn initialIntegerOrNil]				thenSelect: [:fn | fn notNil].	self		applyUpdatesFromDiskToUpdateNumber: (updateNumbers				inject: 0				into: [:max :num | max max: num])		stopIfGap: false! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:57'!safelyRegisterExternalObject: anObject	"Register the given object in the external objects array and return its index. If it is already there, just return its index."	| objects firstEmptyIndex obj sz newObjects |	objects := Smalltalk specialObjectsArray at: 39.	"find the first empty slot"	firstEmptyIndex := 0.	1 to: objects size do: [:i |		obj := objects at: i.		obj == anObject ifTrue: [^ i].  "object already there, just return its index"		(obj == nil and: [firstEmptyIndex = 0]) ifTrue: [firstEmptyIndex := i]].	"if no empty slots, expand the array"	firstEmptyIndex = 0 ifTrue: [		sz := objects size.		newObjects := objects species new: sz + 20.  "grow linearly"		newObjects replaceFrom: 1 to: sz with: objects startingAt: 1.		firstEmptyIndex := sz + 1.		Smalltalk specialObjectsArray at: 39 put: newObjects.		objects := newObjects].	objects at: firstEmptyIndex put: anObject.	^ firstEmptyIndex! !!SmalltalkImage methodsFor: 'utilities' stamp: 'sd 1/16/2004 20:54'!stripMethods: tripletList messageCode: messageString	"Used to 'cap' methods that need to be protected for proprietary reasons, etc.; call this with a list of triplets of symbols of the form  (<class name>  <#instance or #class> <selector name>), and with a string to be produced as part of the error msg if any of the methods affected is reached"	| aClass sel keywords codeString |	tripletList do:		[:triplet |  			(aClass := (Smalltalk at: triplet first ifAbsent: [nil])) notNil ifTrue:				[triplet second == #class ifTrue:					[aClass := aClass class].				sel := triplet third.				keywords := sel keywords.				(keywords size == 1 and: [keywords first asSymbol isKeyword not])					ifTrue:						[codeString := keywords first asString]					ifFalse:						[codeString := ''.						keywords withIndexDo:							[:kwd :index |								codeString := codeString, ' ', (keywords at: index), ' ',									'arg', index printString]].				codeString := codeString, '	self codeStrippedOut: ', (messageString surroundedBySingleQuotes).				aClass compile: codeString classified: 'stripped']]! !!DataStream methodsFor: 'write and read' stamp: 'tk 1/8/97'!readInstance	"PRIVATE -- Read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  "	| instSize aSymbol refPosn anObject newClass |	instSize := (byteStream nextNumber: 4) - 1.	refPosn := self getCurrentReference.	aSymbol := self next.	newClass := Smalltalk at: aSymbol asSymbol.	anObject := newClass isVariable 	"Create object here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].	self setCurrentReference: refPosn.  "before readDataFrom:size:"	anObject := anObject readDataFrom: self size: instSize.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!Project methodsFor: 'file in/out' stamp: 'mir 6/7/2001 14:41'!fromMyServerLoad: otherProjectName	| pair pr dirToUse |	"If a newer version of me is on the server, load it."	(pr := Project named: otherProjectName) ifNotNil: ["it appeared"		^ pr enter	].	dirToUse := self primaryServerIfNil: [		lastDirectory ifNil: [			self inform: 'Current project does not know a server either.'.			^nil].		lastDirectory].	pair := self class mostRecent: otherProjectName onServer: dirToUse.	pair first ifNil: [^self decideAboutCreatingBlank: otherProjectName].	"nothing to load"	^ProjectLoading		installRemoteNamed: pair first		from: dirToUse		named: otherProjectName		in: self! !!SystemNavigation methodsFor: 'browse' stamp: 'md 8/27/2005 17:17'!browseAllStoresInto: instVarName from: aClass	"Create and schedule a Message Set browser for all the receiver's methods 	or any methods of a subclass/superclass that refer to the instance variable name."		"self new browseAllStoresInto: 'contents' from: Collection."	| coll |	coll := OrderedCollection new.	Cursor wait showWhile: [		aClass withAllSubAndSuperclassesDo: [:class | 			(class whichSelectorsStoreInto: instVarName) do: [:sel |				sel isDoIt ifFalse: [					coll add: (						MethodReference new							setStandardClass: class 							methodSymbol: sel					)				]			]		].	].	^ self		browseMessageList: coll 		name: 'Stores into ' , instVarName 		autoSelect: instVarName! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/27/2003 09:49'!fileInProjectNamed: projectOrMemberName createView: aBoolean 	"This is to be used from preamble/postscript code to file in SAR members 	as Projects. 	Answers the loaded project, or nil. 	Does not enter the loaded project. 	If aBoolean is true, also creates a ProjectViewMorph 	(possibly in a window, depending on your Preferences)."	| member project triple memberName |	member := self memberNamed: projectOrMemberName.	member		ifNotNil: [ memberName := member fileName ]		ifNil: [ 	member := self memberNamed: (memberName := self memberNameForProjectNamed: projectOrMemberName) ].	member ifNil: [ ^self errorNoSuchMember: projectOrMemberName ].	triple := Project parseProjectFileName: memberName unescapePercents.	project := nil.	[[ProjectLoading		openName: triple first		stream: member contentStream		fromDirectory: nil		withProjectView: nil]		on: ProjectViewOpenNotification		do: [:ex | ex resume: aBoolean]]		on: ProjectEntryNotification		do: [:ex | 			project := ex projectToEnter.			ex resume].	self installed: member.	^ project! !!ExternalDropHandler class methodsFor: 'accessing' stamp: 'mir 1/10/2002 17:17'!defaultHandler	DefaultHandler ifNil: [DefaultHandler := ExternalDropHandler type: nil extension: nil action: [:dropStream | dropStream edit]].	^DefaultHandler! !!ToolSet class methodsFor: 'accessing' stamp: 'ar 7/17/2005 10:47'!askForDefault	"Ask for the default implementor"	self registeredClasses isEmpty 		ifTrue:[^ default := nil].	self registeredClasses size = 1 		ifTrue:[^ default := self registeredClasses anyOne].	default := UIManager default 		chooseFrom: (self registeredClasses collect:[:each| each name printString])		values: self registeredClasses		title: 'Which ', self appName, ' would you prefer?'.	^default.! !!Project methodsFor: 'flaps support' stamp: 'sw 4/17/2001 12:49'!isFlapIDEnabled:  aFlapID	"Answer whether a flap of the given ID is enabled in this project"	| disabledFlapIDs  |	disabledFlapIDs := self parameterAt: #disabledGlobalFlapIDs ifAbsent: [^ true].	^ (disabledFlapIDs includes: aFlapID) not! !!SmartRefStream methodsFor: 'accessing' stamp: 'tk 5/19/1999 15:47'!structures: anObject	structures := anObject! !!TextDiffBuilder methodsFor: 'creating patches' stamp: ''!detectShiftedRuns	| sortedRuns lastY run shiftedRuns |	runs size < 2 ifTrue: [^ nil].	shiftedRuns := OrderedCollection new.	sortedRuns := SortedCollection sortBlock: [:a1 :a2 | a1 key x < a2 key x].	runs associationsDo: [:assoc | sortedRuns add: assoc].	lastY := sortedRuns first key y.	2 to: sortedRuns size do:[:i | 		run := sortedRuns at: i.		run key y > lastY			ifTrue: [lastY := run key y]			ifFalse: [shiftedRuns add: run]].	^ shiftedRuns! !!CodeLoader methodsFor: 'accessing' stamp: 'ar 12/13/1999 18:19'!baseURL: aString	baseURL := aString.! !!ResourceManager methodsFor: 'accessing' stamp: ''!adjustToNewServer: newResourceUrl from: oldResourceUrl	"Adjust the resource manager to the current download location. A project might have been moved manually to a different location or server."	| urlMap oldUrl newUrl |	newResourceUrl isEmptyOrNil ifTrue: [^self].	urlMap := Dictionary new.	self resourceMap		keysDo: [:locator | 			"Local file refs are not handled well, so work around here"			oldUrl := ResourceLocator make: locator urlString relativeTo: oldResourceUrl.			newUrl := ResourceLocator make: locator urlString relativeTo: newResourceUrl.			oldUrl ~= newUrl				ifTrue: [urlMap at: oldUrl asString unescapePercents put: newUrl asString unescapePercents]].	self resourceMap rehash.	unloaded rehash.	urlMap keysAndValuesDo: [:old :new |		ResourceManager renameCachedResource: old to: new]! !!MczInstaller methodsFor: 'utilities' stamp: 'cwp 8/13/2003 01:58'!parseMember: fileName	| tokens |	tokens := (self scanner scanTokens: (zip contentsOf: fileName)) first.	^ self associate: tokens! !!ResourceManager methodsFor: 'loading' stamp: 'ar 3/2/2001 18:16'!prioritizedUnloadedResources	"Return an array of unloaded resource locators prioritized by some means"	| list |	list := unloaded asArray.	^list sort:[:l1 :l2|		(l1 resourceFileSize ifNil:[SmallInteger maxVal]) <=			(l2 resourceFileSize ifNil:[SmallInteger maxVal])]! !!HTTPLoader methodsFor: 'requests' stamp: 'mir 1/15/2000 22:59'!abort	| oldRequests |	"Abort all requests"	oldRequests := requests.	requests := SharedQueue new.	[oldRequests isEmpty] whileFalse: [		oldRequests next signalAbort].	downloads do: [:each | each ifNotNil: [each terminate]].	downloads := OrderedCollection new! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 1/17/2001 12:15'!acceptSingleMethodSource: aDictionary	| oldClassInfo oldClassName ismeta newName actualClass selector |	oldClassInfo := (aDictionary at: #oldClassName) findTokens: ' '.	"'Class' or 'Class class'"	oldClassName := oldClassInfo first asSymbol.	ismeta := oldClassInfo size > 1.	"must use class var since we may not be the same guy who did the initial work"	newName := RecentlyRenamedClasses ifNil: [		oldClassName	] ifNotNil: [		RecentlyRenamedClasses at: oldClassName ifAbsent: [oldClassName]	].	actualClass := Smalltalk at: newName.	ismeta ifTrue: [actualClass := actualClass class].	selector := actualClass parserClass new parseSelector: (aDictionary at: #methodText).	(actualClass compiledMethodAt: selector ifAbsent: [^self "hosed input"]) 		putSource: (aDictionary at: #methodText)		fromParseNode: nil		class: actualClass		category: (aDictionary at: #category)		withStamp: (aDictionary at: #changeStamp)		inFile: 2		priorMethod: nil.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 6/22/2001 15:40'!findStacks	"Return an array of all the StackMorphs in this project."| guys stacks |guys := StackMorph withAllSubclasses asIdentitySet.stacks := OrderedCollection new.arrayOfRoots do: [:obj |	(guys includes: obj class) ifTrue: [stacks add: obj]].^ stacks! !!Project methodsFor: 'menu messages' stamp: 'RAA 5/16/2001 17:50'!doWeWantToRename	| want |	self hasBadNameForStoring ifTrue: [^true].	(self name beginsWith: 'Unnamed') ifTrue: [^true].	want := world valueOfProperty: #SuperSwikiRename ifAbsent: [false].	world removeProperty: #SuperSwikiRename.	^want! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 3/15/2000 09:51'!objectAfter: ind	"Return the object or free chunk immediately following the given object or free chunk in the segment.  *** Warning: When class ObjectMemory change, be sure to change it here. ***"	| sz word newInd hdrBits |	sz := ((word := segment at: ind "header") bitAnd: 3) = 2   "free block?"		ifTrue: [word bitAnd: 16rFFFFFFFC]		ifFalse: [(word bitAnd: 3) = 0 "HeaderTypeSizeAndClass"			ifTrue: [(segment at: ind-2) bitAnd: 16rFFFFFFFC]			ifFalse: [word bitAnd: "SizeMask" 252]].	newInd := ind + (sz>>2).	"adjust past extra header words"	(hdrBits := (segment atPin: newInd) bitAnd: 3) = 3 ifTrue: [^ newInd].		"If at end, header word will be garbage.  This is OK"	hdrBits = 1 ifTrue: [^ newInd+1].	hdrBits = 0 ifTrue: [^ newInd+2].	^ newInd	"free"! !!StandardSystemFontsTest methodsFor: 'utilities' stamp: 'bp 6/13/2004 18:22'!assert: selector familyName: aString pointSize: anInteger	| font |	font := Preferences perform: selector.	self assert: font familyName = aString.	self assert: font pointSize = anInteger	! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/4/2000 11:05'!noteChangeType: newChangeType	(changeType == #addedThenRemoved and: [newChangeType == #change])		ifTrue: [changeType := #add]		ifFalse: [changeType := newChangeType]! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:18'!copy	| answer |	answer := self class new initialize.	self do: [ :each |		answer add: each	].	^answer! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 17:38'!inputFlowControlType: anInteger	"Set the type of input flow control, where:		0 - none		1 - XOn/XOff		2 - hardware handshaking"	inputFlowControlType := anInteger.! !!DataStream methodsFor: 'write and read' stamp: 'ar 4/10/2005 20:31'!next	"Answer the next object in the stream."	| type selector anObject isARefType pos internalObject |	type := byteStream next.	type ifNil: [pos := byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos := byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType := self noteCurrentReference: type.	selector := #(readNil readTrue readFalse readInteger	"<-4"			readStringOld readSymbol readByteArray		"<-7"			readArray readInstance readReference readBitmap	"<-11"			readClass readUser readFloat readRectangle readShortInst 	"<-16"			readString readWordArray readWordArrayForSegment 	"<-19"			readWordLike readMethod "<-21") at: type.	selector == 0 ifTrue: [pos := byteStream position.	"absolute!!!!"			byteStream close. 			self error: 'file is more recent than this system'. ^ nil].	anObject := self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].		"After reading the externalObject, internalize it.		 #readReference is a special case. Either:		   (1) We actually have to read the object, recursively calling			   next, which internalizes the object.		   (2) We just read a reference to an object already read and			   thus already interalized.		 Either way, we must not re-internalize the object here."	selector == #readReference ifTrue: [^ anObject].	internalObject := anObject comeFullyUpOnReload: self.	internalObject == String ifTrue:[		"This is a hack to figure out if we're loading a String class 		that really should be a ByteString. Note that these days this		will no longer be necessary since we use #withClassVersion:		for constructing the global thus using a different classVersion		will perfectly do the trick."		((anObject isKindOf: DiskProxy) 			and:[anObject globalObjectName == #String			and:[anObject constructorSelector == #yourself]]) ifTrue:[				internalObject := ByteString]].	^ self maybeBeginReference: internalObject! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:28'!buildAggregateChangeSet	"Establish a change-set named Aggregate which bears the union of all the changes in all the existing change-sets in the system (other than any pre-existing Aggregate).  This can be useful when wishing to discover potential conflicts between a disk-resident change-set and an image.  Formerly very useful, now some of its unique contributions have been overtaken by new features"	| aggregateChangeSet |	aggregateChangeSet := self existingOrNewChangeSetNamed: 'Aggregate'.	aggregateChangeSet clear.	self allChangeSets do:		[:aChangeSet | aChangeSet == aggregateChangeSet ifFalse:			[aggregateChangeSet assimilateAllChangesFoundIn: aChangeSet]]"ChangeSet buildAggregateChangeSet"	! !!DataStream methodsFor: 'write and read' stamp: 'tk 1/8/97'!readShortInst	"Read the contents of an arbitrary instance that has a short header.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.	Let the instance, not the class read the data.  "	| instSize aSymbol refPosn anObject newClass |	instSize := (byteStream next) - 1.	"one byte of size"	refPosn := self getCurrentReference.	aSymbol := self readShortRef.	"class symbol in two bytes of file pos"	newClass := Smalltalk at: aSymbol asSymbol.	anObject := newClass isVariable 	"Create object here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].	self setCurrentReference: refPosn.  "before readDataFrom:size:"	anObject := anObject readDataFrom: self size: instSize.	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForUnclassifiedMethods	"Open a message list browser on all methods in the current change set that have not been categorized,"	| aList |	(aList := self methodsWithoutClassifications) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '"are categorized.']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" which have not been categorized']! !!PseudoClass methodsFor: 'methods' stamp: 'sw 6/10/2003 17:31'!stampAt: selector	"Answer the authoring time-stamp of the change"	| code |	^ ((code := self sourceCode at: selector) isKindOf: ChangeRecord)		ifTrue:			[code stamp]		ifFalse:			[code string]! !!Preferences class methodsFor: 'fonts' stamp: 'nk 9/1/2004 11:37'!printStandardSystemFonts	"self printStandardSystemFonts"	| string |	string := String streamContents: [ :s |	#(standardDefaultTextFont standardListFont standardFlapFont 	standardEToysFont standardMenuFont windowTitleFont 	standardBalloonHelpFont standardCodeFont standardButtonFont) do: [:selector |		| font |		font := Preferences perform: selector.		s			nextPutAll: selector; space;			nextPutAll: font familyName; space;			nextPutAll: (AbstractFont emphasisStringFor: font emphasis);			nextPutAll: ' points: ';			print: font pointSize;			nextPutAll: ' height: ';			print: font height;			cr		]].	(StringHolder new)		contents: string;		openLabel: 'Current system font settings' translated.! !!Preference methodsFor: 'local to project' stamp: 'sw 4/10/2001 12:37'!isProjectLocalString	"Answer a string representing whether sym is a project-local preference or not"	| aStr |	aStr :=  'each project has its own setting'.	^ localToProject		ifTrue:			['<yes>', aStr]		ifFalse:			['<no>', aStr]! !!SARInstaller methodsFor: 'client services' stamp: 'nk 7/5/2003 22:40'!extractMemberWithoutPath: aMemberOrName inDirectory: aDirectory	"Extract aMemberOrName to its own filename, but ignore any directory paths, using aDirectory instead"	| member |	member := self memberNamed: aMemberOrName.	member ifNil: [ ^self errorNoSuchMember: aMemberOrName ].	self zip extractMemberWithoutPath: member inDirectory: aDirectory.	self installed: member.! !!Utilities class methodsFor: 'recent method submissions' stamp: 'RAA 5/28/2001 07:39'!recentMethodSubmissions	"Answer the list of recent method submissions, in order.  5/16/96 sw"	self flag: #mref.	"fix for faster references to methods"	RecentSubmissions == nil ifTrue: [RecentSubmissions := OrderedCollection new].	^ RecentSubmissions! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/5/1998 17:58'!chooseFileWithSuffixFromList: aSuffixList withCaption: aCaption	"Pop up a list of all files in the default directory which have a suffix in the list.  Return #none if there are none; return nil if the user backs out of the menu without making a choice."	"Utilities chooseFileWithSuffixFromList: #('.gif' '.jpg')"	| aList aName |	aList := OrderedCollection new.	aSuffixList do:		[:aSuffix | aList addAll: (FileDirectory default fileNamesMatching: '*', aSuffix)].	^ aList size > 0		ifTrue:			[aName := (SelectionMenu selections: aList) startUpWithCaption: aCaption.			aName]		ifFalse:			[#none]! !!Preference methodsFor: 'value' stamp: 'sw 4/12/2001 00:04'!restoreDefaultValue	"restore the default value to the preference"	value := defaultValue! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/26/2000 10:06'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips method |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method := aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips! !!ModifiedTraitDefinitionEvent class methodsFor: 'instance creation' stamp: 'al 7/18/2004 10:50'!traitDefinitionChangedFrom: oldTrait to: newTrait	| instance |	instance := self item: newTrait kind: self classKind.	instance oldItem: oldTrait.	^instance! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'NS 1/16/2004 15:34'!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	| changesFile |	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile := SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile isReadOnly ifTrue:[^self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: StartupStamp asString; cr.	StartupStamp := nil.	self forceChangesToDisk.! !!CodeLoader methodsFor: 'installing' stamp: 'ar 12/22/1999 15:02'!installSourceFiles	"Install the previously loaded source files"	sourceFiles == nil ifTrue:[^self].	sourceFiles do:[:req| self installSourceFile: req contentStream].	sourceFiles := nil.! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 14:39'!nextRandom160	"Answer a newly generated 160-bit random number in the range [1..(2^160 - 1)]."	"Details: Try again in the extremely unlikely chance that zero is encountered."	| result |	result := 0.	[result = 0] whileTrue: [		result := SecureHashAlgorithm new hashInteger: randKey seed: randSeed.		randKey := randKey + result + 1].	^ result! !!ImageSegment methodsFor: 'read/write segment' stamp: 'RAA 9/30/2000 20:53'!writeForExportWithSources: fName inDirectory: aDirectory	"Write the segment on the disk with all info needed to reconstruct it in a new image.  For export.  Out pointers are encoded as normal objects on the disk.  Append the source code of any classes in roots.  Target system will quickly transfer the sources to its changes file."	"this is the old version which I restored until I solve the gzip problem"	| fileStream temp tempFileName zipper allClassesInRoots classesToWriteEntirely methodsWithSource |	state = #activeCopy ifFalse: [self error: 'wrong state'].	(fName includes: $.) ifFalse: [		^ self inform: 'Please use ''.pr'' or ''.extSeg'' at the end of the file name'.].	temp := endMarker.	endMarker := nil.	tempFileName := aDirectory nextNameFor: 'SqProject' extension: 'temp'.	zipper := [		ProgressNotification signal: '3:uncompressedSaveComplete'.		(aDirectory oldFileNamed: tempFileName) compressFile.	"makes xxx.gz"		aDirectory 			rename: (tempFileName, FileDirectory dot, 'gz')			toBe: fName.		aDirectory			deleteFileNamed: tempFileName			ifAbsent: []	].	fileStream := aDirectory newFileNamed: tempFileName.	fileStream fileOutClass: nil andObject: self.		"remember extra structures.  Note class names."	endMarker := temp.	"append sources"	allClassesInRoots := arrayOfRoots select: [:cls | cls isKindOf: Behavior].	classesToWriteEntirely := allClassesInRoots select: [ :cls | cls theNonMetaClass isSystemDefined].	methodsWithSource := OrderedCollection new.	allClassesInRoots do: [ :cls |		(classesToWriteEntirely includes: cls) ifFalse: [			cls selectorsAndMethodsDo: [ :sel :meth |				meth sourcePointer = 0 ifFalse: [methodsWithSource add: {cls. sel. meth}].			].		].	].	(classesToWriteEntirely isEmpty and: [methodsWithSource isEmpty]) ifTrue: [zipper value. ^ self].	fileStream reopen; setToEnd.	fileStream nextPutAll: '\\!!ImageSegment new!!\\' withCRs.	methodsWithSource do: [ :each |		fileStream nextPut: $!!.	"try to pacify ImageSegment>>scanFrom:"		fileStream nextChunkPut: 'RenamedClassSourceReader formerClassName: ',				each first name printString,' methodsFor: ',				(each first organization categoryOfElement: each second) asString printString,				' stamp: ',(Utilities timeStampForMethod: each third) printString; cr.		fileStream nextChunkPut: (each third getSourceFor: each second in: each first) asString.		fileStream nextChunkPut: ' '; cr.	].	classesToWriteEntirely do: [:cls | 		cls isMeta ifFalse: [fileStream nextPutAll: 						(cls name, ' category: ''', cls category, '''.!!'); cr; cr].		cls organization			putCommentOnFile: fileStream			numbered: 0			moveSource: false			forClass: cls.	"does nothing if metaclass"		cls organization categories do: 			[:heading |			cls fileOutCategory: heading				on: fileStream				moveSource: false				toFile: 0]].	"no class initialization -- it came in as a real object"	fileStream close.	zipper value.! !!ProjectLauncher methodsFor: 'running' stamp: 'KR 8/30/2005 17:41'!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (SmalltalkImage current getSystemAttribute: 2) ifNil:[''].			scriptName := scriptName convertFromSystemString.			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[scriptName := 'file:',scriptName]].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!RealEstateAgent class methodsFor: 'framing' stamp: 'nk 7/5/2003 08:32'!strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent world: aWorld	"This method implements a staggered window placement policy that I (di) like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible."	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea :=(self maximumUsableAreaInWorld: aWorld)		insetBy: (self scrollBarSetback @ self screenTopSetback extent: 0@0).	(Smalltalk isMorphic and: [Flaps sharedFlapsAllowed]) ifTrue:		[allowedArea := self reduceByFlaps: allowedArea].	"Number to be staggered at each corner (less on small screens)"	maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame := 0@0 extent: ((initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames := Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel := #(topLeft topRight bottomRight bottomLeft) at: ci.			corner := allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta := (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta := delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner := corner + delta.			free := true.			otherFrames do:				[:w |				free := free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 translatedAndSquishedToBeWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		translatedAndSquishedToBeWithin: allowedArea! !!Project class methodsFor: 'utilities' stamp: 'tk 10/26/1999 14:25'!returnToPreviousProject	"Return to the project from which this project was entered. Do nothing if the current project has no link to its previous project."	| prevProj |	prevProj := CurrentProject previousProject.	prevProj ifNotNil: [prevProj enter: true revert: false saveForRevert: false].! !!Utilities class methodsFor: 'miscellaneous' stamp: 'nk 2/15/2004 09:36'!garbageCollectAndReport	"Do a garbage collection, and report results to the user."	| cc reportString |	reportString := String streamContents:		[:aStream | 			aStream nextPutAll: Smalltalk bytesLeftString.			Smalltalk at: #Command ifPresent:				[:cmdClass |				(cc := cmdClass instanceCount) > 0 ifTrue:					[aStream cr; nextPutAll:		('(note: there are ', cc printString,		                         ' undo record(s) present in yoursystem; purging them may free up more space.)')]]].				self inform: reportString! !!Utilities class methodsFor: 'graphical support' stamp: ''!showFormsAcrossTopOfScreen: aFormList	"Display the given array of forms across the top of the screen, wrapping to subsequent lines if needed.    Useful for example for looking at sets of rotations and animations.  6/10/96 sw"	| position maxHeight screenBox ceiling |	position := 20.	maxHeight := 0.	ceiling := 0.	screenBox := Display boundingBox.	aFormList do:		[:elem | elem displayAt: (position @ ceiling).			maxHeight := maxHeight max: elem boundingBox height.			position := position + elem boundingBox width + 5.			position > (screenBox right - 100) ifTrue:				[position := 20.				ceiling := ceiling + maxHeight + 10.				maxHeight := 0]]! !!SecurityManager methodsFor: 'accessing' stamp: 'ar 2/6/2001 16:19'!addTrustedKey: aPublicKey	"Add a public key to the list of trusted keys"	trustedKeys := (trustedKeys copyWithout: aPublicKey) copyWith: aPublicKey.! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 15:17'!playScale: mSecsPerNote onPort: portNum	"MidiPrimTester new playScale: 130 onPort: 0"	| noteOn noteOff |	noteOn := #(144 0 100) as: ByteArray.	noteOff := #(144 0 0) as: ByteArray.	self openPort: portNum andDo: [		#(60 62 64 65 67 69 71 72 74 72 71 69 67 65 64 62 60) do: [:midiKey | 			noteOn at: 2 put: midiKey.			noteOff at: 2 put: midiKey.			self primMIDIWritePort: portNum from: noteOn at: 0.			(Delay forMilliseconds: mSecsPerNote - 10) wait.			self primMIDIWritePort: portNum from: noteOff at: 0.			(Delay forMilliseconds: 10) wait]].! !!ChangeRecord methodsFor: 'initialization' stamp: '6/6/97 08:48 dhhi'!file: f position: p type: t class: c category: cat meta: m stamp: s	self file: f position: p type: t.	class := c.	category := cat.	meta := m.	stamp := s! !!Utilities class methodsFor: 'recent method submissions' stamp: 'nk 8/30/2004 08:02'!dumpAnyOldStyleRecentSubmissions	"simplify conversion by purging those recent submissions which are still Strings"	RecentSubmissions := self recentMethodSubmissions reject: [ :each |		each isString	].! !!ExternalSemaphoreTable class methodsFor: 'initialize' stamp: 'JMM 6/6/2000 20:32'!initialize	ProtectTable := Semaphore forMutualExclusion! !!SystemDictionary methodsFor: 'memory space' stamp: 'apb 10/3/2000 16:40'!useUpMemory	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemory"	| lst |	lst := nil.	[true] whileTrue: [		lst := Link nextLink: lst.	].! !!Project class methodsFor: 'utilities' stamp: 'RAA 11/16/2000 12:04'!addingProject: newProject	(self allProjects includes: newProject) ifTrue: [^self].	AllProjects := self allProjects copyWith: newProject.! !!SerialPort methodsFor: 'settings' stamp: 'jm 5/1/1998 18:02'!stopBitsType: anInteger	"Set the stop bits type for this serial port, where:		0 - 1.5 stop bits		1 - one stop bit		2 - two stop bits"	stopBitsType := anInteger.! !!SystemDictionary methodsFor: 'ui' stamp: 'sd 1/16/2004 20:49'!inspectGlobals	"Smalltalk  inspectGlobals"		| associations aDict |	associations := ((self  keys select: [:aKey | ((self  at: aKey) isKindOf: Class) not]) asSortedArray collect:[:aKey | self associationAt: aKey]).	aDict := IdentityDictionary new.	associations do: [:as | aDict add: as].	aDict inspectWithLabel: 'The Globals'! !!Utilities class methodsFor: 'fetching updates' stamp: 'md 9/11/2004 12:06'!assureAbsenceOfUnstableUpdateStream	"Check to see if the unstable Updates stream is in the list; if it is, *remove* it.  This is the *opposite* of #assureAvailabilityOfUnstableUpdateStream"	UpdateUrlLists ifNil: [UpdateUrlLists := OrderedCollection new].	UpdateUrlLists := UpdateUrlLists select:		[:pair | pair first ~= 'Unstable Updates*']"Utilities assureAbsenceOfUnstableUpdateStream"! !!ImageSegment methodsFor: 'testing' stamp: 'tk 11/30/1999 22:29'!deepCopyTest: aRootArray	"ImageSegment new deepCopyTest: Morph withAllSubclasses asArray"	"Project allInstances do:		[:p | p == Project current ifFalse:			[Transcript cr; cr; nextPutAll: p name.			ImageSegment new deepCopyTest: (Array with: p)]]."	| t1 t2 copy |	t1 := Time millisecondsToRun: [self copyFromRoots: aRootArray sizeHint: 0].	t2 := Time millisecondsToRun: [copy := self segmentCopy].	Transcript cr; print: segment size * 4; nextPutAll: ' bytes stored with ';		print: outPointers size; show: ' outpointers in '; print: t1; show: 'ms.'.	Transcript cr; nextPutAll: 'Reconstructed in '; print: t2; show: 'ms.'.	^ copy"Smalltalk allClasses do:	[:m | ImageSegment new deepCopyTest: (Array with: m with: m class)]"! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/21/1999 20:34'!readStamp	"Get the time stamp of this method off the file"	| item tokens anIndex |	stamp := ''.	file ifNil: [^ stamp].	file position: position.	item := file nextChunk.	tokens := Scanner new scanTokens: item.	tokens size < 3 ifTrue: [^ stamp].	anIndex := tokens indexOf: #stamp: ifAbsent: [^ stamp].	^ stamp := tokens at: (anIndex + 1).! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/17/2005 10:48'!checkForUncommentedClasses	"Check to see if any classes involved in this change set do not have class comments.  Open up a browser showing all such classes."	| aList |	aList := self changedClasses		select:			[:aClass | aClass theNonMetaClass organization classComment isEmptyOrNil]		thenCollect:			[:aClass  | aClass theNonMetaClass name].	aList size > 0		ifFalse:			[^ self inform: 'All classes involved in this change set have class comments']		ifTrue:			[ToolSet openClassListBrowser: aList asSet asSortedArray title: 'Classes in Change Set ', self name, ': classes that lack class comments']! !!ResourceCollector class methodsFor: 'accessing' stamp: 'ar 2/24/2001 21:41'!current: aResourceManager	Current := aResourceManager! !!HTTPClient class methodsFor: 'post/get' stamp: 'nk 8/30/2004 07:50'!httpGet: url	| document |	document := self httpGetDocument: url.	^(document isString)		ifTrue: [			"strings indicate errors"			document]		ifFalse: [(RWBinaryOrTextStream with: document content) reset]! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'ar 4/10/2005 22:17'!initialize	"TypeMap maps Smalltalk classes to type ID numbers which identify the data stream primitive formats.  nextPut: writes these IDs to the data stream.  NOTE: Changing these type ID numbers will invalidate all extant data stream files.  Adding new ones is OK.  	Classes named here have special formats in the file.  If such a class has a subclass, it will use type 9 and write correctly.  It will just be slow.  (Later write the class name in the special format, then subclasses can use the type also.)	 See nextPut:, next, typeIDFor:, & ReferenceStream>>isAReferenceType:"	"DataStream initialize"	| refTypes t |	refTypes := OrderedCollection new.	t := TypeMap := Dictionary new: 80. "sparse for fast hashing"	t at: UndefinedObject put: 1.   refTypes add: 0.	t at: True put: 2.   refTypes add: 0.	t at: False put: 3.   refTypes add: 0.	t at: SmallInteger put: 4.	 refTypes add: 0.	t at: ByteString put: 5.   refTypes add: 1.	t at: ByteSymbol put: 6.   refTypes add: 1.	t at: ByteArray put: 7.   refTypes add: 1.	t at: Array put: 8.   refTypes add: 1.	"(type ID 9 is for arbitrary instances of any class, cf. typeIDFor:)"		refTypes add: 1.	"(type ID 10 is for references, cf. ReferenceStream>>tryToPutReference:)"		refTypes add: 0.	t at: Bitmap put: 11.   refTypes add: 1.	t at: Metaclass put: 12.   refTypes add: 0.	"Type ID 13 is used for HyperSqueak User classes that must be reconstructed."		refTypes add: 1.	t at: Float put: 14.  refTypes add: 1.	t at: Rectangle put: 15.  refTypes add: 1.	"Allow compact Rects."	"type ID 16 is an instance with short header.  See beginInstance:size:"		refTypes add: 1.self flag: #ByteArray.	t at: ByteString put: 17.   refTypes add: 1.	"new String format, 1 or 4 bytes of length"	t at: WordArray put: 18.  refTypes add: 1.	"bitmap-like"	t at: WordArrayForSegment put: 19.  refTypes add: 1.		"bitmap-like"	t at: SoundBuffer put: 20.  refTypes add: 1.	"And all other word arrays, both 		16-bit and 32-bit.  See methods in ArrayedCollection.  Overridden in SoundBuffer."	t at: CompiledMethod put: 21.  refTypes add: 1.	"special creation method"	"t at:  put: 22.  refTypes add: 0."	ReferenceStream refTypes: refTypes.		"save it"	"For all classes that are like WordArrays, store them the way ColorArray is stored.  As bits, and able to change endianness."	Smalltalk do: [:cls |		cls isInMemory ifTrue: [			cls isBehavior ifTrue: [				cls isPointers not & cls isVariable & cls isWords ifTrue: [					(t includesKey: cls) ifFalse: [t at: cls put: 20]]]]].! !!RealEstateAgent class methodsFor: 'framing' stamp: 'nk 7/5/2003 08:32'!initialFrameFor: aView initialExtent: initialExtent world: aWorld	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView initialExtent: initialExtent world: aWorld].	allowedArea := self maximumUsableAreaInWorld: aWorld.	screenRight := allowedArea right.	screenBottom := allowedArea bottom.	otherFrames := Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: aWorld satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	allOrigins := otherFrames collect: [:f | f origin].	(self standardPositionsInWorld: aWorld) do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) translatedAndSquishedToBeWithin: allowedArea]].	staggerOrigin := (self standardPositionsInWorld: aWorld) first.  "Fallback: try offsetting from top left"	putativeOrigin := staggerOrigin.	[putativeOrigin := putativeOrigin + StaggerOffset.	putativeFrame := putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) translatedAndSquishedToBeWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) translatedAndSquishedToBeWithin: allowedArea! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'nk 10/29/2000 12:15'!sourceString: aString 	realSrc := self split: aString asString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc		doWithIndex: [:line :realIndex | 			srcLines				add: (self formatLine: line).			srcMap add: realIndex].	srcPos := PluggableDictionary new: srcLines size.	srcPos hashBlock: self stringHashBlock.	srcLines		doWithIndex: [:line :index | (srcPos includesKey: line)				ifTrue: [(srcPos at: line)						add: index.					multipleMatches := true]				ifFalse: [srcPos						at: line						put: (OrderedCollection with: index)]]! !!FileServices class methodsFor: 'accessing' stamp: 'ar 7/16/2005 16:59'!registeredFileReaderClasses	FileReaderRegistry ifNil: [FileReaderRegistry := OrderedCollection new].	^ FileReaderRegistry! !!SARInstaller methodsFor: 'client services' stamp: 'nk 6/12/2004 10:03'!openGraphicsFile: memberOrName	| member morph |	member := self memberNamed: memberOrName.	member ifNil: [ ^self errorNoSuchMember: memberOrName ].	morph := (World drawingClass fromStream: member contentStream binary).	morph ifNotNil: [ morph openInWorld ].	self installed: member.! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 10:30'!getDriverParameters	"Return a string that describes this platform's MIDI parameters."	"MidiPrimTester new getDriverParameters"	| s parameterNames v |	parameterNames := #(Installed Version HasBuffer HasDurs CanSetClock CanUseSemaphore EchoOn UseControllerCache EventsAvailable FlushDriver ClockTicksPerSec HasInputClock).	s := WriteStream on: String new.	s cr.	1 to: parameterNames size do: [:i |		v := self primMIDIParameterGet: i.		s nextPutAll: (parameterNames at: i).		s nextPutAll: ' = '.		s print: v; cr].	s nextPutAll: 'MIDI Echoing is '.	(self canTurnOnParameter: EchoOn)		ifTrue: [s nextPutAll: 'supported.'; cr]		ifFalse: [s nextPutAll: 'not supported.'; cr].	s nextPutAll: 'Controller Caching is '.	(self canTurnOnParameter: UseControllerCache)		ifTrue: [s nextPutAll: 'supported.'; cr]		ifFalse: [s nextPutAll: 'not supported.'; cr].	^ s contents! !!ResourceManager class methodsFor: 'resource caching' stamp: 'yo 12/20/2003 02:12'!cacheResource: urlString stream: aStream	| fd localName file buf |	HTTPClient shouldUsePluginAPI ifTrue:[^self]. "use browser cache"	(self resourceCache at: urlString ifAbsent:[#()]) size > 0 		ifTrue:[^self]. "don't waste space"	fd := Project squeakletDirectory.	localName := fd nextNameFor: 'resource' extension:'cache'.	file := fd forceNewFileNamed: localName.	buf := ByteArray new: 10000.	aStream binary.	file binary.	[aStream atEnd] whileFalse:[		buf := aStream next: buf size into: buf.		file nextPutAll: buf.	].	file close.	"update cache"	file := [fd oldFileNamed: self resourceCacheName] 			on: FileDoesNotExistException			do:[:ex| fd forceNewFileNamed: self resourceCacheName].	file setToEnd.	file nextPutAll: urlString; cr.	file nextPutAll: localName; cr.	file close.	self addCacheLocation: localName for: urlString.	aStream position: 0.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 5/8/2000 20:47'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict changeType classRecord currentDef |	classRecord := changeRecords at: class name ifAbsent: [^ self].	dict := classRecord methodChangeTypes.	dict keysSortedSafely do:		[:key | changeType := dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [stream nextChunkPut: class name,						' removeSelector: ', key storeString; cr]			ifFalse: [(key = #initialize and: [class isMeta]) ifTrue:						[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]].	((classRecord includesChangeType: #change)		and: [(currentDef := class definition) ~= (self fatDefForClass: class)]) ifTrue:		[stream command: 'H3'; nextChunkPut: currentDef; cr; command: '/H3'].	(classRecord includesChangeType: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!SystemDictionary methodsFor: 'memory space' stamp: 'dtl 10/3/2005 06:12'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	| free preemptedProcess |	self garbageCollectMost <= self lowSpaceThreshold		ifTrue: [self garbageCollect <= self lowSpaceThreshold				ifTrue: ["free space must be above threshold before					starting low space watcher"					^ Beeper beep]].	Smalltalk specialObjectsArray at: 23 put: nil.  "process causing low space will be saved here"	LowSpaceSemaphore := Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess := nil.	"The process that was active at the time of the low space interrupt."	preemptedProcess := Smalltalk specialObjectsArray at: 23.	Smalltalk specialObjectsArray at: 23 put: nil.	"Note: user now unprotected until the low space watcher is re-installed"	self memoryHogs isEmpty		ifFalse: [free := self bytesLeft.			self memoryHogs				do: [ :hog | hog freeSomeSpace ].			self bytesLeft > free				ifTrue: [ ^ self installLowSpaceWatcher ]].	self isMorphic		ifTrue: [CurrentProjectRefactoring				currentInterruptName: 'Space is low'				preemptedProcess: preemptedProcess]		ifFalse: [ScheduledControllers				interruptName: 'Space is low'				preemptedProcess: preemptedProcess]! !!ChangeSet methodsFor: 'converting' stamp: 'tk 11/26/2004 05:56'!convertToCurrentVersion: varDict refStream: smartRefStrm	"major change - 4/4/2000"	| newish |	varDict at: 'classChanges' ifPresent: [ :x |		newish := self convertApril2000: varDict using: smartRefStrm.		newish == self ifFalse: [^ newish].		].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ExternalDropHandler class methodsFor: 'accessing' stamp: 'mir 1/10/2002 16:54'!defaultHandler: externalDropHandler	DefaultHandler := externalDropHandler! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 15:12'!scanCategory: file	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp isComment anIndex |	itemPosition := file position.	item := file nextChunk.	isComment := (item includesSubString: 'commentStamp:').	(isComment or: [item includesSubString: 'methodsFor:']) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^{(ChangeRecord new file: file position: itemPosition type: #preamble)}].	tokens := Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp := ''.		anIndex := tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp := tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanFile: file category: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanFile: file category: tokens fourth class: tokens first							meta: true stamp: stamp]].		tokens second == #commentStamp:			ifTrue:				[stamp := tokens third.				item := (ChangeRecord new file: file position: file position type: #classComment										class: tokens first category: nil meta: false stamp: stamp).				file nextChunk.				file skipStyleChunk.				^Array with: item].	^#()! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14'!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow := AlignmentMorph newRow color: aColor.			aSwatch := ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 08:06'!setClass: aClass methodSymbol: methodSym stringVersion: aString 	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 4/1/2000 10:45'!compileAll: newClass from: oldClass	"Something about this class has changed.  Locally retained methods must be recompiled.	NOTE:  You might think that if this changeSet is in force, then we can just note	the new methods but a lower change set may override and be in force which	would mean that only the overriding copies go recompiled.  Just do it."	| sel changeType changeRecord newMethod |	methodChanges associationsDo:		[:assn | sel := assn key.  changeRecord := assn value.		changeType := changeRecord changeType.		(changeType == #add or: [changeType == #change]) ifTrue:			[newMethod := newClass				recompileNonResidentMethod: changeRecord currentMethod				atSelector: sel from: oldClass.			changeRecord noteNewMethod: newMethod]]! !!ExternalSettings class methodsFor: 'accessing' stamp: 'sw 1/25/2002 12:39'!assuredPreferenceDirectory	"Answer the preference directory, creating it if necessary"	|  prefDir |	prefDir := self preferenceDirectory.	prefDir		ifNil:			[prefDir := FileDirectory default directoryNamed: self preferenceDirectoryName.			prefDir assureExistence].	^ prefDir! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 10/4/2001 13:54'!checkBasicClasses	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it.  	DeepCopier new checkVariables	"	| str str2 objCls morphCls playerCls |	str := '|veryDeepCopyWith: or veryDeepInner: is out of date.'.	(objCls := self objInMemory: #Object) ifNotNil: [		objCls instSize = 0 ifFalse: [self error: 			'Many implementers of veryDeepCopyWith: are out of date']].	(morphCls := self objInMemory: #Morph) ifNotNil: [		morphCls superclass == Object ifFalse: [self error: 'Morph', str].		(morphCls instVarNames copyFrom: 1 to: 6) = #('bounds' 'owner' 'submorphs' 				'fullBounds' 'color' 'extension') 			ifFalse: [self error: 'Morph', str]].	"added ones are OK"	str2 := 'Player|copyUniClassWith: and DeepCopier|mapUniClasses are out of date'.	(playerCls := self objInMemory: #Player) ifNotNil: [		playerCls class instVarNames = #('scripts' 'slotInfo')			ifFalse: [self error: str2]].! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 16:01'!saveChangesInFileNamed: aString	| fullChangesName |	fullChangesName := (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullChangesName )) assureExistence.	FileDirectory default 		copyFileWithoutOverwriteConfirmationNamed: SmalltalkImage current changesName 		toFileNamed: fullChangesName.	Smalltalk setMacFileInfoOn: fullChangesName.! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'sw 4/3/2001 14:16'!noteChangeType: changeSymbol fromClass: class	(changeSymbol = #new or: [changeSymbol = #add]) ifTrue:		[changeTypes add: #add.		changeTypes remove: #change ifAbsent: [].		revertable := false.		^ self].	changeSymbol = #change ifTrue:		[(changeTypes includes: #add) ifTrue: [^ self].		^ changeTypes add: changeSymbol].	changeSymbol == #addedThenRemoved ifTrue:		[^ self].  "An entire class was added but then removed"	changeSymbol = #comment ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #reorganize ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #rename ifTrue:		[^ changeTypes add: changeSymbol].	(changeSymbol beginsWith: 'oldName: ') ifTrue:		["Must only be used when assimilating other changeSets"		(changeTypes includes: #add) ifTrue: [^ self].		priorName := changeSymbol copyFrom: 'oldName: ' size + 1 to: changeSymbol size.		^ changeTypes add: #rename].	changeSymbol = #remove ifTrue:		[(changeTypes includes: #add)			ifTrue: [changeTypes add: #addedThenRemoved]			ifFalse: [changeTypes add: #remove].		^ changeTypes removeAllFoundIn: #(add change comment reorganize)].	self error: 'Unrecognized changeType'! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ar 8/16/2001 13:26'!prepareToBeSaved	"Prepare objects in outPointers to be written on the disk.  They must be able to match up with existing objects in their new system.  outPointers is already a copy.	Classes are already converted to a DiskProxy.  	Associations in outPointers:1) in Smalltalk.2) in a classPool.3) in a shared pool.4) A pool dict pointed at directly"| left pool myClasses outIndexes key |myClasses := Set new.arrayOfRoots do: [:aRoot | aRoot class class == Metaclass ifTrue: [myClasses add: aRoot]].outIndexes := IdentityDictionary new.outPointers withIndexDo: [:anOut :ind | 	anOut isVariableBinding ifTrue: [		(myClasses includes: anOut value)			ifFalse: [outIndexes at: anOut put: ind]			ifTrue: [(Smalltalk associationAt: anOut key ifAbsent: [3]) == anOut 				ifTrue: [outPointers at: ind put: 					(DiskProxy global: #Smalltalk selector: #associationDeclareAt: 						args: (Array with: anOut key))]				ifFalse: [outIndexes at: anOut put: ind]				]].	(anOut isKindOf: Dictionary) ifTrue: ["Pools pointed at directly"		(key := Smalltalk keyAtIdentityValue: anOut ifAbsent: [nil]) ifNotNil: [			outPointers at: ind put: 				(DiskProxy global: key selector: #yourself args: #())]].	anOut isMorph ifTrue: [outPointers at: ind put: 		(StringMorph contents: anOut printString, ' that was not counted')]	].left := outIndexes keys asSet.left size > 0 ifTrue: ["Globals"	(left copy) do: [:assoc |	"stay stable while delete items"		(Smalltalk associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [			outPointers at: (outIndexes at: assoc) put: 				(DiskProxy global: #Smalltalk selector: #associationAt: 					args: (Array with: assoc key)).			left remove: assoc]]].left size > 0 ifTrue: ["Class variables"	Smalltalk allClassesDo: [:cls | cls classPool size > 0 ifTrue: [		(left copy) do: [:assoc |	"stay stable while delete items"			(cls classPool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [				outPointers at: (outIndexes at: assoc) put: 					(DiskProxy new global: cls name						preSelector: #classPool						selector: #associationAt: 						args: (Array with: assoc key)).				left remove: assoc]]]]].left size > 0 ifTrue: ["Pool variables"	Smalltalk associationsDo: [:poolAssoc |		poolAssoc value class == Dictionary ifTrue: ["a pool"			pool := poolAssoc value.			(left copy) do: [:assoc |	"stay stable while delete items"				(pool associationAt: assoc key ifAbsent: [3]) == assoc ifTrue: [					outPointers at: (outIndexes at: assoc) put: 						(DiskProxy global: poolAssoc key selector: #associationAt: 							args: (Array with: assoc key)).					left remove: assoc]]]]].left size > 0 ifTrue: [	"If points to class in arrayOfRoots, must deal with it separately"	"OK to have obsolete associations that just get moved to the new system"	self inform: 'extra associations'.	left inspect].! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/14/1999 16:07'!load: anInteger	"Set my contents to the value of given integer."	low := anInteger bitAnd: 16rFFFF.	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF.	self asInteger = anInteger		ifFalse: [self error: 'out of range: ', anInteger printString].! !!SystemNavigation methodsFor: 'query' stamp: 'md 8/27/2005 16:42'!allMethodsNoDoitsSelect: aBlock 	"Like allSelect:, but strip out Doits"	| aCollection |	aCollection := SortedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsDo: [:sel | (sel isDoIt not									and: [aBlock											value: (class compiledMethodAt: sel)])								ifTrue: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!Project methodsFor: 'resources' stamp: 'ar 2/27/2001 15:49'!resourceManager: aResourceManager	resourceManager := aResourceManager! !!FontSubstitutionDuringLoading methodsFor: 'accessing' stamp: 'nk 11/8/2004 15:01'!pixelSize: anObject	"Set the value of pixelSize"	pixelSize := anObject! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'SqR 11/14/2000 11:36'!doWeFileOut: aClass given: aSet cache: cache	| aClassAllSuperclasses aClassSoleInstanceAllSuperclasses |	aClassAllSuperclasses := cache at: aClass		ifAbsent: [cache at: aClass put: aClass allSuperclasses asArray].	(aSet includesAnyOf: aClassAllSuperclasses) ifTrue: [^false].	aClass isMeta ifFalse: [^true].	(aSet includes: aClass soleInstance) ifTrue: [^false].	aClassSoleInstanceAllSuperclasses := cache at: aClass soleInstance		ifAbsent: [cache at: aClass soleInstance put: aClass soleInstance allSuperclasses asArray].	(aSet includesAnyOf: aClassSoleInstanceAllSuperclasses) ifTrue: [^false].	^true! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'md 2/22/2006 21:16'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse internalStream |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	nameToUse := self defaultChangeSetDirectory fullNameFor: nameToUse.	Cursor write showWhile: [			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(PopUpMenu withCaption: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?' chooseFrom: 'Ignore\Browse slips')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!EventManager class methodsFor: 'initialize-release' stamp: 'rw 2/10/2002 13:09'!flushEvents	"Object flushEvents"	| msgSet |	self actionMaps keysAndValuesDo:[:rcvr :evtDict| rcvr ifNotNil:[		"make sure we don't modify evtDict while enumerating"		evtDict keys do:[:evtName|			msgSet := evtDict at: evtName ifAbsent:[nil].			(msgSet == nil) ifTrue:[rcvr removeActionsForEvent: evtName]]]].	EventManager actionMaps finalizeValues. ! !!ChangeSet methodsFor: 'testing' stamp: 'sd 5/23/2003 14:24'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName := self name.	self == self class current ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!Project methodsFor: 'file in/out' stamp: 'yo 11/29/2005 20:13'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileNamedirectory: aDirectory	"Store my project out on the disk as an *exported*ImageSegment.  All outPointers will be in a form that can be resolvedin the target image.  Name it <project name>.extSeg.  Whatdo we doabout subProjects, especially if they are out as local imagesegments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder collector fd mgr stacks |	"Files out a changeSet first, so that a project can containits own classes"world isMorph ifFalse: [	self projectParameters at: #isMVC put: true.	^ false].	"Only Morphic projects for now"world ifNil: [^ false].  world presenter ifNil: [^ false].Utilities emptyScrapsBook.world currentHand pasteBuffer: nil.	  "don't write the paste buffer."world currentHand mouseOverHandler initialize.	  "forget about anyreferences here"	"Display checkCurrentHandForObjectToPaste."Command initialize.world clearCommandHistory.world fullReleaseCachedState; releaseViewers.world cleanseStepList.world localFlapTabs size = world flapTabs size ifFalse: [	self error: 'Still holding onto Global flaps'].world releaseSqueakPages.ScriptEditorMorph writingUniversalTiles: (self projectParameterAt:#universalTiles ifAbsent: [false]).holder := Project allProjects.	"force them in to outPointers, whereDiskProxys are made""Just export me, not my previous version"revertSeg := self projectParameters at: #revertToMe ifAbsent: [nil].self projectParameters removeKey: #revertToMe ifAbsent: [].roots := OrderedCollection new.roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.roots add: world activeHand.	"; addAll: classList; addAll: (classList collect: [:cls | cls class])"roots := roots reject: [ :x | x isNil].	"early saves may not haveactive hand or thumbnail"	fd := aDirectory directoryNamed: self resourceDirectoryName.	fd assureExistence.	"Clean up resource references before writing out"	mgr := self resourceManager.	self resourceManager: nil.	ResourceCollector current: ResourceCollector new.	ResourceCollector current localDirectory: fd.	ResourceCollector current baseUrl: self resourceUrl.	ResourceCollector current initializeFrom: mgr.	ProgressNotification signal: '2:findingResources' extra:'(collecting resources...)' translated.	"Must activate old world because this is run at #armsLength.	Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent	will not be captured correctly if referenced from blocks or user code."	world becomeActiveDuring:[		is := ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is := ImageSegment newcopyFromRootsForExport: roots asArray)"	].	self resourceManager: mgr.	collector := ResourceCollector current.	ResourceCollector current: nil.	ProgressNotification signal: '2:foundResources' extra: ''.	is state = #tooBig ifTrue: [		collector replaceAll.		^ false].str := ''."considered legal to save a project that has never been entered"(is outPointers includes: world) ifTrue: [	str := str, '\Project''s own world is not in the segment.' translated withCRs].str isEmpty ifFalse: [	ans := (PopUpMenu labels: 'Do not write fileWrite file anywayDebug' translated) startUpWithCaption: str.	ans = 1 ifTrue: [		revertSeg ifNotNil: [projectParameters at:#revertToMe put: revertSeg].		collector replaceAll.		^ false].	ans = 3 ifTrue: [		collector replaceAll.		self halt: 'Segment not written' translated]].	stacks := is findStacks.	is		writeForExportWithSources: aFileName		inDirectory: fd		changeSet: aChangeSetOrNil.	SecurityManager default signFile: aFileName directory: fd.	"Compress all files and update check sums"	collector forgetObsolete.	self storeResourceList: collector in: fd.	self storeHtmlPageIn: fd.	self storeManifestFileIn: fd.	self writeStackText: stacks in: fd registerIn: collector.	"local proj.005.myStack.t"	self compressFilesIn: fd to: aFileName in: aDirectoryresources: collector.			"also deletes the resource directory"	"Now update everything that we know about"	mgr updateResourcesFrom: collector.revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].holder.collector replaceAll.world flapTabs do: [:ft |		(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].is arrayOfRoots do: [:obj |	obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].^ true! !!Project methodsFor: 'file in/out' stamp: 'dgd 9/21/2003 17:41'!exportSegmentFileName: aFileName directory: aDirectory	| exportChangeSet |	"An experimental version to fileout a changeSet first so that a project can contain its own classes"	"Store my project out on the disk as an *exported* ImageSegment.  Put all outPointers in a form that can be resolved in the target image.  Name it <project name>.extSeg.	Player classes are included automatically."	exportChangeSet := nil.	(changeSet notNil and: [changeSet isEmpty not]) ifTrue: [		(self confirm: 'Would you like to include all the changes in the change setas part of this publishing operation?' translated) ifTrue: [			exportChangeSet := changeSet		].	].	^ self 		exportSegmentWithChangeSet: exportChangeSet		fileName: aFileName 		directory: aDirectory! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/29/2003 20:19'!checkForUnsentMessages	"Check the change set for unsent messages, and if any are found, open 	up a message-list browser on them"	| nameLine allChangedSelectors augList unsent |	nameLine := '"' , self name , '"'.	allChangedSelectors := Set new.	(augList := self changedMessageListAugmented)		do: [:each | each isValid				ifTrue: [allChangedSelectors add: each methodSymbol]].	unsent := self systemNavigation allUnSentMessagesIn: allChangedSelectors.	unsent size = 0		ifTrue: [^ self inform: 'There are no unsent messages in change set' , nameLine].	self systemNavigation		browseMessageList: (augList				select: [:each | unsent includes: each methodSymbol])		name: 'Unsent messages in ' , nameLine! !!Project methodsFor: 'flaps support' stamp: 'sw 4/24/2001 11:02'!showSharedFlaps	"Answer whether shared flaps are shown or suppressed in this project"	| result |	result := Preferences showSharedFlaps.	^ self == Project current		ifTrue:			[result]		ifFalse:			[self projectPreferenceAt: #showSharedFlaps ifAbsent: [result]]! !!Project class methodsFor: 'utilities' stamp: 'sw 9/7/2000 06:50'!showProjectHierarchyInWindow	"Open a window that displays the project hierarchy"	| hierarchyString numberOfProjects |	hierarchyString := self projectHierarchy.	numberOfProjects := hierarchyString lineCount.	((StringHolder new contents: hierarchyString)		embeddedInMorphicWindowLabeled: 'Projects (', numberOfProjects printString, ') ', Date today printString, ' ', Time now printString)			setWindowColor:  (Color r: 1.0 g: 0.829 b: 0.909);			openInWorld: self currentWorld extent: (300 @ (((numberOfProjects * (TextStyle  defaultFont lineGrid + 4) min: (self currentWorld height - 50)))))"Project showProjectHierarchyInWindow"! !!AbstractLauncher methodsFor: 'private' stamp: 'mdr 4/10/2001 10:50'!numericParameterAtOneOf: alternateParameterNames ifAbsent: aBlock	"Return the parameter named using one of the alternate names or an empty string"	| parameterValue |	parameterValue := self parameterAtOneOf: alternateParameterNames.	parameterValue isEmpty		ifTrue: [^aBlock value].	^[Number readFrom: parameterValue] ifError: aBlock ! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 12/20/2000 11:07'!reshapeClasses: mapFakeClassesToReal refStream: smartRefStream 	| bads allVarMaps perfect insts partials in out |	self flag: #bobconv.		partials := OrderedCollection new.	bads := OrderedCollection new.	allVarMaps := IdentityDictionary new.	mapFakeClassesToReal keysAndValuesDo: [ :aFakeClass :theRealClass | 		(theRealClass indexIfCompact > 0) "and there is a fake class"			ifFalse: [insts := aFakeClass allInstances]			ifTrue: ["instances have the wrong class.  Fix them before anyone notices."				insts := OrderedCollection new.				self allObjectsDo: [:obj | obj class == theRealClass ifTrue: [insts add: obj]].			].		insts do: [ :misShapen | 			perfect := smartRefStream convert1: misShapen to: theRealClass allVarMaps: allVarMaps.			bads 				detect: [ :x | x == misShapen] 				ifNone: [					bads add: misShapen.					partials add: perfect				].		].	].	bads isEmpty ifFalse: [		bads asArray elementsForwardIdentityTo: partials asArray	].	in := OrderedCollection new.	out := OrderedCollection new.	partials do: [ :each |		perfect := smartRefStream convert2: each allVarMaps: allVarMaps.		in 			detect: [ :x | x == each]			ifNone: [				in add: each.				out add: perfect			]	].	in isEmpty ifFalse: [		in asArray elementsForwardIdentityTo: out asArray	].! !!CodeLoader class methodsFor: 'utilities' stamp: 'ads 7/31/2003 14:00'!signFilesFrom: sourceNames to: destNames key: privateKey	"Sign all the given files using the private key.	This will add an 's' to the extension of the file."	"| fd oldNames newNames |	fd := FileDirectory default directoryNamed:'unsigned'.	oldNames := fd fileNames.	newNames := oldNames collect:[:name| 'signed', FileDirectory slash, name].	oldNames := oldNames collect:[:name| 'unsigned', FileDirectory slash, name].	CodeLoader		signFilesFrom: oldNames		to: newNames		key: DOLPrivateKey."	| dsa |	dsa := DigitalSignatureAlgorithm new.	dsa initRandomNonInteractively.	'Signing files...' displayProgressAt: Sensor cursorPoint		from: 1 to: sourceNames size during:[:bar|			1 to: sourceNames size do:[:i|				bar value: i.				self signFile: (sourceNames at: i) renameAs: (destNames at: i) key: privateKey dsa: dsa]].! !!Project methodsFor: 'accessing' stamp: 'di 4/14/1999 13:59'!setParent: newParent	parentProject := newParent.	nextProject := previousProject := nil.! !!FakeClassPool class methodsFor: 'initialize' stamp: 'dvf 9/27/2005 19:05'!adopt: classOrNil	"Temporarily use the classPool and sharedPools of another class"	classOrNil isBehavior		ifFalse: [classPool := nil.				sharedPools := nil]		ifTrue: [classPool := classOrNil classPool.				sharedPools := classOrNil sharedPools]! !!Preferences class methodsFor: 'personalization' stamp: 'rr 10/1/2005 15:14'!storePreferencesIn: aFileName 	| stream |	#(#Prevailing #PersonalPreferences )  do:[:ea | Parameters  removeKey:ea  ifAbsent:[]].	stream := ReferenceStream  fileNamed:aFileName.	stream  nextPut:Parameters.	stream  nextPut:self dictionaryOfPreferences.	Smalltalk isMorphic 		 ifTrue:[stream  nextPut:World fillStyle]		 ifFalse:[stream  nextPut:DesktopColor].	stream close! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 1/18/2001 15:54'!uniClassInstVarsRefs: dummy	"If some of the objects seen so far are instances UniClasses, check the UniClasses for extra class inst vars, and send them to the steam also.  The new objects get added to (dummy references), where they will be noticed by the caller.  They will wind up in the structures array and will be written on the disk by class.	Return all classes seen." | uniClasses normal more aUniClass mySize allClasses |"Note: Any classes used in the structure of classInstVars must be written out also!!"uniClasses := Set new.allClasses := IdentitySet new.normal := Object class instSize.more := true.[more] whileTrue: [	more := false.	dummy references keysDo: [:each | "any faster way to do this?"		(aUniClass := each class) isSystemDefined ifFalse: [			(uniClasses includes: aUniClass name) ifFalse: [				mySize := aUniClass class instSize.				normal+1 to: mySize do: [:ii | 					more := true.					dummy nextPut: (aUniClass instVarAt: ii)].				uniClasses add: aUniClass name]].		each class class isMeta ifFalse: ["it is a class" allClasses add: each]]]."References dictionary is modified as the loop proceeds, but we will catch any we missed on the next cycle."^ allClasses! !!ResourceManager methodsFor: 'loading' stamp: 'ar 3/2/2001 17:09'!stopDownload	"Stop downloading unloaded resources"	loaderProcess ifNil:[^self].	stopFlag := true.	stopSemaphore signal.	[loaderProcess == nil] whileFalse:[(Delay forMilliseconds: 10) wait].	stopSemaphore := nil.! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 19:06'!allUnusedClassesWithout: classesAndMessagesPair 	"Enumerates all classes in the system and returns a list of those that are 	apparently unused. A class is considered in use if it (a) has subclasses  	or (b) is referred to by some method or (c) has its name in use as a  	literal."	"SystemNavigation new unusedClasses"	| unused cl |	unused := Smalltalk classNames asIdentitySet				copyWithoutAll: (self allGlobalRefsWithout: classesAndMessagesPair).	^ unused		reject: [:cName | 			cl := Smalltalk at: cName.			cl subclasses isEmpty not				or: [cl inheritsFrom: FileDirectory]]! !!ResourceCollector methodsFor: 'resource writing' stamp: 'yo 11/13/2002 23:30'!writeResourceForm: aForm fromLocator: aLocator	"The given form has been externalized before. If it was reasonably compressed, use the bits of the original data - this allows us to recycle GIF, JPEG, PNG etc. data without using the internal compression (which is in most cases inferior). If necessary the data will be retrieved from its URL location. This retrieval is done only if the resouce comes from either		* the local disk (in which case the file has never been published)		* the browser cache (in which case we don't cache the resource locally)	In any other case we will *not* attempt to retrieve it, because doing so can cause the system to connect to the network which is probably not what we want. It should be a rare case anyways; could only happen if one clears the squeak cache selectively."	| fName fStream url data |	"Try to be smart about the name of the file"	fName := (aLocator urlString includes: $:)		ifTrue: [			url := aLocator urlString asUrl.			url path last]		ifFalse: [aLocator urlString].	fName isEmptyOrNil ifFalse:[fName := fName asFileName].	(fName isEmptyOrNil or:[localDirectory isAFileNamed: fName]) ifTrue:[		"bad luck -- duplicate name"		fName := localDirectory 				nextNameFor:'resource' 				extension: (FileDirectory extensionFor: aLocator urlString)].	"Let's see if we have cached it locally"	ResourceManager		lookupCachedResource: self baseUrl , aLocator urlString		ifPresentDo:[:stream | data := stream upToEnd].	"Check if the cache entry is without qualifying baseUrl. Workaround for older versions."	data ifNil:[		ResourceManager			lookupCachedResource: aLocator urlString			ifPresentDo:[:stream | data := stream upToEnd]].	data ifNil:[		"We don't have it cached locally. Retrieve it from its original location."		((url notNil and: [url hasRemoteContents]) and:[HTTPClient isRunningInBrowser not])			ifTrue:[^nil]. "see note above"		(Url schemeNameForString: aLocator urlString)			ifNil: [^nil].		data := HTTPLoader default retrieveContentsFor: aLocator urlString.		data ifNil:[^nil].		data := data content.	].	"data size > aForm bits byteSize ifTrue:[^nil]."	fStream := localDirectory newFileNamed: fName.	fStream binary.	fStream nextPutAll: data.	fStream close.	^{fName. data size}! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/21/2002 16:25'!dependentsSave: dummy	"Object that have dependents are supposed to be instances of subclasses of Model.  But, class Objects still provides 'Global Dependents', and some people still use them.  When both the model and the dependent are in a project that is being saved, remember them, so we can hook them up when this project is loaded in."	| dict proj list |	proj := dummy project.	dict := Dictionary new.	DependentsFields associationsDo: [:assoc |		(dummy references includesKey: assoc key) ifTrue: [			list := assoc value select: [:dd | dummy references includesKey: dd].			list size > 0 ifTrue: [dict at: assoc key put: list]]].	dict size > 0 ifTrue: [		proj projectParameterAt: #GlobalDependentsInProject put: dict].! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/10/2002 22:21'!containsMethodAtPosition: aFilePosition	"Answer whether the receiver contains the method logged at the given file position"	"class: aClassSymbol" "(need class parameter to speed up?)"  "<- dew 9/6/2001"	changeRecords values do:		[:classChangeRecord |		classChangeRecord methodChanges values do:			[:methodChangeRecord | | changeType |			changeType := methodChangeRecord changeType.			((changeType == #add or: [changeType == #change]) and:				[methodChangeRecord currentMethod notNil and: [methodChangeRecord currentMethod filePosition = aFilePosition]])					ifTrue: [^ true]]].	^ false! !!RealEstateAgent class methodsFor: 'utilities' stamp: 'di 11/20/2001 00:16'!assignCollapseFrameFor: aSSView 	"Offer up a location along the left edge of the screen for a collapsed SSView. Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames topLeft viewBox collapsedFrame extent newFrame verticalBorderDistance top |	grid := 8.	verticalBorderDistance := 8.	aSSView isMorph		ifTrue: [otherFrames := (SystemWindow windowsIn: aSSView world satisfying: [:w | w ~= aSSView])						collect: [:w | w collapsedFrame]						thenSelect: [:rect | rect notNil].				viewBox := self reduceByFlaps: aSSView world viewBox]		ifFalse: [otherFrames := ScheduledControllers scheduledWindowControllers						collect: [:aController | aController view ~= aSSView ifTrue: [aController view collapsedFrame]]						thenSelect: [:rect | rect notNil].				viewBox := Display boundingBox].	collapsedFrame := aSSView collapsedFrame.	extent := collapsedFrame notNil				ifTrue: [collapsedFrame extent]				ifFalse: [aSSView isMorph					ifTrue: [aSSView getRawLabel width + aSSView labelWidgetAllowance @ (aSSView labelHeight + 2)]					ifFalse: [(aSSView labelText extent x + 70) @ aSSView labelHeight							min: aSSView labelDisplayBox extent]].	collapsedFrame notNil		ifTrue: [(otherFrames anySatisfy: [:f | collapsedFrame intersects: f])				ifFalse: ["non overlapping"					^ collapsedFrame]].	top := viewBox top + verticalBorderDistance.	[topLeft := viewBox left @ top.	newFrame := topLeft extent: extent.	newFrame bottom <= (viewBox height - verticalBorderDistance)]		whileTrue: 			[(otherFrames anySatisfy: [:w | newFrame intersects: w])				ifFalse: ["no overlap"					^ newFrame].			top := top + grid].	"If all else fails... (really to many wins here)"	^ 0 @ 0 extent: extent! !!Utilities class methodsFor: 'fetching updates' stamp: 'CdG 10/17/2005 22:51'!readServer: serverList special: indexPrefix updatesThrough: maxNumber saveLocally: saveLocally updateImage: updateImage	"Scan the update server(s) for unassimilated updates. If maxNumber is not nil, it represents the highest-numbered update to load.  This makes it possible to update only up to a particular point.   If saveLocally is true, then save local copies of the update files on disc.  If updateImage is true, then absorb the updates into the current image.""Utilities readServer: Utilities serverUrls updatesThrough: 828 saveLocally: true updateImage: true"	| urls failed loaded docQueue this nextDoc docQueueSema str updateName |	Cursor wait showWhile: [	urls := self newUpdatesOn: (serverList collect: [:url | url, 'updates/']) 				special: indexPrefix				throughNumber: maxNumber.	loaded := 0.	failed := nil.	"send downloaded documents throuh this queue"	docQueue := SharedQueue new.	"this semaphore keeps too many documents from beeing queueed up at a time"	docQueueSema := Semaphore new.	5 timesRepeat: [ docQueueSema signal ].	"fork a process to download the updates"	self retrieveUrls: urls ontoQueue: docQueue withWaitSema: docQueueSema.	"process downloaded updates in the foreground"	'Processing updates' displayProgressAt: Sensor cursorPoint from: 0 to: urls size during: [:bar |	[ this := docQueue next.	  nextDoc := docQueue next.  	  nextDoc = #failed ifTrue: [ failed := this ].	  (failed isNil and: [ nextDoc ~= #finished ])	] whileTrue: [		failed ifNil: [			nextDoc reset; text.			nextDoc size = 0 ifTrue: [ failed := this ]. ].		failed ifNil: [			nextDoc peek asciiValue = 4	"pure object file"				ifTrue: [failed := this]].	"Must be fileIn, not pure object file"		failed ifNil: [			"(this endsWith: '.html') ifTrue: [doc := doc asHtml]."				"HTML source code not supported here yet"			updateImage				ifTrue: [					updateName := (this findTokens: '/') last.					ChangeSet newChangesFromStream: nextDoc named: updateName.					SystemVersion current registerUpdate: updateName initialIntegerOrNil].			saveLocally ifTrue:				[self saveUpdate: nextDoc onFile: (this findTokens: '/') last].	"if wanted"			loaded := loaded + 1.			bar value: loaded].		docQueueSema signal].	]].	failed ~~ nil & (urls size - loaded > 0) ifTrue: [		str := loaded printString ,' new update file(s) processed.'.		str := str, '\Could not load ' withCRs, 			(urls size - loaded) printString ,' update file(s).',			'\Starting with "' withCRs, failed, '".'.		self inform: str].	^ Array with: failed with: loaded! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'ar 2/1/2001 20:18'!initRandomFromString: aString	"Ask the user to type a long random string and use the result to seed the secure random number generator."	| s k srcIndex |	s := aString.	k := LargePositiveInteger new: (s size min: 64).	srcIndex := 0.	k digitLength to: 1 by: -1 do: [:i |		k digitAt: i put: (s at: (srcIndex := srcIndex + 1)) asciiValue].	k := k + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"	k highBit > 512 ifTrue: [k := k bitShift: k highBit - 512].	self initRandom: k.! !!Utilities class methodsFor: 'fetching updates' stamp: 'CdG 10/17/2005 19:36'!chooseUpdateList	"When there is more than one set of update servers, let the user choose which we will update from.  Put it at the front of the list. Return false if the user aborted.  If the preference #promptForUpdateServer is false, then suppress that prompt, in effect using the same server choice that was used the previous time (a convenience for those of us who always answer the same thing to the prompt.)"	| index him |	((UpdateUrlLists size > 1) and: [Preferences promptForUpdateServer])		ifTrue:			[index := UIManager default 				chooseFrom: (UpdateUrlLists collect: [:each | each first]) 				lines: #()				title: 'Choose a group of servers\from which to fetch updates.' translated withCRs.			index > 0 ifTrue:				[him := UpdateUrlLists at: index.				UpdateUrlLists removeAt: index.				UpdateUrlLists addFirst: him].			^ index > 0].	^ true! !!Project class methodsFor: 'squeaklet on server' stamp: 'gk 10/21/2005 11:01'!fromUrl: urlString	"Load the project, and make a thumbnail to it in the current project.  Replace the old one if necessary.To test it, make sure you don't have AAEmptyTest.001.pr in your Squeaklets directory. Then do:Project fromUrl: 'http://209.143.91.36/super/SuperSwikiProj/AAEmptyTest.001.pr'.The project should open and you should enter it. Return to the previous project and delete the project. Then do:Project fromUrl: 'AAEmptyTest.001.pr'.The project should open again - this time faster - and you should enter it. "	| absoluteUrl projectFilename projName proj serverDir pair |	Project canWeLoadAProjectNow ifFalse: [^ self].	absoluteUrl := Url absoluteFromFileNameOrUrlString: urlString.	projectFilename := absoluteUrl fileName.	projName := (Project parseProjectFileName: projectFilename unescapePercents) first.	(proj := Project named: projName) ifNotNil: [		"it appeared"		^ProjectEntryNotification signal: proj].	serverDir := ServerDirectory serverForURL: absoluteUrl directoryUrl asString.	serverDir ifNotNil: [		pair := self mostRecent: projectFilename onServer: serverDir.		"Pair first is name exactly as it is on the server"		pair first ifNil: [^self openBlankProjectNamed: projName].		projectFilename := pair first].	ProjectLoading		installRemoteNamed: projectFilename		from: absoluteUrl asString unescapePercents		named: projName		in: CurrentProject! !!SerialPort methodsFor: 'input/output' stamp: 'jm 5/18/1998 15:44'!readByteArray	"Answer a ByteArray read from this serial port. Answer an empty ByteArray if no data is available. The port must be open."	| buf count |	buf := ByteArray new: 1000.	count := self primReadPort: port into: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: count! !!PrettyTextDiffBuilder methodsFor: 'initialize' stamp: 'nk 10/29/2000 12:16'!sourceClass: aClass	sourceClass := aClass.! !!PseudoClass methodsFor: 'accessing' stamp: ''!name: anObject	name := anObject! !!Project methodsFor: 'language' stamp: 'mir 9/1/2005 00:37'!localeID	"Answer the natural language for the project"	| prev |	^ self projectParameterAt: #localeID		ifAbsentPut: [			(prev := self previousProject)				ifNotNil: [prev projectParameterAt: #localeID ifAbsent: [LocaleID current]]				ifNil: [LocaleID current]]! !!SmalltalkImage methodsFor: 'endian' stamp: 'yo 2/18/2004 18:24'!endianness	EndianCache ifNil: [EndianCache := self calcEndianness].	^ EndianCache.! !!MessageTally methodsFor: 'collecting leaves' stamp: ''!bump: hitCount fromSender: senderTally	"Add this hitCount to the total, and include a reference to the	sender responsible for the increment"	self bump: hitCount.	senders == nil ifTrue: [senders := OrderedCollection new].	senderTally == nil		ifFalse: [senders add: (senderTally copyWithTally: hitCount)]! !!Utilities class methodsFor: 'durable menus' stamp: 'di 9/22/1998 14:48'!windowFromMenu: aMenu target: aTarget title: aTitle colorPattern: aColorPattern	| labelList targetList selectionList i |	selectionList := aMenu selections.	labelList := (1 to: selectionList size) collect:		[:ind | aMenu labelString lineNumber: ind].	targetList :=  (1 to: selectionList size) collect: [:ind | aTarget].	(i := labelList indexOf: 'keep this menu up') > 0 ifTrue:		[selectionList := selectionList copyReplaceFrom: i to: i with: Array new.		labelList := labelList copyReplaceFrom: i to: i with: Array new.		targetList := targetList copyReplaceFrom: i to: i with: Array new].	self windowMenuWithLabels:  labelList colorPattern: aColorPattern targets: targetList selections: selectionList title: aTitle! !!Utilities class methodsFor: 'support windows' stamp: 'dgd 9/21/2003 15:12'!commandKeyMappings	^ (self class firstCommentAt: #commandKeyMappings) translated"Lower-case command keys(use with Cmd key on Mac and Alt key on other platforms)a	Select allb	Browse it (selection is a class name or cursor is over a class-list or message-list)c	Copy selectiond	Do it (selection is a valid expression)e	Exchange selection with prior selectionf	Findg	Find againh	Set selection as search string for find againi	Inspect it (selection is a valid expression, or selection is over an inspect-ilst)j	Again once (do the last text-related operation again)k	Set fontl	Cancelm	Implementors of it (selection is a message selector or cursor is over a class-list or message-list)n	Senders of it (selection is a message selector or cursor is over a class-list or message-list)o	Spawn current methodp	Print it (selection is a valid expression)q	Query symbol (toggle all possible completion for a given prefix)r	Recognizers	Save (i.e. accept)t	Finds a Transcript (when cursor is over the desktop)u	Toggle alignmentv	Pastew	Delete preceding word (over text);  Close-window (over morphic desktop)x	Cut selectiony	Swap charactersz	UndoNote: for Do it, Senders of it, etc., a null selection will be expanded to a word or to the current line in an attempt to do what you want.  Also note that Senders/Implementors of it will find the outermost keyword selector in a large selection, as when you have selected a bracketed expression or an entire line.  Finally note that the same cmd-m and cmd-n (and cmd-v for versions) work in the message pane of most browsers.Upper-case command keys	(use with Shift-Cmd, or Ctrl on Mac	or Shift-Alt on other platforms; sometimes Ctrl works too)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'G	fileIn from it (a file name)H	cursor TopHome:I	Inspect via Object ExplorerJ	Again many (apply the previous text command repeatedly until the end of the text)K	Set styleL	Outdent (move selection one tab-stop left)M	Select current type-inN	References to it (selection is a class name, or cursor is over a class-list or message-list)O	Open single-message browser (in message lists)P	Make project linkR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing it (in text); show-world-menu (when issued with cursor over desktop)X	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selectionOther special keysBackspace	Backward delete characterDel			Forward delete characterShift-Bksp	Backward delete wordShift-Del	Forward delete wordEsc			Pop up the Desktop Menu\			Send top window to backCursor keysleft, right,up, down	Move cursor left, right, up or downCtrl-left		Move cursor left one wordCtrl-right	Move cursor right one wordHome		Move cursor to begin of line or begin of textEnd			Move cursor to end of line or end of textPgUp, Ctrl-up	Move cursor up one pagePgDown, Ctrl-Dn	Move cursor down one pageNote all these keys can be used together with Shift to define or enlarge the selection. You cannot however shrink that selection again, as in some other systems.Other Cmd-key combinations (not available on all platforms)Return		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)Space		Select the current word as with double clickingEnclose the selection in a kind of bracket.  Each is a toggle.	(not available on all platforms)Ctrl-(	Enclose within ( and ), or remove enclosing ( and )Ctrl-[	Enclose within [ and ], or remove enclosing [ and ]Crtl-{	Enclose within { and }, or remove enclosing { and }Ctrl-<	Enclose within < and >, or remove enclosing < and >Ctrl-'	Enclose within ' and ', or remove enclosing ' and 'Ctrl-""	Enclose within "" and "", or remove enclosing "" and ""Note also that you can double-click just inside any of the above delimiters,or at the beginning or end of a line, to select the text enclosed.Text Emphasis	(not available on all platforms)Cmd-1	10 point fontCmd-2	12 point fontCmd-3	18 point fontCmd-4	24 point fontCmd-5	36 point fontCmd-6	color, action-on-click, link to class comment, link to method, url		Brings up a menu.  To remove these properties, select		more than the active part and then use command-0.Cmd-7	boldCmd-8	italicCmd-9	narrow (same as negative kern)Cmd-0	plain text (resets all emphasis)Cmd--	underlined (toggles it)Cmd-=	struck out (toggles it)Shift-Cmd--	(aka :=) negative kern (letters 1 pixel closer)Shift-Cmd-+	positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'miscellaneous' stamp: ''!keyLike: aString withTrailing: trailerString satisfying: aBlock	"Return a key like (aString, trailerString) that satisfies aBlock.  The block should provide a test for acceptability -- typically the test is about whether the key is already in use.  aBlock should return a boolean.  8/11/96 sw"	| stemAndSuffix suffix stem composite |	composite := aString, trailerString.	(aBlock value: composite) ifTrue: [^ composite].	stemAndSuffix := aString stemAndNumericSuffix.	suffix := stemAndSuffix last + 1.	stem := stemAndSuffix first.	[aBlock value: (composite := stem, suffix printString, trailerString)]		whileFalse:			[suffix := suffix + 1].	^ composite! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 4/2/2003 15:25'!register: aProviderClass	(self registeredClasses includes: aProviderClass) ifFalse:		[default := nil.  "so it'll ask for a new default, since if you're registering a new app you probably want to use it"		self registeredClasses add: aProviderClass].! !!Utilities class methodsFor: 'miscellaneous' stamp: 'JMM 3/31/2000 20:41'!awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw3/31/00 JMM added logic to stop multiple redraws"	| p inside lightForm darkForm isLight |	p := Sensor cursorPoint.	inside := box insetBy: 1.	isLight := true.	lightForm := Form fromDisplay: inside.	darkForm := lightForm deepCopy reverse.	[Sensor anyButtonPressed] whileTrue:		[doBlock1 value.		(box containsPoint: (p := Sensor cursorPoint))			ifTrue: [doBlock2 value.					isLight ifTrue: 						[isLight := false.						darkForm displayAt: inside origin]]			ifFalse: [isLight ifFalse:						[isLight := true.						lightForm displayAt: inside origin]]].	(box containsPoint: p)		ifTrue: [lightForm displayAt: inside origin.				^ succBlock value]! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 6/26/2001 12:15'!changedMessageList	"Used by a message set browser to access the list view information."	| messageList classNameInFull classNameInParts |	messageList := OrderedCollection new.	changeRecords associationsDo: [:clAssoc |		classNameInFull := clAssoc key asString.		classNameInParts := classNameInFull findTokens: ' '.		(clAssoc value allChangeTypes includes: #comment) ifTrue:			[messageList add:				(MethodReference new					setClassSymbol: classNameInParts first asSymbol					classIsMeta: false 					methodSymbol: #Comment 					stringVersion: classNameInFull, ' Comment')].		clAssoc value methodChangeTypes associationsDo: [:mAssoc |			(#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add:					(MethodReference new						setClassSymbol: classNameInParts first asSymbol						classIsMeta: classNameInParts size > 1 						methodSymbol: mAssoc key 						stringVersion: classNameInFull, ' ' , mAssoc key)]]].	^ messageList asSortedArray! !!Preference methodsFor: 'user interface' stamp: 'hpt 9/26/2004 16:58'!representativeButtonWithColor: aColor inPanel: aPanel	| view |	view := self viewForPanel: aPanel.	^view ifNotNil: [view representativeButtonWithColor: aColor inPanel: aPanel]! !!Project methodsFor: 'file in/out' stamp: 'RAA 10/26/2000 14:12'!ensureChangeSetNameUnique	| myName |	myName := self name.	Project allProjects do: [:pp | 		pp == self ifFalse: [			(pp name = myName and: [pp projectChangeSet ~~ changeSet]) ifTrue: [				(pp parameterAt: #loadingNewerVersion ifAbsent: [false]) ifTrue: [					pp projectParameters at: #loadingNewerVersion put: false.				] ifFalse: [					changeSet ifNil: [^ changeSet := ChangeSet new].					^changeSet name: (ChangeSet uniqueNameLike: myName)				].			]		]	]! !!ResourceManager methodsFor: 'accessing' stamp: 'mir 8/21/2001 17:07'!makeAllProjectResourcesLocalTo: resourceUrl	"Change the urls in the resource locators so project specific resources are stored and referenced locally. Project specific resources are all those that are kept locally in any of the project's versions."	| locators locUrl locBase lastSlash projectBase localResource isExternal | 	"Construct the version neutral project base"	resourceUrl isEmptyOrNil ifTrue: [^self].	projectBase := resourceUrl copyFrom: 1 to: (resourceUrl lastIndexOf: $.) - 1.	locators := OrderedCollection new.	self resourceMap		keysAndValuesDo:[:loc :res | res ifNotNil: [locators add: loc]].	locators do: [:locator |		locUrl := locator urlString.		locUrl ifNotNil: [			lastSlash := locUrl lastIndexOf: $/.			lastSlash > 0				ifTrue: [					locBase := locUrl copyFrom: 1 to: lastSlash - 1.					locBase := locBase copyFrom: 1 to: (((locBase lastIndexOf: $.) - 1) max: 0).					isExternal := projectBase ~= locBase.					(isExternal not						or: [self localizeAllExternalResources])						ifTrue: [							localResource := locUrl copyFrom: lastSlash+1 to: locUrl size.							"Update the cache entry to point to the new resource location"							ResourceManager renameCachedResource: locUrl to: (resourceUrl , localResource) external: isExternal.							locator urlString: localResource]]]].	self resourceMap rehash! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 19:43'!processBuffer: aByteArray	"Process given 64-byte buffer, accumulating the results in totalA through totalE."	| a b c d e w tmp |	self primHasSecureHashPrimitive		ifTrue: [^ self processBufferUsingPrimitives: aByteArray]		ifFalse: [totals := nil].	"initialize registers a through e from the current totals" 	a := totalA copy.	b := totalB copy.	c := totalC copy.	d := totalD copy.	e := totalE copy.	"expand and process the buffer"	w := self expandedBlock: aByteArray.	1 to: 80 do: [:i |		tmp := (a copy leftRotateBy: 5)			+= (self hashFunction: i of: b with: c with: d);			+= e;			+= (w at: i);			+= (self constantForStep: i).		e := d.		d := c.		c := b copy leftRotateBy: 30.		b := a.		a := tmp].	"add a through e into total accumulators"	totalA += a.	totalB += b.	totalC += c.	totalD += d.	totalE += e.! !!Project methodsFor: 'menu messages' stamp: 'sd 5/23/2003 14:40'!saveState	"Save the current state in me prior to leaving this project"	changeSet := ChangeSet current.	thumbnail ifNotNil: [thumbnail hibernate].	Smalltalk isMorphic		ifTrue:			[world := World.			world sleep.			ActiveWorld := ActiveHand := ActiveEvent := nil]		ifFalse:			[world := ScheduledControllers.			ScheduledControllers unCacheWindows].	Sensor flushAllButDandDEvents. "Will be reinstalled by World>>install"	transcript := Transcript.! !!SmartRefStream methodsFor: 'read write' stamp: 'ar 4/10/2005 18:52'!verifyStructure	"Compare the incoming inst var name lists with the existing classes.  Prepare tables that will help to restructure those who need it (renamed, reshaped, steady).    If all superclasses are recorded in the file, only compare inst vars of this class, not of superclasses.  They will get their turn.  "	| newClass newList oldList converting |	self flag: #bobconv.		converting := OrderedCollection new.	structures keysDo: [:nm "an old className (symbol)" |		"For missing classes, there needs to be a method in SmartRefStream like 			#rectangleoc2 that returns the new class."		newClass := self mapClass: nm.	   "does (renamed at: nm put: newClass name)"		newClass isString ifTrue: [^ newClass].  "error, fileIn needed"		newList := (Array with: newClass classVersion), (newClass allInstVarNames).		oldList := structures at: nm.		newList = oldList 			ifTrue: [steady add: newClass]  "read it in as written"			ifFalse: [converting add: newClass name]	].	false & converting isEmpty not ifTrue: ["debug" 			self inform: 'These classes are being converted from existing methods:\' withCRs,				converting asArray printString].! !!ImageSegmentRootStub class methodsFor: 'settings' stamp: 'di 2/7/2000 23:17'!dontLogFaults  "ImageSegmentRootStub dontLogFaults"	FaultLogs := Dictionary new.	LoggingFaults := false.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'nk 6/2/2006 09:22'!removeAllLineFeedsQuietlyCalling: aBlock	"Smalltalk removeAllLineFeedsQuietly"	"Scan all methods for source code with lineFeeds.	Replaces all occurrences of <CR><LF> or <LF> by <CR>.	Answer a Dictionary keyed by author name containing sets of affected method names,	as well as (at the key 'OK') a list of methods that still contain LF characters inside literal strings or characters.	Evaluate aBlock for each method so that status can be updated."	| oldCodeString newCodeString oldStamp oldCategory authors nameString |	self forgetDoIts.	authors := Dictionary new.	authors at: 'OK' put: Set new.	self systemNavigation		allBehaviorsDo: [:cls | cls selectors				do: [:selector | 					aBlock value: cls value: selector.					oldCodeString := cls sourceCodeAt: selector.					(oldCodeString includes: Character lf)						ifTrue: [							newCodeString := oldCodeString withSqueakLineEndings.							nameString := cls name , '>>' , selector.							((cls compiledMethodAt: selector) hasLiteralSuchThat: [ :lit | lit asString includes: Character lf ])								ifTrue: [(authors at: 'OK')										add: nameString]								ifFalse: [oldStamp := (Utilities												timeStampForMethod: (cls compiledMethodAt: selector))												copy replaceAll: Character cr												with: Character space.									(authors										at: (oldStamp copyFrom: 1 to: (oldStamp findFirst: [ :c | c isAlphaNumeric not ]))										ifAbsentPut: [Set new])										add: nameString.									oldCategory := cls whichCategoryIncludesSelector: selector.									cls										compile: newCodeString										classified: oldCategory										withStamp: oldStamp										notifying: nil ]]]].	^ authors! !!SystemNavigation methodsFor: 'query' stamp: 'nk 7/3/2003 19:51'!allPrimitiveMethods	"Answer an OrderedCollection of all the methods that are implemented by primitives."	| aColl method |	aColl := OrderedCollection new: 200.	Cursor execute		showWhile: [self allBehaviorsDo: [:class | class						selectorsDo: [:sel | 							method := class compiledMethodAt: sel.							method primitive ~= 0								ifTrue: [aColl addLast: class name , ' ' , sel , ' ' , method primitive printString]]]].	^ aColl! !!HTTPLoader class methodsFor: 'class initialization' stamp: 'mir 3/8/2001 16:31'!initialize	"HTTPLoader initialize"	MaxNrOfConnections := 4.	DefaultLoader ifNotNil: [		DefaultLoader release.		DefaultLoader := nil]! !!SARInstaller methodsFor: 'client services' stamp: 'nk 10/14/2003 18:58'!memberNamed: aString	^(zip member: aString)		ifNil: [ | matching |			matching := zip membersMatching: aString.			matching isEmpty ifFalse: [ matching last ]].! !!Utilities class methodsFor: 'fetching updates' stamp: 'md 9/11/2004 12:07'!assureAvailabilityOfUnstableUpdateStream	"Check to see if the unstable Updates stream is in the list; if not, add it"	UpdateUrlLists ifNil: [UpdateUrlLists := OrderedCollection new].	UpdateUrlLists do:		[:pair | (pair first =  'Unstable Updates*') ifTrue: [^ self]].	UpdateUrlLists addFirst: #('Unstable Updates*' #('squeak.cs.uiuc.edu/Squeak2.0/' 'update.squeakfoundation.org/external/'))"Utilities assureAvailabilityOfUnstableUpdateStream"! !!Project methodsFor: 'file in/out' stamp: 'RAA 5/10/2001 12:21'!armsLengthCommand: aCommand withDescription: aString	| pvm tempProject foolingForm tempCanvas bbox crossHatchColor stride |	"Set things up so that this aCommand is sent to self as a messageafter jumping to the parentProject.  For things that can't be executedwhile in this project, such as saveAs, loadFromServer, storeOnServer.  SeeProjectViewMorph step."	self isMorphic ifTrue: [		world borderWidth: 0.	"get rid of the silly default border"		tempProject := Project newMorphic.		foolingForm := world imageForm.		"make them think they never left"		tempCanvas := foolingForm getCanvas.		bbox := foolingForm boundingBox.		crossHatchColor := Color yellow alpha: 0.3.		stride := 20.		10 to: bbox width by: stride do: [ :x |			tempCanvas fillRectangle: (x@0 extent: 1@bbox height) fillStyle: crossHatchColor.		].		10 to: bbox height by: stride do: [ :y |			tempCanvas fillRectangle: (0@y extent: bbox width@1) fillStyle: crossHatchColor.		].		tempProject world color: (InfiniteForm with: foolingForm).		tempProject projectParameters 			at: #armsLengthCmd 			put: (				DoCommandOnceMorph new					addText: aString;					actionBlock: [						self doArmsLengthCommand: aCommand.					] fixTemps			).		tempProject projectParameters 			at: #deleteWhenEnteringNewProject 			put: true.		tempProject enter.	] ifFalse: [		parentProject ifNil: [^ self inform: 'The top project can''t do that'].		pvm := parentProject findProjectView: self.		pvm armsLengthCommand: {self. aCommand}.		self exit.	].! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 22:39'!compareTallyIn: beforeFileName to: afterFileName	"SpaceTally new compareTallyIn: 'tally' to: 'tally2'"	| answer s beforeDict a afterDict allKeys before after diff |	beforeDict := Dictionary new.	s := FileDirectory default fileNamed: beforeFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		beforeDict at: a first put: a allButFirst.	].	s close.	afterDict := Dictionary new.	s := FileDirectory default fileNamed: afterFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		afterDict at: a first put: a allButFirst.	].	s close.	answer := WriteStream on: String new.	allKeys := (Set new addAll: beforeDict keys; addAll: afterDict keys; yourself) asSortedCollection.	allKeys do: [ :each |		before := beforeDict at: each ifAbsent: [#(0 0 0)].		after := afterDict at: each ifAbsent: [#(0 0 0)].		diff := before with: after collect: [ :vBefore :vAfter | vAfter - vBefore].		diff = #(0 0 0) ifFalse: [			answer nextPutAll: each,'  ',diff printString; cr.		].	].	StringHolder new contents: answer contents; openLabel: 'space diffs'.	! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/6/2001 09:40'!initialize 	"Initialize the receiver to be empty."	name ifNil:		[^ self error: 'All changeSets must be registered, as in ChangeSorter newChangeSet'].	revertable := false.	self clear.! !!ReferenceStream methodsFor: 'reading' stamp: '6/9/97 09:00 tk'!noteCurrentReference: typeID	"PRIVATE -- If we support references for type typeID, remember	 the current byteStream position so beginReference: can add the	 next object to the 'objects' dictionary of reference positions,	 then return true. Else return false."	| answer |	(answer := self isAReferenceType: typeID)		ifTrue: [self setCurrentReference: (byteStream position - 1) - basePos "relative"				"subtract 1 because we already read the object's type ID byte"].	^ answer! !!SystemNavigation methodsFor: 'browse' stamp: 'sd 4/16/2003 08:53'!browseClassCommentsWithString: aString	"Smalltalk browseClassCommentsWithString: 'my instances' "	"Launch a message list browser on all class comments containing aString as a substring."	| caseSensitive suffix list |	suffix := (caseSensitive := Sensor shiftPressed)		ifTrue: [' (case-sensitive)']		ifFalse: [' (use shift for case-sensitive)'].	list := Set new.	Cursor wait showWhile: [		Smalltalk allClassesDo: [:class | 			(class organization classComment asString findString: aString 							startingAt: 1 caseSensitive: caseSensitive) > 0 ifTrue: [								list add: (									MethodReference new										setStandardClass: class										methodSymbol: #Comment								)							]		]	].	^ self 		browseMessageList: list asSortedCollection		name: 'Class comments containing ' , aString printString , suffix		autoSelect: aString! !!DataStream methodsFor: 'write and read' stamp: ' 	6/9/97'!objectAt: anInteger	"PRIVATE -- Read & return the object at a given stream position.  08:18 tk  anInteger is a relative file position. "	| savedPosn anObject refPosn |	savedPosn := byteStream position.	"absolute"	refPosn := self getCurrentReference.	"relative position"	byteStream position: anInteger + basePos.	"was relative"	anObject := self next.	self setCurrentReference: refPosn.	"relative position"	byteStream position: savedPosn.		"absolute"	^ anObject! !!Utilities class methodsFor: 'scraps' stamp: 'dgd 9/19/2003 10:49'!trashTitle	| label pgs |	label := 'T R A S H' translated.	^ (pgs := ScrapsBook pages size) < 2		ifTrue:			[label]		ifFalse:			[label, ('  ({1} pages)' translated format:{pgs})]! !!Project methodsFor: 'initialization' stamp: 'RAA 6/21/2000 22:59'!setChangeSet: aChangeSet	isolatedHead == true ifTrue: [^ self].  "ChangeSet of an isolated project cannot be changed"	changeSet := aChangeSet! !!ResourceManager methodsFor: 'loading' stamp: 'ar 3/3/2001 18:01'!startDownload	"Start downloading unloaded resources"	self stopDownload.	unloaded isEmpty ifTrue:[^self].	self loadCachedResources.	unloaded isEmpty ifTrue:[^self].	stopFlag := false.	stopSemaphore := Semaphore new.	loaderProcess := [self loaderProcess] newProcess.	loaderProcess priority: Processor lowIOPriority.	loaderProcess resume.! !!Utilities class methodsFor: 'miscellaneous' stamp: 'mdr 8/31/2000 18:54'!convertCRtoLF: fileName	"Convert the given file to LF line endings. Put the result in a file with the extention '.lf'"	| in out c justPutCR |	in := (FileStream readOnlyFileNamed: fileName) binary.	out :=  (FileStream newFileNamed: fileName, '.lf') binary.	justPutCR := false.	[in atEnd] whileFalse: [		c := in next.		c = 10			ifTrue: [				out nextPut: 13.				justPutCR := true]			ifFalse: [				(justPutCR and: [c = 10]) ifFalse: [out nextPut: c].				justPutCR := false]].	in close.	out close.! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!checkForUncommentedMethods	| aList |	"Check to see if there are any methods in the receiver that have no comments, and open a browser on all found"	(aList := self methodsWithoutComments) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '" have comments']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" that lack comments']! !!Preferences class methodsFor: 'misc' stamp: 'sw 3/2/2004 22:11'!setArrowheads	"Let the user edit the size of arrowheads"	| aParameter result  |	aParameter := self parameterAt: #arrowSpec ifAbsent: [5 @ 4].	result := Morph obtainArrowheadFor: 'Default size of arrowheads on pen trails ' translated defaultValue: aParameter asString.	result ifNotNil:			[self setParameter: #arrowSpec to: result]		ifNil:			[Beeper beep]! !!Utilities class methodsFor: 'fetching updates' stamp: 'di 4/29/2001 14:27'!parseListContents: listContents	| sections vers strm line fileNames |	"Parse the contents of updates.list into {{vers. {fileNames*}}*}, and return it."	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	vers := nil.	strm := ReadStream on: listContents.	[strm atEnd] whileFalse:		[line := strm upTo: Character cr.		line size > 0 ifTrue:			[line first = $#				ifTrue: [vers ifNotNil: [sections addLast: {vers. fileNames asArray}].						"Start a new section"						vers := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	vers ifNotNil: [sections addLast: {vers. fileNames asArray}].	^ sections asArray" TEST: | list |list := Utilities parseListContents: (FileStream oldFileNamed: 'updates.list') contentsOfEntireFile.list = (Utilities parseListContents: (String streamContents: [:s | Utilities writeList: list toStream: s]))	ifFalse: [self error: 'test failed']	ifTrue: [self inform: 'test OK']"! !!Utilities class methodsFor: 'miscellaneous' stamp: ''!keyLike: aString satisfying: aBlock	"Return a key like aString that satisfies aBlock.  The block should provide a test for acceptability -- typically the test is about whether the key is already in use.  aBlock should return a boolean.  8/11/96 sw"	| stemAndSuffix suffix stem newKey |	(aBlock value: aString) ifTrue: [^ aString].	stemAndSuffix := aString stemAndNumericSuffix.	suffix := stemAndSuffix last + 1.	stem := stemAndSuffix first.	[aBlock value: (newKey := stem, suffix printString)]		whileFalse:			[suffix := suffix + 1].	^ newKey! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 10/2/2000 18:16'!beginInstance: aClass size: anInteger	"This is for use by storeDataOn: methods.  Cf. Object>>storeDataOn:."	"Addition of 1 seems to make extra work, since readInstance has to compensate.  Here for historical reasons dating back to Kent Beck's original implementation in late 1988.	In ReferenceStream, class is just 5 bytes for shared symbol.	SmartRefStream puts out the names and number of class's instances variables for checking.6/10/97 16:09 tk: See if we can put on a short header. Type = 16. "	| short ref |	short := true.	"All tests for object header that can be written in 4 bytes"	anInteger <= 254 ifFalse: [short := false].	"one byte size"	ref := references at: aClass name ifAbsent: [short := false. nil].	ref isInteger ifFalse: [short := false].	short ifTrue: [short := (ref < 65536) & (ref > 0) "& (ref ~= self vacantRef)"].  "vacantRef is big"	short ifTrue: [		byteStream skip: -1.		short := byteStream next = 9.		byteStream skip: 0].	"ugly workaround"	short 		ifTrue: ["passed all the tests!!"			byteStream skip: -1; nextPut: 16; "type = short header"				nextPut: anInteger + 1;	"size is short"				nextNumber: 2 put: ref]		ifFalse: [			"default to normal longer object header"			byteStream nextNumber: 4 put: anInteger + 1.			self nextPut: aClass name].	insideASegment ifTrue: [		aClass isSystemDefined ifFalse: [self nextPut: aClass]].			"just record it to put it into roots"! !!ObjectScanner methodsFor: 'scanning' stamp: 'yo 11/11/2002 10:27'!lookAhead: aChunk	"See if this chunk is a class Definition, and if the new class name already exists and is instance-specific.  Modify the chunk, and record the rename in the SmartRefStream and in me."	| pieces sup oldName existing newName newDefn |	aChunk size < 90 ifTrue: [^ aChunk].		"class defn is big!!"	(aChunk at: 1) == $!! ifTrue: [^ aChunk].	"method def, fast exit"	pieces := (aChunk copyFrom: 1 to: (300 min: aChunk size)) findTokens: ' #	\' withCRs.	pieces size < 3 ifTrue: [^ aChunk].	"really bigger, but just took front"	(pieces at: 2) = 'subclass:' ifFalse: [^ aChunk].	sup := Smalltalk at: (pieces at: 1) asSymbol ifAbsent: [^ aChunk].	sup class class == Metaclass ifFalse: [^ aChunk].	((oldName := pieces at: 3) at: 1) canBeGlobalVarInitial ifFalse: [^ aChunk].	oldName := oldName asSymbol.	(Smalltalk includesKey: oldName) ifFalse: [^ aChunk].	"no conflict"	existing := Smalltalk at: oldName.	(existing isKindOf: Class) ifFalse: [^ aChunk].	"Write over non-class global"	existing isSystemDefined ifTrue: [^ aChunk].	"Go ahead and redefine it!!"	"Is a UniClass"	newName := sup chooseUniqueClassName.	newDefn := aChunk copyReplaceAll: oldName with: newName.	Compiler evaluate: newDefn for: self logged: true.	"Create the new class"	self rename: oldName toBe: newName.	^ newName asString		"to be evaluated"! !!HTTPLoader class methodsFor: 'accessing' stamp: 'mir 10/4/1999 18:41'!default	DefaultLoader ifNil: [		DefaultLoader := HTTPLoader new].	^DefaultLoader! !!Utilities class methodsFor: 'debugging' stamp: 'sw 4/29/2001 23:42'!doesNotUnderstand: aMessage	"A temporary expedient for revectoring various messages formerly sent to Utilities that now are instead implemented by Flaps; this is only for the benefit of pre-existing buttons and menu items that were set up to call the old interface"	| aSelector |	aSelector := aMessage selector.	(#(addLocalFlap explainFlaps addMenuFlap addPaintingFlap addStackToolsFlap addGlobalFlap offerGlobalFlapsMenu toggleWhetherToUseGlobalFlaps ) includes: aSelector)		ifTrue:			[^ self inform: 'Sorry, this is an obsolete menu.  Pleasedismiss it and get a fresh one.  Thank you'].	^ super doesNotUnderstand: aMessage! !!Project methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		isolatedHead ifNil: [isolatedHead := false].	inForce ifNil: [inForce := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 8/16/97 13:13'!chooseFileWithSuffix: aSuffix	"Utilities chooseFileWithSuffix: '.gif'"	| aList aName |	aList := FileDirectory default fileNamesMatching: '*', aSuffix.	aList size > 0		ifTrue:			[aName := (SelectionMenu selections: aList) startUpWithCaption: 'Choose a file'.			^ aName]		ifFalse:			[self inform: 'Sorry, there are no fileswhose names end with "', aSuffix, '".'.			^ nil]! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 15:40'!layersToTop	"Return an OrderedCollection of all the projects that are isolation layers from this one up to the top of the project hierarchy, inclusive."	| layers |	self isTopProject		ifTrue: [layers := OrderedCollection new]		ifFalse: [layers := parentProject layersToTop].	isolatedHead ifTrue: [layers addFirst: self].	^ layers! !!Utilities class methodsFor: 'recent method submissions' stamp: 'sw 9/26/2002 19:16'!purgeFromRecentSubmissions: aMethodReference	"Purge any reference found in RecentSubmissions to the method supplied"	RecentSubmissions := RecentSubmissions select:		[:aSubmission |			Utilities setClassAndSelectorFrom: aSubmission in:				[:aClass :aSelector | (aClass ~~ aMethodReference actualClass) or: [aSelector ~~ aMethodReference methodSymbol]]]! !!Project class methodsFor: 'squeaklet on server' stamp: 'RAA 1/28/2001 08:39'!isBadNameForStoring: aString	| badChars |	"will the name of this project cause problems when stored on an arbitrary file system?"	badChars := #( $: $< $> $| $/ $\ $? $* $" $.) asSet.	^aString size > 24 or: [		aString anySatisfy: [ :each | 			each asciiValue < 32 or: [badChars includes: each]		]	]! !!Project methodsFor: 'flaps support' stamp: 'sw 5/7/2001 12:48'!cleanseDisabledGlobalFlapIDsList	"Make certain that the items on the disabled-global-flap list are actually global flaps, and if not, get rid of them"	| disabledFlapIDs currentGlobalIDs oldList |	Smalltalk isMorphic ifTrue:		[disabledFlapIDs := self parameterAt: #disabledGlobalFlapIDs ifAbsent: [Set new].		currentGlobalIDs := Flaps globalFlapTabsIfAny collect: [:f | f flapID].		oldList := Project current projectParameterAt: #disabledGlobalFlaps ifAbsent: [nil].		oldList ifNotNil:			[disabledFlapIDs := oldList select: [:aFlap | aFlap flapID]].		disabledFlapIDs := disabledFlapIDs select: [:anID | currentGlobalIDs includes: anID].		self projectParameterAt: #disabledGlobalFlapIDs put: disabledFlapIDs].	projectParameters ifNotNil:		[projectParameters removeKey: #disabledGlobalFlaps ifAbsent: []].! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'al 1/13/2006 00:19'!reconstructChanges		"Move all the changes and its histories onto another sources file."	"Smalltalk reconstructChanges"	| f oldChanges classCount |	f := FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size + self traitNames size	during:		[:bar | classCount := 0.		Smalltalk allClassesAndTraitsDo:			[:classOrTrait | bar value: (classCount := classCount + 1).			classOrTrait moveChangesWithVersionsTo: f.			classOrTrait putClassCommentToCondensedChangesFile: f.			classOrTrait classSide moveChangesWithVersionsTo: f]].	SmalltalkImage current lastQuitLogPosition: f position.	f trailer; close.	oldChanges := SourceFiles at: 2.	oldChanges close.	FileDirectory default 		deleteFileNamed: oldChanges name , '.old';		rename: oldChanges name toBe: oldChanges name , '.old';		rename: f name toBe: oldChanges name.	self setMacFileInfoOn: oldChanges name.	SourceFiles at: 2			put: (FileStream oldFileNamed: oldChanges name)! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!findUpdateChangeSetMatching: updateNumber	"Find update-changeset beginning with updateNumber, or reasonably close."	"This is to account for the fact that many changeset files are output from final releases, but may be tested for conflicts in a following alpha image, which will often not include that particular update-changeset from the final release but will contain ones near it.  For example, if the file updateNumber is 5180 (from 3.5 final), but the image has no update-changeset beginning with 5180 because it's a 3.6alpha image (which starts at 5181), it will try up to 5190 and down to 5170 for a close match."	| updateNumberChangeSet updateNumberToTry |	updateNumberToTry := updateNumber.	updateNumberChangeSet := nil.	[updateNumberChangeSet isNil and: [updateNumberToTry notNil]] whileTrue:		[updateNumberChangeSet := ChangesOrganizer allChangeSets			detect: [:cs | (cs name beginsWith: updateNumberToTry asString)							and: [(cs name at: (updateNumberToTry asString size + 1)) isDigit not]]			ifNone: [nil].		updateNumberToTry >= updateNumber ifTrue:			[updateNumberToTry < (updateNumber + 10)				ifTrue: [updateNumberToTry := updateNumberToTry + 1]				ifFalse: [updateNumberToTry := updateNumber]].		updateNumberToTry <= updateNumber ifTrue:			[updateNumberToTry > (updateNumber - 10)				ifTrue: [updateNumberToTry := updateNumberToTry - 1]				ifFalse: [updateNumberToTry := nil  "we're done trying"]].		].	updateNumberChangeSet ifNil:		[(self confirm: 'Warning: No changeset beginning with ',updateNumber asString, ' (within +/- 10) was found in the image.You must have changesets going back this far in your imagein order to accurately check for conflicts.Proceed anyway?')			ifTrue: [updateNumberChangeSet := ChangesOrganizer allChangeSets first]].	^ updateNumberChangeSet! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'dgd 4/4/2006 16:42'!maximumUsableArea	| allowedArea |	allowedArea := Display usableArea.	Smalltalk isMorphic ifTrue: [		allowedArea := allowedArea intersect: ActiveWorld visibleClearArea.	].	^allowedArea! !!ImageSegment methodsFor: 'testing' stamp: 'tk 9/7/1999 09:48'!findOwnersOutPtrs| ow ff |ow := Smalltalk at: #Owners ifAbsent: [^ self].ow ifNil: [^ self].outPointers do: [:oo | 	oo isMorph ifTrue: [		ow := ow copyReplaceAll: oo printString with: oo printString, '[<<<- Pointed at]']].ff := FileStream fileNamed: 'Owners log'.ff nextPutAll: ow; close.Smalltalk at: #Owners put: ow.ff edit.! !!Project methodsFor: 'file in/out' stamp: 'tk 6/28/2001 16:16'!writeStackText: stacks in: resourceDirectory registerIn: aCollector	"The user's text is very valuable.  Write an extra file with just the text.  It can be read in case the Project can't be opened." 	"Find allText for each stack, storeOn a local file in the resources folder, with a name like myProj.005.myStack.t.  Make the names be unique."	"get project name and version"	| localName sn trial char ind fs resourceURL textLoc |	resourceURL := self resourceUrl.	stacks do: [:stackObj |	"Construct a good file name"		localName := self versionedFileName allButLast: 2.	"projectName.005."		stacks size = 1 ifFalse: ["must distinguish between stacks in the project"			(sn := stackObj knownName) ifNil: [				sn := stackObj hash printString].	"easy name, or use hash"			localName := localName , sn, FileDirectory dot]. 	"projectName.005.myStack."		localName := localName , 't'.		"See if in use because truncates same as another, fix last char, try again"		[trial := resourceDirectory checkName: localName fixErrors: true.		 trial endsWith: '.t'] whileFalse: [				localName := (localName allButLast: 3) , FileDirectory dot, 't'].		[resourceDirectory fileExists: trial] whileTrue: [			char := trial at: (ind := trial size - 3).			trial at: ind put: (char asciiValue + 1) asCharacter].	"twiddle it a little"				"write allText in file"		fs := resourceDirectory newFileNamed: trial.		fs timeStamp; cr; nextPutAll: '''This is the text for a stack in this project.  Use only in an emergency, if the project file is ever unreadable.''.'; cr; cr.		stackObj getAllText storeOn: fs.    fs close.		textLoc := (ResourceLocator new) localFileName: trial; 			urlString: resourceURL, '/', trial.		aCollector locatorMap at: trial "any distinct object" put: textLoc.		].! !!Project class methodsFor: 'squeaklet on server' stamp: 'ar 10/11/2000 15:42'!parseProjectFileName: aString	"It was formerly possible to have periods in projct names and this messed up some parsing methods. Try to handle that more gracefully and allow for a change in scheme at a later time.	ar 10/11/2000: Switch to a different version encoding scheme. The new scheme is		baseName.NNN.ext	where NNN is at least three digits wide and encodes the version in a human readable form.	Examples:		Project parseProjectFileName: 'My Project.007.pr'.		Project parseProjectFileName: 'My.First.Project.042.prj'.		Project parseProjectFileName: 'My Project.123456.p r o j e c t'.	The 'dot' is determined on FileDirectory>>dot to compensate for platforms wishing to use something different from a period. Also allows parsing the former encoding of file using Base64 encoded versions of the form	Project parseProjectFileName: 'aa.bb.cc|AQ.ss'	"	| suffix baseName version versionAndSuffix index tokens |	"answer an array with: 		1 = basic project name		2 = version string		3 = suffix (pr)"	"First check for the old style versions"	index := aString findLast:[:ch| ch = $|].	index = 0 ifFalse:["Old style version"		baseName := aString copyFrom: 1 to: index-1.		versionAndSuffix := aString copyFrom: index+1 to: aString size.		(versionAndSuffix occurrencesOf: $.) = 0 ifTrue: [^ #('no suffix')].		version := versionAndSuffix copyUpTo: $..		suffix := versionAndSuffix copyFrom: version size+1 to: versionAndSuffix size.		"Decode Base64 encoded version"		version isEmpty			ifTrue:[version := 0]			ifFalse:[version := Base64MimeConverter decodeInteger: version unescapePercents].		^{baseName. version. suffix}].	"New style versions"	tokens := aString findTokens: FileDirectory dot.	tokens size < 2 "Not even a single dot"		ifTrue:[^{aString. 0. ''}].	tokens size < 3 ifTrue:["Only one dot"		self flag: #arNote. "We could allow project file names of the form 'project.001' (e.g., no project extension) or '.001.pr' (without a base name) but I don't think its a good idea."		^{tokens first. 0. tokens last}].	suffix := tokens last.	version := tokens at: tokens size - 1.	(version anySatisfy:[:ch| ch isDigit not]) ifTrue:[		"Non-digit version??? I don't think so..."		baseName := aString copyFrom: 1 to: aString size - suffix size - 1.		^{baseName. 0. suffix}].	baseName := aString copyFrom: 1 to: aString size - suffix size - version size - 2.	version := version asInteger.	^{baseName. version. suffix}! !!Utilities class methodsFor: 'identification' stamp: 'ar 8/23/2001 22:44'!authorName: aString	AuthorName := aString! !!Utilities class methodsFor: 'common requests' stamp: 'sw 2/5/2002 13:17'!initializeCommonRequestStrings	"Initialize the common request strings, a directly-editable list of expressions that can be evaluated from the 'do...' menu."	CommonRequestStrings := StringHolder new contents: 'Utilities emergencyCollapse.Utilities closeAllDebuggers.-Sensor keyboard.ParagraphEditor abandonChangeText.Cursor normal show.-CommandHistory resetAllHistory.Project allInstancesDo: [:p | p displayDepth: 16].ScriptingSystem inspectFormDictionary.Form fromUser bitEdit.Display border: (0@0 extent: 640@480) width: 2.-Undeclared inspect.Undeclared removeUnreferencedKeys; inspect.Transcript clear.Utilities grabScreenAndSaveOnDisk.FrameRateMorph new openInHand.-Utilities reconstructTextWindowsFromFileNamed: ''TW''.Utilities storeTextWindowContentsToFileNamed: ''TW''.ChangeSorter removeEmptyUnnamedChangeSets.ChangeSorter reorderChangeSets.-ActiveWorld installVectorVocabulary.ActiveWorld abandonVocabularyPreference.Smalltalk saveAsNewVersion'"Utilities initializeCommonRequestStrings"! !!SmartRefStream methodsFor: 'read write' stamp: 'yo 1/21/2006 19:27'!readInstanceSize: instSize clsname: className refPosn: refPosn	"The common code to read the contents of an arbitrary instance.	 ASSUMES: readDataFrom:size: sends me beginReference: after it	   instantiates the new object but before reading nested objects.	 NOTE: We must restore the current reference position after	   recursive calls to next.Three cases for files from older versions of the system:1) Class has not changed shape, read it straight.2) Class has changed instance variables (or needs fixup).  Call a particular method to do it.3) There is a new class instead.  Find it, call a particular method to read.	All classes used to construct the structures dictionary *itself* need to be in 'steady' and they must not change!!  See setStream:"	| anObject newName newClass dict oldInstVars isMultiSymbol |	self flag: #bobconv.		self setCurrentReference: refPosn.  "remember pos before readDataFrom:size:"	newName := renamed at: className ifAbsent: [className].	isMultiSymbol := newName = #MultiSymbol or: [newName = #WideSymbol].	"isMultiSymbol ifTrue: [self halt]."	newClass := Smalltalk at: newName asSymbol.	(steady includes: newClass) & (newName == className) ifTrue: [	 	anObject := newClass isVariable "Create it here"			ifFalse: [newClass basicNew]			ifTrue: [newClass basicNew: instSize - (newClass instSize)].		anObject := anObject readDataFrom: self size: instSize.		self setCurrentReference: refPosn.  "before returning to next"		isMultiSymbol ifTrue: [^ Symbol intern: anObject asString].		^ anObject].	oldInstVars := structures at: className ifAbsent: [			self error: 'class is not in structures list'].	"Missing in object file"	anObject := newClass createFrom: self size: instSize version: oldInstVars.		"only create the instance"	self beginReference: anObject.	dict := self catalogValues: oldInstVars size: instSize.		"indexed vars as (1 -> val) etc."	dict at: #ClassName put: className.	"so conversion method can know it"	"Give each superclass a chance to make its changes"	self storeInstVarsIn: anObject from: dict.	"ones with the same names"	anObject := self applyConversionMethodsTo: anObject className: className varMap: dict.	self setCurrentReference: refPosn.  "before returning to next"	isMultiSymbol ifTrue: [^ Symbol intern: anObject asString].	^ anObject! !!SystemNavigation methodsFor: 'query' stamp: 'yo 7/16/2003 15:18'!allGlobalRefsWithout: classesAndMessagesPair 	"Answer a set of symbols that may be refs to Global names. In some  	sense we should only need the associations, but this will also catch, eg,  	HTML tag types. This method computes its result in the absence of  	specified classes and messages."	"may be a problem if namespaces are introduced as for the moment  	only Smalltalk is queried. sd 29/4/03"	| globalRefs absentClasses absentSelectors |	globalRefs := IdentitySet new: CompiledMethod instanceCount.	absentClasses := classesAndMessagesPair first.	absentSelectors := classesAndMessagesPair second.	self flag: #shouldBeRewrittenUsingSmalltalkAllClassesDo:.	"sd 29/04/03"	Cursor execute		showWhile: [Smalltalk classNames				do: [:cName | ((absentClasses includes: cName)						ifTrue: [{}]						ifFalse: [{Smalltalk at: cName. (Smalltalk at: cName) class}])						do: [:cl | (absentSelectors isEmpty								ifTrue: [cl selectors]								ifFalse: [cl selectors copyWithoutAll: absentSelectors])								do: [:sel | "Include all capitalized symbols for good 									measure"									(cl compiledMethodAt: sel) literals										do: [:m | 											((m isSymbol)													and: [m size > 0															and: [m first canBeGlobalVarInitial]])												ifTrue: [globalRefs add: m].											(m isMemberOf: Array)												ifTrue: [m														do: [:x | ((x isSymbol)																	and: [x size > 0																			and: [x first canBeGlobalVarInitial]])																ifTrue: [globalRefs add: x]]].											m isVariableBinding												ifTrue: [m key														ifNotNil: [globalRefs add: m key]]]]]]].	^ globalRefs! !!ImageSegment methodsFor: 'read/write segment' stamp: 'mdr 8/31/2000 19:01'!readFromFile	"Read in a simple segment.  Use folder of this image, even if remembered as previous location of this image"	| ff realName |	realName := self class folder, FileDirectory slash, self localName.	ff := FileStream readOnlyFileNamed: realName.	segment := ff nextWordsInto: (WordArrayForSegment new: ff size//4).	endMarker := segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker := 'End' clone].	ff close.	state := #active! !!Utilities class methodsFor: 'miscellaneous' stamp: 'RAA 5/28/2001 10:02'!setClassAndSelectorFrom: messageIDString in: csBlock	"Decode strings of the form <className> [class] <selectorName>.   If <className> does not exist as a class, use nil for the class in the block"	| aStream aClass maybeClass sel |	(messageIDString isKindOf: MethodReference) ifTrue: [		^messageIDString setClassAndSelectorIn: csBlock	].	aStream := ReadStream on: messageIDString.	aClass := Smalltalk at: (aStream upTo: $ ) asSymbol ifAbsent: [nil].	maybeClass := aStream upTo: $ .	sel := aStream upTo: $ .	((maybeClass = 'class') & (sel size ~= 0))		ifTrue:			[aClass				ifNil:					[csBlock value: nil value: sel asSymbol]				ifNotNil:					[csBlock value: aClass class value: sel asSymbol]]		ifFalse:			[csBlock value: aClass value: maybeClass asSymbol]"Utilities setClassAndSelectorFrom: 'Utilities class oppositeModeTo:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString].Utilities setClassAndSelectorFrom: 'MessageSet setClassAndSelectorIn:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString]."! !!Project methodsFor: 'accessing' stamp: 'jla 5/28/2001 20:01'!nameAdjustedForDepth	"Answer the name of the project, prepended with spaces reflecting the receiver's depth from the top project"	"	Project current nameAdjustedForDepth	"	| stream |	stream := WriteStream on: String new.	self depth timesRepeat: 	  [2 timesRepeat: [stream nextPut: $ ]].	stream nextPutAll: self name.	^ stream contents! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:11'!initialize	firstLevel := Dictionary new.! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'md 7/30/2005 14:12'!signatureToString: aSignature	"Answer a string representation of the given signature. This string can be parsed using the stringToSignature: method."	| s |	s := WriteStream on: (String new: 2000).	s nextPutAll: '[DSA digital signature '.	s nextPutAll: aSignature first printStringHex.	s space.	s nextPutAll: aSignature second printStringHex.	s nextPutAll: ']'.	^ s contents! !!Preferences class methodsFor: 'parameters' stamp: 'sw 9/7/1999 12:45'!initializeParameters	"Preferences initializeParameters"	Parameters := IdentityDictionary new.	self restoreDefaultMenuParameters.	Parameters at: #maxBalloonHelpLineLength put: 28.	self initializeTextHighlightingParameters! !!DataStream methodsFor: 'write and read' stamp: 'jm 8/19/1998 17:00'!readByteArray	"PRIVATE -- Read the contents of a ByteArray."	| count |	count := byteStream nextNumber: 4.	^ byteStream next: count  "assume stream is in binary mode"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 11/30/1999 22:30'!extract	"This operation replaces (using become:) all the original roots of a segment with segmentRootStubs.  Thus the original objects will be reclaimed, and the root stubs will remain to bring the segment back in if it is needed."	Cursor write showWhile: [		state = #inactive ifTrue: [self copyFromRoots: arrayOfRoots sizeHint: 0].		state = #activeCopy ifFalse: [self errorWrongState].		arrayOfRoots elementsForwardIdentityTo:			(arrayOfRoots collect: [:r | r rootStubInImageSegment: self]).		state := #active].! !!PseudoClass methodsFor: 'methods' stamp: 'sma 6/1/2000 14:54'!addMethodChange: aChangeRecord	| selector |	selector := self parserClass new parseSelector: aChangeRecord string.	self organization classify: selector under: aChangeRecord category.	self sourceCodeAt: selector put: aChangeRecord! !!SystemNavigation methodsFor: 'query' stamp: 'nb 5/6/2003 16:57'!allClassesImplementing: aSelector  	"Answer an Array of all classes that implement the message aSelector."	| aCollection |	aCollection := ReadWriteStream on: Array new.	self allBehaviorsDo:		[:class | (class includesSelector: aSelector)			ifTrue: [aCollection nextPut: class]].	^ aCollection contents! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 3/3/2001 08:31'!cleanUpUndoCommands	"Smalltalk cleanUpUndoCommands"  "<== print this to get classes involved"	| classes i p |	classes := Bag new.	'Ferreting out obsolete undo commands'		displayProgressAt: Sensor cursorPoint		from: 0 to: Morph withAllSubclasses size		during:	[:bar | i := 0.	Morph withAllSubclassesDo:		[:c | bar value: (i := i+1).		c allInstancesDo:			[:m | (p := m otherProperties) ifNotNil:				[p keys do:					[:k | (p at: k) class == Command ifTrue:						[classes add: c name.						m removeProperty: k]]]]]].	^ classes! !!ChangeSet methodsFor: 'isolation layers' stamp: 'di 3/29/2000 13:59'!isolationSet: setOrNil	setOrNil == self		ifTrue: [isolationSet := nil]  "Means this IS the isolation set"		ifFalse: [isolationSet := setOrNil]! !!Project methodsFor: 'accessing' stamp: 'jla 5/28/2001 21:50'!children	"Answer a list of all the subprojects of the receiver"		| children |	children := OrderedCollection new.	Project allProjects do: [ :p | 		(self == p parent and: [self ~~ p]) ifTrue:			[ children add: p ]].	^ children"Project topProject children"! !!Project class methodsFor: 'utilities' stamp: 'dgd 11/6/2004 21:29'!jumpToProject	"Project jumpToProject"	"Present a list of potential projects and enter the one selected."	| menu |menu:=MenuMorph new.menu defaultTarget: self.	menu := self buildJumpToMenu: menu.	menu popUpInWorld! !!Utilities class methodsFor: 'fetching updates' stamp: 'mir 6/26/2001 12:08'!broadcastUpdatesFrom: n1 to: n2 except: skipList"	Note:  This method takes its list of files from the directory named 'updates',	which will have been created and filled by, eg,		Utilities readServerUpdatesSaveLocally: true updateImage: true.	These can then be rebroadcast to any server using, eg,		Utilities broadcastUpdatesFrom: 1 to: 9999 except: #(223 224).	If the files are already on the server, and it is only a matter	of copying them to the index for a different version, then use...		(ServerDirectory serverInGroupNamed: 'SqC Internal Updates*')			exportUpdatesExcept: #()."	| fileNames fileNamesInOrder names choice file updateDirectory |	updateDirectory := FileDirectory default directoryNamed: 'updates'.	fileNames := updateDirectory fileNames select:		[:n | n first isDigit			and: [(n initialIntegerOrNil between: n1 and: n2)			and: [(skipList includes: n initialIntegerOrNil) not]]].	(file := fileNames select: [:n | (n occurrencesOf: $.) > 1]) size > 0		ifTrue: [self halt: file first , ' has multiple periods'].	fileNamesInOrder := fileNames asSortedCollection:		[:a :b | a initialIntegerOrNil < b initialIntegerOrNil].	names := ServerDirectory groupNames asSortedArray.	choice := (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory serverInGroupNamed: choice)		putUpdateMulti: fileNamesInOrder fromDirectory: updateDirectory! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 11:06'!convert1: misShapenInst to: goodClass allVarMaps: allVarMaps	"Go through the normal instance conversion process and return a modern object."	| className oldInstVars anObject varMap |	self flag: #bobconv.		goodClass isVariable ifTrue: [		goodClass error: 'shape change for variable class not implemented yet'	].	(misShapenInst class name beginsWith: 'Fake37') ifFalse: [self error: 'why mapping?'].	className := (misShapenInst class name allButFirst: 6) asSymbol.	oldInstVars := structures at: className.	anObject := goodClass basicNew.	varMap := Dictionary new.	"later, indexed vars as (1 -> val) etc."	2 to: oldInstVars size do: [:ind |		varMap at: (oldInstVars at: ind) put: (misShapenInst instVarAt: ind-1)].	varMap at: #ClassName put: className.	"original"	varMap at: #NewClassName put: goodClass name.	"new"	self storeInstVarsIn: anObject from: varMap. 	"ones with the same names"	allVarMaps at: misShapenInst put: varMap.	^ anObject! !!SmartRefStream methodsFor: 'class changed shape' stamp: 'tk 1/7/97'!catalogValues: instVarList size: varsOnDisk	"Create a dictionary of (name -> value) for the inst vars of this reshaped object.  Indexed vars as (1 -> val) etc.  "	| dict sz |	dict := Dictionary new.	2 to: instVarList size do: [:ind |		dict at: (instVarList at: ind) put: self next].	sz := varsOnDisk - (instVarList size - 1).	1 to: sz do: [:ii | 		dict at: ii put: self next].	"Total number read MUST be equal to varsOnDisk!!"	sz > 0 ifTrue: [dict at: #SizeOfVariablePart put: sz].	^ dict! !!ChangeSet methodsFor: 'moving changes' stamp: 'nk 7/2/2003 10:47'!methodsWithInitialsOtherThan: myInits	"Return a collection of method refs whose author appears to be different from the given one"	| slips method aTimeStamp |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method := aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[((aTimeStamp := Utilities timeStampForMethod: method) notNil and:							[(aTimeStamp beginsWith: myInits) not])								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithInitialsOtherThan: 'sw') name: 'authoring problems'"! !!ImageSegment class methodsFor: 'fileIn/Out' stamp: 'rbb 2/18/2005 13:25'!startUp	| choice |	"Minimal thing to assure that a .segs folder is present"(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [	(FileDirectory default includesKey: (FileDirectory localNameFor: self folder)) 		ifFalse: [			choice := UIManager default 				chooseFrom: #('Create folder' 'Quit without saving')				title: 					'The folder with segments for this image is missing.\' withCRs,					self folder, '\If you have moved or renamed the image file,\' withCRs,					'please Quit and rename the segments folder in the same way'.			choice = 1 ifTrue: [FileDirectory default createDirectory: self folder].			choice = 2 ifTrue: [SmalltalkImage current snapshot: false andQuit: true]]]	! !!SystemDictionary methodsFor: 'shrinking' stamp: 'edc 11/8/2005 10:11'!unusedClassesAndMethodsWithout: classesAndMessagesPair 	"Accepts and returns a pair: {set of class names. set of selectors}. 	It is expected these results will be diff'd with the normally unused 	results. "	| classRemovals messageRemovals nClasses nMessages |	(classRemovals := IdentitySet new) addAll: classesAndMessagesPair first.	(messageRemovals := IdentitySet new) addAll: classesAndMessagesPair second.	nClasses := nMessages := -1.	["As long as we keep making progress..."	classRemovals size > nClasses		or: [messageRemovals size > nMessages]]		whileTrue: ["...keep trying for bigger sets of unused classes and selectors."			nClasses := classRemovals size.			nMessages := messageRemovals size.			Utilities				informUser: 'Iterating removals '						, (classesAndMessagesPair first isEmpty								ifTrue: ['for baseline...']								ifFalse: ['for ' , classesAndMessagesPair first first , ' etc...']) , Character cr asString , nClasses printString , ' classes, ' , nMessages printString , ' messages.||'				during: ["spacers move menu off cursor"					classRemovals						addAll: (self systemNavigation allUnusedClassesWithout: {classRemovals. messageRemovals}).					messageRemovals						addAll: (self systemNavigation allUnSentMessagesWithout: {classRemovals. messageRemovals})]].	^ {classRemovals. self systemNavigation allUnSentMessagesWithout: {classRemovals. messageRemovals}}! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'raa 5/30/2000 15:46'!generateSandQ	"Generate a 160-bit random seed s and an industrial grade prime q."	| hasher s sPlusOne u q |	hasher := SecureHashAlgorithm new.	[true] whileTrue: [		s := self nextRandom160.		sPlusOne := s + 1.		sPlusOne highBit > 160 ifTrue: [sPlusOne := sPlusOne \\ (2 raisedTo: 160)].		u := (hasher hashInteger: s) bitXor: (hasher hashInteger: sPlusOne).		q := u bitOr: ((1 bitShift: 159) bitOr: 1).		(self isProbablyPrime: q) ifTrue: [^ Array with: s with: q]].! !!CodeLoader methodsFor: 'loading' stamp: 'mir 10/13/2000 12:24'!loadSegments: anArray	"Load all the source files in the given array."	| loader request reqName |	loader := HTTPLoader default.	segments := anArray collect:[:name |		reqName := (FileDirectory extensionFor: name) isEmpty			ifTrue: [FileDirectory fileName: name extension: ImageSegment compressedFileExtension]			ifFalse: [name].		request := self createRequestFor: reqName in: loader.		name->request].! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 2/2/2001 14:56'!loadCodeSegment: segmentName	| loader |	loader := self new.	loader loadSegments: (Array with: segmentName). 	loader installSegments.! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/23/1999 08:20'!text	| text |	^ file ifNil: ['']		ifNotNil: [			file openReadOnly.			file position: position.			text := file nextChunkText.			file close.			text]! !!SARInstaller methodsFor: 'client services' stamp: 'yo 8/17/2004 10:01'!fileInMemberNamed: csName	"This is to be used from preamble/postscript code to file in zip members as ChangeSets."	| cs |	cs := self memberNamed: csName.	cs ifNil: [ ^self errorNoSuchMember: csName ].	self class fileIntoChangeSetNamed: csName fromStream: cs contentStream text setConverterForCode.	self installed: cs.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ar 4/10/2005 22:19'!smartFillRoots: dummy	| refs known ours ww blockers |	"Put all traced objects into my arrayOfRoots.  Remove somethat want to be in outPointers.  Return blockers, anIdentityDictionary of objects to replace in outPointers."	blockers := dummy blockers.	known := (refs := dummy references) size.	refs fasterKeys do: [:obj | "copy keys to be OK with removing items"		(obj isSymbol) ifTrue: [refs removeKey: obj.known := known-1].		(obj class == PasteUpMorph) ifTrue: [			obj isWorldMorph & (obj owner == nil) ifTrue: [				obj == dummy project world ifFalse: [					refs removeKey: obj.  known := known-1.					blockers at: obj put:						(StringMorphcontents: 'The worldMorph of a different world')]]].					"Make a ProjectViewMorph here"		"obj class == Project ifTrue: [Transcript show: obj; cr]."		(blockers includesKey: obj) ifTrue: [			refs removeKey: obj ifAbsent: [known :=known+1].  known := known-1].		].	ours := dummy project world.	refs keysDo: [:obj |			obj isMorph ifTrue: [				ww := obj world.				(ww == ours) | (ww == nil) ifFalse: [					refs removeKey: obj.  known := known-1.					blockers at: obj put:(StringMorph contents:								objprintString, ' from another world')]]].	"keep original roots on the front of the list"	(dummy rootObject) do: [:rr | refs removeKey: rr ifAbsent: []].	^ dummy rootObject, refs fasterKeys asArray.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'dao 10/1/2004 13:30'!zapMVCprojects	"Smalltalk zapMVCprojects"	| window |	self flag: #bob. "zapping projects"	Smalltalk garbageCollect.	"So allInstances is precise"	Project		allSubInstancesDo: [:proj | proj isTopProject				ifTrue: [proj isMorphic						ifFalse: ["Root project is MVC -- we must become the root"							Project current setParent: Project current.]]				ifFalse: [proj parent isMorphic						ifFalse: [proj isMorphic								ifTrue: ["Remove Morphic projects from MVC 									views "									"... and add them back here."									window := (SystemWindow labelled: proj name)												model: proj.									window										addMorph: (ProjectViewMorph on: proj)										frame: (0 @ 0 corner: 1.0 @ 1.0).									window openInWorld.									proj setParent: Project current]].					proj isMorphic						ifFalse: ["Remove MVC projects from Morphic views"							Project deletingProject: proj]]]! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'al 7/18/2004 18:45'!traitsOrder: aCollection 	"Answer an OrderedCollection. The traits 	are ordered so they can be filed in."	|  traits |	traits := aCollection asSortedCollection: [:t1 :t2 |		(t1 isBaseTrait and: [t1 classTrait == t2]) or: [			(t2 traitComposition allTraits includes: t1) or: [				(t1 traitComposition allTraits includes: t2) not]]].	^traits asArray! !!ImageSegment methodsFor: 'testing' stamp: 'tk 11/30/1999 22:30'!findRogueRootsImSeg: rootArray	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) Break all owner pointers in submorphs and all scripts.2) Create the segment and look at outPointers.3) Remove those we expect.4) Remember to quit without saving -- the owner pointers are smashed."| newRoots suspects bag1 bag2 |arrayOfRoots := rootArray.[(newRoots := self rootsIncludingPlayers) == nil] whileFalse: [	arrayOfRoots := newRoots].		"world, presenter, and all Player classes"self findRogueRootsPrep.	"and free that context!!"Smalltalk forgetDoIts.Smalltalk garbageCollect.self copyFromRoots: arrayOfRoots sizeHint: 0.suspects := outPointers select: [:oo | oo isMorph].suspects size > 0 ifTrue: [suspects inspect].bag1 := Bag new.  bag2 := Bag new.outPointers do: [:key | 	(key isKindOf: Class) 		ifTrue: [bag2 add: key class name]		ifFalse: [(#(Symbol Point Rectangle True False String Float Color Form ColorForm StrikeFont Metaclass UndefinedObject TranslucentColor) includes: key class name)			ifTrue: [bag2 add: key class name]			ifFalse: [bag1 add: key class name]]]."(bag sortedCounts) is the SortedCollection"(StringHolder new contents: bag1 sortedCounts printString, '', bag2 sortedCounts printString) 	openLabel: 'Objects pointed at by the outside'.self halt: 'Examine local variables pointIn and inSeg'."Use this in inspectors:	outPointers select: [:oo | oo class == <a Class>].		"! !!HTTPLoader methodsFor: 'requests' stamp: 'nk 8/30/2004 07:50'!retrieveObjectsFor: aURL	"Load a remote image segment and extract the root objects.	Check if the remote file is a zip archive."	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.extSeg' 		asUrl loadRemoteObjects" 	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.zip' 		asUrl loadRemoteObjects" 	| stream info data | 	data := self retrieveContentsFor: aURL.	(data isString)		ifTrue: [^self error: data]		ifFalse: [data := data content].	(data beginsWith: 'error')		ifTrue: [^self error: data].	data := data unzipped.	stream := RWBinaryOrTextStream on: data.	stream reset.	info := stream fileInObjectAndCode.	stream close.	^info originalRoots! !!CachingCodeLoader methodsFor: 'accessing' stamp: 'mir 12/22/1999 14:10'!localCache: stringArray	| fd |	fd := FileDirectory default.	stringArray do:[:part|		(fd directoryNames includes: part) 			ifFalse:[fd createDirectory: part].		fd := fd directoryNamed: part].	self cacheDir: (fd pathName copyWith: fd pathNameDelimiter).! !!Project class methodsFor: 'squeaklet on server' stamp: 'nb 6/17/2003 12:25'!enterIfThereOrFind: aProjectName	| newProject |	newProject := Project named: aProjectName.	newProject ifNotNil: [^newProject enter].	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			[				newProject := CurrentProject fromMyServerLoad: aProjectName			] 				on: ProjectViewOpenNotification				do: [ :ex | ex resume: false]							"we probably don't want a project view morph in this case"		].	newProject ifNotNil: [^newProject enter].	Beeper beep.! !!MessageTally methodsFor: 'comparing' stamp: ''!sonsOver: threshold	| hereTally last sons |	(receivers == nil or: [receivers size = 0]) ifTrue: [^#()].	hereTally := tally.	sons := receivers select:  "subtract subNode tallies for primitive hits here"		[:son |		hereTally := hereTally - son tally.		son tally > threshold].	hereTally > threshold		ifTrue: 			[last := MessageTally new class: class method: method.			^sons copyWith: (last primitives: hereTally)].	^sons! !!ProjectLoading class methodsFor: 'utilities' stamp: 'gk 10/21/2005 11:18'!bestAccessToFileName: aFileName andDirectory: aDirectoryOrUrlString	"Answer an array with a stream and a directory. The directory can be nil."		| dir url |	dir := Project squeakletDirectory.	(dir fileExists: aFileName) ifTrue: [		^{dir readOnlyFileNamed: aFileName. dir}].	aDirectoryOrUrlString isString ifFalse: [		^{aDirectoryOrUrlString readOnlyFileNamed: aFileName. aDirectoryOrUrlString}].	url := Url absoluteFromFileNameOrUrlString: aDirectoryOrUrlString.	(url scheme = 'file') ifTrue: [		dir := FileDirectory on: url pathForDirectory.		^{dir readOnlyFileNamed: aFileName. dir}].	(url path anySatisfy: [:each | each = 'SuperSwikiProj']) ifTrue: [		dir := SuperSwikiServer new fullPath: url directoryUrl asString.		^{dir readOnlyFileNamed: url fileName. nil}].	^{ServerFile new fullPath: aDirectoryOrUrlString. nil}! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:27'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"	| ps s2 date author line intName |	^ String streamContents:		[:s |		intName := self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps := self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 := ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date := s2 upTo: Character cr.			s2 match: 'Author:'; skipSeparators.  author := s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line := s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!Project methodsFor: 'isolation layers' stamp: 'di 3/29/2000 16:06'!revoke	"Take back all methods changed here.	Install the original method dictionaries and organizations.	The orignal method versions will now be the ones used."	isolatedHead ifFalse: [^ self error: 'This isnt an isolation layer.'].	inForce ifFalse: [^ self error: 'This layer should have been in force.'].	changeSet revoke.		inForce := false.! !!SystemVersion class methodsFor: 'accessing' stamp: 'mir 8/10/2001 11:52'!parseVersionString: versionString	"Answer the version of this release as version, date, update."	"SystemVersion parseVersionString: 'Squeak3.1alpha of 28 February 2001 [latest update: #3966]' "	| stream version date update |	[stream := ReadStream on: versionString.	version := stream upToAll: ' of '.	date := Date readFrom: stream.	stream upToAll: ' #'.	update := Number readFrom: stream]		on: Error		do: [^nil].	^{version. date. update.}! !!AutoStart class methodsFor: 'class initialization' stamp: 'mir 7/28/1999 17:44'!deinstall	"AutoStart deinstall"	Smalltalk removeFromStartUpList: AutoStart.	InstalledLaunchers := nil! !!ImageSegment methodsFor: 'instance change shape' stamp: 'tk 1/25/2000 21:54'!allInstancesOf: aClass do: aBlock	| withSymbols oldInstances segSize |	"Bring me in, locate instances of aClass and submit them to the block.  Write me out again."	(state = #onFile or: [state = #onFileWithSymbols]) ifFalse: [^ self].	withSymbols := state = #onFileWithSymbols.	(outPointers includes: aClass) ifFalse: [^ self].		"If has instances, they point out at the class"	state = #onFile ifTrue: [Cursor read showWhile: [self readFromFile]].	segSize := segment size.	self install.	oldInstances := OrderedCollection new.	self allObjectsDo: [:obj | obj class == aClass ifTrue: [		oldInstances add: obj]].	oldInstances do: [:inst | aBlock value: inst].	"do the work"	self copyFromRoots: arrayOfRoots sizeHint: segSize.	self extract.	withSymbols 		ifTrue: [self writeToFileWithSymbols]		ifFalse: [self writeToFile].! !!ImageSegment methodsFor: 'read/write segment' stamp: 'tk 10/8/1999 12:23'!writeToFileWithSymbols: shortName	segmentName := (shortName endsWith: '.seg')		ifTrue: [shortName copyFrom: 1 to: shortName size - 4]		ifFalse: [shortName].	segmentName last isDigit ifTrue: [segmentName := segmentName, '-'].	self writeToFileWithSymbols.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'jm 12/21/1999 19:38'!initializeTotalsArray	"Initialize the totals array from the registers for use with the primitives."	totals := Bitmap new: 5.	totals at: 1 put: totalA asInteger.	totals at: 2 put: totalB asInteger.	totals at: 3 put: totalC asInteger.	totals at: 4 put: totalD asInteger.	totals at: 5 put: totalE asInteger.! !!ImageSegmentRootStub methodsFor: 'fetch from disk' stamp: 'di 3/27/1999 12:19'!xxSuperclass: superclass format: format segment: segment	"Set up fields like a class but with null methodDict"	shadowSuper := superclass.	shadowMethodDict := nil.	shadowFormat := format.	imageSegment := segment.! !!Project methodsFor: 'file in/out' stamp: 'RAA 10/26/2000 16:58'!objectForDataStream: refStrm	| uu dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	"Use a copy with no parent, previous or next to reduce extra stuff copied"	refStrm project == self ifTrue: [^ self copy setParent: nil].	dp := (uu := self url) size > 0 ifTrue: [		DiskProxy global: #Project selector: #namedUrl: args: {uu}.	] ifFalse: [		DiskProxy global: #Project selector: #named: args: {self name}	].	refStrm replace: self with: dp.	^ dp! !!ResourceLocator methodsFor: 'accessing' stamp: 'ar 2/27/2001 20:01'!localFileName: aString	localFileName := aString! !!CodeLoader class methodsFor: 'accessing' stamp: 'mir 1/10/2000 18:16'!defaultKey: aPublicKey	"Store the default key used for verifying signatures of loaded code"	DefaultKey := aPublicKey	"CodeLoader defaultKey: DOLPublicKey"	"CodeLoader defaultKey: (DigitalSignatureAlgorithm testKeySet at: 2)"! !!ChangeSet class methodsFor: 'services' stamp: 'ar 7/15/2005 21:30'!assuredChangeSetNamed: aName	"Answer a change set of the given name.  If one already exists, answer that, else create a new one and answer it."	| existing |	^ (existing := self named: aName)		ifNotNil:			[existing]		ifNil:			[self basicNewChangeSet: aName]! !!ChangeSet methodsFor: 'private' stamp: 'yo 8/30/2002 13:59'!changeRecorderFor: class	| cname |	(class isString)		ifTrue: [ cname := class ]		ifFalse: [ cname := class name ].	"Later this will init the changeRecords so according to whether they should be revertable."	^ changeRecords at: cname			ifAbsent: [^ changeRecords at: cname							put: (ClassChangeRecord new initFor: cname revertable: revertable)]! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'jm 12/13/1999 16:36'!generateRandomLength: bitLength s: s n: n	"Answer a random number of bitLength bits generated using the secure hash algorithm."	| sha out count extraBits v |	sha := SecureHashAlgorithm new.	out := 0.	count := (bitLength // 160).	extraBits := bitLength - (count * 160).	0 to: count do: [:k |		v := sha hashInteger: (s + n + k).		k = count ifTrue: [			v := v - ((v >> extraBits) << extraBits)].		out := out bitOr: (v bitShift: (160 * k))].	^ out! !!CodeLoader methodsFor: 'installing' stamp: 'sd 1/30/2004 15:16'!installSourceFile: aStream	"Install the previously loaded source file"	| contents trusted |	aStream ifNil:[^self error:'No content to install'].	trusted := SecurityManager default positionToSecureContentsOf: aStream.	trusted ifFalse:[(SecurityManager default enterRestrictedMode) 					ifFalse:[ aStream close.							^ self error:'Insecure content encountered']].	contents := aStream ascii upToEnd unzipped.	(aStream respondsTo: #close) ifTrue:[aStream close].	^(RWBinaryOrTextStream with: contents) reset fileIn! !!Project class methodsFor: 'utilities' stamp: 'dtl 4/3/2005 16:27'!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label."	| preemptedProcess projectProcess suspendingList |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	ActiveHand ifNotNil:[ActiveHand interrupted].	ActiveWorld := World. "reinstall active globals"	ActiveHand := World primaryHand.	ActiveHand interrupted. "make sure this one's interrupted too"	ActiveEvent := nil.	projectProcess := self uiProcess.	"we still need the accessor for a while"	preemptedProcess := theInterruptedProcess ifNil: [Processor preemptedProcess].	"Only debug preempted process if its priority is >= projectProcess' priority"	preemptedProcess priority < projectProcess priority ifTrue:[		(suspendingList := projectProcess suspendingList) == nil			ifTrue: [projectProcess == Processor activeProcess						ifTrue: [projectProcess suspend]]			ifFalse: [suspendingList remove: projectProcess ifAbsent: [].					projectProcess offList].		preemptedProcess := projectProcess.	] ifFalse:[		preemptedProcess suspend offList.	].	Debugger openInterrupt: labelString onProcess: preemptedProcess! !!Project methodsFor: 'file in/out' stamp: 'mir 6/7/2001 14:39'!primaryServerIfNil: aBlock	"Return my primary server, that is the one I was downloaded from or are about to be stored on. If none is set execute the exception block"	| serverList | 	serverList := self serverList.	^serverList isEmptyOrNil		ifTrue: [aBlock value]		ifFalse: [serverList first]! !!Project methodsFor: 'initialization' stamp: 'di 4/6/2001 10:30'!initialize	"Initialize the project, seting the CurrentProject as my parentProject and initializing my project preferences from those of the CurrentProject"	changeSet := ChangeSet new.	transcript := TranscriptStream new.	displayDepth := Display depth.	parentProject := CurrentProject.	isolatedHead := false.	self initializeProjectPreferences! !!Project methodsFor: 'initialization' stamp: 'di 4/14/1999 13:55'!initialProject	self saveState.	parentProject := self.	previousProject := nextProject := nil! !!Preferences class methodsFor: 'fonts' stamp: 'sw 4/17/2001 11:34'!setSystemFontTo: aFont	"Establish the default text font and style"	| aStyle newDefaultStyle |	aFont ifNil: [^ self].	aStyle := aFont textStyle ifNil: [^ self].	newDefaultStyle := aStyle copy.	newDefaultStyle defaultFontIndex: (aStyle fontIndexOf: aFont).	TextConstants at: #DefaultTextStyle put: newDefaultStyle.	Flaps replaceToolsFlap.	ScriptingSystem resetStandardPartsBin! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:15'!checkForAlienAuthorship	"Check to see if there are any methods in the receiver that have author initials other than that of the current author, and open a browser on all found"	| aList initials |	(initials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	(aList := self methodsWithInitialsOtherThan: initials) size > 0		ifFalse:			[^ self inform: 'All methods in "', self name, '"have authoring stamps which start with "', initials, '"']		ifTrue:			[self systemNavigation  browseMessageList: aList name: 'methods in "', self name, '" whose authoring stamps do not start with "', initials, '"']! !!ProjectLoading class methodsFor: 'loading' stamp: 'RAA 2/20/2001 20:25'!openFromDirectory: aDirectory andFileName: aFileName	| fileAndDir |	ComplexProgressIndicator new 		targetMorph: nil;		historyCategory: 'project loading';		withProgressDo: [			ProgressNotification signal: '1:foundMostRecent'.			fileAndDir := self bestAccessToFileName: aFileName andDirectory: aDirectory.			self 				openName: aFileName 				stream: fileAndDir first 				fromDirectory: fileAndDir second				withProjectView: nil.		]! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 6/23/1998 11:00'!nextPutObjOnly: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  Not in fileOut format.  No class definitions will be written for instance-specific classes.  Error if find one.  (Use nextPut: instead)"	| info |	topCall == nil 		ifTrue:			[topCall := anObject.			super nextPut: ReferenceStream versionCode.			'Please wait while objects are counted' displayProgressAt: Sensor cursorPoint				from: 0 to: 10				during: [:bar |					info := self instVarInfo: anObject].			self uniClasesDo: [:cls | cls error: 'Class defn not written out.  Proceed?'].			'Writing an object file' displayProgressAt: Sensor cursorPoint				from: 0 to: objCount*4	"estimate"				during: [:bar |					objCount := 0.					progressBar := bar.					super nextPut: info.					super nextPut: anObject.	"<- the real writing"					"Class inst vars not written here!!"].			"references is an IDict of every object that got written			(in case you want to take statistics)"			"Transcript cr; show: structures keys printString."		"debug"			topCall := progressBar := nil]	"reset it"		ifFalse:			[super nextPut: anObject.			progressBar ifNotNil: [progressBar value: (objCount := objCount + 1)]].! !!SARInstaller methodsFor: 'initialization' stamp: 'nk 7/5/2003 22:24'!initialize	installed := OrderedCollection new.! !!FileServices class methodsFor: 'accessing' stamp: 'ar 7/16/2005 17:00'!itemsForDirectory: aFileDirectory	"Answer a list of services appropriate when no file is selected."	| services |	services := OrderedCollection new.	self registeredFileReaderClasses do: [:reader |		reader ifNotNil: [services addAll: (reader fileReaderServicesForDirectory: aFileDirectory) ]].	^ services! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sd 11/16/2003 12:55'!internalizeSources    		"Smalltalk internalizeSources"	"Bring the sources and changes files into memory-resident filestreams, for faster access and freedom from file-system interface.  1/29/96 sw"	| reply aName aFile |	reply := self confirm:  'CAUTION -- do not undertake this lightly!!If you have backed up your system andare prepared to face the consequences ofthe requested internalization of sources,hit Yes.  If you have any doubts, hit Noto back out with no harm done.'.	(reply ==  true) ifFalse:		[^ self inform: 'Okay - abandoned'].	aName := SmalltalkImage current sourcesName.	(aFile := SourceFiles first) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile := FileStream readOnlyFileNamed: aName].	SourceFiles at: 1 put: (ReadWriteStream with: aFile contentsOfEntireFile).	aName := SmalltalkImage current changesName.	(aFile := SourceFiles last) == nil ifTrue:		[(FileDirectory default fileExists: aName)			ifFalse: [^ self halt: 'Cannot locate ', aName, ' so cannot proceed.'].		aFile := FileStream readOnlyFileNamed: aName].	SourceFiles at: 2 put: (ReadWriteStream with: aFile contentsOfEntireFile).	self inform: 'Okay, sources internalized'! !!DataStream methodsFor: 'write and read' stamp: ' 6/9/97'!readRectangle    "Read a compact Rectangle.  Rectangles with values outside +/- 2047 were stored as normal objects (type=9).  They will not come here.  17:22 tk"	"Encoding is four 12-bit signed numbers.  48 bits in next 6 bytes.  17:24 tk"	| acc left top right bottom |	acc := byteStream nextNumber: 3.	left := acc bitShift: -12.	(left bitAnd: 16r800) ~= 0 ifTrue: [left := left - 16r1000].	"sign"	top := acc bitAnd: 16rFFF.	(top bitAnd: 16r800) ~= 0 ifTrue: [top := top - 16r1000].	"sign"	acc := byteStream nextNumber: 3.	right := acc bitShift: -12.	(right bitAnd: 16r800) ~= 0 ifTrue: [right := right - 16r1000].	"sign"	bottom := acc bitAnd: 16rFFF.	(bottom bitAnd: 16r800) ~= 0 ifTrue: [bottom := bottom - 16r1000].	"sign"	    ^ Rectangle left: left right: right top: top bottom: bottom! !!Utilities class methodsFor: 'class initialization' stamp: 'asm 4/11/2003 12:11'!initialize	"Initialize the class variables.  5/16/96 sw"	self initializeCommonRequestStrings.	RecentSubmissions := OrderedCollection new.	self registerInFlapsRegistry.	! !!SecurityManager methodsFor: 'private' stamp: 'ar 5/8/2001 16:41'!generateKeyPairInBackground	"SecurityManager default generateKeyPairInBackground"	"Silently generate a key set on the local machine while running in the background."	| guesstimate startTime |	guesstimate := [10 benchmark] timeToRun * 150.	startTime := Time millisecondClockValue.	privateKeyPair := nil.	[self generateLocalKeyPair] fork.	Utilities informUserDuring:[:bar|		[privateKeyPair == nil] whileTrue:[			bar value:'Initializing Squeak security system (', (Time millisecondClockValue - startTime * 100 // guesstimate) printString,'%)'.			(Delay forSeconds: 1) wait.		].	].! !!SmartRefStream methodsFor: 'read write' stamp: 'ar 7/25/2005 21:30'!readWordLike	| refPosn newClass anObject className |	"Can be used by any class that is bits and not bytes (WordArray, Bitmap, SoundBuffer, etc)."	refPosn := self getCurrentReference.	className := self next asSymbol.	className := renamed at: className ifAbsent: [className].	newClass := Smalltalk at: className.	anObject := newClass newFromStream: byteStream.	"Size is number of long words."	self setCurrentReference: refPosn.  "before returning to next"	^ anObject! !!Project methodsFor: 'displaying' stamp: 'ar 5/28/2000 19:43'!displayZoom: entering	"Show the project transition when entering a new project"	| newDisplay vanishingPoint |	"Play the flash transition if any."	self projectParameters at: #flashTransition ifPresent:[:dict|		dict at: CurrentProject ifPresent:[:player| ^player playProjectTransitionFrom: CurrentProject to: self entering: entering]].	"Show animated zoom to new display"	newDisplay := self imageForm.	entering		ifTrue: [vanishingPoint := Sensor cursorPoint]		ifFalse: [vanishingPoint := self viewLocFor: CurrentProject].	Display zoomIn: entering orOutTo: newDisplay at: 0@0			vanishingPoint: vanishingPoint.! !!DataStream methodsFor: 'write and read' stamp: ''!readFloat	"PRIVATE -- Read the contents of a Float.	 This is the fast way to read a Float.	 We support 8-byte Floats here.  Non-IEEE"	| new |	new := Float new: 2.		"To get an instance"	new at: 1 put: (byteStream nextNumber: 4).	new at: 2 put: (byteStream nextNumber: 4).	^ new! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/23/2000 23:00'!noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: infoOrNil	| methodChange |	methodChange := self findOrMakeMethodChangeAt: selector priorMethod: priorMethod.	methodChange changeType == #add		ifTrue: [methodChange noteChangeType: #addedThenRemoved]		ifFalse: [methodChange noteChangeType: #remove].	infoOrNil ifNotNil:		["Save the source code pointer and category so can still browse old versions"		methodChange noteMethodInfoFromRemoval: infoOrNil]! !!ImageSegment methodsFor: 'statistics' stamp: 'ar 2/21/2001 19:19'!doSpaceAnalysis	"Capture statistics about the IS and print the number of instances per class and space usage"	| index sz word hdrBits cc instCount instSpace |	state == #activeCopy ifFalse:[self errorWrongState].	instCount := IdentityDictionary new.	instSpace := IdentityDictionary new.	index := 2. 	"skip version word, first object"	"go past extra header words"	hdrBits := (segment at: index) bitAnd: 3.	hdrBits = 1 ifTrue: [index := index+1].	hdrBits = 0 ifTrue: [index := index+2].	[index > segment size] whileFalse:[		hdrBits := (word := segment at: index) bitAnd: 3.		hdrBits = 2 ifTrue:[sz := word bitAnd: 16rFFFFFFFC].		hdrBits = 0 ifTrue:[sz := ((segment at: index-2) bitAnd: 16rFFFFFFFC) + 8].		hdrBits = 1 ifTrue:[sz := (word bitAnd: "SizeMask" 252) + 4].		hdrBits = 3 ifTrue:[sz := word bitAnd: "SizeMask" 252].		hdrBits = 2 			ifTrue:[cc := #freeChunk]			ifFalse:[cc := self classNameAt: index].		instCount at: cc put: (instCount at: cc ifAbsent:[0]) + 1.		instSpace at: cc put: (instSpace at: cc ifAbsent:[0]) + sz.		index := self objectAfter: index].	^{instCount. instSpace}! !!DataStream class methodsFor: 'as yet unclassified' stamp: 'jm 12/3/97 19:36'!testWith: anObject	"As a test of DataStream/ReferenceStream, write out anObject and read it back.	11/19/92 jhm: Set the file type. More informative file name."	"DataStream testWith: 'hi'"	"ReferenceStream testWith: 'hi'"	| file result |	file := FileStream fileNamed: (self name, ' test').	file binary.	(self on: file) nextPut: anObject.	file close.	file := FileStream fileNamed: (self name, ' test').	file binary.	result := (self on: file) next.	file close.	^ result! !!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:34'!spyOn: aBlock    "MessageTally spyOn: [100 timesRepeat: [3.14159 printString]]"	| node result |	node := self new.	result := node spyEvery: self defaultPollPeriod on: aBlock.	(StringHolder new contents: (String streamContents: [:s | node report: s; close]))		openLabel: 'Spy Results'.	^ result! !!Project methodsFor: 'file in/out' stamp: 'rbb 2/18/2005 08:57'!decideAboutCreatingBlank: otherProjectName	| resp |	"20 Oct - just do it"	true "version isNil" ifFalse: [	"if saved, then maybe don't create"		resp := (UIManager default chooseFrom: #('Yes, make it up' 'No, skip it') 			title: ('I cannot locate the project\',				otherProjectName,				'\Would you like me to create a new project\with that name?'			) withCRs).		resp = 1 ifFalse: [^ nil]	].	^Project openBlankProjectNamed: otherProjectName! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:39'!allChangeTypes	| chgs |	(priorName ~~ nil and: [changeTypes includes: #rename]) ifTrue:		[(chgs := changeTypes copy) add: 'oldName: ' , priorName.		^ chgs].	^ changeTypes! !!Project class methodsFor: 'utilities' stamp: 'dgd 11/6/2004 20:49'!buildJumpToMenu: menu	"Make the supplied menu offer a list of potential projects, consisting of:		*	The previous-project chain		*	The next project, if any		*	The parent project, if any		*	All projects, alphabetically or hierarchically"	| prev listed i next  toAdd |	listed := OrderedCollection with: CurrentProject.	i := 0.	"The previous Project chain"	prev := CurrentProject previousProject.	[(prev ~~ nil and: [(listed includes: prev) not])] whileTrue:	  [i := i + 1.		listed add: prev.		self 	addItem: prev name , ' (', ('back {1}' translated format:{i}  ), ')'				toMenu: menu 				selection: ('%back' , i printString) 				project: prev.		prev := prev previousProject].	i > 0 ifTrue: [menu addLine].	"Then the next Project"	(((next := CurrentProject nextProject) ~~ nil) and: [(listed includes: next) not]) ifTrue:		[self	addItem: (next name, ' (', ('forward {1}' translated format:{1}), ')') 				toMenu: menu 				selection: next name 				project: next]. 	next ~~ nil ifTrue: [menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self	addItem: CurrentProject parent name , ' (', 'parent' translated, ')' 				toMenu: menu 				selection: #parent 				project: CurrentProject parent.		  menu addLine].	"Finally all the projects, in hierarchical or alphabetical order:"	(Preferences alphabeticalProjectMenu			ifTrue:				[Project allNamesAndProjects]			ifFalse:				[Project hierarchyOfNamesAndProjects]) do:		[:aPair | 			toAdd := aPair last isCurrentProject				ifTrue:				  [aPair first, ' (', 'current' translated, ')']				ifFalse:				  [aPair first].			self	addItem: toAdd 				toMenu: menu 				selection: aPair first 				project: aPair last].	^ menu! !!SystemChangeNotifier class methodsFor: 'private' stamp: 'rw 7/11/2003 14:36'!resetUniqueInstance	"self resetUniqueInstance"	UniqueInstance		ifNotNilDo: [:u | UniqueInstance releaseAll.			UniqueInstance := nil]! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/11/2003 14:14'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321)."	"Players also refer to each other using associations in the References dictionary.  Search the methods of our Players for those.  Make new entries in References and point to them."| pp oldPlayer newKey newAssoc oldSelList newSelList |	newUniClasses ifFalse: [^ self].	"All will be siblings.  uniClasses is empty""Uniclasses use class vars to hold onto siblings who are referred to in code"pp := Player class superclass instSize.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+1"	"(pp+2) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+3 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	]."Make new entries in References and point to them."References keys "copy" do: [:playerName |	oldPlayer := References at: playerName.	(references includesKey: oldPlayer) ifTrue: [		newKey := (references at: oldPlayer) "new player" uniqueNameForReference.		"now installed in References"		(references at: oldPlayer) renameTo: newKey]].uniClasses "values" do: [:newClass |	oldSelList := OrderedCollection new.   newSelList := OrderedCollection new.	newClass selectorsDo: [:sel | 		(newClass compiledMethodAt: sel)	 literals do: [:assoc |			assoc isVariableBinding ifTrue: [				(References associationAt: assoc key ifAbsent: [nil]) == assoc ifTrue: [					newKey := (references at: assoc value ifAbsent: [assoc value]) 									externalName asSymbol.					(assoc key ~= newKey) & (References includesKey: newKey) ifTrue: [						newAssoc := References associationAt: newKey.						newClass methodDictionary at: sel put: 							(newClass compiledMethodAt: sel) clone.	"were sharing it"						(newClass compiledMethodAt: sel)							literalAt: ((newClass compiledMethodAt: sel) literals indexOf: assoc)							put: newAssoc.						(oldSelList includes: assoc key) ifFalse: [							oldSelList add: assoc key.  newSelList add: newKey]]]]]].	oldSelList with: newSelList do: [:old :new |			newClass replaceSilently: old to: new]].	"This is text replacement and can be wrong"! !!ProjectHistory class methodsFor: 'accessing' stamp: 'RAA 7/10/2000 15:56'!changeCounter	^ChangeCounter ifNil: [ChangeCounter := 0].! !!SystemDictionary methodsFor: 'shrinking' stamp: 'nk 4/28/2004 10:24'!removeAllUnSentMessages	"Smalltalk removeAllUnSentMessages"	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]. 	Smalltalk removeAllUnSentMessages > 0] whileTrue."	"Remove all implementations of unsent messages."	| sels n |	sels := self systemNavigation allUnSentMessages.	"The following should be preserved for doIts, etc"	"needed even after #majorShrink is pulled"	#(#rehashWithoutBecome #compactSymbolTable #rebuildAllProjects #browseAllSelect:  #lastRemoval #scrollBarValue: vScrollBarValue: #scrollBarMenuButtonPressed: #withSelectionFrom: #to: #removeClassNamed: #dragon: #hilberts: #mandala: #web #test3 #factorial #tinyBenchmarks #benchFib #newDepth: #restoreAfter: #forgetDoIts #zapAllMethods #obsoleteClasses #removeAllUnSentMessages #abandonSources #removeUnreferencedKeys #reclaimDependents #zapOrganization #condenseChanges #browseObsoleteReferences #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: #methodsFor:stamp: #methodsFor:stamp:prior: #instanceVariableNames: #startTimerInterruptWatcher #unusedClasses )		do: [:sel | sels				remove: sel				ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet		do: [:sel | sels				remove: sel				ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet		do: [:sel | sels				remove: sel				ifAbsent: []].	sels size = 0		ifTrue: [^ 0].	n := 0.	self systemNavigation		allBehaviorsDo: [:x | n := n + 1].	'Removing ' , sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0		to: n		during: [:bar | 			n := 0.			self systemNavigation				allBehaviorsDo: [:class | 					bar value: (n := n + 1).					sels						do: [:sel | class basicRemoveSelector: sel]]].	^ sels size! !!MessageTally methodsFor: 'initialize-release' stamp: ''!close	(Timer isMemberOf: Process) ifTrue: [Timer terminate].	Timer := ObservedProcess := nil.	class := method := tally := receivers := nil! !!ResourceManager methodsFor: 'loading' stamp: 'tetha 3/6/2004 15:46'!preLoadFromArchive: aZipArchive cacheName: aFileName	"Load the resources from the given zip archive"	| orig nameMap resMap loc stream |	self class reloadCachedResources.	resMap := Dictionary new.	nameMap := Dictionary new.	unloaded do:[:locator|		locator localFileName: nil.		nameMap at: locator urlString put: locator.		resMap at: locator urlString put: (resourceMap at: locator)].	aZipArchive members do:[:entry|		stream := nil.		orig := resMap at: (self convertMapNameForBackwardcompatibilityFrom: entry fileName ) ifAbsent:[nil].		loc := nameMap at: (self convertMapNameForBackwardcompatibilityFrom: entry fileName ) ifAbsent:[nil].		"note: orig and loc may be nil for non-resource members"		(orig notNil and:[loc notNil]) ifTrue:[			stream := entry contentStream.			self installResource: orig from: stream locator: loc.			stream reset.			aFileName 				ifNil:[self class cacheResource: loc urlString stream: stream]				ifNotNil:[self class cacheResource: loc urlString inArchive: aFileName]].	].! !!FilePackage class methodsFor: 'conflict checker logging' stamp: 'stephaneducasse 11/1/2005 15:39'!logFileStream	LogFileStream ifNil:		[LogFileStream := FileStream fileNamed: 'ConflictChecker.log'.		LogFileStream setToEnd].	^ LogFileStream! !!ChangeRecord methodsFor: 'access' stamp: 'di 1/13/98 16:57'!string 	| string |	file openReadOnly.	file position: position.	string := file nextChunk.	file close.	^ string! !!SystemNavigation methodsFor: 'query' stamp: 'sd 4/29/2003 15:17'!selectAllMethods: aBlock 	"Answer a SortedCollection of each method that, when used as the block  	argument to aBlock, gives a true result."	| aCollection |	aCollection := SortedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsDo: [:sel | (aBlock									value: (class compiledMethodAt: sel))								ifTrue: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'sw 10/28/96'!renameClassNamed: oldName as: newName	"Invoked from fileouts:  if there is currently a class in the system named oldName, then rename it to newName.  If anything untoward happens, report it in the Transcript.  "	| oldClass |	(oldClass := self at: oldName asSymbol ifAbsent: [nil]) == nil		ifTrue:			[Transcript cr; show: 'Class-rename for ', oldName, ' ignored because ', oldName, ' does not exist.'.			^ self].	oldClass rename: newName! !!MessageTally methodsFor: 'tallying' stamp: ''!bumpBy: count	tally := tally + count! !!SmartRefStream methodsFor: 'import image segment' stamp: 'tk
11/26/2004 05:53'!applyConversionMethodsTo: objectIn className: className varMap: varMap	"Modify the object's instance vars to have the proper valuesfor its new shape.  Mostly, fill in defaut values of new inst vars.Can substitute an object of a different class.  (Beware: ifsubstituted, varMap will not be correct when the new object is askedto convert.)"	| anObject prevObject |	self flag: #bobconv.	anObject := objectIn.	[		prevObject := anObject.		anObject := anObject convertToCurrentVersion: varMaprefStream: self.		prevObject == anObject	] whileFalse.	^anObject! !!ImageSegment methodsFor: 'testing' stamp: 'di 3/27/1999 21:36'!verifyCopy	| copyOfRoots matchDict |	copyOfRoots := self segmentCopy.	matchDict := IdentityDictionary new.	arrayOfRoots with: copyOfRoots do:		[:r :c | self verify: r matches: c knowing: matchDict]! !!HTTPDownloadRequest methodsFor: 'initialize' stamp: 'KR 9/4/2005 10:33'!for: aUrl in: aLoader	url := aUrl.	loader := aLoader.	semaphore := Semaphore new.! !!AppRegistry class methodsFor: 'as yet unclassified' stamp: 'ads 3/29/2003 13:03'!unregister: aProviderClass	(default = aProviderClass) ifTrue: [default := nil].	self registeredClasses remove: aProviderClass ifAbsent: [].! !!CodeLoader class methodsFor: 'utilities' stamp: 'mir 1/18/2000 16:22'!exportCategories: catList to: aFileName	"CodeLoader exportCategories: #( 'Game-Animation' 'Game-Framework' ) to: 'Game-Framework'"	| list classList |	classList := OrderedCollection new.	catList do: [:catName |		list := SystemOrganization listAtCategoryNamed: catName asSymbol.		list do: [:nm | classList add: (Smalltalk at: nm); add: (Smalltalk at: nm) class]].	self exportCodeSegment: aFileName classes: classList keepSource: true! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:36'!+= aThirtTwoBitRegister	"Replace my contents with the sum of the given register and my current contents."	| lowSum |	lowSum := low + aThirtTwoBitRegister low.	hi := (hi + aThirtTwoBitRegister hi + (lowSum bitShift: -16)) bitAnd: 16rFFFF.	low := lowSum bitAnd: 16rFFFF.! !!SecurityManager methodsFor: 'fileIn/out' stamp: 'hg 9/29/2001 14:35'!storeSecurityKeys	"SecurityManager default storeSecurityKeys"	"Store the keys file for the current user"	| fd loc file |	self isInRestrictedMode ifTrue:[^self]. "no point in even trying"	loc := self secureUserDirectory. "where to put it"	loc last = FileDirectory pathNameDelimiter ifFalse:[		loc := loc copyWith: FileDirectory pathNameDelimiter.	].	fd := FileDirectory on: loc.	fd assureExistence.	fd deleteFileNamed: self keysFileName ifAbsent:[].	file := fd newFileNamed: self keysFileName.	{privateKeyPair. trustedKeys} storeOn: file.	file close.! !!ResourceManager class methodsFor: 'private-resources' stamp: 'ar 5/30/2001 23:55'!loadResource: urlString fromCacheFileNamed: fileName in: dir	| archiveName file archive |	(fileName beginsWith: 'zip://') ifTrue:[		archiveName := fileName copyFrom: 7 to: fileName size.		archive := [dir readOnlyFileNamed: archiveName] 			on: FileDoesNotExistException			do:[:ex| ex return: nil].		archive ifNil:[^nil].		archive isZipArchive ifTrue:[			archive := ZipArchive new readFrom: archive.			file := archive members detect:[:any| any fileName = urlString] ifNone:[nil]].		file ifNotNil:[file := file contentStream].		archive close.	] ifFalse:[		file := [dir readOnlyFileNamed: fileName] 				on: FileDoesNotExistException				do:[:ex| ex return: nil].	].	^file! !!SmartRefStream methodsFor: 'read write' stamp: 'md 2/24/2006 19:52'!nextPut: anObject	"Really write three objects: (version, class structure, object).  But only when called from the outside.  If any instance-specific classes are present, prepend their source code.  byteStream will be in fileOut format.	You can see an analysis of which objects are written out by doing: 	(SmartRefStream statsOfSubObjects: anObject)	(SmartRefStream tallyOfSubObjects: anObject)	(SmartRefStream subObjects: anObject ofClass: aClass)"| info |topCall == nil 	ifTrue:		[topCall := anObject.		'Please wait while objects are counted' 			displayProgressAt: Sensor cursorPoint			from: 0 to: 10			during: [:bar | info := self instVarInfo: anObject].		self appendClassDefns.	"For instance-specific classes"		'Writing an object file' displayProgressAt: Sensor cursorPoint			from: 0 to: objCount*4	"estimate"			during: [:bar |				objCount := 0.				progressBar := bar.				self setStream: byteStream reading: false.					"set basePos, but keep any class renames"				super nextPut: ReferenceStream versionCode.				super nextPut: info.				super nextPut: anObject.		"<- the real writing"				classInstVars size > 0 ifTrue: [super nextPut: classInstVars]].					"Note: the terminator, $!!, is not doubled inside object data"		"references is an IDict of every object that got written"		byteStream ascii.		byteStream nextPutAll: '!!'; cr; cr.		byteStream padToEndWith: $ .	"really want to truncate file, but can't"		topCall := progressBar := nil]	"reset it"	ifFalse:		[super nextPut: anObject.		progressBar ifNotNil: [progressBar value: (objCount := objCount + 1)]].		"return the argument - added by kwl"	^ anObject! !!HTTPDownloadRequest methodsFor: 'private' stamp: 'yo 7/29/2005 16:04'!httpEncodeSafely: aUrl	"Encode the url but skip $/ and $:."	| unescaped |	unescaped := aUrl unescapePercents.	^ unescaped encodeForHTTPWithTextEncoding: 'utf-8'		conditionBlock: [:c | c isSafeForHTTP or: [c = $/ or: [c = $:]]].! !!DataStream class methodsFor: 'as yet unclassified' stamp: ''!newFileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr := ReferenceStream fileNamed: 'test.obj'.rr nextPut: <your object>.rr close."	| strm |	strm :=  self on: (FileStream newFileNamed: aString).		"will be binary"	strm byteStream setFileTypeToObject.		"Type and Creator not to be text, so can attach correctly to an email msg"	^ strm! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 1/11/2000 15:27'!remapCompactClasses: mapFakeClassesToReal refStrm: smartRefStream	| ccArray current fake info |	"See if our compact classes are compatible with this system.  Convert to what the system already has.  If we are adding a new class, it has already been filed in.  A compact class may not be a root."	(outPointers at: (outPointers size - 1)) = 1717 ifFalse: [^ true].	ccArray := outPointers last.	current := Smalltalk compactClassesArray.	1 to: ccArray size do: [:ind | 		(ccArray at: ind) ifNotNil: ["is compact in the segment"			fake := mapFakeClassesToReal keyAtValue: (current at: ind) ifAbsent: [nil].			info := self cc: ind new: (ccArray at: ind) current: (current at: ind) 					fake: fake refStrm: smartRefStream.			info ifFalse: [^ false]]].	^ true! !!Project class methodsFor: 'utilities' stamp: 'RAA 12/26/2000 12:42'!forget: aProject	AllProjects := self allProjects reject: [ :x | x == aProject].! !!MessageTally methodsFor: 'tallying' stamp: 'efc 8/27/2005 16:42'!tallyPath: context by: count	| aMethod path |	aMethod := context method.	receivers do: 		[:aMessageTally | 		aMessageTally method == aMethod ifTrue: [path := aMessageTally]].	path == nil ifTrue: 		[path := MessageTally new class: context receiver class method: aMethod;			maxClassNameSize: maxClassNameSize;			maxClassPlusSelectorSize: maxClassPlusSelectorSize;			maxTabs: maxTabs.		receivers := receivers copyWith: path].	^ path bumpBy: count! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:40'!bitOr: aThirtTwoBitRegister	"Replace my contents with the bitwise OR of the given register and my current contents."	hi := hi bitOr: aThirtTwoBitRegister hi.	low := low bitOr: aThirtTwoBitRegister low.! !!SmartRefStream methodsFor: 'read write' stamp: 'ar 4/10/2005 19:27'!initShapeDicts	"Initialize me. "	self flag: #bobconv.		"These must stay constant.  When structures read in, then things can change."	steady := {Array. Dictionary. Association. ByteString. SmallInteger} asSet.	renamed ifNil: [		renamed := Dictionary new.  "(old class name symbol -> new class name)"		renamedConv := Dictionary new "(oldClassNameSymbol -> conversionSelectorInNewClass)"	].	self initKnownRenames! !!PluginHTTPDownloadRequest methodsFor: 'accessing' stamp: 'mir 1/11/2000 11:36'!startRetrieval	| attempts |	attempts := self maxAttempts.	"Note: Only the first request may fail due to not running in a browser"	url first = $/		ifTrue: [url := url copyFrom: 2 to: url size].	fileStream := FileStream requestURLStream: url ifError:[^super startRetrieval].	[fileStream == nil] whileTrue:[		attempts := attempts - 1.		attempts = 0 ifTrue:[^self content:'Error downloading file'].		fileStream := FileStream requestURLStream: url].	semaphore signal.! !!ProjectLauncher methodsFor: 'initialization' stamp: 'mir 8/24/2001 20:25'!initialize	super initialize.	showSplash := true.	HTTPClient isRunningInBrowser		ifTrue: [whichFlaps := 'etoy']! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 8/18/1998 09:02'!scanFrom: aByteStream	"During a code fileIn, we need to read in an object, and stash it in ScannedObject.  "	self setStream: aByteStream reading: true.	ScannedObject := self next.	byteStream ascii.	byteStream next == $!! ifFalse: [		byteStream close.		self error: 'Object did not end correctly']. 	"caller will close the byteStream"	"HandMorph.readMorphFile will retrieve the ScannedObject"! !!ExternalDropHandler methodsFor: 'accessing' stamp: 'mir 1/10/2002 17:29'!handle: dropStream in: pasteUp dropEvent: anEvent	| numArgs |	numArgs := action numArgs.	numArgs == 1		ifTrue: [^action value: dropStream].	numArgs == 2		ifTrue: [^action value: dropStream value: pasteUp].	numArgs == 3		ifTrue: [^action value: dropStream value: pasteUp value: anEvent].	self error: 'Wrong number of args for dop action.'! !!DataStream class methodsFor: 'as yet unclassified' stamp: ''!oldFileNamed: aString	"Here is the way to use DataStream and ReferenceStream:rr := ReferenceStream oldFileNamed: 'test.obj'.^ rr nextAndClose."	| strm ff |	ff := FileStream oldFileOrNoneNamed: aString.	ff ifNil: [^ nil].	strm := self on: (ff binary).	^ strm! !!Project methodsFor: 'menu messages' stamp: 'RAA 6/11/2000 15:04'!enterAsActiveSubprojectWithin: enclosingWorld	"Install my ChangeSet, Transcript, and scheduled views as current globals. 	If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	"Experimental mods for initial multi-project work:		1. assume in morphic (this eliminated need for <showZoom>)		2. assume <saveForRevert> is false (usual case) - removed <old>		3. assume <revertFlag> is false		4. assume <revertWithoutAsking> is false - <forceRevert> now auto false <seg> n.u.		5. no zooming		6. assume <projectsSentToDisk> false - could be dangerous here		7. assume no isolation problems (isolationHead ==)		8. no closing scripts	"	self isCurrentProject ifTrue: [^ self].	guards ifNotNil: [		guards := guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]	].		"CurrentProject makeThumbnail."		"--> Display bestGuessOfCurrentWorld triggerClosingScripts."	CurrentProject displayDepth: Display depth.	displayDepth == nil ifTrue: [displayDepth := Display depth].		"Display newDepthNoRestore: displayDepth."		"(world hasProperty: #letTheMusicPlay)			ifTrue: [world removeProperty: #letTheMusicPlay]			ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 						playerClass allSubInstancesDo: [:player | player pause]]]."		"returningFlag			ifTrue: [nextProject := CurrentProject]			ifFalse: [previousProject := CurrentProject]."		"CurrentProject saveState."		"CurrentProject := self."		"Smalltalk newChanges: changeSet."		"TranscriptStream newTranscript: transcript."		"Sensor flushKeyboard."		"recorderOrNil := Display pauseMorphicEventRecorder."		"Display changeMorphicWorldTo: world."  "Signifies Morphic"	world 		installAsActiveSubprojectIn: enclosingWorld 		titled: self name.		"recorderOrNil ifNotNil: [recorderOrNil resumeIn: world]."	world triggerOpeningScripts.	self removeParameter: #exportState.		"self spawnNewProcessAndTerminateOld: true"! !!SpaceTally methodsFor: 'fileOut' stamp: 'sd 6/20/2003 23:07'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f := FileStream readOnlyFileNamed: fileName1.	coll1 := OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f := FileStream readOnlyFileNamed: fileName2.	coll2 := OrderedCollection new.	[f atEnd] whileFalse:		[item := (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!HTTPClient class methodsFor: 'private' stamp: 'fbs 2/2/2005 13:23'!pluginHttpPostMultipart: url args: argsDict	| mimeBorder argsStream crLf fieldValue resultStream result |	" do multipart/form-data encoding rather than x-www-urlencoded "	crLf := String crlf.	mimeBorder := '----squeak-', Time millisecondClockValue printString, '-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, crLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', crLf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: crLf, crLf, fieldValue, crLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	resultStream := FileStream		post: 			('ACCEPT: text/html', crLf,			'User-Agent: Squeak 3.1', crLf,			'Content-type: multipart/form-data; boundary=', mimeBorder, crLf,			'Content-length: ', argsStream contents size printString, crLf, crLf, 			argsStream contents)		url: url ifError: [^'Error in post ' url asString].	"get the header of the reply"	result := resultStream		ifNil: ['']		ifNotNil: [resultStream upToEnd].	^MIMEDocument content: result! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 1/30/2001 15:41'!absorbStructureOfClass: aClass from: otherChangeSet	"Absorb into the receiver all the structure and superclass info in the other change set.  Used to write conversion methods."	| sup next |	otherChangeSet structures ifNil: [^ self].	(otherChangeSet structures includesKey: aClass name) ifFalse: [^ self].	structures ifNil:		[structures := Dictionary new.		superclasses := Dictionary new].	sup := aClass name.	[(structures includesKey: sup) 		ifTrue: ["use what is here" true]		ifFalse: [self flag: #noteToDan.  "sw 1/30/2001 13:57 emergency workaround -- a case arose where the otherChangeSet's structures did not have the key, and it gummed up the works."				(otherChangeSet structures includesKey: sup) ifTrue:					[structures at: sup put: (otherChangeSet structures at: sup)].				next := otherChangeSet superclasses at: sup.				superclasses at: sup put: next.				(sup := next) = 'nil']	] whileFalse.! !!CodeLoader class methodsFor: 'utilities' stamp: 'asm 12/6/2002 08:11'!signFile: fileName renameAs: destFile key: privateKey dsa: dsa	"Sign the given file using the private key."	| in out |	in := FileStream readOnlyFileNamed: fileName.	in binary.	out := FileStream newFileNamed: destFile.			out binary.	[in atEnd] whileFalse:[out nextPutAll: (in next: 4096)].	in close.	out close.	FileDirectory activeDirectoryClass splitName: destFile to:[:path :file|		SecurityManager default signFile: file directory: (FileDirectory on: path).	].! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'RAA 1/17/2001 12:06'!declare: classThatIsARoot	| nameOnArrival |	"The class just arrived in this segment.  How fit it into the Smalltalk dictionary?  If it had an association, that was installed with associationDeclareAt:."	nameOnArrival := classThatIsARoot name.	self declareAndPossiblyRename: classThatIsARoot.	nameOnArrival == classThatIsARoot name ifTrue: [^self].	renamedClasses ifNil: [RecentlyRenamedClasses := renamedClasses := Dictionary new].	renamedClasses at: nameOnArrival put: classThatIsARoot name.! !!ImageSegment methodsFor: 'testing' stamp: 'gm 2/22/2003 18:36'!findRogueRootsPrep	"Part of the tool to track down unwanted pointers into the segment.  Break all owner pointers in submorphs, scripts, and viewers in flaps."| wld players morphs scriptEditors |wld := arrayOfRoots detect: [:obj | 	obj isMorph ifTrue: [obj isWorldMorph] ifFalse: [false]] ifNone: [nil].wld ifNil: [wld := arrayOfRoots detect: [:obj | obj isMorph] 				ifNone: [^ self error: 'can''t find a root morph']].morphs := IdentitySet new: 400.wld allMorphsAndBookPagesInto: morphs.players := wld presenter allExtantPlayers.	"just the cached list"players do: [:pp |	scriptEditors := pp class tileScriptNames collect: [:nn | 			pp scriptEditorFor: nn].	scriptEditors do: [:se | morphs addAll: se allMorphs]].wld submorphs do: [:mm | 	"non showing flaps"	(mm isKindOf: FlapTab) ifTrue: [		mm referent allMorphsAndBookPagesInto: morphs]].morphs do: [:mm | 	"break the back pointers"	mm isInMemory ifTrue: [	(mm respondsTo: #target) ifTrue: [		mm nearestOwnerThat: [:ow | ow == mm target 			ifTrue: [mm target: nil. true]			ifFalse: [false]]].	(mm respondsTo: #arguments) ifTrue: [		mm arguments do: [:arg | arg ifNotNil: [			mm nearestOwnerThat: [:ow | ow == arg				ifTrue: [mm arguments at: (mm arguments indexOf: arg) put: nil. true]				ifFalse: [false]]]]].	mm eventHandler ifNotNil: ["recipients point back up"		(morphs includesAllOf: (mm eventHandler allRecipients)) ifTrue: [			mm eventHandler: nil]].	"temporary, until using Model for PartsBin"	(mm isMorphicModel) ifTrue: [		(mm model isMorphicModel) ifTrue: [			mm model breakDependents]].	(mm isTextMorph) ifTrue: [mm setContainer: nil]]].(Smalltalk includesKey: #Owners) ifTrue: [Smalltalk at: #Owners put: nil].	"in case findOwnerMap: is commented out""self findOwnerMap: morphs."morphs do: [:mm | 	"break the back pointers"	mm isInMemory ifTrue: [mm privateOwner: nil]]."more in extensions?"! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'NS 1/16/2004 15:35'!forceChangesToDisk	"Ensure that the changes file has been fully written to disk by closing and re-opening it. This makes the system more robust in the face of a power failure or hard-reboot."	| changesFile |	changesFile := SourceFiles at: 2.	(changesFile isKindOf: FileStream) ifTrue: [		changesFile flush.		SecurityManager default hasFileAccess ifTrue:[			changesFile close.			changesFile open: changesFile name forWrite: true].		changesFile setToEnd.	].! !!ClassChangeRecord methodsFor: 'initialization' stamp: 'di 4/5/2000 08:11'!initFor: className revertable: isRevertable	inForce := isRevertable.	changeTypes := IdentitySet new.	methodChanges := IdentityDictionary new.	priorName := thisName := className.	revertable := isRevertable and: [self realClass notNil].	revertable ifTrue:		[priorMD := self realClass methodDict copy.		priorOrganization := self realClass organization deepCopy].! !!Project methodsFor: 'displaying' stamp: 'ar 9/1/2000 14:24'!imageFormOfSize: extentPoint depth: d	| newDisplay |	newDisplay := DisplayScreen extent: extentPoint depth: d.	Display replacedBy: newDisplay do:[		world isMorph 			ifTrue:[Display getCanvas fullDrawMorph: world] "Morphic"			ifFalse:[world restore]. "MVC"	].	^newDisplay! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'raa 5/30/2000 15:47'!generateQandP	"Generate the two industrial-grade primes, q (160-bits) and p (512-bit) needed to build a key set. Answer the array (q, p, s), where s is the seed that from which q and p were created. This seed is normally discarded, but can be used to verify the key generation process if desired."	| pBits halfTwoToTheP chunkCount sAndq q twoQ n c w x p s |	pBits := 512.  "desired size of p in bits"	halfTwoToTheP := 2 raisedTo: (pBits - 1).	chunkCount := pBits // 160.	Transcript show: 'Searching for primes q and p...'; cr.	[true] whileTrue: [		sAndq := self generateSandQ.		Transcript show: '  Found a candidate q.'; cr.		s := sAndq first.		q := sAndq last.		twoQ := q bitShift: 1.		n := 2.		c := 0.		[c < 4096] whileTrue: [			w := self generateRandomLength: pBits s: s n: n.			x := w + halfTwoToTheP.			p := (x - ( x \\ twoQ)) + 1.			p highBit = pBits ifTrue: [				Transcript show: '    Testing potential p ', (c + 1) printString, '...'; cr.				(self isProbablyPrime: p) ifTrue: [					Transcript show: '  Found p!!'; cr.					^ Array with: q with: p with: s]].			n := n + chunkCount + 1.			c := c + 1]].! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref := self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SARInstaller methodsFor: 'client services' stamp: 'nk 2/13/2004 12:12'!fileInGenieDictionaryNamed: memberName 	"This is to be used from preamble/postscript code to file in zip 	members as Genie gesture dictionaries.	Answers a dictionary."	| member object crDictionary stream |	crDictionary := Smalltalk at: #CRDictionary ifAbsent: [ ^self error: 'Genie not installed' ].	"don't know how to recursively load"	member := self memberNamed: memberName.	member ifNil: [ ^self errorNoSuchMember: memberName ].	stream := ReferenceStream on: member contentStream.	[ object := stream next ]		on: Error do: 		[:ex |  stream close.		self inform: 'Error on loading: ' , ex description. ^ nil ].	stream close.	(object notNil and: [object name isEmptyOrNil])		ifTrue: [object := crDictionary name: object storedName].	self installed: member.	^ object! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 13:35'!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  "	| aString |	aString := self postscriptString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!Utilities class methodsFor: 'investigations' stamp: 'sd 4/29/2003 11:59'!reportSenderCountsFor: selectorList 	"Produce a report on the number of senders of each of the selectors in 	the list. 1/27/96 sw"	| total report thisSize |	total := 0.	report := ''.	selectorList		do: [:selector | 			thisSize := (self systemNavigation allCallsOn: selector) size.			report := report , thisSize printString , String tab , selector printString , String cr.			total := total + thisSize].	report := report , '--- ------------------'.	report := report , total printString , String tab , 'TOTAL'.	^ report! !!ReferenceStream class methodsFor: 'accessing' stamp: ''!refTypes: oc	RefTypes := oc! !!Utilities class methodsFor: 'fetching updates' stamp: 'RAA 12/17/2000 16:19'!zapUpdateDownloader	UpdateDownloader ifNotNil: [UpdateDownloader terminate].	UpdateDownloader := nil.! !!ChangeSet methodsFor: 'method changes' stamp: 'RAA 5/28/2001 12:05'!messageListForChangesWhich: aBlock ifNone: ifEmptyBlock	| answer |	answer := self changedMessageListAugmented select: [ :each |		aBlock value: each actualClass value: each methodSymbol	].	answer isEmpty ifTrue: [^ifEmptyBlock value].	^answer! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder := self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder := changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'sd 11/16/2003 13:29'!saveImageSegments	| haveSegs oldImageSegDir newImageSegDir |	haveSegs := false.	Smalltalk at: #ImageSegment ifPresent: [:theClass | 		(haveSegs := theClass instanceCount ~= 0) ifTrue: [			oldImageSegDir := theClass segmentDirectory]].	haveSegs ifTrue: [		Smalltalk at: #ImageSegment ifPresent: [:theClass |			newImageSegDir := theClass segmentDirectory.	"create the folder"			oldImageSegDir fileNames do: [:theName | "copy all segment files"				| imageSegmentName |				imageSegmentName := oldImageSegDir pathName, FileDirectory slash, theName.				newImageSegDir 					copyFileWithoutOverwriteConfirmationNamed: imageSegmentName					toFileNamed: theName]]].! !!ResourceManager methodsFor: 'loading' stamp: 'nk 4/17/2004 19:50'!loadCachedResources	"Load all the resources that we have cached locally"	| resource |	self class reloadCachedResources.	self prioritizedUnloadedResources do:[:loc|		self class lookupCachedResource: loc urlString ifPresentDo:[:stream|			resource := resourceMap at: loc ifAbsent:[nil].			self installResource: resource				from: stream				locator: loc.			(resource isForm) ifTrue:[				self formChangedReminder value.				World displayWorldSafely].		].	].! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 19:22'!getRecentLocatorWithPrompt: aPrompt	"Prompt with a menu of how far back to go.  Return nil if user backs out.  Otherwise return the number of characters back from the end of the .changes file the user wishes to include"	 "ChangeList getRecentPosition"	| end changesFile banners positions pos chunk i |	changesFile := (SourceFiles at: 2) readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := SmalltalkImage current lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk := changesFile nextChunk.		i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos := Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos := 0]].	changesFile close.	pos := UIManager default chooseFrom: banners values: positions title: aPrompt.	pos == nil ifTrue: [^ nil].	^ end - pos! !!DataStream methodsFor: 'other' stamp: '6/9/97 08:03 di'!setStream: aStream	"PRIVATE -- Initialization method."	aStream binary.	basePos := aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."	byteStream := aStream.! !!SARInstaller methodsFor: 'fileIn' stamp: 'yo 8/17/2004 00:33'!fileInFrom: stream	"The zip has been saved already by the download.	Read the zip into my instvar, then file in the correct members"	| preamble postscript |	[		stream position: 0.		zip := ZipArchive new readFrom: stream.		preamble := zip memberNamed: 'install/preamble'.		preamble ifNotNil: [			preamble contentStream text setConverterForCode fileInFor: self announcing: 'Preamble'.			self class currentChangeSet preambleString: preamble contents.		].		postscript := zip memberNamed: 'install/postscript'.		postscript ifNotNil: [			postscript contentStream text setConverterForCode fileInFor: self announcing: 'Postscript'.			self class currentChangeSet postscriptString: postscript contents.		].		preamble isNil & postscript isNil ifTrue: [			(self confirm: 'No install/preamble or install/postscript member were found.	Install all the members automatically?') ifTrue: [ self installAllMembers ]		].	] ensure: [ stream close ].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 15:42'!checkClass: aClass	| meth |	"Check that no indexes of instance vars have changed in certain classes.  If you get an error in this method, an implementation of veryDeepCopyWith: needs to be updated.  The idea is to catch a change while it is still in the system of the programmer who made it."	self checkBasicClasses.	"Unlikely, but important to catch when it does happen."	"Every class that implements veryDeepInner: must copy all its inst vars.  Danger is that a user will add a new instance variable and forget to copy it.  So check that the last one is mentioned in the copy method."	(aClass includesSelector: #veryDeepInner:) ifTrue: [ 		((aClass compiledMethodAt: #veryDeepInner:) writesField: aClass instSize) ifFalse: [			aClass instSize > 0 ifTrue: [				self warnIverNotCopiedIn: aClass sel: #veryDeepInner:]]].	(aClass includesSelector: #veryDeepCopyWith:) ifTrue: [		meth := aClass compiledMethodAt: #veryDeepCopyWith:.		(meth size > 20) & (meth literals includes: #veryDeepCopyWith:) not ifTrue: [			(meth writesField: aClass instSize) ifFalse: [				self warnIverNotCopiedIn: aClass sel: #veryDeepCopyWith:]]].! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 17:15'!convert2: partiallyCorrectInst allVarMaps: allVarMaps	"Go through the normal instance conversion process and return a modern object."	| className varMap |	self flag: #bobconv.		varMap := allVarMaps at: partiallyCorrectInst.	className := varMap at: #ClassName.	"original"	^self applyConversionMethodsTo: partiallyCorrectInst className: className varMap: varMap.! !!SARInstaller methodsFor: 'accessing' stamp: 'nk 7/10/2003 16:53'!installedMembers	"Answer the zip members that have been installed already."	^installed ifNil: [ installed := OrderedCollection new ]! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'jm 12/14/1999 16:07'!loadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."	hi := ((aByteArray at: index) bitShift: 8) + ( aByteArray at: index + 1).	low := ((aByteArray at: index + 2) bitShift: 8) + ( aByteArray at: index + 3).! !!SmartRefStream methodsFor: 'import image segment' stamp: 'RAA 12/20/2000 11:08'!checkFatalReshape: setOfClasses	| suspects oldInstVars newInstVars bad className |	"Inform the user if any of these classes were reshaped.  A block has a method from the old system whose receiver is of this class.  The method's inst var references might be wrong.  OK if inst vars were only added."	self flag: #bobconv.		setOfClasses isEmpty ifTrue: [^ self].	suspects := OrderedCollection new.	setOfClasses do: [:aClass |		className := renamed keyAtValue: aClass name ifAbsent: [aClass name].		oldInstVars := (structures at: className ifAbsent: [#(0)]) allButFirst.		"should be there"		newInstVars := aClass allInstVarNames.		oldInstVars size > newInstVars size ifTrue: [bad := true].		oldInstVars size = newInstVars size ifTrue: [			bad := oldInstVars ~= newInstVars].		oldInstVars size < newInstVars size ifTrue: [			bad := oldInstVars ~= (newInstVars copyFrom: 1 to: oldInstVars size)].		bad ifTrue: [suspects add: aClass]].	suspects isEmpty ifFalse: [		self inform: ('Imported foreign methods will run on instances of:\',			suspects asArray printString, 			'\whose shape has changed.  Errors may occur.') withCRs].! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/4/2003 19:44'!newUniClasses: newVal	"If false, all new players are merely siblings of the old players"	newUniClasses := newVal! !!ExternalSettings class methodsFor: 'accessing' stamp: 'mir 8/23/2002 14:22'!parseServerEntryArgsFrom: stream	"Args are in the form <argName>: <argValueString> delimited by end of line.	It's not a very robust format and should be replaced by something like XML later.	But it avoids evaluating the entries for security reasons."	| entries lineStream entryName entryValue |	entries := Dictionary new.	stream skipSeparators.	[stream atEnd]		whileFalse: [			lineStream := ReadStream on: stream nextLine.			entryName := lineStream upTo: $:.			lineStream skipSeparators.			entryValue := lineStream upToEnd.			(entryName isEmptyOrNil 				or: [entryValue isEmptyOrNil])				ifFalse: [entries at: entryName put: entryValue withoutTrailingBlanks].			stream skipSeparators].	^entries! !!DigitalSignatureAlgorithm class methodsFor: 'public' stamp: 'jm 12/22/1999 11:20'!verify: signatureString isSignatureOf: aStringOrStream publicKey: publicKey	"Answer true if the given signature string signs the given message (a stream or string)."	"Note: Random numbers are not needed for signature verification; thus, there is no need to call initRandomFromUser before verifying a signature."	| dsa hasher h sig |	dsa := DigitalSignatureAlgorithm new.	hasher := SecureHashAlgorithm new.	(aStringOrStream class isBytes)		ifTrue: [h := hasher hashMessage: aStringOrStream]		ifFalse: [h := hasher hashStream: aStringOrStream].	sig := dsa stringToSignature: signatureString.	^ dsa verifySignature: sig ofMessageHash: h publicKey: publicKey! !!Project methodsFor: 'menu messages' stamp: 'yo 2/17/2005 15:07'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom recorderOrNil old forceRevert response seg newProcess |	(world isKindOf: StringMorph) ifTrue: [		self inform: 'This project is not all here. I will try to load a complete version.' translated.		^self loadFromServer: true	"try to get a fresh copy"	].	self isCurrentProject ifTrue: [^ self].	"Check the guards"	guards ifNotNil:		[guards := guards reject: [:obj | obj isNil].		guards do: [:obj | obj okayToEnterProject ifFalse: [^ self]]].	CurrentProject world triggerEvent: #aboutToLeaveWorld.	forceRevert := false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to' translated]]		ifNotNil: [saveForRevert ifFalse: [				forceRevert := CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response := SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' translated withCRs			trueChoice: 'Revert to saved version' translated			falseChoice: 'Cancel' translated.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg := CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to' translated]]		ifFalse: [			CurrentProject finalExitActions.			CurrentProject makeThumbnail.			returningFlag == #specialReturn				ifTrue:					[ProjectHistory forget: CurrentProject.		"this guy is irrelevant"					Project forget: CurrentProject]				ifFalse:					[ProjectHistory remember: CurrentProject]].	(revertFlag | saveForRevert | forceRevert) ifFalse:		[(Preferences valueOfFlag: #projectsSentToDisk) ifTrue:			[self storeToMakeRoom]].	CurrentProject abortResourceLoading.	Smalltalk isMorphic ifTrue: [CurrentProject world triggerClosingScripts].	CurrentProject saveProjectPreferences.	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	old := CurrentProject.		"for later"	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth := Display depth].	self installNewDisplay: Display extent depth: displayDepth.	(showZoom := self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresentAndInMemory:					[:playerClass | playerClass allSubInstancesDo:						[:player | player pause]]].	returningFlag == #specialReturn ifTrue: [		old removeChangeSetIfPossible.	"keep this stuff from accumulating"		nextProject := nil	] ifFalse: [		returningFlag			ifTrue: [nextProject := CurrentProject]			ifFalse: [previousProject := CurrentProject].	].	CurrentProject saveState.	CurrentProject isolationHead == self isolationHead ifFalse:		[self invokeFrom: CurrentProject].	CurrentProject := self.	self installProjectPreferences.	ChangeSet  newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	Smalltalk isMorphic ifTrue: [recorderOrNil := World pauseEventRecorder].	ProjectHistory remember: CurrentProject.	world isMorph		ifTrue:			[World := world.  "Signifies Morphic"			world install.			world transferRemoteServerFrom: old world.			"(revertFlag | saveForRevert | forceRevert) ifFalse: [				(Preferences valueOfFlag: #projectsSentToDisk) ifTrue: [					self storeSomeSegment]]."			recorderOrNil ifNotNil: [recorderOrNil resumeIn: world].			world triggerOpeningScripts]		ifFalse:			[World := nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	saveForRevert ifTrue: [		Smalltalk garbageCollect.	"let go of pointers"		old storeSegment.		"result :=" old world isInMemory 			ifTrue: ['Can''t seem to write the project.']			ifFalse: [old projectParameters at: #revertToMe put: 					old world xxxSegment clone].				'Project written.'].			"original is for coming back in and continuing."	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	self removeParameter: #exportState.	"Complete the enter: by launching a new process"	world isMorph ifTrue: [		self finalEnterActions.		world repairEmbeddedWorlds.		world triggerEvent: #aboutToEnterWorld.		Project spawnNewProcessAndTerminateOld: true	] ifFalse: [		SystemWindow clearTopWindow.	"break external ref to this project"		newProcess := [				ScheduledControllers resetActiveController.	"in case of walkback in #restore"			showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController		] fixTemps newProcess priority: Processor userSchedulingPriority.		newProcess resume.		"lose the current process and its referenced morphs"		Processor terminateActive.	]! !!ImageSegment class methodsFor: 'testing' stamp: 'di 3/7/2001 17:07'!discoverActiveClasses   "ImageSegment discoverActiveClasses" 	"Run this method, do a few things, maybe save and resume the image.	This will leave unused classes with MDFaults.	You MUST follow this soon by activeClasses, or by swapOutInactiveClasses."	"NOTE:  discoverActiveClasses uses Squeak's ability to detect and recover from faults due to a nil method dictionary.  It staches the method dict in with the organization during the time when discovery is in progress (Gag me with a spoon).  This is why the faults need to be cleared promptly before resuming normal work with the system.  It is also important that classes *do not* refer directly to their method dictionary, but only via the accessor message."	| ok |	Smalltalk allClasses do:		[:c | ok := true.		#(Array Object Class Message MethodDictionary) do:			[:n | ((Smalltalk at: n) == c or:				[(Smalltalk at: n) inheritsFrom: c]) ifTrue: [ok := false]].		ok ifTrue: [c induceMDFault]]."	ImageSegment discoverActiveClasses.		-- do something typical --	PopUpMenu notify: ImageSegment activeClasses size printString , ' classes were active out of ' ,			Smalltalk allClasses size printString."! !!Project methodsFor: 'release' stamp: 'dgd 9/21/2003 17:49'!okToChange	"Answer whether the window in which the project is housed can be dismissed -- which is destructive. We never clobber a project without confirmation"	| ok is list |	self subProjects size  >0 ifTrue:		[self inform: ('The project {1}contains sub-projects.  You must remove theseexplicitly before removing their parent.' translated format:{self name}).		^ false].	ok := world isMorph not and: [world scheduledControllers size <= 1].	ok ifFalse: [self isMorphic ifTrue:		[self parent == CurrentProject 			ifFalse: [^ true]]].  "view from elsewhere.  just delete it."	ok := (self confirm:('Really delete the project{1}and all its windows?' translated format:{self name})).			ok ifFalse: [^ false].	world isMorph ifTrue:		[Smalltalk at: #WonderlandCameraMorph ifPresent:[:aClass |			world submorphs do:   "special release for wonderlands"						[:m | (m isKindOf: aClass)								and: [m getWonderland release]]].			"Remove Player classes and metaclasses owned by project"			is := ImageSegment new arrayOfRoots: (Array with: self).			(list := is rootsIncludingPlayers) ifNotNil:				[list do: [:playerCls | 					(playerCls respondsTo: #isMeta) ifTrue:						[playerCls isMeta ifFalse:							[playerCls removeFromSystemUnlogged]]]]].	self removeChangeSetIfPossible.	"do this last since it will render project inaccessible to #allProjects and their ilk"	ProjectHistory forget: self.	Project deletingProject: self.	^ true! !!SystemNavigation methodsFor: 'browse' stamp: 'ar 9/27/2005 20:34'!browseUncommentedMethodsWithInitials: targetInitials	"Browse uncommented methods whose initials (in the time-stamp, as logged to disk) match the given initials.  Present them in chronological order.  CAUTION: It will take several minutes for this to complete."	"Time millisecondsToRun: [SystemNavigation default browseUncommentedMethodsWithInitials: 'jm']"	| initials timeStamp methodReferences cm |	methodReferences := OrderedCollection new.	self  allBehaviorsDo:		[:aClass | aClass selectors do: [:sel |			cm := aClass compiledMethodAt: sel.			timeStamp := Utilities timeStampForMethod: cm.			timeStamp isEmpty ifFalse:				[initials := timeStamp substrings first.				initials first isDigit ifFalse:					[((initials = targetInitials) and: [(aClass firstPrecodeCommentFor: sel) isNil])						ifTrue:							[methodReferences add: (MethodReference new								setStandardClass: aClass 								methodSymbol: sel)]]]]].	ToolSet		browseMessageSet: methodReferences 		name: 'Uncommented methods with initials ', targetInitials		autoSelect: nil! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'jm 12/7/1999 15:40'!bitInvert	"Replace my contents with the bitwise inverse my current contents."	hi := hi bitXor: 16rFFFF.	low := low bitXor: 16rFFFF.! !!SecurityManager methodsFor: 'security operations' stamp: 'RAA 3/2/2002 14:32'!signFile: fileName directory: fileDirectory	"Sign the given project in the directory"	| bytes file dsa hash sig key |	Preferences signProjectFiles ifFalse:[^self]. "signing turned off"	key := self signingKey.	key ifNil:[^self].	file := FileStream readOnlyFileNamed: (fileDirectory fullNameFor: fileName).	bytes := file binary; contentsOfEntireFile.	fileDirectory deleteFileNamed: fileName ifAbsent:[].	dsa := DigitalSignatureAlgorithm new.	dsa initRandom: Time millisecondClockValue + Date today julianDayNumber.	hash := SecureHashAlgorithm new hashStream: (ReadStream on: bytes).	sig := dsa computeSignatureForMessageHash: hash privateKey: key.	file := FileStream newFileNamed: (fileDirectory fullNameFor: fileName).	file binary.	"store a header identifying the signed file first"	file nextPutAll: 'SPRJ' asByteArray.	"now the signature"	file 		nextPutAll: (sig first withAtLeastNDigits: 20); 		nextPutAll: (sig last withAtLeastNDigits: 20).	"now the contents"	file nextPutAll: bytes.	file close.! !!SystemNavigation methodsFor: 'browse' stamp: 'rbb 2/18/2005 14:43'!browseClassVarRefs: aClass	"Put up a menu offering all class variable names; if the user chooses one, open up a message-list browser on all methods 	that refer to the selected class variable"	| lines labelStream vars allVars index owningClasses |	lines := OrderedCollection new.	allVars := OrderedCollection new.	owningClasses := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	aClass withAllSuperclasses reverseDo:		[:class |		vars := class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var.			owningClasses add: class].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^Beeper beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index := (UIManager default chooseFrom: (labelStream contents substrings) lines: lines).	index = 0 ifTrue: [^ self].	self browseAllCallsOn:		((owningClasses at: index) classPool associationAt: (allVars at: index))! !!Project methodsFor: 'menu messages' stamp: 'RAA 2/6/2001 14:21'!finalExitActions	| navigator |	world isMorph ifTrue: [		navigator := world findA: ProjectNavigationMorph.		navigator ifNotNil: [navigator retractIfAppropriate].	].! !!DataStream methodsFor: 'other' stamp: 'tk 8/18/1998 08:59'!setStream: aStream reading: isReading	"PRIVATE -- Initialization method."	aStream binary.	basePos := aStream position.	"Remember where we start.  Earlier part of file contains a class or method file-in.  Allow that to be edited.  We don't deal in absolute file locations."	byteStream := aStream.! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'nk 10/29/2000 12:15'!destString: aString 	realDst := self split: aString asString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst		doWithIndex: [:line :realIndex | 			dstLines				add: (self formatLine: line).			dstMap add: realIndex].	dstPos := PluggableDictionary new: dstLines size.	dstPos hashBlock: self stringHashBlock.	dstLines		doWithIndex: [:line :index | (dstPos includesKey: line)				ifTrue: [(dstPos at: line)						add: index.					multipleMatches := true]				ifFalse: [dstPos						at: line						put: (OrderedCollection with: index)]]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sd 4/16/2003 09:16'!mailOut	"Email a compressed version of this changeset to the squeak-dev list, so that it can be shared with everyone.  (You will be able to edit the email before it is sent.)"	| userName message slips |	userName := MailSender userName.	self checkForConversionMethods.	Cursor write showWhile: [message := self buildMessageForMailOutWithUser: userName].	MailSender sendMessage: message.	Preferences suppressCheckForSlips ifTrue: [^ self].	slips := self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!MidiPrimTester methodsFor: 'private' stamp: 'jm 5/18/1998 12:48'!canTurnOnParameter: whichParameter	"Return true if the given MIDI parameter can be turned on. Leave the parameter in its orginal state."	| old canSet |	old := self primMIDIParameterGet: whichParameter.	self primMIDIParameterSet: whichParameter to: 1.	canSet := (self primMIDIParameterGet: whichParameter) = 1.	self primMIDIParameterSet: whichParameter to: old.	^ canSet! !!Project methodsFor: 'language' stamp: 'yo 8/11/2003 16:46'!setPaletteFor: aLanguageSymbol 	| prototype formKey form |	prototype := PaintBoxMorph prototype.	formKey := ('offPalette' , aLanguageSymbol) asSymbol.	form := Imports default imports				at: formKey				ifAbsent: [Imports default imports						at: #offPaletteEnglish						ifAbsent: []].	form isNil ifFalse: [prototype loadOffForm: form].	formKey := ('pressedPalette' , aLanguageSymbol) asSymbol.	form := Imports default imports				at: formKey				ifAbsent: [Imports default imports						at: #pressedPaletteEnglish						ifAbsent: []].	form isNil ifFalse: [prototype loadPressedForm: form].! !!ImageSegment methodsFor: 'statistics' stamp: 'ar 2/21/2001 19:22'!printSpaceAnalysisOn: aStream	"Capture statistics about the IS and print the number of instances per class and space usage"	| instCount instSpace sorted sum1 sum2 |	instCount := self doSpaceAnalysis.	instSpace := instCount last.	instCount := instCount first.	sorted := SortedCollection sortBlock:[:a1 :a2| a1 value >= a2 value].	instSpace associationsDo:[:a| sorted add: a].	sorted do:[:assoc|		aStream cr; nextPutAll: assoc key; tab.		aStream print: (instCount at: assoc key); nextPutAll:' instances '.		aStream print: assoc value; nextPutAll: ' bytes '.	].	sum1 := instCount inject: 0 into:[:sum :n| sum + n].	sum2 := instSpace inject: 0 into:[:sum :n| sum + n].	aStream cr; cr.	aStream print: sum1; nextPutAll:' instances '.	aStream print: sum2; nextPutAll: ' bytes '.! !!Utilities class methodsFor: 'fetching updates' stamp: 'tk 5/7/1998 17:03'!updateUrlLists	UpdateUrlLists ifNil: [UpdateUrlLists := OrderedCollection new].	^ UpdateUrlLists! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 3/28/2000 22:19'!tryToPutReference: anObject typeID: typeID	"PRIVATE -- If we support references for type typeID, and if	   anObject already appears in my output stream, then put a	   reference to the place where anObject already appears. If we	   support references for typeID but didn't already put anObject,	   then associate the current stream position with anObject in	   case one wants to nextPut: it again.	 Return true after putting a reference; false if the object still	   needs to be put.	 : Added support for weak refs. Split out outputReference:.	08:42 tk  references stores relative file positions."	| referencePosn nextPosn |	"Is it a reference type of object?"	(self isAReferenceType: typeID) ifFalse: [^ false].	"Have we heard of and maybe even written anObject before?"	referencePosn := references at: anObject ifAbsent:			["Nope. Remember it and let the sender write it."			references at: anObject put: (byteStream position - basePos).	"relative"			^ false].	"If referencePosn is an Integer, it's the stream position of anObject."	referencePosn isInteger ifTrue:		[self outputReference: referencePosn.	"relative"		^ true].	referencePosn == #none ifTrue: ["for DiskProxy"			references at: anObject put: (byteStream position - basePos).	"relative"			^ false].	"Else referencePosn is a collection of positions of weak-references to anObject.	 Make them full references since we're about to really write anObject."	references at: anObject put: (nextPosn := byteStream position) - basePos.	"store relative"	referencePosn do: [:weakRefPosn |			byteStream position: weakRefPosn + basePos.		"make absolute"			self outputReference: nextPosn - basePos].	"make relative"	byteStream position: nextPosn.		"absolute"	^ false! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'nk 7/29/2004 10:09'!timeStamp: aStream 	"Writes system version and current time on stream aStream."	| dateTime |	dateTime := Time dateAndTimeNow.	aStream nextPutAll: 'From ', SmalltalkImage current datedVersion, ' [', SmalltalkImage current lastUpdateString, '] on ', (dateTime at: 1) printString,						' at ', (dateTime at: 2) printString! !!SmartRefStream class methodsFor: 'i/o' stamp: 'tk 12/9/97 21:31'!read: aByteStream withClasses: structureArray	"Read an object off the stream, but first check structureArray against the current system."	| me |	me := self on: aByteStream.	me noHeader.	me structures: (structureArray at: 2).	me superclasses: (structureArray at: 4).	(me verifyStructure = 'conversion method needed') ifTrue: [^ nil].	^ super next! !!AbstractLauncher methodsFor: 'private' stamp: 'mir 7/29/1999 10:21'!parameters: startupParameters	parameters := startupParameters! !!ReferenceStream methodsFor: 'writing' stamp: 'tk 8/18/1998 08:38'!reset	"PRIVATE -- Reset my internal state.	   11/15-17/92 jhm: Added transients and fwdRefEnds.	   7/11/93 sw: Give substantial initial sizes to avoid huge time spent growing.	   9/3/93 sw: monster version for Sasha"	super reset.	references := IdentityDictionary new: 4096 * 5."	objects := IdentityDictionary new: 4096 * 5.	fwdRefEnds := IdentityDictionary new."	blockers ifNil: [blockers := IdentityDictionary new]. ! !!ResourceManager methodsFor: 'initialize' stamp: 'ar 2/27/2001 16:54'!reset	"Clean out everything"	resourceMap := WeakValueDictionary new.	loaded := Set new.	unloaded := Set new.! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'md 11/14/2003 17:17'!hashInteger: aPositiveInteger seed: seedInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in the production of random numbers"	| buffer dstIndex |	"Initialize totalA through totalE to their seed values."	totalA := ThirtyTwoBitRegister new		load: ((seedInteger bitShift: -128) bitAnd: 16rFFFFFFFF).	totalB := ThirtyTwoBitRegister new		load: ((seedInteger bitShift: -96) bitAnd: 16rFFFFFFFF).	totalC := ThirtyTwoBitRegister new		load: ((seedInteger bitShift: -64) bitAnd: 16rFFFFFFFF).	totalD := ThirtyTwoBitRegister new		load: ((seedInteger bitShift: -32) bitAnd: 16rFFFFFFFF).	totalE := ThirtyTwoBitRegister new		load: (seedInteger bitAnd: 16rFFFFFFFF).	self initializeTotalsArray.	"pad integer with zeros"	buffer := ByteArray new: 64.	dstIndex := 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!ResourceCollector methodsFor: 'accessing' stamp: 'ar 2/27/2001 20:39'!baseUrl: aString	baseUrl := aString.	baseUrl isEmpty ifFalse:[		baseUrl last = $/ ifFalse:[baseUrl := baseUrl copyWith: $/].	].! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'nk 6/2/2006 10:22'!removeAllLineFeeds	"Smalltalk removeAllLineFeeds"	"Scan all methods for source code with lineFeeds.	Replaces all occurrences of <CR><LF> or <LF> by <CR>.	When done, offers to display an Inspector containing the message	names grouped by author initials.	In this dictionary, the key 'OK' contains the methods that had literals that contained <LF> characters."	| n authors totalStripped totalOK |	'Scanning sources for LineFeeds.This will take a few minutes...'		displayProgressAt: Sensor cursorPoint		from: 0		to: CompiledMethod instanceCount		during: [:bar | 			n := 0.			authors := self						removeAllLineFeedsQuietlyCalling: [:cls :sel | (n := n + 1) \\ 100 = 0								ifTrue: [bar value: n]]].	totalStripped := authors				inject: 1				into: [:sum :set | sum + set size].	totalOK := (authors at: 'OK') size.	totalStripped := totalStripped - totalOK.	Transcript cr; show: totalStripped printString , ' methods stripped of LFs.'.	Transcript cr; show: totalOK printString , ' methods still correctly contain LFs.'.	(self confirm: 'Do you want to see the affected methods?')		ifTrue: [authors inspect]! !!Project methodsFor: 'menu messages' stamp: 'sw 11/22/2001 08:40'!assureNavigatorPresenceMatchesPreference	"Make sure that the current project conforms to the presence/absence of the navigator"	| navigator navType wantIt |	Smalltalk isMorphic ifFalse: [^ self].	wantIt :=  Preferences classicNavigatorEnabled and: [Preferences showProjectNavigator].	navType := ProjectNavigationMorph preferredNavigator.	navigator := world findA: navType.	wantIt		ifFalse:			[navigator ifNotNil: [navigator delete]]		ifTrue:			[navigator isNil ifTrue: 				[(navigator := navType new)					bottomLeft: world bottomLeft;					openInWorld: world]]! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ar 4/10/2005 22:19'!writeToFileWithSymbols	| symbols nonSymbols pound |	state = #extracted ifFalse: [self error: 'wrong state'].	segmentName ifNil: [		segmentName := (FileDirectory localNameFor: fileName) sansPeriodSuffix].		"OK that still has number on end.  This is an unusual case"	fileName := self class uniqueFileNameFor: segmentName.	symbols := OrderedCollection new.	nonSymbols := OrderedCollection new.	pound := '#' asSymbol.	outPointers do:		[:s | 		((s isSymbol) and: [s isLiteral and: [s ~~ pound]])			ifTrue: [symbols addLast: s]			ifFalse: [symbols addLast: pound.  nonSymbols addLast: s]].	(self class segmentDirectory newFileNamed: fileName)		store: symbols asArray; cr;		nextPutAll: segment; close.	outPointers := nonSymbols asArray.	state := #onFileWithSymbols! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 8/18/2000 16:50'!useUpMemoryWithTinyObjects 	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemoryWithTinyObjects"	| b |  "First use up most of memory."	b := String new: self bytesLeft - self lowSpaceThreshold - 100000.	b := b.  "Avoid unused value warning"	(1 to: 10000) collect: [:i | BitBlt new]! !!SmartRefStream class methodsFor: 'utilities' stamp: 'RAA 7/9/2000 05:35'!streamedRepresentationOf: anObject	| file |	file := (RWBinaryOrTextStream on: (ByteArray new: 5000)).	file binary.	(self on: file) nextPut: anObject.	file close.	^file contents! !!ChangeSet methodsFor: 'accessing' stamp: ''!name: anObject	name := anObject! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sd 4/17/2003 21:04'!decommissionTheAllCategory	"Utilities decommissionTheAllCategory"	"Moves all methods that are in a category named 'all' into the default 'as yet unclassified' category"	| org aCategory methodCount classCount any |	self flag: #ShouldBeMovedIntoClassOrganization. "sd"	methodCount := 0.	classCount := 0.	self systemNavigation allBehaviorsDo:		[:aClass | org := aClass organization.			any := false.			aClass selectorsDo:				[:aSelector |					aCategory := org categoryOfElement: aSelector.					aCategory = #all ifTrue:						[org classify: aSelector under: ClassOrganizer default suppressIfDefault: false.						methodCount := methodCount + 1.						any := true]].			any ifTrue: [classCount := classCount + 1].			org removeEmptyCategories].	Transcript cr; show: methodCount printString, ' methods in ', classCount printString, ' classes movedfrom "all" to "as yet unclassified"'! !!ResourceManager methodsFor: 'loading' stamp: 'ar 5/30/2001 23:11'!installResource: aResource from: aStream locator: loc	| repl |	aResource ifNil:[^false]. "it went away, so somebody might have deleted it"	(aStream == nil or:[aStream size = 0]) ifTrue:[^false]. "error?!!"	repl := aResource clone readResourceFrom: aStream asUnZippedStream.	repl ifNotNil:[		aResource replaceByResource: repl.		unloaded remove: loc.		loaded add: loc.		^true	].	^false! !!ChangeSet class methodsFor: 'scanning' stamp: 'ar 7/16/2005 20:19'!scanVersionsOf: method class: class meta: meta category: cat selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp changeList file |	changeList := OrderedCollection new.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:[:x | x ifNotNil:[x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil] whileTrue:[		file position: (0 max: position-150).  "Skip back to before the preamble"		preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-3) = #stamp: ifTrue:[					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size-2.					prevPos := tokens last.					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.					prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos.				] ifFalse: ["Old format gives no stamp; prior pointer in two parts"					prevPos := tokens at: tokens size-2.					prevFileIndex := tokens last.				].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]			].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-1) = #stamp: ifTrue: [					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size.			]		]. 		changeList add: (ChangeRecord new file: file position: position type: #method						class: class name category: cat meta: meta stamp: stamp).		position := prevPos.		prevPos notNil ifTrue:[file := sourceFilesCopy at: prevFileIndex].	].	sourceFilesCopy do: [:x | x ifNotNil:[x close]].	^changeList! !!ExternalDropHandler class methodsFor: 'private' stamp: 'mir 1/10/2002 15:57'!registeredHandlers	RegisteredHandlers ifNil: [RegisteredHandlers := OrderedCollection new].	^RegisteredHandlers! !!Project methodsFor: 'release' stamp: 'RAA 5/10/2001 12:58'!deletingProject: aProject	"Clear my previousProject link if it points at the given Project, which is being deleted."	self flag: #bob.		"zapping projects"	parentProject == aProject ifTrue: [		parentProject := parentProject parent	].	previousProject == aProject		ifTrue: [previousProject := nil].	nextProject == aProject		ifTrue:	[nextProject := nil]! !!MessageTally class methodsFor: 'spying' stamp: 'nk 3/8/2004 10:35'!spyOnProcess: aProcess forMilliseconds: msecDuration toFileNamed: fileName 	"Spy on the evaluation of aProcess. Write the data collected on a file  	named fileName. Will overwrite fileName"	| file node |	node := self new.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	file := FileStream fileNamed: fileName.	node report: file;		 close.	file close! !!SecurityManager methodsFor: 'initialize-release' stamp: 'ar 2/6/2001 16:23'!flushSecurityKeys	"Flush all keys"	privateKeyPair ifNotNil:[		self flushSecurityKey: privateKeyPair first.		self flushSecurityKey: privateKeyPair last.	].	privateKeyPair := nil.	trustedKeys do:[:key| self flushSecurityKey: key].	trustedKeys := #().! !!ImageSegment methodsFor: 'read/write segment' stamp: 'gk 2/24/2004 23:53'!install	"This operation retrieves the segment if necessary from file storage, installs it in memory, and replaces (using become:) all the root stubs with the reconstructed roots of the segment."	| newRoots |	state = #onFile ifTrue: [self readFromFile].	state = #onFileWithSymbols ifTrue: [self readFromFileWithSymbols.		endMarker := segment nextObject. 	"for enumeration of objects"		endMarker == 0 ifTrue: [endMarker := 'End' clone]].	(state = #active) | (state = #imported) ifFalse: [self errorWrongState].	newRoots := self loadSegmentFrom: segment outPointers: outPointers.	state = #imported 		ifTrue: ["just came in from exported file"			arrayOfRoots := newRoots]		ifFalse: [			arrayOfRoots elementsForwardIdentityTo: newRoots].	state := #inactive.	Beeper beepPrimitive! !!RealEstateAgent class methodsFor: 'settings' stamp: 'RAA 11/21/1999 22:55'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent := self maximumUsableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea := self maximumUsableArea insetBy: (			self scrollBarSetback @ self screenTopSetback extent: 0@0		).		"Number to be staggered at each corner (less on small screens)"		maxLevel := allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid := allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: StandardSize "600@400"].	width := (strips := self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height := (strips := self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!DataStream class methodsFor: 'as yet unclassified' stamp: ''!example    "An example and test of DataStream/ReferenceStream.     11/19/92 jhm: Use self testWith:."    "DataStream example"    "ReferenceStream example"    | input sharedPoint |    "Construct the test data."    input := Array new: 9.    input at: 1 put: nil.    input at: 2 put: true.    input at: 3 put: (Form extent: 63 @ 50 depth: 8).		(input at: 3) fillWithColor: Color lightBlue.    input at: 4 put: #(3 3.0 'three').    input at: 5 put: false.    input at: 6 put: 1024 @ -2048.    input at: 7 put: #x.    input at: 8 put: (Array with: (sharedPoint := 0 @ -30000)).    input at: 9 put: sharedPoint.    "Write it out, read it back, and return it for inspection."    ^ self testWith: input! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/16/2005 18:02'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble isEmptyOrNil)		ifTrue: [preamble := self preambleTemplate]! !!ResourceCollector methodsFor: 'resource writing' stamp: 'ar 9/23/2002 03:34'!writeResourceForm: aForm locator: aLocator	"Store the given form on a file. Return an array with the name and the size of the file"	| fName fStream fullSize result writerClass |	aLocator ifNotNil:[		result := self writeResourceForm: aForm fromLocator: aLocator.		result ifNotNil:[^result]		"else fall through"	].	fName := localDirectory nextNameFor:'resource' extension:'form'.	fStream := localDirectory newFileNamed: fName.	fStream binary.	aForm storeResourceOn: fStream.false ifTrue:[	"What follows is a Really, REALLY bad idea. I leave it in as a reminder of what you should NOT do. 	PART I: Using JPEG or GIF compression on forms where we don't have the original data means loosing both quality and alpha information if present..."	writerClass := ((Smalltalk includesKey: #JPEGReaderWriter2)		and: [(Smalltalk at: #JPEGReaderWriter2) new isPluginPresent])		ifTrue: [(Smalltalk at: #JPEGReaderWriter2)]		ifFalse: [GIFReadWriter].	writerClass putForm: aForm onStream: fStream.	fStream open.	fullSize := fStream size.	fStream close.].	"Compress contents here"true ifTrue:[	"...PART II: Using the builtin compression which combines RLE+ZIP is AT LEAST AS GOOD as PNG and how much more would you want???"	fStream position: 0.	fStream compressFile.	localDirectory deleteFileNamed: fName.	localDirectory rename: fName, FileDirectory dot, 'gz' toBe: fName.	fStream := localDirectory readOnlyFileNamed: fName.	fullSize := fStream size.	fStream close.].	^{fName. fullSize}! !!Project methodsFor: 'file in/out' stamp: 'KR 12/16/2005 10:07'!storeManifestFileIn: aFileDirectory	| file |	file := aFileDirectory forceNewFileNamed: (self name, FileDirectory dot,'manifest').	file ifNil: [^ self].	file converter: UTF8TextConverter new.	self storeAttributesOn: file.	file close.! !!Project methodsFor: 'initialization' stamp: 'di 7/19/1999 15:00'!installPasteUpAsWorld: pasteUpMorph	"(ProjectViewMorph newMorphicProjectOn: aPasteUpMorph) openInWorld."	world := pasteUpMorph beWorldForProject: self! !!SystemDictionary methodsFor: 'shrinking' stamp: 'nk 4/28/2004 10:24'!presumedSentMessages   | sent |"Smalltalk presumedSentMessages"	"The following should be preserved for doIts, etc"	sent := IdentitySet new.	#( rehashWithoutBecome compactSymbolTable rebuildAllProjects		browseAllSelect:  lastRemoval		scrollBarValue: vScrollBarValue: scrollBarMenuButtonPressed: 		withSelectionFrom:  to: removeClassNamed:		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib		newDepth: restoreAfter: forgetDoIts zapAllMethods obsoleteClasses		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher unusedClasses) do:		[:sel | sent add: sel].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sent add: sel].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sent add: sel].	^ sent! !!Utilities class methodsFor: 'fetching updates' stamp: 'nk 6/26/2003 21:12'!serverUrls 	"Return the current list of server URLs.  For code updates.  Format of UpdateUrlLists is #( ('squeak updates' ('url1' 'url2'))    ('some other updates' ('url3' 'url4')))"	| list |	list := UpdateUrlLists first last.	"If there is a dead server, return a copy with that server last" 	Socket deadServer ifNotNil: [		list clone withIndexDo: [:aName :ind |		(aName beginsWith: Socket deadServer) ifTrue: [			list := list asOrderedCollection.	"and it's a copy"			list removeAt: ind.			list addLast: aName]]	].	^ list asArray! !!SmalltalkImage methodsFor: 'sources, changes log' stamp: 'tpr 12/15/2003 15:58'!saveImageInFileNamed: aString	| fullImageName |	fullImageName := (FileDirectory default fullNameFor: aString).	(FileDirectory default directoryNamed:(FileDirectory dirPathFor: fullImageName )) assureExistence.	self		changeImageNameTo: fullImageName;		closeSourceFiles;		openSourceFiles;  "so SNAPSHOT appears in new changes file"		saveImageSegments;		snapshot: true andQuit: false! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'al 1/13/2006 00:51'!classNames	"Answer a SortedCollection of all class names."	| names |	cachedClassNames == nil ifTrue:		[names := OrderedCollection new: self size.		self do: 			[:cl | (cl isInMemory				and: [(cl isKindOf: Class)					and: [(cl name beginsWith: 'AnObsolete') not]])				ifTrue: [names add: cl name]].		cachedClassNames := names asSortedCollection].	^ cachedClassNames! !!ChangeSet class methodsFor: 'enumerating' stamp: 'ar 7/15/2005 21:12'!gatherChangeSets		"ChangeSet gatherChangeSets"	"Collect any change sets created in other projects"	| allChangeSets obsolete |	allChangeSets := AllChangeSets asSet.	ChangeSet allSubInstances do: [:each |		(allChangeSets includes: each) == (obsolete := each isMoribund) ifTrue:[			obsolete				ifTrue: ["Was included and is obsolete."						AllChangeSets remove: each]				ifFalse: ["Was not included and is not obsolete."						AllChangeSets add: each]]].	^ AllChangeSets! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/11/2003 13:56'!fixDependents	"They are not used much, but need to be right"	| newDep newModel |	DependentsFields associationsDo: [:pair |		pair value do: [:dep | 			newDep := references at: dep ifAbsent: [nil].			newDep ifNotNil: [				newModel := references at: pair key ifAbsent: [pair key].				newModel addDependent: newDep]]].! !!Project methodsFor: 'file in/out' stamp: 'rbb 2/18/2005 08:58'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder |self halt.  "unused"	"world == World ifTrue: [^ false]."		"self inform: 'Can''t send the current world out'."	world isMorph ifFalse: [		self projectParameters at: #isMVC put: true.		^ false].	"Only Morphic projects for now"	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers. 	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	ScriptEditorMorph writingUniversalTiles: (self projectParameterAt: #universalTiles ifAbsent: [false]).	holder := Project allProjects.	"force them in to outPointers, where DiskProxys are made"	"Just export me, not my previous version"	revertSeg := self projectParameters at: #revertToMe ifAbsent: [nil].	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots := OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).	roots := roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	catList do: [:sysCat | 		(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |			roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].	is := ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is := ImageSegment new copyFromRootsForExport: roots asArray)"	is state = #tooBig ifTrue: [^ false].	str := ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str := str, '\Project''s own world is not in the segment.' withCRs].	str isEmpty ifFalse: [		ans := (UIManager default				 chooseFrom: #('Do not write file' 'Write file anyway' 'Debug')				 title: str).		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].			^ false].		ans = 3 ifTrue: [self halt: 'Segment not written']].	is writeForExportWithSources: aFileName inDirectory: aDirectory.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	world flapTabs do: [:ft | 			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj class == ScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!FilePackage methodsFor: 'conflict checker' stamp: 'pk 10/17/2006 09:39'!checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet pseudoClass: pseudoClass selector: selector	"Returns the source code for a conflict if a conflict is found, otherwise returns nil."	| classOrMeta allChangeSets moreRecentChangeSets conflictingChangeSets changeRecordSource classAndMethodPrintString |	classAndMethodPrintString := pseudoClass name, (pseudoClass hasMetaclass ifTrue: [' class'] ifFalse: ['']), '>>', selector asString.	changeRecordSource := pseudoClass sourceCode at: selector.	changeRecordSource isText		ifTrue: [changeRecordSource := Text					fromString: 'method: ', classAndMethodPrintString, ' was removed']		ifFalse: [changeRecordSource stamp isEmptyOrNil ifTrue:					[self notify: 'Warning: ', classAndMethodPrintString, ' in ', self packageName, ' has no timestamp/initials!!']].	pseudoClass exists ifFalse:		[(self classes at: pseudoClass name) hasDefinition			ifTrue: [^ nil  "a method was added for a newly defined class; not a conflict"]			ifFalse: [self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString, '... class ', pseudoClass name asString, ' does not exist in the image and is not defined in the file'.					^ changeRecordSource]].	classOrMeta := pseudoClass realClass.	"Only printout the replacing methods here, but we still check for removed methods too in the rest of this method."	(self class verboseConflicts and: [classOrMeta includesSelector: selector])		ifTrue: [self class logCr; log: '...checking ', classOrMeta asString, '>>', selector asString].	allChangeSets := ChangesOrganizer allChangeSets.	moreRecentChangeSets := allChangeSets				copyFrom: (allChangeSets indexOf: updateNumberChangeSet)				to: (allChangeSets size).	conflictingChangeSets := (moreRecentChangeSets select:		[:cs | (cs atSelector: selector class: classOrMeta) ~~ #none]).	conflictingChangeSets isEmpty ifTrue: [^ nil].	self class logCr; log: 'CONFLICT found for ', classAndMethodPrintString,				(' with newer changeset' asPluralBasedOn: conflictingChangeSets).	conflictingChangeSets do: [:cs | self class log: ' ', cs name].	^ changeRecordSource! !!TwoLevelSet methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 23:22'!remove: aPoint	| lev2 |	lev2 := firstLevel at: aPoint x ifAbsent: [^self].	lev2 remove: aPoint y ifAbsent: [].	lev2 isEmpty ifTrue: [firstLevel removeKey: aPoint x].! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:59'!assimilateAllChangesIn: otherRecord	| selector changeRecord changeType |	otherRecord isClassRemoval ifTrue: [^ self noteChangeType: #remove].	otherRecord allChangeTypes do:		[:chg | self noteChangeType: chg fromClass: self realClass].	otherRecord methodChanges associationsDo:		[:assn | selector := assn key. changeRecord := assn value.		changeType := changeRecord changeType.		(changeType == #remove or: [changeType == #addedThenRemoved])			ifTrue:				[changeType == #addedThenRemoved					ifTrue: [self atSelector: selector put: #add].				self noteRemoveSelector: selector priorMethod: nil						lastMethodInfo: changeRecord methodInfoFromRemoval]			ifFalse: 				[self atSelector: selector put: changeType]].! !!SmartRefStream methodsFor: 'read write' stamp: 'tk 10/10/2000 13:36'!recordImageSegment: refs	"Besides the objects being written out, record the structure of instances inside the image segment we are writing out."	| cls list |	"Do not record Player class inst vars.  They are in the segement."	refs keysDo: [:each | 		cls := each class.		cls isObsolete ifTrue: [self error: 'Trying to write ', cls name].		cls class == Metaclass 			ifFalse: [structures at: cls name put: false.				(each isKindOf: ImageSegment) ifTrue: [					each outPointers do: [:out |						(out isKindOf: Class) ifTrue: [							structures at: out theNonMetaClass name put: false].						out class == DiskProxy ifTrue: [							out simpleGlobalOrNil ifNotNil: [								(out simpleGlobalOrNil isKindOf: Class) ifTrue: [									structures at: out simpleGlobalOrNil name put: false]]]].					"each arrayOfRoots do: [:rr | (rr isKindOf: Class) ifTrue: [							structures at: rr theNonMetaClass name put: false]]."					 	"all classes in roots are local to seg"]]].	list := refs at: #BlockReceiverClasses ifAbsent: [^ self].	list do: [:meta | structures at: meta name put: false].		"Just the metaclasses whose instances are block receivers.  Otherwise metaclasses are not allowed."! !!SystemNavigation methodsFor: 'query' stamp: 'sd 9/23/2004 22:06'!obsoleteClasses   	"SystemNavigation default obsoleteClasses inspect"	"NOTE:  Also try inspecting comments below"	| obs c |	obs := OrderedCollection new.  Smalltalk garbageCollect.	Metaclass allInstancesDo:		[:m | c := m soleInstance.		(c ~~ nil and: ['AnOb*' match: c name asString])			ifTrue: [obs add: c]].	^ obs asArray"Likely in a ClassDict or Pool...(Association allInstances select: [:a | (a value isKindOf: Class) and: ['AnOb*' match: a value name]]) asArray""Obsolete class refs or super pointer in last lit of a method...| n l found |Smalltalk browseAllSelect:	[:m | found := false.	1 to: m numLiterals do:		[:i | (((l := m literalAt: i) isMemberOf: Association)				and: [(l value isKindOf: Behavior)				and: ['AnOb*' match: l value name]])			ifTrue: [found := true]].	found]"! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'hh 8/3/2000 18:18'!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations := 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes := Integer primesUpTo: 2000.		SmallPrimes := SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor := SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ p = factor].	pMinusOne := p - 1.	b := self logOfLargestPowerOfTwoDividing: pMinusOne.	m := pMinusOne // (2 raisedTo: b).	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r := Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a := (r next * 16rFFFFFF) truncated.		j := 0.		z := (a raisedTo: m modulo: p) normalize.		couldBePrime := z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime := true]				ifFalse: [					(j := j + 1) < b						ifTrue: [z := (z * z) \\ p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/15/2005 21:53'!askAddedInstVars: classList	| pairList pairClasses index pls newStruct oldStruct |	"Ask the author whether these newly added inst vars need to be non-nil"	pairList := OrderedCollection new.	pairClasses := OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls |		newStruct := (cls allInstVarNames).		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		newStruct do: [:instVarName |			(oldStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index := UIManager default 		chooseFrom: pairList, #('all of these need a non-nil value'						'all of these are OK with a nil value')		title:'These instance variables were added.When an old project comes in, newly added instance variables will have the value nil.Click on items to remove them from the list.Click on any for which nil is an OK value.'.	(index <= (pls := pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1)) "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!Preferences class methodsFor: 'personalization' stamp: 'sw 4/18/2002 18:02'!restorePersonalPreferences	"Restore all the user's saved personal preference settings"	| savedPrefs |	savedPrefs := self parameterAt: #PersonalDictionaryOfPreferences ifAbsent: [^ self inform: 'There are no personal preferences saved in this image yet'].	savedPrefs associationsDo:		[:assoc | (self preferenceAt: assoc key ifAbsent: [nil]) ifNotNilDo:			[:pref | pref preferenceValue: assoc value preferenceValue]]! !!MidiPrimTester methodsFor: 'tests' stamp: 'jm 5/18/1998 15:33'!getInputForSeconds: seconds onPort: portNum	"Collect MIDI input from the given port for the given number of seconds, and answer a string describing the data read."	"MidiPrimTester new getInputForSeconds: 5 onPort: 0"	| buf bufList endTime n midiStartTime s t |	"collect the data"	self openPort: portNum andDo: [		buf := ByteArray new: 1000.		bufList := OrderedCollection new.		midiStartTime := self primMIDIGetClock.		endTime := Time millisecondClockValue + (seconds * 1000).		[Time millisecondClockValue < endTime] whileTrue: [			n := self primMIDIReadPort: portNum into: buf.			n > 0 ifTrue: [bufList add: (buf copyFrom: 1 to: n)].			(Delay forMilliseconds: 5) wait]].	"format the data into a string"	s := WriteStream on: String new.	s cr.	bufList do: [:b |		t := (self bufferTimeStampFrom: b) - midiStartTime.		s print: t.		s nextPutAll: ': '.		5 to: b size do: [:i | s print: (b at: i); space].		s cr].	^ s contents! !!Project methodsFor: 'file in/out' stamp: 'ar 5/30/2001 23:34'!compressFilesIn: tempDir to: localName in: localDirectory resources: collector	"Compress all the files in tempDir making up a zip file in localDirectory named localName"	| archive entry urlMap archiveName |	urlMap := Dictionary new.	collector locatorsDo:[:loc|		"map local file names to urls"		urlMap at: (tempDir localNameFor: loc localFileName) put: loc urlString.		ResourceManager cacheResource: loc urlString inArchive: localName].	archive := ZipArchive new.	tempDir fileNames do:[:fn|		archiveName := urlMap at: fn ifAbsent:[fn].		entry := archive addFile: (tempDir fullNameFor: fn) as: archiveName.		entry desiredCompressionMethod: ZipArchive compressionStored.	].	archive writeToFileNamed: (localDirectory fullNameFor: localName).	archive close.	tempDir fileNames do:[:fn|		tempDir deleteFileNamed: fn ifAbsent:[]].	localDirectory deleteDirectory: tempDir localName.! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'tk 3/7/2001 15:29'!objInMemory: ClassSymbol	| cls |	"Test if this global is in memory and return it if so."	cls := Smalltalk at: ClassSymbol ifAbsent: [^ nil].	^ cls isInMemory ifTrue: [cls] ifFalse: [nil].! !!Locale class methodsFor: 'private' stamp: 'ka 2/18/2005 02:40'!migrateSystem	"Locale migrateSystem"	"Do all the necessary operations to switch to the new Locale environment."	LocaleChangeListeners := nil.	self		addLocalChangedListener: HandMorph;		addLocalChangedListener: Clipboard;		addLocalChangedListener: Vocabulary;		addLocalChangedListener: PartsBin;		addLocalChangedListener: Project;		addLocalChangedListener: PaintBoxMorph;		yourself! !!CodeLoader class methodsFor: 'accessing' stamp: 'mir 1/11/2000 13:45'!defaultBaseURL: aURLString	DefaultBaseURL := aURLString! !!Project class methodsFor: 'instance creation' stamp: 'RAA 11/16/2000 12:07'!newMorphic	| new |	"ProjectView open: Project newMorphic"	new := self basicNew.	self addingProject: new.	new initMorphic.	^new! !!Preferences class methodsFor: 'get/set' stamp: 'sw 4/12/2001 23:29'!enable: aSymbol	"Shorthand access to enabling a preference of the given name.  If there is none in the image, conjure one up"	| aPreference |	aPreference := self preferenceAt: aSymbol ifAbsent:		[self addPreference: aSymbol category: 'unclassified' default: true balloonHelp: 'this preference was added idiosyncratically and has no help message.'.		self preferenceAt: aSymbol].	aPreference preferenceValue: true! !!ImageSegmentRootStub class methodsFor: 'settings' stamp: 'di 2/11/2000 12:33'!stopLoggingFaults  "ImageSegmentRootStub stopLoggingFaults"	FaultLogs := Dictionary new.	LoggingFaults := false.! !!Project methodsFor: 'menu messages' stamp: 'sd 5/23/2003 15:16'!enterForEmergencyRecovery	"This version of enter invokes an absolute minimum of mechanism.	An unrecoverable error has been detected in an isolated project.	It is assumed that the old changeSet has already been revoked.	No new process gets spawned here.  This will happen in the debugger."	self isCurrentProject ifTrue: [^ self].	CurrentProject saveState.	CurrentProject := self.	Display newDepthNoRestore: displayDepth.	ChangeSet  newChanges: changeSet.	TranscriptStream newTranscript: transcript.	World pauseEventRecorder.	world isMorph		ifTrue:			["Entering a Morphic project"			World := world.			world install.			world triggerOpeningScripts]		ifFalse:			["Entering an MVC project"			World := nil.			Smalltalk at: #ScheduledControllers put: world.			ScheduledControllers restore].	UIProcess := Processor activeProcess.! !!ProjectHistory methodsFor: 'updating' stamp: 'RAA 7/10/2000 15:57'!changed	ChangeCounter := (ChangeCounter ifNil: [0]) + 1.	super changed.! !!Utilities class methodsFor: 'common requests' stamp: 'nk 8/30/2004 08:02'!eval: aString	"Evaluate the string in a neutral context, and under certain circumstances print the 	result in the transcript"	| result |	result := Compiler new evaluate: aString in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 5/3/1998 20:12'!openScratchWorkspaceLabeled: labelString contents: initialContents	"Open a scratch text view with the given label on the given string. A scratch text view won't warn you about unsaved changes when you close it."	"Utilities openScratchWorkspaceLabeled: 'Scratch' contents: 'Hello. world!!'"	| model topView stringView |	model := StringHolder new contents: initialContents.	topView := StandardSystemView new.	topView		model: model;		label: labelString;		minimumSize: 180@120.	topView borderWidth: 1.	stringView := PluggableTextView on: model 		text: #contents		accept: nil		readSelection: #contentsSelection		menu: #codePaneMenu:shifted:.	stringView		askBeforeDiscardingEdits: false;		window: (0@0 extent: 180@120).	topView addSubView: stringView.	topView controller open.! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'jm 12/14/1999 13:33'!stringToSignature: aString	"Answer the signature stored in the given string. A signature string has the format:		 '[DSA digital signature <r> <s>]'	where <r> and <s> are large positive integers represented by strings of hexidecimal digits."	| prefix stream r s |	prefix := '[DSA digital signature '.	(aString beginsWith: prefix) ifFalse: [self error: 'bad signature prefix'].	stream := ReadStream on: aString.	stream position: prefix size.	r := Integer readFrom: stream base: 16.	stream next.	s := Integer readFrom: stream base: 16.	^ Array with: r with: s! !!ImageSegment methodsFor: 'compact classes' stamp: 'tk 12/21/1999 21:53'!compactIndexAt: ind	| word |	"Look in this header word in the segment and find it's compact class index. *** Warning: When class ObjectMemory change, be sure to change it here. *** "	((word := segment at: ind) bitAnd: 3) = 2 ifTrue: [^ 0].  "free block"	^ (word >> 12) bitAnd: 16r1F 	"Compact Class field of header word"! !!Project methodsFor: 'resources' stamp: 'ar 3/2/2001 15:16'!storeResourceList: collector in: fd	"Store a list of all used resources in the given directory. Used for maintenance."	| file rcName |	rcName := self resourceDirectoryName,'.rc'.	file := fd forceNewFileNamed: rcName.	collector locatorsDo:[:loc| file nextPutAll: loc urlString; cr].	file close.	file := fd readOnlyFileNamed: rcName.	file compressFile.	fd deleteFileNamed: rcName ifAbsent:[].! !!ReferenceStream methodsFor: 'statistics' stamp: 'ls 10/10/1999 13:27'!statisticsOfRefs	"Analyze the information in references, the objects being written out"	| parents n kids nm ownerBags tallies owners objParent |	parents := IdentityDictionary new: references size * 2.	n := 0.	'Finding Owners...'	displayProgressAt: Sensor cursorPoint	from: 0 to: references size	during: [:bar |	references keysDo:		[:parent | bar value: (n := n+1).		kids := parent class isFixed			ifTrue: [(1 to: parent class instSize) collect: [:i | parentinstVarAt: i]]			ifFalse: [parent class isBits ifTrue: [Array new]					 ifFalse: [(1 to: parent basicSize) collect: [:i | parent basicAt:i]]].		(kids select: [:x | references includesKey: x])			do: [:child | parents at: child put: parent]]].	ownerBags := Dictionary new.	tallies := Bag new.	n := 0.	'Tallying Owners...'	displayProgressAt: Sensor cursorPoint	from: 0 to: references size	during: [:bar |	references keysDo:  "For each class of obj, tally a bag of ownerclasses"		[:obj | bar value: (n := n+1).		nm := obj class name.		tallies add: nm.		owners := ownerBags at: nm ifAbsent: [ownerBags at: nm put: Bag new].		(objParent := parents at: obj ifAbsent: [nil]) == nil			ifFalse: [owners add: objParent class name]]].	^ String streamContents:		[:strm |  tallies sortedCounts do:			[:assn | n := assn key.  nm := assn value.			owners := ownerBags at: nm.			strm cr; nextPutAll: nm; space; print: n.			owners size > 0 ifTrue:				[strm cr; tab; print: owners sortedCounts]]]! !!MethodReference methodsFor: 'setting' stamp: 'RAA 5/28/2001 06:04'!setClassSymbol: classSym classIsMeta: isMeta methodSymbol: methodSym stringVersion: aString 	classSymbol := classSym.	classIsMeta := isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'hh 8/3/2000 18:17'!computeSignatureForMessageHash: hash privateKey: privateKey	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."	| p q g x r s k tmp |	p := privateKey first.	q := privateKey second.	g := privateKey third.	x := privateKey fourth.	r := s := 0.	[r = 0 or: [s = 0]] whileTrue: [		k := self nextRandom160 \\ q.		r := (g raisedTo: k modulo: p) \\ q.		tmp := (hash + (x * r)) \\ q.		s := ((self inverseOf: k mod: q) * tmp) \\ q].	^ Array with: r with: s! !!ResourceCollector methodsFor: 'initialize' stamp: 'ar 3/3/2001 19:49'!initialize	| fd pvt |	originalMap := IdentityDictionary new.	stubMap := IdentityDictionary new.	locatorMap := IdentityDictionary new.	internalStubs := IdentityDictionary new.	fd := ScriptingSystem formDictionary.	pvt := ScriptingSystem privateGraphics asSet.	fd keysAndValuesDo:[:sel :form|		(pvt includes: sel) ifFalse:[			internalStubs at: form put:				(DiskProxy 					global: #ScriptingSystem					selector: #formAtKey:extent:depth:					args: {sel. form extent. form depth})]].! !!SystemNavigation methodsFor: 'query' stamp: 'sd 5/5/2003 09:18'!allSelectorsWithAnyImplementorsIn: selectorList 	"Answer the subset of the given list which represent method selectors 	which have at least one implementor in the system."	| good |	good := OrderedCollection new.	self allBehaviorsDo: [:class | selectorList				do: [:aSelector | (class includesSelector: aSelector)						ifTrue: [good add: aSelector]]].	^ good asSet asSortedArray" 	SystemNavigation new selectorsWithAnyImplementorsIn: #( contents 	contents: nuts)	"! !!ImageSegmentRootStub methodsFor: 'fetch from disk' stamp: 'di 3/4/2001 22:45'!doesNotUnderstand: aMessage 	 | segmentName |"Any normal message sent to this object is really intended for another object that is in a non-resident imageSegment.  Reinstall the segment and resend the message."	segmentName := imageSegment segmentName.	imageSegment install.	LoggingFaults ifTrue:		"Save the stack printout to show who caused the fault"		[FaultLogs at: Time millisecondClockValue printString			put: (String streamContents:				[:strm | 				strm nextPutAll: segmentName; cr.				strm print: self class; space; print: aMessage selector; cr.				(thisContext sender stackOfSize: 30)					do: [:item | strm print: item; cr]])].	"NOTE:  The following should really be (aMessage sentTo: self)		in order to recover properly from a fault in a super-send,		however, the lookupClass might be bogus in this case, and it's		almost unthinkable that the first fault would be a super send."	^ self perform: aMessage selector withArguments: aMessage arguments! !!Project methodsFor: 'flaps support' stamp: 'dgd 8/31/2003 19:42'!assureFlapIntegrity	"Make certain that the items on the disabled-global-flap list are actually global flaps, and if not, get rid of them.  Also, old (and damaging) parameters that held references to actual disabled flaps are cleansed"	| disabledFlapIDs currentGlobalIDs oldList |	Smalltalk isMorphic ifTrue:		[disabledFlapIDs := self parameterAt: #disabledGlobalFlapIDs ifAbsent: [Set new].		currentGlobalIDs := Flaps globalFlapTabsIfAny collect: [:f | f flapID].		oldList := Project current projectParameterAt: #disabledGlobalFlaps ifAbsent: [nil].		oldList ifNotNil:			[disabledFlapIDs := oldList collect: [:aFlap | aFlap flapID].			disabledFlapIDs addAll: {'Scripting' translated. 'Stack Tools' translated. 'Painting' translated}].		disabledFlapIDs := disabledFlapIDs select: [:anID | currentGlobalIDs includes: anID].		self projectParameterAt: #disabledGlobalFlapIDs put: disabledFlapIDs asSet.		self assureNavigatorPresenceMatchesPreference].	projectParameters ifNotNil:		[projectParameters removeKey: #disabledGlobalFlaps ifAbsent: []]! !!SystemVersion methodsFor: 'accessing' stamp: ''!date: newDate	date := newDate! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 7/15/2005 21:54'!askRemovedInstVars: classList	| pairList pairClasses index pls newStruct oldStruct |	"Ask the author whether these newly removed inst vars need to have their info saved"	pairList := OrderedCollection new.	pairClasses := OrderedCollection new.	"Class version numbers:  If it must change, something big happened.  Do need a conversion method then.  Ignore them here."	classList do: [:cls |		newStruct := (cls allInstVarNames).		oldStruct := (structures at: cls name ifAbsent: [#(0), newStruct]) allButFirst.		oldStruct do: [:instVarName |			(newStruct includes: instVarName) ifFalse: [				pairList add: cls name, ' ', instVarName.				pairClasses add: cls]]].	pairList isEmpty ifTrue: [^ #()].	[index := UIManager default 		chooseFrom: pairList, #('all of these need a conversion method'						'all of these have old values that can be erased')			title:'These instance variables were removed.When an old project comes in, instance variables that have been removed will lose their contents.Click on items to remove them from the list.Click on any whose value is unimportant and need not be saved.'.	(index <= (pls := pairList size)) & (index > 0) ifTrue: [		pairList removeAt: index.		pairClasses removeAt: index].	index = (pls + 2) ifTrue: ["all are OK" ^ #()].	pairList isEmpty | (index = (pls + 1))  "all need conversion, exit"] whileFalse.	^ pairClasses asSet asArray	"non redundant"! !!Project methodsFor: 'file in/out' stamp: 'yo 12/14/2004 19:01'!storeHtmlPageIn: aFileDirectory	"Prepare the HTML wrapper for the current project"	| file page |	file := aFileDirectory forceNewFileNamed: (self name, FileDirectory dot,'html').	file ifNil: [^self].	file converter: UTF8TextConverter new.	page := self htmlPagePrototype.	page := page copyReplaceAll: '$$PROJECT$$' with: self versionedFileName.	page := page copyReplaceAll: '$$WIDTH$$' with: world bounds width printString.	page := page copyReplaceAll: '$$HEIGHT$$' with: world bounds height printString.	page := page copyReplaceAll: String cr with: String lf. "not sure if necessary..."	file nextPutAll: page.	file close.! !!Preferences class methodsFor: 'parameters' stamp: 'jhm 10/15/97 17:31'!desktopColor: aColor	"Record a new desktop color preference."	DesktopColor := aColor.! !!DigitalSignatureAlgorithm class methodsFor: 'examples' stamp: 'RAA 5/31/2000 13:13'!writeExamplesToDisk	"Example of signing a message and verifying its signature. Used to create samples from one implementation that could later be tested with a different implementation"	"Note: Secure random numbers are needed for key generation and message signing, but not for signature verification. There is no need to call initRandomFromUser if you are merely checking a signature."	"DigitalSignatureAlgorithm writeExamplesToDisk"	| sig file keyList dsa msgList |	dsa := DigitalSignatureAlgorithm new.	dsa initRandomFromUser.	self inform: 'About to generate 5 key sets. Will take a while'.	keyList := {self testKeySet},((1 to: 5) collect: [ :ignore | self generateKeySet]).	msgList := {'This is a test...'. 'This is the second test period.'. 'And finally, a third message'}.	file := FileStream newFileNamed: 'dsa.test.out'.	[		msgList do: [ :msg |			keyList do: [ :keys |				sig := self sign: msg privateKey: keys first dsa: dsa.				(self verify: sig isSignatureOf: msg publicKey: keys last) ifTrue: [					file						nextChunkPut: sig;						nextChunkPut: msg;						nextChunkPut: keys last storeString.				] ifFalse: [					self error: 'ERROR!! Signature verification failed'				].			].		].	] ensure: [file close]! !!Utilities class methodsFor: 'fetching updates' stamp: 'mir 8/10/2001 12:30'!setUpdateServer: groupName	"Utilities setUpdateServer: 'Squeakland' "	| entry index |	entry := UpdateUrlLists detect: [:each | each first = groupName] ifNone: [^self].	index := UpdateUrlLists indexOf: entry.	UpdateUrlLists removeAt: index.	UpdateUrlLists addFirst: entry! !!NaturalLanguageFormTranslator class methodsFor: 'i/o' stamp: 'yo 1/13/2005 14:02'!loadFormsFrom: aStream	| rr pair inst |	rr := ReferenceStream on: aStream.	pair := rr next.	inst := self localeID: (LocaleID isoString: pair first).	pair second associationsDo: [:assoc |		inst name: assoc key form: assoc value.	].	^ inst.! !!MczInstaller methodsFor: 'utilities' stamp: 'avi 1/20/2004 11:13'!associate: tokens	| result |	result := Dictionary new.	tokens pairsDo: [:key :value | 					value isString ifFalse: [value := value collect: [:ea | self associate: ea]].					value = 'nil' ifTrue: [value := ''].					result at: key put: value].	^ result! !!ProjectHistory methodsFor: 'project lifetime' stamp: 'RAA 9/27/2000 20:27'!forget: aProject	| newTuple |	newTuple := {		aProject name.		aProject thumbnail.		aProject url.		WeakArray with: aProject.	}.	mostRecent := mostRecent reject: [ :each |		each fourth first == aProject or: [			each fourth first isNil & (each first = newTuple first)		].	].	self changed.	^newTuple! !!Project methodsFor: 'accessing' stamp: 'mir 6/26/2001 17:09'!storeNewPrimaryURL: aURLString	| oldResourceUrl |	oldResourceUrl := self resourceUrl.	urlList isEmptyOrNil ifTrue: [urlList := Array new: 1].	urlList at: 1 put: aURLString.	self lastDirectory: nil.	self resourceManager adjustToNewServer: self resourceUrl from: oldResourceUrl! !!Project class methodsFor: 'utilities' stamp: 'RAA 6/3/2000 18:28'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	UIProcess := aProcess.	UIProcess resume! !RealEstateAgent initialize!MidiPrimTester initialize!ChangeSet initialize!DigitalSignatureAlgorithm initialize!Project initialize!SystemDictionary initialize!SecureHashAlgorithm initialize!ExternalSemaphoreTable initialize!DataStream initialize!HTTPLoader initialize!Utilities initialize!