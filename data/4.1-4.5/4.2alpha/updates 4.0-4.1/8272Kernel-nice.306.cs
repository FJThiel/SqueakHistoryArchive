"Change Set:		8272Kernel-nice.306Kernel-nice.306:Speed up highBit and lowBit according to http://bugs.squeak.org/view.php?id=7113This is usefull for algorithms like DSA.This version has a cache of known result for bytes.Prerequisite: ByteArray literals #[]{[100000 timesRepeat: [123456798 highBit]] timeToRun.[100000 timesRepeat: [122 highBit]] timeToRun.[100000 timesRepeat: [12 highBit]] timeToRun.[100000 timesRepeat: [3950591 lowBit]] timeToRun.[100000 timesRepeat: [3950592 lowBit]] timeToRun.[100000 timesRepeat: [8 lowBit]] timeToRun.[100000 timesRepeat: [(-1073741824) lowBit]] timeToRun.}'OLD' #(186 139 138 92 165 134 1965) /'NEW' #(115 96 96 83 97 79 743)'SPEED UP FACTOR' collect: [:e | e roundTo: 0.1]-> #(1.6 1.4 1.4 1.1 1.7 1.7 2.6)"!!SmallInteger methodsFor: 'private' stamp: 'nice 11/27/2009 19:58'!highBitOfPositiveReceiver	| shifted bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted := self.	bitNo := 0.	[shifted < 65536]		whileFalse: 			[shifted := shifted bitShift: -16.			bitNo := bitNo + 16].	shifted < 256		ifFalse: 			[shifted := shifted bitShift: -8.			bitNo := bitNo + 8].			"The high bits table can be obtained with:	(1 to: 8) inject: #[0] into: [:highBits :rank | highBits , (highBits collect: [:e | rank])]."	^bitNo + ( #[0 1 2 2 3 3 3 3 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8] at: shifted + 1)! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'nice 11/27/2009 19:49'!lowBit	" Answer the index of the low order one bit.		2r00101000 lowBit       (Answers: 4)		2r-00101000 lowBit      (Answers: 4)	  First we skip bits in groups of 8, then do a lookup in a table.	  While not optimal, this is a good tradeoff; long	  integer #lowBit always invokes us with bytes."	| n result lastByte |	n := self.	n = 0 ifTrue: [ ^ 0 ].	result := 0.	[(lastByte := n bitAnd: 16rFF) = 0]		whileTrue: [			result := result + 8.			n := n bitShift: -8 ].	"The low bits table can be obtained with:	((1 to: 8) inject: #[1] into: [:lowBits :rank | (lowBits copy at: 1 put: lowBits first + 1; yourself) , lowBits]) allButFirst."	^result + ( #[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1] at: lastByte)! !