"Change Set:		8850Graphics-dtl.102Graphics-dtl.102:Remove all MVC BitEditor references from non-MVC packages.  Form>>bitEdit to Project class>>bitEdit:  Form>>bitEditAt:scale: to Project class>>bitEdit:at:scale:  BitEditor class>>locateMagnifiedView:scale: to Rectangle class>>locateMagnifiedView:scale:Graphics-nice.98:1) let #slideFrom:to:nSteps: truncate intermediate points just like #slideFrom:to:nStepsdelay: does2) let some temp assignments migrate to outer blocksGraphics-nice.99:Use ByteArray literalsGraphics-nice.100:move some temp assignment outside blocksGraphics-ar.101:Merging Graphics-nice.96:Experimental: let a Rectangle merge in place (I called this swallow:)This has two advantages:- avoid repeated Object creation when we just want the gross result- avoid closures writing to outer tempsIMHO, generalizing this kind of policy could have a measurable impact on GUI speed.However, this is against current policy to never change a Point nor rectangle in place, so I let gurus judge if worth or not."!!JPEGReadWriter methodsFor: 'dct' stamp: 'nice 1/8/2010 22:14'!idctBlockFloat: anArray component: aColorComponent	| t0 t1 t2 t3 t4 t5 t6 t7 t10 t11 t12 t13 z5 z10 z11 z12 z13 qt ws |	qt := self qTable at: (aColorComponent qTableIndex).	ws := Array new: DCTSize2.	"Pass 1: process columns from input, store into work array"	1 to: DCTSize do: [:i |		t0 := (anArray at: i) * (qt at: i).		t1 := (anArray at: (DCTSize*2 + i)) * (qt at: (DCTSize*2 + i)).		t2 := (anArray at: (DCTSize*4 + i)) * (qt at: (DCTSize*4 + i)).		t3 := (anArray at: (DCTSize*6 + i)) * (qt at: (DCTSize*6 + i)).		t10 := t0 + t2.		t11 := t0 - t2.		t13 := t1 + t3.		t12 := (t1 - t3) * DCTK1 - t13.		t0 := t10 + t13.		t3 := t10 - t13.		t1 := t11 + t12.		t2 := t11 - t12.		t4 := (anArray at: (DCTSize + i)) * (qt at: (DCTSize + i)).		t5 := (anArray at: (DCTSize*3 + i)) * (qt at: (DCTSize*3 + i)).		t6 := (anArray at: (DCTSize*5 + i)) * (qt at: (DCTSize*5 + i)).		t7 := (anArray at: (DCTSize*7 + i)) * (qt at: (DCTSize*7 + i)).		z13 := t6 + t5.		z10 := t6 - t5.		z11 := t4 + t7.		z12 := t4 - t7.		t7 := z11 + z13.		t11 := (z11 - z13) * DCTK1.		z5 := (z10 + z12) * DCTK2.		t10 := DCTK3 * z12 - z5.		t12 := DCTK4 * z10 + z5.		t6 := t12 - t7.		t5 := t11 - t6.		t4 := t10 + t5.		ws at: i put: t0 + t7.		ws at: (DCTSize*7 + i) put: t0 - t7.		ws at: (DCTSize + i) put: t1 + t6.		ws at: (DCTSize*6 + i) put: t1 - t6.		ws at: (DCTSize*2 + i) put: t2 + t5.		ws at: (DCTSize*5 + i) put: t2 - t5.		ws at: (DCTSize*4 + i) put: t3 + t4.		ws at: (DCTSize*3 + i) put: t3 - t4].		"Pass 2: process rows from the workspace"	0 to: DCTSize2-DCTSize by: DCTSize do: [:i |		t10 := (ws at: (i+1)) + (ws at: (i+5)).		t11 := (ws at: (i+1)) - (ws at: (i+5)).		t13 := (ws at: (i+3)) + (ws at: (i+7)).		t12 := ((ws at: (i+3)) - (ws at: (i+7))) * DCTK1 - t13.		t0 := t10 + t13.		t3 := t10 - t13.		t1 := t11 + t12.		t2 := t11 - t12.		z13 := (ws at: (i+6)) + (ws at: (i+4)).		z10 := (ws at: (i+6)) - (ws at: (i+4)).		z11 := (ws at: (i+2)) + (ws at: (i+8)).		z12 := (ws at: (i+2)) - (ws at: (i+8)).		t7 := z11 + z13.		t11 := (z11 - z13) * DCTK1.		z5 := (z10 + z12) * DCTK2.		t10 := DCTK3 * z12 - z5.		t12 := DCTK4 * z10 + z5.		t6 := t12 - t7.		t5 := t11 - t6.		t4 := t10 + t5.		"final output stage: scale down by a factor of 8 and range-limit"		anArray at: (i+1) put: (self dctFloatRangeLimit: (t0 + t7)).		anArray at: (i+8) put: (self dctFloatRangeLimit: (t0 - t7)).		anArray at: (i+2) put: (self dctFloatRangeLimit: (t1 + t6)).		anArray at: (i+7) put: (self dctFloatRangeLimit: (t1 - t6)).		anArray at: (i+3) put: (self dctFloatRangeLimit: (t2 + t5)).		anArray at: (i+6) put: (self dctFloatRangeLimit: (t2 - t5)).		anArray at: (i+5) put: (self dctFloatRangeLimit: (t3 + t4)).		anArray at: (i+4) put: (self dctFloatRangeLimit: (t3 - t4))]! !!Form methodsFor: 'displaying' stamp: 'nice 1/18/2010 21:25'!displayInterpolatedIn: aRectangle on: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine adjustedR |	self extent = aRectangle extent ifTrue:[^self displayOn: aForm at: aRectangle origin].	engine := Smalltalk at: #B3DRenderEngine 		ifPresent: [:engineClass | (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aRectangle;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	"there seems to be a slight bug in B3D which the following adjusts for"	adjustedR := (aRectangle withRight: aRectangle right + 1) translateBy: 0@1.	engine viewport: adjustedR.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.! !!Form methodsFor: 'displaying' stamp: 'nice 1/18/2010 21:43'!displayInterpolatedOn: aForm	"Display the receiver on aForm, using interpolation if necessary.		Form fromUser displayInterpolatedOn: Display.	Note: When scaling we attempt to use bilinear interpolation based	on the 3D engine. If the engine is not there then we use WarpBlt.	"	| engine |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	engine := Smalltalk at: #B3DRenderEngine 		ifPresent:[:engineClass| (engineClass defaultForPlatformOn: aForm)].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	"Otherwise use the 3D engine for our purposes"	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: self.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.! !!Form methodsFor: 'editing' stamp: 'dtl 1/23/2010 18:36'!bitEditAt: magnifiedFormLocation scale: scaleFactor 	"Create and schedule a view whose top left corner is magnifiedLocation 	and that contains a view of the receiver magnified by scaleFactor that 	can be modified using the Bit Editor. It also contains a view of the 	original form."	Project current bitEdit: self at: magnifiedFormLocation scale: scaleFactor ! !!Form class methodsFor: 'examples' stamp: 'nice 1/10/2010 17:41'!exampleBorder    "Form exampleBorder"	"This example demonstrates the border finding algorithm. Start	by having the user sketch on the screen (end with option-click) and then select a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of the region to be	outlined, and the region begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.		"sketch a little area with an enclosed region"	r := Rectangle fromUser.	f := Form fromDisplay: r.	interiorPoint := Cursor crossHair showWhile:		[Sensor waitButton - r origin].	Cursor execute showWhile:		[f shapeBorder: Color blue width: 2 interiorPoint: interiorPoint			sharpCorners: false internal: false].	f displayOn: Display at: r origin	! !!StrikeFont methodsFor: 'character shapes' stamp: 'dtl 1/24/2010 11:39'!edit: character 	"Open a Bit Editor on the given character. Note that you must do an accept 	(in the option menu of the bit editor) if you want this work. 	Accepted edits will not take effect in the font until you leave or close the bit editor. 	Also note that unaccepted edits will be lost when you leave or close."	"Note that BitEditor only works in MVC currently."	"(TextStyle default fontAt: 1) edit: $="	Project current editCharacter: character ofFont: self! !!Rectangle methodsFor: 'rectangle functions' stamp: 'nice 12/27/2009 22:38'!swallow: aRectangle 	"Modify the receiver so that it contains aRectangle."	origin := origin min: aRectangle origin.	corner := corner max: aRectangle corner! !!Rectangle class methodsFor: 'instance creation' stamp: 'dtl 1/23/2010 18:10'!locateMagnifiedView: aForm scale: scaleFactor	"Answer a rectangle at the location where the scaled view of the form,	aForm, should be displayed."	^ self originFromUser: (aForm extent * scaleFactor + (0@50))! !!DisplayObject methodsFor: 'displaying-Display' stamp: 'nice 1/10/2010 20:46'!slideFrom: startPoint to: stopPoint nSteps: nSteps 	"does not display at the first point, but does at the last"	| i p delta |	i := 0.	p := startPoint.	delta := stopPoint - startPoint // nSteps.	^ self		follow: [(p := p + delta) truncated]		while: [(i := i + 1) < nSteps]! !!TextStyle methodsFor: 'Disk I/O' stamp: 'nice 1/12/2010 20:24'!veryDeepCopyWith: deepCopier	"All inst vars are meant to be shared"	self == #veryDeepCopyWith:.	"to satisfy checkVariables"	^ deepCopier references at: self ifAbsentPut: [self clone].	"remember"! !!PNGReadWriter methodsFor: 'writing' stamp: 'nice 1/18/2010 18:08'!writeFileSignature	stream nextPutAll: #[ 16r89 16r50 16r4E  16r47 16r0D 16r0A 16r1A 16r0A ]! !!SegmentScanner methodsFor: 'private' stamp: 'ar 5/18/2000 16:48'!setFont	super setFont.	"Make a local copy of stop conditions so we don't modify the default"	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions := stopConditions copy].	stopConditions at: Space asciiValue + 1 put: nil.! !!Form methodsFor: 'editing' stamp: 'dtl 1/23/2010 18:28'!bitEdit	"Create and schedule a view located in an area designated by the user 	that contains a view of the receiver magnified by 8@8 that can be 	modified using the Bit Editor. It also contains a view of the original 	form."	Project current bitEdit: self! !!Form methodsFor: 'displaying' stamp: 'nice 1/10/2010 17:39'!displayResourceFormOn: aForm	"a special display method for blowing up resource thumbnails"	| engine tx cmap blitter |	self extent = aForm extent ifTrue:[^self displayOn: aForm].	engine := Smalltalk at: #B3DRenderEngine ifPresentAndInMemory:		[:engineClass | engineClass defaultForPlatformOn: aForm].	engine ifNil:[		"We've got no bilinear interpolation. Use WarpBlt instead"		(WarpBlt current toForm: aForm)			sourceForm: self destRect: aForm boundingBox;			combinationRule: 3;			cellSize: 2;			warpBits.		^self	].	tx := self asTexture.	(blitter := BitBlt current toForm: tx)		sourceForm: self; destRect: aForm boundingBox;		sourceOrigin: 0@0;		combinationRule: Form paint.	"map transparency to current World background color"	(World color respondsTo: #pixelWordForDepth:) ifTrue: [		cmap := Bitmap new: (self depth <= 8 ifTrue: [1 << self depth] ifFalse: [4096]).		cmap at: 1 put: (tx pixelWordFor: World color).		blitter colorMap: cmap.	].	blitter copyBits.	engine viewport: aForm boundingBox.	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	engine texture: tx.	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	engine finish.	"the above, using bilinear interpolation doesn't leave transparent pixel values intact"	(WarpBlt current toForm: aForm)		sourceForm: self destRect: aForm boundingBox;		combinationRule: Form and;		colorMap: (Color maskingMap: self depth);		warpBits.! !!Form class methodsFor: 'examples' stamp: 'nice 1/10/2010 17:41'!exampleSpaceFill    "Form exampleSpaceFill"	"This example demonstrates the area filling algorithm. Starts by having	the user sketch on the screen (ended by option-click) and then select a rectangular	area of the screen which includes all of the area to be filled. Finally,	(with crosshair cursor), the user points at the interior of some region to be	filled, and the filling begins with that place as its seed."	| f r interiorPoint |	Form exampleSketch.		"sketch a little area with an enclosed region"	r := Rectangle fromUser.	f := Form fromDisplay: r.	interiorPoint := Cursor crossHair showWhile:		[Sensor waitButton - r origin].	Cursor execute showWhile:		[f shapeFill: Color gray interiorPoint: interiorPoint].	f displayOn: Display at: r origin	! !