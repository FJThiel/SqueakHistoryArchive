"Change Set:		7327Compiler-ar.71Compiler-ar.71:Post-closure cleanup and underscore removal."!!Encoder methodsFor: 'initialize-release' stamp: 'ajh 7/21/2003 00:53'!temps: tempVars literals: lits class: cl 	"Decompile."	supered := false.	class := cl.	nTemps := tempVars size.	tempVars do: [:node | scopeTable at: node name put: node].	literalStream := ReadStream on: lits.	literalStream position: lits size.	sourceRanges := Dictionary new: 32.	globalSourceRanges := OrderedCollection new: 32.! !!Parser methodsFor: 'expression types' stamp: 'di 12/4/1999 21:04'!variable	| varName varStart varEnd |	varStart := self startOfNextToken + requestorOffset.	varName := self advance.	varEnd := self endOfLastToken + requestorOffset.	^ encoder encodeVariable: varName		sourceRange: (varStart to: varEnd)		ifUnknown: [self correctVariable: varName interval: (varStart to: varEnd)]! !!BraceNode methodsFor: 'enumerating' stamp: ''!casesForwardDo: aBlock	"For each case in forward order, evaluate aBlock with three arguments:	 the key block, the value block, and whether it is the last case."	| numCases case |	1 to: (numCases := elements size) do:		[:i |		case := elements at: i.		aBlock value: case receiver value: case arguments first value: i=numCases]! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:33'!sizeExceptLast: encoder	| codeSize nextToLast |	nextToLast := statements size - 1.	nextToLast < 1 ifTrue: [^ 0]. "Only one statement"	codeSize := 0.	1 to: nextToLast do: 		[:i | codeSize := codeSize + ((statements at: i) sizeForEffect: encoder)].	^ codeSize! !!MethodNode methodsFor: 'printing' stamp: 'ar 2/13/2001 21:15'!printPrimitiveOn: aStream 	"Print the primitive on aStream"	| primIndex primDecl |	primIndex := primitive.	primIndex = 0		ifTrue: [^ self].	primIndex = 120		ifTrue: ["External call spec"			^ aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primIndex = 117		ifTrue: [primDecl := encoder literals at: 1.			aStream nextPut: $';								nextPutAll: (primDecl at: 2);				 nextPut: $'.			(primDecl at: 1) notNil				ifTrue: [aStream nextPutAll: ' module:';						 nextPut: $';												nextPutAll: (primDecl at: 1);						 nextPut: $']]		ifFalse: [aStream print: primIndex].	aStream nextPut: $>.	Smalltalk at: #Interpreter ifPresent:[:cls|		aStream nextPutAll: ' "'				, ((cls classPool at: #PrimitiveTable)						at: primIndex + 1) , '" '].! !!MessageNode methodsFor: 'printing' stamp: 'di 5/30/2000 23:17'!printOn: strm indent: level precedence: outerPrecedence	| parenthesize |	parenthesize := precedence > outerPrecedence		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].	parenthesize		ifTrue: [strm nextPutAll: '('.				self printOn: strm indent: level.				strm nextPutAll: ')']		ifFalse: [self printOn: strm indent: level]! !!MessageNode methodsFor: 'initialize-release' stamp: 'tk 10/26/2000 15:37'!selector: sel	selector := sel! !!Parser methodsFor: 'error correction' stamp: 'rbb 2/18/2005 11:01'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection := requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives := Symbol possibleSelectorsFor: proposedKeyword.	self flag: #toBeFixed.	"alternatives addAll: (MultiSymbol possibleSelectorsFor: proposedKeyword)."	aStream := WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine := 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines := Array with: firstLine with: (alternatives size + firstLine).		choice := (UIManager default 			chooseFrom: (aStream contents substrings)			lines: lines			title: 'Unknown selector, please\confirm, correct, or cancel' withCRs).	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector := alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~= $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!Encoder methodsFor: 'error handling' stamp: ''!requestor: req	"Often the requestor is a BrowserCodeController"	requestor := req! !!ReturnNode methodsFor: 'code generation' stamp: ''!emitForValue: stack on: strm	expr emitForReturn: stack on: strm.	pc := strm position! !!ParseNode methodsFor: 'code generation' stamp: ''!emitLong: dist code: longCode on: aStream 	"Force a two-byte jump."	| code distance |	code := longCode.	distance := dist.	distance < 0		ifTrue: 			[distance := distance + 1024.			code := code - 4]		ifFalse: 			[distance > 1023 ifTrue: [distance := -1]].	distance < 0		ifTrue: 			[self error: 'A block compiles more than 1K bytes of code']		ifFalse: 			[aStream nextPut: distance // 256 + code.			aStream nextPut: distance \\ 256]! !!CascadeNode methodsFor: 'code generation' stamp: ''!sizeForValue: encoder	| size |	size := (receiver sizeForValue: encoder) + (messages size - 1 * 2).	messages do: [:aMessage | size := size + (aMessage sizeForValue: encoder)].	^size! !!Encoder methodsFor: 'temps' stamp: ''!newTemp: name	nTemps := nTemps + 1.	^ TempVariableNode new		name: name		index: nTemps - 1		type: LdTempType		scope: 0! !!Encoder methodsFor: 'error handling' stamp: ''!notify: string	"Put a separate notifier on top of the requestor's window"	| req |	requestor == nil		ifFalse: 			[req := requestor.			self release.			req notify: string].	^false! !!ParseNode methodsFor: 'comment' stamp: ''!comment: newComment	comment := newComment! !!Scanner methodsFor: 'multi-character scans' stamp: 'tao 4/23/98 12:55'!xDigit	"Form a number."	tokenType := #number.	(aheadChar = 30 asCharacter and: [source atEnd			and:  [source skip: -1. source next ~= 30 asCharacter]])		ifTrue: [source skip: -1 "Read off the end last time"]		ifFalse: [source skip: -2].	token := [Number readFrom: source] ifError: [:err :rcvr | self offEnd: err].	self step; step! !!Parser methodsFor: 'expression types' stamp: ''!cascade	" {; message} => CascadeNode."	| rcvr msgs |	parseNode canCascade		ifFalse: [^self expected: 'Cascading not'].	rcvr := parseNode cascadeReceiver.	msgs := OrderedCollection with: parseNode.	[self match: #semicolon]		whileTrue: 			[parseNode := rcvr.			(self messagePart: 3 repeat: false)				ifFalse: [^self expected: 'Cascade'].			parseNode canCascade				ifFalse: [^self expected: '<- No special messages'].			parseNode cascadeReceiver.			msgs addLast: parseNode].	parseNode := CascadeNode new receiver: rcvr messages: msgs! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:06'!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc :=do not:= return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^(encoder sizePushLiteralVar: index)	 + (writeNode sizeCode: encoder args: 1 super: false)! !!MessageNode methodsFor: 'code generation' stamp: ''!sizeIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	(forValue		or: [(thenExpr isJust: NodeNil)		or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super sizeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize := elseExpr sizeForEvaluatedValue: encoder.			thenSize := (thenExpr sizeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeJump: elseSize]).			branchSize := self sizeBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize := 0.					thenSize := thenExpr sizeForEvaluatedEffect: encoder.					branchSize := self sizeBranchOn: false dist: thenSize]				ifFalse:					[thenSize := 0.					elseSize := elseExpr sizeForEvaluatedEffect: encoder.					branchSize := self sizeBranchOn: true dist: elseSize]].	sizes := Array with: thenSize with: elseSize.	^ (receiver sizeForValue: encoder) + branchSize			+ thenSize + elseSize! !!Scanner methodsFor: 'expression types' stamp: ''!nextLiteral	"Same as advance, but -4 comes back as a number instead of two tokens"	| prevToken |	prevToken := self advance.	(prevToken == #- and: [token isKindOf: Number])		ifTrue: 			[^self advance negated].	^prevToken! !!Parser methodsFor: 'primitives' stamp: 'lr 2/6/2006 20:50'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken:'(' asSymbol) ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == ')' asSymbol] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:')' asSymbol) ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addPragma: (Pragma keyword: #primitive: arguments: #(120)).	^true! !!Encoder methodsFor: 'private' stamp: ''!name: name key: key class: leafNodeClass type: type set: dict	| node |	^dict 		at: key		ifAbsent: 			[node := leafNodeClass new						name: name						key: key						index: nil						type: type.			dict at: key put: node.			^node]! !!BraceNode methodsFor: 'initialize-release' stamp: ''!elements: collection	"Decompile."	elements := collection! !!Decompiler class methodsFor: 'class initialization' stamp: 'di 1/28/2000 22:21'!initialize	CascadeFlag := 'cascade'.  "A unique object"	CaseFlag := 'case'. "Ditto"	ArgumentFlag := 'argument'.  "Ditto"	IfNilFlag := 'ifNil'.  "Ditto"	"Decompiler initialize"! !!MethodNode methodsFor: 'code generation' stamp: 'di 5/25/2000 06:45'!generate: trailer ifQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]])		ifFalse: [^ self].	v := block code.	v < 0		ifTrue: [^ self].	v = LdSelf		ifTrue: [^ methodBlock value: (CompiledMethod toReturnSelfTrailerBytes: trailer)].	(v between: LdTrue and: LdMinus1 + 3)		ifTrue: [^ methodBlock value: (CompiledMethod toReturnConstant: v - LdSelf trailerBytes: trailer)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v trailerBytes: trailer)].	v // 256 = 1		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v \\ 256 trailerBytes: trailer)]! !!BlockNode methodsFor: 'accessing' stamp: ''!returnLast	self returns		ifFalse: 			[returns := true.			statements at: statements size put: statements last asReturnNode]! !!Parser methodsFor: 'error correction' stamp: ''!declareGlobal: name	| sym |	sym := name asSymbol.	Smalltalk at: sym put: nil.	^ encoder global: (Smalltalk associationAt: sym) name: sym! !!Decompiler methodsFor: 'control' stamp: ''!statementsTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end."	| blockPos stackPos t |	blockPos := statements size.	stackPos := stack size.	[pc < end]		whileTrue:			[lastPc := pc.  limit := end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue := stack size > stackPos)		ifTrue:			[statements addLast: stack removeLast].	lastJumpPc = lastPc ifFalse: [exit := pc].	^self popTo: blockPos! !!CompiledMethodWithNode methodsFor: 'private' stamp: 'NS 1/28/2004 09:04'!node: aMethodNode	node := aMethodNode! !!BlockNode methodsFor: 'code generation' stamp: ''!sizeForValue: encoder	nArgsNode := encoder encodeLiteral: arguments size.	remoteCopyNode := encoder encodeSelector: #blockCopy:.	size := (self sizeForEvaluatedValue: encoder)				+ (self returns ifTrue: [0] ifFalse: [1]). "endBlock"	arguments := arguments collect:  "Chance to prepare debugger remote temps"				[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size := size + (arg sizeForStorePop: encoder)].	^1 + (nArgsNode sizeForValue: encoder) 		+ (remoteCopyNode size: encoder args: 1 super: false) + 2 + size! !!MethodNode methodsFor: 'code generation' stamp: 'DF 4/18/2006 23:58'!generateWith: trailer using: aCompiledMethodClass	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method := m.		method properties: properties.		^ method].	nArgs := arguments size.	blkSize := block sizeForEvaluatedValue: encoder.	literals := encoder allLiterals.	nLits := literals size.	method := aCompiledMethodClass	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm := ReadWriteStream with: method.	strm position: method initialPC - 1.	stack := ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method properties: properties.	^ method! !!Parser methodsFor: 'error handling' stamp: ''!fail	| exitBlock |	encoder == nil		ifFalse: [encoder release. encoder := nil]. "break cycle"	exitBlock := failBlock.	failBlock := nil.	^exitBlock value! !!Parser methodsFor: 'error handling' stamp: 'hmm 7/18/2001 21:45'!expected: aString 	"Notify a problem at token 'here'."	tokenType == #doIt ifTrue: [hereMark := hereMark + 1].	hereType == #doIt ifTrue: [hereMark := hereMark + 1].	^ self notify: aString , ' expected' at: hereMark + requestorOffset! !!MessageNode methodsFor: 'printing' stamp: 'RAA 6/9/2000 18:06'!asMorphicCaseOn: parent indent: ignored	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise |	braceNode := arguments first.	otherwise := arguments last.	((arguments size = 1) or: [otherwise isJustCaseError]) ifTrue: [		self morphFromKeywords: #caseOf: arguments: {braceNode} on: parent indent: nil.		^parent	].	self morphFromKeywords: #caseOf:otherwise: arguments: arguments on: parent indent: nil.	^parent! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:31'!emitCodeForToDo: stack encoder: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].	initStmt emitCodeForEffect: stack encoder: encoder.	test emitCodeForValue: stack encoder: encoder.	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.	pc := encoder methodStreamPosition.	block emitCodeForEvaluatedEffect: stack encoder: encoder.	incStmt emitCodeForEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!Scanner methodsFor: 'multi-character scans' stamp: ''!xDollar	"Form a Character literal."	self step. "pass over $"	token := self step.	tokenType := #number "really should be Char, but rest of compiler doesn't know"! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:39'!emitForEffect: stack on: strm	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: strm with: false]		ifFalse: 			[super emitForEffect: stack on: strm]! !!Scanner methodsFor: 'expression types' stamp: 'di 4/23/2000 22:11'!revertToCheckpoint: checkpoint	"Revert to the state when checkpoint was made."	| myCopy |	myCopy := checkpoint first.	1 to: self class instSize do:		[:i | self instVarAt: i put: (myCopy instVarAt: i)].	source := checkpoint second.	currentComment := checkpoint third! !!Scanner methodsFor: 'expression types' stamp: ''!scanStringStruct	| s |	s := WriteStream on: (Array new: 16).	[tokenType = #rightParenthesis or: [tokenType = #doIt]]		whileFalse: 			[tokenType = #leftParenthesis				ifTrue: 					[self scanToken; scanStringStruct]				ifFalse: 					[tokenType = #word ifFalse:						[^self error: 'only words and parens allowed']].			s nextPut: token.			self scanToken].	token := s contents! !!BraceNode class methodsFor: 'examples' stamp: 'di 11/19/1999 09:05'!example	"Test the {a. b. c} syntax."	| x |	x := {1. {2. 3}. 4}.	^ {x first. x second first. x second last. x last. 5} as: Set"BraceNode example Set (0 1 2 3 4 5 )"! !!ParseNode methodsFor: 'printing' stamp: 'tk 10/16/2000 13:57'!nodePrintOn: aStrm indent: nn	| var aaStrm myLine |	"Show just the sub nodes and the code."	(aaStrm := aStrm) ifNil: [aaStrm := WriteStream on: (String new: 500)].	nn timesRepeat: [aaStrm tab].	aaStrm nextPutAll: self class name; space.	myLine := self printString copyWithout: Character cr.	myLine := myLine copyFrom: 1 to: (myLine size min: 70).	aaStrm nextPutAll: myLine; cr.	1 to: self class instSize do: [:ii | 		var := self instVarAt: ii.		(var respondsTo: #asReturnNode) ifTrue: [var nodePrintOn: aaStrm indent: nn+1]].	1 to: self class instSize do: [:ii | 		var := self instVarAt: ii.		(var isKindOf: SequenceableCollection) ifTrue: [				var do: [:aNode | 					(aNode respondsTo: #asReturnNode) ifTrue: [						aNode nodePrintOn: aaStrm indent: nn+1]]]].	^ aaStrm! !!PrimitiveNode methodsFor: 'as yet unclassified' stamp: 'ajh 7/14/2001 12:23'!num: n	primitiveNum := n! !!BraceNode methodsFor: 'initialize-release' stamp: ''!elements: collection sourceLocations: locations	"Compile."	elements := collection.	sourceLocations := locations! !!Decompiler methodsFor: 'initialize-release' stamp: ''!withTempNames: tempNameArray	tempVars := tempNameArray! !!MessageNode methodsFor: 'equation translation' stamp: 'tk 10/27/2000 15:11'!arguments: list	arguments := list! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 10:43'!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc :=do not:= return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!MethodNode methodsFor: 'initialize-release' stamp: 'ajh 1/24/2003 17:37'!selector: symbol	selectorOrFalse := symbol! !!MethodNode methodsFor: 'initialize-release' stamp: 'ar 1/4/2002 00:23'!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim properties: propDict	"Initialize the receiver with respect to the arguments given."	encoder := anEncoder.	selectorOrFalse := selOrFalse.	precedence := p.	arguments := args.	temporaries := temps.	block := blk.	primitive := prim.	properties := propDict.! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:42'!emitToDo: stack on: strm value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitForEffect: stack on: strm].	initStmt emitForEffect: stack on: strm.	test emitForValue: stack on: strm.	self emitBranchOn: false dist: blockSize pop: stack on: strm.	pc := strm position.	block emitForEvaluatedEffect: stack on: strm.	incStmt emitForEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!Parser methodsFor: 'error correction' stamp: 'RAA 6/5/2001 11:57'!declareTempAndPaste: name	| insertion delta theTextString characterBeforeMark |	theTextString := requestor text string.	characterBeforeMark := theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion := name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion := ' ', insertion].		delta := 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion := '| ' , name , ' |',String cr.		delta := 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion := insertion , String tab.			delta := delta + 1.	"the tab"		].	].	tempsMark := tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta.	^ encoder bindAndJuggle: name! !!BlockNode methodsFor: 'accessing' stamp: 'sma 2/27/2000 22:37'!temporaries: aCollection	temporaries := aCollection! !!MethodNode methodsFor: 'initialize-release' stamp: 'ajh 1/22/2003 17:53'!sourceText: stringOrText	sourceText := stringOrText! !!Parser methodsFor: 'error correction' stamp: ''!declareClassVar: name	| sym class |	sym := name asSymbol.	class := encoder classEncoding.	class := class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Scanner methodsFor: 'initialize-release' stamp: ''!initScanner	buffer := WriteStream on: (String new: 40).	typeTable := TypeTable! !!VariableNode class methodsFor: 'class initialization' stamp: ''!initialize    "VariableNode initialize.  Decompiler initialize"	| encoder |	encoder := Encoder new.	StdVariables := Dictionary new: 16.	encoder		fillDict: StdVariables		with: VariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors := Dictionary new: 64.	encoder		fillDict: StdSelectors		with: SelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals := LiteralDictionary new: 16.	encoder		fillDict: StdLiterals		with: LiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil := encoder encodeVariable: 'nil'.	NodeTrue := encoder encodeVariable: 'true'.	NodeFalse := encoder encodeVariable: 'false'.	NodeSelf := encoder encodeVariable: 'self'.	NodeThisContext := encoder encodeVariable: 'thisContext'.	NodeSuper := encoder encodeVariable: 'super'! !!AssignmentNode methodsFor: 'initialize-release' stamp: 'di 3/22/1999 12:00'!variable: aVariable value: expression from: encoder	(aVariable isMemberOf: MessageAsTempNode)		ifTrue: ["Case of remote temp vars"				^ aVariable store: expression from: encoder].	variable := aVariable.	value := expression! !!CascadeNode methodsFor: 'initialize-release' stamp: ''!receiver: receivingObject messages: msgs	" Transcript show: 'abc'; cr; show: 'def' "	receiver := receivingObject.	messages := msgs! !!Encoder methodsFor: 'temps' stamp: 'di 10/12/1999 16:53'!bindAndJuggle: name	| node nodes first thisCode |	node := self reallyBind: name.	"Declared temps must precede block temps for decompiler and debugger to work right"	nodes := self tempNodes.	(first := nodes findFirst: [:n | n scope > 0]) > 0 ifTrue:		[node == nodes last ifFalse: [self error: 'logic error'].		thisCode := (nodes at: first) code.		first to: nodes size - 1 do:			[:i | (nodes at: i) key: (nodes at: i) key							code: (nodes at: i+1) code].		nodes last key: nodes last key code: thisCode].		^ node! !!ParseNode methodsFor: 'private' stamp: 'nk 7/11/2004 13:39'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.	Break the string at word breaks, given the widths in the default	font, at 450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth lastChar |	readStream := ReadStream on: aString.	font := TextStyle default defaultFont.	tabWidth := TextConstants at: #DefaultTab.	spaceWidth := font widthOf: Character space.	position := indent * tabWidth.	lineBreak := 450.	[readStream atEnd]		whileFalse: 			[word := self nextWordFrom: readStream setCharacter: [:lc | lastChar := lc].			wordWidth := word inject: 0 into: [:width :char | width + (font widthOf: char)].			position := position + wordWidth.			position > lineBreak				ifTrue: 					[aStream skip: -1; crtab: indent.					position := indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					word isEmpty ifFalse: [aStream nextPutAll: word; space]]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position := position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream skip: -1; crtab: indent.							position := indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !!ReturnNode methodsFor: 'initialize-release' stamp: ''!expr: e	expr := e! !!ReturnNode methodsFor: 'initialize-release' stamp: ''!expr: e encoder: encoder sourceRange: range	expr := e.	encoder noteSourceRange: range forNode: self! !!Encoder methodsFor: 'initialize-release' stamp: 'ajh 1/24/2003 18:46'!nTemps: n literals: lits class: cl 	"Decompile."	supered := false.	class := cl.	nTemps := n.	literalStream := ReadStream on: lits.	literalStream position: lits size.	sourceRanges := Dictionary new: 32.	globalSourceRanges := OrderedCollection new: 32.! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'sma 2/5/2000 12:37'!codeMessage: receiver selector: selector arguments: arguments	| symbol node |	symbol := selector key.	(node := BraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node := self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ MessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: symbol precedence! !!ParseStack methodsFor: 'initialize-release' stamp: ''!init	length := position := 0! !!Decompiler methodsFor: 'control' stamp: 'tao 8/20/97 22:51'!blockForCaseTo: end	"Decompile a range of code as in statementsForCaseTo:, but return a block node."	| exprs block oldBase |	oldBase := blockStackBase.	blockStackBase := stack size.	exprs := self statementsForCaseTo: end.	block := constructor codeBlock: exprs returns: lastReturnPc = lastPc.	blockStackBase := oldBase.	lastReturnPc := -1.  "So as not to mislead outer calls"	^block! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:32'!emitExceptLast: stack on: aStream	| nextToLast |	nextToLast := statements size - 1.	nextToLast < 1 ifTrue: [^ self].  "Only one statement"	1 to: nextToLast do:		[:i | (statements at: i) emitForEffect: stack on: aStream].! !!Parser methodsFor: 'error correction' stamp: ''!substituteSelector: selectorParts wordIntervals: spots	"Substitute the correctSelector into the (presuamed interactive) receiver."	| offset |	offset := 0.	selectorParts with: spots do:		[ :word :interval |		offset := self substituteWord: word wordInterval: interval offset: offset ]! !!Encoder methodsFor: 'private' stamp: ''!reallyBind: name	| node |	node := self newTemp: name.	scopeTable at: name put: node.	^node! !!TempVariableNode methodsFor: 'initialize-release' stamp: ''!scope: level	"Note scope of temporary variables.	Currently only the following distinctions are made:		0	outer level: args and user-declared temps		1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:"	scope := level! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:48'!compiledMethodFor: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method := methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method := method copyWithTempNames: methodNode tempNames].		logFlag ifTrue: [SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext].	^ method.! !!Scanner class methodsFor: 'testing' stamp: 'fbs 2/13/2006 22:33'!wellFormedInstanceVariableNameFrom: aString	"Answer a legal instance variable name, derived from aString"	| cleansedString |	cleansedString := aString select: [:ch | ch isDigit or: [ch isLetter]].	(cleansedString isEmpty or: [cleansedString first isDigit])		ifTrue: [cleansedString := 'a', cleansedString]		ifFalse:	[cleansedString := cleansedString withFirstCharacterDownshifted].	[self isLegalInstVarName: cleansedString] whileFalse:		[cleansedString := cleansedString, 'x'].	^ cleansedString"Scanner wellFormedInstanceVariableNameFrom:  '234 xx\ Uml /ler42342380-4'"! !!Encoder methodsFor: 'temps' stamp: 'crl 2/26/1999 12:18'!bindBlockTemp: name 	"Declare a temporary block variable; complain if it's not a field or class variable."	| node |	node := scopeTable at: name ifAbsent: [^self reallyBind: name].	node isTemp		ifTrue: [			node scope >= 0 ifTrue: [^ self notify: 'Name already used in this method'].			node scope: 0]		ifFalse: [^self notify: 'Name already used in this class'].	^node! !!MessageNode methodsFor: 'macro transformations' stamp: ''!transform: encoder	special = 0 ifTrue: [^false].	(self perform: (MacroTransformers at: special) with: encoder)		ifTrue: 			[^true]		ifFalse: 			[special := 0. ^false]! !!Parser methodsFor: 'expression types' stamp: 'di 3/8/2000 09:36'!braceExpression	" { elements } => BraceNode."	| elements locations loc more |	elements := OrderedCollection new.	locations := OrderedCollection new.	self advance.	more := hereType ~~ #rightBrace.	[more]		whileTrue: 			[loc := hereMark + requestorOffset.			self expression				ifTrue: 					[elements addLast: parseNode.					locations addLast: loc]				ifFalse:					[^self expected: 'Variable or expression'].			(self match: #period)				ifTrue: [more := hereType ~~ #rightBrace]				ifFalse: [more := false]].	parseNode := BraceNode new elements: elements sourceLocations: locations.	(self match: #rightBrace)		ifFalse: [^self expected: 'Period or right brace'].	^true! !!ColoredCodeStream methodsFor: 'color/style' stamp: 'sw 5/20/2001 11:30'!withStyleFor: elementType do: aBlock	"Evaluate aBlock with appropriate emphasis and color for the given elementType"	| colorAndStyle |	colorAndStyle := self colorTable at: elementType.	^ self withColor: colorAndStyle first emphasis: colorAndStyle second do: aBlock! !!TempVariableNode methodsFor: 'initialize-release' stamp: ''!nowHasRef	hasRefs := true! !!MessageNode methodsFor: 'code generation' stamp: ''!sizeForValue: encoder	| total argSize |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector := selector copy "only necess for splOops"].	total := selector size: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total := total + (receiver sizeForValue: encoder)].	sizes := arguments collect: 					[:arg | 					argSize := arg sizeForValue: encoder.					total := total + argSize.					argSize].	^total! !!LiteralDictionary methodsFor: 'as yet unclassified' stamp: 'md 10/5/2005 15:43'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject hash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil					or: [self literalEquality: element key and: anObject])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!ParseStack methodsFor: 'accessing' stamp: ''!pop: n	(position := position - n) < 0 		ifTrue: [self error: 'Parse stack underflow']! !!ReturnNode methodsFor: 'code generation' stamp: ''!emitForReturn: stack on: strm	expr emitForReturn: stack on: strm.	pc := strm position! !!Decompiler methodsFor: 'instruction decoding' stamp: ''!jump: dist	exit := pc + dist.	lastJumpPc := lastPc! !!PrimitiveNode methodsFor: 'as yet unclassified' stamp: 'ajh 7/14/2001 12:30'!spec: literal	spec := literal! !!Parser methodsFor: 'private' stamp: ''!addComment	parseNode ~~ nil		ifTrue: 			[parseNode comment: currentComment.			currentComment := nil]! !!Parser methodsFor: 'error correction' stamp: ''!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presuamed interactive) receiver."	requestor correctFrom: (spot first + o)					to: (spot last + o)					with: correctWord.	requestorOffset := requestorOffset + correctWord size - spot size.	^ o + correctWord size - spot size! !!Encoder methodsFor: 'temps' stamp: ''!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node := scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self notify: 'Name already used in a Pool or Global'].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node! !!CompiledMethodWithNode methodsFor: 'private' stamp: 'NS 1/28/2004 09:03'!method: aCompiledMethod	method := aCompiledMethod! !!Parser methodsFor: 'expression types' stamp: ''!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode := self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal]])		ifTrue: 			[parseNode := encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number])		ifTrue: 			[self advance.			parseNode := encoder encodeLiteral: self advance negated.			^true].	^false! !!MessageNode methodsFor: 'code generation' stamp: ''!sizeToDo: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize blockVar initSize limitInit |	block := arguments at: 3.	blockVar := block firstArgument.	initStmt := arguments at: 4.	test := arguments at: 5.	incStmt := arguments at: 6.	limitInit := arguments at: 7.	initSize := initStmt sizeForEffect: encoder.	limitInit == nil		ifFalse: [initSize := initSize + (limitInit sizeForEffect: encoder)].	blockSize := (block sizeForEvaluatedEffect: encoder)			+ (incStmt sizeForEffect: encoder) + 2.  "+2 for Jmp backward"	loopSize := (test sizeForValue: encoder)			+ (self sizeBranchOn: false dist: blockSize)			+ blockSize.	sizes := Array with: blockSize with: loopSize.	^ initSize + loopSize			+ (forValue ifTrue: [1] ifFalse: [0])    " +1 for value (push nil) "! !!Decompiler methodsFor: 'control' stamp: ''!blockTo: end	"Decompile a range of code as in statementsTo:, but return a block node."	| exprs block oldBase |	oldBase := blockStackBase.	blockStackBase := stack size.	exprs := self statementsTo: end.	block := constructor codeBlock: exprs returns: lastReturnPc = lastPc.	blockStackBase := oldBase.	lastReturnPc := -1.  "So as not to mislead outer calls"	^block! !!ParseStack methodsFor: 'accessing' stamp: ''!push: n	(position := position + n) > length 		ifTrue: [length := position]! !!Scanner methodsFor: 'initialize-release' stamp: ''!scan: inputStream 	"Bind the input stream, fill the character buffers and first token buffer."	source := inputStream.	self step.	self step.	self scanToken! !!Compiler methodsFor: 'private' stamp: ''!from: textOrStream class: aClass context: aContext notifying: req	(textOrStream isKindOf: PositionableStream)		ifTrue: [sourceStream := textOrStream]		ifFalse: [sourceStream := ReadStream on: textOrStream asString].	class := aClass.	context := aContext.	requestor := req! !!Encoder methodsFor: 'encoding' stamp: ''!litIndex: literal	| p |	p := literalStream position.	p = 256 ifTrue:		[self notify: 'More than 256 literals referenced. You must split or otherwise simplify this method.The 257th literal is: ', literal printString. ^nil].		"Would like to show where it is in the source code, 		 but that info is hard to get."	literalStream nextPut: literal.	^ p! !!Scanner methodsFor: 'expression types' stamp: ''!step	| c |	c := hereChar.	hereChar := aheadChar.	source atEnd		ifTrue: [aheadChar := 30 asCharacter "doit"]		ifFalse: [aheadChar := source next].	^c! !!Compiler methodsFor: 'public access' stamp: 'sd 1/19/2004 20:58'!evaluate: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	| result |	result := self				evaluate: aString				in: aContext				to: aReceiver				notifying: nil				ifFail: [^ #failedDoit].	^ result! !!Decompiler methodsFor: 'control' stamp: 'ls 1/28/2004 13:29'!statementsForCaseTo: end	"Decompile the method from pc up to end and return an array of	expressions. If at run time this block will leave a value on the stack,	set hasValue to true. If the block ends with a jump or return, set exit	to the destination of the jump, or the end of the method; otherwise, set	exit = end. Leave pc = end.	Note that stack initially contains a CaseFlag which will be removed by	a subsequent Pop instruction, so adjust the StackPos accordingly."	| blockPos stackPos |	blockPos := statements size.	stackPos := stack size - 1. "Adjust for CaseFlag"	[pc < end]		whileTrue:			[lastPc := pc.  limit := end.  "for performs"			self interpretNextInstructionFor: self].	"If there is an additional item on the stack, it will be the value	of this block."	(hasValue := stack size > stackPos)		ifTrue:			[stack last == CaseFlag				ifFalse: [ statements addLast: stack removeLast] ].	lastJumpPc = lastPc ifFalse: [exit := pc].	caseExits add: exit.	^self popTo: blockPos! !!Encoder methodsFor: 'initialize-release' stamp: ''!noteSuper	supered := true! !!Scanner methodsFor: 'public access' stamp: 'sw 1/28/2001 23:31'!scanMessageParts: sourceString	"Return an array of the form (comment keyword comment arg comment keyword comment arg comment) for the message pattern of this method.  Courtesy of Ted Kaehler, June 1999"	| coll nonKeywords |	coll := OrderedCollection new.	self scan: (ReadStream on: sourceString asString).	nonKeywords := 0.	[tokenType = #doIt] whileFalse:		[(currentComment == nil or: [currentComment isEmpty])			ifTrue: [coll addLast: nil]			ifFalse: [coll addLast: currentComment removeFirst.				[currentComment isEmpty] whileFalse:					[coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].		(token numArgs < 1 or: [(token = #|) & (coll size > 1)])			ifTrue: [(nonKeywords := nonKeywords + 1) > 1 ifTrue: [^ coll]]						"done with header"			ifFalse: [nonKeywords := 0].		coll addLast: token.		self scanToken].	(currentComment == nil or: [currentComment isEmpty])		ifTrue: [coll addLast: nil]		ifFalse: [coll addLast: currentComment removeFirst.			[currentComment isEmpty] whileFalse: [				coll at: coll size put: (coll last, ' ', currentComment removeFirst)]].	^ coll! !!Parser methodsFor: 'scanning' stamp: 'hmm 7/16/2001 20:12'!advance	| this |	prevMark := hereMark.	prevEnd := hereEnd.	this := here.	here := token.	hereType := tokenType.	hereMark := mark.	hereEnd := source position - (source atEnd ifTrue: [hereChar == 30 asCharacter ifTrue: [0] ifFalse: [1]] ifFalse: [2]).	self scanToken.	"Transcript show: 'here: ', here printString, ' mark: ', hereMark printString, ' end: ', hereEnd printString; cr."	^this! !!Parser methodsFor: 'expression types' stamp: 'hmm 7/16/2001 18:47'!assignment: varNode	" var ':=' expression => AssignmentNode."	| loc start |	(loc := varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	start := self startOfNextToken.	varNode nowHasDef.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode := AssignmentNode new				variable: varNode				value: parseNode				from: encoder				sourceRange: (start to: self endOfLastToken).	^true! !!ColoredCodeStream methodsFor: 'color/style' stamp: 'md 8/14/2005 17:33'!colorTable	"Answer the table to use to determine colors"	^ colorTable ifNil: [colorTable := ST80ColorTable]! !!TempVariableNode methodsFor: 'initialize-release' stamp: ''!nowHasDef	hasDefs := true! !!ParseNode class methodsFor: 'class initialization' stamp: ''!initialize	"ParseNode initialize. VariableNode initialize"	LdInstType := 1.	LdTempType := 2.	LdLitType := 3.	LdLitIndType := 4.	SendType := 5.	CodeBases := #(0 16 32 64 208 ).	CodeLimits := #(16 16 32 32 16 ).	LdSelf := 112.	LdTrue := 113.	LdFalse := 114.	LdNil := 115.	LdMinus1 := 116.	LoadLong := 128.	Store := 129.	StorePop := 130.	ShortStoP := 96.	SendLong := 131.	DblExtDoAll := 132.	SendLong2 := 134.	LdSuper := 133.	Pop := 135.	Dup := 136.	LdThisContext := 137.	EndMethod := 124.	EndRemote := 125.	Jmp := 144.	Bfp := 152.	JmpLimit := 8.	JmpLong := 164.  "code for jmp 0"	BtpLong := 168.	SendPlus := 176.	Send := 208.	SendLimit := 16! !!Scanner methodsFor: 'public access' stamp: ''!scanFieldNames: stringOrArray	"Answer an Array of Strings that are the identifiers in the input string, 	stringOrArray. If passed an Array, just answer with that Array, i.e., 	assume it has already been scanned."	| strm |	(stringOrArray isMemberOf: Array)		ifTrue: [^stringOrArray].	self scan: (ReadStream on: stringOrArray asString).	strm := WriteStream on: (Array new: 10).	[tokenType = #doIt]		whileFalse: 			[tokenType = #word ifTrue: [strm nextPut: token].			self scanToken].	^strm contents	"Scanner new scanFieldNames: 'abc  def ghi' ('abc' 'def' 'ghi' )"! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:25'!sizeCase: encoder value: forValue	| braceNode sizeIndex thenSize elseSize |	forValue not		ifTrue: [^super sizeForEffect: encoder].	equalNode := encoder encodeSelector: #=.	braceNode := arguments first.	sizes := Array new: 2 * braceNode numElements.	sizeIndex := sizes size.	elseSize := arguments size = 2		ifTrue:			[arguments last sizeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode := encoder encodeSelector: #caseError.			 1 + (caseErrorNode size: encoder args: 0 super: false)]. "self caseError"	braceNode casesReverseDo:		[:keyNode :valueNode :last |		sizes at: sizeIndex put: elseSize.		thenSize := valueNode sizeForEvaluatedValue: encoder.		last ifFalse: [thenSize := thenSize + 1]. "Pop"		valueNode returns ifFalse: [thenSize := thenSize + (self sizeJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize := elseSize + 1]. "Dup"		elseSize := elseSize + (keyNode sizeForEvaluatedValue: encoder) +			(equalNode size: encoder args: 1 super: false) +			(self sizeBranchOn: false dist: thenSize) + thenSize.		sizeIndex := sizeIndex - 2].	^(receiver sizeForValue: encoder) + elseSize! !!Parser methodsFor: 'private' stamp: ''!init: sourceStream notifying: req failBlock: aBlock	requestor := req.	failBlock := aBlock.	super scan: sourceStream.	prevMark := hereMark := mark.	requestorOffset := 0.	self advance! !!ColoredCodeStream class methodsFor: 'instance creation' stamp: 'md 8/15/2005 11:00'!contents: blockWithArg 	"Evaluate blockWithArg on a DialectStream of the given description"	| stream |	stream := self on: (Text new: 400).	blockWithArg value: stream.	^ stream contents! !!Encoder methodsFor: 'encoding' stamp: 'yo 11/11/2002 10:22'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode := self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [action value]].	range ifNotNil: [		name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !!Parser methodsFor: 'primitives' stamp: 'ar 12/2/1999 16:49'!externalType: descriptorClass	"Parse an return an external type"	| xType |	xType := descriptorClass atomicTypeNamed: here.	xType == nil ifTrue:["Look up from class scope"		Symbol hasInterned: here ifTrue:[:sym|			xType := descriptorClass structTypeNamed: sym]].	xType == nil ifTrue:[		"Raise an error if user is there"		self interactive ifTrue:[^nil].		"otherwise go over it silently"		xType := descriptorClass forceTypeNamed: here].	self advance.	(self matchToken:#*)		ifTrue:[^xType asPointerType]		ifFalse:[^xType]! !!MessageNode methodsFor: 'code generation' stamp: ''!sizeWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := (stmt sizeForEvaluatedEffect: encoder) + 2.	branchSize := self sizeBranchOn: (selector key == #whileFalse:)  "Btp for whileFalse"					dist: stmtSize.	loopSize := (cond sizeForEvaluatedValue: encoder)			+ branchSize + stmtSize.	sizes := Array with: stmtSize with: loopSize.	^ loopSize    " +1 for value (push nil) "		+ (forValue ifTrue: [1] ifFalse: [0])! !!Encoder methodsFor: 'error handling' stamp: ''!notify: string at: location	| req |	requestor == nil		ifFalse: 			[req := requestor.			self release.			req notify: string at: location].	^false! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 4/10/2005 22:46'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start := mark.	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanLitVec.			mark := start+1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(tokenType==#literal)						ifTrue:							[(token isSymbol)								ifTrue: "##word"									[token := token "May want to move toward ANSI here"]]						ifFalse:							[tokenType==#string ifTrue: [token := token asSymbol]]]].	mark := start.	tokenType := #literal"	#(Pen)	#Pen	#'Pen'	##Pen	###Pen"! !!Compiler methodsFor: 'public access' stamp: 'ab 3/23/2005 16:47'!compiledMethodFor: aString in: aContext to: aReceiver	"evaluate aString in the given context, and return the result.  2/2/96 sw"	| result |	result := self				compiledMethodFor: aString 				in: aContext 				to: aReceiver 				notifying: nil				ifFail: [^#Failed] 				logged: false.	^ result! !!PrimitiveNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 22:06'!printPrimitiveOn: aStream 	"Print the primitive on aStream"	| primIndex primDecl |	primIndex := primitiveNum.	primIndex = 0 ifTrue: [^ self].	primIndex = 120 ifTrue: [		"External call spec"		^ aStream print: spec].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue: [		primDecl := spec.		aStream nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut: $'.		(primDecl at: 1) ifNotNil: [			aStream nextPutAll: ' module: ';				nextPut: $';				nextPutAll: (primDecl at: 1);				nextPut: $'].	] ifFalse: [aStream print: primIndex].	aStream nextPut: $>.	(primIndex ~= 117 and: [primIndex ~= 120]) ifTrue: [		Smalltalk at: #Interpreter ifPresent: [:cls |			aStream nextPutAll: ' "', 				((cls classPool at: #PrimitiveTable) at: primIndex + 1) , '" '		].	].! !!Parser methodsFor: 'expression types' stamp: 'ar 1/4/2002 00:23'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [self interactive				ifFalse: [tempsMark := 1]				ifTrue: [tempsMark := requestor selectionInterval first].			^ #()].		tempsMark := (prevEnd ifNil: [0]) + 1.		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!ParseNode methodsFor: 'private' stamp: 'sma 5/28/2000 10:47'!nextWordFrom: aStream setCharacter: aBlock	| outStream char |	outStream := WriteStream on: (String new: 16).	[(aStream peekFor: Character space) 		or: [aStream peekFor: Character tab]] whileTrue.	[aStream atEnd		or:			[char := aStream next.			char = Character cr or: [char = Character space]]]		whileFalse: [outStream nextPut: char].	aBlock value: char.	^ outStream contents! !!SelectorNode methodsFor: 'code generation' stamp: 'di 1/7/2000 12:32'!size: encoder args: nArgs super: supered	| index |	self reserve: encoder.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])		ifTrue: [^1]. "short send"	(supered and: [code < Send]) ifTrue: 		["super special:"		code := self code: (encoder sharableLitIndex: key) type: 5].	index := code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7])		ifTrue: [^ 2]. "medium send"	(supered not and: [index <= 63 and: [nArgs <= 3]])		ifTrue: [^ 2]. "new medium send"	^ 3 "long send"! !!AssignmentNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 09:37'!analyseTempsWithin: scopeBlock "<BlockNode>"  rootNode: rootNode "<MethodNode>"	"N.B.  since assigment happens :=after:= the value is evaluated the value is sent the message :=first:=."	value analyseTempsWithin: scopeBlock rootNode: rootNode.	variable beingAssignedToAnalyseTempsWithin: scopeBlock rootNode: rootNode! !!DecompilerConstructor methodsFor: 'initialize-release' stamp: ''!method: aMethod class: aClass literals: literals	method := aMethod.	instVars := aClass allInstVarNames.	nArgs := method numArgs.	literalValues := literals! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:23'!emitIf: stack on: strm value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize := sizes at: 1.	elseSize := sizes at: 2.	(forValue not and: [(elseSize*thenSize) > 0])		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^ super emitForEffect: stack on: strm].	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	receiver emitForValue: stack on: strm.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitBranchOn: false dist: thenSize pop: stack on: strm.			pc := strm position.			thenExpr emitForEvaluatedValue: stack on: strm.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not				ifTrue:  "Elide jump over else after a return"					[self emitJump: elseSize on: strm].			elseExpr emitForEvaluatedValue: stack on: strm]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitBranchOn: false dist: thenSize pop: stack on: strm.					pc := strm position.					thenExpr emitForEvaluatedEffect: stack on: strm]				ifFalse:					[self emitBranchOn: true dist: elseSize pop: stack on: strm.					pc := strm position.					elseExpr emitForEvaluatedEffect: stack on: strm]]! !!AssignmentNode methodsFor: 'initialize-release' stamp: ''!variable: aVariable value: expression	variable := aVariable.	value := expression! !!Scanner methodsFor: 'expression types' stamp: ''!advance	| prevToken |	prevToken := token.	self scanToken.	^prevToken! !!Encoder methodsFor: 'initialize-release' stamp: ''!fillDict: dict with: nodeClass mapping: keys to: codeArray	| codeStream |	codeStream := ReadStream on: codeArray.	keys do: 		[:key | dict 				at: key				put:  (nodeClass new name: key key: key code: codeStream next)]! !!ColoredCodeStream class methodsFor: 'class initialization' stamp: 'wiz 9/12/2005 00:41'!initialize	"Initialize the colors that characterize the ST80 dialect"	ST80ColorTable := IdentityDictionary new.	#(	(temporaryVariable blue italic)		(methodArgument blue normal)		(methodSelector black bold)		(blockArgument red normal)		(comment brown normal)		(variable magenta normal)		(literal	orange normal)		(keyword darkGray bold)		(prefixKeyword veryDarkGray bold)		(setOrReturn black bold)) do:			[:aTriplet |				ST80ColorTable at: aTriplet first put: aTriplet allButFirst]"ColoredCodeStream initialize"! !!BlockNode methodsFor: 'equation translation' stamp: ''!statements: val	statements := val! !!MessageNode methodsFor: 'equation translation' stamp: 'RAA 2/14/2001 14:07'!receiver: val	"14 feb 2001 - removed return arrow"	receiver := val! !!Decompiler methodsFor: 'instruction decoding' stamp: ''!pushConstant: value	| node |	node := value == true ifTrue: [constTable at: 2]		ifFalse: [value == false ifTrue: [constTable at: 3]		ifFalse: [value == nil ifTrue: [constTable at: 4]		ifFalse: [constructor codeAnyLiteral: value]]].	stack addLast: node! !!MessageNode methodsFor: 'code generation' stamp: 'hmm 7/28/2001 14:36'!emitWhile: stack on: strm value: forValue 	" L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := sizes at: 1.	loopSize := sizes at: 2.	cond emitForEvaluatedValue: stack on: strm.	self emitBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack on: strm.   "Btp for whileFalse"	pc := strm position.	stmt emitForEvaluatedEffect: stack on: strm.	self emitJump: 0 - loopSize on: strm.	forValue ifTrue: [strm nextPut: LdNil. stack push: 1]! !!Decompiler methodsFor: 'private' stamp: ''!popTo: oldPos	| t |	t := Array new: statements size - oldPos.	(t size to: 1 by: -1) do:		[:i | t at: i put: statements removeLast].	^t! !!MessageNode methodsFor: 'code generation' stamp: 'acg 1/28/2000 22:00'!sizeIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (1 "pop" + (theNode sizeForEvaluatedValue: encoder))).			 ^(receiver sizeForValue: encoder) +				2 "Dup. LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeForEvaluatedEffect: encoder)).			 ^(receiver sizeForValue: encoder) +				1 "LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]! !!BlockNode methodsFor: 'accessing' stamp: ''!arguments: argNodes 	"Decompile."	arguments := argNodes! !!Encoder methodsFor: 'private' stamp: 'yo 11/11/2002 10:23'!possibleVariablesFor: proposedVariable	| results |	results := proposedVariable correctAgainstDictionary: scopeTable								continuedFrom: nil.	proposedVariable first canBeGlobalVarInitial ifTrue:		[ results := class possibleVariablesFor: proposedVariable						continuedFrom: results ].	^ proposedVariable correctAgainst: nil continuedFrom: results.! !!Encoder methodsFor: 'initialize-release' stamp: ''!release	requestor := nil! !!BlockNode methodsFor: 'code generation' stamp: 'hmm 7/17/2001 21:02'!emitForValue: stack on: aStream	aStream nextPut: LdThisContext.	stack push: 1.	nArgsNode emitForValue: stack on: aStream.	remoteCopyNode		emit: stack		args: 1		on: aStream.	"Force a two byte jump."	self emitLong: size code: JmpLong on: aStream.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitStorePop: stack on: aStream].	self emitForEvaluatedValue: stack on: aStream.	self returns ifFalse: [		aStream nextPut: EndRemote.		pc := aStream position.	].	stack pop: 1! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 10:55'!methodRefersOnlyOnceToTemp: offset	| nRefs byteCode extension scanner |	nRefs := 0.	offset <= 15		ifTrue:			[byteCode := 16 + offset.			(InstructionStream on: method) scanFor:				[:instr | instr = byteCode ifTrue: [nRefs := nRefs + 1].				nRefs > 1]]		ifFalse:			[extension := 64 + offset.			scanner := InstructionStream on: method.			scanner scanFor:				[:instr | (instr = 128 and: [scanner followingByte = extension])							ifTrue: [nRefs := nRefs + 1].				nRefs > 1]].	^ nRefs = 1! !!Encoder methodsFor: 'private' stamp: 'ar 1/2/2002 14:53'!possibleNamesFor: proposedName	| results |	results := class possibleVariablesFor: proposedName continuedFrom: nil.	^ proposedName correctAgainst: nil continuedFrom: results.! !!MessageNode methodsFor: 'code generation' stamp: 'tao 8/20/97 22:24'!emitCase: stack on: strm value: forValue	| braceNode sizeStream thenSize elseSize |	forValue not		ifTrue: [^super emitForEffect: stack on: strm].	braceNode := arguments first.	sizeStream := ReadStream on: sizes.	receiver emitForValue: stack on: strm.	braceNode casesForwardDo:		[:keyNode :valueNode :last |		thenSize := sizeStream next.		elseSize := sizeStream next.		last ifFalse: [strm nextPut: Dup. stack push: 1].		keyNode emitForEvaluatedValue: stack on: strm.		equalNode emit: stack args: 1 on: strm.		self emitBranchOn: false dist: thenSize pop: stack on: strm.		last ifFalse: [strm nextPut: Pop. stack pop: 1].		valueNode emitForEvaluatedValue: stack on: strm.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse: [self emitJump: elseSize on: strm]].	arguments size = 2		ifTrue:			[arguments last emitForEvaluatedValue: stack on: strm] "otherwise: [...]"		ifFalse:			[NodeSelf emitForValue: stack on: strm.			caseErrorNode emit: stack args: 0 on: strm]! !!MessageNode methodsFor: 'private' stamp: ''!receiver: rcvr arguments: args precedence: p	receiver := rcvr.	arguments := args.	sizes := Array new: arguments size.	precedence := p! !!Decompiler methodsFor: 'instruction decoding' stamp: 'nk 2/20/2004 11:56'!pushReceiverVariable: offset	| var |	(var := instVars at: offset + 1 ifAbsent: []) == nil		ifTrue:			["Not set up yet"			var := constructor codeInst: offset.			instVars size < (offset + 1) ifTrue: [				instVars := (Array new: offset + 1)					replaceFrom: 1 to: instVars size with: instVars; yourself ].			instVars at: offset + 1 put: var].	stack addLast: var! !!Encoder methodsFor: 'temps' stamp: 'jm 9/18/97 21:06'!bindArg: name 	"Declare an argument."	| node |	nTemps >= 15		ifTrue: [^self notify: 'Too many arguments'].	node := self bindTemp: name.	^ node nowHasDef nowHasRef! !!Compiler methodsFor: 'public access' stamp: 'sw 11/7/1999 00:11'!format: textOrStream in: aClass notifying: aRequestor decorated: aBoolean	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode := self format: sourceStream noPattern: false ifFail: [^ nil].	^ aBoolean		ifTrue: [aNode decompileText]		ifFalse: [aNode decompileString]! !!SelectorNode methodsFor: 'code generation' stamp: ''!emit: stack args: nArgs on: aStream super: supered	| index |	stack pop: nArgs.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]]) ifTrue:		["short send"		code < Send			ifTrue: [^ aStream nextPut: code "special"]			ifFalse: [^ aStream nextPut: nArgs * 16 + code]].	index := code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7]) ifTrue: 		["extended (2-byte) send [131 and 133]"		aStream nextPut: SendLong + (supered ifTrue: [2] ifFalse: [0]).		^ aStream nextPut: nArgs * 32 + index].	(supered not and: [index <= 63 and: [nArgs <= 3]]) ifTrue:		["new extended (2-byte) send [134]"		aStream nextPut: SendLong2.		^ aStream nextPut: nArgs * 64 + index].	"long (3-byte) send"	aStream nextPut: DblExtDoAll.	aStream nextPut: nArgs + (supered ifTrue: [32] ifFalse: [0]).	aStream nextPut: index! !!BraceNode methodsFor: 'code generation' stamp: 'di 11/19/1999 11:13'!sizeForValue: encoder	emitNode := elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^ emitNode sizeForValue: encoder! !!Parser methodsFor: 'expression types' stamp: 'yo 8/30/2002 14:41'!messagePart: level repeat: repeat	| start receiver selector args precedence words keywordStart |	[receiver := parseNode.	(hereType == #keyword and: [level >= 3])		ifTrue: 			[start := self startOfNextToken.			selector := WriteStream on: (String new: 32).			args := OrderedCollection new.			words := OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[keywordStart := self startOfNextToken + requestorOffset.					selector nextPutAll: self advance.					words addLast: (keywordStart to: self endOfLastToken + requestorOffset).					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 2 repeat: true.					args addLast: parseNode].			(Symbol hasInterned: selector contents ifTrue: [ :sym | selector := sym])				ifFalse: [ selector := self correctSelector: selector contents										wordIntervals: words										exprInterval: (start to: self endOfLastToken)										ifAbort: [ ^ self fail ] ].			precedence := 3]		ifFalse: [((hereType == #binary or: [hereType == #verticalBar])				and: [level >= 2])				ifTrue: 					[start := self startOfNextToken.					selector := self advance asOctetString asSymbol.					self primaryExpression ifFalse: [^self expected: 'Argument'].					self messagePart: 1 repeat: true.					args := Array with: parseNode.					precedence := 2]				ifFalse: [hereType == #word						ifTrue: 							[start := self startOfNextToken.							selector := self advance.							args := #().							words := OrderedCollection with: (start  + requestorOffset to: self endOfLastToken + requestorOffset).							(Symbol hasInterned: selector ifTrue: [ :sym | selector := sym])								ifFalse: [ selector := self correctSelector: selector													wordIntervals: words													exprInterval: (start to: self endOfLastToken)													ifAbort: [ ^ self fail ] ].							precedence := 1]						ifFalse: [^args notNil]]].	parseNode := MessageNode new				receiver: receiver				selector: selector				arguments: args				precedence: precedence				from: encoder				sourceRange: (start to: self endOfLastToken).	repeat]		whileTrue: [].	^true! !!BraceNode methodsFor: 'enumerating' stamp: ''!casesReverseDo: aBlock	"For each case in reverse order, evaluate aBlock with three arguments:	 the key block, the value block, and whether it is the last case."	| numCases case |	(numCases := elements size) to: 1 by: -1 do:		[:i |		case := elements at: i.		aBlock value: case receiver value: case arguments first value: i=numCases]! !!MessageNode methodsFor: 'cascading' stamp: ''!cascadeReceiver	"Nil out rcvr (to indicate cascade) and return what it had been."	| rcvr |	rcvr := receiver.	receiver := nil.	^rcvr! !TempVariableNode removeSelector: #asMorphicSyntaxIn:!BlockNode removeSelector: #asMorphicCollectSyntaxIn:!MessageNode removeSelector: #asMorphicSyntaxIn:!MethodNode removeSelector: #asMorphicSyntaxIn:!VariableNode removeSelector: #currentValueIn:!VariableNode removeSelector: #asMorphicSyntaxIn:!BraceNode removeSelector: #asMorphicSyntaxIn:!ParseNode removeSelector: #addCommentToMorph:!VariableNode removeSelector: #variableGetterBlockIn:!CascadeNode removeSelector: #asMorphicSyntaxIn:!AssignmentNode removeSelector: #asMorphicSyntaxIn:!LiteralNode removeSelector: #asMorphicSyntaxIn:!BlockNode removeSelector: #asMorphicSyntaxIn:!ParseNode removeSelector: #currentValueIn:!ReturnNode removeSelector: #asMorphicSyntaxIn:!MethodNode removeSelector: #asMorphicSyntaxUsing:!ParseNode removeSelector: #asMorphicSyntaxIn:!Decompiler initialize!VariableNode initialize!ParseNode initialize!ColoredCodeStream initialize!