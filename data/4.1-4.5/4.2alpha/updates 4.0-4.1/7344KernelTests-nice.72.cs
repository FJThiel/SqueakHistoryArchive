"Change Set:		7344KernelTests-nice.72KernelTests-nice.72:Test forhttp://bugs.squeak.org/view.php?id=69900.0 significandAsIntegerKernelTests-ar.68:Underscore removal.KernelTests-nice.70:Tests for both:http://bugs.squeak.org/view.php?id=6729Float infinity closeTo: Float infinity negated.http://bugs.squeak.org/view.php?id=73681.0 closeTo: 200 factorial.KernelTests-nice.71:Test forhttp://bugs.squeak.org/view.php?id=7134Float rounded is inexact"!!IntegerTest methodsFor: 'tests - instance creation' stamp: 'dtl 9/18/2004 17:14'!testReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: '.s could be confused with a ScaledDecimal' = s! !!FloatTest methodsFor: 'testing - conversion' stamp: 'dtl 9/18/2004 12:40'!testStringAsNumber	"This covers parsing in Number>>readFrom:"	| aFloat |	aFloat := '10r-12.3456' asNumber.	self assert: -12.3456 = aFloat.	aFloat := '10r-12.3456e2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456d2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '12.3456q2' asNumber.	self assert: 1234.56 = aFloat.! !!YearMonthWeekTest methodsFor: 'running' stamp: 'brp 9/26/2004 19:26'!setUp	restoredStartDay := Week startDay.	restoredTimeZone := DateAndTime localTimeZone.	Week startDay: #Sunday.	DateAndTime localTimeZone: (TimeZone timeZones detect: [:tz | tz abbreviation = 'GMT']).! !!InstVarRefLocatorTest methodsFor: 'private' stamp: 'md 4/8/2003 12:39'!hasInstVarRef: aMethod	"Answer whether the receiver references an instance variable."	| scanner end printer |	scanner := InstructionStream on: aMethod.	printer := InstVarRefLocator new.	end := scanner method endPC.	[scanner pc <= end] whileTrue: [		(printer interpretNextInstructionUsing: scanner) ifTrue: [^true].	].	^false! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/24/2003 22:56'!testNew	| sw |	sw := Stopwatch new.		self 		assert: (sw isSuspended);		assert: (sw state = #suspended);		deny: (sw isActive);		assert: (sw timespans isEmpty)! !!MonitorTest methodsFor: 'examples' stamp: 'md 3/19/2006 21:19'!testExample2	"Here is a second version that does not use a semaphore to inform the 	forking process about termination of both forked processes"	| producer1 producer2  monitor goal work counter goalReached activeProducers|	goal := (1 to: 1000) asOrderedCollection.	work := OrderedCollection new.	counter := 0.	goalReached := false.	activeProducers := 0.	monitor := Monitor new.  producer1 :=      [ monitor critical: [activeProducers := activeProducers + 1].  [monitor critical:            [monitor waitUntil: [counter \\5 = 0].      goalReached or: [work add: (counter := counter + 1)].     " Transcript show: 'P1  '; show: counter printString; show: '  ';       show: activeProducers printString; cr."      goalReached := counter >= goal size.      monitor signal            ].           goalReached          ]             whileFalse.         monitor critical: [activeProducers := activeProducers - 1.        monitor signal: #finish]. ] . producer2 :=    [monitor critical: [activeProducers := activeProducers + 1].  [monitor critical:          [monitor waitWhile: [counter \\5 = 0].    goalReached or: [work add: (counter := counter + 1)].    goalReached := counter >= goal size.    monitor signal].         goalReached ] whileFalse.     monitor critical: [		activeProducers := activeProducers - 1. 		monitor signal: #finish].	].	producer1 forkAt: Processor userBackgroundPriority.	producer2  forkAt: Processor userBackgroundPriority.	monitor critical: [		monitor waitUntil: [activeProducers = 0 & (goalReached)]				for: #finish.  	].	self assert: goal = work! !!MethodContextTest methodsFor: 'running' stamp: 'tlk 5/31/2004 16:18'!setUp	super setUp.	aCompiledMethod := Rectangle methodDict at: #rightCenter.	aReceiver := 100@100 corner: 200@200.	aSender := thisContext.	aMethodContext := MethodContext sender: aSender receiver: aReceiver method: aCompiledMethod arguments: #(). ! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'dtl 11/24/2004 14:29'!testFloatFromStreamAsNumber	"This covers parsing in Number>>readFrom:"	| rs aFloat |	rs := '10r-12.3456' readStream.	aFloat := Number readFrom: rs.	self assert: -12.3456 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456e2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456e2e2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs upToEnd = 'e2'.	rs := '10r-12.3456d2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '10r-12.3456q2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '-12.3456q2' readStream.	aFloat := Number readFrom: rs.	self assert: -1234.56 = aFloat.	self assert: rs atEnd.	rs := '12.3456q2' readStream.	aFloat := Number readFrom: rs.	self assert: 1234.56 = aFloat.	self assert: rs atEnd.	rs := '12.3456z2' readStream.	aFloat := Number readFrom: rs.	self assert: 12.3456 = aFloat.	self assert: rs upToEnd = 'z2'.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:28'!testAsNumberWithRadix	| sd |	sd := '10r-22.2s5' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 5.	self assert: '-22.20000s5' = sd printString.! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!tearDown	super tearDown.	month := nil.! !!FloatTest methodsFor: 'testing compare' stamp: 'nice 7/19/2009 19:24'!testCloseTo	self deny: (Float nan closeTo: Float nan) description: 'NaN isn''t close to anything'.	self deny: (Float nan closeTo: 1.0) description: 'NaN isn''t close to anything'.	self deny: (1.0 closeTo: Float nan) description: 'NaN isn''t close to anything'.		self deny: (-1.0 closeTo: 1.0).	self deny: (1.0 closeTo: Float infinity).	self assert: (Float infinity closeTo: Float infinity) description: 'since they are =, they also are closeTo:'.		self assert: (1.0/3.0 closeTo: 1/3).	self assert: (1.0e-8 closeTo: 0).	self assert: (0 closeTo: 1.0e-8).	self assert: (1+1.0e-8 closeTo: 1.0).		self assert: (1000000001.0 closeTo: 1000000000.0).	self deny: (1000000001 closeTo: 1000000000) description: 'exact representation are considered closeTo: only if equal'.! !!FloatTest methodsFor: 'zero behavior' stamp: 'nice 3/23/2008 16:00'!testZeroSignificandAsInteger	"This is about http://bugs.squeak.org/view.php?id=6990"		self assert: 0.0 significandAsInteger = 0! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 13:38'!testLiteral	| sd |	sd := 1.40s2.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '1.40s2' = sd printString! !!FloatTest methodsFor: 'infinity behavior' stamp: 'nice 7/14/2009 09:32'!testHugeIntegerCloseTo	"This is a test for bug http://bugs.squeak.org/view.php?id=7368"	 	"FloatTest new testHugeIntegerCloseTo"	self deny: (1.0 closeTo: 200 factorial).	self deny: (200 factorial closeTo: 1.0).	self assert: (Float infinity closeTo: 200 factorial) = (200 factorial closeTo: Float infinity).! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'dtl 11/24/2004 14:12'!testFloatFromStringWithExponent	"This covers parsing in Number>>readFrom:"	| aFloat |	aFloat := '1.0e-14' asNumber.	self assert: 1.0e-14 = aFloat.	aFloat := '1.0e-14 1' asNumber.	self assert: 1.0e-14 = aFloat.	aFloat := '1.0e-14e' asNumber.	self assert: 1.0e-14 = aFloat.	aFloat := '1.0e14e' asNumber.	self assert: 1.0e14 = aFloat.	aFloat := '1.0e+14e' asNumber. "Plus sign is not parseable"	self assert: 1.0 = aFloat.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'BG 11/7/2004 12:18'!testTimeZoneEquivalence  "DateAndTimeTest new testTimeZoneEquivalence"	"When the clock on the wall in Detroit says 9:00am, the clock on the wall	in London says 2:00pm. The Duration difference between the corresponding	DateAndTime values should be zero."		 " Detroit is 5 hours behind UTC, this offset to UTC is therefore written with a minus sign. This example tests both the correct interpretation of the DateAndTime denotation and correct DateAndTime arithmetics. "	| twoPmInLondon nineAmInDetroit durationDifference |	twoPmInLondon := '2004-11-02T14:00:00+00:00' asDateAndTime.	nineAmInDetroit  := '2004-11-02T09:00:00-05:00' asDateAndTime.	durationDifference := twoPmInLondon - nineAmInDetroit.	self assert: durationDifference asSeconds = 0.	self assert: twoPmInLondon = nineAmInDetroit! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 11:06'!testConvertFromInteger	"Converting an Integer to a ScaledDecimal yields a ScaledDecimal with	scale 0, regardless of the scale specified in the #asScaledDecimal: message."	| sd |	sd := 13 asScaledDecimal: 6.	self assert: 0 = sd scale.	self assert: ('13s0' = sd printString).	sd := -13 asScaledDecimal: 6.	self assert: 0 = sd scale.	self assert: ('-13s0' = sd printString).	sd := 130000000013 asScaledDecimal: 6.	self assert: 0 = sd scale.	self assert: ('130000000013s0' = sd printString).	sd := -130000000013 asScaledDecimal: 6.	self assert: 0 = sd scale.	self assert: ('-130000000013s0' = sd printString)! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:12'!testNNegatedEqualsNComplementedPlusOne	"Verify that n negated = (n complemented + 1) for single bits"	| n |	1 to: 100 do: [:i | n := 1 bitShift: i.				self assert: n negated = ((n bitXor: -1) + 1)]! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:56'!testReset	| sw |	sw := Stopwatch new.	sw activate.		sw reset.	self 		assert: (sw isSuspended);		assert: (sw timespans isEmpty)! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/21/2004 18:36'!testModulo	| d1 d2 d3 |	d1 := 11.5 seconds.	d2 := d1 \\ 3.	self assert: d2 = (Duration nanoSeconds: 1).	d3 := d1 \\ (3 seconds).	self assert: d3 =  (Duration seconds: 2 nanoSeconds: 500000000).	self assert: aDuration \\ aDuration = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 0). 	self assert: aDuration \\ 2 = 		(Duration days: 0 hours: 0 minutes: 0 seconds: 0 nanoSeconds: 1).	! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:32'!testComparing	| d1 d2 d3 |	d1 := Duration seconds: 10 nanoSeconds: 1.	d2 := Duration seconds: 10 nanoSeconds: 1.	d3 := Duration seconds: 10 nanoSeconds: 2.		self		assert: (d1 = d1);		assert: (d1 = d2);		deny: (d1 = d3);		assert: (d1 < d3)! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'dtl 11/24/2004 14:07'!testFloatFromStringAsNumber	"This covers parsing in Number>>readFrom:"	| aFloat |	aFloat := '10r-12.3456' asNumber.	self assert: -12.3456 = aFloat.	aFloat := '10r-12.3456e2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456d2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '10r-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '-12.3456q2' asNumber.	self assert: -1234.56 = aFloat.	aFloat := '12.3456q2' asNumber.	self assert: 1234.56 = aFloat.! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 11:45'!testActive	| sw |	sw := Stopwatch new.	sw activate.		1 seconds asDelay wait.	self 		assert: (sw duration >= 1 seconds).	2 seconds asDelay wait.	self 		assert: (sw duration >= 3 seconds).	sw suspend.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 17:00'!testArithmeticAcrossDateBoundary	| t1 t2 |	t1 := '2004-01-07T11:55:00+00:00' asDateAndTime. 	t2 := t1 - ( (42900+1) seconds).  	self 		assert: t2 = ('2004-01-06T23:59:59+00:00' asDateAndTime)		! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'sd 6/5/2005 08:46'!testDifferentBases	"self run: #testDifferentBases"	"| value |	2 to: 36 do: [:each|		value := 0.		1 to: each-1 do: [:n| value := value + (n * (each raisedToInteger: n))].		value := value negated.		Transcript tab; show: 'self assert: (', value printString, ' printStringBase: ', each printString, ') = ''', (value printStringBase: each), '''.'; cr.		Transcript tab; show: 'self assert: (', value printString, ' radix: ', each printString, ') = ''', (value radix: each), '''.'; cr.		Transcript tab; show: 'self assert: ', value printString, ' printStringHex = ''', (value printStringBase: 16), '''.'; cr.		Transcript tab; show: 'self assert: (', value printString, ' storeStringBase: ', each printString, ') = ''', (value storeStringBase: each), '''.'; cr.		Transcript tab; show: 'self assert: ', value printString, ' storeStringHex = ''', (value storeStringBase: 16), '''.'; cr.].	"	self assert: 2r10 = 2.	self assert: 3r210 = 21.	self assert: 4r3210 = 228.	self assert: 5r43210 = 2930.	self assert: 6r543210 = 44790.	self assert: 7r6543210 = 800667.	self assert: 8r76543210 = 16434824.	self assert: 9r876543210 = 381367044.	self assert: 10r9876543210 = 9876543210.	self assert: 11rA9876543210 = 282458553905.	self assert: 12rBA9876543210 = 8842413667692.	self assert: 13rCBA9876543210 = 300771807240918.	self assert: 14rDCBA9876543210 = 11046255305880158.	self assert: 15rEDCBA9876543210 = 435659737878916215.	self assert: 16rFEDCBA9876543210 = 18364758544493064720.	self assert: 17rGFEDCBA9876543210 = 824008854613343261192.	self assert: 18rHGFEDCBA9876543210 = 39210261334551566857170.	self assert: 19rIHGFEDCBA9876543210 = 1972313422155189164466189.	self assert: 20rJIHGFEDCBA9876543210 = 104567135734072022160664820.	self assert: 21rKJIHGFEDCBA9876543210 = 5827980550840017565077671610.	self assert: 22rLKJIHGFEDCBA9876543210 = 340653664490377789692799452102.	self assert: 23rMLKJIHGFEDCBA9876543210 = 20837326537038308910317109288851.	self assert: 24rNMLKJIHGFEDCBA9876543210 = 1331214537196502869015340298036888.	self assert: 25rONMLKJIHGFEDCBA9876543210 = 88663644327703473714387251271141900.	self assert: 26rPONMLKJIHGFEDCBA9876543210 = 6146269788878825859099399609538763450.	self assert: 27rQPONMLKJIHGFEDCBA9876543210 = 442770531899482980347734468443677777577.	self assert: 28rRQPONMLKJIHGFEDCBA9876543210 = 33100056003358651440264672384704297711484.	self assert: 29rSRQPONMLKJIHGFEDCBA9876543210 = 2564411043271974895869785066497940850811934.	self assert: 30rTSRQPONMLKJIHGFEDCBA9876543210 = 205646315052919334126040428061831153388822830.	self assert: 31rUTSRQPONMLKJIHGFEDCBA9876543210 = 17050208381689099029767742314582582184093573615.	self assert: 32rVUTSRQPONMLKJIHGFEDCBA9876543210 = 1459980823972598128486511383358617792788444579872.	self assert: 33rWVUTSRQPONMLKJIHGFEDCBA9876543210 = 128983956064237823710866404905431464703849549412368.	self assert: 34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 = 11745843093701610854378775891116314824081102660800418.	self assert: 35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = 1101553773143634726491620528194292510495517905608180485.	self assert: 36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = 106300512100105327644605138221229898724869759421181854980.	self assert: -2r10 = -2.	self assert: -3r210 = -21.	self assert: -4r3210 = -228.	self assert: -5r43210 = -2930.	self assert: -6r543210 = -44790.	self assert: -7r6543210 = -800667.	self assert: -8r76543210 = -16434824.	self assert: -9r876543210 = -381367044.	self assert: -10r9876543210 = -9876543210.	self assert: -11rA9876543210 = -282458553905.	self assert: -12rBA9876543210 = -8842413667692.	self assert: -13rCBA9876543210 = -300771807240918.	self assert: -14rDCBA9876543210 = -11046255305880158.	self assert: -15rEDCBA9876543210 = -435659737878916215.	self assert: -16rFEDCBA9876543210 = -18364758544493064720.	self assert: -17rGFEDCBA9876543210 = -824008854613343261192.	self assert: -18rHGFEDCBA9876543210 = -39210261334551566857170.	self assert: -19rIHGFEDCBA9876543210 = -1972313422155189164466189.	self assert: -20rJIHGFEDCBA9876543210 = -104567135734072022160664820.	self assert: -21rKJIHGFEDCBA9876543210 = -5827980550840017565077671610.	self assert: -22rLKJIHGFEDCBA9876543210 = -340653664490377789692799452102.	self assert: -23rMLKJIHGFEDCBA9876543210 = -20837326537038308910317109288851.	self assert: -24rNMLKJIHGFEDCBA9876543210 = -1331214537196502869015340298036888.	self assert: -25rONMLKJIHGFEDCBA9876543210 = -88663644327703473714387251271141900.	self assert: -26rPONMLKJIHGFEDCBA9876543210 = -6146269788878825859099399609538763450.	self assert: -27rQPONMLKJIHGFEDCBA9876543210 = -442770531899482980347734468443677777577.	self assert: -28rRQPONMLKJIHGFEDCBA9876543210 = -33100056003358651440264672384704297711484.	self assert: -29rSRQPONMLKJIHGFEDCBA9876543210 = -2564411043271974895869785066497940850811934.	self assert: -30rTSRQPONMLKJIHGFEDCBA9876543210 = -205646315052919334126040428061831153388822830.	self assert: -31rUTSRQPONMLKJIHGFEDCBA9876543210 = -17050208381689099029767742314582582184093573615.	self assert: -32rVUTSRQPONMLKJIHGFEDCBA9876543210 = -1459980823972598128486511383358617792788444579872.	self assert: -33rWVUTSRQPONMLKJIHGFEDCBA9876543210 = -128983956064237823710866404905431464703849549412368.	self assert: -34rXWVUTSRQPONMLKJIHGFEDCBA9876543210 = -11745843093701610854378775891116314824081102660800418.	self assert: -35rYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = -1101553773143634726491620528194292510495517905608180485.	self assert: -36rZYXWVUTSRQPONMLKJIHGFEDCBA9876543210 = -106300512100105327644605138221229898724869759421181854980.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:49'!testAsNumberWithoutDecimalPoint	| sd |	sd := '123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 0.	self assert: '123s0' = sd printString.! !!FloatTest methodsFor: 'infinity behavior' stamp: 'nice 10/17/2007 23:54'!testInfinityCloseTo	"This is a test for bug http://bugs.squeak.org/view.php?id=6729:"	 	"FloatTest new testInfinityCloseTo"	self deny: (Float infinity closeTo: Float infinity negated).	self deny: (Float infinity negated closeTo: Float infinity).! !!YearTest methodsFor: 'Tests' stamp: 'brp 9/11/2003 14:30'!testCurrent	| yyyy |	yyyy := DateAndTime now year.		self assert: Year current start = (DateAndTime year: yyyy month: 1 day: 1)! !!WeekTest methodsFor: 'Running' stamp: 'brp 9/26/2004 18:53'!tearDown	super tearDown.	Week startDay: restoredStartDay.	week := nil.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:43'!testSmalltalk80Accessors	| t |	t := DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t hours = t hours);		assert: (t minutes = t minute);		assert: (t seconds = t second).! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:51'!testAsNumberWithoutDecimalPoint2	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '123.00s2' = sd printString.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/7/2004 13:00'!testDateTimeDenotation1  "DateAndTimeTest new testDateTimeDenotation1"		 " Detroit is 5 hours behind UTC, this offset to UTC is therefore written with a minus sign. This example tests the correct interpretation of the DateAndTime denotation. "	| twoPmInLondon twoPmUTCInLocalTimeOfDetroit nineAmInDetroit |	twoPmInLondon := DateAndTime				year: 2004				month: 11				day: 2				hour: 14				minute: 0				second: 0				offset: 0 hours.	twoPmUTCInLocalTimeOfDetroit := twoPmInLondon utcOffset: -5 hours.	nineAmInDetroit  := '2004-11-02T09:00:00-05:00' asDateAndTime.	self assert:  twoPmUTCInLocalTimeOfDetroit = nineAmInDetroit.	! !!InstructionPrinterTest methodsFor: 'examples' stamp: 'md 4/8/2003 12:28'!example1	| ff|	(1 < 2) ifTrue: [tt ifNotNil: [ff := 'hallo']].	^ ff.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 11:51'!testPrintString	"The printed representation of a ScaledDecimal is truncated, not rounded.	Not sure if this is right, so this test describes the current Squeak implementation.	If someone knows a reason that rounding would be preferable, then update	this test."	| sd |	sd := (13 / 11) asScaledDecimal: 6.	self assert: ('1.181818s6' = sd printString).	sd := (13 / 11) asScaledDecimal: 5.	self deny: ('1.18182s5' = sd printString).	sd := (13 / 11) asScaledDecimal: 5.	self assert: ('1.18181s5' = sd printString)! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 16:49'!testUnion	| union |	union := timespan union: timespan.		self 		assert: (union start = timespan start);		assert: (union duration = timespan duration)! !!TimeStampTest methodsFor: 'testing' stamp: 'cbc 2/4/2004 21:18'!testReadFromA1	|ts|	ts := TimeStamp current.	self assert: (ts = (TimeStamp fromString: ts asString)).! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:21'!testAsNumberWithExtendedScale	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '123.00s2' = sd printString.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 3/12/2004 15:54'!testComparing	| ts1 ts2 ts3 c1 c2 le |	ts1 := self timestampClass date: ('01-10-2000' asDate) time: ('11:55:00 am' asTime).	ts2 := self timestampClass date: ('07-26-2003' asDate) time: ('22:09:45 am' asTime).	ts3 := self timestampClass date: ('05-28-1972' asDate) time: ('04:31:14 pm' asTime).	self		assert: ts1 = timestamp;		assert: ts1 hash = timestamp hash;		assert: timestamp = timestamp copy;		assert: ts1 < ts2;		deny: ts1 < ts3.	c1 := self timestampClass current.	c2 := self timestampClass current.	le := (c1 <= c2).	self assert: le.! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 9/15/2003 14:29'!testArithmetic	| ts1 ts2 d |	ts1 := timespan + 2 days.	ts2 := ts1 - 2 days.	d := ts1 - (DateAndTime year: 2003 month: 03 day: 20).	self 		assert: (ts1 start = 				 (DateAndTime year: 2003 month: 03 day: 24 hour: 12 minute: 0 second: 0));		assert: (ts1 duration = timespan duration);		assert: (ts2 start = timespan start);		assert: (ts2 duration = timespan duration).	self		assert: d = (Duration days: 4 hours: 12 minutes: 0 seconds: 0)! !!DurationTest methodsFor: 'Tests' stamp: 'brp 1/16/2004 14:17'!testMonthDurations	| jan feb dec |	jan := Duration month: #January.	feb := Duration month: #February.	dec := Duration month: #December.		self 		assert: jan = (Year current months first duration);		assert: feb = (Year current months second duration);		assert: dec = (Year current months last duration)		! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'brp 9/26/2004 18:31'!testMonthPrintOn    	| aMonth cs rw |	aMonth := Month starting: DateAndTime new duration: 31 days.  	cs := ReadStream on: 'January 1901'.	rw := ReadWriteStream on: ''.     aMonth printOn: rw.     self assert: rw contents = cs contents.! !!BlockContextTest methodsFor: 'setup' stamp: 'md 9/6/2005 19:56'!setUp	super setUp.	aBlockContext := [100@100 corner: 200@200].	contextOfaBlockContext := thisContext.! !!BlockContextTest methodsFor: 'tests' stamp: 'mjr 8/24/2003 18:25'!testOneArgument	| c |	c := OrderedCollection new.	c add: 'hello'.	[c		do: [1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 0 arguments.'].	[c		do: [:arg1 :arg2 | 1 + 2]]		ifError: [:err :rcvr | self deny: err = 'This block requires 2 arguments.'] ! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'dtl 11/24/2004 18:18'!testIntegerReadWithRadix	"This covers parsing in Number>>readFrom:	Note: In most Smalltalk dialects, the radix notation is not used for numbers	with exponents. In Squeak, a string with radix and exponent can be parsed,	and the exponent is always treated as base 10 (not the base indicated in the	radix prefix). I am not sure if this is a feature, a bug, or both, but the	Squeak behavior is documented in this test. -dtl"	| aNumber rs |	aNumber := '2r1e26' asNumber.	self assert: 67108864 = aNumber.	self assert: (Number readFrom: '2r1e26') = (2 raisedTo: 26).	rs := '2r1e26eee' readStream.	self assert: (Number readFrom: rs) = 67108864.	self assert: rs upToEnd = 'eee'! !!YearMonthWeekTest methodsFor: 'testing' stamp: 'brp 9/26/2004 18:32'!testYearPrintOn    	| aYear cs rw |	aYear := Year starting: DateAndTime new duration: 365 days. 	cs := ReadStream on: 'a Year (1901)'.	rw := ReadWriteStream on: ''.     aYear printOn: rw.     self assert: rw contents = cs contents.! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'tween 7/8/2006 12:31'!testIntegerReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: '.s could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123sA has unary message sA'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 'sA has unary message sA' = s.		rs := ReadStream on: '123sB has unary message sB'.	i := Number readFrom: rs.	self assert: i == 123.	s := rs upToEnd.	self assert: 'sB has unary message sB' = s.! !!TimeStampTest methodsFor: 'Tests' stamp: 'brp 8/23/2003 17:47'!testSorting	| c1 c2 |	c1 := self timestampClass current.	c2 := self timestampClass current.	self		assert: (self timestampClass current) <= (self timestampClass current);		assert: (c1 <= c2).! !!FloatTest methodsFor: 'testing - conversion' stamp: 'nice 7/24/2008 02:04'!testFloatRounded	"5000000000000001 asFloat has an exact representation (no round off error).	It should round to nearest integer without loosing bits.	This is a no regression test on http://bugs.squeak.org/view.php?id=7134"		| x y int r |		"This is a preamble asserting exactness of representation	and quality of various conversions"	int := 5000000000000001.	x := int asFloat.	y := (5 asFloat squared squared squared squared timesTwoPower: 15) + 1.	self assert: x = y.	self assert: x asTrueFraction = int.		"this one should be true for any float	in order to conform to ISO/IEC 10967-2"	self assert: x rounded = x asTrueFraction rounded.	self assert: x negated rounded = x negated asTrueFraction rounded.	"a random test"	r := Random new.	10000 timesRepeat: [		x := r next * 1.9999e16 + 1.0e12 .		self assert: x rounded = x asTrueFraction rounded.		self assert: x negated rounded = x negated asTrueFraction rounded]! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'brp 1/7/2004 15:37'!testInstanceCreation	| t |	t := DateAndTime 			year: 1 month: 1 day: 2 			hour: 2 minute: 3 second: 4 nanoSecond: 5 			offset: 6 hours.	self 		assert: (t julianDayNumber = 1721427);		assert: (t offset = 6 hours);		assert: (t hour = 2);		assert: (t minute = 3);		assert: (t second = 4);		assert: (t nanoSecond = 5).		! !!DurationTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:38'!testPrintOn    	|cs rw |	cs := ReadStream on: '1:02:03:04.000000005'.	rw := ReadWriteStream on: ''.     aDuration printOn: rw.     self assert: rw contents = cs contents.! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/7/2004 13:01'!testDateTimeDenotation2  "DateAndTimeTest new testDateTimeDenotation2"		 " Moscow is 3 hours ahead UTC, this offset to UTC is therefore positive. This example tests the correct interpretation of the DateAndTime denotation. "	| lateEveningInLondon lateEveningInLocalTimeOfMoscow	 localMoscowTimeFromDenotation |	lateEveningInLondon := DateAndTime				year: 2004				month: 11				day: 30				hour: 23				minute: 30				second: 0				offset: 0 hours.	lateEveningInLocalTimeOfMoscow := lateEveningInLondon utcOffset: 3 hours.	localMoscowTimeFromDenotation  := '2004-12-01T02:30:00+03:00' asDateAndTime.	self assert:  lateEveningInLocalTimeOfMoscow = localMoscowTimeFromDenotation.	! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:04'!testConvertFromFloat	| aFloat sd f2 diff |	aFloat := 11/13 asFloat.	sd := aFloat asScaledDecimal: 2.	self assert: 2 == sd scale.	self assert: '0.84s2' = sd printString.	f2 := sd asFloat.	diff := f2 - aFloat.	self assert: diff < 1.0e-9. "actually, f = f2, but this is not a requirement"! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'dtl 11/24/2004 18:16'!testFloatReadWithRadix	"This covers parsing in Number>>readFrom:	Note: In most Smalltalk dialects, the radix notation is not used for numbers	with exponents. In Squeak, a string with radix and exponent can be parsed,	and the exponent is always treated as base 10 (not the base indicated in the	radix prefix). I am not sure if this is a feature, a bug, or both, but the	Squeak behavior is documented in this test. -dtl"	| aNumber rs |	aNumber := '2r1.0101e9' asNumber.	self assert: 672.0 = aNumber.	self assert: (Number readFrom: '2r1.0101e9') = (1.3125 * (2 raisedTo: 9)).	rs := ReadStream on: '2r1.0101e9e9'.	self assert: (Number readFrom: rs) = 672.0.	self assert: rs upToEnd = 'e9'! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:20'!testAsNumberWithSuperfluousDecimalPoint	| sd |	sd := '123.s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '123.00s2' = sd printString.! !!MonitorTest methodsFor: 'examples' stamp: 'md 3/19/2006 21:15'!testExample1	| producer1 producer2  monitor goal work counter goalReached finished |	goal := (1 to: 1000) asOrderedCollection.	work := OrderedCollection new.	counter := 0.	goalReached := false.	finished := Semaphore new.	monitor := Monitor new.	producer1 := [       [monitor critical:             [monitor waitUntil: [counter \\5 = 0].              goalReached or: [work add: (counter := counter + 1)].              goalReached := counter >= goal size.              monitor signal            ].           goalReached          ]             whileFalse.         finished signal.	].	producer2 := [         [monitor critical:                [monitor waitWhile: [counter \\5 = 0].                 goalReached or: [work add: (counter := counter + 1)].                 goalReached := counter >= goal size.                 monitor signal].         goalReached       ] whileFalse.     finished signal	].	producer1 forkAt: Processor userBackgroundPriority.	producer2 forkAt: Processor userBackgroundPriority.	finished wait; wait.	self assert: goal = work! !!InstVarRefLocatorTest methodsFor: 'tests' stamp: 'md 4/8/2003 12:35'!testInstructions	| scanner end printer methods |	methods := Object methodDict values. 	methods do: [:method |		scanner := InstructionStream on: method.		printer := InstVarRefLocator new.		end := scanner method endPC.		[scanner pc <= end] whileTrue: [			self shouldnt: [printer interpretNextInstructionUsing: scanner] raise: Error.		].	].! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'dtl 11/5/2004 05:45'!testPrintString	"(self new setTestSelector: #testPrintString) debug"	| dt |	dt :=DateAndTime		year: 2004		month: 11		day: 2		hour: 14		minute: 3		second: 5		nanoSecond: 12345		offset: (Duration seconds: (5 * 3600)).	self assert: dt printString = '2004-11-02T14:03:05.000012345+05:00'! !!MonthTest methodsFor: 'Running' stamp: 'brp 8/6/2003 19:37'!setUp	super setUp.	month := Month month: 7 year: 1998.! !!ScheduleTest methodsFor: 'testing' stamp: 'brp 1/21/2004 18:44'!testDateAndTimes	| answer |	self assert: aSchedule dateAndTimes size  = 104.	self assert: aSchedule dateAndTimes first = firstEvent.	answer := true.	aSchedule dateAndTimes do: [:each | (each dayOfWeekName = 'Saturday'		or: [each dayOfWeekName = 'Sunday']) ifFalse: [^false]].	self assert: answer! !!InstVarRefLocatorTest methodsFor: 'examples' stamp: 'md 4/8/2003 12:31'!example2	| ff|		ff := 1.	(1 < 2) ifTrue: [ff ifNotNil: [ff := 'hallo']].	^ ff.! !!DurationTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 14:57'!testQuotient	| d1 d2 q |	d1 := 11.5 seconds.	d2 := d1 // 3.	self assert: d2 = (Duration seconds: 3 nanoSeconds: 833333333).	q := d1 // (3 seconds).	self assert: q = 3.! !!TimespanTest methodsFor: 'Tests' stamp: 'brp 1/9/2004 06:43'!testInclusion	| t1 t2 t3 t4 |	t1 := timespan start.	t2 := timespan start + (timespan duration / 2).	t3 := timespan end.	t4 := timespan start + (timespan duration).	self 		assert: (timespan includes: t1);		assert: (timespan includes: t2);		assert: (timespan includes: t3)";		deny: (timespan includes: t4).	self		assert: (timespan includes: (t1 to: t2));		assert: (timespan includes: (t1 to: t4));		deny: (timespan includes: (Timespan starting: t2 duration: (timespan duration * 2))).	self 		assert: (timespan includesAllOf: { t1. t2. t3 } );		deny: (timespan includesAllOf: { t1. t2. t3. t4} ).	self 		assert: (timespan includesAnyOf: { t1. t2. t3 } );		deny: (timespan includesAnyOf: { t4 } )."! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:51'!testAsNumberNegatedWithoutDecimalPoint	| sd |	sd := '-123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 0.	self assert: '-123s0' = sd printString.! !!IntegerDigitLogicTest methodsFor: 'tests' stamp: 'hmm 1/7/2002 21:12'!testNBitAndNNegatedEqualsN	"Verify that (n bitAnd: n negated) = n for single bits"	| n |	1 to: 100 do: [:i | n := 1 bitShift: i.				self assert: (n bitAnd: n negated) = n]! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'dtl 5/26/2004 18:33'!testEmptyTemplate	"Check that an uninitialized instance behaves reasonably."	| i |	i := LargePositiveInteger new: 4.	self assert: i size == 4.	self assert: i printString = '0'.	self assert: i normalize == 0! !!NumberParsingTest methodsFor: 'tests - Float' stamp: 'nice 4/28/2006 01:20'!testFloatFromStreamWithExponent	"This covers parsing in Number>>readFrom:"	| rs aFloat |	rs := '1.0e-14' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs atEnd.	rs := '1.0e-14 1' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs upToEnd = ' 1'.	rs := '1.0e-14eee' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e-14 = aFloat.	self assert: rs upToEnd = 'eee'.	rs := '1.0e14e10' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0e14 = aFloat.	self assert: rs upToEnd = 'e10'.	rs := '1.0e+14e' readStream. "Plus sign is not parseable"	aFloat := Number readFrom: rs.	self assert: 1.0 = aFloat.	self assert: rs upToEnd = 'e+14e'.	rs := '1.0e' readStream.	aFloat := Number readFrom: rs.	self assert: 1.0 = aFloat.	self assert: rs upToEnd = 'e'.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 15:51'!testAsNumberNegatedWithoutDecimalPoint2	| sd |	sd := '-123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '-123.00s2' = sd printString.! !!MethodContextTest methodsFor: 'tests' stamp: 'tlk 5/31/2004 16:55'!testReturn	"Why am I overriding setUp? Because sender must be thisContext, i.e, testReturn, not setUp."	aMethodContext := MethodContext sender: thisContext receiver: aReceiver method: aCompiledMethod arguments: #(). 	self assert: (aMethodContext return: 5) = 5.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:24'!testConvertFromFraction	| sd |	sd := (13 / 11) asScaledDecimal: 6.	self assert: ScaledDecimal == sd class.	self assert: ('1.181818s6' = sd printString).	self assert: 6 == sd scale! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'dtl 9/18/2004 12:22'!testAsNumber	"Ensure no loss of precision"	| sd |	sd := '1.40s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale == 2.	self assert: '1.40s2' = sd printString.! !!ScheduleTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 16:08'!testFromDateAndTime	| oc1 oc2 |	oc1 := OrderedCollection new.	DateAndTime today to: DateAndTime tomorrow by: 10 hours do: [ :dt | oc1 add: dt ].	oc2 := { DateAndTime today. 			(DateAndTime today + 10 hours). 				(DateAndTime today + 20 hours) }.	self assert: (oc1 asArray = oc2)! !!StopwatchTest methodsFor: 'Tests' stamp: 'brp 9/25/2003 12:02'!testReActivate	| sw |	sw := Stopwatch new.	sw 		activate;		suspend;		reActivate.		self 		assert: (sw isActive).! !