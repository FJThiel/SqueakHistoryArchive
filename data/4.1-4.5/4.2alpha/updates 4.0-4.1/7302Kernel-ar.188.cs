"Change Set:		7302Kernel-ar.188Kernel-ar.188:Prerequiste changes for Closure installation.Kernel-dtl.186:Reference Mantis 7357: DateAndTime class>>localOffset broken since Mantis 474, and Mantis 7273: DateAndTime class>>localTimeZone: does not workRestore original implementation of DateAndTime class>>localOffset (including original author initials and time stamp, but with <lf> characters removed from source). Eliminate class variable LocalOffset.This restores the original correct implementation, with no performance penalty.Kernel-dtl.187:Reference Mantis 7353: Float>>printPaddedWith:to: doesn't meet its specificationFix provided by Eliot Miranda:The comment for Float>>printPaddedWith:to: is    'Answer the string containing the ASCII representation of the receiver    padded on the left with aCharacter to be at least on aNumber    integerPart characters and padded the right with aCharacter to be at    least anInteger fractionPart characters.'but the number of fractional characters printed is not respected, at least not obviously.e.g. IMO ((1000 / 3) roundTo: 0.001) printPaddedWith: $: to: 4.5should answer ':333.333::' but answers ':333.333:::::::'.The bug is in the computation of fLen:    fLen := (aNumber fractionPart * (aNumber asFloat exponent * 10)) asInteger.for a natural interpretation of the fractionPart this can read e.g.    fLen := aNumber fractionPart.    [fLen fractionPart > 1e-6] whileTrue:        [fLen := fLen * 10.0].    fLen := fLen asInteger."!Magnitude subclass: #DateAndTime	instanceVariableNames: 'seconds offset jdn nanos'	classVariableNames: 'ClockProvider LastTickSemaphore LastTick MilliSecondOffset LocalTimeZone LastMilliSeconds DaysSinceEpoch'	poolDictionaries: 'ChronologyConstants'	category: 'Kernel-Chronology'!ContextPart variableSubclass: #MethodContext	instanceVariableNames: 'method closureOrNil receiver'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!CompiledMethod methodsFor: 'source code management' stamp: 'eem 5/6/2008 15:15'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString |	(SourceFiles == nil or: [(file := SourceFiles at: fileIndex) == nil]) ifTrue:		[^self become: (self copyWithTempNames: methodNode tempNames)].	SmalltalkImage current assureStartupStampLogged.	file setToEnd.	preambleBlock value: file.  "Write the preamble"	remoteString := RemoteString newString: sourceStr onFileNumber: fileIndex toFile: file.	file nextChunkPut: ' '.	InMidstOfFileinNotification signal ifFalse: [file flush].	self checkOKToAdd: sourceStr size at: remoteString position.	self setSourcePosition: remoteString position inFile: fileIndex! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 6/24/2008 12:24'!namedTempAt: index put: aValue	"Set the value of the temp at index in the receiver's sequence of tempNames.	 (Note that if the value is a copied value it is also set out along the lexical chain,	  but alas not in along the lexical chain.)."	^self debuggerMap namedTempAt: index put: aValue in: self! !!ProtoObject methodsFor: 'testing' stamp: 'eem 5/23/2008 11:02'!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'dtl 7/13/2009 13:08'!initialize	super initialize.	ClockProvider := Time.	LastTickSemaphore := Semaphore forMutualExclusion.	LastMilliSeconds := 0.	LastTick := 0.	Smalltalk addToStartUpList: self.	self startUp: true! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/5/2008 10:07'!previousPc	^self method pcPreviousTo: pc! !!Behavior methodsFor: 'testing method dictionary' stamp: 'md 1/17/2006 17:56'!scopeHas: varName ifTrue: aBlock	"Obsolete. Kept around for possible spurios senders which we don't know about"	self deprecated: 'Obsolete'.	(self bindingOf: varName) ifNotNilDo:[:binding|		aBlock value: binding.		^true].	^false! !!Behavior methodsFor: 'compiling' stamp: 'eem 5/13/2008 09:50'!instVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	"Nothing to do here; ClassDescription introduces named instance variables"	^self! !!ProtoObject methodsFor: 'testing' stamp: 'vb 4/15/2007 10:54'!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/5/2008 10:32'!abstractPCForConcretePC: concretePC	"Answer the abstractPC matching concretePC."	| abstractPC scanner client |	self flag: 'belongs in DebuggerMethodMap?'.	abstractPC := 1.	scanner := InstructionStream on: self.	client := InstructionClient new.	[(scanner atEnd	  or: [scanner pc >= concretePC]) ifTrue:		[^abstractPC].	 abstractPC := abstractPC + 1.	 scanner interpretNextInstructionFor: client.	 true] whileTrue! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'md 2/17/2006 18:48'!selectorAtMethod: method setClass: classResultBlock 	"Answer both the message selector associated with the compiled method 	and the class in which that selector is defined."	| sel |	self deprecated: 'please call #methodClass and #selector on the method'.	sel _ self methodDict keyAtIdentityValue: method				ifAbsent: 					[superclass == nil						ifTrue: 							[classResultBlock value: self.							^method defaultSelector].					sel _ superclass selectorAtMethod: method setClass: classResultBlock.					"Set class to be self, rather than that returned from 					superclass. "					sel == method defaultSelector ifTrue: [classResultBlock value: self].					^sel].	classResultBlock value: self.	^sel! !!ProtoObject methodsFor: 'testing' stamp: 'vb 4/15/2007 10:55'!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock valueWithPossibleArgs: {self}! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 5/24/2008 13:42'!methodClass	"answer the class that I am installed in"	| who |	self hasNewPropertyFormat ifFalse:		[^(who := self who first) == #unknown ifFalse: [who]]. "there are some activated old methods"	^(self literalAt: self numLiterals) value.! !!ClassBuilder methodsFor: 'class format' stamp: 'eem 6/13/2008 10:03'!computeFormat: type instSize: newInstSize forSuper: newSuper ccIndex: ccIndex	"Compute the new format for making oldClass a subclass of newSuper.	Return the format or nil if there is any problem."	| instSize isVar isWords isPointers isWeak |	type == #compiledMethod		ifTrue:[^CompiledMethod format].	instSize := newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize]).	instSize > 254 ifTrue:[		self error: 'Class has too many instance variables (', instSize printString,')'.		^nil].	type == #normal ifTrue:[isVar := isWeak := false. isWords := isPointers := true].	type == #bytes ifTrue:[isVar := true. isWords := isPointers := isWeak := false].	type == #words ifTrue:[isVar := isWords := true. isPointers := isWeak := false].	type == #variable ifTrue:[isVar := isPointers := isWords := true. isWeak := false].	type == #weak ifTrue:[isVar := isWeak := isWords := isPointers := true].	(isPointers not and:[instSize > 0]) ifTrue:[		self error:'A non-pointer class cannot have instance variables'.		^nil].	^(self format: instSize 		variable: isVar 		words: isWords 		pointers: isPointers 		weak: isWeak) + (ccIndex bitShift: 11).! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'eem 5/7/2008 12:02'!definition	"Refer to the comment in ClassDescription|definition."	^ String streamContents: 		[:strm |		strm print: self;			crtab;			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString]! !!Float methodsFor: 'printing' stamp: 'eem 5/13/2009 15:43'!printPaddedWith: aCharacter to: aNumber 	"Answer the string containing the ASCII representation of the receiver 	padded on the left with aCharacter to be at least on aNumber 	integerPart characters and padded the right with aCharacter to be at 	least anInteger fractionPart characters."	| aStream digits fPadding fLen iPadding iLen curLen periodIndex |	#Numeric.	"2000/03/04  Harmon R. Added Date and Time support"	aStream := WriteStream on: (String new: 10).	self printOn: aStream.	digits := aStream contents.	periodIndex := digits indexOf: $..	curLen := periodIndex - 1.	iLen := aNumber integerPart.	curLen < iLen		ifTrue: [iPadding := (String new: (iLen - curLen) asInteger) atAllPut: aCharacter;					 yourself]		ifFalse: [iPadding := ''].	curLen := digits size - periodIndex.	fLen := aNumber fractionPart.	[fLen fractionPart > 1e-6] whileTrue:		[fLen := fLen * 10.0].	fLen := fLen asInteger.	curLen < fLen		ifTrue: [fPadding := (String new: fLen - curLen) atAllPut: aCharacter;					 yourself]		ifFalse: [fPadding := ''].	^ iPadding , digits , fPadding! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/23/2008 13:58'!pushConstant: obj	"Print the Push Constant, obj, on Top Of Stack bytecode."	self print: (String streamContents:				[:s |				s nextPutAll: 'pushConstant: '.				(obj isKindOf: LookupKey)					ifFalse: [obj printOn: s]					ifTrue: [obj key						ifNotNil: [s nextPutAll: '##'; nextPutAll: obj key]						ifNil: [s nextPutAll: '###'; nextPutAll: obj value soleInstance name]]]).	(obj isKindOf: CompiledMethod) ifTrue:		[obj longPrintOn: stream indent: self indent + 2.		^self].! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'eem 5/7/2008 12:02'!definition	"Answer a String that defines the receiver."	| aStream path |	aStream := WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [path := ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path := remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/14/2008 18:58'!pcPreviousTo: pc	| scanner client prevPc |	self flag: 'belongs in DebuggerMethodMap?'.	pc > self endPC ifTrue: [^self endPC].	scanner := InstructionStream on: self.	client := InstructionClient new.	[scanner pc < pc] whileTrue:		[prevPc := scanner pc.		 scanner interpretNextInstructionFor: client].	^prevPc! !!InstructionStream methodsFor: 'debugger access' stamp: 'eem 6/5/2008 10:45'!debuggerMap	^self method debuggerMap! !!CompiledMethod methodsFor: 'testing' stamp: 'eem 6/3/2008 13:30'!isClosureCompiled	"Answer whether the receiver was compiled using the closure compiler.	 This is used to help DebuggerMethodMap choose which mechanisms to	 use to inspect activations of the receiver.	 This method answers false negatives in that it only identifies methods	 that create new BlockClosures or use the new BlockClosure bytecodes.	 But since methods that don't create blocks have essentially the same	 code when compiled with either compiler this makes little difference."	^((InstructionStream on: self) scanFor: [:instr | instr >= 138 and: [instr <= 143]])	   or: [(self hasLiteral: #closureCopy:copiedValues:)		   and: [self messages includes: #closureCopy:copiedValues:]]! !!Object methodsFor: 'testing' stamp: 'eem 5/8/2008 11:13'!isArray	^false! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'dtl 7/13/2009 13:08'!initializeOffsets 	| epochianSeconds secondsSinceMidnight nowSecs  |	  	LastTick := 0.  	nowSecs :=  self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue. 	epochianSeconds := Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: nowSecs.	DaysSinceEpoch := epochianSeconds days.	secondsSinceMidnight := (epochianSeconds - (Duration days: DaysSinceEpoch hours: 0 minutes: 0 seconds: 0)) asSeconds.  	MilliSecondOffset := (secondsSinceMidnight * 1000 - LastMilliSeconds)! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 7/10/2009 22:55'!isBlueBookCompiled	"Answer whether the receiver was compiled using the closure compiler.	 This is used to help DebuggerMethodMap choose which mechanisms to	 use to inspect activations of the receiver.	 This method answers false negatives in that it only identifies methods	 that create old BlockClosures or use the new BlockClosure bytecodes.	 It cannot tell if a method which uses neither the old nor the new block	 bytecodes is compiled with the blue-book compiler or the new compiler.	 But since methods that don't create blocks have essentially the same	 code when compiled with either compiler this makes little difference."	^((InstructionStream on: self) scanFor:		[:instr |		(instr >= 138 and: [instr <= 143]) ifTrue: [^false].		instr = 200])	   or: [(self hasLiteral: #blockCopy:)		   and: [self messages includes: #blockCopy:]]! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 7/17/2008 14:49'!namedTempAt: index	"Answer the value of the temp at index in the receiver's sequence of tempNames."	^self debuggerMap namedTempAt: index in: self! !!CompiledMethod methodsFor: 'testing' stamp: 'eem 6/4/2008 16:19'!usesClosureBytecodes	"Answer whether the receiver was compiled using the closure compiler.	 This is used to help DebuggerMethodMap choose which mechanisms to	 use to inspect activations of the receiver.	 This method answers false negatives in that it only identifies methods	 that use the new BlockClosure bytecodes.	 But since methods that don't create blocks have essentially the same	 code when compiled with either compiler this makes little difference."	^(InstructionStream on: self) scanFor: [:instr | instr >= 138 and: [instr <= 143]]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'brp 9/4/2003 06:40'!localOffset	"Answer the duration we are offset from UTC"	^ self localTimeZone offset! !!Class class methodsFor: 'instance creation' stamp: 'eem 5/7/2008 12:06'!templateForSubclassOf: priorClassName category: systemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"	^priorClassName asString, ' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString , ''''! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/5/2008 09:10'!debuggerMap	^DebuggerMethodMap forMethod: self! !!Behavior methodsFor: 'compiling' stamp: 'eem 6/19/2008 09:08'!variablesAndOffsetsDo: aBinaryBlock	"This is the interface between the compiler and a class's instance or field names.  The	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed	 by the instance variable name strings and their integer offsets (1-relative).  The order is	 important; names evaluated later will override the same names occurring earlier."	"Only need to do instance variables here.  CProtoObject introduces field definitions."	self instVarNamesAndOffsetsDo: aBinaryBlock! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 7/13/2007 16:52'!print: anObject on: aStream	"Safely print anObject in the face of direct ProtoObject subclasses"	| title |	(anObject class canUnderstand: #printOn:)		ifTrue:[^anObject printOn: aStream].	title := anObject class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!BlockContext methodsFor: 'printing' stamp: 'eem 5/16/2008 12:03'!printOn: aStream	| decompilation blockString truncatedBlockString |	home == nil ifTrue: [^aStream nextPutAll: 'a BlockContext with home=nil'].	aStream nextPutAll: '[] in '.	super printOn: aStream.	decompilation := [self decompile ifNil: ['--source missing--']]						on: Error						do: [:ex| ' (error in decompilation)'].	blockString := ((decompilation isString					ifTrue: [decompilation]					ifFalse: [decompilation printString])						replaceAll: Character cr with: Character space)							replaceAll: Character tab with: Character space.	truncatedBlockString := blockString truncateWithElipsisTo: 80.	truncatedBlockString size < blockString size ifTrue:		[truncatedBlockString := truncatedBlockString, ']}'].	aStream space; nextPutAll: truncatedBlockString! !!Semaphore methodsFor: 'communication' stamp: ''!wait	"Primitive. The active Process must receive a signal through the receiver 	before proceeding. If no signal has been sent, the active Process will be 	suspended until one is sent. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 86>	self primitiveFailed	"excessSignals>0  		ifTrue: [excessSignals _ excessSignals-1]  		ifFalse: [self addLastLink: Processor activeProcess suspend]"! !!ClassBuilder methodsFor: 'public' stamp: 'eem 6/13/2008 10:00'!superclass: aClass	variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable byte-sized nonpointer variables."	| oldClassOrNil actualType |	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(aClass isVariable and: [aClass isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a byte subclass of a class with pointer fields'].	oldClassOrNil := aClass environment at: t ifAbsent:[nil].	actualType := (oldClassOrNil notNil				   and: [oldClassOrNil typeOfClass == #compiledMethod])					ifTrue: [#compiledMethod]					ifFalse: [#bytes].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: actualType		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassDescription methodsFor: 'compiling' stamp: 'eem 5/13/2008 09:48'!instVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 The class should enumerate aBinaryBlock with the instance variable name strings and	 their integer offsets.  The order is important. Names evaluated later will override the	 same names occurring earlier."	| superInstSize |	(superInstSize := superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:		[superclass instVarNamesAndOffsetsDo: aBinaryBlock].	1 to: self instSize - superInstSize do:		[:i| aBinaryBlock value: (instanceVariables at: i) value: i + superInstSize]! !MethodContext removeSelector: #tempsAndValues!Metaclass removeSelector: #definitionST80!MethodContext removeSelector: #myEnv!MethodContext removeSelector: #myEnv:!ClassDescription removeSelector: #definitionST80!DateAndTime initialize!