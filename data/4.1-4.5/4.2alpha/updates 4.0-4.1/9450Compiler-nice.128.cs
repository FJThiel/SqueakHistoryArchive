"Change Set:		9450Compiler-nice.128Compiler-nice.128:1) Cuis 2.2 ParserSmallFix2) simplification method:context:encoder: replaced by method:context:Compiler-nice.120:Authorize - at any position in binary selectors (like VW 7.7)See http://bugs.squeak.org/view.php?id=3616Address the problem of compiling 1@-2 with following strategy:If compiler is non interactive, then compile with backward compatibility 1 @ (-2).If compiler is interactive, propose a menu to disambiguate and insert a proper space.1@ -2 -> MessageSend receiver: 1 selector: #'@' argument: -21@- 2 -> MessageSend receiver: 1 selector: #'@-' argument: 2Warning: Squeak did understand (1@-   2) as (1 @ (-2))....I didn't do anything to support this vicious Squeakism, and by now the semantics are change.Compiler-nice.121:Change requestorOffset initialization order so that I can evaluate#(1--2) and get automatic correction workingCompiler-nice.122:Forbid the construction (-  1)The minus sign now MUST NOT be separated from the literal number.RATIONALE: this syntax is not Smalltalk, not portable, not documented, not the same inside #(- 1) and is just adding confusion to the -1 rule, especially since the binary selectors can now embed a $- at any place.WARNING: THIS MIGHT INTRODUCE INCOMPATIBILITY IN PACKAGESwe might introduce a Preferences if the case shows up.I did a Compiler recompileAll, which works fine in trunk.In order to achieve this, I had to first correct the hereEnd and mark instance variables near end of stream.The scanner scans two letters ahead, so it clearly has to test both aheadChar then hereChar.Previously, it did decide on source atEnd and hereChar only, which was a bogus for example in case of a trailing separator in source.WARNING: hope this won't break any obscure workaround in Debugger selection.Compiler-nice.123:Warn about ambiguous selector like @- in the Transcript when compiling in non interactive mode.Compiler-nice.124:Use a Text emphasizing error message in bold red rather than a String in SyntaxErrorNotification.Maybe this would find a better place in the handling of notification, but this change was easier.Compiler-nice.125:Let Parser better signal NumberParser errors.Compiler-nice.126:Implement a Parser compatibility layer in Scanner: #notify:at:.I used it for inserting NumberParser errorString...Alas, it is not understood by Scanner, only by Parser.Alternative #offEnd: lacks of precision regarding position, so I clearly prefer implementing the compatible message.Compiler-nice.127:Let this one raise a SyntaxError thanks to earlier encoder initialization:Compiler evaluate: '0r0 + 1'"!ParserNotification subclass: #AmbiguousSelector	instanceVariableNames: 'interval'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Exceptions'!!Parser methodsFor: 'expression types' stamp: 'nice 2/25/2010 17:52'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	encoder := encoderToUse.	^self method: doit context: ctxt! !!ParserNotification methodsFor: 'handling' stamp: 'cwp 10/17/2007 21:36'!openMenuIn: aBlock	self subclassResponsibility! !!UndeclaredVariable class methodsFor: 'instance creation' stamp: 'cwp 10/15/2007 22:37'!signalFor: aParser name: aString inRange: anInterval 	^ (self new setParser: aParser name: aString range: anInterval) signal! !!Parser methodsFor: 'scanning' stamp: 'nice 2/24/2010 01:36'!advance	| this |	prevMark := hereMark.	prevEnd := hereEnd.	this := here.	here := token.	hereType := tokenType.	hereMark := mark.	hereEnd := source position - ((aheadChar == 30 asCharacter and: [source atEnd])		ifTrue: [hereChar == 30 asCharacter			ifTrue: [0]			ifFalse: [1]]		ifFalse: [2]).	self scanToken.	"Transcript show: 'here: ', here printString, ' mark: ', hereMark printString, ' end: ', hereEnd printString; cr."	^this! !!AmbiguousSelector methodsFor: 'handling' stamp: 'nice 2/23/2010 16:54'!openMenuIn: aBlock 	"Ask the user which selector to choose.	Answer the choosen selector or nil if cancellation is requested."		| labels actions lines caption choice |	labels := {		'selector is ' , (name copyFrom: 1 to: name size - 1) , ' argument is negative'.		'selector is ' , name , ' argument is positive'.		'cancel'}.	actions := {		name copyReplaceFrom: name size to: name size - 1 with: ' '.		name copyReplaceFrom: name size + 1 to: name size with: ' '.		nil.	}.	lines := {2}.	caption := 'Ambiguous selector: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !!Parser methodsFor: 'error correction' stamp: 'nice 2/25/2010 01:50'!ambiguousSelector: aString inRange: anInterval	| correctedSelector userSelection |		self interactive ifFalse: [		"In non interactive mode, compile with backward comapatibility: $- is part of literal argument"		Transcript cr; store: encoder classEncoding; nextPutAll:#'>>';store: encoder selector; show: ' would send ' , token , '-'.		token := token asSymbol.		^self].		"handle the text selection"	userSelection := requestor selectionInterval.	requestor selectFrom: anInterval first to: anInterval last.	requestor select.	"Build the menu with alternatives"	correctedSelector := AmbiguousSelector 			signalName: aString			inRange: anInterval.	correctedSelector ifNil: [^self fail].	"Execute the selected action"	self substituteWord: correctedSelector wordInterval: anInterval offset: 0.	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last + 1.	token := (correctedSelector readStream upTo: Character space) asSymbol! !!Parser methodsFor: 'expression types' stamp: 'nice 2/25/2010 17:52'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode := self newMethodNode comment: messageComment.	^methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!Parser methodsFor: 'private' stamp: 'nice 2/23/2010 17:48'!init: sourceStream notifying: req failBlock: aBlock	requestor := req.	failBlock := aBlock.	requestorOffset := 0.	super scan: sourceStream.	prevMark := hereMark := mark.	self advance! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 2/23/2010 16:39'!xBinary	| startOfToken |	tokenType := #binary.	startOfToken := mark.	token := String with: self step.	[(self typeTableAt: hereChar) == #xBinary] whileTrue:		[(hereChar == $- and: [(self typeTableAt: aheadChar) == #xDigit])			ifTrue: [^self ambiguousSelector: (token , '-')					inRange: (startOfToken to: source position - 1).].		token := token, (String with: self step)].	token := token asSymbol! !!Parser methodsFor: 'error handling' stamp: 'nice 2/24/2010 02:21'!notify: string at: location	requestor isNil		ifTrue: [(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxErrorNotification					inClass: encoder classEncoding					category: category					withCode: 						(source contents asText							copyReplaceFrom: location							to: location - 1							with: ((string , ' ->') asText allBold 								addAttribute: TextColor red; yourself))					doitFlag: doitFlag					errorMessage: string					location: location]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!Parser methodsFor: 'expression types' stamp: 'nice 2/24/2010 01:20'!primaryExpression 	hereType == #word 		ifTrue: 			[parseNode := self variable.			(parseNode isUndefTemp and: [self interactive])				ifTrue: [self queryUndefined].			parseNode nowHasRef.			^ true].	hereType == #leftBracket		ifTrue: 			[self advance.			self blockExpression.			^true].	hereType == #leftBrace		ifTrue: 			[self braceExpression.			^true].	hereType == #leftParenthesis		ifTrue: 			[self advance.			self expression ifFalse: [^self expected: 'expression'].			(self match: #rightParenthesis)				ifFalse: [^self expected: 'right parenthesis'].			^true].	(hereType == #string or: [hereType == #number or: [hereType == #literal]])		ifTrue: 			[parseNode := encoder encodeLiteral: self advance.			^true].	(here == #- and: [tokenType == #number and: [1 + hereEnd = mark]])		ifTrue: 			[self advance.			parseNode := encoder encodeLiteral: self advance negated.			^true].	^false! !!Parser methodsFor: 'error handling' stamp: 'nice 2/26/2010 00:21'!fail	| exitBlock |	(encoder == nil or: [encoder == self])		ifFalse: [encoder release. encoder := nil]. "break cycle"	exitBlock := failBlock.	failBlock := nil.	^exitBlock value! !!Scanner methodsFor: 'expression types' stamp: 'nice 2/23/2010 21:38'!scanToken	[(tokenType := self typeTableAt: hereChar) == #xDelimiter]		whileTrue: [self step].  "Skip delimiters fast, there almost always is one."	mark := (aheadChar == 30 asCharacter and: [source atEnd])		ifTrue: [source position]		ifFalse: [source position - 1].	(tokenType at: 1) = $x "x as first letter"		ifTrue: [self perform: tokenType "means perform to compute token & type"]		ifFalse: [token := self step asSymbol "else just unique the first char"].	^token! !!Scanner methodsFor: 'error handling' stamp: 'nice 2/25/2010 02:56'!notify: string at: posiiton	"Parser compatible message"	 	^self notify: string ! !!Parser methodsFor: 'public access' stamp: 'nice 2/25/2010 17:52'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 self encoder init: class context: ctxt notifying: self.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := ReadStream on: requestor text string].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !!ParserNotification methodsFor: 'private' stamp: 'cwp 10/17/2007 23:29/eem 9/5/2009 11:10 - => :='!setName: aString	name := aString! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 2/25/2010 02:43'!xDigit	"Form a number."	tokenType := #number.	(aheadChar = 30 asCharacter and: [source atEnd			and:  [source skip: -1. source next ~= 30 asCharacter]])		ifTrue: [source skip: -1 "Read off the end last time"]		ifFalse: [source skip: -2].	token := (SqNumberParser on: source)		failBlock: [:errorString :position | self notify: errorString at:position];		nextNumber.	self step; step! !!AmbiguousSelector class methodsFor: 'instance creation' stamp: 'nice 2/23/2010 16:52'!signalName: aString inRange: anInterval 	^ (self new setName: aString range: anInterval) signal! !!AmbiguousSelector methodsFor: 'private' stamp: 'nice 2/23/2010 16:51'!setName: aString range: anInterval 	name := aString.	interval := anInterval! !