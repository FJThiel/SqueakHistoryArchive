"Change Set:		8372Collections-nice.246Collections-nice.246:After an idea from Henrik Johansen, speed-up WideCharacterSet enumeration- 1) do not use a WordArray but a ByteArray to avoid large integers- 2) inline enumeration of bits in a byte with optimistic subtraction of highest bit (work best if bits pattern is sparse)Collections-nice.241:Provide a universal #nextLine relying on #upToAnyOf:do:Subclass might want to override #upToAnyOf:do: for speedCollections-ul.242:- fix: Character >> #digitValue shadowed instance variable: value- fix: Character >> #storeBinaryOn: didn't work with non-octet characters- faster methods in String: #convertFromWithConverter:, #convertToWithConverter: and #skipDelimiters:startingAt:Collections-nice.243:Correct ReadStream #upToEnd and #upTo: with respect to readLimitCollections-nice.244:Cosmetic clean-up:- remove a useless send to private setString:setRuns: (and a useless Text creation)- remove a useless send to oldBack crapCollections-nice.245:Move indexOfAnyOf: & co from String to SequenceableCollectionMake it work for any collection argument, not just CharacterSetHandle optimized ByteString+CharacterSet case by double dispatching-- this removes ugly class checks --Implement a fast ReadStream upToAnyOf:do: thanks to above changes"!!ReadStream methodsFor: 'accessing' stamp: 'nice 12/8/2009 14:22'!upToAnyOf: aCollection do: aBlock	"Overriden for speed"	| end result |	end := collection indexOfAnyOf: aCollection startingAt: 1 + position ifAbsent: [0].	(end = 0 or: [end > readLimit]) ifTrue: [^self upToEnd].	result := collection copyFrom: 1 + position to: -1 + end.	position := end.	aBlock value: (collection at: end).	^result! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 12/9/2009 20:28'!setBitmap: aMap at: shortInteger	"set a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -3.	bitIndex := shortInteger bitAnd: 7.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitOr: (1 bitShift: bitIndex))! !!ByteSymbol methodsFor: 'accessing' stamp: 'nice 12/9/2009 15:40'!indexOfAnyOf: aCollection startingAt: start ifAbsent: aBlock	"Use double dispatching for speed"	| index |	^(index := aCollection findFirstInByteString: self startingAt: start) = 0		ifTrue: [aBlock value]		ifFalse: [index]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 12/9/2009 20:12'!bitmap: aMap at: shortInteger	"access a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -3.	bitIndex := shortInteger bitAnd: 7.	^(aMap at: collecIndex + 1) bitAnd: (1 bitShift: bitIndex)! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 12/7/2009 08:30'!upToAnyOf: subcollection do: aBlock	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of any object in the collection.	Evaluate aBlock with this occurence as argument.	If no matching object is found, don't evaluate aBlock and answer the entire rest of the receiver."		^self collectionSpecies new: 1000 streamContents: [ :stream |		| ch |		[ self atEnd or: [ (subcollection includes: (ch := self next)) and: [aBlock value: ch. true] ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!String methodsFor: 'converting' stamp: 'ul 12/9/2009 06:07'!convertToWithConverter: converter	converter ifNil: [ ^self ].	^String new: self size streamContents: [ :stream |		| character |		1 to: self size do: [ :index |			converter 				nextPut: (self at: index) 				toStream: stream ].		converter emitSequenceToResetStateIfNeededOn: stream ]! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 12/9/2009 15:30'!findFirstInByteString: aByteString startingAt: startIndex	"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver."	^ByteString		findFirstInString: aByteString		inSet: self byteArrayMap		startingAt: startIndex! !!WideCharacterSet class methodsFor: 'class initialization' stamp: 'nice 12/9/2009 20:41'!initialize	"Old representation use WordArray.	Accessing a WordArray can create slow LargeInteger and is inefficient.	This is a temporary hack to mutate internal representation to faster ByteArray"	self allInstancesDo: [:e | e convertInternalRepresentationToByteArray]! !!AttributedTextStream methodsFor: 'retrieving the text' stamp: 'nice 12/9/2009 08:26'!contents	| ans |	currentRun > 0 ifTrue:[		attributeValues nextPut: currentAttributes.		attributeRuns nextPut: currentRun.		currentRun := 0].	ans := Text string: characters contents  runs: 		(RunArray runs: attributeRuns contents values: attributeValues contents).	^ans! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 12/9/2009 20:07'!wordBitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits"		0 to: 31 do: [:shift |		| mask |		mask := 1 bitShift: shift.		1 to: aMap size do: [:i | 			((aMap at: i) bitAnd: mask) isZero ifFalse: [aBlock value: ((i - 1 bitShift: 5) bitOr: shift)]]]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 12/9/2009 20:27'!clearBitmap: aMap at: shortInteger	"clear a single bit in aMap.	shortInteger should be between: 0 and: 16rFFFF"		| collecIndex bitIndex |	collecIndex := shortInteger bitShift: -3.	bitIndex := shortInteger bitAnd: 7.	^aMap at: collecIndex + 1 put: ((aMap at: collecIndex + 1) bitClear: (1 bitShift: bitIndex))! !!Collection methodsFor: 'enumerating' stamp: 'nice 12/9/2009 15:37'!findFirstInByteString: aByteString startingAt: start	"Find the index of first character starting at start in aByteString that is included in the receiver.	Default is to use a naive algorithm.	Subclasses might want to implement a more efficient scheme"	start to: aByteString size do:		[:index |		(self includes: (aByteString at: index)) ifTrue: [^ index]].	^ 0! !!ByteString methodsFor: 'accessing' stamp: 'nice 12/9/2009 15:39'!indexOfAnyOf: aCollection startingAt: start	"Use double dispatching for speed"	^aCollection findFirstInByteString: self startingAt: start! !!ReadStream methodsFor: 'accessing' stamp: 'nice 12/8/2009 15:24'!upToEnd	| start |	start := 1 + position.	position := readLimit.	^collection copyFrom: start to: position! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 12/7/2009 08:38'!upToAnyOf: aCollection 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of any object in the collection. If 	no matching object is found, answer the entire rest of the receiver."	^self upToAnyOf: aCollection do: [:matchingObject | ]! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 12/7/2009 08:40'!nextLine	"Answer next line (may be empty) without line end delimiters, or nil if at end.	Let the stream positioned after the line delimiter(s).	Handle a zoo of line delimiters CR, LF, or CR-LF pair"	self atEnd ifTrue: [^nil].	^self upToAnyOf: CharacterSet crlf do: [:char | char = Character cr ifTrue: [self peekFor: Character lf]]! !!String methodsFor: 'converting' stamp: 'nice 12/9/2009 12:38'!asSignedInteger	"Returns the first signed integer it can find or nil."	| start |	start := self findFirst: [:char | char isDigit].	start isZero ifTrue: [^ nil].	(start > 1 and: [self at: start - 1]) = $- ifTrue: [start := start - 1].	^ Integer readFrom: (ReadStream on: self from: start to: self size)! !!ByteSymbol methodsFor: 'accessing' stamp: 'nice 12/9/2009 15:40'!indexOfAnyOf: aCollection startingAt: start	"Use double dispatching for speed"	^aCollection findFirstInByteString: self startingAt: start! !!SequenceableCollection methodsFor: 'accessing' stamp: 'nice 12/9/2009 14:55'!indexOfAnyOf: aCollection ifAbsent: exceptionBlock	"Answer the index of the first occurence of any element included in aCollection within the receiver.	If the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock."	^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: exceptionBlock! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 12/9/2009 20:40'!convertInternalRepresentationToByteArray	| oldMap |	(map anySatisfy: [:e | e class == WordArray]) ifTrue: [		oldMap := map.		map := Dictionary new.		oldMap keysAndValuesDo: [:i :words |			self wordBitmap: words do: [:code | self add: (Character value: (i bitShift: 16) + code)]]].! !!SequenceableCollection methodsFor: 'accessing' stamp: 'nice 12/9/2009 14:57'!indexOfAnyOf: aCollection startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of any element included in aCollection after start within the receiver.	If the receiver does not contain anElement, answer the result of evaluating the argument, exceptionBlock.	Note: it is user responsibility to provide aCollection that behaves relatevily fast when asked for includes: (like a Set)"	start to: self size do:		[:index |		(aCollection includes: (self at: index)) ifTrue: [^ index]].	^ exceptionBlock value! !!ReadStream methodsFor: 'accessing' stamp: 'nice 12/8/2009 15:05'!upTo: anObject	"fast version using indexOf:"	| start end |	start := position+1.	end := collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		(end = 0 or: [end > readLimit]) ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position := end.	^collection copyFrom: start to: (end-1)! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 12/9/2009 15:29'!findFirstInByteString: aByteString startingAt: startIndex	"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver."	^ByteString		findFirstInString: aByteString		inSet: self byteArrayMap		startingAt: startIndex! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 12/9/2009 20:27'!add: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map at: high ifAbsentPut: ["create a chunk of 65536=8192*8 bits"		ByteArray new: 8192].	self setBitmap: lowmap at: low.	^ aCharacter! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 12/9/2009 20:24'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.	Intended for use by primitives only. (and comparison)	This version will answer a subset with only byte characters"		| aMap lowmap |	aMap := ByteArray new: 256.	lowmap := map at: 0 ifAbsent: [^aMap].	lowmap := lowmap copyFrom: 1 to: 32. "Keep first 8*32=256 bits..."	self bitmap: lowmap do: [:code | aMap at: code + 1 put: 1].	^aMap! !!Character methodsFor: 'printing' stamp: 'ul 12/7/2009 07:16'!storeBinaryOn: aStream	"Store the receiver on a binary (file) stream"		value < 256 		ifTrue: [ aStream basicNextPut: self ]		ifFalse: [ aStream nextInt32Put: value ]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'nice 12/9/2009 14:54'!indexOfAnyOf: aCollection startingAt: start	"Answer the index of the first occurence of any element included in aCollection after start within the receiver.	If the receiver does not contain anElement, answer zero, which is an invalid index."	^self indexOfAnyOf: aCollection startingAt: start ifAbsent: [0]! !!String methodsFor: 'accessing' stamp: 'ul 12/7/2009 06:41'!skipDelimiters: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that does NOT match one of the delimiters. If the receiver does not contain any of the delimiters, answer size + 1.  Assumes the delimiters to be a non-empty string."	start to: self size do: [:i |		(delimiters includes: (self at: i)) ifFalse: [ ^i ] ].	^self size + 1! !!Character methodsFor: 'accessing' stamp: 'ul 12/7/2009 07:00'!digitValue	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	| digitValue |	(digitValue := ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' indexOf: self) - 1) >= 0		ifTrue: [ ^digitValue ].	^ (EncodedCharSet charsetAt: self leadingChar) digitValue: self.! !!ByteString methodsFor: 'accessing' stamp: 'nice 12/9/2009 15:40'!indexOfAnyOf: aCollection startingAt: start ifAbsent: aBlock	"Use double dispatching for speed"	| index |	^(index := aCollection findFirstInByteString: self startingAt: start) = 0		ifTrue: [aBlock value]		ifFalse: [index]! !!String methodsFor: 'converting' stamp: 'ul 12/9/2009 10:43'!convertFromWithConverter: converter	converter ifNil: [^ self].	^String new: self size streamContents: [ :stream |		| readStream character |		readStream := self readStream.		[ (character := converter nextFromStream: readStream) == nil ]			whileFalse: [ stream nextPut: character ] ]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'nice 12/9/2009 14:55'!indexOfAnyOf: aCollection	"Answer the index of the first occurence of any element included in aCollection within the receiver.	If the receiver does not contain anElement, answer zero, which is an invalid index."	^self indexOfAnyOf: aCollection startingAt: 1 ifAbsent: [0]! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 12/9/2009 20:57'!bitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits.	Implementation: this version works best for sparse maps.	The powers of two and highBit tables are inlined for speed"		| byte bitOffset byteOffset powersOf2 highBits |	powersOf2 := #[1 2 4 8 16 32 64 128].	highBits := #[0 1 1 2 2 2 2 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 4 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7 7].	1 to: aMap size do: [:i | 		(byte := aMap at: i) = 0 ifFalse: [			byteOffset := (i - 1) bitShift: 3.			[aBlock value: (byteOffset + (bitOffset := highBits at: byte)).			(byte := byte - (powersOf2 at: 1 + bitOffset)) = 0] whileFalse]]! !String class removeSelector: #findFirstInString:inCharacterSet:startingAt:!String removeSelector: #indexOfAnyOf:ifAbsent:!String removeSelector: #indexOfAnyOf:startingAt:!String removeSelector: #indexOfAnyOf:!String removeSelector: #indexOfAnyOf:startingAt:ifAbsent:!WideCharacterSet initialize!