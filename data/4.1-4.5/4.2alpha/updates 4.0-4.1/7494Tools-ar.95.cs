"Change Set:		7494Tools-ar.95Tools-ar.95:UIManagerization. Replaces all the trivial references to PopUpMenu, SelectionMenu, CustomMenu, and FillInTheBlank."!!VersionsBrowser methodsFor: 'menu' stamp: 'ar 8/6/2009 19:23'!compareToOtherVersion	"Prompt the user for a reference version, then spawn a window 	showing the diffs between the older and the newer of the current 	version and the reference version as text."	| change1 change2 s1 s2 |	change1 := changeList at: listIndex ifAbsent: [ ^self ].	change2 := ((UIManager default				chooseFrom: (list copyWithoutIndex: listIndex)				values: (changeList copyWithoutIndex: listIndex))) ifNil: [ ^self ].		"compare earlier -> later"	"change1 timeStamp < change2 timeStamp		ifFalse: [ | temp | temp := change1. change1 := change2. change2 := temp ]."	s1 := change1 string.	s2 := change2 string.	s1 = s2		ifTrue: [^ self inform: 'Exact Match' translated].	(StringHolder new		textContents: (TextDiffBuilder				buildDisplayPatchFrom: s1				to: s2				inClass: classOfMethod				prettyDiffs: self showingPrettyDiffs))		openLabel: (('Comparison from {1} to {2}' translated) format: { change1 stamp. change2 stamp })! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'ar 8/6/2009 18:47'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| changeSetsSortedAlphabetically chosen |	self okToChange ifFalse: [^ self].	changeSetsSortedAlphabetically := self changeSetList asSortedCollection:		[:a :b | a asLowercase withoutLeadingDigits < b asLowercase withoutLeadingDigits].	chosen := UIManager default chooseFrom: changeSetsSortedAlphabetically values: changeSetsSortedAlphabetically.	chosen ifNil: [^ self].	self showChangeSet: (ChangesOrganizer changeSetNamed: chosen)! !!ChangeList class methodsFor: 'public access' stamp: 'ar 8/6/2009 18:46'!browseRecentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	changesFile setConverterForCode.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size == 0 ifTrue: [^ self inform: 'this image has never been savedsince changes were compressed'].	pos := UIManager default chooseFrom: banners values: positions				title: 'Browse as far back as...'.	pos == nil		ifTrue: [^ self].	self browseRecent: end - pos on: origChangesFile! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'ar 8/6/2009 18:17'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| index pattern candidates nameList |	self okToChange ifFalse: [^ self].	pattern := UIManager default request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self].	nameList := self changeSetList asSet.	candidates := ChangeSet allChangeSets select:			[:c | (nameList includes: c name) and: 				[c name includesSubstring: pattern caseSensitive: false]].	candidates size = 0 ifTrue: [^ Beeper beep].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	index := (UIManager default chooseFrom: 		(candidates collect: [:each | each name]) asStringWithCr).	index = 0 ifFalse: [self showChangeSet: (candidates at: index)].! !!Browser methodsFor: 'class list' stamp: 'ar 8/6/2009 18:44'!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 : dont fall into debugger in empty case"	| className class recentList |	recentList := RecentClasses select: [:n | Smalltalk includesKey: n].	recentList size == 0 ifTrue: [^ Beeper beep].	className := (UIManager default chooseFrom: recentList values: recentList) startUp.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self selectCategoryForClass: class.	self classListIndex: (self classList indexOf: class name)! !!CodeHolder methodsFor: 'traits' stamp: 'ar 8/6/2009 18:49'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size == 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport := String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	UIManager default chooseFrom: aList values: aList 		title: 'Unreferencedclass variables in ' , cls name! !!ArchiveViewer methodsFor: 'member order' stamp: 'ar 8/6/2009 20:38'!toIndexPlace| index max temp |max := self archive members size.index :=0.[index := (UIManager default		request: 'To which index '		initialAnswer:  '1') asInteger.		index between: 1 and: max] whileFalse.	temp := (self archive members) at: memberIndex.	self archive members at: memberIndex put: (self archive members at: index).	self archive members at: index put: temp.	self memberIndex:  0.	self changed: #memberList.! !!CodeHolder methodsFor: 'traits' stamp: 'ar 8/6/2009 18:49'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClassOrMetaClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport := String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	UIManager default chooseFrom: aList values: aList title: 'Unreferencedinstance variables in ', cls name! !!Browser methodsFor: 'class functions' stamp: 'ar 8/6/2009 18:43'!findMethodWithWildcard	"Pop up a list of the current class's methods, and select the one chosen by the user"	| aClass selectors reply cat messageCatIndex messageIndex |	self classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	aClass := self selectedClassOrMetaClass.	selectors := aClass selectors asSortedArray.	selectors isEmpty ifTrue: [self inform: aClass name, ' has no methods.'. ^ self].	reply := UIManager default request: 'Enter partial method name:'.	(reply isNil or: [reply isEmpty])		ifTrue: [^self].	(reply includes: $*)		ifFalse: [reply := '*', reply, '*'].	selectors := selectors select: [:each | reply match: each].	selectors isEmpty ifTrue: [self inform: aClass name, ' has no matching methods.'. ^ self].	reply := selectors size = 1		ifTrue: [selectors first]		ifFalse: [			UIManager default				chooseFrom: selectors				values: selectors].	reply == nil ifTrue: [^ self].	cat := aClass whichCategoryIncludesSelector: reply.	messageCatIndex := self messageCategoryList indexOf: cat.	self messageCategoryListIndex: messageCatIndex.	messageIndex := (self messageList indexOf: reply).	self messageListIndex: messageIndex! !!Browser methodsFor: 'class functions' stamp: 'ar 8/6/2009 18:42'!findMethod	"Pop up a list of the current class's methods, and select the one chosen by the user"	| aClass selectors reply cat messageCatIndex messageIndex |	self classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	aClass := self selectedClassOrMetaClass.	selectors := aClass selectors asSortedArray.	selectors isEmpty ifTrue: [self inform: aClass name, ' has no methods.'. ^ self].	reply := UIManager default 		chooseFrom: (Array with: 'Enter Wildcard'), selectors		values: (Array with: 'Enter Wildcard'), selectors		lines: #(1).	reply == nil ifTrue: [^ self].	reply = 'EnterWildcard'		ifTrue: [			reply := UIManager default request: 'Enter partial method name:'.			(reply isNil or: [reply isEmpty])				ifTrue: [^self].			(reply includes: $*)				ifFalse: [reply := '*', reply, '*'].			selectors := selectors select: [:each | reply match: each].			selectors isEmpty ifTrue: [self inform: aClass name, ' has no matching methods.'. ^ self].			reply := selectors size = 1				ifTrue: [selectors first]				ifFalse: [					UIManager default						chooseFrom: selectors						values selectors].			reply == nil ifTrue: [^ self]].	cat := aClass whichCategoryIncludesSelector: reply.	messageCatIndex := self messageCategoryList indexOf: cat.	self messageCategoryListIndex: messageCatIndex.	messageIndex := (self messageList indexOf: reply).	self messageListIndex: messageIndex! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'ar 8/6/2009 20:38'!saveArchive	| result name |		name := FileDirectory  localNameFor: labelString .	self canSaveArchive ifFalse: [ ^self ].	result := UIManager default		request: 'Name this zip '		initialAnswer:  name.	result ifNil: [ ^self ].		(archive canWriteToFileNamed: result)		ifFalse: [ self inform: name, ' is used by one or more membersin your archive, and cannot be overwritten.Try writing to another file name'.			^self ].	[ archive writeToFileNamed: result ] on: Error do: [ :ex | self inform: ex description. ].	self setLabel: name asString.	self changed: #memberList	"in case CRC's and compressed sizes got set"! !!ChangeList class methodsFor: 'public access' stamp: 'ar 8/6/2009 18:46'!getRecentLocatorWithPrompt: aPrompt	"Prompt with a menu of how far back to go.  Return nil if user backs out.  Otherwise return the number of characters back from the end of the .changes file the user wishes to include"	 "ChangeList getRecentPosition"	| end changesFile banners positions pos chunk i |	changesFile := (SourceFiles at: 2) readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := SmalltalkImage current lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk := changesFile nextChunk.		i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos := Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos := 0]].	changesFile close.	pos := UIManager default chooseFrom: banners values: positions title: aPrompt.	pos == nil ifTrue: [^ nil].	^ end - pos! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'ar 8/6/2009 18:47'!chooseChangeSetCategory	"Present the user with a list of change-set-categories and let her choose one"	|  cats result |	self okToChange ifFalse: [^ self].	Smalltalk isMorphic ifTrue: [^ self chooseChangeSetCategoryInMorphic].  "gives balloon help"	cats := self changeSetCategories elementsInOrder.	result := UIManager default		chooseFrom: (cats collect: [:cat | cat categoryName])		values: cats.	result ifNotNil:		[changeSetCategory := result.		self changed: #changeSetList.		(self changeSetList includes: myChangeSet name) ifFalse:			[self showChangeSet: (ChangesOrganizer changeSetNamed: self changeSetList first)].		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'ar 8/6/2009 20:39'!setRecentUpdatesMarker	"Allow the user to change the recent-updates marker"	| result |	result := UIManager default request: ('Enter the lowest change-set numberthat you wish to consider "recent"?(note: highest change-set numberin this image at this time is ', ChangeSet highestNumberedChangeSet asString, ')') initialAnswer: self class recentUpdateMarker asString.	(result notNil and: [result startsWithDigit]) ifTrue:		[self class recentUpdateMarker: result asInteger.		Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]]! !!Lexicon methodsFor: 'history' stamp: 'ar 8/6/2009 18:53'!navigateToRecentMethod	"Put up a menu of recent selectors visited and navigate to the one chosen"	| visited aSelector |	(visited := self selectorsVisited) size > 1 ifTrue:		[visited := visited copyFrom: 1 to: (visited size min: 20).		aSelector := UIManager default chooseFrom: visited values: visited 			title: 'Recent methods visited in this browser'.		aSelector isEmptyOrNil ifFalse: [self displaySelector: aSelector]]! !!Lexicon methodsFor: 'senders' stamp: 'ar 8/6/2009 18:52'!navigateToASender	"Present the user with a list of senders of the currently-selected 	message, and navigate to the chosen one"	| selectorSet chosen aSelector |	aSelector := self selectedMessageName.	selectorSet := Set new.	(self systemNavigation allCallsOn: aSelector)		do: [:anItem | selectorSet add: anItem methodSymbol].	selectorSet := selectorSet				select: [:sel | currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass].	selectorSet size == 0		ifTrue: [^ Beeper beep].	self okToChange		ifFalse: [^ self].	chosen := UIManager default chooseFrom: selectorSet asSortedArray values: selectorSet asSortedArray.	chosen isEmptyOrNil		ifFalse: [self displaySelector: chosen]! !!CodeHolder methodsFor: 'misc' stamp: 'ar 8/6/2009 18:48'!okayToAccept	"Answer whether it is okay to accept the receiver's input"	self showingDocumentation ifTrue:		[self inform: 'Sorry, for the moment you canonly submit changes here whenyou are showing source.  Later, youwill be able to edit the isolated commenthere and save it back, but only if YOUimplement it!!.'.		^ false].	self showingAnyKindOfDiffs ifFalse:		[^ true]. 	^ (UIManager default chooseFrom: {		'accept anyway -- I''ll take my chances'.		'um, let me reconsider'.	} title:'Caution!!  You are "showing diffs" here, so there is a danger that some of the text in thecode pane is contaminated by the "diff" display') = 1! !!Browser methodsFor: 'drag and drop' stamp: 'ar 8/6/2009 18:44'!overwriteDialogHierarchyChange: hierarchyChange higher: higherFlag sourceClassName: srcClassName destinationClassName: dstClassName methodSelector: methodSelector 	| lf success |	lf := Character cr asString.	success := (UIManager default chooseFrom: {		'Yes, don''t care.'.		'No, I have changed my opinion.'.	} title: 'There is a conflict.' , ' Overwrite' , (hierarchyChange							ifTrue: [higherFlag									ifTrue: [' superclass']									ifFalse: [' subclass']]							ifFalse: ['']) , ' method' , lf , dstClassName , '>>' , methodSelector , lf , 'by ' , (hierarchyChange							ifTrue: ['moving']							ifFalse: ['copying']) , ' method' , lf , srcClassName name , '>>' , methodSelector , ' ?') = 1.	^ success! !