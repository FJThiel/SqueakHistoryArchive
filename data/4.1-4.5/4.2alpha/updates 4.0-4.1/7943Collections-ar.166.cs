"Change Set:		7943Collections-ar.166Collections-ar.166:Merging Collections-ul.164, Collections-ul.165:- removed Matrix >> #shallowCopy. The contents array is already copied in #postCopy, don't have to do it twice. This may break code which assumes that #shallowCopy copies the contents array which is a really bad assumption.- also removed empty category 'copying' from Interval- faster and simpler String >> #format:, String >> #withBlanksTrimmedCollections-ul.165:- faster and simpler String >> #format:, String >> #withBlanksTrimmedCollections-ul.164:- removed Matrix >> #shallowCopy. The contents array is already copied in #postCopy, don't have to do it twice. This may break code which assumes that #shallowCopy copies the contents array which is a really bad assumption.- also removed empty category 'copying' from IntervalCollections-ul.163:- faster shuffle"!!SequenceableCollection methodsFor: 'copying' stamp: 'ul 10/9/2009 00:50'!shuffledBy: aRandom	| copy | 	copy := self copy.	copy size to: 1 by: -1 do: [ :i | 		copy swap: i with: (aRandom nextInt: i) ].	^copy! !!String methodsFor: 'formatting' stamp: 'ul 10/12/2009 21:31'!format: aCollection 	"format the receiver with aCollection  	 	simplest example:  	'foo {1} bar' format: {Date today}.	 	complete example:  	'\{ \} \\ foo {1} bar {2}' format: {12. 'string'}. 	"	^String new: self size streamContents: [ :result |		| stream currentChar |		stream := self readStream.		[ (currentChar := stream next) == nil ] whileFalse: [			currentChar == ${				ifTrue: [					result nextPutAll: (						self 							evaluateExpression: (stream upTo: $}) withBlanksTrimmed 								parameters: aCollection) ]				ifFalse: [					currentChar == $\						ifFalse: [ result nextPut: currentChar ]						ifTrue: [							(currentChar := stream next) ifNotNil: [								result nextPut: currentChar ] ] ] ] ]! !!String methodsFor: 'private' stamp: 'ul 10/13/2009 00:42'!evaluateExpression: aString parameters: aCollection 	"private - evaluate the expression aString with  	aCollection as the parameters and answer the  	evaluation result as an string"	| index |	index := Integer readFrom: aString readStream base: 10.	index isZero		ifTrue: [^ '[invalid subscript: {1}]' format: {aString}].	index > aCollection size		ifTrue: [^ '[subscript is out of bounds: {1}]' format: {aString}].	^ (aCollection at: index) asString! !!String methodsFor: 'converting' stamp: 'ul 10/13/2009 00:56'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first last |	first := self findFirst: [ :c | c isSeparator not ].	first = 0 ifTrue: [ ^'' ].  "no non-separator character"	last := self findLast: [ :c | c isSeparator not ].	(first = 1 and: [ last = self size ]) ifTrue: [ ^self copy ].	^self		copyFrom: first		to: last! !String removeSelector: #getEnclosedExpressionFrom:!Matrix removeSelector: #shallowCopy!