"Change Set:		8767EToys-ar.51EToys-ar.51:Move lots of stuff to the Etoys package to make it more self-consistent and (un|re)loadable."!AlignmentMorph subclass: #ScriptEditorMorph	instanceVariableNames: 'scriptName firstTileRow timeStamp playerScripted handWithTile showingMethodPane threadPolygon'	classVariableNames: 'WritingUniversalTiles'	poolDictionaries: ''	category: 'Etoys-Scripting'!Presenter subclass: #EtoysPresenter	instanceVariableNames: 'associatedMorph standardPlayer standardPlayfield standardPalette playerList'	classVariableNames: ''	poolDictionaries: ''	category: 'EToys-Scripting'!!ColorType methodsFor: '*eToys-tiles' stamp: 'yo 4/5/2005 11:36'!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	"Answer, for classic tiles, an updating readout tile for a part with the receiver's type, with the given getter and setter"	| readout |	readout _ UpdatingRectangleMorph new.	readout		getSelector: getter;		target: aTarget;		borderWidth: 1;		extent:  22@22.	((aTarget isKindOf: KedamaExamplerPlayer) and: [getter = #getColor]) ifTrue: [		readout getSelector: #getColorOpaque.	].	(setter isNil or: [#(unused none #nil) includes: setter]) ifFalse:		[readout putSelector: setter].	^ readout! !!Morph methodsFor: '*Etoys' stamp: 'sw 10/25/2000 06:11'!moveWithPenDownBy: delta	"If this is a costume for a player with its pen down, draw a line."	| trailMorph tfm start tfmEnd |	(trailMorph := self trailMorph) ifNotNil:		[tfm := self owner transformFrom: trailMorph.		start :=  self referencePosition.		trailMorph batchPenTrails			ifTrue: [trailMorph notePenDown: true								forPlayer: self player								at: (tfm localPointToGlobal: start)]			ifFalse: [trailMorph drawPenTrailFor: self								from: (tfm localPointToGlobal: start)								to: (tfmEnd := tfm localPointToGlobal: start + delta).					trailMorph noteNewLocation: tfmEnd forPlayer: self player]]! !!Morph methodsFor: '*Etoys-scripting' stamp: 'nk 8/21/2004 08:39'!wantsConnectionVocabulary	submorphs ifNil: [ ^true ].	"called from EToyVocabulary>>initialize after basicNew"	^ (Preferences valueOfFlag: #alwaysShowConnectionVocabulary)		or: [ self connections isEmpty not ]! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:17'!allGoButtons	"Answer a list of all script-controlling Go buttons within my scope"	^ associatedMorph allMorphs select:		[:aMorph | (aMorph isKindOf: ThreePhaseButtonMorph) and:			[aMorph actionSelector == #goUp:with:]]	"ActiveWorld presenter allGoButtons"! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 10/9/2000 16:48'!listViewLineForFieldList: aFieldList	"Answer a ListLineView object which describes the receiver"	| aLine |	aLine := ListViewLine new objectRepresented: self.	aFieldList do:		[:fieldSym | aLine addMorphBack: (self readoutForField: fieldSym).		aLine addTransparentSpacerOfSize: (7 @ 0)].	^ aLine! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'nice 12/27/2009 03:10'!showDesignationsOfObjects	"Momentarily show the designations of objects on the receiver"	| colorToUse |	self isStackBackground ifFalse: [^self].	self submorphsDo: 			[:aMorph | | aLabel | 			aLabel :=aMorph renderedMorph holdsSeparateDataForEachInstance 				ifTrue: 					[colorToUse := Color orange.					 aMorph externalName]				ifFalse: 					[colorToUse := aMorph isShared ifFalse: [Color red] ifTrue: [Color green].					 nil].			Display 				border: (aMorph fullBoundsInWorld insetBy: -6)				width: 6				rule: Form over				fillColor: colorToUse.			aLabel ifNotNil: 					[aLabel asString 						displayOn: Display						at: aMorph fullBoundsInWorld bottomLeft + (0 @ 5)						textColor: Color blue]].	Sensor anyButtonPressed 		ifTrue: [Sensor waitNoButton]		ifFalse: [Sensor waitButton].	World fullRepaintNeeded! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/23/2000 14:38'!stackDo: aBlock	"If the receiver has a stack, evaluate aBlock on its behalf"	| aStack |	(aStack := self ownerThatIsA: StackMorph) ifNotNil:		[^ aBlock value: aStack]! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:42'!stopRunningScripts	"Put all ticking scripts within my scope into paused mode.  Get any scripting-control buttons to show the correct state"	self stopButtonState: #on.	self stepButtonState: #off.	self goButtonState: #off.	associatedMorph stopRunningAll.	"associatedMorph borderColor: Preferences borderColorWhenStopped"! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 2/4/98 00:45'!playerScripted: aPlayer	playerScripted := aPlayer ! !!Viewer methodsFor: 'queries' stamp: 'ar 1/3/2010 17:54'!isViewer	^true! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:46'!actorState	"This method instantiates actorState as a side-effect.	For simple queries, use actorStateOrNil"	| state |	state := self actorStateOrNil.	state ifNil:		[state := ActorState new initializeFor: self assuredPlayer.		self actorState: state].	^ state! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/3/2001 21:22'!defaultLimitClassForVocabulary: aVocabulary	"Answer the class to use, by default, as the limit class on a protocol browser or viewer opened up on the receiver, within the purview of the Vocabulary provided"	^ (aVocabulary isKindOf: FullVocabulary)		ifTrue:			 [self class superclass == Object				ifTrue:					[self class]				ifFalse:					[self class superclass]]		ifFalse:			[ProtoObject]! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'nk 7/7/2003 11:17'!createOrResizeTrailsForm	"If necessary, create a new turtleTrailsForm or resize the existing one to fill my bounds.	On return, turtleTrailsForm exists and is the correct size.	Use the Display depth so that color comparisons (#color:sees: and #touchesColor:) will work right."	| newForm |	(turtleTrailsForm isNil or: [ turtleTrailsForm extent ~= self extent ]) ifTrue:		["resize TrailsForm if my size has changed"		newForm := Form extent: self extent depth: Display depth.		turtleTrailsForm ifNotNil: [			newForm copy: self bounds from: turtleTrailsForm					to: 0@0 rule: Form paint ].		turtleTrailsForm := newForm.		turtlePen := nil].	"Recreate Pen for this form"	turtlePen ifNil: [turtlePen := Pen newOnForm: turtleTrailsForm].! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'di 9/10/1998 16:17'!trailMorph	"Yes, you can draw trails on me."	^ self! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'nice 12/27/2009 20:16'!updateSubmorphThumbnails	| thumbsUp heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	thumbsUp := self alwaysShowThumbnail.	heightForThumbnails := self heightForThumbnails.	maxHeightToAvoidThumbnailing := self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails := self maximumThumbnailWidth.	self submorphs do:		[:aMorph | | itsThumbnail |		thumbsUp			ifTrue:				[itsThumbnail := aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'nice 12/27/2009 03:11'!imposeListViewSortingBy: sortOrderSymbol retrieving: fieldListSelectors	"Establish a list view of the receiver's contents, sorting the contents by the criterion represented by sortOrderSymbol, and displaying readouts as indicated by the list of field selectors."		self setProperty: #sortOrder toValue: sortOrderSymbol.	self setProperty: #fieldListSelectors toValue: fieldListSelectors.	self showingListView ifFalse:		[self autoLineLayout ifFalse: [self saveBoundsOfSubmorphs].		self setProperty: #showingListView toValue: true.		self layoutPolicy: TableLayout new.		self layoutInset: 2; cellInset: 2.		self listDirection: #topToBottom.		self wrapDirection: #none].	self submorphs "important that it be a copy" do:		[:aMorph | | rep | 			rep := aMorph listViewLineForFieldList: fieldListSelectors.			rep hResizing: #spaceFill.			self replaceSubmorph: aMorph by: rep].	self sortSubmorphsBy: (self valueOfProperty: #sortOrder).! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:07'!mouseEnterDragging: evt	"Test button state elsewhere if at all"	^ self mouseEnter: evt! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 5/17/2001 12:47'!adoptVocabulary: aVocabulary	"Make aVocabulary be the one used by me and my submorphs"	self submorphsDo: [:m | m adoptVocabulary: aVocabulary]! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'tk 11/14/2000 13:54'!showingMethodPane: val	"Whether the receiver will show the textual method pane"	showingMethodPane := val! !!Morph methodsFor: '*Etoys' stamp: 'sw 7/20/1999 08:13'!scriptPerformer	^ self topRendererOrSelf player ifNil: [self]! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 10/1/97 00:18'!configureForKids	submorphs ifNotNil:		[submorphs do: [:m | m configureForKids]]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/12/2001 21:50'!handUserRandomTile	"Hand the user a random-number tile, presumably to drop in the script"	self currentHand attachMorph: RandomNumberTile new markAsPartsDonor makeAllTilesGreen	! !!TileMorph methodsFor: 'e-toy support' stamp: 'ar 1/3/2010 17:53'!isTileMorph	^true! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'nb 6/17/2003 12:25'!newCard	"Create a new card for the receiver and return it"	| aNewInstance |	self isStackBackground ifFalse: [^ Beeper beep].  "bulletproof against deconstruction"	aNewInstance := self player class baseUniclass new.	^ aNewInstance! !!ScriptEditorMorph methodsFor: 'scripting' stamp: 'dgd 2/21/2003 23:03'!bringUpToDate	"Make certain that the player name in my header is up to date.  Names emblazoned on submorphs of mine are handled separately by direct calls to their #bringUpToDate methods -- the responsibility here is strictly for the name in the header."	| currentName |	playerScripted ifNil: 			["likely a naked test/yes/no fragment!!"			^self].	currentName := playerScripted externalName.	submorphs isEmpty ifTrue: [^self].	(self firstSubmorph findDeepSubmorphThat: [:m | m knownName = 'title']		ifAbsent: [^self]) label: currentName font: ScriptingSystem fontForTiles! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'yo 3/11/2005 22:18'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	scriptName := scriptName veryDeepCopyWith: deepCopier.	firstTileRow := firstTileRow veryDeepCopyWith: deepCopier.	timeStamp := timeStamp veryDeepCopyWith: deepCopier.	playerScripted := playerScripted.		"Weakly copied"	handWithTile := nil.  "Just a cache"	showingMethodPane := showingMethodPane.	"boolean"	threadPolygon := nil. "Just a cache".! !!EtoysPresenter methodsFor: 'viewer' stamp: 'ul 12/12/2009 14:07'!viewMorph: aMorph 	| aPlayer openViewers aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown 		ifFalse: 			[((aPalette := aMorph standardPalette) notNil and: [aPalette isInWorld]) 				ifTrue: [^aPalette viewMorph: aMorph]].	aPlayer := (topItem := aMorph topRendererOrSelf) assuredPlayer.	openViewers := aPlayer allOpenViewers.	aViewer := openViewers isEmpty ifFalse: [ openViewers first ] ifTrue: [ self nascentPartsViewer ].	self cacheSpecs: topItem.	"redo the spec cache once in a while"	"19 sept 2000 - allow flaps in any paste up"	flapLoc := associatedMorph.	"world"	Preferences viewersInFlaps  ifTrue:  [		aViewer owner ifNotNil: [ :f | ^f flapTab showFlap; yourself ].		aViewer setProperty: #noInteriorThumbnail toValue: true.			aViewer initializeFor: aPlayer barHeight: 0.			aViewer enforceTileColorPolicy.			aViewer fullBounds.	"force layout"			"associatedMorph addMorph: aViewer."	"why???"			flapLoc hideViewerFlapsOtherThanFor: aPlayer.			aFlapTab := flapLoc viewerFlapTabFor: topItem.			aFlapTab referent submorphs 				do: [:m | (m isKindOf: Viewer) ifTrue: [m delete]].			aViewer visible: true.			aFlapTab applyThickness: aViewer width + 25.			aFlapTab spanWorld.			aFlapTab showFlap.			aViewer position: aFlapTab referent position.			aFlapTab referent addMorph: aViewer beSticky.	"moved"			flapLoc startSteppingSubmorphsOf: aFlapTab.			flapLoc startSteppingSubmorphsOf: aViewer.			^aFlapTab].	aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds.	"force layout"	Preferences automaticViewerPlacement 		ifTrue: 			[aPoint := aMorph bounds right 						@ (aMorph center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).			aRect := (aPoint extent: aViewer width @ nominalHeight) 						translatedToBeWithin: flapLoc bounds.			aViewer position: aRect topLeft.			aViewer visible: true.			associatedMorph addMorph: aViewer.			flapLoc startSteppingSubmorphsOf: aViewer.			"it's already in the world, somewhat coincidentally"			^aViewer].	aMorph primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/11/2002 02:03'!offerViewerMenuFor: aViewer event: evt	"Offer the primary Viewer menu to the user.  Copied up from Player code, but most of the functions suggested here don't work for non-Player objects, many aren't even defined, some relate to exploratory sw work not yet reflected in the current corpus.  We are early in the life cycle of this method..."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu title: '**CAUTION -- UNDER CONSTRUCTION!!**Many things may not work!!', self nameForViewer.	(aViewer affordsUniclass and: [self belongsToUniClass not]) ifTrue:		[aMenu add: 'give me a Uniclass' action: #assureUniClass.		aMenu addLine].	aMenu add: 'choose vocabulary...' target: aViewer action: #chooseVocabulary.	aMenu add: 'choose limit class...' target: aViewer action: #chooseLimitClass.	aMenu add: 'add search pane' target: aViewer action: #addSearchPane.	aMenu balloonTextForLastItem: 'Specify which class should be the most generic one to have its methods shown in this Viewer'.	aMenu addLine.	self belongsToUniClass ifTrue:		[aMenu add: 'add a new instance variable' target: self selector: #addInstanceVariableIn: argument: aViewer.		aMenu add: 'add a new script' target: aViewer selector: #newPermanentScriptIn: argument: aViewer.		aMenu addLine.		aMenu add: 'make my class be first-class' target: self selector: #makeFirstClassClassIn: argument: aViewer.		aMenu add: 'move my changes up to my superclass' target: self action: #promoteChangesToSuperclass.		aMenu addLine].	aMenu add: 'tear off a tile' target: self selector: #launchTileToRefer.	aMenu addLine.	aMenu add: 'inspect me' target: self selector: #inspect.	aMenu add: 'inspect my class' target: self class action: #inspect.	aMenu addLine.	aMenu add: 'browse vocabulary' action: #haveFullProtocolBrowsed.	aMenu add: 'inspect this Viewer' target: aViewer action: #inspect.	aMenu popUpEvent: evt in: aViewer currentWorld"	aMenu add: 'references to me' target: aViewer action: #browseReferencesToObject.	aMenu add: 'toggle scratch pane' target: aViewer selector: #toggleScratchPane.	aMenu add: 'make a nascent script for me' target: aViewer selector: #makeNascentScript.	aMenu add: 'rename me' target: aViewer selector: #chooseNewNameForReference.	aMenu add: 'browse full' action: #browseOwnClassFull.	aMenu add: 'browse hierarchy' action: #browseOwnClassHierarchy.	aMenu add: 'set user level...' target: aViewer action: #setUserLevel.	aMenu add: 'browse sub-protocol' action: #browseOwnClassSubProtocol.	aMenu addLine."! !!PasteUpMorph methodsFor: '*eToys-world menu' stamp: 'sw 6/6/2004 13:16'!attemptCleanup	"Try to fix up some bad things that are known to occur in some etoy projects we've seen.  This is a bare beginning, but a useful place to tack on further cleanups, which then can be invoked whenever the attempt-cleanup item invoked from the debug menu"	self attemptCleanupReporting: true"ActiveWorld attemptCleanup"! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 3/11/2003 11:40'!trailStyleForAllPens: aTrailStyle	"Ascribe the given trail style to all pens of objects within me"	submorphs do: [:m | m assuredPlayer setTrailStyle: aTrailStyle]! !!ScriptEditorMorph methodsFor: 'menus' stamp: 'sw 8/28/2004 20:55'!wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph	"Answer whether the receiver would like to offer the halo handle with the given selector (e.g. #addCollapseHandle:)"	(#(addDupHandle: addMakeSiblingHandle:) includes: aSelector) ifTrue:		[^ false].	^ super wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph! !!PhraseTileMorph methodsFor: 'e-toy support' stamp: 'ar 1/3/2010 17:52'!isPhraseTileMorph	^true! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 11/9/2000 20:43'!insertTileRow: tileList after: index	"Return a row to be used to insert an entire row of tiles."	| row |	row := AlignmentMorph newRow		vResizing: #spaceFill;		layoutInset: 0;		extent: (bounds width)@(TileMorph defaultH);		color: Color transparent.	row addAllMorphs: tileList.	self privateAddMorph: row atIndex: index + 1.! !!ScriptEditorMorph methodsFor: 'customevents-buttons' stamp: 'nk 4/23/2004 07:28'!actuallyDestroyScript	"Carry out the actual destruction of the associated script."	| aHandler itsCostume |	self delete.	playerScripted class removeScriptNamed: scriptName.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: scriptName ifAbsent: [].		"not quite enough yet in the multiple-instance case..."	itsCostume := playerScripted costume.	(aHandler := itsCostume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: scriptName].	itsCostume removeActionsSatisfying: [ :act | act receiver == playerScripted and: [ act selector == scriptName ]].	itsCostume currentWorld removeActionsSatisfying: [ :act | act receiver == playerScripted and: [ act selector == scriptName ]].	playerScripted updateAllViewersAndForceToShow: ScriptingSystem nameForScriptsCategory! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'nk 8/21/2004 13:35'!printVocabularySummary	"Put up a window with summaries of all Morph vocabularies."		(StringHolder new contents: EToyVocabulary vocabularySummary) 	openLabel: 'EToy Vocabulary' 	"self currentWorld printVocabularySummary"! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 5/22/2001 16:53'!elementTypeFor: aStringOrSymbol vocabulary: aVocabulary	"Answer a symbol characterizing what kind of element aStringOrSymbol represents.  Realistically, at present, this always just returns #systemScript; a prototyped but not-incorporated architecture supported use of a leading colon to characterize an inst var of a system class, and for the moment we still see its remnant here."	self flag: #deferred.  "a loose end in the non-player case"	^ #systemScript! !!Morph methodsFor: '*Etoys-scripting' stamp: 'LC 9/28/1999 21:57'!makeAllTilesColored	self allMorphsDo: 		[:m | m restoreTypeColor]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 8/31/2004 14:05'!addDismissButtonTo: aRowMorph	"Add the brown dismiss button to the header"	| aButton |	aButton := self tanOButton.	aRowMorph addMorphBack: aButton.	aButton actionSelector: #dismiss;			setBalloonText: 'Remove this scriptfrom the screen(you can open itagain from a Viewer)' translated.	^ aRowMorph! !!StickySketchMorph methodsFor: 'e-toy support' stamp: 'ar 1/3/2010 17:52'!isStickySketchMorph	^true! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/29/98 03:26'!scriptName	^ scriptName! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/24/2000 06:30'!setAsDefaultValueForNewCard	"Set the receiver's current value as the one to be used to supply the default value for a variable on a new card.  This implementation does not support multiple variables per morph, which is problematical"	self setProperty: #defaultValue toValue: self currentDataValue deepCopy! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 12/11/2000 15:37'!browseOwnClassSubProtocol	"Open up a ProtocolBrowser on the subprotocol of the receiver"	ProtocolBrowser openSubProtocolForClass: self class! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 3/8/2004 22:09'!hasAnyTextuallyCodedScripts	"Answer whether any uniclasses in the receiver have any textually coded scripts"	self uniclassesAndCounts do:		[:classAndCount | 			classAndCount first scripts do:				[:aScript | aScript isTextuallyCoded ifTrue: [^ true]]].	^ false"ActiveWorld presenter hasAnyTextuallyCodedScripts"! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/27/2000 17:41'!holdsSeparateDataForEachInstance	"Answer whether the receiver is currently behaving as a 'background field', i.e., whether it is marked as shared (viz. occurring on the background of a stack) *and* is marked as holding separate data for each instance"	^ self isShared and: [self hasProperty: #holdsSeparateDataForEachInstance]! !!EtoysPresenter methodsFor: 'intialize' stamp: 'nice 12/26/2009 20:31'!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.  <-- this note dates from 4/21/99Call #flushPlayerListCache; to force recomputation."	| fullList |	playerList ifNotNil:		[^ playerList].	fullList := associatedMorph allMorphs select: 		[:m | m player ~~ nil] thenCollect: [:m | m player].	fullList copy do:		[:aPlayer |			aPlayer class scripts do:				[:aScript |  aScript isTextuallyCoded ifFalse:					[aScript currentScriptEditor ifNotNil: [:ed |						| objectsReferredToByTiles |						objectsReferredToByTiles := ed allMorphs							select:								[:aMorph | (aMorph isKindOf: TileMorph) and: [aMorph type == #objRef]]							thenCollect:								[:aMorph | aMorph actualObject].						fullList addAll: objectsReferredToByTiles]]]].	^ playerList := (fullList asSet asSortedCollection:			[:a :b | a externalName < b externalName]) asArray! !!Morph methodsFor: '*Etoys' stamp: 'sw 2/19/1999 09:06'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer := self player) ifNil:		[self assureExternalName.  "a default may be given if not named yet"		self player: (aPlayer := self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'ka 4/10/2005 00:43'!viewerFlapTabFor: anObject	"Open up a Viewer on aMorph in its own flap, creating it if necessary"	| bottomMost aPlayer aFlapTab tempFlapTab |	bottomMost := self top.	aPlayer := anObject isMorph ifTrue: [anObject assuredPlayer] ifFalse: [anObject objectRepresented].	self flapTabs do:		[:aTab | ((aTab isKindOf: ViewerFlapTab) or: [aTab hasProperty: #paintingFlap])			ifTrue:				[bottomMost := aTab bottom max: bottomMost.				((aTab isKindOf: ViewerFlapTab) and: [aTab scriptedPlayer == aPlayer])					ifTrue:						[^ aTab]]].	"Not found; make a new one"	tempFlapTab := Flaps newFlapTitled: anObject nameForViewer onEdge: #right inPasteUp: self.	tempFlapTab arrangeToPopOutOnDragOver: false;		arrangeToPopOutOnMouseOver: false. 	"For some reason those event handlers were causing trouble, as reported by ar 11/22/2001, after di's flapsOnBottom update."	aFlapTab := tempFlapTab as: ViewerFlapTab.	aFlapTab initializeFor: aPlayer topAt: bottomMost + 2.	aFlapTab referent color: (Color green muchLighter alpha: 0.5).	aFlapTab referent borderWidth: 0.	aFlapTab referent setProperty: #automaticPhraseExpansion toValue: true.	Preferences compactViewerFlaps 		ifTrue:	[aFlapTab makeFlapCompact: true].	self addMorphFront: aFlapTab.	aFlapTab adaptToWorld: self.	aFlapTab setProperty: #isEToysFlap toValue: true.	^ aFlapTab! !!Morph methodsFor: '*Etoys-support' stamp: 'dgd 2/22/2003 14:31'!firedMouseUpCode	"If the user has special mouseUpCodeToRun, then fire it once right now and return true, else return false"	| evt |	(self world isNil or: [self mouseUpCodeOrNil isNil]) ifTrue: [^false].	evt := MouseEvent new 				setType: nil				position: self center				buttons: 0				hand: self world activeHand.	self programmedMouseUp: evt for: self.	^true! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 8/15/2000 16:58'!willingToBeDiscarded	"Resist the drag-into-trash gesture"	^ false! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 10/24/2004 17:41'!updateToPlayer: newPlayer 	"Make certain that the script name and the names of actors within are up to date"	playerScripted ifNil: 		["likely a naked test/yes/no fragment!!"		^ self].	newPlayer == playerScripted ifTrue: [^ self].	"Already points to him"	self allMorphs do:  [:m | 		(m isKindOf: TileMorph)  ifTrue: 			[m retargetFrom: playerScripted to: newPlayer.			m bringUpToDate]].	playerScripted := newPlayer.	self replaceRow1! !!StandardScriptingSystem class methodsFor: '*Etoys' stamp: 'mir 11/26/2004 16:14'!removePlayersIn: project	"Remove existing player references for project"	References keys do: 		[:key | (References at: key) costume pasteUpMorph == project world			ifTrue: [References removeKey: key]].! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:08'!goButtonState: newState	"Get all go buttons in my scope to show the correct state"	self allGoButtons do:		[:aButton | aButton state: newState]! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'tk 9/30/97 14:15'!handlesMouseOver: evt	^ true! !!Morph class methodsFor: '*eToys-scripting' stamp: 'nk 9/10/2004 11:34'!additionsToViewerCategoryConnection	"Answer viewer additions for the 'connection' category"	"Vocabulary initialize"	^{		#'connections to me'.		#(		(command tellAllPredecessors: 'Send a message to all graph predecessors' ScriptName)		(command tellAllSuccessors: 'Send a message to all graph predecessors' ScriptName)		(command tellAllIncomingConnections: 'Send a message to all the connectors whose destination end is connected to me' ScriptName)		(command tellAllOutgoingConnections: 'Send a message to all the connectors whose source end is connected to me' ScriptName)		(slot incomingConnectionCount 'The number of connectors whose destination end is connected to me' Number readOnly Player getIncomingConnectionCount unused unused)		(slot outgoingConnectionCount 'The number of connectors whose source end is connected to me' Number readOnly Player getOutgoingConnectionCount unused unused)		)	}! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 9/1/2003 14:48'!handUserButtonDownTile	"Hand the user a button-down tile, presumably to drop in the script"			self currentHand attachMorph:		(self presenter systemQueryPhraseWithActionString: '(Sensor anyButtonPressed)' labelled: 'button down?' translated)	! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 11/2/2004 16:41'!dismiss	"Dismiss the scriptor, usually nondestructively"	owner ifNil: [^ self].	scriptName ifNil: [^ self delete].  "ad hoc fixup for bkwrd compat"	(playerScripted isExpendableScript: scriptName) ifTrue: [playerScripted removeScript: scriptName  fromWorld: self world].	handWithTile := nil.	self delete! !!ScriptEditorMorph methodsFor: 'other' stamp: 'di 2/19/2001 10:12'!recreateScript	| aUserScript |	aUserScript := playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript recreateScriptFrom: self! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:46'!choosePenSize	self assuredPlayer choosePenSize! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'di 5/24/2000 15:13'!noteNewLocation: location forPlayer: player	"Note that a morph has just moved with its pen down, begining at startPoint.	Only used in conjunction with Preferences batchPenTrails."	lastTurtlePositions ifNil: [lastTurtlePositions := IdentityDictionary new].	lastTurtlePositions at: player put: location! !!Object methodsFor: '*Etoys-viewer' stamp: 'sd 3/30/2005 22:04'!uniqueInstanceVariableNameLike: aString excluding: takenNames	"Answer a nice instance-variable name to be added to the receiver which resembles aString, making sure it does not coincide with any element in takenNames"	| okBase uniqueName usedNames |	usedNames := self class allInstVarNamesEverywhere.	usedNames removeAllFoundIn: self class instVarNames.	usedNames addAll: takenNames.	okBase := Scanner wellFormedInstanceVariableNameFrom: aString.	uniqueName := Utilities keyLike: okBase satisfying: 		[:aKey | (usedNames includes: aKey) not].	^ uniqueName! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 17:51'!viewingNonOverlappingString	"Answer a string to show in a menu representing whether the 	receiver is currently viewing its subparts by 	non-overlapping-icon (aka auto-line-layout)"	^ ((self showingListView			or: [self autoLineLayout ~~ true])		ifTrue: ['<no>']		ifFalse: ['<yes>']), 'view with line layout' translated! !!ScriptEditorMorph methodsFor: 'testing' stamp: 'sw 7/18/2002 02:43'!setParameterType: typeChosen	"Set the parameter type as indicated"	playerScripted setParameterFor: scriptName toType: typeChosen! !!StandardScriptingSystem class methodsFor: '*Etoys' stamp: 'nk 9/1/2004 10:53'!applyNewEToyLook	"Apply the new EToy look based on free fonts, approximating the classic look as closely as possible."	"StandardScriptingSystem applyNewEToyLook""	| aTextStyle aFont | 	aTextStyle := TextStyle named: #BitstreamVeraSansMono.	aFont := aTextStyle fontOfSize: 12.	aFont := aFont emphasis: 1.	Preferences setEToysFontTo: aFont.	Preferences setButtonFontTo: aFont.	aTextStyle := TextStyle named: #Accushi.	aFont := aTextStyle fontOfSize: 12.	Preferences setFlapsFontTo: aFont.	(aTextStyle := TextStyle named: #Accuny)		ifNotNil:			[Preferences setSystemFontTo: (aTextStyle fontOfSize: 12)]"	Preferences setDefaultFonts: #(		(setEToysFontTo:			BitstreamVeraSansBold	10)		(setButtonFontTo:		BitstreamVeraSansMono	9)		(setFlapsFontTo:			Accushi				12)		(setSystemFontTo:		Accuny				10)		(setWindowTitleFontTo:	BitstreamVeraSansBold	12)	)! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'nk 8/29/2004 17:17'!currentVocabularyFor: aScriptableObject 	"Answer the Vocabulary object to be applied when scripting an object in the world."	| vocabSymbol vocab aPointVocab |	vocabSymbol := self valueOfProperty: #currentVocabularySymbol				ifAbsent: [nil].	vocabSymbol ifNil: 			[vocab := self valueOfProperty: #currentVocabulary ifAbsent: [nil].			vocab ifNotNil: 					[vocabSymbol := vocab vocabularyName.					self removeProperty: #currentVocabulary.					self setProperty: #currentVocabularySymbol toValue: vocabSymbol]].	vocabSymbol ifNotNil: [^Vocabulary vocabularyNamed: vocabSymbol]		ifNil: 			[(aScriptableObject isPlayerLike) ifTrue: [^Vocabulary eToyVocabulary].			(aScriptableObject isNumber) 				ifTrue: [^Vocabulary numberVocabulary].			(aScriptableObject isKindOf: Time) 				ifTrue: [^Vocabulary vocabularyForClass: Time].			(aScriptableObject isString) 				ifTrue: [^Vocabulary vocabularyForClass: String].			(aScriptableObject isPoint) 				ifTrue: 					[(aPointVocab := Vocabulary vocabularyForClass: Point) 						ifNotNil: [^aPointVocab]].			(aScriptableObject isKindOf: Date) 				ifTrue: [^Vocabulary vocabularyForClass: Date].			"OrderedCollection and Holder??"			^Vocabulary fullVocabulary]! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 10/16/2000 10:41'!belongsToUniClass	"Answer whether the receiver belongs to a uniclass.  For the moment (this is not entirely satisfactory) this is precisely equated with the classname ending in a digit"	^ self class name endsWithDigit! !!Morph methodsFor: '*Etoys-support' stamp: 'dgd 2/22/2003 14:31'!enclosingEditor	"Return the next editor around the receiver"	| tested |	tested := owner.	[tested isNil] whileFalse: 			[tested isTileEditor ifTrue: [^tested].			tested := tested owner].	^nil! !!Morph methodsFor: '*Etoys' stamp: 'yo 1/27/2005 23:33'!isTurtleRow	| aCollection selectorCollection |	aCollection := Set new.	selectorCollection := Set new.	self accumlatePlayersInto: aCollection andSelectorsInto: selectorCollection.	#(turtleCount: turtleCount grouped: grouped) do: [:sel |		(selectorCollection includes: sel) ifTrue: [^ false].	].	aCollection do: [:e |		(e isKindOf: KedamaExamplerPlayer) ifTrue: [^ true].	].	^ false.! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 2/15/2001 20:04'!showSourceInScriptor	"Remove tile panes, if any, and show textual source instead"	| aCodePane |	self isTextuallyCoded ifFalse: [self becomeTextuallyCoded].		"Mostly to fix up grandfathered ScriptEditors"	self removeAllButFirstSubmorph.	aCodePane := MethodHolder 		isolatedCodePaneForClass: playerScripted class 		selector: scriptName.	aCodePane		hResizing: #spaceFill;		vResizing: #spaceFill;		minHeight: 100.	self 		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self addMorphBack: aCodePane.	self fullBounds.	self 		listDirection: #topToBottom;		hResizing: #rigid;		vResizing: #rigid;		rubberBandCells: true;		minWidth: self width.	showingMethodPane := true.	self currentWorld startSteppingSubmorphsOf: self! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 4/10/2003 21:15'!dotsForAllPens	"Set the trail style for all my objects to show dots"	self trailStyleForAllPens: #dots! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 5/4/2001 07:04'!externalName	"Answer an external name by which the receiver is known.  Generic implementation here is a transitional backstop. probably"	^ self nameForViewer! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 2/6/2001 22:07'!recompileScript	"A hook called in several places in the UI when something has been dragged & dropped into or out of the script."	self install.	"self stopScript"! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 11/1/2004 22:50'!addParameter	"Transform the receiver so that it bears a parameter.  This will require a selector change, e.g. from #script3 to #script3:"	playerScripted startHavingParameterFor: scriptName asSymbol! !!Morph class methodsFor: '*Etoys' stamp: 'nice 10/20/2009 21:15'!allAdditionsToViewerCategories	"Answer a Dictionary of (<categoryName> <list of category specs>) that 	defines the phrases this kind of morph wishes to add to various Viewer categories. 	 	This version allows each category definition to be defined in one or more separate methods. 	 	Subclasses that have additions can either:	- override #additionsToViewerCategories, or	- (preferably) define one or more additionToViewerCategory* methods.	The advantage of the latter technique is that class extensions may be added by	external packages without having to re-define additionsToViewerCategories."	"	Morph allAdditionsToViewerCategories	"	| dict |	dict := IdentityDictionary new.	(self class includesSelector: #additionsToViewerCategories)		ifTrue: [self additionsToViewerCategories				do: [:group | group						pairsDo: [:key :list | (dict								at: key								ifAbsentPut: [OrderedCollection new])								addAll: list]]].	self class selectorsDo:		[:aSelector | ((aSelector beginsWith: 'additionsToViewerCategory')					and: [(aSelector at: 26 ifAbsent: []) ~= $:])				ifTrue: [(self perform: aSelector)						pairsDo: [:key :list | (dict								at: key								ifAbsentPut: [OrderedCollection new])								addAll: list]]].	^ dict! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'ar 6/2/2001 16:55'!paintBackground	| pic rect |	self world prepareToPaint.	pic := self backgroundSketch.	pic ifNotNil: [pic editDrawingIn: self forBackground: true]		"need to resubmit it? (tck comment)"		ifNil: [rect := self bounds.			pic := self world drawingClass new form: 				(Form extent: rect extent depth: Display depth).			pic bounds: rect.			"self world addMorphBack: pic.  done below"			pic := self backgroundSketch: pic.	"returns a different guy"			pic ifNotNil: [pic editDrawingIn: self forBackground: true]]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'ar 11/8/2000 22:37'!toggleIndicateCursor	indicateCursor := self indicateCursor not.	self changed.! !!EtoysPresenter methodsFor: 'button creation' stamp: 'sw 3/7/1999 00:52'!addTrashCan	| aPosition aCan |	(aCan := associatedMorph findA: TrashCanMorph) ifNotNil: [^ aCan].	aCan := TrashCanMorph newSticky.	aPosition := associatedMorph positionNear: (associatedMorph bottomRight - aCan extent) forExtent: aCan extent adjustmentSuggestion:  (-10 @ 0).	aCan position: aPosition.	associatedMorph addMorph: aCan.	aCan startStepping.	aCan setToAdhereToEdge: #bottomRight.	^ aCan! !!EToyVocabulary class methodsFor: 'accessing' stamp: 'ar 1/3/2010 22:15'!morphClassesDeclaringViewerAdditions	"Answer a list of actual morph classes that either implement #additionsToViewerCategories,	or that have methods that match #additionToViewerCategory* ."	^(Morph class allSubInstances select: [ :ea | ea hasAdditionsToViewerCategories ])! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'tk 10/4/2001 18:03'!noArrowheadsOnAllPens	submorphs do: [:m | m assuredPlayer setPenArrowheads: false]! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'sw 6/16/1999 11:16'!deleteBackgroundPainting	backgroundMorph		ifNotNil:			[backgroundMorph delete.			backgroundMorph := nil]		ifNil:			[self inform: 'There is presently nobackground paintingto delete.']! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 4/10/2001 18:56'!userScriptObject	"Answer the user-script object associated with the receiver"	| aPlayerScripted topEd |	aPlayerScripted := (topEd := self topEditor) playerScripted.	^ aPlayerScripted class userScriptForPlayer: aPlayerScripted selector: topEd scriptName ! !!Player methodsFor: 'testing' stamp: 'nk 9/4/2004 11:48'!hasAnyBorderedCostumes	"Answer true if any costumes of the receiver are BorderedMorph descendents"	self costumesDo:		[:cost | (cost understandsBorderVocabulary) ifTrue: [^ true]].	^ false! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 1/30/2001 23:07'!toolToViewScriptInstantiations	"Open a tool which shows, and allows the user to change the status of, all the instantiations of all the user-written scripts in the world"	AllScriptsTool launchAllScriptsToolFor: self	"self currentWorld presenter toolToViewScriptInstantiations"! !!NumericReadoutTile methodsFor: 'accessing' stamp: 'ar 1/3/2010 17:51'!isNumericReadoutTile	^true! !!EtoysPresenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield := aPlayfield! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/5/2001 14:11'!tearOfButtonToFireScript	"Tear off a button to fire this script"	playerScripted tearOffButtonToFireScriptForSelector: scriptName! !!Morph methodsFor: '*Etoys' stamp: 'dgd 2/22/2003 14:36'!trailMorph	"You can't draw trails on me, but try my owner."	owner isNil ifTrue: [^nil].	^owner trailMorph! !!Morph class methodsFor: '*Etoys' stamp: 'ar 1/3/2010 16:51'!noteAddedSelector: aSelector meta: isMeta	"Any change to an additionsToViewer... method can invalidate existing etoy vocabularies.	The #respondsTo: test is to allow loading the FlexibleVocabularies change set without having to worry about method ordering."	[(isMeta			and: [(aSelector beginsWith: 'additionsToViewer')					and: [self respondsTo: #hasAdditionsToViewerCategories]])		ifTrue: [Vocabulary changeMadeToViewerAdditions]] on: Error do:[].	super noteCompilationOf: aSelector meta: isMeta! !!EToyVocabulary class methodsFor: 'accessing' stamp: 'ar 1/3/2010 22:15'!vocabularySummary	"Answer a string describing all the vocabulary defined anywhere in the 	system."	"	(StringHolder new contents: EToyVocabulary vocabularySummary)  	openLabel: 'EToy Vocabulary' translated 	"	| etoyVocab |	etoyVocab := Vocabulary eToyVocabulary.	etoyVocab initialize.		"just to make sure that it's unfiltered."	^ String streamContents: [:s |		self morphClassesDeclaringViewerAdditions do: [:cl | | allAdditions | 			s nextPutAll: cl name; cr.			allAdditions := cl allAdditionsToViewerCategories.			cl unfilteredCategoriesForViewer do: [ :cat |				allAdditions at: cat ifPresent: [ :additions | | interfaces |					interfaces := ((etoyVocab categoryAt: cat) ifNil: [ ElementCategory new ]) elementsInOrder.					interfaces := interfaces								select: [:ea | additions										anySatisfy: [:tuple | (tuple first = #slot												ifTrue: [tuple at: 7]												ifFalse: [tuple at: 2])												= ea selector]].					s tab; nextPutAll: cat translated; cr.					interfaces						do: [:if | | rt | 							s tab: 2.							rt := if resultType.							rt = #unknown								ifTrue: [s nextPutAll: 'command' translated]								ifFalse: [s nextPutAll: 'property' translated;										 nextPut: $(;										 nextPutAll: (if companionSetterSelector											ifNil: ['RO']											ifNotNil: ['RW']) translated;										 space;										 nextPutAll: rt translated;										 nextPutAll: ') '].							s tab; print: if wording; space.							if argumentVariables								do: [:av | s nextPutAll: av variableName;										 nextPut: $(;										 nextPutAll: av variableType asString;										 nextPut: $)]								separatedBy: [s space].							s tab; nextPutAll: if helpMessage; cr]]]]]! !!Object methodsFor: '*Etoys-viewer' stamp: 'nice 12/26/2009 18:53'!tilePhrasesForMethodInterfaces: methodInterfaceList inViewer: aViewer	"Return a collection of ViewerLine objects corresponding to the method-interface list provided.   The resulting list will be in the same order as the incoming list, but may be smaller if the viewer's vocbulary suppresses some of the methods, or if, in classic tiles mode, the selector requires more arguments than can be handled."	| toSuppress interfaces |	toSuppress := aViewer currentVocabulary phraseSymbolsToSuppress.	interfaces := methodInterfaceList reject: [:int | toSuppress includes: int selector].	Preferences universalTiles ifFalse:  "Classic tiles have their limitations..."		[interfaces := interfaces select:			[:int |				| itsSelector |				itsSelector := int selector.				itsSelector numArgs < 2 or:					"The lone two-arg loophole in classic tiles"					[#(color:sees:) includes: itsSelector]]].	^ interfaces collect:		[:aMethodInterface |			| resultType |			((resultType := aMethodInterface resultType) notNil and: [resultType ~~ #unknown]) 				ifTrue:					[aViewer phraseForVariableFrom: aMethodInterface]				ifFalse:					[aViewer phraseForCommandFrom: aMethodInterface]]! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList := nil! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/23/98 01:07'!hasScriptInvoking: aScriptName ofPlayer: aPlayer	"Answer whether the receiver has any tiles in it which invoke the given script of the given player.  Place-holder for now, needs to be implemented"	^ false! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 7/6/1999 13:36'!toggleOriginAtCenter	| hasIt |	hasIt := self hasProperty: #originAtCenter.	hasIt		ifTrue:			[self removeProperty: #originAtCenter]		ifFalse:			[self setProperty: #originAtCenter toValue: true]! !!SyntaxMorph class methodsFor: 'accessing' stamp: 'ar 1/3/2010 22:12'!allSpecs	"Return all specs that the Viewer knows about. Cache them."	"SyntaxMorph allSpecs"	^AllSpecs ifNil: [		AllSpecs := Dictionary new.		(EToyVocabulary morphClassesDeclaringViewerAdditions)			do: [:cls | cls allAdditionsToViewerCategories keysAndValuesDo: [ :k :v | 				(AllSpecs at: k ifAbsentPut: [ OrderedCollection new ]) addAll: v ] ].		AllSpecs	]! !!Object methodsFor: '*Etoys-viewer' stamp: 'nice 12/26/2009 18:54'!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.  At present this uses a global References dictionary to hold the database of references, but in due course this will need to acquire some locality"	| aName stem knownClassVars |	(aName := self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	(stem := self knownName) ifNil:		[stem := self defaultNameStemForInstances asString].	stem := stem select: [:ch | ch isLetter or: [ch isDigit]].	stem size == 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	knownClassVars := ScriptingSystem allKnownClassVariableNames.	aName := Utilities keyLike:  stem satisfying:		[:jinaLake |			| nameSym |			nameSym := jinaLake asSymbol.			 ((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(knownClassVars includes: nameSym) not]].	References at: (aName := aName asSymbol) put: self.	^ aName! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:52'!* other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primMulScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primMulScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primMulArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primMulArray: self and: other into: result.	].	^ super * other.! !!MethodInterface methodsFor: '*Etoys' stamp: 'yo 3/7/2005 08:46'!initializeFromEToySlotSpec: tuple	"tuple holds an old etoy slot-item spec, of the form found in #additionsToViewerCategories methods.   Initialize the receiver to hold the same information"	| setter |	selector _ tuple seventh.	self		wording: (ScriptingSystem wordingForOperator: tuple second);		helpMessage: tuple third.	receiverType _ #Player.	resultSpecification _ ResultSpecification new.	resultSpecification resultType: tuple fourth.	(#(getNewClone getTurtleAt: getTurtleOf: "seesColor: isOverColor:") includes: selector)		ifTrue:			[self setNotToRefresh]  "actually should already be nil"		ifFalse:			[self setToRefetch].	((tuple fifth == #readWrite) and: [((tuple size >= 9) and: [(setter _ tuple at: 9) ~~ #unused])]) ifTrue:		[resultSpecification companionSetterSelector: setter].		"An example of an old slot-item spec:(slot numericValue 'A number representing the current position of the knob.' number readWrite Player getNumericValue Player setNumericValue:)	1	#slot	2	wording	3	balloon help	4	type	5	#readOnly or #readWrite	6	#Player (not used -- ignore)	7	getter selector	8	#Player (not used -- ignore)	9	setter selector"	! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 5/4/2001 04:51'!tileToRefer	"Answer a reference tile that comprises an alias to me"	^ TileMorph new setToReferTo: self! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:43'!startRunningScripts	"Start running scripts; get stop-step-go buttons to show the right thing"	self stopButtonState: #off.	self stepButtonState: #off.	self goButtonState: #on.	associatedMorph startRunningAll.	"associatedMorph borderColor: Preferences borderColorWhenRunning."	ThumbnailMorph recursionReset.  "needs to be done once in a while (<- tk note from 1997)"! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 4/1/98 16:38'!clearTurtleTrails	turtleTrailsForm := nil.	turtlePen := nil.	self changed.! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 10/26/2000 11:37'!noteNegotiatedName: uniqueName for: requestedName	"This works, kind of, for morphs that have a single variable.  Still holding out for generality of morphs being able to have multiple variables, but need a driving example"	self setProperty: #variableName toValue: uniqueName.	self setProperty: #setterSelector toValue: (Utilities setterSelectorFor: uniqueName).	self setNameTo: uniqueName! !!EtoysPresenter methodsFor: 'scripting' stamp: 'ar 3/17/2001 20:14'!adaptedToWorld: aWorld	"If I refer to a world or a hand, return the corresponding items in the new world."	^aWorld presenter! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 11/4/2001 20:57'!wrapWithAStack	"Install me as a card inside a new stack.  The stack has no border or controls, so I my look is unchanged.  If I don't already have a CardPlayer, find my data fields and make one.  Be ready to make new cards in the stack that look like me, but hold different field data."	self player class officialClass == CardPlayer ifFalse: [		self abstractAModel ifFalse: [^ false]].	StackMorph new initializeWith: self.	self stack addHalo.	"Makes it easier for the user"! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 5/1/2005 00:22'!allCurrentlyTickingScriptInstantiations	"Answer a list of ScriptInstantiation objects representing all the scripts within the scope of the receiver which are currently ticking."	^ Array streamContents:		[:aStream | 			self allExtantPlayers do:				[:aPlayer | aPlayer instantiatedUserScriptsDo:					[:aScriptInstantiation |						aScriptInstantiation status == #ticking ifTrue:							[aStream nextPut: aScriptInstantiation]]]]! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 1/5/1999 10:05'!deletePath	self removeProperty: #pathPoints! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 4/16/2003 12:27'!linesAndArrowsForAllPens	"Set the trail style for all my objects to show arrows"	self trailStyleForAllPens: #arrows! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'sw 10/30/2000 11:09'!showingMethodPane	"Answer whether the receiver is currently showing the textual method pane"	^ showingMethodPane ifNil: [showingMethodPane := false]! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 8/11/1998 16:46'!scriptEditorFor: aScriptName	^ self assuredPlayer scriptEditorFor: aScriptName! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'yo 2/17/2005 17:47'!insertAsStackBackground	"I am not yet in a stack.  Find a Stack that my reference point (center) overlaps, and insert me as a new background."	| aMorph |	self isStackBackground ifTrue: [^ Beeper beep].			"already in a stack.  Must clear flags when remove.""	self potentialEmbeddingTargets do: [:mm |   No, force user to choose a stack.  		(mm respondsTo: #insertAsBackground:resize:) ifTrue: [			^ mm insertAsBackground: self resize: false]]."	"None found, ask user"	self inform: 'Please click on a Stack' translated.	Sensor waitNoButton.	aMorph := self world chooseClickTarget.	aMorph ifNil: [^ self].	(aMorph ownerThatIsA: StackMorph) insertAsBackground: self resize: false.! !!Morph class methodsFor: '*Etoys' stamp: 'nk 8/29/2004 16:35'!additionsToViewerCategory: aCategoryName	"Answer a list of viewer specs for items to be added to the given category on behalf of the receiver.  Each class in a morph's superclass chain is given the opportunity to add more things"	aCategoryName == #vector ifTrue:		[^ self vectorAdditions].	^self allAdditionsToViewerCategories at: aCategoryName ifAbsent: [ #() ].! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 7/18/2002 02:42'!hasParameter	"Answer whether the receiver has a parameter"	^ scriptName numArgs > 0! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 3/11/2002 16:11'!insertUniversalTilesForClass: aClass selector: aSelector	"Add a submorph which holds the universal-tiles script for the given class and selector"	| source tree syn widget header |	source := aClass sourceCodeAt: aSelector ifAbsent: [		Transcript cr; show: aClass name, 'could not find selector ', aSelector.		^ self delete].    	tree := Compiler new 		parse: source 		in: aClass 		notifying: nil.	(syn := tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass.	aSelector numArgs = 0 ifTrue: [		"remove method header line"		(header := syn findA: SelectorNode) ifNotNil: [header delete]].	syn removeReturnNode.		"if ^ self at end, remove it"	widget := syn inAScrollPane.	widget hResizing: #spaceFill;		vResizing: #spaceFill;		color: Color transparent;		setProperty: #hideUnneededScrollbars toValue: true.	self addMorphBack: widget.	(self hasProperty: #autoFitContents) ifFalse:		[self valueOfProperty: #sizeAtHibernate ifPresentDo:			[:oldExtent | self extent: oldExtent]].	syn finalAppearanceTweaks.! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/10/2004 12:23'!tilePhrasesForSelectorList: aList inViewer: aViewer	"Particular to the search facility in viewers.  Answer a list, in appropriate order, of ViewerLine objects to put into the viewer."	| interfaces aVocab |	aVocab := aViewer currentVocabulary.	interfaces := self		methodInterfacesInPresentationOrderFrom:			(aList collect: [:aSel | aVocab methodInterfaceForSelector: aSel class: self class])		forCategory: #search.	^ self tilePhrasesForMethodInterfaces: interfaces inViewer: aViewer! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 18:01'!batchPenTrailsString	"Answer the string to be shown in a menu to represent the 	batch-pen-trails enabled status"	^ (self batchPenTrails		ifTrue: ['<on>']		ifFalse: ['<off>']), 'batch pen trails' translated! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/6/1998 10:20'!stepDown: evt with: aMorph	self stopRunningScripts! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:47'!reshapeBackground	"Abandon any memory of variable-name preferences, and reassess the shape of the background"	self relaxGripOnVariableNames.	"self reassessBackgroundShape.	already done there"! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'dgd 8/31/2003 19:39'!modernizeBJProject	"Prepare a kids' project from the BJ fork of September 2000 -- a once-off thing for converting such projects forward to a modern 3.1a image, in July 2001.  Except for the #enableOnlyGlobalFlapsWithIDs: call, this could conceivably be called upon reloading *any* project, just for safety."	"ActiveWorld modernizeBJProject"	ScriptEditorMorph allInstancesDo:		[:m | m userScriptObject].	Flaps enableOnlyGlobalFlapsWithIDs: {'Supplies' translated}.	ActiveWorld abandonOldReferenceScheme.	ActiveWorld relaunchAllViewers.! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 8/31/2004 14:11'!pinkXButton	"Answer a button with the old X on a pink background, targeted to self"	| aButton |	aButton := IconicButton new labelGraphic: (ScriptingSystem formAtKey: #PinkX).	aButton color: Color transparent; borderWidth: 0; shedSelvedge; actWhen: #buttonUp.	aButton target: self.	^ aButton! !!EtoysPresenter methodsFor: 'standardPlayer etc' stamp: 'sw 6/17/1998 16:05'!standardPlayer	standardPlayer ifNil:		[self createStandardPlayer].	standardPlayer costume isInWorld ifFalse: [associatedMorph addMorphNearBack: standardPlayer costume].	^ standardPlayer! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:51'!primDivArray: rcvr and: other into: result	<primitive: 'primitiveDivArrays' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveDivArrays."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) / (other at: i)	].	^ result.! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 14:58'!+ other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primAddScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primAddScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primAddArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primAddArray: self and: other into: result.	].	^ super + other.! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'ar 12/14/2001 17:44'!mouseEnter: evt	| hand tile |	self flag: #bob.		"needed renderedMorph due to transformations"	hand := evt hand.	hand submorphs size = 1 ifFalse: [^self].	tile := hand firstSubmorph renderedMorph.	(self wantsDroppedMorph: tile event: evt) ifFalse: [^self].	handWithTile := hand.	self startSteppingSelector: #trackDropZones.! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 10/31/2000 07:08'!viewBySize	"Make the receiver show its subparts as a vertical list of lines of information, sorted by object size"	self imposeListViewSortingBy: #reportableSize retrieving: #(externalName reportableSize className oopString)! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 10/25/2000 06:05'!batchPenTrails: aBoolean	self setProperty: #batchPenTrails toValue: aBoolean! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 2/21/2003 23:03'!hibernate	"Possibly delete the tiles, but only if using universal tiles."	| tw |	Preferences universalTiles ifFalse: [^self].	(tw := self findA: TwoWayScrollPane) isNil 		ifFalse: 			[self setProperty: #sizeAtHibernate toValue: self extent.	"+ tw xScrollerHeight"			submorphs size > 1 ifTrue: [tw delete]]! !!EtoysPresenter methodsFor: 'viewer' stamp: 'sw 12/28/1998 22:34'!updateViewer: aViewer	self updateViewer: aViewer forceToShow: nil! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 2/15/1999 19:38'!enforceTileColorPolicy	Preferences coloredTilesEnabled		ifTrue:			[self makeAllTilesColored]		ifFalse:			[self makeAllTilesGreen]! !!ScriptEditorMorph methodsFor: 'menu' stamp: 'tk 8/22/2001 10:49'!autoFitOnOff	"Toggle between auto fit to size of code and manual resize with scrolling"	| tw |	(tw := self findA: TwoWayScrollPane) ifNil: [^ self].	(self hasProperty: #autoFitContents)		ifTrue: [self removeProperty: #autoFitContents.			self hResizing: #rigid; vResizing: #rigid]		ifFalse: [self setProperty: #autoFitContents toValue: true.			self hResizing: #shrinkWrap; vResizing: #shrinkWrap].	tw layoutChanged! !!Morph methodsFor: '*Etoys-scripting' stamp: 'LC 9/28/1999 21:57'!makeAllTilesGreen	self allMorphsDo: 		[:m | m useUniformTileColor]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/2/2004 18:45'!addDestroyButtonTo: aRowMorph 	"Add the destroiy button at the end of the header provided"	| aButton |	aButton := self pinkXButton.	aRowMorph addMorphBack: aButton.	aButton actionSelector: #destroyScript;			 setBalloonText: 'Destroy this script(CAUTION!!!!)' translated.	^ aRowMorph! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:46'!liftPen	self assuredPlayer liftPen! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 10/16/2000 10:35'!assureUniClass	"If the receiver is not yet an instance of a uniclass, create a uniclass for it and make the receiver become an instance of that class."	| anInstance |	self belongsToUniClass ifTrue: [^ self].	anInstance := self class instanceOfUniqueClass.	self become: (self as: anInstance class).	^ anInstance! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'ul 12/12/2009 14:06'!updateStatusMorph: statusMorph	"My status button may need to reflect an externally-induced change in status"	(playerScripted existingScriptInstantiationForSelector: scriptName) ifNotNil:		[:scriptInstantiation |			scriptInstantiation updateStatusMorph: statusMorph]! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 11/2/2001 13:38'!makeHoldSeparateDataForEachInstance	"Mark the receiver as holding separate data for each instance (i.e., like a 'background field') and reassess the shape of the corresponding background so that it will be able to accommodate this arrangement."	self setProperty: #holdsSeparateDataForEachInstance toValue: true.	self stack reassessBackgroundShape.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/16/2001 00:39'!becomeTextuallyCoded	"If the receiver is not currently textually coded, make it become so now, and show its source in place in the Scriptor"	self isTextuallyCoded ifTrue: [^ self].	self saveScriptVersion.	Preferences universalTiles ifFalse: [self userScriptObject becomeTextuallyCoded].	(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete]! !!ParseNode methodsFor: '*eToys-tiles' stamp: 'ab 7/13/2004 13:47'!addCommentToMorph: aMorph	| row |	(self comment isNil or: [self comment isEmpty]) ifTrue: [^ self].	row := aMorph addTextRow:		(String streamContents: [:strm | self printCommentOn: strm indent: 1]).	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 11/3/1998 17:20'!myMorph	"Answer the morph that serves as the costume of my associated player.  If for some reason I have no associated player, answer nil"	| aPlayer |	^ (aPlayer := self playerScripted) ifNotNil: [aPlayer costume]! !!EtoysPresenter methodsFor: 'viewer' stamp: 'ul 12/12/2009 14:07'!updateViewer: aViewer forceToShow: aCategorySymbol	"Update the given viewer to make sure it is in step with various possible changes in the outside world, and when reshowing it be sure it shows the given category"	| aPlayer aPosition newViewer oldOwner wasSticky barHeight itsVocabulary aCategory categoryInfo restrictedIndex |	aCategory := aCategorySymbol ifNotNil: [aViewer currentVocabulary translatedWordingFor: aCategorySymbol].	categoryInfo := aViewer categoryMorphs  asOrderedCollection collect:		[:aMorph | aMorph categoryRestorationInfo].	itsVocabulary := aViewer currentVocabulary.	aCategory ifNotNil: [(categoryInfo includes: aCategorySymbol) ifFalse: [categoryInfo addFirst: aCategorySymbol]].	aPlayer := aViewer scriptedPlayer.	aPosition := aViewer position.	wasSticky := aViewer isSticky.	newViewer := aViewer species new visible: false.	(aViewer isMemberOf: KedamaStandardViewer)		ifTrue: [restrictedIndex := aViewer restrictedIndex].	barHeight := aViewer submorphs first listDirection == #topToBottom		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	Preferences viewersInFlaps ifTrue:		[newViewer setProperty: #noInteriorThumbnail toValue: true].	newViewer rawVocabulary: itsVocabulary.	newViewer limitClass: aViewer limitClass.	newViewer initializeFor: aPlayer barHeight: barHeight includeDismissButton: aViewer hasDismissButton showCategories: categoryInfo.	(newViewer isMemberOf: KedamaStandardViewer)		ifTrue: [			newViewer providePossibleRestrictedView: 0.			newViewer providePossibleRestrictedView: restrictedIndex].	wasSticky ifTrue: [newViewer beSticky].	oldOwner := aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer position: aPosition.	newViewer enforceTileColorPolicy.	newViewer visible: true.	newViewer world ifNotNil: [:aWorld | aWorld startSteppingSubmorphsOf: newViewer].	newViewer layoutChanged! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:46'!lowerPen	self assuredPlayer lowerPen! !!Morph methodsFor: '*Etoys' stamp: 'di 9/3/1998 10:38'!penUpWhile: changeBlock 	"Suppress any possible pen trail during the execution of changeBlock"	self getPenDown		ifTrue: ["If this is a costume for a player with its pen down, suppress any line."				self liftPen.				changeBlock value.				self lowerPen]		ifFalse: ["But usually, just do it."				changeBlock value]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:39'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/22/97 13:14'!newTileMorphRepresentative	^ TileMorph new setLiteral: self! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'sw 2/18/2003 01:46'!getCharacters	"obtain a string value from the receiver"	^ String streamContents:		[:aStream |			submorphs do:				[:m | aStream nextPutAll: m getCharacters]]! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:53'!getPenDown	self player ifNil: [^ false].	^ self actorState getPenDown! !!PasteUpMorph methodsFor: '*eToys-world menu' stamp: 'sw 7/22/2001 00:55'!abandonOldReferenceScheme	"Perform a one-time changeover"	"ActiveWorld abandonOldReferenceScheme"	Preferences setPreference: #capitalizedReferences toValue: true.	(self presenter allExtantPlayers collect: [:aPlayer | aPlayer class]) asSet do:			[:aPlayerClass |				aPlayerClass isUniClass ifTrue:					[aPlayerClass abandonOldReferenceScheme]]! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'di 5/24/2000 15:10'!notePenDown: penDown forPlayer: player at: location	"Note that a morph has just moved with its pen down, begining at startPoint.	Only used in conjunction with Preferences batchPenTrails."	| startLoc |	lastTurtlePositions ifNil: [lastTurtlePositions := IdentityDictionary new].	penDown		ifTrue: ["Putting the Pen down -- record current location"				(lastTurtlePositions includesKey: player) ifFalse:					[lastTurtlePositions at: player put: location]]		ifFalse: ["Picking the Pen up -- draw to current location and remove"				(startLoc := lastTurtlePositions at: player ifAbsent: [nil]) ifNotNil:					[self drawPenTrailFor: player costume							from: startLoc to: location].				lastTurtlePositions removeKey: player ifAbsent: []]! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'sw 2/18/2003 02:56'!elementCount	"Answer how many objects are contained within me"	^ submorphs size! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 10/17/2001 09:46'!bringTileScriptingElementsUpToDate	"Send #bringUpToDate to every tile-scripting element of the receiver, including possibly the receiver itself"	(self allMorphs select: [:s | s isTileScriptingElement]) do:		[:el | el bringUpToDate]! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 11/8/2002 14:57'!becomeSharedBackgroundField	"Mark the receiver as holding separate data for each instance (i.e., like a 'background field') and reassess the shape of the corresponding background so that it will be able to accommodate this arrangement."	((self hasProperty: #shared) and: [self hasProperty: #holdsSeparateDataForEachInstance])		ifFalse: 			[self setProperty: #shared toValue: true.			self setProperty: #holdsSeparateDataForEachInstance toValue: true.			self stack reassessBackgroundShape]! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 8/11/1998 16:55'!succeededInRevealing: aPlayer	aPlayer == self player ifTrue: [^ true].	submorphs do:		[:m | (m succeededInRevealing: aPlayer) ifTrue: [^ true]].	^ false! !!Morph methodsFor: '*Etoys' stamp: 'yo 1/18/2004 10:31'!traverseRowTranslateSlotOld: oldSlotName of: aPlayer to: newSlotName	"Traverse my submorphs, translating submorphs appropriately given the slot rename"	submorphs do: [:tile |		(tile isKindOf: AssignmentTileMorph) ifTrue:			[tile assignmentRoot = oldSlotName ifTrue:				[(self isPlayer: aPlayer ofReferencingTile: tile) ifTrue:					[tile setRoot: newSlotName]]].		(tile isMemberOf: TileMorph) ifTrue:			[(tile operatorOrExpression = (Utilities getterSelectorFor: oldSlotName)) ifTrue:				[(self isPlayer: aPlayer ofReferencingTile: tile) ifTrue:					[tile setOperator: (Utilities getterSelectorFor: newSlotName)]]].		tile traverseRowTranslateSlotOld: oldSlotName of: aPlayer to: newSlotName]! !!Morph methodsFor: '*Etoys-scripting' stamp: 'RAA 3/9/2001 11:39'!bringUpToDate	(self buttonProperties ifNil: [^self]) bringUpToDate! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'dgd 9/1/2003 14:59'!destroyScript	"At user request, and only after confirmation, destroy the script, thus removing it from the uniclass's method dictionary and removing its instantiations from all instances of uniclass, etc."	(self confirm: 'Caution -- this destroys this scriptpermanently; are you sure you want to do this?' translated) ifFalse: [^ self].	true ifTrue: [^ playerScripted removeScript: scriptName fromWorld: self world].	self flag: #deferred.  "revisit"	(playerScripted okayToDestroyScriptNamed: scriptName)		ifFalse:			[^ self inform: 'Sorry, this script is being calledfrom another script.' translated].	self actuallyDestroyScript! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/24/98 17:28'!prepareToUndoDropOf: aMorph	"No longer functional"! !!EtoysPresenter methodsFor: 'viewer' stamp: 'sw 2/19/2001 15:41'!cacheSpecs: aMorph	"For SyntaxMorph's type checking, cache the list of all viewer command specifications."	aMorph world ifNil: [^ true].	Preferences universalTiles ifFalse: [^ true].	Preferences eToyFriendly ifFalse: [^ true].	"not checking"	(Project current projectParameterAt: #fullCheck ifAbsent: [false]) 		ifFalse: [^ true].	"not checking"	SyntaxMorph initialize.! !!Morph methodsFor: '*Etoys' stamp: 'dgd 9/5/2003 18:25'!putOnForeground	"Place the receiver, formerly on the background, onto the foreground.  If the receiver needs data carried on its behalf by the card, those data will be lost, so in this case get user confirmation before proceeding."	self holdsSeparateDataForEachInstance "later add the refinement of not putting up the following confirmer if only a single instance of the current background's uniclass exists"		ifTrue:			[self confirm: 'Caution -- every card of this backgroundformerly had its own value for thisitem.  If you put it on the foreground,the values  of this item on all othercards will be lost' translated				orCancel: [^ self]].	self removeProperty: #shared.	self stack reassessBackgroundShape.	"still work to be done here!!"! !!StandardScriptingSystem class methodsFor: '*Etoys' stamp: 'ar 1/3/2010 16:52'!noteAddedSelector: aSelector meta: isMeta	[aSelector == #wordingForOperator: ifTrue:		[Vocabulary changeMadeToViewerAdditions]] on: Error do:[].	super noteAddedSelector: aSelector meta: isMeta! !!EtoysPresenter methodsFor: 'viewer' stamp: 'yo 3/30/2005 11:21'!nascentPartsViewerFor: aViewee	"Create a new, naked Viewer object for viewing aViewee.  Give it a vocabulary if either the viewee insists on one or if the project insists on one."	| aViewer aVocab |	(aViewee isKindOf: KedamaExamplerPlayer) ifTrue: [^ KedamaStandardViewer new].	aViewer := StandardViewer new.	(aVocab := aViewee vocabularyDemanded)		ifNotNil:			[aViewer useVocabulary: aVocab]		ifNil:			[(aVocab := associatedMorph currentVocabularyFor: aViewee) ifNotNil:				[aViewer useVocabulary: aVocab]].		"If the viewee does not *demand* a special kind of Viewer, and if the project has not specified a preferred vocabulary, then the system defaults will kick in later"	^ aViewer! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'kfr 1/24/2006 21:23'!addYesNoToHand	"Place a test/yes/no complex in the hand of the beloved user"	| ms messageNodeMorph aMorph |	Preferences universalTiles		ifTrue:			[ms := MessageSend receiver: true selector: #ifTrue:ifFalse:						arguments: {['do nothing']. ['do nothing']}.			messageNodeMorph := ms asTilesIn: playerScripted class globalNames: true.			self primaryHand attachMorph: messageNodeMorph]		ifFalse:			[aMorph := CompoundTileMorph new.			ActiveHand attachMorph: aMorph.			aMorph setNamePropertyTo: 'TestTile' translated.			aMorph position: ActiveHand position.			aMorph formerPosition: ActiveHand position.			self startSteppingSelector: #trackDropZones.]! !!Morph class methodsFor: '*eToys-scripting' stamp: 'sw 7/20/2005 01:20'!additionsToViewerCategoryColorAndBorder	"Answer viewer additions for the 'color & border' category"	^#(		#'color & border' 		(			(slot color 'The color of the object' Color readWrite Player getColor  Player  setColor:)			(slot opacity '0 means completely transparent, 1 means completely opaque' Number readWrite Player getAlpha Player setAlpha:)			(slot borderStyle 'The style of the object''s border' BorderStyle readWrite Player getBorderStyle player setBorderStyle:)			(slot borderColor 'The color of the object''s border' Color readWrite Player getBorderColor Player  setBorderColor:)			(slot borderWidth 'The width of the object''s border' Number readWrite Player getBorderWidth Player setBorderWidth:)			(slot roundedCorners 'Whether corners should be rounded' Boolean readWrite Player getRoundedCorners Player setRoundedCorners:)			(slot gradientFill 'Whether a gradient fill should be used' Boolean readWrite Player getUseGradientFill Player setUseGradientFill:)			(slot secondColor 'The second color used when gradientFill is in effect' Color readWrite Player getSecondColor Player setSecondColor:)			(slot radialFill 'Whether the gradient fill, if used, should be radial' Boolean readWrite Player getRadialGradientFill Player setRadialGradientFill:)			(slot dropShadow 'Whether a drop shadow is shown' Boolean readWrite Player getDropShadow Player setDropShadow:)			(slot shadowColor 'The color of the drop shadow' Color readWrite Player getShadowColor Player setShadowColor:)		)	)! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/6/2000 07:37'!variableDocks	"Answer a list of VariableDocker objects for docking up my data with an instance held in my containing playfield.  The simple presence of some objects on a Playfield will result in the maintenance of instance data on the corresponding Card.  This is a generalization of the HyperCard 'field' idea.  If there is already a cachedVariableDocks cached, use that.  For this all to work happily, one must be certain to invalidate the #cachedVariableDocks cache when that's appropriate."	^ self valueOfProperty: #cachedVariableDocks ifAbsent: [#()]! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:52'!- other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primSubScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primSubScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primSubArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primSubArray: self and: other into: result.	].	^ super - other.! !!EtoysPresenter class methodsFor: 'class initialization' stamp: 'ar 1/3/2010 22:22'!initialize	Presenter defaultPresenterClass: self.	PasteUpMorph allInstancesDo:[:p| p dumpPresenter].	Vocabulary initializeStandardVocabularies.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 12/31/1998 17:54'!setTimeStamp	timeStamp := Date today mmddyyyy, ' ', (Time now print24 copyFrom: 1 to: 8).	^ timeStamp! !!ScriptEditorMorph methodsFor: 'menus' stamp: 'yo 3/11/2005 22:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add custom menu items to a menu"	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addUpdating: #autoFitString target: self action: #autoFitOnOff.	aCustomMenu addLine.	aCustomMenu add: 'fix layout' target: self action: #fixLayout.	threadPolygon ifNil: [		aCustomMenu add: 'show thread' target: self action: #createThreadShowing.	] ifNotNil: [		aCustomMenu add: 'hide thread' target: self action: #deleteThreadShowing.	].! !!Morph methodsFor: '*Etoys-scripting' stamp: 'ar 1/25/2001 12:50'!asEmptyPermanentScriptor	"Answer a new empty permanent scriptor derived from info deftly secreted in the receiver.  Good grief"	| aScriptor aPlayer |	aPlayer := self valueOfProperty: #newPermanentPlayer.	aPlayer assureUniClass.	aScriptor :=  aPlayer newScriptorAround: nil.	aScriptor position: (self world primaryHand position - (10 @ 10)).	aPlayer updateAllViewersAndForceToShow: #scripts.	^ aScriptor! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/29/98 18:37'!scriptee	| editor |	playerScripted ifNotNil: [^ playerScripted].	(editor := self topEditor) == self ifTrue: [self error: 'unattached script editor'. ^ nil].	^ editor scriptee! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'RAA 10/4/2000 08:26'!toggleFenceEnabled		self fenceEnabled: self fenceEnabled not! !!PasteUpMorph class methodsFor: '*eToys-scripting' stamp: 'sw 8/3/2005 13:57'!additionsToViewerCategoryPreferences	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #(preferences (			(slot useVectorVocabulary 'Whether to use the Vector vocabulary with etoy scripting in this project' Boolean readWrite Player getUseVectorVocabulary Player setUseVectorVocabulary:)			(slot dropProducesWatcher 'Whether a drop of a value tile, such as "car''s x", on the desktop, should produce a watcher for that value' Boolean readWrite Player getDropProducesWatcher Player setDropProducesWatcher:)			(slot allowEtoyUserCustomEvents 'Whether to allow "custom events" in etoys.' Boolean readWrite Player getAllowEtoyUserCustomEvents Player setAllowEtoyUserCustomEvents:)			(slot batchPenTrails 'Whether pen trails should reflect small movements within the same tick or only should integrate all movement between ticks' Boolean readWrite Player getBatchPenTrails Player setBatchPenTrails:)			"(slot eToyFriendly 'Whether various restrictions should apply in many parts of the system.  Intended to be set to true for younger users.' Boolean readWrite Player getEToyFriendly Player setEToyFriendly:)"			(slot fenceEnabled 'Whether an object hitting the edge of the screen should be kept "fenced in", rather than being allowed to escape and disappear' Boolean readWrite Player getFenceEnabled Player setFenceEnabled:)			(slot keepTickingWhilePainting 'Whether scripts should continue to run while you''re using the painting system' Boolean readWrite Player getKeepTickingWhilePainting Player setKeepTickingWhilePainting:)			(slot oliveHandleForScriptedObjects 'Whether the default green halo handle (at the top right of the halo) should, for scripted objects, be the olive-green handle, signifying that use will result in a sibling instance. ' Boolean readWrite Player getOliveHandleForScriptedObjects  Player setOliveHandleForScriptedObjects: )	))! !!ScriptEditorMorph methodsFor: 'menu commands' stamp: 'yo 1/26/2005 14:56'!deleteThreadShowing	threadPolygon ifNotNil: [threadPolygon delete. threadPolygon := nil].! !!ParseNode methodsFor: '*eToys-tiles' stamp: 'RAA 8/24/1999 13:06'!currentValueIn: aContext	^nil! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'nice 12/27/2009 03:10'!abstractAModel	"Find data-containing fields in me.  Make a new class, whose instance variables are named for my fields, and whose values are the values I am showing.  Use a CardPlayer for now.  Force the user to name the fields.  Make slots for text, Number Watchers, SketchMorphs, and ImageMorphs."	| unnamed ans player twoListsOfMorphs holdsSepData docks oldPlayer instVarNames |	(oldPlayer := self player) ifNotNil: 			[oldPlayer belongsToUniClass 				ifTrue: 					["Player"					oldPlayer class instVarNames notEmpty 						ifTrue: 							[self 								inform: 'I already have a regular Player, so I can''t have a CardPlayer'.							^true]]].	twoListsOfMorphs := StackMorph discoverSlots: self.	holdsSepData := twoListsOfMorphs first.	instVarNames := ''.	holdsSepData do: 			[:ea | | iVarName | 			iVarName := Scanner wellFormedInstanceVariableNameFrom: ea knownName.			iVarName = ea knownName ifFalse: [ea name: iVarName].			instVarNames := instVarNames , iVarName , ' '].	unnamed := twoListsOfMorphs second.	"have default names"	instVarNames isEmpty 		ifTrue: 			[self 				inform: 'No named fields were found.Please get a halo on each field and give it a name.Labels or non-data fields should be named "shared xxx".'.			^false].	unnamed notEmpty 		ifTrue: 			[ans := (UIManager default					chooseFrom: #(						 'All other fields are non-data fields'.						'Stop.  Let me give a name to some more fields'.					) title: 'Data fields are ' , instVarNames printString 								, ('\Some fields are not named.  Are they labels or non-data fields?' 										, '\Please get a halo on each data field and give it a name.') withCRs) = 1.			ans ifFalse: [^false]].	unnamed 		withIndexDo: [:mm :ind | mm setName: 'shared label ' , ind printString].	"Make a Player with instVarNames.  Make me be the costume"	player := CardPlayer instanceOfUniqueClassWithInstVarString: instVarNames				andClassInstVarString: ''.	self player: player.	player costume: self.	"Fill in the instance values.  Make docks first."	docks := OrderedCollection new.	holdsSepData do: 			[:morph | 			morph setProperty: #shared toValue: true.	"in case it is deeply embedded"			morph setProperty: #holdsSeparateDataForEachInstance toValue: true.			player class compileInstVarAccessorsFor: morph knownName.			morph isSyntaxMorph ifTrue: [morph setTarget: player].	"hookup the UpdatingString!!"			docks addAll: morph variableDocks].	player class newVariableDocks: docks.	docks do: [:dd | dd storeMorphDataInInstance: player].	"oldPlayer class mdict do: [:assoc | move to player].	move methods to new class?"	"oldPlayer become: player."	^true	"success"! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:50'!primAddArray: rcvr and: other into: result	<primitive: 'primitiveAddArrays' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveAddArrays."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) + (other at: i)	].	^ result.! !!EtoysPresenter methodsFor: 'standardPlayer etc' stamp: 'tk 7/28/2005 04:54'!createStandardPlayer	| aMorph |	aMorph := ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	(standardPlayer := aMorph assuredPlayer) renameTo: 'dot' translated.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 17:50'!viewingBySizeString	"Answer a string to show in a menu representing whether the 	receiver is currently viewing its subparts by size or not"	^ ((self showingListView			and: [(self					valueOfProperty: #sortOrder					ifAbsent: [])					== #reportableSize])		ifTrue: ['<yes>']		ifFalse: ['<no>']), 'view by size' translated! !!ScriptEditorMorph methodsFor: 'other' stamp: 'yo 3/15/2005 12:11'!handUserButtonUpTile	"Hand the user a button-up tile, presumably to drop in the script"			self currentHand attachMorph:		(self presenter systemQueryPhraseWithActionString: '(Sensor noButtonPressed)' labelled: 'button up?' translated)	! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 17:59'!autoExpansionString	"Answer the string to be shown in a menu to represent the  	auto-phrase-expansion status"	^ ((self hasProperty: #automaticPhraseExpansion)		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'auto-phrase-expansion' translated! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 2/6/2001 22:07'!scriptEdited	| anEditor |	(anEditor := self topEditor) ifNotNil: [anEditor recompileScript]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 7/6/1998 16:26'!toggleAlwaysShowThumbnail	(self hasProperty: #alwaysShowThumbnail)		ifTrue:			[self removeProperty: #alwaysShowThumbnail]		ifFalse:			[self setProperty: #alwaysShowThumbnail toValue: true].	self updateSubmorphThumbnails! !!Morph methodsFor: '*Etoys' stamp: 'yo 1/18/2004 10:32'!traverseRowTranslateSlotOld: oldSlotName to: newSlotName	"Traverse my submorphs, translating submorphs appropriately given the slot rename"	submorphs do: [:tile |		(tile isKindOf: AssignmentTileMorph) ifTrue: 			[tile assignmentRoot = oldSlotName ifTrue: [tile setRoot: newSlotName]].		(tile isMemberOf: TileMorph) ifTrue:			[(tile operatorOrExpression = (Utilities getterSelectorFor: oldSlotName)) ifTrue:				[tile setOperator: (Utilities getterSelectorFor: newSlotName)]].		tile traverseRowTranslateSlotOld: oldSlotName to: newSlotName]! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:33'!explainDesignations	"Hand the user an object that contains explanations for the designation feedback used"	StackMorph designationsExplainer openInHand	"self currentWorld explainDesignations"! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 5/17/2001 15:40'!updateHeader	"Replace my header morph with another one assured of being structurally au courant"		(firstTileRow notNil and: [firstTileRow > 1]) ifTrue:		[self replaceRow1]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/28/2004 20:57'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 cellPositioning: #topLeft;		 setProperty: #autoFitContents toValue: true;	 layoutInset: 2;	 useRoundedCorners.	self setNameTo: 'Script Editor' translated.	firstTileRow := 1.	"index of first tile-carrying submorph"	self addNewRow.	showingMethodPane := false! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/30/2001 18:56'!reinsertSavedTiles: savedTiles	"Revert the scriptor to show the saved tiles"	self submorphs doWithIndex: [:m :i | i > 1 ifTrue: [m delete]].	self addAllMorphs: savedTiles.	self allMorphsDo: [:m | m isTileScriptingElement ifTrue: [m bringUpToDate]].	self install.	self showingMethodPane: false! !!EtoysPresenter methodsFor: 'standardPlayer etc' stamp: 'sw 1/20/2004 20:08'!positionStandardPlayer	"Put the standard player slightly off-screen"	standardPlayer ifNotNil:		[standardPlayer costume position: (associatedMorph topLeft - (13@0))]! !!Morph methodsFor: '*Etoys-scripting' stamp: 'ul 12/12/2009 14:09'!defaultFloatPrecisionFor: aGetSelector	"Answer a number indicating the default float precision to be used in a numeric readout for which the receiver provides the data.   Individual morphs can override this.  Showing fractional values for readouts of getCursor was in response to an explicit request from ack"	(self renderedMorph decimalPlacesForGetter: aGetSelector) ifNotNil: [:places | ^ (Utilities floatPrecisionForDecimalPlaces: places)].	(#(getCursor getNumericValue getNumberAtCursor getCursorWrapped getScaleFactor getUnitVector getAlpha) includes: aGetSelector)		ifTrue:			[^ 0.01].	^ 1! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 11/25/2004 15:20'!unhibernate	"I have been loaded as part of an ImageSegment.	Make sure that I am fixed up properly."	| fixMe |	(fixMe := self valueOfProperty: #needsLayoutFixed ifAbsent: [ false ])		ifTrue: [self removeProperty: #needsLayoutFixed ].	self topEditor == self		ifFalse: [^ self]. "Part of a compound test"	self updateHeader.	fixMe ifTrue: [ self fixLayout. self removeProperty: #needsLayoutFixed ].	"Recreate my tiles from my method if i have new universal tiles."	self world		ifNil: [(playerScripted isNil					or: [playerScripted isUniversalTiles not])				ifTrue: [^ self]]		ifNotNil: [Preferences universalTiles				ifFalse: [^ self]].	self insertUniversalTiles.	self showingMethodPane: false! !!JoystickMorph class methodsFor: '*eToys-scripting' stamp: 'bf 9/5/2005 11:02'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ #((joystick ((slot amount 'The amount of displacement' Number readOnly Player getAmount unused unused)(slot angle 'The angular displacement' Number readOnly Player getAngle  unused  unused)(slot leftRight  'The horizontal displacement' Number  readOnly Player getLeftRight  unused  unused)(slot upDown 'The vertical displacement' Number  readOnly Player getUpDown unused unused)(slot button1 'Button 1 pressed' Boolean  readOnly Player getButton1 unused unused)(slot button2 'Button 2 pressed' Boolean  readOnly Player getButton2 unused unused))))! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 10/27/2000 17:46'!slotSpecifications	"A once and possibly future feature; retained here for backward-compatibility bulletproofing."	^ #()! !!Morph methodsFor: '*Etoys-support' stamp: ''!jumpTo: aPoint	"Let my owner decide how I move."	owner move: self toPosition: aPoint.! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'tk 6/14/1998 15:18'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	self world ifNil: [^ nil].	aScriptor := ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:10'!stepButtonState: newState	"Get all step buttons in my scope to show the correct state"	self allStepButtons do:		[:aButton | aButton state: newState]! !!Morph methodsFor: '*Etoys-support' stamp: 'nb 6/17/2003 12:25'!beep: soundName	self playSoundNamed: soundName! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'RAA 10/4/2000 08:24'!fenceEnabled	^ self valueOfProperty: #fenceEnabled ifAbsent: [Preferences fenceEnabled]! !!Player methodsFor: 'testing' stamp: 'ar 1/3/2010 20:56'!isPlayer	^true! !!TileMorph class methodsFor: 'class initialization' stamp: 'ar 1/3/2010 22:18'!upPicture	^ UpPicture ifNil:[UpPicture := Form	extent: 9@8	depth: 16	fromArray: #( 0 0 932001709 0 0 0 14254 793457484 0 0 0 13197 654912266 931987456 0 0 12107 654912266 862715904 0 0 931998474 722020105 724252557 0 0 793455401 724183850 724187021 0 14221 724182761 652879594 652816171 931987456 0 791422634 717892298 648686282 862781440)	offset: 0@0]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 18:04'!presentViewMenu	"Answer an auxiliary menu with options specific to viewing playfields -- this is put up from the provisional 'view' halo handle, on pasteup morphs only."	| aMenu isWorld |	isWorld := self isWorldMorph.	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	self addViewingItemsTo: aMenu.	#(	"(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')"		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(resizeToFitString		toggleResizeToFit			'whether I should automatically strive exactly to fit my contents')		(behaveLikeAHolderString	toggleBehaveLikeAHolder			'whether auto-line-layout, resize-to-fit, and indicate-cursor should be set to true; useful for animation control, etc.')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')		(fenceEnabledString	toggleFenceEnabled			'whether moving objects should stop at the edge of their container')		(autoViewingString		toggleAutomaticViewing			'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.')		(griddingString			griddingOnOff			'whether gridding should be used in my interior')		(gridVisibleString		gridVisibleOnOff			'whether the grid should be shown when gridding is on')	) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail toggleAutomaticViewing ) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third translated]]. 	aMenu addLine.	aMenu add: 'round up strays' translated action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.' translated.	aMenu add: 'shuffle contents' translated action: #shuffleSubmorphs.	aMenu balloonTextForLastItem: 'Rearranges my contents in random order' translated.	aMenu add: 'set grid spacing...' translated action: #setGridSpec.	aMenu balloonTextForLastItem: 'Set the spacing to be used when gridding is on' translated.	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' translated action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them' translated].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' translated action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.' translated].	aMenu addLine.	self addPenTrailsMenuItemsTo: aMenu.	aMenu addLine.	aMenu add: 'use standard texture' translated action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.' translated.	aMenu add: 'make graph paper...' translated action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.' translated.	aMenu addTitle: ('viewing options for "{1}"' translated format: {self externalName}).	aMenu popUpForHand: self activeHand in: self world! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 10/21/1999 12:34'!makeIsolatedCodePane	MethodHolder makeIsolatedCodePaneForClass: playerScripted class selector: scriptName! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 2/12/98 13:25'!installWithNewLiteral	self removeSpaces.	scriptName ifNotNil:		[playerScripted ifNotNil: [playerScripted acceptScript: self topEditor for:  scriptName]]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/20/2002 14:34'!renameScriptTo: newSelector	"Rename the receiver's script so that it bears a new selector"	| aMethodNodeMorph methodMorph methodSource pos newMethodSource |	scriptName := newSelector.	self updateHeader.	Preferences universalTiles		ifFalse:  "classic tiles"			[self showingMethodPane				ifTrue:					["textually coded -- need to change selector"					methodMorph := self findA: MethodMorph.					methodSource := methodMorph text string.					pos := methodSource indexOf: Character cr ifAbsent: [self error: 'no cr'].					newMethodSource := newSelector.					newSelector numArgs > 0 ifTrue: [newMethodSource := newMethodSource, ' t1'].  "for the parameter"					newMethodSource := newMethodSource, (methodSource copyFrom: pos to: methodSource size).					methodMorph editString: newMethodSource.					methodMorph model changeMethodSelectorTo: newSelector.					playerScripted class compile: newMethodSource classified: 'scripts'.					methodMorph accept]				ifFalse:					[self install]]		ifTrue:  "universal tiles..."			[(aMethodNodeMorph := self methodNodeMorph) ifNotNil:				[aMethodNodeMorph acceptInCategory: 'scripts']]! !!EtoysPresenter methodsFor: 'tile support' stamp: 'sw 9/27/2001 17:43'!valueTiles	"Answer some constant-valued tiles.  This dates back to very early etoy work in 1997, and presently has no senders"	| tiles |	tiles := OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #Number)).	tiles add: (ColorTileMorph new typeColor: (ScriptingSystem colorForType: #Color)).	tiles add: (TileMorph new typeColor: (ScriptingSystem colorForType: #Number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 12/14/2001 17:42'!trackDropZones	"The fundamental heart of script-editor layout, by Dan Ingalls in fall 1997, though many hands have touched it since."	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii where |	hand := handWithTile ifNil: [self primaryHand].	((self hasOwner: hand) not and: [hand submorphCount > 0])		ifTrue:			[insertion := hand firstSubmorph renderedMorph.			insHt := insertion fullBounds height.			self removeSpaces.			where := self globalPointToLocal: hand position"insertion fullBounds topLeft".			i := (ii := self indexOfMorphAbove: where) min: submorphs size-1.			prevBot := i <= 0 ifTrue: [(self innerBounds) top]							ifFalse: [(self submorphs at: i) bottom].			nxtHt := (submorphs isEmpty				ifTrue: [insertion]				ifFalse: [self submorphs at: i+1]) height.			d := ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (where y - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 := Color green.  c2 := Color transparent.			ht2 := d*insHt//nxtHt.			space1 := Morph newBounds: (0@0 extent: 30@(insHt-ht2))                                        color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 := Morph newBounds: (0@0 extent: 30@ht2)                                        color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]		ifFalse:			[self stopSteppingSelector: #trackDropZones.			self removeSpaces]! !!Morph methodsFor: '*Etoys-scripting' stamp: 'dgd 7/4/2004 12:41'!arrowDeltaFor: aGetSelector 	"Answer a number indicating the default arrow delta to be  	used in a numeric readout with the given get-selector. This is  	a hook that subclasses of Morph can reimplement."	aGetSelector == #getScaleFactor		ifTrue: [^ 0.1].	^ 1! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 12/15/2004 20:37'!restoreScriptName: aScriptName	"For fixup only..."	scriptName := aScriptName! !!StandardScriptingSystem class methodsFor: '*Etoys' stamp: 'mir 11/25/2004 19:01'!removeUnreferencedPlayers	"Remove existing but unreferenced player references"	"StandardScriptingSystem removeUnreferencedPlayers"	References keys do: 		[:key | (References at: key) costume pasteUpMorph			ifNil: [References removeKey: key]].! !!Morph class methodsFor: '*Etoys' stamp: 'nice 10/21/2009 00:38'!unfilteredCategoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer for one of my instances, in order of:	- masterOrderingOfCategorySymbols first	- others last in order by translated wording"	"	Morph unfilteredCategoriesForViewer	"	| aClass additions masterOrder |	aClass := self.	additions := OrderedCollection new.	[aClass == Morph superclass ] whileFalse: [		additions addAll: (aClass allAdditionsToViewerCategories keys asArray			sort: [ :a :b | a translated < b translated ]).		aClass := aClass superclass ]. 	masterOrder := EToyVocabulary masterOrderingOfCategorySymbols.	^(masterOrder intersection: additions), (additions difference: masterOrder).! !!ScriptEditorMorph methodsFor: 'e-toy support' stamp: 'tk 2/1/2001 22:37'!adaptToWorld: aWorld	self unhibernate	"for universal tiles"! !!EtoysPresenter methodsFor: 'palette & parts bin' stamp: 'sw 2/12/2001 22:02'!systemQueryPhraseWithActionString: anActionString labelled: aLabel	"Answer a SystemQueryPhrase with the given action string and label"	| aTile aPhrase |		aPhrase := SystemQueryPhrase new.	aTile := BooleanTile new.	aTile setExpression: anActionString label: aLabel.	aPhrase addMorph: aTile.	aPhrase enforceTileColorPolicy.	^ aPhrase! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/29/98 18:02'!timeStamp	^ timeStamp! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:53'!/ other	| result |	other isNumber ifTrue: [		other isFloat ifTrue: [			result := KedamaFloatArray new: self size.			^ self primDivScalar: self and: other into: result.		] ifFalse: [			result := WordArray new: self size.			^ self primDivScalar: self and: other into: result.		].	].	(other isMemberOf: WordArray) ifTrue: [			result := WordArray new: self size.		^ self primDivArray: self and: other into: result.	].	(other isMemberOf: KedamaFloatArray) ifTrue: [			result := KedamaFloatArray new: self size.		^ self primDivArray: self and: other into: result.	].	^ super / other.! !!Morph methodsFor: '*Etoys' stamp: 'nice 10/21/2009 00:09'!categoriesForViewer	"Answer a list of symbols representing the categories to offer in the 	viewer, in order"	| dict |	dict := Dictionary new.	self unfilteredCategoriesForViewer		withIndexDo: [:cat :index | dict at: cat put: index].	self filterViewerCategoryDictionary: dict.	^ dict keys asArray sort: [:a :b | (dict at: a)						< (dict at: b)]! !!Morph methodsFor: '*Etoys' stamp: 'nk 9/4/2004 11:47'!understandsBorderVocabulary	"Replace the 'isKindOf: BorderedMorph' so that (for instance) Connectors can have their border vocabulary visible in viewers."	^false! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 6/18/1998 09:13'!toggleAutomaticViewing	| current |	current := self automaticViewing.	current		ifTrue:			[self removeProperty: #automaticViewing]		ifFalse:			[self setProperty: #automaticViewing toValue: true]! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 12:13'!assuredCardPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer := self player) ifNotNil: [		(aPlayer isKindOf: CardPlayer) 				ifTrue: [^ aPlayer]				ifFalse: [self error: 'Must convert to a CardPlayer']					"later convert using as: and remove the error"].	self assureExternalName.  "a default may be given if not named yet"	self player: (aPlayer := UnscriptedCardPlayer newUserInstance).		"Force it to be a CardPlayer.  Morph class no longer dictates what kind of player"	aPlayer costume: self.	self presenter ifNotNil: [self presenter flushPlayerListCache].	^ aPlayer! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 1/22/2001 15:22'!renameScript	"Rename the current script.  Invoked at user menu request"	playerScripted renameScript: self scriptName! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'ar 1/3/2010 17:53'!isTilePadMorph	^true! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'sw 10/17/2000 11:56'!backgroundSketch: aSketchMorphOrNil	"Set the receiver's background graphic as indicated.  If nil is supplied, remove any existing background graphic.  In any case, delete any preexisting background graphic."	backgroundMorph ifNotNil: [backgroundMorph delete].  "replacing old background"	aSketchMorphOrNil ifNil: [backgroundMorph := nil.  ^ self].	backgroundMorph := StickySketchMorph new form: aSketchMorphOrNil form.	backgroundMorph position: aSketchMorphOrNil position.	self addMorphBack: backgroundMorph.	aSketchMorphOrNil delete.	backgroundMorph lock.	backgroundMorph setProperty: #shared toValue: true.	^ backgroundMorph! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 9/1/2003 14:47'!extent: x	| newExtent tw menu |	newExtent := x max: self minWidth@self minHeight.	(tw := self findA: TwoWayScrollPane) ifNil:		["This was the old behavior"		^ super extent: newExtent].	(self hasProperty: #autoFitContents) ifTrue: [		menu := MenuMorph new defaultTarget: self.		menu addUpdating: #autoFitString target: self action: #autoFitOnOff.		menu addTitle: 'To resize the script, uncheck the box below' translated.		menu popUpEvent: nil in: self world	.		^ self].	"Allow the user to resize to any size"	tw extent: ((newExtent x max: self firstSubmorph width)				@ (newExtent y - self firstSubmorph height)) - (borderWidth*2) + (-4@-4).  "inset?"	^ super extent: newExtent! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 8/11/1998 16:47'!lowerAllPens	submorphs do: [:m | m assuredPlayer lowerPen]! !!Morph methodsFor: '*Etoys-support' stamp: 'RAA 3/8/2001 07:18'!hasButtonProperties	^self hasProperty: #universalButtonProperties! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 2/18/2003 02:54'!getCharacters	"obtain a string value from the receiver.  The default generic response is simply the name of the object."	^ self externalName! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:46'!choosePenColor: evt	self assuredPlayer choosePenColor: evt! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 9/26/2001 11:58'!initialTypeForSlotNamed: aName	"Answer the initial type to be ascribed to the given instance variable"	^ #Object! !!DSCPostscriptCanvas methodsFor: '*Etoys-drawing' stamp: 'nk 6/10/2004 13:19'!fullDrawBookMorph: aBookMorph	" draw all the pages in a book morph, but only if it is the top-level morph "	morphLevel = 1 ifFalse: [^ super fullDrawBookMorph: aBookMorph].	"Unfortunately, the printable 'pages' of a StackMorph are the cards, but for a BookMorph, they are the pages.  Separate the cases here."	(aBookMorph isKindOf: StackMorph) 		ifTrue: [			aBookMorph cards do: [:aCard |				aBookMorph goToCard: aCard.	"cause card-specific morphs to be installed"				pages := pages + 1.				target print: '%%Page: '; write: pages; space; write: pages; cr.				self drawPage: aBookMorph currentPage]]		ifFalse: [			aBookMorph pages do: [:aPage |				pages := pages + 1.				target print: '%%Page: '; write: pages; space; write: pages; cr.				self drawPage: aPage]].	morphLevel = 0 ifTrue: [ self writeTrailer: pages ].! !!TheWorldMenu methodsFor: '*EToys' stamp: 'nk 10/14/2004 07:08'!scriptingMenu	"Build the authoring-tools menu for the world."	^ self fillIn: (self menu: 'authoring tools...') from: { 		{ 'objects (o)' . { #myWorld . #activateObjectsTool }. 'A searchable source of new objects.'}.		nil.  "----------" 		{ 'view trash contents' . { #myWorld . #openScrapsBook:}. 'The place where all your trashed morphs go.'}. 		{ 'empty trash can' . { Utilities . #emptyScrapsBook}. 'Empty out all the morphs that have accumulated in the trash can.'}.		nil.  "----------"			{ 'new scripting area' . { #myWorld . #detachableScriptingSpace}. 'A window set up for simple scripting.'}.		nil.  "----------"					{ 'status of scripts' . {#myWorld . #showStatusOfAllScripts}. 'Lets you view the status of all the scripts belonging to all the scripted objects of the project.'}.		{ 'summary of scripts' . {#myWorld . #printScriptSummary}. 'Produces a summary of scripted objects in the project, and all of their scripts.'}.		{ 'browser for scripts' . {#myWorld . #browseAllScriptsTextually}. 'Allows you to view all the scripts in the project in a traditional programmers'' "browser" format'}.		nil.		{ 'gallery of players' . {#myWorld . #galleryOfPlayers}. 'A tool that lets you find out about all the players used in this project'}."		{ 'gallery of scripts' . {#myWorld . #galleryOfScripts}. 'Allows you to view all the scripts in the project'}."		{ 'etoy vocabulary summary' . {#myWorld . #printVocabularySummary }. 'Displays a summary of all the pre-defined commands and properties in the pre-defined EToy vocabulary.'}.		{ 'attempt misc repairs' . {#myWorld . #attemptCleanup}. 'Take measures that may help fix up some things about a faulty or problematical project.'}.		{ 'remove all viewers' . {#myWorld . #removeAllViewers}. 'Remove all the Viewers from this project.'}.		{ 'refer to masters' . {#myWorld . #makeAllScriptEditorsReferToMasters }. 'Ensure that all script editors are referring to the first (alphabetically by external name) Player of their type' }.		nil.  "----------" 		{ 'unlock locked objects' . { #myWorld . #unlockContents}. 'If any items on the world desktop are currently locked, unlock them.'}.		{ 'unhide hidden objects' . { #myWorld . #showHiders}. 'If any items on the world desktop are currently hidden, make them visible.'}.        }! !!Object methodsFor: '*Etoys-viewer' stamp: 'nice 12/26/2009 18:55'!uniqueNameForReferenceFrom: proposedName	"Answer a satisfactory symbol, similar to the proposedName but obeying the rules, to represent the receiver"	| aName stem |	proposedName = self uniqueNameForReferenceOrNil 		ifTrue: [^ proposedName].  "No change"	stem := proposedName select: [:ch | ch isLetter or: [ch isDigit]].	stem size == 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	aName := Utilities keyLike: stem satisfying:		[:jinaLake |			| nameSym okay |			nameSym := jinaLake asSymbol.			okay := true.			(self class bindingOf: nameSym) ifNotNil: [okay := false "don't use it"].			okay].	^ aName asSymbol! !!Morph methodsFor: '*Etoys-scripting' stamp: 'tk 10/1/97 18:23'!isTileLike	"Cannot be dropped into a script"	^ false! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 3/15/2004 23:01'!uniqueNameForReferenceOrNil	"If the receiver has a unique name for reference, return it here, else return nil"	^ References keyAtValue: self ifAbsent: [nil]! !!TileMorph class methodsFor: 'class initialization' stamp: 'ar 1/3/2010 22:21'!initialize	"TileMorph readInArrowGraphics    -- call manually if necessary to bring graphics forward"	"TileMorph initialize"	UpdatingOperators := Dictionary new.	UpdatingOperators at: #incr: put: #+.	UpdatingOperators at: #decr: put: #-.	UpdatingOperators at: #set: put: ''.	self downPicture; upPicture; suffixPicture; retractPicture.	SuffixArrowAllowance := 5 + self suffixPicture width + self retractPicture width.	UpArrowAllowance := 10.! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/27/2000 17:38'!currentDataValue	"Answer the data value associated with the receiver.  Useful in conjunction with default-value setting"	^ nil! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:35'!insertCard	"Insert a new card in the stack, with the receiver as its background, and have it become the current card of the stack"	self stackDo: [:aStack | aStack insertCardOfBackground: self]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 2/13/98 16:35'!setMorph: anActorMorph scriptName: aString	"Create a script editor for editing a named script."	self setMorph: anActorMorph.	scriptName := aString.	self addMorphFront: self buttonRowForEditor.	self updateStatus.	firstTileRow := 2! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 4/30/1998 14:34'!scriptInstantiation	^ playerScripted scriptInstantiationForSelector: scriptName! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:23'!stopUp: dummy with: theButton	self flushPlayerListCache.  "catch guys not in cache but who're running"	self stopRunningScripts! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 12/13/2003 19:30'!behaveLikeAHolderString	"Answer a string to be displayed in a menu to characterize 	whether the receiver is currently behaving like a holder"	^ (self behavingLikeAHolder		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'behave like a holder' translated! !!ScriptEditorMorph methodsFor: 'tiles from method' stamp: 'sw 2/20/2001 02:03'!fromExistingMethod: aSelector forPlayer: aPlayer 	"Create tiles for this method.  "	self initialize.	playerScripted := aPlayer.	self setMorph: aPlayer costume scriptName: aSelector.	self insertUniversalTiles! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 5/4/2001 07:08'!hasUserDefinedSlots	"Answer whether the receiver has any user-defined slots, in the omniuser sense of the term.  This is needed to allow Viewers to look at any object, not just at Players."	^ false! !!Morph methodsFor: '*Etoys' stamp: 'sw 9/15/1998 13:33'!newPlayerInstance	^ UnscriptedPlayer newUserInstance! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/23/2001 10:53'!chooseTrigger	"NB; the keyStroke branch commented out temporarily until keystrokes can actually be passed along to the user's scripting code"		self presentScriptStatusPopUp! !!EtoysPresenter methodsFor: 'misc' stamp: 'sw 6/30/1999 20:31'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	aPasteUpMorph automaticViewing ifTrue:		[aMorph isCandidateForAutomaticViewing ifTrue:			[self viewMorph: aMorph]]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 3/24/2005 01:55'!editMethodDescription	"Edit the balloon help associated with the script"	self userScriptObject editDescription.	playerScripted updateAllViewers! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'RAA 5/18/2001 10:47'!addImageToPenTrailsFor: aMorph	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| image |	self createOrResizeTrailsForm.	"origin := self topLeft."	image := aMorph imageForm offset: 0@0.	image		displayOn: turtleTrailsForm 		at: aMorph topLeft - self topLeft		rule: Form paint.	self invalidRect: (image boundingBox translateBy: aMorph topLeft).! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:06'!stepStillDown: dummy with: theButton	"The step button is still down; get temporary button feedback right and step all and then get all button feedback right again"	self stepButtonState: #pressed.	self stopButtonState: #off.	associatedMorph stepAll.	associatedMorph world displayWorld.	self stepButtonState: #off.	self stopButtonState: #on! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 7/22/2002 17:49'!assureParameterTilesValid	"Make certain that parameter tiles in my interior are still type valid; replace any that now intimate type errors"	self isTextuallyCoded ifFalse:		[(self allMorphs select: [:m | m isKindOf: ParameterTile]) do:			[:aTile | aTile assureTypeStillValid].		self install]! !!ScriptEditorMorph methodsFor: 'menu' stamp: ''!fixLayout	self fixLayoutOfSubmorphsNotIn: IdentitySet new! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:32'!currentDataInstance	"Answer the current data instance"	^ self player! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 12/15/2004 15:19'!printOn: aStream	^ aStream nextPutAll: 'ScriptEditor for #', scriptName asString, ' player: ', playerScripted externalName! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 9/28/2001 07:07'!wantsDroppedMorph: aMorph event: evt	"Answer whether the receiver would be interested in accepting the morph"	^ (aMorph isTileLike and: [self isTextuallyCoded not]) and:		[(#(Command Unknown) includes: aMorph resultType capitalized)]! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:50'!primSubArray: rcvr and: other into: result	<primitive: 'primitiveSubArrays' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveSubArrays."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) - (other at: i)	].	^ result.! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 8/31/2004 14:06'!tanOButton	"Answer a button with the old O on a tan background, targeted to self"	| aButton |	aButton := IconicButton new labelGraphic: (ScriptingSystem formAtKey: #TanO).	aButton color: Color transparent; borderWidth: 0; shedSelvedge; actWhen: #buttonUp.	aButton target: self.	^ aButton! !!ScriptEditorMorph methodsFor: 'frequency' stamp: 'sw 4/21/1999 09:12'!setFrequencyTo: aNumber	self scriptInstantiation frequency: aNumber! !!Object methodsFor: '*Etoys-viewer' stamp: 'ar 8/6/2009 20:43'!chooseNewNameForReference	"Offer an opportunity for the receiver, presumed already to be known in the References registry, to be renamed"	|  nameSym current newName |	current := References keyAtValue: self ifAbsent: [^ self error: 'not found in References'].	newName := UIManager default request: 'Please enter new name' initialAnswer: current.	"Want to user some better way of determining the validity of the chosen identifier, and also want to give more precise diagnostic if the string the user types in is not acceptable.  Work to be done here."	newName isEmpty ifTrue: [^ nil].	((Scanner isLiteralSymbol: newName) and: [(newName includes: $:) not])		ifTrue:			[nameSym := newName capitalized asSymbol.			(((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(ScriptingSystem allKnownClassVariableNames includes: nameSym) not])					ifTrue:						[(References associationAt: current) key: nameSym.						References rehash.						^ nameSym]].	self inform: 'Sorry, that name is not available.'.	^ nil! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 18:54'!containsCard: aCard	"Answer whether the given card belongs to the uniclass representing the receiver"	^ self isStackBackground and: [aCard isKindOf: self player class baseUniclass]! !!EtoysPresenter methodsFor: 'playerList' stamp: 'yo 2/10/2005 17:07'!reportPlayersAndScripts	"Open a window which contains a report on players and their scripts"	| aList aString |	(aList := self uniclassesAndCounts) ifEmpty:  [^ self inform: 'there are no scripted players' translated].	aString := String streamContents:		[:aStream |			aList do:				[:aPair |					aStream nextPutAll: aPair first name, ' -- ', aPair second printString.					aStream nextPutAll: ' ', (aPair second > 1 ifTrue: ['instances'] ifFalse: ['instance']) translated, ', '.					aStream nextPutAll: 'named' translated.					aPair first allInstancesDo: [:inst | aStream space; nextPutAll: inst externalName].					aStream cr].			aStream cr.			aList do:				[:aPair |					aStream cr.					aStream nextPutAll: '--------------------------------------------------------------------------------------------'.					aStream cr; nextPutAll: aPair first typicalInstanceName.					aStream nextPutAll: '''s' translated.					aStream nextPutAll: ' scripts:' translated.					aPair first addDocumentationForScriptsTo: aStream]].	(StringHolder new contents: aString)		openLabel: 'All scripts in this project' translated"self currentWorld presenter reportPlayersAndScripts"! !!Morph class methodsFor: '*eToys-scripting' stamp: 'bf 9/11/2004 17:18'!hasAdditionsToViewerCategories	^ self class selectors		anySatisfy: [:each | each == #additionsToViewerCategories				or: [(each beginsWith: 'additionsToViewerCategory')						and: [(each at: 26 ifAbsent: []) ~= $:]]]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tk 3/9/2001 10:42'!scriptTitle	^ Preferences universalTiles 		ifTrue: [SyntaxMorph new substituteKeywordFor: scriptName] 				"spaces instead of capitals, no colons"				"Don't use property #syntacticallyCorrectContents.  				  scriptName here holds the truth"		ifFalse: [scriptName].! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 7/20/2002 12:52'!scriptSelectorToTriggerFor: aButtonMorph	"Answer a new selector which will bear the code for aButtonMorph in the receiver"	| buttonName selectorName |	buttonName := aButtonMorph externalName.	selectorName := self assuredPlayer acceptableScriptNameFrom: buttonName  forScriptCurrentlyNamed: nil.	buttonName ~= selectorName ifTrue:		[aButtonMorph setNameTo: selectorName].	^ selectorName! !!BorderedMorph methodsFor: '*Etoys' stamp: 'nk 9/4/2004 11:47'!understandsBorderVocabulary	"Replace the 'isKindOf: BorderedMorph' so that (for instance) Connectors can have their border vocabulary visible in viewers."	^true! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 10/25/2000 06:06'!toggleBatchPenTrails		self batchPenTrails: self batchPenTrails not! !!Object methodsFor: '*Etoys-viewer' stamp: 'nice 12/26/2009 18:52'!methodInterfacesInPresentationOrderFrom: interfaceList forCategory: aCategory 	"Answer the interface list sorted in desired presentation order, using a 	static master-ordering list, q.v. The category parameter allows an 	escape in case one wants to apply different order strategies in different 	categories, but for now a single master-priority-ordering is used -- see 	the comment in method EToyVocabulary.masterOrderingOfPhraseSymbols"	| masterOrder ordered unordered |	masterOrder := Vocabulary eToyVocabulary masterOrderingOfPhraseSymbols.	ordered := SortedCollection sortBlock: [:a :b | a key < b key].	unordered := SortedCollection sortBlock: [:a :b | a wording < b wording].	interfaceList do: [:interface | 		| index |		index := masterOrder indexOf: interface elementSymbol.		index isZero			ifTrue: [unordered add: interface]			ifFalse: [ordered add: index -> interface]].	^ Array		streamContents: [:stream | 			ordered do: [:assoc | stream nextPut: assoc value].			stream nextPutAll: unordered]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 17:50'!viewingByNameString	"Answer a string to show in a menu representing whether the 	receiver is currently viewing its subparts by name or not"	^ ((self showingListView			and: [(self					valueOfProperty: #sortOrder					ifAbsent: [])					== #downshiftedNameOfObjectRepresented])		ifTrue: ['<yes>']		ifFalse: ['<no>']), 'view by name' translated! !!ScriptEditorMorph methodsFor: 'menu' stamp: ''!fixLayoutOfSubmorphsNotIn: aCollection 	self		allMorphsDo: [:m | (aCollection includes: m)				ifFalse: [m ~~ self						ifTrue: [(m respondsTo: #fixLayoutOfSubmorphsNotIn:)								ifTrue: [m fixLayoutOfSubmorphsNotIn: aCollection]].					m layoutChanged.					aCollection add: m]]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/29/98 18:30'!playerScripted	^ playerScripted! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'RAA 9/24/2000 17:50'!replaceRow1	submorphs first delete.  "the button row"	self addMorphFront: self buttonRowForEditor.  "up to date"! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'ul 12/12/2009 14:07'!buttonRowForEditor	"Answer a row of buttons that comprise the header at the top of the Scriptor"	| aRow aString buttonFont aStatusMorph aButton aColumn aTile |	buttonFont := Preferences standardButtonFont.	aRow := AlignmentMorph newRow color: Color transparent; layoutInset: 0.	aRow hResizing: #shrinkWrap.	aRow vResizing: #shrinkWrap.	self hasParameter ifFalse:		[aRow addMorphFront:			(SimpleButtonMorph new				label: '!!' font: Preferences standardEToysFont;				target: self;				color: Color yellow;				borderWidth: 0;				actWhen: #whilePressed;				actionSelector: #tryMe;				balloonTextSelector: #tryMe).		aRow addTransparentSpacerOfSize: 6@10].	self addDismissButtonTo: aRow.	aRow addTransparentSpacerOfSize: 6@1.	aColumn := AlignmentMorph newColumn beTransparent.	aColumn addTransparentSpacerOfSize: 0@4.	aButton := UpdatingThreePhaseButtonMorph checkBox.	aButton		target: self;		actionSelector: #toggleWhetherShowingTiles;		getSelector: #showingMethodPane.	aButton setBalloonText: 'toggle between showing tiles and showing textual code' translated.	aColumn addMorphBack: aButton.	aRow addMorphBack: aColumn.	aRow addTransparentSpacerOfSize: 6@10.	aString := playerScripted externalName.	aRow addMorphBack:		(aButton := SimpleButtonMorph new useSquareCorners label: aString font: buttonFont; target: self; setNameTo: 'title').	aButton actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButton		on: #mouseEnter send: #menuButtonMouseEnter: to: aButton;		on: #mouseLeave send: #menuButtonMouseLeave: to: aButton.	aButton borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButton color: ScriptingSystem uniformTileInteriorColor.	aButton balloonTextSelector: #offerScriptorMenu.	aRow addTransparentSpacerOfSize: 4@1.	aButton := (Preferences universalTiles ifTrue: [SyntaxUpdatingStringMorph] 					ifFalse: [UpdatingStringMorph]) new.	aButton useStringFormat;		target:  self;		getSelector: #scriptTitle;		setNameTo: 'script name';		font: ScriptingSystem fontForNameEditingInScriptor;		putSelector: #setScriptNameTo:;		setProperty: #okToTextEdit toValue: true;		step;		yourself.	aRow addMorphBack: aButton.	aButton setBalloonText: 'Click here to edit the name of the script.' translated.	aRow addTransparentSpacerOfSize: 6@0.	self hasParameter		ifTrue:			[aTile := TypeListTile new choices: Vocabulary typeChoices dataType: nil.			aTile addArrows.			aTile setLiteral: #Number.	"(aButton := SimpleButtonMorph new useSquareCorners label: 'parameter' translated font: buttonFont; target: self; setNameTo: 'parameter').			aButton actWhen: #buttonDown; actionSelector: #handUserParameterTile."			aRow addMorphBack: aTile.			aTile borderColor: Color red.			aTile color: ScriptingSystem uniformTileInteriorColor.			aTile setBalloonText: 'Drag from here to get a parameter tile' translated]		ifFalse:			[aRow addMorphBack: (aStatusMorph := self scriptInstantiation statusControlMorph)].	aRow addTransparentSpacerOfSize: 6@1.	aRow addMorphBack:		(IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: 'AddTest'); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addYesNoToHand;			shedSelvedge;			balloonTextSelector: #addYesNoToHand).	aRow addTransparentSpacerOfSize: 12@10.	self addDestroyButtonTo: aRow.	(playerScripted existingScriptInstantiationForSelector: scriptName)		ifNotNil:			[:inst | inst updateStatusMorph: aStatusMorph].	^ aRow! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'nice 12/27/2009 03:10'!reassessBackgroundShape	"A change has been made which may affect the instance structure of the Card uniclass that holds the instance state, which can also be thought of as the 'card data'."	"Caution: still to be done: the mechanism so that when a new instance variable is added, it gets initialized in all subinstances of the receiver's player, which are the cards of this shape.  One needs to take into account here the instance variable names coming in; those that are unchanged should keep their values, but those that have newly arrived should obtain their default values from the morphs on whose behalf they are being maintained in the model"	| requestedName |	self isStackBackground ifFalse: [^Beeper beep].	"bulletproof against deconstruction"	Cursor wait showWhile: 			[ | variableDocks takenNames sepDataMorphs sorted existing |variableDocks := OrderedCollection new.	"This will be stored in the uniclass's 			class-side inst var #variableDocks"			takenNames := OrderedCollection new.			sepDataMorphs := OrderedCollection new.	"fields, holders of per-card data"			self submorphs do: 					[:aMorph | 					aMorph renderedMorph holdsSeparateDataForEachInstance 						ifTrue: [sepDataMorphs add: aMorph renderedMorph]						ifFalse: 							["look for buried fields, inside a frame"							aMorph renderedMorph isShared 								ifTrue: 									[aMorph allMorphs do: 											[:mm | 											mm renderedMorph holdsSeparateDataForEachInstance 												ifTrue: [sepDataMorphs add: mm renderedMorph]]]]].			sorted := SortedCollection new 						sortBlock: [:a :b | (a valueOfProperty: #cardInstance) notNil].	"puts existing ones first"			sorted addAll: sepDataMorphs.			sorted do: 					[:aMorph | | docks | 					docks := aMorph variableDocks.					"Each morph can request multiple variables.  	This complicates matters somewhat but creates a generality for Fabrk-like uses.	Each spec is an instance of VariableDock, and it provides a point of departure	for the negotiation between the PasteUp and its constitutent morphs"					docks do: 							[:aVariableDock | | uniqueName | 							uniqueName := self player 										uniqueInstanceVariableNameLike: (requestedName := aVariableDock 														variableName)										excluding: takenNames.							uniqueName ~= requestedName 								ifTrue: 									[aVariableDock variableName: uniqueName.									aMorph noteNegotiatedName: uniqueName for: requestedName].							takenNames add: uniqueName].					variableDocks addAll: docks].			existing := self player class instVarNames.			variableDocks := (variableDocks asSortedCollection: 							[:dock1 :dock2 | | name2 name1 | 							name1 := dock1 variableName.							name2 := dock2 variableName.							(existing indexOf: name1 ifAbsent: [0]) 								< (existing indexOf: name2 ifAbsent: [variableDocks size])]) 						asOrderedCollection.			self player class setNewInstVarNames: (variableDocks 						collect: [:info | info variableName asString]).			"NB: sets up accessors, and removes obsolete ones"			self player class newVariableDocks: variableDocks]! !!ScriptEditorMorph methodsFor: 'objects from disk' stamp: 'tk
11/29/2004 17:27'!fixUponLoad: aProject seg: anImageSegment	"We are in an old project that is being loaded from disk.Fix up conventions that have changed."	(aProject projectParameters at: #substitutedFont ifAbsent: [#none])		 ~~ #none ifTrue: [ self setProperty:#needsLayoutFixed toValue: true ].	^ super fixUponLoad: aProject seg: anImageSegment! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/18/2002 10:26'!ceaseHavingAParameter	"Cease having a parameter"	playerScripted ceaseHavingAParameterFor: scriptName! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 8/3/1998 15:08'!isTextuallyCoded	(self topEditor isKindOf: ScriptEditorMorph) ifFalse: [^ false].  "workaround for the case where the receiver is embedded in a free-standing CompoundTileMorph.  Yecch!!"	^ self userScriptObject isTextuallyCoded! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:53'!getPenSize	self player ifNil: [^ 1].	^ self actorState getPenSize! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'dgd 9/6/2003 18:01'!fenceEnabledString	"Answer the string to be shown in a menu to represent the  	fence enabled status"	^ (self fenceEnabled		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'fence enabled' translated! !!EtoysPresenter methodsFor: 'playerList' stamp: 'yo 7/2/2004 19:45'!allKnownScriptSelectors	"Answer a list of all the selectors implemented by any user-scripted objected within the scope of the receiver"	| aSet allUniclasses |	aSet := Set with: ('script' translated , '1') asSymbol.	allUniclasses := (self presenter allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownScriptSelectors"! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 11/3/2001 12:23'!affiliatedSelector	"Answer a selector affiliated with the receiver for the purposes of launching a messenger.   Reimplement this to plug into the messenger service"	^ nil! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'bf 10/2/2002 18:36'!backgroundForm	^ self backgroundSketch		ifNil: [Form extent: self extent depth: Display depth]		ifNotNil: [backgroundMorph form]! !!SoundTile methodsFor: 'accessing' stamp: 'ar 1/3/2010 17:52'!isSoundTile	^true! !!Morph methodsFor: '*Etoys-support' stamp: 'RAA 3/8/2001 14:45'!buttonProperties: propertiesOrNil	propertiesOrNil ifNil: [		self removeProperty: #universalButtonProperties	] ifNotNil: [		self setProperty: #universalButtonProperties toValue: propertiesOrNil	].! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'RAA 10/4/2000 08:24'!fenceEnabled: aBoolean	self setProperty: #fenceEnabled toValue: aBoolean! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 10/27/2000 17:37'!creationStamp	"Answer the creation stamp stored within the receiver, if any"	^ self valueOfProperty: #creationStamp ifAbsent: [super creationStamp]! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 11/14/2001 00:31'!reinvigorateAllScriptsTool: anAllScriptsTool 	"Rebuild the contents of an All Scripts tool"	| showingOnlyActiveScripts candidateList firstTwo oldList allExtantPlayers newList morphList |	showingOnlyActiveScripts := anAllScriptsTool showingOnlyActiveScripts.	self flushPlayerListCache.	"needed? Probably to pick up on programmatical script-status control only"	firstTwo := {anAllScriptsTool submorphs first.  anAllScriptsTool submorphs second}.	oldList := (anAllScriptsTool submorphs copyFrom: 3 to: anAllScriptsTool submorphs size) collect:		[:aRow |			(aRow findA: UpdatingSimpleButtonMorph) target].	allExtantPlayers := self allExtantPlayers.	anAllScriptsTool showingAllInstances "take all instances of all classes"		ifTrue:			[candidateList := allExtantPlayers]  		ifFalse:  "include only one exemplar per uniclass.  Try to get one that has some qualifying scripts"			[candidateList := Set new.			allExtantPlayers do:				[:aPlayer |					(candidateList detect: [:plyr | plyr isMemberOf:  aPlayer class] ifNone: [nil]) ifNil:						[aPlayer instantiatedUserScriptsDo: [:aScriptInstantiation |							(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) 								ifTrue:									[candidateList add: aPlayer]]]]].	newList := OrderedCollection new.	candidateList do:		[:aPlayer | aPlayer instantiatedUserScriptsDo:			[:aScriptInstantiation |				(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) ifTrue:					[newList add: aScriptInstantiation]]].	oldList asSet = newList asSet		ifFalse:			[anAllScriptsTool removeAllMorphs; addAllMorphs: firstTwo.			morphList := newList collect:				[:aScriptInstantiation |  aScriptInstantiation statusControlRowIn: anAllScriptsTool].			anAllScriptsTool addAllMorphs: morphList.			newList do:				[:aScriptInstantiation | aScriptInstantiation updateAllStatusMorphs]]! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 2/16/98 02:03'!morph	^ self playerScripted costume! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 8/11/1998 16:53'!jettisonScripts	self player ifNotNil: [self player class jettisonScripts]! !!Morph methodsFor: '*Etoys-support' stamp: 'RAA 10/4/2000 08:29'!fenceEnabled	"in case a non-pasteUp is used as a container"	^Preferences fenceEnabled! !!Morph methodsFor: '*Etoys' stamp: 'sw 10/27/2000 06:39'!putOnBackground	"Place the receiver, formerly private to its card, onto the shared background.  If the receiver needs data carried on its behalf by the card, such data will be represented on every card."	(self hasProperty: #shared) ifTrue: [^ self].  "Already done"	self setProperty: #shared toValue: true.	self stack ifNotNil: [self stack reassessBackgroundShape]! !!PasteUpMorph methodsFor: '*eToys-world menu' stamp: 'RAA 1/8/2001 15:17'!hideAllPlayers	| a |	a := OrderedCollection new.	self allMorphsDo: [ :x | 		(x isKindOf: ViewerFlapTab) ifTrue: [a add: x]	].	a do: [ :each | each delete].! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 10/31/2000 09:29'!viewByName	"Make the receiver show its subparts as a vertical list of lines of information, sorted by object name"	self imposeListViewSortingBy: #downshiftedNameOfObjectRepresented retrieving: #(nameOfObjectRepresented reportableSize  className oopString)! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 10/24/2000 11:36'!newScriptorAround: aPhraseTileMorph	"Sprout a scriptor around aPhraseTileMorph, thus making a new script.  This is where generalized scriptors will be threaded in"	^ nil! !!ScriptEditorMorph methodsFor: 'submorphs-add/remove' stamp: 'sw 11/15/2001 12:30'!dismissViaHalo	"The user has clicked in the delete halo-handle.  This provides a hook in case some concomitant action should be taken, or if the particular morph is not one which should be put in the trash can, for example."	self resistsRemoval ifTrue: [^ self].	self destroyScript! !!ScriptEditorMorph methodsFor: 'scripting' stamp: 'sw 4/21/1998 21:34'!isTileScriptingElement	^ true! !!ScriptEditorMorph methodsFor: 'save & revert' stamp: 'sw 5/19/1998 14:12'!saveScriptVersion	self userScriptObject saveScriptVersion: self setTimeStamp! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 10/30/1998 15:36'!goUp: evt with: aMorph	self startRunningScripts! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/23/2000 14:52'!goToPreviousCardInStack	"Tell my stack to advance to the previous card"		self stackDo: [:aStack | aStack goToPreviousCardInStack]! !!EtoysPresenter methodsFor: 'misc' stamp: 'sw 4/23/1998 18:47'!tempCommand	Transcript cr; show: '#tempCommand invoked for Presenter'! !!ScriptEditorMorph methodsFor: 'other' stamp: 'em 3/29/2005 14:30'!toggleWhetherShowingTiles	"Toggle between showing the method pane and showing the tiles pane"	self showingMethodPane		ifFalse:				"currently showing tiles"			[self showSourceInScriptor]		ifTrue:				"current showing textual source"			[Preferences universalTiles				ifTrue: [^ self revertToTileVersion].			self savedTileVersionsCount >= 1				ifTrue:					[(self userScriptObject lastSourceString = (playerScripted class compiledMethodAt: scriptName) decompileString)						ifFalse:							[(self confirm: 'Caution -- this script was changedtextually; if you revert to tiles at thispoint you will lose all the changes youmay have made textually.  Do youreally want to do this?' translated) ifFalse: [^ self]].					self revertToTileVersion]				ifFalse:					[Beeper beep]]! !!Vocabulary class methodsFor: '*Etoys-queries' stamp: 'stephaneducasse 2/4/2006 20:39'!instanceWhoRespondsTo: aSelector 	"Find the most likely class that responds to aSelector. Return an instance 	of it. Look in vocabularies to match the selector."	"Most eToy selectors are for Players"	| mthRefs |	((self vocabularyNamed: #eToy)			includesSelector: aSelector)		ifTrue: [aSelector == #+				ifFalse: [^ Player new costume: Morph new]].	"Numbers are a problem"	((self vocabularyNamed: #Number)			includesSelector: aSelector)		ifTrue: [^ 1].	"Is a Float any different?"	"String Point Time Date"	#()		do: [:nn | ((self vocabularyNamed: nn)					includesSelector: aSelector)				ifTrue: ["Ask Scott how to get a prototypical instance"					^ (Smalltalk at: nn) new]].	mthRefs := self systemNavigation allImplementorsOf: aSelector.	"every one who implements the selector"	mthRefs		sortBlock: [:a :b | (Smalltalk at: a classSymbol) allSuperclasses size < (Smalltalk at: b classSymbol) allSuperclasses size].	mthRefs size > 0		ifTrue: [^ (Smalltalk at: mthRefs first classSymbol) new].	^ Error new! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/20/2002 14:31'!setScriptNameTo: aNewName	"The user has typed into the script-name pane.  Accept the changed contents as the new script name, and take action accordingly"	playerScripted renameScript: self scriptName newSelector:		(playerScripted acceptableScriptNameFrom: aNewName forScriptCurrentlyNamed:  self scriptName)! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'sw 6/16/1999 11:09'!makeDetachable	presenter		ifNil:			[self impartPrivatePresenter.			self borderWidth: 1;  borderColor: Color green darker]		ifNotNil:			[self inform: 'This view is ALREADY detachable']! !!Morph methodsFor: '*Etoys-support' stamp: 'nk 1/6/2004 12:37'!asWearableCostume	"Return a wearable costume for some player"	^(World drawingClass withForm: self imageForm) copyCostumeStateFrom: self! !!ScriptEditorMorph methodsFor: 'e-toy support' stamp: 'sw 12/4/1998 15:46'!objectViewed	^ self playerScripted costume! !!Morph methodsFor: '*Etoys-support' stamp: 'mir 6/13/2001 14:34'!asWearableCostumeOfExtent: extent	"Return a wearable costume for some player"	^self asWearableCostume! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 1/3/2001 06:42'!addViewingItemsTo: aMenu	"Add viewing-related items to the given menu.  If any are added, this method is also responsible for adding a line after them"	#(	(viewingByIconString 			viewByIcon)		(viewingByNameString 			viewByName)		"(viewingBySizeString 			viewBySize)"		(viewingNonOverlappingString 	viewNonOverlapping)) do:			[:pair |  aMenu addUpdating: pair first target:  self action: pair second].	aMenu addLine! !!ScriptEditorMorph methodsFor: 'caching' stamp: 'sw 11/2/2004 16:40'!releaseCachedState	"Release any state that could be recomputed"	super releaseCachedState.	handWithTile := nil.	self hibernate! !!Morph methodsFor: '*Etoys-support' stamp: 'ar 9/23/2000 22:38'!copyCostumeStateFrom: aMorph	"Copy all state that should be persistant for costumes from aMorph"	self rotationCenter: aMorph rotationCenter.	self rotationStyle: aMorph rotationStyle.	self referencePosition: aMorph referencePosition.	self forwardDirection: aMorph forwardDirection.! !!EtoysPresenter methodsFor: 'viewer' stamp: 'sw 6/20/2001 12:37'!viewObject: anObject	"Open up and return a viewer on the given object.  If the object is a Morph, open a viewer on its associated Player"	anObject isMorph		ifTrue:			[self viewMorph: anObject]  "historic morph/player implementation"		ifFalse:			[self viewObjectDirectly: anObject]! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:51'!primMulArray: rcvr and: other into: result	<primitive: 'primitiveMulArrays' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveMulArrays."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) * (other at: i)	].	^ result.! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 10/18/2000 10:32'!viewAfreshIn: aPasteUp showingScript: aScriptName at: aPosition	"Obtain a smartly updated ScriptEditor for the given script name and zap it into place at aPosition"	| anEditor |	self player updateAllViewersAndForceToShow: #scripts.	anEditor := self player scriptEditorFor: aScriptName.	aPasteUp ifNotNil: [aPasteUp addMorph: anEditor].	anEditor position: aPosition.	anEditor currentWorld startSteppingSubmorphsOf: anEditor! !!ScriptEditorMorph methodsFor: 'caching' stamp: 'sw 11/2/2004 17:00'!resetHandWithTile	"Set the handWithTile back to nil, in case it somehow got to be nonnil"	handWithTile := nil! !!Morph class methodsFor: '*eToys-scripting' stamp: 'yo 3/15/2005 14:10'!helpContributions	"Answer a list of pairs of the form (<symbol> <help message> ) to contribute to the system help dictionary"	"NB: Many of the items here are not needed any more since they're specified as part of command definitions now.  Someone needs to take the time to go through the list and remove items no longer needed.  But who's got that kind of time?"	^ #(		(acceptScript:for:			'submit the contents of the given script editor as the code defining the given selector')		(actorState			'return the ActorState object for the receiver, creating it if necessary')		(addInstanceVariable			'start the interaction for adding a new variable to the object')		(addPlayerMenuItemsTo:hand:			'add player-specific menu items to the given menu, on behalf of the given hand.  At present, these are only commands relating to the turtle')		(addYesNoToHand			'Press here to tear off a  TEST/YES/NO unit which you can drop into your script')		(allScriptEditors			'answer a list off the extant ScriptEditors for the receiver')		(amount			'The amount of displacement')		(angle				'The angular displacement')		(anonymousScriptEditorFor:			'answer a new ScriptEditor object to serve as the place for scripting an anonymous (unnamed, unsaved) script for the receiver')		(append:			'add an object to this container')		(prepend:			'add an object to this container')		(assignDecrGetter:setter:amt:			'evaluate the decrement variant of assignment')		(assignGetter:setter:amt:			'evaluate the vanilla variant of assignment')		(assignIncrGetter:setter:amt:			'evalute the increment version of assignment')		(assignMultGetter:setter:amt:			'evaluate the multiplicative version of assignment')		(assureEventHandlerRepresentsStatus			'make certain that the event handler associated with my current costume is set up to conform to my current script-status')		(assureExternalName			'If I do not currently have an external name assigned, get one now')		(assureUniClass			'make certain that I am a member a uniclass (i.e. a unique subclass); if I am not, create one now and become me into an instance of it')		(availableCostumeNames			'answer a list of strings representing the names of all costumes currently available for me')		(availableCostumesForArrows			'answer a list of actual, instantiated costumes for me, which can be cycled through as the user hits a next-costume or previous-costume button in a viewer')		(beep:			'make the specified sound')		(borderColor			'The color of the object''s border')		(borderWidth			'The width of the object''s border')		(bottom			'My bottom edge, measured downward from the top edge of the world')		(bounce:			'If object strayed beyond the boundaries of its container, make it reflect back into it, making the specified noise while doing so.')		(bounce			'If object strayed beyond the boundaries of its container, make it reflect back into it')		(chooseTrigger'When this script should run."normal" means "only when called"')		(clearTurtleTrails			'Clear all the pen trails in the interior.')		(clearOwnersPenTrails			'Clear all the pen trails in my container.')		(color				'The object''s interior color')		(colorSees			'Whether a given color in the object is over another given color')		(colorUnder			'The color under the center of the object')		(copy			'Return a new object that is very much like this one')		(cursor				'The index of the chosen element')		(deleteCard			'Delete the current card.')		(dismiss			'Click here to dismiss me')		(doMenuItem:			'Do a menu item, the same way as if it were chosen manually')		(doScript:			'Perform the given script once, on the next tick.')		(elementNumber			'My element number as seen by my owner')		(fire			'Run any and all button-firing scripts of this object')		(firstPage			'Go to first page of book')		(followPath				'Retrace the path the object has memorized, if any.')		(forward:			'Moves the object forward in the direction it is heading') 		(goto:			'Go to the specfied book page')		(goToNextCardInStack			'Go to the next card')		(goToPreviousCardInStack			'Go to the previous card.')		(goToRightOf:			'Align the object just to the right of any specified object.')		(heading			'Which direction the object is facing.  0 is straight up') 		(height				'The distance between the top and bottom edges of the object')		(hide			'Make the object so that it does not display and cannot handle input')		(initiatePainting				'Initiate painting of a new object in the standard playfield.')		(initiatePaintingIn:			'Initiate painting of a new object in the given place.')		(isOverColor			'Whether any part of this object is directly over the specified color')		(isUnderMouse			'Whether any part of this object is beneath the current mouse-cursor position')		(lastPage			'Go to the last page of the book.')		(left			'My left edge, measured from the left edge of the World')		(leftRight			'The horizontal displacement')		(liftAllPens			'Lift the pens on all the objects in my interior.')		(lowerAllPens			'Lower the pens on all the objects in my interior.')		(mouseX			'The x coordinate of the mouse pointer')		(mouseY			'The y coordinate of the mouse pointer')		(moveToward:			'Move in the direction of another object.')		(insertCard			'Create a new card.')		(nextPage			'Go to next page.')		(numberAtCursor			'The number held by the object at the chosen element')		(objectNameInHalo			'Object''s name -- To change: click here, edit, hit ENTER')		(obtrudes			'Whether any part of the object sticks out beyond its container''s borders')		(offerScriptorMenu			'The Scriptee.Press here to get a menu')		(pauseScript:			'Make a running script become paused.')		(penDown			'Whether the object''s pen is down (true) or up (false)')		(penColor			'The color of the object''s pen')		(penSize				'The size of the object''s pen')		(clearPenTrails			'Clear all pen trails in the current playfield')		(playerSeeingColorPhrase			'The player who "sees" a given color')		(previousPage			'Go to previous page')		(show			'If object was hidden, make it show itself again.')		(startScript:			'Make a script start running.')		(stopScript:			'Make a script stop running.')		(top			'My top edge, measured downward from the top edge of the world')		(right			'My right edge, measured from the left edge of the world')		(roundUpStrays			'Bring all out-of-container subparts back into view.')		(scaleFactor			'The amount by which the object is scaled')		(stopScript:			'make the specified script stop running')		(tellAllSiblings:			'send a message to all of my sibling instances')		(try			'Run this command once.')		(tryMe			'Click here to run this script once; hold button down to run repeatedly')		(turn:							'Change the heading of the object by the specified amount')		(unhideHiddenObjects			'Unhide all hidden objects.')		(upDown			'The vertical displacement')		(userScript			'This is a script defined by you.')		(userSlot			'This is a variable defined by you.  Click here to change its type')		(valueAtCursor			'The chosen element')		(wearCostumeOf:			'Wear the same kind of costume as the other object')		(width				'The distance between the left and right edges of the object')		(wrap			'If object has strayed beond the boundaries of its container, make it reappear from the opposite edge.')		(x			'The x coordinate, measured from the left of the container')		(y			'The y-coordinate, measured upward from the bottom of the container')		)! !!ScriptEditorMorph class methodsFor: 'instance creation' stamp: 'tk 1/31/2001 09:48'!writingUniversalTiles	"Only valid during the write of a Project."	^ WritingUniversalTiles! !!Morph class methodsFor: '*Etoys' stamp: 'nk 10/11/2003 18:06'!additionToViewerCategorySelectors	"Answer the list of my selectors matching additionsToViewerCategory*"	^self class organization allMethodSelectors select: [ :ea |		(ea beginsWith: 'additionsToViewerCategory')					and: [ (ea at: 26 ifAbsent: []) ~= $: ]]! !!ScrollableField class methodsFor: '*Etoys-scripting' stamp: 'dgd 10/14/2004 18:08'!additionsToViewerCategories	^ TextMorph additionsToViewerCategories! !!ScriptEditorMorph methodsFor: 'e-toy support' stamp: 'mir 7/15/2004 15:19'!localeChanged	"Update myself to reflect the change in locale"	self fixLayout! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 17:55'!becomeLikeAHolder	(self autoLineLayout			and: [self indicateCursor])		ifTrue: [^ self inform: 'This view is ALREADYbehaving like a holder, whichis to say, it is set to indicate thecursor and to have auto-line-layout.' translated].	self behaveLikeHolder! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:48'!showBackgroundObjects	"Momentarily highlight just the background objects on the current playfield"	self isStackBackground ifFalse: [^ self].	self invalidRect: self bounds.	self currentWorld doOneCycle.	Display restoreAfter:		[self submorphsDo:			[:aMorph | (aMorph renderedMorph hasProperty: #shared)				ifTrue:					[Display border: (aMorph fullBoundsInWorld insetBy: -6) 							width: 6 rule: Form over fillColor: Color blue]]]! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/4/2001 00:51'!categoriesForViewer: aViewer	"Answer a list of categories to offer in the given viewer"	^ aViewer currentVocabulary categoryListForInstance: self ofClass: self class limitClass: aViewer limitClass! !!EtoysPresenter methodsFor: 'misc' stamp: 'dgd 2/22/2003 19:08'!currentlyViewing: aPlayer 	"Only detects viewers in tabs"	aPlayer ifNil: [^false].	^aPlayer viewerFlapTab notNil! !!Morph methodsFor: '*Etoys' stamp: 'sw 3/7/2004 13:03'!isPlayer: aPlayer ofReferencingTile: tile	"Answer whether the given player is the object referred to by the given tile, or a sibling of that object.  This theoretically is only sent to PhraseTileMorphs, so this version is theoretically never reached"	^ false! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:42'!isStackBackground	"Answer whether the receiver serves as a background of a stack"	^ ((owner isKindOf: StackMorph) and: [owner currentPage == self]) or:		[self hasProperty: #stackBackground]	"This odd property-based check is because when a paste-up-morph is not the *current* background of a stack, it is maddeningly ownerlyess"! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 1/12/2001 16:58'!allPlayersWithUniclasses	"Answer a list of all players known to the receiver that have uniclasses"	^ self allExtantPlayers select: [:p | p belongsToUniClass]! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:42'!stopRunningScriptsFrom: ignored	"Stop running scripts; get all script-control buttons to reflect this"	self stopRunningScripts! !!EtoysPresenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph: aMorph	associatedMorph := aMorph! !!Object methodsFor: '*Etoys-viewer' stamp: 'ar 5/26/2001 16:13'!isPlayerLike	"Return true if the receiver is a player-like object"	^false! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/20/2001 03:30'!modernize	"If the receiver appears to date from the past, try to fix it up"		Preferences universalTiles ifFalse:		[(self isTextuallyCoded and: [self showingMethodPane not]) ifTrue:			["Fix up old guys that  are not showing the code in place"			self showSourceInScriptor]]! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:46'!penColor: aColor	self assuredPlayer penColor: aColor! !!KedamaMorph methodsFor: 'accessing' stamp: 'ar 1/3/2010 19:11'!isKedamaMorph	^true! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 10/25/2000 17:42'!offerViewerMenuForEvt: anEvent morph: aMorph	"Offer the viewer's primary menu to the user.  aMorph is some morph within the viewer itself, the one within which a mousedown triggered the need for this menu, and it is used only to retrieve the Viewer itself"	self offerViewerMenuFor: (aMorph ownerThatIsA: StandardViewer) event: anEvent! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/16/1999 16:35'!isEmpty	^ submorphs size < firstTileRow! !!ScriptEditorMorph methodsFor: 'e-toy support' stamp: 'ar 2/7/2001 17:57'!isTileEditor	"Yes I am"	^true! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'nk 8/21/2004 12:16'!tryMe	"Evaluate the given script on behalf of the scripted object"	scriptName numArgs = 0		ifTrue:			[self playerScripted performScriptIfCan: scriptName ]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 5/25/2004 16:57'!updateStatus	"Update that status in the receiver's header.  "	(self topEditor == self and: [firstTileRow ~~ 1]) ifTrue:		[(submorphs size == 0 or: [(self firstSubmorph findA: ScriptStatusControl) isNil])			ifTrue:				[self replaceRow1].		self updateStatusMorph: (self firstSubmorph findA: ScriptStatusControl)]! !!EtoysPresenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph	^ associatedMorph! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 3/13/98 17:40'!updateLiteralLabel	"Backstop -- updatingStringMorphs inform their owners with this message when they've changed; some Morphs care, others don't"! !!EToyVocabulary class methodsFor: 'accessing' stamp: 'ar 1/3/2010 22:15'!masterOrderingOfCategorySymbols	"Answer a dictatorially-imposed presentation list of category symbols.	This governs the order in which available vocabulary categories are presented in etoy viewers using the etoy vocabulary.	The default implementation is that any items that are in this list will occur first, in the order specified here; after that, all other items will come, in alphabetic order by their translated wording."	^#(basic #'color & border' geometry motion #'pen use' tests layout #'drag & drop' scripting observation button search miscellaneous)! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 9/2/1999 15:16'!codeString	^ String streamContents: [:aStream | self storeCodeOn: aStream indent: 1]! !!EtoysPresenter class methodsFor: 'class initialization' stamp: 'ar 1/3/2010 19:40'!unload	Presenter defaultPresenterClass: nil.	PasteUpMorph allInstancesDo:[:p| p dumpPresenter].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 5/4/2001 07:25'!handUserTileForSelf	"Hand the user a tile representing the player who is current the 'self' of this script"	playerScripted tileToRefer openInHand! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'di 10/20/97 08:22'!indexOfMorphAbove: aPoint	"Return index of lowest morph whose bottom is above aPoint.	Will return 0 if the first morph is not above aPoint"	submorphs doWithIndex:		[:m :i | m fullBounds bottom >= aPoint y ifTrue:					[^ (i max: firstTileRow) - 1]].	^ submorphs size! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:49'!primSubScalar: rcvr and: other into: result	<primitive: 'primitiveSubScalar' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveSubScalar."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) - other.	].	^ result.! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 9/28/1998 13:15'!automaticViewing: aBoolean	self setProperty: #automaticViewing toValue: aBoolean! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 2/20/2001 00:43'!install	"Accept the current classic tiles as the new source code for the script.  In the case of universalTiles, initialize the method and its methodInterface if not already done."	Preferences universalTiles ifFalse:		[self removeSpaces].	scriptName ifNotNil:		[playerScripted acceptScript: self topEditor for:  scriptName asSymbol]! !!EToyVocabulary methodsFor: 'initialization' stamp: 'ar 1/3/2010 22:11'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	| classes categorySymbols |	super initialize.	self vocabularyName: #eToy.	self documentation: '"EToy" is a vocabulary that provides the equivalent of the 1997-2000 etoy prototype'.	categorySymbols := Set new.	classes := self class morphClassesDeclaringViewerAdditions.	classes do:		[:aMorphClass | categorySymbols addAll: aMorphClass unfilteredCategoriesForViewer].	self addCustomCategoriesTo: categorySymbols.  "For benefit, e.g., of EToyVectorVocabulary"	categorySymbols asOrderedCollection do:		[:aCategorySymbol | | selectors aMethodCategory |			aMethodCategory := ElementCategory new categoryName: aCategorySymbol.			selectors := Set new.			classes do:				[:aMorphClass |					 (aMorphClass additionsToViewerCategory: aCategorySymbol) do:						[:anElement | | selector aMethodInterface |						aMethodInterface := self methodInterfaceFrom: anElement.						selectors add: (selector := aMethodInterface selector).						(methodInterfaces includesKey: selector) ifFalse:							[methodInterfaces at: selector put: aMethodInterface].						self flag: #deferred.						"NB at present, the *setter* does not get its own method interface.  Need to revisit"].			(selectors copyWithout: #unused) asSortedArray do:				[:aSelector |					aMethodCategory elementAt: aSelector put: (methodInterfaces at: aSelector)]].				 			self addCategory: aMethodCategory].	self addCategoryNamed: ScriptingSystem nameForInstanceVariablesCategory.	self addCategoryNamed: ScriptingSystem nameForScriptsCategory.	self setCategoryDocumentationStrings.	(self respondsTo: #applyMasterOrdering)		ifTrue: [ self applyMasterOrdering ].! !!ScriptEditorMorph methodsFor: 'customevents-other' stamp: 'nk 11/1/2004 08:13'!explainStatusAlternatives	(StringHolder new contents: (ScriptingSystem statusHelpStringFor: playerScripted))		openLabel: 'Script Status' translated! !!ScriptEditorMorph class methodsFor: 'new-morph participation' stamp: 'di 6/22/97 09:07'!includeInNewMorphMenu	"Not to be instantiated from the menu"	^ false! !!EtoysPresenter methodsFor: 'tile support' stamp: 'sw 4/25/1998 13:28'!typeForConstant: anObject	^ anObject basicType! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:53'!getPenColor	^ self player ifNotNil: [self actorState getPenColor] ifNil: [Color green]! !!ScriptEditorMorph methodsFor: 'testing' stamp: 'tk 9/30/97 14:09'!stepTime	^ 0! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 4/16/2003 12:45'!arrowsForAllPens	"Set the trail style for all my objects to show arrowheads only"	self trailStyleForAllPens: #arrowheads! !!EtoysPresenter methodsFor: 'misc' stamp: 'sw 8/28/2002 23:07'!drawingJustCompleted: aSketchMorph	"The user just finished drawing.  Now maybe put up a viewer"	| aWorld |	self flushPlayerListCache.  "Because a new drawing already created one, thus obviating #assuredPlayer kicking in with its invalidation"	aWorld := associatedMorph world.	(aWorld hasProperty: #automaticFlapViewing)		ifTrue:			[^ aWorld presenter viewMorph: aSketchMorph].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[self viewMorph: aSketchMorph]! !!Morph methodsFor: '*Etoys-support' stamp: 'nb 6/17/2003 12:25'!followPath	| pathPoints offset |	(pathPoints := self renderedMorph valueOfProperty: #pathPoints) ifNil: [^ Beeper beep].	offset := owner position - (self extent // 2).	pathPoints do:		[:aPoint |			self position: aPoint + offset.			self world displayWorld.			(Delay forMilliseconds: 20) wait]! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 11/9/2000 20:43'!addNewRow	| row |	row := AlignmentMorph newRow		vResizing: #spaceFill;		layoutInset: 0;		borderWidth: 0;		extent: (bounds width)@(TileMorph defaultH);		color: Color transparent.	self addMorphBack: row.	^ row! !!Morph methodsFor: '*Etoys-scripting' stamp: 'nk 8/21/2004 12:17'!triggerScript: aSymbol	"Have my player perform the script of the given name, which is guaranteed to exist."	^self assuredPlayer triggerScript: aSymbol! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 7/28/2004 21:00'!reinvigoratePlayersTool: aPlayersTool 	"Rebuild the contents of the Players tool"	| firstTwo oldList newList rowsForPlayers |	firstTwo := {aPlayersTool submorphs first.  aPlayersTool submorphs second}.	oldList := (aPlayersTool submorphs copyFrom: 3 to: aPlayersTool submorphs size) collect:		[:aRow |			aRow playerRepresented].	self flushPlayerListCache.	newList := self allExtantPlayers.	oldList asSet = newList asSet		ifFalse:			[aPlayersTool removeAllMorphs; addAllMorphs: firstTwo.			rowsForPlayers := newList collect:				[:aPlayer |  aPlayer entryForPlayersTool: aPlayersTool].			aPlayersTool addAllMorphs: rowsForPlayers ]! !!PasteUpMorph class methodsFor: '*eToys-scripting' stamp: 'sw 10/3/2004 01:14'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the phrases this kind of morph wishes to add to various Viewer categories."	^ # ((playfield ((command initiatePainting 'Initiate painting of a new object in the standard playfield.')(slot mouseX 'The x coordinate of the mouse pointer' Number readWrite Player getMouseX  unused unused)(slot mouseY 'The y coordinate of the mouse pointer' Number readWrite Player getMouseY  unused unused)(command roundUpStrays 'Bring all out-of-container subparts back into view.')(slot graphic 'The graphic shown in the background of this object' Graphic readWrite Player getGraphic Player setGraphic:)(command unhideHiddenObjects 'Unhide all hidden objects.')))(scripting ((command tellAllContents: 'Send a message to all the objects inside the playfield' ScriptName)))(collections ((slot cursor 'The index of the chosen element' Number readWrite Player getCursor Player setCursorWrapped:)(slot count 'How many elements are within me' Number readOnly Player getCount unused unused)(slot stringContents 'The characters of the objects inside me, laid end to end' String readOnly Player getStringContents unused unused)(slot playerAtCursor 'the object currently at the cursor' Player readWrite Player getValueAtCursor  unused unused)(slot firstElement  'The first object in my contents' Player  readWrite Player getFirstElement  Player  setFirstElement:)(slot numberAtCursor 'the number at the cursor' Number readWrite Player getNumberAtCursor Player setNumberAtCursor: )(slot graphicAtCursor 'the graphic worn by the object at the cursor' Graphic readOnly Player getGraphicAtCursor  unused unused)(command tellAllContents: 'Send a message to all the objects inside the playfield' ScriptName)(command removeAll 'Remove all elements from the playfield')(command shuffleContents 'Shuffle the contents of the playfield')(command append: 'Add the object to the end of my contents list.' Player)(command prepend: 'Add the object at the beginning of my contents list.' Player)(command includeAtCursor: 'Add the object to my contents at my current cursor position' Player)(command include: 'Add the object to my contents' Player)))(#'stack navigation' ((command goToNextCardInStack 'Go to the next card')(command goToPreviousCardInStack  'Go to the previous card')(command goToFirstCardInBackground 'Go to the first card of the current background')(command goToFirstCardOfStack 'Go to the first card of the entire stack')(command goToLastCardInBackground 'Go to the last card of the current background')(command goToLastCardOfStack 'Go to the last card of the entire stack')(command deleteCard 'Delete the current card')(command insertCard 'Create a new card')))"(viewing ((slot viewingNormally 'whether contents are viewed normally' Boolean readWrite Player getViewingByIcon Player setViewingByIcon: )))"(#'pen trails' ((command liftAllPens 'Lift the pens on all the objects in my interior.')(command lowerAllPens  'Lower the pens on all the objects in my interior.')(command trailStyleForAllPens:  'Set the trail style for pens of all objects within' TrailStyle)(command clearTurtleTrails 'Clear all the pen trails in the interior.'))))! !!Morph methodsFor: '*Etoys' stamp: 'RAA 3/8/2001 07:49'!ensuredButtonProperties	self hasButtonProperties ifFalse: [		self buttonProperties: (ButtonProperties new visibleMorph: self)	].	^self buttonProperties! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'sw 4/17/2003 12:01'!drawPenTrailFor: aMorph from: oldPoint to: targetPoint	"Draw a pen trail for aMorph, using its pen state (the pen is assumed to be down)."	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| origin mPenSize offset turtleTrailsDelta newPoint aPlayer trailStyle aRadius dotSize |	turtleTrailsDelta := self valueOfProperty: #turtleTrailsDelta ifAbsent:[0@0].	newPoint := targetPoint - turtleTrailsDelta.	oldPoint = newPoint ifTrue: [^ self].	self createOrResizeTrailsForm.	origin := self topLeft.	mPenSize := aMorph getPenSize.	turtlePen color: aMorph getPenColor.	turtlePen sourceForm width ~= mPenSize		ifTrue: [turtlePen squareNib: mPenSize].	offset := (mPenSize // 2)@(mPenSize // 2).	(#(lines arrows) includes: (trailStyle := (aPlayer := aMorph player) getTrailStyle))		ifTrue:			[turtlePen drawFrom: (oldPoint - origin - offset) asIntegerPoint				to: (newPoint - origin - offset) asIntegerPoint].	((#(arrowheads arrows) includes: trailStyle) and: [oldPoint ~= newPoint]) ifTrue:		[turtlePen			arrowHeadFrom: (oldPoint - origin - offset) 			to: (newPoint - origin - offset)			forPlayer: aPlayer].	(#(dots) includes: trailStyle)		ifTrue:			[dotSize := aPlayer getDotSize.			turtlePen				putDotOfDiameter: dotSize at: (oldPoint - origin).			turtlePen				putDotOfDiameter: dotSize at: (targetPoint - origin).			aRadius := (dotSize // 2) + 1.			dotSize := dotSize + 1.  "re round-off-derived gribblies"			self invalidRect: ((oldPoint - origin - (aRadius @ aRadius)) extent: (dotSize @ dotSize)).			self invalidRect: ((targetPoint - origin - (aRadius @ aRadius)) extent: (dotSize @ dotSize))]		ifFalse:			[self invalidRect: ((oldPoint rect: newPoint) expandBy: mPenSize)]! !!ScriptEditorMorph class methodsFor: 'instance creation' stamp: 'tk 1/31/2001 09:48'!writingUniversalTiles: boolean	WritingUniversalTiles := boolean! !!SyntaxMorph class methodsFor: 'accessing' stamp: 'ar 1/3/2010 22:12'!clearAllSpecs	"Clear the specs that the Viewer knows about."	"SyntaxMorph clearAllSpecs"	AllSpecs := nil.! !!EToyVocabulary methodsFor: 'testing' stamp: 'ar 1/3/2010 22:11'!isEToyVocabulary	^true! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:50'!showForegroundObjects	"Temporarily highlight the foreground objects"	self isStackBackground ifFalse: [^ self].	Display restoreAfter:		[self submorphsDo:			[:aMorph | aMorph renderedMorph isShared				ifFalse:					[Display border: (aMorph fullBoundsInWorld insetBy: -6) 						width: 6 rule: Form over fillColor: Color orange]]]! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 1/27/2001 14:44'!removeEmptyRows	submorphs copy do: [:m |		(m isAlignmentMorph and: [m submorphCount = 0])			ifTrue: [m delete]].self flag: #arNote. "code below lead to large and unnecessary recomputations of layouts; without it things just fly""	self fullBounds.	self layoutChanged."	self flag: #noteToJohn.  "Screws up when we have nested IFs.  got broken in 11/97 when you made some emergency fixes for some other reason, and has never worked since...  Would be nice to have a more robust reaction to this!!""	self removeEmptyLayoutMorphs.	spacer := LayoutMorph new extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: self indexForLeadingSpacer.	spacer := LayoutMorph new  extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: (submorphs size + 1).	self fullBounds; layoutChanged."! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 8/11/1998 16:59'!restoreTypeColor	self player ifNotNil: [self player allScriptEditors do:		[:anEditor | anEditor allMorphsDo:			[:m | m restoreTypeColor]]]! !!Morph methodsFor: '*Etoys-support' stamp: 'RAA 3/8/2001 14:45'!buttonProperties	^self valueOfProperty: #universalButtonProperties! !!Morph methodsFor: '*Etoys-support' stamp: 'sd 3/30/2005 22:04'!defaultVariableName	"If the receiver is of the sort that wants a variable maintained on its behalf in the 'card' data, then return a variable name to be used for that datum.  What is returned here is only a point of departure in the forthcoming negotiation"	^ Scanner wellFormedInstanceVariableNameFrom: (self valueOfProperty: #variableName ifAbsent: [self externalName])! !!EtoysPresenter methodsFor: 'tile support' stamp: 'gm 2/22/2003 14:53'!constantTile: anObject 	"Answer a constant tile that represents the object"	(anObject isColor) 		ifTrue: 			[^ColorTileMorph new typeColor: (ScriptingSystem colorForType: #Color)].	^anObject newTileMorphRepresentative 		typeColor: (ScriptingSystem colorForType: (self typeForConstant: anObject))! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'dgd 8/28/2004 19:15'!tabHitWithEvent: anEvent	"The tab key was hit.  The keyboard focus has referred this event to me, though this perhaps seems rather backwards.  Anyway, the assumption is that I have the property #tabAmongFields, so now the task is to tab to the next field."	| currentFocus fieldList anIndex itemToHighlight variableBearingMorphs otherAmenableMorphs |	currentFocus := anEvent hand keyboardFocus.	fieldList := self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	fieldList isEmpty ifTrue:[^ self].	variableBearingMorphs := self player isNil										ifTrue:[#()]										ifFalse:[self player class variableDocks collect: [:vd | vd definingMorph] thenSelect: [:m | m isInWorld]].	otherAmenableMorphs := (self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]])			copyWithoutAll: variableBearingMorphs.	fieldList := variableBearingMorphs, otherAmenableMorphs.	anIndex := fieldList indexOf: currentFocus ifAbsent: [nil].	itemToHighlight := fieldList atWrap: 		(anIndex ifNotNil: [anEvent shiftPressed ifTrue: [anIndex - 1] ifFalse: [anIndex + 1]]				ifNil: [1]).	anEvent hand newKeyboardFocus: itemToHighlight. self flag: #arNote. "really???"	itemToHighlight editor selectAll.	itemToHighlight invalidRect: itemToHighlight bounds ! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'ar 1/3/2010 18:09'!impartPrivatePresenter	presenter ifNil:		[presenter := EtoysPresenter new associatedMorph: self.		presenter standardPlayer]! !!ScriptEditorMorph methodsFor: 'private' stamp: 'sw 2/13/98 15:44'!rowInsertionIndexFor: aPoint	"Return the row into which the given morph should be inserted."	| m |	firstTileRow to: submorphs size do: [:i |		m := submorphs at: i.		((m top <= aPoint y) and: [m bottom >= aPoint y]) ifTrue:			[(aPoint y > m center y)				ifTrue: [^ i]				ifFalse: [^ (i - 1) max: firstTileRow]]].	^ firstTileRow > submorphs size		ifTrue:			[submorphs size]		ifFalse:			[(submorphs at: firstTileRow) top > aPoint y 				ifTrue: [firstTileRow - 1]				ifFalse: [submorphs size]]! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 8/12/2005 13:26'!filterViewerCategoryDictionary: dict	"dict has keys of categories and values of priority.	You can re-order or remove categories here."	self wantsConnectionVocabulary		ifFalse: [ dict removeKey: #'connections to me' ifAbsent: [].			dict removeKey: #connection ifAbsent: []].	self wantsConnectorVocabulary		ifFalse: [ dict removeKey: #connector ifAbsent: [] ].	self wantsEmbeddingsVocabulary		ifFalse: [dict removeKey: #embeddings ifAbsent: []].	Preferences eToyFriendly		ifTrue:			[dict removeKey: #layout ifAbsent: []].	(Preferences eToyFriendly or: [self isWorldMorph not]) ifTrue:		[dict removeKey: #preferences ifAbsent: []].! !!TileMorph class methodsFor: 'class initialization' stamp: 'ar 1/3/2010 22:18'!downPicture	^ DownPicture ifNil:[DownPicture := Form	extent: 9@9	depth: 16	fromArray: #( 14253 862794605 862794605 862729101 934150144 14221 724182793 654911241 654913323 931987456 0 793519881 722086698 652880586 862781440 0 931998474 654977834 648621835 0 0 12107 654911209 717895565 0 0 13164 654976681 789250048 0 0 14254 722085546 929890304 0 0 0 860630796 934150144 0 0 0 934098861 0 0)	offset: 0@0]! !!ScriptEditorMorph methodsFor: 'testing' stamp: 'ar 1/3/2010 17:52'!isScriptEditorMorph	^true! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:06'!stepUp: evt with: aMorph	"The step button came up; get things right"	self stepButtonState: #off! !!EtoysPresenter methodsFor: 'access' stamp: 'sw 4/22/1998 20:05'!world	^ associatedMorph world! !!ScriptEditorMorph methodsFor: 'other' stamp: 'RAA 2/27/2001 15:55'!insertUniversalTiles	"Insert universal tiles for the method at hand"	self removeAllButFirstSubmorph.	"fix a broken header in weasel"	submorphs isEmpty ifFalse: [		self firstSubmorph vResizing: #shrinkWrap.	].	self insertUniversalTilesForClass: playerScripted class selector: scriptName! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:10'!primAddScalar: rcvr and: other into: result	<primitive: 'primitiveAddScalar' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveAddScalar."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) + other.	].	^ result.! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 2/14/2001 18:16'!repelsMorph: aMorph event: ev	"Answer whether the receiver shoul repel the given morph"	^ Preferences universalTiles		ifTrue:			[(aMorph respondsTo: #parseNode) not]		ifFalse:			[aMorph isTileLike not]! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'RAA 1/8/2001 15:24'!showAllPlayers	| a |	a := OrderedCollection new.	self allMorphsDo: [ :x | 		(x player notNil and: [x player hasUserDefinedScripts]) ifTrue: [a add: x]	].	a do: [ :each | each openViewerForArgument].! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 1/12/2001 18:10'!uniclassesAndCounts	"Answer a list of all players known to the receiver that have uniclasses"	^ (self allPlayersWithUniclasses collect: [:aPlayer | aPlayer class]) asSet asArray collect:		[:aClass | Array			with:	aClass			with:	aClass instanceCount]	"self currentWorld presenter uniclassesAndCounts"! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 2/16/1999 11:33'!makeFenceSound	Preferences soundsEnabled ifTrue:		[self playSoundNamed: 'scratch'].! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 6/18/1998 09:12'!toggleAutomaticPhraseExpansion	| expand |	expand := self hasProperty: #automaticPhraseExpansion.	expand		ifTrue:			[self removeProperty: #automaticPhraseExpansion]		ifFalse:			[self setProperty: #automaticPhraseExpansion toValue: true]! !!Morph methodsFor: '*Etoys-support' stamp: 'nb 6/17/2003 12:25'!definePath	| points lastPoint aForm offset currentPoint dwell ownerPosition |	points := OrderedCollection new: 70.	lastPoint := nil.	aForm := self imageForm.	offset := aForm extent // 2.	ownerPosition := owner position.	Cursor move show.	Sensor waitButton.	[Sensor anyButtonPressed and: [points size < 100]] whileTrue:		[currentPoint := Sensor cursorPoint.		dwell := 0.		currentPoint = lastPoint			ifTrue:				[dwell := dwell + 1.				((dwell \\ 1000) = 0) ifTrue:					[Beeper beep]]			ifFalse:				[self position: (currentPoint - offset).				self world displayWorld.				(Delay forMilliseconds: 20) wait.				points add: currentPoint.				lastPoint := currentPoint]].	points size > 1		ifFalse:			[self inform: 'no path obtained']		ifTrue:			[points size = 100 ifTrue: [self playSoundNamed: 'croak'].			Transcript cr; show: 'path defined with', points size printString, ' points'.			self renderedMorph setProperty: #pathPoints toValue: 				(points collect: [:p | p - ownerPosition])].	Cursor normal show		! !!ScriptEditorMorph methodsFor: 'other' stamp: 'yo 1/14/2004 10:50'!hasScriptReferencing: aSlotName ofPlayer: aPlayer	"Answer whether the receiver has any tiles in it which reference the given slot of the given player.  By doing a text search on the decompiled method, this is able to work both with text and with tiles.  The approach is still not perfect, because we can't really know until run-time whom the getters and setters are sent to.  But practically speaking, this is all presumably a positive."	| stringToSearch |	"(aPlayer isKindOf: playerScripted class) ifFalse: [^ false]."	stringToSearch := (playerScripted class compiledMethodAt: scriptName) decompileString.	{Utilities getterSelectorFor: aSlotName. Utilities setterSelectorFor: aSlotName} do:		[:searchee |			(stringToSearch findString: searchee startingAt: 1) = 0				ifFalse:					[^ true]]. 	^ false! !!ScriptEditorMorph methodsFor: 'other' stamp: 'ar 1/3/2010 16:11'!storeCodeOn: aStream indent: tabCount 	| lastOwner |	lastOwner := nil.	self tileRows do: 			[:r | 			r do: 					[:m | 					((m isTileMorph) 						or: [(m isCompoundTileMorph) or: [m isPhraseTileMorph]]) 							ifTrue: 								[tabCount timesRepeat: [aStream tab].								(m owner ~= lastOwner and: [lastOwner ~= nil]) 									ifTrue: 										[aStream											nextPut: $.;											cr;											tab.										]									ifFalse: 										[lastOwner ~= nil ifTrue: [aStream space].										].								m storeCodeOn: aStream indent: tabCount.								lastOwner := m owner]]]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:30'!defaultColor	"answer the default color/fill style for the receiver"	^ ScriptingSystem colorBehindTiles! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/23/2000 14:49'!goToNextCardInStack	"Tell my stack to advance to the next page"	self stackDo: [:aStack | aStack goToNextCardInStack]! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'tk 10/4/2001 18:03'!arrowheadsOnAllPens	submorphs do: [:m | m assuredPlayer setPenArrowheads: true]! !!EtoysPresenter methodsFor: 'tile support' stamp: 'dgd 2/21/2003 22:35'!phraseForReceiver: rcvr op: op arg: arg resultType: resultType 	"Answer a PhraseTileMorph affiliated with the given receiver, initialized to hold the given operator, argument, and result type"	| m argTile rcvrTile |	arg isNil 		ifTrue: 			[m := PhraseTileMorph new 						setOperator: op						type: resultType						rcvrType: (self typeForConstant: rcvr)]		ifFalse: 			[m := PhraseTileMorph new 						setOperator: op						type: resultType						rcvrType: (self typeForConstant: rcvr)						argType: (self typeForConstant: arg).			argTile := self constantTile: arg.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	rcvrTile := self constantTile: rcvr.	"	TilePadMorph makeReceiverColorOfResultType ifTrue: [rcvrTile color: m color]."	rcvrTile position: m firstSubmorph position.	m firstSubmorph addMorph: rcvrTile.	m vResizing: #shrinkWrap.	^m! !!ScriptEditorMorph methodsFor: 'other' stamp: 'gm 2/22/2003 18:59'!methodNodeMorph	"Answer the morph that constitutes the receiver's method node"	submorphs size < 2  ifTrue: [^ nil].	^ self findDeepSubmorphThat:		[:aMorph | (aMorph isSyntaxMorph) and:				[aMorph parseNode isKindOf: MethodNode]]			ifAbsent: [nil]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'ar 11/9/2000 13:50'!viewByIcon	"The receiver has been being viewed in some constrained layout view; now restore it to its normal x-y-layout view"	|  oldSubs |	self showingListView		ifTrue:			[oldSubs := submorphs.			self removeAllMorphs.			self layoutPolicy: nil.			oldSubs do:				[:aSubmorph |					self addMorphBack:  aSubmorph objectRepresented].			self restoreBoundsOfSubmorphs.			self removeProperty: #showingListView]		ifFalse:			[self autoLineLayout == true ifTrue: [self toggleAutoLineLayout]]! !!Morph methodsFor: '*Etoys-support' stamp: ''!set: aPointOrNumber	"Set my position."	self jumpTo: aPointOrNumber.! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'nice 12/27/2009 03:11'!updateTrailsForm	"Update the turtle-trails form using the current positions of all pens.	Only used in conjunction with Preferences batchPenTrails."	"Details: The positions of all morphs with their pens down are recorded each time the draw method is called. If the list from the previous display cycle isn't empty, then trails are drawn from the old to the new positions of those morphs on the turtle-trails form. The turtle-trails form is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| removals |	self flag: #bob.	"transformations WRONG here"	(lastTurtlePositions isNil or: [lastTurtlePositions isEmpty]) 		ifTrue: [^self].	removals := OrderedCollection new.	lastTurtlePositions associationsDo: 			[:assoc | | player oldPoint newPoint morph tfm | 			player := assoc key.			morph := player costume.			(player getPenDown and: [morph trailMorph == self]) 				ifTrue: 					[oldPoint := assoc value.					tfm := morph owner transformFrom: self.					newPoint := tfm localPointToGlobal: morph referencePosition.					newPoint = oldPoint 						ifFalse: 							[assoc value: newPoint.							self 								drawPenTrailFor: morph								from: oldPoint								to: newPoint]]				ifFalse: [removals add: player]].	removals do: [:key | lastTurtlePositions removeKey: key ifAbsent: []]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'ar 11/8/2000 22:37'!viewNonOverlapping	"Make the receiver show its contents as full-size morphs laid out left-to-right and top-to-bottom to be non-overlapping."	self viewingNormally ifTrue:		[self saveBoundsOfSubmorphs].	self showingListView ifTrue:		[self viewByIcon.		self removeProperty: #showingListView].	self autoLineLayout: true.! !!ScriptEditorMorph methodsFor: 'save & revert' stamp: 'sw 1/30/2001 12:18'!savedTileVersionsCount	"Answer the number of saved tile versions that currently exist for this script"	^ self userScriptObject savedTileVersionsCount! !!ColorType methodsFor: '*eToys-tiles' stamp: 'sw 1/5/2005 19:57'!wantsArrowsOnTiles	"Answer whether this data type wants up/down arrows on tiles representing its values"	^ false! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:08'!mouseLeaveDragging: evt	"Test button state elsewhere if at all"	^ self mouseLeave: evt! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/20/2004 23:09'!methodString	"Answer the source-code string for the receiver.  This is for use by classic tiles, but is also used in universal tiles to formulate an initial method declaration for a nascent user-defined script; in universalTiles mode, the codeString (at present anyway) is empty -- the actual code derives from the SyntaxMorph in that case"	| k methodNode string |	playerScripted class compileSilently: (string := String streamContents:		[:aStream |			aStream nextPutAll: scriptName.			scriptName endsWithAColon ifTrue:				[aStream nextPutAll: ' parameter'].			aStream cr; cr; tab.			aStream nextPutAll: self codeString.	]) classified: 'temporary'.	k := KedamaVectorizer new initialize.	(k includesTurtlePlayer: (playerScripted class decompile: scriptName) for: playerScripted) ifFalse: [^ string].	methodNode := k vectorize: (playerScripted class decompile: scriptName) 	object: playerScripted.	^ methodNode decompileString.! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 10/23/2000 19:04'!toggleBehaveLikeAHolder	"Toggle whether or not the receiver is currently behaving like a holder"	self behaveLikeHolder: (self behavingLikeAHolder not)! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'ul 12/12/2009 14:08'!tellAllContents: aMessageSelector	"Send the given message selector to all the objects within the receiver"	self submorphs do:		[:m |			m player ifNotNil:				[:p | p performScriptIfCan: aMessageSelector]]! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 5/4/2001 07:06'!graphicForViewerTab	"When a Viewer is open on the receiver, its tab needs some graphic to show to the user.  Answer a form or a morph to serve that purpose.  A generic image is used for arbitrary objects, but note my reimplementors"		^ ScriptingSystem formAtKey: 'Image'! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'sw 4/10/2004 23:12'!removeSpaces	"Remove vertical space"	self submorphsDo:		[:m | (m isMemberOf: Morph) ifTrue: [m delete]].	self removeEmptyRows.	submorphs isEmpty ifTrue: [self height: 14]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/20/2001 00:34'!tileRows	"If using classic tiles, return a collection of arrays of Tiles in which each array is one line of tiles.  (John Maloney's original design and code)."	| rows r |	rows := OrderedCollection new.	Preferences universalTiles ifTrue: [^ rows].	firstTileRow to: submorphs size do: [:i |		r := submorphs at: i.		r submorphCount > 0 ifTrue: [rows addLast: r submorphs]].	^ rows! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'ar 12/14/2001 17:41'!mouseLeave: evt	owner ifNil: [^ self].	"left by being removed, not by mouse movement"	(self hasProperty: #justPickedUpPhrase) ifTrue:[		self removeProperty: #justPickedUpPhrase.		^self].	self stopSteppingSelector: #trackDropZones.	handWithTile := nil.	self removeSpaces.! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'nice 12/27/2009 20:11'!installAsCurrent: anInstance	"Install anInstance as the one currently viewed in the receiver.  Dock up all the morphs in the receiver which contain data rooted in the player instance to the instance data.  Run any 'opening' scripts that pertain."	| fieldList |	self player == anInstance ifTrue: [^ self].	fieldList := self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	self currentWorld hands do:		[:aHand | | itsFocus |		(itsFocus := aHand keyboardFocus) notNil ifTrue:			[(fieldList includes: itsFocus) ifTrue: [aHand newKeyboardFocus: nil]]].	self player uninstallFrom: self.  "out with the old"	anInstance installPrivateMorphsInto: self.	self changed.	anInstance costume: self.	self player: anInstance.	self player class variableDocks do:		[:aVariableDock | aVariableDock dockMorphUpToInstance: anInstance].	self currentWorld startSteppingSubmorphsOf: self! !!ScriptEditorMorph methodsFor: 'e-toy support' stamp: 'sw 7/28/1999 17:02'!isCandidateForAutomaticViewing	^ false! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 2/14/2000 14:24'!defaultNameStemForInstances	"Answer a basis for names of default instances of the receiver.  The default is to let the class specify, but certain instances will want to override.  (PasteUpMorphs serving as Worlds come to mind"	^ self class defaultNameStemForInstances! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/2/2002 21:04'!handUserParameterTile	"Hand the user a parameter, presumably to drop in the script"		| aTileMorph |	aTileMorph := ParameterTile new forScriptEditor: self.	self currentHand attachMorph: aTileMorph! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:19'!allStepButtons	"Answer a list of all the script-controlling Step buttons within my scope"	^ associatedMorph allMorphs select:		[:aMorph | (aMorph isKindOf: ThreePhaseButtonMorph) and:			[aMorph actionSelector == #stepStillDown:with:]]	"ActiveWorld presenter allStepButtons"! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 10/30/2001 13:46'!relaxGripOnVariableNames	"Abandon any memory of specific variable names that should be preserved.  The overall situation here is not yet completely understood, and this relaxation is basically always done on each reassessment of the background shape nowadays.  But this doesn't feel quite right, because if the user has somehow intervened to specify certain name preference we should perhaps honored it.  Or perhaps that is no longer relevant.  ????"	self submorphs do:		[:m | m removeProperty: #variableName.		m removeProperty: #setterSelector].	self reassessBackgroundShape! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:49'!primDivScalar: rcvr and: other into: result	<primitive: 'primitiveDivScalar' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveDivScalar."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) / other.	].	^ result.! !!ScriptEditorMorph methodsFor: 'save & revert' stamp: 'RAA 1/16/2001 01:34'!revertToTileVersion	"The receiver, currently showing textual code,  is asked to revert to the last-saved tile version"	| aUserScript |	self 		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	aUserScript := playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript revertToLastSavedTileVersionFor: self.	self currentWorld startSteppingSubmorphsOf: self! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 3/11/2003 11:57'!linesForAllPens	"Set the trail style for all my objects to show lines only"	self trailStyleForAllPens: #lines! !!MorphicProject methodsFor: '*Etoys-stack' stamp: 'dtl 11/28/2009 18:38'!currentStack	"Answer the current stack of the current project.  Called basically as a bail-out when we can't find the stack in the owner chain of a morph, probably because it is on a background that is not currently installed.  This method will always return a stack that is in the world, or nil if no stack is found in the world.  Of course it would be nice to have multiple stacks concurrently open in the same world, but at the moment that is problematical."	| aStack curStack |	curStack := self projectParameterAt: #CurrentStack.	curStack ifNotNil: [curStack isInWorld ifTrue: [^ curStack]].	(aStack := world findA: StackMorph) ifNotNil:		[self currentStack: aStack].	^ aStack! !!Morph methodsFor: '*Etoys' stamp: 'yo 1/27/2005 23:29'!accumlatePlayersInto: aCollection andSelectorsInto: selectorsCollection	submorphs do: [:tile |		(tile isMemberOf: TileMorph) ifTrue: [			(tile type = #objRef and: [tile actualObject isKindOf: Player]) ifTrue: [				aCollection add: tile actualObject			]		].		(tile isKindOf: AssignmentTileMorph) ifTrue: [			(tile type = #operator) ifTrue: [				selectorsCollection add: tile operatorOrExpression			]		].		tile accumlatePlayersInto: aCollection andSelectorsInto: selectorsCollection	].! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/22/2002 14:07'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating to me.  Some of the messages dispatched here are not yet available in this image"	| aMenu elementType |	elementType := self elementTypeFor: anElement vocabulary: aViewer currentVocabulary.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].	self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu := MenuMorph new defaultTarget: aViewer.	#(	('implementors'			browseImplementorsOf:)		('senders'				browseSendersOf:)		('versions'				browseVersionsOf:)		-		('browse full'			browseMethodFull:)		('inheritance'			browseMethodInheritance:)		-		('about this method'		aboutMethod:)) do:			[:pair |				pair = '-'					ifTrue:						[aMenu addLine]					ifFalse:						[aMenu add: pair first target: aViewer selector: pair second argument: anElement]].	aMenu addLine.	aMenu defaultTarget: self.	#(	('destroy script'		removeScript:)		('rename script'		renameScript:)		('pacify script'		pacifyScript:)) do:			[:pair |				aMenu add: pair first target: self selector: pair second argument: anElement].	aMenu addLine.	aMenu  add: 'show categories....' target: aViewer selector: #showCategoriesFor: argument: anElement.	aMenu items size == 0 ifTrue:  "won't happen at the moment a/c the above"		[aMenu add: 'ok' action: nil].  "in case it was a slot -- weird, transitional"	aMenu addTitle: anElement asString, ' (', elementType, ')'.	aMenu popUpInWorld: self currentWorld. ! !!Morph methodsFor: '*Etoys' stamp: 'sw 8/11/1998 16:54'!showPlayerMenu	self player ifNotNil:		[self player showPlayerMenu]! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'ul 12/12/2009 14:08'!galleryOfPlayers	"Put up a tool showing all the players in the project"		(ActiveWorld findA: AllPlayersTool) ifNotNil: [:aTool | ^ aTool comeToFront].	AllPlayersTool newStandAlone openInHand"ActiveWorld galleryOfPlayers"! !!ScriptEditorMorph methodsFor: 'testing' stamp: 'ul 12/12/2009 14:07'!typeForParameter	"Answer a symbol representing the type of my parameter"	scriptName numArgs > 0 ifTrue:		[(playerScripted class scripts at: scriptName ifAbsent: [nil]) ifNotNil:			[:aScript | ^ aScript argumentVariables first variableType]].	^ #Error! !!Morph methodsFor: '*Etoys' stamp: 'sw 5/17/2001 17:57'!currentVocabulary	"Answer the receiver's current vocabulary"	| outer |	^ (outer := self ownerThatIsA: StandardViewer orA: ScriptEditorMorph) 			ifNotNil:				[outer currentVocabulary]			ifNil:				[super currentVocabulary]! !!ScriptEditorMorph methodsFor: 'drawing' stamp: 'sw 2/14/2001 18:12'!drawOn: aCanvas	"may need to unhibernate the script lazily here."	(Preferences universalTiles and: [self submorphs size < 2])		ifTrue:			[WorldState addDeferredUIMessage: [self unhibernate] fixTemps].	^ super drawOn: aCanvas! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 3/9/2001 13:48'!usableMethodInterfacesIn: aListOfMethodInterfaces	"Filter aList, returning a subset list of apt phrases"	^ aListOfMethodInterfaces! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 12/19/2003 23:39'!allKnownUnaryScriptSelectors	"Answer a list of all the unary selectors implemented by any user-scripted objected within the scope of the receiver; include #emptyScript as a bail-out"	| aSet allUniclasses |	aSet := Set with: #emptyScript.	allUniclasses := (self allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedUnaryTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownUnaryScriptSelectors"! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 5/18/2001 11:17'!changeAllBorderColorsFrom: oldColor to: newColor	"Set any occurrence of oldColor as a border color in my entire submorph tree to be newColor"	(self allMorphs select: [:m | m respondsTo: #borderColor:]) do:		[:aMorph | aMorph borderColor = oldColor ifTrue: [aMorph borderColor: newColor]]! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'bf 10/2/2002 17:07'!backgroundSketch	backgroundMorph ifNil: [^ nil].	backgroundMorph owner == self ifFalse:		[backgroundMorph := nil].	"has been deleted"	^ backgroundMorph! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'tak 3/17/2005 18:27'!playfieldOptionsMenu	"Answer an auxiliary menu with options specific to playfields -- too many to be housed in the main menu"	| aMenu isWorld |	isWorld := self isWorldMorph.	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'save on file...' translated action: #saveOnFile.	Preferences eToyFriendly ifFalse: [		aMenu add: 'save as SqueakPage at url...' translated action: #saveOnURL.		aMenu add: 'update all from resources' translated action: #updateAllFromResources].	aMenu add: 'round up strays' translated action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.' translated.	aMenu add: 'show all players' translated action: #showAllPlayers.	aMenu balloonTextForLastItem:  'Make visible the viewers for all players which have user-written scripts in this playfield.' translated.	aMenu add: 'hide all players' translated action: #hideAllPlayers.	aMenu balloonTextForLastItem:  'Make invisible the viewers for all players in this playfield. This will save space before you publish this project' translated.	aMenu addLine.	aMenu add: 'shuffle contents' translated action: #shuffleSubmorphs.	aMenu balloonTextForLastItem: 'Rearranges my contents in random order' translated.	self griddingOn		ifTrue: [aMenu add: 'turn gridding off' translated action: #griddingOnOff.				aMenu add: (self gridVisible ifTrue: ['hide'] ifFalse: ['show']) translated, ' grid' translated						action: #gridVisibleOnOff.				aMenu add: 'set grid spacing...' translated action: #setGridSpec]		ifFalse: [aMenu add: 'turn gridding on' translated action: #griddingOnOff].	aMenu addLine.	#(	(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')		(fenceEnabledString	toggleFenceEnabled			'whether moving objects should stop at the edge of their container')		(batchPenTrailsString	toggleBatchPenTrails 			'if true, detailed movement of pens between display updates is ignored.  Thus multiple line segments drawn within a script may not be seen individually.')	) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third translated]]. 	aMenu addUpdating: #autoViewingString action: #toggleAutomaticViewing.	aMenu balloonTextForLastItem:  'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.' translated.	((isWorld not or: [self backgroundSketch notNil]) or: [presenter isNil])		ifTrue:			[aMenu addLine].	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' translated action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them' translated.		aMenu add: 'behave like a Holder' translated action: #becomeLikeAHolder.		aMenu balloonTextForLastItem: 'Set properties to make this object nicely set up to hold frames of a scripted animation.' translated].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' translated action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.' translated].	presenter ifNil:		[aMenu add: 'make detachable' translated action: #makeDetachable.		aMenu balloonTextForLastItem: 'Allow this area to be separately governed by its own controls.' translated].	aMenu addLine.	aMenu add: 'use standard texture' translated action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.' translated.	aMenu add: 'make graph paper...' translated action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.' translated.	aMenu addTitle: 'playfield options...' translated.	^ aMenu! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 1/22/2001 15:20'!renameScript: oldSelector	"prompt the user for a new selector and apply it.  Presently only works for players"	self notYetImplemented! !!PasteUpMorph methodsFor: '*Etoys-pen' stamp: 'sw 8/11/1998 16:47'!liftAllPens	submorphs do: [:m | m assuredPlayer liftPen]! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'dgd 8/30/2003 20:34'!addStackItemsTo: aMenu	"Add stack-related items to the menu"	| stackSubMenu |	stackSubMenu := MenuMorph new defaultTarget: self.	(owner notNil and: [owner isStackBackground]) ifTrue:		[self isShared			ifFalse:				[self couldHoldSeparateDataForEachInstance					ifTrue:						[stackSubMenu add: 'Background field, shared value' translated target: self action: #putOnBackground.						stackSubMenu add: 'Background field, individual values' translated target: self action: #becomeSharedBackgroundField]					ifFalse:						[stackSubMenu add: 'put onto Background' translated target: self action: #putOnBackground]]			ifTrue:				[stackSubMenu add: 'remove from Background' translated target: self action: #putOnForeground.				self couldHoldSeparateDataForEachInstance ifTrue:					[self holdsSeparateDataForEachInstance						ifFalse:							[stackSubMenu add: 'start holding separate data for each instance' translated target: self action: #makeHoldSeparateDataForEachInstance]						ifTrue:							[stackSubMenu add: 'stop holding separate data for each instance' translated target: self action: #stopHoldingSeparateDataForEachInstance].							stackSubMenu add: 'be default value on new card' translated target: self action: #setAsDefaultValueForNewCard.							(self hasProperty: #thumbnailImage)								ifTrue:									[stackSubMenu add: 'stop using for reference thumbnail' translated target: self action: #stopUsingForReferenceThumbnail]								ifFalse:									[stackSubMenu add: 'start using for reference thumbnail' translated target: self action: #startUsingForReferenceThumbnail]]].				stackSubMenu addLine].	(self isStackBackground) ifFalse:		[stackSubMenu add: 'be a card in an existing stack...' translated action: #insertAsStackBackground].	stackSubMenu add: 'make an instance for my data' translated action: #abstractAModel.	(self isStackBackground) ifFalse:		[stackSubMenu add: 'become a stack of cards' translated action: #wrapWithAStack].	aMenu add: 'stacks and cards...' translated subMenu: stackSubMenu! !!Morph methodsFor: '*Etoys' stamp: 'nk 8/29/2004 17:14'!selectorsForViewerIn: aCollection	"Answer a list of symbols representing all the selectors available in all my viewer categories, selecting only the ones in aCollection"	| aClass aList itsAdditions added addBlock |	aClass := self renderedMorph class.	aList := OrderedCollection new.	added := Set new.	addBlock := [ :sym |		(added includes: sym) ifFalse: [ (aCollection includes: sym)			ifTrue: [ added add: sym. aList add: sym ]]].	[aClass == Morph superclass] whileFalse: 			[(aClass hasAdditionsToViewerCategories) 				ifTrue: 					[itsAdditions := aClass allAdditionsToViewerCategories.					itsAdditions do: [ :add | add do: [:aSpec |									"the spec list"									aSpec first == #command ifTrue: [ addBlock value: aSpec second].									aSpec first == #slot 										ifTrue: 											[ addBlock value: (aSpec seventh).											 addBlock value: aSpec ninth]]]].			aClass := aClass superclass].	^aList copyWithoutAll: #(#unused #dummy)	"SimpleSliderMorph basicNew selectorsForViewerIn: 	#(setTruncate: getColor setColor: getKnobColor setKnobColor: getWidth setWidth: getHeight setHeight: getDropEnabled setDropEnabled:)	"! !!Morph methodsFor: '*Etoys-scripting' stamp: 'RAA 3/9/2001 11:47'!isTileScriptingElement	^ self hasButtonProperties and: [self buttonProperties isTileScriptingElement]! !!CompoundTileMorph methodsFor: 'testing' stamp: 'ar 1/3/2010 17:51'!isCompoundTileMorph	^true! !!Morph class methodsFor: '*Etoys' stamp: 'nk 10/11/2003 18:17'!additionsToViewerCategories	"Answer a list of (<categoryName> <list of category specs>) pairs that characterize the	phrases this kind of morph wishes to add to various Viewer categories.	This version factors each category definition into a separate method.	Subclasses that have additions can either:		- override this method, or		- (preferably) define one or more additionToViewerCategory* methods.	The advantage of the latter technique is that class extensions may be added	by external packages without having to re-define additionsToViewerCategories.	"	^#()! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:08'!stopButtonState: newState	"Get all stop buttons in my scope to show the correct state"	self allStopButtons do:		[:aButton | aButton state: newState]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 4/30/1998 13:46'!revertScriptVersion	| aUserScript |	aUserScript := playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript revertScriptVersionFrom: self! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'dgd 9/1/2003 14:00'!chooseFrequency	| currentFrequency aMenu |	currentFrequency := self scriptInstantiation frequency.	currentFrequency = 0 ifTrue: [currentFrequency := 1].	aMenu := MenuMorph new defaultTarget: self.	#(1 2 5 10 25 50 100 1000 5000 10000) do:		[:i | aMenu add: i printString selector: #setFrequencyTo: argument: i].		aMenu add: 'other...' translated action: #typeInFrequency.	aMenu addTitle: ('Choose frequency (current: {1})' translated format: {currentFrequency}).	aMenu  popUpEvent: self currentEvent in: self world! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'sw 10/25/2000 06:04'!batchPenTrails	"Answer whether pen trails should be batched in the receiver"	^ self valueOfProperty: #batchPenTrails ifAbsent: [Preferences batchPenTrails]! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'sw 10/27/2000 17:36'!couldHoldSeparateDataForEachInstance	"Answer whether this type of morph is inherently capable of holding separate data for each instance ('card data')"	^ false! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 17:50'!viewingByIconString	"Answer a string to show in a menu representing whether the 	receiver is currently viewing its subparts by icon or not"	^ ((self showingListView			or: [self autoLineLayout == true])		ifTrue: ['<no>']		ifFalse: ['<yes>']), 'view by icon' translated! !!EtoysPresenter methodsFor: 'palette & parts bin' stamp: 'sw 4/21/1998 22:57'!ownStandardPalette	^ standardPalette! !!EtoysPresenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette := aPalette! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 1/3/2010 16:10'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph."	| i slideMorph p1 p2 |	self prepareToUndoDropOf: aMorph.	"Find where it will go, and prepare to animate the move..."	i := self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph := aMorph imageForm offset: 0@0.	p1 := aMorph screenRectangle topLeft.	aMorph delete.	self stopSteppingSelector: #trackDropZones.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isPhraseTileMorph) ifTrue:		[aMorph justGrabbedFromViewer: false].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i := i + 1].	self removeSpaces.	self enforceTileColorPolicy.	self layoutChanged.	self fullBounds. "force layout"	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 := (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 7/5/2005 00:31'!tearOffTile	"Tear off a tile representing the player associated with the receiver.  This is obtained from the top renderer"	^ self topRendererOrSelf assuredPlayer tearOffTileForSelf! !!TileMorph class methodsFor: 'class initialization' stamp: 'ar 1/3/2010 22:19'!suffixPicture	^ SuffixPicture ifNil:[SuffixPicture := Form	extent: 9@11	depth: 16	fromArray: #( 934084608 0 0 0 0 864825164 934150144 0 0 0 862726922 724252557 0 0 0 864824074 722021162 793509888 0 0 864824074 722086666 654977834 864813056 0 864889610 722086666 722085641 722088812 0 864889610 722086698 722086634 646524683 0 864889610 722085610 648686250 858535854 0 864889610 650717866 789264269 0 0 934095595 717894476 0 0 0 13165 931987456 0 0 0)	offset: 0@0]! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'dgd 9/6/2003 18:02'!autoViewingString	"Answer the string to be shown in a menu to represent the  	automatic-viewing status"	^ (self automaticViewing		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'automatic viewing' translated! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/11/1998 16:58'!setMorph: anActorMorph	"Not really the way to do this any more"	playerScripted := anActorMorph player! !!EtoysPresenter methodsFor: 'playerList' stamp: 'sw 8/2/2004 17:24'!browseAllScriptsTextually	"Open a method-list browser on all the scripts in the project"	| aList aMethodList |	(aList := self uniclassesAndCounts) size == 0 ifTrue: [^ self inform: 'there are no scripted players'].	aMethodList := OrderedCollection new.	aList do:		[:aPair | aPair first addMethodReferencesTo: aMethodList].	aMethodList size > 0 ifFalse: [^ self inform: 'there are no scripts in this project!!'].		SystemNavigation new 		browseMessageList: aMethodList 		name: 'All scripts in this project' 		autoSelect: nil"ActiveWorld presenter browseAllScriptsTextually"! !!Object methodsFor: '*Etoys-viewer' stamp: 'ar 5/16/2001 01:40'!updateThresholdForGraphicInViewerTab	"When a Viewer is open on the receiver, its tab needs some graphic to show to the user. Computing this graphic can take quite some time so we want to make the update frequency depending on how long it takes to compute the thumbnail. The threshold returned by this method defines that the viewer will update at most every 'threshold * timeItTakesToDraw' milliseconds. Thus, if the time for computing the receiver's thumbnail is 200 msecs and the the threshold is 10, the viewer will update at most every two seconds."	^20 "seems to be a pretty good general choice"! !!Morph methodsFor: '*Etoys' stamp: 'nk 8/29/2004 17:09'!selectorsForViewer	"Answer a list of symbols representing all the selectors available in all my viewer categories"	| aClass aList itsAdditions added addBlock |	aClass := self renderedMorph class.	aList := OrderedCollection new.	added := Set new.	addBlock := [ :sym | (added includes: sym) ifFalse: [ added add: sym. aList add: sym ]].	[aClass == Morph superclass] whileFalse: 			[(aClass hasAdditionsToViewerCategories) 				ifTrue: 					[itsAdditions := aClass allAdditionsToViewerCategories.					itsAdditions do: [ :add | add do: [:aSpec |									"the spec list"									aSpec first == #command ifTrue: [ addBlock value: aSpec second].									aSpec first == #slot 										ifTrue: 											[ addBlock value: (aSpec seventh).											 addBlock value: aSpec ninth]]]].			aClass := aClass superclass].	^aList copyWithoutAll: #(#unused #dummy)	"SimpleSliderMorph basicNew selectorsForViewer"! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 11/2/2001 13:53'!stack	"Answer the nearest containing Stack, or, if none, a stack in the current project, and if still none, nil.  The extra messiness is because uninstalled backgrounds don't have an owner pointers to their stack."	| aStack bkgnd |	bkgnd := self orOwnerSuchThat: [:oo | oo hasProperty: #myStack].	bkgnd ifNotNil: [^ bkgnd valueOfProperty: #myStack].	"fallbacks"	(aStack := self ownerThatIsA: StackMorph) ifNotNil: [^ aStack].	^ Project current currentStack! !!PasteUpMorph methodsFor: '*Etoys-viewing' stamp: 'ar 8/6/2009 20:43'!setThumbnailHeight	|  reply |	(self hasProperty: #alwaysShowThumbnail) ifFalse:		[^ self inform: 'setting the thumbnail height is onlyapplicable when you are currentlyshowing thumbnails.' translated].	reply := UIManager default		request: 'New height for thumbnails? ' translated		initialAnswer: self heightForThumbnails printString.	reply isEmpty ifTrue: [^ self].	reply := reply asNumber.	(reply > 0 and: [reply <= 150]) ifFalse:		[^ self inform: 'Please be reasonable!!' translated].	self setProperty: #heightForThumbnails toValue: reply.	self updateSubmorphThumbnails! !!PluggableTileScriptorMorph methodsFor: 'updating' stamp: 'ar 1/4/2010 00:28'!update: aSymbol	"Update the receiver in the manner suggested by aSymbol"	aSymbol == #flash ifTrue: [^ self flash].! !!Morph methodsFor: '*Etoys-support' stamp: 'RAA 1/13/2001 11:27'!appearsToBeSameCostumeAs: aMorph	^false! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'gm 2/22/2003 13:09'!recreateScripts	"self currentWorld recreateScripts."	Preferences enable: #universalTiles.	Preferences enable: #capitalizedReferences.	"Rebuild viewers"	self flapTabs do: 			[:ff | 			(ff isMemberOf: ViewerFlapTab) 				ifTrue: 					[ff referent 						submorphsDo: [:m | (m isStandardViewer) ifTrue: [m recreateCategories]]]].	"Rebuild scriptors"	((self flapTabs collect: [:t | t referent]) copyWith: self) 		do: [:w | w allScriptEditors do: [:scrEd | scrEd unhibernate]]! !!EtoysPresenter methodsFor: 'viewer' stamp: 'sw 1/17/1999 21:51'!nascentPartsViewer	^ StandardViewer new! !!PasteUpMorph methodsFor: '*Etoys-playfield' stamp: 'nk 1/6/2004 12:39'!backgroundForm: aForm	self backgroundSketch: (self drawingClass new		center: self center;		form: aForm)! !!Morph methodsFor: '*Etoys' stamp: 'sw 4/12/2005 23:12'!addPlayerItemsTo: aMenu	"Add player-related items to the menu if appropriate"	| aPlayer subMenu |	self couldMakeSibling ifFalse: [^ self].	aPlayer := self topRendererOrSelf player.	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'make a sibling instance' translated target: self action: #makeNewPlayerInstance:.	subMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts' translated.	subMenu add: 'make multiple siblings...' translated target: self action: #makeMultipleSiblings:.	subMenu balloonTextForLastItem: 'Make any number of sibling instances all at once' translated.	(aPlayer belongsToUniClass and: [aPlayer class instanceCount > 1]) ifTrue:		[subMenu addLine.		subMenu add: 'make all siblings look like me' translated target: self action: #makeSiblingsLookLikeMe:.		subMenu balloonTextForLastItem: 'make all my sibling instances look like me.' translated.		subMenu add: 'bring all siblings to my location' translated target: self action: #bringAllSiblingsToMe:.		subMenu balloonTextForLastItem: 'find all sibling instances and bring them to me' translated.		subMenu add: 'apply status to all siblngs' translated target: self action: #applyStatusToAllSiblings:.		subMenu balloonTextForLastItem: 'apply the current status of all of my scripts to the scripts of all my siblings' translated].		subMenu add: 'indicate all siblings' translated target: self action: #indicateAllSiblings.		subMenu balloonTextForLastItem: 'momentarily show, by flashing , all of my visible siblings.'.		aMenu add: 'siblings...' translated subMenu: subMenu! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 07:51'!handlesMouseOverDragging: evt	^ true! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:18'!allStopButtons	"Answer a list of all script-controlling Stop buttons within my scope"	^ associatedMorph allMorphs select:		[:aMorph | (aMorph isKindOf: ThreePhaseButtonMorph) and:			[aMorph actionSelector == #stopUp:with:]]	"ActiveWorld presenter allStopButtons"! !!EtoysPresenter methodsFor: 'tile support' stamp: 'nice 12/26/2009 20:32'!booleanTiles	"Answer some boolean-valued tiles.  This dates back to very early etoy work in 1997, and presently has no sent senders"	| list |	list := #(#(0 #< 1) #(0 #<= 1) #(0 #= 1) #(0 #~= 1) #(0 #> 1) #(0 #>= 1)).	list := list asOrderedCollection collect: 					[:entry | 					| rcvr op arg |					rcvr := entry first.					op := (entry second) asSymbol.					arg := entry last.					self 						phraseForReceiver: rcvr						op: op						arg: arg						resultType: #Boolean].	list add: (self 				phraseForReceiver: Color red				op: #=				arg: Color red				resultType: #Boolean).	^list	"copyWith: CompoundTileMorph new"! !!ScriptEditorMorph methodsFor: 'menu commands' stamp: 'nice 12/27/2009 03:11'!createThreadShowing	| vertices |	self deleteThreadShowing.	vertices := OrderedCollection new.	self tileRows do: [:row | | b |		row first isTurtleRow ifTrue: [			b := row first bounds.			vertices add: ((b topLeft + (4@0)) + ((0 * 0.1 * b width)@0)).			0 to: 9 do: [:i |				vertices add: ((b topLeft + (4@4))+ ((i * 0.1 * b width )@0)).				vertices add: ((b bottomLeft + (4@-4)) + ((i * 0.1 * b width)@0)).			].				vertices add: ((b bottomLeft + (4@0)) + ((9 * 0.1 * b width)@0)).		] ifFalse: [			b := row first bounds.			vertices add: ((b origin x + b corner x)//2)@(b origin y).			vertices add: ((b origin x + b corner x)//2)@(b origin y + 4).			vertices add: ((b origin x + b corner x)//2)@(b corner y - 4).			vertices add: ((b origin x + b corner x)//2)@(b corner y).		].	].	threadPolygon := PolygonMorph vertices: vertices color: Color black borderWidth: 2 borderColor: Color black.	threadPolygon makeOpen.	threadPolygon openInWorld.! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/3/2001 22:08'!categoriesForVocabulary: aVocabulary limitClass: aLimitClass	"Answer a list of categories of methods for the receiver when using the given vocabulary, given that one considers only methods that are implemented not further away than aLimitClass"	^ aVocabulary categoryListForInstance: self ofClass: self class limitClass: aLimitClass! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 11/2/2001 13:31'!beAStackBackground	"Transform the receiver into one that has stack-background behavior.  If just becoming a stack, allocate a uniclass to represent the cards (if one does not already exist"	self assuredCardPlayer assureUniClass.	self setProperty: #tabAmongFields toValue: true.	self setProperty: #stackBackground toValue: true.	"put my submorphs onto the background"	submorphs do: [:mm | mm setProperty: #shared toValue: true].	self reassessBackgroundShape! !!Morph methodsFor: '*Etoys-scripting' stamp: 'sw 8/11/1998 16:55'!useUniformTileColor	self player ifNotNil:		[self player allScriptEditors do:			[:anEditor | anEditor allMorphsDo:				[:m | m useUniformTileColor]]]! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 16:57'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.playerScripted := deepCopier references at: playerScripted ifAbsent: [playerScripted].! !!EtoysPresenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:43'!startRunningScriptsFrom: ignored	"Start running all scripts.  Get all script-control buttons to show the right thing."	self startRunningScripts! !!Morph methodsFor: '*Etoys' stamp: 'nk 9/11/2004 17:31'!unfilteredCategoriesForViewer	"Answer a list of symbols representing the categories to offer in the viewer, in order of:	- masterOrderingOfCategorySymbols first	- others last in order by translated wording"	"	Morph basicNew unfilteredCategoriesForViewer	"	^self renderedMorph class unfilteredCategoriesForViewer.! !!Morph methodsFor: '*Etoys-card in a stack' stamp: 'tk 11/2/2001 13:38'!stopHoldingSeparateDataForEachInstance	"Make the receiver no longer hold separate data for each instance"	self removeProperty: #holdsSeparateDataForEachInstance.	self stack reassessBackgroundShape.! !!ScriptEditorMorph methodsFor: 'e-toy support' stamp: 'yo 1/18/2004 10:34'!replaceReferencesToSlot: oldSlotName inPlayer: aPlayer with: newSlotName	"An instance variable has been renamed in a player; replace all references to the old instance variable of that player such that they become references to the new slot"	self tileRows do: [:row |		row do: [:c | c traverseRowTranslateSlotOld: oldSlotName of: aPlayer to: newSlotName]].	self install.	self fixLayout! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 4/10/2004 00:59'!phrase: aPhraseTileMorph	"Make the receiver be a Scriptor for a new script whose initial contents is the given phrase."	| aHolder |	firstTileRow := 2.	aHolder := AlignmentMorph newRow.	aHolder beTransparent; layoutInset: 0.	aHolder addMorphBack: aPhraseTileMorph.	self addMorphBack: aHolder.	self install! !!WordArray methodsFor: '*Etoys-arithmetic' stamp: 'yo 10/25/2004 15:49'!primMulScalar: rcvr and: other into: result	<primitive: 'primitiveMulScalar' module:'KedamaPlugin'>	"^ KedamaPlugin doPrimitive: #primitiveMulScalar."	1 to: rcvr size do: [:i |		result at: i put: (rcvr at: i) * other.	].	^ result.! !!PasteUpMorph methodsFor: '*eToys-world menu' stamp: 'yo 3/15/2005 13:36'!attemptCleanupReporting: whetherToReport	"Try to fix up some bad things that are known to occur in some etoy projects we've seen. If the whetherToReport parameter is true, an informer is presented after the cleanups"	| fixes |	fixes := 0.	ActiveWorld ifNotNil:		[(ActiveWorld submorphs select:			[:m | (m isKindOf: ScriptEditorMorph) and: [m submorphs isEmpty]]) do:				[:m | m delete.  fixes := fixes + 1]].	TransformationMorph allSubInstancesDo:		[:m | (m player notNil and: [m renderedMorph ~~ m])			ifTrue:				[m renderedMorph visible ifFalse:					[m renderedMorph visible: true.  fixes := fixes + 1]]].	(Player class allSubInstances select: [:cl | cl isUniClass]) do:		[:aUniclass |			fixes := fixes + aUniclass cleanseScripts].	self presenter flushPlayerListCache; allExtantPlayers.	whetherToReport ifTrue:		[self inform: ('{1} [or more] repair(s) made' translated format: {fixes printString})]"ActiveWorld attemptCleanupReporting: true.ActiveWorld attemptCleanupReporting: false."! !!Morph methodsFor: '*Etoys-support' stamp: 'sw 2/6/2001 23:22'!fire	"If the receiver has any kind of button-action defined, fire that action now.   Any morph can have special, personal mouseUpCodeToRun, and that will be triggered by this.  Additionally, some morphs have specific buttonness, and these get sent the #doButtonAction message to carry out their firing.  Finally, some morphs have mouse behaviors associated with one or more Player scripts.	For the present, we'll try out doing *all* the firings this object can do. "	self firedMouseUpCode.   	"This will run the mouseUpCodeToRun, if any"	self player ifNotNil:				[self player fireOnce].  "Run mouseDown and mouseUp scripts"	self doButtonAction			"Do my native button action, if any"! !!ScriptEditorMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 22:06'!autoFitString	"Answer the string to put in a menu that will invite the user to 	switch autoFit mode"	^ ((self hasProperty: #autoFitContents)		ifTrue: ['<yes>']		ifFalse: ['<no>'])		, 'auto fit' translated! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 9/1/2003 14:54'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	self modernize.	ActiveHand showTemporaryCursor: nil.	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	Preferences universalTiles ifFalse:		[count := self savedTileVersionsCount.		self showingMethodPane			ifFalse:				"currently showing tiles"				[aMenu add: 'show code textually' translated action: #showSourceInScriptor.				count > 0 ifTrue: 					[aMenu add: 'revert to tile version...' translated action:	 #revertScriptVersion].				aMenu add: 'save this version' translated	action: #saveScriptVersion]			ifTrue:				"current showing textual source"				[count >= 1 ifTrue:					[aMenu add: 'revert to tile version' translated action: #revertToTileVersion]]].	aMenu addList: {		#-.		{'destroy this script' translated.					#destroyScript}.		{'rename this script' translated.					#renameScript}.		}.	self hasParameter ifFalse:		[aMenu addList: {{'button to fire this script' translated.			#tearOfButtonToFireScript}}].	aMenu addList: {		{'edit balloon help for this script' translated.		#editMethodDescription}.		#-.		{'explain status alternatives' translated. 			#explainStatusAlternatives}.		#-.		{'hand me a tile for self' translated.					#handUserTileForSelf}.		{'hand me a "random number" tile' translated.		#handUserRandomTile}.		{'hand me a "button down?" tile' translated.		#handUserButtonDownTile}.		{'hand me a "button up?" tile' translated.			#handUserButtonUpTile}.		}.	aMenu addList: (self hasParameter		ifTrue: [{			#-.			{'remove parameter' translated.					#ceaseHavingAParameter}}]		ifFalse: [{			{'fires per tick...' translated.						#chooseFrequency}.			#-.			{'add parameter' translated.						#addParameter}}]).	aMenu popUpInWorld: self currentWorld.! !!ScriptEditorMorph methodsFor: 'frequency' stamp: 'ar 8/6/2009 20:44'!typeInFrequency	| reply aNumber |	reply := UIManager default request: 'Number of firings per tick: ' translated initialAnswer: self scriptInstantiation frequency printString.	reply ifNotNil:		[aNumber := reply asNumber.		aNumber > 0 ifTrue:			[self setFrequencyTo: aNumber]]! !!EtoysPresenter methodsFor: 'printing' stamp: 'dtl 8/29/2009 13:05'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' (', self identityHash printString, ')'! !!Morph methodsFor: '*Etoys-support' stamp: 'dgd 2/22/2003 14:35'!topEditor	"Return the top-most editor around the receiver"	| found tested |	tested := self.	[tested isNil] whileFalse: 			[tested isTileEditor ifTrue: [found := tested].			tested := tested owner].	^found! !!PasteUpMorph methodsFor: '*eToys-support' stamp: 'nice 12/27/2009 03:11'!relaunchAllViewers	"Relaunch all the viewers in the project"		(self submorphs select: [:m | m isKindOf: ViewerFlapTab]) do: 			[:aTab | | aViewer | 			aViewer := aTab referent submorphs 						detect: [:sm | sm isStandardViewer]						ifNone: [nil].			aViewer ifNotNil: [aViewer relaunchViewer]			"ActiveWorld relaunchAllViewers"]! !!EtoysPresenter methodsFor: 'viewer' stamp: 'sw 6/20/2001 13:12'!viewObjectDirectly: anObject	"Open up and return a viewer on the given object"	|  aViewer aRect aPoint nominalHeight aFlapTab flapLoc |	associatedMorph addMorph: (aViewer := self nascentPartsViewerFor: anObject).	flapLoc := associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: anObject barHeight: 0.		aViewer enforceTileColorPolicy.		flapLoc hideViewerFlapsOtherThanFor: anObject.		aFlapTab := flapLoc viewerFlapTabFor: anObject.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		flapLoc startSteppingSubmorphsOf: aViewer.		^ aFlapTab].		"Caution: the branch below is historical and has not been used for a long time, though if you set the #viewersInFlaps preference to false you'd hit it.  Not at all recently maintained."	aViewer initializeFor: anObject barHeight: 6.	aViewer enforceTileColorPolicy.	Preferences automaticViewerPlacement ifTrue:		[aPoint := anObject bounds right @ 			(anObject center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).		aRect := (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ aViewer].	anObject primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!TileMorph class methodsFor: 'class initialization' stamp: 'ar 1/3/2010 22:20'!retractPicture	^ RetractPicture ifNil:[RetractPicture := Form	extent: 9@11	depth: 16	fromArray: #( 0 0 0 0 934084608 0 0 0 934162252 864813056 0 0 14221 724249354 862715904 0 0 793520938 722021130 864813056 0 864824106 654977802 722086666 864813056 13164 722085641 722086666 722086666 864878592 12043 646523626 722086698 722086666 864878592 14254 858532522 648685290 722086666 864878592 0 14221 789260970 650717962 864878592 0 0 13132 717892331 934084608 0 0 0 932000621 0)	offset: 8@0]! !!MethodInterface methodsFor: '*Etoys' stamp: 'ar 1/3/2010 22:26'!initializeFromEToyCommandSpec: tuple category: aCategorySymbol	"tuple holds an old etoy command-item spec, of the form found in #additionsToViewerCategories methods.   Initialize the receiver to hold the same information"	selector := tuple second.	receiverType := #Player.	selector numArgs = 1 ifTrue:		[argumentVariables := OrderedCollection with:			(Variable new name: (Player formalHeaderPartsFor: selector) fourth type: tuple fourth)].	aCategorySymbol ifNotNil: [self flagAttribute: aCategorySymbol].	self		wording: (ScriptingSystem wordingForOperator: selector);		helpMessage:  tuple third! !!Object methodsFor: '*Etoys-viewer' stamp: 'sw 8/10/2004 11:53'!tilePhrasesForCategory: aCategorySymbol inViewer: aViewer	"Return a collection of phrases for the category."	| interfaces |	interfaces := self methodInterfacesForCategory: aCategorySymbol inVocabulary: aViewer currentVocabulary limitClass: aViewer limitClass.	interfaces := self methodInterfacesInPresentationOrderFrom: interfaces forCategory: aCategorySymbol.	^ self tilePhrasesForMethodInterfaces: interfaces inViewer: aViewer! !Presenter removeSelector: #allStepButtons!Presenter removeSelector: #allKnownUnaryScriptSelectors!Presenter removeSelector: #stopButtonState:!Presenter removeSelector: #ownStandardPalette!Presenter removeSelector: #standardPalette:!Presenter removeSelector: #browseAllScriptsTextually!Presenter removeSelector: #nascentPartsViewer!MorphExtension removeSelector: #player!Presenter removeSelector: #booleanTiles!Presenter removeSelector: #allStopButtons!Presenter removeSelector: #startRunningScriptsFrom:!Presenter removeSelector: #printOn:!Presenter removeSelector: #viewObjectDirectly:!Presenter removeSelector: #allGoButtons!MorphExtension removeSelector: #actorState!Presenter removeSelector: #stopRunningScripts!Presenter removeSelector: #viewMorph:!Lexicon removeSelector: #installTilesForSelection!Presenter removeSelector: #hasAnyTextuallyCodedScripts!Presenter removeSelector: #allExtantPlayers!Presenter removeSelector: #goButtonState:!Presenter removeSelector: #addTrashCan!Presenter removeSelector: #toolToViewScriptInstantiations!Presenter removeSelector: #standardPlayfield:!Presenter removeSelector: #flushPlayerListCache!Presenter removeSelector: #startRunningScripts!MorphExtension removeSelector: #actorState:!Presenter removeSelector: #adaptedToWorld:!Presenter removeSelector: #allCurrentlyTickingScriptInstantiations!Preferences class removeSelector: #allowEtoyUserCustomEvents!Presenter removeSelector: #stepDown:with:!Presenter removeSelector: #standardPlayer!Presenter removeSelector: #updateViewer:!Presenter removeSelector: #updateViewer:forceToShow:!MorphExtension removeSelector: #player:!Presenter removeSelector: #cacheSpecs:!SyntaxMorph removeSelector: #inAPluggableScrollPane!Presenter removeSelector: #nascentPartsViewerFor:!Presenter removeSelector: #createStandardPlayer!Presenter removeSelector: #positionStandardPlayer!Presenter removeSelector: #stepButtonState:!Presenter removeSelector: #valueTiles!Presenter removeSelector: #systemQueryPhraseWithActionString:labelled:!CodeHolder removeSelector: #installTilesForSelection!Presenter removeSelector: #stopUp:with:!Presenter removeSelector: #morph:droppedIntoPasteUpMorph:!Presenter removeSelector: #stepStillDown:with:!Presenter removeSelector: #reportPlayersAndScripts!Presenter removeSelector: #allKnownScriptSelectors!Presenter removeSelector: #reinvigorateAllScriptsTool:!Presenter removeSelector: #goUp:with:!Presenter removeSelector: #tempCommand!Presenter removeSelector: #viewObject:!Presenter removeSelector: #allPlayersWithUniclasses!Presenter removeSelector: #currentlyViewing:!Presenter removeSelector: #stopRunningScriptsFrom:!Presenter removeSelector: #associatedMorph:!Presenter removeSelector: #associatedMorph!Presenter removeSelector: #typeForConstant:!Presenter removeSelector: #drawingJustCompleted:!Presenter removeSelector: #reinvigoratePlayersTool:!Presenter removeSelector: #constantTile:!Presenter removeSelector: #stepUp:with:!Presenter removeSelector: #world!CodeHolder removeSelector: #toggleShowingTiles!Presenter removeSelector: #uniclassesAndCounts!Presenter removeSelector: #phraseForReceiver:op:arg:resultType:!Smalltalk removeClassNamed: #Presenter!EtoysPresenter initialize!TileMorph initialize!