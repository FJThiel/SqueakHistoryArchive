"Change Set:		7405EToys-ar.31EToys-ar.31:UIManagerization. Replaces all the trivial references to PopUpMenu, SelectionMenu, CustomMenu, and FillInTheBlank."!!CategoryViewer methodsFor: 'categories' stamp: 'ar 8/6/2009 20:03'!chooseCategory	"The mouse went down on my category-list control; pop up a list of category choices"	| aList reply aLinePosition lineList |	aList := scriptedPlayer categoriesForViewer: self.	aLinePosition := aList indexOf: #miscellaneous ifAbsent: [nil].	aList := aList collect:			[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	lineList := aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aList size == 0 ifTrue: [aList add: ScriptingSystem nameForInstanceVariablesCategory translated].	reply := UIManager default 		chooseFrom: aList 		values: aList 		lines: lineList		title: 'category' translated.	reply ifNil: [^ self].	self chooseCategoryWhoseTranslatedWordingIs: reply asSymbol! !!ButtonProperties methodsFor: 'menu' stamp: 'ar 8/6/2009 18:45'!setActWhen	| selections |	selections := #(mouseDown mouseUp mouseStillDown).	actWhen := UIManager default 		chooseFrom: (selections collect: [:t | t translated])		values: selections		title: 'Choose one of the following conditions' translated.! !!ScriptInstantiation methodsFor: 'customevents-status control' stamp: 'ar 8/6/2009 19:08'!deleteCustomEvent	| userEvents eventName |	userEvents :=  ScriptingSystem userCustomEventNames.	eventName := UIManager default 		chooseFrom: userEvents 		values: userEvents 		title: 'Remove which event?'.	eventName ifNotNil: [ ScriptingSystem removeUserCustomEventNamed: eventName ].	self class allSubInstancesDo: [ :ea | ea status = eventName ifTrue: [ ea status: #normal ]]! !!SoundReadoutTile methodsFor: 'arrows' stamp: 'ar 8/6/2009 19:09'!soundNameFromUser	"Obtain a sound from the user.  Exclude the items designated as being discouraged, except that if the current selection is one of those, show it anyway"	| choices |	choices := self soundChoices.	^ UIManager default 		chooseFrom: (choices collect: [:t | t translated]) 		values: self soundChoices		title: 'Sounds' translated! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 19:15'!changeStyle	| aList reply style |	aList := StrikeFont actualFamilyNames.	aList addFirst: 'DefaultTextStyle'.	reply := UIManager default chooseFrom: aList values: aList lines: #(1).	reply ifNil: [^self].	(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].	self applyToWholeText ifTrue: [self activeEditor selectAll].	self activeEditor changeStyleTo: style copy.	self activeTextMorph updateFromParagraph.! !!EToyCommunicatorMorph class methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 18:18'!instanceReport	"for cleaning up Alan's demo""EToySenderMorph instanceReport"	| answer resp |	Smalltalk garbageCollect.	answer := self allInstances collect: [ :each |		{			each.			[each ipAddress] on: Error do: [ 'no ipAddress'].			each owner 					ifNil: ['* no owner *'] 					ifNotNil: [each owner innocuousName,' ',each owner printString].			each world ifNil: ['-----no project-----'] ifNotNil: [each world project name].		}	].	resp := UIManager default chooseFrom:  {		'IP Address'.		'Project'.		'Owner'	}  title:  'Sorted by'.	resp = 1 ifTrue: [		^(answer asSortedCollection: [ :a :b | a second <= b second]) asArray explore	].	resp = 2 ifTrue: [		^(answer asSortedCollection: [ :a :b | a fourth <= b fourth]) asArray explore	].	resp = 3 ifTrue: [		^(answer asSortedCollection: [ :a :b | a third <= b third]) asArray explore	].	answer explore! !!Player methodsFor: 'slots-user' stamp: 'ar 8/6/2009 20:43'!renameSlot: oldSlotName 	| reply newSlotName |	reply := UIManager default request: 'New name for "' translated , oldSlotName , '":'				initialAnswer: oldSlotName.	reply isEmpty ifTrue: [^self].	newSlotName := ScriptingSystem 				acceptableSlotNameFrom: reply				forSlotCurrentlyNamed: oldSlotName				asSlotNameIn: self				world: self costume currentWorld.	self renameSlot: oldSlotName newSlotName: newSlotName! !!ScriptActivationButton methodsFor: 'miscellaneous' stamp: 'ar 8/6/2009 20:44'!setLabel	"Allow the user to enter a new label for this button"	| newLabel existing |	existing := self label.	newLabel := UIManager default		request: 'Please enter a new label for this button'		initialAnswer: existing.	(newLabel isEmptyOrNil not and: [newLabel ~= existing]) ifTrue:		[self setProperty: #labelManuallyEdited toValue: true.		self label: newLabel].! !!ButtonProperties methodsFor: 'menu' stamp: 'ar 8/6/2009 20:39'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := UIManager default		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!ActorState methodsFor: 'pen' stamp: 'ar 8/6/2009 20:00'!choosePenSize	| sz |	sz := UIManager default chooseFrom: (1 to: 10)  values: (1 to: 10).	sz ifNotNil: [penSize := sz]! !!KedamaMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:41'!setScale	| reply |	reply := UIManager default		request: 'Set the number of pixels per patch (a number between 1 and 10)?'		 initialAnswer: pixelsPerPatch printString.	reply isEmpty ifTrue: [^ self].	self pixelsPerPatch: reply asNumber.! !!KedamaExamplerPlayer methodsFor: 'player protocol' stamp: 'ar 8/6/2009 18:52'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName := Utilities inherentSelectorForGetter: aGetter.	typeChoices := Vocabulary typeChoices.	typeChosen := UIManager default chooseFrom: (typeChoices collect: [:t | t translated])values: typeChoices title: 		('Choose the TYPEfor ' translated, slotName, '(currently ' translated, (self slotInfoAt: slotName) type translated, ')').	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	turtles setVectorSlotTypeFor: slotName typeChosen: typeChosen.	sequentialStub ifNotNil: [sequentialStub setScalarSlotTypeFor: slotName typeChosen: typeChosen].	self updateAllViewers.	"does siblings too"! !!ScriptableButton methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setLabel	"Invoked from a menu, let the user change the label of the button"	| newLabel |	newLabel := UIManager default		request:'Enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!Player methodsFor: 'slots-user' stamp: 'ar 8/6/2009 20:43'!addInstanceVariable	"Offer the user the opportunity to add an instance variable, and if he goes through with it, actually add it."	| itsName initialValue typeChosen usedNames initialAnswer setterSelector originalString |	usedNames := self class instVarNames.	initialAnswer := Utilities keyLike: ('var' translated, (usedNames size + 1) asString)  satisfying: [:aKey | (usedNames includes: aKey) not].	originalString := UIManager default request: 'name for new variable: ' translated initialAnswer: initialAnswer.	originalString isEmptyOrNil ifTrue: [^ self].	itsName := ScriptingSystem acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: nil asSlotNameIn: self world: self costume world. 	itsName size == 0 ifTrue: [^ self].		self assureUniClass.	typeChosen := self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new initialize type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileInstVarAccessorsFor: itsName.	setterSelector := Utilities setterSelectorFor: itsName.	((self class allSubInstances copyWithout: self) reject: [:e | e isSequentialStub]) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: ScriptingSystem nameForInstanceVariablesCategory! !!EToyProjectHistoryMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 20:09'!jumpToProject	| selection |	selection := (Project buildJumpToMenu: MenuMorph new) startUp.	self closeMyFlapIfAny.	Project jumpToSelection: selection! !!UniclassScript methodsFor: 'versions' stamp: 'ar 8/6/2009 19:18'!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| chosenStampAndTileList |	formerScriptingTiles isEmptyOrNil ifTrue: [^Beeper beep].	chosenStampAndTileList := formerScriptingTiles size == 1 		ifTrue: [ formerScriptingTiles first]		ifFalse: 			[UIManager default 						chooseFrom: (formerScriptingTiles collect: [:e | e first])						values: formerScriptingTiles].	chosenStampAndTileList ifNotNil: 			[anEditor reinsertSavedTiles: chosenStampAndTileList second.			isTextuallyCoded := false]! !!UserScript methodsFor: 'versions' stamp: 'ar 8/6/2009 19:19'!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| result |	formerScriptEditors isEmptyOrNil ifTrue: [^Beeper beep].	result := formerScriptEditors size == 1 		ifTrue: [formerScriptEditors first]		ifFalse: 			[UIManager default 						chooseFrom: (formerScriptEditors collect: [:e | e timeStamp])						values: formerScriptEditors].	result 		ifNotNil: [self revertScriptVersionFrom: anEditor installing: result]! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 19:10'!insertCardOfBackground	"Prompt the user for choice of a background, and insert a new card of that background"	| bgs aBackground |	(bgs := self backgrounds) size == 1 ifTrue:		[self inform: 'At this time, there IS only one kind ofbackground in this stack, so that''swhat you''ll get' translated.		^ self insertCard].	aBackground := UIManager default		chooseFrom: (bgs collect: [:bg | bg externalName])		values: bgs.	aBackground ifNotNil:		[self insertCardOfBackground: aBackground]! !!Player methodsFor: 'scripts-kernel' stamp: 'ar 8/6/2009 20:43'!renameScript: oldSelector 	"The user has asked to rename the script formerly known by oldSelector; obtain a new selector from the user, check it out, and if all is well, ascribe the new name as appropriate"	| reply newSelector aUserScript |	self flag: #deferred.	"Relax the restriction below, before too long"	aUserScript := self class userScriptForPlayer: self selector: oldSelector.	aUserScript okayToRename 		ifFalse: 			[self 				inform: 'Sorry, we do not permit you to renameclassic-tiled scripts that are currentlytextually coded.  Go back to tile scriptsand try again.  Humble apologies.' translated.			^self].	reply := UIManager default request: 'Script Name' translated initialAnswer: oldSelector.	reply isEmpty ifTrue: [^self].	reply = oldSelector ifTrue: [^Beeper beep].	newSelector := self acceptableScriptNameFrom: reply				forScriptCurrentlyNamed: oldSelector.	Preferences universalTiles 		ifTrue: 			["allow colons"			(reply copyWithout: $:) = newSelector 				ifTrue: [newSelector := reply asSymbol]				ifFalse: [self inform: 'name will be modified']].	self renameScript: oldSelector newSelector: newSelector! !!Player methodsFor: 'slots-user' stamp: 'ar 8/6/2009 19:05'!offerGetterTiles: slotName 	"For a player-type slot, offer to build convenient compound tiles that otherwise would be hard to get"	| typeChoices typeChosen thePlayerThereNow slotChoices slotChosen getterTiles aCategoryViewer playerGetter |	typeChoices := Vocabulary typeChoices.	typeChosen := UIManager default 		chooseFrom: (typeChoices collect: [:t | t translated]) 		values: typeChoices		title: ('Choose the TYPEof data to get from{1}''s {2}' translated format: {self externalName. slotName translated}).	typeChosen isEmptyOrNil ifTrue: [^self].	thePlayerThereNow := self perform: (Utilities getterSelectorFor: slotName).	thePlayerThereNow 		ifNil: [thePlayerThereNow := self presenter standardPlayer].	slotChoices := thePlayerThereNow slotNamesOfType: typeChosen.	slotChoices isEmpty 		ifTrue: [^self inform: 'sorry -- no slots of that type' translated].	slotChoices := slotChoices asSortedArray.	slotChosen := UIManager default 		chooseFrom: (slotChoices collect: [:t | t translated]) 		values: slotChoices		title: ('Choose the datumyou want to extract from {1}''s {2}' translated format: {self externalName. slotName translated}).	slotChosen isEmptyOrNil ifTrue: [^self].	"Now we want to tear off tiles of the form		holder's valueAtCursor's foo"	getterTiles := nil.	aCategoryViewer := CategoryViewer new initializeFor: thePlayerThereNow				categoryChoice: 'basic'.	getterTiles := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotChosen)				type: typeChosen.	aCategoryViewer := CategoryViewer new initializeFor: self				categoryChoice: 'basic'.	playerGetter := aCategoryViewer 				getterTilesFor: (Utilities getterSelectorFor: slotName)				type: #Player.	getterTiles submorphs first acceptDroppingMorph: playerGetter event: nil.	"the pad"	"simulate a drop"	getterTiles makeAllTilesGreen.	getterTiles justGrabbedFromViewer: false.	(getterTiles firstSubmorph)		changeTableLayout;		hResizing: #shrinkWrap;		vResizing: #spaceFill.	ActiveHand attachMorph: getterTiles! !!Player methodsFor: 'slots-user' stamp: 'ar 8/6/2009 19:06'!setPrecisionFor: slotName 	"Set the precision for the given slot name"	| aList reply val aGetter places |	aGetter := Utilities getterSelectorFor: slotName.	places := Utilities 				decimalPlacesForFloatPrecision: (self defaultFloatPrecisionFor: aGetter).	aList := #('0' '1' '2' '3' '4' '5' '6').	reply := UIManager default		chooseFrom: aList		values: (aList collect: [:m | m asNumber])		title: ('How many decimal places? (currently {1})' translated						format: {places}).	reply ifNotNil: 			[(self slotInfo includesKey: slotName) 				ifTrue: 					["it's a user slot"					(self slotInfoAt: slotName) 						floatPrecision: (Utilities floatPrecisionForDecimalPlaces: reply).					self class allInstancesDo: 							[:anInst | 							reply == 0 								ifFalse: 									[((val := anInst instVarNamed: slotName asString) isInteger) 										ifTrue: [anInst instVarNamed: slotName asString put: val asFloat]].							anInst updateAllViewers]]				ifFalse: 					["it's specifying a preference for precision on a system-defined numeric slot"					self noteDecimalPlaces: reply forGetter: aGetter.					self updateAllViewers]]! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 8/6/2009 19:16'!showOptions	"The receiver is a tile that represents an operator; a click on the 	receiver's label will pop up a menu of alternative operator choices"	| result menuChoices word |	menuChoices := (self options first collect: [:each | each asString translated]) collect: [:each | 							word := self currentVocabulary translatedWordingFor: each asSymbol.							word isEmpty								ifTrue: ['<-']								ifFalse: [word]].	result := UIManager default chooseFrom: menuChoices values: self options first.	result 		ifNotNil: [self value: result.			self scriptEdited]! !!Player methodsFor: 'slots-user' stamp: 'ar 8/6/2009 19:03'!chooseUserSlot	| names result |	(names := self slotNames) size == 1		ifTrue: [^ names first].	result := UIManager default 		chooseFrom: names 		values: names 		title: 'Please choose a variable'.	result isEmptyOrNil ifTrue: [^ nil].	^ result! !!CategoryViewer methodsFor: 'categories' stamp: 'ar 8/6/2009 18:45'!showCategoriesFor: aSymbol	"Put up a pop-up list of categories in which aSymbol is filed; replace the receiver with a CategoryViewer for the one the user selects, if any"	| allCategories aVocabulary hits meths chosen |	aVocabulary := self currentVocabulary.	allCategories := scriptedPlayer categoriesForVocabulary: aVocabulary limitClass: ProtoObject.	hits := allCategories select:		[:aCategory | 			meths := aVocabulary allMethodsInCategory: aCategory forInstance: scriptedPlayer ofClass: scriptedPlayer class.			meths includes: aSymbol].	hits isEmpty ifTrue: [ ^self ].	chosen := UIManager default chooseFrom: hits values: hits.	chosen isEmptyOrNil ifFalse:		[self outerViewer addCategoryViewerFor: chosen atEnd: true]	! !!ButtonProperties methodsFor: 'menu' stamp: 'ar 8/6/2009 20:39'!setActionSelector	| newSel |	newSel := UIManager default		request:'Please type the selector to be sent tothe target when this button is pressed' translated		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!StackMorph methodsFor: 'background' stamp: 'ar 8/6/2009 20:45'!insertAsBackground: newPage resize: doResize	"Make a new background for the stack.  Obtain a name for it from the user.  It starts out life empty"	| aName |	aName := UIManager default request: 'What should we call this new background?' translated initialAnswer: 'alternateBackground' translated.	aName isEmptyOrNil ifTrue: [^ self].	newPage beSticky.	doResize ifTrue: [newPage extent: currentPage extent].	newPage beAStackBackground.	newPage setNameTo: aName.	newPage vResizeToFit: false.	pages isEmpty		ifTrue: [pages add: newPage]		ifFalse: [pages add: newPage after: currentPage].	self privateCards add: newPage currentDataInstance after: currentPage currentDataInstance.	self nextPage.! !!TextPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 19:15'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList := self activeTextMorph textStyle fontNamesWithPointSizes.	reply := UIManager default chooseFrom: aList values: aList.	reply ifNil: [^self].	self applyToWholeText ifTrue: [self activeEditor selectAll].	self activeEditor replaceSelectionWith:		(Text string: self activeEditor selection asString 			attribute: (TextFontChange fontNumber: (aList indexOf: reply))).	self activeTextMorph updateFromParagraph.! !!StackMorph methodsFor: 'background' stamp: 'ar 8/6/2009 20:45'!changeInstVarOrder	"Change the order of the receiver's instance variables"	| reply |	reply := UIManager default request: 'rearrange, then accept; or cancel' initialAnswer:		((self currentPage player class instVarNames asArray collect: [:v | v asSymbol]) storeString copyWithoutAll: #($# $( $))) asString.	reply isEmptyOrNil ifTrue: [^ self].	self flag: #deferred.  "Error checking and graceful escape wanted"	self currentPage player class resortInstanceVariables: (Compiler evaluate:		('#(', reply, ')'))! !!Player methodsFor: 'costume' stamp: 'ar 8/6/2009 19:04'!newCostume	| reply |	(reply := UIManager default 		chooseFrom: self availableCostumeNames 		values: self availableCostumeNames 		title: 'choose a costume') ifNil: [^ self].	self wearCostumeOfName: reply.	self updateAllViewers! !!ButtonProperties methodsFor: 'menu' stamp: 'ar 8/6/2009 20:39'!setLabel	| newLabel |	newLabel := UIManager default		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!TileMorph methodsFor: 'mouse handling' stamp: 'ar 8/6/2009 19:16'!presentOperatorAlternatives: evt	"The receiver is a tile that represents an operator; a click on the receiver's label will pop up a menu of alternative operator choices"	| result ops |	((ops := ScriptingSystem arithmeticalOperatorsAndHelpStrings first) includes: operatorOrExpression) ifFalse:		[((ops := ScriptingSystem numericComparitorsAndHelpStrings first) includes: operatorOrExpression)			ifFalse: [^ self]].			(result := UIManager default chooseFrom: ops values: ops) ifNotNil:		[self setOperatorAndUseArrows: result asString.		self scriptEdited]! !!ScriptInstantiation methodsFor: 'status control' stamp: 'ar 8/6/2009 20:44'!typeInTickingRate	| reply aNumber |	reply := UIManager default request: 'Number of ticks per second: ' translated initialAnswer: self tickingRate printString.	reply ifNotNil:		[aNumber := reply asNumber.		aNumber > 0 ifTrue:			[self tickingRate: aNumber]]! !!Player methodsFor: 'slots-user' stamp: 'ar 8/6/2009 19:03'!chooseSlotTypeFor: aGetter	"Let the user designate a type for the slot associated with the given getter"	| typeChoices typeChosen slotName |	slotName := Utilities inherentSelectorForGetter: aGetter.	typeChoices := Vocabulary typeChoices.	typeChosen := UIManager default 		chooseFrom: (typeChoices collect: [:t | t translated]) 		values: typeChoices		title: ('Choose the TYPEfor ' translated, slotName, '(currently ' translated, (self slotInfoAt: slotName) type translated, ')').	typeChosen isEmptyOrNil ifTrue: [^ self].	(self typeForSlot: slotName) capitalized = typeChosen ifTrue: [^ self].	(self slotInfoAt: slotName) type: typeChosen.	self class allInstancesDo:   "allSubInstancesDo:"		[:anInst | anInst instVarNamed: slotName asString put: 			(anInst valueOfType: typeChosen from: (anInst instVarNamed: slotName))].	self updateAllViewers.	"does siblings too"	self changeTypesInWatchersOf: slotName  "does siblings too"! !!StackMorph methodsFor: 'card access' stamp: 'ar 8/6/2009 20:45'!goToCard	"prompt the user for an ordinal number, and use that as a basis for choosing a new card to install in the receiver"	| reply index |	reply := UIManager default request: 'Which card number? ' translated initialAnswer: '1'.	reply isEmptyOrNil ifTrue: [^ self].	((index := reply asNumber) > 0 and: [index <= self privateCards size])		ifFalse: [^ self inform: 'no such card'].	self goToCard: (self privateCards at: index)! !!Player methodsFor: 'costume' stamp: 'ar 8/6/2009 19:02'!changeParameterTypeFor: aSelector	"Change the parameter type for the given selector.  Not currently sent, since types are now set by direct manipulation in the Scriptor header.  If this were reinstated someday, there would probably be an issue about getting correct-looking Parameter tile(s) into the Scriptor header(s)"	| current typeChoices typeChosen |	current := self typeforParameterFor: aSelector.	typeChoices := Vocabulary typeChoices.	typeChosen := UIManager default 		chooseFrom: typeChoices 		values: typeChoices  		title: ('Choose the TYPEfor the parameter (currently ', current, ')').	self setParameterFor: aSelector toType: typeChosen! !!MenuTile methodsFor: 'event handling' stamp: 'ar 8/6/2009 18:54'!mouseDown: evt	| aPoint reply choices |	aPoint := evt cursorPoint.	nArrowTicks := 0.	((upArrow bounds containsPoint: aPoint) or: [downArrow bounds containsPoint: aPoint]) ifTrue: [^ self mouseStillDown: evt].	choices := ((self ownerThatIsA: PhraseTileMorph) associatedPlayer costume allMenuWordings) copyWithout: ''.	reply := UIManager default chooseFrom: choices values: choices.	reply ifNotNil: [self literal: reply; layoutChanged]! !