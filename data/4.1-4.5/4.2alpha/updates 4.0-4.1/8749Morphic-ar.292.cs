"Change Set:		8749Morphic-ar.292Morphic-ar.292:Prepare for Etoys unloading:- Move player and actorState accessors back to Morphic- Move Presenter and StandardScriptingSystem to Morphic-Worlds since they represent some of the 'world globals'- Make ScrollPane a subclass of MorphicModel instead of ComponentLikeModelMorphic-ar.281:Remove last dependencies of PreferenceBrowser and Services. Both are now unloadable.Morphic-ul.282:- add a missing method, to fix an MNUMorphic-ar.283:Make Nebraska unloadable. Some methods in Worldstate need to remain in the Morphic package otherwise things blow up after unloading Nebraska.Morphic-nice.284:move #basicType to EToysremove some #or:or: #and:and: sends"!MorphicModel subclass: #ScrollPane	instanceVariableNames: 'scrollBar scroller retractableScrollBar scrollBarOnLeft getMenuSelector getMenuTitleSelector scrollBarHidden hasFocus hScrollBar'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Windows'!Object subclass: #StandardScriptingSystem	instanceVariableNames: ''	classVariableNames: 'ClassVarNamesInUse FormDictionary HelpStrings StandardPartsBin'	poolDictionaries: ''	category: 'Morphic-Worlds'!Object subclass: #Presenter	instanceVariableNames: 'associatedMorph standardPlayer standardPlayfield standardPalette playerList'	classVariableNames: 'DefaultPresenterClass'	poolDictionaries: ''	category: 'Morphic-Worlds'!!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:42'!player	"answer the receiver's player"	^ player! !!Presenter methodsFor: 'playerList' stamp: 'yo 2/10/2005 17:07'!reportPlayersAndScripts	"Open a window which contains a report on players and their scripts"	| aList aString |	(aList := self uniclassesAndCounts) ifEmpty:  [^ self inform: 'there are no scripted players' translated].	aString := String streamContents:		[:aStream |			aList do:				[:aPair |					aStream nextPutAll: aPair first name, ' -- ', aPair second printString.					aStream nextPutAll: ' ', (aPair second > 1 ifTrue: ['instances'] ifFalse: ['instance']) translated, ', '.					aStream nextPutAll: 'named' translated.					aPair first allInstancesDo: [:inst | aStream space; nextPutAll: inst externalName].					aStream cr].			aStream cr.			aList do:				[:aPair |					aStream cr.					aStream nextPutAll: '--------------------------------------------------------------------------------------------'.					aStream cr; nextPutAll: aPair first typicalInstanceName.					aStream nextPutAll: '''s' translated.					aStream nextPutAll: ' scripts:' translated.					aPair first addDocumentationForScriptsTo: aStream]].	(StringHolder new contents: aString)		openLabel: 'All scripts in this project' translated"self currentWorld presenter reportPlayersAndScripts"! !!DockingBarMorph methodsFor: 'initialization' stamp: 'nice 1/1/2010 21:47'!setDefaultParameters	"private - set the default parameter using Preferences as the inspiration source"	| colorFromMenu worldColor menuColor menuBorderColor |	colorFromMenu := Preferences menuColorFromWorld				and: [Display depth > 4				and: [(worldColor := self currentWorld color) isColor]].	""	menuColor := colorFromMenu				ifTrue: [worldColor luminance > 0.7						ifTrue: [worldColor mixed: 0.85 with: Color black]						ifFalse: [worldColor mixed: 0.4 with: Color white]]				ifFalse: [Preferences menuColor].	""	menuBorderColor := Preferences menuAppearance3d				ifTrue: [#raised]				ifFalse: [colorFromMenu						ifTrue: [worldColor muchDarker]						ifFalse: [Preferences menuBorderColor]].	""	self		setColor: menuColor		borderWidth: Preferences menuBorderWidth		borderColor: menuBorderColor! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:06'!stepUp: evt with: aMorph	"The step button came up; get things right"	self stepButtonState: #off! !!MenuIcons class methodsFor: 'import/export' stamp: 'nice 1/1/2010 21:42'!importAllIconNamed: aString	"self importIconNamed: 'Icons16:appearanceIcon'"		| writer image stream |	writer := GIFReadWriter on: (FileStream fileNamed: aString, '.gif').	image := [ writer nextImage]			ensure: [writer close].	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString ; cr.	stream nextPutAll: (self methodStart: aString).	image storeOn: stream.	stream nextPutAll: self methodEnd.	^ stream contents! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'tk 7/28/2005 04:54'!createStandardPlayer	| aMorph |	aMorph := ImageMorph new image: (ScriptingSystem formAtKey: 'standardPlayer').	associatedMorph addMorphFront: aMorph.	(standardPlayer := aMorph assuredPlayer) renameTo: 'dot' translated.	aMorph setBalloonText: '...'.	self positionStandardPlayer.	^ standardPlayer! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 1/2/2010 15:42'!findAPreferencesPanel: evt	"Locate a Preferences Panel, open it, and bring it to the front.  Create one if necessary"	Smalltalk at: #PreferenceBrowser ifPresent:[:pb|		self findAWindowSatisfying:[:aWindow | aWindow model isKindOf: pb]			orMakeOneUsing:[pb open]	].! !!Presenter methodsFor: 'playerList' stamp: 'sw 3/8/2004 22:09'!hasAnyTextuallyCodedScripts	"Answer whether any uniclasses in the receiver have any textually coded scripts"	self uniclassesAndCounts do:		[:classAndCount | 			classAndCount first scripts do:				[:aScript | aScript isTextuallyCoded ifTrue: [^ true]]].	^ false"ActiveWorld presenter hasAnyTextuallyCodedScripts"! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:42'!stopRunningScriptsFrom: ignored	"Stop running scripts; get all script-control buttons to reflect this"	self stopRunningScripts! !!MenuMorph methodsFor: 'initialization' stamp: 'nice 1/1/2010 21:56'!setDefaultParameters	"change the receiver's appareance parameters"	| colorFromMenu worldColor menuColor |		colorFromMenu := Preferences menuColorFromWorld									and: [Display depth > 4									and: [(worldColor := self currentWorld color) isColor]].	menuColor := colorFromMenu						ifTrue: [worldColor luminance > 0.7										ifTrue: [worldColor mixed: 0.85 with: Color black]										ifFalse: [worldColor mixed: 0.4 with: Color white]]						ifFalse: [Preferences menuColor].	self color: menuColor.	self borderWidth: Preferences menuBorderWidth.	Preferences menuAppearance3d ifTrue: [		self borderStyle: BorderStyle thinGray.		self			addDropShadow;			shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.666);			shadowOffset: 1 @ 1	]	ifFalse: [		| menuBorderColor |		menuBorderColor := colorFromMenu										ifTrue: [worldColor muchDarker]										ifFalse: [Preferences menuBorderColor].		self borderColor: menuBorderColor.	].	self layoutInset: 3.! !!Presenter methodsFor: 'misc' stamp: 'dgd 2/22/2003 19:08'!currentlyViewing: aPlayer 	"Only detects viewers in tabs"	aPlayer ifNil: [^false].	^aPlayer viewerFlapTab notNil! !!PolygonMorph methodsFor: 'editing' stamp: 'nice 1/1/2010 22:06'!addHandles	"Put moving handles at the vertices. Put adding handles at	edge midpoints.	Moving over adjacent vertex and dropping will delete a	vertex. "	| tri |	self removeHandles.	handles := OrderedCollection new.	tri := Array				with: 0 @ -4				with: 4 @ 3				with: -3 @ 3.	vertices		withIndexDo: [:vertPt :vertIndex | 			| handle |			handle := EllipseMorph						newBounds: (Rectangle center: vertPt extent: 8 @ 8)						color: (self handleColorAt: vertIndex) .			handle				on: #mouseMove				send: #dragVertex:event:fromHandle:				to: self				withValue: vertIndex.			handle				on: #mouseUp				send: #dropVertex:event:fromHandle:				to: self				withValue: vertIndex.				handle				on: #click				send: #clickVertex:event:fromHandle:				to: self				withValue: vertIndex.			self addMorph: handle.			handles addLast: handle.			(closed					or: [1 = vertices size						"Give a small polygon a chance to grow. 						-wiz"					or: [vertIndex < vertices size]])				ifTrue: [| newVert |					newVert := PolygonMorph								vertices: (tri										collect: [:p | p + (vertPt													+ (vertices atWrap: vertIndex + 1) // 2)])								color: Color green								borderWidth: 1								borderColor: Color black.					newVert						on: #mouseDown						send: #newVertex:event:fromHandle:						to: self						withValue: vertIndex.					self addMorph: newVert.					handles addLast: newVert]].	self isCurvy		ifTrue: [self updateHandles; layoutChanged].	self changed! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'nice 1/1/2010 21:55'!siblingSplitters	^ self owner submorphsSatisfying: [:each | (each isKindOf: self class) and: [self splitsTopAndBottom = each splitsTopAndBottom and: [each ~= self]]]! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:10'!stepButtonState: newState	"Get all step buttons in my scope to show the correct state"	self allStepButtons do:		[:aButton | aButton state: newState]! !!WorldState methodsFor: 'Nebraska support' stamp: 'ar 10/26/2000 14:08'!remoteServer	^remoteServer! !!Presenter methodsFor: 'viewer' stamp: 'ul 12/12/2009 14:07'!viewMorph: aMorph 	| aPlayer openViewers aViewer aPalette aRect aPoint nominalHeight aFlapTab topItem flapLoc |	Sensor leftShiftDown 		ifFalse: 			[((aPalette := aMorph standardPalette) notNil and: [aPalette isInWorld]) 				ifTrue: [^aPalette viewMorph: aMorph]].	aPlayer := (topItem := aMorph topRendererOrSelf) assuredPlayer.	openViewers := aPlayer allOpenViewers.	aViewer := openViewers isEmpty ifFalse: [ openViewers first ] ifTrue: [ self nascentPartsViewer ].	self cacheSpecs: topItem.	"redo the spec cache once in a while"	"19 sept 2000 - allow flaps in any paste up"	flapLoc := associatedMorph.	"world"	Preferences viewersInFlaps  ifTrue:  [		aViewer owner ifNotNil: [ :f | ^f flapTab showFlap; yourself ].		aViewer setProperty: #noInteriorThumbnail toValue: true.			aViewer initializeFor: aPlayer barHeight: 0.			aViewer enforceTileColorPolicy.			aViewer fullBounds.	"force layout"			"associatedMorph addMorph: aViewer."	"why???"			flapLoc hideViewerFlapsOtherThanFor: aPlayer.			aFlapTab := flapLoc viewerFlapTabFor: topItem.			aFlapTab referent submorphs 				do: [:m | (m isKindOf: Viewer) ifTrue: [m delete]].			aViewer visible: true.			aFlapTab applyThickness: aViewer width + 25.			aFlapTab spanWorld.			aFlapTab showFlap.			aViewer position: aFlapTab referent position.			aFlapTab referent addMorph: aViewer beSticky.	"moved"			flapLoc startSteppingSubmorphsOf: aFlapTab.			flapLoc startSteppingSubmorphsOf: aViewer.			^aFlapTab].	aViewer initializeFor: aPlayer barHeight: 6.	aViewer enforceTileColorPolicy.	aViewer fullBounds.	"force layout"	Preferences automaticViewerPlacement 		ifTrue: 			[aPoint := aMorph bounds right 						@ (aMorph center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).			aRect := (aPoint extent: aViewer width @ nominalHeight) 						translatedToBeWithin: flapLoc bounds.			aViewer position: aRect topLeft.			aViewer visible: true.			associatedMorph addMorph: aViewer.			flapLoc startSteppingSubmorphsOf: aViewer.			"it's already in the world, somewhat coincidentally"			^aViewer].	aMorph primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!WorldState methodsFor: 'Nebraska support' stamp: 'ar 10/26/2000 14:17'!removeRemoteCanvas: c	self canvas: nil.	"force withdrawal of remote from MultiCanvas"! !!Presenter methodsFor: 'tile support' stamp: 'sw 4/25/1998 13:28'!typeForConstant: anObject	^ anObject basicType! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:43'!startRunningScriptsFrom: ignored	"Start running all scripts.  Get all script-control buttons to show the right thing."	self startRunningScripts! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 6/29/1998 17:23'!stopUp: dummy with: theButton	self flushPlayerListCache.  "catch guys not in cache but who're running"	self stopRunningScripts! !!Presenter methodsFor: 'viewer' stamp: 'ul 12/12/2009 14:07'!updateViewer: aViewer forceToShow: aCategorySymbol	"Update the given viewer to make sure it is in step with various possible changes in the outside world, and when reshowing it be sure it shows the given category"	| aPlayer aPosition newViewer oldOwner wasSticky barHeight itsVocabulary aCategory categoryInfo restrictedIndex |	aCategory := aCategorySymbol ifNotNil: [aViewer currentVocabulary translatedWordingFor: aCategorySymbol].	categoryInfo := aViewer categoryMorphs  asOrderedCollection collect:		[:aMorph | aMorph categoryRestorationInfo].	itsVocabulary := aViewer currentVocabulary.	aCategory ifNotNil: [(categoryInfo includes: aCategorySymbol) ifFalse: [categoryInfo addFirst: aCategorySymbol]].	aPlayer := aViewer scriptedPlayer.	aPosition := aViewer position.	wasSticky := aViewer isSticky.	newViewer := aViewer species new visible: false.	(aViewer isMemberOf: KedamaStandardViewer)		ifTrue: [restrictedIndex := aViewer restrictedIndex].	barHeight := aViewer submorphs first listDirection == #topToBottom		ifTrue:			[aViewer submorphs first submorphs first height]		ifFalse:			[0].	Preferences viewersInFlaps ifTrue:		[newViewer setProperty: #noInteriorThumbnail toValue: true].	newViewer rawVocabulary: itsVocabulary.	newViewer limitClass: aViewer limitClass.	newViewer initializeFor: aPlayer barHeight: barHeight includeDismissButton: aViewer hasDismissButton showCategories: categoryInfo.	(newViewer isMemberOf: KedamaStandardViewer)		ifTrue: [			newViewer providePossibleRestrictedView: 0.			newViewer providePossibleRestrictedView: restrictedIndex].	wasSticky ifTrue: [newViewer beSticky].	oldOwner := aViewer owner.	oldOwner ifNotNil:		[oldOwner replaceSubmorph: aViewer by: newViewer].		"It has happened that old readouts are still on steplist.  We may see again!!"	newViewer position: aPosition.	newViewer enforceTileColorPolicy.	newViewer visible: true.	newViewer world ifNotNil: [:aWorld | aWorld startSteppingSubmorphsOf: newViewer].	newViewer layoutChanged! !!Presenter methodsFor: 'playerList' stamp: 'sw 6/29/1998 17:17'!flushPlayerListCache	playerList := nil! !!Presenter methodsFor: 'viewer' stamp: 'sw 6/20/2001 13:12'!viewObjectDirectly: anObject	"Open up and return a viewer on the given object"	|  aViewer aRect aPoint nominalHeight aFlapTab flapLoc |	associatedMorph addMorph: (aViewer := self nascentPartsViewerFor: anObject).	flapLoc := associatedMorph "world".	Preferences viewersInFlaps ifTrue:		[aViewer setProperty: #noInteriorThumbnail toValue: true.		aViewer initializeFor: anObject barHeight: 0.		aViewer enforceTileColorPolicy.		flapLoc hideViewerFlapsOtherThanFor: anObject.		aFlapTab := flapLoc viewerFlapTabFor: anObject.		aFlapTab referent submorphs do: 			[:m | (m isKindOf: Viewer) ifTrue: [m delete]].		aFlapTab referent addMorph: aViewer beSticky.		aViewer visible: true.		aFlapTab applyThickness: aViewer width + 25.		aFlapTab spanWorld.		aFlapTab showFlap. 		aViewer position: aFlapTab referent position.		flapLoc startSteppingSubmorphsOf: aFlapTab.		flapLoc startSteppingSubmorphsOf: aViewer.		^ aFlapTab].		"Caution: the branch below is historical and has not been used for a long time, though if you set the #viewersInFlaps preference to false you'd hit it.  Not at all recently maintained."	aViewer initializeFor: anObject barHeight: 6.	aViewer enforceTileColorPolicy.	Preferences automaticViewerPlacement ifTrue:		[aPoint := anObject bounds right @ 			(anObject center y - ((nominalHeight := aViewer initialHeightToAllow) // 2)).		aRect := (aPoint extent: (aViewer width @ nominalHeight)) translatedToBeWithin: flapLoc bounds.		aViewer position: aRect topLeft.		aViewer visible: true.		flapLoc startSteppingSubmorphsOf: aViewer.		"it's already in the world, somewhat coincidentally"		^ aViewer].	anObject primaryHand attachMorph: (aViewer visible: true).	^aViewer! !!Morph methodsFor: 'menu' stamp: 'nice 1/1/2010 22:05'!addYellowButtonMenuItemsTo: aMenu event: evt 	"Populate aMenu with appropriate menu items for a  	yellow-button (context menu) click."	aMenu defaultTarget: self.	""	Preferences noviceMode		ifFalse: [aMenu addStayUpItem].	""	self addModelYellowButtonItemsTo: aMenu event: evt.	""	Preferences generalizedYellowButtonMenu		ifFalse: [^ self].	""	Preferences cmdGesturesEnabled		ifTrue: [""			aMenu addLine.			aMenu add: 'inspect' translated action: #inspect].	""	aMenu addLine.	self world selectedObject == self		ifTrue: [aMenu add: 'deselect' translated action: #removeHalo]		ifFalse: [aMenu add: 'select' translated action: #addHalo].	""	(self isWorldMorph			or: [self mustBeBackmost			or: [self wantsToBeTopmost]])		ifFalse: [""			aMenu addLine.			aMenu add: 'send to back' translated action: #goBehind.			aMenu add: 'bring to front' translated action: #comeToFront.			self addEmbeddingMenuItemsTo: aMenu hand: evt hand].	""	self isWorldMorph		ifFalse: [""	Smalltalk		at: #NCAAConnectorMorph		ifPresent: [:connectorClass | 			aMenu addLine.			aMenu add: 'connect to' translated action: #startWiring.			aMenu addLine].	""			self isFullOnScreen				ifFalse: [aMenu add: 'move onscreen' translated action: #goHome]].	""	Preferences noviceMode		ifFalse: [""			self addLayoutMenuItems: aMenu hand: evt hand.			(owner notNil					and: [owner isTextMorph])				ifTrue: [self addTextAnchorMenuItems: aMenu hand: evt hand]].	""	self isWorldMorph		ifFalse: [""			aMenu addLine.			self addToggleItemsToHaloMenu: aMenu].	""	aMenu addLine.	self isWorldMorph		ifFalse: [aMenu add: 'copy to paste buffer' translated action: #copyToPasteBuffer:].	(self allStringsAfter: nil) isEmpty		ifFalse: [aMenu add: 'copy text' translated action: #clipText].	""	self addExportMenuItems: aMenu hand: evt hand.	""	(Preferences noviceMode not			and: [self isWorldMorph not])		ifTrue: [""			aMenu addLine.			aMenu add: 'adhere to edge...' translated action: #adhereToEdge].	""	self addCustomMenuItems: aMenu hand: evt hand! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:08'!stopButtonState: newState	"Get all stop buttons in my scope to show the correct state"	self allStopButtons do:		[:aButton | aButton state: newState]! !!Presenter class methodsFor: 'accessing' stamp: 'ar 1/3/2010 18:10'!defaultPresenterClass: aPresenterClass	"The default presenter class to use"	DefaultPresenterClass := aPresenterClass! !!Presenter methodsFor: 'misc' stamp: 'sw 6/30/1999 20:31'!morph: aMorph droppedIntoPasteUpMorph: aPasteUpMorph	aPasteUpMorph automaticViewing ifTrue:		[aMorph isCandidateForAutomaticViewing ifTrue:			[self viewMorph: aMorph]]! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 1/2/2010 15:19'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu := MenuMorph new defaultTarget: self.	menu commandKeyHandler: self.	self colorForDebugging: menu.	menu addStayUpItem.	self makeConvenient: menu.	Smalltalk at: #ServiceGUI ifPresent:[:sgui|		sgui worldMenu: menu.		sgui onlyServices ifTrue: [^ menu].	].	self addProjectEntries: menu.	myWorld addUndoItemsTo: menu.	self addRestoreDisplay: menu.	self addUtilities: menu.	self addObjectsAndTools: menu.	self addPrintAndDebug: menu.	self addSaveAndQuit: menu.	^ menu! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:06'!stepStillDown: dummy with: theButton	"The step button is still down; get temporary button feedback right and step all and then get all button feedback right again"	self stepButtonState: #pressed.	self stopButtonState: #off.	associatedMorph stepAll.	associatedMorph world displayWorld.	self stepButtonState: #off.	self stopButtonState: #on! !!NewParagraph methodsFor: 'private' stamp: 'ul 1/3/2010 06:50'!lastLine	^lines last! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'nice 1/1/2010 21:53'!setDefaultParameters	"change the receiver's appareance parameters"	| colorFromMenu worldColor menuColor |	colorFromMenu := Preferences menuColorFromWorld									and: [Display depth > 4									and: [(worldColor := self currentWorld color) isColor]].	menuColor := colorFromMenu						ifTrue: [worldColor luminance > 0.7										ifTrue: [worldColor mixed: 0.85 with: Color black]										ifFalse: [worldColor mixed: 0.4 with: Color white]]						ifFalse: [Preferences menuColor].	self color: menuColor.	self borderWidth: Preferences menuBorderWidth.	Preferences menuAppearance3d ifTrue: [		self borderStyle: BorderStyle thinGray.		self			addDropShadow;			shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.666);			shadowOffset: 1 @ 1	]	ifFalse: [		| menuBorderColor |		menuBorderColor := colorFromMenu										ifTrue: [worldColor muchDarker]										ifFalse: [Preferences menuBorderColor].		self borderColor: menuBorderColor.	].	self layoutInset: 3.! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:18'!allStopButtons	"Answer a list of all script-controlling Stop buttons within my scope"	^ associatedMorph allMorphs select:		[:aMorph | (aMorph isKindOf: ThreePhaseButtonMorph) and:			[aMorph actionSelector == #stopUp:with:]]	"ActiveWorld presenter allStopButtons"! !!Presenter methodsFor: 'viewer' stamp: 'sw 12/28/1998 22:34'!updateViewer: aViewer	self updateViewer: aViewer forceToShow: nil! !!WorldState methodsFor: 'Nebraska support' stamp: 'ar 10/26/2000 14:15'!remoteCanvasesDo: aBlock	remoteServer ifNil:[^self].	^remoteServer clients do:[:client| aBlock value: client canvas]! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:56'!actorState	"answer the redeiver's actorState"	^ actorState ! !!Presenter methodsFor: 'playerList' stamp: 'yo 7/2/2004 19:45'!allKnownScriptSelectors	"Answer a list of all the selectors implemented by any user-scripted objected within the scope of the receiver"	| aSet allUniclasses |	aSet := Set with: ('script' translated , '1') asSymbol.	allUniclasses := (self presenter allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownScriptSelectors"! !!Presenter methodsFor: 'playerList' stamp: 'sw 5/1/2005 00:22'!allCurrentlyTickingScriptInstantiations	"Answer a list of ScriptInstantiation objects representing all the scripts within the scope of the receiver which are currently ticking."	^ Array streamContents:		[:aStream | 			self allExtantPlayers do:				[:aPlayer | aPlayer instantiatedUserScriptsDo:					[:aScriptInstantiation |						aScriptInstantiation status == #ticking ifTrue:							[aStream nextPut: aScriptInstantiation]]]]! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:53'!actorState: anActorState "change the receiver's actorState"	actorState := anActorState! !!WorldState methodsFor: 'Nebraska support' stamp: 'sd 11/20/2005 21:25'!remoteServer: aNebraskaServer	remoteServer ifNotNil:[remoteServer destroy].	remoteServer := aNebraskaServer.	self canvas: nil.! !!Presenter methodsFor: 'playerList' stamp: 'sw 12/19/2003 23:39'!allKnownUnaryScriptSelectors	"Answer a list of all the unary selectors implemented by any user-scripted objected within the scope of the receiver; include #emptyScript as a bail-out"	| aSet allUniclasses |	aSet := Set with: #emptyScript.	allUniclasses := (self allPlayersWithUniclasses collect:		[:aPlayer | aPlayer class]) asSet.	allUniclasses do:		[:aUniclass | aSet addAll: aUniclass namedUnaryTileScriptSelectors].	^ aSet asSortedArray"ActiveWorld presenter allKnownUnaryScriptSelectors"! !!Presenter methodsFor: 'playerList' stamp: 'sw 1/30/2001 23:07'!toolToViewScriptInstantiations	"Open a tool which shows, and allows the user to change the status of, all the instantiations of all the user-written scripts in the world"	AllScriptsTool launchAllScriptsToolFor: self	"self currentWorld presenter toolToViewScriptInstantiations"! !!Presenter methodsFor: 'playerList' stamp: 'sw 8/2/2004 17:24'!browseAllScriptsTextually	"Open a method-list browser on all the scripts in the project"	| aList aMethodList |	(aList := self uniclassesAndCounts) size == 0 ifTrue: [^ self inform: 'there are no scripted players'].	aMethodList := OrderedCollection new.	aList do:		[:aPair | aPair first addMethodReferencesTo: aMethodList].	aMethodList size > 0 ifFalse: [^ self inform: 'there are no scripts in this project!!'].		SystemNavigation new 		browseMessageList: aMethodList 		name: 'All scripts in this project' 		autoSelect: nil"ActiveWorld presenter browseAllScriptsTextually"! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 6/16/1998 16:17'!standardPalette: aPalette	standardPalette := aPalette! !!Presenter methodsFor: 'tile support' stamp: 'gm 2/22/2003 14:53'!constantTile: anObject 	"Answer a constant tile that represents the object"	(anObject isColor) 		ifTrue: 			[^ColorTileMorph new typeColor: (ScriptingSystem colorForType: #Color)].	^anObject newTileMorphRepresentative 		typeColor: (ScriptingSystem colorForType: (self typeForConstant: anObject))! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 4/21/1998 22:57'!ownStandardPalette	^ standardPalette! !!MorphListItemWrapper methodsFor: 'accessing' stamp: 'nice 1/1/2010 22:12'!contents	"Answer the receiver's contents"	| tentative submorphs |	tentative := item submorphs				collect: [:each | each renderedMorph].	submorphs := Preferences noviceMode				ifTrue: [					tentative						reject: [:each |							each isSystemWindow								or: [each isDockingBar								or: [(each isKindOf: HaloMorph)								or: [(each hasProperty: #morphHierarchy)								or: [each isFlapOrTab								or: [each isObjectsTool]]]]]]]				ifFalse: [					tentative						reject: [:each | each isKindOf: HaloMorph]].	^ submorphs		collect: [:each | self class with: each]! !!Presenter methodsFor: 'playerList' stamp: 'sw 7/28/2004 21:00'!reinvigoratePlayersTool: aPlayersTool 	"Rebuild the contents of the Players tool"	| firstTwo oldList newList rowsForPlayers |	firstTwo := {aPlayersTool submorphs first.  aPlayersTool submorphs second}.	oldList := (aPlayersTool submorphs copyFrom: 3 to: aPlayersTool submorphs size) collect:		[:aRow |			aRow playerRepresented].	self flushPlayerListCache.	newList := self allExtantPlayers.	oldList asSet = newList asSet		ifFalse:			[aPlayersTool removeAllMorphs; addAllMorphs: firstTwo.			rowsForPlayers := newList collect:				[:aPlayer |  aPlayer entryForPlayersTool: aPlayersTool].			aPlayersTool addAllMorphs: rowsForPlayers ]! !!MenuMorph methodsFor: 'drawing' stamp: 'nice 1/1/2010 21:50'!drawOn: aCanvas 	"Draw the menu. Add keyboard-focus feedback if appropriate"	super drawOn: aCanvas.	(ActiveHand notNil			and: [ActiveHand keyboardFocus == self			and: [self rootMenu hasProperty: #hasUsedKeyboard]])		ifTrue: [			aCanvas				frameAndFillRectangle: self innerBounds				fillColor: Color transparent				borderWidth: Preferences menuBorderWidth				borderColor: Preferences keyboardFocusColor		].! !!Presenter methodsFor: 'tile support' stamp: 'sw 9/27/2001 17:43'!valueTiles	"Answer some constant-valued tiles.  This dates back to very early etoy work in 1997, and presently has no senders"	| tiles |	tiles := OrderedCollection new.	tiles add: (5 newTileMorphRepresentative typeColor: (ScriptingSystem colorForType: #Number)).	tiles add: (ColorTileMorph new typeColor: (ScriptingSystem colorForType: #Color)).	tiles add: (TileMorph new typeColor: (ScriptingSystem colorForType: #Number);			setExpression: '(180 atRandom)'			label: 'random').	tiles add: RandomNumberTile new.	^ tiles! !!Presenter methodsFor: 'playerList' stamp: 'sw 11/14/2001 00:31'!reinvigorateAllScriptsTool: anAllScriptsTool 	"Rebuild the contents of an All Scripts tool"	| showingOnlyActiveScripts candidateList firstTwo oldList allExtantPlayers newList morphList |	showingOnlyActiveScripts := anAllScriptsTool showingOnlyActiveScripts.	self flushPlayerListCache.	"needed? Probably to pick up on programmatical script-status control only"	firstTwo := {anAllScriptsTool submorphs first.  anAllScriptsTool submorphs second}.	oldList := (anAllScriptsTool submorphs copyFrom: 3 to: anAllScriptsTool submorphs size) collect:		[:aRow |			(aRow findA: UpdatingSimpleButtonMorph) target].	allExtantPlayers := self allExtantPlayers.	anAllScriptsTool showingAllInstances "take all instances of all classes"		ifTrue:			[candidateList := allExtantPlayers]  		ifFalse:  "include only one exemplar per uniclass.  Try to get one that has some qualifying scripts"			[candidateList := Set new.			allExtantPlayers do:				[:aPlayer |					(candidateList detect: [:plyr | plyr isMemberOf:  aPlayer class] ifNone: [nil]) ifNil:						[aPlayer instantiatedUserScriptsDo: [:aScriptInstantiation |							(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) 								ifTrue:									[candidateList add: aPlayer]]]]].	newList := OrderedCollection new.	candidateList do:		[:aPlayer | aPlayer instantiatedUserScriptsDo:			[:aScriptInstantiation |				(showingOnlyActiveScripts not or: [aScriptInstantiation pausedOrTicking]) ifTrue:					[newList add: aScriptInstantiation]]].	oldList asSet = newList asSet		ifFalse:			[anAllScriptsTool removeAllMorphs; addAllMorphs: firstTwo.			morphList := newList collect:				[:aScriptInstantiation |  aScriptInstantiation statusControlRowIn: anAllScriptsTool].			anAllScriptsTool addAllMorphs: morphList.			newList do:				[:aScriptInstantiation | aScriptInstantiation updateAllStatusMorphs]]! !!Presenter methodsFor: 'playerList' stamp: 'sw 1/12/2001 18:10'!uniclassesAndCounts	"Answer a list of all players known to the receiver that have uniclasses"	^ (self allPlayersWithUniclasses collect: [:aPlayer | aPlayer class]) asSet asArray collect:		[:aClass | Array			with:	aClass			with:	aClass instanceCount]	"self currentWorld presenter uniclassesAndCounts"! !!SystemProgressMorph methodsFor: 'initialization' stamp: 'nice 1/1/2010 21:56'!setDefaultParameters	"change the receiver's appareance parameters"	| colorFromMenu worldColor menuColor |	colorFromMenu := Preferences menuColorFromWorld									and: [Display depth > 4									and: [(worldColor := self currentWorld color) isColor]].	menuColor := colorFromMenu						ifTrue: [worldColor luminance > 0.7										ifTrue: [worldColor mixed: 0.85 with: Color black]										ifFalse: [worldColor mixed: 0.4 with: Color white]]						ifFalse: [Preferences menuColor].	self color: menuColor.		Preferences roundedMenuCorners		ifTrue: [self useRoundedCorners].	self borderWidth: Preferences menuBorderWidth.	Preferences menuAppearance3d ifTrue: [		self borderStyle: BorderStyle thinGray.		self			addDropShadow;			shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.666);			shadowOffset: 1 @ 1	]	ifFalse: [		| menuBorderColor |		menuBorderColor := colorFromMenu										ifTrue: [worldColor muchDarker]										ifFalse: [Preferences menuBorderColor].		self borderColor: menuBorderColor.	].	self		updateColor: self		color: self color		intensity: 1.! !!WorldState methodsFor: 'Nebraska support' stamp: 'ar 10/26/2000 14:11'!addRemoteCanvas: c	self canvas: nil. "force recomputation"! !!Presenter class methodsFor: 'accessing' stamp: 'ar 1/3/2010 18:10'!defaultPresenterClass	"The default presenter class to use"	^DefaultPresenterClass ifNil:[self]! !!Presenter methodsFor: 'tile support' stamp: 'dgd 2/21/2003 22:35'!phraseForReceiver: rcvr op: op arg: arg resultType: resultType 	"Answer a PhraseTileMorph affiliated with the given receiver, initialized to hold the given operator, argument, and result type"	| m argTile rcvrTile |	arg isNil 		ifTrue: 			[m := PhraseTileMorph new 						setOperator: op						type: resultType						rcvrType: (self typeForConstant: rcvr)]		ifFalse: 			[m := PhraseTileMorph new 						setOperator: op						type: resultType						rcvrType: (self typeForConstant: rcvr)						argType: (self typeForConstant: arg).			argTile := self constantTile: arg.			argTile position: m lastSubmorph position.			m lastSubmorph addMorph: argTile].	rcvrTile := self constantTile: rcvr.	"	TilePadMorph makeReceiverColorOfResultType ifTrue: [rcvrTile color: m color]."	rcvrTile position: m firstSubmorph position.	m firstSubmorph addMorph: rcvrTile.	m vResizing: #shrinkWrap.	^m! !!Presenter methodsFor: 'misc' stamp: 'sw 8/28/2002 23:07'!drawingJustCompleted: aSketchMorph	"The user just finished drawing.  Now maybe put up a viewer"	| aWorld |	self flushPlayerListCache.  "Because a new drawing already created one, thus obviating #assuredPlayer kicking in with its invalidation"	aWorld := associatedMorph world.	(aWorld hasProperty: #automaticFlapViewing)		ifTrue:			[^ aWorld presenter viewMorph: aSketchMorph].	(aSketchMorph pasteUpMorph hasProperty: #automaticViewing)		ifTrue:			[self viewMorph: aSketchMorph]! !!PasteUpMorph methodsFor: 'event handling' stamp: 'nice 1/1/2010 21:54'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph handHadHalos |	(Preferences generalizedYellowButtonMenu			and: [evt yellowButtonPressed])		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	grabbedMorph := self morphToGrab: evt.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		self isPartsBin ifFalse:[^evt hand grabMorph: grabbedMorph].		grabbedMorph := grabbedMorph partRepresented duplicate.		grabbedMorph restoreSuspendedEventHandler.		(grabbedMorph fullBounds containsPoint: evt position) 			ifFalse:[grabbedMorph position: evt position].		"Note: grabbedMorph is ownerless after duplicate so use #grabMorph:from: instead"		^ evt hand grabMorph: grabbedMorph from: self].	(super handlesMouseDown: evt)		ifTrue:[^super mouseDown: evt].	handHadHalos := evt hand halo notNil.	evt hand removeHalo. "shake off halos"	evt hand releaseKeyboardFocus. "shake of keyboard foci"	self submorphs		select:[:each | each hasProperty: #morphHierarchy]		thenDo:[:each | each delete].	Preferences noviceMode		ifTrue:[			self submorphs				select:[:each | (each isKindOf: MenuMorph) and:[each stayUp not]]				thenDo:[:each | each delete].		].	(evt shiftPressed not			and:[ self isWorldMorph not 			and:[ self wantsEasySelection not ]])	ifTrue:[		"explicitly ignore the event if we're not the world and we'll not select,		so that we could be picked up if need be"		evt wasHandled: false.		^ self.	].	( evt shiftPressed or: [ self wantsEasySelection ] ) ifTrue:[		"We'll select on drag, let's decide what to do on click"		| clickSelector |		clickSelector := nil.		evt shiftPressed ifTrue:[			clickSelector := #findWindow:.		]		ifFalse:[			self isWorldMorph ifTrue:[				clickSelector := handHadHalos										ifTrue: [ #delayedInvokeWorldMenu: ]										ifFalse: [ #invokeWorldMenu: ]			]		].		evt hand 				waitForClicksOrDrag: self 				event: evt 				selectors: { clickSelector. nil. nil. #dragThroughOnDesktop: }				threshold: 5.	]	ifFalse:[		"We wont select, just bring world menu if I'm the world"		self isWorldMorph ifTrue:[			handHadHalos				ifTrue: [ self delayedInvokeWorldMenu: evt ]				ifFalse: [ self invokeWorldMenu: evt ]		]	].! !!Presenter methodsFor: 'tile support' stamp: 'nice 12/26/2009 20:32'!booleanTiles	"Answer some boolean-valued tiles.  This dates back to very early etoy work in 1997, and presently has no sent senders"	| list |	list := #(#(0 #< 1) #(0 #<= 1) #(0 #= 1) #(0 #~= 1) #(0 #> 1) #(0 #>= 1)).	list := list asOrderedCollection collect: 					[:entry | 					| rcvr op arg |					rcvr := entry first.					op := (entry second) asSymbol.					arg := entry last.					self 						phraseForReceiver: rcvr						op: op						arg: arg						resultType: #Boolean].	list add: (self 				phraseForReceiver: Color red				op: #=				arg: Color red				resultType: #Boolean).	^list	"copyWith: CompoundTileMorph new"! !!Presenter methodsFor: 'viewer' stamp: 'sw 1/17/1999 21:51'!nascentPartsViewer	^ StandardViewer new! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 1/20/2004 20:08'!positionStandardPlayer	"Put the standard player slightly off-screen"	standardPlayer ifNotNil:		[standardPlayer costume position: (associatedMorph topLeft - (13@0))]! !!Presenter methodsFor: 'printing' stamp: 'dtl 8/29/2009 13:05'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' (', self identityHash printString, ')'! !!Presenter methodsFor: 'standardPlayer etc' stamp: 'sw 6/17/1998 16:05'!standardPlayer	standardPlayer ifNil:		[self createStandardPlayer].	standardPlayer costume isInWorld ifFalse: [associatedMorph addMorphNearBack: standardPlayer costume].	^ standardPlayer! !!Presenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph	^ associatedMorph! !!WorldState methodsFor: 'Nebraska support' stamp: 'ar 10/26/2000 14:17'!assuredRemoteCanvas	| newCanvas |	(self canvas notNil) ifTrue: [ ^self canvas ].	newCanvas := MultiCanvas new.	newCanvas depth: 32.	newCanvas extent: viewBox extent.	self remoteCanvasesDo: [ :c | newCanvas addCanvas: c ].	newCanvas addCanvas: Display getCanvas.	"newCanvas := CachingCanvas on: newCanvas."	self canvas: newCanvas.	^newCanvas! !!Presenter methodsFor: 'scripting' stamp: 'ar 3/17/2001 20:14'!adaptedToWorld: aWorld	"If I refer to a world or a hand, return the corresponding items in the new world."	^aWorld presenter! !!Presenter methodsFor: 'misc' stamp: 'sw 4/23/1998 18:47'!tempCommand	Transcript cr; show: '#tempCommand invoked for Presenter'! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:19'!allStepButtons	"Answer a list of all the script-controlling Step buttons within my scope"	^ associatedMorph allMorphs select:		[:aMorph | (aMorph isKindOf: ThreePhaseButtonMorph) and:			[aMorph actionSelector == #stepStillDown:with:]]	"ActiveWorld presenter allStepButtons"! !!Presenter methodsFor: 'viewer' stamp: 'sw 2/19/2001 15:41'!cacheSpecs: aMorph	"For SyntaxMorph's type checking, cache the list of all viewer command specifications."	aMorph world ifNil: [^ true].	Preferences universalTiles ifFalse: [^ true].	Preferences eToyFriendly ifFalse: [^ true].	"not checking"	(Project current projectParameterAt: #fullCheck ifAbsent: [false]) 		ifFalse: [^ true].	"not checking"	SyntaxMorph initialize.! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:43'!startRunningScripts	"Start running scripts; get stop-step-go buttons to show the right thing"	self stopButtonState: #off.	self stepButtonState: #off.	self goButtonState: #on.	associatedMorph startRunningAll.	"associatedMorph borderColor: Preferences borderColorWhenRunning."	ThumbnailMorph recursionReset.  "needs to be done once in a while (<- tk note from 1997)"! !!Presenter methodsFor: 'viewer' stamp: 'sw 6/20/2001 12:37'!viewObject: anObject	"Open up and return a viewer on the given object.  If the object is a Morph, open a viewer on its associated Player"	anObject isMorph		ifTrue:			[self viewMorph: anObject]  "historic morph/player implementation"		ifFalse:			[self viewObjectDirectly: anObject]! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 5/6/1998 10:20'!stepDown: evt with: aMorph	self stopRunningScripts! !!Presenter methodsFor: 'button creation' stamp: 'sw 3/7/1999 00:52'!addTrashCan	| aPosition aCan |	(aCan := associatedMorph findA: TrashCanMorph) ifNotNil: [^ aCan].	aCan := TrashCanMorph newSticky.	aPosition := associatedMorph positionNear: (associatedMorph bottomRight - aCan extent) forExtent: aCan extent adjustmentSuggestion:  (-10 @ 0).	aCan position: aPosition.	associatedMorph addMorph: aCan.	aCan startStepping.	aCan setToAdhereToEdge: #bottomRight.	^ aCan! !!Presenter methodsFor: 'palette & parts bin' stamp: 'sw 2/12/2001 22:02'!systemQueryPhraseWithActionString: anActionString labelled: aLabel	"Answer a SystemQueryPhrase with the given action string and label"	| aTile aPhrase |		aPhrase := SystemQueryPhrase new.	aTile := BooleanTile new.	aTile setExpression: anActionString label: aLabel.	aPhrase addMorph: aTile.	aPhrase enforceTileColorPolicy.	^ aPhrase! !!WorldState methodsFor: 'Nebraska support' stamp: 'sd 11/20/2005 21:25'!releaseRemoteServer	"My server has been transferred to some other world. Release pending references"	remoteServer := nil.	self canvas: nil.! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:08'!goButtonState: newState	"Get all go buttons in my scope to show the correct state"	self allGoButtons do:		[:aButton | aButton state: newState]! !!Presenter methodsFor: 'viewer' stamp: 'yo 3/30/2005 11:21'!nascentPartsViewerFor: aViewee	"Create a new, naked Viewer object for viewing aViewee.  Give it a vocabulary if either the viewee insists on one or if the project insists on one."	| aViewer aVocab |	(aViewee isKindOf: KedamaExamplerPlayer) ifTrue: [^ KedamaStandardViewer new].	aViewer := StandardViewer new.	(aVocab := aViewee vocabularyDemanded)		ifNotNil:			[aViewer useVocabulary: aVocab]		ifNil:			[(aVocab := associatedMorph currentVocabularyFor: aViewee) ifNotNil:				[aViewer useVocabulary: aVocab]].		"If the viewee does not *demand* a special kind of Viewer, and if the project has not specified a preferred vocabulary, then the system defaults will kick in later"	^ aViewer! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 18:42'!stopRunningScripts	"Put all ticking scripts within my scope into paused mode.  Get any scripting-control buttons to show the correct state"	self stopButtonState: #on.	self stepButtonState: #off.	self goButtonState: #off.	associatedMorph stopRunningAll.	"associatedMorph borderColor: Preferences borderColorWhenStopped"! !!Presenter methodsFor: 'intialize' stamp: 'nice 12/26/2009 20:31'!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.  <-- this note dates from 4/21/99Call #flushPlayerListCache; to force recomputation."	| fullList |	playerList ifNotNil:		[^ playerList].	fullList := associatedMorph allMorphs select: 		[:m | m player ~~ nil] thenCollect: [:m | m player].	fullList copy do:		[:aPlayer |			aPlayer class scripts do:				[:aScript |  aScript isTextuallyCoded ifFalse:					[aScript currentScriptEditor ifNotNil: [:ed |						| objectsReferredToByTiles |						objectsReferredToByTiles := ed allMorphs							select:								[:aMorph | (aMorph isKindOf: TileMorph) and: [aMorph type == #objRef]]							thenCollect:								[:aMorph | aMorph actualObject].						fullList addAll: objectsReferredToByTiles]]]].	^ playerList := (fullList asSet asSortedCollection:			[:a :b | a externalName < b externalName]) asArray! !!Presenter methodsFor: 'access' stamp: 'sw 4/17/1998 20:07'!associatedMorph: aMorph	associatedMorph := aMorph! !!HandMorph methodsFor: 'private events' stamp: 'ar 1/2/2010 15:22'!sendKeyboardEvent: anEvent 	"Send the event to the morph currently holding the focus, or if none to	the owner of the hand."	^ self		sendEvent: anEvent		focus: self keyboardFocus		clear: [self keyboardFocus: nil]! !!Presenter methodsFor: 'misc' stamp: 'sw 6/17/1998 10:16'!standardPlayfield: aPlayfield	standardPlayfield := aPlayfield! !!TheWorldMenu methodsFor: 'commands' stamp: 'ar 1/2/2010 15:42'!openPreferencesBrowser	"Open a preferences browser"	^Smalltalk at: #PreferenceBrowser ifPresent:[:pb| pb open].! !!TheWorldMainDockingBar methodsFor: 'submenu - tools' stamp: 'ar 1/2/2010 15:42'!preferenceBrowserMenuItemOn: menu	Smalltalk at: #PreferenceBrowser ifPresent:[:pb|		menu addItem: [ :item |			item				contents: 'Preferences' translated;				help: 'Open a Preferences Browser' translated;				icon: (self colorIcon: pb basicNew defaultBackgroundColor);				target: pb;				selector: #open ]	].! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 11/13/2001 14:17'!allGoButtons	"Answer a list of all script-controlling Go buttons within my scope"	^ associatedMorph allMorphs select:		[:aMorph | (aMorph isKindOf: ThreePhaseButtonMorph) and:			[aMorph actionSelector == #goUp:with:]]	"ActiveWorld presenter allGoButtons"! !!Presenter methodsFor: 'playerList' stamp: 'sw 1/12/2001 16:58'!allPlayersWithUniclasses	"Answer a list of all players known to the receiver that have uniclasses"	^ self allExtantPlayers select: [:p | p belongsToUniClass]! !!MenuIcons class methodsFor: 'import/export' stamp: 'nice 1/1/2010 21:43'!importIconNamed: aString	"self importIconNamed: 'Icons16:appearanceIcon'"		| writer image stream |	writer := GIFReadWriter on: (FileStream fileNamed: aString, '.gif').	image := [ writer nextImage]			ensure: [writer close].	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString ; cr.	stream nextPutAll: (self methodStart: aString).	image storeOn: stream.	stream nextPutAll: self methodEnd.	MenuIcons class compile: stream contents classified: 'accessing - icons' notifying: nil.	^ stream contents! !!Presenter methodsFor: 'access' stamp: 'sw 4/22/1998 20:05'!world	^ associatedMorph world! !!Presenter methodsFor: 'stop-step-go buttons' stamp: 'sw 10/30/1998 15:36'!goUp: evt with: aMorph	self startRunningScripts! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:53'!player: anObject 	"change the receiver's player"	player := anObject ! !SketchMorph removeSelector: #basicType!ImageMorph removeSelector: #basicType!TextMorph removeSelector: #basicType!