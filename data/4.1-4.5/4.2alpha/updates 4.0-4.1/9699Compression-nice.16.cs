"Change Set:		9699Compression-nice.16Compression-nice.16:Generalize stream protocol #readInto:startingAt:count:It's the same as #next:into:startingAt: but avoid a copy and rather answer number of elements read.Compression-nice.15:Reverse the logic and avoid a copy:- let next:putAll:startingAt: do the real work- let nextPutAll: call next:putAll:startingAt:This costs an additional send in nextPutAll: but is much better."!!DeflateStream methodsFor: 'accessing' stamp: 'nice 12/7/2009 09:44'!nextPutAll: aCollection	^self next: aCollection size putAll: aCollection startingAt: 1! !!InflateStream methodsFor: 'accessing' stamp: 'nice 3/16/2010 23:02'!readInto: buffer startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	| c numRead count |	numRead := 0.	["Force decompression if necessary"	(c := self next) == nil 		ifTrue: [^numRead].	"Store the first value which provoked decompression"	buffer at: startIndex + numRead put: c.	numRead := numRead + 1.	"After collection has been filled copy as many objects as possible"	count := (readLimit - position) min: (n - numRead).	buffer 		replaceFrom: startIndex + numRead 		to: startIndex + numRead + count - 1 		with: collection 		startingAt: position+1.	position := position + count.	numRead := numRead + count.	numRead = n] whileFalse.	^n! !!DeflateStream methodsFor: 'accessing' stamp: 'nice 12/7/2009 09:37'!next: bytesCount putAll: aCollection startingAt: startIndex	| start count max |	aCollection species = collection species		ifFalse:[			aCollection do:[:ch| self nextPut: ch].			^aCollection].	start := startIndex.	count := bytesCount.	[count = 0] whileFalse:[		position = writeLimit ifTrue:[self deflateBlock].		max := writeLimit - position.		max > count ifTrue:[max := count].		collection replaceFrom: position+1			to: position+max			with: aCollection			startingAt: start.		start := start + max.		count := count - max.		position := position + max].	^aCollection! !