"Change Set:		7905Collections-nice.159Collections-nice.159:As signalled by Henrik Johansen in Pharo list, it might be safer to  modify the monitor inst. var. after all the others in case postCopy is used outside its ^self shallowCopy postCopy context.Collections-nice.158:Apply patch from http://bugs.squeak.org/view.php?id=6535keyBlock and sortBlock are lost when creating a collection of the same species. Unlike http://bugs.squeak.org/view.php?id=6535 initial solution, avoid defining a basicShallowCopy.This requires using postCopy paradigm as pre-requisite.If new methods are added before old methods are modified, this patch should load without problem in MC, else I will revert..."!!SharedQueue2 methodsFor: 'copying' stamp: 'nice 10/5/2009 19:07'!postCopy	super postCopy.	monitor critical:		[items := items copy.		monitor := Monitor new]! !!Dictionary methodsFor: 'enumerating' stamp: 'nice 10/5/2009 10:16'!select: aBlock 	"Evaluate aBlock with each of my values as the argument. Collect into a new dictionary, only those associations for which aBlock evaluates to true."	| newCollection |	newCollection := self copyEmpty.	self associationsDo: [ :each |		(aBlock value: each value) ifTrue: [			newCollection add: each copy ] ].	^newCollection! !!KeyedSet methodsFor: 'copying' stamp: 'nice 10/5/2009 10:15'!copyEmpty	^super copyEmpty		keyBlock: keyBlock! !!OrderedCollection methodsFor: 'copying' stamp: 'nice 5/28/2008 21:02'!postCopyFrom: startIndex to: endIndex 	"finish copying the array in a certain range."	endIndex < startIndex ifFalse: [		"Because actual size of the array may be greater than used size,		postCopyFrom:to: may fail to fail and answer an incorrect result		if this sanity check were not applied"		(startIndex between: 1 and: self size) ifFalse: [^self error: 'startIndex is out of bounds'].		(endIndex between: 1 and: self size) ifFalse: [^self error: 'endIndex is out of bounds']].		"Add a protection that lacks in Array>>postcopy"	array := array copyFrom: startIndex + firstIndex - 1 to: (endIndex max: startIndex - 1) + firstIndex - 1.	firstIndex := 1.	lastIndex := array size! !!OrderedCollection methodsFor: 'copying' stamp: 'nice 10/5/2009 10:18'!copyFrom: startIndex to: endIndex 	"Answer a copy of the receiver that contains elements from position	startIndex to endIndex."	^self shallowCopy postCopyFrom: startIndex to: endIndex! !!Set methodsFor: 'enumerating' stamp: 'nice 5/22/2008 14:56'!select: aBlock 	"Use copyEmpty instead of self species new to give subclasses a chance to initialize additional inst vars."	"Note: this code could be moved to super"		| newCollection |	newCollection := self copyEmpty.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection! !!Set methodsFor: 'copying' stamp: 'nice 5/22/2008 14:56'!copyEmpty	"Answer an empty copy of this collection"		"Note: this code could be moved to super"		^self species new! !!PluggableDictionary methodsFor: 'copying' stamp: 'nice 10/5/2009 10:15'!copyEmpty	^super copyEmpty		hashBlock: hashBlock;		equalBlock: equalBlock! !!PluggableSet methodsFor: 'copying' stamp: 'nice 10/5/2009 10:15'!copyEmpty	^super copyEmpty		hashBlock: hashBlock;		equalBlock: equalBlock! !