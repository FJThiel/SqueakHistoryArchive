"Change Set:		7853Collections-ar.138Collections-ar.138:Merging Collections-ul.137:- prepare for a new #grow and #rehash implementation for Set and its subclasses (except MethodDictionary). Add #noCheckNoGrowFillFrom:, #scanForEmptySlotFor: and #growTo: to these classes.- fix: adding Objects with the usual 12-bit #identityHash to a KeyedIdentitySet became O(n^2) when the set size reached 4096 (#scanFor:).- other minor changes (#scanFor:, #keysDo:)"!!Set methodsFor: 'private' stamp: 'ul 9/20/2009 04:40'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		| object |		(object := anArray at: index) ifNotNil: [			array				at: (self scanForEmptySlotFor: object)				put: object ] ]! !!WeakSet methodsFor: 'private' stamp: 'ul 9/20/2009 14:43'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		| object |		((object := anArray at: index) == flag or: [			object == nil ]) ifFalse: [ 				array					at: (self scanForEmptySlotFor: object)					put: object.				tally := tally + 1 ] ]! !!KeyedIdentitySet methodsFor: 'private' stamp: 'ul 9/18/2009 14:16'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element hash start finish |	finish := array size.	finish > 4096		ifTrue: [ hash := anObject identityHash * (finish // 4096) ]		ifFalse: [ hash := anObject identityHash ].	start := hash \\ finish + 1.		"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == nil or: [(keyBlock value: element) == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ul 9/20/2009 03:08'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| finish hash start |	(finish := array size) > 4096		ifTrue: [ hash := anObject identityHash * (finish // 4096) ]		ifFalse: [ hash := anObject identityHash ].	start := hash \\ finish + 1.	"Search from (hash mod size) to the end."	start to: finish do: [ :index |		(array at: index) ifNil: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		(array at: index) ifNil: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !!Dictionary methodsFor: 'private' stamp: 'ul 9/20/2009 04:40'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		| object |		(object := anArray at: index) ifNotNil: [			array				at: (self scanForEmptySlotFor: object key)				put: object ] ]! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ul 9/20/2009 04:11'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."		self associationsDo: [ :association |		| key |		(key := association key) ifNotNil: [			aBlock value: key ] ].! !!Set methodsFor: 'private' stamp: 'ul 9/20/2009 03:07'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| start |	start := anObject hash \\ array size + 1.	"Search from (hash mod size) to the end."	start to: array size do: [ :index |		(array at: index) ifNil: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		(array at: index) ifNil: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !!PluggableDictionary methodsFor: 'private' stamp: 'ul 9/20/2009 03:11'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| start |	start := (hashBlock		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	"Search from (hash mod size) to the end."	start to: array size do: [ :index |		(array at: index) ifNil: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		(array at: index) ifNil: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !!PluggableSet methodsFor: 'private' stamp: 'ul 9/20/2009 03:10'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| start |	start := (hashBlock		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	"Search from (hash mod size) to the end."	start to: array size do: [ :index |		(array at: index) ifNil: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		(array at: index) ifNil: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !!Set methodsFor: 'private' stamp: 'ul 9/18/2009 03:17'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start |	start := (anObject hash \\ array size) + 1.		"Search from (hash mod size) to the end."	start to: array size do: [ :index |		((element := array at: index) == nil or: [ element = anObject ])			ifTrue: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		((element := array at: index) == nil or: [ element = anObject ])			ifTrue: [ ^index ] ].	^0  "No match AND no empty slot"! !!Set methodsFor: 'private' stamp: 'ul 9/20/2009 04:41'!growTo: anInteger	"Grow the elements array and reinsert the old elements"		| oldElements |	oldElements := array.	array := Array new: anInteger.	self noCheckNoGrowFillFrom: oldElements! !!PluggableDictionary methodsFor: 'private' stamp: 'ul 9/18/2009 14:09'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil (indicating an empty slot)	or an element that matches anObject. Answer the index of that slot or zero if no slot	is found. This  method will be overridden in various subclasses that have different	interpretations for matching elements."		| element start |	start := (hashBlock ifNil: [anObject hash]				ifNotNil: [hashBlock value: anObject])				\\ array size + 1.	"Search from (hash mod size) to the end."	start to: array size do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element key = anObject]				ifNotNil: [equalBlock value: element key value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!PluggableSet methodsFor: 'private' stamp: 'ul 9/18/2009 14:23'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil (indicating an empty slot)	or an element that matches anObject. Answer the index of that slot or zero if no slot	is found. This  method will be overridden in various subclasses that have different 	interpretations for matching elements."	| element start |	start := (hashBlock 		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	"Search from (hash mod size) to the end."	start to: array size do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	"Search from 1 to where we started."	1 to: start - 1 do: [:index | ((element := array at: index) == nil or:[equalBlock ifNil: [element = anObject]				ifNotNil: [equalBlock value: element value: anObject]])			ifTrue: [^ index]].	^ 0"No match AND no empty slot"! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 9/20/2009 04:40'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do:[ :i |		| association |		(association := anArray at: i) ifNotNil: [			array				at: (self scanForEmptySlotFor: association key)				put: association.			tally := tally + 1 ] ]! !!WeakKeyToCollectionDictionary methodsFor: 'as yet unclassified' stamp: 'ul 9/20/2009 04:40'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do:[ :i |		| association cleanedValue |		((association := anArray at: i) == nil or: [ 			(cleanedValue := association value copyWithout: nil) isEmpty ]) 				ifFalse: [					association value: cleanedValue.					array						at: (self scanForEmptySlotFor: association key)						put: association.					tally := tally + 1 ] ]! !!KeyedSet methodsFor: 'private' stamp: 'ul 9/20/2009 04:40'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		| object |		(object := anArray at: index) ifNotNil: [			array				at: (self scanForEmptySlotFor: (keyBlock value: object))				put: object ] ]! !!IdentitySet methodsFor: 'private' stamp: 'ul 9/20/2009 03:08'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| finish hash start |	(finish := array size) > 4096		ifTrue: [ hash := anObject identityHash * (finish // 4096) ]		ifFalse: [ hash := anObject identityHash ].	start := hash \\ finish + 1.	"Search from (hash mod size) to the end."	start to: finish do: [ :index |		(array at: index) ifNil: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		(array at: index) ifNil: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !!IdentityDictionary methodsFor: 'private' stamp: 'ul 9/20/2009 03:07'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| finish hash start |	(finish := array size) > 4096		ifTrue: [ hash := anObject identityHash * (finish // 4096) ]		ifFalse: [ hash := anObject identityHash ].	start := hash \\ finish + 1.	"Search from (hash mod size) to the end."	start to: finish do: [ :index |		(array at: index) ifNil: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		(array at: index) ifNil: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !!WeakSet methodsFor: 'private' stamp: 'ul 9/20/2009 03:09'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by flag or a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| start element |	start := anObject hash \\ array size + 1.	"Search from (hash mod size) to the end."	start to: array size do: [ :index |		((element := array at: index) == flag or: [ element == nil ]) ifTrue: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		((element := array at: index) == flag or: [ element == nil ]) ifTrue: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !!KeyedIdentitySet methodsFor: 'private' stamp: 'ul 9/20/2009 03:08'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| finish hash start |	(finish := array size) > 4096		ifTrue: [ hash := anObject identityHash * (finish // 4096) ]		ifFalse: [ hash := anObject identityHash ].	start := hash \\ finish + 1.	"Search from (hash mod size) to the end."	start to: finish do: [ :index |		(array at: index) ifNil: [ ^index ] ].	"Search from 1 to where we started."	1 to: start - 1 do: [ :index |		(array at: index) ifNil: [ ^index ] ].	self error: 'There is no free space in this collection!!'! !