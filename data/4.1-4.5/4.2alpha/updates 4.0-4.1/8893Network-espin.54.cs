"Change Set:		8893Network-espin.54Network-espin.54:Added    HTTPProxyCredentialsto the HTTP GET message. This makes HTTPSocket work from behind a proxy.See also   http://bugs.squeak.org/view.php?id=7193   http://bugs.squeak.org/view.php?id=912Network-ul.49:- code criticsNetwork-ar.50:Fix SocketStream>>peek.Network-nice.51:Correct socket peekFor: ( http://bugs.squeak.org/view.php?id=7446 )Remove some remote temps in PRServerDirectory  (simplify)Network-nice.52:move some temp assignment outside block"!!PRServerDirectory methodsFor: 'squeaklets' stamp: 'nice 1/14/2010 21:05'!writeProject: aProject inFileNamed: fileNameString fromDirectory: localDirectory 	"write aProject (a file version can be found in the file named  	fileNameString in localDirectory)"	| url arguments string |	url := self urlFromServer: self server directories: {'programmatic'. 'uploadproject'}.	arguments := self				getPostArgsFromProject: aProject				fileNamed: fileNameString				fromDirectory: localDirectory.	""	string := Cursor read showWhile: [			(HTTPClient httpPostDocument: url args: arguments) contents			"(HTTPSocket httpGetDocument: url args: arguments) contents."].	(string beginsWith: '--OK--')		ifTrue: [^ true].	""	self		inform: ('Server responded: {1}' translated format: {string}).	^ false! !!SocketStream methodsFor: 'stream in' stamp: 'ar 1/13/2010 22:30'!peek	"Return next byte, if inBuffer is empty	we recieve some more data and try again.	Do not consume the byte."	self atEnd ifTrue: [^nil].	self isInBufferEmpty ifTrue:		[self receiveData.		self atEnd ifTrue: [^nil]].	^inBuffer at: lastRead+1! !!PRServerDirectory methodsFor: 'testing' stamp: 'nice 1/14/2010 21:07'!queryProjectsAndShow: thingsToSearchForCollection 	"query the server for all the projects that match  	thingsToSearchForCollection"	| url arguments string |	url := self urlFromServer: self server directories: {'programmatic'. 'queryprojects'}.	arguments := self getPostArgsFromThingsToSearchFor: thingsToSearchForCollection.	""	string := Cursor read showWhile: [			"(HTTPClient httpPostDocument: url args:  args) contents."			(HTTPSocket httpGetDocument: url args: arguments) contents].	(string beginsWith: '--OK--')		ifTrue: [^ true].	""	self		inform: ('Server responded: {1}' translated format: {string}).	^ false! !!PRServerDirectory methodsFor: 'private' stamp: 'nice 1/14/2010 21:04'!getOnly: numberOfBytes ofProjectContents: aString 	"private - get numberOfBytes of the project contents"	| url args contents |	self flag: #todo.	"use an LRUCache"	url := self urlFromServer: self server directories: {'programmatic'. aString}.	""	args := numberOfBytes isNil				ifFalse: ['numberOfBytes=' , numberOfBytes asString].	""	contents := Cursor read showWhile: [			(HTTPSocket httpGetDocument: url args: args) contents].	""	(contents beginsWith: '--OK--')		ifFalse: [^ nil].	""	^ contents allButFirst: 6! !!UUIDGenerator methodsFor: 'random seed' stamp: 'nice 1/18/2010 19:22'!makeUnixSeed	^[FileStream readOnlyFileNamed: '/dev/urandom' do: [:strm |		strm binary.		strm converter: Latin1TextConverter new.		Integer			byte1: strm next			byte2: strm next			byte3: strm next			byte4: strm next].	] on: FileStreamException do: [nil]! !!ConnectionQueue methodsFor: 'private' stamp: 'nice 1/18/2010 18:34'!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	| newConnection |	socket := Socket newTCP.	"We'll accept four simultanous connections at the same time"	socket listenOn: portNumber backlogSize: 4.	"If the listener is not valid then the we cannot use the	BSD style accept() mechanism."	socket isValid ifFalse: [^self oldStyleListenLoop].	[true] whileTrue: [		socket isValid ifFalse: [			"socket has stopped listening for some reason"			socket destroy.			(Delay forMilliseconds: 10) wait.			^self listenLoop ].		newConnection := [socket waitForAcceptFor: 10]			on: ConnectionTimedOut			do: [nil].		(newConnection notNil and: [newConnection isConnected]) ifTrue: [			accessSema critical: [connections addLast: newConnection.].			newConnection := nil.			self changed].		self pruneStaleConnections]. ! !!ServerDirectory methodsFor: 'file directory' stamp: 'nice 1/18/2010 19:13'!exists	"It is difficult to tell if a directory exists.  This is ugly, but it works for writable directories.  http: will fall back on ftp for this"	| probe |	self isTypeFile ifTrue: [		self entries size > 0 ifTrue: [^ true].		probe := self newFileNamed: 'withNoName23'. 		probe ifNotNil: [			probe close.			probe directory deleteFileNamed: probe localName].		^probe notNil].	^	[client := self openFTPClient.	[client pwd]		ensure: [self quit].	true]		on: Error		do: [:ex | false]! !!PRServerDirectory methodsFor: 'private' stamp: 'nice 1/14/2010 21:04'!getLines	"private - answer a collection of lines with the server response"	| url lines string |	url := self urlFromServer: self server directories: {'programmatic'} , self directories.	url := url , self slash.	""	string := Cursor read showWhile: [		(HTTPClient httpGetDocument: url)	contents].	(string beginsWith: '--OK--')		ifFalse: [^ nil].	""	lines := OrderedCollection new.	(string allButFirst: 6)		linesDo: [:line | lines add: line squeakToIso].	""	^ lines! !!SocketStream methodsFor: 'stream in' stamp: 'nice 1/13/2010 23:16'!peekFor: aCharacterOrByte	"Read and return next character or byte	if it is equal to the argument.	Otherwise return false."	| nextObject |	self atEnd ifTrue: [^false].	self isInBufferEmpty ifTrue: 		[self receiveData.		self atEnd ifTrue: [^false]].	nextObject := inBuffer at: lastRead + 1.	nextObject = aCharacterOrByte ifTrue: [		lastRead := lastRead + 1.		^true].	^false! !!HTTPSocket class methodsFor: 'get the page' stamp: 'espin 1/14/2010 15:21'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port bare page index connectToHost connectToPort aStream portSuffix |	Socket initializeNetwork.	bare := (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare := bare copyUpTo: $#.  "remove fragment, if specified"	serverName := bare copyUpTo: $/.	page := bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index := serverName indexOf: $:.			port := (serverName copyFrom: index+1 to: serverName size) asNumber.			portSuffix := ':', port printString.			serverName := serverName copyFrom: 1 to: index-1. ]		ifFalse: [			port := self defaultPort.			portSuffix := ''. ].	page size = 0 ifTrue: [page := '/'].	"add arguments"	args ifNotNil: [page := page, (self argString: args) ].	(self shouldUseProxy: serverName)		ifFalse: [ 			connectToHost := serverName.			connectToPort := port ]		ifTrue:  [			page := 'http://', serverName, portSuffix, page.		"put back together"			connectToHost := self httpProxyServer.			connectToPort := self httpProxyPort].		HTTPProgress signal: 'Looking up ', connectToHost.	serverAddr := NetNameResolver addressForName: connectToHost timeout: 20.	serverAddr ifNil: [^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [ | sock length firstData list type header newUrl |	sock := HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	"Transcript cr;show: url; cr.	Transcript show: page; cr."	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPProxyCredentials,		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		self userAgentString, CrLf,		'Host: ', serverName, portSuffix, CrLf.	"blank line automatically added"	list := sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData := list at: 3.	header isEmpty 		ifTrue: [aStream := 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length := sock getHeader: 'content-length'.			length ifNotNil: [ length := length asNumber ].			type := sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl := sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					newUrl := self expandUrl: newUrl ip: serverAddr port: connectToPort.					^self httpGetDocument: newUrl args: args  accept: mimeType request: requestString] ].			aStream := sock getRestOfBuffer: firstData totalLength: length.			"a 400-series error"			sock responseCode first = $4 ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifTrue: [ ^aStream ].	].{'HTTPSocket class>>httpGetDocument:args:accept:request:'. aStream. url} inspect.	^'some other bad thing happened!!'! !