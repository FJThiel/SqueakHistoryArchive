"Change Set:		8190Graphics-nice.90Graphics-nice.90:Cosmetic changes from Cuis: avoid using == JustifiedThis is an Integer and should be compared using =Graphics-nice.89:Hack to handle crlf pair composition and display"!!CompositionScanner methodsFor: 'stop conditions' stamp: 'nice 11/16/2009 09:23'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	pendingKernX := 0.	(lastIndex < text size and: [(text at: lastIndex) = CR and: [(text at: lastIndex+1) = Character lf]]) ifTrue: [lastIndex := lastIndex + 1].	line stop: lastIndex.	spaceX := destX.	line paddingWidth: rightMargin - spaceX.	^true! !!CharacterScanner methodsFor: 'scanning' stamp: 'jmv 12/8/2008 16:08'!plainTab	"This is the basic method of adjusting destX for a tab."	destX := (alignment = Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin]! !!CharacterScanner class methodsFor: 'class initialization' stamp: 'nice 11/16/2009 15:04'!initialize"	CharacterScanner initialize"	| a |	a := Array new: 258.	a at: 1 + 1 put: #embeddedObject.	a at: Tab asciiValue + 1 put: #tab.	a at: CR asciiValue + 1 put: #cr.	a at: Character lf asciiValue + 1 put: #cr.	a at: EndOfRun put: #endOfRun.	a at: CrossedX put: #crossedX.	NilCondition := a copy.	DefaultStopConditions := a copy.	PaddedSpaceCondition := a copy.	PaddedSpaceCondition at: Space asciiValue + 1 put: #paddedSpace.		SpaceCondition := a copy.	SpaceCondition at: Space asciiValue + 1 put: #space.! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'nice 11/16/2009 15:02'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	pendingKernX := 0.	(lastIndex < text size and: [(text at: lastIndex) = CR and: [(text at: lastIndex+1) = Character lf]])		ifTrue: [lastIndex := lastIndex + 2]		ifFalse: [lastIndex := lastIndex + 1].	^false! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'nice 11/16/2009 14:52'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY := destY +  line lineHeight.				lastCharacter := nil.				characterPoint := (nextLeftMargin ifNil: [leftMargin]) @ destY.				(lastIndex < text size and: [(text at: lastIndex) = CR and: [(text at: lastIndex+1) = Character lf]])					ifTrue: [lastIndex := lastIndex + 2]					ifFalse: [lastIndex := lastIndex + 1].				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter := CR.		characterPoint := destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'jmv 12/8/2008 16:08'!tab	| currentX |	currentX := (alignment = Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent := lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent := lastSpaceOrTabExtent copy.			^ self crossedX].	destX := currentX.	lastIndex := lastIndex + 1.	^false! !CharacterScanner initialize!