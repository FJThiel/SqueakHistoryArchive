"Change Set:		7436Kernel-ar.209Kernel-ar.209:UIManagerization. Replaces all the trivial references to PopUpMenu, SelectionMenu, CustomMenu, and FillInTheBlank.Kernel-nice.198:Fix for http://bugs.squeak.org/view.php?id=7114SmallInteger minVal highBitOfMagnitude.Kernel-nice.199:Fix for http://bugs.squeak.org/view.php?id=6874(2 raisedTo: 31) negated bitAnd: (2 raisedTo: 31) negated - 1.Kernel-nice.200:Faster printString for LargeIntegerhttp://bugs.squeak.org/view.php?id=6887Basic idea is to use divide and conquer algorithm:split the LargeInteger in two halves and recursively so as to fallback to faster SmallInteger arithmetic as soon as possible.This change improves[:n | [n printString] bench] value: 100 factorial.by roughly a factor 4Kernel-nice.201:Fix for http://bugs.squeak.org/view.php?id=7169self assert: (SqNumberParser parse: '0.50s2') = (1/2).Kernel-nice.202:Fix forhttp://bugs.squeak.org/view.php?id=6779ScaledDecimal readFrom: '5.3'.did not answer a ScaledDecimal Kernel-nice.203:Speed up number parsing by refactoring SqNumberParserhttp://bugs.squeak.org/view.php?id=6976http://bugs.squeak.org/view.php?id=7174+ some refactoring applied in PharoMain speed up come from:- not using Character>>#digitValue- avoid creating ifFail: [] blocks, but rather return nil- compose and conquer algorithm for parsing large integers (so as to make as many computations with SmallInteger as possible, in the spirit of divide and conquer printing)Kernel-nice.204:Fix forhttp://bugs.squeak.org/view.php?id=4378ScaledDecimal storeString incorrectly use printOn: and loose exactness Kernel-nice.207:Fix forhttp://bugs.squeak.org/view.php?id=6983Float nan isLiteral. It should not. Kernel-ar.208:Fixes debugging of FFI methods."!Object subclass: #SqNumberParser	instanceVariableNames: 'sourceStream base neg integerPart fractionPart exponent scale nDigits lastNonZero requestor failBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!Integer methodsFor: 'printing' stamp: 'nice 2/15/2008 22:14'!numberOfDigitsInBase: b 	"Return how many digits are necessary to print this number in base b.	This does not count any place for minus sign, radix prefix or whatever.	Note that this algorithm may cost a few operations on LargeInteger."	| nDigits q |	self negative ifTrue: [^self negated numberOfDigitsInBase: b].	self < b ifTrue: [^1].	b isPowerOfTwo	ifTrue: [^self highBit + b highBit - 2 quo: b highBit - 1].		"A conversion from base 2 to base b has to be performed.	This algorithm avoids Float computations like (self log: b) floor + 1,	1) because they are inexact	2) because LargeInteger might overflow	3) because this algorithm might be cheaper than conversion"	"Make an initial nDigits guess that is lower than or equal to required number of digits"	b = 10		ifTrue: [nDigits := ((self highBit - 1) * 3 quo: 10) + 1. "This is because 1024 is a little more than a kilo"]		ifFalse: [nDigits := self highBit quo: b highBit].	"See how many digits remains above these first nDigits guess"	q := self quo: (b raisedTo: nDigits).	^q = 0		ifTrue: [nDigits]		ifFalse: [nDigits + (q numberOfDigitsInBase: b)]! !!Integer methodsFor: 'private' stamp: 'nice 1/26/2008 02:12'!digitLogic: arg op: op length: len 	| i result neg1 neg2 rneg z1 z2 rz b1 b2 b |	neg1 := self negative.	neg2 := arg negative.	rneg := ((neg1				ifTrue: [-1]				ifFalse: [0])				perform: op				with: (neg2						ifTrue: [-1]						ifFalse: [0]))				< 0.	result := Integer new: len neg: rneg.	rz := z1 := z2 := true.	i := 0.	[(i := i + 1) <= len		or: ["mind a carry on result that might go past len digits"			rneg and: [rz				and: [result := result growby: 1.					true]]]]		whileTrue: [b1 := self digitAt: i.			neg1				ifTrue: [b1 := z1								ifTrue: [b1 = 0										ifTrue: [0]										ifFalse: [z1 := false.											256 - b1]]								ifFalse: [255 - b1]].			b2 := arg digitAt: i.			neg2				ifTrue: [b2 := z2								ifTrue: [b2 = 0										ifTrue: [0]										ifFalse: [z2 := false.											256 - b2]]								ifFalse: [255 - b2]].			b := b1 perform: op with: b2.			result				digitAt: i				put: (rneg						ifTrue: [rz								ifTrue: [b = 0										ifTrue: [0]										ifFalse: [rz := false.											256 - b]]								ifFalse: [255 - b]]						ifFalse: [b])].	^ result normalize! !!Integer methodsFor: 'printing' stamp: 'nice 2/15/2008 21:49'!printOn: aStream	^self printOn: aStream base: 10! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 00:22'!makeFloatFromMantissa: m exponent: k base: aRadix 	"Convert infinite precision arithmetic into Floating point.	This alogrithm rely on correct IEEE rounding mode	being implemented in Integer>>asFloat and Fraction>>asFloat"	^(k positive		ifTrue: [m * (aRadix raisedToInteger: k)]		ifFalse: [Fraction numerator: m denominator: (aRadix raisedToInteger: k negated)]) asFloat! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 10/16/2008 02:17'!readScale	"read the scale if any (stored in instVar).	Answer true if found, answer false if none.	If scale letter is not followed by a digit, this is not considered as an error.	Scales are always read in base 10, though i do not see why..."		scale := 0.	sourceStream atEnd ifTrue: [^ false].	(sourceStream peekFor: $s)		ifFalse: [^ false].	scale := self nextUnsignedIntegerOrNilBase: 10.	scale ifNil: [		scale := 0.		sourceStream skip: -1. "ungobble the s"		^ false].	^ true! !!Integer methodsFor: 'printing-numerative' stamp: 'nice 2/15/2008 21:44'!printOn: aStream base: b nDigits: n 	"Append a representation of this number in base b on aStream using nDigits.	self must be positive."	self subclassResponsibility! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 7/26/2009 00:21'!nextUnsignedIntegerOrNilBase: aRadix	"Form an unsigned integer with incoming digits from sourceStream.	Answer this integer, or nil if no digit found.	Count the number of digits and the position of lastNonZero digit and store them in instVar"		| nPackets high nDigitsHigh lastNonZeroHigh low |	"read no more digits than one elementary LargeInteger"	high :=  self nextElementaryLargeIntegerBase: aRadix.	nDigits = 0 ifTrue: [^nil].		"Not enough digits to form a LargeInteger, stop iteration"	high isLarge ifFalse: [^high].	"We now have to engage arithmetic with LargeInteger	Decompose the integer in a high and low packets of growing size:"	nPackets := 1.	nDigitsHigh := nDigits.	lastNonZeroHigh := lastNonZero.	[	low := self nextLargeIntegerBase: aRadix nPackets: nPackets .	high := high * (aRadix raisedToInteger: nDigits) + low.	lastNonZero = 0 ifFalse: [lastNonZeroHigh := lastNonZero + nDigitsHigh].	nDigitsHigh := nDigitsHigh + nDigits.	low isLarge]		whileTrue: [nPackets := nPackets * 2].	nDigits := nDigitsHigh.	lastNonZero := lastNonZeroHigh.	^high! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 10/16/2008 00:24'!readNamedFloatOrFail	"This method is used when there is no digit encountered:	It try and read a named Float NaN or Infinity.	Negative sign for -Infinity has been read before sending this method, and is indicated in the neg inst.var.	Fail if no named Float is found"			neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].	(sourceStream nextMatchAll: 'Infinity')		ifTrue: [^ neg			ifTrue: [Float infinity negated]			ifFalse: [Float infinity]].	^self expected: ['a digit between 0 and ' , (Character digitValue: base - 1)]! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'nice 7/8/2008 02:39'!highBitOfMagnitude	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. This method is used for negative SmallIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."		self < 0 ifTrue: [		"Beware: do not use highBitOfPositiveReceiver		because self negated is not necessarily a SmallInteger		(see SmallInteger minVal)"		^self negated highBitOfMagnitude].		"Implementation note: this method could be as well inlined here."	^self highBitOfPositiveReceiver! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 00:23'!makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart	"at this point integerPart fractionPart and scale have been read out (in inst var).	Form a ScaledDecimal.	Care of eliminating trailing zeroes from the fractionPart"		| decimalMultiplier decimalFraction |	decimalMultiplier := base raisedToInteger: numberOfNonZeroFractionDigits.	decimalFraction := integerPart * decimalMultiplier + (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)) / decimalMultiplier.	^ ScaledDecimal		newFromNumber: (neg			ifTrue: [decimalFraction negated]			ifFalse: [decimalFraction])		scale: scale! !!SqNumberParser methodsFor: 'parsing-large int' stamp: 'nice 7/26/2009 00:24'!nextLargeIntegerBase: aRadix nPackets: nPackets 	"Form a Large integer with incoming digits from sourceStream.	Return this integer, or zero if no digits found.	Stop reading when no more digits or when nPackets elementary LargeInteger have been encountered.	Count the number of digits and the lastNonZero digit and store them in instVar"		| high nDigitsHigh low nDigitsLow halfPackets |	halfPackets := nPackets bitShift: -1.	halfPackets = 0 ifTrue: [^self nextElementaryLargeIntegerBase: aRadix].	high := self nextLargeIntegerBase: aRadix nPackets: halfPackets.	high isLarge ifFalse: [^high].	nDigitsHigh := nDigits.	low := self nextLargeIntegerBase: aRadix nPackets: halfPackets.	nDigitsLow := nDigits.	nDigits := nDigitsHigh + nDigitsLow.	lastNonZero = 0 ifFalse: [lastNonZero := lastNonZero + nDigitsHigh].	^high * (aRadix raisedToInteger: nDigitsLow) + low! !!Float methodsFor: 'testing' stamp: 'nice 3/14/2008 23:49'!isLiteral	"There is no literal representation of NaN.	However, there are literal representations of Infinity, like 1.0e1000.	But since they are not able to print properly, only case of finite Float is considered."		^self isFinite! !!SmallInteger methodsFor: 'printing' stamp: 'nice 2/15/2008 22:22'!numberOfDigitsInBase: b 	"Return how many digits are necessary to print this number in base b.	Mostly same as super but an optimized version for base 10 case"		b = 10 ifFalse: [^super numberOfDigitsInBase: b].	self < 0 ifTrue: [^self negated numberOfDigitsInBase: b].	^self decimalDigitLength! !!SmallInteger methodsFor: 'printing' stamp: 'nice 2/15/2008 21:39'!printStringBase: b nDigits: n	"Return a string representation of this number in base b with n digits (left padded with 0).	Should be invoked with: 0 <= self < (b raisedToInteger: n)."		| integer next result |	result := String new: n.	integer := self.	n to: 1 by: -1 do: [:i |		next := integer // b.		result byteAt: i put: (Character digitValue: (integer - (next * b))).		integer := next].	^result! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 00:49'!nextIntegerBase: aRadix ifFail: aBlock	"Form an integer with following digits"		| isNeg value |	isNeg := sourceStream peekFor: $-.	value := self nextUnsignedIntegerOrNilBase: aRadix.	value isNil ifTrue: [^aBlock value].	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!ContextPart methodsFor: 'private' stamp: 'ar 8/2/2009 10:48'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	 simulated receiver and arguments are given as arguments to this message.	 Any primitive which provikes execution needs to be intercepted and simulated	 to avoid execution running away."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:		[ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	"ContextPart>>blockCopy:; simulated to get startpc right"	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart]) 		ifTrue: [^self push: ((BlockContext newForMethod: receiver method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext]) "BlockContext>>value[:value:...]"		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext]) "BlockContext>>valueWithArguments:"		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50" "Object>>perform:[with:...]"		ifTrue: [^self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50" "Object>>perform:withArguments:"		ifTrue: [^self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	primitiveIndex = 188 ifTrue: "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"		[^MethodContext			sender: self			receiver: receiver			method: (arguments at: 2)			arguments: (arguments at: 1)].	"Closure primitives"	(primitiveIndex = 200 and: [receiver == self]) ifTrue:		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"		[^self push: (BlockClosure						outerContext: receiver						startpc: pc + 2						numArgs: arguments first						copiedValues: arguments last)].	((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"	or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"		[^receiver simulateValueWithArguments: arguments caller: self].	primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"		[^receiver simulateValueWithArguments: arguments first caller: self].	primitiveIndex = 120 ifTrue:[ "FFI method"		value := meth literals first tryInvokeWithArguments: arguments.	] ifFalse:[		arguments size > 6 ifTrue: [^PrimitiveFailToken].		value := primitiveIndex = 117 "named primitives"				ifTrue:[self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]				ifFalse:[receiver tryPrimitive: primitiveIndex withArgs: arguments].	].	^value == PrimitiveFailToken		ifTrue: [PrimitiveFailToken]		ifFalse: [self push: value]! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 01:02'!makeIntegerOrScaledInteger	"at this point, there is no digit, nor fractionPart.	maybe it can be a scaled decimal with fraction omitted..."		neg		ifTrue: [integerPart := integerPart negated].	self readExponent		ifTrue: [^integerPart * (base raisedToInteger: exponent)].	self readScale		ifTrue: [^ScaledDecimal newFromNumber: integerPart scale: scale].	^ integerPart! !!Integer methodsFor: 'printing-numerative' stamp: 'nice 2/15/2008 21:52'!printOn: aStream base: base	^self subclassResponsibility! !!SmallInteger methodsFor: 'printing' stamp: 'nice 2/15/2008 21:42'!printOn: aStream base: b nDigits: n 	"Append a representation of this number in base b on aStream using nDigits.	self must be positive."	"allocating a String seems faster than streaming for SmallInteger"	aStream nextPutAll: (self printStringBase: b nDigits: n)! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 00:49'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [^ self expected: 'an integer greater than 1 as valid radix'].			(sourceStream peekFor: $-)				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !!Object methodsFor: 'viewer' stamp: 'ar 8/6/2009 20:43'!chooseNewNameForReference	"Offer an opportunity for the receiver, presumed already to be known in the References registry, to be renamed"	|  nameSym current newName |	current := References keyAtValue: self ifAbsent: [^ self error: 'not found in References'].	newName := UIManager default request: 'Please enter new name' initialAnswer: current.	"Want to user some better way of determining the validity of the chosen identifier, and also want to give more precise diagnostic if the string the user types in is not acceptable.  Work to be done here."	newName isEmpty ifTrue: [^ nil].	((Scanner isLiteralSymbol: newName) and: [(newName includes: $:) not])		ifTrue:			[nameSym := newName capitalized asSymbol.			(((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(ScriptingSystem allKnownClassVariableNames includes: nameSym) not])					ifTrue:						[(References associationAt: current) key: nameSym.						References rehash.						^ nameSym]].	self inform: 'Sorry, that name is not available.'.	^ nil! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:05'!nextUnsignedIntegerBase: aRadix 	"Form an unsigned integer with incoming digits from sourceStream.	Fail if no digit found.	Count the number of digits and the lastNonZero digit and store int in instVar "		| value |	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^self expected: ('a digit between 0 and ' copyWith: (Character digitValue: aRadix - 1))].	^value! !!ClassDescription methodsFor: 'instance variables' stamp: 'ar 8/6/2009 18:17'!chooseClassVarName 	"Present the user with a list of class variable names and answer the one selected, or nil if none"	| lines labelStream vars allVars index |	lines := OrderedCollection new.	allVars := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[:class |		vars := class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^Beeper beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index := (UIManager default chooseFrom: (labelStream contents substrings) lines: lines).	index = 0 ifTrue: [^ nil].	^ allVars at: index! !!Float methodsFor: 'testing' stamp: 'nice 3/14/2008 23:45'!isFinite	"simple, byte-order independent test for rejecting Not-a-Number and (Negative)Infinity"	^(self - self) = 0.0! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 00:50'!nextNumberBase: b	"Method for reading a number without radix prefix.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := b.	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !!LargePositiveInteger methodsFor: 'printing' stamp: 'nice 7/5/2008 23:23'!printOn: aStream base: b nDigits: n	"Append a representation of this number in base b on aStream using n digits.	In order to reduce cost of LargePositiveInteger ops, split the number of digts approximatily in two	Should be invoked with: 0 <= self < (b raisedToInteger: n)"		| halfPower half head tail |	n <= 1 ifTrue: [		n <= 0 ifTrue: [self error: 'Number of digits n should be > 0'].				"Note: this is to stop an infinite loop if one ever attempts to print with a huge base		This can happen because choice was to not hardcode any limit for base b		We let Character>>#digitValue: fail"		^Character digitValue: self].	halfPower := n bitShift: -1.	half := b raisedToInteger: halfPower.	head := self quo: half.	tail := self - (head * half).	head printOn: aStream base: b nDigits: n - halfPower.	tail printOn: aStream base: b nDigits: halfPower! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 00:51'!nextScaledDecimal	"Main method for reading a (scaled) decimal number.	Good Gracious, do not accept a decimal in another base than 10!!	In other words, do not accept radix notation like 2r1.1, even not 10r5.3	Do not accept exponent notation neither, like 1.0e-3"		| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart |	base := 10.	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerBase: base.	(sourceStream peekFor: $.)		ifTrue: [fractionPart := self nextUnsignedIntegerOrNilBase: base.			fractionPart ifNil: ["Oops, the decimal point seems not part of this number"							sourceStream skip: -1.							^ neg								ifTrue: [integerPart negated asScaledDecimal: 0]								ifFalse: [integerPart asScaledDecimal: 0]].			numberOfNonZeroFractionDigits := lastNonZero.			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.			self readScale				ifFalse: ["No scale were provided. use number of digits after decimal point as scale"					scale := nDigits].			^self makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart].	self readScale.	neg	ifTrue: [integerPart := integerPart negated].	^integerPart asScaledDecimal: scale! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 00:45'!readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart	"at this stage, sign integerPart and a decimal point have been read.	try and form a number with a fractionPart"		| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart mantissa value |	fractionPart := self nextUnsignedIntegerOrNilBase: base.	fractionPart ifNil: ["No fractionPart found,ungobble the decimal point and return the integerPart"					sourceStream skip: -1.					^ neg						ifTrue: [integerPart negated]						ifFalse: [integerPart]].	numberOfNonZeroFractionDigits := lastNonZero.	numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.	self readExponent		ifFalse: [self readScale				ifTrue: [^self makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits					andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart]].	fractionPart isZero		ifTrue: [mantissa := integerPart						// (base raisedToInteger: numberOfTrailingZeroInIntegerPart).			exponent := exponent + numberOfTrailingZeroInIntegerPart]		ifFalse: [mantissa := integerPart						* (base raisedToInteger: numberOfNonZeroFractionDigits) + (fractionPart // (base raisedToInteger: numberOfTrailingZeroInFractionPart)).			exponent := exponent - numberOfNonZeroFractionDigits].	value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.	^ neg		ifTrue: [value isZero				ifTrue: [Float negativeZero]				ifFalse: [value negated]]		ifFalse: [value]! !!ScaledDecimal class methodsFor: 'instance creation' stamp: 'nice 11/22/2007 22:36'!readFrom: stringOrStream 	"Answer a decimal number as described on stringOrStream.	The number may not include a leading radix specification, as in 16rFADE,	nor an exponent like 1.0e-3	It might have a scale specification at end or not like 10.3s2	If not, number of digits after decimal point will be used as scale"		^(SqNumberParser on: stringOrStream) nextScaledDecimal! !!SmallInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!isLarge	^false! !!SmallInteger methodsFor: 'printing' stamp: 'nice 7/6/2008 00:48'!printStringBase: b 	"Return a String representation of this number in base b.	For SmallIntegers, it is more efficient to print directly in a String,	rather than using a Stream like super."	self < 0		ifTrue: [^ '-'				, (self negated printStringBase: b)].	self < b		ifTrue: [^ String				with: (Character digitValue: self)].	^ self printStringBase: b nDigits: (self numberOfDigitsInBase: b)! !!ScaledDecimal methodsFor: 'printing' stamp: 'nice 12/3/2007 21:28'!storeOn: aStream 	"SxaledDecimal sometimes have more digits than they print (potentially an infinity).	In this case, do not use printOn: because it would loose some extra digits"		self isLiteral		ifTrue: [self printOn: aStream]		ifFalse: [aStream			nextPut: $(;		 	store: fraction numerator;			nextPut: $/;			store: fraction denominator;			nextPut: $s;			store: scale;			nextPut: $)]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:07'!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := sourceStream peekFor: $-.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!LargeNegativeInteger methodsFor: 'printing' stamp: 'nice 2/15/2008 21:47'!printOn: aStream base: b	"Append a representation of this number in base b on aStream."		aStream nextPut: $-.	self abs printOn: aStream base: b! !!ScaledDecimal methodsFor: 'testing' stamp: 'nice 12/3/2007 20:51'!isLiteral	"Answer if this number could be a well behaved literal.	Well, it would only if evaluating back to self.	This is not the case of all ScaledDecimals.	Some has an infinite precision and would need an infinite number of digits to print literally.	Try for example (3.00s2 reciprocal)."		^fraction denominator = 1 "first test trivial case before engaging arithmetic"			or: ["Exactly we should test:			(fraction numerator * (10 raisedTo; scale)) \\ fraction denominator = 0.			But since we can assume fraction is reduced already this will be simply:"						(10 raisedTo: scale) \\ fraction denominator = 0]		! !!SmallInteger methodsFor: 'printing' stamp: 'nice 2/15/2008 21:43'!printOn: aStream base: b 	"Append a representation of this number in base b on aStream."	self < 0		ifTrue: [aStream nextPut: $-.			aStream nextPutAll: (self negated printStringBase: b).			^self].	"allocating a String seems faster than streaming for SmallInteger"	aStream nextPutAll: (self printStringBase: b)! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 00:04'!readExponent	"read the exponent if any (stored in instVar).	Answer true if found, answer false if none.	If exponent letter is not followed by a digit,	this is not considered as an error.	Exponent are always read in base 10."		| eneg |	exponent := 0.	sourceStream atEnd ifTrue: [^ false].	(self exponentLetters includes: sourceStream peek)		ifFalse: [^ false].	sourceStream next.	eneg := sourceStream peekFor: $-.	exponent := self nextUnsignedIntegerOrNilBase: 10.	exponent ifNil: ["Oops, there was no digit after the exponent letter.Ungobble the letter"		exponent := 0.		sourceStream						skip: (eneg								ifTrue: [-2]								ifFalse: [-1]).					^ false].	eneg		ifTrue: [exponent := exponent negated].	^ true! !!Integer methodsFor: 'printing' stamp: 'nice 2/15/2008 21:49'!printString	"For Integer, prefer the stream version to the string version for efficiency"		^String streamContents: [:str | self printOn: str base: 10]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:05'!nextUnsignedIntegerBase: aRadix ifFail: errorBlock	"Form an unsigned integer with incoming digits from sourceStream.	Answer this integer, or execute errorBlock if no digit found.	Count the number of digits and the position of lastNonZero digit and store them in instVar"		| value |	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^errorBlock value].	^value! !!LargePositiveInteger methodsFor: 'testing' stamp: 'nice 8/31/2008 00:07'!isLarge	^true! !!LargePositiveInteger methodsFor: 'printing' stamp: 'nice 7/6/2008 00:34'!printStringBase: base	"For LargeIntegers, it's faster to use the stream version.	This reproduces Number implementation to avoid speed down if one defines Integer>>#printStringBase:	This method should be removed if  Integer>>#printStringBase: is removed.	Note: tests preallocating stream space with exact numberOfDigitsInBase: did not gain speed"		^String streamContents: [:str | self printOn: str base: base]! !!LargePositiveInteger methodsFor: 'printing' stamp: 'nice 7/22/2008 00:13'!printOn: aStream base: b	"Append a representation of this number in base b on aStream.	In order to reduce cost of LargePositiveInteger ops, split the number in approximately two equal parts in number of digits."		| halfDigits halfPower head tail nDigitsUnderestimate |	"Don't engage any arithmetic if not normalized"	(self digitLength = 0 or: [(self digitAt: self digitLength) = 0]) ifTrue: [^self normalize printOn: aStream base: b].		nDigitsUnderestimate := b = 10		ifTrue: [((self highBit - 1) * 3 quo: 10) + 1 "because 1024 is almost a kilo"]		ifFalse: [self highBit quo: b highBit].			"splitting digits with a whole power of two is more efficient"	halfDigits := 1 bitShift: nDigitsUnderestimate highBit - 2.		halfDigits <= 1		ifTrue: ["Hmmm, this could happen only in case of a huge base b... Let lower level fail"			^self printOn: aStream base: b nDigits: (self numberOfDigitsInBase: b)].		"Separate in two halves, head and tail"	halfPower := b raisedToInteger: halfDigits.	head := self quo: halfPower.	tail := self - (head * halfPower).		"print head"	head printOn: aStream base: b.		"print tail without the overhead to count the digits"	tail printOn: aStream base: b nDigits: halfDigits! !!SqNumberParser methodsFor: 'parsing-large int' stamp: 'nice 8/31/2008 23:00'!nextElementaryLargeIntegerBase: aRadix	"Form an unsigned integer with incoming digits from sourceStream.	Return this integer, or zero if no digits found.	Stop reading if end of digits or if a LargeInteger is formed.	Count the number of digits and the position of lastNonZero digit and store them in instVar"	| value digit |	value := 0.	nDigits := 0.	lastNonZero := 0.	aRadix <= 10		ifTrue: ["Avoid using digitValue which is awfully slow"			[value isLarge or: [sourceStream atEnd				or: [digit := sourceStream next charCode - 48.					(0 > digit							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]]				whileFalse: [nDigits := nDigits + 1.					0 = digit						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]]		ifFalse: [			[value isLarge or: [sourceStream atEnd				or: [digit := sourceStream next digitValue.					(0 > digit							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]]				whileFalse: [nDigits := nDigits + 1.					0 = digit						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]].	^value! !Integer removeSelector: #printStringBase:!