"Change Set:		9697Collections-nice.340Collections-nice.340:Generalize stream protocol #readInto:startingAt:count:It's the same as #next:into:startingAt: but avoid a copy and rather answer number of elements read.Collections-nice.337:Speed-up Character digitValue PART 2.Now get rid of class var initialization guard.Also use value instead of charCode to reach almost a x2 speedup (5x for lowercase).Benchmark:['0123456789' do: [:e | e digitValue]] benchNEW '312686.2627474505 per second.'ORIG  '197284.9430113977 per second.'['0123456789ABCDEF' do: [:e | e digitValue]] benchNEW '208848.6302739452 per second.BEFORE '120782.4435112977 per second.'['0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' do: [:e | e digitValue]] benchNEW '116395.9208158368 per second.'ORIG '55508.49830033993 per second.'['0123456789abcdefghijklmnopqrstuvwxyz' do: [:e | e digitValue]] benchNEW '108928.8142371526 per second.'ORIG '21273.34533093381 per second.'Collections-ul.338:Lint:- removed supersends where we can be sure that no superclass implements the method- implemented missing Collection >> #atRandom:, removed the implementation from HashedCollection, because it's the same- removed double indexing from SequenceableCollection >> #collect:from:to: while kept the same number of bytecodes inside the loop- unified categorization of several methods in the hierarchyCollections-ul.339:- added missing negation"!!ReadStream methodsFor: 'accessing' stamp: 'nice 3/16/2010 23:08'!readInto: aCollection startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	^max! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'ul 3/15/2010 02:31'!writeOnGZIPByteStream: aStream 	"We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	(self class isPointers or: [ self class isWords not ]) ifTrue: [ ^self ].	aStream nextPutAllWordArray: self! !!NullStream methodsFor: 'reading' stamp: 'nice 3/16/2010 23:04'!readInto: aCollection startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	position := position + n.	^n! !!PluggableSet class methodsFor: 'instance creation' stamp: 'dvf6/10/2000 18:13'!integerSet	^self new hashBlock: [:integer | integer hash \\ 1064164 * 1009]! !!ArrayedCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 18:18'!asSortedArray	self isSorted ifTrue: [^ self asArray].	^ super asSortedArray! !!WeakRegistry methodsFor: 'private' stamp: 'ar 3/20/98 19:31'!species	^Set! !!Collection class methodsFor: 'class initialization' stamp: 'lr 11/4/2003 12:07'!initialize	"Set up a Random number generator to be used by atRandom when the 	user does not feel like creating his own Random generator."	RandomForPicking := Random new.	MutexForPicking := Semaphore forMutualExclusion! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 3/16/2010 23:05'!readInto: aCollection startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	| obj |	0 to: n - 1 do: [:i |		(obj := self next) == nil ifTrue: [^i].		aCollection at: startIndex + i put: obj].	^n! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'nice 3/16/2010 23:06'!readInto: aCollection startingAt: startIndex count: n	"Read n objects into the given collection. 	Return number of elements that have been read."	"Overriden for efficiency"	| max |	max := (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position := position + max.	^max! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 3/15/2010 03:50'!collect: aBlock from: firstIndex to: lastIndex	"Refer to the comment in Collection|collect:."	| size result |	size := lastIndex - firstIndex + 1.	result := self species new: size.	1 to: size do: [ :index |		result at: index put: (aBlock value: (self at: index + firstIndex - 1)) ].	^result! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'ul 3/15/2010 04:52'!newFromStream: s	"Only meant for my subclasses that are raw bits and word-like.  For quick unpack form the disk."		| len |	(self isPointers or: [ self isWords not ]) ifTrue: [ ^self ].	s next = 16r80 ifTrue: [		"A compressed format.  Could copy what BitMap does, or use a 		special sound compression format.  Callers normally compress their own way."		^self error: 'not implemented' ].	s skip: -1.	len := s nextInt32.	^s nextWordsInto: (self basicNew: len)! !!WeakKeyDictionary methodsFor: 'enumerating' stamp: 'ul 2/3/2010 06:20'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."		self associationsDo: [ :association |		association key ifNotNil: [ :key | "Don't let the key go away"			aBlock value: key ] ].! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ar 2/26/2010 23:29'!cleanUp: aggressive	"Rehash all instances when cleaning aggressively"	aggressive ifTrue:[self rehashAll].! !!PluggableDictionary class methodsFor: 'instance creation' stamp: 'dvf6/10/2000 18:13'!integerDictionary	^ self new hashBlock: [:integer | integer hash \\ 1064164 * 1009]! !!SequenceableCollection methodsFor: 'filter streaming' stamp: 'kph 9/27/2007 21:18'!putOn: aStream	self do: [ :each | each putOn: aStream ]! !!Collection methodsFor: 'accessing' stamp: 'ul 3/15/2010 02:13'!atRandom: aGenerator	"Answer a random element of the receiver. Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers because 	only you use the generator. Causes an error if self has no elements."	| randomIndex index |	self emptyCheck.	randomIndex := aGenerator nextInt: self size.	index := 1.	self do: [ :each |		index = randomIndex ifTrue: [ ^each ].		index := index + 1 ]! !!Dictionary methodsFor: 'filter streaming' stamp: 'MPW 1/4/1901 08:33'!flattenOnStream:aStream	^aStream writeDictionary:self.! !!Set methodsFor: 'comparing' stamp: 'tk 11/8/2001 15:35'!= aSet	self == aSet ifTrue: [^ true].	"stop recursion"	(aSet isKindOf: Set) ifFalse: [^ false].	self size = aSet size ifFalse: [^ false].	self do: [:each | (aSet includes: each) ifFalse: [^ false]].	^ true! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 3/16/2010 23:12'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than n elements have been read."		| count |	count := self readInto: aCollection startingAt: startIndex count: n.	count = n		ifTrue:[ ^aCollection ]		ifFalse:[ ^aCollection copyFrom: 1 to: startIndex + count - 1 ]! !!Set methodsFor: 'copying' stamp: 'sma 5/12/2000 14:45'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self copy		remove: oldElement ifAbsent: [];		yourself! !!WeakKeyToCollectionDictionary methodsFor: 'private' stamp: 'ul 1/25/2010 20:01'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :association |			association key ifNotNil: [ :key | "Don't let the key go away"				| cleanedValue |				(cleanedValue := association value copyWithout: nil) isEmpty 					ifFalse: [						association value: cleanedValue.						array							at: (self scanForEmptySlotFor: key)							put: association.						tally := tally + 1 ] ] ] ]! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 1/25/2010 19:55'!rehashAll	"HashedCollection rehashAll"				self allSubclassesDo: #rehashAllInstances! !!SequenceableCollection methodsFor: 'testing' stamp: 'di 11/6/1998 09:35'!isSequenceable	^ true! !!Character methodsFor: 'accessing' stamp: 'nice 3/14/2010 23:42'!digitValue	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	value > 16rFF ifTrue: [^(EncodedCharSet charsetAt: self leadingChar) digitValueOf: self].	^DigitValues at: 1 + value! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 1/25/2010 19:54'!rehashAllInstances	"Do not use #allInstancesDo: because rehash may create new instances."	self allInstances do: #rehash! !!ArrayedCollection methodsFor: 'objects from disk' stamp: 'ul 3/15/2010 02:30'!writeOn: aStream 	"Store the array of bits onto the argument, aStream.  (leading byte ~= 16r80) identifies this as raw bits (uncompressed).  Always store in Big Endian (Mac) byte order.  Do the writing at BitBlt speeds. We only intend this for non-pointer arrays.  Do nothing if I contain pointers."	(self class isPointers or: [ self class isWords not ]) ifTrue: [ ^self ].	aStream nextInt32Put: self basicSize.	aStream nextWordsPutAll: self.! !HashedCollection removeSelector: #atRandom:!Collection initialize!