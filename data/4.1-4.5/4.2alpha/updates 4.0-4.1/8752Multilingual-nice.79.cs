"Change Set:		8752Multilingual-nice.79Multilingual-nice.79:remove useless done temp variable"!!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 20:14'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop stopCondition |	line := textLine.	rightMargin := line rightMargin.	lastIndex := line first.	self setStopConditions.		"also sets font"	characterIndex := index.  " == nil means scanning for point"	characterPoint := aPoint.	(characterPoint isNil or: [characterPoint y > line bottom])		ifTrue: [characterPoint := line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX := leftMargin := line leftMarginForAlignment: alignment.	destY := line top.	runLength := text runLengthFor: line first.	characterIndex		ifNotNil:	[lineStop := characterIndex  "scanning for index"]		ifNil:	[lineStop := line last  "scanning for point"].	runStopIndex := lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0.	[false] whileFalse:		[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth			ifNil: [font widthOf: (text at: lastIndex)]			ifNotNil: [specialWidth]).		(self perform: stopCondition) ifTrue:			[characterIndex				ifNil: [					"Result for characterBlockAtPoint: "					(stopCondition ~~ #cr and: [ lastIndex == line last						and: [ aPoint x > ((characterPoint x) + (lastCharacterExtent x / 2)) ]])							ifTrue: [ "Correct for right half of last character in line"								^ (CharacterBlock new stringIndex: lastIndex + 1										text: text										topLeft: characterPoint + (lastCharacterExtent x @ 0) + (font descentKern @ 0)										extent:  0 @ lastCharacterExtent y)									textLine: line ].						^ (CharacterBlock new stringIndex: lastIndex							text: text topLeft: characterPoint + (font descentKern @ 0)							extent: lastCharacterExtent - (font baseKern @ 0))									textLine: line]				ifNotNil: ["Result for characterBlockForIndex: "						^ (CharacterBlock new stringIndex: characterIndex							text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)							extent: lastCharacterExtent)									textLine: line]]]! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 20:07'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	"Set up margins"	leftMargin := lineRectangle left.	leftSide ifTrue: [leftMargin := leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX := spaceX := leftMargin.	firstDestX := destX.	rightMargin := lineRectangle right.	rightSide ifTrue: [rightMargin := rightMargin - textStyle rightIndent].	lastIndex := startIndex.	"scanning sets last index"	destY := lineRectangle top.	lineHeight := baseline := 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	presentationLine := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	numOfComposition := 0.	spaceCount := 0.	self handleIndentation.	leftMargin := destX.	line leftMargin: leftMargin.	presentationLine leftMargin: leftMargin.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	[false]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 19:55'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	baselineY := lineY + line baseline.	destY := baselineY - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	string := text string.	[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			bitBlt displayString: string 				from: startIndex 	"XXXX: The following is an interesting bug. All stopConditions exept #endOfRun		have lastIndex past the last character displayed. #endOfRun sets it *on* the character.		If we display up until lastIndex then we will also display invisible characters like		CR and tab. This problem should be fixed in the scanner (i.e., position lastIndex		consistently) but I don't want to deal with the fallout right now so we keep the		fix minimally invasive."				to: (stopCondition == #endOfRun ifTrue:[lastIndex] ifFalse:[lastIndex-1])				at: lastPos kern: kern baselineY: baselineY font: font].		(emphasisCode allMask: 4) ifTrue:[			font displayUnderlineOn: bitBlt from: lastPos x@baselineY to: destX@baselineY.		].		(emphasisCode allMask: 16) ifTrue:[			font displayStrikeoutOn: bitBlt from: lastPos x@baselineY to: destX@baselineY.		].		"see setStopConditions for stopping conditions for displaying."		self perform: stopCondition.		"or: [lastIndex > runStopIndex]."	] whileFalse.	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!MultiCanvasCharacterScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 19:58'!displayLine: textLine  offset: offset  leftInRun: leftInRun	|  nowLeftInRun startLoc startIndex stopCondition |	"largely copied from DisplayScanner's routine"	line := textLine.	foregroundColor ifNil: [ foregroundColor := Color black ].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	rightMargin := line rightMargin + offset x.	lineY := line top + offset y.	lastIndex := textLine first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	runX := destX := leftMargin.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	[		"remember where this portion of the line starts"		startLoc := destX@destY.		startIndex := lastIndex.		"find the end of this portion of the line"		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: text string rightX: rightMargin stopConditions: stopConditions						kern: kern "displaying: false".		"display that portion of the line"		canvas drawString: text string			from: startIndex to: lastIndex			at: startLoc			font: font			color: foregroundColor.		"handle the stop condition"		self perform: stopCondition	] whileFalse.	^runStopIndex - lastIndex! !!MultiCompositionScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 20:08'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	destX := spaceX := leftMargin := aParagraph leftMarginForCompositionForLine: lineIndex.	destY := 0.	rightMargin := aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex := startIndex.	"scanning sets last index"	lineHeight := textStyle lineGrid.  "may be increased by setFont:..."	baseline := textStyle baseline.	baselineY := destY + baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	presentationLine := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	numOfComposition := 0.	presentation := TextStream on: (Text fromString: (WideString new: text size)).	spaceCount := 0.	[false]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [presentationLine lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading.						^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!MultiDisplayScanner methodsFor: 'MVC-compatibility' stamp: 'nice 12/28/2009 20:10'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| leftInRun |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset := 0@0.	leftInRun := 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges := false.	paragraph := aParagraph.	foregroundColor := paragraphColor := aParagraph foregroundColor.	backgroundColor := aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt := nil]		ifFalse: [fillBlt := bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin := aParagraph rightMarginForDisplay.	lineY := aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			| runLength stopCondition startIndex string lastPos |			leftMargin := aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX := (runX := leftMargin).			line := aParagraph lines at: lineIndex.			lineHeight := line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex := line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun := text runLengthFor: line first].			baselineY := lineY + line baseline.			destY := baselineY - font ascent.  "Should have happened in setFont"			runLength := leftInRun.			runStopIndex := lastIndex + (runLength - 1) min: line last.			leftInRun := leftInRun - (runStopIndex - lastIndex + 1).			spaceCount := 0.			string := text string.			self handleIndentation.			[				startIndex := lastIndex.				lastPos := destX@destY.				stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern baselineY: baselineY].				"see setStopConditions for stopping conditions for displaying."				self perform: stopCondition			] whileFalse.			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY := lineY + lineHeight]]! !