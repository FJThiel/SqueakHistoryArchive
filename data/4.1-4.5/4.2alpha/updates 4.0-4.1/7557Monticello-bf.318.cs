"Change Set:		7557Monticello-bf.318Monticello-bf.318:- store and read preambles/postscripts in textual source, too- show preambles/postscripts when browsing a snapshotMonticello-bf.316:- sort class vars and pools (merging Eliot's and my fixes)Monticello-bf.317:- merged bp.316 from inbox- deal with nil user/password in MCHttpRepository"!MCDoItParser subclass: #MCScriptParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Monticello-Chunk Format'!!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:03'!evaluate	Compiler evaluate: script! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'bf 8/12/2009 23:00'!text	self switchIsComment ifTrue: [^ self classCommentString].	methodSelection ifNotNil: [^ methodSelection source].	protocolSelection ifNotNil: [^ ''].	classSelection ifNotNil: [^ self classDefinitionString].	categorySelection ifNil: [^self scriptDefinitionString].	^ ''! !!MCScriptDefinition methodsFor: 'testing' stamp: 'bf 8/12/2009 22:55'!isScriptDefinition	^true! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:04'!source	^ script! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:12'!description	^ Array with: packageName with: self scriptSelector! !!MCClassDefinition methodsFor: 'initializing' stamp: 'bf 8/12/2009 10:55'!initializeWithName: nameStringsuperclassName: superclassStringtraitComposition: traitCompositionStringclassTraitComposition: classTraitCompositionStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	superclassName := superclassString ifNil: ['nil'] ifNotNil: [superclassString asSymbol].	traitComposition := traitCompositionString.	classTraitComposition := classTraitCompositionString.	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray asSortedCollection ofType: MCClassVariableDefinition.	self addVariables: poolArray asSortedCollection ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:11'!installScript	self installScript: script! !!MCTool methodsFor: 'morphic ui' stamp: 'bp 8/9/2009 19:25'!buildWindow	| window |	window := SystemWindow labelled: self label.	window model: self.	self widgetSpecs do: [:spec |		| send fractions offsets |		send := spec first.		fractions := spec at: 2 ifAbsent: [#(0 0 1 1)].		offsets := spec at: 3 ifAbsent: [#(0 0 0 0)].		window			addMorph: (self perform: send first withArguments: send allButFirst)			fullFrame:				(LayoutFrame					fractions: 						((fractions first)@(fractions second) corner: 							(fractions third)@(fractions fourth))					offsets:						((offsets first)@(offsets second)  corner:							(offsets third)@(offsets fourth)))].	^ window! !!MCClassDefinition methodsFor: 'visiting' stamp: 'bf 8/12/2009 10:53'!= aDefinition	^((super = aDefinition)		and: [superclassName = aDefinition superclassName]		and: [self traitCompositionString = aDefinition traitCompositionString]		and: [self classTraitCompositionString = aDefinition classTraitCompositionString])		and: [category = aDefinition category]		and: [type = aDefinition type]		and: [self sortedVariables = aDefinition sortedVariables]		and: [comment = aDefinition comment]		! !!MCScriptParser class methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:07'!pattern	^'(PackageInfo named: *'! !!MCScriptDefinition methodsFor: 'comparing' stamp: 'avi 2/28/2005 16:55'!= aDefinition	^ (super = aDefinition)		and: [script = aDefinition script]! !!MCStWriter methodsFor: 'visiting' stamp: 'bf 8/12/2009 21:41'!visitScriptDefinition: definition	self writeScriptDefinition: definition! !!MCClassDefinition methodsFor: 'initializing' stamp: 'bf 8/12/2009 10:55'!initializeWithName: nameStringsuperclassName: superclassStringcategory: categoryString instVarNames: ivarArrayclassVarNames: cvarArraypoolDictionaryNames: poolArrayclassInstVarNames: civarArraytype: typeSymbolcomment: commentStringcommentStamp: stampStringOrNil	name := nameString asSymbol.	superclassName := superclassString ifNil: ['nil'] ifNotNil: [superclassString asSymbol].	category := categoryString.	name = #CompiledMethod ifTrue: [type := #compiledMethod] ifFalse: [type := typeSymbol].	comment := commentString withSqueakLineEndings.	commentStamp := stampStringOrNil ifNil: [self defaultCommentStamp].	variables := OrderedCollection  new.	self addVariables: ivarArray ofType: MCInstanceVariableDefinition.	self addVariables: cvarArray asSortedCollection ofType: MCClassVariableDefinition.	self addVariables: poolArray asSortedCollection ofType: MCPoolImportDefinition.	self addVariables: civarArray ofType: MCClassInstanceVariableDefinition.! !!MCVariableDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^true! !!MCScriptParser methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:13'!addDefinitionsTo: aCollection	| tokens  definition |	tokens := Scanner new scanTokens: source.	definition := MCScriptDefinition		scriptSelector: tokens second allButLast		script: tokens third		packageName: tokens first third.	aCollection add: definition.! !!MCClassDefinition methodsFor: 'accessing' stamp: 'bf 8/29/2006 11:45'!sortedVariables	"sort variables for comparison purposes"	| sorted |	sorted := variables select: [:var | var isOrderDependend].	sorted addAll: ((variables reject: [:var | var isOrderDependend])		asSortedCollection: [:a :b | a name <= b name]).	^sorted! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 16:54'!script	^ script! !!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:12'!load	self installScript! !!MCClassVariableDefinition methodsFor: 'as yet unclassified' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'bf 8/13/2009 00:09'!packageName	^ packageName! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 8/12/2009 11:21'!user	self userAndPasswordFromSettingsDo: [:usr :pwd | ^usr].	"not in settings"	^user ifNil: ['']! !!MCSnapshotBrowser methodsFor: 'text' stamp: 'bf 8/13/2009 00:20'!scriptDefinitionString	| defs |	defs := items select: [:ea | ea isScriptDefinition].	defs isEmpty ifTrue: [^'(package defines no scripts)'].	^ String streamContents: [:stream | 		defs asArray sort 			do: [:ea | stream nextPutAll: '---------- package ';					nextPutAll: ea scriptSelector;					nextPutAll: ' ----------'; cr;					nextPutAll: ea script; cr]			separatedBy: [stream cr]].! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:22'!packageInfo	^ PackageInfo named: packageName! !!MCDefinition methodsFor: 'testing' stamp: 'bf 8/12/2009 22:55'!isScriptDefinition	^false! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:12'!summary	^ packageName, ' ', self scriptSelector! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'bf 10/25/2005 19:05'!sortKey	^ '!!', self scriptSelector "force to the front so it gets loaded first"! !!MCScriptDefinition methodsFor: 'installing' stamp: 'bf 10/25/2005 18:55'!installScript: aString	| sel pi |	sel := (self scriptSelector, ':') asSymbol.	pi := self packageInfo.	(pi respondsTo: sel)		ifTrue: [pi perform: sel with: aString]! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:25'!subclassForScriptSelector: selectorString	^self allSubclasses detect: [:ea | ea scriptSelector = selectorString]! !!MCScriptDefinition class methodsFor: 'as yet unclassified' stamp: 'bf 8/13/2009 00:24'!scriptSelector: selectorString script: aString packageName: packageString	^ (self subclassForScriptSelector: selectorString)		script: aString packageName: packageString! !!MCStWriter methodsFor: 'writing' stamp: 'bf 8/13/2009 00:21'!writeScriptDefinition: definition	stream nextChunkPut: (		'(PackageInfo named: {1}) {2}: {3}'		format: {			"{1}" definition packageName printString.			"{2}" definition scriptSelector. 			"{3}" definition script printString		}); cr! !!MCPoolImportDefinition methodsFor: 'testing' stamp: 'bf 8/29/2006 11:41'!isOrderDependend	^false! !!MCScriptDefinition methodsFor: 'installing' stamp: 'avi 2/28/2005 17:12'!unload	self installScript: nil! !!MCScriptDefinition methodsFor: 'initializing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithScript: aString packageName: packageString	script := aString.	packageName := packageString! !!MCScriptDefinition methodsFor: 'visiting' stamp: 'bf 8/12/2009 21:41'!accept: aVisitor	aVisitor visitScriptDefinition: self! !!MCScriptDefinition methodsFor: 'accessing' stamp: 'avi 2/28/2005 17:10'!scriptSelector	^ self class scriptSelector! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'bf 8/12/2009 11:26'!password	self userAndPasswordFromSettingsDo: [:usr :pwd | ^pwd].	self user isEmpty ifTrue: [^password ifNil: ['']].	[password isEmptyOrNil] whileTrue: [		| answer |		"Give the user a chance to change the login"		answer := UIManager default request: 'User name for ', String cr, location			initialAnswer: self user.		answer isEmpty			ifTrue: [^password]			ifFalse: [self user: answer].				password := UIManager default requestPassword: 'Password for "', self user, '" at ', String cr, location.	].	^ password! !MCPostscriptDefinition removeSelector: #accept:!