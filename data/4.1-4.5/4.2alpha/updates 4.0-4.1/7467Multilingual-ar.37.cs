"Change Set:		7467Multilingual-ar.37Multilingual-ar.37:UIManagerization. Replaces all the trivial references to PopUpMenu, SelectionMenu, CustomMenu, and FillInTheBlank.Multilingual-ar.33:Allow TTCFont to return nil from formOf: and handle it gracefully by using #hasGlyphOf: where required. This paves the way to allowing on-disk TrueType fonts where the actual font file may be missing after an image move and consquently no glyph can be computed for the font.Multilingual-ar.34:Addresses an interesting bug in [Multi]DisplayScanner. All stopConditions exept #endOfRun have lastIndex past the last character displayed. #endOfRun sets it *on* the character. If we display up until lastIndex then we will also display invisible characters like CR and tab. This problem should be fixed in the scanner (i.e., position lastIndex consistently) but I don't want to deal with the fallout right now so we keep the fix minimally invasive.Multilingual-ar.35:Integrate Multilingual-Support-FromEToys.Multilingual-bf.36:- use UTF8ClipboardInterpreter for all platforms, not just Windows"!Object subclass: #LanguageEnvironment	instanceVariableNames: 'id'	classVariableNames: 'ClipboardInterpreterClass KnownEnvironments InputInterpreterClass SystemConverterClass Current FileNameConverterClass'	poolDictionaries: ''	category: 'Multilingual-Languages'!ProtoObject subclass: #UTF32RussianInputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!LanguageEnvironment subclass: #RussianEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!!TTCFont methodsFor: 'private' stamp: 'ar 7/30/2009 21:42'!computeForm: char	| ttGlyph scale |	scale := self pixelSize asFloat / (ttcDescription ascender - ttcDescription descender).	Scale ifNotNil: [scale := Scale * scale].	ttGlyph := ttcDescription at: (char isCharacter ifTrue: [char charCode] ifFalse: [char]).	^ ttGlyph ifNotNil:[ttGlyph asFormWithScale: scale ascender: ttcDescription ascender descender: ttcDescription descender fgColor: foregroundColor bgColor: Color transparent depth: self depth].! !!TTCFont methodsFor: 'accessing' stamp: 'ar 7/30/2009 22:02'!fallbackFont	^fallbackFont ifNil: [		fallbackFont := (self textStyle == TextStyle default) 			ifTrue:[FixedFaceFont new errorFont fontSize: self height]			ifFalse:[TextStyle default fontOfPointSize: self height]].! !!TTCFont methodsFor: 'public' stamp: 'ar 7/30/2009 21:48'!widthOf: aCharacter	"This method cannot use #formOf: because formOf: discriminates the color and causes unnecessary bitmap creation."	(self hasGlyphOf: aCharacter) ifFalse: [		fallbackFont ifNotNil: [^ fallbackFont widthOf: aCharacter].		^ 1	].	^(self formOf: aCharacter) width! !!UTF32RussianInputInterpreter methodsFor: 'as yet unclassified' stamp: 'yo 8/29/2008 14:09'!nextCharFrom: sensor firstEvt: evtBuf 	| keyValue |	keyValue := evtBuf at: 6.	keyValue < 256		ifTrue: [^ (Character value: keyValue) squeakToIso].	^ Character leadingChar: RussianEnvironment leadingChar code: keyValue! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'sn 7/31/2009 15:06'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := EncodedCharSet scanSelectorAt: startEncoding.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stopConditions with: kernDelta).	].		^ stops at: EndOfRun! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'ar 7/30/2009 22:13'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	baselineY := lineY + line baseline.	destY := baselineY - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	done := false.	string := text string.	[done] whileFalse:[		startIndex := lastIndex.		lastPos := destX@destY.		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex 	"XXXX: The following is an interesting bug. All stopConditions exept #endOfRun		have lastIndex past the last character displayed. #endOfRun sets it *on* the character.		If we display up until lastIndex then we will also display invisible characters like		CR and tab. This problem should be fixed in the scanner (i.e., position lastIndex		consistently) but I don't want to deal with the fallout right now so we keep the		fix minimally invasive."				to: (stopCondition == #endOfRun ifTrue:[lastIndex] ifFalse:[lastIndex-1])				at: lastPos kern: kern baselineY: baselineY].		"see setStopConditions for stopping conditions for displaying."		done := self perform: stopCondition.		"lastIndex > runStopIndex ifTrue: [done := true]."	].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!RussianEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/29/2008 14:12'!clipboardInterpreterClass	^ UTF8ClipboardInterpreter.! !!RussianEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/29/2008 14:12'!fileNameConverterClass	^UTF8TextConverter.! !!EncodedCharSet class methodsFor: 'accessing - displaying' stamp: 'sn 7/31/2009 15:01'!scanSelectorAt: encoding 	| charset |	charset := self charsetAt: encoding.	^ charset		ifNil: [LanguageEnvironment scanSelector]		ifNotNil: [charset scanSelector]! !!EncodedCharSet class methodsFor: 'accessing - displaying' stamp: 'sn 7/31/2009 15:01'!scanSelector	^ #scanMultiCharactersFrom:to:in:rightX:stopConditions:kern:! !!LanguageEditor methodsFor: 'updating' stamp: 'ar 8/6/2009 20:11'!okToChange	"Allows a controller to ask this of any model"	self selectedTranslation isZero ifTrue: [^ true].	translationText hasUnacceptedEdits		ifFalse: [^ true].	^ (UIManager default 		confirm: 'Discard the changes to currently selected translated phrase?' translated)		and: [translationText hasUnacceptedEdits: false.			true]! !!TTCFont methodsFor: 'private' stamp: 'ar 7/30/2009 21:47'!hasGlyphOf: aCharacter	"Answer whether this font includes a glyph for the given character"	^ aCharacter charCode <= self maxAscii		and:[(self formOf: aCharacter) notNil]! !!LanguageEnvironment class methodsFor: 'public query' stamp: 'bf 8/3/2009 18:32'!defaultClipboardInterpreter	ClipboardInterpreterClass ifNil: [ClipboardInterpreterClass := self currentPlatform class clipboardInterpreterClass].	^ ClipboardInterpreterClass new.! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'bf 8/3/2009 18:31'!clipboardInterpreterClass	^ UTF8ClipboardInterpreter! !!RussianEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 12/11/2007 11:22'!supportedLanguages	"Return the languages that this class supports. 	Any translations for those languages will use this class as their environment."		^#('ru' )! !!EncodedCharSet class methodsFor: 'class methods' stamp: 'sn 7/31/2009 15:07'!initialize"	self initialize"	self allSubclassesDo: [:each | each initialize].	EncodedCharSets := Array new: 256.	EncodedCharSets at: 0+1 put: Latin1Environment.	EncodedCharSets at: 1+1 put: JISX0208.	EncodedCharSets at: 2+1 put: GB2312.	EncodedCharSets at: 3+1 put: KSX1001.	EncodedCharSets at: 4+1 put: JISX0208.	EncodedCharSets at: 5+1 put: JapaneseEnvironment.	EncodedCharSets at: 6+1 put: SimplifiedChineseEnvironment.	EncodedCharSets at: 7+1 put: KoreanEnvironment.	EncodedCharSets at: 8+1 put: GB2312.	"EncodedCharSets at: 9+1 put: UnicodeTraditionalChinese."	"EncodedCharSets at: 10+1 put: UnicodeVietnamese."	EncodedCharSets at: 12+1 put: KSX1001.	EncodedCharSets at: 13+1 put: GreekEnvironment.	EncodedCharSets at: 14+1 put: Latin2Environment.	EncodedCharSets at: 15+1 put: RussianEnvironment.	EncodedCharSets at: 256 put: Unicode.! !!RussianEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 8/29/2008 14:11'!systemConverterClass	^ UTF8TextConverter! !!RussianEnvironment class methodsFor: 'as yet unclassified' stamp: 'ar 7/31/2009 20:56'!inputInterpreterClass	| platformName  |	platformName := SmalltalkImage current platformName.	platformName = 'Win32'		ifTrue: [^UTF32RussianInputInterpreter].	platformName = 'Mac OS'		ifTrue: [^ (('10*' match: SmalltalkImage current osVersion)					and: [(SmalltalkImage current getSystemAttribute: 3) isNil])				ifTrue: [MacUnicodeInputInterpreter]				ifFalse: [MacRomanInputInterpreter]].	platformName = 'unix'		ifTrue: [^ UTF32RussianInputInterpreter].	^ MacRomanInputInterpreter! !!RussianEnvironment class methodsFor: 'as yet unclassified' stamp: 'yo 12/11/2007 11:21'!leadingChar	^ 15.! !!TTCFont methodsFor: 'private' stamp: 'ar 7/30/2009 21:47'!formOf: char	| code form |	char charCode > self maxAscii		ifTrue: [^ self fallbackFont formOf: char].	cache ifNil:[self foregroundColor: Color black]. "make sure we have a cache"	code := char charCode.	form := cache at: (code + 1).	form class == Association ifTrue:[^self computeForm: code]. "in midst of loading"	form ifNil:[		form := self computeForm: code.		form ifNil:[^nil].		cache at: code+1 put: form.		GlyphCacheData at: (GlyphCacheIndex := GlyphCacheIndex \\ GlyphCacheSize + 1) put: form.	].	^form! !EncodedCharSet initialize!