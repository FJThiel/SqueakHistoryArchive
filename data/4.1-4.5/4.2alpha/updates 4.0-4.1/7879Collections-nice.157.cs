"Change Set:		7879Collections-nice.157Collections-nice.157:Also related to copy refactoring from http://bugs.squeak.org/view.php?id=7404It appears that #fixTemps is not needed anymore with new BlockClosure, making #postCopyBlocks unecessary.Collections-nice.151:Merge patch from http://bugs.squeak.org/view.php?id=6366Avoid direct use of findSubstring:in:starting:matchTable: and CaseSensitiveOrder / CaseInsensitiveOrder because it does not work with WideStringCollections-nice.152:Fix bug http://bugs.squeak.org/view.php?id=5331beginsWith: did not work with a WideString receiver/argumentSolution is to use super beginsWith: rather than fast primitive, except if both receiver and argument are bytes....Collections-dtl.153:Add range checks to the primitive fallback code in IntegerArray>>at:put: and IntegerArray>>atAllPut:. Throw an error for out of range value to prevent arithmetic overflow.Reference Mantis 7309Collections-dtl.154:A TranscriptStream window opened from the Tools flap is not attached to the global Transcript. Change TranscriptStream class>>buildWith: to use Transcript rather than self new.Collections-nice.155:According to http://bugs.squeak.org/view.php?id=7404switch Collection copy to postCopy paradigm.This should solve http://bugs.squeak.org/view.php?id=7402http://bugs.squeak.org/view.php?id=7403This is also a prerequisite for solvinghttp://bugs.squeak.org/view.php?id=6535Collections-nice.156:According to http://bugs.squeak.org/view.php?id=7402Modify various Collection copy to use postCopy paradigm.shallowCopyThis should solve http://bugs.squeak.org/view.php?id=7402http://bugs.squeak.org/view.php?id=7403This is also a prerequisite for solvinghttp://bugs.squeak.org/view.php?id=6535"!!Heap methodsFor: 'copying' stamp: 'nice 10/5/2009 08:47'!postCopy	super postCopy.	array := array copy! !!String methodsFor: 'comparing' stamp: 'nice 7/27/2007 22:55'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."		| extra |	(extra := self size - suffix size) < 0 ifTrue: [^ false].	^ (self findString: suffix startingAt: extra + 1) > 0"  'Elvis' endsWith: 'vis'"! !!SharedQueue2 methodsFor: 'copying' stamp: 'nice 10/5/2009 09:04'!postCopy	super postCopy.	monitor critical:		[monitor := Monitor new.		items := items copy]! !!String methodsFor: 'system primitives' stamp: 'nice 7/28/2007 00:15'!numArgs 	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons excess start ix |	self size = 0 ifTrue: [^ -1].	firstChar := self at: 1.	(firstChar isLetter or: [firstChar = $:]) ifTrue:		["Fast reject if any chars are non-alphanumeric		NOTE: fast only for Byte things - Broken for Wide"		self class isBytes			ifTrue: [(self findSubstring: '~' in: self startingAt: 1 matchTable: Tokenish) > 0 ifTrue: [^ -1]]			ifFalse: [2 to: self size do: [:i | (self at: i) tokenish ifFalse: [^ -1]]].		"Fast colon count"		numColons := 0.  start := 1.		[(ix := self indexOf: $: startingAt: start) > 0]			whileTrue:				[numColons := numColons + 1.				start := ix + 1].		numColons = 0 ifTrue: [^ 0].		firstChar = $:			ifTrue: [excess := 2 "Has an initial keyword, as #:if:then:else:"]			ifFalse: [excess := 0].		self last = $:			ifTrue: [^ numColons - excess]			ifFalse: [^ numColons - excess - 1 "Has a final keywords as #nextPut::andCR"]].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!RunArray methodsFor: 'copying' stamp: 'nice 10/5/2009 08:44'!postCopy	super postCopy.	runs := runs copy.	values := values copy! !!String methodsFor: 'accessing' stamp: 'nice 10/3/2009 21:29'!findLastOccuranceOfString: subString startingAt: start 	"Answer the index of the last occurance of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	| last now |	last := self findString: subString startingAt: start.	last = 0 ifTrue: [^ 0].	[last > 0] whileTrue: [		now := last.		last := self findString: subString startingAt: last + 1.	].	^ now.! !!SharedQueue methodsFor: 'copying' stamp: 'nice 10/5/2009 09:01'!postCopy	super postCopy.	contentsArray := contentsArray copy.	accessProtect := Semaphore forMutualExclusion.	readSynch := Semaphore new! !!SparseLargeTable methodsFor: 'copying' stamp: 'nice 10/5/2009 08:46'!postCopy	super postCopy.	1 to: self basicSize do: [:i | self basicAt: i put: (self basicAt: i) copy]! !!Set methodsFor: 'copying' stamp: 'nice 10/5/2009 08:55'!postCopy	super postCopy.	array := array copy! !!Text methodsFor: 'copying' stamp: 'nice 10/5/2009 08:53'!postCopy	super postCopy.	string := string copy.	runs := runs copy! !!Matrix methodsFor: 'copying' stamp: 'nice 10/5/2009 09:09'!postCopy	super postCopy.	contents := contents copy! !!OrderedCollection methodsFor: 'copying' stamp: 'nice 10/5/2009 08:50'!postCopy	array := array copy! !!LinkedList methodsFor: 'copying' stamp: 'nice 10/5/2009 08:49'!postCopy	| aLink |	super postCopy.	firstLink isNil ifFalse: [		aLink := firstLink := firstLink copy.		[aLink nextLink isNil] whileFalse: [aLink nextLink: (aLink := aLink nextLink copy)].		lastLink := aLink].! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 22:58'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index := self findString: sub startingAt: start.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!Symbol class methodsFor: 'access' stamp: 'nice 7/27/2007 23:15'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	aString first isLetter ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findString: aString startingAt: 1 caseSensitive: false) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!IntegerArray methodsFor: 'accessing' stamp: 'dtl 3/8/2009 15:09'!atAllPut: anInteger	| word |	anInteger < 0		ifTrue:[anInteger < -16r80000000 ifTrue: [self error: anInteger asString , ' out of range'].				"word _ 16r100000000 + anInteger"				word := (anInteger + 1) negated bitInvert32]		ifFalse:[anInteger > 16r7FFFFFFF ifTrue: [self error: anInteger asString , ' out of range'].				word := anInteger].	self primFill: word.! !!CharacterSetComplement methodsFor: 'copying' stamp: 'nice 10/5/2009 08:52'!postCopy	super postCopy.	absent := absent copy! !!WideCharacterSet methodsFor: 'copying' stamp: 'nice 10/5/2009 08:53'!postCopy	super postCopy.	map := map collect: [:each | each copy]! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:34'!findString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^self findString: subString startingAt: start caseSensitive: true! !!IntegerArray methodsFor: 'accessing' stamp: 'dtl 3/8/2009 11:52'!at: index put: anInteger	| word |	<primitive: 166>	anInteger < 0		ifTrue:[anInteger < -16r80000000 ifTrue: [self error: anInteger asString , ' out of range'].				"word _ 16r100000000 + anInteger"				word := (anInteger + 1) negated bitInvert32]		ifFalse:[anInteger > 16r7FFFFFFF ifTrue: [self error: anInteger asString , ' out of range'].				word := anInteger].	self  basicAt: index put: word.	^anInteger! !!Bag methodsFor: 'copying' stamp: 'nice 10/5/2009 08:54'!postCopy	super postCopy.	contents := contents copy! !!TranscriptStream class methodsFor: 'toolbuilder' stamp: 'dtl 10/4/2009 23:44'!buildWith: aBuilder	^(Smalltalk at: #Transcript) buildWith: aBuilder! !!WeakRegistry methodsFor: 'copying' stamp: 'nice 10/5/2009 08:57'!postCopy	accessLock := Semaphore forMutualExclusion.	valueDictionary := valueDictionary copy.! !!ByteString methodsFor: 'comparing' stamp: 'nice 3/23/2007 00:50'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	"IMPLEMENTATION NOTE:	following algorithm is optimized in primitive only in case self and prefix are bytes like.	Otherwise, if self is wide, then super outperforms,	Otherwise, if prefix is wide, primitive is not correct"		prefix class isBytes ifFalse: [^super beginsWith: prefix].		self size < prefix size ifTrue: [^ false].	^ (self findSubstring: prefix in: self startingAt: 1			matchTable: CaseSensitiveOrder) = 1! !!WeakSet methodsFor: 'copying' stamp: 'nice 10/5/2009 08:59'!postCopy	| oldFlag |	super postCopy.	oldFlag := flag.	flag := Object new.	array replaceAll: oldFlag with: flag.! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:13'!findWordStart: key startingAt: start	| ind |	"HyperCard style searching.  Answer the index in self of the substring key, when that key is preceeded by a separator character.  Must occur at or beyond start.  The match is case-insensitive.  If no match is found, zero will be returned."	ind := start.	[ind := self findString: key startingAt: ind caseSensitive: false.	ind = 0 ifTrue: [^ 0].	"not found"	ind = 1 ifTrue: [^ 1].	"First char is the start of a word"	(self at: ind-1) isSeparator] whileFalse: [ind := ind + 1].	^ ind	"is a word start"! !!ByteSymbol methodsFor: 'comparing' stamp: 'nice 3/23/2007 00:50'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	"IMPLEMENTATION NOTE:	following algorithm is optimized in primitive only in case self and prefix are bytes like.	Otherwise, if self is wide, then super outperforms,	Otherwise, if prefix is wide, primitive is not correct"		prefix class isBytes ifFalse: [^super beginsWith: prefix].		self size < prefix size ifTrue: [^ false].	^ (self findSubstring: prefix in: self startingAt: 1			matchTable: CaseSensitiveOrder) = 1! !!CharacterSet methodsFor: 'copying' stamp: 'nice 10/5/2009 08:52'!postCopy	super postCopy.	map := map copy! !!String methodsFor: 'accessing' stamp: 'nice 7/27/2007 23:33'!findString: key startingAt: start caseSensitive: caseSensitive 	"Answer the index in this String at which the substring key first occurs,	at or beyond start. The match can be case-sensitive or not. If no match	is found, zero will be returned."		"IMPLEMENTATION NOTE: do not use CaseSensitiveOrder because it is broken for WideString	This is a temporary work around until Wide CaseSensitiveOrder search is fixed	Code should revert to:	caseSensitive		ifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]		ifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]"			^caseSensitive		ifTrue: [			(self class isBytes and: [key class isBytes])				ifTrue: [self						findSubstring: key						in: self						startingAt: start						matchTable: CaseSensitiveOrder]				ifFalse: [WideString new						findSubstring: key						in: self						startingAt: start						matchTable: nil]]		ifFalse: [			(self class isBytes and: [key class isBytes])				ifTrue: [self						findSubstring: key						in: self						startingAt: start						matchTable: CaseInsensitiveOrder]				ifFalse: [WideString new						findSubstring: key						in: self						startingAt: start						matchTable: CaseInsensitiveOrder]]! !!Stack methodsFor: 'copying' stamp: 'nice 10/5/2009 08:52'!postCopy	super postCopy.	linkedList := linkedList copy! !PluggableDictionary removeSelector: #copy!KeyedSet removeSelector: #copy!Interval removeSelector: #shallowCopy!PluggableDictionary removeSelector: #postCopyBlocks!KeyedSet removeSelector: #postCopyBlocks!SortedCollection removeSelector: #copy!Interval removeSelector: #copy!Text removeSelector: #copy!PluggableSet removeSelector: #copy!SequenceableCollection removeSelector: #shallowCopy!String removeSelector: #beginsWith:!Bag removeSelector: #copy!PluggableSet removeSelector: #postCopyBlocks!Matrix removeSelector: #copy!