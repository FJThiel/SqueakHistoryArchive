"Change Set:		8593PackageInfo-Base-nice.35PackageInfo-Base-nice.35:Cosmetic: move or remove a few temps inside closuresPackageInfo-Base-ar.33:Some comments for PackageInfo.PackageInfo-Base-ar.34:Fix typo in previous comment."!!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:35'!overriddenMethodsInClass: aClass do: aBlock	"Evaluates aBlock with the overridden methods in aClass"	^ self overrideCategoriesForClass: aClass do: [:cat |		self methodsInCategory: cat ofClass: aClass do: aBlock]! !!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:28'!overrideCategoriesForClass: aClass do: aBlock	"Evaluates aBlock with all the *foo-override categories in aClass"	^ aClass organization categories do: [:cat |		(self isOverrideCategory: cat) ifTrue: [aBlock value: cat]]! !!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:28'!allOverridenMethodsDo: aBlock	"Evaluates aBlock with all the overridden methods in the system"	^ ProtoObject withAllSubclassesDo: [:class | 		self overriddenMethodsInClass: class do: aBlock]! !!PackageInfo methodsFor: 'testing' stamp: 'ar 12/23/2009 18:32'!isOverrideOfYourMethod: aMethodReference	"Answers true if the argument overrides a method in this package"	^ (self isYourClassExtension: aMethodReference category) not and:		[(self changeRecordForOverriddenMethod: aMethodReference) notNil]! !!PackageInfo methodsFor: 'enumerating' stamp: 'ar 12/23/2009 18:53'!overriddenMethodsDo: aBlock	"Enumerates the methods the receiver contains which have been overridden by other packages"	^ self allOverridenMethodsDo: [:ea |		(self isOverrideOfYourMethod: ea)			ifTrue: [aBlock value: ea]]! !!PackageInfo methodsFor: 'dependencies' stamp: 'nice 12/26/2009 19:07'!externalRefsSelect: selBlock thenCollect: colBlock	| pkgMethods dependents extMethods otherClasses otherMethods classNames |	classNames := self classes collect: [:c | c name].	extMethods := self extensionMethods collect: [:mr | mr methodSymbol].	otherClasses := self externalClasses difference: self externalSubclasses.	otherMethods :=  otherClasses gather: [:c | c selectors].	pkgMethods := self methods asSet collect: [:mr | mr methodSymbol].	pkgMethods removeAllFoundIn: otherMethods.	dependents := Set new.	otherClasses do: [:c |		c selectorsAndMethodsDo:			[:sel :compiled |			| refs |			(extMethods includes: sel) ifFalse: 				[refs := compiled literals select: selBlock thenCollect: colBlock.				refs do: [:ea |					((classNames includes: ea) or: [pkgMethods includes: ea])							ifTrue: [dependents add: (self referenceForMethod: sel ofClass: c) -> ea]]]]].	^ dependents! !!PackageInfo methodsFor: 'modifying' stamp: 'nice 12/26/2009 19:07'!externalTraits	^ Array streamContents: [:s |		| behaviors |		behaviors := self classesAndMetaClasses.		Smalltalk allTraits do: [:trait |			(behaviors includes: trait) ifFalse: [s nextPut: trait].			(behaviors includes: trait classSide) ifFalse: [s nextPut: trait classSide]]].			! !!PackageInfo methodsFor: 'testing' stamp: 'nice 12/27/2009 04:13'!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex preamble stamp methodCategory tokens |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !