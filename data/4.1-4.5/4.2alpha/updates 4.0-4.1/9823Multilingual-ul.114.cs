"Change Set:		9823Multilingual-ul.114Multilingual-ul.114:- removed unused selectors and instance variables from UTF8TextConverter- added string encoding/decoding capabilities to TextConverter- copied ByteString's #utf8ToSqueak and #squeakToUtf8 implementation to UTF8TextConverter class without the Latin-1 fallback code (an error is raised if the input is not valid)"!TextConverter subclass: #UTF8TextConverter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!!UTF8TextConverter class methodsFor: 'conversion' stamp: 'ul 3/17/2010 09:56'!decodeByteString: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex byte1 byte2 byte3 byte4 unicode |	lastIndex := 1.	(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0		ifTrue: [ ^aByteString ].	outStream := (String new: aByteString size) writeStream.	[		outStream next: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex.		byte1 := aByteString byteAt: nextIndex.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[	^self errorMalformedInput ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63)].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63)].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput ].			byte4 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte4 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63)].		unicode ifNil: [ ^self errorMalformedInput ].		unicode = 16rFEFF ifFalse: [ "Skip byte order mark"			outStream nextPut: (Unicode value: unicode) ].		lastIndex := nextIndex + 1.		(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0 ] whileFalse.	^outStream 		next: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex;		contents! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 3/17/2010 09:57'!errorMalformedInput		^self class errorMalformedInput! !!TextConverter methodsFor: 'conversion' stamp: 'ul 3/13/2010 19:32'!encodeString: aString	^String new: aString size streamContents: [ :stream | 		self 			nextPutAll: aString			toStream: stream ]! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 3/17/2010 10:07'!encodeString: aString	aString isByteString ifTrue: [ ^self class encodeByteString: aString ].	^super encodeString: aString! !!UTF8TextConverter class methodsFor: 'conversion' stamp: 'ul 3/17/2010 09:54'!encodeByteString: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex |	lastIndex := 1.	(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0		ifTrue: [ ^aByteString ].	outStream := (String new: aByteString size + 1) writeStream.	[		outStream 			next: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex;			nextPutAll: (latin1Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0 ] whileFalse.	^outStream 		next: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex;		contents! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 3/17/2010 02:02'!nextFromStream: aStream	| character1 value1 character2 value2 unicode character3 value3 character4 value4 |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext.	character1 isNil ifTrue: [^ nil].	value1 := character1 asciiValue.	value1 <= 127 ifTrue: [		"1-byte character"		^ character1	].	"at least 2-byte character"	character2 := aStream basicNext.	character2 = nil ifTrue: [^self errorMalformedInput].	value2 := character2 asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63).	].	"at least 3-byte character"	character3 := aStream basicNext.	character3 = nil ifTrue: [^self errorMalformedInput].	value3 := character3 asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63).	].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte character"		character4 := aStream basicNext.		character4 = nil ifTrue: [^self errorMalformedInput].		value4 := character4 asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63).	].	unicode isNil ifTrue: [^self errorMalformedInput].	unicode > 16r10FFFD ifTrue: [^self errorMalformedInput].		unicode = 16rFEFF ifTrue: [^ self nextFromStream: aStream].	^ Unicode value: unicode.! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ul 3/17/2010 09:56'!errorMalformedInput	^self error: 'Invalid utf8 input detected'! !!TextConverter methodsFor: 'conversion' stamp: 'ul 3/13/2010 19:35'!decodeString: aString	^String new: aString size streamContents: [ :stream |		| readStream character |		readStream := aString readStream.		[ (character := self nextFromStream: readStream) == nil ]			whileFalse: [ stream nextPut: character ] ]! !!CompoundTextConverter methodsFor: 'conversion' stamp: 'ul 3/13/2010 19:32'!encodeString: aString	^String new: aString size streamContents: [ :stream | 		self 			nextPutAll: aString			toStream: stream.		Latin1			emitSequenceToResetStateIfNeededOn: stream			forState: state ]! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 3/17/2010 10:06'!decodeString: aString	aString isByteString ifTrue: [ ^self class decodeByteString: aString ].	^super decodeString: aString! !UTF8TextConverter removeSelector: #currentCharSize!UTF8TextConverter removeSelector: #forceToEncodingTag:!UTF8TextConverter removeSelector: #forceToEncodingTag!