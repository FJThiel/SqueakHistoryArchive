"Change Set:		8539Collections-ar.266Collections-ar.266:Allow implicit coercion to string when using string concatenation, i.e,	Transcript cr; show: 'The value is: ', 3.instead of	Transcript cr; show: 'The value is: ', 3 printString.Collections-ar.256:CompiledMethodTrailer: Cleanup.Collections-ul.259:- merged Collections-nice.256Collections-ul.260:- make sure that SortedCollection's #sort and #sort: update the sortBlockCollections-nice.261:Correct 2 typos in method name Occurance->OccurrenceDeprecate old findLastOccuranceOfString:startingAt:Collections-nice.262:A return was missing in WideString>>#asPackedIs this message used ? usable ?I doubt you can recover String -> Packed -> String because nothing would distinguish a packed WideString from a packed ByteString...Collections-nice.263:remove Dictionary>>#occurrencesOf: because same as superCollections-nice.264:Cosmetic: puch a few temps inside closuresCollections-nice.265:Cosmetic: move or remove a few temps inside closures"!!String methodsFor: 'converting' stamp: 'nice 12/26/2009 01:02'!asPacked	"Convert to a longinteger that describes the string"	^ self inject: 0 into: [ :pack :next | pack * 256 + next asInteger ].! !!SortedCollection methodsFor: 'sorting' stamp: 'ul 12/23/2009 12:12'!sort: aSortBlock 	"Sort this collection using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one.	If aSortBlock is nil then <= is used for comparison."	super sort: aSortBlock.	sortBlock := aSortBlock! !!WideString methodsFor: 'converting' stamp: 'nice 12/26/2009 01:03'!asPacked	^self inject: 0 into: [:pack :next | pack * 16r100000000 + next asInteger].! !!String methodsFor: 'deprecated-3.10' stamp: 'AdrianLienhard 8/26/2009 21:51'!findLastOccuranceOfString: subString startingAt: start 	self deprecated: 'Use instead #findLastOccurrenceOfString:startingAt:'.	^ self findLastOccurrenceOfString: subString startingAt: start ! !!String methodsFor: 'converting' stamp: 'nice 12/27/2009 03:10'!encodeForHTTPWithTextEncoding: encodingName conditionBlock: conditionBlock	"change dangerous characters to their %XX form, for use in HTTP transactions"	| httpSafeStream encodedStream |	httpSafeStream := WriteStream on: (String new).	encodedStream := MultiByteBinaryOrTextStream on: (String new: 6).	encodedStream converter: (TextConverter newForEncoding: encodingName).	self do: [:c | | cont |		(conditionBlock value: c)			ifTrue: [httpSafeStream nextPut: (Character value: c charCode)]			ifFalse: [				encodedStream text; resetToStart.				encodedStream nextPut: c.				encodedStream position: 0.				encodedStream binary.				cont := encodedStream contents.				cont do: [:byte |					httpSafeStream nextPut: $%.					httpSafeStream nextPut: (byte // 16) asHexDigit.					httpSafeStream nextPut: (byte \\ 16) asHexDigit.				].			].	].	^ httpSafeStream contents.! !!String methodsFor: 'converting' stamp: 'nice 12/26/2009 22:15'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks removed	 and consecutive white spaces condensed."	^String streamContents: [:stream |		| trimmed lastBlank |		trimmed := self withBlanksTrimmed.		lastBlank := false.		trimmed do: [:c | (c isSeparator and: [lastBlank]) ifFalse: [stream nextPut: c].			lastBlank := c isSeparator]].	" ' abc  d   ' withBlanksCondensed"! !!Text methodsFor: 'converting' stamp: 'nice 12/27/2009 03:10'!removeAttributesThat: removalBlock replaceAttributesThat: replaceBlock by: convertBlock	"Enumerate all attributes in the receiver. Remove those passing removalBlock and replace those passing replaceBlock after converting it through convertBlock"	| added removed |	"Deliberately optimized for the no-op default."	added := removed := nil.	runs withStartStopAndValueDo: [ :start :stop :attribs | 		attribs do: [ :attrib | | new |			(removalBlock value: attrib) ifTrue:[				removed ifNil:[removed := WriteStream on: #()].				removed nextPut: {start. stop. attrib}.			] ifFalse:[				(replaceBlock value: attrib) ifTrue:[					removed ifNil:[removed := WriteStream on: #()].					removed nextPut: {start. stop. attrib}.					new := convertBlock value: attrib.					added ifNil:[added := WriteStream on: #()].					added nextPut: {start. stop. new}.				].			].		].	].	(added == nil and:[removed == nil]) ifTrue:[^self].	"otherwise do the real work"	removed ifNotNil:[removed contents do:[:spec|		self removeAttribute: spec last from: spec first to: spec second]].	added ifNotNil:[added contents do:[:spec|		self addAttribute: spec last from: spec first to: spec second]].! !!PositionableStream methodsFor: 'filein/out' stamp: 'SergeStinckwich 7/31/2009 15:25'!copyPreamble: preamble from: aStream at: pos 	"Look for a changeStamp for this method by peeking backward.	Write a method preamble, with that stamp if found."	| terminator last50 stamp i |	terminator := $!!.	"Look back to find stamp in old preamble, such as...	Polygon methodsFor: 'private' stamp: 'di 6/25/97 21:42' prior: 34957598!! "	aStream position: pos.	aStream backChunk.	"to beginning of method"	last50 := aStream backChunk.	"to get preamble"	aStream position: pos.	stamp := String new.	(i := last50 		findLastOccurrenceOfString: 'stamp:'		startingAt: 1) > 0 ifTrue: 		[ stamp := (last50 			copyFrom: i + 8			to: last50 size) copyUpTo: $' ].	"Write the new preamble, with old stamp if any."	self		cr;		nextPut: terminator.	self nextChunkPut: (String streamContents: 			[ :strm | 			strm nextPutAll: preamble.			stamp size > 0 ifTrue: 				[ strm					nextPutAll: ' stamp: ';					print: stamp ] ]).	self cr! !!SharedQueue2 methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:34'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no such object has been queued, answer <nil> and leave me intact."	^monitor critical: [		| index |		index := items findFirst: aBlock.		index = 0 ifTrue: [			nil ]		ifFalse: [			items removeAt: index ] ].! !!Dictionary methodsFor: 'removing' stamp: 'nice 12/26/2009 01:34'!unreferencedKeys	"TextConstants unreferencedKeys"	^'Scanning for references . . .' 		displayProgressAt: Sensor cursorPoint		from: 0		to: self size		during: 			[:bar | 			| n |			n := 0.			self keys select: 					[:key | 					bar value: (n := n + 1).					(self systemNavigation allCallsOn: (self associationAt: key)) isEmpty]]! !!Array methodsFor: 'arithmetic' stamp: 'nice 12/27/2009 02:49'!preMultiplyByMatrix: m	"Answer m+*self where m is a Matrix."	m columnCount = self size ifFalse: [self error: 'dimensions do not conform'].	^(1 to: m rowCount) collect: [:row |		| s |		s := 0.		1 to: self size do: [:k | s := (m at: row at: k) * (self at: k) + s].		s]! !!String methodsFor: 'accessing' stamp: 'nice 10/5/2009 03:15'!findLastOccurrenceOfString: subString startingAt: start 	"Answer the index of the last occurrence of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0.  Case-sensitive match used."	| last now |	last := self findString: subString startingAt: start.	last = 0 ifTrue: [^ 0].	[last > 0] whileTrue:		[now := last.		last := self findString: subString startingAt: last + 1].	^ now! !!WordArray class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!bobsTest	| wa answer |"WordArray bobsTest"	answer := OrderedCollection new.	wa := WordArray with: 16r01020304 with: 16r05060708.	{false. true} do: [ :pad | | rawData s1 s2 wa2 |		0 to: 3 do: [ :skip |			s1 := RWBinaryOrTextStream on: ByteArray new.			s1 next: skip put: 0.		"start at varying positions"			wa writeOn: s1.			pad ifTrue: [s1 next: 4-skip put: 0].	"force length to be multiple of 4"			rawData := s1 contents.			s2 := RWBinaryOrTextStream with: rawData.			s2 reset.			s2 skip: skip.			"get to beginning of object"			wa2 := WordArray newFromStream: s2.			answer add: {				rawData size. 				skip. 				wa2 = wa. 				wa2 asArray collect: [ :each | each radix: 16]			}		].	].	^answer explore! !!Interval methodsFor: 'enumerating' stamp: 'nice 4/30/2007 18:28'!reverseDo: aBlock 	"Evaluate aBlock for each element of my interval, in reverse order.	Implementation notes: see do: for an explanation on loop detail"	| aValue index |	index := self size.	[index > 0]		whileTrue: [			index := index - 1.			aValue := start + (index * step).			aBlock value: aValue]! !!Interval methodsFor: 'accessing' stamp: 'nice 12/22/2009 15:50'!indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock 	"startIndex is an positive integer, the collection index where the search is started."	"during the computation of val , floats are only used when the receiver	contains floats"	| index val |	(self rangeIncludes: anElement)		ifFalse: [^ exceptionBlock value].	val := anElement - self first / self increment.	val isFloat		ifTrue: [(val - val rounded) abs * 100000000 < 1				ifTrue: [index := val rounded + 1]				ifFalse: [^ exceptionBlock value]]		ifFalse: [val isInteger				ifTrue: [index := val + 1]				ifFalse: [^ exceptionBlock value]].	"finally, the value of startIndex comes into play:"	^ (index between: startIndex and: self size)		ifTrue: [index]		ifFalse: [exceptionBlock value]! !!Array methodsFor: 'converting' stamp: 'nice 12/27/2009 03:10'!evalStrings	   "Allows you to construct literal arrays.    #(true false nil '5@6' 'Set new' '''text string''') evalStrings    gives an array with true, false, nil, a Point, a Set, and a String    instead of just a bunch of Symbols"        ^ self collect: [:each | | it |        it := each.        each == #true ifTrue: [it := true].		      each == #false ifTrue: [it := false].        each == #nil ifTrue: [it := nil].        (each isString and:[each isSymbol not]) ifTrue: [			it := Compiler evaluate: each].        each class == Array ifTrue: [it := it evalStrings].        it]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'nice 12/26/2009 21:21'!groupsOf: n atATimeDo: aBlock 	"Evaluate aBlock with my elements taken n at a time. Ignore any leftovers at the end.	Allows use of a flattened 	array for things that naturally group into groups of n.	If aBlock has a single argument, pass it an array of n items,	otherwise, pass the items as separate arguments.	See also pairsDo:"	| passArray |	passArray := (aBlock numArgs = 1).	n		to: self size		by: n		do: [:index | 			| args |			args := (self copyFrom: index - n + 1 to: index) asArray.			passArray ifTrue: [ aBlock value: args ]				ifFalse: [ aBlock valueWithArguments: args ]].! !!WeakArray class methodsFor: 'accessing' stamp: 'nice 12/26/2009 22:25'!addWeakDependent: anObject	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		| finished index weakDependent |		finished := false.		index := 0.		[index := index + 1.		finished not and:[index <= FinalizationDependents size]] whileTrue:[			weakDependent := FinalizationDependents at: index.			weakDependent isNil ifTrue:[				FinalizationDependents at: index put: anObject.				finished := true.			].		].		finished ifFalse:[			"Grow linearly"			FinalizationDependents := FinalizationDependents, (WeakArray new: 10).			FinalizationDependents at: index put: anObject.		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:26'!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."	^accessProtect critical: [		| value readPos |		value := nil.		readPos := readPosition.		[readPos < writePosition and: [value isNil]] whileTrue: [			value := contentsArray at: readPos.			readPos := readPos + 1.			(aBlock value: value) ifTrue: [				readPosition to: readPos - 1 do: [ :j |					contentsArray at: j put: nil.				].				readPosition := readPos.			] ifFalse: [				value := nil.			].		].		readPosition >= writePosition ifTrue: [readSynch initSignals].		value.	]."===q := SharedQueue new.1 to: 10 do: [ :i | q nextPut: i].c := OrderedCollection new.[	v := q nextOrNilSuchThat: [ :e | e odd].	v notNil] whileTrue: [	c add: {v. q size}].{c. q} explore==="! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:24'!flushAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."	^accessProtect critical: [		| value newReadPos |		newReadPos := writePosition.		writePosition-1 to: readPosition by: -1 do:			[:i | value := contentsArray at: i.			contentsArray at: i put: nil.			(aBlock value: value) ifTrue: [				"We take an element out of the queue, and therefore, we need to decrement 				the readSynch signals"				readSynch wait.			] ifFalse: [				newReadPos := newReadPos - 1.				contentsArray at: newReadPos put: value]].		readPosition := newReadPos.		value]! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 04:55'!fileInAnnouncing: announcement 	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val |	announcement 		displayProgressAt: Sensor cursorPoint		from: 0		to: self size		during: 			[:bar | 			[self atEnd] whileFalse: 					[bar value: self position.					self skipSeparators.										[ | chunk |					val := (self peekFor: $!!) 								ifTrue: [(Compiler evaluate: self nextChunk logged: false) scanFrom: self]								ifFalse: 									[chunk := self nextChunk.									self checkForPreamble: chunk.									Compiler evaluate: chunk logged: true]] 							on: InMidstOfFileinNotification							do: [:ex | ex resume: true].					self skipStyleChunk].			self close].	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current logChange: '----End fileIn of ' , self name , '----'.	self flag: #ThisMethodShouldNotBeThere.	"sd"	Smalltalk forgetDoIts.	^val! !!String methodsFor: 'accessing' stamp: 'nice 12/27/2009 03:10'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	| min |	min := self size + 1.	delimiters do: [:delim | | ind |	"May be a char, a string of length 1, or a substring"		delim isCharacter 			ifTrue: [ind := self indexOfSubCollection: (String with: delim) 						startingAt: start ifAbsent: [min]]			ifFalse: [ind := self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].			min := min min: ind].	^ min! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:25'!next	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, suspend the 	requesting process until one is."	readSynch wait.	^accessProtect		critical: [			| value |			readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value := nil]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1].			value].! !!String methodsFor: 'internet' stamp: 'nice 12/26/2009 22:13'!isoToUtf8	"Convert ISO 8559-1 to UTF-8"	| s |	s := WriteStream on: (String new: self size).	self do: [:c |		| v |		v := c asciiValue.		(v > 128)			ifFalse: [s nextPut: c]			ifTrue: [				s nextPut: (192+(v >> 6)) asCharacter.				s nextPut: (128+(v bitAnd: 63)) asCharacter]].	^s contents. ! !!Collection methodsFor: 'enumerating' stamp: 'nice 12/26/2009 00:44'!groupBy: keyBlock having: selectBlock 	"Like in SQL operation - Split the recievers contents into collections of 	elements for which keyBlock returns the same results, and return those 	collections allowed by selectBlock. keyBlock should return an Integer."	| result |	result := PluggableDictionary integerDictionary.	self do: 		[:e | 		| key |		key := keyBlock value: e.		(result includesKey: key)			ifFalse: [result at: key put: OrderedCollection new].		(result at: key)			add: e].	^ result := result select: selectBlock! !!Symbol class methodsFor: 'private' stamp: 'nice 12/27/2009 04:53'!possibleSelectorsFor: misspelled 	"Answer an ordered collection of possible corrections	for the misspelled selector in order of likelyhood"	| numArgs candidates lookupString best binary short long first |	lookupString := misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs := lookupString numArgs.	(numArgs < 0 or: [lookupString size < 2]) ifTrue: [^ OrderedCollection new: 0].	first := lookupString first.	short := lookupString size - (lookupString size // 4 max: 3) max: 2.	long := lookupString size + (lookupString size // 4 max: 3).	"First assemble candidates for detailed scoring"	candidates := OrderedCollection new.	self allSymbolTablesDo: [:s | | ss |		(((ss := s size) >= short	"not too short"			and: [ss <= long			"not too long"					or: [(s at: 1) = first]])	"well, any length OK if starts w/same letter"			and: [s numArgs = numArgs])	"and numArgs is the same"			ifTrue: [candidates add: s]].	"Then further prune these by correctAgainst:"	best := lookupString correctAgainst: candidates.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary := misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | best addFirst: him]].	^ best! !!LimitingLineStreamWrapper methodsFor: 'accessing' stamp: 'nice 12/26/2009 10:24'!upToEnd	^String streamContents: [:strm |		| ln |		[(ln := self nextLine) isNil] whileFalse: [ 			strm nextPutAll: ln; cr]]! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:34'!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, return nil"	^accessProtect		critical: [			| value |			readPosition >= writePosition					ifTrue: [readPosition := 1.							writePosition := 1.							value := nil]					ifFalse: [value := contentsArray at: readPosition].			value].! !!String methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!correctAgainstEnumerator: wordBlock continuedFrom: oldCollection	"The guts of correction, instead of a wordList, there is a block that should take another block and enumerate over some list with it."	| choices results maxChoices scoreMin |	scoreMin := self size // 2 min: 3.	maxChoices := 10.	oldCollection isNil		ifTrue: [ choices := SortedCollection sortBlock: [ :x :y | x value > y value ] ]		ifFalse: [ choices := oldCollection ].	wordBlock isNil		ifTrue:			[ results := OrderedCollection new.			1 to: (maxChoices min: choices size) do: [ :i | results add: (choices at: i) key ] ]		ifFalse:			[ wordBlock value: [ :word | | score |				(score := self alike: word) >= scoreMin ifTrue:					[ choices add: (Association key: word value: score).						(choices size >= maxChoices) ifTrue: [ scoreMin := (choices at: maxChoices) value] ] ].			results := choices ].	^ results! !!String methodsFor: 'converting' stamp: 'nice 12/26/2009 22:13'!compressWithTable: tokens	"Return a string with all substrings that occur in tokens replaced	by a character with ascii code = 127 + token index.	This will work best if tokens are sorted by size.	Assumes this string contains no characters > 127, or that they	are intentionally there and will not interfere with this process."	| str null finalSize result ri c |	null := Character value: 0.	str := self copyFrom: 1 to: self size.  "Working string will get altered"	finalSize := str size.	tokens doWithIndex:		[:token :tIndex |		| start ts |		start := 1.		[(start := str findString: token startingAt: start) > 0]			whileTrue:			[ts := token size.			((start + ts) <= str size				and: [(str at: start + ts) = $  and: [tIndex*2 <= 128]])				ifTrue: [ts := token size + 1.  "include training blank"						str at: start put: (Character value: tIndex*2 + 127)]				ifFalse: [str at: start put: (Character value: tIndex + 127)].			str at: start put: (Character value: tIndex + 127).			1 to: ts-1 do: [:i | str at: start+i put: null].			finalSize := finalSize - (ts - 1).			start := start + ts]].	result := String new: finalSize.	ri := 0.	1 to: str size do:		[:i | (c := str at: i) = null ifFalse: [result at: (ri := ri+1) put: c]].	^ result! !!PositionableStream methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 04:55'!fileInFor: client announcing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title.	Does NOT handle preambles or postscripts specially."	| val |	announcement displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				[ | chunk |				val := (self peekFor: $!!) ifTrue: [						(Compiler evaluate: self nextChunk for: client logged: false) scanFrom: self					] ifFalse: [						chunk := self nextChunk.						self checkForPreamble: chunk.						Compiler evaluate: chunk for: client logged: true ].				] on: InMidstOfFileinNotification				  do: [ :ex | ex resume: true].				self atEnd ifFalse: [ self skipStyleChunk ]].		self close].	"Note:  The main purpose of this banner is to flush the changes file."	SmalltalkImage current logChange: '----End fileIn of ' , self name , '----'.	Smalltalk forgetDoIts.	^ val! !!TextColor methodsFor: 'scanning' stamp: 'nice 12/26/2009 22:57'!writeScanOn: strm	"Two formats.  c125000255 or cblue;"	| nn |	strm nextPut: $c.	(nn := color name) ifNotNil: [		(self class respondsTo: nn) ifTrue: [			^ strm nextPutAll: nn; nextPut: $;]].	(Array with: color red with: color green with: color blue) do: [:float |		| str |		str := '000', (float * 255) asInteger printString.		strm nextPutAll: (str copyFrom: str size-2 to: str size)]! !!String methodsFor: 'converting' stamp: 'ar 12/27/2009 14:56'!, anObject	"Concatenate the argument to the receiver.		Transcript cr; show: 'The value is: ', 3.	"	^ self copyReplaceFrom: self size + 1		  to: self size		  with: anObject asString! !!SharedQueue methodsFor: 'accessing' stamp: 'nice 12/26/2009 21:25'!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	^accessProtect critical: [		| value |		readPosition >= writePosition ifTrue: [			value := nil		] ifFalse: [			value := contentsArray at: readPosition.			contentsArray at: readPosition put: nil.			readPosition := readPosition + 1		].		readPosition >= writePosition ifTrue: [readSynch initSignals].		value	].! !!Collection methodsFor: 'enumerating' stamp: 'nice 12/27/2009 03:10'!detectMin: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the lowest number.	If collection empty, return nil."	| minElement minValue |	self do: [:each | | val | 		minValue == nil			ifFalse: [				(val := aBlock value: each) < minValue ifTrue: [					minElement := each.					minValue := val]]			ifTrue: ["first element"				minElement := each.				minValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ minElement! !!Dictionary methodsFor: 'accessing' stamp: 'nice 12/26/2009 01:32'!associationDeclareAt: aKey	"Return an existing association, or create and return a new one.  Needed as a single message by ImageSegment.prepareToBeSaved."	^ self associationAt: aKey ifAbsent: [		| existing |		(Undeclared includesKey: aKey)			ifTrue: 				[existing := Undeclared associationAt: aKey.				Undeclared removeKey: aKey.				self add: existing]			ifFalse: 				[self add: aKey -> false]]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'nice 12/26/2009 21:21'!groupsOf: n atATimeCollect: aBlock 	"Evaluate aBlock with my elements taken n at a time. Ignore any 	leftovers at the end. 	Allows use of a flattened  	array for things that naturally group into groups of n. 	If aBlock has a single argument, pass it an array of n items, 	otherwise, pass the items as separate arguments. 	See also pairsDo:"	| passArray |	passArray := aBlock numArgs = 1.	^(n		to: self size		by: n)		collect: [:index | 			| args |			args := (self copyFrom: index - n + 1 to: index) asArray.			passArray				ifTrue: [aBlock value: args]				ifFalse: [aBlock valueWithArguments: args]]! !!Collection methodsFor: 'enumerating' stamp: 'nice 12/27/2009 03:10'!detectMax: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the element for which aBlock evaluates to the highest magnitude.	If collection empty, return nil.  This method might also be called elect:."	| maxElement maxValue |	self do: [:each | | val | 		maxValue == nil			ifFalse: [				(val := aBlock value: each) > maxValue ifTrue: [					maxElement := each.					maxValue := val]]			ifTrue: ["first element"				maxElement := each.				maxValue := aBlock value: each].				"Note that there is no way to get the first element that works 				for all kinds of Collections.  Must test every one."].	^ maxElement! !!String methodsFor: 'converting' stamp: 'nice 12/26/2009 22:14'!keywords	"Answer an array of the keywords that compose the receiver."	| keywords |	keywords := Array streamContents:		[:kwds |		| kwd |		kwd := WriteStream on: (String new: 16).		1 to: self size do:			[:i |			| char |			kwd nextPut: (char := self at: i).			char = $: ifTrue: 					[kwds nextPut: kwd contents.					kwd reset]].		(kwd position = 0) ifFalse: [kwds nextPut: kwd contents]].	(keywords size >= 1 and: [(keywords at: 1) = ':']) ifTrue:		["Has an initial keyword, as in #:if:then:else:"		keywords := keywords allButFirst].	(keywords size >= 2 and: [(keywords at: keywords size - 1) = ':']) ifTrue:		["Has a final keyword, as in #nextPut::andCR"		keywords := keywords copyReplaceFrom: keywords size - 1								to: keywords size with: {':' , keywords last}].	^ keywords! !!Character class methodsFor: 'class initialization' stamp: 'nice 12/27/2009 03:11'!initializeClassificationTable	"	Initialize the classification table. The classification table is a	compact encoding of upper and lower cases of characters with		- bits 0-7: The lower case value of this character.		- bits 8-15: The upper case value of this character.		- bit 16: lowercase bit (e.g., isLowercase == true)		- bit 17: uppercase bit (e.g., isUppercase == true)	"	| ch1 |	LowercaseBit := 1 bitShift: 16.	UppercaseBit := 1 bitShift: 17.	"Initialize the letter bits (e.g., isLetter == true)"	LetterBits := LowercaseBit bitOr: UppercaseBit.	ClassificationTable := Array new: 256.	"Initialize the defaults (neither lower nor upper case)"	0 to: 255 do:[:i|		ClassificationTable at: i+1 put: (i bitShift: 8) + i.	].	"Initialize character pairs (upper-lower case)"	#(		"Basic roman"		($A $a) 	($B $b) 	($C $c) 	($D $d) 		($E $e) 	($F $f) 	($G $g) 	($H $h) 		($I $i) 		($J $j) 		($K $k) 	($L $l) 		($M $m)	($N $n)	($O $o)	($P $p) 		($Q $q) 	($R $r) 	($S $s) 	($T $t) 		($U $u)	($V $v)	($W $w)	($X $x)		($Y $y)	($Z $z)		"International"		($Ä $ä)	($Å $å)	($Ç $ç)	($É $é)		($Ñ $ñ)	($Ö $ö)	($Ü $ü)	($À $à)		($Ã $ã)	($Õ $õ)	($ $)	($Æ $æ)		"International - Spanish"		($Á $á)	($Í $í)		($Ó $ó)	($Ú $ú)		"International - PLEASE CHECK"		($È $è)	($Ì $ì)		($Ò $ò)	($Ù $ù)		($Ë $ë)	($Ï $ï)		($Â $â)	($Ê $ê)	($Î $î)	($Ô $ô)	($Û $û)	) do:[:pair| | ch2 |		ch1 := pair first asciiValue.		ch2 := pair last asciiValue.		ClassificationTable at: ch1+1 put: (ch1 bitShift: 8) + ch2 + UppercaseBit.		ClassificationTable at: ch2+1 put: (ch1 bitShift: 8) + ch2 + LowercaseBit.	].	"Initialize a few others for which we only have lower case versions."	#($ß $Ø $ø $ÿ) do:[:char|		ch1 := char asciiValue.		ClassificationTable at: ch1+1 put: (ch1 bitShift: 8) + ch1 + LowercaseBit.	].! !!Interval methodsFor: 'enumerating' stamp: 'nice 12/22/2009 16:11'!do: aBlock 	"Evaluate aBlock for each value of the interval.	Implementation note: instead of repeatedly incrementing the value	    aValue := aValue + step.	until stop is reached,	We prefer to recompute value from start	    aValue := start + (index * step).	This is better for floating points accuracy, while not degrading Integer and Fraction speed too much.	Moreover, this is consistent with methods #at: and #size"		| aValue index size |	index := 0.	size := self size.	[index < size]		whileTrue: [aValue := start + (index * step).			index := index + 1.			aBlock value: aValue]! !!RunArray methodsFor: 'enumerating' stamp: 'nice 12/26/2009 20:55'!runsFrom: start to: stop do: aBlock	"Evaluate aBlock with all existing runs in the range from start to stop"	start > stop ifTrue:[^self].	self at: start setRunOffsetAndValue:[:firstRun :offset :firstValue|		| run value index |		run := firstRun.		value := firstValue.		index := start + (runs at: run) - offset.		[aBlock value: value.		index <= stop] whileTrue:[			run := run + 1.			value := values at: run.			index := index + (runs at: run)]].! !!Matrix methodsFor: 'arithmetic' stamp: 'nice 12/27/2009 03:10'!preMultiplyByMatrix: m	"Answer m +* self where m is a Matrix."		nrows = m columnCount ifFalse: [self error: 'dimensions do not conform'].	^Matrix rows: m rowCount columns: ncols tabulate: [:row :col | | s |		s := 0.		1 to: nrows do: [:k | s := (m at: row at: k) * (self at: k at: col) + s].		s]! !!String methodsFor: 'converting' stamp: 'nice 12/27/2009 04:54'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens |	sel := self withBlanksTrimmed.	(sel includes: $:) ifTrue:		[sel := sel copyReplaceAll: ':' with: ': '.	"for the style (aa max:bb) with no space"		possibleParens := sel findTokens: Character separators.		sel := self class streamContents:			[:s | | level |			 level := 0.			possibleParens do:				[:token | | n |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n := token occurrencesOf: $( ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $[ ) > 0 ifTrue: [level := level + n].							(n := token occurrencesOf: $] ) > 0 ifTrue: [level := level - n].							(n := token occurrencesOf: $) ) > 0 ifTrue: [level := level - n]]]]].	sel isEmpty ifTrue: [^ nil].	sel isOctetString ifTrue: [sel := sel asOctetString].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!RunArray methodsFor: 'accessing' stamp: 'nice 12/27/2009 04:54'!withStartStopAndValueDo: aBlock	| start |	start := 1.	runs with: values do:		[:len : val | | stop |		stop := start + len - 1.		aBlock value: start value: stop value: val.		start := stop + 1]		! !Dictionary removeSelector: #occurrencesOf:!ArrayedCollection removeSelector: #createMethod:header:!