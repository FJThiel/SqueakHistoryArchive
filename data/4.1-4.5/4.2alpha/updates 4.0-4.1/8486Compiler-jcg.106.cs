"Change Set:		8486Compiler-jcg.106Compiler-jcg.106:Inline the transformation defined by FutureMaker in Kernel-jcg.329.Compiler-ul.105:- marked unimplemented mirror primitives' tests as expected failures in MirrorPrimitiveTests"!ParseNode subclass: #FutureNode	instanceVariableNames: 'receiver originalSelector futureSelector futureDelta futureArgs effectNode valueNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!!FutureNode methodsFor: 'initialize-release' stamp: 'ar 10/18/2005 17:23'!futureMessage: selName arguments: args  from: encoder sourceRange: range	futureSelector := selName.	futureArgs := args.	^self! !!FutureNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block."	^effectNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation (new scheme)' stamp: 'eem 7/18/2008 12:27'!sizeCodeForEffect: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForEffect: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/5/2008 14:57'!emitForValue: stack on: strm	^valueNode emitForValue: stack on: strm! !!FutureNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:00'!sizeForBlockValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeForValue: encoder! !!FutureNode methodsFor: 'accessing' stamp: 'eem 9/10/2008 15:21'!receiver	^receiver! !!FutureNode methodsFor: 'code generation (closures)' stamp: 'eem 7/17/2008 19:58'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	{ receiver. futureDelta }, (futureArgs ifNil: [#()]) do:		[:node|		node == nil ifFalse:			[node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]]! !!FutureNode methodsFor: 'code generation (new scheme)' stamp: 'eem 7/18/2008 12:28'!sizeCodeForValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	valueNode := MessageNode new		receiver: receiver		selector: #futureSend:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^valueNode sizeCodeForValue: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'das 11/3/2005 12:23'!sizeForEffect: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeForEffect: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/5/2008 14:57'!emitForEffect: stack on: strm	^effectNode emitForEffect: stack on: strm! !!FutureNode methodsFor: 'testing' stamp: 'eem 7/18/2008 16:22'!isFutureNode	^true! !!FutureNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 17:59'!emitForBlockValue: stack on: strm	"Generate code for evaluating the last statement in a block."	^effectNode emitForValue: stack on: strm! !!FutureNode methodsFor: 'accessing' stamp: 'eem 9/10/2008 15:21'!originalSelector	^originalSelector! !!FutureNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^effectNode emitCodeForEffect: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'ar 10/18/2005 17:26'!sizeForValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	valueNode := MessageNode new		receiver: receiver		selector: #futureSend:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^valueNode sizeForValue: encoder! !!FutureNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitFutureNode: self! !!FutureNode methodsFor: 'code generation (new scheme)' stamp: 'eem 7/18/2008 12:28'!sizeCodeForBlockValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForValue: encoder! !!FutureNode methodsFor: 'initialize-release' stamp: 'ar 10/18/2005 17:23'!receiver: rcvr selector: selector arguments: args precedence: p from: encoder sourceRange: range	receiver := rcvr.	originalSelector := selector.	originalSelector == #future: ifTrue:[futureDelta := args first].	encoder noteSourceRange: range forNode: self.! !!FutureNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	^valueNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'accessing' stamp: 'das 1/6/2006 16:28'!futureSelector	^futureSelector! !!MirrorPrimitiveTests methodsFor: 'testing' stamp: 'ul 12/15/2009 20:23'!expectedFailures	^#(testMirrorAt testMirrorEqEq testMirrorInstVarAt testMirrorPerform testMirrorSize)! !