"Change Set:		9566Morphic-cmm.372Morphic-cmm.372:Merged laza.370.Morphic-ar.368:Add a preference to restore simple rectangular feedback for indicating changes.Morphic-ar.369:Merging Morphic-tfel.367Do not apply gradients on menus more than once. This fixes a bug where submenus got increasingly whiter with gradient menus activated after opening and closing them several times. (Without closing the parent menu)Morphic-cmm.370:Added hot-key to invoke pretty-print on a method.  It is crucial for the computer to handle mundane code-formatting, because it allows code to 'flow' into the system as quickly as one can type.The key is Shift+Command+S.  The pretty-print command also now positions the cursor at the end of the code, where there is a chance you wish to continue the method, instead of at the beginning, where there is no chance of that.Morphic-laza.370:Add to the windows menu:- contain every visible window (collapsed or not)- show a collapsed window in the list by putting () around the label- show a touched window by putting a leading * to the label- group windows by model (eg. Browsers are most likely always at the top of the list)- have a 'close all like this' menu entry to close all windows of a same kind (eg. close all open inspectors) [won't touch any windows with changed content]- have a 'close all but this' menu entry which does exactly like the above, but without closing the selected windowMorphic-cmm.371:Added AlternatePluggableListMorphOfMany, the same as a PluggableListMorphOfMany, but operating in a more familiar manner, notably allowing range selection via holding Shift.  Currently, it is only used by the new MessageTrace, but we may wish to consider it for current users of PluggableListMorphOfMany."!ScrollPane subclass: #PluggableTextMorph	instanceVariableNames: 'textMorph getTextSelector setTextSelector getSelectionSelector hasUnacceptedEdits askBeforeDiscardingEdits selectionInterval hasEditingConflicts'	classVariableNames: 'AdornmentCache SimpleFrameAdornments'	poolDictionaries: ''	category: 'Morphic-Pluggable Widgets'!PluggableListMorph subclass: #AlternatePluggableListMorphOfMany	instanceVariableNames: 'getSelectionListSelector setSelectionListSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Pluggable Widgets'!!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/3/2010 05:18'!allOtherWindowsLike: window	^ self allVisibleWindows reject: [:each |		each model name ~= window model name or: [each = window]]! !!AlternatePluggableListMorphOfMany methodsFor: 'drawing' stamp: 'cmm 1/18/2002 16:08'!listSelectionAt: index put: value	setSelectionListSelector ifNil:[^false].	^model perform: setSelectionListSelector with: index with: value! !!PluggableTextMorph class methodsFor: 'frame adornments' stamp: 'ar 3/1/2010 19:40'!simpleFrameAdornments: aBool	"Sets the simpleFrameAdornment preference		PluggableTextMorph simpleFrameAdornments: true.		PluggableTextMorph simpleFrameAdornments: false.	"	SimpleFrameAdornments := aBool! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/2/2010 11:29'!allVisibleWindows	^SystemWindow windowsIn: World satisfying: [ :w | w visible ]! !!AlternatePluggableListMorphOfMany methodsFor: 'model access' stamp: 'cmm 1/18/2002 16:50'!changeModelSelection: anInteger shifted: shiftedBoolean controlled: controlledBoolean	"Change the model's selected item index to be anInteger."	setIndexSelector ifNotNil:		[ model 			perform: setIndexSelector 			with: anInteger			with: shiftedBoolean			with: controlledBoolean ]! !!AlternatePluggableListMorphOfMany methodsFor: 'event handling' stamp: 'cmm 3/2/2004 23:14'!handlesMouseDown: evt	^ true! !!MenuMorph methodsFor: 'control' stamp: 'tfel 2/28/2010 15:29'!updateColor	| fill title |	Preferences gradientMenu		ifFalse: [^ self].	(self fillStyle == self color) not 		ifTrue: [^ self]. "Don't apply the gradient more than once"	""	fill := GradientFillStyle ramp: {0.0 -> Color white. 1 -> self color}.	""	fill		radial: false;		origin: self topLeft;		direction: 0 @ self height.	""	self fillStyle: fill.	" 	update the title color"	title := self allMorphs				detect: [:each | each hasProperty: #titleString]				ifNone: [^ self].	""	fill := GradientFillStyle ramp: {0.0 -> title color twiceLighter. 1 -> title color twiceDarker}.	""	fill		origin: title topLeft;		direction: title width @ 0.	""	title fillStyle: fill! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/3/2010 05:17'!closeAllWindowsLike: window	self closeAllWindowsBut: window.	window model canDiscardEdits ifTrue: [window delete]! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/2/2010 11:59'!windowMenuFor: window on: menu	menu 		addItem: [ :item |			item				contents: 'Close';				target: window;				selector: #delete ];		addItem: [ :item |			item				contents: 'Close all like this';				target: self;				selector: #closeAllWindowsLike:;				arguments: { window } ];		addItem: [ :item |			item				contents: 'Close all but this';				target: self;				selector: #closeAllWindowsBut:;				arguments: { window } ];		addItem: [ :item |			item 				contents: 'Toggle Full Screen';				target: window;				selector: #expandBoxHit ]! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/3/2010 05:04'!allWindowsLike: window	^ self allVisibleWindows reject: [:each | each model ~= window model or: [each = window]]! !!TextEditor methodsFor: 'menu messages' stamp: 'cmm 3/2/2010 18:46'!prettyPrint: decorated 	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageName ifNil: [ ^ morph flash ].	selectedClass := model selectedClassOrMetaClass.	newText := selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[ self			deselect ;			selectInvisiblyFrom: 1			to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: self text size + 1 ]! !!AlternatePluggableListMorphOfMany class methodsFor: 'instance creation' stamp: 'cmm 1/18/2002 16:08'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/3/2010 05:00'!listWindowsOn: menu	| windows |	windows := SortedCollection sortBlock: [:winA :winB |		winA model name = winB model name			ifTrue: [winA label < winB label]			ifFalse: [winA model name < winB model name]].	windows addAll: self allVisibleWindows.	windows ifEmpty: [ 		menu addItem: [ :item | 			item				contents: 'No Windows' translated;				isEnabled: false ] ].	windows do: [ :each |		menu addItem: [ :item |			item 				contents: (self windowMenuItemLabelFor: each);				icon: (self colorIcon: each paneColor);				target: each;				selector: #comeToFront;				subMenuUpdater: self				selector: #windowMenuFor:on:				arguments: { each };				action: [ each activateAndForceLabelToShow; expand ] ] ].! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/3/2010 04:59'!windowMenuItemLabelFor: window	| s |	s := WriteStream on: String new.	window model canDiscardEdits ifFalse: [ s nextPut: $* ].	window isCollapsed ifTrue: [ s nextPut: $( ].	s nextPutAll: window label.	window isCollapsed ifTrue: [ s nextPut: $) ].	^s contents contractTo: 50! !!PluggableTextMorph class methodsFor: 'frame adornments' stamp: 'ar 3/1/2010 19:43'!simpleFrameAdornments	<preference: 'Simple Frame Adornments'		category: 'Morphic'		description: 'When true, use a simple rectangular feedback for indicating unsaved changes in text editors'		type: #Boolean>	^SimpleFrameAdornments ifNil:[false]! !!AlternatePluggableListMorphOfMany methodsFor: 'model access' stamp: 'cmm 3/2/2004 23:06'!itemSelectedAmongMultiple: index	^model isMessageSelectedAt: index! !!PluggableMessageCategoryListMorph methodsFor: 'updating' stamp: 'cmm 3/1/2010 22:06'!verifyContents	| newList existingSelection anIndex newRawList |	(model editSelection == #editComment) ifTrue: [^ self].	model classListIndex = 0 ifTrue: [^ self].	newRawList := model perform: getRawListSelector.	newRawList == priorRawList ifTrue: [^ self].  "The usual case; very fast"	priorRawList := newRawList.	newList := (Array with: ClassOrganizer allCategory), priorRawList.	list = newList ifTrue: [^ self].	existingSelection := self selection.	self updateList.	(anIndex := newList indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifNil:			[self changeModelSelection: 0]! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'ar 3/1/2010 19:41'!drawFrameAdornment: aColor on: aCanvas	"Indicate edit status for the text editor"	| form |	self class simpleFrameAdornments		ifTrue:[^aCanvas frameRectangle: self innerBounds width: 2 color: aColor].	"Class-side adornment cache is currently using pre-multiplied alpha, 	so we need to use rule 34 which works for < 32bpp, too."	form := self class adornmentWithColor: aColor.	aCanvas image: form at: (self innerBounds topRight - (form width@0))		sourceRect: form boundingBox rule: 34.! !!MessageSet methodsFor: '*morphic' stamp: 'cmm 2/19/2010 13:32'!representsSameBrowseeAs: anotherModel	^ self hasUnacceptedEdits not	and: [ messageList = anotherModel messageList ]! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'cmm 3/1/2010 16:06'!invokePrettyPrint: dummy	self prettyPrint: false.	^ true! !!TextEditor methodsFor: 'menu messages' stamp: 'cmm 2/18/2010 12:27'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ morph flash].	model browseAllImplementorsOf: aSelector! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 3/3/2010 05:18'!closeAllWindowsBut: window	(self allOtherWindowsLike: window) do: [:each |		each model canDiscardEdits ifTrue: [each delete]]! !!AlternatePluggableListMorphOfMany class methodsFor: 'instance creation' stamp: 'cmm 1/18/2002 16:08'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	^ self new		on: anObject		list: listSel		primarySelection: getSelectionSel		changePrimarySelection: setSelectionSel		listSelection: getListSel		changeListSelection: setListSel		menu: getMenuSel		keystroke: keyActionSel! !!AlternatePluggableListMorphOfMany methodsFor: 'event handling' stamp: 'cmm 3/2/2004 23:13'!mouseDown: event	| row |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	row := self rowAtLocation: event position.		row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^ self].  "No change if model is locked"	"Inform model of selected item and let it toggle."	self		changeModelSelection: row		shifted: event shiftPressed		controlled: event controlKeyPressed."	event hand releaseMouseFocus: aMorph.	submorphs do: [ :each | each changed ]"! !!AlternatePluggableListMorphOfMany methodsFor: 'drawing' stamp: 'cmm 1/18/2002 16:08'!listSelectionAt: index	getSelectionListSelector ifNil:[^false].	^model perform: getSelectionListSelector with: index! !!PluggableListMorph methodsFor: 'updating' stamp: 'cmm 3/2/2010 08:59'!verifyContents	"Verify the contents of the receiver, reconstituting if necessary.  Called whenever window is reactivated, to react to possible structural changes.  Also called periodically in morphic if the smartUpdating preference is true"	| newList existingSelection anIndex oldList |	oldList := list ifNil: [ #() ].	newList := self getList.	oldList = newList ifTrue: [ ^ self ].	existingSelection := self selectionIndex > 0 ifTrue: [ oldList at: self selectionIndex ] ifFalse: [ nil ].	self updateList.	(existingSelection notNil and: [(anIndex := list indexOf: existingSelection asStringOrText ifAbsent: [nil]) notNil])		ifTrue:			[model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifFalse:			[self changeModelSelection: 0]! !!AlternatePluggableListMorphOfMany methodsFor: 'initialization' stamp: 'cmm 12/24/2002 15:47'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel 	"setup a whole load of pluggability options"	getSelectionListSelector := getListSel.	setSelectionListSelector := setListSel.	self 		on: anObject		list: listSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !!AlternatePluggableListMorphOfMany methodsFor: 'initialization' stamp: 'cmm 1/18/2002 16:08'!list: listOfStrings	scroller removeAllMorphs.	list := listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	super list: listOfStrings.	"At this point first morph is sensitized, and all morphs share same handler."	scroller firstSubmorph on: #mouseEnterDragging						send: #mouseEnterDragging:onItem:						to: self.	scroller firstSubmorph on: #mouseUp						send: #mouseUp:onItem:						to: self.	"This should add this behavior to the shared event handler thus affecting all items"! !!AlternatePluggableListMorphOfMany methodsFor: 'event handling' stamp: 'cmm 12/14/2007 13:22'!mouseMove: event 	"The mouse has moved, as characterized by the event provided.  Adjust the scrollbar, and alter the selection as appropriate"	| oldIndex oldVal row |	event position y < self top 		ifTrue: 			[scrollBar scrollUp: 1.			row := self rowAtLocation: scroller topLeft + (1 @ 1)]		ifFalse: 			[row := event position y > self bottom 				ifTrue: 					[scrollBar scrollDown: 1.					self rowAtLocation: scroller bottomLeft + (1 @ -1)]				ifFalse: [ self rowAtLocation: event position]].	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^self].	"No change if model is locked"	"Set meaning for subsequent dragging of selection"	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	"Inform model of selected item and let it toggle."	self 		changeModelSelection: row		shifted: true		controlled: event controlKeyPressed.	submorphs do: [:each | each changed]! !!AlternatePluggableListMorphOfMany methodsFor: 'model access' stamp: 'cmm 1/18/2002 17:49'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	^self		changeModelSelection: anInteger		shifted: Sensor shiftPressed		controlled: Sensor controlKeyPressed! !!AlternatePluggableListMorphOfMany methodsFor: 'event handling' stamp: 'cmm 1/18/2002 17:45'!mouseUp: event	"Not needed.  Overridden to do nothing."! !!SmalltalkEditor class methodsFor: 'keyboard shortcut tables' stamp: 'cmm 3/1/2010 16:04'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	"SmalltalkEditor initialize"	| cmds |	super initializeShiftCmdKeyShortcuts.		cmds := #(		$a	argAdvance:		$b	browseItHere:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$g	fileItIn:		$i	exploreIt:		$n	referencesToIt:		$s	invokePrettyPrint:		$t	displayIfTrue:		$v	pasteInitials:		$w	methodNamesContainingIt:	).	1 to: cmds size by: 2 do: [ :i |		shiftCmdActions at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).			"plain keys"		shiftCmdActions at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"		shiftCmdActions at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1).		"ctrl keys"	].! !!AlternatePluggableListMorphOfMany methodsFor: 'event handling' stamp: 'cmm 1/18/2002 16:08'!update: aSymbol 	aSymbol == #allSelections ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self changed].	^ super update: aSymbol! !MorphicProject removeSelector: #currentVocabulary!