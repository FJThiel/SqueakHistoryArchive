"Change Set:		9738Multilingual-nice.104Multilingual-nice.104:Let nextPut: answer the put object.Same for nextPutAll:, answer the collection argumentMultilingual-nice.103:Do not let MultiCharacterScanner reserve space for one more character et end of run.This resolves FontTest>>testParagraphFallback"!!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'nice 3/18/2010 21:05'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| charCode encoding f startEncoding combining combined combiningIndex c |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		f := [font fontArray at: startEncoding + 1]			on: Exception do: [:ex | nil].		f ifNil: [ f := font fontArray at: 1].	].	spaceWidth := font widthOf: Space.	combining := nil.	[lastIndex <= stopIndex] whileTrue: [		charCode := (sourceString at: lastIndex) charCode.		c := (sourceString at: lastIndex).		combining ifNil: [			combining := CombinedChar new.			combining add: c.			combiningIndex := lastIndex.			lastIndex := lastIndex + 1.		] ifNotNil: [			(combining add: c) ifFalse: [				self addCharToPresentation: (combined := combining combined).				combining := CombinedChar new.				combining add: c.				charCode := combined charCode.				encoding := combined leadingChar.				encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1.					(encoding = 0 and: [charCode < 256 and:[(stops at: charCode + 1) notNil]]) ifTrue: [						^ stops at: charCode + 1					] ifFalse: [						 ^ stops endOfRun					].				].				(encoding = 0 and: [charCode < 256 and:[(stops at: charCode + 1) notNil]]) ifTrue: [					combining ifNotNil: [						self addCharToPresentation: (combining combined).					].					^ stops at: charCode + 1				].				(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [					self registerBreakableIndex.				].						destX > rightX ifTrue: [					destX ~= firstDestX ifTrue: [						lastIndex := combiningIndex.						self removeLastCharFromPresentation.						^ stops crossedX]].				combiningIndex := lastIndex.				lastIndex := lastIndex + 1.			] ifTrue: [				lastIndex := lastIndex + 1.				numOfComposition := numOfComposition + 1.			].		].	].	lastIndex := stopIndex.	combining ifNotNil: [		combined := combining combined.		self addCharToPresentation: combined.	].	^ stops endOfRun! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'nice 3/19/2010 19:05'!nextPut: aCharacter	aCharacter isInteger ifTrue: [^ super nextPut: aCharacter asCharacter].	self converter nextPut: aCharacter toStream: self.	^aCharacter! !!UnicodeCompositionStream methodsFor: 'accessing' stamp: 'nice 3/19/2010 19:07'!nextPut: anObject	self isCombining ifFalse: [		combinedChar := CombinedChar new.		combinedChar simpleAdd: anObject.	] ifTrue: [		(combinedChar simpleAdd: anObject) ifFalse: [			super nextPut: combinedChar combined.			combinedChar := CombinedChar new.			combinedChar simpleAdd: anObject.		]	].	^anObject! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'nice 3/19/2010 19:14'!nextPutAll: aCollection	self isBinary ifTrue: [		^ super nextPutAll: aCollection.	].	^aCollection do: [:e | self nextPut: e].! !!MultiByteFileStream methodsFor: 'public' stamp: 'nice 3/19/2010 19:06'!nextPut: aCharacter	aCharacter isInteger ifTrue: [ ^super nextPut: aCharacter ].	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifTrue: [			aCharacter = Cr				ifTrue: [					(LineEndStrings at: lineEndConvention) do: [ :each |						converter nextPut: each toStream: self ] ]				ifFalse: [ 					converter nextPut: aCharacter toStream: self ].			^aCharacter ].	self converter nextPut: aCharacter toStream: self.	^aCharacter! !!UnicodeCompositionStream methodsFor: 'accessing' stamp: 'nice 3/19/2010 19:15'!nextPutAll: aCollection	^aCollection do: [:e | self nextPut: e].! !!MultiByteFileStream methodsFor: 'public' stamp: 'nice 3/19/2010 19:14'!nextPutAll: aCollection	(self isBinary or: [aCollection class == ByteArray]) ifTrue: [		^ super nextPutAll: aCollection.	].	self converter nextPutAll: aCollection toStream: self.	^aCollection! !