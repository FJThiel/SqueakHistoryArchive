"Change Set:		9784Traits-nice.285Traits-nice.285:Use literalEqual: rather than = to test for compiled code equality.We don't want 256000.0s1 = 256000.0e0 nor = 256000Traits-nice.284:Don't use closeTo: when comparing compiledMethod.Either two methods are equals or not (or we could fuzzify String equality to with sameAs: or other trick....).The hack was previously necessary due to roundoff errors in printing and reading a Float.This is not the case anymore: Float literals now storeOn: and readFrom: exactly.."!!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'nice 3/22/2010 22:07'!sameTraitCodeAs: method	"Answer whether the receiver implements the same code as the 	argument, method. Does not look at properties/pragmas since they	do not affect the resulting code."	| numLits |	(method isKindOf: CompiledMethod) ifFalse: [^false].	self methodHome == method methodHome ifFalse:[^false].	(self properties analogousCodeTo: method properties) ifFalse:[^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(numLits := self numLiterals) ~= method numLiterals ifTrue: [^false].	1 to: numLits-2 do:[:i| | lit1 lit2 |		lit1 := self literalAt: i.		lit2 := method literalAt: i.		(lit1 == lit2 or: [lit1 literalEqual: lit2]) ifFalse: [			(i = 1 and: [#(117 120) includes: self primitive]) ifTrue: [				lit1 isArray ifTrue:[					(lit2 isArray and: [lit1 allButLast = lit2 allButLast]) ifFalse:[^false]				] ifFalse: "ExternalLibraryFunction"					[(lit1 analogousCodeTo: lit2) ifFalse:[^false]].			] ifFalse:[				"any other discrepancy is a failure"^ false]]].	^true! !