"Change Set:		8445Monticello-ar.336Monticello-ar.336:Repairing the confusion about MethodReference>>category: Put it back into Monticello temporarily so that we can transfer it properly to the System packageMonticello-ar.334:A little white lie: When loading sizable packages, most of the time can be spent in notifying the observers. Tell the users that we're still installing because it's embarrassing to let them know that we're wasting our time in notifications.Monticello-ul.335:- replace sends of #ifNotNilDo: to #ifNotNil:, #ifNil:ifNotNilDo: to #ifNil:ifNotNil:, #ifNotNilDo:ifNil: to #ifNotNil:ifNil:"!!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!openRepository	self repository ifNotNil: [:repos | repos morphicOpen: workingCopy ]! !!MCMergingTest methodsFor: 'emulating' stamp: 'ul 12/12/2009 14:12'!handleConflict: aConflict		|l r|	l := #removed.	r := #removed.	aConflict localDefinition ifNotNil: [:d | l := d token].	aConflict remoteDefinition ifNotNil: [:d | r := d token].		conflicts := conflicts copyWith: (Array with: r with: l).	(l = #removed or: [r = #removed])		ifTrue: [aConflict chooseRemote]		ifFalse:			[l > r				ifTrue: [aConflict chooseLocal]				ifFalse: [aConflict chooseRemote]]		! !!MCPackageLoader methodsFor: 'private' stamp: 'ar 12/10/2009 00:16'!basicLoad	errorDefinitions := OrderedCollection new.	[["Pass 1: Load everything but the methods,  which are collected in methodAdditions."	additions do: [:ea | 		[ea isMethodDefinition 			ifTrue:[methodAdditions add: ea asMethodAddition]			ifFalse:[ea load]]on: Error do: [errorDefinitions add: ea].	] displayingProgress: 'Reshaping classes...'.	"Pass 2: We compile new / changed methods"	methodAdditions do:[:ea| ea createCompiledMethod] displayingProgress: 'Compiling...'.	'Installing...' displayProgressAt: Sensor cursorPoint from: 0 to: 2 during:[:bar|		"There is progress *during* installation since a progress bar update		will redraw the world and potentially call methods that we're just trying to install."		bar value: 1.		"Pass 3: Install the new / changed methods		(this is a separate pass to allow compiler changes to be loaded)"		methodAdditions do:[:ea| ea installMethod].		"Pass 4: Remove the obsolete methods"		removals do:[:ea| ea unload].	].	"Try again any delayed definitions"	self shouldWarnAboutErrors ifTrue: [self warnAboutErrors].	errorDefinitions do: [:ea | ea load] displayingProgress: 'Reloading...'.	"Finally, notify observers for the method additions"	methodAdditions do: [:each | each notifyObservers] 		"the message is fake but actually telling people how much time we spend		in the notifications is embarrassing so lie instead"		displayingProgress: 'Installing...'.	additions do: [:ea | ea postloadOver: (self obsoletionFor: ea)] displayingProgress: 'Initializing...'	] on: InMidstOfFileinNotification do: [:n | n resume: true]	] ensure: [self flushChangesFile]! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!annotations	^operation ifNotNil: [ :op | op annotations ]! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!versionReaderForFileNamed: aString do: aBlock	^ (self versionReaderForFileNamed: aString) ifNotNil: aBlock! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!addRepositoryToWorkingCopy	workingCopy ifNotNil:		[:wc |			workingCopy repositoryGroup addRepository: self repository.			self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]! !!MCDirectoryRepository class methodsFor: 'instance creation' stamp: 'ul 12/12/2009 14:10'!morphicConfigure	^ FileList2 modalFolderSelector ifNotNil:		[:directory |		self new directory: directory]! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!save	self pickRepository ifNotNil:		[:ea |		ea storeVersion: self version]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!extractDefinitionsFrom: member	| reader |	(MCSnapshotReader readerClassForFileNamed: member fileName)		ifNotNil: [:rc | reader := rc on: member contentStream text.					definitions addAll: reader definitions]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!addDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other |			(self removalForDefinition: aDefinition)				ifNotNil:					[:op |					self addOperation: (MCModification of: other to: aDefinition).					self removeOperation: op.					^ self].			other = aDefinition				ifFalse: [self addConflictWithOperation: (MCModification of: other to: aDefinition)]				ifTrue: [self redundantAdds add: aDefinition]]		ifAbsent: [self addOperation: (MCAddition of: aDefinition)]! !!MCAncestryTest methodsFor: 'building' stamp: 'ul 12/12/2009 14:10'!versionForName: name in: tree	(tree name = name) ifTrue: [^ tree].		tree ancestors do: [:ea | (self versionForName: name in: ea) ifNotNil: [:v | ^ v]].		^ nil! !!MCConflict methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!definition	^operation ifNotNil: [ :op | op definition ]! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!assertDict: dict matchesInfo: info	#(name id message date time author)		do: [:sel |  (info perform: sel) ifNotNil: [:i | dict at: sel ifPresent: [:d | self assert: i = d]]].	info ancestors 			with: (dict at: #ancestors) 			do: [:i :d | self assertDict: d matchesInfo: i]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!addRequiredPackage	| chosen |	workingCopy ifNotNil:		[:wc |		chosen := self pickWorkingCopySatisfying: 			[:ea | ea ~= wc and: [(wc requiredPackages includes: ea package) not]].		chosen ifNotNil:			[wc requirePackage: chosen package.			self workingCopyListChanged]]! !!MCClassDefinition methodsFor: 'installing' stamp: 'ul 12/12/2009 14:10'!load	 self createClass ifNotNil:		[:class |		class class instanceVariableNames: self classInstanceVariablesString.		self hasComment ifTrue: [class classComment: comment stamp: commentStamp]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!clearRequiredPackages	workingCopy ifNotNil:		[:wc |		wc clearRequiredPackages.		self workingCopyListChanged]! !!MCDoItParser class methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!forDoit: aString	^ (self subclassForDoit: aString) ifNotNil: [:c | c new source: aString]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!revertPackage	self pickAncestorVersionInfo ifNotNil: [:info |		(self repositoryGroup versionWithInfo: info			ifNone: [^self inform: 'No repository found for ', info name]		) load]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'ul 12/12/2009 14:09'!backportChangesTo: aVersionInfo	| baseVersion fullPatch currentVersionInfo currentVersion newSnapshot newAncestry |	currentVersionInfo := self currentVersionInfo.	baseVersion := self repositoryGroup versionWithInfo: aVersionInfo.	currentVersion := self repositoryGroup versionWithInfo: currentVersionInfo.	fullPatch := currentVersion snapshot patchRelativeToBase: baseVersion snapshot.	(MCChangeSelectionRequest new		patch: fullPatch;		label: 'Changes to Backport';		signal ) ifNotNil:		[:partialPatch |		newSnapshot := MCPatcher apply: partialPatch to: baseVersion snapshot.		newAncestry := MCWorkingAncestry new							addAncestor: aVersionInfo;							addStepChild: currentVersionInfo;							yourself.		MCPackageLoader updatePackage: package withSnapshot: newSnapshot.		ancestry := newAncestry.		self modified: false; modified: true]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!versionReaderForFileNamed: aString do: aBlock	^ self		readStreamForFileNamed: aString		do: [:s |			(MCVersionReader readerClassForFileNamed: aString) ifNotNil:				[:class | aBlock value: (class on: s fileName: aString)]]! !!MCMczReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!loadDefinitions	definitions := OrderedCollection new.	(self zip memberNamed: 'snapshot.bin') ifNotNil:		[:m | [^ definitions := (DataStream on: m contentStream) next definitions]			on: Error do: [:fallThrough ]].	"otherwise"	(self zip membersMatching: 'snapshot/*')		do: [:m | self extractDefinitionsFrom: m].! !!MCCodeTool methodsFor: 'menus' stamp: 'ul 12/12/2009 14:10'!adoptMessageInCurrentChangeset	"Add the receiver's method to the current change set if not already there"	self selectedClassOrMetaClass ifNotNil: [ :cl |		self selectedMessageName ifNotNil: [ :sel |			ChangeSet current adoptSelector: sel forClass: cl.			self changed: #annotations ]]! !!MCPackageManager methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:10'!modified: aBoolean     modified = aBoolean ifTrue: [^ self].	modified := aBoolean.	self changed: #modified.		modified ifFalse:		[(((Smalltalk classNamed: 'SmalltalkImage') ifNotNil: [:si | si current]) ifNil: [Smalltalk])			logChange: '"', self packageName, '"'].! !!MCRepository methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!closestAncestorVersionFor: anAncestry ifNone: errorBlock	anAncestry breadthFirstAncestorsDo:		[:ancestorInfo |		(self versionWithInfo: ancestorInfo) ifNotNil: [:v | ^ v]].	^ errorBlock value! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!removeRepository	self repository ifNotNil:		[:repos |		self repositoryGroup removeRepository: repos.		self repositorySelection: (1 min: self repositories size)].	self changed: #repositoryList.	self changedButtons.! !!MCStReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!addDefinitionsFromDoit: aString	(MCDoItParser forDoit: aString) ifNotNil:		[:parser |		parser addDefinitionsTo: definitions]! !!MCThreeWayMerger methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!removeDefinition: aDefinition	index		definitionLike: aDefinition		ifPresent: [:other | other = aDefinition								ifTrue:									[(self modificationConflictForDefinition: aDefinition)										ifNotNil:											[:c |											self addOperation: c operation.											self removeConflict: c.											^ self]. 									(self redundantAdds includes: aDefinition)										ifFalse: [self addOperation: (MCRemoval of: aDefinition)]]								ifFalse:									[self addConflictWithOperation: (MCRemoval of: other)]]		ifAbsent: []! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:12'!addRepositoryToPackage	self repository ifNotNil:		[:repos |		(self pickWorkingCopySatisfying: [ :p | (p repositoryGroup includes: repos) not ]) ifNotNil:			[:wc |			workingCopy := wc.			workingCopy repositoryGroup addRepository: repos.			self repository: repos.				self				changed: #workingCopySelection;				changed: #repositoryList;				changed: #repositorySelection.			self changedButtons]]! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!backportChanges	self canBackport ifFalse: [^self].	workingCopy ifNotNil:		[workingCopy needsSaving ifTrue: [^ self inform: 'You must save the working copy before backporting.'].		self pickAncestorVersionInfo ifNotNil:			[:baseVersionInfo |			workingCopy backportChangesTo: baseVersionInfo]]! !!MCWorkingCopy methodsFor: 'operations' stamp: 'ul 12/12/2009 14:09'!newVersion	^ (self requestVersionNameAndMessageWithSuggestion: self uniqueVersionName) ifNotNil:		[:pair |		self newVersionWithName: pair first message: pair last].! !!MCRepositoryGroup methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!versionWithInfo: aVersionInfo ifNone: aBlock	self repositoriesDo: [:ea | (ea versionWithInfo: aVersionInfo) ifNotNil: [:v | ^ v]].	^aBlock value! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!saveVersion	| repo |	self canSave ifFalse: [^self].	repo := self repository.	workingCopy newVersion ifNotNil:		[:v |		(MCVersionInspector new version: v) show.		Cursor wait showWhile: [repo storeVersion: v].		MCCacheRepository default cacheAllFileNamesDuring: 			[repo cacheAllFileNamesDuring: 				[v allAvailableDependenciesDo:					[:dep |					(repo includesVersionNamed: dep info name)						ifFalse: [repo storeVersion: dep]]]]]! !!MCMethodDefinition methodsFor: 'installing' stamp: 'ul 12/12/2009 14:10'!unload	| previousVersion |	self isOverrideMethod ifTrue: [previousVersion := self scanForPreviousVersion].	previousVersion		ifNil: [self actualClass ifNotNil: [:class | class removeSelector: selector]]		ifNotNil: [previousVersion fileIn] ! !!MCWorkingCopyBrowser methodsFor: 'actions' stamp: 'ul 12/12/2009 14:09'!addRepository	self newRepository ifNotNil:		[:repos | self addRepository: repos ].! !!MCTraitDefinition methodsFor: 'installing' stamp: 'ul 12/12/2009 14:09'!load	 self createClass ifNotNil: [:trait |		self hasComment ifTrue: [trait classComment: comment stamp: commentStamp]]! !!MCMcdReader methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!loadPatch	| old new |	(self zip memberNamed: 'patch.bin') ifNotNil:		[:m | [^ patch := (DataStream on: m contentStream) next ]			on: Error do: [:fallThrough ]].	definitions := OrderedCollection new.	(self zip membersMatching: 'old/*')		do: [:m | self extractDefinitionsFrom: m].	old := definitions asArray.	definitions := OrderedCollection new.	(self zip membersMatching: 'new/*')		do: [:m | self extractDefinitionsFrom: m].	new := definitions asArray.	^ patch := self buildPatchFrom: old to: new.	! !!MCVersionInspector methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:09'!diff	| ancestorVersion |	self pickAncestor ifNotNil:		[:ancestor |		ancestorVersion := self version workingCopy repositoryGroup versionWithInfo: ancestor.		(self version asDiffAgainst: ancestorVersion) open]! !!MCSnapshotBrowser methodsFor: 'menus' stamp: 'ul 12/12/2009 14:09'!methodListMenu: aMenu 	super methodListMenu: aMenu.	self selectedMessageName		ifNotNil: [:msgName | aMenu addLine; add: 'load method' translated action: #loadMethodSelection].	^ aMenu! !!MethodReference methodsFor: '*monticello' stamp: 'mtf 10/4/2008 01:18'!category	^ category ifNil: [category := self actualClass organization categoryOfElement: methodSymbol]! !