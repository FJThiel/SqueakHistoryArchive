"Change Set:		7955Kernel-ar.267Kernel-ar.267:Create Kernel-Models category and promote ValueHolder and StringHolder to be a Kernel (instead of an ST80) entity. Enables support for Model-based Tools without having MVC loaded."!Array weakSubclass: #DependentsArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Models'!ScrollController subclass: #ParagraphEditor	instanceVariableNames: 'paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing otherInterval lastParentLocation'	classVariableNames: 'ChangeText CmdActions FindText Keyboard ShiftCmdActions UndoInterval UndoMessage UndoParagraph UndoSelection Undone'	poolDictionaries: 'TextConstants'	category: 'Kernel-Models'!Model subclass: #ValueHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Models'!Model subclass: #StringHolder	instanceVariableNames: 'contents'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Models'!Object subclass: #Model	instanceVariableNames: 'dependents'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Models'!!StringHolder methodsFor: 'accessing' stamp: 'sw 12/6/2000 17:48'!reformulateListNoting: newSelector	"A method has possibly been submitted for the receiver with newSelector as its selector; If the receiver has a way of reformulating its message list, here is a chance for it to do so"	^ self reformulateList! !!StringHolder class methodsFor: 'class initialization' stamp: ''!initialize	"The class variables were initialized once, and subsequently filled with	information. Re-executing this method is therefore dangerous." 	 	"workSpace := StringHolder new"	"StringHolder initialize"! !!StringHolder methodsFor: 'accessing' stamp: 'di 11/23/1998 15:21'!textContents: aStringOrText 	"Set aStringOrText to be the contents of the receiver."	contents := aStringOrText! !!StringHolder class methodsFor: 'yellow button menu' stamp: 'ar 10/5/2009 23:19'!shiftedYellowButtonMenuItems	"Returns the standard yellow button menu items"	^{		{'explain' translated.						#explain}.		{'pretty print' translated.					#prettyPrint}.		{'pretty print with color' translated.		#prettyPrintWithColor}.		{'file it in (G)' translated.					#fileItIn}.		{'tiles from it' translated.					#selectionAsTiles}.		{'spawn (o)' translated.						#spawn}.		#-.		{'browse it (b)' translated.					#browseIt}.		{'senders of it (n)' translated.				#sendersOfIt}.		{'implementors of it (m)' translated.		#implementorsOfIt}.		{'references to it (N)' translated.			#referencesToIt}.		#-.		{'selectors containing it (W)' translated.	#methodNamesContainingIt}.		{'method strings with it (E)' translated.	#methodStringsContainingit}.		{'method source with it' translated.		#methodSourceContainingIt}.		{'class names containing it' translated.	#classNamesContainingIt}.		{'class comments with it' translated.		#classCommentsContainingIt}.		{'change sets with it' translated.			#browseChangeSetsWithSelector}.		#-.		{'save contents to file...' translated.		#saveContentsInFile}.		{'send contents to printer' translated.	#sendContentsToPrinter}.		{'printer setup' translated.					#printerSetup}.		#-.		{'special menu...' translated.				#presentSpecialMenu}.		{'more...' translated.						#yellowButtonActivity}.	}! !!StringHolder class methodsFor: 'window color' stamp: 'sw 2/26/2002 14:44'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name wording: 'Workspace' brightColor: #lightYellow pastelColor: #paleYellow helpMessage: 'A place for text in a window.'! !!StringHolder methodsFor: 'code pane menu' stamp: 'ar 10/5/2009 23:24'!codePaneMenu: aMenu shifted: shifted	"Fill in the given menu with additional items. The menu is prepoulated with the 'standard' text commands that the editor supports. Note that unless we override perform:orSendTo:, the editor will respond to all menu items in a text pane"	^self class codePaneMenu: aMenu shifted: shifted! !!StringHolder methodsFor: 'accessing' stamp: ''!contents	"Answer the contents that the receiver is holding--presumably a string."	^contents! !!StringHolder methodsFor: 'optional panes' stamp: 'sw 1/24/2001 21:25'!wantsAnnotationPane	"Answer whether the receiver, seen in some browser window, would like to have the so-called  annotationpane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences annotationPanes! !!StringHolder class methodsFor: 'yellow button menu' stamp: 'ar 10/5/2009 23:17'!yellowButtonMenuItems	"Returns the standard yellow button menu items"	^{			{'set font... (k)' translated.				#offerFontMenu}.			{'set style... (K)' translated.				#changeStyle}.			{'set alignment... (u)' translated.		#chooseAlignment}.			#-.			{'make project link (P)' translated.	#makeProjectLink}.			#-.			{'find...(f)' translated.					#find}.			{'find again (g)' translated.				#findAgain}.			{'set search string (h)' translated.		#setSearchString}.			#-.			{'do again (j)' translated.				#again}.			{'undo (z)' translated.					#undo}.			#-.			{'copy (c)' translated.					#copySelection}.			{'cut (x)' translated.						#cut}.			{'paste (v)' translated.					#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			     		{'print it (p)' translated.		#printIt}.		     		{'inspect it (i)' translated.		#inspectIt}.		     		{'explore it (I)' translated.		#exploreIt}.		     		{'debug it' translated.			#debugIt}.		     		{'tally it' translated.			#tallyIt}.			#-.			{'accept (s)' translated.					#accept}.			{'cancel (l)' translated.					#cancel}.			#-.			{'show bytecodes' translated.			#showBytecodes}.			#-.			{'copy html' translated.					#copyHtml}.			#-.			{'more...' translated.					#shiftedTextPaneMenuRequest}.		}! !!StringHolder methodsFor: 'accessing' stamp: 'sw 1/12/1999 11:47'!contents: textOrString 	"Set textOrString to be the contents of the receiver."	contents := textOrString "asString"! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 14:59'!selectedClassName	"I may know what class is currently selected"	self selectedClass ifNotNil: [^ self selectedClass name].	^ nil! !!StringHolder methodsFor: 'accessing' stamp: 'sw 12/9/2000 23:59'!noteAcceptanceOfCodeFor: aSelector	"A method has possibly been submitted for the receiver with aSelector as its selector; If the receiver wishes to take soem action here is a chance for it to do so"! !!StringHolder methodsFor: 'code pane menu' stamp: 'tk 4/6/98 11:43'!showBytecodes	"We don't know how to do this"	^ self changed: #flash! !!StringHolder methodsFor: 'tiles' stamp: 'di 11/4/2000 11:07'!openSyntaxView	"Open a syntax view on the current method"	| class selector |	(selector := self selectedMessageName) ifNotNil: [		class := self selectedClassOrMetaClass.		SyntaxMorph testClass: class andMethod: selector.	]! !!StringHolder methodsFor: 'evaluation' stamp: ''!doItContext	"Answer the context in which a text selection can be evaluated."	^nil! !!StringHolder class methodsFor: 'instance creation' stamp: 'tk 5/4/1998 16:41'!openLabel: aString	self new openLabel: aString! !!StringHolder methodsFor: 'code pane menu' stamp: 'wod 5/29/1998 16:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'accessing' stamp: 'nk 4/29/2004 12:32'!classCommentIndicated	"Answer true iff we're viewing the class comment."	^false! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 15:22'!selectedMessageName	^ nil! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 23:46'!buildCodePaneWith: builder	| textSpec |	textSpec := builder pluggableTextSpec new.	textSpec 		model: self;		getText: #contents; 		setText: #contents:notifying:; 		selection: #contentsSelection; 		menu: #codePaneMenu:shifted:.	^textSpec! !!StringHolder methodsFor: 'user edits' stamp: 'di 4/21/1998 11:30'!clearUserEditFlag	"Clear the hasUnacceptedEdits flag in all my dependent views."	self changed: #clearUserEdits! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/3/98 22:50'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^ 1 to: 0  "null selection"! !!StringHolder methodsFor: 'initialize-release' stamp: 'jm 3/24/98 17:56'!initialize	"Initialize the state of the receiver with its default contents."	contents := self defaultContents.! !!StringHolder methodsFor: 'accessing' stamp: 'sw 12/1/2000 11:04'!reformulateList	"If the receiver has a way of reformulating its message list, here is a chance for it to do so"! !!StringHolder class methodsFor: 'yellow button menu' stamp: 'ar 10/6/2009 10:36'!codePaneMenu: aMenu shifted: shifted	"Utility method for the 'standard' codePane menu"	aMenu addList: (shifted 		ifTrue:[self shiftedYellowButtonMenuItems]		ifFalse:[self yellowButtonMenuItems]).	^aMenu! !!StringHolder methodsFor: 'user edits' stamp: 'tk 4/13/1998 23:07'!okToChange	self canDiscardEdits ifTrue: [^ true].	self changed: #wantToChange.  "Solicit cancel from view"	^ self canDiscardEdits! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 17:16'!optionalButtonPairs	"Answer a tuple (formerly pairs) defining buttons, in the format:			button label			selector to send			help message"	^#()! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 11:15'!buildWith: builder	| windowSpec |	windowSpec := 	self buildWindowWith: builder specs: {		(0@0corner: 1@1) -> [self buildCodePaneWith: builder].	}.	^builder build: windowSpec! !!StringHolder class methodsFor: 'instance creation' stamp: 'ar 9/27/2005 20:48'!open	(Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'ls 8/5/1998 07:49'!contents	^contents! !!ValueHolder methodsFor: 'as yet unclassified' stamp: 'sw 1/28/1999 12:35'!contents: newContents	contents := newContents.	self contentsChanged! !!StringHolder methodsFor: 'accessing' stamp: 'tk 4/18/1998 15:01'!selectedClassOrMetaClass	^ self selectedClass	"I don't know any better"! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 11:12'!buildWindowWith: builder specs: specs	| windowSpec rect action widgetSpec |	windowSpec := self buildWindowWith: builder.	specs do:[:assoc|		rect := assoc key.		action := assoc value.		widgetSpec := action value.		widgetSpec ifNotNil:[			widgetSpec frame: rect.			windowSpec children add: widgetSpec]].	^windowSpec! !!StringHolder methodsFor: 'code pane menu' stamp: 'ar 9/27/2005 20:47'!spawn: contentsString	UIManager default edit: contentsString label: 'Workspace'! !!StringHolder methodsFor: 'code pane menu' stamp: 'ar 8/8/2009 22:58'!contents: aString notifying: aController 	"Accept text"	^self acceptContents: aString! !!StringHolder methodsFor: 'accessing' stamp: 'di 5/19/1998 15:34'!acceptContents: aString 	"Set aString to be the contents of the receiver.  Return true cuz happy"	self contents: aString.	^ true! !!StringHolder methodsFor: 'initialize-release' stamp: 'ar 8/7/2009 22:27'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	^ToolBuilder open: self label: aString! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 12:18'!labelString	^self class name! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 17:14'!buildOptionalButtonsWith: builder	| panelSpec buttonSpec |	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	self optionalButtonPairs do:[:spec|		buttonSpec := builder pluggableActionButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		spec size > 2 ifTrue:[buttonSpec help: spec third].		panelSpec children add: buttonSpec.	].	panelSpec layout: #horizontal. "buttons"	^panelSpec! !!StringHolder methodsFor: 'evaluation' stamp: ''!doItReceiver	"Answer the object that should be informed of the result of evaluating a 	text selection."	^nil! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 17:16'!annotation	^''! !!StringHolder methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 12:31'!buildWindowWith: builder	| windowSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec model: self.	windowSpec label: #labelString.	windowSpec children: OrderedCollection new.	^windowSpec! !!StringHolder methodsFor: 'optional panes' stamp: 'sw 1/24/2001 18:57'!wantsOptionalButtons	"Answer whether the receiver, seen in some browser window, would like to have the so-called optional button pane included.  By default, various browsers defer to the global preference 'optionalButtons' -- but individual subclasses can insist to the contrary."	^ Preferences optionalButtons! !!StringHolder methodsFor: 'initialize-release' stamp: ''!defaultContents	^''! !StringHolder initialize!