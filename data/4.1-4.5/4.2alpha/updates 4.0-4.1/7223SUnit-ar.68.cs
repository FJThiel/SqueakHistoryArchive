"Change Set:		7223SUnit-ar.68SUnit-ar.68:Merge SUnitGUI from Pharo to support package based test coverage.SUnit-marcus.denker.34:Cleaning duplicated code, some misc fixesSUnit-AlexandreBergel.35:Adding an history for SUnit. Pair programming with GwenaelSUnit-GwenaelCasaccio.36:Added a show progress in the TestRunnerSUnit-stephane.ducasse.37:fixing self halt in the code!!!SUnit-al.38:method categories cleanup by Lukas Renggli #241.	- remove empty categories	- sort all categories	- make all categories lower case	- replace #initialize-release/#class-initialization with #initializationSUnit-lr.39:- don't show timestamp in print string of test resultSUnit-AlexandreBergel.40:SUnit is now a client to SystemChangeNotification. This is necessary to get notified when a method change occurs. In the new version of OB we have new icons in front of a test method that shows whether this method has passed, has failed, triggered an error. It also use special icons to see whether it is a progress or not (compared with the sunit rest that was stored when pressing 'Store result').Note we took care to not introduce any dependency between SUnit and OB. If we failed on something, please let us know. this change is the result of a pair programming session with David R., Simon D., and me. SUnit-DavidRoethlisberger.41:re-committed SUnit-AlexandreBergel.40 because it was broken (t1, t2, etc. used everywhere)SUnit-DavidRoethlisberger.42:- merge with stephane_ducassse.denker.41- added methods being overridden by keralaSUnit-simon_denier.43:create history in TestResult class side.change TestCase to use TestResult for lastRun retrieval.lastStored also use TestResult history for content generationSUnit-simon_denier.44:Remove method from test history when changedRetrieve an empty dictionary when asked for non-existant test historySUnit-simon_denier.45:rename testClasses in classesTested to avoid confusion with a test methodSUnit-simon_denier.46:debug TestCase class>>methodChanged: and relatedSUnit-simon_denier.47:update last stored only if necessary, ie change in test methods state since last storeSUnit-simon_denier.48:test reference for sunit package (+ hope it will remove history category in TestCase)SUnit-sd.49:Morph D->I cleaning	defaultVariableName	doMenuItem:	noteNegotiatedName: uniqueName for: requestedName     variableDocks- SUnit extension (icon)SUnit-simon_denier.50:Remove author from test dictionary data.Update test history from OB test run (including partial update)SUnit-simon_denier.51:refactoringSUnit-simon_denier.52:-Bug correction: author remove test history data so no more author popup.-Enhancement: history support when running tests from OB (cmd-t)SUnit-stephane_ducasse.53:Simon fixes to icons tests No author pop upSUnit-ab.54:The class TestCase is extended with few methods that enables a simple code coverage. It essentially checks for method calls in the test, and compare them with the set of defined methods. For example, OrderedCollectionTest coverageAsString ==> 'OrderedCollectionTest covers 60% of OrderedCollection'to get these results for all collections:(((Smalltalk allClasses select: [:cls | cls category beginsWith: 'CollectionsTests-']) copyWithoutAll: {TextAndTextStreamTest . TextLineEndingsTest}) collect: [:cls | cls coverageAsString]) do: [:str | Transcript show: str; cr]SUnit-stephane_ducasse.55:- More test in DictionaryTest. The class Dictionary is now covered at 66%- Issue 433: TPureBehavior>>traits to get a collection of used traits.- Issue 226:  	 Resize comment pane in Monticello browser- Issue 426:  	 Code coverage- Collection extension: groupedBy, flatCollect:, collectAsSet:, should remove sixx as packageSUnit-adrian_lienhard.56:- Issue 363: fix some traits issues (introduced by changes in Metaclass and TestCase)- Traits conflict marker methods stored in wrong cache - Remove duplicated method in trait and class that uses it (in collection tests)- Issue 315: darker colors in diff dialog (thanks to Damien Pollet)- Issue 342: Removing beginning capital letter of instance variables (Alexandre Bergel)- Make MC always display dependencies of a version in its summary text- Issue: 101: fasterDayOfYear-brp.1 (Mantis 7156)- Issue 102: better testPrintShowingDecimalPlacesSUnit-stephane_ducasse.57:- More collection tests- SUnit coverage improved - allSelectorsAbove, allSelectorUntil:, allSuperclassesIncluding:- polymorphWidgetsSUnit-al.58:Make edge case where method is an object work.SUnit-al.59:Make edge case where method is an object work.SUnit-marcus_denker.60:Issue 464:	Added subclass: and subclass:instanceVariableNames:	Issue 456:	7272: BlockContext equality test is missingIssue 518:	 -94 asInteger --> 94SUnit-al.59: Make edge case where method is an object work.Tests-al.41: Clean up TestObjectsAsMethods (do a proper tearDown)SUnit-adrian_lienhard.61:Issue 628: Shortcut for 'Debug it' (thanks cdrick65)Issue 633: Bring back keyboard shortcut for 'case insensitive search for method strings containing it'Issue 625: 'recent submissions' missingIssue 626: TestRunner showing wrong status colour when expected failures are present (thanks Julien)SUnit-Alexandre_Bergel.62:History is now stored in each TestUnit class. TestResult does not have an History class variable. A new class-instance variable has been defined in TestCase called history. Each subclass of TestCase will therefore have its own history.SUnit-stephane_ducasse.63:- Issue 807:	Mantis 7351: SmalltalkImage image suffix problem not solved by 5851	Fix for issue http://code.google.com/p/pharo/issues/detail?id=807mantis http://bugs.squeak.org/view.php?id=7351Clean-up some SmalltalkImage imageSuffix mess- Issue 711:	SUnit history designSUnit-alain_plantec.64:issue135 fixedSUnit-stephane_ducasse.65:super initialize second halfIssue 135 Thanks alain.SUnit-onierstrasz.66:Added TestCase>>assert:equals: (from dc)Fixes http://code.google.com/p/pharo/issues/detail?id=939SUnit-stephane_ducasse.67:Issue 943:	fix polymorph cursor	Polymorph 	Fix for colouring of submenu markers.	W2K Improvements.	Fix for drop-list button label in W2K theme.	Support for adjustment of label inset for buttons when pressed.	Added #setColor: to ColorPresenterMorph to enable use without a model.Quit gets back its normal behaviorIssue 944:	SUnit assert:equalsSUnit assert equals + better feedback message"!TestCase subclass: #ClassFactoryForTestCaseTest	instanceVariableNames: 'factory'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Tests'!Object subclass: #TestCase	instanceVariableNames: 'testSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!Object subclass: #ClassFactoryForTestCase	instanceVariableNames: 'createdClasses'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Extensions'!Object subclass: #TestResult	instanceVariableNames: 'timeStamp failures errors passed'	classVariableNames: ''	poolDictionaries: ''	category: 'SUnit-Kernel'!!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 10/26/2008 14:08'!newName	| postFix |	postFix := (self createdClasses size + 1) printString.	^#ClassForTestToBeDeleted, postFix! !!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 16:33'!deletePackage	| categoriesMatchString |	categoriesMatchString := self packageName, '-*'.	SystemOrganization removeCategoriesMatching: categoriesMatchString! !!TestResult class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:44'!historyAt: aTestCaseClass"I will return the last test dictionary for aTestCaseClass. If none found, I will create a new empty one and link it in the history."	^ aTestCaseClass history ! !!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 14:01'!createdClasses: classes	createdClasses := classes asIdentitySet ! !!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 15:04'!localCoverageAsString	| cov className |	cov := self localCoverage first asInteger. 	"coverage already checks that the name is ends with 'Test' and if the class tested exists"		className := self name copyFrom: 1 to: (self name size - 'Test' size).	^ self name asString, ' covers ', cov asString, '% of ', className.! !!ResumableTestFailureTestCase methodsFor: 'not categorized' stamp: ''!testResumable	| result suite |	suite := TestSuite new.	suite addTest: (self class selector: #errorTest).	suite addTest: (self class selector: #regularTestFailureTest).	suite addTest: (self class selector: #resumableTestFailureTest).	suite addTest: (self class selector: #okTest).	result := suite run.	self assert: result failures size = 2;		assert: result errors size = 1			! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 16:00'!methodProgressed: aSelector	^ ((self storedMethodRaisedError: aSelector) or: [self storedMethodFailed: aSelector])		and: [self methodPassed: aSelector]		! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!dummy	self assert: true			! !!TestResult methodsFor: 'querying' stamp: 'GwenaelCasaccio 10/1/2008 22:37'!isErrorFor: class selector: selector	^ self errors anySatisfy: [:testCase | testCase class == class and: [testCase selector == selector]]! !!SUnitExtensionsTest class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!lastStoredRun	^ ((Dictionary new) add: (#passed->((Set new) add: #testNoExceptionWithMatchingString; add: #testNoExceptionWithNoMatchingString; add: #testExceptionWithMatchingString; add: #testExceptionWithoutMatchingString; add: #testValidShouldNotTakeMoreThan; add: #testInvalidShouldNotTakeMoreThanMilliseconds; add: #testDifferentExceptionInShouldRaiseWithExceptionDo; add: #testShouldRaiseWithExceptionDo; add: #testShouldFix; add: #testAssertionFailedInRaiseWithExceptionDo; add: #testAutoDenyFalse; add: #testAutoDenyTrue; add: #testAutoAssertFalse; add: #testAutoAssertTrue; add: #testValidShouldNotTakeMoreThanMilliseconds; add: #testErrorInRaiseWithExceptionDo; add: #testNoExceptionInShouldRaiseWithExceptionDo; add: #testInvalidShouldNotTakeMoreThan; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !!TestCase methodsFor: 'running' stamp: 'GwenaelCasaccio 10/1/2008 19:58'!run: aResult 	aResult runCase: self.! !!TestResult methodsFor: 'accessing' stamp: 'AlexandreBergel 10/1/2008 11:52'!timeStamp: anObject	timeStamp := anObject! !!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 14:20'!cleanUpChangeSetForClassNames: classeNames	| changeSet |	changeSet := ChangeSet current.	classeNames do: [:name|		changeSet 			removeClassChanges: name;			removeClassChanges: name, ' class'].	! !!TestResult class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:45'!historyAt: aTestCaseClass put: aDictionary	aTestCaseClass history: aDictionary	"^ self history at: aTestCaseClass put: aDictionary "! !!TestCase class methodsFor: 'history' stamp: 'simon.denier 11/13/2008 19:21'!lastRunMethodNamed: aSelector		^ String streamContents: [:str |		str nextPutAll: aSelector asString ;cr.		str tab; nextPutAll: '^ ', (self lastRun) storeString]! !!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:42'!testClassFastCreationInDifferentCategories	| firstThreeClasses lastTwoClasses |	3 timesRepeat: [		factory newClassInCategory: #One].	firstThreeClasses := factory createdClasses copy.	2 timesRepeat: [		factory newClassInCategory: #Two].	lastTwoClasses := factory createdClasses copyWithoutAll: firstThreeClasses.	self assert: (firstThreeClasses allSatisfy: [:class| class category = (factory packageName, '-', #One) asSymbol]).	self assert: (lastTwoClasses allSatisfy: [:class| class category = (factory packageName, '-', #Two) asSymbol]).! !!TestCase class methodsFor: 'history' stamp: 'simon.denier 11/13/2008 19:22'!generateLastStoredRunMethod	self shouldGenerateLastStoredRunMethod ifTrue: [		self class			compile: (self lastRunMethodNamed: #lastStoredRun)			classified: 'history' ]! !!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:37'!testSingleClassFastCreation	|class elementsInCategoryForTest |	class := factory newClass.	self assert: (SystemNavigation new allClasses includes: class).	elementsInCategoryForTest := SystemOrganization listAtCategoryNamed: factory defaultCategory. 	self assert: elementsInCategoryForTest = {class name}.	self assert: class instVarNames isEmpty.	self assert: class classPool isEmpty! !!TestCase class methodsFor: 'initialize - event' stamp: 'AlexandreBergel 10/22/2008 13:31'!initialize     super initialize.	SystemChangeNotifier uniqueInstance notify: self ofSystemChangesOfItem: #method using: #methodChanged:.! !!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 12:47'!delete: aClass	aClass isObsolete ifTrue: [^self].	aClass removeFromChanges.	aClass removeFromSystemUnlogged! !!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:58'!coverageForClass: cls until: aRootClass	"returns the test coverage of all the methods included inherited ones but stopping at aRootClass included"		| definedMethods testedMethods untestedMethods |	definedMethods := cls allSelectorsAboveUntil: aRootClass.	definedMethods size = 0		ifTrue: [^ {0. Set new}].	testedMethods := 		self methodDictionary values inject: Set new into: 							[:sums :cm | sums union: cm messages].	testedMethods := testedMethods reject: [:sel | (definedMethods includes: sel) not].	untestedMethods := definedMethods select: [:selector | (testedMethods includes: selector) not].	^ { (testedMethods size * 100 / definedMethods size) asFloat . untestedMethods}! !!LongTestCaseTestUnderTest class methodsFor: 'accessing' stamp: 'sd 9/25/2004 14:02'!hasRun	^ RunStatus! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!setUp	resource := SimpleTestResource current			! !!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:47'!testPackageCleanUp	| createdClassNames allClasses |	3 timesRepeat: [		factory newClassInCategory: #One].	2 timesRepeat: [		factory newClassInCategory: #Two].	createdClassNames := factory createdClassNames.	factory cleanUp.		self assert: (factory createdClasses allSatisfy: [:class| class isObsolete]). 	allClasses := SystemNavigation new allClasses.	self assert: (factory createdClasses noneSatisfy: [:class| allClasses includes: class]).	self assert: (SystemOrganization categoriesMatching: factory packageName, '*') isEmpty. 	self deny: (ChangeSet current changedClassNames includesAnyOf: createdClassNames)! !!ClassFactoryForTestCaseTest class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!lastStoredRun	^ ((Dictionary new) add: (#passed->((Set new) add: #testDefaultCategoryCleanUp; add: #testPackageCleanUp; add: #testSingleClassCreation; add: #testClassCreationInDifferentCategories; add: #testClassFastCreationInDifferentCategories; add: #testMultipleClassCreation; add: #testSingleClassFastCreation; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !!ResumableTestFailureTestCase class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!lastStoredRun	^ ((Dictionary new) add: (#passed->((Set new) add: #testResumable; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !!LongTestCase class methodsFor: 'initialization' stamp: 'sd 9/25/2004 12:57'!initialize	self doNotRunLongTestCases! !!SimpleTestResourceTestCase class methodsFor: 'not categorized' stamp: ''!resources	^Set new add: SimpleTestResource; yourself			! !!TestCase class methodsFor: 'history' stamp: 'simon.denier 11/13/2008 21:29'!shouldGenerateLastStoredRunMethod	| sameRun |		(self class methodDictionary includesKey: #lastStoredRun)		ifFalse: [^ true].	sameRun := #(#passed #failures #errors) inject: true into: 		[ :ok :set | ok and: [(self lastRun at: set) = (self lastStoredRun at: set) ]].	^ sameRun not! !!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 10/26/2008 14:55'!newClass	^self newSubclassOf: Object instanceVariableNames: '' classVariableNames: ''! !!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 12:46'!deleteClasses	self createdClasses do: [:class|		self delete: class]! !!ResumableTestFailureTestCase methodsFor: 'not categorized' stamp: ''!resumableTestFailureTest	self		assert: false description: 'You should see me' resumable: true; 		assert: false description: 'You should see me too' resumable: true; 		assert: false description: 'You should see me last' resumable: false; 		assert: false description: 'You should not see me' resumable: true			! !!TestResult class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:46'!historyFor: aTestCaseClass	"I return the last test dictionary for aTestCaseClass. 	If none found, I return an empty dictionary but will not link it to the class in the history."		| history |	history := aTestCaseClass history.	history ifNil: [ ^ self newTestDictionary ].	^ history	"	^ self history at: aTestCaseClass ifAbsent: [ self newTestDictionary ]"! !!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 10/26/2008 16:25'!newSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString 	^self 		newSubclassOf: aClass 		instanceVariableNames: ivNamesString 		classVariableNames: classVarsString 		category: self defaultCategoryPostfix! !!TestCase methodsFor: 'accessing' stamp: 'dc 4/2/2007 18:38'!assert: expected equals: actual	^ self		assert: (expected = actual)		description: (self comparingStringBetween: expected and: actual)! !!TestCase class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:57'!newTestDictionary	^ Dictionary new at: #timeStamp put: TimeStamp now;		at: #passed put: Set new;		at: #failures put: Set new;		at: #errors put: Set new;		yourself		! !!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:55'!localCoverageForClass: cls		| definedMethods testedMethods untestedMethods |	definedMethods := cls selectors.	"It happens for IdentityBag / IdentityBagTest"	definedMethods size = 0		ifTrue: [^ {0. Set new}].	testedMethods := 		self methodDictionary values inject: Set new into: 							[:sums :cm | sums union: cm messages].						"testedMethods contains all the methods send in test methods, which probably contains methods that have nothign to do with collection"	testedMethods := testedMethods reject: [:sel | (definedMethods includes: sel) not].	untestedMethods := definedMethods select: [:selector | (testedMethods includes: selector) not].	^ { (testedMethods size * 100 / definedMethods size) asFloat . untestedMethods}! !!ResumableTestFailureTestCase methodsFor: 'not categorized' stamp: ''!failureTest	self		assert: false description: 'You should see me' resumable: true; 		assert: false description: 'You should see me too' resumable: true; 		assert: false description: 'You should see me last' resumable: false; 		assert: false description: 'You should not see me' resumable: true			! !!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:44'!testDefaultCategoryCleanUp	| createdClassNames allClasses |	3 timesRepeat: [		factory newClass].	createdClassNames := factory createdClassNames.	factory cleanUp.		self assert: (factory createdClasses allSatisfy: [:class| class isObsolete]). 	allClasses := SystemNavigation new allClasses.	self assert: (factory createdClasses noneSatisfy: [:class| allClasses includes: class]).	self deny: (SystemOrganization categories includes: factory defaultCategory). 	self deny: (ChangeSet current changedClassNames includesAnyOf: createdClassNames)! !!TestResult methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 11:11'!initialize	super initialize.	passed := OrderedCollection new.	failures := Set new.	errors := OrderedCollection new.	timeStamp := TimeStamp now! !!ResumableTestFailureTestCase methodsFor: 'not categorized' stamp: ''!okTest	self assert: true			! !!TestCase class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:47'!resetHistory	history := nil! !!TestCase class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:45'!history: aDictionary	history := aDictionary! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!fail	self assert: false			! !!TestResult methodsFor: 'testing' stamp: 'jf 3/4/2009 11:55'!hasPassed	^ self hasErrors not and: [ self hasFailures not ]! !!TestCase methodsFor: 'private' stamp: 'dc 4/2/2007 18:46'!comparingStringBetween: expected and: actual	^ String streamContents: [:stream |		stream			nextPutAll: 'Expected ';			nextPutAll: (expected printStringLimitedTo: 10);			nextPutAll: ' but was ';			nextPutAll: (actual printStringLimitedTo: 10);			nextPutAll: '.'		]! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!error	'foo' odd			! !!TestResult methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:05'!updateResultsInHistory		#(#passed #failures #errors) do: [ :status | 		(self perform: status) do: [ :testCase | 			self class updateTestHistoryFor: testCase status: status ] ]! !!TestCase class methodsFor: 'coverage' stamp: 'ab 12/25/2008 17:20'!coverageAsString	| cov className |	cov := self coverage first asInteger. 	"coverage already checks that the name is ends with 'Test' and if the class tested exists"		className := self name copyFrom: 1 to: (self name size - 'Test' size).	^ self name asString, ' covers ', cov asString, '% of ', className.! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 15:58'!methodFailed: aSelector	^ (self lastRun at: #failures) includes: aSelector! !!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:43'!testClassCreationInDifferentCategories	| firstThreeClasses lastTwoClasses |	3 timesRepeat: [		factory newSubclassOf: Object instanceVariableNames: '' classVariableNames: '' category: #One].	firstThreeClasses := factory createdClasses copy.	2 timesRepeat: [		factory newSubclassOf: Object instanceVariableNames: '' classVariableNames: '' category: #Two].	lastTwoClasses := factory createdClasses copyWithoutAll: firstThreeClasses.	self assert: (firstThreeClasses allSatisfy: [:class| class category = (factory packageName, '-', #One) asSymbol]).	self assert: (lastTwoClasses allSatisfy: [:class| class category = (factory packageName, '-', #Two) asSymbol]).! !!TestCase class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 20:56'!lastRun	^ TestResult historyFor: self! !!TestCase class methodsFor: 'history' stamp: 'AlexandreBergel 10/22/2008 10:33'!lastStoredRun	^ ((Dictionary new) add: (#failures->#()); add: (#passed->#()); add: (#errors->#()); yourself)! !!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 16:20'!packageName	^#CategoryForTestToBeDeleted! !!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 15:03'!localCoverage	"returns the coverage determined by a simple static analysis of test coverage 	made by the receiver on a class that is identified by the name of the receiver.	We assume that SetTest test Set. The computation of the coverage takes only into	account the methods defined locally in the tested class. See coverage for a more global 	coverage"		| cls className |	(self name endsWith: 'Test') ifFalse: [self error: 'Please, use #localCoverageForClass: instead'].	className := self name copyFrom: 1 to: (self name size - 'Test' size).	cls := Smalltalk at: className asSymbol ifAbsent: [self error: 'Please, use #localCoverageForClass: instead'].	cls isBehavior ifFalse: [cls := cls class].	^ self localCoverageForClass: cls! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 16:00'!methodPassed: aSelector	^ (self lastRun at: #passed) includes: aSelector! !!TestResult methodsFor: 'querying' stamp: 'GwenaelCasaccio 10/1/2008 22:37'!isFailureFor: class selector: selector	^ self failures anySatisfy: [:testCase | testCase class == class and: [testCase selector == selector]]! !!TestResult class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:10'!newTestDictionary	^ Dictionary new at: #timeStamp put: TimeStamp now;		at: #passed put: Set new;		at: #failures put: Set new;		at: #errors put: Set new;		yourself		! !!TestCase class methodsFor: 'history' stamp: 'Alexandre.Bergel 4/3/2009 14:57'!history	^ history ifNil: [ history := self newTestDictionary ]! !!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 14:21'!createdClassNames	^self createdClasses collect: [:class| class name]! !!ResumableTestFailureTestCase methodsFor: 'not categorized' stamp: ''!errorTest	1 zork			! !!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 16:37'!defaultCategory	^ (self packageName , '-', self defaultCategoryPostfix) asSymbol! !!TestResult methodsFor: 'history' stamp: 'simon.denier 11/13/2008 20:51'!selectResultsForTestCase: aTestCaseClass	| passedSelectors errorsSelectors failuresSelectors |	passedSelectors := self passed						select: [:testCase | testCase class == aTestCaseClass ] thenCollect: [:testCase | testCase selector].	errorsSelectors := self errors 						select: [:testCase | testCase class == aTestCaseClass ] thenCollect:  [:testCase | testCase selector].	failuresSelectors := self failures 						select: [:testCase | testCase class == aTestCaseClass ] thenCollect:  [:testCase | testCase selector].		^ self class newTestDictionary 		at: #passed put: passedSelectors asSet;		at: #failures put: failuresSelectors asSet;		at: #errors put: errorsSelectors asSet;		yourself		! !!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:04'!coverage	"returns the coverage determined by a simple static analysis of test coverage 	made by the receiver on a class that is identified by the name of the receiver.	We assume that SetTest test Set."		| cls className |	(self name endsWith: 'Test') ifFalse: [self error: 'Please, use #coverageForClass: instead'].	className := self name copyFrom: 1 to: (self name size - 'Test' size).	cls := Smalltalk at: className asSymbol ifAbsent: [self error: 'Please, use #coverageForClass: instead'].		"May happen with Transcript"	cls isBehavior ifFalse: [cls := cls class].		^ self coverageForClass: cls! !!TestResult methodsFor: 'accessing' stamp: 'AlexandreBergel 10/1/2008 11:52'!timeStamp	^ timeStamp! !!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 16:23'!defaultCategoryPostfix	^ #Default! !!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 14:01'!initialize	super initialize.	self createdClasses: IdentitySet new! !!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:55'!localCoveragePercentage	^ self localCoverage first! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 15:59'!storedMethodRaisedError: aSelector	^ (self lastStoredRun at: #errors) includes: aSelector! !!TestResult class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:05'!updateTestHistoryFor: aTestCase status: aSymbol	| cls sel |		cls := aTestCase class.	sel := aTestCase selector.	self removeFromTestHistory: sel in: cls.	((self historyAt: cls) at: aSymbol ) add: sel! !!ClassFactoryForTestCase methodsFor: 'cleaning' stamp: 'Noury 10/26/2008 16:26'!cleanUp	| createdClassNames |	createdClassNames := self createdClassNames.	self deleteClasses.	self deletePackage.	self cleanUpChangeSetForClassNames: createdClassNames! !!ClassFactoryForTestCaseTest methodsFor: 'setUp-tearDown' stamp: 'Noury 10/26/2008 14:53'!tearDown	super tearDown.	factory cleanUp! !!ClassFactoryForTestCaseTest methodsFor: 'setUp-tearDown' stamp: 'Noury 10/26/2008 12:19'!setUp	super setUp.	factory := ClassFactoryForTestCase new! !!TestResult methodsFor: 'querying' stamp: 'GwenaelCasaccio 10/1/2008 22:36'!isPassedFor: class selector: selector	^ self passed anySatisfy: [:testCase | testCase class == class and: [testCase selector == selector]]! !!TestCase class methodsFor: 'coverage' stamp: 'ab 12/25/2008 17:15'!coveragePercentage	^ self coverage first! !!SUnitTest class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!lastStoredRun	^ ((Dictionary new) add: (#passed->((Set new) add: #testWithExceptionDo; add: #testRan; add: #testAssert; add: #testRanOnlyOnce; add: #testDialectLocalizedException; add: #testFail; add: #testDefects; add: #testIsNotRerunOnDebug; add: #testResult; add: #testRunning; add: #testError; add: #testException; add: #testShould; add: #testSuite; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !!LongTestCaseTestUnderTest class methodsFor: 'accessing' stamp: 'md 11/14/2004 21:37'!markAsNotRun	^ RunStatus := false! !!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:38'!testMultipleClassCreation	5 timesRepeat: [		factory newClass].	self assert: (SystemNavigation new allClasses includesAllOf: factory createdClasses).	self assert: factory createdClassNames asSet size = 5.	self assert: (SystemOrganization listAtCategoryNamed: factory defaultCategory) asSet = factory createdClassNames asSet! !!TestResult methodsFor: 'accessing' stamp: 'simon.denier 11/13/2008 20:27'!classesTested	^ (self tests collect: [ :testCase | testCase class ]) asSet! !!TestSuite methodsFor: 'running' stamp: 'stephane.ducasse 10/9/2008 18:36'!run: aResult 	self tests do: [:each | 		self changed: each.		each run: aResult].			! !!TestResult class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 20:56'!removeFromTestHistory: aSelector in: aTestCaseClass	| lastRun |		lastRun := self historyFor: aTestCaseClass.	#(#passed #failures #errors) do:		[ :set | (lastRun at: set) remove: aSelector ifAbsent: []].! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 16:00'!methodRegressed: aSelector	^ (self storedMethodPassed: aSelector) and: [(self methodFailed: aSelector) or: [self methodRaisedError: aSelector]]! !!ClassFactoryForTestCase methodsFor: 'accessing' stamp: 'Noury 10/26/2008 13:59'!createdClasses	^createdClasses! !!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 10/26/2008 16:46'!newClassInCategory: category	^self newSubclassOf: Object instanceVariableNames: '' classVariableNames: '' category: category! !!ResumableTestFailureTestCase methodsFor: 'not categorized' stamp: ''!regularTestFailureTest	self assert: false description: 'You should see me'			! !!TestCase class methodsFor: 'coverage' stamp: 'sd 1/28/2009 14:57'!coverageForClass: cls	"returns the test coverage of all the methods included inherited ones"	^ self coverageForClass: cls until: ProtoObject! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!testResourceInitRelease	| result suite error failure |	suite := TestSuite new.	suite addTest: (error := self class selector: #error).	suite addTest: (failure := self class selector: #fail).	suite addTest: (self class selector: #dummy).	result := suite run.	self assert: resource hasSetup			! !!SimpleTestResourceTestCase class methodsFor: 'history' stamp: 'simon.denier 11/22/2008 22:13'!lastStoredRun	^ ((Dictionary new) add: (#passed->((Set new) add: #testResourceInitRelease; add: #testResourcesCollection; add: #testRan; yourself)); add: (#timeStamp->'22 November 2008 10:11:35 pm'); add: (#failures->((Set new))); add: (#errors->((Set new))); yourself)! !!ClassFactoryForTestCase methodsFor: 'creating' stamp: 'Noury 10/26/2008 16:36'!newSubclassOf: aClass instanceVariableNames: ivNamesString classVariableNames:  classVarsString category: category	| newClass |	newClass := aClass 		subclass: self newName 		instanceVariableNames: ivNamesString 		classVariableNames: classVarsString 		poolDictionaries: '' 		category: (self packageName, '-', category) asSymbol.	self createdClasses add: newClass.	^newClass! !!TestCase class methodsFor: 'testing' stamp: 'Alexandre.Bergel 4/3/2009 15:06'!hasMethodBeenRun: aSelector	^ ((self lastRun at: #errors),		(self lastRun at: #failures),		(self lastRun at: #passed))			includes: aSelector! !!TestResult methodsFor: 'history' stamp: 'simon.denier 11/13/2008 20:33'!dispatchResultsIntoHistory 	self classesTested do: 		[ :testClass | 		self class			historyAt: testClass			put: (self selectResultsForTestCase: testClass) ].! !!TestResult methodsFor: 'diff' stamp: 'AlexandreBergel 10/1/2008 16:26'!diff: aTestResult	"Return a collection that contains differences"	| passed1Selectors failed1Selectors errors1Selectors passed2Selectors failed2Selectors errors2Selectors |	passed1Selectors := self passed collect: [:testCase | testCase selector].	failed1Selectors := self failures collect: [:testCase | testCase selector].	errors1Selectors := self errors collect: [:testCase | testCase selector].	passed2Selectors := aTestResult passed collect: [:testCase | testCase selector].	failed2Selectors := aTestResult failures collect: [:testCase | testCase selector].	errors2Selectors := aTestResult errors collect: [:testCase | testCase selector].		^ {passed1Selectors copyWithoutAll: passed2Selectors .		failed1Selectors copyWithoutAll: failed2Selectors .		errors1Selectors copyWithoutAll: errors2Selectors}! !!TestSuite methodsFor: 'running' stamp: 'stephane.ducasse 10/9/2008 18:36'!run	| result | 	result := TestResult new.	self resources do: [ :res |		res isAvailable ifFalse: [^res signalInitializationError]].	[self run: result] ensure: [self resources do: [:each | each reset]].	^result			! !!TestCase class methodsFor: 'initialize - event' stamp: 'al 2/9/2009 20:00'!methodChanged: anEvent	"Remove the changed method from the known test results."		| cls sel |	anEvent item isCompiledMethod ifFalse: [ ^ self ].	cls := anEvent item methodClass.	(cls inheritsFrom: TestCase)		ifFalse: [^ self].	sel := anEvent item selector.	(sel beginsWith: 'test')		ifFalse: [^ self].	TestResult removeFromTestHistory: sel in: cls.! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!testRan	| case |	case := self class selector: #setRun.	case run.	self assert: resource hasSetup.	self assert: resource hasRun			! !!TestResource methodsFor: 'initializing' stamp: 'alain.plantec 5/28/2009 11:11'!initialize	super initialize.	self setUp			! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 15:59'!storedMethodFailed: aSelector	^ (self lastStoredRun at: #failures) includes: aSelector! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 16:00'!methodRaisedError: aSelector	^ (self lastRun at: #errors) includes: aSelector! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!testResourcesCollection	| collection |	collection := self resources.	self assert: collection size = 1			! !!ClassFactoryForTestCaseTest methodsFor: 'testing' stamp: 'Noury 10/26/2008 16:37'!testSingleClassCreation	|class elementsInCategoryForTest |	class := factory 		newSubclassOf: Object 		instanceVariableNames: 'a b c' 		classVariableNames: 'X Y'.	self assert: (SystemNavigation new allClasses includes: class).	elementsInCategoryForTest := SystemOrganization listAtCategoryNamed: factory defaultCategory. 	self assert: elementsInCategoryForTest = {class name}.	self assert: class instVarNames = #(a b c).	self assert: class classPool keys = #(X Y) asSet! !!SimpleTestResourceTestCase methodsFor: 'not categorized' stamp: ''!setRun	resource setRun			! !!TestCase methodsFor: 'running' stamp: 'DavidRoethlisberger 11/10/2008 09:54'!tearDown! !!TestCase class methodsFor: 'testing' stamp: 'AlexandreBergel 10/21/2008 16:00'!storedMethodPassed: aSelector	^ (self lastStoredRun at: #passed) includes: aSelector! !!TestCase methodsFor: 'running' stamp: 'DavidRoethlisberger 11/10/2008 09:54'!setUp! !ResumableTestFailureTestCase removeSelector: #failureLog!ResumableTestFailureTestCase removeSelector: #isLogging!TestCase initialize!LongTestCase initialize!