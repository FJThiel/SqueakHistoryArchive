"Change Set:		9943SMBase-ar.111SMBase-ar.111:Add a workaround for the 'SMDependencyTest problem'. The issue appears to be caused by 'SMSqueakMap new synchWithDisk' creating an invalid checkpoint file (no objects in it) which when loaded later causes constant failure. This may not be the intended behavior as it will cause the user being asked whether to upgrade the map from the net when opening the Tools tab in the object tools. However, it beats having a broken SqueakMap lingering around.SMBase-gk.104:Trying to quickly update trunk and SqueakMap server for release 4.1:- Fixes for downloads/installation- Move to SmartRefStreamSMBase-gk.105:Change one ifNotNil: to ifNotNilDo: so that the code can be loaded into a 3.8 image.SMBase-gk.106:One more ifNotNil: made to ifNotNilDo: for backwards compatibility.SMBase-gk.107:Sigh, yet another revert of code critic stuff.SMBase-gk.108:Yet another revert of ifNotNil: instead of ifNotNilDo:SMBase-gk.109:- Added #oldReload to be able to load an old map using ImageSegments. Only to be used when switching on the server.And a bunch of fixes from a long time back:2006, Doug Way:- A bunch of additions and cleanups for the SMPackage and SMPackageRelease full descriptions which appear in the package loader.2008, Göran Krampe:- Fix in default installer for text file converter.2009, Göran Krampe:-Added #isPurged and fix in synchWithDisk to avoid problems with a purged map when there is no map on disk (fresh install)- Fix included from http://bugs.squeak.org/view.php?id=7201SMBase-ar.110:Nuke SMSqueakmap default when cleaning up aggressively."!!SMSqueakMap methodsFor: 'private' stamp: 'gk 2/13/2009 09:14'!synchWithDisk	"Synchronize myself with the checkpoints on disk.	If there is a newer checkpoint than I know of, load it.	If there is no checkpoint or if I have a higher checkpoint number,	create a new checkpoint from me.	The end result is that I am in synch with the disk and we are both as	updated as possible."	| checkpointNumberOnDisk |	 "If there is no checkpoint, save one from me."	(self isCheckpointAvailable) ifFalse: [		"If I am purged - don't checkpoint, no point"		self isPurged ifTrue: [^self].		^self createCheckpointNumber: checkpointNumber].	"If the one on disk is newer, load it"	checkpointNumberOnDisk := self lastCheckpointNumberOnDisk.	(checkpointNumber < checkpointNumberOnDisk)		ifTrue: [^self reload].	"If I am newer, recreate me on disk"	(checkpointNumberOnDisk < checkpointNumber)		ifTrue: [^self createCheckpointNumber: checkpointNumber]! !!SMInstallationRegistry methodsFor: 'installation' stamp: 'gk 5/5/2006 02:07'!noteInstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully installed.	Can be used to inform SM of an installation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	| time name id v |	v := aVersion isString ifTrue: [aVersion asVersion] ifFalse: [aVersion].	aName ifNil: [name := '<unknown package name>'] ifNotNil: [name := aName].	id := UUID fromString: aPackageId.	time := Time totalSeconds.	self countInstall.	self markInstalled: id version: v time: time counter: installCounter.	(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])		logChange: '"Installed ', name, ' auto version ', v versionString, '".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: ', id asString storeString, ' autoVersion: ', v storeString, ' atSeconds: ', time asString, ' number: ', installCounter asString, ']'! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 4/11/2010 21:07'!createCheckpointNumber: number	"Export me using an ImageSegment or SmartRefStream.	This is used for checkpointing the map on disk	in a form that can be brought into an independent image.	We do not overwrite older versions."	| fname stream oldMutex |	fname := self filename, '.', number asString, '.r'.	(self directory fileExists: fname, 'gz') ifTrue: [self error: 'Checkpoint already exists!!'].	stream := StandardFileStream newFileNamed: (self directory fullNameFor: fname).	checkpointNumber := number.	oldMutex := mutex.	mutex := nil. self clearCaches.	[| smartStream |	[smartStream := SmartRefStream on: stream.	smartStream nextPut: self] ensure: [smartStream close].	self compressFile: (StandardFileStream oldFileNamed: (self directory fullNameFor: fname)).	isDirty := false]		ensure: [mutex := oldMutex]! !!SMInstaller class methodsFor: 'instance creation' stamp: 'gk 4/11/2010 21:38'!classForPackageRelease: aPackageRelease	"Decide which subclass to instantiate. 	We detect and return the first subclass	that wants to handle the release going	recursively leaf first so that subclasses gets	first chance if several classes compete over	the same packages, like for example SMDVSInstaller	that also uses the .st file extension."	self subclasses do: [:ea |		(ea classForPackageRelease: aPackageRelease)			ifNotNilDo: [:class | ^ class]].	^(self canInstall: aPackageRelease)		ifTrue: [self]! !!SMDefaultInstaller methodsFor: 'private' stamp: 'KLC 4/27/2007 17:31'!fileIn	"Installing in the standard installer is simply filing in.	Both .st and .cs files will file into a ChangeSet of their own.	We let the user confirm filing into an existing ChangeSet	or specify another ChangeSet name if	the name derived from the filename already exists."		| fileStream |	(self class nonMultiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			(fileStream respondsTo: #setConverterForCode) ifTrue: [fileStream setConverterForCode].			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	(self class multiSuffixes anySatisfy: [:each | unpackedFileName endsWith: (FileDirectory dot, each)])		ifTrue:[			fileStream := dir readOnlyFileNamed: unpackedFileName.			"Only images with converters should have multi suffixes"			fileStream converter: (Smalltalk at: #UTF8TextConverter) new.			self fileIntoChangeSetNamed: (fileStream localName sansPeriodSuffix) fromStream: fileStream.			^self].	self error: 'Filename should end with a proper extension'.! !!SMInstallationRegistry methodsFor: 'installation' stamp: 'gk 4/11/2010 21:49'!noteUninstalledPackageWithId: aPackageId autoVersion: aVersion name: aName	"The package release was just successfully uninstalled.	Can be used to inform SM of an uninstallation not been	done using SM, even when the map isn't loaded.	We record the fact in our Dictionary of installed packages	and log a 'do it' to mark this in the changelog.	The doit helps keeping track of the packages when	recovering changes etc - not a perfect solution but should help.	The map used is the default map.	The id of the package is the key and the value is an OrderedCollection	of Arrays with the release auto version, the point in time and the current installCounter."	| time name id v |	v := aVersion isString ifTrue: [aVersion asVersion] ifFalse: [aVersion].	aName ifNil: [name := '<unknown package name>'] ifNotNil: [name := aName].	id := UUID fromString: aPackageId.	time := Time totalSeconds.	self countInstall. "Used for both installs and uninstalls"	self clearInstalled: id version: v time: time counter: installCounter.	(((Smalltalk classNamed: 'SmalltalkImage') ifNotNilDo: [:si | si current]) ifNil: [Smalltalk])		logChange: '"Uninstalled ', name, ' auto version ', v versionString, '".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteUninstalledPackageWithId: ', id asString storeString, ' autoVersion: ', v storeString, ' atSeconds: ', time asString, ' number: ', installCounter asString, ']'! !!SMDependencyAnalysis methodsFor: 'private' stamp: 'md 12/22/2006 14:31'!removeOlderReleasesIn: collectionOfReleases	"Remove older multiple releases of the same package.	2 scans to retain order."	| newestReleases rel |	newestReleases := Dictionary new.	collectionOfReleases do: [:r |		rel := newestReleases at: r package ifAbsentPut: [r].		(r newerThan: rel) ifTrue: [newestReleases at: r package put: r]].	^collectionOfReleases select: [:r |		(newestReleases at: r package) == r]! !!SMSqueakMap class methodsFor: 'class initialization' stamp: 'ar 4/11/2010 19:15'!cleanUp: aggressive	"Nuke the default map when performing aggressive cleanup"	aggressive ifTrue:[self clear].! !!SMSqueakMap methodsFor: 'private' stamp: 'gk 4/11/2010 22:00'!oldReload	"Reload the map from the latest checkpoint on disk.	The opposite of #purge."	| fname stream map |	fname := self directory lastNameFor: self filename extension: 'sgz'.	fname ifNil: [self error: 'No ImageSegment checkpoint available!!'].	stream := (StandardFileStream oldFileNamed: (self directory fullNameFor: fname)) asUnZippedStream.	stream ifNil: [self error: 'Couldn''t open stream on checkpoint file!!'].	[map := (stream fileInObjectAndCode) install arrayOfRoots first] ensure: [stream close].	self copyFrom: map! !!SMSqueakMap methodsFor: 'accessing' stamp: 'gk 2/13/2009 15:11'!categories	"Lazily maintain a cache of all known category objects."	categories ifNotNil: [^categories].	objects isNil ifTrue: [ ^ #() ].	categories := objects select: [:o | o isCategory].	^categories! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43'!changeSetNamed: newName	"This method copied here to ensure SqueakMap is independent of ChangesOrganizer."	Smalltalk at: #ChangesOrganizer ifPresentAndInMemory: [ :cs | ^cs changeSetNamed: newName ].	^ChangeSet allInstances detect: [ :cs | cs name = newName ] ifNone: [ nil ].! !!SMPackageRelease methodsFor: 'printing' stamp: 'dew 10/23/2006 18:52'!fullDescription	"Return a full textual description of the package release."	| s |	s := TextStream on: (Text new: 400).	self describe: self package name withBoldLabel: 'Package Name: ' on: s.	name isEmptyOrNil ifFalse:		[self describe: self name withBoldLabel: 'Release Name: ' on: s].	summary isEmptyOrNil ifFalse:		[self describe: self summary withBoldLabel: 'Release Summary: ' on: s].	self 		describe: self version		withBoldLabel: 'Version: '		on: s.	categories isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Categories: '];				cr.			(self categories asSortedCollection: [:a :b | a path < b path])				do: [:c | 					s						tab;						withAttribute: TextEmphasis italic							do: 								[c parentsDo: 										[:p | 										s											nextPutAll: p name;											nextPutAll: '/'].								s nextPutAll: c name];						nextPutAll: ' - ' , c summary;						cr].			s cr].	created ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: self created;			cr].	updated ifNotNil: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Modified: ' ];			print: self updated;			cr].	publisher ifNotNil: [		s			withAttribute: TextEmphasis bold			do: [s nextPutAll: 'Publisher: '].		s			withAttribute: (PluggableTextAttribute					evalBlock: [self userInterface									sendMailTo: self publisher email									regardingPackageRelease: self])			do: [s nextPutAll: self publisher nameAndEmail];				cr].	self note isEmptyOrNil 		ifFalse: 			[s				cr;				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Version Comment:'].			s cr.			s withAttribute: (TextIndent tabs: 1) do: [s nextPutAll: self note withSqueakLineEndings].			s				cr;				cr].	url isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Homepage:'];				tab;				withAttribute: (TextURL new url: url) do: [s nextPutAll: url];				cr].	self downloadUrl isEmptyOrNil 		ifFalse: 			[s				withAttribute: TextEmphasis bold do: [s nextPutAll: 'Download:'];				tab;				withAttribute: (TextURL new url: self downloadUrl)					do: [s nextPutAll: self downloadUrl];				cr].	^s contents.! !!SMSqueakMap class methodsFor: 'constants' stamp: 'gk 4/11/2010 21:26'!version	"This is the protocol version number used for clients to decide if	they need to update SMSqueakMap before synching with	the master. In short - only increase this if changes have made	the clients incompatible so that they need to be updated.	2.0: Removed Module stuff and added Package releases.	2.1: Various changes/additions and class shape changes.	2.2: Various 3.9 related fixes and bug fix in segment compression etc.	2.3: Moving to SmartRefStream when preparing to release Squeak 4.1."	^'2.3'! !!SMFileCache methodsFor: 'services' stamp: 'gk 5/5/2006 02:07'!download: aDownloadable 	"Download the file for this SMObject into the local file cache.	If the file already exists, delete it.	No unpacking or installation into the running image."	| stream file fileName dir |	[fileName := aDownloadable downloadFileName.	fileName		ifNil: [self inform: 'No download url, can not download.'.			^ false].	fileName isEmpty		ifTrue: [self inform: 'Download url lacks filename, can not download.'.			^ false].	dir := aDownloadable cacheDirectory.	[stream := self getStream: aDownloadable.	stream ifNil: [^ false].	(dir fileExists: fileName)		ifTrue: [dir deleteFileNamed: fileName].	file := dir newFileNamed: fileName.	file binary; nextPutAll: stream contents]		ensure: [file ifNotNil: [file close]]]		on: Error		do: [^ false].	^ true! !!SMInstaller class methodsFor: 'changeset utilities' stamp: 'pk 10/17/2006 09:43'!basicNewChangeSet: newName 	"This method copied here to ensure SqueakMap is independent of 	ChangesOrganizer. "	Smalltalk		at: #ChangesOrganizer		ifPresentAndInMemory: [:cs | ^ cs basicNewChangeSet: newName].	(self changeSetNamed: newName)		ifNotNil: [self error: 'The name ' , newName , ' is already used'].	^ ChangeSet basicNewNamed: newName! !!SMFileCache methodsFor: 'private' stamp: 'gk 4/11/2010 21:00'!getStream: aDownloadable 	"Get the stream, either from the original url	or if that fails, from the server cache - unless	this is the actual server of course. :)	We also verify that the sha1sum is correct."	| stream |	[stream := aDownloadable downloadUrl asUrl retrieveContents contentStream binary.	(aDownloadable correctSha1sum: stream contents)		ifFalse: [self error: 'Incorrect SHA checksum of file from original URL']]		on: Error do: [:ex |			Transcript show: 'Download from original url (', aDownloadable downloadUrl, ') failed with this exception: ', ex messageText;cr.			SMUtilities isServer				ifTrue: [^nil]				ifFalse: [					Transcript show: 'Trying server cache instead.'; cr.					[stream := (self cacheUrlFor: aDownloadable) asUrl retrieveContents contentStream binary.					(stream contents size = 21 and: [stream contents asString = 'SMFILEMISSINGONSERVER'])						ifTrue: [self error: 'File missing in server cache'].					(stream contents size = 24 and: [stream contents asString = 'SMRELEASENOTDOWNLOADABLE'])						ifTrue: [self error: 'Release not downloadable'].					(aDownloadable correctSha1sum: stream contents)						ifFalse: [self error: 'Incorrect SHA checksum of file from server']]							on: Error do: [:ex2 | | msg |								msg := 'Download from server cache of ', aDownloadable printName, ' failed with this exception: ', ex2 messageText.								Transcript show: msg; cr.								self error: msg]]].	^ stream! !!SMInstallationProposal methodsFor: 'initialize-release' stamp: 'md 12/22/2006 14:30'!collectConflictsIn: collectionOfReleases	"Collect all conflicts where there are either		- multiple releases of the same package and/or		- another release of the same package already installed	Return the conflicts as an IdentityDictionary with	the package as key and the value being a Set of releases."	| conflicts set |	conflicts := IdentityDictionary new.	collectionOfReleases do: [:r |		set := conflicts at: r package ifAbsentPut: [OrderedCollection new].		set add: r].	"Add the installed releases too"	conflicts keysAndValuesDo: [:key :value |		key isInstalled ifTrue: [value add: key installedRelease]].	"Prune release sets with only one member"	^conflicts select: [:releaseSet | releaseSet size > 1]! !!SMSqueakMap methodsFor: 'public' stamp: 'gk 4/11/2010 21:05'!reload	"Reload the map from the latest checkpoint on disk.	The opposite of #purge."	| fname stream map |	fname := self lastCheckpointFilename.	fname ifNil: [self error: 'No checkpoint available!!'].	"Code below uses good ole StandardFileStream to avoid m17n issues (this is binary data) and	also uses #unzipped since it works in older Squeaks"	stream := (StandardFileStream oldFileNamed: (self directory fullNameFor: fname)) asUnZippedStream.	stream ifNil: [self error: 'Couldn''t open stream on checkpoint file!!'].	[map := stream fileInObjectAndCode] ensure: [stream close].	self copyFrom: map! !!SMInstallationRegistry methodsFor: 'private' stamp: 'md 12/22/2006 14:30'!markInstalled: uuid version: version time: time counter: num	"Private. Mark the installation. SM2 uses an Association	to distinguish the automatic version from old versions."	| installs |	installedPackages ifNil: [installedPackages := Dictionary new].	installs := installedPackages at: uuid ifAbsentPut: [OrderedCollection new].	installs add:		(Array with: 2->version				with: time				with: num)! !!SMPackage methodsFor: 'accessing' stamp: 'dew 10/23/2006 19:08'!fullDescription	"Return a full textual description of the package. 	Most of the description is taken from the last release."	| s publishedRelease sqDescription |	s := TextStream on: (Text new: 400).	self		describe: name		withBoldLabel: 'Name:		'		on: s.	summary isEmptyOrNil		ifFalse: [self				describe: summary				withBoldLabel: 'Summary:	'				on: s ].	author isEmptyOrNil		ifFalse: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Author:'];				 tab;				 tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: (SMUtilities stripEmailFrom: author)										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: author];				 cr].	self owner		ifNotNil: [s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Owner:'];				 tab; tab.			s				withAttribute: (PluggableTextAttribute						evalBlock: [self userInterface										sendMailTo: self owner email										regardingPackageRelease: self lastRelease])				do: [s nextPutAll: self owner nameAndEmail];					 cr].	self maintainers isEmpty ifFalse: [		s withAttribute: TextEmphasis bold do: [s nextPutAll: 'Co-Maintainers:']; tab.		self maintainers do: [:com |			com = self maintainers first ifFalse: [s nextPutAll: ', '].			s				withAttribute:					(PluggableTextAttribute						evalBlock: [self userInterface									sendMailTo: com email									regardingPackageRelease: self lastRelease])				do: [s nextPutAll: com nameAndEmail]].				s cr].	description isEmptyOrNil		ifFalse: [sqDescription := description withSqueakLineEndings.			s cr.			s				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Description:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s next: (sqDescription findLast: [ :c | c isSeparator not ]) putAll: sqDescription].			s cr ].	self describeCategoriesOn: s indent: 1.	s cr.	publishedRelease := self lastPublishedRelease.	self		describe: (self publishedVersion ifNil: ['<not published>'])		withBoldLabel: 'Published Version: '		on: s.	self isPublished ifTrue: [		s			withAttribute: TextEmphasis bold do: [ s nextPutAll: 'Created: ' ];			print: publishedRelease created;			cr.			self note isEmptyOrNil				ifFalse: [s					withAttribute: TextEmphasis bold					do: [s nextPutAll: 'Release Note:'].			s cr.			s				withAttribute: (TextIndent tabs: 1)				do: [s nextPutAll: publishedRelease note withSqueakLineEndings].			s cr ]].	url isEmptyOrNil		ifFalse: [s cr;				withAttribute: TextEmphasis bold				do: [s nextPutAll: 'Homepage: '];				withAttribute: (TextURL new url: url)				do: [s nextPutAll: url];				 cr].	packageInfoName isEmptyOrNil		ifFalse: [self				describe: packageInfoName				withBoldLabel: 'Package Info: '				on: s ].	^ s contents! !!SMSqueakMap methodsFor: 'public' stamp: 'ar 4/13/2010 20:43'!isPurged	"Is this instance purged (empty)?	ar 4/13/2010: Added the test for object isNil as a workaround for 4.1.	Without the test 'SMSqueakMap new syncWithDisk' creates an invalid	checkpoint file and fails forever after."	^checkpointNumber isZero or:[objects isNil]! !!SMSqueakMap methodsFor: 'checkpoints' stamp: 'gk 4/11/2010 21:05'!extension	^'rgz'! !!SMPackage methodsFor: 'printing' stamp: 'gk 11/17/2003 10:14'!installedVersion	"Return the version String for the installed version.	We ask the map. Return nil if this package is not installed."	^self installedRelease ifNotNilDo: [:r | r smartVersion]! !