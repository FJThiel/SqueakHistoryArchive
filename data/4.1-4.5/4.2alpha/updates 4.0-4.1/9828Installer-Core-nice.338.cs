"Change Set:		9828Installer-Core-nice.338Installer-Core-nice.338:Get rid of #and:and:Use #sort:"!!InstallerUpdateStream methodsFor: 'updates' stamp: 'nice 3/27/2010 21:30'!changesetNamesFromUpdates: startNumber through: stopNumber	"Answer the concatenation of summary strings for updates numbered in the given range"	"self new changesetNamesFromUpdates: 7059 through: 7061"		^ String streamContents: [:aStream |		((ChangeSet changeSetsNamedSuchThat:			[:aName | aName first isDigit						and: [aName initialIntegerOrNil >= startNumber						and: [aName initialIntegerOrNil <= stopNumber]]]) asArray				sort: [:a :b | a name < b name])					do: [:aChangeSet | aStream cr; nextPutAll: aChangeSet summaryString]]! !!Installer methodsFor: 'mantis' stamp: 'nice 3/27/2010 21:14'!installDefault: aFileName from: stream	"Check for UTF-8 input before filing it in"	| pos |	pos := stream position.	(stream next: 3) asByteArray = #[16rEF 16rBB 16rBF]	"BOM"		ifTrue: [(RWBinaryOrTextStream on: stream upToEnd utf8ToSqueak) fileIn]		ifFalse: [stream position: pos; fileIn]! !!InstallerSqueakMap methodsFor: 'squeakmap' stamp: 'nice 3/27/2010 21:16'!update"Updates the local map for SqueakMap, upgrading SqueakMap to the latest version if necessary.When SqueakMap is old and needs to be upgraded, it does four things that mostly make sense in the interactive world SM was built for, but are totally evil here in the world of automatic scripting:1. It asks the user if she wants to upgrade, in the form of a pop-up (see SMSqueakMap >> #checkVersion:).2. It terminates its own process.3. It creates a new UI process.(see the last line of the SqueakMap upgrade file-in: ''Project spawnNewProcessAndTerminateOld: true'', from http://map.squeak.org/accountbyid/9bdedc18-1525-44a6-9b79-db5d4a87f6f8/files/SqueakMap8.st4. It opens a SqueakMap windowWe work around these three problems seperately:1. We use #answer:with: and #withAnswersDo: to automatically answer ''Yes'' when asked if we want to upgrade2. We don't want this process to be terminated, so we run the update in a forked process and wait for it to finish, using #fork, #ensure:, and a Semaphore3. We keep track of the UI process before updating, and if it changes, we terminate the new UI process and reinstall the old one using Project >> #resumeProcess:4. We don't bother with the newly opened window. The other three problems are much worse.We do all this in a new process, since it is not unlikely that this method is executing in the UI process"	| oldUIProcess doneSema |	self answer: 'You need to upgrade the SqueakMap package' with: true.	oldUIProcess := Project uiProcess.	doneSema := Semaphore new.	[[self withAnswersDo: [self classSMSqueakMap default loadUpdates]] 		ensure: [			| newUIProcess |			newUIProcess := Project uiProcess.			(oldUIProcess ~~ newUIProcess				and: [oldUIProcess notNil					and: [oldUIProcess isTerminated not]])					 ifTrue: [							newUIProcess ifNotNil: [newUIProcess terminate].							oldUIProcess suspend.							Project resumeProcess: oldUIProcess.].			doneSema signal]] fork.	doneSema wait! !