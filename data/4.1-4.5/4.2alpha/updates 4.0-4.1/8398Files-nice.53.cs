"Change Set:		8398Files-nice.53Files-nice.53:A test for nextLineOops, aren't test a different package ?Files-ul.32:- StandardFileStream hacks (readonly buffering)Files-ul.33:- a few more fixes for StandardFileStream speedupFiles-ul.34:- more fixesFiles-ul.35:- support read buffering in all filestreamsFiles-ul.36:- fix, improvement, cleanupFiles-ul.37:- fixesFiles-klub.38:- fall back to the primitive if the collection is not byte based in StandardFileStream >> #next:into:startingAt:- green testsFiles-ul.39:- make sure that #enableReadBuffering can be sent to every StandardFileStream- added postscript to enable read buffering in all open subinstances of StandardFileStreamFiles-ul.41:- fixes, enhancementsFiles-ul.43:- more fixesFiles-ul.44:- #position: fixedFiles-ul.45:- cleanup, fixes, etcFiles-ul.46:- cleanup, commentFiles-ul.47:- updated postscriptFiles-nice.48:Restore the semantics of #readInto:startingAt:count: to return the number of bytes readFiles-nice.49:Fast version of upToAnyOf:do:Files-nice.50:Throw away another #getSystemAttribute:Please don't spread cryptic code in the system! Use clear messages instead.Files-ul.51:- buffer friendly #skip:Files-nice.52:Correct my own bug in upToAnyOf:do: (nextLine)"!FileStream subclass: #StandardFileStream	instanceVariableNames: 'name fileID buffer1'	classVariableNames: 'Registry'	poolDictionaries: ''	category: 'Files-Kernel'!!StandardFileStream methodsFor: 'open/close' stamp: 'ul 12/6/2009 04:11'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [		collection ifNotNil: [			position < readLimit ifTrue: [				self flushReadBuffer ] ].		self primCloseNoError: fileID ].	self open: name forWrite: rwmode.! !!StandardFileStream methodsFor: 'private' stamp: 'ul 12/6/2009 04:12'!disableReadBuffering	collection ifNotNil: [		position < readLimit			ifTrue: [				| currentPosition |				currentPosition := self position.				collection := readLimit := position := nil.				self position: currentPosition ]			ifFalse: [				collection := readLimit := position := nil ] ]		! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/4/2009 06:59'!position	"Return the receiver's current file position.  2/12/96 sw"	collection ifNotNil: [		position < readLimit ifTrue: [			^(self primGetPosition: fileID) - readLimit + position ] ].	^self primGetPosition: fileID! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/5/2009 07:21'!padToEndWith: aChar	"On the Mac, files do not truncate.  One can delete the old file and write a new one, but sometime deletion fails (file still open? file stale?).  This is a sad compromise.  Just let the file be the same length but pad it with a harmless character."	| pad |	self atEnd ifTrue: [^ self].	pad := self isBinary 		ifTrue: [aChar asCharacter asciiValue]	"ok for char or number"		ifFalse: [aChar asCharacter].	self nextPutAll: (self collectionSpecies new: ((self size - self position) min: 20000) 							withAll: pad).! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/6/2009 04:10'!basicNext	"Answer the next byte from this file, or nil if at the end of the file."		| count |	<primitive: 65>	collection ifNotNil: [		position < readLimit 			ifFalse: [ 				readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.				position := 0.				readLimit = 0 ifTrue: [ ^nil ] ].		^collection at: (position := position + 1) ].		count := self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [ ^buffer1 at: 1 ]		ifFalse: [ ^nil ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/3/2009 06:44'!atEnd	"Answer whether the receiver is at its end.  "		collection ifNotNil: [		position < readLimit ifTrue: [ ^false ] ].	^self primAtEnd: fileID! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/6/2009 04:11'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [ 		position < readLimit ifTrue: [ self flushReadBuffer ] ].	self primWrite: fileID from: aString startingAt: 1 count: aString basicSize.	^ aString! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'ul 12/3/2009 06:39'!requestDropStream: dropIndex	"Return a read-only stream for some file the user has just dropped onto Squeak."	| rawName |	rawName := self primDropRequestFileName: dropIndex.	name :=  (FilePath pathName: rawName isEncoded: true) asSqueakPathName.	fileID := self primDropRequestFileHandle: dropIndex.	fileID == nil ifTrue:[^nil].	self register.	rwmode := false.	buffer1 := String new: 1.	self enableReadBuffering! !!StandardFileStream methodsFor: 'private' stamp: 'ul 12/6/2009 04:11'!flushReadBuffer	collection ifNotNil: [		position < readLimit ifTrue: [			| currentPosition |			currentPosition := self position.			position := readLimit := 0.			self primSetPosition: fileID to: currentPosition ] ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/5/2009 07:19'!next: n	"Return a string with the next n characters of the filestream in it.  1/31/96 sw"	^ self nextInto: (self collectionSpecies new: n)! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/6/2009 04:08'!position: pos	"Set the receiver's position as indicated.  2/12/96 sw"	collection ifNotNil: [		position < readLimit ifTrue: [			| newPosition |			newPosition := pos - (self primGetPosition: fileID) + readLimit.			newPosition < 0 ifTrue: [					| offsetPos |					self primSetPosition: fileID to: (offsetPos := pos - (collection size // 4) max: 0).					readLimit := self primRead: fileID into: collection startingAt: 1 count: collection size.					position := pos - offsetPos.					^self ].			newPosition < readLimit 				ifTrue: [					position := newPosition.					^self ]				ifFalse: [					readLimit := position := 0 ] ] ].	^self primSetPosition: fileID to: pos! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'nice 12/8/2009 19:10'!testNextLine	| filename lines text file |	filename := 'filestream.tst'.	lines := #('line 1' ' and line 2' '' 'fourth').	text := lines first , String cr , lines second , String crlf , lines third , String lf , lines fourth.		[(StandardFileStream forceNewFileNamed: filename)		nextPutAll: text;		close.			file := StandardFileStream readOnlyFileNamed: filename.	lines do: [:e |		self assert: file nextLine = e].	self assert: file nextLine = nil.	file close]		ensure: [FileDirectory default deleteFileNamed: filename ifAbsent: [] ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'nice 12/7/2009 08:10'!readInto: byteArray startingAt: startIndex count: count	"Read into the given array as specified, and return the count	actually transferred.  index and count are in units of bytes or	longs depending on whether the array is Bitmap, String or ByteArray"		^(self next: count into: byteArray startingAt: startIndex) size - startIndex + 1! !!CrLfFileStream methodsFor: 'access' stamp: 'nice 12/7/2009 08:26'!upToAnyOf: delimiters do: aBlock	^String new: 1000 streamContents: [ :stream |		| ch |		[ (ch := self next) == nil or: [ (delimiters includes: ch) and: [aBlock value: ch. true] ] ] 			whileFalse: [ stream nextPut: ch ] ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/6/2009 04:11'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [ 		position < readLimit ifTrue: [ self flushReadBuffer ] ].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'open/close' stamp: 'ul 12/6/2009 02:45'!closed	"Answer true if this file is closed."	^ fileID == nil or: [ (self primSizeNoError: fileID) == nil ]! !!StandardFileStream methodsFor: 'browser requests' stamp: 'ul 12/3/2009 06:39'!post: data target: target url: url ifError: errorBlock	"Post data to the given URL. The returned file stream contains the reply of the server.	If Squeak is not running in a browser evaluate errorBlock"	| sema index request result |	self waitBrowserReadyFor: self defaultBrowserReadyWait ifFail: [^errorBlock value].	sema := Semaphore new.	index := Smalltalk registerExternalObject: sema.	request := self primURLPost: url target: target data: data semaIndex: index.	request == nil ifTrue:[		Smalltalk unregisterExternalObject: sema.		^errorBlock value.	] ifFalse:[		[sema wait. "until something happens"		result := self primURLRequestState: request.		result == nil] whileTrue.		result ifTrue:[fileID := self primURLRequestFileHandle: request].		self primURLRequestDestroy: request.	].	Smalltalk unregisterExternalObject: sema.	fileID == nil ifTrue:[^nil].	self register.	name := url.	rwmode := false.	buffer1 := String new: 1.	self enableReadBuffering	! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/4/2009 19:19'!upTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	collection ifNotNil: [		(position < readLimit and: [			(count := collection indexOf: delim startingAt: position + 1) <= readLimit and: [				count > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := position + count) ] ].	pos := self position.	buffer := self next: 2000.	(count := buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upTo: delim)! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'nice 11/27/2009 21:56'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the	path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $:		ifTrue: [^ self defaultToCR].	FileDirectory pathNameDelimiter = $/		ifTrue: [((SmalltalkImage current osVersion) beginsWith: 'darwin')				ifTrue: [^ self defaultToCR]				ifFalse: [^ self defaultToLF]].	FileDirectory pathNameDelimiter = $\		ifTrue: [^ self defaultToCRLF].	"in case we don't know"	^ self defaultToCR! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/8/2009 00:13'!skip: n	"Set the character position to n characters from the current position.	Error if not enough characters left in the file.  1/31/96 sw"	collection ifNotNil: [		position < readLimit ifTrue: [			| newPosition |			((newPosition := position + n) >= 0 and: [ newPosition < readLimit ])				ifTrue: [ 					position := newPosition.					^self ] ] ].	self position: self position + n! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'ul 12/3/2009 06:39'!readOnly	"Make this file read-only."	rwmode := false.! !!StandardFileStream methodsFor: 'open/close' stamp: 'ul 12/3/2009 06:39'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	"Changed to do a GC and retry before failing ar 3/21/98 17:25"	| f |	f := fileName asVmPathName.	fileID := StandardFileStream retryWithGC:[self primOpen: f writable: writeMode] 					until:[:id| id notNil] 					forFileNamed: fileName.	fileID ifNil: [^ nil].  "allows sender to detect failure"	self register.	name := fileName.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering	! !!StandardFileStream methodsFor: 'open/close' stamp: 'ul 12/4/2009 07:18'!close	"Close this file."	fileID ifNotNil: [		collection ifNotNil: [			readLimit := position := 0 ].		self primClose: fileID.		self unregister.		fileID := nil].! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'ul 12/3/2009 06:39'!readWrite	"Make this file writable."	rwmode := true.! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/6/2009 04:14'!next: n into: aString startingAt: startIndex	"Read n bytes into the given string.	Return aString or a partial copy if less than	n elements have been read."		| count  newN newStartIndex |	collection 		ifNil: [ 			newN := n.			newStartIndex := startIndex ]		ifNotNil: [			aString class isBytes 				ifFalse: [ 					position < readLimit ifTrue: [ self flushReadBuffer ].					newN := n.					newStartIndex := startIndex ]				ifTrue: [					| available |					(available := readLimit - position) > 0 						ifFalse: [ available := 0 ]						ifTrue: [							| bufferedCount |							bufferedCount := n min: available.							aString								replaceFrom: startIndex								to: startIndex + bufferedCount - 1								with: collection								startingAt: position + 1.							position := position + bufferedCount.							bufferedCount = n ifTrue: [ ^aString ] ].					newN := n - available.					newStartIndex := startIndex + available ] ].	count := self primRead: fileID into: aString				startingAt: newStartIndex count: newN.	count = newN		ifTrue:[ ^aString ]		ifFalse:[ ^aString copyFrom: 1 to: newStartIndex + count - 1 ]! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'ul 12/3/2009 02:17'!ascii	"opposite of binary"	buffer1 := String new: 1.	collection ifNotNil: [ collection := collection asString ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/6/2009 04:11'!next: anInteger putAll: aString startingAt: startIndex	"Store the next anInteger elements from the given collection."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	collection ifNotNil: [		position < readLimit ifTrue: [ self flushReadBuffer ] ].		self primWrite: fileID from: aString startingAt: startIndex count: anInteger.	^aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'nice 12/8/2009 19:03'!upToAnyOf: delimiters do: aBlock	"Fast version to speed up nextChunk"	| pos buffer count result |	collection ifNotNil: [		(position < readLimit and: [			(count := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				count > 0 ] ]) ifTrue: [					result := collection copyFrom: position + 1 to: (position := count) - 1.					aBlock value: (collection at: count).					^result ] ].	pos := self position.	buffer := self next: 2000.	(count := buffer indexOfAnyOf: delimiters) > 0 ifTrue: 		["Found one of the delimiters part way into buffer"		self position: pos + count.		aBlock value: (buffer at: count).		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self upToAnyOf: delimiters do: aBlock)! !!StandardFileStream methodsFor: 'browser requests' stamp: 'ul 12/3/2009 06:40'!requestURLStream: url ifError: errorBlock	"Request a FileStream for the given URL.	If Squeak is not running in a browser evaluate errorBlock"	"FileStream requestURLStream:'http://www.squeak.org'"	| sema index request result |	self waitBrowserReadyFor: self defaultBrowserReadyWait ifFail: [^errorBlock value].	sema := Semaphore new.	index := Smalltalk registerExternalObject: sema.	request := self primURLRequest: url semaIndex: index.	request == nil ifTrue:[		Smalltalk unregisterExternalObject: sema.		^errorBlock value.	] ifFalse:[		[sema wait. "until something happens"		result := self primURLRequestState: request.		result == nil] whileTrue.		result ifTrue:[fileID := self primURLRequestFileHandle: request].		self primURLRequestDestroy: request.	].	Smalltalk unregisterExternalObject: sema.	fileID == nil ifTrue:[^nil].	self register.	name := url.	rwmode := false.	buffer1 := String new: 1.	self enableReadBuffering	! !!StandardFileStream methodsFor: 'browser requests' stamp: 'ul 12/3/2009 06:39'!requestURL: url target: target ifError: errorBlock	"Request to go to the target for the given URL.	If Squeak is not running in a browser evaluate errorBlock"	| sema index request result |	self waitBrowserReadyFor: self defaultBrowserReadyWait ifFail: [^errorBlock value].	sema := Semaphore new.	index := Smalltalk registerExternalObject: sema.	request := self primURLRequest: url target: target semaIndex: index.	request == nil ifTrue:[		Smalltalk unregisterExternalObject: sema.		^errorBlock value.	] ifFalse:[		[sema wait. "until something happens"		result := self primURLRequestState: request.		result == nil] whileTrue.		self primURLRequestDestroy: request.	].	Smalltalk unregisterExternalObject: sema.	fileID == nil ifTrue:[^nil].	self register.	name := url.	rwmode := false.	buffer1 := String new: 1.	self enableReadBuffering	! !!StandardFileStream methodsFor: 'private' stamp: 'ul 12/6/2009 02:49'!enableReadBuffering	collection ifNil: [		buffer1 ifNotNil: [			collection := self collectionSpecies new: 2048 ] ].	readLimit := position := 0! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'ul 12/3/2009 02:18'!binary	buffer1 := ByteArray new: 1.	collection ifNotNil: [ collection := collection asByteArray ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 12/3/2009 06:42'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	^self collectionSpecies streamContents: [ :newStream |		| next |		[ (next := self next) == nil ] whileFalse: [			newStream nextPut: next ] ]! !