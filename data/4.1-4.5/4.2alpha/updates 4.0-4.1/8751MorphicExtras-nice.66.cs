"Change Set:		8751MorphicExtras-nice.66MorphicExtras-nice.66:move #basicType to EToysremove some #or:or: #and:and: sends"!!CanvasCharacterScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 20:00'!displayLine: textLine offset: offset leftInRun: leftInRun 	"largely copied from DisplayScanner's routine"	| nowLeftInRun startLoc startIndex stopCondition |	line := textLine.	foregroundColor ifNil: [foregroundColor := Color black].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	rightMargin := line rightMargin + offset x.	lineY := line top + offset y.	lastIndex := textLine first.	nowLeftInRun := leftInRun <= 0 				ifTrue: 					[self setStopConditions.	"also sets the font"					text runLengthFor: lastIndex]				ifFalse: [leftInRun]. 	runX := destX := leftMargin.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	[			"remember where this portion of the line starts"			startLoc := destX @ destY.			startIndex := lastIndex.			"find the end of this portion of the line"			stopCondition := self 						scanCharactersFrom: lastIndex						to: runStopIndex						in: text string						rightX: rightMargin						stopConditions: stopConditions						kern: kern.	"displaying: false"			"display that portion of the line"			canvas 				drawString: text string				from: startIndex				to: lastIndex				at: startLoc				font: font				color: foregroundColor.			"handle the stop condition"			self perform: stopCondition	] whileFalse.	^runStopIndex - lastIndex! !!PostscriptCharacterScanner methodsFor: 'displaying' stamp: 'nice 12/28/2009 14:12'!displayLine: line offset: baseOffset leftInRun: leftInRun	| offset aText string doJustified |	self setTextStylesForOffset: ((line first) + 1).	" sets up various instance vars from text styles "	offset := baseOffset.	offset := offset + (line left @ (line top + line baseline - self font ascent )). 	offset := offset + ((self textStyle alignment caseOf:{		[Centered] -> [ line paddingWidth /2 ].		[RightFlush] -> [ line paddingWidth ] } otherwise:[0]) @ 0).	canvas moveto: offset.	aText := paragraph text copyFrom: line first to: line last.	doJustified := (paragraph textStyle alignment = Justified)						and: [ (paragraph text at:line last) ~= Character cr						and: [aText runs runs size = 1]].	string := aText string.	aText runs withStartStopAndValueDo: [:start :stop :attributes | | s drawFont |		self setTextStylesForOffset: (start + line first - 1).	" sets up inst vars from text styles "		s := string copyFrom: start to: stop.		drawFont := self font.		canvas setFont: drawFont.		canvas 			textStyled: s			at: offset 		"<--now ignored"			font: drawFont 		"<--now ignored"			color: foregroundColor			justified: doJustified		"<-can't do this now for multi-styles" 			parwidth: line right - line left.	].! !!Flaps class methodsFor: 'shared flaps' stamp: 'dgd 8/31/2003 19:29'!positionVisibleFlapsRightToLeftOnEdge: edgeSymbol butPlaceAtLeftFlapsWithIDs: idList	"Lay out flaps along the designated edge right-to-left, while laying left-to-right any flaps found in the exception list	Flaps positionVisibleFlapsRightToLeftOnEdge: #bottom butPlaceAtLeftFlapWithIDs: {'Navigator' translated. 'Supplies' translated}	Flaps sharedFlapsAlongBottom"	| leftX flapList flapsOnRight flapsOnLeft |	flapList := self globalFlapTabsIfAny select:		[:aFlapTab | aFlapTab isInWorld and: [aFlapTab edgeToAdhereTo == edgeSymbol]].	flapsOnLeft := flapList select: [:fl | idList includes: fl flapID].	flapList removeAll: flapsOnLeft.	flapsOnRight := flapList asSortedCollection:		[:f1 :f2 | f1 left > f2 left].	leftX := ActiveWorld width - 15.	flapsOnRight do:		[:aFlapTab |			aFlapTab right: leftX - 3.			leftX := aFlapTab left].	leftX := ActiveWorld left.	flapsOnLeft := flapsOnLeft asSortedCollection:		[:f1 :f2 | f1 left > f2 left].	flapsOnLeft do:		[:aFlapTab |			aFlapTab left: leftX + 3.			leftX := aFlapTab right].	(flapsOnLeft asOrderedCollection, flapsOnRight asOrderedCollection) do:		[:ft | ft computeEdgeFraction.		ft flapID = 'Navigator' translated ifTrue:			[ft referent left: (ft center x - (ft referent width//2) max: 0)]]! !!CommandHistory methodsFor: 'menu' stamp: 'nice 1/1/2010 22:07'!undoMenuWording	"Answer the wording to be used in an 'undo' menu item"	(lastCommand isNil			or: [Preferences useUndo not			or: [(Preferences infiniteUndo not and: [lastCommand phase == #undone])			or: [self nextCommandToUndo isNil]]])		ifTrue: [^ 'can''t undo' translated].	^ String		streamContents: [:aStream | 			aStream nextPutAll: 'undo' translated.			aStream nextPutAll: ' "'.			aStream nextPutAll: (self nextCommandToUndo cmdWording truncateWithElipsisTo: 20).			aStream nextPut: $".			lastCommand phase == #done				ifTrue: [aStream nextPutAll: ' (z)']].! !