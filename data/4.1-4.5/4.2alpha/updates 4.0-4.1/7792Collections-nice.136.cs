"Change Set:		7792Collections-nice.136Collections-nice.136:Fix from http://bugs.squeak.org/view.php?id=7095RATIONALE:Dictionary>>#collect: should preserve the keys1) This is the ANSI specification2) This is very logicalA Dictionary is a Bag of values indexed by unique, arbitrary keys.OLD BEHAVIOUR CRITIC:The old behaviour consisting in returning an OrderedCollection is wrong, at least for these reasons:a Dictionary is unordered, and there is no reason to reassign keys (1 to: self size) with a random order...BACKWARD COMPATIBILITY ISSUE:Those relying on old behaviour should replace their code with something like:	aDictionary values asOrderedCollection collect: aBlock.or:	(OrderedCollection newFrom: aDictionary) collect: aBlock.Collections-cbc.128:Optimized Character>>digitValue for latin numbers, without removing ability to work with non-latin digits (full functionality remains).  The speedup for Latin conversions removes more than 26% of the time to convert a number (as tested via the String>>asNumber method).Collections-ar.129:Merging Collections-ul.128:- introduced #new:streamContents: in SequenceableCollection class. It's like #streamContents: but if you know the size of the new collection this method doesn't copy the result.- updated SequenceableCollection class >> #streamContents: to use #new:streamContents:, kept the original default size 100.- also updated Dictionary >> #association, Bag >> #sortedCounts and Dictionary >> #keysSortedSafely to use #new:streamContents:.- introduced #sort: in OrderedCollection. It uses Array's merge sort to sort the internal array. This is much faster than sorting with SortedCollection (though it uses an extra Array object). Also added #sort which uses the same default block as Array >> #sort.- updated Bag >> #sortedCounts, Bag >> #sortedElements, Dictionary >> #keysSortedSafely, SequenceableCollection >> #sortBy: to use OrderedCollection's or Array's #sort method which can be significantly faster in these cases.- modified OrderedCollection class >> #newFrom: to avoid reallocating the internal array of the new OrderedCollection when the sender of #newFrom: doesn't extend the collection.- changed the variable name from anOrderedCollection to aCollection in OrderedCollection >> #addAllLast: since it is being used with other Collections. Also changed the comment which seems to be superfluous.All related tests are green.Collections-nice.130:add #removeAll suport to collectionsThis is to solve bothhttp://bugs.squeak.org/view.php?id=7177http://bugs.squeak.org/view.php?id=6937Comments about the implementation:The super implementation might be enhanced with a shallowCopy in order to provide a working implementation in more cases:    self shallowCopy do: [:each | self remove: each].I believe much subclasses will override, so I did not even bother.Subclass implementation tries to preserve original capacity.This choice is arbitrary and really depends on application side...CharacterSetComplement use a #become:. This is not efficient, but neither would be the addition of all existing characters to the complement (this set is defined by its complement as the name tells).Collection>>#removeAll: also has been modified to handle case of (self removeAll: self). This extends and supersedes the changes from kwl at http://bugs.squeak.org/view.php?id=6937The big question is what should (self removeAll: self) return?My answer is simple: it returns self (an empty collection).Beware, this will break some chaining:(b removeAll: (a removeAll: a)) ~= (a removeAll: (b removeAll: a)).Anyway, that is not worse than current implementation which will not lead to the most predictible results.Collections-nice.131:grab some WideCharacterSet patches from http://bugs.squeak.org/view.php?id=35741) A convenient #newFrom: instance creation method was missing, add it.2) #hash was bugged, correct it and handle CharacterSet equality => hash equality3) a period was missing in #remove:Collections-nice.132:WideCharacterSet patch again:forgot this one: copy is too shallow(modifying the original would modify the copy)Collections-nice.133:Harvest 3 missing fixes from http://bugs.squeak.org/view.php?id=63671) Create a CharacterSetComplement on a copy of the original (to avoid modifying the original when modifying the complement)2) Create a postCopy to avoid modifying the original when modifying the copy3) Correct a type in hashStrange, I thought it was already harvested in 3.10 ...Collections-ar.134:Merging Collections-ul.130:- don't try to use the matchTable if it doesn't contain the character of the strings in String >> #findSubstring:in:startingAt:matchTable:Collections-nice.135:Merge #removeAll from inbox/Collections-klub.131Its implementation looks good.I did not load the conflicting methods: apart comments, there are 3 of them:Collection>>#removeAll:he uses a #copy when I did notOrderedCollection>>#removeAllSet>>#removeAllWeakSet>>#removeAllklub preserves the same array using atAllPut: nil, when I create a new one.klub version will take a little longer to perform.Might perform better in case of huge collections ?(avoiding swap, putting less pressure on garbageCollector...)Anyone having an advice about this ?Concerning Set, he has to implement #removeAll in WeakSet, while I have to implement in KeyedSet, so 1-1Obviously, it would be good to extend the tests to more collection subclasses, to check whether our two implementations have holes or not"!!Dictionary methodsFor: 'accessing' stamp: 'ul 9/12/2009 17:16'!keysSortedSafely	"Answer an Array containing the receiver's keys."		| sortedKeys |	sortedKeys := Array new: self size streamContents: [ :stream |		self keysDo: [ :each | stream nextPut: each ] ].	sortedKeys sort: [ :x :y |		"Should really be use <obj, string, num> compareSafely..."		((x isString and: [ y isString ])			or: [ x isNumber and: [ y isNumber ] ])			ifTrue: [ x < y ]			ifFalse: [ x class == y class				ifTrue: [ x printString < y printString ]				ifFalse: [ x class name < y class name ] ] ].	^sortedKeys! !!CharacterSet methodsFor: 'removing' stamp: 'klub 9/14/2009 19:07'!removeAll	map atAllPut: 0! !!OrderedCollection methodsFor: 'adding' stamp: 'ul 9/12/2009 22:37'!addAllLast: aCollection 	"Add each element of aCollection at the end of the receiver. 	Answer aCollection."	aCollection do: [ :each | self addLast: each].	^aCollection! !!Dictionary methodsFor: 'enumerating' stamp: 'ar 6/13/2008 00:16'!collect: aBlock 	"Evaluate aBlock with each of my values as the argument.  Collect the	resulting values into a collection that is like me. Answer with the new	collection."	| newCollection |	newCollection := self species new.	self associationsDo:[:each |		newCollection at: each key put: (aBlock value: each value).	].	^newCollection! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 9/25/2007 21:01'!remove: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map				at: high				ifAbsent: [^ aCharacter].	self clearBitmap: lowmap at: low.	lowmap max = 0		ifTrue: [map removeKey: high].	^ aCharacter! !!OrderedCollection methodsFor: 'sorting' stamp: 'ul 9/12/2009 22:24'!sort: aSortBlock 	"Sort this array using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one."	self ifNotEmpty: [		array			mergeSortFrom: firstIndex			to: lastIndex			by: aSortBlock ]! !!Dictionary class methodsFor: 'instance creation' stamp: 'bgf 10/25/2006 17:08'!newFromPairs: anArray 	"Answer an instance of me associating (anArray at:i) to (anArray at: i+i)	 for each odd i.  anArray must have an even number of entries."	| newDictionary |	newDictionary := self new: (anArray size/2).	1 to: (anArray size-1) by: 2 do: [ :i|		newDictionary at: (anArray at: i) put: (anArray at: i+1).	].	^ newDictionary	"  Dictionary newFromPairs: {'Red' . Color red . 'Blue' . Color blue . 'Green' . Color green}. "! !!Heap methodsFor: 'removing' stamp: 'klub 9/14/2009 19:10'!removeAll	array atAllPut: nil.	tally := 0! !!Bag methodsFor: 'accessing' stamp: 'ul 9/13/2009 01:19'!sortedCounts	"Answer with a collection of counts with elements, sorted by decreasing	count."	^(Array new: contents size streamContents: [ :stream |		contents associationsDo: [ :each |			stream nextPut: each value -> each key ] ])		sort: [:x :y | x >= y ];		yourself! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 11/20/2007 00:19'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self copy! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'ul 9/12/2009 22:37'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^(self new: aCollection size)		resetTo: 1;		addAll: aCollection;		yourself"	OrderedCollection newFrom: {1. 2. 3}	{1. 2. 3} as: OrderedCollection	{4. 2. 7} as: SortedCollection"! !!Set methodsFor: 'removing' stamp: 'nice 12/30/2008 18:46'!removeAll	"remove all elements from this collection.	Preserve the capacity"		self initialize: self capacity! !!Bag methodsFor: 'accessing' stamp: 'ul 9/12/2009 03:14'!sortedElements	"Answer with a collection of elements with counts, sorted by element."	^contents associations		sort;		yourself! !!WideCharacterSet class methodsFor: 'instance creation' stamp: 'nice 11/15/2007 22:38'!newFrom: aCollection	| newCollection |	newCollection := self new.	newCollection addAll: aCollection.	^newCollection! !!CharacterSetComplement methodsFor: 'copying' stamp: 'nice 11/20/2007 01:08'!postCopy	absent := absent copy! !!WideCharacterSet methodsFor: 'copying' stamp: 'nice 11/20/2007 00:57'!postCopy	map := map collect: [:each | each copy]! !!Matrix methodsFor: 'removing' stamp: 'klub 9/14/2009 16:34'!removeAll	self shouldNotImplement! !!String methodsFor: 'system primitives' stamp: 'ul 9/14/2009 02:59'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned."	| index c1 c2 |	matchTable == nil ifTrue: [		key size = 0 ifTrue: [^ 0].		start to: body size - key size + 1 do:			[:startIndex |			index := 1.				[(body at: startIndex+index-1)					= (key at: index)]					whileTrue:					[index = key size ifTrue: [^ startIndex].					index := index+1]].		^ 0	].	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.		[c1 := body at: startIndex+index-1.		c2 := key at: index.		((c1 leadingChar = 0 and: [ c1 asciiValue < matchTable size ]) 			ifTrue: [ matchTable at: c1 asciiValue + 1 ]			ifFalse: [ c1 asciiValue + 1 ]) = 			((c2 leadingChar = 0 and: [ c2 asciiValue < matchTable size ])				ifTrue: [ matchTable at: c2 asciiValue + 1 ]				ifFalse: [c2 asciiValue + 1 ]) ]			whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0! !!OrderedCollection methodsFor: 'removing' stamp: 'nice 12/30/2008 18:44'!removeAll	"remove all the elements from this collection.	Keep same amount of storage"		self setCollection: (Array new: array size)! !!LinkedList methodsFor: 'removing' stamp: 'nice 1/10/2009 00:23'!removeAll	"Implementation note: this has to be fast"	firstLink := lastLink := nil! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 1/10/2009 00:50'!removeAll	| newSet |	newSet := CharacterSet new.	self become: newSet! !!KeyedSet methodsFor: 'removing' stamp: 'nice 12/30/2008 19:01'!removeAll	"See super."		| tmp |	tmp := keyBlock.	super removeAll.	keyBlock := tmp! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 1/10/2009 00:45'!removeAll	map removeAll! !!Collection methodsFor: 'removing' stamp: 'nice 1/10/2009 00:01'!removeAll: aCollection 	"Remove each element of aCollection from the receiver. If successful for 	each, answer aCollection. Otherwise create an error notification.	ArrayedCollections cannot respond to this message."	aCollection == self ifTrue: [^self removeAll].	aCollection do: [:each | self remove: each].	^ aCollection! !!CharacterSetComplement methodsFor: 'comparing' stamp: 'nice 11/1/2007 19:39'!hash	^ absent hash bitXor: self class hash! !!Bag methodsFor: 'removing' stamp: 'nice 9/14/2009 20:28'!removeAll	"Implementation Note: as contents will be overwritten, a shallowCopy of self would be modified.	An alternative implementation preserving capacity would be to create a new contents:	self setContents: (self class contentsClass new: contents size)."		contents removeAll! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 11/15/2007 21:26'!hash	"Answer a hash code aimed at storing and retrieving the receiver in a Set or Dictionary.	Two equal objects should have equal hash.	Note: as the receiver can be equal to an ordinary CharacterSet,	the hash code must reflect this"		^self hasWideCharacters		ifTrue: [map hash]		ifFalse: [self asCharacterSet hash]! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'ul 9/12/2009 19:33'!streamContents: blockWithArg		^self new: 100 streamContents: blockWithArg! !!WideCharacterSet methodsFor: 'converting' stamp: 'nice 11/20/2007 00:19'!complement	"return a character set containing precisely the characters the receiver does not"		^CharacterSetComplement of: self copy! !!SequenceableCollection methodsFor: 'copying' stamp: 'ul 9/12/2009 04:11'!sortBy: aBlock	"Create a copy that is sorted.  Sort criteria is the block that accepts two arguments.	When the block is true, the first arg goes first ([:a :b | a > b] sorts in descending	order)."	^ self asOrderedCollection		sort: aBlock;		yourself! !!WeakRegistry methodsFor: 'removing' stamp: 'nice 1/10/2009 00:44'!removeAll	"See super"		self protected:[		valueDictionary removeAll.	].! !!Collection methodsFor: 'removing' stamp: 'nice 9/14/2009 20:30'!removeAll	"Remove each element from the receiver and leave it empty.	ArrayedCollections cannot respond to this message.	There are two good reasons why a subclass should override this message:	1) the subclass does not support being modified while being iterated	2) the subclass provides a much faster way than iterating through each element"	self do: [:each | self remove: each].! !!ArrayedCollection methodsFor: 'removing' stamp: 'klub 9/14/2009 16:27'!removeAll	self shouldNotImplement! !!OrderedCollection methodsFor: 'sorting' stamp: 'ul 9/12/2009 03:18'!sort	"Sort this array into ascending order using the '<=' operator."	self sort: [:a :b | a <= b]! !!Dictionary methodsFor: 'accessing' stamp: 'ul 9/12/2009 17:29'!associations	"Answer a Collection containing the receiver's associations."		^Array new: self size streamContents: [ :stream |		self associationsDo: [ :each | stream nextPut: each ] ]! !!Character methodsFor: 'accessing' stamp: 'cbc 9/9/2009 23:23'!digitValue	"Answer 0-9 if the receiver is $0-$9, 10-35 if it is $A-$Z, and < 0 	otherwise. This is used to parse literal numbers of radix 2-36."	| value |		value := ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' indexOf: self) - 1.	value >= 0 ifTrue: [^value].	^ (EncodedCharSet charsetAt: self leadingChar) digitValue: self.! !!SequenceableCollection class methodsFor: 'stream creation' stamp: 'ul 9/12/2009 17:29'!new: newSize streamContents: blockWithArg	| stream |	stream := WriteStream on: (self new: newSize).	blockWithArg value: stream.	stream position = newSize		ifTrue: [ ^stream originalContents ]		ifFalse: [ ^stream contents ]! !