"Change Set:		8039Tools-nice.138Tools-nice.138:Use #keys rather than #fasterKeysNote that pattern (x keys asArray sort) could as well be written (x keys sort) now that keys returns an Array...This #asArray is here solely for cross-dialect/fork compatibility."!!DebuggerMethodMap class methodsFor: 'debugger support' stamp: 'nice 10/21/2009 00:04'!cacheDebugMap: aDebuggerMethodMap forMethod: aCompiledMethod	MapCache finalizeValues.	[MapCache size >= MapCacheEntries] whileTrue:		[| mapsByAge |		 mapsByAge := MapCache keys asArray sort:							[:m1 :m2|							(MapCache at: m1) timestamp							< (MapCache at: m2) timestamp].		mapsByAge notEmpty ifTrue: "There be race conditions and reentrancy issues here"			[MapCache removeKey: mapsByAge last]].	^MapCache		at: aCompiledMethod		put: aDebuggerMethodMap! !!FileContentsBrowser methodsFor: 'class list' stamp: 'nice 10/21/2009 00:05'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	(systemCategoryListIndex = 0 or:[self selectedPackage isNil])		ifTrue: [^Array new]		ifFalse: [^self selectedPackage classes keys asArray sort].! !!FileContentsBrowser methodsFor: 'class list' stamp: 'rbb 3/1/2005 10:52'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern := (UIManager default request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index := classNames size == 1				ifTrue:	[1]				ifFalse:	[(UIManager default chooseFrom: classNames lines: #())].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).	self classListIndex: (self classList indexOf: foundClass name). ! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'sd 11/20/2005 21:28'!browseStream: aStream named: aString	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict := Dictionary new.		browser := self new.		organizer := SystemOrganizer defaultList: Array new.		package := (FilePackage new fullName: aString; fileInFrom: aStream).		packageDict 			at: package packageName 			put: package.		organizer 			classifyAll: package classes keys 			under: package packageName.		(browser := self systemOrganizer: organizer)			packages: packageDict].	self		openBrowserView: browser createViews		label: 'File Contents Browser'.! !!DebuggerMethodMap methodsFor: 'source mapping' stamp: 'eem 6/5/2008 16:43'!rangeForPC: contextsConcretePC contextIsActiveContext: contextIsActiveContext	"Answer the indices in the source code for the supplied pc.	 If the context is the actve context (is at the hot end of the stack)	 then its pc is the current pc.  But if the context isn't, because it is	 suspended sending a message, then its current pc is the previous pc."	| pc i end |	pc := self method abstractPCForConcretePC: (contextIsActiveContext													ifTrue: [contextsConcretePC]													ifFalse: [(self method pcPreviousTo: contextsConcretePC)																ifNotNil: [:prevpc| prevpc]																ifNil: [contextsConcretePC]]).	(self abstractSourceMap includesKey: pc) ifTrue:		[^self abstractSourceMap at: pc].	sortedSourceMap ifNil:		[sortedSourceMap := self abstractSourceMap.		 sortedSourceMap := (sortedSourceMap keys collect: 								[:key| key -> (sortedSourceMap at: key)]) asSortedCollection].	(sortedSourceMap isNil or: [sortedSourceMap isEmpty]) ifTrue: [^1 to: 0].	i := sortedSourceMap indexForInserting: (pc -> nil).	i < 1 ifTrue: [^1 to: 0].	i > sortedSourceMap size ifTrue:		[end := sortedSourceMap inject: 0 into:			[:prev :this | prev max: this value last].		^end+1 to: end].	^(sortedSourceMap at: i) value	"| method source scanner map |	 method := DebuggerMethodMap compiledMethodAt: #rangeForPC:contextIsActiveContext:.	 source := method getSourceFromFile asString.	 scanner := InstructionStream on: method.	 map := method debuggerMap.	 Array streamContents:		[:ranges|		[scanner atEnd] whileFalse:			[| range |			 range := map rangeForPC: scanner pc contextIsActiveContext: true.			 ((map abstractSourceMap includesKey: scanner abstractPC)			  and: [range first ~= 0]) ifTrue:				[ranges nextPut: (source copyFrom: range first to: range last)].			scanner interpretNextInstructionFor: InstructionClient new]]"! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'sd 11/20/2005 21:28'!browseFiles: fileList	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict := Dictionary new.		organizer := SystemOrganizer defaultList: Array new.		fileList do: [:fileName |			package := FilePackage fromFileNamed: fileName.			packageDict 				at: package packageName 				put: package.			organizer 				classifyAll: package classes keys 				under: package packageName].		(browser := self systemOrganizer: organizer)			packages: packageDict].	self		openBrowserView: browser createViews		label: 'File Contents Browser'.! !