"Change Set:		8728Graphics-nice.97Graphics-nice.97:move #basicType to EToysremove useless done temp variable"!!DisplayScanner methodsFor: 'MVC-compatibility' stamp: 'nice 12/28/2009 20:10'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| leftInRun |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	morphicOffset := 0@0.	leftInRun := 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges := false.	paragraph := aParagraph.	foregroundColor := paragraphColor := aParagraph foregroundColor.	backgroundColor := aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt := nil]		ifFalse: [fillBlt := bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin := aParagraph rightMarginForDisplay.	lineY := aParagraph topAtLineIndex: linesInterval first.	bitBlt destForm deferUpdatesIn: visibleRectangle while: [		linesInterval do: 			[:lineIndex | 			| string startIndex lastPos runLength stopCondition |			line := aParagraph lines at: lineIndex.			lastIndex := line first.               self setStopConditions. " causes an assignment to inst var.  alignment "			leftMargin := aParagraph leftMarginForDisplayForLine: lineIndex alignment: (alignment ifNil:[textStyle alignment]).			destX := (runX := leftMargin).			line := aParagraph lines at: lineIndex.			lineHeight := line lineHeight.			fillBlt == nil ifFalse:				[fillBlt destX: visibleRectangle left destY: lineY					width: visibleRectangle width height: lineHeight; copyBits].			lastIndex := line first.			leftInRun <= 0				ifTrue: [self setStopConditions.  "also sets the font"						leftInRun := text runLengthFor: line first].			destY := lineY + line baseline - font ascent.  "Should have happened in setFont"			runLength := leftInRun.			runStopIndex := lastIndex + (runLength - 1) min: line last.			leftInRun := leftInRun - (runStopIndex - lastIndex + 1).			spaceCount := 0.			string := text string.			self handleIndentation.			[				startIndex := lastIndex.				lastPos := destX@destY.				stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex							in: string rightX: rightMargin stopConditions: stopConditions							kern: kern.				lastIndex >= startIndex ifTrue:[					font displayString: string on: bitBlt 						from: startIndex to: lastIndex at: lastPos kern: kern].				"see setStopConditions for stopping conditions for displaying."				self perform: stopCondition			] whileFalse.			fillBlt == nil ifFalse:				[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].			lineY := lineY + lineHeight]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 20:07'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	"Set up margins"	leftMargin := lineRectangle left.	leftSide ifTrue: [leftMargin := leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX := spaceX := leftMargin.	rightMargin := lineRectangle right.	rightSide ifTrue: [rightMargin := rightMargin - textStyle rightIndent].	lastIndex := startIndex.	"scanning sets last index"	destY := lineRectangle top.	lineHeight := baseline := 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle.	spaceCount := 0.	self handleIndentation.	leftMargin := destX.	line leftMargin: leftMargin.	[false]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 20:08'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength stopCondition |	destX := spaceX := leftMargin := aParagraph leftMarginForCompositionForLine: lineIndex.	destY := 0.	rightMargin := aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex := startIndex.	"scanning sets last index"	lineHeight := textStyle lineGrid.  "may be increased by setFont:..."	baseline := textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength := text runLengthFor: startIndex.	runStopIndex := (lastIndex := startIndex) + (runLength - 1).	line := TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount := 0.	[false]		whileFalse: 			[stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!DisplayScanner methodsFor: 'scanning' stamp: 'nice 12/28/2009 20:02'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| stopCondition nowLeftInRun startIndex string lastPos |	line := textLine.	morphicOffset := offset.	lineY := line top + offset y.	lineHeight := line lineHeight.	rightMargin := line rightMargin + offset x.	lastIndex := line first.	leftInRun <= 0 ifTrue: [self setStopConditions].	leftMargin := (line leftMarginForAlignment: alignment) + offset x.	destX := runX := leftMargin.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: line width left height: lineHeight; copyBits].	lastIndex := line first.	leftInRun <= 0		ifTrue: [nowLeftInRun := text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun := leftInRun].	destY := lineY + line baseline - font ascent.	runStopIndex := lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount := 0.	string := text string.	[		"remember where this portion of the line starts"		startIndex := lastIndex.		lastPos := destX@destY.				"find the end of this portion of the line"		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		"display that portion of the line"		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex 	"XXXX: The following is an interesting bug. All stopConditions exept #endOfRun		have lastIndex past the last character displayed. #endOfRun sets it *on* the character.		If we display up until lastIndex then we will also display invisible characters like		CR and tab. This problem should be fixed in the scanner (i.e., position lastIndex		consistently) but I don't want to deal with the fallout right now so we keep the		fix minimally invasive."				to: (stopCondition == #endOfRun ifTrue:[lastIndex] ifFalse:[lastIndex-1]) 				at: lastPos kern: kern].		"handle the stop condition"		"see setStopConditions for stopping conditions for displaying."		(self perform: stopCondition)			or: [lastIndex > runStopIndex].	] whileFalse.	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !Point removeSelector: #basicType!Color removeSelector: #basicType!