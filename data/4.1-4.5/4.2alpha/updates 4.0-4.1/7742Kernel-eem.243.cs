"Change Set:		7742Kernel-eem.243Kernel-eem.243:Fifth package of eight in closure compiler fixes 9/5/2009.Change kernel to use closure compiler fixes:- Replace old temp names compression scheme with the new one.- restore strange selector replacement in CompiledMethod>>getSourceFor:in:- remove unused CompiledMethod>>primitiveNode (and thence PrimitiveNode)"!!CompiledMethod methodsFor: 'source code management' stamp: 'eem 9/5/2009 15:04'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| flagByte source |	flagByte := self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) allSatisfy: [:i | (self at: self size - i) = 0])]])		ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNamesString)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"		source := [self getSourceFromFile]				on: Error		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."				do: [ :ex | ex return: nil].			^source		ifNotNil:			[| sourceSelector |			"I think this is something to do with the traits system.  It would be ncie if someone			 documented this.  It looks like an egregious hack to me. eem 9/5/2009 09:04"			 sourceSelector := Parser parserClass new parseSelector: source.			 sourceSelector = selector				ifTrue: [source]				ifFalse: [self replace: sourceSelector with: selector in: source]]		ifNil:			["Something really wrong -- decompile blind (no temps)"			 (class decompilerClass new decompile: selector in: class method: self)				decompileString]! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 9/5/2009 14:59'!copyWithTempNames: tempNames	"Minimal temp name copy that only works for methods containing no temporaries or blocks with arguments.	Used by the Traits system for creating conflict and required methdos that generate warnings.	For generic use use copyWithTempsFromMethodNode:"	| tempString |	tempString := String streamContents:					[:str|					tempNames						do: [:temp| str nextPutAll: temp]						separatedBy: [str space].					str space].	^self copyWithTrailerBytes: (self qCompress: tempString)! !!MethodProperties methodsFor: 'forward compatibility' stamp: 'eem 9/5/2009 15:09'!method: ignored	"For forward compatibility wth AdditionalMethodState, for decompilation"! !!MethodProperties methodsFor: 'properties' stamp: 'eem 9/5/2009 15:01'!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	^properties ifNotNil:[properties keysAndValuesDo: aBlock]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'eem 7/1/2009 13:53'!compileSelectionFor: anObject in: evalContext	| methodNode method |	methodNode := [Compiler new		compileNoPattern: self selectionAsStream		in: anObject class		context: evalContext		notifying: self		ifFail: [^nil]]			on: OutOfScopeNotification			do: [:ex | ex resume: true].	method := methodNode generate: #(0 0 0 0).	^method copyWithTempsFromMethodNode: methodNode! !CompiledMethod removeSelector: #primitiveNode!CompiledMethod removeSelector: #qCompress:firstTry:!CompiledMethod removeSelector: #qDecompress:!CompiledMethod removeSelector: #tempNames!ContextPart removeSelector: #isBottomContext!