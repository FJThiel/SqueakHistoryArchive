"Change Set:		8623XML-Parser-nice.23XML-Parser-nice.23:Cosmetic: move or remove a few temps inside closuresXML-Parser-nice.20:Merge trunk with latest version from http://www.squeaksource.com/XMLSupportXML-Parser-nice.21:Never ask String to findFirstInString:inSet:startingAt: because this will always be slow in an image with wide characters...Rather ask aString class to do the job, it might be fast if it is a ByteString.XML-Parser-nice.22:Cosmetic: move or remove a few temps inside closures"!XMLTokenizer subclass: #XMLParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'XML-Parser'!XMLNode subclass: #XMLNodeWithElements	instanceVariableNames: 'elementsAndContents uri namespace parent'	classVariableNames: ''	poolDictionaries: ''	category: 'XML-Parser'!XMLNodeWithElements subclass: #XMLElement	instanceVariableNames: 'name attributes'	classVariableNames: ''	poolDictionaries: ''	category: 'XML-Parser'!ClassTestCase subclass: #XMLParserTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'XML-Parser'!Object subclass: #XMLWriter	instanceVariableNames: 'stream stack scope scanner canonical currentIndent indentString'	classVariableNames: 'XMLTranslation XMLTranslationMap'	poolDictionaries: ''	category: 'XML-Parser'!XMLTokenizer subclass: #SAXDriver	instanceVariableNames: 'saxHandler scope useNamespaces validateAttributes languageEnvironment'	classVariableNames: ''	poolDictionaries: ''	category: 'XML-Parser'!!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/16/2003 16:21'!namespace: ns uri: u	namespace := ns.	uri := u! !!XMLWriter methodsFor: 'writing xml' stamp: 'nice 12/22/2009 20:49'!pcData: aString	| lastIndex nextIndex |	lastIndex := 1.	"Unroll the first search to avoid copying"	nextIndex := aString class findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self stream nextPutAll: aString].	[self stream nextPutAll: (aString copyFrom: lastIndex to: nextIndex-1).	self stream nextPutAll: (XMLTranslation at: (aString at: nextIndex)).	lastIndex := nextIndex + 1.	nextIndex := aString class findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0] whileFalse.	self stream nextPutAll: (aString copyFrom: lastIndex to: aString size).! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:23'!elementUnqualifiedAt: entityName ifAbsent: aBlock	elementsAndContents		ifNil: [^aBlock value].	^self elements detect: [:each | each localName = entityName] ifNone: [^aBlock value]! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version: aString		version := aString! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 11:52'!testExampleAddressBook	| tokenizer |	"self debug: #testExampleAddressBook"	tokenizer := XMLTokenizer on: self addressBookXML readStream.	"We enumerate the first characters of the addressbook example. The file being parsed begins with <addressbook"	self assert: tokenizer next = $<.	self assert: tokenizer next = $a.		self assert: tokenizer next = $d.	self assert: tokenizer next = $d.	self assert: tokenizer next = $r.	self shouldnt: ([tokenizer next notNil] whileTrue: []) raise: Error. ! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:51'!nextAttributeValue	| delimiterChar attributeValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar := self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Attribute value delimiter expected.'].	attributeValueStream := attributeBuffer reset.	[	nextPeek := nextChar := self next.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek := nil.							nextChar := entityValue first]						ifFalse: [							entityValue := entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek := nextChar := nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek := nextChar := self next]]]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [attributeValueStream nextPut: nextChar]].	^self fastStreamStringContents: attributeValueStream"	^attributeValueStream contents"! !!XMLParserTest methodsFor: 'source' stamp: 'AlexandreBergel 1/29/2009 11:49'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><?xml-stylesheet type="text/xsl" href="demo.xsl"?><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 19:42'!nextUpToAll: delimitingString	| string |	self unpeek.	string := self upToAll: delimitingString.	string		ifNil: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].	^string! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:02'!push: anObject	self stack add: anObject.	entity := anObject! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'rkris 7/28/2004 12:35'!nextExternalId	| extDefType systemId dir |	extDefType := self nextLiteral.	extDefType = 'PUBLIC'		ifTrue: [			self skipSeparators.			self nextPubidLiteral.			self skipSeparators.			self peek == $>				ifFalse: [					systemId := self nextSystemLiteral]].	extDefType = 'SYSTEM'		ifTrue: [			self skipSeparators.			systemId := self nextSystemLiteral].	systemId		ifNil: [^nil].	"The rest of this method only applies if we're reading aFileStream"	(self topStream isKindOf: FileStream)		ifFalse: [^''].	dir := self topStream directory.	^(dir fileExists: systemId)		ifTrue: [(dir readOnlyFileNamed: systemId) contentsOfEntireFile]		ifFalse: ['']! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata: aString	ndata := aString! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/23/2007 15:45'!initEntities	| ents |	ents := Dictionary new.	ents		at: 'amp' put: (DTDEntityDeclaration name: 'amp' value: '&');		at: 'quot' put: (DTDEntityDeclaration name: 'quot' value: '"');		at: 'apos' put: (DTDEntityDeclaration name: 'apos' value: '''');		at: 'gt' put: (DTDEntityDeclaration name: 'gt' value: '>');		at: 'lt' put: (DTDEntityDeclaration name: 'lt' value: '<').	^ents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/29/2001 00:36'!popNestingLevel	self hasNestedStreams		ifTrue: [			self stream close.			self stream: self nestedStreams removeLast.			self nestedStreams size > 0				ifFalse: [nestedStreams := nil]]! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/8/2002 13:54'!nextDocType	| declType |	declType := self nextLiteral.	declType = 'DOCTYPE'		ifTrue: [			self startParsingMarkup.			^self nextDocTypeDecl].	self errorExpected: 'markup declaration, not ' , declType printString! !!XMLDOMParser methodsFor: 'content' stamp: 'thf 9/2/2005 14:09'!documentAttributes: attributeList	self document version: (attributeList at: 'version' ifAbsent: [nil]).	self document encoding: (attributeList at: 'encoding' ifAbsent: [nil]).	self document requiredMarkup: (attributeList at: 'requiredMarkup' ifAbsent: [nil]).! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/28/2001 16:38'!nextIncludeSection: parseSection	| section |	"Read the file up to the next include section delimiter and parse it if parseSection is true"		section := self nextUpToAll: ']]>'.	parseSection		ifTrue: [			self pushStream: (ReadStream on: section)]! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre.Bergel 6/1/2009 10:30'!at: aSymbol	^ self attributeAt: aSymbol ! !!XMLElement methodsFor: 'accessing' stamp: 'mir 10/31/2007 18:24'!contents	^self elementsAndContents select: [:each | each isText]! !!String methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment		| leadingChar |	leadingChar := languageEnvironment leadingChar.	self withIndexDo: [:each :idx |		each asciiValue > 255			ifTrue: [self at: idx put: (Character leadingChar: leadingChar code: each asUnicode)]]! !!XMLWriter methodsFor: 'initialize' stamp: 'mir 7/12/2006 15:54'!initialize	stack := OrderedCollection new.	canonical := false.	scope := XMLNamespaceScope new! !!SAXHandler class methodsFor: 'instance creation' stamp: 'cwp 5/28/2003 02:08'!parseDTDFrom: aStream	| driver parser |	driver := SAXDriver on: aStream.	driver validating: true.	driver startParsingMarkup.	parser := self new driver: driver.	parser startDocument.	parser parseDocument.	^parser! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/14/2005 14:07'!nextCharReference	| base charValue |	self next == $#		ifFalse: [self errorExpected: 'character reference'].	base := self peek == $x		ifTrue: [			self next.			16]		ifFalse: [10].	charValue := [self readNumberBase: base] on: Error do: [:ex | self errorExpected: 'Number.'].	(self next) == $;		ifFalse: [self errorExpected: '";"'].	^Unicode value: charValue! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 11:53'!testExampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer := XMLTokenizer on: self addressBookXMLWithDTD readStream.	self shouldnt: ([tokenizer next notNil] whileTrue: []) raise: Error! !!XMLParserTest methodsFor: 'source' stamp: 'AlexandreBergel 1/29/2009 11:49'!addressBookXML	^'<addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:26'!endDocument	"This call corresponds to the Java SAX call	endDocument()."	eod := true! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 20:00'!upToAll: delimitingString	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of delimitingString. If delimitingString is not in the stream, answer the entire rest of the stream."	| result |	self hasNestedStreams		ifFalse: [			result := self stream: self stream upToAll: delimitingString.			result				ifNil: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].			^result].	result := self stream: self stream upToAll: delimitingString.	result		ifNotNil: [^result].	result := String streamContents: [:resultStream |		resultStream nextPutAll: self stream upToEnd.		self atEnd			ifTrue: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].		self stream position timesRepeat: [			self atEnd				ifFalse: [					resultStream nextPut: self next]]].	self pushBack: result.	^self upToAll: delimitingString! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:52'!indent	currentIndent		ifNotNil: [currentIndent := currentIndent +1]! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:55'!value: aString	value := aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:36'!handleEndTag: elementName	| namespace localName namespaceURI qualifiedName |	self usesNamespaces		ifTrue: [			self splitName: elementName into: [:ns :ln |				namespace := ns.				localName := ln].			"ensure our namespace is defined"			namespace				ifNil: [					namespace := self scope defaultNamespace.					qualifiedName := namespace , ':' , elementName]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString].					qualifiedName := elementName].			"call the handler"			self saxHandler				checkEOD; 				endElement: localName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName.			self scope leaveScope]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				endElement: elementName namespace: nil namespaceURI: nil qualifiedName: elementName]! !!XMLElement methodsFor: 'initialize' stamp: 'mir 3/7/2000 16:43'!setAttributes: newAttributes	attributes := newAttributes! !!XMLElement methodsFor: 'accessing' stamp: 'gc 6/28/2007 21:32'!parent	^ parent! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:42'!skipUpTo: delimiter	| nextChar |	self unpeek.	[self atEnd or: [(nextChar := self next) == delimiter]]		whileFalse: [].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found']! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:13'!elementsAndContents	elementsAndContents ifNil: [elementsAndContents := OrderedCollection new].	^elementsAndContents! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup: aString		requiredMarkup := aString! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 13:49'!nextMarkupDeclaration	| declType |	declType := self nextLiteral.	self validating		ifFalse: [^self skipMarkupDeclaration].	declType = 'ENTITY'		ifTrue: [self nextEntityDeclaration]		ifFalse: [self skipMarkupDeclaration]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'gvc 6/6/2007 13:13'!pushBack: aString	"Fixed to push the string before the peek char (if any)."		| pushBackString |	pushBackString := peekChar		ifNil: [aString]		ifNotNil: [aString, peekChar asString].	peekChar := nil.	self pushStream: (ReadStream on: pushBackString)! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:23'!elementAt: entityName ifAbsent: aBlock	elementsAndContents		ifNil: [^aBlock value].	^self elements detect: [:each | each isProcessingInstruction not and: [each name = entityName or: [each localName = entityName]]] ifNone: [^aBlock value]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 13:00'!nextPI	| piTarget piData |	"Skip ?"	self next.	piTarget := self nextLiteral.	piTarget asUppercase = 'XML'		ifTrue: [^self nextXMLDecl].	self skipSeparators.	piData := self nextUpToAll: '?>'.	self handlePI: piTarget data: piData! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:25'!elementsDo: aBlock	self elementsAndContentsDo: [:each | each isText ifFalse: [aBlock value: each]]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:55'!handlePCData: aString	self languageEnvironment		ifNotNil: [aString applyLanguageInfomation: self languageEnvironment].	self saxHandler		checkEOD; 		characters: aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!encoding: aString		encoding := aString! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 3/14/2003 23:09'!fastStreamStringContents: writeStream	| newSize |	newSize := writeStream position.	^(String new: newSize)		replaceFrom: 1		to: newSize		with: writeStream originalContents		startingAt: 1! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:05'!peek	"Return the next character from the current input stream. If the current stream poop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^peekChar := stream next]		ifNotNil: [^peekChar]! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 18:52'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	| newElement |	"newElement := namespace = self defaultNamespace		ifTrue: [XMLElement named: localName namespace: nil uri: nil attributes: attributeList]		ifFalse: [XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList]."	newElement := XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLTokenizer methodsFor: 'streaming' stamp: 'gvc 6/6/2007 13:19'!unpeek	"Fixed to use nested stream since multi-byte streams	do not properly override pushBack: to deal with multi-byte	characters."		peekChar ifNotNil: [self pushBack: '']! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target: aString	target := aString! !!XMLTokenizer methodsFor: 'streaming' stamp: 'nice 12/26/2009 22:31'!streamEncoding: encodingString	Smalltalk at: #TextConverter ifPresent: [:tc | 		(stream respondsTo: #converter:) ifTrue: [			| converterClass |			converterClass := tc defaultConverterClassForEncoding: encodingString asLowercase.			converterClass ifNotNil: [stream converter: converterClass new]]]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:13'!elements	^self elementsAndContents! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document: aDocument	document := aDocument! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string: aString	string := aString! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 10/31/2007 17:49'!nextWhitespace	| nextChar resultStream resultString|	resultStream := (String new: 10) writeStream.	[((nextChar := self peek) ~~ nil)		and: [SeparatorTable includes: nextChar]]		whileTrue: [resultStream nextPut: nextChar. self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [self checkNestedStream.				self nextWhitespace].	resultString := resultStream contents.	resultString isEmpty ifFalse: [self handleWhitespace: resultString].	^resultString! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data: aString	data := aString! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!startElement: elementName attributeList: attributeList	| newElement |	newElement := XMLElement named: elementName attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 18:16'!match: subCollection into: resultStream	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern _ ReadStream on: subCollection.	startMatch _ nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^ false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch.						startMatch _ nil]]].	^ true! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 18:12'!handleEntity: referenceString in: parsingContext 	| entity entityValue |	entity := self entity: referenceString.	entityValue := entity valueForContext: parsingContext.	(self class isCharEscape: entityValue)		ifTrue: [entityValue := entity reference].	self pushStream: (ReadStream on: entityValue asString)! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 17:29'!nextDocTypeDecl	| nextChar |	self skipSeparators.	self nextLiteral.	self skipSeparators.	self peek == $[		ifFalse: [[nextChar := self peek.				nextChar == $> or: [nextChar == $[ ]] whileFalse: [self next]].	self peek == $[		ifTrue: [			self next.			[self skipSeparators.			self peek == $]] whileFalse: [				self checkAndExpandReference: #dtd.				self nextNode].			self next == $] 				ifFalse: [self errorExpected: ']' ]].	self skipSeparators.	self next == $>		ifFalse: [self errorExpected: '>' ].	self endParsingMarkup! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical: aBoolean	canonical := aBoolean! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 16:23'!exampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer := XMLTokenizer on: self addressBookXMLWithDTD readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLElement methodsFor: 'accessing' stamp: 'gc 6/28/2007 21:32'!parent: anXMLElement	parent := anXMLElement ! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'thf 9/2/2005 15:04'!nextXMLDecl	| attributes nextChar namespaces |	self skipSeparators.	attributes := Dictionary new.	namespaces := Dictionary new.	[(nextChar := self peek) == $?] whileFalse: [		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self next.	self next == $>		ifFalse: [self errorExpected: '> expected.'].	(attributes includesKey: 'encoding') ifTrue: [self streamEncoding: (attributes at: 'encoding')].	self handleXMLDecl: attributes namespaces: namespaces	! !!XMLTokenizer methodsFor: 'private' stamp: 'mu 11/14/2005 14:12'!readNumberBase: base	"Read a hex number from stream until encountering $; "	| value digit |	base = 10 ifFalse: [	| numberString | 		numberString := self nextUpTo: $;.		self stream skip: -1.		^Integer readFrom: numberString asUppercase readStream base: base. 	].	value := 0.	digit := DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [self error: 'At least one digit expected here'].	self next.	value := digit.	[digit := DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [^value]		ifFalse: [			self next.			value := value * base + digit]		] repeat.	^ value! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental: aBoolean	incremental := aBoolean! !!XMLTokenizer class methodsFor: 'class initialization' stamp: 'mir 10/31/2007 17:22'!initialize	"XMLTokenizer initialize"	CharEscapes := CharacterSet newFrom: #( $& $" $' $> $< ).	SeparatorTable  := CharacterSet new.	#(9 10 12 13 32) do: [:each | SeparatorTable add: each asCharacter].	LiteralChars := CharacterSet newFrom: #( $: $- $: $= $.).	0 to: 255 do: [:i | 		| char |		char := i asCharacter.		(char isDigit or: [char isLetter])		ifTrue: [LiteralChars add: char]].	NameDelimiters := CharacterSet new.	#(9 10 12 13 32 61 "$= asInteger 61" 62 "$> asInteger" 47 "$/ asInteger")		do: [:each | NameDelimiters add: each asCharacter].	DigitTable := Array new: 256.	DigitTable atAllPut: -1.	($0 to: $9) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($a to: $f) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($A to: $F) do: [:each | DigitTable at: each asciiValue put: each digitValue].! !!XMLTokenizer methodsFor: 'initialize' stamp: 'mir 3/14/2003 19:27'!initialize	parsingMarkup := false.	validating := false.	attributeBuffer := WriteStream on: (String new: 128).	nameBuffer := WriteStream on: (String new: 128)! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 16:32'!nextAttributeInto: attributes namespaces: namespaces	| attrName attrValue |	attrName := self nextName.	self skipSeparators.	self next == $=		ifFalse: [self errorExpected: '='].	self skipSeparators.	attrValue := self nextAttributeValue.	(self usesNamespaces		and: [(attrName findString: 'xmlns') = 1])		ifTrue: [attrName size > 6			ifTrue: [namespaces at: (attrName copyFrom: 7 to: attrName size) put: attrValue]			ifFalse: [namespaces at: attrName put: attrValue]]		ifFalse: [attributes at: attrName put: attrValue]! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 14:53'!endElement: localName namespace: namespace namespaceURI: uri qualifiedName: qualifiedName	| currentElement |	currentElement := self pop.	(currentElement namespace isNil		or: [currentElement namespace = self defaultNamespace])		ifTrue: [			currentElement localName = localName				ifFalse: [self driver errorExpected: 'End tag "', localName , '" doesn''t match "' , currentElement localName  , '".']]		ifFalse: [			currentElement qualifiedName = qualifiedName				ifFalse: [self driver errorExpected: 'End tag "', qualifiedName , '" doesn''t match "' , currentElement qualifiedName  , '".']]! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!processingInstruction: piName data: dataString	| newElement |	newElement := XMLPI target: piName data: dataString.	self top addElement: newElement! !!XMLElement methodsFor: 'initialize' stamp: 'mir 1/17/2002 15:24'!name: aString	name := aString asSymbol! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre.Bergel 6/1/2009 10:31'!@ aSymbol	"shorthand form"	^ self at: aSymbol ! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 12:21'!testParsingCharacters	| parser |	"This test is actually not that useful. This is not the proper way of using the parser. This test is here just for specification purpose"	"self debug: #testParsingCharacters"	parser := XMLParser on: self addressBookXML readStream.	self assert: parser next = $<.	self assert: parser next = $a.		self assert: parser next = $d.	self assert: parser next = $d.	self assert: parser next = $r.! !!XMLTokenizer methodsFor: 'streaming' stamp: 'bf 4/27/2006 17:55'!nextTrimmedBlanksUpTo: delimiter	| resultStream nextChar |	resultStream := WriteStream on: (String new: 10).	nextChar := nil.	[(nextChar := self next) == delimiter]		whileFalse: [			nextChar == $  ifFalse: [				resultStream nextPut: nextChar]].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:02'!elementsAndContentsDo: aBlock	self elementsDo: aBlock! !!XMLElement methodsFor: 'initialize' stamp: 'mir 10/31/2007 17:55'!addContent: contentString	self addElement: contentString! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:20'!parameterEntities	parameterEntities ifNil: [parameterEntities := Dictionary new].	^parameterEntities! !!XMLTokenizer class methodsFor: 'accessing' stamp: 'mir 11/23/2007 15:50'!isCharEscape: entityValue	^entityValue size = 1		and: [CharEscapes includes: entityValue first]! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/29/2007 14:42'!root	"return my root element"	^ self topElement ! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName readIntoMemory: readIntoMemory	| stream xmlDoc |	stream := FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream := stream contentsOfEntireFile readStream].	[xmlDoc := self parseDocumentFrom: stream]		ensure: [stream close].	^xmlDoc! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntities	externalEntities ifNil: [externalEntities := Dictionary new].	^externalEntities! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 10/31/2007 16:33'!skipSeparators	| nextChar |	[((nextChar := self peek) ~~ nil)		and: [SeparatorTable includes: nextChar]]		whileTrue: [self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [			self checkNestedStream.			self skipSeparators]! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver: aDriver	driver := aDriver.	driver saxHandler: self! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/28/2001 18:45'!nextEntity	| currentTop |	currentTop := self top.	[self driver nextEntity isNil		or: [self top ~~ currentTop]] whileTrue.	^entity! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:04'!next	"Return the next character from the current input stream. If the current stream is at end pop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	| nextChar |	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^nextChar := stream next]		ifNotNil: [			nextChar := peekChar.			peekChar := nil.			^nextChar].	! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:23'!popTag: tagName	| stackTop |	stackTop := self stack isEmpty		ifTrue: ['<empty>']		ifFalse: [self stack last].	^stackTop = tagName		ifTrue: [self stack removeLast]		ifFalse: [self error: 'Closing tag "' , tagName , '" does not match "' , stackTop]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 12/6/2000 14:29'!nextCDataOrConditional	| nextChar conditionalKeyword |	"Skip ["	self next.	self skipSeparators.	nextChar := self peek.	nextChar == $%		ifTrue: [			self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).			conditionalKeyword := self nextLiteral.			self skipSeparators.			^self next == $[				ifTrue: [						self skipSeparators.						self nextIncludeSection: (self conditionalInclude: conditionalKeyword)]				ifFalse: [self errorExpected: '[' ]].	nextChar == $C		ifTrue: [			^self nextLiteral = 'CDATA'				ifTrue: [self peek == $[							ifTrue: [self nextCDataContent]							ifFalse: [self errorExpected: '[' ]]				ifFalse: [self errorExpected: 'CData']].	self errorExpected: 'CData or declaration'! !!XMLDOMParser class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:26'!addressBookXMLWithDTD	"XMLDOMParser addressBookXMLWithDTD"	^self parseDocumentFrom: XMLTokenizer addressBookXMLWithDTD readStream useNamespaces: true! !!ByteString methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment! !!XMLElement methodsFor: 'accessing' stamp: 'mas 10/15/2003 09:18'!attributes	^attributes ifNil: [attributes := Dictionary new]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:54'!nextComment	| string |	"Skip first -"	self next.	self next == $-		ifFalse: [self errorExpected: 'second comment $-'].	string := self nextUpToAll: '-->'.	self handleComment: string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 10/31/2007 16:20'!nextName	| nextChar |	nameBuffer reset.	self peek == $.		ifTrue: [self malformedError: 'Character expected.'].	[(nextChar := self peek)		ifNil: [self errorExpected: 'Character expected.'].	NameDelimiters includes: nextChar] whileFalse: [			nameBuffer nextPut: self next].	^self fastStreamStringContents: nameBuffer! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentString: aString	currentIndent := 0.	indentString := aString! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:08'!startTag: tagName	self writeIndent.	self startTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 17:05'!outdent	currentIndent		ifNotNil: [			stream cr.			currentIndent := currentIndent-1.			self writeIndent.			currentIndent := currentIndent-1.]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 17:00'!nextCDataContent	| cdata |	"Skip $[ "	self next.	cdata := self nextUpToAll: ']]>'.	self handleCData: cdata! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'mir 11/14/2007 17:21'!elementsDo: aBlock	self elements do: [:each | aBlock value: each]! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:24'!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25'!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!endParsingMarkup	parsingMarkup := false! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:58'!writeIndent	currentIndent ifNotNil: [		currentIndent timesRepeat: [self stream nextPutAll: indentString]]! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:26'!parseDocumentFrom: aStream useNamespaces: aBoolean	|  parser |	parser := self on: aStream.	parser useNamespaces: aBoolean.	parser startDocument.	parser parseDocument.	^parser! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream: aStream	stream := aStream! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre.Bergel 6/1/2009 10:29'!allAttributes	^ self attributes asOrderedCollection! !!XMLElement methodsFor: 'testing' stamp: 'mir 10/31/2007 17:55'!isEmpty	^self elements isEmpty! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 7/14/2006 11:48'!languageEnvironment	^languageEnvironment! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 1/14/2002 17:51'!validating: aBoolean	validating := aBoolean! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 10/25/2000 11:30'!characters: aString	| newElement |	newElement := XMLStringNode string: aString.	self top addContent: newElement.! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:44'!nextUpTo: delimiter	| resultStream nextChar |	resultStream := WriteStream on: (String new: 10).	[self atEnd or: [(nextChar := self next) == delimiter]]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:52'!nextNode	| nextChar |	"Skip < "	self next.	nextChar := self peek.	nextChar == $!! ifTrue: [		"Skip !!"		self next.		nextChar := self peek.		nextChar == $- ifTrue: [^self nextComment].		nextChar == $[ ifTrue: [^self nextCDataOrConditional].		^self parsingMarkup			ifTrue: [self nextMarkupDeclaration]			ifFalse: [self nextDocType]].	nextChar == $? ifTrue: [^self nextPI].	^self nextTag! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!startParsingMarkup	parsingMarkup := true! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 11/14/2007 17:25'!addElement: element	self elementsAndContents add: element! !!XMLNode methodsFor: 'searching' stamp: 'nice 12/26/2009 22:30'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag. Pass the message on"	self elementsDo: [:node |		| answer |		(answer := node firstTagNamed: aSymbol) ifNotNil: [^answer]].	^nil! !!XMLNamespaceScope methodsFor: 'validation' stamp: 'nice 12/27/2009 03:26'!validateAttributes: attributeList	"check all attribute namespaces are defined and not duplicated by aliasing"		attributeList keysDo: [:attrName |		| namespace localName |		self splitName: attrName into: [:ns :ln |			namespace := ns.			localName := ln].		namespace ifNotNil: [			(self namespaceAliases: namespace) do: [:alias |				(attributeList includesKey: alias , ':' , localName)					ifTrue: [self parseError: 'Attributes ' , attrName , ' and ' , alias , ':' , localName , ' are aliased to namespace ' , (self namespaceURIOf: namespace) ]]]]! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:54'!nestedStreams	nestedStreams ifNil: [nestedStreams := OrderedCollection new].	^nestedStreams! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:52'!nextPCData	| resultStream nextChar referenceString entity entityValue nextPeek |	resultStream := (String new: 10) writeStream.	self validating		ifFalse: [			[self peek == $<]				whileFalse: [resultStream nextPut: self next].			^self handlePCData: resultStream contents].	[	nextPeek := nextChar := self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek := nil.							nextChar := entityValue first]						ifFalse: [							entityValue := entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek := nextChar := nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek := nextChar := self peek]]]]		ifFalse: [nextPeek == $< ifFalse: [self next]].	nextPeek == $<]		whileFalse: [			nextChar ifNotNil: [resultStream nextPut: nextChar]].	self handlePCData: resultStream contents! !!DTDParameterEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDParameterEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #notRecognized: ;		at: #attributeValueContent put: #notRecognized: ;		at: #attributeValue put: #notRecognized: ;		at: #entityValue put: #include: ;		at: #dtd put: #includePE:! !!XMLParserTest methodsFor: 'tests' stamp: 'AlexandreBergel 1/29/2009 14:38'!testParsing	| xmlDocument root firstPerson numberOfPersons |	"self debug: #testParsing"	xmlDocument := XMLDOMParser parseDocumentFrom: self addressBookXML readStream.	self assert: (xmlDocument isKindOf: XMLDocument).	root := xmlDocument root.	self assert: (root class == XMLElement).		"the tag has to be a symbol!!"	self assert: (root firstTagNamed: 'person') isNil.	self assert: (root firstTagNamed: 'addressbook') isNil.	self assert: (root firstTagNamed: #addressbook) == root.	numberOfPersons := 0.	root tagsNamed: #person do: [:p | numberOfPersons := numberOfPersons + 1].	self assert: numberOfPersons = 4.	firstPerson := root firstTagNamed: #person.	self assert: (firstPerson attributeAt: #'employee-number') = 'A0000'.	self assert: (firstPerson attributeAt: #'family-name') = 'Gates'.	self assert: (firstPerson attributeAt: #'first-name') = 'Bob'.! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 22:37'!nextTag	| tagName attributes nextChar namespaces |	(self peek = $/)		ifTrue: [^self nextEndTag].	tagName := self nextName.	self skipSeparators.	attributes := Dictionary new: 33.	namespaces := Dictionary new: 5.	[(nextChar := self peek) == $> or: [nextChar == $/]] whileFalse: [		self checkAndExpandReference: #content.		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self handleStartTag: tagName attributes: attributes namespaces: namespaces.	self next == $/		ifTrue: [			self handleEndTag: tagName.			self next].	! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/16/2003 13:09'!splitName: aName into: twoArgsBlock	"Split the name into namespace and local name (the block arguments).	Handle both qualified and unqualified names using the default name space"	| i ns ln |	i := aName lastIndexOf: $:.	i = 0		ifTrue: [			ns := nil.			ln := aName]		ifFalse: [			ns := aName copyFrom: 1 to: (i - 1).			ln := aName copyFrom: i+1 to: aName size].	twoArgsBlock value: ns value: ln! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:52'!saxHandler: aHandler	saxHandler := aHandler! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/23/2007 17:48'!nextEndTag	| tagName |	"Skip /"	self next.	tagName := self nextName.	self skipSeparators.	(self nextTrimmedBlanksUpTo: $>)		ifNotEmpty: [self parseError: 'XML invalid end tag ' , tagName].	self handleEndTag: tagName! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 14:24'!nextEntityDeclaration	| entityName entityDef referenceClass reference |	self skipSeparators.	referenceClass := self peek == $%		ifTrue: [			self next.			self skipSeparators.			DTDParameterEntityDeclaration]		ifFalse: [DTDEntityDeclaration].	entityName := self nextLiteral.	self skipSeparators.	entityDef := (self peek == $" or: [self peek == $'])		ifTrue: [self nextEntityValue]		ifFalse: [self nextExternalId].	self skipUpTo: $>.	reference := referenceClass name: entityName value: entityDef.	reference registerIn: self.	^reference! !!XMLNode methodsFor: 'searching' stamp: 'nice 12/26/2009 22:31'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that	allows the block to evaluate to true. Pass the message on"	self elementsDo: [:node |		| answer |		(answer := node firstTagNamed: aSymbol with: aBlock) ifNotNil: [^answer]].	^nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:07'!endTag	self stream nextPutAll: '>'.	self indent.	"self canonical		ifFalse: [self stream space]"! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd: aDTD	dtd := aDTD! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25'!parseDocumentFrom: aStream useNamespaces: aBoolean	^(super parseDocumentFrom: aStream useNamespaces: aBoolean) document! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!exampleAddressBook	| tokenizer |	"XMLTokenizer exampleAddressBook"	tokenizer := XMLTokenizer on: self addressBookXML readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/31/2007 18:25'!contentsDo: aBlock	self elementsAndContentsDo: [:each | each isText ifTrue: [aBlock value: each]]! !!XMLWriter methodsFor: 'writing xml' stamp: 'thf 9/2/2005 14:08'!xmlDeclaration: versionString encoding: encodingString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				attribute: 'encoding' value: encodingString;				endPI.			self stream flush]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 17:02'!endTag: tagName	self outdent.	self endTag: tagName xmlns: nil! !!DTDExternalEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDExternalEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:12'!checkAndExpandReference: parsingContext	| referenceString nextChar |	nextChar := self peek.	self validating		ifFalse: [^nil].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [^self pushStream: (ReadStream on: self nextCharReference asString)].			referenceString := self nextLiteral.			self next == $;				ifFalse: [self errorExpected: ';'].			self handleEntity: referenceString in: parsingContext ]		ifFalse: [			((nextChar == $%				and: [self parsingMarkup])				and: [parsingContext == #entityValue])				ifTrue: [					self skipSeparators.					referenceString := self nextLiteral.					self handleEntity: referenceString in: parsingContext]].	self atEnd ifTrue: [self errorExpected: 'Character expected.'].	^nextChar! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:25'!name: aString	name := aString asSymbol! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:14'!parserOnFileNamed: fileName readIntoMemory: readIntoMemory	| stream  |	stream := FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream := stream contentsOfEntireFile readStream].	^self on: stream! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:11'!endElement: elementName	| currentElement |	currentElement := self pop.	currentElement name = elementName		ifFalse: [self driver errorExpected: 'End tag "', elementName , '" doesn''t match "' , currentElement name , '".']! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:49'!handleStartTag: elementName attributes: attributeList namespaces: namespaces	| localName namespace namespaceURI |	(attributeList includesKey: 'xml:lang')		ifTrue: [languageEnvironment := LanguageEnvironment localeID: (LocaleID isoString: (attributeList at: 'xml:lang'))].	self usesNamespaces		ifTrue: [			self scope enterScope.				"declare any namespaces"					namespaces keysAndValuesDo: [:ns :uri |					self scope declareNamespace: ns uri: uri].			self splitName: elementName into: [:ns :ln |				namespace := ns.				localName := ln].			"ensure our namespace is defined"			namespace				ifNil: [namespace := self scope defaultNamespace]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString]].			self validatesAttributes				ifTrue: [self scope validateAttributes: attributeList].			"call the handler"			self saxHandler				checkEOD; 				startElement: localName namespaceURI: namespaceURI namespace: namespace attributeList: attributeList]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				startElement: elementName namespaceURI: nil namespace: nil attributeList: attributeList]! !!DTDEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/15/2002 18:02'!initialize	"DTDEntityDeclaration initialize"	contextBehavior := Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 11/23/2007 19:40'!stream: aStream upToAll: aCollection	"Answer a subcollection from the current access position to the occurrence (not inclusive) of aCollection. If aCollection is not in the stream, answer nil."	| startPos endMatch result |	startPos := aStream position.	(aStream  match: aCollection) 		ifTrue: [endMatch := aStream position.			aStream position: startPos.			result := aStream next: endMatch - startPos - aCollection size.			aStream position: endMatch.			^ result]		ifFalse: [			aStream position: startPos.			^nil]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:14'!nextEntityValue	| delimiterChar entityValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar := self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Entity value delimiter expected.'].	entityValueStream := WriteStream on: (String new).	[	nextPeek := nextChar := self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek := nil.					nextChar := self nextCharReference]				ifFalse: [					referenceString := self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity := self entity: referenceString.					entityValue := entity valueForContext: #entityValue.					self pushStream: (ReadStream on: entityValue asString).					nextPeek := nextChar := self next]]		ifFalse: [			nextChar == $%				ifTrue: [					self skipSeparators.					referenceString := self nextLiteral.					nextChar := self handleEntity: referenceString in: #entityValue.					nextPeek := nextChar := self next]				ifFalse: [self next]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [entityValueStream nextPut: nextChar]].	^entityValueStream contents! !!SAXHandler class methodsFor: 'instance creation' stamp: 'sd 5/23/2003 15:19'!on: aStream	| driver parser |	driver := SAXDriver on: aStream.	driver validating: true.	parser := self new driver: driver.	^parser! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream: newStream	"Continue parsing from the new nested stream."	stream := newStream! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:04'!pop	| oldTop |	oldTop := self stack removeLast.	entity := oldTop.	^oldTop! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'gvc 6/6/2007 13:17'!nextEntity	"return the next XMLnode, or nil if there are no more.	Fixed to retain leading whitespace when PCDATA is detected."	|whitespace|	"branch, depending on what the first character is"	whitespace := self nextWhitespace.	self atEnd ifTrue: [self handleEndDocument. ^ nil].	self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).	^self peek = $<		ifTrue: [self nextNode]		ifFalse: [whitespace isEmpty					ifFalse: [self pushBack: whitespace].				self nextPCData]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 15:06'!entities	entities ifNil: [entities := self initEntities].	^entities! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 1/3/2008 14:18'!elementsAndContentsDo: aBlock	self elementsAndContents do: aBlock! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:49'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><?xml-stylesheet type="text/xsl" href="demo.xsl"?><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!SAXHandler methodsFor: 'initialize' stamp: 'mir 1/8/2002 18:18'!initialize	eod := false! !!XMLElement methodsFor: 'accessing' stamp: 'Alexandre Bergel 11/26/2009 17:41'!contentString	| contentElements |	contentElements := self elementsAndContents.	^(contentElements size > 0		and: [contentElements first isText])		ifTrue: [contentElements first string]		ifFalse: ['']! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentTab	self indentString: (String with: Character tab)! !!XMLDOMParser methodsFor: 'initialize' stamp: 'mir 1/8/2001 12:05'!initialize	super initialize.	stack := OrderedCollection new.	incremental := false! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'nice 12/27/2009 03:26'!nextLiteral	| resultStream nextChar |	resultStream := (String new: 10) writeStream.	((nextChar := self peek) isLetter		or: [nextChar == $_])		ifFalse: [self errorExpected: 'Name literal.'].	[ | resultString |	nextChar := self peek.	(LiteralChars includes: nextChar)		ifTrue: [			nextChar == $&				ifTrue: [					nextChar := self next.					resultStream nextPut: (self peek == $#						ifTrue: [self nextCharReference]						ifFalse: [^resultStream contents])]				ifFalse: [					resultStream nextPut: self next]]		ifFalse: [resultString := resultStream contents.			resultString isEmpty				ifTrue: [self errorExpected: 'Name literal']				ifFalse: [^resultString]]] repeat! !!XMLElement methodsFor: 'accessing' stamp: 'mir 10/31/2007 18:25'!elements	^self elementsAndContents select: [:each | each isText not]! !!XMLDocument methodsFor: 'printing' stamp: 'mir 1/17/2002 16:44'!printCanonicalOn: aStream	| writer |	writer := XMLWriter on: aStream.	writer canonical: true.	self printXMLOn: writer! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/5/2003 19:32'!namespaceAliases: namespace	"Locate all namespaces that are aliases of the given URI."	| aliases uri |	aliases := Set new.	uri := self namespaceURIOf: namespace ifAbsent: [self parseError: 'Attribute refers to undefined namespace ' , namespace asString ].	currentBindings keysAndValuesDo: [:ns :u |		(u = uri			and: [ns ~= namespace])			ifTrue: [aliases add: ns]].	^ aliases! !!XMLElement methodsFor: 'printing' stamp: 'mir 10/31/2007 18:19'!printXMLOn: writer	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty and: [self attributes isEmpty not]])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self elementsAndContentsDo: [:content | content printXMLOn: writer].			writer endTag: self name]! !XMLTokenizer class removeSelector: #new!SAXHandler class removeSelector: #new!XMLTokenizer initialize!DTDParameterEntityDeclaration initialize!DTDExternalEntityDeclaration initialize!DTDEntityDeclaration initialize!