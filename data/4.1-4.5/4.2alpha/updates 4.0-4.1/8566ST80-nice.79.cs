"Change Set:		8566ST80-nice.79ST80-nice.79:Cosmetic: move or remove a few temps inside closuresST80-nice.77:Simplify #lines and handle eventual crlf pairs correctly(Old code did assume there was a single separator using index := index + 1)So many duplicated code... More code = more maintenance + more errors. If I had to pay a programmer, I would index a good proportion of wages on code removal rate, especially in Squeak ;)ST80-nice.78:Cosmetic: puch a few temps inside closures"!!Paragraph methodsFor: 'selecting' stamp: 'nice 12/26/2009 19:08'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action |	action := false.	startBlock := self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[| range boxes box |				range := text rangeOf: att startingAt: startBlock stringIndex.				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box := boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model in: self at: clickPoint editor: aController) ifTrue: [action := true]]]]].	^ action! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/26/2009 19:12'!presentSpecialMenu	"Present a list of expressions, and if the user chooses one, evaluate it in the context of the receiver, a ParagraphEditor.  Primarily for debugging, this provides a convenient way to talk to the various views, controllers, and models associated with any text pane"	self terminateAndInitializeAround:		[| reply items |		reply := (UIManager default chooseFrom: (items := self specialMenuItems) lines: #()).		reply = 0 ifTrue: [^ self].		Compiler new evaluate: (items at: reply) in: [] to: self]	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/26/2009 19:09'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol |	self flag: #yoCharCases.	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol := self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[| anEntry |				anEntry := (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isBehavior or: [ anEntry isTrait ])					ifFalse: [ anEntry := anEntry class ].				ToolSet browse: anEntry selector: nil.		] ifFalse:[ self systemNavigation browseAllImplementorsOf: aSymbol]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/26/2009 19:12'!selectionAsTiles	"Try to make new universal tiles from the selected text"	| selection |	selection := self selection.	self terminateAndInitializeAround:		[| tiles |		self currentHand attachMorph: (tiles := Player tilesFrom: selection).		Preferences tileTranslucentDrag			ifTrue: [tiles lookTranslucent]			ifFalse: [tiles align: tiles topLeft 			 			with: self currentHand position + tiles cursorBaseOffset]].! !!StandardSystemView methodsFor: 'private' stamp: 'nice 12/26/2009 22:04'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen |	theLen := 0.	subViews do:		[:sub |		| box |		box := sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub := sub.				theSide := side.				theLen := len]]].	sideBlock value: theSide.	^ theSub! !!FormMenuView methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!makeConnections: indexInterval	| connector aSwitchView |	connector := Object new.  "a dummy model for connecting dependents."	indexInterval do: [:index | | button buttonCache |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!StandardSystemView methodsFor: 'framing' stamp: 'nice 12/26/2009 22:02'!chooseMoveRectangle	"Ask the user to designate a new window rectangle."	| offset |	offset := Sensor anyButtonPressed "Offset if draggin, eg, label"		ifTrue: [self windowBox topLeft - Sensor cursorPoint]		ifFalse: [0@0].	self isCollapsed		ifTrue: [^ self labelDisplayBox newRectFrom:					[:f | | p |					p := Sensor cursorPoint + offset.					p := (p max: 0@0) truncateTo: 8.					p extent: f extent]]		ifFalse: [^ self windowBox newRectFrom:					[:f | | p |					p := Sensor cursorPoint + offset.					self constrainFrame: (p extent: f extent)]]! !!ParagraphEditor methodsFor: 'undoers' stamp: 'nice 12/27/2009 03:12'!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize := (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText := self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i | | index subject |		index := indices at: i.		(subject := index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/26/2009 19:09'!browseClassFromIt	"Launch a browser for the class indicated by the current selection. 	If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self		lineSelectAndEmptyCheck: [^ self].	aClass := Utilities				classFromPattern: (self selection string copyWithoutAll: CharacterSet separators)				withCaption: 'choose a class to browse...'.	aClass		ifNil: [^ view flash].	self		terminateAndInitializeAround: 			[| aBrow |			aBrow := SystemBrowser default new.			aBrow setClass: aClass selector: nil.			aBrow class				openBrowserView: (aBrow openEditString: nil) label: 'System Browser'].! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 12/27/2009 03:12'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt valueAsString v |	self lineSelectAndEmptyCheck: [^ -1].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [ | cm |		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: (Array with: ctxt)].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !!PluggableTextController methodsFor: 'transcript' stamp: 'nice 12/27/2009 03:59'!visibleAreas	"Transcript dependents last controller visibleAreas"	| myTopController visibleAreas |	myTopController := self view topView controller.	visibleAreas := Array with: view insetDisplayBox.	myTopController view uncacheBits.	ScheduledControllers scheduledWindowControllers do:		[:c | | remnants rect |		c == myTopController ifTrue: [^ visibleAreas].		rect := c view windowBox.		remnants := OrderedCollection new.		visibleAreas do: [:a | remnants addAll: (a areasOutside: rect)].		visibleAreas := remnants].	^ visibleAreas! !!ParagraphEditor methodsFor: 'do-its' stamp: 'nice 12/27/2009 03:12'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "		self terminateAndInitializeAround: [ | result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [view flash]		ifFalse: [self systemNavigation					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]].	]! !!StandardSystemController methodsFor: 'borders' stamp: 'nice 12/26/2009 22:01'!adjustWindowCorners 	| box clicked |	box := view windowBox.	clicked := false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			| cornerBox |			cornerBox := ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (sensor cursorPoint))						and: [(clicked := sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | | p f2 |						p := sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 := p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 := (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 := f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 := (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!FormMenuView methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!makeColorConnections: indexInterval	| connector aSwitchView |	connector := Object new.  "a dummy model for connecting dependents"	indexInterval do: [:index | | button buttonCache |	buttonCache := (FormButtons at: index) shallowCopy.	buttonCache form: (FormButtons at: index) form copy.		buttonCache initialState = #true			ifTrue: [button := OneOnSwitch newOn]			ifFalse: [button := OneOnSwitch newOff].		button onAction: [model changeTool: buttonCache value].		button connection: connector.		aSwitchView := self makeViews: buttonCache for: button.		aSwitchView			borderWidthLeft: 1 right: 0 top: 1 bottom: 1;			action: #turnOn].	aSwitchView borderWidth: 1.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/27/2009 03:12'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName |	stringToSave := paragraph text string.	stringToSave size == 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow := self model dependents						detect: [:dep | dep isKindOf: SystemWindow orOf: StandardSystemView]						ifNone: [nil].	labelToUse := parentWindow		ifNil: 		['Untitled']		ifNotNil: 	[parentWindow label].	suggestedName := nil.	#(('Decompressed contents of: '		'.gz')) do:  "can add more here..."		[:leaderTrailer | | lastIndex |			(labelToUse beginsWith: leaderTrailer first) ifTrue:				[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1 to: labelToUse size.				(labelToUse endsWith: leaderTrailer last)					ifTrue:						[suggestedName := suggestedName copyFrom: 1 to: suggestedName size - leaderTrailer last size]					ifFalse:						[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].						(lastIndex = 0 or: [lastIndex = 1]) ifFalse:							[suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil:		[suggestedName := labelToUse, '.text'].				fileName := UIManager default request: 'File name?' translated			initialAnswer: suggestedName.	fileName isEmptyOrNil ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave; close]! !!StandardSystemView methodsFor: 'updating' stamp: 'nice 12/26/2009 22:04'!setUpdatablePanesFrom: getSelectors	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	| aList |	aList := OrderedCollection new.	getSelectors do:		[:sel | 			| aPane |			aPane := self subViewSatisfying:				[:pane | (pane isKindOf: PluggableListView) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: view ', sel, ' not found.']].	updatablePanes := aList asArray! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'nice 12/26/2009 01:06'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |		sensor keyboard.  "Flush typeahead"	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart := self startIndex.	realStop := self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == Character cr or: [(paragraph string at: realStart - 1) == Character lf]]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^ true].	lines := paragraph lines.	startLine := paragraph lineIndexOfCharacterIndex: realStart.	stopLine := paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start := (lines at: startLine) first.	stop := (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart := realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation := (startLine to: stopLine) inject: 1000 into:		[:m :l |		m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size :=  stop + 1 - start.	numLines := stopLine + 1 - startLine.	inStream := ReadStream on: paragraph string from: start to: stop.	newString := WideString new: size + ((numLines * delta) max: 0).	outStream := ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart := (realStart + delta) max: start].	realStop := realStop + outStream position - size.	"Prepare for another iteration"	indentation := indentation + delta.	size := outStream position.	inStream := outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[view flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString := outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!Arc methodsFor: 'displaying' stamp: 'nice 12/27/2009 04:00'!displayOn: aDisplayMedium at: aPoint clippingBox: clipRect rule: anInteger fillColor: aForm	| nSegments line angle sin cos xn yn |	nSegments := 12.0.	line := Line new.	line form: self form.	angle := 90.0 / nSegments.	sin := (angle * (2 * Float pi / 360.0)) sin.	cos := (angle * (2 * Float pi / 360.0)) cos.	quadrant = 1		ifTrue: 			[xn := radius asFloat.			yn := 0.0].	quadrant = 2		ifTrue: 			[xn := 0.0.			yn := 0.0 - radius asFloat].	quadrant = 3		ifTrue: 			[xn := 0.0 - radius asFloat.			yn := 0.0].	quadrant = 4		ifTrue: 			[xn := 0.0.			yn := radius asFloat].	nSegments asInteger		timesRepeat: 			[ | xn1 yn1 |			xn1 := xn * cos + (yn * sin).			yn1 := yn * cos - (xn * sin).			line beginPoint: center + (xn asInteger @ yn asInteger).			line endPoint: center + (xn1 asInteger @ yn1 asInteger).			line				displayOn: aDisplayMedium				at: aPoint				clippingBox: clipRect				rule: anInteger				fillColor: aForm.			xn := xn1.			yn := yn1]! !!StandardSystemView methodsFor: 'framing' stamp: 'nice 12/26/2009 22:03'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| delta newRect minDim theMin |	newRect := aDisplayBox.	theMin := 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim := ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta := minDim - theMin.		newRect := newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[| newBox |			newBox := sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport := nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 12/27/2009 03:59'!explain	"Try to shed some light on what kind of entity the current selectionis. 	The selection must be a single token or construct. Insert the answerafter 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	Cursor execute showWhile: 			[ | symbol string delimitors reply numbers tiVars selectors sorry cgVars |			sorry := '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry := sorry , (view canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string := self selection asString) isEmpty				ifTrue: [reply := '']				ifFalse: [string := self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are allletters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars := self explainTemp: string.							tiVars == nil ifTrue: [tiVars := self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars := model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars := '']						ifFalse: [tiVars := tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol := s])						ifTrue: [cgVars := self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars := self explainClass: symbol.									cgVars == nil ifTrue: [cgVars := self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors := self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors := self explainPartSel: string.									selectors == nil ifTrue: [										selectors := self explainAnySel: symbol]]]						ifFalse: [selectors := self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars := '']						ifFalse: [cgVars := cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors := '']						ifFalse: [selectors := selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors := self explainChar: string]						ifFalse: ["matched delimitors"							delimitors := self explainDelimitor: string].					numbers := self explainNumber: string.					numbers == nil ifTrue: [numbers := ''].					delimitors == nil ifTrue: [delimitors := ''].					reply := tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply := sorry].			self afterSelectionInsertAndSelect: reply]! !!ParagraphEditor methodsFor: 'private' stamp: 'nice 12/25/2009 16:00'!lines	"Other than my member paragraph i compute lines based on logical	line breaks, not optical (which may change due to line wrapping of the editor)"	| lines string lineIndex |	string := paragraph text string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	lines := OrderedCollection new: (string size // 15).	lineIndex := 0.	string lineIndicesDo: [:start :endWithoutDelimiters :end |		lines addLast: {start. (lineIndex := lineIndex + 1). end}].	"Special workaround for last line empty."	(string last == Character cr or: [string last == Character lf])		ifTrue: [lines addLast: {string size + 1. lineIndex + 1. string size}].	^lines! !!MVCProject methodsFor: 'utilities' stamp: 'nice 12/27/2009 03:10'!findProjectView: projectDescription	"In this world, find the ProjectController for the project described by projectDescription."	| pName |	pName := (projectDescription isString) 		ifTrue: [projectDescription]		ifFalse: [projectDescription name].	world scheduledControllers do: [:cont | | proj dpName |		(cont isKindOf: ProjectController) ifTrue: [			((proj := cont model) class == Project and: 				[proj name = pName]) ifTrue: [^ cont view].			proj class == DiskProxy ifTrue: [ 				dpName := proj constructorArgs first.				dpName := (dpName findTokens: '/') last.				dpName := (Project parseProjectFileName: dpName unescapePercents) first.				dpName = pName ifTrue: [^ cont view]]]].	^ nil! !!PopUpMenu methodsFor: 'accessing' stamp: 'nice 12/26/2009 20:27'!startUpLeftFlush	"Build and invoke this menu with no initial selection.  By Jerry Archibald, 4/01.	If in MVC, align menus items with the left margin.	Answer the selection associated with the menu item chosen by the user or nil if none is chosen.  	The mechanism for getting left-flush appearance in mvc leaves a tiny possibility for misadventure: if the user, in mvc, puts up the jump-to-project menu, then hits cmd period while it is up, then puts up a second jump-to-project menu before dismissing or proceeding through the debugger, it's possible for mvc popup-menus thereafter to appear left-aligned rather than centered; this very unlikely condition can be cleared by evaluating 'PopUpMenu alignment: 2'"	| saveAlignment |	Smalltalk isMorphic ifFalse:		[saveAlignment := PopUpMenu alignment.		PopUpMenu leftFlush].	^[self startUp] ensure:		[Smalltalk isMorphic ifFalse:			[PopUpMenu alignment: saveAlignment]].! !