"Change Set:		8008System-nice.157System-nice.157:Track keys and selectors usage, use #includesSelector: #selectorsDo: and #asSet where due+ make #classVarNames a sorted ArraySystem-nice.156:use #fasterKeys"!!ImageSegment methodsFor: 'testing' stamp: 'nice 10/20/2009 20:11'!findRogueRootsRefStrm: rootArray 	"This is a tool to track down unwanted pointers into the segment.  If we don't deal with these pointers, the segment turns out much smaller than it should.  These pointers keep a subtree of objects out of the segment.1) assemble all objects that should be in the segment by using SmartReference Stream and a dummyReference Stream.  Put in a Set.2) Remove the roots from this list.  Ask for senders of each.  Of the senders, forget the ones that are in the segment already.  Keep others.  The list is now all the 'incorrect' pointers into the segment."	| dummy goodInSeg inSeg ok pointIn |	dummy := ReferenceStream on: (DummyStream on: nil).	"Write to a fake Stream, not a file"	rootArray do: 			[:root | 			dummy rootObject: root.	"inform him about the root"			dummy nextPut: root].	inSeg := dummy references keys asSet.	dummy := nil.	Smalltalk garbageCollect.	"dump refs dictionary"	rootArray do: [:each | inSeg remove: each ifAbsent: []].	"want them to be pointed at from outside"	pointIn := IdentitySet new: 500.	goodInSeg := IdentitySet new: 2000.	inSeg do: 			[:obj | 			ok := obj class isPointers.			obj class == Color ifTrue: [ok := false].			obj class == TranslucentColor ifTrue: [ok := false].			obj class == Array ifTrue: [obj size = 0 ifTrue: [ok := false]].			"shared #() in submorphs of all Morphs"			ok ifTrue: [goodInSeg add: obj]].	goodInSeg 		do: [:ob | pointIn addAll: (Utilities pointersTo: ob except: #())].	inSeg do: [:each | pointIn remove: each ifAbsent: []].	rootArray do: [:each | pointIn remove: each ifAbsent: []].	pointIn remove: inSeg array ifAbsent: [].	pointIn remove: goodInSeg array ifAbsent: [].	pointIn remove: pointIn array ifAbsent: [].	self halt: 'Examine local variables pointIn and inSeg'.	^pointIn! !!PseudoClass methodsFor: 'testing' stamp: 'nice 10/20/2009 21:02'!needsInitialize	^self hasMetaclass and:[		self metaClass includesSelector: #initialize]! !!ResourceManager class methodsFor: 'resource caching' stamp: 'nice 10/19/2009 22:25'!lookupOriginalResourceCacheEntry: resourceFileName for: resourceUrl	"See if we have cached the resource described by the given url in an earlier version of the same project on the same server. In that case we don't need to upload it again but rather link to it."	| resourceBase resourceMatch matchingUrls |		CachedResources ifNil:[^nil].	"Strip the version number from the resource url"	resourceBase := resourceUrl copyFrom: 1 to: (resourceUrl lastIndexOf: $.) .	"Now collect all urls that have the same resource base"	resourceMatch := resourceBase , '*/' , resourceFileName.	matchingUrls := self resourceCache fasterKeys		select: [:entry | (resourceMatch match: entry) and: [(entry beginsWith: resourceUrl) not]].	matchingUrls isEmpty		ifTrue: [^nil].	matchingUrls sort do: [:entry | | candidates |			candidates := (self resourceCache at: entry).			candidates isEmptyOrNil				ifFalse: [candidates do: [:candidate |					candidate = resourceFileName						ifTrue: [^entry]]]].	^nil! !!ChangeSet methodsFor: 'testing' stamp: 'nice 10/20/2009 20:55'!methodsWithoutClassifications	"Return a collection representing methods in the receiver which have not been categorized"	| slips notClassified aSelector |	notClassified := {'as yet unclassified' asSymbol. #all}.	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (aClass includesSelector:  (aSelector := mAssoc key)) ifTrue:						[(notClassified includes: (aClass organization categoryOfElement: aSelector))								ifTrue: [slips add: aClass name , ' ' , aSelector]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutClassifications) name: 'unclassified methods'"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'nice 10/19/2009 22:11'!comeFullyUpOnReload: smartRefStream	"fix up the objects in the segment that changed size.  Anobject in the segment is the wrong size for the modern version of theclass.  Construct a fake class that is the old size.  Replace themodern class with the old one in outPointers.  Load the segment.Traverse the instances, making new instances by copying fields, andrunning conversion messages.  Keep the new instances.  Bulk forwardbecome the old to the new.  Let go of the fake objects and classes.	After the install (below), arrayOfRoots is filled in.Globalize new classes.  Caller may want to do some special install oncertain objects in arrayOfRoots.	May want to write the segment out to disk in its new form."	| mapFakeClassesToReal ccFixups receiverClassesrootsToUnhiberhate myProject existing |	RecentlyRenamedClasses := nil.		"in case old datahanging around"	mapFakeClassesToReal := smartRefStream reshapedClassesIn: outPointers.		"Dictionary of just the ones that change shape.Substitute them in outPointers."	ccFixups := self remapCompactClasses: mapFakeClassesToReal				refStrm: smartRefStream.	ccFixups ifFalse: [^ self error: 'A class in the file is notcompatible'].	endMarker := segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker := 'End' clone].	self fixCapitalizationOfSymbols.	arrayOfRoots := self loadSegmentFrom: segment outPointers: outPointers.		"Can't use install.  Not ready for rehashSets"	mapFakeClassesToReal isEmpty ifFalse: [		self reshapeClasses: mapFakeClassesToReal refStream:smartRefStream	].	"When a Project is stored, arrayOfRoots has all objects inthe project, except those in outPointers"	arrayOfRoots do: [:importedObject |		((importedObject isMemberOf: WideString) or: [importedObject isMemberOf: WideSymbol]) ifTrue: [			importedObject mutateJISX0208StringToUnicode.			importedObject class = WideSymbol ifTrue: [				"self halt."				Symbol hasInterned: importedObject asString ifTrue: [:multiSymbol |					multiSymbol == importedObjectifFalse: [						importedObjectbecomeForward: multiSymbol.					].				].			].		].		(importedObject isKindOf: TTCFontSet) ifTrue: [			existing := TTCFontSet familyName:importedObject familyName						pointSize:importedObject pointSize.	"supplies default"			existing == importedObject ifFalse:[importedObject becomeForward: existing].		].	].	"Smalltalk garbageCollect.   MultiSymbol rehash.  These taketime and are not urgent, so don't to them.  In the normal case, nobad MultiSymbols will be found."	receiverClasses := self restoreEndianness.		"rehash sets"	smartRefStream checkFatalReshape: receiverClasses.	"Classes in this segment."	arrayOfRoots do: [:importedObject |		importedObject class class == Metaclass ifTrue: [selfdeclare: importedObject]].	arrayOfRoots do: [:importedObject |		(importedObject isKindOf: CompiledMethod) ifTrue: [			importedObject sourcePointer > 0 ifTrue:[importedObject zapSourcePointer]].		(importedObject isKindOf: Project) ifTrue: [			myProject := importedObject.			importedObject ensureChangeSetNameUnique.			Project addingProject: importedObject.			importedObject restoreReferences.			self dependentsRestore: importedObject.			ScriptEditorMorph writingUniversalTiles:				((importedObject projectPreferenceAt:#universalTiles) ifNil: [false])]].	rootsToUnhiberhate := arrayOfRoots select: [:importedObject |		importedObject respondsTo: #unhibernate	"ScriptEditors and ViewerFlapTabs"	].	myProject ifNotNil: [		myProject world setProperty: #thingsToUnhibernatetoValue: rootsToUnhiberhate	].	mapFakeClassesToReal isEmpty ifFalse: [		mapFakeClassesToReal fasterKeys do: [:aFake |			aFake indexIfCompact > 0 ifTrue: [aFakebecomeUncompact].			aFake removeFromSystemUnlogged].		SystemOrganization removeEmptyCategories].	"^ self"! !!SystemDictionary methodsFor: 'shrinking' stamp: 'nice 10/20/2009 21:04'!abandonTempNames	"Replaces every method by a copy with no source pointer or	encoded temp names."	"Smalltalk abandonTempNames"	| continue oldMethods newMethods n m |	continue := self confirm: '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning all source code, hit Yes.If you have any doubts, hit No,to back out with no harm done.'.	continue		ifFalse: [^ self inform: 'Okay - no harm done'].	self forgetDoIts; garbageCollect.	oldMethods := OrderedCollection new.	newMethods := OrderedCollection new.	n := 0.	'Removing temp names to save space...'		displayProgressAt: Sensor cursorPoint		from: 0		to: CompiledMethod instanceCount		during: [:bar | self systemNavigation				allBehaviorsDo: [:cl | cl selectorsDo: [:sel | 							bar value: (n := n + 1).							m := cl compiledMethodAt: sel.							oldMethods addLast: m.							newMethods								addLast: (m copyWithTrailerBytes: #(0 ))]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	SmalltalkImage current closeSourceFiles.	self flag: #shouldUseAEnsureBlockToBeSureThatTheFileIsClosed.	"sd: 17 April 2003"	Preferences disable: #warnIfNoChangesFile.	Preferences disable: #warnIfNoSourcesFile! !!ResourceManager methodsFor: 'private' stamp: 'nice 10/19/2009 22:23'!abandonResourcesThat: matchBlock	"Private. Forget resources that match the given argument block"	resourceMap fasterKeys "need copy" do:[:loc|		(matchBlock value: loc) ifTrue:[			resourceMap removeKey: loc ifAbsent:[].			loaded remove: loc ifAbsent:[].			unloaded remove: loc ifAbsent:[].		].	].! !!NaturalLanguageTranslator class methodsFor: 'private' stamp: 'nice 10/19/2009 22:19'!cleanUpCache	"NaturalLanguageTranslator cleanUpCache"	self cachedTranslations fasterKeys do: [:key |		key isoLanguage size > 2 ifTrue: [self cachedTranslations removeKey: key]]! !!FilePackage methodsFor: 'conflict checker' stamp: 'nice 10/20/2009 21:17'!conflictsWithUpdatedMethods	"Check this package for conflicts with methods in the image which are in newer updates."	| localFileName stream updateNumberString updateNumber imageUpdateNumber updateNumberChangeSet conflicts fileStream |	localFileName := FileDirectory localNameFor: fullName.	stream := ReadStream on: sourceSystem.	stream upToAll: 'latest update: #'.	updateNumberString := stream upTo: $].	stream close.		fileStream := FileStream readOnlyFileNamed: fullName.	(fileStream contentsOfEntireFile includes: Character linefeed)		ifTrue: [self notifyWithLabel:  'The changeset file ', localFileName, ' contains linefeeds.  Proceed if...you know that this is okay (e.g. the file contains raw binary data).'].	fileStream close.	updateNumberString isEmpty ifFalse:		"remove prepended junk, if any"		[updateNumberString := (updateNumberString findTokens: Character space) last].	updateNumberString asInteger ifNil:		[(self confirm: 'Error: ', localFileName, ' has no valid Latest Update number in its header.Do you want to enter an update number for this file?')			ifFalse: [^ self]			ifTrue: [updateNumberString := UIManager default						request: 'Please enter the estimated update number (e.g. 4332).']].	updateNumberString asInteger ifNil: [self inform: 'Conflict check cancelled.'. ^ self].	updateNumber := updateNumberString asInteger.	imageUpdateNumber := SystemVersion current highestUpdate.	updateNumber > imageUpdateNumber ifTrue:		[(self confirm: 'Warning: The update number for this file (#', updateNumberString, ')is greater than the highest update number for this image (#', imageUpdateNumber asString, ').This probably means you need to update your image.Should we proceed anyway as if the file update number is #', imageUpdateNumber asString, '?')			ifTrue:				[updateNumber := imageUpdateNumber.				updateNumberString := imageUpdateNumber asString]			ifFalse: [^ self]].	updateNumberChangeSet := self findUpdateChangeSetMatching: updateNumber.	updateNumberChangeSet ifNil: [^ self].	Smalltalk isMorphic ifTrue: [self currentWorld findATranscript: self currentEvent].	self class logCr; logCr; log: 'Checking ', localFileName, ' (#', updateNumberString, ') for method conflicts with changesets after ', updateNumberChangeSet name, ' ...'.	conflicts := OrderedCollection new.	self classes do: [:pseudoClass |		(Array with: pseudoClass with: pseudoClass metaClass) do: [:classOrMeta |			classOrMeta selectorsDo: [:selector | | conflict |				conflict := self							checkForMoreRecentUpdateThanChangeSet: updateNumberChangeSet							pseudoClass: classOrMeta							selector: selector.				conflict ifNotNil: [conflicts add: conflict].			].		].	].	self class logCr; log: conflicts size asString, (' conflict' asPluralBasedOn: conflicts), ' found.'; logCr.	self class closeLog.	^ conflicts! !!ImageSegment class methodsFor: 'testing' stamp: 'nice 10/19/2009 22:12'!swapOutInactiveClasses  "ImageSegment swapOutInactiveClasses"  	"Make up segments by grouping unused classes by system category.	Read about, and execute discoverActiveClasses, and THEN execute this one."	| unused groups i roots |	ImageSegment recoverFromMDFault.	ImageSegmentRootStub recoverFromMDFault.	unused := Smalltalk allClasses select: [:c | (c instVarNamed: 'methodDict') == nil].	unused do: [:c | c recoverFromMDFault].	groups := Dictionary new.	SystemOrganization categories do:		[:cat |		i := (cat findLast: [:c | c = $-]) - 1.		i <= 0 ifTrue: [i := cat size].		groups at: (cat copyFrom: 1 to: i)			put: (groups at: (cat copyFrom: 1 to: i) ifAbsent: [Array new]) ,			((SystemOrganization superclassOrder: cat) select: [:c | 				unused includes: c]) asArray].	groups fasterKeys do:		[:cat | roots := groups at: cat.		Transcript cr; cr; show: cat; cr; print: roots; endEntry.		roots := roots , (roots collect: [:c | c class]).		(cat beginsWith: 'Sys' "something here breaks") ifFalse:			[(ImageSegment new copyFromRoots: roots sizeHint: 0) extract; 				writeToFile: cat].		Transcript cr; print: Smalltalk garbageCollect; endEntry]! !!SystemDictionary methodsFor: 'retrieving' stamp: 'nice 10/19/2009 22:30'!poolUsers	"Answer a dictionary of pool name -> classes that refer to it.	Also includes any globally know dictionaries (such as	Smalltalk, Undeclared etc) which although not strictly	accurate is potentially useful information"	"Smalltalk poolUsers"	| poolUsers |	poolUsers := Dictionary new.	self fasterKeys		do: [:k | "yes, using isKindOf: is tacky but for reflective code like			this it is very useful. If you really object you can:-			a) go boil your head.			b) provide a better answer.			your choice."			| pool refs |			(((pool := self at: k) isKindOf: Dictionary)					or: [pool isKindOf: SharedPool class])				ifTrue: [refs := self systemNavigation allClasses								select: [:c | c sharedPools identityIncludes: pool]								thenCollect: [:c | c name].					refs						add: (self systemNavigation								allCallsOn: (self associationAt: k)).					poolUsers at: k put: refs]].	^ poolUsers! !!CodeLoader class methodsFor: 'utilities' stamp: 'nice 10/20/2009 21:18'!exportCodeSegment: exportName classes: aClassList keepSource: keepSources	"Code for writing out a specific category of classes as an external image segment.  Perhaps this should be a method."	| is oldMethods newMethods classList symbolHolder fileName |	keepSources		ifTrue: [			self confirm: 'We are going to abandon sources.Quit without saving after this has run.' orCancel: [^self]].	classList := aClassList asArray.	"Strong pointers to symbols"	symbolHolder := Symbol allSymbols.	oldMethods := OrderedCollection new: classList size * 150.	newMethods := OrderedCollection new: classList size * 150.	keepSources		ifTrue: [			classList do: [:cl |				cl selectorsDo:					[:selector | | m oldCodeString methodNode |					m := cl compiledMethodAt: selector.					m fileIndex > 0 ifTrue:						[oldCodeString := cl sourceCodeAt: selector.						methodNode := cl compilerClass new											parse: oldCodeString in: cl notifying: nil.						oldMethods addLast: m.						newMethods addLast: (m copyWithTempsFromMethodNode: methodNode)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	oldMethods := newMethods := nil.	Smalltalk garbageCollect.	is := ImageSegment new copyFromRootsForExport: classList.	"Classes and MetaClasses"	fileName := FileDirectory fileName: exportName extension: ImageSegment fileExtension.	is writeForExport: fileName.	self compressFileNamed: fileName! !!ResourceManager methodsFor: 'private' stamp: 'nice 10/19/2009 22:23'!fixJISX0208Resource	resourceMap fasterKeys do: [:key |		| value url |		value := resourceMap at: key.		url := key urlString copy.		url isOctetString not ifTrue: [url mutateJISX0208StringToUnicode].		resourceMap removeKey: key.		key urlString: url.		resourceMap at: key put: value.	].! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'nice 10/20/2009 20:49'!oldClassVarNames	^ oldItem classVarNames! !!ResourceManager methodsFor: 'loading' stamp: 'nice 10/19/2009 22:24'!loaderProcess	| loader requests req locator resource stream |	loader := HTTPLoader default.	requests := Dictionary new.	self prioritizedUnloadedResources do:[:loc|		req := HTTPLoader httpRequestClass for: (self hackURL: loc urlString) in: loader.		loader addRequest: req.		requests at: req put: loc].	[stopFlag or:[requests isEmpty]] whileFalse:[		stopSemaphore waitTimeoutMSecs: 500.		requests fasterKeys "need a copy" do:[:r|			r isSemaphoreSignaled ifTrue:[				locator := requests at: r.				requests removeKey: r.				stream := r contentStream.				resource := resourceMap at: locator ifAbsent:[nil].				self class cacheResource: locator urlString stream: stream.				self installResource: resource					from: stream					locator: locator.				(resource isForm) ifTrue:[					WorldState addDeferredUIMessage: self formChangedReminder]ifFalse: [self halt].			].		].	].	"Either done downloading or terminating process"	stopFlag ifTrue:[loader abort].	loaderProcess := nil.	stopSemaphore := nil.! !!Utilities class methodsFor: 'closure support' stamp: 'nice 10/20/2009 20:17'!initializeClosures	"Utilities initializeClosures"	"Eliminate the prototype BlockContext from the specialObjectsArray.  The VM doesn't use it. This paves the way for removing BlockCOntext altogether and merging ContextPart and MethodContext into e.g. Context."	(Smalltalk specialObjectsArray at: 38) class == BlockContext 		ifTrue:[Smalltalk specialObjectsArray at: 38 put: nil].	"Remove unused class vars from CompiledMethod since we can't redefine its class definition directly. Add the new BlockClosure to the specialObjectsArray"	(#(	BlockNodeCache MethodProperties SpecialConstants) 			intersection: CompiledMethod classPool keys asSet) 				do:[:classVarName| CompiledMethod removeClassVarName: classVarName].	Smalltalk recreateSpecialObjectsArray.	"Recompile methods in ContextPart, superclasses and subclasses that access inst vars"	ContextPart withAllSuperclasses, ContextPart allSubclasses asArray do:[:class|		class instSize > 0 ifTrue:[			class allInstVarNames do:[:ivn|				(class whichSelectorsAccess: ivn) do:[:sel| class recompile: sel]]]]! !!ChangeSet methodsFor: 'moving changes' stamp: 'nice 10/20/2009 20:55'!methodsWithoutComments	"Return a collection representing methods in the receiver which have no precode comments"	| slips |	slips := OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[(aClass includesSelector:  mAssoc key) ifTrue:						[(aClass firstPrecodeCommentFor: mAssoc key) isEmptyOrNil								ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips	"Smalltalk browseMessageList: (ChangeSet current methodsWithoutComments) name: 'methods lacking comments'"! !!SystemDictionary methodsFor: 'shrinking' stamp: 'nice 10/20/2009 21:03'!abandonSources	"Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	 replaced by a string of all arg and temp names, followed by its	 length. These names can then be used to inform the decompiler."	"wod 11/3/1998: zap the organization before rather than after	 condensing changes."	"eem 7/1/2009 13:59 update for the closure schematic temp names regime"	| oldMethods newMethods bTotal bCount |	(self confirm: 'This method will preserve most temp names(up to about 15k characters of temporaries)while allowing the sources file to be discarded.-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, choose Yes.If you have any doubts, you may choose Noto back out with no harm done.')			== true		ifFalse: [^ self inform: 'Okay - no harm done'].	self forgetDoIts.	oldMethods := OrderedCollection new: CompiledMethod instanceCount.	newMethods := OrderedCollection new: CompiledMethod instanceCount.	bTotal := 0.	bCount := 0.	self systemNavigation allBehaviorsDo: [:b | bTotal := bTotal + 1].	'Saving temp names for better decompilation...'		displayProgressAt: Sensor cursorPoint		from: 0		to: bTotal		during:			[:bar |			self systemNavigation allBehaviorsDo:				[:cl |  "for test: (Array with: Arc with: Arc class) do:"				bar value: (bCount := bCount + 1).				cl selectorsDo:					[:selector | | m oldCodeString methodNode |					m := cl compiledMethodAt: selector.					m fileIndex > 0 ifTrue:						[oldCodeString := cl sourceCodeAt: selector.						methodNode := cl compilerClass new											parse: oldCodeString											in: cl											notifying: nil.						oldMethods addLast: m.						newMethods addLast: (m copyWithTempsFromMethodNode: methodNode)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	self systemNavigation allBehaviorsDo: [:b | b zapOrganization].	self condenseChanges.	Preferences disable: #warnIfNoSourcesFile! !!SystemDictionary methodsFor: 'ui' stamp: 'nice 10/19/2009 22:30'!inspectGlobals	"Smalltalk  inspectGlobals"		| associations aDict |	associations := ((self  fasterKeys select: [:aKey | ((self  at: aKey) isKindOf: Class) not]) sort collect:[:aKey | self associationAt: aKey]).	aDict := IdentityDictionary new.	associations do: [:as | aDict add: as].	aDict inspectWithLabel: 'The Globals'! !!EventManager class methodsFor: 'initialize-release' stamp: 'nice 10/19/2009 22:06'!flushEvents	"Object flushEvents"	| msgSet |	self actionMaps keysAndValuesDo:[:rcvr :evtDict| rcvr ifNotNil:[		"make sure we don't modify evtDict while enumerating"		evtDict fasterKeys do:[:evtName|			msgSet := evtDict at: evtName ifAbsent:[nil].			(msgSet == nil) ifTrue:[rcvr removeActionsForEvent: evtName]]]].	EventManager actionMaps finalizeValues. ! !!ModifiedClassDefinitionEvent methodsFor: 'accessing' stamp: 'nice 10/20/2009 20:49'!classVarNames	^ item classVarNames! !!ResourceCollector methodsFor: 'accessing' stamp: 'nice 10/19/2009 22:22'!removeLocator: loc	locatorMap fasterKeys do:[:k|		(locatorMap at: k) = loc ifTrue:[locatorMap removeKey: k]].! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'nice 10/20/2009 21:05'!testFormatter	"Smalltalk testFormatter"	"Reformats the source for every method in the system, and	then compiles that source and verifies that it generates	identical code. The formatting used will be either classic	monochrome or fancy polychrome, depending on the setting	of the preference #colorWhenPrettyPrinting." 		"Note: removed references to Preferences colorWhenPrettyPrinting and replaced them simply with false, as I've been removing this preference lately. --Ron Spengler 8/23/09"	| newCodeString methodNode oldMethod newMethod badOnes n |	badOnes := OrderedCollection new.	self forgetDoIts.	'Formatting all classes...' 		displayProgressAt: Sensor cursorPoint		from: 0		to: CompiledMethod instanceCount		during: 			[:bar | 			n := 0.			self systemNavigation allBehaviorsDo: 					[:cls | 					"Transcript cr; show: cls name."					cls selectorsDo: 							[:selector | 							(n := n + 1) \\ 100 = 0 ifTrue: [bar value: n].							newCodeString := cls prettyPrinterClass 										format: (cls sourceCodeAt: selector)										in: cls										notifying: nil										decorated: false.							methodNode := cls compilerClass new 										compile: newCodeString										in: cls										notifying: nil										ifFail: [].							newMethod := methodNode generate: #(0 0 0 0).							oldMethod := cls compiledMethodAt: selector.							oldMethod = newMethod 								ifFalse: 									[Transcript										cr;										show: '***' , cls name , ' ' , selector.									badOnes add: cls name , ' ' , selector]]]].	self systemNavigation browseMessageList: badOnes asSortedCollection		name: 'Formatter Discrepancies'! !!SpaceTally methodsFor: 'fileOut' stamp: 'nice 10/19/2009 22:57'!compareTallyIn: beforeFileName to: afterFileName	"SpaceTally new compareTallyIn: 'tally' to: 'tally2'"	| answer s beforeDict a afterDict allKeys |	beforeDict := Dictionary new.	s := FileDirectory default fileNamed: beforeFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		beforeDict at: a first put: a allButFirst.	].	s close.	afterDict := Dictionary new.	s := FileDirectory default fileNamed: afterFileName.	[s atEnd] whileFalse: [		a := Array readFrom: s nextLine.		afterDict at: a first put: a allButFirst.	].	s close.	answer := WriteStream on: String new.	allKeys := (Set new addAll: beforeDict fasterKeys; addAll: afterDict fasterKeys; yourself) asSortedCollection.	allKeys do: [ :each |		| before after diff |		before := beforeDict at: each ifAbsent: [#(0 0 0)].		after := afterDict at: each ifAbsent: [#(0 0 0)].		diff := before with: after collect: [ :vBefore :vAfter | vAfter - vBefore].		diff = #(0 0 0) ifFalse: [			answer nextPutAll: each,'  ',diff printString; cr.		].	].	StringHolder new contents: answer contents; openLabel: 'space diffs'.	! !!SystemDictionary methodsFor: 'shrinking' stamp: 'nice 10/19/2009 22:29'!cleanUpUndoCommands	"Smalltalk cleanUpUndoCommands"  "<== print this to get classes involved"	| classes i p |	classes := Bag new.	'Ferreting out obsolete undo commands'		displayProgressAt: Sensor cursorPoint		from: 0 to: Morph withAllSubclasses size		during:	[:bar | i := 0.	Morph withAllSubclassesDo:		[:c | bar value: (i := i+1).		c allInstancesDo:			[:m | (p := m otherProperties) ifNotNil:				[p fasterKeys do:					[:k | (p at: k) class == Command ifTrue:						[classes add: c name.						m removeProperty: k]]]]]].	^ classes! !!ResourceManager methodsFor: 'loading' stamp: 'nice 10/19/2009 22:24'!registerUnloadedResources	resourceMap fasterKeys do: [:newLoc |		unloaded add: newLoc]! !!SystemDictionary methodsFor: 'shrinking' stamp: 'nice 10/19/2009 22:30'!removeNormalCruft	"Remove various graphics, uniclasses, references. Caution: see	comment at bottom of method"	"Smalltalk removeNormalCruft"	ScriptingSystem stripGraphicsForExternalRelease.	ScriptingSystem spaceReclaimed.	References fasterKeys		do: [:k | References removeKey: k].	self classNames		do: [:cName | #('Player' 'CardPlayer' 'Component' 'WonderlandActor' 'MorphicModel' 'PlayWithMe' )				do: [:superName | ((cName ~= superName								and: [cName beginsWith: superName])							and: [(cName allButFirst: superName size)									allSatisfy: [:ch | ch isDigit]])						ifTrue: [self removeClassNamed: cName]]].	self		at: #Wonderland		ifPresent: [:cls | cls removeActorPrototypesFromSystem].	ChangeSet current clear	"Caution: if any worlds in the image happen to have uniclass	players associated with them, running this method would	likely compromise their functioning and could cause errors,	especially if the uniclass player of the current world had any	scripts set to ticking. If that happens to you somehow, you will	probably want to find a way to reset the offending world's	player to be an UnscriptedCardPlayer, or perhaps nil"! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'nice 10/20/2009 21:12'!testFormatter2	"Smalltalk testFormatter2"	"Reformats the source for every method in the system, and	then verifies that the order of source tokens is unchanged.	The formatting used will be either classic monochrome or	fancy polychrome, depending on the setting of the preference	#colorWhenPrettyPrinting. "		"Note: removed references to Preferences colorWhenPrettyPrinting and replaced them simply with false, as I've been removing this preference lately. --Ron Spengler 8/23/09"	| newCodeString badOnes n oldCodeString oldTokens newTokens |	badOnes := OrderedCollection new.	self forgetDoIts.	'Formatting all classes...' 		displayProgressAt: Sensor cursorPoint		from: 0		to: CompiledMethod instanceCount		during: 			[:bar | 			n := 0.			self systemNavigation allBehaviorsDo: 					[:cls | 					"Transcript cr; show: cls name."					cls selectorsDo: 							[:selector | 							(n := n + 1) \\ 100 = 0 ifTrue: [bar value: n].							oldCodeString := (cls sourceCodeAt: selector) asString.							newCodeString := cls prettyPrinterClass 										format: oldCodeString										in: cls										notifying: nil										decorated: false.							oldTokens := oldCodeString findTokens: Character separators.							newTokens := newCodeString findTokens: Character separators.							oldTokens = newTokens 								ifFalse: 									[Transcript										cr;										show: '***' , cls name , ' ' , selector.									badOnes add: cls name , ' ' , selector]]]].	self systemNavigation browseMessageList: badOnes asSortedCollection		name: 'Formatter Discrepancies'! !!DeepCopier methodsFor: 'like fullCopy' stamp: 'nice 10/19/2009 22:02'!mapUniClasses	"For new Uniclasses, map their class vars to the new objects.  And their additional class instance vars.  (scripts slotInfo) and cross references like (player321)."	"Players also refer to each other using associations in the References dictionary.  Search the methods of our Players for those.  Make new entries in References and point to them."| pp oldPlayer newKey newAssoc oldSelList newSelList |	newUniClasses ifFalse: [^ self].	"All will be siblings.  uniClasses is empty""Uniclasses use class vars to hold onto siblings who are referred to in code"pp := Player class superclass instSize.uniClasses do: [:playersClass | "values = new ones"	playersClass classPool associationsDo: [:assoc |		assoc value: (assoc value veryDeepCopyWith: self)].	playersClass scripts: (playersClass privateScripts veryDeepCopyWith: self).	"pp+1"	"(pp+2) slotInfo was deepCopied in copyUniClass and that's all it needs"	pp+3 to: playersClass class instSize do: [:ii | 		playersClass instVarAt: ii put: 			((playersClass instVarAt: ii) veryDeepCopyWith: self)].	]."Make new entries in References and point to them."References fasterKeys do: [:playerName |	oldPlayer := References at: playerName.	(references includesKey: oldPlayer) ifTrue: [		newKey := (references at: oldPlayer) "new player" uniqueNameForReference.		"now installed in References"		(references at: oldPlayer) renameTo: newKey]].uniClasses "values" do: [:newClass |	oldSelList := OrderedCollection new.   newSelList := OrderedCollection new.	newClass selectorsDo: [:sel | 		(newClass compiledMethodAt: sel)	 literals do: [:assoc |			assoc isVariableBinding ifTrue: [				(References associationAt: assoc key ifAbsent: [nil]) == assoc ifTrue: [					newKey := (references at: assoc value ifAbsent: [assoc value]) 									externalName asSymbol.					(assoc key ~= newKey) & (References includesKey: newKey) ifTrue: [						newAssoc := References associationAt: newKey.						newClass methodDictionary at: sel put: 							(newClass compiledMethodAt: sel) clone.	"were sharing it"						(newClass compiledMethodAt: sel)							literalAt: ((newClass compiledMethodAt: sel) literals indexOf: assoc)							put: newAssoc.						(oldSelList includes: assoc key) ifFalse: [							oldSelList add: assoc key.  newSelList add: newKey]]]]]].	oldSelList with: newSelList do: [:old :new |			newClass replaceSilently: old to: new]].	"This is text replacement and can be wrong"! !!SystemNavigation methodsFor: 'browse' stamp: 'nice 10/20/2009 21:10'!browseUncommentedMethodsWithInitials: targetInitials	"Browse uncommented methods whose initials (in the time-stamp, as logged to disk) match the given initials.  Present them in chronological order.  CAUTION: It will take several minutes for this to complete."	"Time millisecondsToRun: [SystemNavigation default browseUncommentedMethodsWithInitials: 'jm']"	| initials timeStamp methodReferences cm |	methodReferences := OrderedCollection new.	self  allBehaviorsDo:		[:aClass | aClass selectorsDo: [:sel |			cm := aClass compiledMethodAt: sel.			timeStamp := Utilities timeStampForMethod: cm.			timeStamp isEmpty ifFalse:				[initials := timeStamp substrings first.				initials first isDigit ifFalse:					[((initials = targetInitials) and: [(aClass firstPrecodeCommentFor: sel) isNil])						ifTrue:							[methodReferences add: (MethodReference new								setStandardClass: aClass 								methodSymbol: sel)]]]]].	ToolSet		browseMessageSet: methodReferences 		name: 'Uncommented methods with initials ', targetInitials		autoSelect: nil! !!ObjectScanner methodsFor: 'initialize-release' stamp: 'nice 10/19/2009 22:19'!clear	"remove all old class vars.  They were UniClasses being remapped to aviod a name conflict."	self class classPool fasterKeys do: [:key |		self class classPool removeKey: key].	"brute force"! !!SystemNavigation methodsFor: 'browse' stamp: 'nice 10/20/2009 20:50'!browseClassVarRefs: aClass	"Put up a menu offering all class variable names; if the user chooses one, open up a message-list browser on all methods 	that refer to the selected class variable"	| lines labelStream vars allVars index owningClasses |	lines := OrderedCollection new.	allVars := OrderedCollection new.	owningClasses := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	aClass withAllSuperclasses reverseDo:		[:class |		vars := class classVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var.			owningClasses add: class].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^Beeper beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index := (UIManager default chooseFrom: (labelStream contents substrings) lines: lines).	index = 0 ifTrue: [^ self].	self browseAllCallsOn:		((owningClasses at: index) classPool associationAt: (allVars at: index))! !!ResourceCollector methodsFor: 'initialize' stamp: 'nice 10/19/2009 22:22'!forgetObsolete	"Forget obsolete locators, e.g., those that haven't been referenced and not been stored on a file."	locatorMap fasterKeys do:[:k|		(locatorMap at: k) localFileName ifNil:[locatorMap removeKey: k]].! !!NaturalLanguageTranslator methodsFor: 'fileIn/fileOut' stamp: 'nice 10/19/2009 22:19'!fileOutOn: aStream keys: keys 	"self current fileOutOn: Transcript. Transcript endEntry"	(keys		ifNil: [generics fasterKeys sort])		do: [:key | self				nextChunkPut: (generics associationAt: key)				on: aStream].	keys		ifNil: [self untranslated				do: [:each | self nextChunkPut: each -> '' on: aStream]].	aStream nextPut: $!!;		 cr! !