"Change Set:		9706Morphic-nice.383Morphic-nice.383:Minor clean-up:1) merge some super initialize from Pharo2) avoid cascading super (from Pharo)3) avoid a few outer temp assignment in blocks4) avoid (isKindOf: BlockContext) in menu enablement blockMorphic-ul.381:- added a missing subclassResponsibility: MorphicProject >> #currentVocabularyMorphic-cmm.382:- Integrated new ListChooser from Michael Davies."!ScrollPane subclass: #PluggableListMorph	instanceVariableNames: 'list getListSelector getListSizeSelector getListElementSelector getIndexSelector setIndexSelector keystrokeActionSelector autoDeselect lastKeystrokeTime lastKeystrokes lastClickTime doubleClickSelector handlesBasicKeys potentialDropRow listMorph hScrollRangeCache keystrokePreviewSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Pluggable Widgets'!!PasteUpMorph methodsFor: 'world menu' stamp: 'nice 1/19/2010 01:57'!grabFloodFromScreen: evt	"Allow the user to plant a flood seed on the Display, and create a new drawing morph from the resulting region. Attach the result to the hand."	| screenForm exterior p1 box |	p1 := Cursor crossHair showWhile: [Sensor waitButton].	box := Display floodFill: Color transparent at: p1.	exterior := ((Display copy: box) makeBWForm: Color transparent) reverse.	self world invalidRect: box; displayWorldSafely.	(box area > (Display boundingBox area // 2))		ifTrue: [^ UIManager default notify: 'Sorry, the region was too big'].	(exterior deepCopy reverse anyShapeFill reverse)  "save interior bits"		displayOn: exterior at: 0@0 rule: Form and.	screenForm := Form fromDisplay: box.	screenForm eraseShape: exterior.	screenForm isAllWhite ifFalse:		[evt hand attachMorph: (self drawingClass withForm: screenForm)]! !!PolygonMorph methodsFor: 'attachments' stamp: 'nice 1/10/2010 19:20'!midpoint	"Answer the midpoint along my segments"	| middle |	middle := self totalLength.	middle < 2 ifTrue: [ ^ self center ].	middle := middle / 2.	self lineSegmentsDo: [ :a :b | | dist |		dist := (a dist: b).		middle < dist			ifTrue: [ ^(a + ((b - a) * (middle / dist))) asIntegerPoint ].		middle := middle - dist.	].	self error: 'can''t happen'! !!CircleMorph methodsFor: 'parts bin' stamp: 'alain.plantec 5/28/2009 09:46'!initialize	super initialize.	self extent: 40@40;		color: Color green lighter;		yourself! !!BalloonCanvas methodsFor: 'initialize' stamp: 'alain.plantec 5/28/2009 09:42'!initialize	super initialize.	aaLevel := 1.	deferred := false.! !!LayoutProperties methodsFor: 'initialize' stamp: 'alain.plantec 5/28/2009 10:00'!initialize	super initialize.	hResizing := vResizing := #rigid.	disableLayout := false.! !!BalloonCanvas methodsFor: 'private' stamp: 'marcus.denker 9/14/2008 21:01'!ifNoTransformWithIn: box	"Return true if the current transformation does not affect the given bounding box"	| delta |	transform ifNil: [^true].	delta := (transform localPointToGlobal: box origin) - box origin.	^(transform localPointToGlobal: box corner) - box corner = delta! !!PluggableListMorph methodsFor: 'selection' stamp: 'MAD 3/13/2010 14:53'!keystrokePreviewSelector: sel	"The method on the model that will be given first view of any keystroke events.  For access via scripting"	keystrokePreviewSelector := sel! !!SystemWindow methodsFor: 'layout' stamp: 'nice 1/10/2010 17:48'!convertAlignment	"Primarily Jesse Welton's code to convert old system windows to ones with modern layout scheme"	self layoutPolicy: ProportionalLayout new.	(paneMorphs isNil 		or: [paneRects isNil or: [paneMorphs size ~= paneRects size]]) 			ifFalse: 				[self addLabelArea.				self putLabelItemsInLabelArea.				self setFramesForLabelArea.				paneMorphs with: paneRects					do: 						[:m :r | 						| frame |						frame := LayoutFrame new.						frame							leftFraction: r left;							rightFraction: r right;							topFraction: r top;							bottomFraction: r bottom.						m layoutFrame: frame.						m							hResizing: #spaceFill;							vResizing: #spaceFill]].	labelArea isNil 		ifTrue: 			[self addLabelArea.			self putLabelItemsInLabelArea.			self setFramesForLabelArea.			paneMorphs ifNotNil: 					[paneMorphs do: 							[:m | 							| frame |							frame := m layoutFrame ifNil: [LayoutFrame new].							frame topOffset: (frame topOffset ifNil: [0]) - self labelHeight.							frame bottomFraction ~= 1.0 								ifTrue: 									[frame bottomOffset: (frame bottomOffset ifNil: [0]) - self labelHeight]]]].	label ifNotNil: 			[| frame |			frame := LayoutFrame new.			frame				leftFraction: 0.5;				topFraction: 0;				leftOffset: label width negated // 2.			label layoutFrame: frame].	collapseBox ifNotNil: 			[| frame |			frame := LayoutFrame new.			frame				rightFraction: 1;				topFraction: 0;				rightOffset: -1;				topOffset: 1.			collapseBox layoutFrame: frame].	stripes ifNotNil: 			[| frame |			frame := LayoutFrame new.			frame				leftFraction: 0;				topFraction: 0;				rightFraction: 1;				leftOffset: 1;				topOffset: 1;				rightOffset: -1.			stripes first layoutFrame: frame.			stripes first height: self labelHeight - 2.			stripes first hResizing: #spaceFill.			frame := LayoutFrame new.			frame				leftFraction: 0;				topFraction: 0;				rightFraction: 1;				leftOffset: 3;				topOffset: 3;				rightOffset: -3.			stripes last layoutFrame: frame.			stripes last height: self labelHeight - 6.			stripes last hResizing: #spaceFill].	menuBox ifNotNil: 			[| frame |			frame := LayoutFrame new.			frame				leftFraction: 0;				leftOffset: 19;				topFraction: 0;				topOffset: 1.			menuBox layoutFrame: frame].	closeBox ifNotNil: 			[| frame |			frame := LayoutFrame new.			frame				leftFraction: 0;				leftOffset: 4;				topFraction: 0;				topOffset: 1.			closeBox layoutFrame: frame]! !!Morph methodsFor: 'menus' stamp: 'nice 1/19/2010 01:56'!setRotationCenter	| p |	self world displayWorld.	p := Cursor crossHair showWhile:		[Sensor waitButton].	Sensor waitNoButton.	self setRotationCenterFrom: (self transformFromWorld globalPointToLocal: p).! !!PluggableListMorph methodsFor: 'model access' stamp: 'MAD 3/13/2010 14:44'!previewKeystroke: event	"Let the model decide if it's going to handle the event for us"	^ keystrokePreviewSelector 		ifNil: [ false ]		ifNotNil: [ model perform: keystrokePreviewSelector with: event ]! !!MorphicProject methodsFor: 'protocols' stamp: 'ul 3/15/2010 06:54'!currentVocabulary	^ActiveWorld currentVocabulary! !!PluggableListMorph methodsFor: 'selection' stamp: 'MAD 3/13/2010 14:53'!keystrokePreviewSelector	^ keystrokePreviewSelector! !!PluggableListMorph methodsFor: 'event handling' stamp: 'MAD 3/13/2010 15:06'!keyStroke: event 	"Process keys 	The model is allowed to preview all keystrokes. If it's not interested:	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"	| aChar aSpecialKey |	(self previewKeystroke: event) ifTrue: [ ^ self ].	(self scrollByKeyboard: event) ifTrue: [^self].	aChar := event keyCharacter.	aSpecialKey := aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!UpdatingMenuItemMorph methodsFor: 'enablement' stamp: 'nice 3/13/2010 21:46'!enablementSelector: aSelector 	enablementSelector := aSelector isBlock 				ifTrue: [aSelector copyForSaving]				ifFalse: [aSelector] ! !