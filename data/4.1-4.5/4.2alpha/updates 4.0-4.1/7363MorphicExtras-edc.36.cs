"Change Set:		7363MorphicExtras-edc.36MorphicExtras-edc.36:I just add package MorphicExtras-Flaps for having same as in http://www.squeaksource.com/Ladrillos.html.MorphicExtras-ar.35:Underscore removal."!!SoundEventMorph methodsFor: 'piano rolls' stamp: 'RAA 12/7/2000 12:36'!addMorphsTo: morphList pianoRoll: pianoRoll eventTime: t betweenTime: leftTime and: rightTime	| startX lengthInTicks endX |	startTimeInScore > rightTime ifTrue: [^ self].  	lengthInTicks := pianoRoll scorePlayer ticksForMSecs: sound duration * 1000.0.	startTimeInScore + lengthInTicks < leftTime ifTrue: [^ self].	startX := pianoRoll xForTime: startTimeInScore.	endX := pianoRoll xForTime: startTimeInScore + lengthInTicks.	morphList add: 		(self left: startX; width: endX - startX).! !!MagnifierMorph methodsFor: 'accessing' stamp: 'nk 3/6/2004 10:14'!showPointer: aBoolean	"If aBoolean is true, display the current pointer position as a small square in the center of the lens."	showPointer == aBoolean ifTrue: [ ^self ].	showPointer := aBoolean.	self changed.! !!BackgroundMorph methodsFor: 'accessing' stamp: ''!stopRunning	running := false.	self changed! !!BookMorph methodsFor: 'insert and delete' stamp: 'dgd 9/21/2003 17:45'!deletePage	| message |	message := 'Are you certain that youwant to delete this page andeverything that is on it? ' translated.	(self confirm: message) ifTrue: 			[self deletePageBasic].	! !!PaintBoxMorph class methodsFor: 'instance creation' stamp: 'bf 10/11/2004 13:37'!new	| pb button dualUse formCanvas rect |	pb := Prototype veryDeepCopy.		"Assume that the PaintBox does not contain any scripted Players!!"	pb stampHolder normalize.	"Get the stamps to show"	"Get my own copies of the brushes so I can modify them"	#(brush1: brush2: brush3: brush4: brush5: brush6:) do: [:sel |		button := pb submorphNamed: sel.		button offImage: button offImage deepCopy.		dualUse := button onImage == button pressedImage.	"sometimes shared"		button onImage: button onImage deepCopy.		dualUse			ifTrue: [button pressedImage: button onImage]			ifFalse: [button pressedImage: button pressedImage deepCopy].		"force color maps for later mapping"		button offImage.		button onImage.		button pressedImage.		formCanvas := button onImage getCanvas.		formCanvas := formCanvas			copyOrigin: 0@0			clipRect: (rect := 0@0 extent: button onImage extent).		(#(brush1: brush3:) includes: sel) ifTrue: [			rect := rect origin corner: rect corner - (2@2)].		(#brush2: == sel) ifTrue: [			rect := rect origin corner: rect corner - (2@4)].		formCanvas frameAndFillRectangle: rect fillColor: Color transparent			borderWidth: 2 borderColor: (Color r: 0.599 g: 0.8 b: 1.0).		].	pb showColor.	pb fixUpRecentColors.	pb addLabels.	^ pb! !!CommandHistory methodsFor: 'menu' stamp: 'sw 2/2/2006 01:53'!undoOrRedoMenuWording	"Answer the wording to be used in a menu item offering undo/redo (i.e., the form used when the #infiniteUndo preference is false)"	| pre |	self assureLastCommandStillValid. 	lastCommand ifNil: [^ 'can''t undo' translated].	pre := lastCommand phase == #done		ifTrue: ['undo' translated]		ifFalse: ['redo' translated].	^ pre, ' "', (lastCommand cmdWording truncateWithElipsisTo: 20), '" (z)'! !!TransformMorph methodsFor: '*MorphicExtras-accessing' stamp: 'sps 12/28/2002 02:09'!quickAddAllMorphs: aCollection"A fast add of all the morphs for the PluggableListMorph>>list: method to use -- assumes that fullBounds will get called later by the sender, so it avoids doing any updating on the morphs in aCol or updating layout of this scroller. So the sender should handle those tasks as appropriate"	| myWorld itsWorld |	myWorld := self world.	aCollection do: [:m |		m owner ifNotNil: [			itsWorld := m world.			itsWorld == myWorld ifFalse: [m outOfWorld: itsWorld].			m owner privateRemoveMorph: m].		m privateOwner: self.		"inWorld ifTrue: [self addedOrRemovedSubmorph: m]."		itsWorld == myWorld ifFalse: [m intoWorld: myWorld].		].	submorphs := aCollection.	"self layoutChanged."! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:00'!readTape: fileName 	| file |	self writeCheck.	(FileStream isAFileNamed: fileName) ifFalse: [^ nil].	file := FileStream oldFileNamed: fileName.	tape := self readFrom: file.	file close.	saved := true  "Still exists on file"! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected := false.		pair do: [:atom | atom infected ifTrue: [infected := true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count := 0.	self submorphsDo: [:m | m infected ifTrue: [count := count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection := false.		self stopStepping].! !!NewWorldWindow methodsFor: 'panes' stamp: 'ar 11/9/2000 01:31'!addMorph: aMorph frame: relFrame	| cc |	cc := aMorph color.	super addMorph: aMorph frame: relFrame.	aMorph color: cc.! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'sw 6/10/2003 12:59'!makeSoundMorph	| m |	recorder verifyExistenceOfRecordedSound ifFalse: [^ self].	recorder pause.	m := SoundEventMorph new sound: recorder recordedSound.	self world firstHand attachMorph: m.! !!PrintSpecifications class methodsFor: 'as yet unclassified' stamp: 'RAA 9/18/2000 09:29'!defaultSpecs	DefaultSpecs ifNil: [DefaultSpecs := self new].	^DefaultSpecs copy! !!ReferenceMorph methodsFor: 'misc' stamp: 'sw 1/11/2000 10:18'!morphToInstall: aMorph font: aFont	"Create a new tab consisting of a string holding the morph's name"	| aLabel nameToUse |	aLabel := StringMorph contents: (nameToUse := aMorph externalName) font: aFont.	self addMorph: aLabel.	aLabel lock.	self referent: aMorph.	self setNameTo: nameToUse.	self fitContents.! !!CommandHistory class methodsFor: 'system startup' stamp: 'tk 5/16/2002 13:52'!forgetAllGrabCommandsFrom: starter	"Forget all the commands that might be held on to in the properties dicitonary of various morphs for various reasons."	| object |	object := starter.	[		[0 == object] whileFalse: [			object isMorph ifTrue: [object removeProperty: #undoGrabCommand].			object := object nextObject].		] ifError: [:err :rcvr | "object is obsolete"			self forgetAllGrabCommandsFrom: object nextObject].	"CommandHistory forgetAllGrabCommandsFrom: true someObject"! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'jm 6/25/1998 13:00'!releaseCachedStateOfPages	"Note: This shouldn't be necessary if we are doing a good job of releasing cached state as we go. If running this doesn't do very much, we're doing well!!"	"SqueakPageCache releaseCachedStateOfPages"	| memBytes |	memBytes := Smalltalk garbageCollect.	PageCache do: [:pg |		pg contentsMorph allMorphsDo: [:m | m releaseCachedState]].	^ (Smalltalk garbageCollect - memBytes) printString, ' bytes recovered'! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 2/27/1999 14:18'!grabForBook: bookMorph	"Create a URLMorph for this book.  Put it into the hand."	| um bookUrl pageUrl pg |	bookUrl := bookMorph valueOfProperty: #url.	pageUrl := bookMorph currentPage url.	"should have one!!"	pg := SqueakPageCache atURL: pageUrl.	(SqueakPage stemUrl: bookUrl) = (SqueakPage stemUrl: pageUrl) 		ifTrue: [bookUrl := true].		"not a shared book"	um := URLMorph newForURL: pageUrl.	um setURL: pageUrl page: pg.	pg isContentsInMemory ifTrue: [pg computeThumbnail].	um isBookmark: true.	um book: bookUrl.	um removeAllMorphs.	um color: Color transparent.	Smalltalk currentHand attachMorph: um.	^ um! !!ThreePhaseButtonMorph methodsFor: '*MorphicExtras-accessing' stamp: 'tk 6/29/97 21:04'!authorModeOwner: aMorph	AuthorModeOwner := aMorph! !!URLMorph class methodsFor: 'instance creation' stamp: 'tk 10/2/1998 12:08'!newForURL: aURLString	| pg |	pg := SqueakPageCache atURL: aURLString.	^ self new setURL: aURLString page: pg! !!BookMorph methodsFor: 'other' stamp: 'tk 2/19/2001 18:35'!makeMinimalControlsWithColor: aColor title: aString	| aButton aColumn aRow but |	aButton := SimpleButtonMorph new target: self; borderColor: Color black; 				color: aColor; borderWidth: 0.	aColumn := AlignmentMorph newColumn.	aColumn color: aButton color; borderWidth: 0; layoutInset: 0.	aColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow := AlignmentMorph newRow.	aRow color: aButton color; borderWidth: 0; layoutInset: 0.	aRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	aRow addTransparentSpacerOfSize: 40@0.	aRow addMorphBack: (but := aButton label: ' < ' ; actionSelector: #previousPage).		"copy is OK, since we just made it and it can't own any Players"	but setBalloonText: 'Go to previous page'.	aRow addTransparentSpacerOfSize: 82@0.	aRow addMorphBack: (StringMorph contents: aString) lock.	aRow addTransparentSpacerOfSize: 82@0.	aButton := SimpleButtonMorph new target: self; borderColor: Color black; 				color: aColor; borderWidth: 0.	aRow addMorphBack: (but := aButton label: ' > ' ; actionSelector: #nextPage).	but setBalloonText: 'Go to next page'.	aRow addTransparentSpacerOfSize: 40@0.	aColumn addMorphBack: aRow.	aColumn setNameTo: 'Page Controls'.		^ aColumn! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 12:59'!goToPage	| pageNum |	pageNum := FillInTheBlank request: 'Page?' translated initialAnswer: '0'.	pageNum isEmptyOrNil ifTrue: [^true].	self goToPage: pageNum asNumber.! !!PostscriptCanvas methodsFor: 'drawing-support' stamp: 'nk 4/1/2004 19:41'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	| result oldShadow |	oldShadow := shadowColor.	self translate: delta.	result := aBlock value: self.	self translate: delta negated.	shadowColor := oldShadow.	^ result! !!MagnifierMorph methodsFor: 'menu' stamp: 'md 11/16/2003 15:14'!chooseMagnification	| result |	result := (SelectionMenu selections: #(1.5 2 4 8))		startUpWithCaption: ('Choose magnification(currently {1})' translated format:{magnification}).	(result isNil or: [result = magnification]) ifTrue: [^ self].	magnification := result.	self extent: self extent. "round to new magnification"	self changed. "redraw even if extent wasn't changed"! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:12'!changeTiltFactor: x	panAndTiltFactor := x! !!ScreeningMorph methodsFor: 'submorphs-add/remove' stamp: 'di 6/4/1999 08:25'!addMorph: aMorph	| f |	super addMorph: aMorph.	submorphs size <= 2 ifTrue:		[self bounds: submorphs last bounds].	submorphs size = 2 ifTrue:		["The screenMorph has just been added.		Choose as the passingColor the center color of that morph"		f := self screenMorph imageForm.		passingColor := f colorAt: f boundingBox center.		passElseBlock := true]! !!TabMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:39'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.morphToInstall := deepCopier references at: morphToInstall ifAbsent: [morphToInstall].! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'nb 6/17/2003 12:25'!renameEntry	| reply curr |	reply := FillInTheBlank		request: 'New key? '		initialAnswer: (curr := entryNames at: currentIndex)		centerAt: self center.	(reply isEmptyOrNil or: [reply = curr]) ifTrue: [^ Beeper beep].	(baseDictionary includesKey: reply) ifTrue:		[^ self inform: 'sorry that conflicts withthe name of anotherentry in this dictionary'].	baseDictionary at: reply put: (baseDictionary at: curr).	baseDictionary removeKey: curr.	self baseDictionary: baseDictionary.	self updateThumbnail! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'sw 7/5/2004 03:20'!polyNew: evt	"Create a new polygon.  Add it to the sketch, and let the user dragits vertices around!!  Freeze it into the painting when the user choosesanother tool."	| poly cColor |	self polyEditing ifTrue:[		self polyFreeze.		(self hasProperty: #polyCursor)			ifTrue:[palette plainCursor: (self valueOfProperty: #polyCursor) event: evt.					self removeProperty: #polyCursor].		^self].	cColor := self getColorFor: evt.	self polyFreeze.		"any old one we were working on"	poly := PolygonMorph new "addHandles".	poly referencePosition: poly bounds origin.	poly align: poly bounds center with: evt cursorPoint.	poly borderWidth: (self getNibFor: evt) width.	poly borderColor: (cColor isTransparent ifTrue: [Color black] ifFalse: [cColor]).	poly color: Color transparent.	self addMorph: poly.	poly changed.	self setProperty: #polygon toValue: poly.! !!SoundLoopMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:50'!initialize	"initialize the state of the receiver"	super initialize.	""		controlIndex := 0.	self addCursorMorph! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/14/1998 12:25'!nSteps: n stepTime: msPerStep	nSteps := n.	stepTime := msPerStep! !!GraphMorph methodsFor: 'commands' stamp: 'gk 2/23/2004 21:08'!playOnce	| scale absV scaledData |	data isEmpty ifTrue: [^ self].  "nothing to play"	scale := 1.	data do: [:v | (absV := v abs) > scale ifTrue: [scale := absV]].	scale := 32767.0 / scale.	scaledData := SoundBuffer newMonoSampleCount: data size.	1 to: data size do: [:i | scaledData at: i put: (scale * (data at: i)) truncated].	SoundService default playSampledSound: scaledData rate: 11025.! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 9/18/2000 09:28'!printSpecs: aPrintSpecification	printSpecs := aPrintSpecification! !!TickIndicatorMorph methodsFor: 'geometry' stamp: 'ar 2/11/2001 20:12'!extent: aPoint	super extent: ((aPoint x max: aPoint y)  asInteger bitClear: 3) asPoint.	corners := nil.! !!MorphWorldController methodsFor: 'basic control sequence' stamp: 'di 11/16/2001 13:58'!controlTerminate 	"This window is becoming inactive; restore the normal cursor."	Cursor normal show.	ActiveWorld := ActiveHand := ActiveEvent := nil! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/30/98 12:41'!minVal: aNumber	minVal := aNumber.! !!StringButtonMorph methodsFor: 'accessing' stamp: ''!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 8/24/97 21:31'!makeRecordMeter	| outerBox |	outerBox := Morph new extent: 102@18; color: Color gray.	recordMeter := Morph new extent: 1@16; color: Color yellow.	recordMeter position: outerBox topLeft + (1@1).	outerBox addMorph: recordMeter.	^ outerBox! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!selector: aSymbol	selector := aSymbol! !!SimpleSliderMorph methodsFor: 'copying' stamp: 'tk 1/6/1999 19:24'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].arguments := arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/20/1998 09:13'!stretch: sampleArray by: stretchFactor	"Return an array consisting of the given samples \stretched in time by the given factor."	| out end incr i frac index |	out := OrderedCollection new: (stretchFactor * sampleArray size) asInteger + 1.	end := (sampleArray size - 1) asFloat.	incr := 1.0 / stretchFactor.	i := 1.0.	[i < end] whileTrue: [		frac := i fractionPart.		index := i truncated.		i := i + incr.		out addLast:			(((1.0 - frac) * (sampleArray at: index)) + (frac * (sampleArray at: index + 1))) rounded].	^ out asArray! !!URLMorph methodsFor: 'updating' stamp: 'jm 6/17/1998 14:15'!pageHasChanged: aSqueakPage	"The given page has changed. Update this morph if it refers to the given page."	| thumbnail |	page == aSqueakPage ifFalse: [^ self].  "this change does not affect me"	thumbnail := self thumbnailOrNil.	thumbnail ifNotNil: [		self extent: (thumbnail extent + 2).		self changed].! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 2/3/98 19:14'!chooseFrom: chooserMorph envelopeItem: item	| name |	(item beginsWith: 'edit ') ifTrue:		[name := item copyFrom: 'edit ' size+1 to: item size.		self editEnvelope: (sound envelopes detect:				[:env | env name = name])].	(item beginsWith: 'add ') ifTrue:		[name := item copyFrom: 'add ' size+1 to: item size.		self addEnvelopeNamed: name].	(item beginsWith: 'remove ') ifTrue:		[self removeEnvelope  "the current one"].	chooserMorph contentsClipped: envelope name! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/8/2003 19:44'!addControls	| b r partsBinButton newButton |	newButton := ImageMorph new image: (World project makeThumbnail scaledToSize: 24@18).	newButton on: #mouseDown send: #insertNewProject: to: self.	newButton setBalloonText: 'Make a new Project' translated.	(partsBinButton := UpdatingThreePhaseButtonMorph checkBox)		target: self;		actionSelector: #togglePartsBinStatus;		arguments: #();		getSelector: #getPartsBinStatus.	(r := AlignmentMorph newRow)		color: Color transparent;		borderWidth: 0;		layoutInset: 0;		wrapCentering: #center;		cellPositioning: #topCenter;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		extent: 5@5.	b := SimpleButtonMorph new target: self; color: self defaultColor darker;			borderColor: Color black.	r addMorphBack: (self wrapperFor: (b label: 'Okay' translated;	actionSelector: #acceptSort)).	b := SimpleButtonMorph new target: self; color: self defaultColor darker;			borderColor: Color black.	r addMorphBack: (self wrapperFor: (b label: 'Cancel' translated;	actionSelector: #delete));		addMorphBack: (self wrapperFor: (newButton));		addTransparentSpacerOfSize: 8 @ 0;		addMorphBack: (self wrapperFor: partsBinButton);		addMorphBack: (self wrapperFor: (StringMorph contents: 'Parts bin' translated) lock).	self addMorphFront: r.! !!ScaleMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:00'!initialize	"initialize the state of the receiver"	super initialize.	""		start := 0.	stop := 100.	minorTick := 1.	majorTick := 10.	minorTickLength := 3.	majorTickLength := 10.	caption := nil.	tickPrintBlock := [:v | v printString].	labelsAbove := true.	captionAbove := true! !!GeeBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/3/2000 12:13'!geePageRectangles	| pageBounds allPageRects |	pageBounds := geeMail topLeft 			extent: geeMail width @ (geeMail height min: Display height - 50).	allPageRects := OrderedCollection new.	[pageBounds top <= geeMail bottom] whileTrue: [		allPageRects add: pageBounds.		pageBounds := pageBounds translateBy: 0 @ pageBounds height.	].	^allPageRects! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 20:53'!undoTarget: target selector: selector arguments: arguments	"Give target morph a chance to refine its undo operation"	target refineUndoTarget: target selector: selector arguments: arguments in:		[:rTarget :rSelector :rArguments |		undoTarget := rTarget.		undoSelector := rSelector.		undoArguments := rArguments]! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/2/2004 01:27'!fontsForAccuAt	| d |	"Bold = 1, Ital = 2, Under = 4, Narrow = 8, Struckout = 16"	d := Dictionary new.	d		at: 0 put: #('Helvetica-Bold' 1.0);		at: 1 put: #('Helvetica-Bold' 1.0);		at: 2 put: #('Helvetica-BoldOblique' 1.0);		at: 3 put: #('Helvetica-BoldOblique' 1.0).	^d! !!PartsBin class methodsFor: 'thumbnail cache' stamp: 'nk 9/1/2004 17:44'!thumbnailForQuad: aQuint color: aColor	"Answer a thumbnail for a morph obtaining as per the quintuplet provided, creating the thumbnail if necessary.  If it is created afresh, it will also be cached at this time"	| aThumbnail aSymbol formToThumbnail labeledItem |	aSymbol := aQuint third.	Thumbnails at: aSymbol ifPresent: [ :thumb | ^thumb ].	formToThumbnail := aQuint at: 5 ifAbsent: [].	formToThumbnail ifNil: [		labeledItem := (Smalltalk at: aQuint first) perform: aQuint second.		formToThumbnail := labeledItem imageForm: 32 backgroundColor: aColor forRectangle: labeledItem fullBounds.		formToThumbnail replaceColor: aColor withColor: Color transparent.	].	aThumbnail := Thumbnail new makeThumbnailFromForm: formToThumbnail.	self cacheThumbnail: aThumbnail forSymbol: aSymbol.	^ aThumbnail"PartsBin initialize"! !!ThreePhaseButtonMorph methodsFor: '*MorphicExtras-copying' stamp: 'jm 7/28/97 11:56'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then update it to point to the new copy. This method also copies the arguments array itself, which is important!!"	super updateReferencesUsing: aDictionary.	arguments := arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!StoryboardBookMorph methodsFor: 'navigation' stamp: 'sw 7/25/2003 16:47'!insertPageMorphInCorrectSpot: aPageMorph	"Insert the page morph at the correct spot"		| place |	place := submorphs size > 1 ifTrue: [submorphs second] ifFalse: [submorphs first].	"Old architecture had a tiny spacer morph as the second morph; now architecture does not"	self addMorph: (currentPage := aPageMorph) behind: place.	self changeTiltFactor: self getTiltFactor.	self changeZoomFactor: self getZoomFactor.	zoomController target: currentPage.! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'sw 12/1/1998 17:54'!upArrowHit	currentIndex := currentIndex + 1.	(currentIndex > formChoices size) ifTrue: [currentIndex := 1].	self updateThumbnail	! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/6/2000 23:31'!methodHolderVersions	| arrayOfVersions vTimes strings |	"Create lists of times of older versions of all code in MethodMorphs in this book."	arrayOfVersions := MethodHolders collect: [:mh | 		mh versions].	"equality, hash for MethodHolders?"	vTimes := SortedCollection new.	arrayOfVersions do: [:versionBrowser |  		versionBrowser changeList do: [:cr | 			(strings := cr stamp findTokens: ' ') size > 2 ifTrue: [				vTimes add: strings second asDate asSeconds + 						strings third asTime asSeconds]]].	VersionTimes := Time condenseBunches: vTimes.	VersionNames := Time namesForTimes: VersionTimes.! !!PostscriptCharacterScanner methodsFor: 'accessing' stamp: ''!bounds:newBounds    bounds:=newBounds.    curPos:=newBounds origin.	! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 13:50'!offset: aPoint	offset := aPoint! !!EnvelopeEditorMorph methodsFor: 'stepping and presenter' stamp: 'di 6/7/1999 15:37'!step	| mouseDown hand |	hand := self world firstHand.	(bounds containsPoint: hand position) ifFalse: [^ self].	mouseDown := hand lastEvent redButtonPressed.	mouseDown not & prevMouseDown ifTrue:		["Mouse just went up"		limitXs = (limits collect: [:i | (envelope points at: i) x]) ifFalse:			["Redisplay after changing limits"			self editEnvelope: envelope]].	prevMouseDown := mouseDown! !!SqueakPageCache class methodsFor: 'class initialization' stamp: 'tk 11/24/1998 14:53'!initialize	"SqueakPageCache initialize"	GlobalPolicy := #neverWrite.	PageCache := Dictionary new: 100.		"forgets urls of pages, but ObjectOuts still remember them"! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'ar 3/17/2001 14:24'!addCurves	"Add the polyLine corresponding to the currently selected envelope,	and possibly all the others, too."	| verts aLine |	sound envelopes do:		[:env | 		(showAllEnvelopes or: [env == envelope]) ifTrue:			[verts := env points collect:				[:p | (self xFromMs: p x) @ (self yFromValue: p y)].			aLine := EnvelopeLineMorph basicNew						vertices: verts borderWidth: 1						borderColor: (self colorForEnvelope: env).			env == envelope				ifTrue: [aLine borderWidth: 2.  line := aLine]				ifFalse: [aLine on: #mouseUp send: #clickOn:evt:from:							to: self withValue: env.						self addMorph: aLine]]].	self addMorph: line  "add the active one last (in front)"! !!MagnifierMorph methodsFor: 'menu' stamp: 'di 8/24/2000 14:02'!chooseMagnification: evt	| handle origin aHand currentMag |	currentMag := magnification.	aHand := evt ifNil: [self currentHand] ifNotNil: [evt hand].	origin := aHand position y.	handle := HandleMorph new forEachPointDo:		[:newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag].	aHand attachMorph: handle.	handle startStepping.	self changed. "Magnify handle"! !!PrintSpecifications methodsFor: 'as yet unclassified' stamp: 'RAA 9/19/2000 17:07'!drawAsBitmapFlag: aBoolean	drawAsBitmapFlag := aBoolean! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/4/1930 09:19'!canvas:newCanvas	canvas := newCanvas.! !!Command class methodsFor: 'class initialization' stamp: 'RAA 9/21/2000 14:02'!zapObsolete"Command zapObsolete"	"kill some obsolete stuff still retained by the CompiledMethods in change records"	| before after histories lastCmd histCount lastCount |	Smalltalk garbageCollect.	before := Command allInstances size.	histories := Association allInstances select: [ :each | 		each key == #CommandHistory and: [			(each value isKindOf: OrderedCollection) and: [				each value isEmpty not and: [					each value first isKindOf: Command]]]	].	histCount := histories size.	lastCmd := Association allInstances select: [ :each | 		each key == #LastCommand and: [each value isKindOf: Command]	].	lastCount := lastCmd size.	histories do: [ :each | each value: OrderedCollection new].	lastCmd do: [ :each | each value: Command new].	Smalltalk garbageCollect.	Smalltalk garbageCollect.	after := Command allInstances size.	Transcript show: {before. after. histCount. histories. lastCount. lastCmd} printString; cr; cr.	! !!ClockMorph methodsFor: 'seconds' stamp: 'sw 2/17/1999 14:53'!toggleShowingSeconds	showSeconds := (showSeconds == true) not! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'RAA 6/14/2001 16:50'!pauseIn: aWorld	"Suspend playing or recording, either as part of a stop command,	or as part of a project switch, after which it will be resumed."	self setStatusLight: #ready.	state = #play ifTrue:		[state := #suspendedPlay.		playHand delete.		aWorld removeHand: playHand.		playHand := nil].	state = #record ifTrue:		[state := #suspendedRecord.		recHand removeEventListener: self.		recHand := nil].	voiceRecorder ifNotNil:		[voiceRecorder pause.		startSoundEvent ifNotNil:			[startSoundEvent argument: voiceRecorder recordedSound.			voiceRecorder clearRecordedSound.			startSoundEvent := nil]].! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'JMV 1/29/2001 10:58'!curveChoices	| extant others |	extant := sound envelopes collect: [:env | env name].	others := #('volume' 'modulation' 'pitch' 'random pitch:' 'ratio')		reject: [:x | (extant includes: x) | ((x = 'pitch') & (extant includes: 'random pitch:')) | ((x = 'random pitch:') & (extant includes: 'pitch')) ].	^ (extant collect: [:name | 'edit ' , name])	, (others collect: [:name | 'add ' , name])	, (sound envelopes size > 1		ifTrue: [Array with: 'remove ' , envelope name]		ifFalse: [Array new])! !!RemoteHandMorph methodsFor: 'connections' stamp: 'mir 5/13/2003 10:45'!startTransmittingEventsTo: remoteAddr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	remoteAddress := remoteAddr.	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := OldSimpleClientSocket new.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!positionCursor	| x |	x := controlIndex * 128 // self controlRate.	cursor position: self innerBounds topLeft + (x@0)! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'di 1/29/98 13:06'!constrain: xVal adjacentTo: ix in: points	"Return xVal, restricted between points adjacent to vertX"	| newVal |	newVal := xVal.	ix > 1 ifTrue: [newVal := newVal max: (points at: ix-1) x].	ix < points size ifTrue: [newVal := newVal min: (points at: ix+1) x].	^ newVal! !!EventRecorderMorph methodsFor: 'commands' stamp: 'RAA 6/14/2001 16:42'!play	self isInWorld ifFalse: [^ self].	self stop.	tape ifNil: [^ self].	tapeStream := ReadStream on: tape.	self resumePlayIn: self world.	self setStatusLight: #nowPlaying.! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/20/2001 17:12'!togglePageBreaks	showPageBreaks := showPageBreaks not.	self changed! !!IndexTabs methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:29'!regularColor: aColor	regularColor := aColor! !!PrintSpecifications methodsFor: 'as yet unclassified' stamp: 'RAA 2/22/2001 07:35'!scaleToFitPage: aBoolean	scaleToFitPage := aBoolean! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 1/9/2001 08:26'!positionVertically	| wb stickToTop |	owner == self world ifFalse: [^self].	wb := self worldBounds.	stickToTop := self valueOfProperty: #stickToTop.	stickToTop ifNil: [		stickToTop := (self top - wb top) abs < (self bottom - wb bottom) abs.		self setProperty: #stickToTop toValue: stickToTop.	].	mouseInside == true ifTrue: [		stickToTop ifTrue: [			self top: wb top		] ifFalse: [			self bottom: wb bottom		].	] ifFalse: [		stickToTop ifTrue: [			self bottom: wb top + self amountToShowWhenSmall		] ifFalse: [			self top: wb bottom - self amountToShowWhenSmall		].	].! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'RAA 6/14/2001 16:13'!makeStatusLight	^statusLight := EllipseMorph new 		extent: 11 @ 11;		color: Color green;		borderWidth: 0! !!PreferencesPanel methodsFor: 'initialization' stamp: 'FBS 2/24/2004 14:26'!adjustProjectLocalEmphasisFor: aSymbol	"Somewhere, the preference represented by aSymbol got changed from being one that is truly global to one that varies by project, or vice-versa.  Get my panel right -- this involves changing the emphasis on the item"	| aWindow toFixUp allMorphs emphasis |	(aWindow := self containingWindow) ifNil: [^ self].	emphasis := (Preferences preferenceAt: aSymbol ifAbsent: [^ self]) localToProject		ifTrue:	[TextEmphasis bold emphasisCode "bold for local-to-project"]		ifFalse:	[TextEmphasis normal emphasisCode "normal for global"].	allMorphs := IdentitySet new.	aWindow allMorphsAndBookPagesInto: allMorphs.	toFixUp := allMorphs select:		[:m | (m isKindOf: StringMorph) and: [m contents = aSymbol]].	toFixUp do:		[:aStringMorph | aStringMorph emphasis: emphasis]	! !!Command methodsFor: 'initialization' stamp: 'sw 8/29/2000 14:12'!cmdWording: wrd	"Set the wording to be used in a menu item referring to the receiver"	cmdWording := wrd! !!ScreeningMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 13:43'!passElseBlock: aBool	passElseBlock := aBool.! !!EnvelopeLineMorph methodsFor: 'as yet unclassified' stamp: 'dgd 2/14/2003 20:17'!vertices: verts borderWidth: bw borderColor: bc 	super initialize.	vertices := verts.		borderWidth := bw.	borderColor := bc.	closed := false.	arrows := #none.	self computeBounds! !!PostscriptCanvas methodsFor: 'private' stamp: 'mpw 8/7/2000 09:09'!bounds:newBounds	psBounds := newBounds.! !!GeeMailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/3/2001 13:01'!scrollToYAbsolute: yValue	| transform transformedPoint |	transform := scroller transformFrom: self.	transformedPoint := transform localPointToGlobal: 0@yValue.	self scrollBy: 0@(bounds top - transformedPoint y).! !!MorphWorldController methodsFor: 'basic control sequence' stamp: 'di 11/16/2001 22:43'!controlLoop 	"Overridden to keep control active when the hand goes out of the view"	| db |	[self viewHasCursor  "working in the window"		or: [Sensor noButtonPressed  "wandering with no button pressed"		or: [model primaryHand submorphs size > 0  "dragging something outside"]]]		whileTrue:   "... in other words anything but clicking outside"			[self controlActivity.			"Check for reframing since we hold control here"			db := view superView displayBox.			view superView controller checkForReframe.			db = view superView displayBox ifFalse:				[self controlInitialize "reframe world if bounds changed"]].! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 11:46'!otherButtonFor: aButton	"Find the corresponding button for either a pickup or a stamp button"	| ii |	(ii := pickupButtons indexOf: aButton) > 0 ifTrue: [^ stampButtons at: ii].	(ii := stampButtons indexOf: aButton) > 0 ifTrue: [^ pickupButtons at: ii].	self error: 'stamp button not found'.! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'sw 7/4/1998 15:39'!clearNewPagePrototype	newPagePrototype := nil! !!TabbedPalette methodsFor: 'palette menu' stamp: 'nk 6/12/2004 10:05'!addMenuTab	"Add the menu tab.  This is ancient code, not much in the spirit of anything current"	| aMenu aTab aGraphic sk |	aMenu := MenuMorph new defaultTarget: self.	aMenu stayUp: true.	"aMenu add:  'clear' translated action: #showNoPalette."	aMenu add:  'sort tabs' translated action: #sortTabs:.	aMenu add:  'choose new colors for tabs' translated action: #recolorTabs.	aMenu setProperty: #paletteMenu toValue: true.	"aMenu add:  'make me the Standard palette' translated action: #becomeStandardPalette."	aTab := self addTabForBook: aMenu  withBalloonText: 'a menu of palette-related controls' translated.	aTab highlightColor: tabsMorph highlightColor; regularColor: tabsMorph regularColor.	tabsMorph laySubpartsOutInOneRow; layoutChanged.	aGraphic := ScriptingSystem formAtKey: 'TinyMenu'.	aGraphic ifNotNil:		[aTab removeAllMorphs.		aTab addMorph: (sk := World drawingClass withForm: aGraphic).		sk position: aTab position.		sk lock.		aTab fitContents].	self layoutChanged! !!ThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 11/10/2000 11:37'!ensureSuitableDefaults	listOfPages ifNil: [listOfPages := OrderedCollection new].	currentIndex ifNil: [currentIndex := 0].! !!StringButtonMorph methodsFor: 'menu' stamp: 'yo 3/16/2005 21:02'!setActWhen	| selections |	selections := #(buttonDown buttonUp whilePressed).	actWhen := (SelectionMenu labelList: (selections collect: [:t | t translated]) selections: selections)		startUpWithCaption: 'Choose one of the following conditions' translated.! !!TransformationB2Morph methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/2000 12:44'!useRegularWarpBlt: aBoolean	useRegularWarpBlt := aBoolean! !!SqueakPage class methodsFor: 'as yet unclassified' stamp: 'sw 7/6/1998 11:49'!newURLAndPageFor: aMorph	"Create a new SqueakPage whose contents is the given morph. Assign a URL for that page, record it in the page cache, and answer its URL."	| pg newURL stamp |	pg := self new.	stamp := Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: aMorph author: stamp.	newURL := SqueakPageCache generateURL.	SqueakPageCache atURL: newURL put: pg.	^ newURL ! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!chooseDenominator: evt	| menu |	menu := MenuMorph new.	(Integer primesUpTo: 30) do:		[:i |		menu add: i printString			target: self selector: #setDenominator:			argument: i].	menu addLine.	menu add: 'none' target: self selector: #setDenominator: argument: 9999.	menu popUpEvent: evt in: self world! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 19:23'!extentFromParent: aPoint	| newExtent |	submorphs isEmpty ifTrue: [^self extent: aPoint].	newExtent := aPoint truncated.	bounds := bounds topLeft extent: newExtent.	newExtent := self recomputeExtent.	newExtent ifNil: [^self].	bounds := bounds topLeft extent: newExtent.! !!TickIndicatorMorph methodsFor: 'accessing' stamp: 'ar 2/12/2001 17:40'!stepTime: aNumber	stepTime := aNumber max: 1.! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:16'!fixup	| newMorphs state fixed |	somethingChanged := false.	newMorphs := OrderedCollection new.	state := #new.	fixed := false.	submorphs do: [ :each |		(each isKindOf: ZASMCameraMarkMorph) ifTrue: [			state == #mark ifTrue: [				newMorphs add: (					ZASMStepsMorph new setStepCount: 10				).				fixed := true.			].			newMorphs add: each.			state := #mark.		].		(each isKindOf: ZASMStepsMorph) ifTrue: [			state == #steps ifTrue: [				fixed := true.			] ifFalse: [				newMorphs add: each.				state := #steps.			].		].	].	fixed ifTrue: [		self removeAllMorphs.		self addAllMorphs: newMorphs.	].! !!BasicButton methodsFor: 'as yet unclassified' stamp: 'sw 12/10/1999 09:07'!label: aString font: aFontOrNil	| oldLabel m aFont |	(oldLabel := self findA: StringMorph)		ifNotNil: [oldLabel delete].	aFont := aFontOrNil ifNil: [Preferences standardButtonFont].	m := StringMorph contents: aString font: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!FunctionComponent methodsFor: 'as yet unclassified' stamp: 'di 5/3/1998 22:04'!headerString	| ps |	^ String streamContents:		[:s | s nextPutAll: self knownName.		2 to: pinSpecs size do:			[:i | ps := pinSpecs at: i.			s nextPutAll: ps pinName , ': ';				nextPutAll: ps pinName , ' '].		s cr; tab; nextPutAll: '^ ']! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 12/11/2000 12:02'!mouseDown: evt	| paintBox |	evt hand visible: true.	"See if a stamp is being dropped into the trash. It is not held by the hand."	(paintBox := self findActivePaintBox) ifNotNil: [		paintBox getSpecial == #stamp: ifTrue: [			paintBox deleteCurrentStamp: evt.  "throw away stamp..."			self primaryHand showTemporaryCursor: nil.			^ self]].	  "... and don't open trash"	evt hand waitForClicksOrDrag: self event: evt.! !!NewWorldWindow methodsFor: 'label' stamp: 'sw 5/19/2001 10:44'!setStripeColorsFrom: paneColor	"Since our world may be *any* color, try to avoid really dark colors so title will show"	| revisedColor |	stripes ifNil: [^ self].	revisedColor := paneColor atLeastAsLuminentAs: 0.1 .	self isActive ifTrue:		[stripes second 			color: revisedColor; 			borderColor: stripes second color darker.		stripes first 			color: stripes second borderColor darker;			borderColor: stripes first color darker.		^ self].	"This could be much faster"	stripes second 		color: revisedColor; 		borderColor: revisedColor.	stripes first 		color: revisedColor; 		borderColor: revisedColor! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/26/2003 13:22'!closeButtonOnly	"Replace my default control panel with one that has only a close button."	| b r |	self firstSubmorph delete.  "remove old control panel"	b := SimpleButtonMorph new target: self; borderColor: Color black.	r := AlignmentMorph newRow.	r color: b color; borderWidth: 0; layoutInset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r wrapCentering: #topLeft.	r addMorphBack: (b label: 'Close' translated; actionSelector: #delete).	self addMorphFront: r.! !!ReferenceMorph methodsFor: 'menu' stamp: 'sw 7/7/1999 12:49'!useGraphicalTab	| aGraphic |	self preserveDetails.	self color: Color transparent.	aGraphic := self graphicalMorphForTab.	self borderWidth: 0.	self removeAllMorphs.	self addMorphBack: aGraphic.	aGraphic position: self position.	aGraphic lock.	self fitContents.	self layoutChanged.	(owner isKindOf: IndexTabs) ifTrue:		[owner laySubpartsOutInOneRow.		isHighlighted ifTrue: [self highlight]].! !!SpeakerMorph methodsFor: 'speaker' stamp: 'jm 4/22/1999 13:29'!flushBuffer	| buf |	buf := buffer contents.	buffer resetContents.	sound isPlaying ifFalse: [sound := SequentialSound new].	sound add: (SampledSound samples: buf samplingRate: 11025).	sound isPlaying		ifTrue: [sound pruneFinishedSounds]		ifFalse: [sound play].! !!BookMorph methodsFor: 'menu' stamp: 'tk 1/26/1999 09:26'!getAllText	"Collect the text for each page.  Just point at strings so don't have to recopy them.  Parallel array of urls for ID of pages.	allText = Array (pages size) of arrays (fields in it) of strings of text.	allTextUrls = Array (pages size) of urls or page numbers.	For any page that is out, text data came from .bo file on server.  	Is rewritten when one or all pages are stored."	| oldUrls oldStringLists allText allTextUrls aUrl which |	oldUrls := self valueOfProperty: #allTextUrls ifAbsent: [#()].	oldStringLists := self valueOfProperty: #allText ifAbsent: [#()].	allText := pages collect: [:pg | OrderedCollection new].	allTextUrls := Array new: pages size.	pages doWithIndex: [:aPage :ind | aUrl := aPage url.  aPage isInMemory 		ifTrue: [(allText at: ind) addAll: (aPage allStringsAfter: nil).			aUrl ifNil: [aUrl := ind].			allTextUrls at: ind put: aUrl]		ifFalse: ["Order of pages on server may be different.  (later keep up to date?)"			which := oldUrls indexOf: aUrl.			allTextUrls at: ind put: aUrl.			which = 0 ifFalse: [allText at: ind put: (oldStringLists at: which)]]].	self setProperty: #allText toValue: allText.	self setProperty: #allTextUrls toValue: allTextUrls.	^ allText! !!WiWPasteUpMorph methodsFor: 'world state' stamp: 'RAA 11/23/1999 09:01'!doOneCycle	pendingEvent ifNotNil: [		self primaryHand handleEvent: (pendingEvent setHand: self primaryHand).		pendingEvent := nil.	].	^super doOneCycle.! !!FatBitsPaint methodsFor: 'events' stamp: 'sw 3/30/2002 16:47'!mouseDownSelection: evt        lastMouse := nil.        currentSelectionMorph ifNotNil: [currentSelectionMorph delete. currentSelectionMorph := nil].        selectionAnchor := self pointGriddedFromEvent: evt! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:03'!drawZoomOn: aCanvas	"Zoom in: endForm expands overlaying startForm.	Zoom out: startForm contracts revealing endForm."	| box innerForm outerForm boxExtent scale |	direction = #in		ifTrue: [innerForm := endForm.  outerForm := startForm.				boxExtent := self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm := startForm.  outerForm := endForm.				boxExtent := self stepFrom: self extent to: 0@0].	aCanvas drawImage: outerForm at: self position.	box := Rectangle center: self center extent: boxExtent.	scale := box extent asFloatPoint / bounds extent.	aCanvas drawImage: (innerForm magnify: innerForm boundingBox by: scale smoothing: 1)		at: box topLeft.	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/15/2000 21:43'!start: aNumber	start := aNumber.! !!ZASMScriptMorph methodsFor: 'layout' stamp: 'RAA 12/3/2000 09:56'!acceptDroppingMorph: aMorph event: evt	super acceptDroppingMorph: aMorph event: evt.	somethingChanged := true.	! !!Thumbnail methodsFor: 'initialization' stamp: 'sw 6/13/2001 18:17'!maxWidth: maxWidth minHeight: minHeight	"Set the min and max heights and widths as indicated"	maximumWidth := maxWidth.	minimumHeight := minHeight! !!LedTimerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:36'!initialize"initialize the state of the receiver"	super initialize.""	counting := false.	startSeconds := Time totalSeconds! !!ScreeningMorph methodsFor: 'menu' stamp: ''!showScreenOnly	displayMode := #showScreenOnly.	self changed! !!IndexTabs methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:43'!initialize	"Initialize the receiver. Make sure it is not open to drag and  	drop"	super initialize.	""	padding := 10.	verticalPadding := 4.	basicHeight := 14.	basicWidth := 200.		self enableDragNDrop: false! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'ar 11/9/2000 21:58'!initialize	| r |	super initialize.	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	borderWidth := 2.	self listDirection: #topToBottom.	recorder := SoundRecorder new.	self addButtonRows.	self addRecordLevelSlider.	r := AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!BackgroundMorph methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:06'!drawOn: aCanvas	"The tiling is solely determined by bounds, subBounds and offset.	The extent of display is determined by bounds and the clipRect of the canvas."	| start d subBnds |	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	subBnds := self subBounds.	running ifFalse:		[super drawOn: aCanvas.		^ aCanvas fillRectangle: subBnds color: Color lightBlue].	start := subBnds topLeft + offset - bounds topLeft - (1@1) \\ subBnds extent - subBnds extent + (1@1).	d := subBnds topLeft - bounds topLeft."Sensor redButtonPressed ifTrue: [self halt]."	start x to: bounds width - 1 by: subBnds width do:		[:x |		start y to: bounds height - 1 by: subBnds height do:			[:y | aCanvas translateBy: (x@y) - d clippingTo: bounds				during:[:tileCanvas| self drawSubmorphsOn: tileCanvas]]].! !!ScreeningMorph methodsFor: 'menu' stamp: 'di 6/3/1999 16:41'!choosePassingColor	passingColor := Color fromUser.	passElseBlock := true.	self layoutChanged! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/21/2000 15:57'!toggleStamps	| tab otherTab st shapes |	"The sub panel that has the stamps in it.  For saving and moving parts of an image."	shapes := self submorphNamed: 'shapes'.	otherTab := self submorphNamed: 'shapeTab'.	tab := self submorphNamed: 'stampTab'.	(st := self submorphNamed: 'stamps') visible		ifTrue: [st hide.  st bottom: self bottom.  tab top: self bottom-1.				shapes top: self bottom-9.				otherTab top: (shapes visible ifTrue: [shapes bottom - otherTab height + 10] 									ifFalse: [self bottom-1])]		ifFalse: [st top: self bottom-10.  st show.  tab top: st bottom-0.				shapes top: st bottom-9.				otherTab top: (shapes visible ifTrue: [shapes bottom - otherTab height + 10] 									ifFalse: [st bottom-0])].	self layoutChanged.! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 9/25/1999 16:15'!cutSelection        | relativeBounds |        relativeBounds := self copySelection ifNil: [^ nil].        originalForm fill: relativeBounds rule: Form over fillColor: Color transparent.        self revealPenStrokes! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 16:42'!addARow: aCollectionOfMorphs	| row |	row := self inARow: aCollectionOfMorphs.	self addMorphBack: row.	^row! !!RemoteHandMorph methodsFor: 'events-processing' stamp: 'ar 10/26/2000 01:12'!handleListenEvent: anEvent	"Transmit the event to interested listeners"	| currentExtent |	currentExtent := self worldBounds extent.	self lastWorldExtent ~= currentExtent ifTrue: [		self transmitEvent: (MorphicUnknownEvent new setType: #worldExtent argument: currentExtent).		self lastWorldExtent: currentExtent].	self transmitEvent: anEvent.! !!GraphMorph methodsFor: 'accessing' stamp: ''!cursorColor: aColor	cursorColor := aColor.	self flushCachedForm.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:06'!flipHoriz: evt 	"Flip the image"	| temp myBuff |	myBuff := self get: #buff for: evt.	temp := myBuff deepCopy flipBy: #horizontal centerAt: myBuff center.	temp offset: 0 @ 0.	paintingForm fillWithColor: Color transparent.	temp displayOn: paintingForm at: paintingForm center - myBuff center + myBuff offset.	rotationButton position: evt cursorPoint x - 6 @ rotationButton position y.	self render: bounds! !!EnvelopeLineMorph methodsFor: 'editing' stamp: 'ar 3/17/2001 14:31'!dropVertex: ix event: evt fromHandle: handle	| oldVerts |	oldVerts := vertices.	super dropVertex: ix event: evt fromHandle: handle.	vertices = oldVerts ifFalse: [owner deletePoint: ix "deleted a vertex"]! !!SimpleSliderMorph methodsFor: 'parts bin' stamp: 'sw 6/29/2001 12:24'!initializeToStandAlone	| nominalColor |	self initialize.	self beSticky.	self extent: 14@120.	nominalColor := Color r: 0.452 g: 0.645 b: 0.935.	self color: nominalColor.	self borderColor: Color veryDarkGray.	self sliderColor: nominalColor muchLighter.	self descending: true.	self setScaledValue: 0.3! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 10/29/1998 17:35'!addTabForBook: aBook withBalloonText: text	| aTab |	aTab := tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage := aBook].	text ifNotNil: [aTab setBalloonText: text].	^ aTab! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:46'!loopStart: index	| start len |	start := self fractionalLoopStartAt: index.	len := (loopEnd asFloat - start) + 1.0.	loopCycles := (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'ar 11/8/2000 22:49'!book: aBookMorph morphsToSort: morphList	| innerBounds |	book := aBookMorph.	pageHolder removeAllMorphs.	pageHolder addAllMorphs: morphList.	pageHolder extent: pageHolder width@pageHolder fullBounds height.	innerBounds := Rectangle merging: (morphList collect: [:m | m bounds]).	pageHolder extent: innerBounds extent + pageHolder borderWidth + 6.! !!PostscriptCanvas methodsFor: 'drawing-polygons' stamp: 'nk 4/1/2004 19:15'!drawPolygon: vertices color: aColor borderWidth: bw borderColor: bc 	| fillC |	fillC := self shadowColor ifNil:[aColor].	self		preserveStateDuring: [:pc | pc			 outlinePolygon: vertices;				 setLinewidth: bw;								fill: fillC				andStroke: ((bc isKindOf: Symbol)						ifTrue: [Color gray]						ifFalse: [bc])]! !!PaintBoxMorph methodsFor: 'other' stamp: 'ar 3/23/2000 14:18'!focusMorph	"Note: For backward compatibility we search the world for a SketchEditorMorph if the current focus morph is nil"	^focusMorph ifNil:[focusMorph := self world findA: SketchEditorMorph]! !!BOBTransformationMorph methodsFor: 'geometry' stamp: 'RAA 6/27/2000 12:39'!extent: aPoint	| newExtent |	newExtent := aPoint truncated.	bounds extent = newExtent ifTrue: [^self].	bounds := bounds topLeft extent: newExtent.	self recomputeExtent.! !!ScaleMorph methodsFor: 'geometry' stamp: 'RCS 3/16/2000 13:59'!extent: newExtent 	| modExtent |	modExtent := self checkExtent: newExtent.	super extent: modExtent.	self buildLabels! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'ar 10/7/2000 15:38'!morphRepresented: aMorph	morphRepresented := aMorph.	self computeThumbnail.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 12:58'!textSearch	"search the text on all pages of this book"	| wanted wants list str |	list := self valueOfProperty: #searchKey ifAbsent: [#()].	str := String streamContents: [:strm | 			list do: [:each | strm nextPutAll: each; space]].	wanted := FillInTheBlank request: 'words to search for.  Order is not important.Beginnings of words are OK.' translated		initialAnswer: str.	wants := wanted findTokens: Character separators.	wants isEmpty ifTrue: [^ self].	self getAllText.		"save in allText, allTextUrls"	^ self findText: wants	"goes to the page and highlights the text"! !!TextOnCurve methodsFor: 'access' stamp: 'jm 11/19/97 20:29'!textOwner: theCurve	curve := theCurve! !!EventRecorderMorph methodsFor: 'events-processing' stamp: 'ar 10/25/2000 21:26'!handleListenEvent: anEvent	"Record the given event"	(state == #record and:[anEvent hand == recHand]) 		ifFalse:[^self].	anEvent = lastEvent ifTrue: [^ self].	(anEvent isKeyboard and:[anEvent keyValue = 27 "esc"])		ifTrue: [^ self stop].	time := anEvent timeStamp.	tapeStream nextPut: (anEvent copy setHand: nil).	journalFile ifNotNil:		[journalFile store: anEvent; cr; flush].	lastEvent := anEvent.! !!StringButtonMorph methodsFor: 'accessing' stamp: ''!target: anObject	target := anObject! !!FatBitsPaint methodsFor: 'initialization' stamp: 'RAA 9/25/1999 15:54'!editForm: aForm        formToEdit := aForm.        brushSize := magnification := 64 // (aForm height min: aForm width) max: 4.        self revert! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 2/4/2001 11:41'!editThisThread	| sorter |	sorter := ProjectSorterMorph new.	sorter navigator: self listOfPages: listOfPages.	self currentWorld addMorphFront: sorter.	sorter align: sorter center with: self currentWorld center.	self delete.! !!MenuMorph methodsFor: '*MorphicExtras-accessing' stamp: 'sw 10/3/2002 20:11'!allWordingsNotInSubMenus: verbotenSubmenuContentsList	"Answer a collection of the wordings of all items and subitems, but omit the stay-up item, and also any items in any submenu whose tag is in verbotenSubmenuContents"	| aList |	aList := OrderedCollection new.	self items do: [:anItem | aList addAll: (anItem allWordingsNotInSubMenus: verbotenSubmenuContentsList)].	^ aList! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/24/2001 22:19'!clickFromSorterEvent: evt morph: aMorph	| where what |	(aMorph bounds containsPoint: evt cursorPoint) ifFalse: [^self].	evt isMouseUp ifFalse: [		evt shiftPressed ifFalse: [^evt hand grabMorph: aMorph].		^self	].	evt shiftPressed ifTrue: [		where := aMorph owner submorphs indexOf: aMorph ifAbsent: [nil].		what := book threadName.		WorldState addDeferredUIMessage: [			InternalThreadNavigationMorph openThreadNamed: what atIndex: where		] fixTemps.		(Project named: (aMorph valueOfProperty: #nameOfThisProject)) enter.	].! !!BookMorph methodsFor: 'menu' stamp: 'ar 4/10/2005 18:42'!saveIndexOfOnly: aPage	"Modify the index of this book on a server.  Read the index, modify the entry for just this page, and write back.  See saveIndexOnURL. (page file names must be unique even if they live in different directories.)"	| mine sf remoteFile strm remote pageURL num pre index after dict allText allTextUrls fName |	mine := self valueOfProperty: #url.	mine ifNil: [^ self saveIndexOnURL].	Cursor wait showWhile: [strm := (ServerFile new fullPath: mine)].	strm ifNil: [^ self saveIndexOnURL].	strm isString ifTrue: [^ self saveIndexOnURL].	strm exists ifFalse: [^ self saveIndexOnURL].	"write whole thing if missing"	strm := strm asStream.	strm isString ifTrue: [^ self saveIndexOnURL].	remote := strm fileInObjectAndCode.	dict := remote first.	allText := dict at: #allText ifAbsent: [nil].	"remote, not local"	allTextUrls := dict at: #allTextUrls ifAbsent: [nil].	allText size + 1 ~= remote size ifTrue: [self error: '.bo size mismatch.  Please tell Ted what you just did to this book.' translated].	(pageURL := aPage url) ifNil: [self error: 'just had one!!' translated].	fName := pageURL copyAfterLast: $/.	2 to: remote size do: [:ii | 		((remote at: ii) url findString: fName startingAt: 1 						caseSensitive: false) > 0 ifTrue: [index := ii].	"fast"		(remote at: ii) xxxReset].	index ifNil: ["new page, what existing page does it follow?"		num := self pageNumberOf: aPage.		1 to: num-1 do: [:ii | (pages at: ii) url ifNotNil: [pre := (pages at: ii) url]].		pre ifNil: [after := remote size+1]			ifNotNil: ["look for it on disk, put me after"				pre := pre copyAfterLast: $/.				2 to: remote size do: [:ii | 					((remote at: ii) url findString: pre startingAt: 1 								caseSensitive: false) > 0 ifTrue: [after := ii+1]].				after ifNil: [after := remote size+1]].		remote := remote copyReplaceFrom: after to: after-1 with: #(1).		allText ifNotNil: [			dict at: #allText put: (allText copyReplaceFrom: after-1 to: after-2 with: #(())).			dict at: #allTextUrls put: (allTextUrls copyReplaceFrom: after-1 to: after-2 with: #(()))].		index := after].	remote at: index put: (aPage sqkPage copyForSaving).	(dict at: #modTime ifAbsent: [0]) < Time totalSeconds ifTrue:		[dict at: #modTime put: Time totalSeconds].	allText ifNotNil: [		(dict at: #allText) at: index-1 put: (aPage allStringsAfter: nil).		(dict at: #allTextUrls) at: index-1 put: pageURL].	sf := ServerDirectory new fullPath: mine.	Cursor wait showWhile: [		remoteFile := sf fileNamed: mine.		remoteFile fileOutClass: nil andObject: remote.		"remoteFile close"].! !!TabMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 10:39'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.morphToInstall := morphToInstall.		"Weakly copied"! !!Morph class methodsFor: '*MorphicExtras-new-morph participation' stamp: 'sw 11/27/2001 13:20'!addPartsDescriptorQuadsTo: aList if: aBlock	"For each of the standard objects to be put into parts bins based on declarations in this class, add a parts-launching quintuplet to aList, provided that the boolean-valued-block-with-one-argument supplied evaluates to true when provided the DescriptionForPartsBin"	| info more |	(self class includesSelector: #descriptionForPartsBin) ifTrue:		[info := self descriptionForPartsBin.		(aBlock value: info) ifTrue:			[aList add:				{info globalReceiverSymbol.				info nativitySelector.				info formalName.				info documentation.				info sampleImageFormOrNil}]].	(self class includesSelector: #supplementaryPartsDescriptions)		ifTrue:			[more := self supplementaryPartsDescriptions.			(more isKindOf: DescriptionForPartsBin) ifTrue: [more := Array with: more].				"The above being a mild bit of forgiveness, so that in the usual only-one				case, the user need not return a collection"			more do:				[:aPartsDescription |  (aBlock value: aPartsDescription) ifTrue:					[aList add:						{aPartsDescription globalReceiverSymbol.						aPartsDescription nativitySelector.						aPartsDescription formalName.						aPartsDescription documentation.						aPartsDescription sampleImageFormOrNil}]]]! !!BookMorph class methodsFor: 'fileIn/Out' stamp: 'LEG 10/25/2001 00:06'!openFromFile: fullName	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world"	| book aFileStream |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream := FileStream oldFileNamed: fullName.	book := BookMorph new.	book setProperty: #url toValue: aFileStream url.	book fromRemoteStream: aFileStream.	aFileStream close.	Smalltalk isMorphic 		ifTrue: [ActiveWorld addMorphsAndModel: book]		ifFalse:			[book isMorph ifFalse: [^self inform: 'Can only load a single morphinto an mvc project via this mechanism.'].			book openInWorld].	book goToPage: 1! !!TextOnCurve methodsFor: 'as yet unclassified' stamp: 'di 11/29/97 20:15'!releaseCachedState	super releaseCachedState.	CachedWarpMap := CachedWarpDepth := CachedWarpColor := nil! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 6/17/1999 21:43'!cursorWrapped: aNumber	| sz |	cursor ~= aNumber ifTrue: [		cursor := aNumber.		sz := data size.		sz = 0			ifTrue: [cursor := 1]			ifFalse: [				((cursor >= (sz + 1)) or: [cursor < 0]) ifTrue: [					cursor := cursor - ((cursor // sz) * sz)].				cursor < 1 ifTrue: [cursor := sz + cursor]].		"assert: 1 <= cursor < data size + 1"		hasChanged := true].! !!WaveEditor methodsFor: 'initialization' stamp: 'nk 6/22/2004 16:22'!initialize	"initialize the state of the receiver"	super initialize.	""	samplingRate := SoundPlayer samplingRate.	loopEnd := loopLength := 0.	loopCycles := 1.	perceivedFrequency := 0.	"zero means unknown"	self extent: 5 @ 5;		 listDirection: #topToBottom;		 wrapCentering: #topLeft;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 3.	graph := GraphMorph new extent: 450 @ 100.	graph cursor: 0.	graph cursorColorAtZeroCrossings: Color blue.	self addControls.	self addLoopPointControls.	self addMorphBack: graph.	self		addMorphBack: (Morph				newBounds: (0 @ 0 extent: 0 @ 3)				color: Color transparent).	self addMorphBack: (keyboard := PianoKeyboardMorph new).	self sound: (SampledSound soundNamed: 'croak').! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'dao 10/1/2004 12:57'!checkForRebuild	| lastScreenMode flapsSuppressed |	lastScreenMode := ScreenController lastScreenModeSelected ifNil: [false].	flapsSuppressed := Project current flapsSuppressed.	((self valueOfProperty: #currentNavigatorVersion) = self currentNavigatorVersion			and: [lastScreenMode = self inFullScreenMode			and: [flapsSuppressed = self inFlapsSuppressedMode			and: [(self valueOfProperty: #includeSoundControlInNavigator) = 						Preferences includeSoundControlInNavigator]]]) ifFalse: [		self 			setProperty: #includeSoundControlInNavigator 			toValue: Preferences includeSoundControlInNavigator.		self setProperty: #flapsSuppressedMode toValue: flapsSuppressed.		self setProperty: #showingFullScreenMode toValue: lastScreenMode.		self setProperty: #currentNavigatorVersion toValue: self currentNavigatorVersion.		self removeAllMorphs.		self addButtons.	].! !!MultiResolutionCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 12/17/2000 13:25'!initializeFrom: aFormCanvas	origin := aFormCanvas origin.	clipRect := aFormCanvas privateClipRect.	form := aFormCanvas form.	port := aFormCanvas privatePort.	shadowColor := aFormCanvas shadowColor.! !!GeePrinter methodsFor: 'Postscript Canvases' stamp: 'RAA 5/7/2001 12:54'!doPrintToPrinter	"fileName := ('gee.',Time millisecondClockValue printString,'.eps') asFileName."	self pageRectangles.	"ensure bounds computed"	DSCPostscriptCanvasToDisk 		morphAsPostscript: self 		rotated: self printSpecs landscapeFlag		specs: self printSpecs! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 7/27/2001 16:39'!initiateSearch: morphHoldingSearchString	"Carry out the action of the Search button in the Preferences panel"	searchString := morphHoldingSearchString text.	self setSearchStringTo: self searchString.		self findPreferencesMatchingSearchString! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'yo 7/16/2003 15:10'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: aPosition	"NB: if aPosition is nil, then it's assumed that the paintbox is obtained from a flap or some such, so do nothing special regarding a palette in this case.  The palette needs already to be in the world for this to work."	| w  |	(w := aPasteUpMorph world) addMorphInLayer: self.	"in back of palette"	enclosingPasteUpMorph := aPasteUpMorph.	hostView := aSketchMorph.  "may be ownerless"	self bounds: boundsToUse.	palette := w paintBox focusMorph: self.	palette beStatic.		"give Nebraska whatever help we can"	palette fixupButtons.	palette addWeakDependent: self.	aPosition ifNotNil:		[w addMorphFront: palette.  "bring to front"		palette position: aPosition].	paintingForm := Form extent: bounds extent depth: w assuredCanvas depth.	self dimTheWindow.	self addRotationScaleHandles.	aSketchMorph ifNotNil:		[		aSketchMorph form			displayOn: paintingForm			at: (hostView boundsInWorld origin - bounds origin - hostView form offset)			clippingBox: (0@0 extent: paintingForm extent)			rule: Form over			fillColor: nil.  "assume they are the same depth".			undoBuffer := paintingForm deepCopy.		rotationCenter := aSketchMorph rotationCenter]! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 13:37'!cursorFor: anAction oldCursor: oldCursor currentNib: aNibForm color: aColor 	"Return the cursor to use with this painting action/tool. Offset of the 	form must be set."	| ff width co larger c box |	anAction == #paint:		ifTrue: ["Make a cursor from the brush and the color"			width := aNibForm width.			c := self ringColorFor: aColor.			co := oldCursor offset - (width // 4 @ 34 - (width // 6)) min: 0 @ 0.			larger := width negated + 10 @ 0 extent: oldCursor extent + (width @ width).			ff := oldCursor copy: larger.			ff colors at: 1 put: Color transparent.			ff colors at: 2 put: Color transparent.			ff offset: co - (width @ width // 2).			ff getCanvas				fillOval: (Rectangle center: ff offset negated extent: width @ width)				color: Color transparent				borderWidth: 1				borderColor: c.			^ ff].	anAction == #erase:		ifTrue: ["Make a cursor from the cursor and the color"			width := aNibForm width.			co := oldCursor offset + (width // 2 @ 4) min: 0 @ 0.			larger := 0 @ 0 extent: oldCursor extent + (width @ width).			ff := oldCursor copy: larger.			ff offset: co - (width @ width // 2).			ff				fill: (box := co negated extent: width @ width)				fillColor: (Color r: 0.5 g: 0.5 b: 1.0).			ff				fill: (box insetBy: 1 @ 1)				fillColor: Color transparent.			^ ff].	^ oldCursor! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 12:02'!saveScript	| newScript scriptName |	newScript := self compileScript.	scriptName := FillInTheBlank 		request: 'Name this script' 		initialAnswer: (self valueOfProperty: #cameraScriptName ifAbsent: ['']).	scriptName isEmptyOrNil ifTrue: [^self].	(self valueOfProperty: #cameraController)		saveScript: newScript		as: scriptName.	self delete.! !!BookMorph methodsFor: 'navigation' stamp: 'RAA 11/20/2000 12:43'!insertPageMorphInCorrectSpot: aPageMorph	self addMorphBack: (currentPage := aPageMorph).! !!SimpleSliderMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:35'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied""arguments := arguments.		All weakly copied"minVal := minVal veryDeepCopyWith: deepCopier.		"will be fast if integer"maxVal := maxVal veryDeepCopyWith: deepCopier.truncate := truncate veryDeepCopyWith: deepCopier.! !!SqueakPage methodsFor: 'private' stamp: 'jm 6/18/1998 11:31'!updateThumbnail	"Update my thumbnail from my morph."	| f scale scaleX scaleY shrunkF |	contentsMorph ifNil: [thumbnail := nil. ^ self].	f := contentsMorph imageForm.	scaleX := MaxThumbnailWidthOrHeight asFloat / f height.	scaleY := MaxThumbnailWidthOrHeight asFloat/ f width.	scale := scaleX min: scaleY.  "choose scale that maintains aspect ratio"	shrunkF := (f magnify: f boundingBox by: scale@scale smoothing: 2).	thumbnail := Form extent: shrunkF extent depth: 8.  "force depth to be 8"	shrunkF displayOn: thumbnail.	contentsMorph allMorphsDo: [:m | m releaseCachedState].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 12/19/2000 19:53'!fill: evt 	"Find the area that is the same color as where you clicked. Fill it with 	the current paint color."	| box |	evt isMouseUp		ifFalse: [^ self].	"Only fill upon mouseUp"	"would like to only invalidate the area changed, but can't find out what it is."	Cursor execute		showWhile: [			box := paintingForm				floodFill: (self getColorFor: evt)				at: evt cursorPoint - bounds origin.			self render: (box translateBy: bounds origin)]! !!GradientFillMorph methodsFor: 'initialization' stamp: 'di 1/9/98 22:17'!initialize	super initialize.	borderWidth := 0.	fillColor2 := Color black.	gradientDirection := #vertical! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 16:50'!readyToTransmit	"Return true if the receiver is ready to send."	(sendState == #connected) ifTrue:[		 sendSocket sendDone ifFalse:[^false].		^true].	sendState == #opening ifTrue:[		sendSocket isConnected ifTrue:[^true].		sendSocket isWaitingForConnection ifFalse:[			Transcript show: 'trying connection again...'; cr.			sendSocket destroy.			sendSocket := Socket new.			sendSocket connectTo: self remoteHostAddress port: 54323]].	sendState == #closing ifTrue:[		sendSocket isUnconnectedOrInvalid ifTrue:[			sendSocket destroy.			sendState := #unconnected]].	^false! !!GeePrinterPage methodsFor: 'Postscript Canvases' stamp: 'RAA 2/22/2001 09:05'!fullDrawPostscriptOn: aCanvas	| s |	s := TextMorph new 		beAllFont: (TextStyle default fontOfSize: 30);		contentsAsIs: '   Drawing page ',pageNumber printString,' of ',totalPages printString,'     '.	s layoutChanged; fullBounds.	s := AlignmentMorph newRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		addMorph: s;		color: Color yellow.	s position: Display center - (s width // 2 @ 0).	World addMorphFront: s.	World displayWorld.	printSpecs drawAsBitmapFlag ifTrue: [		aCanvas paintImage: self pageAsForm at: 0@0	] ifFalse: [		aCanvas 			translateTo: bounds origin negated 			clippingTo: (0@0 extent: bounds extent) 			during: [ :c |				pasteUp fullDrawForPrintingOn: c			].	].	s delete.! !!GeeMailMorph methodsFor: 'initialization' stamp: 'jam 3/9/2003 16:38'!initializeThePasteUp"initialize the receiver's thePasteUp"	thePasteUp := TextPlusPasteUpMorph new borderWidth: 0;				 color: color.	scroller addMorph: thePasteUp! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 11/24/1998 14:52'!generateURL	"Generate an unused URL for an in-memory page."	"SqueakPageCache generateURL"	| sd |	sd := ServerFile new on: 'file:./'.	sd fileName: 'page1.sp'.	^ SqueakPage new urlNoOverwrite: sd pathForFile! !!MailComposition methodsFor: '*MorphicExtras-interface' stamp: 'ls 10/16/1998 09:17'!openInMVC	| textView sendButton  |	mvcWindow := StandardSystemView new		label: 'Mister Postman';		minimumSize: 400@250;		model: self.	textView := PluggableTextView		on: self		text: #messageText		accept: #messageText:.	textEditor := textView controller.	sendButton := PluggableButtonView 		on: self		getState: nil		action: #submit.	sendButton label: 'Send'.	sendButton borderWidth: 1.	sendButton window: (1@1 extent: 398@38).	mvcWindow addSubView: sendButton.	textView window: (0@40 corner: 400@250).	mvcWindow addSubView: textView below: sendButton.	mvcWindow controller open.		! !!PartsBin methodsFor: 'initialization' stamp: 'nk 9/1/2004 17:28'!listDirection: aListDirection quadList: quadList	"Initialize the receiver to run horizontally or vertically, obtaining its elements from the list of tuples of the form:		(<receiver> <selector> <label> <balloonHelp>)"	| aButton aClass |	self layoutPolicy: TableLayout new.	self listDirection: aListDirection.	self wrapCentering: #topLeft.	self layoutInset: 2.	self cellPositioning: #bottomCenter.	aListDirection == #leftToRight		ifTrue:			[self vResizing: #rigid.			self hResizing: #spaceFill.			self wrapDirection: #topToBottom]		ifFalse:			[self hResizing: #rigid.			self vResizing: #spaceFill.			self wrapDirection: #leftToRight].	quadList do:		[:tuple |			aClass := Smalltalk at: tuple first.			aButton := IconicButton new initializeWithThumbnail: (self class thumbnailForQuad: tuple color: self color) withLabel: tuple third andColor: self color andSend: tuple second to: aClass.			(tuple size > 3 and: [tuple fourth isEmptyOrNil not]) ifTrue:				[aButton setBalloonText: tuple fourth]. 			self addMorphBack: aButton]! !!TickIndicatorMorph methodsFor: 'private' stamp: 'ar 2/11/2001 19:22'!privateMoveBy: delta	corners := nil.	super privateMoveBy: delta! !!PinMorph methodsFor: 'geometry' stamp: 'di 1/18/2000 12:31'!placeFromSpec	| side corners c1 c2 |	side := pinSpec pinLoc asInteger.  "1..4 ccw from left"	corners := owner bounds corners.	c1 := corners at: side.	c2 := corners atWrap: side+1.	self position: (c1 + (c2 - c1 * pinSpec pinLoc fractionPart)).	self updateImage.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:20'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	self getAllText.	"stored with index later"	response := (PopUpMenu labels: 'Use page numbersType in file namesSave in a new place (using page numbers)Save in a new place (typing names)Save new book sharing old pages' translated)			startUpWithCaption: 'Each page will be a file on the server.  Do you want to page numbers be the names of the files? or name each one yourself?' translated.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 5 ifTrue: [		"Make up new url for .bo file and confirm with user."  "Mark as shared"		[rand := String new: 4.		1 to: rand size do: [:ii |			rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].		(newPlace := self getStemUrl) isEmpty ifTrue: [^ self].		newPlace := (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.		dir := ServerFile new fullPath: newPlace.		(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"		self setProperty: #url toValue: newPlace.		self saveAsNumberedURLs. 		bookUrl := self valueOfProperty: #url.		(SqueakPage stemUrl: bookUrl) = 			(SqueakPage stemUrl: currentPage url) ifTrue: [				bookUrl := true].		"not a shared book"		(URLMorph grabURL: currentPage url) book: bookUrl.		^ self].	response = 0 ifTrue: [^ self]."self reserveUrlsIfNeeded.	Need two passes here -- name on one, write on second"pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURLbasic.		]].	"ask user if no url"list := pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list := (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime := (self valueOfProperty: #url) isNil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	URLMorph grabForBook: self.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!ZoomAndScrollMorph methodsFor: 'stepping and presenter' stamp: 'RAA 12/5/2000 18:31'!step	| innerPasteUp overlap |	innerPasteUp := self myTransformMorph firstSubmorph.	overlap := (innerPasteUp submorphs 		inject: 0@0 		into: [ :min :each | min min: each position]) rounded.	overlap = (0@0) ifFalse: [		innerPasteUp submorphs do: [ :each | each position: each position - overlap].		innerPasteUp layoutChanged.	].! !!FrameRateMorph class methodsFor: 'scripting' stamp: 'sw 6/13/2001 00:57'!authoringPrototype	"Answer a morph representing a prototypical instance of the receiver"	| aMorph |	aMorph := self new.	aMorph color: Color blue.	aMorph step.	^ aMorph! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector := aSelector! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/26/1999 22:39'!forgetURLs	"About to save these objects in a new place.  Forget where stored now.  Must bring in all pages we don't have."| pg |pages do: [:aPage |	aPage yourself.	"bring it into memory"	(pg := aPage valueOfProperty: #SqueakPage) ifNotNil: [		SqueakPageCache removeURL: pg url.		pg contentsMorph setProperty: #SqueakPage toValue: nil]].self setProperty: #url toValue: nil.! !!FatBitsPaint methodsFor: 'menu' stamp: 'bf 1/5/2000 18:48'!fill	| fillPt |	Cursor blank show.	Cursor crossHair showWhile:		[fillPt := Sensor waitButton - self position].	originalForm shapeFill: brushColor interiorPoint: fillPt.	self changed.! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/25/1999 16:11'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	lastIndex = line last ifTrue: [^true].	runX := destX.	runLength := text runLengthFor: (lastIndex := lastIndex + 1).	runStopIndex := lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ar 12/15/2001 23:28'!tab	destX := (alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastIndex := lastIndex + 1.	^ false! !!PaintBoxColorPicker methodsFor: 'initialization' stamp: 'jm 4/29/1998 21:24'!initialize	super initialize.	currentColor := Color black.	locOfCurrent := nil.	self initMouseHandlers.! !!PostscriptCharacterScanner methodsFor: 'textstyle support' stamp: ''!textColor: aColor	foregroundColor := aColor.! !!TextPlusMorph methodsFor: 'event handling' stamp: 'ag 8/19/2004 04:53'!keyboardFocusChange: aBoolean	| parent |	"we basically ignore loss of focus unless it is going to one of our siblings"	aBoolean ifFalse: [^self].	paragraph isNil ifFalse:[paragraph focused: aBoolean].	"A hand is wanting to send us characters..."	self hasFocus ifFalse: [self editor "Forces install"].	"Inform our siblings we have taken the focus"	parent := self parentGeeMail ifNil: [^self].	parent allTextPlusMorphs do: [ :each |		each == self ifFalse: [each keyboardFocusLostForSure]	].! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/18/2000 15:30'!doProgrammedMoves	| thisMove startPoint endPoint startZoom endZoom newScale newPoint fractionLeft |	programmedMoves isEmptyOrNil ifTrue: [		^programmedMoves := nil	].	thisMove := programmedMoves first.	thisMove at: #pauseTime ifPresent: [ :ignore | ^self].	fractionLeft := self fractionLeftInMove: thisMove.	fractionLeft ifNil: [^programmedMoves := programmedMoves allButFirst].	startPoint := thisMove at: #startPoint ifAbsentPut: [self cameraPoint].	endPoint := thisMove at: #endPoint ifAbsentPut: [self cameraPoint].	startZoom := thisMove at: #startZoom ifAbsentPut: [self cameraScale].	endZoom := thisMove at: #endZoom ifAbsentPut: [self cameraScale].	newScale := endZoom - (endZoom - startZoom * fractionLeft).	newPoint := (endPoint - (endPoint - startPoint * fractionLeft)) "rounded".	target changeScaleTo: newScale.	target cameraPoint: newPoint.	fractionLeft <= 0 ifTrue: [^programmedMoves := programmedMoves allButFirst].! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!reset	"Reset my internal state for a replay."	seqSound := self buildSound reset.	samplesUntilNextControl := (self samplingRate // self controlRate).	controlIndex := 0.	self positionCursor! !!MagnifierMorph methodsFor: 'initialization' stamp: 'nk 3/6/2004 10:47'!initialize	"initialize the state of the receiver"	super initialize.	trackPointer := true.	showPointer := false.	magnification := 2.	self extent: 128 @ 128! !!NewWorldWindow methodsFor: 'initialization' stamp: 'ar 5/11/2001 23:48'!openInWorld: aWorld	| xxx |	"This msg and its callees result in the window being activeOnlyOnTop"	xxx := RealEstateAgent initialFrameFor: self world: aWorld.	"Bob say: 'opening in ',xxx printString,' out of ',aWorld bounds printString.	6 timesRepeat: [Display flash: xxx andWait: 300]."	self bounds: xxx.	^self openAsIsIn: aWorld.! !!GeeBookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:10'!initialize	"initialize the state of the receiver"	super initialize.	""	newPagePrototype := GeeBookPageMorph new extent: Display extent // 3 ! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'ar 11/9/2000 21:10'!inAColumn: aCollectionOfMorphs	| col |	col := AlignmentMorph newColumn		color: Color transparent;		vResizing: #shrinkWrap;		layoutInset: 1;		wrapCentering: #center;		cellPositioning: #topCenter.	aCollectionOfMorphs do: [ :each | col addMorphBack: each].	^col! !!Flaps class methodsFor: 'predefined flaps' stamp: 'edc 6/19/2008 07:14'!newSuppliesFlapFromQuads: quads positioning: positionSymbol	"Answer a fully-instantiated flap named 'Supplies' to be placed at the bottom of the screen.  Use #center as the positionSymbol to have it centered at the bottom of the screen, or #right to have it placed off near the right edge."	|  aFlapTab aStrip hPosition |	aStrip _ PartsBin newPartsBinWithOrientation: #leftToRight andColor: Color red muchLighter from:	 quads.	"self twiddleSuppliesButtonsIn: aStrip."	aFlapTab _ FlapTab new referent: aStrip beSticky.	aFlapTab setName: 'Supplies' translated edge: #bottom color: Color red lighter.	hPosition _ positionSymbol == #center		ifTrue:			[(Display width // 2) - (aFlapTab width // 2)]		ifFalse:			[Display width - (aFlapTab width + 22)].	aFlapTab position: (hPosition @ (self currentWorld height - aFlapTab height)).	aFlapTab setBalloonText: aFlapTab balloonTextForFlapsMenu.	aStrip extent: self currentWorld width @ 136.	aStrip beFlap: true.	aStrip autoLineLayout: true.		^ aFlapTab"Flaps replaceGlobalFlapwithID: 'Supplies' translated"! !!SketchEditorMorph methodsFor: 'access' stamp: ''!ticksToDwell: t	ticksToDwell := t! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'yo 11/4/2002 21:20'!loadOffForm: pic16Bit 	"Prototype loadOffForm: (Smalltalk imageImports at: #offPaletteJapanese)"	| blt |	OriginalBounds := pic16Bit boundingBox.	AllOffImage := Form extent: OriginalBounds extent depth: 16.	blt := BitBlt current toForm: AllOffImage.	blt sourceForm: pic16Bit;		 combinationRule: Form over;		 sourceRect: OriginalBounds;		 destOrigin: 0 @ 0;		 copyBits.	AllOffImage mapColor: Color blue to: Color transparent.	self image: AllOffImage.	AllOffImage := nil.	self invalidRect: bounds! !!InternalThreadNavigationMorph methodsFor: 'sorting' stamp: 'RAA 2/4/2001 09:38'!makeThumbnailForPageNumber: pageNumber scaledToSize: sz default: aString	| cachedData proj tn label |	cachedData := listOfPages at: pageNumber.	proj := Project named: cachedData first.	(proj isNil or: [proj thumbnail isNil]) ifTrue: [		cachedData size >= 2 ifTrue: [^cachedData second].		tn := Form extent: sz depth: 8.		tn fillColor: Color veryLightGray.		label := (StringMorph contents: aString) imageForm.		label displayOn: tn at: tn center - (label extent // 2) rule: Form paint.		^tn	].	tn := proj thumbnail  scaledToSize: sz.	cachedData size < 2 ifTrue: [		cachedData := cachedData,#(0).		listOfPages at: pageNumber put: cachedData.	].	cachedData at: 2 put: tn.	^tn! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/18/2000 15:38'!resumeProgrammedMoves	| thisStep |	programmedMoves isEmptyOrNil ifTrue: [^self].	(thisStep := programmedMoves first)		at: #pauseTime		ifPresent: [ :pauseTime |			thisStep 				at: #startTime 				put: (thisStep at: #startTime) + Time millisecondClockValue - pauseTime.			thisStep removeKey: #pauseTime ifAbsent: [].		].! !!ReferenceMorph methodsFor: 'events' stamp: 'nb 6/17/2003 12:25'!tabSelected	"Called when the receiver is hit.  First, bulletproof against someone having taken the structure apart.  My own action basically requires that my grand-owner be a TabbedPalette.  Note that the 'opening' script concept has been left behind here."	| gramps |	(owner isKindOf: IndexTabs) ifFalse: [^ Beeper beep].	((gramps := owner owner) isKindOf: TabbedPalette)  ifTrue:		[gramps selectTab: self]! !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/6/1999 19:35'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.page := deepCopier references at: page ifAbsent: [page].bookMorph := deepCopier references at: bookMorph ifAbsent: [bookMorph].! !!MorphThumbnail methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:51'!initialize	"initialize the state of the receiver"	| f |	super initialize.	""	f := Form extent: 60 @ 80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!PaintBoxColorPicker methodsFor: 'accessing' stamp: 'jm 4/29/1998 20:18'!currentColor: aColor	"Force me to select the given color."	currentColor := aColor.	locOfCurrent := nil.  "remove the marker"! !!PostscriptEncoder class methodsFor: 'configuring' stamp: 'RAA 9/19/2000 23:07'!clearCharacterMappings	MacToPSCharacterMappings := nil.! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 7/27/2001 23:11'!searchString	"Answer the current searchString, initializing it if need be"	 | win aMorph |searchString isEmptyOrNil ifTrue: 		[searchString := 'Type here, hit Search'.		(win := self containingWindow) ifNotNil:			[aMorph := win findDeepSubmorphThat:					[:m | m isKindOf: PluggableTextMorph]				ifAbsent: [^ searchString].			aMorph setText: searchString.			aMorph setTextMorphToSelectAllOnMouseEnter.			aMorph selectAll]].	^ searchString! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:39'!playLoop	| sz i1 i2 snd len |	sz := graph data size.	i1 := ((loopEnd - loopLength) truncated min: sz) max: 1.	i2 := (loopEnd min: sz) max: i1.	len := (i2 - i1) + 1.	len < 2 ifTrue: [^ self].	snd := LoopedSampledSound new		samples: (graph data copyFrom: i1 to: i2)		loopEnd: len		loopLength: loopLength		pitch: 100.0		samplingRate: samplingRate.	"sustain for the longer of four loops or two seconds"	snd setPitch: 100.0		dur: (((4.0 * loopLength) / samplingRate) max: 2.0)		loudness: 0.5.	snd play.! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/27/2000 12:39'!recomputeExtent	| scalePt newScale theGreenThingie greenIBE myNewExtent |	submorphs isEmpty ifTrue: [^self extent].	worldBoundsToShow ifNil: [worldBoundsToShow := self firstSubmorph bounds].	worldBoundsToShow area = 0 ifTrue: [^self extent].	scalePt := owner innerBounds extent / worldBoundsToShow extent.	newScale := scalePt x min: scalePt y.	theGreenThingie := owner.	greenIBE := theGreenThingie innerBounds extent.	myNewExtent := (greenIBE min: worldBoundsToShow extent * newScale) truncated.	self		scale: newScale;		offset: worldBoundsToShow origin * newScale.	smoothing := (newScale < 1.0) ifTrue: [2] ifFalse: [1].	^myNewExtent! !!ThumbnailMorph methodsFor: 'drawing' stamp: 'ar 10/26/2000 23:45'!drawOn: aCanvas	"Draw a small view of a morph in another place. Guard against infinite recursion if that morph has a thumbnail of itself inside."	| time |	time := Time millisecondClockValue.	self drawMeOn: aCanvas.	drawTime := Time millisecondClockValue - time.	drawTime < 0 ifTrue:[drawTime := nil].! !!ScaleMorph methodsFor: 'geometry' stamp: 'RCS 3/16/2000 13:58'!checkExtent: newExtent 	| pixPerTick newWidth |	pixPerTick := newExtent x - (self borderWidth * 2) - 1 / ((stop - start) asFloat / minorTick).	pixPerTick := pixPerTick				detentBy: 0.1				atMultiplesOf: 1.0				snap: false.	newWidth := pixPerTick * ((stop - start) asFloat / minorTick) + (self borderWidth * 2) + 1.	^ (newWidth @ newExtent y).! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/13/2000 12:18'!addJumpEnd	| ed attribute jumpLabel selectedString |	ed := self editor.	selectedString := ed selection asString.	selectedString isEmpty ifTrue: [^self inform: 'Please select something first'].	jumpLabel := FillInTheBlank request: 'Name this place' initialAnswer: selectedString.	jumpLabel isEmpty ifTrue: [^self].	self removeJumpEndFor: jumpLabel.	attribute := TextPlusJumpEnd new jumpLabel: jumpLabel.	ed replaceSelectionWith: (ed selection addAttribute: attribute).! !!FlexMorph methodsFor: 'drawing' stamp: 'di 1/11/1999 20:54'!drawOn: aCanvas	originalForm := nil.  "Aggressively uncache the originalForm"	^ super drawOn: aCanvas! !!EventRecorderMorph class methodsFor: 'instance creation' stamp: 'edc 5/29/2006 08:35'!fromFileNamed: aFileName	| file answer |	file := FileStream readOnlyFileNamed: aFileName.	answer := self readFrom: file setConverterForCode.	file close.	^ answer! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 1/31/98 16:49'!readFileNamed: fileName	| snd |	snd := Compiler evaluate:		(FileStream readOnlyFileNamed: fileName) contentsOfEntireFile.	soundName := fileName copyFrom: 1 to: fileName size-4. "---.fmp"	self editSound: snd! !!DropDownChoiceMorph methodsFor: 'event handling' stamp: 'bolot 11/2/1999 12:22'!mouseDown: evt	| menu selectedItem |	self items isEmpty ifTrue: [^ self].	menu := CustomMenu new.	self items do: [:item | menu add: item action: item].	selectedItem := menu startUp.	selectedItem ifNil: [^ self].	self contentsClipped: selectedItem.  "Client can override this if necess"	actionSelector ifNotNil: [		target			perform: actionSelector			withArguments: (arguments copyWith: selectedItem)].! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit: anInteger	digit := anInteger \\ 10	"make sure it stays between 0 and 9"! !!ObjectsTool methodsFor: 'search' stamp: 'nk 9/3/2004 12:13'!showSearchPane	"Set the receiver up so that it shows the search pane"	| tabsPane aPane frame |	modeSymbol == #search ifTrue: [ ^self ].	self partsBin removeAllMorphs.	tabsPane := self tabsPane.	aPane := self newSearchPane.	aPane layoutChanged; fullBounds.	aPane layoutFrame: (frame := tabsPane layoutFrame copy).	frame bottomOffset: (frame topOffset + aPane height).	self replaceSubmorph: tabsPane by: aPane.	self partsBin layoutFrame topOffset: frame bottomOffset.	self modeSymbol: #search.	self showMorphsMatchingSearchString.	ActiveHand newKeyboardFocus: aPane! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 9/21/1999 12:27'!magnification: aNumber	| c |  	magnification := aNumber min: 8 max: 0.5.	magnification := magnification roundTo:		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).	srcExtent := srcExtent min: (512@512) // magnification. "to prevent accidents"	c := self center.	super extent: self defaultExtent.	self center: c.! !!RecordingControlsMorph methodsFor: 'copying' stamp: 'jm 10/17/97 15:17'!updateReferencesUsing: aDictionary	"Copy my recorder."	super updateReferencesUsing: aDictionary.	recorder := SoundRecorder new.! !!FunctionComponent methodsFor: 'components' stamp: 'di 5/3/1998 16:14'!initPinSpecs 	pinSpecs := Array		with: (PinSpec new pinName: 'output' direction: #output				localReadSelector: nil localWriteSelector: nil				modelReadSelector: nil modelWriteSelector: nil				defaultValue: nil pinLoc: 3.5)		with: (PinSpec new pinName: 'a' direction: #input				localReadSelector: nil localWriteSelector: nil				modelReadSelector: nil modelWriteSelector: nil				defaultValue: nil pinLoc: 1.5)! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 10/24/2000 14:34'!stopTransmittingEvents	"Stop broadcasting events from this world's cursor to a remote cursor on the host with the given address. This method issues a 'close' but does not destroy the socket; it will be destroyed when the other end reads the last data and closes the connection."	(sendSocket isUnconnectedOrInvalid) ifFalse:[		sendSocket close.		sendState := #closing].	owner primaryHand removeEventListener: self.! !!TwoWayScrollPane methodsFor: 'initialization' stamp: 'jam 3/9/2003 17:53'!createScroller"create a scroller"	| result |	result := TransformMorph new color: Color transparent.	result offset: 0 @ 0.	^ result! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/8/2000 14:41'!methodHolders	| all |	"search for all scripts that are in MethodHolders.  These are the ones that have versions."	all := IdentitySet new.	self allMorphsAndBookPagesInto: all.	all := all select: [:mm | mm class = MethodMorph].	MethodHolders := all asArray collect: [:mm | mm model].! !!GraphicalDictionaryMenu class methodsFor: 'example' stamp: 'sd 5/11/2003 20:53'!example	"GraphicalDictionaryMenu example"	| aDict |	aDict := Dictionary new.	#('ColorTilesOff' 'ColorTilesOn' 'Controls') do:		[:aString | aDict at: aString put: (ScriptingSystem formAtKey: aString)].	self openOn: aDict withLabel: 'Testing One Two Three'! !!PinSpec methodsFor: 'initialization' stamp: 'di 5/1/1998 13:38'!pinName: a direction: b localReadSelector: c localWriteSelector: d modelReadSelector: e modelWriteSelector: f defaultValue: g pinLoc: h	pinName := a.	direction := b.	localReadSelector := c.	localWriteSelector := d.	modelReadSelector := e.	modelWriteSelector := f.	defaultValue := g.	pinLoc := h! !!ClockMorph methodsFor: 'seconds' stamp: 'sw 2/17/1999 14:39'!showSeconds: aBoolean	showSeconds := aBoolean! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 10/10/2000 16:29'!polyFreeze	"A live polygon is on the painting.  Draw it into the painting anddelete it."	| poly |	self polyEditing ifFalse:[^self].	(poly := self valueOfProperty: #polygon) ifNil: [^ self].	poly drawOn: formCanvas.	poly delete.	self setProperty: #polygon toValue: nil.	self polyEditing: false.! !!ProjectNavigationMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 1/9/2001 07:47'!justDroppedInto: aMorph event: anEvent	self setProperty: #stickToTop toValue: nil.	self positionVertically.	LastManualPlacement := {self position. self valueOfProperty: #stickToTop}.	super justDroppedInto: aMorph event: anEvent.	self step! !!PostscriptCharacterScanner methodsFor: 'textstyle support' stamp: 'RAA 5/8/2001 10:01'!addEmphasis: emphasisCode	emphasis := emphasis bitOr: emphasisCode.! !!GraphMorph methodsFor: 'commands' stamp: 'jm 7/30/1998 12:17'!centerCursor	"Scroll so that the cursor is as close as possible to the center of my window."	| w |	w := self width - (2 * borderWidth).	self startIndex: ((cursor - (w // 2)) max: 1).! !!ProjectNavigationMorph methodsFor: 'accessing' stamp: 'RAA 7/5/2000 16:24'!color: newColor	| buttonColor |	super color: newColor.	buttonColor := color darker.	self submorphsDo: [:m | m submorphsDo: [:n | n color: buttonColor]]! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 10/11/97 10:21'!stampButtons: anArray	"Pop in a new list of buttons that are the tools for stamping.  Left to right"	stampButtons := anArray.	self clear.! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'ar 10/10/2000 17:30'!set: aSymbol for: anEventOrHand to: anObject	| valuesForHand |	valuesForHand := self valuesForHand: anEventOrHand.	aSymbol == #action ifTrue: [		valuesForHand at: #priorAction put: (valuesForHand at: #action ifAbsent: [#paint:]).		(anObject ~~ #polygon: and:[self polyEditing]) ifTrue:[self polyFreeze].	].	valuesForHand at: aSymbol put: anObject.	^anObject! !!TextPlusPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 5/3/2001 17:22'!initialize	super initialize.	showPageBreaks := true.	self addMorphBack: (TextPlusMorph new position: 4@4).! !!CommandHistory methodsFor: 'undo' stamp: 'di 12/12/2000 10:16'!rememberCommand: aCommand	"Make the supplied command be the 'LastCommand', and mark it 'done'"	| currentCommandIndex |	Preferences useUndo ifFalse: [^ self].  "Command initialize"	Preferences infiniteUndo ifTrue:		[currentCommandIndex := history indexOf: lastCommand.		((currentCommandIndex < history size) and: [Preferences preserveCommandExcursions]) ifTrue:			[excursions add: (history copyFrom: (currentCommandIndex to: history size)).			history := history copyFrom: 1 to: currentCommandIndex].		history addLast: aCommand].	lastCommand := aCommand.	lastCommand phase: #done.! !!GeeMailMorph methodsFor: 'scroll bar events' stamp: 'nk 4/28/2004 10:22'!scrollBarValue: scrollValue	| newPt pageBreaks topOfPage |	scroller hasSubmorphs ifFalse: [^ self].	newPt := -3 @ (self vLeftoverScrollRange * scrollValue).	pageBreaks := self valueOfProperty: #pageBreakRectangles ifAbsent: [#()].	pageBreaks isEmpty ifTrue: [		^scroller offset: newPt.	].	topOfPage := pageBreaks inject: (0@0 corner: 0@0) into: [ :closest :each |		(each bottom - newPt y) abs < (closest bottom - newPt y) abs ifTrue: [			each 		] ifFalse: [			closest 		].	].	topOfPage ifNotNil: [		newPt := newPt x @ topOfPage bottom.		scrollBar value: newPt y / self vLeftoverScrollRange.	].	scroller offset: newPt.! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!argument: anObject	argument := anObject! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/3/2001 17:46'!keyboardFocusLostForSure	editor ifNotNil: [		self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor := nil	].! !!BookMorph methodsFor: 'submorphs-add/remove' stamp: 'tk 12/15/1998 14:32'!abandon	"Like delete, but we really intend not to use this morph again.  Make the page cache release the page object."	| pg |	self delete.	pages do: [:aPage |		(pg := aPage sqkPage) ifNotNil: [			pg contentsMorph == aPage ifTrue: [					pg contentsMorph: nil]]].! !!PaintBoxColorPicker methodsFor: 'initialization' stamp: 'RAA 8/15/2000 14:57'!beStatic	"an aid for Nebraska: make the color chart a static image to reduce traffic"	image isStatic ifFalse: [		image := image as: StaticForm	].! !!InternalThreadNavigationMorph class methodsFor: 'known threads' stamp: 'RAA 11/9/2000 15:53'!knownThreads	^KnownThreads ifNil: [KnownThreads := Dictionary new].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/17/2000 17:06'!currentColor: aColor evt: evt	"Accept a color from the outside.  (my colorMemoryMorph must call takeColorEvt: evt from: colorPicker instead)"	currentColor := aColor.	colorMemory currentColor: aColor.	self notifyWeakDependentsWith: {#currentColor. evt. currentColor}.	self showColor.	self colorable ifFalse: [self setAction: #paint: evt: evt].	"User now thinking of painting"! !!InternalThreadNavigationMorph class methodsFor: 'known threads' stamp: 'tetha 4/18/2005 01:38'!clearKnownThreads	KnownThreads := nil! !!PrintComponent methodsFor: 'components' stamp: 'di 5/1/1998 13:39'!initPinSpecs 	pinSpecs := Array		with: (PinSpec new pinName: 'value' direction: #inputOutput				localReadSelector: nil localWriteSelector: nil				modelReadSelector: getTextSelector modelWriteSelector: setTextSelector				defaultValue: nil pinLoc: 1.5)! !!MagnifierMorph methodsFor: 'accessing' stamp: 'bf 9/21/1999 09:31'!borderWidth: anInteger	"Grow outwards preserving innerBounds"	| c |  	c := self center.	super borderWidth: anInteger.	super extent: self defaultExtent.	self center: c.! !!FlexMorph methodsFor: 'accessing' stamp: 'di 1/11/1999 21:43'!borderColor: aColor	borderColor := aColor.	self updateFromOriginal! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:34'!targetScriptDictionary	| scriptDict |	target ifNil: [^Dictionary new].	^target 		valueOfProperty: #namedCameraScripts 		ifAbsent: [			scriptDict := Dictionary new.			target setProperty: #namedCameraScripts toValue: scriptDict.			scriptDict		].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:42'!setMinVal	| newMinVal |	newMinVal := FillInTheBlank		request: 'Minimum value?'		initialAnswer: minVal printString.	newMinVal isEmpty ifFalse: [		minVal := newMinVal asNumber.		maxVal := maxVal max: minVal].! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'RAA 6/14/2001 16:52'!addButtons	| r b |	caption ifNotNil: ["Special setup for play-only interface"		(r := self makeARowForButtons)			addMorphBack: (SimpleButtonMorph new target: self;	 							label: caption; actionSelector: #play);			addMorphBack: self makeASpacer;			addMorphBack: self makeStatusLight;			addMorphBack: self makeASpacer.		^ self addMorphBack: r	].	(r := self makeARowForButtons)		addMorphBack: (b := self buttonFor: {#record. nil. 'Begin recording'});		addMorphBack: self makeASpacer;		addMorphBack: (self buttonFor: {#stop. b width. 'Stop recording - you can also use the ESC key to stop it'});		addMorphBack: self makeASpacer;		addMorphBack: (self buttonFor: {#play. b width. 'Play current recording'}).	self addMorphBack: r.	(r := self makeARowForButtons)		addMorphBack: (b := self buttonFor: {#writeTape. nil. 'Save current recording on disk'});		addMorphBack: self makeASpacer;		addMorphBack: (self buttonFor: {#readTape. b width. 'Get a new recording from disk'}).	self addMorphBack: r.	(r := self makeARowForButtons)		addMorphBack: (b := self buttonFor: {#shrink. nil. 'Make recording shorter by removing unneeded events'});		addMorphBack: self makeASpacer;		addMorphBack: self makeStatusLight;		addMorphBack: self makeASpacer;		addMorphBack: (self buttonFor: {#button. b width. 'Make a simple button to play this recording'}).	self addMorph: r.	self setStatusLight: #ready.! !!Component methodsFor: 'drag and drop' stamp: 'ar 10/5/2000 20:03'!justDroppedInto: aMorph event: anEvent	| theModel |	theModel := aMorph model.	((aMorph isKindOf: ComponentLayout) 		and: [theModel isKindOf: Component]) ifFalse:		["Disconnect prior to removal by move"		(theModel isKindOf: Component) ifTrue: [self unwire.  model := nil].		^ super justDroppedInto: aMorph event: anEvent].	theModel == model ifTrue: [^ self  "Presumably just a move"].	self initComponentIn: aMorph.	super justDroppedInto: aMorph event: anEvent.! !!PostscriptCanvas methodsFor: 'private' stamp: 'nk 1/2/2004 16:18'!drawPages:collectionOfPages	collectionOfPages do:[ :page |		pages := pages + 1.		target print:'%%Page: '; write:pages; space; write:pages; cr.		self drawPage:page.	].	morphLevel = 0 ifTrue: [ self writeTrailer: pages ].! !!CommandHistory methodsFor: 'called from the ui' stamp: 'nb 6/17/2003 12:25'!undoOrRedoCommand	"This gives a feature comparable to standard Mac undo/redo.  If the undo/redo action taken was a simple do or a redo, then undo it.  But if the last undo/redo action taken was an undo, then redo it."	"Command undoOrRedoCommand"	| aPhase |	lastCommand ifNil: [^ Beeper beep].	(aPhase := lastCommand phase) == #done		ifTrue:			[lastCommand undoCommand.			lastCommand phase: #undone]		ifFalse:			[aPhase == #undone				ifTrue:					[lastCommand redoCommand.					lastCommand phase: #done]]! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawSlideAwayOn: aCanvas	"startMorph slides away in the given direction, revealing up the endMorph."	| startLoc moveRect |	startLoc := self stepFrom: self position to: self position + (self extent * direction).	moveRect := startForm boundingBox translateBy: startLoc.	aCanvas drawImage: endForm at: self position.	aCanvas drawImage: startForm at: startLoc.	((moveRect translateBy: direction negated) areasOutside: moveRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/2/2004 01:27'!fontsForComicPlain	| d |	"Bold = 1, Ital = 2, Under = 4, Narrow = 8, Struckout = 16""how do we do underlined??"	d := Dictionary new.	d		at: 0 put: #('Helvetica-Narrow' 0.9);		at: 1 put: #('Helvetica-Narrow-Bold' 0.9);		at: 2 put: #('Helvetica-Narrow-Oblique' 0.9);		at: 3 put: #('Helvetica-Narrow-BoldOblique' 0.9).	^d! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:31'!offsetY: aNumber	| transform |	transform := self myTransformMorph.	transform offset: transform offset x @ aNumber! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/29/1999 20:13'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount).	lastIndex := lastIndex + 1.	^ false! !!LedTimerMorph methodsFor: 'accessing' stamp: 'djp 10/23/1999 21:46'!reset	startSeconds := Time totalSeconds.	self value: 0.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:03'!bookmarkForThisPage	"If this book exists on a server, make the reference via a URL"	| bb url um |	(url := self url) ifNil: [		bb := SimpleButtonMorph new target: self.		bb actionSelector: #goToPageMorph:fromBookmark:.		bb label: 'Bookmark' translated.		bb arguments: (Array with: currentPage with: bb).		self primaryHand attachMorph: bb.		^ bb].	currentPage url ifNil: [currentPage saveOnURLbasic].	um := URLMorph newForURL: currentPage url.	um setURL: currentPage url page: currentPage sqkPage.	(SqueakPage stemUrl: url) = (SqueakPage stemUrl: currentPage url) 		ifTrue: [um book: true]		ifFalse: [um book: url].  	"remember which book"	um isBookmark: true; label: 'Bookmark' translated.	um borderWidth: 1; borderColor: #raised.	um color: (Color r: 0.4 g: 0.8 b: 0.6).	self primaryHand attachMorph: um.	^ um! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 14:04'!stampFormFor: aButton	| which |	which := stampButtons indexOf: aButton ifAbsent: [1].	^ stamps atWrap: which+start-1! !!ThumbnailMorph class methodsFor: 'class initialization' stamp: 'sw 12/30/2004 00:47'!initialize	"Initialize the class variables of ThumbnailMorph"	RecursionMax := 2.	RecursionDepth := 0.	EccentricityThreshhold :=  Float pi"ThumbnailMorph initialize"! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 1/14/1999 23:50'!url: aString	| sd |	aString isEmpty ifTrue: [url := nil. ^ self].	"Expand ./ and store as an absolute url"	sd := ServerFile new.	sd fullPath: aString.	url := sd realUrl.! !!FatBitsPaint methodsFor: 'events' stamp: 'sw 3/30/2002 16:47'!mouseDownDefault: evt	lastMouse := nil.	formToEdit depth = 1 ifTrue:		[self brushColor: (originalForm colorAt: (self pointGriddedFromEvent: evt)) negated]! !!ZoomAndScrollControllerMorph methodsFor: 'event handling' stamp: 'RAA 12/2/2000 14:22'!keyDown: anEvent	changeKeysState ifNotNil: [		upDownCodes at: anEvent keyValue put: changeKeysState first.		changeKeysState := changeKeysState allButFirst.		changeKeysState isEmpty ifTrue: [changeKeysState := nil].		currentKeyDown := Set new.		^self changed	].	currentKeyDown add: anEvent keyValue.! !!GeeMailMorph methodsFor: 'menu' stamp: 'RAA 5/3/2001 17:50'!getMenu: shiftKeyState	| menu |	self flag: #convertToBook.	"<-- no longer used"	menu := MenuMorph new defaultTarget: self.	self addGeeMailMenuItemsTo: menu.	^menu! !!SimpleSliderMorph class methodsFor: 'scripting' stamp: 'sw 3/10/2000 13:45'!authoringPrototype	| aSlider nominalColor |	"self currentHand attachMorph: SimpleSliderMorph authoringPrototype"	aSlider := super authoringPrototype beSticky.	aSlider extent: 14@120.	nominalColor := Color r: 0.4 g: 0.86 b: 0.7.	aSlider color: nominalColor.	aSlider sliderColor: nominalColor muchLighter.	aSlider descending: true.	aSlider setScaledValue: 0.3.	^ aSlider! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/14/2000 10:48'!myWorldChanged	| trans |	trans := self myTransformation.	self changed.	self layoutChanged.	trans ifNotNil:[		trans extentFromParent: self innerBounds extent.		bounds := bounds topLeft extent: trans extent + (borderWidth * 2).	].	self changed.! !!MagnifierMorph methodsFor: 'geometry' stamp: 'bf 9/21/1999 09:23'!extent: aPoint	"Round to multiples of magnification"	srcExtent := (aPoint - (2 * borderWidth)) // magnification.	^super extent: self defaultExtent! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'sw 12/1/1998 17:56'!downArrowHit	currentIndex := currentIndex - 1.	(currentIndex < 1) ifTrue:  [currentIndex := formChoices size].	self updateThumbnail	! !!SoundEventMorph methodsFor: 'piano rolls' stamp: 'RAA 12/9/2000 18:48'!justDroppedIntoPianoRoll: newOwner event: evt		| startX lengthInTicks endX |	super justDroppedIntoPianoRoll: newOwner event: evt.	startTimeInScore := newOwner timeForX: self left.	lengthInTicks := newOwner scorePlayer ticksForMSecs: sound duration * 1000.0.	endTimeInScore := startTimeInScore + lengthInTicks.	endTimeInScore > newOwner scorePlayer durationInTicks ifTrue:		[newOwner scorePlayer updateDuration].	startX := newOwner xForTime: startTimeInScore.	endX := newOwner xForTime: endTimeInScore.	self width: endX - startX.! !!IconicButton methodsFor: '*MorphicExtras-initialization' stamp: 'nk 9/1/2004 17:14'!initializeToShow: aMorph withLabel: aLabel andSend: aSelector to: aReceiver 		"Initialize the receiver to show the current appearance of aMorph on its face, giving it the label supplied and arranging for it, when the button goes down on it, to obtain a new morph by sending the specified selector to the specified receiver"	| aThumbnail |	aThumbnail := Thumbnail new.	aThumbnail makeThumbnailFromForm: (aMorph imageFormDepth: 32).	^ self initializeWithThumbnail: aThumbnail withLabel: aLabel andColor: self color andSend: aSelector to: aReceiver 	! !!SketchEditorMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:24'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.hostView := deepCopier references at: hostView ifAbsent: [hostView].enclosingPasteUpMorph := deepCopier references at: enclosingPasteUpMorph 			ifAbsent: [enclosingPasteUpMorph].! !!ClockMorph methodsFor: 'parts bin' stamp: 'sw 7/12/2001 17:41'!initializeToStandAlone	super initializeToStandAlone.	showSeconds := true.	self step! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 1/31/98 10:41'!editEnvelope: env	envelope := env.	limits := Array with: envelope loopStartIndex				with: envelope loopEndIndex				with: envelope points size.	limitXs := limits collect: [:i | (envelope points at: i) x].	self buildView! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/2/2004 01:27'!fontsForNewYork	| d |	"Bold = 1, Ital = 2, Under = 4, Narrow = 8, Struckout = 16"	d := Dictionary new.	d		at: 0 put: #('Times-Roman' 1.0);		at: 1 put: #('Times-Bold' 1.0);		at: 2 put: #('Times-Italic' 1.0);		at: 3 put: #('Times-BoldItalic' 1.0);		at: 8 put: #('Helvetica-Narrow' 1.0);		at: 9 put: #('Helvetica-Narrow-Bold' 1.0);		at: 10 put: #('Helvetica-Narrow-Oblique' 1.0);		at: 11 put: #('Helvetica-Narrow-BoldOblique' 1.0).	^d! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:39'!menuPageVisualFor: target event: evt	| tSpec menu subMenu directionChoices |	tSpec := self transitionSpecFor: target.	menu := (MenuMorph entitled: ('Choose an effect(it is now {1})' translated format:{tSpec second asString translated})) defaultTarget: target.	TransitionMorph allEffects do:		[:effect |		directionChoices := TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect asString translated target: target					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu := MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir asString translated target: target						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect asString translated subMenu: subMenu]].	menu popUpEvent: evt in: self world! !!PinMorph class methodsFor: 'class initialization' stamp: 'di 4/28/1998 10:58'!initialize  "PinMorph initialize"	OutputPinForm := Form extent: 8@8 depth: 1 fromArray:			#( 0 3221225472 4026531840 4227858432 4278190080 4227858432 4026531840 3221225472)		offset: 0@0.	IoPinForm := Form extent: 8@8 depth: 1 fromArray:			#( 0 402653184 1006632960 2113929216 4278190080 2113929216 1006632960 402653184)		offset: 0@0.	InputPinForm := OutputPinForm flipBy: #horizontal centerAt: 0@0.! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/20/1998 10:46'!startMorph: start endMorph: end startBlock: firstBlock completionBlock: aBlock	startMorph := start.	endMorph := end.	startBlock := firstBlock.	completionBlock := aBlock! !!WiWPasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 11/14/1999 11:04'!show	Debug inspect.	Debug := OrderedCollection new.! !!GraphMorph methodsFor: 'accessing' stamp: ''!data: aCollection	data := aCollection.	maxVal := minVal := 0.	data do: [:x |		x < minVal ifTrue: [minVal := x].		x > maxVal ifTrue: [maxVal := x]].	self flushCachedForm.! !!SimpleSwitchMorph methodsFor: 'event handling' stamp: 'ar 6/4/2001 00:39'!mouseDown: evt	oldColor := self fillStyle.! !!Command methodsFor: 'private' stamp: 'sw 8/29/2000 14:09'!assuredParameterDictionary	"Private!!  Answer the parameters dictionary, creating it if necessary"	^ parameters ifNil: [parameters := IdentityDictionary new]! !!FatBitsPaint methodsFor: 'events' stamp: 'sw 3/30/2002 16:47'!pointGriddedFromEvent: evt	| relativePt |	relativePt := evt cursorPoint - self position.	^ (relativePt x truncateTo: magnification)@(relativePt y truncateTo: magnification)! !!ReferenceMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:59'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the menu for the hand"	| sketch |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	self isCurrentlyTextual		ifTrue:			[aCustomMenu add: 'change label wording...' translated action: #changeTabText.			aCustomMenu add: 'use graphical label' translated action: #useGraphicalTab]		ifFalse:			[aCustomMenu add: 'use textual label' translated action: #useTextualTab.			aCustomMenu add: 'choose graphic...' translated action: #changeTabGraphic.			(sketch := self findA: SketchMorph) ifNotNil:				[aCustomMenu add: 'repaint' translated target: sketch action: #editDrawing]]! !!ProjectNavigationMorph methodsFor: 'event handling' stamp: 'RAA 6/30/2000 13:57'!mouseEnter: evt	(self worldBounds containsPoint: evt cursorPoint) ifFalse: [^self].	mouseInside := true.	self positionVertically.	! !!ScreeningMorph methodsFor: 'menu' stamp: ''!showSourceOnly	displayMode := #showSourceOnly.	self changed! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/17/97 11:48'!stampHolder: newOne	stampHolder := newOne! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'di 1/29/2001 14:18'!resizeScroller	| inner |	"used to handle left vs right scrollbar"	inner := self innerBounds.	scroller bounds: (inner topLeft + (yScrollBar width@0) corner: (inner bottomRight - (0@xScrollBar height)))! !!LedDigitMorph methodsFor: 'drawing' stamp: 'dew 1/16/2002 20:44'!drawOn: aCanvas	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset |	foregroundColor := highlighted ifTrue: [Color white] ifFalse: [color].	backgroundColor := color muchDarker.	hThickness := self height * 0.1.	vThickness := self width * 0.1.	thickness := hThickness min: vThickness.	vOffset := ((hThickness - thickness) // 2) max: 0.	hOffset := ((vThickness - thickness) // 2) max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	"added to show the minus sign"	(digit asString = '-') ifTrue: [digit := 10].	HSegmentOrigins with: (HSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (0@vOffset) + (o * self extent)) rounded				extent: ((self width * 0.6) @ thickness) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].	VSegmentOrigins with: (VSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (hOffset@0) + (o * self extent)) rounded				extent: (thickness @ (self height * 0.25)) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].! !!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'di 9/4/1998 12:57'!soundPrototype: aSound	soundPrototype := aSound! !!TransformationB2Morph methodsFor: 'drawing' stamp: 'RAA 12/17/2000 13:25'!drawSubmorphsOn: aCanvas	| r1 fullG r2 actualCanvas newClip where deferredMorphs case |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	useRegularWarpBlt == true ifTrue: [		^aCanvas 			transformBy: transform			clippingTo: ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) rounded			during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]			]			smoothing: smoothing	].	r1 := self innerBounds intersect: aCanvas clipRect.	r1 area = 0 ifTrue: [^self].	fullG := (transform localBoundsToGlobal: self firstSubmorph fullBounds) rounded.	r2 := r1 intersect: fullG.	r2 area = 0 ifTrue: [^self].	newClip := (r2 expandBy: 1) rounded intersect: self innerBounds rounded.	deferredMorphs := #().	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: newClip		during: [:myCanvas |			self scale > 1.0 ifTrue: [				actualCanvas := MultiResolutionCanvas new initializeFrom: myCanvas.				actualCanvas deferredMorphs: (deferredMorphs := OrderedCollection new).			] ifFalse: [				actualCanvas := myCanvas.			].			submorphs reverseDo:[:m | actualCanvas fullDrawMorph: m].		]		smoothing: smoothing.	deferredMorphs do: [ :each |		where := each bounds: each fullBounds in: self.		case := 2.		case = 1 ifTrue: [where := where origin rounded extent: where extent rounded].		case = 2 ifTrue: [where := where rounded].		each drawHighResolutionOn: aCanvas in: where.	].! !!PaintBoxMorph methodsFor: 'other' stamp: 'yo 1/13/2005 11:06'!addTextualLabels	"translate button labels"	#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		| button |		button := submorphs detect: [:m | m externalName = extName] ifNone: [nil].		button ifNotNil: [			button removeAllMorphs.			button addMorph: (TextMorph new 				contentsWrapped: (Text string: label translated					attributes: {						TextAlignment centered. 						TextEmphasis bold.						TextFontReference toFont:							(Preferences standardPaintBoxButtonFont)});				bounds: (button bounds translateBy: 0@3);				lock)]]! !!FancyMailComposition methodsFor: 'morphic gui' stamp: 'ar 11/10/2000 15:46'!openInMorphic	"open an interface for sending a mail message with the given initial 	text "	| buttonsList container toField subjectField |	buttonsList := self newRow.	buttonsList wrapCentering: #center; cellPositioning: #leftCenter.	buttonsList		addMorphBack: (			(self 				buttonWithAction: #submit				label: 'send later'				help: 'add this to the queue of messages to be sent')		);		addMorphBack: (			(self 				buttonWithAction: #sendNow				label: 'send now'				help: 'send this message immediately')		);		addMorphBack: (			(self 				buttonWithAction: #forgetIt				label: 'forget it'				help: 'forget about sending this message')		).	morphicWindow := container := AlignmentMorphBob1 new		borderWidth: 8;		borderColor: self borderAndButtonColor;		color: Color white.	container 		addMorphBack: (buttonsList vResizing: #shrinkWrap; minHeight: 25; yourself);		addMorphBack: ((self simpleString: 'To:') vResizing: #shrinkWrap; minHeight: 18; yourself);		addMorphBack: ((toField := PluggableTextMorph			on: self			text: #to			accept: #to:) hResizing: #spaceFill; vResizing: #rigid; height: 50; yourself		);		addMorphBack: ((self simpleString: 'Subject:') vResizing: #shrinkWrap; minHeight: 18; yourself);		addMorphBack: ((subjectField := PluggableTextMorph			on: self			text: #subject			accept: #subject:) hResizing: #spaceFill; vResizing: #rigid; height: 50; yourself		);		addMorphBack: ((self simpleString: 'Message:') vResizing: #shrinkWrap; minHeight: 18; yourself);		addMorphBack: ((textEditor := PluggableTextMorph			on: self			text: #messageText			accept: #messageText:) hResizing: #spaceFill; vResizing: #spaceFill; yourself		).	textFields := {toField. subjectField. textEditor}.	container 		extent: 300@400;		openInWorld.! !!PreferencesPanel methodsFor: 'category switch' stamp: 'sw 2/18/2001 04:02'!switchToCategoryNamed: aName event: anEvent	"Switch the panel so that it looks at the category of the given name"	| aPalette |	aPalette := self containingWindow findDeeplyA: TabbedPalette.	aPalette ifNil: [^ self].	aPalette selectTabNamed: aName! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/2/2004 01:27'!fontsForPalatino	| d |	"Bold = 1, Ital = 2, Under = 4, Narrow = 8, Struckout = 16"	d := Dictionary new.	d		at: 0 put: #('Palatino-Roman' 1.0);		at: 1 put: #('Palatino-Bold' 1.0);		at: 2 put: #('Palatino-Italic' 1.0);		at: 3 put: #('Palatino-BoldItalic' 1.0).	^d! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'sw 5/23/2001 13:53'!createButtons	"Create buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"	| rect button nib |	#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: pickup: "pickup: pickup: pickup:" stamp: "stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |		(self submorphNamed: sel) ifNil:			[self inform: 'Rectangle for ',sel.			rect := Rectangle fromUser.			button := ThreePhaseButtonMorph new.			button onImage: nil; bounds: rect.			self addMorph: button.			button actionSelector: #tool:action:cursor:evt:; arguments: (Array with: button with: sel with: nil).			button actWhen: #buttonUp; target: self]].	#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |		(self submorphNamed: sel) ifNil:			[self inform: 'Rectangle for ',sel.			rect := Rectangle fromUser.			button := ThreePhaseButtonMorph new.			button onImage: nil; bounds: rect.			self addMorph: button.			nib := Form dotOfSize: (#(1 2 3 6 11 26) at: ind).			button actionSelector: #brush:action:nib:evt:; 					arguments: (Array with: button with: sel with: nib).			button actWhen: #buttonUp; target: self]].	"stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 7/14/2000 12:42'!chooseSound: evt	| menu |	menu := MenuMorph new.	menu add: 'new...' target: self selector: #editNewSound.	menu addLine.	AbstractSound soundNames do:		[:name |		menu add: name			target: self selector: #editSoundNamed:			argument: name].	menu popUpEvent: evt in: self world! !!PaintBoxMorph class methodsFor: 'as yet unclassified' stamp: 'ar 7/8/2006 20:33'!initializeColorChart	"PaintBoxMorph initializeColorChart"	ColorChart := (ColorPickerMorph colorPaletteForDepth: 32 extent: (360+10)@(180+10))! !!ZoomAndScrollControllerMorph methodsFor: 'event handling' stamp: 'RAA 12/1/2000 18:23'!mouseEnter: evt	evt hand newKeyboardFocus: self.	currentKeyDown := Set new.	hasFocus := true.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'sw 4/21/2004 13:23'!ellipse: evt	"Draw an ellipse from the center. "	| rect oldRect ww ext oldExt cColor sOrigin priorEvt |	sOrigin := self get: #strokeOrigin for: evt.	cColor := self getColorFor: evt.	ext := (sOrigin - evt cursorPoint) abs * 2.	evt shiftPressed ifTrue: [ext := self shiftConstrainPoint: ext].	rect := Rectangle center: sOrigin extent: ext.	ww := (self getNibFor: evt) width.	(priorEvt := self get: #lastEvent for: evt) ifNotNil: [		oldExt := (sOrigin - priorEvt cursorPoint) abs + ww * 2.		priorEvt shiftPressed ifTrue: [oldExt := self shiftConstrainPoint: oldExt].		(oldExt < ext) ifFalse: ["Last draw sticks out, must erase the area"			oldRect := Rectangle center: sOrigin extent: oldExt.			self restoreRect: oldRect]].	cColor == Color transparent		ifFalse:			[formCanvas fillOval: rect color: Color transparent borderWidth: ww borderColor: cColor]		ifTrue:			[formCanvas fillOval: rect color: cColor borderWidth: ww borderColor: Color black].	self invalidRect: rect.! !!BookPageThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:35'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."page := page.		Weakly copied"pageNumber := pageNumber veryDeepCopyWith: deepCopier."bookMorph := bookMorph.		All weakly copied"flipOnClick := flipOnClick veryDeepCopyWith: deepCopier. ! !!InternalThreadNavigationMorph class methodsFor: 'known threads' stamp: 'RAA 2/24/2001 13:10'!openThreadNamed: nameOfThread atIndex: anInteger	| coll nav |	coll := self knownThreads at: nameOfThread ifAbsent: [^self].	nav := World 		submorphThat: [ :each | (each isKindOf: self) and: [each threadName = nameOfThread]]		ifNone: [			nav := self basicNew.			nav				listOfPages: coll;				threadName: nameOfThread index: anInteger;				initialize;				openInWorld;				positionAppropriately.			^self		].	nav		listOfPages: coll;		threadName: nameOfThread index: anInteger;		removeAllMorphs;		addButtons.! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:14'!undoLastCommand	| w |	^(w := self currentWorld) == nil ifFalse:[w commandHistory undoLastCommand]! !!URLMorph methodsFor: 'private' stamp: 'tk 10/2/1998 08:20'!setURL: aURLString page: aSqueakPage	"Initialize the receiver for the given URL and page."	url := aURLString.	page := aSqueakPage.	page ifNotNil: [self pageHasChanged: page].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:11'!writeTape: fileName 	| b name |	name := self writeFileNamed: fileName.	(b := self button: 'writeTape') ifNotNil: [		b actionSelector: #writeTape:.		b arguments: (Array with: name)].! !!TransitionMorph class methodsFor: 'initialization' stamp: 'di 12/20/1998 21:37'!effect: effectSymbol direction: dirSymbol inverse: inverse	| invEffect invDir i dirSet |	inverse ifFalse: [^ self effect: effectSymbol direction: dirSymbol].	invEffect := effectSymbol.	effectSymbol = #pageForward ifTrue: [invEffect := #pageBack].	effectSymbol = #pageBack ifTrue: [invEffect := #pageForward].	effectSymbol = #slideOver ifTrue: [invEffect := #slideAway].	effectSymbol = #slideAway ifTrue: [invEffect := #slideOver].	invDir := dirSymbol.	dirSet := self directionsForEffect: effectSymbol.	(i := dirSet indexOf: dirSymbol) > 0		ifTrue: [invDir := dirSet atWrap: i + (dirSet size // 2)].	^ self effect: invEffect direction: invDir! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:13'!redoNextCommand	| w |	^(w := self currentWorld) == nil ifFalse:[w commandHistory redoNextCommand]! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a := AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:37'!changeZoomFactor: x	currentPage changeZoomFactor: x.	zoomFactor := x.! !!MultiResolutionCanvas methodsFor: 'as yet unclassified' stamp: 'RAA 12/4/2000 11:58'!deferredMorphs: aCollection	deferredMorphs := aCollection! !!ThumbnailMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:57'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.objectToView := deepCopier references at: objectToView ifAbsent: [objectToView].! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 8/15/2001 12:00'!insertNewProject	| newProj |	[newProj := Project newMorphicOn: nil.]		on: ProjectViewOpenNotification		do: [ :ex | ex resume: false].		EToyProjectDetailsMorph 		getFullInfoFor: newProj		ifValid: [self insertNewProjectActionFor: newProj]		expandedFormat: false.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 16:16'!arguments: aCollection	arguments := aCollection asArray copy.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:18'!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) isNil and: [pages first url notNil]) ifTrue: [		response := (PopUpMenu labels: 'Old bookNew book sharing old pages' translated)				startUpWithCaption: 'Modify the old book, or make a newbook sharing its pages?' translated.		response = 2 ifTrue: [			"Make up new url for .bo file and confirm with user."  "Mark as shared"			[rand := String new: 4.			1 to: rand size do: [:ii |				rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			(newPlace := self getStemUrl) isEmpty ifTrue: [^ self].			newPlace := (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.			dir := ServerFile new fullPath: newPlace.			(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace].		response = 0 ifTrue: [^ self]].	stem := self getStemUrl.	"user must approve"	stem isEmpty ifTrue: [^ self].	ind := pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?' translated].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!PaintBoxMorph methodsFor: 'other' stamp: 'tk 8/22/2000 11:57'!maxBounds	| rr |	"fullBounds if all flop-out parts of the paintBox were showing."	rr := bounds merge: colorMemory bounds.	rr := rr merge: (self submorphNamed: 'stamps') bounds.	rr := rr origin corner: rr corner + (0@ (self submorphNamed: 'shapes') height 				+ 10 "what is showing of (self submorphNamed: #toggleShapes) height").	^ rr! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate: samplesPerSecond	samplingRate := samplesPerSecond.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 10:51'!pickupButtons: anArray	"Save the list of buttons that are for making a new stamp.  Left to right"	pickupButtons := anArray! !!GeePrinter methodsFor: 'Postscript Canvases' stamp: 'RAA 9/18/2000 12:51'!doPages	| dialog |	(dialog := GeePrinterDialogMorph new) 		printSpecs: self printSpecs 		printBlock: [ :preview :specs |			preview ifTrue: [self doPrintPreview] ifFalse: [self doPrintToPrinter]		];		fullBounds;		position: Display extent - dialog extent // 2;		openInWorld! !!PostscriptCanvas methodsFor: 'private' stamp: 'di 9/22/1999 08:16'!resetContentRotated: rotateFlag	target := self class defaultTarget.	self writeHeaderRotated: rotateFlag.     ^self.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'ar 5/28/2000 12:10'!loadOnImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadOnImage: 'NoSh:=on.bmp'.		AllOnImage := nil.	'save space'.	"	| pic16Bit blt aa on type |	type := 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" := GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa := AllOnImage := Form extent: OriginalBounds extent depth: 8.	blt := BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit := (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa := AllOnImage := Form extent: OriginalBounds extent depth: 16.	blt := BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa mapColor: Color transparent to: Color black.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on := ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on := Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button onImage: on]].	self invalidRect: bounds.	! !!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/20/1999 15:48'!toggleTrackingPointer	trackPointer := trackPointer not! !!HandMorphForReplay methodsFor: 'initialization' stamp: 'di 3/3/1999 14:54'!recorder: anEventRecorder	recorder := anEventRecorder! !!RemoteHandMorph methodsFor: 'connections' stamp: ''!stopListening	"Destroy the socket, if any, terminating the connection."	socket ifNotNil: [		socket destroy.		socket := nil].! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 13:36'!modelReadSelector: a modelWriteSelector: b	modelReadSelector := a.	modelWriteSelector := b! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:40'!dirty: aBool	dirty := aBool! !!PartsBin class methodsFor: 'thumbnail cache' stamp: 'sw 7/12/2001 19:06'!thumbnailForInstanceOf: aMorphClass	"Answer a thumbnail for a stand-alone instance of the given class, creating it if necessary.  If it is created afresh, it will also be cached at this time"	| aThumbnail |	^ Thumbnails at: aMorphClass name ifAbsent:		[aThumbnail := Thumbnail new makeThumbnailFromForm: aMorphClass newStandAlone imageForm.		self cacheThumbnail: aThumbnail forSymbol: aMorphClass name.		^ aThumbnail]"PartsBin initialize"! !!EventRecorderMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 20:44'!synchronize	time := Time millisecondClockValue.	deltaTime := nil.! !!EventRecorderMorph methodsFor: 'stepping and presenter' stamp: 'RAA 6/14/2001 16:43'!stop	state = #record ifTrue:		[tape := tapeStream contents.		saved := false].	journalFile ifNotNil:		[journalFile close].	self pauseIn: self world.	tapeStream := nil.	state := nil.	self setStatusLight: #ready.	recordMeter ifNotNil: [recordMeter width: 1].	self checkTape.! !!LedMorph methodsFor: 'initialization' stamp: 'di 3/8/2001 23:44'!scrollInit	chars := 0.	scroller := 1.	string := ''.	scrollLoop := false.! !!ClockMorph methodsFor: '24hr' stamp: 'fc 2/8/2004 11:38'!show24hr: aBoolean	show24hr := aBoolean! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'nb 6/17/2003 12:25'!skipOverNext		| target |	(target := self currentIndex + 2) > listOfPages size ifTrue: [^Beeper beep].	currentIndex := target.	self loadPageWithProgress.! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:55'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt hand targetOffset.	target := rootMorphs size > 1				ifTrue: [rootMorphs second]! !!String methodsFor: '*MorphicExtras-*morphic-Postscript Canvases' stamp: 'yo 11/3/2004 19:24'!asPostscript	| temp |	temp := self asString copyReplaceAll: '(' with: '\('.	temp := temp copyReplaceAll: ')' with: '\)'.	temp := temp copyReplaceAll: '' 			with: ''.	^ PostscriptEncoder mapMacStringToPS: temp! !!BookMorph methodsFor: 'menu' stamp: 'tk 2/25/1999 10:37'!reserveUrlsIfNeeded	"See if this book needs to pre-allocate urls.  Harmless if have urls already.  Actually writes dummy files to reserve names."| baddies bad2 |pages size > 25 ifTrue: [^ self reserveUrls].baddies := BookPageThumbnailMorph withAllSubclasses.bad2 := FlexMorph withAllSubclasses.pages do: [:aPage |	aPage allMorphsDo: [:mm | 		(baddies includes: mm class) ifTrue: [^ self reserveUrls].		(bad2 includes: mm class) ifTrue: [			mm originalMorph class == aPage class ifTrue: [				^ self reserveUrls]]]].		! !!ReferenceMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:49'!initialize"initialize the state of the receiver"	super initialize.""	isHighlighted := false.	referent := nil! !!MorphExtension methodsFor: '*MorphicExtras-accessing' stamp: 'dgd 2/16/2003 21:40'!isPartsDonor: aBoolean 	"change the receiver's isPartDonor property"	isPartsDonor := aBoolean! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 11/25/1999 09:20'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta := aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	self changed.	self privateFullMoveBy: delta.	self changed.! !!PreferencesPanel methodsFor: 'find' stamp: 'nk 4/28/2004 10:18'!addHelpItemsTo: panelPage	"Add the items appropriate the the ? page of the receiver"	| aButton aTextMorph aMorph firstTextMorph |	panelPage hResizing: #shrinkWrap; vResizing: #shrinkWrap.	firstTextMorph :=  TextMorph new contents: 'Search Preferences for:'.	firstTextMorph beAllFont: ((TextStyle default fontOfSize: 13) emphasized: 1).	panelPage addMorphBack: firstTextMorph lock.	panelPage addTransparentSpacerOfSize: 0@10.	aMorph := RectangleMorph new clipSubmorphs: true; beTransparent; borderWidth: 2; borderColor: Color black; extent: 250 @ 36.	aMorph vResizing: #rigid; hResizing: #rigid.	aTextMorph :=  PluggableTextMorph new				on: self				text: #searchString				accept: #setSearchStringTo:				readSelection: nil				menu: nil."	aTextMorph hResizing: #rigid."	aTextMorph borderWidth: 0.	aTextMorph font: ((TextStyle default fontOfSize: 21) emphasized: 1); setTextColor: Color red.	aMorph addMorphBack: aTextMorph.	aTextMorph acceptOnCR: true.	aTextMorph position: (aTextMorph position + (6@5)).	aMorph clipLayoutCells: true.	aTextMorph extent: 240 @ 25.	panelPage addMorphBack: aMorph.	aTextMorph setBalloonText: 'Type what you want to search for here, then hit the "Search" button, or else hit RETURN or ENTER'.	aTextMorph setTextMorphToSelectAllOnMouseEnter.	aTextMorph hideScrollBarsIndefinitely.	panelPage addTransparentSpacerOfSize: 0@10.	aButton := SimpleButtonMorph new target: self; color: Color transparent; actionSelector: #initiateSearch:; arguments: {aTextMorph}; label: 'Search'.	panelPage addMorphBack: aButton.	aButton setBalloonText: 'Type what you want to search for in the box above, then click here (or hit RETURN or ENTER) to start the search; results will appear in the "search results" category.'.	panelPage addTransparentSpacerOfSize: 0@30.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Restore all Default Preference Settings'; target: Preferences; actionSelector: #chooseInitialSettings; setBalloonText: 'Click here to reset all the preferences to their standard default values.'; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Save Current Settings as my Personal Preferences'; 		target: Preferences; actionSelector: #savePersonalPreferences; setBalloonText: 'Click here to save the current constellation of Preferences settings as your personal defaults; you can get them all reinstalled with a single gesture by clicking the "Restore my Personal Preferences".'; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Restore my Personal Preferences'; target: Preferences; actionSelector: #restorePersonalPreferences; setBalloonText: 'Click here to reset all the preferences to their values in your Personal Preferences.'; yourself).	panelPage addTransparentSpacerOfSize: 0@30.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Save Current Settings to Disk'; 		target: Preferences; actionSelector: #storePreferencesToDisk; setBalloonText: 'Click here to save the current constellation of Preferences settings to a file; you can get them all reinstalled with a single gesture by clicking "Restore Settings From Disk".'; yourself).	panelPage addTransparentSpacerOfSize: 0@14.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Restore Settings from Disk'; target: Preferences; actionSelector: #restorePreferencesFromDisk; setBalloonText: 'Click here to load all the preferences from their saved values on disk.'; yourself).	panelPage addTransparentSpacerOfSize: 0@30.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Inspect Parameters'; target: Preferences; actionSelector: #inspectParameters; setBalloonText: 'Click here to view all the values stored in the system Parameters dictionary'; yourself).	panelPage addTransparentSpacerOfSize: 0@10.	panelPage addMorphBack: (Preferences themeChoiceButtonOfColor: Color transparent font: TextStyle defaultFont).	panelPage addTransparentSpacerOfSize: 0@10.	panelPage addMorphBack: (SimpleButtonMorph new color: Color transparent; label: 'Help!!'; target: Preferences; actionSelector: #giveHelpWithPreferences; setBalloonText: 'Click here to get some hints on use of this Preferences Panel'; yourself).	panelPage wrapCentering: #center.! !!AnimatedImageMorph methodsFor: 'private' stamp: 'bf 2/25/2005 11:18'!fromReader: reader	images := reader forms.	delays := reader delays.	imageIndex := 0.	self image: (Form extent: images first extent depth: 32).	self step! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!readFromDisk: evt	| menu |	menu := MenuMorph new.	(FileDirectory default fileNamesMatching: '*.fmp') do:		[:fileName |		menu add: fileName			target: self selector: #readFileNamed:			argument: fileName].	menu popUpEvent: evt in: self world! !!BookMorph methodsFor: 'initialization' stamp: 'sw 6/24/1998 09:23'!newPages: pageList	"Replace all my pages with the given list of BookPageMorphs.  After this call, currentPage may be invalid."	pages := pages species new.	pages addAll: pageList! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:54'!line: evt 	"Draw a line on the paintingForm using formCanvas aimed at it."	| rect oldRect ww now diff cor cColor sOrigin priorEvt |	sOrigin := self get: #strokeOrigin for: evt.	rect := sOrigin rect: (now := evt cursorPoint).	evt shiftPressed		ifTrue: [diff := evt cursorPoint - sOrigin.			now := sOrigin						+ (Point r: diff r degrees: diff degrees + 22.5 // 45 * 45).			rect := sOrigin rect: now].	ww := (self getNibFor: evt) width.	(priorEvt := self get: #lastEvent for: evt)		ifNotNil: [oldRect := sOrigin rect: priorEvt cursorPoint.			priorEvt shiftPressed				ifTrue: [diff := priorEvt cursorPoint - sOrigin.					cor := sOrigin								+ (Point r: diff r degrees: diff degrees + 22.5 // 45 * 45).					oldRect := sOrigin rect: cor].			oldRect := oldRect expandBy: ww @ ww.			"Last draw will always stick out, must erase the area"			self restoreRect: oldRect].	cColor := self getColorFor: evt.	formCanvas		line: sOrigin		to: now		width: ww		color: cColor.	self invalidRect: rect! !!ThreadNavigationMorph methodsFor: 'navigation' stamp: 'nb 6/17/2003 12:25'!previousPage	self currentIndex <= 1 ifTrue: [^Beeper beep].	currentIndex := self currentIndex - 1.	self loadPageWithProgress.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/30/98 12:41'!maxVal: aNumber	maxVal := aNumber.! !!BooklikeMorph methodsFor: 'page controls' stamp: 'sw 6/6/2003 13:58'!showPageControls: controlSpecs  	"Remove any existing page controls, and add fresh controls at the top of the receiver (or in position 2 if the receiver's first submorph is one with property #header).  Add a single column of controls."	| pageControls column |	self hidePageControls.	column := AlignmentMorph newColumn beTransparent.	pageControls := self makePageControlsFrom: controlSpecs.	pageControls borderWidth: 0; layoutInset: 4.	pageControls beSticky.	pageControls setNameTo: 'Page Controls'.	self setEventHandlerForPageControls: pageControls.	column addMorphBack: pageControls.	self addPageControlMorph: column! !!TrashCanMorph methodsFor: 'private' stamp: 'sw 8/22/1998 22:44'!findActivePaintBox	"If painting, return the active PaintBoxMorph. If not painting, or if the paint box cannot be found, return nil."	| w m |	w := self world.	w ifNil: [^ nil].	(w findA: SketchEditorMorph) ifNil: [^ nil].  "not painting"	(m := w findA: PaintBoxMorph) ifNotNil: [^ m].	^ nil! !!FatBitsPaint methodsFor: 'initialization' stamp: 'RAA 9/25/1999 21:44'!setCurrentToolTo: aDictionary        currentTools := aDictionary.        currentSelectionMorph ifNotNil: [currentSelectionMorph delete. currentSelectionMorph := nil]! !!InternalThreadNavigationMorph class methodsFor: 'thumbnails' stamp: 'RAA 5/10/2001 17:06'!cacheThumbnailFor: aProject	| form |	CachedThumbnails ifNil: [CachedThumbnails := Dictionary new].	CachedThumbnails		at: aProject name		put: (form := self sorterFormForProject: aProject sized: nil).	^form	! !!StringButtonMorph methodsFor: 'menu' stamp: 'yo 3/14/2005 13:09'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!CommandHistory methodsFor: 'command history' stamp: 'di 12/12/2000 13:46'!resetCommandHistory    "CommandHistory allInstancesDo: [:ch | ch resetCommandHistory]"	"Clear out the command history so that no commands are held"	lastCommand := nil.	history := OrderedCollection new.! !!Flaps class methodsFor: 'predefined flaps' stamp: 'edc 7/21/2009 09:21'!defaultsQuadsDefiningPlugInSuppliesFlap	"Answer a list of quads which define the objects to appear in the default Supplies flap used in the Plug-in image"	^  #(	(ObjectsTool				newStandAlone				'Object Catalog'		'A tool that lets you browse the catalog of available objects')	"(AllScriptsTool			allScriptsToolForActiveWorld	'All Scripts' 		'Stop, Step, and Go buttons for controlling all your scripts at once.  The tool can also be "opened up" to control each script in your project individually.')"	(TrashCanMorph			new						'Trash'				'A tool for discarding objects')	(GrabPatchMorph		new						'Grab Patch'		'Allows you to create a new Sketch by grabbing a rectangular patch from the screen')	(LassoPatchMorph		new						'Lasso'		'Allows you to create a new Sketch by lassoing an area from the screen')	(StickyPadMorph		newStandAlone			'Sticky Pad'			'Each time you obtain one of these pastel, translucent, borderless rectangles, it will be a different color from the previous time.')	"(PaintInvokingMorph	new						'Paint'				'Drop this into an area to start making a fresh painting there')"	(TextMorph				boldAuthoringPrototype			'Text'				'Text that you can edit into anything you desire.')	(RecordingControlsMorph	authoringPrototype		'Sound'				'A device for making sound recordings.')	(RectangleMorph 		authoringPrototype		'Rectangle' 		'A rectangle')	(RectangleMorph		roundRectPrototype		'RoundRect'		'A rectangle with rounded corners')	(EllipseMorph			authoringPrototype		'Ellipse'			'An ellipse or circle')	(StarMorph				authoringPrototype		'Star'			'A star')	(CurveMorph			authoringPrototype		'Curve'			'A curve')	(PolygonMorph			authoringPrototype		'Polygon'		'A straight-sided figure with any number of sides')	(ScriptableButton		authoringPrototype		'Button'			'A Scriptable button')	(BookMorph				nextPageButton			'NextPage'		'A button that takes you to the next page')	(BookMorph				previousPageButton 		'PreviousPage'	'A button that takes you to the previous page')	"(ScriptingSystem		prototypicalHolder 		'Holder'			'A place for storing alternative pictures in an animation, etc.')"	(PasteUpMorph			authoringPrototype		'Playfield'		'A place for assembling parts or for staging animations')	(SimpleSliderMorph		authoringPrototype		'Slider'			'A slider for showing and setting numeric values.')	(JoystickMorph			authoringPrototype		'Joystick'		'A joystick-like control')	(BookMorph				authoringPrototype		'Book'			'A multi-paged structure')	"(ClockMorph				authoringPrototype		'Clock'			'A simple digital clock')"	(RandomNumberTile		new					'Random'		'A random-number tile for use with tile scripting')) asOrderedCollection! !!LedDigitMorph class methodsFor: 'class initialization' stamp: 'rjf 5/25/2000 00:16'!initialize	HSegmentOrigins := {0.2@0.1. 0.2@0.45. 0.2@0.8}.	VSegmentOrigins := {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	HSegments := {		{true. false. true}.		{false. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}.		{true. true. true}.		{true. true. true}.		{true. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}}.	VSegments := {		{true. true. true. true}.		{false. false. true. true}.		{false. true. true. false}.		{false. false. true. true}.		{true. false. true. true}.		{true. false. false. true}.		{true. true. false. true}.		{false. false. true. true}.		{true. true. true. true}.		{true. false. true. true}.		{false. false. false. false}}.! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 8/30/2000 21:39'!changeBorderWidth: evt	| handle origin aHand |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	handle := HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(LineMorph from: origin to: newPoint color: Color black width: 1).		self borderWidth: (newPoint - origin) r asInteger // 5].	aHand attachMorph: handle.	handle startStepping! !!BookMorph methodsFor: 'menu' stamp: 'sw 5/14/1998 11:04'!pasteBookPage	| aPage |	aPage := self primaryHand objectToPaste.	self insertPage: aPage pageSize: aPage extent atIndex: ((pages indexOf: currentPage) - 1).	"self goToPageMorph: aPage"! !!GraphMorph methodsFor: 'event handling' stamp: 'jm 10/18/97 11:52'!mouseMove: evt	| x w |	x := evt cursorPoint x - (bounds left + borderWidth).	w := self width - (2 * borderWidth).	self changed.	x < 0 ifTrue: [		cursor := startIndex + (3 * x).		cursor := (cursor max: 1) min: data size.		^ self startIndex: cursor].	x > w ifTrue: [		cursor := startIndex + w + (3 * (x - w)).		cursor := (cursor max: 1) min: data size.		^ self startIndex: cursor - w].	cursor := ((startIndex + x) max: 1) min: data size.! !!StickyPadMorph class methodsFor: 'class initialization' stamp: 'sw 3/3/2004 13:44'!initialize	"Class initialization"	LastColorIndex := 0.	Colors :=  {		TranslucentColor r: 0.0 g: 0.0 b: 0.839 alpha: 0.267.		TranslucentColor r: 0.484 g: 1.0 b: 0.452 alpha: 0.706.		TranslucentColor r: 1.0 g: 0.355 b: 0.71 alpha: 0.569.		TranslucentColor r: 1.0 g: 1.0 b: 0.03 alpha: 0.561.		TranslucentColor r: 0.484 g: 0.161 b: 1.0 alpha: 0.529.		TranslucentColor r: 0.097 g: 0.097 b: 0.097 alpha: 0.192.	}.		self registerInFlapsRegistry.	"StickyPadMorph initialize"! !!BookMorph methodsFor: 'initialization' stamp: 'jm 11/17/97 17:26'!newPages: pageList currentIndex: index	"Replace all my pages with the given list of BookPageMorphs. Make the current page be the page with the given index."	pages := pages species new.	pages addAll: pageList.	pages isEmpty ifTrue: [^ self insertPage].	self goToPage: index.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/31/1998 14:01'!loopEnd: aNumber	loopEnd := (aNumber asInteger max: 1) min: graph data size.	possibleLoopStarts := nil.! !!TextOnCurveContainer methodsFor: 'as yet unclassified' stamp: 'di 12/4/97 08:28'!releaseCachedState	textSegments := nil.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/4/2001 09:18'!doYellowButtonPress: evt	| menu |	menu := CustomMenu new.	menu 		add: 'Go to top of document'				action: [self jumpToDocumentTop];		add: 'Move selection to top of page'		action: [self scrollSelectionToTop];		add: 'Add column break'					action: [self addColumnBreak];		add: 'Define as jump start'				action: [self addJumpBeginning];		add: 'Define as jump end'				action: [self addJumpEnd].	((menu build startUpCenteredWithCaption: 'Text navigation options') ifNil: [^self]) value.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/21/2000 16:06'!toggleShapes	| tab sh stamps |	"The sub panel that has the shape tools on it.  Rect, line..."	stamps := self submorphNamed: 'stamps'.	tab := self submorphNamed: 'shapeTab'.	(sh := self submorphNamed: 'shapes') visible		ifTrue: [sh hide.  tab top: stamps bottom-1]		ifFalse: [sh comeToFront.  sh top: stamps bottom-9.  				sh show.  tab top: sh bottom - tab height + 10].	self layoutChanged.! !!BookMorph methodsFor: 'initialization' stamp: 'ar 4/10/2005 18:42'!fromURL: url	"Make a book from an index and a bunch of pages on a server.  NOT showing any page!!"	| strm |	Cursor wait showWhile: [		strm := (ServerFile new fullPath: url) asStream].	strm isString ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	self setProperty: #url toValue: url.	self fromRemoteStream: strm.	^ self! !!PostscriptCanvas methodsFor: 'accessing' stamp: 'nk 4/1/2004 19:02'!shadowColor: aColor	shadowColor := aColor.! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!appendNewDataToReceiveBuffer	"Append all available raw data to my receive buffer. Assume that my socket is not nil."	| newData tempBuf bytesRead |	socket dataAvailable ifTrue: [		"get all the data currently available"		newData := WriteStream on: (String new: receiveBuffer size + 1000).		newData nextPutAll: receiveBuffer.		tempBuf := String new: 1000.		[socket dataAvailable] whileTrue: [			bytesRead := socket receiveDataInto: tempBuf.			1 to: bytesRead do: [:i | newData nextPut: (tempBuf at: i)]].		receiveBuffer := newData contents].! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/30/1998 18:51'!autoCorrolationBetween: index1 and: index2 length: length	"Answer the cummulative error between the portions of my waveform starting at the given two indices and extending for the given length. The larger this error, the greater the difference between the two waveforms."	| data error i1 e |	data := graph data.	error := 0.	i1 := index1.	index2 to: (index2 + length - 1) do: [:i2 |		e := (data at: i1) - (data at: i2).		e < 0 ifTrue: [e := 0 - e].		error := error + e.		i1 := i1 + 1].	^ error! !!TabbedPalette methodsFor: 'submorphs-add/remove' stamp: 'sw 4/7/1999 12:16'!replaceSubmorph: oldMorph by: newMorph	super replaceSubmorph: oldMorph by: newMorph.	oldMorph == currentPage ifTrue:		[currentPage := newMorph]! !!PianoKeyboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:56'!initialize	"initialize the state of the receiver"	super initialize.	""		whiteKeyColor := Color gray: 0.95.	blackKeyColor := Color black.	playingKeyColor := Color red.	nOctaves := 6.	self buildKeyboard.	soundPrototype := FMSound brass1 duration: 9.9! !!BasicButton methodsFor: 'as yet unclassified' stamp: 'sw 12/7/1999 18:14'!label: aString	| oldLabel m |	(oldLabel := self findA: StringMorph)		ifNotNil: [oldLabel delete].	m := StringMorph contents: aString font: TextStyle defaultFont.	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'JMV 1/29/2001 10:57'!addEnvelopeNamed: envName	| points env |	points := OrderedCollection new.	points add: 0@0.0;		add: (envelope points at: envelope loopStartIndex) x@1.0;		add: (envelope points at: envelope loopEndIndex) x@1.0;		add: (envelope points last) x@0.0.	envName = 'volume' ifTrue:		[env := VolumeEnvelope points: points loopStart: 2 loopEnd: 3.		env target: sound; scale: 0.7].	envName = 'modulation' ifTrue:		[env := Envelope points: (points collect: [:p | p x @ 0.5])						loopStart: 2 loopEnd: 3.		env target: sound; updateSelector: #modulation:;			scale: sound modulation*2.0].	envName = 'pitch' ifTrue:		[env := PitchEnvelope points: (points collect: [:p | p x @ 0.5])						loopStart: 2 loopEnd: 3.		env target: sound; updateSelector: #pitch:; scale: 0.5].	envName = 'random pitch:' ifTrue:		[env := RandomEnvelope for: #pitch:.		points := OrderedCollection new.		points add: 0@(env delta * 5 + 0.5);			add: (envelope points at: envelope loopStartIndex) x@(env highLimit - 1 * 5 + 0.5);			add: (envelope points at: envelope loopEndIndex) x@(env highLimit - 1 * 5 + 0.5);			add: (envelope points last) x@(env lowLimit - 1 * 5 + 0.5).		env setPoints: points loopStart: 2 loopEnd: 3.		env target: sound. ].	envName = 'ratio' ifTrue:		[denominator := 9999.  "No gridding"		env := Envelope points: (points collect: [:p | p x @ 0.5])						loopStart: 2 loopEnd: 3.		env target: sound; updateSelector: #ratio:;			scale: sound ratio*2.0].	env ifNotNil:		[sound addEnvelope: env.		self editEnvelope: env]! !!ProjectViewMorph methodsFor: '*MorphicExtras-*morphic-Postscript Canvases' stamp: 'RAA 4/19/2001 11:25'!fullDrawPostscriptOn: aCanvas	| f |	"handle the fact that we have the squished text within"	f := self imageForm.	f offset: 0@0.	aCanvas paintImage: f at: bounds origin.! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:14'!initialize	"initialize the state of the receiver"	super initialize.	""	damageReported := false.	self extent: 400 @ 250.	infectionHistory := OrderedCollection new.	transmitInfection := false.	self addAtoms: 30! !!PinMorph methodsFor: 'geometry' stamp: 'di 4/30/1998 12:12'!wiringEndPoint	| side |	side := owner bounds sideNearestTo: bounds center.	side = #left ifTrue: [^ self position + (0@4)].	side = #bottom ifTrue: [^ self position + (4@7)].	side = #right ifTrue: [^ self position + (7@4)].	side = #top ifTrue: [^ self position + (4@0)]! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 11/4/97 07:15'!brushColor: aColor	brushColor := aColor.	brush color: aColor.! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!comment: aString	aString isEmpty		ifTrue: [comment := nil]		ifFalse: [comment := aString].! !!AtomMorph methodsFor: 'private' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p := self position.	vx := velocity x.		vy := velocity y.	px := p x + vx.		py := p y + vy.	bounced := false.	px > aRect right ifTrue: [		px := aRect right - (px - aRect right).		vx := velocity x negated.		bounced := true].	py > aRect bottom ifTrue: [		py :=  aRect bottom - (py - aRect bottom).		vy := velocity y negated.		bounced := true].	px < aRect left ifTrue: [		px := aRect left - (px - aRect left).		vx := velocity x negated.		bounced := true].	py < aRect top ifTrue: [		py :=  aRect top - (py - aRect top).		vy := velocity y negated.		bounced := true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !!EnvelopeEditorMorph methodsFor: 'scaling' stamp: 'di 1/31/98 01:10'!valueFromY: y	"The convention is that envelope values are between 0.0 and 1.0"	| value |	value := (graphArea bottom - y) asFloat / (graphArea height).	envelope updateSelector = #ratio: ifTrue:		["Ratio gets gridded by denominator"		^ (value * envelope scale * denominator) rounded asFloat / denominator / envelope scale].	^ value! !!SketchEditorMorph methodsFor: 'copying' stamp: 'RAA 8/16/2000 12:29'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."hostView := hostView.		Weakly copied"	"stampForm := stampForm veryDeepCopyWith: deepCopier."	"canvasRectangle := canvasRectangle veryDeepCopyWith: deepCopier."palette := palette veryDeepCopyWith: deepCopier.	"currentColor := currentColor veryDeepCopyWith: deepCopier."ticksToDwell := ticksToDwell veryDeepCopyWith: deepCopier.rotationCenter := rotationCenter veryDeepCopyWith: deepCopier.registrationPoint := registrationPoint veryDeepCopyWith: deepCopier.newPicBlock := newPicBlock veryDeepCopyWith: deepCopier.emptyPicBlock := emptyPicBlock veryDeepCopyWith: deepCopier.	"action := action veryDeepCopyWith: deepCopier."paintingForm := paintingForm veryDeepCopyWith: deepCopier.dimForm := dimForm veryDeepCopyWith: deepCopier.	"buff := buff veryDeepCopyWith: deepCopier."	"brush := brush veryDeepCopyWith: deepCopier."	"paintingFormPen := paintingFormPen veryDeepCopyWith: deepCopier."formCanvas := formCanvas veryDeepCopyWith: deepCopier.	"picToBuff := picToBuff veryDeepCopyWith: deepCopier."	"brushToBuff := brushToBuff veryDeepCopyWith: deepCopier."	"buffToBuff := buffToBuff veryDeepCopyWith: deepCopier."	"buffToPic := buffToPic veryDeepCopyWith: deepCopier."rotationButton := rotationButton veryDeepCopyWith: deepCopier.scaleButton := scaleButton veryDeepCopyWith: deepCopier.	"strokeOrigin := strokeOrigin veryDeepCopyWith: deepCopier."cumRot := cumRot veryDeepCopyWith: deepCopier.cumMag := cumMag veryDeepCopyWith: deepCopier.undoBuffer := undoBuffer veryDeepCopyWith: deepCopier.	"lastEvent := lastEvent veryDeepCopyWith: deepCopier."	"currentNib := currentNib veryDeepCopyWith: deepCopier."enclosingPasteUpMorph := enclosingPasteUpMorph.	"weakly copied"forEachHand := nil.	"hmm..."                              ! !!GeePrinterPage methodsFor: 'as yet unclassified' stamp: 'RAA 9/16/2000 17:53'!pageNumber: anInteger bounds: aRect	pageNumber := anInteger.	bounds := aRect.! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jhm 10/15/97 15:06'!makeStatusLight	recordingStatusLight := Morph new extent: 18@18.	recordingStatusLight color: Color transparent.	^ recordingStatusLight! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!setMagnification: evt	| menu |	menu := MenuMorph new.	((1 to: 8), #(16 24 32)) do: [:w |		menu add: w printString			target: self			selector: #magnification:			argumentList: (Array with: w).		magnification = w ifTrue: [menu lastSubmorph color: Color red]].	menu popUpEvent: evt in: self world! !!GeeMailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2001 12:12'!makeGalleyStyle	| all first theRest |	(self valueOfProperty: #pageBreakRectangles ifAbsent: [#()]) do: [ :each |		each delete	].	self removeProperty: #pageBreakRectangles.	all := thePasteUp allTextPlusMorphs.	first := all select: [ :x | x predecessor isNil].	first size = 1 ifFalse: [^self].	Cursor wait show.	first := first first.	theRest := all reject: [ :x | x predecessor isNil].	theRest do: [ :each | each delete].	first autoFit: true.	first width: self width - 8.	first recomposeChain.	first repositionAnchoredMorphs.	Cursor normal show.! !!FatBitsPaint methodsFor: 'menu' stamp: 'sw 3/30/2002 16:48'!mouseMoveSelectionMode: evt        | p |        p := self pointGriddedFromEvent: evt.        lastMouse = p ifTrue: [^ self].        currentSelectionMorph ifNil:                [currentSelectionMorph := MarqueeMorph new                         color: Color transparent;                        borderWidth: 2;                        lock.                self addMorphFront: currentSelectionMorph.                currentSelectionMorph startStepping].        currentSelectionMorph                 bounds: ((Rectangle encompassing: {p. selectionAnchor}) translateBy: self position).        lastMouse := p! !!GeeBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/3/2000 11:48'!geeMail: aGeeMail	geeMail := aGeeMail.! !!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'ar 3/17/2001 14:27'!mouseDownPitch: midiKey event: event noteMorph: noteMorph	| pitch |	event hand hasSubmorphs ifTrue: [^ self  "no response if drag something over me"].	event hand mouseFocus ifNil:		["If dragged into me, then establish focus so I'll see moves"		event hand newMouseFocus: noteMorph event: event].	noteMorph color: playingKeyColor.	pitch := AbstractSound pitchForMIDIKey: midiKey + 23.	soundPlaying ifNotNil: [soundPlaying stopGracefully].	soundPlaying := soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3.	SoundPlayer resumePlaying: soundPlaying quickStart: true.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 1/31/98 01:36'!setDenominator: denom	denominator := denom.	self buildView! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:46'!digits: aNumber	digits := aNumber.	self removeAllMorphs.	1 to: digits do: [:i | self addMorph: (LedDigitMorph new color: color)].	self layoutChanged.	self changed.! !!SqueakPage class methodsFor: 'as yet unclassified' stamp: 'tk 1/15/1999 08:13'!stemUrl: aUrlString	"Peel off the 'x5.sp'  or '.bo' from the end of a url of a SqueakPage or a BookMorph index file"	| ll aUrl |	ll := aUrlString findLast: [:char | char == $.].	ll = 0 		ifTrue: [aUrl := aUrlString]		ifFalse: [aUrl := aUrlString copyFrom: 1 to: ll-1].	"remove .sp"	aUrl := (aUrl stemAndNumericSuffix) at: 1.			"remove trailing number"	aUrl size = 0 ifTrue: [^ aUrl].	"empty"	[aUrl last == $x] whileTrue: [aUrl := aUrl allButLast].	^ aUrl! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:43'!highlighted: aBoolean	highlighted := aBoolean.	self changed.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'di 7/28/2001 10:35'!makeSuccessorMorph	| newMorph |	self fixAllLeftOffsets.	newMorph := self copy predecessor: self successor: successor.	newMorph extent: self width @ 100.	successor ifNotNil: [successor setPredecessor: newMorph].	self setSuccessor: newMorph.	successor recomposeChain.	^newMorph! !!StringButtonMorph methodsFor: 'menu' stamp: 'wiz 1/16/2006 19:55'!clearTarget	target := nil.! !!TextPlusMorph methodsFor: 'event handling' stamp: 'RAA 9/13/2000 15:53'!mouseDown: evt	ignoreNextUp := false.	evt yellowButtonPressed ifTrue: [		^self doYellowButtonPress: evt	].	^super mouseDown: evt! !!BookMorph methodsFor: 'menu' stamp: 'tk 8/13/1998 12:09'!setNewPagePrototype	"Record the current page as the prototype to be copied when inserting new pages."	currentPage ifNotNil:		[newPagePrototype := currentPage veryDeepCopy].! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/1/2000 18:50'!scrollLoop: aBoolean	scrollLoop := aBoolean.! !!TextPlusMorph methodsFor: 'private' stamp: 'RAA 9/6/2000 15:52'!releaseParagraphReally	"Paragraph instantiation is lazy -- it will be created only when needed"	editor ifNotNil: [		self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor := nil].	paragraph ifNotNil: [paragraph := nil].	container ifNotNil: [container releaseCachedState]! !!RemoteHandMorph methodsFor: 'connections' stamp: 'RAA 7/12/2000 11:46'!startListening	"Create a socket and start listening for a connection."	self stopListening.	Transcript show: 'My address is ', NetNameResolver localAddressString; cr.	Transcript show: 'Remote hand ', self userInitials, ' waiting for a connection...'; cr.	socket := Socket new.	socket listenOn: 54323.	waitingForConnection := true.! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawPageForwardOn: aCanvas	"startForm shrinks in the given direction, revealing endForm."	| offset shrinkRect scale |	aCanvas drawImage: endForm at: self position.	offset := self stepFrom: 0@0 to: self extent * direction.	shrinkRect := (bounds translateBy: offset) intersect: bounds.	scale := shrinkRect extent asFloatPoint / bounds extent.	aCanvas drawImage: (startForm magnify: startForm boundingBox by: scale smoothing: 1)		at: shrinkRect topLeft.	((shrinkRect translateBy: direction negated) areasOutside: shrinkRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/13/2000 12:08'!removeJumpEndFor: aString	| anchors |	anchors := OrderedCollection new.	text runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			(att isMemberOf: TextPlusJumpEnd) ifTrue: [				att jumpLabel == aString ifTrue: [					anchors add: {att. start. stop}				]			]		]	].	anchors do: [ :old |		text removeAttribute: old first from: old second to: old third.	].! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 10/28/97 15:31'!afterNewPicDo: goodBlock ifNoBits: badBlock	"If the user said 'Save' at the end of drawing, do this block to save the picture.goodBlock takes 2 args, the painted form and the bounding rectangle of its bits.badBlock takes no args.  "	newPicBlock := goodBlock.	emptyPicBlock := badBlock.! !!SimpleSwitchMorph methodsFor: 'copying' stamp: 'jm 1/29/98 16:15'!updateReferencesUsing: aDictionary	"Copy and update references in the arguments array during copying."	super updateReferencesUsing: aDictionary.	arguments := arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!SqueakPage methodsFor: 'private' stamp: 'tk 2/25/1999 09:13'!computeThumbnail	"Make a thumbnail from my morph."	(contentsMorph isKindOf: PasteUpMorph) 		ifTrue: [thumbnail := contentsMorph smallThumbnailForPageSorter]		ifFalse: [self updateThumbnail]! !!BookMorph methodsFor: 'sorting' stamp: 'sw 3/5/1999 17:38'!morphsForPageSorter	| i thumbnails |	'Assembling thumbnail images...'		displayProgressAt: self cursorPoint		from: 0 to: pages size		during:			[:bar | i := 0.			thumbnails := pages collect:				[:p | bar value: (i:= i+1).				pages size > 40 					ifTrue: [p smallThumbnailForPageSorter inBook: self]					ifFalse: [p thumbnailForPageSorter inBook: self]]].	^ thumbnails! !!PaintBoxMorph methodsFor: 'recent colors' stamp: 'ar 7/8/2006 20:33'!fixUpColorPicker	| chart picker |	chart := ColorChart ifNil:[Cursor wait showWhile:[ColorChart := (ColorPickerMorph colorPaletteForDepth: 16 extent: 120@89)]].	chart getCanvas frameRectangle: chart boundingBox color: Color black.	picker := Form extent: (chart extent + (14@12)) depth: 16.	picker fillWhite.	"top"	picker copy: (0@0 extent: picker width@6)			from: (colorMemory image width - picker width)@0 			in: colorMemory image rule: Form over.	"bottom"	picker copy: (0@ (picker height-6) extent: picker width@6) 			from: (colorMemory image width - picker width)@(colorMemory image height - 7)			in: colorMemory image rule: Form over.	"left"	picker copy: (0@6 corner: 8@(picker height - 6))			from: (colorMemory image boundingBox topLeft + (0@6)) 			in: colorMemory image rule: Form over.	"right"	picker copy: (picker width-6@6 corner: picker width@(picker height - 6))			from: (colorMemory image boundingBox topRight - (6@-6)) 			in: colorMemory image rule: Form over.	chart displayOn: picker at: 8@6.	picker getCanvas frameRectangle: picker boundingBox color: Color black.	colorMemory image: picker.! !!CanvasCharacterScanner methodsFor: 'accessing' stamp: 'ls 9/25/1999 15:59'!canvas: aCanvas	"set the canvas to draw on"	canvas ifNotNil: [ self inform: 'initializing twice!!' ].	canvas := aCanvas! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 7/23/2000 16:42'!addAColumn: aCollectionOfMorphs	| col |	col := self inAColumn: aCollectionOfMorphs.	self addMorphBack: col.	^col! !!ScaleMorph methodsFor: 'initialization' stamp: 'RCS 3/16/2000 15:09'!start: strt stop: stp minorTick: mnt minorTickLength: mntLen majorTick: mjt majorTickLength: mjtLen caption: cap tickPrintBlock: blk labelsAbove: aBoolean captionAbove: notherBoolean 	start := strt.	stop := stp.	minorTick := mnt.	minorTickLength := mntLen.	majorTick := mjt.	majorTickLength := mjtLen.	caption := cap.	tickPrintBlock := blk.	labelsAbove := aBoolean.	captionAbove := notherBoolean.	self buildLabels! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/2/2000 14:14'!changeKeys	upDownCodes := Dictionary new.	changeKeysState := #(up down in out).	self changed.! !!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 5/24/2000 10:31'!hostWindow: x	hostWindow := x.	worldState canvas: nil.	"safer to start from scratch"	self viewBox: hostWindow panelRect.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'md 2/15/2006 18:44'!fixAllLeftOffsets	| am |	text runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			(att isMemberOf: TextAnchor) ifTrue: [				am := att anchoredMorph.				(am isNil or: [am world isNil]) ifFalse: [					am 						valueOfProperty: #geeMailLeftOffset 						ifAbsent: [							am setProperty: #geeMailLeftOffset toValue: am left - self left						]				]			]		]	].! !!StringButtonMorph methodsFor: 'submorphs-add/remove' stamp: ''!actWhen: aSymbol	"Set the condition under which to invoke my action to one of: #buttonDown, #buttonUp, and #whilePressed."	actWhen := aSymbol.! !!SketchEditorMorph methodsFor: 'access' stamp: ''!registrationPoint: aPoint	registrationPoint := aPoint! !!ThreadNavigationMorph methodsFor: 'navigation' stamp: 'nb 6/17/2003 12:25'!lastPage	listOfPages isEmpty ifTrue: [^Beeper beep].	currentIndex := listOfPages size.	self loadPageWithProgress.! !!URLMorph class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:52'!grabURL: aURLString	"Create a URLMorph for this url.  Drop it and click it to get the SqueakPage."	| um |	(um := self new) isBookmark: true; setURL: aURLString page: nil.	HandMorph attach: um.	^ um! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:18'!compileScript	| newScript prevMark prevSteps data |	self fixup.	newScript := OrderedCollection new.	prevMark := prevSteps := nil.	submorphs do: [ :each |		(each isKindOf: ZASMCameraMarkMorph) ifTrue: [			prevMark ifNotNil: [				data := Dictionary new.				data 					at: #steps put: prevSteps;					at: #startPoint put: (prevMark valueOfProperty: #cameraPoint);					at: #endPoint put: (each valueOfProperty: #cameraPoint);					at: #startZoom put: (prevMark valueOfProperty: #cameraScale);					at: #endZoom put: (each valueOfProperty: #cameraScale).				newScript add: data.			].			prevMark := each.		].		(each isKindOf: ZASMStepsMorph) ifTrue: [			prevSteps := each getStepCount.		].	].	^newScript! !!WaveEditor methodsFor: 'menu' stamp: 'di 7/16/1999 08:30'!showEnvelope	"Show an envelope wave constructed by collecting the maximum absolute value of the samples in fixed-size time windows of mSecsPerQuantum."	| data mSecsPerQuantum samplesPerQuantum result endOfQuantum maxThisQuantum s nSamples |	data := graph data.	mSecsPerQuantum := 10.	samplesPerQuantum := (mSecsPerQuantum / 1000.0) * self samplingRate.	result := WriteStream on: (Array new: data size // samplesPerQuantum).	endOfQuantum := samplesPerQuantum.	maxThisQuantum := 0.	nSamples := (data isKindOf: SoundBuffer)		ifTrue: [data monoSampleCount]		ifFalse: [data size].	1 to: nSamples do: [:i |		i asFloat > endOfQuantum ifTrue: [			result nextPut: maxThisQuantum.			maxThisQuantum := 0.			endOfQuantum := endOfQuantum + samplesPerQuantum].		s := data at: i.		s < 0 ifTrue: [s := 0 - s].		s > maxThisQuantum ifTrue: [maxThisQuantum := s]].	WaveEditor openOn: result contents.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'RAA 8/16/2000 11:28'!prepareToPaint: evt	"Figure out what the current brush, fill, etc is.  Return an action to take every mouseMove.  Set up instance variable and pens.  Prep for normal painting is inlined here.  tk 6/14/97 21:11"	| specialMode pfPen cColor cNib myBrush |	"Install the brush, color, (replace mode), and cursor."	specialMode := self getActionFor: evt. 	cColor  := self getColorFor: evt.	cNib := self getNibFor: evt.	self set: #brush for: evt to: (myBrush := cNib).	self set: #paintingFormPen for: evt to: (pfPen := Pen newOnForm: paintingForm).	self set: #stampForm for: evt to: nil.	"let go of stamp"	formCanvas := paintingForm getCanvas.	"remember to change when undo"	formCanvas := formCanvas		copyOrigin: self topLeft negated		clipRect: (0@0 extent: bounds extent).	specialMode == #paint: ifTrue: [		"get it to one bit depth.  For speed, instead of going through a colorMap every time ."		self set: #brush for: evt to: (myBrush := Form extent: myBrush extent depth: 1).		myBrush offset: (0@0) - (myBrush extent // 2).		cNib displayOn: myBrush at: (0@0 - cNib offset).		pfPen sourceForm: myBrush.		pfPen combinationRule: Form paint.		pfPen color: cColor.		cColor isTransparent ifTrue: [			pfPen combinationRule: Form erase1bitShape.			pfPen color: Color black].		^ #paint:].	specialMode == #erase: ifTrue: [		self erasePrep: evt.		^ #erase:].	specialMode == #stamp: ifTrue: [		self set: #stampForm for: evt to: palette stampForm.	"keep it"		^ #stamp:].	(self respondsTo: specialMode) 		ifTrue: [^ specialMode]	"fill: areaFill: pickup: (in mouseUp:) 				rect: ellipse: line: polygon: star:"		ifFalse: ["Don't recognise the command"			palette setAction: #paint: evt: evt.	"set it to Paint"			^ self prepareToPaint: evt].! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:03'!drawZoomFrameOn: aCanvas	"startForm and endFrom are both fixed, but a square border expands out from the center (or back), revealing endForm.	It's like passing through a portal."	| box innerForm outerForm boxExtent |	direction = #in		ifTrue: [innerForm := endForm.  outerForm := startForm.				boxExtent := self stepFrom: 0@0 to: self extent]		ifFalse: [innerForm := startForm.  outerForm := endForm.				boxExtent := self stepFrom: self extent to: 0@0].			aCanvas drawImage: outerForm at: self position.	box := Rectangle center: self center extent: boxExtent.	aCanvas drawImage: innerForm at: box topLeft sourceRect: (box translateBy: self position negated).	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!GeePrinterPage methodsFor: 'as yet unclassified' stamp: 'RAA 9/18/2000 16:00'!pageAsForm	| f canvas |	f := Form extent: bounds extent depth: 16.	canvas := f getCanvas.	canvas fillColor: pasteUp color.	canvas translateTo: bounds origin negated clippingTo: f boundingBox during: [ :c |		pasteUp fullDrawForPrintingOn: c	].	^f! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'sw 2/24/2003 15:57'!findEntry	"Prompt the user for a search string and find the next match for it"	| toFind searchIndex |	lastSearchString ifNil: [lastSearchString := 'controls'].	toFind := FillInTheBlank request: 'Type name or fragment: ' initialAnswer: lastSearchString.	toFind isEmptyOrNil ifTrue: [^ self].	lastSearchString := toFind asLowercase.	searchIndex := currentIndex + 1.	toFind := '*', lastSearchString, '*'.	[toFind match: (entryNames at: searchIndex) asString]		whileFalse:			[searchIndex := (searchIndex \\ entryNames size) + 1.			searchIndex == currentIndex ifTrue: [^ self inform: 'not found']].	currentIndex := searchIndex.	self updateThumbnail! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'sw 7/5/2004 03:10'!star: evt 	"Draw an star from the center."	| poly ext ww rect oldExt oldRect oldR verts pt cColor sOrigin priorEvt |	sOrigin := self get: #strokeOrigin for: evt.	cColor := self getColorFor: evt.	ww := (self getNibFor: evt) width.	ext := (pt := sOrigin - evt cursorPoint) r + ww * 2.	rect := Rectangle center: sOrigin extent: ext.	(priorEvt := self get: #lastEvent for: evt)		ifNotNil: [oldExt := (sOrigin - priorEvt cursorPoint) r + ww * 2.			"Last draw sticks out, must erase the area"			oldRect := Rectangle center: sOrigin extent: oldExt.			self restoreRect: oldRect].	ext := pt r.	oldR := ext.	verts := (0 to: 350 by: 36)				collect: [:angle | (Point r: (oldR := oldR = ext									ifTrue: [ext * 5 // 12]									ifFalse: [ext]) degrees: angle + pt degrees)						+ sOrigin].	poly := PolygonMorph new addHandles.	poly borderColor: (cColor isTransparent ifTrue: [Color black] ifFalse: [cColor]).	poly borderWidth: (self getNibFor: evt) width.	poly fillStyle: Color transparent.	"can't handle thick brushes"	self invalidRect: rect.	"self addMorph: poly."	poly privateOwner: self.	poly		bounds: (sOrigin extent: ext).	poly setVertices: verts.	poly drawOn: formCanvas.	"poly delete."	self invalidRect: rect! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawSlideBorderOn: aCanvas	"startForm and endFrom are both fixed, but a border slides in the given direction, revealing endForm.  (It's like opening a can of sardines ;-)."	| endRect box sourceRect boxLoc |	box := endForm boundingBox.	boxLoc := self stepFrom: box topLeft - (box extent * direction) to: box topLeft.	sourceRect := box translateBy: boxLoc.	endRect := sourceRect translateBy: self position.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas drawImage: startForm at: self position].	aCanvas drawImage: endForm at: self position + boxLoc sourceRect: sourceRect.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!ThumbnailMorph methodsFor: 'copying' stamp: 'ar 10/26/2000 23:55'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."objectToView := objectToView.		Weakly copied"viewSelector := viewSelector veryDeepCopyWith: deepCopier.lastSketchForm := lastSketchForm veryDeepCopyWith: deepCopier.lastFormShown := lastFormShown veryDeepCopyWith: deepCopier.drawTime := drawTime veryDeepCopyWith: deepCopier.! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 7/4/1998 14:12'!recolorTabs	"Prompt the user for new on and off colors for tabs"	| onColor offColor |	self inform: 'Choose the ''on'' color'.	onColor := Color fromUser.	self inform: 'Okay, now please choosethe ''off'' color'.	offColor := Color fromUser.	tabsMorph highlightColor: onColor regularColor: offColor.	currentPage ifNotNil:		[tabsMorph highlightTabFor: currentPage]! !!LedCharacterMorph methodsFor: 'accessing' stamp: 'kfr 6/12/2000 15:13'!char: aCharacter 	char := aCharacter digitValue.	char >= 0 & (char <= 35) ifFalse: [char := 36]! !!GraphMorph methodsFor: 'private' stamp: ''!drawDataOn: aCanvas	| yScale baseLine x start end value left top bottom right |	super drawOn: aCanvas.	data isEmpty ifTrue: [^ self].	maxVal = minVal ifTrue: [		yScale := 1.	] ifFalse: [		yScale := (bounds height - (2 * borderWidth)) asFloat / (maxVal - minVal)].	baseLine := bounds bottom - borderWidth + (minVal * yScale) truncated.	left := top := 0. right := 10. bottom := 0.	x := bounds left + borderWidth.	start := (startIndex asInteger max: 1) min: data size.	end := (start + bounds width) min: data size.	start to: end do: [:i |		left := x truncated. right := x + 1.		right > (bounds right - borderWidth) ifTrue: [^ self].		value := (data at: i) asFloat.		value >= 0.0 ifTrue: [			top := baseLine - (yScale * value) truncated.			bottom := baseLine.		] ifFalse: [			top := baseLine.			bottom := baseLine - (yScale * value) truncated].		aCanvas fillRectangle: (left@top corner: right@bottom) color: dataColor.		x := x + 1].! !!GraphMorph methodsFor: 'private' stamp: 'jm 4/21/1999 11:30'!keepIndexInView: index	| w newStart |	w := bounds width - (2 * borderWidth).	index < startIndex ifTrue: [		newStart := index - w + 1.		^ self startIndex: (newStart max: 1)].	index > (startIndex + w) ifTrue: [		^ self startIndex: (index min: data size)].! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 12/27/1998 23:28'!selectTab: aTab	| currentPalette morphToInstall oldTab aSketchEditor |	currentPage ifNotNil:		[self currentPalette currentPlayerDo:			[:aPlayer | aPlayer runAllClosingScripts]].	oldTab := tabsMorph highlightedTab.	(oldTab notNil and: [(morphToInstall := oldTab morphToInstall) isKindOf: PaintBoxMorph])		ifTrue:			[(aSketchEditor := self world submorphOfClass: SketchEditorMorph) ifNotNil:				[aSketchEditor cancelOutOfPainting].			morphToInstall delete].	tabsMorph selectTab: aTab.	morphToInstall := aTab morphToInstall.	(morphToInstall isKindOf: PaintBoxMorph) "special case, maybe generalize this need?"		ifFalse:			[self goToPageMorph: morphToInstall]		ifTrue:			[self showNoPaletteAndHighlightTab: aTab.			self world addMorphFront: morphToInstall.			morphToInstall position: ((self left max: 90) "room for the pop-out-to-left panel"				@ (tabsMorph bottom))].		(currentPalette := self currentPalette) ifNotNil:		[currentPalette layoutChanged.		currentPalette currentPlayerDo: [:aPlayer | aPlayer runAllOpeningScripts]].	self snapToEdgeIfAppropriate! !!MenuMorph methodsFor: '*MorphicExtras-accessing' stamp: 'dgd 8/30/2003 20:44'!allWordings	"Answer a collection of the wordings of all items and subitems, omitting the window-list in the embed... branch and (unless a certain hard-coded preference is set) also omitting items from the debug menu"	| verboten |	verboten := OrderedCollection with: 'embed into'.	Preferences debugMenuItemsInvokableFromScripts 		ifFalse:	[verboten add: 'debug...' translated].	^ self allWordingsNotInSubMenus: verboten! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/6/2001 14:16'!retractIfAppropriate	mouseInside := false.	self positionVertically.! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'mu 8/9/2003 22:40'!setFont	foregroundColor := self defaultTextColor.	super setFont.	destY := lineY + line baseline - font ascent! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:34'!clear: clearButton with: clearSelector evt: evt	| ss |	(ss := self focusMorph) 		ifNotNil: [ss clearPainting: self]		ifNil: [self notCurrentlyPainting].	clearButton state: #off.! !!URLMorph methodsFor: 'accessing' stamp: 'jm 6/17/1998 07:17'!isBookmark: aBoolean	"Make this morph behave as a clickable bookmark if the argument is true."	isBookmark := aBoolean.! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/2/2004 01:27'!fontsForComicBold	| d |	"Bold = 1, Ital = 2, Under = 4, Narrow = 8, Struckout = 16"	d := Dictionary new.	d		at: 0 put: #('Helvetica-Narrow-Bold' 0.9);		at: 1 put: #('Helvetica-Narrow-Bold' 0.9);		at: 2 put: #('Helvetica-Narrow-BoldOblique' 0.9);		at: 3 put: #('Helvetica-Narrow-BoldOblique' 0.9).	^d! !!SqueakPage methodsFor: 'accessing' stamp: 'ar 4/10/2005 18:52'!fetchInformIfError	"Make every effort to get contentsMorph.  Put up a good notice if can't get it.  Assume page is in the cache already.  Overwrite the contentsMorph no matter what."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm := (ServerFile new fullPath: url) asStream].	strm isString ifTrue: [self inform: 'Sorry, ',strm. ^ nil].	"<<<<< Note Diff"	(url beginsWith: 'file:') ifTrue: [Transcript show: 'Fetching  ', url; cr].		page := strm fileInObjectAndCode.	page isMorph 		ifTrue: [contentsMorph := page]	"may be a bare morph"		ifFalse: ["copy over the state"			temp := url.			temp2 := policy.			self copyFrom: page.	"including contentsMorph"			url := temp.	"I know best!!"			temp2 ifNotNil: [policy := temp2]].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	contentsMorph setProperty: #SqueakPage toValue: self.	self dirty: false.	^ contentsMorph! !!CommandHistory methodsFor: 'called by programmer' stamp: 'ar 8/31/2000 22:46'!cantUndo	"Called by client to indicate that the prior undoable command is no longer undoable"	lastCommand := nil.	history := OrderedCollection new.! !!TransitionMorph methodsFor: 'initialization' stamp: 'di 12/22/1998 13:32'!showTransitionFrom: startingMorph to: endingMorph in: containingMorph	whenStart: firstBlock whenDone: doneBlock	effect == #none ifTrue: [firstBlock value.  ^ doneBlock value].	self startMorph: startingMorph endMorph: endingMorph		startBlock: firstBlock completionBlock: doneBlock.	stepNumber := 0.	self bounds: startingMorph bounds.	endingMorph privateOwner: self.  "Allows test of transition in progress"	containingMorph owner privateAddMorph: self atIndex: 		(containingMorph owner submorphs indexOf: containingMorph).	self initiateReplacement! !!TheWorldMenu methodsFor: '*MorphicExtras-construction' stamp: 'RAA 6/2/2000 08:48'!myMenuColor	| c |	c := myWorld color.	c isColor ifTrue: [^c atLeastAsLuminentAs: 0.2].	^Color white! !!StringButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:47'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].arguments := arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!EmbeddedWorldBorderMorph methodsFor: 'layout' stamp: 'RAA 6/26/2000 18:46'!minWidth: anInteger	minWidth := anInteger! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 12:03'!editAScript	| d names reply s |	d := self targetScriptDictionary.	names := d keys asSortedCollection.	reply := (SelectionMenu labelList: names selections: names) startUpWithCaption: 'Script to edit?'.	reply ifNil: [^ self].	(s := ZASMScriptMorph new)		decompileScript: (d at: reply) named: reply for: self;		fullBounds;		align: s center with: self center;		openInWorld	! !!TickIndicatorMorph methodsFor: 'accessing' stamp: 'ar 2/11/2001 20:32'!isTicking: aBool	isTicking := aBool.! !!Command methodsFor: 'initialization' stamp: 'sw 8/29/2000 14:13'!phase: aPhase	"Set the phase of the command to the supplied symbol"	phase := aPhase! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 8/28/2000 11:26'!useRegularWarpBlt: aBoolean	useRegularWarpBlt := aBoolean! !!SqueakPage methodsFor: 'accessing' stamp: 'jm 6/16/1998 18:12'!title: aString	aString isEmpty		ifTrue: [title := nil]		ifFalse: [title := aString].! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'nb 6/17/2003 12:25'!renameGraphicTo: newName	| curr |	curr := entryNames at: currentIndex.	(newName isEmptyOrNil or: [newName = curr]) ifTrue: [^ Beeper beep].	(baseDictionary includesKey: newName) ifTrue:		[^ self inform: 'sorry that conflicts withthe name of anotherentry in this dictionary'].	baseDictionary at: newName put: (baseDictionary at: curr).	baseDictionary removeKey: curr.	self baseDictionary: baseDictionary.	currentIndex := entryNames indexOf: newName.	self updateThumbnail! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/8/2000 14:42'!installRollBackButtons	| all |	"In each script in me, put a versions button it the upper right."	all := IdentitySet new.	self allMorphsAndBookPagesInto: all.	all := all select: [:mm | mm class = MethodMorph].	all do: [:mm | mm installRollBackButtons: self].! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 9/25/1999 21:50'!pasteSelection        | relativeBounds tempForm |        currentSelectionMorph ifNil: [^ nil].        FormClipboard ifNil: [^nil].        relativeBounds := currentSelectionMorph bounds translateBy: self position negated.        tempForm := (FormClipboard magnify: FormClipboard boundingBox by: magnification).        self form                copy: (relativeBounds origin extent: tempForm boundingBox extent)                from: 0@0                in: tempForm                rule: Form over.         self revealPenStrokes! !!ProjectNavigationMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:30'!initialize	"initialize the state of the receiver"	super initialize.	""	self layoutInset: 6;	  hResizing: #shrinkWrap;	  vResizing: #shrinkWrap;	  useRoundedCorners.	mouseInside := false.	self addButtons! !!Thumbnail methodsFor: 'thumnail creation' stamp: 'nk 9/1/2004 18:10'!makeThumbnailFromForm: aForm	"Make a thumbnail from the form provided, obeying my min and max width and height preferences"	|  scaleX scaleY margin opaque |	scaleY := minimumHeight / aForm height.  "keep height invariant"	scaleX := ((aForm width * scaleY) <= maximumWidth)		ifTrue: [scaleY]  "the usual case; same scale factor, to preserve aspect ratio"		ifFalse: [scaleY := maximumWidth / aForm width].	"self form: (aForm magnify: aForm boundingBox by: (scaleX @ scaleY) smoothing: 2)."	"Note: A problem with magnify:by: fails to reproduce borders properly.		The following code does a better job..."	margin := 1.0 / (scaleX@scaleY) // 2 max: 0@0.  "Extra margin around border"	opaque := (Form extent: aForm extent + margin depth: 32) "fillWhite".	aForm fixAlpha displayOn: opaque at: aForm offset negated rule: Form blendAlpha.  "Opaque form shrinks better"	opaque fixAlpha.	self form: (opaque magnify: opaque boundingBox by: (scaleX @ scaleY) smoothing: 2).	self extent: originalForm extent! !!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 11/20/1999 15:11'!initialize	super initialize.	parentWorld := World.! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/11/2000 15:35'!grabCameraPositionEvent: anEvent morph: aMorph 	| mark |	mark := ZASMCameraMarkMorph new.	mark 		cameraPoint: self cameraPoint		cameraScale: self cameraScale		controller: self		page: target.	anEvent hand attachMorph: mark.! !!PrintSpecifications class methodsFor: 'as yet unclassified' stamp: 'RAA 9/18/2000 09:29'!defaultSpecs: aPrintSpecification	DefaultSpecs := aPrintSpecification! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:06'!scaleBy: evt 	"up-down is scale. 3/26/97 tk Now a slider on the right."	| pt temp cy oldRect amt myBuff |	myBuff := self get: #buff for: evt.	pt := evt cursorPoint - bounds center.	cy := bounds height * 0.5.	oldRect := myBuff boundingBox expandBy: myBuff extent * cumMag / 2.	amt := pt y abs < 12				ifTrue: ["detent"					1.0]				ifFalse: [pt y - (12 * pt y abs // pt x)].	amt := amt asFloat / cy + 1.0.	temp := myBuff				rotateBy: cumRot				magnify: amt				smoothing: 2.	cumMag > amt		ifTrue: ["shrinking"			oldRect := oldRect translateBy: paintingForm center - oldRect center + myBuff offset.			paintingForm				fill: (oldRect expandBy: 1 @ 1)				rule: Form over				fillColor: Color transparent].	temp displayOn: paintingForm at: paintingForm center - temp center + myBuff offset.	scaleButton position: scaleButton position x @ (evt cursorPoint y - 6).	self render: bounds.	cumMag := amt! !!LedCharacterMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:55'!initialize	"initialize the state of the receiver"	super initialize.	""		highlighted := false.	char := 0! !!ZoomAndScrollControllerMorph methodsFor: 'event handling' stamp: 'RAA 12/1/2000 15:23'!mouseDown: evt	mouseDownPoint := evt cursorPoint.	self changed.! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 11/28/2006 08:55'!defaultsQuadsDefiningToolsFlap	"Answer a structure defining the default Tools flap.	previously in quadsDefiningToolsFlap"	^ OrderedCollection new	addAll: #(	(Browser 				prototypicalToolWindow		'Browser'			'A Browser is a tool that allows you to view all the code of all the classes in the system')	(TranscriptStream		openMorphicTranscript				'Transcript'			'A Transcript is a window usable for logging and debugging; browse references to #Transcript for examples of how to write to it.')	(Workspace			prototypicalToolWindow		'Workspace'			'A Workspace is a simple window for editing text.  You can later save the contents to a file if you desire.'));		add: {   FileList2 .				#prototypicalToolWindow.				'File List'.				'A File List is a tool for browsing folders and files on disks and FTP servers.' };	addAll: #(	(DualChangeSorter		prototypicalToolWindow		'Change Sorter'		'Shows two change sets side by side')	(SelectorBrowser		prototypicalToolWindow		'Method Finder'		'A tool for discovering methods by providing sample values for arguments and results')	(MessageNames		prototypicalToolWindow		'Message Names'		'A tool for finding, viewing, and editing all methods whose names contain a given character sequence.')	(Preferences			preferencesControlPanel	'Preferences'			'Allows you to control numerous options')	(Utilities				recentSubmissionsWindow	'Recent'				'A message browser that tracks the most recently-submitted methods')	(ProcessBrowser		prototypicalToolWindow		'Processes'			'A Process Browser shows you all the running processes')	(Preferences			annotationEditingWindow	'Annotations'		'Allows you to specify the annotations to be shown in the annotation panes of browsers, etc.')		(PackagePaneBrowser	prototypicalToolWindow		'Packages'			'Package Browser:  like a System Browser, except that if has extra level of categorization in the top-left pane, such that class-categories are further organized into groups called "packages"')	(ChangeSorter			prototypicalToolWindow		'Change Set'			'A tool that allows you to view and manipulate all the code changes in a single change set'));		yourself! !!ZoomAndScrollControllerMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:36'!initialize	"initialize the state of the receiver"	| displayer dataMorph |	super initialize.	""	hasFocus := true.	currentKeyDown := Set new.	upDownCodes := Dictionary new.	upDownCodes at: 126 put: #up;		 at: 125 put: #down;		 at: 123 put: #out;		 at: 124 put: #in.	"arrow keys on the mac"	self extent: 40 @ 40;		 vResizing: #rigid;		 hResizing: #spaceFill;		 setBalloonText: 'Drag in here to zoom, tilt and pan the page above'.	dataMorph := AlignmentMorph newColumn.	dataMorph color: Color yellow;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap.	dataMorph		on: #mouseDown		send: #grabCameraPositionEvent:morph:		to: self.	displayer := UpdatingStringMorph new getSelector: #cameraPointRounded;				 target: self;				 growable: true;				 putSelector: nil.	dataMorph addMorph: displayer lock.	displayer := UpdatingStringMorph new getSelector: #cameraScale;				 target: self;				 growable: true;				 floatPrecision: 0.001;				 putSelector: nil.	dataMorph addMorph: displayer lock.	self addMorph: dataMorph! !!WaveEditor methodsFor: 'menu' stamp: 'dgd 9/19/2003 12:47'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu := CustomMenu new.	aMenu addList:	{		{'play straight through' translated.	#play}.		{'play before cursor' translated.	#playBeforeCursor}.		{'play after cursor' translated.		#playAfterCursor}.		{'play test note' translated.			#playTestNote}.		{'play loop' translated.				#playLoop}.		{'trim before cursor' translated.	#trimBeforeCursor}.		{'trim after cursor' translated.		#trimAfterCursor}.		{'choose loop start' translated.		#chooseLoopStart}.		{'jump to loop start' translated.		#jumpToLoopStart}.		{'jump to loop end' translated.		#jumpToLoopEnd}.		{'make unlooped' translated.		#setUnlooped}.		{'make unpitched' translated.		#setUnpitched}.		{'show envelope' translated.		#showEnvelope}.		{'show FFT' translated.				#showFFTAtCursor}}.	aMenu invokeOn: self defaultSelection: nil.! !!SketchEditorMorph methodsFor: 'palette handling' stamp: 'RAA 8/31/2000 14:03'!dimTheWindow	"Updated to use TranslucentColor by kfr 10/5 00"	"Do not call twice!! Installs a morph with an 'onion-skinned' copy of the pixels behind me." 	"create an 'onion-skinned' version of the stuff on the screen"	owner outermostMorphThat: [:morph | morph resumeAfterDrawError. false].	"an experiment for Nebraska to see if opaque background speeds things up""----- now using the color variable to control background	bgColor := false ifTrue: [TranslucentColor r:1.0 g:1.0 b:1.0 alpha:0.5] ifFalse: [Color white].	dimForm := (RectangleMorph new color: bgColor; bounds: self bounds; borderWidth: 0).	dimForm position: self position.	owner		privateAddMorph: dimForm		atIndex: (owner submorphs indexOf: self) + 1.-----"! !!EnvelopeLineMorph methodsFor: 'editing' stamp: 'ar 3/17/2001 14:38'!dragVertex: ix event: evt fromHandle: handle	| p |	super dragVertex: ix event: evt fromHandle: handle.	p := owner acceptGraphPoint: evt cursorPoint at: ix.	self verticesAt: ix put: p.! !!AtomMorph methodsFor: 'accessing' stamp: ''!velocity: newVelocity	velocity := newVelocity.! !!BookMorph methodsFor: 'submorphs-accessing' stamp: 'tk 12/17/1998 11:19'!allNonSubmorphMorphs	"Return a collection containing all morphs in this morph which are not currently in the submorph containment hierarchy.  Especially the non-showing pages in BookMorphs.    (As needed, make a variant of this that brings in all pages that are not in memory.)"	| coll |	coll := OrderedCollection new.	pages do: [:pg |		pg isInMemory ifTrue: [			pg == currentPage ifFalse: [coll add: pg]]].	^ coll! !!ThreadNavigationMorph methodsFor: 'navigation' stamp: 'nb 6/17/2003 12:25'!nextPage	self currentIndex >= listOfPages size ifTrue: [^Beeper beep].	currentIndex := self currentIndex + 1.	self loadPageWithProgress.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnlooped	"Make this sound play straight through without looping."	loopLength := 0.	loopCycles := 1.! !!TickIndicatorMorph methodsFor: 'drawing' stamp: 'ar 2/12/2001 17:50'!drawOn: aCanvas	| r center cc deg |	super drawOn: aCanvas.	corners ifNil:[		r := (bounds topCenter - bounds center) r - 2.		corners := Array new: 32.		1 to: corners size do:[:i|			deg := 360.0 / corners size * (i-1).			corners at: i put: (Point r: r degrees: deg-90) asIntegerPoint]].	index := index \\ corners size.	cc := color darker.	center := bounds center.	1 to: corners size by: 4 do:[:i|		aCanvas fillRectangle: (center + (corners at: i)-2  extent: 4@4) color: cc.	].	cc := cc darker.	aCanvas line: center to: center + (corners at: index + 1) width: 2 color: cc.! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 13:16'!buildView	| frame |	self color: Color lightGreen.	self removeAllMorphs.	frame := self innerBounds.	self buildGraphAreaIn: frame.	self buildScalesIn: frame.	self addHandlesIn: frame.	self addCurves.	line addHandles.	self addControls.	self addKeyboard! !!MagnifierMorph class methodsFor: 'instance creation' stamp: 'sw 6/25/2001 13:33'!newRound	"Answer a round Magnifier"	| aMagnifier sm |	aMagnifier := self new.	sm := ScreeningMorph new position: aMagnifier position.	sm addMorph: aMagnifier.	sm addMorph: (EllipseMorph newBounds: aMagnifier bounds).	sm setNameTo: 'Magnifier'.	^ sm! !!FrameRateMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	lastDisplayTime := 0.	framesSinceLastDisplay := 0! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:03'!drawSlideOverOn: aCanvas	"endMorph slides in the given direction, covering up the startMorph."	| endLoc endRect |	endLoc := self stepFrom: self position - (self extent * direction) to: self position.	endRect := endForm boundingBox translateBy: endLoc.	((endRect expandBy: 1) containsRect: aCanvas clipRect) ifFalse:		[aCanvas drawImage: startForm at: self position].	aCanvas drawImage: endForm at: endLoc.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!ObjectsTool methodsFor: 'major modes' stamp: 'nk 9/3/2004 13:32'!modeSymbol: aSymbol	"Set the receiver's modeSymbol as indicated"	modeSymbol := aSymbol.	self tweakAppearanceAfterModeShift.! !!TabbedPalette methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:07'!setInitialState	super setInitialState.""	self layoutInset: 0.	pageSize := 156 @ 232! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/3/2000 21:27'!chars: aNumber 	chars := aNumber.	self removeAllMorphs.	1 to: chars do: [:i | self addMorph: (LedCharacterMorph new color: color)].	self layoutChanged.	self changed! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:05'!copyUrl	"Copy this page's url to the clipboard"	| str |	str := currentPage url ifNil: [str := 'Page does not have a url.  Send page to server first.' translated].	Clipboard clipboardText: str asText.! !!MagnifierMorph methodsFor: 'round view' stamp: 'di 9/28/1999 23:16'!toggleRoundness	| sm w |	w := self world.	self isRound		ifTrue: [owner delete.				w addMorph: self]		ifFalse: [sm := ScreeningMorph new position: self position.				sm addMorph: self.				sm addMorph: (EllipseMorph newBounds: self bounds).				w addMorph: sm]! !!MarqueeMorph methodsFor: 'initialization' stamp: 'RAA 9/25/1999 21:26'!initialize        super initialize.        colors := {Color red. Color white. Color blue}.        count := 0! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 15:00'!clear	"wipe out all existing stamps"	stamps := OrderedCollection new: 16.	thumbnailPics := OrderedCollection new: 16.	stampButtons do: [:each | 		stamps addLast: nil.	"hold a space"		thumbnailPics addLast: nil].	start := 1.	self normalize.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'sw 8/29/2000 15:31'!indicateColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt feedbackColor |	pt := Sensor cursorPoint.	"deal with the fact that 32 bit displays may have garbage in the alpha bits"	feedbackColor := Display depth = 32		ifTrue: [ Color colorFromPixelValue: ((Display pixelValueAt: pt) bitOr: 16rFF000000) depth: 32] 		ifFalse: [Display colorAt: pt].	self activeHand position: pt.	self world displayWorldSafely.	Display fill: colorPatch bounds fillColor: feedbackColor.	^ feedbackColor	! !!ReferenceMorph methodsFor: 'event handling' stamp: 'sw 10/26/2000 14:41'!mouseUp: evt	"The mouse came up in the receiver; If the mouse is still within the receiver at this point, do the corresponding action"	| aColor |	(aColor := self valueOfProperty: #oldColor) ifNotNil: [self color: aColor].	(self containsPoint: evt cursorPoint)		ifTrue: [self doButtonAction].	super mouseUp: evt "send to evt handler if any"! !!ScreeningMorph methodsFor: 'menu' stamp: 'di 6/3/1999 16:41'!chooseBlockingColor	passingColor := Color fromUser.	passElseBlock := false.	self layoutChanged! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'dgd 9/19/2003 14:50'!addRotationScaleHandles	"Rotation and scaling handles"	rotationButton := SketchMorph withForm: (palette rotationTabForm).	rotationButton position: bounds topCenter - (6@0).	rotationButton on: #mouseDown send: #rotateScalePrep: to: self.	rotationButton on: #mouseMove send: #rotateBy: to: self.	rotationButton on: #mouseUp send: #rotateDone: to: self.	rotationButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	rotationButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: rotationButton.	rotationButton setBalloonText: 'Drag me sideways torotate yourpicture.' translated.	scaleButton := SketchMorph withForm: (palette scaleTabForm).	scaleButton position: bounds rightCenter - ((scaleButton width)@6).	scaleButton on: #mouseDown send: #rotateScalePrep: to: self.	scaleButton on: #mouseMove send: #scaleBy: to: self.	scaleButton on: #mouseEnter send: #mouseLeave: to: self.	"Put cursor back"	scaleButton on: #mouseLeave send: #mouseEnter: to: self.	self addMorph: scaleButton.	scaleButton setBalloonText: 'Drag me up and down to changethe sizeof your picture.' translated."REMOVED:	fwdButton := PolygonMorph new.	pt := bounds topCenter.	fwdButton borderWidth: 2; makeOpen; makeBackArrow; borderColor:(Color r: 0 g: 0.8 b: 0).	fwdButton removeHandles; setVertices: (Array with: pt+(0@7) with:pt+(0@22)).	fwdButton on: #mouseMove send: #forward:direction: to: self.	fwdButton on: #mouseEnter send: #mouseLeave: to: self.		fwdButton on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdButton toValue: fwdButton.	self addMorph: fwdButton.	fwdButton setBalloonText: 'Drag me around to pointin the directionI go forward.' translated.	toggle := EllipseMorph		newBounds: (Rectangle center: fwdButton vertices last +(-4@4) extent: 8@8)		color: Color gray.	toggle on: #mouseUp send: #toggleDirType:in: to: self.	toggle on: #mouseEnter send: #mouseLeave: to: self.	toggle on: #mouseLeave send: #mouseEnter: to: self.	self setProperty: #fwdToggle toValue: toggle.	fwdButton addMorph: toggle.	toggle setBalloonText: 'When your object turns,how should itspicture change?It can rotate, face left or right,face up or down, or notchange.' translated.	"	self setProperty: #rotationStyle toValue: hostView rotationStyle."	self forward: hostView setupAngle direction: fwdButton.	"	"Set to its current value"! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/28/1998 02:29'!errorBetween: sampleArray1 and: sampleArray2	"Answer the cummulative error between the two sample arrays, which are assumed to be the same size."	| error e |	error := 0.	1 to: sampleArray1 size do: [:i |		e := (sampleArray1 at: i) - (sampleArray2 at: i).		e < 0 ifTrue: [e := 0 - e].		error := error + e].	^ error! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/2/2001 14:13'!doJumpTo: aString	| myStart myStop |	myStart := myStop := nil.	text runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			((att isMemberOf: TextPlusJumpEnd) and: [att jumpLabel = aString]) ifTrue: [				myStart 					ifNil: [myStart := start. myStop := stop] 					ifNotNil: [myStart := myStart min: start. myStop := myStop max: stop].			]		]	].	myStart ifNil: [^self].	self editor selectFrom: myStart to: myStop.	ignoreNextUp := true.	self changed.	self scrollSelectionToTop.! !!BookMorph methodsFor: 'menu' stamp: 'em 3/30/2005 14:35'!menuPageSoundFor: target event: evt	| tSpec menu |	tSpec := self transitionSpecFor: target.	menu := (MenuMorph entitled: 'Choose a sound(it is now ' translated, tSpec first translated, ')') defaultTarget: target.	SoundService default sampledSoundChoices do:		[:soundName |		menu add: soundName translated target: target			selector: #setProperty:toValue:			argumentList: (Array with: #transitionSpec								with: (tSpec copy at: 1 put: soundName; yourself))].	menu popUpEvent: evt in: self world! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 7/20/2009 09:45'!initializeFlapsQuads	"initialize the list of dynamic flaps quads.	self initializeFlapsQuads"	FlapsQuads _ nil. 	self registeredFlapsQuads at: 'PlugIn Supplies' put: self defaultsQuadsDefiningPlugInSuppliesFlap;		 at: 'Stack Tools' put: self defaultsQuadsDefiningStackToolsFlap;		 at: 'Supplies' put: self defaultsQuadsDefiningSuppliesFlap;		 at: 'Tools' put: self defaultsQuadsDefiningToolsFlap;		 at: 'Widgets' put: self defaultsQuadsDefiningWidgetsFlap..	^ self registeredFlapsQuads! !!PostscriptCanvas class methodsFor: 'testing' stamp: 'nk 1/1/2004 20:21'!morphAsPostscript:aMorph rotated:rotateFlag offsetBy:offset | psCanvas |  psCanvas := self new.  psCanvas reset.  psCanvas bounds: (0@0 extent: (aMorph bounds extent + (2 * offset))).  psCanvas topLevelMorph:aMorph.  psCanvas resetContentRotated: rotateFlag.  psCanvas fullDrawMorph: aMorph .  ^psCanvas contents.! !!BookMorph methodsFor: 'other' stamp: 'RAA 8/23/2000 12:43'!exitFullScreen	| floater |	self isInFullScreenMode ifFalse: [^self].	self setProperty: #fullScreenMode toValue: false.	floater := self valueOfProperty: #floatingPageControls ifAbsent: [nil].	floater ifNotNil: [		floater delete.		self removeProperty: #floatingPageControls.	].	self position: 0@0.	self adjustCurrentPageForFullScreen.! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/15/2000 21:44'!stop: aNumber	stop := aNumber.! !!CommandHistory methodsFor: 'initialize' stamp: 'ar 8/31/2000 22:50'!initialize	lastCommand := nil.	history := OrderedCollection new.	excursions := OrderedCollection new.! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 11/9/2000 17:46'!switchToThread: newName	threadName := newName.	listOfPages := self class knownThreads at: threadName.	self removeAllMorphs.	self addButtons.	self currentIndex.! !!SoundLoopMorph methodsFor: 'as yet unclassified' stamp: 'jm 1/5/98 17:31'!buildSound	"Build a compound sound for the next iteration of the loop."	| mixer soundMorphs startTime pan |	mixer := MixedSound new.	mixer add: (RestSound dur: (self width - (2 * borderWidth)) / 128.0).	soundMorphs := self submorphs select: [:m | m respondsTo: #sound].	soundMorphs do: [:m |		startTime := (m position x - (self left + borderWidth)) / 128.0.		pan := (m position y - (self top + borderWidth)) asFloat / (self height - (2 * borderWidth) - m height).		mixer add: ((RestSound dur: startTime), m sound copy) pan: pan].	^ mixer! !!FatBitsPaint methodsFor: 'menu' stamp: 'nb 6/17/2003 12:25'!fileOut        | fileName result |        result := StandardFileMenu newFile ifNil: [^Beeper beep].        fileName := result directory fullNameFor: result name.        Cursor normal showWhile:                [self unmagnifiedForm writeOnFileNamed: fileName]! !!StickyPadMorph methodsFor: 'parts bin' stamp: 'sw 4/3/2003 15:25'!initializeToStandAlone	"Initialize the receiver to stand alone.  Use the next color in the standard sequence."	Colors ifNil: [self initialize].	LastColorIndex := 		LastColorIndex			ifNil:				[1]			ifNotNil:				[(LastColorIndex \\ Colors size) + 1].	super initializeToStandAlone.	self assureExternalName.	self color: (Colors at: LastColorIndex).	self extent: 100@80.	self borderWidth: 0	! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/7/2000 16:23'!textPlusMenuFor: aMorph	| menu |	menu := MenuMorph new.	menu 		add: 'Link to text selection' 		target: [self addAlansAnchorFor: aMorph] fixTemps		selector: #value;		add: 'Unlink from text selection' 		target: [self removeAlansAnchorFor: aMorph] fixTemps		selector: #value;		add: 'Delete' 		target: [			self removeAlansAnchorFor: aMorph.			aMorph delete.		] fixTemps		selector: #value.	^menu! !!Component methodsFor: 'naming' stamp: 'di 5/3/1998 19:50'!nameMeIn: aWorld	| stem otherNames i partName className |	className := self class name.	stem := className.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem := stem copyFrom: 1 to: stem size - 5].	stem := stem first asLowercase asString , stem allButFirst.	otherNames := Set newFrom: aWorld allKnownNames.	i := 1.	[otherNames includes: (partName := stem , i printString)]		whileTrue: [i := i + 1].	self setNamePropertyTo: partName! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:31'!cameraPoint: newPt	| transform |	transform := self myTransformMorph.	self changeOffsetTo: newPt * transform scale - (transform innerBounds extent // 2) ! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/7/2000 15:08'!revertToCheckpoint: secsSince1901	| cngRecord |	"Put all scripts (that appear in MethodPanes) back to the way they were at an earlier time."	MethodHolders do: [:mh | 		cngRecord := mh versions versionFrom: secsSince1901.		cngRecord ifNotNil: [			(cngRecord stamp: Utilities changeStamp) fileIn]].		"does not delete method if no earlier version"! !!GeeMailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/4/2001 09:21'!scrollSelectionIntoView: event alignTop: alignTop inTextMorph: tm	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selRects := tm paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest := selRects first merge: selRects last.	transform := scroller transformFrom: self.	(event notNil and: [event isMouse and: [event anyButtonPressed]]) ifTrue:  "Check for autoscroll"		[cpHere := transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest := selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest := selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect := transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	alignTop ifTrue: [		self scrollBy: 0@(bounds top - selRect top).		^ true	].	selRect bottom > bounds bottom ifTrue: [		self scrollBy: 0@(bounds bottom - selRect bottom - 30).		^ true	].	(delta := selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue: [		"Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!DropDownChoiceMorph methodsFor: 'accessing' stamp: 'bolot 11/2/1999 12:20'!border: newBorder	border := newBorder! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 15:23'!fromGIFFileNamed: fileName	| reader |	reader := AnimatedGIFReadWriter formsFromFileNamed: fileName.	^reader forms size = 1		ifTrue: [ ImageMorph new image: reader forms first ]		ifFalse: [ self new fromReader: reader ]! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/16/2000 15:54'!setTransition: evt	| tSpec menu subMenu directionChoices |	tSpec := self 		valueOfProperty: #transitionSpec		ifAbsent: [			(self valueOfProperty: #bookPage) 				valueOfProperty: #transitionSpec				ifAbsent: [{ 'silence' . #none. #none}]		].	menu := (MenuMorph entitled: 'Choose an effect(it is now ' , tSpec second , ')') defaultTarget: self.	TransitionMorph allEffects do: [:effect |		directionChoices := TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect target: self					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu := MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir target: self						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect subMenu: subMenu]].	menu popUpEvent: evt in: self world! !!ScrollableField methodsFor: 'contents' stamp: 'sw 4/7/2002 18:48'!setMyText: someText	"Set my text, as indicated"	| toUse |	toUse := someText ifNil: [''].	myContents := toUse.	self setText: toUse.	^ true! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: ''!transform:newTransform	transform := newTransform.	^self.! !!BookPageSorterMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:36'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.book := deepCopier references at: book ifAbsent: [book].! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'nk 1/6/2004 12:37'!repaintEntry	"Let the user enter into painting mode to repaint the item and save it back."	| aWorld bnds sketchEditor aPaintBox formToEdit |		(aWorld := self world) assureNotPaintingElse: [^ self].	aWorld prepareToPaint.	aWorld displayWorld.	formToEdit := formChoices at: currentIndex.	bnds := (submorphs second boundsInWorld origin extent: formToEdit extent) intersect: aWorld bounds.	bnds := (aWorld paintingBoundsAround: bnds center) merge: bnds.	sketchEditor := SketchEditorMorph new.	aWorld addMorphFront: sketchEditor.	sketchEditor initializeFor: ((World drawingClass withForm: formToEdit) position: submorphs second positionInWorld)  inBounds: bnds pasteUpMorph: aWorld paintBoxPosition: bnds topRight.	sketchEditor		afterNewPicDo: [:aForm :aRect |			formChoices at: currentIndex put: aForm.			baseDictionary at: (entryNames at: currentIndex) put: aForm.			self updateThumbnail.			(aPaintBox := aWorld paintBoxOrNil) ifNotNil: [aPaintBox delete]] 		ifNoBits:			[(aPaintBox := aWorld paintBoxOrNil) ifNotNil: [aPaintBox delete]].	! !!TabSorterMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/3/1998 16:06'!cancelSort	| oldOwner |	oldOwner := owner.	self delete.	oldOwner addMorphFront: book! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/21/1998 13:28'!purge: megs	"Replace morphs with tombstones in all pages that are clean and not being shown.  Do this until megs of new memory have been recovered.  Write any dirty ones first, if allowed to."	| goal |	goal := Smalltalk garbageCollect + (megs * 1000000) asInteger.	PageCache doPagesInMemory: [:aPage | 		GlobalPolicy == #neverWrite ifFalse: [aPage write].		aPage purge.		Smalltalk garbageCollect > goal ifTrue: [^ true]].	"got enough"	^ false	"caller may want to tell the user to write out more pages"! !!FancyMailComposition methodsFor: 'initialization' stamp: 'nk 7/3/2003 09:41'!celeste: aCeleste to: argTo subject: argSubject initialText: aText theLinkToInclude: linkText  "self new celeste: Celeste current to: 'danielv@netvision.net.il' subject: 'Mysubj' initialText: 'atext' theLinkToInclude: 'linkText'"	to := argTo.	subject := argSubject.	messageText := aText.	theLinkToInclude := linkText.	textFields := #().! !!GraphMorph methodsFor: 'accessing' stamp: ''!dataColor: aColor	dataColor := aColor.	self flushCachedForm.! !!EPSCanvas methodsFor: 'private' stamp: 'nk 1/1/2004 12:48'!writeEPSPreviewImageFor: aMorph	| form stream string lines newExtent |	newExtent := (aMorph width roundUpTo: 8) @ aMorph height.	form := aMorph imageForm: 1 forRectangle: (aMorph bounds origin extent: newExtent).	stream := RWBinaryOrTextStream on: (String new: (form bits byteSize * 2.04) asInteger).	form storePostscriptHexOn: stream.	string := stream contents.	lines := string occurrencesOf: Character cr.	"%%BeginPreview: 80 24 1 24"	"width height depth "	target print: '%%BeginPreview: '; write:  newExtent; space; write: form depth; space; write: lines; cr.	stream position: 0.	[ stream atEnd ] whileFalse: [		target nextPut: $%; nextPutAll: (stream upTo: Character cr); cr.		lines := lines - 1.	].	target print: '%%EndPreview'; cr.! !!LedTimerMorph methodsFor: 'accessing' stamp: 'djp 10/31/1999 21:58'!pause	counting ifTrue: [self updateTime].	counting := false! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 5/14/2000 12:42'!accept	| f |	f := self unmagnifiedForm.	f boundingBox = formToEdit boundingBox		ifFalse: [^ self error: 'implementation error; form dimensions should match'].	f displayOn: formToEdit.  "modify formToEdit in place"! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'JMV 1/26/2001 11:28'!buildScalesIn: frame	| env hmajortick hminortick |	env := envelope.	pixPerTick := graphArea width // (self maxTime//10) max: 1.	hminortick := ( 1 + ( self maxTime // 800 ) ) * 10.	hmajortick := ( 1 + ( self maxTime // 800 ) ) * 100.	hScale := (ScaleMorph newBounds: ((graphArea left)@(frame top) corner: (self xFromMs: self maxTime)@(graphArea top - 1)))		start: 0 stop: self maxTime		minorTick: hminortick minorTickLength: 3		majorTick: hmajortick majorTickLength: 10		caption: 'milliseconds' tickPrintBlock: [:v | v printString].	self addMorph: hScale.	vScale := ScaleMorph newBounds: (0@0 extent: (graphArea height)@(graphArea left - frame left)).	env name = 'pitch'		ifTrue:		[env scale >= 2.0			ifTrue:			[vScale start: 0 stop: env scale				minorTick: env scale / 24 minorTickLength: 3				majorTick: env scale / 2.0 majorTickLength: 10				caption: 'pitch (octaves)'				tickPrintBlock: [:v | (v-(env scale/2)) asInteger printString]]			ifFalse:			[vScale start: 0 stop: env scale				minorTick: 1.0/48.0 minorTickLength: 3				majorTick: 1.0/12.0 majorTickLength: 10				caption: 'pitch (half-steps)'				tickPrintBlock: [:v | (v-(env scale/2)*12) rounded printString]]]		ifFalse: [			env name = 'random pitch:'				ifTrue: [					vScale start: 0.9 stop: 1.1						minorTick: 0.2 / 50.0 minorTickLength: 3						majorTick: 0.2 / 5.0 majorTickLength: 10						caption: env name						tickPrintBlock: [:v | v printString]]				ifFalse: [					vScale start: 0 stop: env scale						minorTick: env scale / 50.0 minorTickLength: 3						majorTick: env scale / 5.0 majorTickLength: 10						caption: env name						tickPrintBlock: [:v | v printString]].		].	vScale := TransformationMorph new asFlexOf: vScale.	vScale angle: Float pi / 2.0.	self addMorph: vScale.	vScale position: (frame left)@(graphArea top-1) - (3@1).! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 12:38'!tool: actionButton action: aSelector cursor: aCursor evt: evt	"Set the current tool and action for the paintBox.  "	tool ifNotNil: [		tool == actionButton ifFalse: [			tool state: #off.			action == #stamp: ifTrue: [self stampDeEmphasize]]].	tool := actionButton.		"A ThreePhaseButtonMorph"	"tool state: #on.	already done"	action := aSelector.		"paint:"	currentCursor := aCursor.	self notifyWeakDependentsWith: {#action. evt. action}.	self notifyWeakDependentsWith: {#currentCursor. evt. currentCursor}.! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'dgd 9/19/2003 12:21'!addButtonRows	| r |	r := AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Morph' translated action: #makeSoundMorph).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Tile' translated action: #makeTile).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Trim' translated action: #trim).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Show' translated action: #show).	self addMorphBack: r.	r := AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' translated action: #record).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' translated action: #stop).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Play' translated action: #playback).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.! !!TextOnCurveContainer methodsFor: 'as yet unclassified' stamp: 'jm 11/19/97 19:30'!baseline: newBaseline	baseline := newBaseline! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 11/30/1998 12:44'!highlightTabFor: aBook	| theOne |	self tabMorphs do: [:m |		(m morphToInstall == aBook)				ifTrue: [m highlight.  theOne := m]				ifFalse: [m unHighlight]].	^ theOne! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'sw 6/10/2003 12:59'!show	"Show my samples in a WaveEditor."	| ed w |	recorder verifyExistenceOfRecordedSound ifFalse: [^ self].	recorder pause.	ed := WaveEditor new.	ed data: recorder condensedSamples.	ed samplingRate: recorder samplingRate.	w := self world.	w activeHand		ifNil: [w addMorph: ed]		ifNotNil: [w activeHand attachMorph: ed].! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 12:03'!decompileScript: aScript named: aString for: aController	| newMorphs prevPt prevScale cameraPoint cameraScale mark |	self removeAllMorphs.	self setProperty: #cameraController toValue: aController.	self setProperty: #cameraScriptName toValue: aString.	newMorphs := OrderedCollection new.	prevPt := prevScale := nil.	aScript do: [ :each |		cameraPoint := each at: #startPoint ifAbsent: [nil].		cameraScale := each at: #startZoom ifAbsent: [nil].		(prevPt = cameraPoint and: [prevScale = cameraScale]) ifFalse: [			mark := ZASMCameraMarkMorph new.			mark cameraPoint: cameraPoint cameraScale: cameraScale controller: aController.			newMorphs add: mark.		].		newMorphs add: (ZASMStepsMorph new setStepCount: (each at: #steps ifAbsent: [10])).		cameraPoint := each at: #endPoint ifAbsent: [nil].		cameraScale := each at: #endZoom ifAbsent: [nil].		mark := ZASMCameraMarkMorph new.		mark cameraPoint: cameraPoint cameraScale: cameraScale controller: aController.		newMorphs add: mark.		prevPt := cameraPoint.		prevScale := cameraScale.	].	self addAllMorphs: newMorphs.! !!TextPlusPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/3/2000 12:18'!disablePageBreaksWhile: aBlock	| save result |	save := showPageBreaks.	showPageBreaks := false.	result := aBlock value.	showPageBreaks := save.	^result! !!PostscriptCharacterScanner methodsFor: 'textstyle support' stamp: 'sw 12/7/1999 12:28'!setTextStylesForOffset:offset	" default text style "	font := self textStyle defaultFont.	emphasis := 0.	foregroundColor := Color black.	" set text styles defined at this point, these methods will set instance vars of myself "	(paragraph text attributesAt: offset forStyle: paragraph textStyle) do: 		[:att | att emphasizeScanner: self].	" post-processing of 'emphasis' "	self setActualFont: (font emphasized: emphasis)! !!AtomMorph methodsFor: 'drawing' stamp: ''!drawOn: aCanvas	"Note: Set 'drawAsRect' to true to make the atoms draw faster. When testing the speed of other aspects of Morphic, such as its damage handling efficiency for large numbers of atoms, it is useful to make drawing faster."	| drawAsRect |	drawAsRect := false.  "rectangles are faster to draw"	drawAsRect		ifTrue: [aCanvas fillRectangle: self bounds color: color]		ifFalse: [super drawOn: aCanvas].! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 2/3/98 16:50'!chooseEnvelope: choice	| name |	(choice beginsWith: 'edit ') ifTrue:		[name := choice copyFrom: 'edit ' size+1 to: choice size.		^ self editEnvelope: (sound envelopes detect:				[:env | env name = name])].	(choice beginsWith: 'add ') ifTrue:		[name := choice copyFrom: 'add ' size+1 to: choice size.		^ self addEnvelopeNamed: name].	(choice beginsWith: 'remove ') ifTrue:		[^ self removeEnvelope  "the current one"].! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'md 2/15/2006 18:44'!repositionAnchoredMorphs	| am cBlock leftShift firstCharacterIndex lastCharacterIndex |	firstCharacterIndex := self paragraph firstCharacterIndex.	lastCharacterIndex := paragraph lastCharacterIndex.	text runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			(att isMemberOf: TextAnchor) ifTrue: [				am := att anchoredMorph.				(am isNil or: [am world isNil]) ifFalse: [					(stop between: firstCharacterIndex and: lastCharacterIndex) ifTrue: [						cBlock := self paragraph characterBlockForIndex: stop.						leftShift := am valueOfProperty: #geeMailLeftOffset ifAbsent: [0].						am position: (self left + leftShift) @ cBlock origin y.					].				]			]		]	].! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 12:20'!geeMail: aGeeMail	geeMail := aGeeMail! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:07'!setInitialState	self listDirection: #topToBottom;	  wrapCentering: #topLeft;	  hResizing: #shrinkWrap;	  vResizing: #shrinkWrap;	  layoutInset: 5.	pageSize := 160 @ 300.	self enableDragNDrop! !!InternalThreadNavigationMorph methodsFor: 'stepping' stamp: 'RAA 6/1/2001 13:36'!step	super step.	(self valueOfProperty: #previousWorldBounds) = self world bounds ifFalse: [		self positionAppropriately.	].	self class knownThreads		at: threadName		ifPresent: [ :known |			known == listOfPages ifFalse: [				listOfPages := known.				self removeAllMorphs.				self addButtons.			].		].! !!SqueakPage methodsFor: 'saving' stamp: 'RAA 8/30/2000 11:43'!write	"Decide whether to write this page on the disk."	| sf remoteFile |	policy == #neverWrite ifTrue: [^ self].		"demo mode, or write only when user explicitly orders it"	"All other policies do write:   #now"	contentsMorph ifNil: [^ self].	dirty := dirty | ((contentsMorph valueOfProperty: #pageDirty) == true).		"set by layoutChanged"	dirty == true ifTrue: [ 		sf := ServerDirectory new fullPath: url.		"check for shared password"		"contentsMorph allMorphsDo: [:m | m prepareToBeSaved].				done in objectToStoreOnDataStream"		lastChangeAuthor := Utilities authorInitialsPerSe ifNil: ['*'].		lastChangeTime := Time totalSeconds.		Cursor wait showWhile: [			remoteFile := sf fileNamed: url.	"no notification when overwriting"			remoteFile dataIsValid.			remoteFile fileOutClass: nil andObject: self.			"remoteFile close"].		contentsMorph setProperty: #pageDirty toValue: nil.		dirty := false].! !!ZASMScriptMorph methodsFor: 'layout' stamp: 'RAA 12/3/2000 09:33'!layoutChanged	super layoutChanged.	somethingChanged := true.	! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 1/4/1999 12:48'!pageMorph: pageMorph inBook: book	page := pageMorph.	bookMorph := book! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:13'!changeZoomFactor: x	zoomFactor := x! !!TabSorterMorph methodsFor: 'as yet unclassified' stamp: 'tk 2/19/2001 18:28'!addControls	| b r |	b := SimpleButtonMorph new target: self; borderColor: Color black.	r := AlignmentMorph newRow.	r color: b color; borderWidth: 0; layoutInset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r wrapCentering: #topLeft.	r addMorphBack: (b label: 'Okay';	actionSelector: #acceptSort).	b := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (b label: 'Cancel';	actionSelector: #cancelSort).	self addMorphFront: r.! !!Morph methodsFor: '*MorphicExtras-menus' stamp: 'dgd 4/3/2006 14:18'!dismissButton	"Answer a button whose action would be to dismiss the receiver, and whose action is to send #delete to the receiver"	| aButton |	aButton := SimpleButtonMorph new.	aButton		target: self topRendererOrSelf;		color: ColorTheme current cancelColor;		borderColor: ColorTheme current cancelColor muchDarker;		borderWidth: 1;		label: 'X' font: Preferences standardButtonFont;		actionSelector: #delete;		setBalloonText: 'dismiss' translated.	^ aButton! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash: aBoolean	flash := aBoolean.! !!Component methodsFor: 'naming' stamp: 'di 5/3/1998 19:48'!chooseNameLike: someName 	| stem otherNames i partName |	stem := someName.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem := stem copyFrom: 1 to: stem size - 5].	stem := stem first asLowercase asString , stem allButFirst.	otherNames := self class allInstVarNames asSet.	"otherNames addAll: self world allKnownNames."	i := 1.	[otherNames includes: (partName := stem , i printString)]		whileTrue: [i := i + 1].	partName := FillInTheBlank request: 'Please give this part a name'						initialAnswer: partName.	partName isEmpty ifTrue: [^ nil].	(otherNames includes: partName) ifTrue:			[self inform: 'Sorry, that name is already used'.			^ nil].	^ partName! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 3/14/2001 08:36'!wantsDroppedMorph: aMorph event: evt	| handlerForDrops |	handlerForDrops := self valueOfProperty: #handlerForDrops ifAbsent: [		^super wantsDroppedMorph: aMorph event: evt	].	^handlerForDrops wantsDroppedMorph: aMorph event: evt in: self! !!TextPlusMorph methodsFor: 'event handling' stamp: 'RAA 9/13/2000 15:53'!mouseUp: evt	ignoreNextUp == true ifTrue: [ignoreNextUp := false. ^self].	^super mouseUp: evt! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:41'!setMaxVal	| newMaxVal |	newMaxVal := FillInTheBlank		request: 'Maximum value?'		initialAnswer: maxVal printString.	newMaxVal isEmpty ifFalse: [		maxVal := newMaxVal asNumber.		minVal := minVal min: maxVal].! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 12:24'!delta: aPoint	delta := aPoint.! !!GraphicalMenu methodsFor: 'initialization' stamp: 'ar 6/25/1999 11:53'!initialize	super initialize.	selector := #newForm:.! !!WorldState methodsFor: '*MorphicExtras-hands' stamp: 'ar 1/22/2001 14:26'!activeHand: aHandMorph	"still needed until event loop with old code goes away"	ActiveHand := aHandMorph.! !!EventRecorderMorph methodsFor: 'commands' stamp: 'dgd 9/21/2003 17:54'!shrink	"Shorten the tape by deleting mouseMove events that can just as well be	interpolated later at playback time."	| oldSize priorSize |	self writeCheck.	oldSize := priorSize := tape size.	[self condense.  tape size < priorSize] whileTrue: [priorSize := tape size].	self inform: ('{1} events reduced to {2}' translated format:{oldSize. tape size}).	voiceRecorder ifNotNil: [voiceRecorder suppressSilence].	saved := false.! !!ReferenceMorph methodsFor: 'accessing' stamp: 'de 11/30/1998 09:58'!referent: m	referent := m! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'md 11/14/2003 16:52'!loadoffImage: fileName	"Read in and convert the background image for the paintBox.  Allbuttons off.  A .bmp 24-bit image."	"	Prototype loadoffImage: 'roundedPalette3.bmp'	"	| pic16Bit blt type getBounds |	type := 'bmp'.  " gif or bmp  "	getBounds := 'fromPic'.	"fromUser = draw out rect of paintbox on image"		"fromOB = just read in new bits, keep same size and place as last time."		"fromPic = picture is just the PaintBox, use its bounds"type = 'gif' ifTrue: [	pic16Bit "really 8" := GIFReadWriter formFromFileNamed: fileName.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds := Rectangle fromUser].	getBounds = 'fromPic' ifTrue: [OriginalBounds := pic16Bit boundingBox].	].		"Use OriginalBounds as it was last time"type = 'bmp' ifTrue: [	pic16Bit := (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	getBounds = 'fromUser' ifTrue: ["Just first time, collect the bounds"			pic16Bit display.			OriginalBounds := Rectangle fromUser].		"Use OriginalBounds as it was last time"	(getBounds = 'fromPic') ifTrue: [OriginalBounds := pic16Bit boundingBox].	AllOffImage := Form extent: OriginalBounds extent depth: 16.	].type = 'gif' ifTrue: [	AllOffImage := ColorForm extent: OriginalBounds extent depth: 8.	AllOffImage colors: pic16Bit colors].	blt := BitBlt current toForm: AllOffImage.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.type = 'bmp' ifTrue: [AllOffImage mapColor: Color transparent to: Color black].	self image: AllOffImage.	self invalidRect: bounds.	! !!BooklikeMorph methodsFor: 'misc' stamp: 'sw 7/4/1998 16:51'!pageSize: aPoint	pageSize := aPoint! !!FancyMailComposition methodsFor: 'access' stamp: 'RAA 5/19/2000 19:02'!subject: x	subject := x.	self changed: #subject.	^true! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:07'!rotateBy: evt 	"Left-right is rotation. 3/26/97 tk Slider at top of window. 4/3/97 tk"	| pt temp amt smooth myBuff |	myBuff := self get: #buff for: evt.	evt cursorPoint x - self left < 20		ifTrue: [^ self flipHoriz: evt].	"at left end flip horizontal"	evt cursorPoint x - self right > -20		ifTrue: [^ self flipVert: evt].	"at right end flip vertical"	pt := evt cursorPoint - bounds center.	smooth := 2.	"paintingForm depth > 8 ifTrue: [2] ifFalse: [1]."	"Could go back to 1 for speed"	amt := pt x abs < 12				ifTrue: ["detent"					0]				ifFalse: [pt x - (12 * pt x abs // pt x)].	amt := amt * 1.8.	temp := myBuff				rotateBy: amt				magnify: cumMag				smoothing: smooth.	temp displayOn: paintingForm at: paintingForm center - temp center + myBuff offset.	rotationButton position: evt cursorPoint x - 6 @ rotationButton position y.	self render: bounds.	cumRot := amt! !!FatBitsPaint methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:54'!initialize	"initialize the state of the receiver"	super initialize.	""	self setCurrentToolTo: self toolsForPaintBrush.	formToEdit := Form extent: 50 @ 40 depth: 8.	formToEdit fill: formToEdit boundingBox fillColor: Color veryVeryLightGray.	brushSize := magnification := 4.		brushColor := Color red.	backgroundColor := Color white.	self revert! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 9/25/1999 21:50'!copySelection        | relativeBounds scaledBounds |        currentSelectionMorph ifNil: [^ nil].        relativeBounds := currentSelectionMorph bounds translateBy: self position negated.        scaledBounds := relativeBounds scaleBy: 1 / magnification.        FormClipboard := (self unmagnifiedForm copy: scaledBounds).        ^ relativeBounds! !!Flasher methodsFor: 'operations' stamp: 'sw 5/28/2002 18:44'!onColor	"Answer my onColor"	^ onColor ifNil: [onColor := Color red]! !!WiWPasteUpMorph methodsFor: 'activation' stamp: 'RAA 5/25/2000 15:11'!revertToParentWorldWithEvent: evt	"RAA 27 Nov 99 - if the display changed while we were in charge, parent may need to redraw"	worldState resetDamageRecorder.	"Terminate local display"	World := parentWorld.	World assuredCanvas.	World installFlaps.	hostWindow setStripeColorsFrom: Color red.	(displayChangeSignatureOnEntry = Display displayChangeSignature) ifFalse: [		World fullRepaintNeeded; displayWorld	].	evt ifNotNil: [World restartWorldCycleWithEvent: evt].! !!SqueakPage methodsFor: 'accessing' stamp: 'ar 4/10/2005 18:52'!fetchContentsIfAbsent: failBlock	"Make every effort to get contentsMorph.  Assume I am in the cache already."	| strm page temp temp2 |	SqueakPageCache write.		"sorry about the pause"	Cursor wait showWhile: [		strm := (ServerFile new fullPath: url) asStream].	strm isString ifTrue: [^ failBlock value].			page := strm fileInObjectAndCode.	page isMorph ifTrue: [contentsMorph := page].	"may be a bare morph"	"copy over the state"	temp := url.	temp2 := policy.	self copyAddedStateFrom: page.	url := temp.	"don't care what it says"	temp2 ifNotNil: [policy := temp2].		"use mine"	contentsMorph setProperty: #pageDirty toValue: nil.	self dirty: false.	^ contentsMorph! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 1/4/1999 12:52'!inBook: book	bookMorph := book! !!ThreadNavigationMorph methodsFor: 'navigation' stamp: 'nb 6/17/2003 12:25'!firstPage	listOfPages isEmpty ifTrue: [^Beeper beep].	currentIndex := 1.	self loadPageWithProgress.! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/15/2000 21:47'!tickPrintBlock: aBlock	tickPrintBlock := aBlock.! !!StringButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:46'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied""actionSelector := actionSelector.		a Symbol""arguments := arguments.		All weakly copied"actWhen := actWhen veryDeepCopyWith: deepCopier.oldColor := oldColor veryDeepCopyWith: deepCopier.! !!DSCPostscriptCanvas methodsFor: 'morph drawing' stamp: 'nk 6/10/2004 13:19'!fullDrawBookMorph: aBookMorph	" draw all the pages in a book morph, but only if it is the top-level morph "	morphLevel = 1 ifFalse: [^ super fullDrawBookMorph: aBookMorph].	"Unfortunately, the printable 'pages' of a StackMorph are the cards, but for a BookMorph, they are the pages.  Separate the cases here."	(aBookMorph isKindOf: StackMorph) 		ifTrue: [			aBookMorph cards do: [:aCard |				aBookMorph goToCard: aCard.	"cause card-specific morphs to be installed"				pages := pages + 1.				target print: '%%Page: '; write: pages; space; write: pages; cr.				self drawPage: aBookMorph currentPage]]		ifFalse: [			aBookMorph pages do: [:aPage |				pages := pages + 1.				target print: '%%Page: '; write: pages; space; write: pages; cr.				self drawPage: aPage]].	morphLevel = 0 ifTrue: [ self writeTrailer: pages ].! !!SoundEventMorph methodsFor: 'caching' stamp: 'RAA 12/8/2000 09:52'!releaseCachedState	super releaseCachedState.	sound := sound compressWith: GSMCodec.! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 1/5/98 13:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Repeatedly play my sounds."	| i count samplesNeeded |	i := startIndex.	samplesNeeded := n.	[samplesNeeded > 0] whileTrue: [		count := seqSound samplesRemaining min: samplesNeeded.		count = 0 ifTrue: [			self reset.			count := seqSound samplesRemaining min: samplesNeeded.			count = 0 ifTrue: [^ self]].  "zero length sound"		seqSound mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: leftVol rightVol: rightVol.		i := i + count.		samplesNeeded := samplesNeeded - count].! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'ar 12/30/2001 19:14'!fullDrawOn: aCanvas	| mask |	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	super fullDrawOn: aCanvas.	mask := self valueOfProperty: #disabledMaskColor ifAbsent: [^self].	aCanvas fillRectangle: bounds color: mask.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 22:49'!panImageBy: pixels	self changeOffsetBy: (pixels * self getTiltFactor * 0.1) @ 0.	"steps := (pixels abs / 6) exp rounded * pixels sign.""==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!SimpleSliderMorph methodsFor: 'initialization' stamp: 'jm 1/29/98 16:16'!initialize	super initialize.	target := nil.	arguments := EmptyArray.	minVal := 0.0.	maxVal := 1.0.	truncate := false.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'mir 5/13/2003 10:44'!startTransmittingEvents	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := OldSimpleClientSocket new.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:48'!getScaledValue	| aValue |	aValue := (value * (maxVal - minVal)) + minVal.	^ truncate ifTrue: [aValue truncated] ifFalse: [aValue]! !!FunctionComponent methodsFor: 'menu commands' stamp: 'di 5/4/1998 08:57'!accept	"Inform the model of text to be accepted, and return true if OK."	| textToAccept oldSelector |	oldSelector := functionSelector.	textToAccept := textMorph asText.	textToAccept = self getText ifTrue: [^ self].  "No body to compile yet"	functionSelector := model class		compile: self headerString , textToAccept asString		classified: 'functions' notifying: nil.	self setText: textToAccept.	self hasUnacceptedEdits: false.	oldSelector ifNotNil:		[functionSelector = oldSelector ifFalse: [model class removeSelector: oldSelector]].	self fire! !!PostscriptCanvas methodsFor: 'balloon compatibility' stamp: 'nk 4/1/2004 19:14'!drawOval: r color: c borderWidth: borderWidth borderColor: borderColor	| fillC |	fillC := self shadowColor ifNil:[c].	^ self fillOval: r color: fillC borderWidth: borderWidth borderColor: borderColor			! !!SqueakPage methodsFor: 'saving' stamp: 'tk 1/23/1999 13:19'!urlNoOverwrite: suggested	"Look in the directory.  If there is a file of this name, create a new name.  Keep track of highest numbers used as a hint."	| dir ll stem num local trial suffix |	(suggested endsWith: '.sp') ifTrue: [suffix := '.sp'].	(suggested endsWith: '.bo') ifTrue: [suffix := '.bo'].	suffix ifNil: [self error: 'unknown suffix'].	dir := ServerFile new fullPath: suggested.	(dir includesKey: dir fileName) ifFalse: [^ url := suggested].	"File already exists!!  Create a new name"	"Find the stem file name"	stem := SqueakPage stemUrl: suggested.	num := stem = RecentStem ifTrue: [RecentMaxNum+1] ifFalse: [1].	local := dir fileName.	"ugh, take stem again..."	ll := local findLast: [:char | char == $.].	ll = 0 ifFalse: [local := local copyFrom: 1 to: ll-1].	"remove .sp"	local := (local splitInteger) at: 1.		"remove trailing number"	local last == $x ifFalse: [local := local , 'x'].	[trial := local, num printString, suffix.		dir includesKey: trial] whileTrue: [num := num + 1].	RecentStem := stem.  RecentMaxNum := num.	^ url := stem, 'x', num printString, suffix! !!PostscriptCharacterScanner methodsFor: 'displaying' stamp: 'RAA 10/2/2000 21:00'!displayLine: line offset: baseOffset leftInRun: leftInRun	| drawFont offset aText string s doJustified |	self setTextStylesForOffset: ((line first) + 1).	" sets up various instance vars from text styles "	drawFont := self font.	offset := baseOffset.	offset := offset + (line left @ (line top + line baseline - drawFont ascent )). 	offset := offset + ((self textStyle alignment caseOf:{		[2] -> [ line paddingWidth /2 ].		[1] -> [ line paddingWidth ] } otherwise:[0]) @ 0).	canvas moveto: offset.	aText := paragraph text copyFrom: line first to: line last.	doJustified := (paragraph textStyle alignment = 3)						and: [ (paragraph text at:line last) ~= Character cr						and: [aText runs runs size = 1]].	string := aText string.	aText runs withStartStopAndValueDo: [:start :stop :attributes |		self setTextStylesForOffset: (start + line first - 1).	" sets up inst vars from text styles "		s := string copyFrom: start to: stop.		drawFont := self font.		canvas setFont: drawFont.		canvas 			textStyled: s			at: offset 		"<--now ignored"			font: drawFont 		"<--now ignored"			color: foregroundColor			justified: doJustified		"<-can't do this now for multi-styles" 			parwidth: line right - line left.	].! !!PreferencesPanel class methodsFor: 'cleanup' stamp: 'RAA 4/14/2001 11:04'!isAPreferenceViewToKill: aSystemView	"Answer whether the given StandardSystemView is one affiliated with a PreferencesPanel"	| m target subView |	aSystemView subViews size = 1 ifFalse: [^ false].	subView := aSystemView subViews first.	(subView isKindOf: MorphWorldView) ifFalse: [^ false].	((m := subView model) isKindOf: MVCWiWPasteUpMorph) ifFalse: [^ false].	m submorphs size = 1 ifFalse: [^ false].	m firstSubmorph submorphs size = 1 ifFalse: [^ false].	target := m firstSubmorph firstSubmorph. 	(target isKindOf: TabbedPalette) ifFalse: [^ false].	^ #(browsing debug fileout general halos) allSatisfy: [:s |		(target tabNamed: s) notNil]! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'RAA 8/15/2000 16:47'!addWeakDependent: anObject	weakDependents ifNil: [^weakDependents := WeakArray with: anObject].	weakDependents := weakDependents,{anObject} reject: [ :each | each isNil].! !!SqueakPage class methodsFor: 'as yet unclassified' stamp: 'jm 6/18/1998 11:15'!initialize	"SqueakPage initialize"	MaxThumbnailWidthOrHeight := 60.! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 12/11/2000 12:13'!mouseMove: evt	| hand firstSub |	hand := evt hand.	(((hand submorphCount > 0) and: [(firstSub := hand submorphs first) ~~ self]) and:			[self wantsDroppedMorph: firstSub event: evt])		ifTrue: 			[super mouseMove: evt]! !!NewWorldWindow methodsFor: 'color' stamp: 'nb 6/17/2003 12:25'!setWindowColor: incomingColor	| existingColor aColor |	incomingColor ifNil: [^ self].  "it happens"	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor 		or: [aColor = Color black]) ifTrue: [^ self].	existingColor := self paneColorToUse.	existingColor ifNil: [^ Beeper beep].	self setStripeColorsFrom: aColor		! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 9/25/1999 15:49'!magnification: aNumber        | oldPenSize oldForm |        oldPenSize := brushSize / magnification.        oldForm := self unmagnifiedForm.        magnification := aNumber asInteger max: 1.        self form: (oldForm magnify: oldForm boundingBox by: magnification).        brush := Pen newOnForm: originalForm.        self penSize: oldPenSize.        brush color: brushColor! !!PostscriptCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 2/2/2001 09:54'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	aFillStyle isSolidFill ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern := aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead PROBABLY won't work here"	"self balloonFillRectangle: aRectangle fillStyle: aFillStyle."	^self fillRectangle: aRectangle color: aFillStyle asColor! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 10/5/2000 16:18'!mouseLeave: event	"Present feedback for aborted deletion."	| hand |	hand := event hand.	((hand submorphCount > 0) and:	 [hand submorphs first ~~ self])		ifTrue:			[Preferences soundsEnabled ifTrue: [self class playMouseLeaveSound].			hand visible: true.			self state: #off]		ifFalse:			[self stopShowingStampIn: hand].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:00'!readFrom: aStream	"Private"	| cr header |	cr := Character cr.	header := aStream upTo: cr.	(header = 'Event Tape v1 BINARY') ifTrue:[^aStream fileInObjectAndCode].	(header = 'Event Tape v1 ASCII') ifTrue:[^self readFromV1: aStream].	"V0 had no header so guess"	aStream reset.	header first isDigit ifFalse:[^self convertV0Tape: (aStream fileInObjectAndCode)].	^self convertV0Tape: (self readFromV0: aStream).! !!SqueakPageCache class methodsFor: 'housekeeping' stamp: 'tk 6/24/1999 11:42'!deleteUnreferencedPages	"Remove any pages that are not current referred to by any book or URL morph."	"Details: Since unreferenced pages could refer to other pages, this process is iterated until no unreferenced pages can be found. It currently does not collect cycles."	"SqueakPageCache deleteUnreferencedPages"	| unreferenced |	[true] whileTrue: [		Smalltalk garbageCollect.		unreferenced := PageCache keys.		URLMorph allSubInstancesDo: [:m | unreferenced remove: m url ifAbsent: []].		MorphObjectOut allInstancesDo: [:ticklish |			unreferenced remove: ticklish url ifAbsent: []].		unreferenced size = 0 ifTrue: [^ self].		unreferenced do: [:url | PageCache removeKey: url ifAbsent: []]].! !!BookMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:13'!addBookMenuItemsTo: aMenu hand: aHandMorph	| controlsShowing subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'previous page' translated action: #previousPage.	subMenu add: 'next page' translated action: #nextPage.	subMenu add: 'goto page' translated action: #goToPage.	subMenu add: 'insert a page' translated action: #insertPage.	subMenu add: 'delete this page' translated action: #deletePage.	controlsShowing := self hasSubmorphWithProperty: #pageControl.	controlsShowing		ifTrue:			[subMenu add: 'hide page controls' translated action: #hidePageControls.			subMenu add: 'fewer page controls' translated action: #fewerPageControls]		ifFalse:			[subMenu add: 'show page controls' translated action: #showPageControls].	self isInFullScreenMode ifTrue: [		subMenu add: 'exit full screen' translated action: #exitFullScreen.	] ifFalse: [		subMenu add: 'show full screen' translated action: #goFullScreen.	].	subMenu addLine.	subMenu add: 'sound effect for all pages' translated action: #menuPageSoundForAll:.	subMenu add: 'sound effect this page only' translated action: #menuPageSoundForThisPage:.	subMenu add: 'visual effect for all pages' translated action: #menuPageVisualForAll:.	subMenu add: 'visual effect this page only' translated action: #menuPageVisualForThisPage:.	subMenu addLine.	subMenu add: 'sort pages' translated action: #sortPages:.	subMenu add: 'uncache page sorter' translated action: #uncachePageSorter.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [subMenu add: 'wrap after last page' translated selector: #setWrapPages: argument: true]		ifFalse: [subMenu add: 'stop at last page' translated selector: #setWrapPages: argument: false].	subMenu addLine.	subMenu add: 'search for text' translated action: #textSearch.	(aHandMorph pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[subMenu add: 'paste book page' translated	action: #pasteBookPage].	subMenu add: 'send all pages to server' translated action: #savePagesOnURL.	subMenu add: 'send this page to server' translated action: #saveOneOnURL.	subMenu add: 'reload all from server' translated action: #reload.	subMenu add: 'copy page url to clipboard' translated action: #copyUrl.	subMenu add: 'keep in one file' translated action: #keepTogether.	subMenu add: 'save as new-page prototype' translated action: #setNewPagePrototype.	newPagePrototype ifNotNil:		[subMenu add: 'clear new-page prototype' translated action: #clearNewPagePrototype].	aMenu add: 'book...' translated subMenu: subMenu! !!BooklikeMorph class methodsFor: 'as yet unclassified' stamp: 'sw 7/4/1998 16:43'!turnOffSoundWhile: aBlock	"Turn off page flip sound during the given block."	| old |	old := PageFlipSoundOn.	PageFlipSoundOn := false.	aBlock value.	PageFlipSoundOn := old! !!ScreeningMorph methodsFor: 'menu' stamp: ''!showScreenOverSource	displayMode := #showScreenOverSource.	self changed! !!SketchEditorMorph methodsFor: 'initialization' stamp: 'ar 6/2/2001 16:54'!initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph	| aPaintBox newPaintBoxBounds worldBounds requiredWidth newOrigin aPosition aPal aTab paintBoxFullBounds |	(aTab := self world paintingFlapTab) ifNotNil:		[aTab showFlap.		^ self initializeFor: aSketchMorph inBounds: boundsToUse pasteUpMorph: aPasteUpMorph paintBoxPosition: nil].	aPaintBox := self world paintBox.	worldBounds := self world bounds.	requiredWidth := aPaintBox width.	aPosition := (aPal := aPasteUpMorph standardPalette)		ifNotNil:			[aPal showNoPalette.			aPal topRight + (aPaintBox width negated @ 0 "aPal tabsMorph height")]		ifNil:			[boundsToUse topRight].	newOrigin := ((aPosition x  + requiredWidth <= worldBounds right) or: [Preferences unlimitedPaintArea])			ifTrue:  "will fit to right of aPasteUpMorph"				[aPosition]			ifFalse:  "won't fit to right, try left"				[boundsToUse topLeft - (requiredWidth @ 0)].	paintBoxFullBounds := aPaintBox maxBounds.	paintBoxFullBounds := (newOrigin - aPaintBox offsetFromMaxBounds) extent: 					paintBoxFullBounds extent.	newPaintBoxBounds := paintBoxFullBounds translatedToBeWithin: worldBounds.		self initializeFor: aSketchMorph inBounds: boundsToUse 		pasteUpMorph: aPasteUpMorph 		paintBoxPosition: newPaintBoxBounds origin + aPaintBox offsetFromMaxBounds.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:21'!loopCycles: aNumber	loopCycles := aNumber.	self loopLength: loopLength.  "updates frequency"! !!PreferencesPanel class methodsFor: 'cleanup' stamp: 'gm 2/22/2003 18:58'!deleteAllPreferencesPanels	"Called manually to clobber all existing preferences panels"	"PreferencesPanel deleteAllPreferencesPanels"	| aWindow |	self allInstancesDo:		[:aPanel |			(aWindow := aPanel containingWindow) isMorph				ifTrue:					[aWindow delete]].	self killExistingMVCViews.	UpdatingThreePhaseButtonMorph allInstancesDo: "clobber old stand-alone prefs buttons"		[:m | (m actionSelector == #togglePreference:) ifTrue:			[(m owner isAlignmentMorph) ifTrue:				[m owner delete]]]! !!URLMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:53'!initialize	"initialize the state of the receiver"	super initialize.	""		isBookmark := false! !!BookMorph methodsFor: 'menu' stamp: 'md 9/27/2005 22:57'!findText: wants	"Turn to the next page that has all of the strings mentioned on it.  Highlight where it is found.  allText and allTextUrls have been set.  Case insensitive search.	Resuming a search.  If container's text is still in the list and secondary keys are still in the page, (1) search rest of that container.  (2) search rest of containers on that page (3) pages till end of book, (4) from page 1 to this page again."	"Later sort wants so longest key is first"	| allText good thisWord here fromHereOn startToHere oldContainer oldIndex otherKeys strings |	allText := self valueOfProperty: #allText ifAbsent: [#()].	here := pages identityIndexOf: currentPage ifAbsent: [1].	fromHereOn := here+1 to: pages size.	startToHere := 1 to: here.		"repeat this page"	(self valueOfProperty: #searchKey ifAbsent: [#()]) = wants ifTrue: [		"does page have all the other keys?  No highlight if found!!"		otherKeys := wants allButFirst.		strings := allText at: here.		good := true.		otherKeys do: [:searchString | "each key"			good ifTrue: [thisWord := false.				strings do: [:longString |					(longString findString: searchString startingAt: 1 						caseSensitive: false) > 0 ifTrue: [							thisWord := true]].				good := thisWord]].		good ifTrue: ["all are on this page.  Look in rest for string again."			oldContainer := self valueOfProperty: #searchContainer.			oldIndex := self valueOfProperty: #searchOffset.			(self findText: (OrderedCollection with: wants first) inStrings: strings					startAt: oldIndex+1 container: oldContainer 				pageNum: here) ifTrue: [					self setProperty: #searchKey toValue: wants.					^ true]]]		ifFalse: [fromHereOn := here to: pages size].	"do search this page"	"other pages"	allText ifNotEmpty: [		fromHereOn do: [:pageNum |			(self findText: wants inStrings: (allText at: pageNum) startAt: 1 container: nil 					pageNum: pageNum) 					ifTrue: [^ true]].		startToHere do: [:pageNum |			(self findText: wants inStrings: (allText at: pageNum) startAt: 1 container: nil 					pageNum: pageNum) 						ifTrue: [^ true]]].	"if fail"	self setProperty: #searchContainer toValue: nil.	self setProperty: #searchOffset toValue: nil.	self setProperty: #searchKey toValue: nil.	^ false! !!BookMorph methodsFor: 'accessing' stamp: 'tk 12/16/1998 12:05'!userString	"Do I have a text string to be searched on?"	| list |	self getAllText.	list := OrderedCollection new.	(self valueOfProperty: #allText ifAbsent: #()) do: [:aList |		list addAll: aList].	^ list! !!GraphMorph methodsFor: 'private' stamp: 'jm 6/17/1999 20:10'!flushCachedForm	cachedForm := nil.	hasChanged := true.! !!MorphThumbnail methodsFor: 'as yet unclassified' stamp: 'sw 11/13/1998 09:53'!computeThumbnail	"Assumption on entry:       The receiver's width represents the maximum width allowable.       The receiver's height represents the exact height desired."	| f scaleX scaleY |	f := morphRepresented imageForm.	morphRepresented fullReleaseCachedState.	scaleY := self height / f height.  "keep height invariant"	scaleX := ((morphRepresented width * scaleY) <= self width)		ifTrue:			[scaleY]  "the usual case; same scale factor, to preserve aspect ratio"		ifFalse:			[self width / f width].	self form: (f magnify: f boundingBox by: (scaleX @ scaleY) smoothing: 2).	self extent: originalForm extent! !!InternalThreadNavigationMorph methodsFor: 'private' stamp: 'RAA 11/11/2000 19:11'!listOfPages: aCollection	listOfPages := aCollection.	currentIndex := nil.	self currentIndex! !!GraphMorph methodsFor: 'private' stamp: 'jm 6/17/1999 21:36'!drawCursorOn: aCanvas	| ptr x r c |	ptr := (cursor asInteger max: 1) min: data size.	c := cursorColor.	((ptr > 1) and: [ptr < data size]) ifTrue: [		(data at: ptr) sign ~= (data at: ptr + 1) sign			ifTrue: [c := cursorColorAtZeroCrossings]].	r := self innerBounds.	x := r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/16/2000 15:53'!menuPageVisualFor: target event: evt	| tSpec menu subMenu directionChoices |	tSpec := self 		valueOfProperty: #transitionSpec		ifAbsent: [			(self valueOfProperty: #bookPage) 				valueOfProperty: #transitionSpec				ifAbsent: [{ 'silence' . #none. #none}]		].	menu := (MenuMorph entitled: 'Choose an effect(it is now ' , tSpec second , ')') defaultTarget: self.	TransitionMorph allEffects do: [:effect |		directionChoices := TransitionMorph directionsForEffect: effect.		directionChoices isEmpty		ifTrue: [menu add: effect target: self					selector: #setProperty:toValue:					argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: #none))]		ifFalse: [subMenu := MenuMorph new.				directionChoices do:					[:dir |					subMenu add: dir target: self						selector: #setProperty:toValue:						argumentList: (Array with: #transitionSpec									with: (Array with: tSpec first with: effect with: dir))].				menu add: effect subMenu: subMenu]].	menu popUpEvent: evt in: self world! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 2/24/1999 12:06'!saveMorph: aMorph author: authorString	"Save the given morph as this page's contents. Update its thumbnail and inform references to this URL that the page has changed."	"Details: updateThumbnail releases the cached state of the saved page contents after computing the thumbnail."	| n |	contentsMorph := aMorph.	n := aMorph knownName.	n ifNotNil: [self title: n].	creationAuthor ifNil: [		creationAuthor := authorString.		creationTime := Time totalSeconds]."	lastChangeAuthor := authorString.	lastChangeTime := Time totalSeconds.	do it when actually write"	self computeThumbnail.	self postChangeNotification.! !!MorphWorldView methodsFor: 'displaying' stamp: 'dew 11/8/1999 02:01'!displayView	"This method is called by the system when the top view is framed or moved."	| topView |	model viewBox: self insetDisplayBox.	self updateSubWindowExtent.	topView := self topView.	(topView == ScheduledControllers scheduledControllers first view		or: [topView cacheBitsAsTwoTone not])		ifTrue: [model displayWorldSafely]		ifFalse: [model displayWorldAsTwoTone].  "just restoring the screen"! !!FunctionComponent methodsFor: 'components' stamp: 'di 5/3/1998 23:34'!initFromPinSpecs	outputSelector := pinSpecs first modelWriteSelector.	inputSelectors := (pinSpecs copyFrom: 2 to: pinSpecs size)						collect: [:ps | ps modelReadSelector]! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:05'!setLabel	| newLabel |	newLabel := FillInTheBlank		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!ZoomAndScrollControllerMorph methodsFor: 'event handling' stamp: 'RAA 12/1/2000 15:23'!mouseUp: evt	mouseMovePoint := mouseDownPoint := nil.	self changed.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 20:06'!flipVert: evt 	"Flip the image"	| temp myBuff |	myBuff := self get: #buff for: evt.	temp := myBuff deepCopy flipBy: #vertical centerAt: myBuff center.	temp offset: 0 @ 0.	paintingForm fillWithColor: Color transparent.	temp displayOn: paintingForm at: paintingForm center - myBuff center + myBuff offset.	rotationButton position: evt cursorPoint x - 6 @ rotationButton position y.	self render: bounds! !!SqueakPage methodsFor: 'saving' stamp: 'tk 9/30/1998 22:39'!policy: aSymbol	policy := aSymbol! !!PostscriptEncoder class methodsFor: 'configuring' stamp: 'RAA 9/19/2000 18:05'!mapMacStringToPS: aString	| copy val newVal |	MacToPSCharacterMappings ifNil: [		MacToPSCharacterMappings := Array new: 256.		self macToPSCharacterChart do: [ :pair |			pair second = 999 ifFalse: [MacToPSCharacterMappings at: pair first put: pair second]		].	].	copy := aString copy.	copy withIndexDo: [ :ch :index |		(val := ch asciiValue) > 127 ifTrue: [			(newVal := MacToPSCharacterMappings at: val) ifNotNil: [				copy at: index put: newVal asCharacter			].		].	].	^copy! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'ar 3/17/2001 14:25'!addHandlesIn: frame	| handle |	handle := PolygonMorph		vertices: (Array with: 0@0 with: 8@0 with: 4@8)		color: Color orange borderWidth: 1 borderColor: Color black.	handle addMorph: ((RectangleMorph			newBounds: ((self handleOffset: handle)-(2@0) extent: 1@(graphArea height-2))			color: Color orange) borderWidth: 0).	limitHandles := Array with: handle with: handle veryDeepCopy with: handle veryDeepCopy.	1 to: limitHandles size do:		[:i | handle := limitHandles at: i.		handle on: #mouseDown				send: #limitHandleMove:event:from:				to: self withValue: i.		handle on: #mouseMove				send: #limitHandleMove:event:from:				to: self withValue: i.		self addMorph: handle.		handle position: ((self xFromMs: 			(envelope points at: (limits at: i)) x) @ 				(graphArea top)) - (self handleOffset: handle)]! !!BookPageSorterMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 14:36'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."book := book.		Weakly copied"pageHolder := pageHolder veryDeepCopyWith: deepCopier.! !!TabbedPalette class methodsFor: 'scripting' stamp: 'nk 6/12/2004 10:05'!authoringPrototype	| aTabbedPalette aBook aTab |	aTabbedPalette := self new markAsPartsDonor.	aTabbedPalette pageSize: 200 @ 300.	aTabbedPalette tabsMorph highlightColor: Color red regularColor: Color blue.	aTabbedPalette addMenuTab.	aBook := BookMorph new setNameTo: 'one'; pageSize: aTabbedPalette pageSize.	aBook color: Color blue muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: (World drawingClass withForm: ScriptingSystem squeakyMouseForm).	aTab := aTabbedPalette addTabForBook: aBook.	aBook := BookMorph new setNameTo: 'two'; pageSize: aTabbedPalette pageSize.	aBook color: Color red muchLighter.	aBook removeEverything; insertPage; showPageControls.	aBook currentPage addMorphBack: CurveMorph authoringPrototype.	aTabbedPalette addTabForBook: aBook.	aTabbedPalette selectTab: aTab.	aTabbedPalette beSticky.	aTabbedPalette tabsMorph hResizing: #spaceFill.	^ aTabbedPalette! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 22:50'!tiltImageBy: pixels	self changeOffsetBy: 0 @ (pixels * self getTiltFactor * 0.1)"	steps := (pixels abs / 6) exp rounded * pixels sign.""==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 7/2/1998 17:52'!addTabForBook: aBook	| aTab |	aTab := tabsMorph addTabForBook: aBook.	pages add: aBook.	currentPage ifNil: [currentPage := aBook].	^ aTab! !!BouncingAtomsMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:32'!step	"Bounce those atoms!!"	| r bounces |	super step.	bounces := 0.	r := bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces := bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!PostscriptCanvas methodsFor: 'drawing' stamp: 'di 8/13/2000 12:27'!paragraph: para bounds: bounds color: c 	| displayablePara |	self comment:'paragraph with bounds: ' with:bounds.	displayablePara := para asParagraphForPostscript.	self preserveStateDuring:		[:inner |		displayablePara displayOn: inner			using: (PostscriptCharacterScanner					scannerWithCanvas: self paragraph: displayablePara bounds: bounds)			at: bounds topLeft]! !!IndexTabs methodsFor: 'layout' stamp: 'sw 1/13/2000 15:50'!rowsNoWiderThan: maxWidth	| aPosition neededHeight |	self fixedWidth: maxWidth.	verticalPadding ifNil: [verticalPadding := 4].  "for benefit of old structures"	aPosition := self topLeft.	neededHeight := self basicHeight.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			(aMorph right > (self left + maxWidth)) ifTrue:				[aPosition := self left @ (aPosition y + neededHeight).				aMorph position: aPosition + (padding @ 0).				neededHeight := self basicHeight].			aPosition := aMorph topRight.			neededHeight := neededHeight max: aMorph height].	self extent: (maxWidth @ ((aPosition y + neededHeight) - self top))! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'dgd 4/4/2006 15:28'!moreCommands	"Put up a menu of options"	| allThreads aMenu others target |	allThreads := self class knownThreads.	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'navigation' translated.	Preferences noviceMode ifFalse:[		self flag: #deferred.  "Probably don't want that stay-up item, not least because the navigation-keystroke stuff is not dynamically handled"		aMenu addStayUpItem	].		others := (allThreads keys reject: [ :each | each = threadName]) asSortedCollection.	others do: [ :each |		aMenu add: ('switch to <{1}>' translated format:{each}) selector: #switchToThread: argument: each	].	aMenu addList: {		{'switch to recent projects' translated.  #getRecentThread}.		#-.		{'create a new thread' translated.  #threadOfNoProjects}.		{'edit this thread' translated.  #editThisThread}.		{'create thread of all projects' translated.  #threadOfAllProjects}.		#-.		{'First project in thread' translated.  #firstPage}.		{'Last project in thread' translated.  #lastPage}	}.	(target := self currentIndex + 2) > listOfPages size ifFalse: [		aMenu 			add: ('skip over next project ({1})' translated format:{(listOfPages at: target - 1) first})			action: #skipOverNext	].	aMenu addList: {		{'jump within this thread' translated.  #jumpWithinThread}.		{'insert new project' translated.  #insertNewProject}.		#-.		{'simply close this navigator' translated.  #delete}.		{'destroy this thread' translated. #destroyThread}.		#-	}.	(ActiveWorld keyboardNavigationHandler == self) ifFalse:[		aMenu add: 'start keyboard navigation with this thread' translated action: #startKeyboardNavigation	]	ifTrue: [		aMenu add: 'stop keyboard navigation with this thread' translated action: #stopKeyboardNavigation	].	aMenu popUpInWorld.! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 12/7/1998 17:26'!newTabs: tabsList	"Reconstitute the palette based on info in the tabs list"	| itsBook color1 color2 color3 |	pages := pages species new.	tabsMorph ifNotNil:		[color1 := tabsMorph  highlightColor.		color2 := tabsMorph regularColor.		color3 := tabsMorph color.		tabsMorph delete].	tabsMorph := IndexTabs new.	self addMorphFront: tabsMorph.	color1 ifNotNil:		[tabsMorph highlightColor: color1 regularColor: color2; color: color3].	currentPage ifNotNil:		[currentPage delete.		currentPage := nil].	tabsList do:		[:aTab |			tabsMorph addTab: aTab.			aTab unHighlight.			(itsBook := aTab morphToInstall) ifNotNil:					[pages add: itsBook.					currentPage ifNil: [currentPage := itsBook]]].	tabsMorph position: self position + self borderWidth! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:49'!addKeyboard	keyboard := PianoKeyboardMorph new soundPrototype: sound.	keyboard align: keyboard bounds bottomCenter with: bounds bottomCenter - (0@4).	self addMorph: keyboard! !!WorldState methodsFor: '*MorphicExtras-update cycle' stamp: 'RAA 6/6/2000 17:30'!displayWorldAsTwoTone: aWorld submorphs: submorphs color: color	"Display the world in living black-and-white. (This is typically done to save space.)"	| f |	f := ColorForm extent: aWorld viewBox extent depth: 1.	f colors: (Array with: color dominantColor with: Color black).	self canvas: f getCanvas.	"force the entire canvas to be redrawn"	aWorld fullRepaintNeeded.	self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "redraw on offscreen canvas"	canvas showAt: aWorld viewBox origin.  "copy redrawn areas to Display"	Display forceDisplayUpdate.	self canvas: nil.  "forget my canvas to save space"! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/2/2004 01:27'!fontsForHelvetica	| d |	"Bold = 1, Ital = 2, Under = 4, Narrow = 8, Struckout = 16"	d := Dictionary new.	d		at: 0 put: #('Helvetica' 1.0);		at: 1 put: #('Helvetica-Bold' 1.0);		at: 2 put: #('Helvetica-Oblique' 1.0);		at: 3 put: #('Helvetica-BoldOblique' 1.0);		at: 8 put: #('Helvetica-Narrow' 1.0);		at: 9 put: #('Helvetica-Narrow-Bold' 1.0);		at: 10 put: #('Helvetica-Narrow-Oblique' 1.0);		at: 11 put: #('Helvetica-Narrow-BoldOblique' 1.0).	^d! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 9/16/2000 17:35'!pasteUp: x	pasteUp := x.! !!EventHandler methodsFor: '*MorphicExtras-initialization' stamp: 'ar 3/17/2001 20:12'!adaptToWorld: aWorld	"If any of my recipients refer to a world or a hand, make them now refer	to the corresponding items in the new world.  (instVarNamed: is slow, later	use perform of two selectors.)"	| value newValue |	#(mouseDownRecipient mouseStillDownRecipient mouseUpRecipient	mouseEnterRecipient mouseLeaveRecipient mouseEnterDraggingRecipient	mouseLeaveDraggingRecipient clickRecipient doubleClickRecipient startDragRecipient keyStrokeRecipient valueParameter) do:		[:aName |		(value := self instVarNamed: aName asString) ifNotNil:[			newValue := value adaptedToWorld: aWorld.			(newValue notNil and: [newValue ~~ value])				ifTrue:					[self instVarNamed: aName asString put: newValue]]]! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'sw 5/23/2001 13:54'!moveButtons	"Move buttons one at a time and let the user place them over the background.  Later can move them again by turning on AuthorModeOwner in ThreePhaseButtonMorph.	self createButtons.	"	| rect button |	#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: "pickup: pickup: pickup: pickup:" "stamp: stamp: stamp: stamp:" undo: keep: toss: prevStamp: nextStamp:) do: [:sel |			self inform: 'Rectangle for ',sel.			rect := Rectangle fromUser.			button := self submorphNamed: sel.			button bounds: rect.	"image is nil"].	#(brush1: brush2: brush3: brush4: brush5: brush6: ) doWithIndex: [:sel :ind |			self inform: 'Rectangle for ',sel.			rect := Rectangle fromUser.			button := self submorphNamed: sel.			button bounds: rect.	"image is nil"].	"stamp:  Stamps are held in a ScrollingToolHolder.  Pickups and stamps and brushes are id-ed by the button == with item from a list."	"	"! !!LedTimerMorph methodsFor: 'stepping and presenter' stamp: 'djp 10/31/1999 21:44'!stop	counting ifTrue: [self updateTime].	counting := false.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 9/5/1998 10:40'!initOnSound: aSound title: title	sound := aSound.	soundName := title.	self initialize.! !!ProjectNavigationMorph methodsFor: 'as yet unclassified' stamp: 'sw 1/31/2006 02:32'!makeUpdatingButtonWithBalloonText: balloonString actionSelector: actionSymbol wordingSelector: wordingSymbol	"Answer a button  whose target is the receiver (i.e. a ProjectNavigationMorph), who gets its wording by sending the wordingSelector to me.  The given string"	| aButton |	aButton := UpdatingSimpleButtonMorph new.	aButton		target: self;		borderColor: #raised;		color: self colorForButtons;		label: '-' font: self fontForButtons;		setBalloonText: balloonString translated;		actionSelector: actionSymbol;		wordingSelector: wordingSymbol.	aButton step.	^ aButton		! !!SketchEditorMorph methodsFor: 'event handling' stamp: 'sw 7/5/2004 03:23'!mouseEnter: evt	"Set the cursor.  Reread colors if embedded editable polygon needs it."	| poly cColor |	super mouseEnter: evt.	(self get: #action for: evt) == #scaleOrRotate ifTrue: [		self set: #action for: evt to: (self get: #priorAction for: evt).		].	"scale and rotate are not real modes.  If we enter with one, wear the previous tool."	evt hand showTemporaryCursor: (self getCursorFor: evt).	palette getSpecial == #polygon: ifFalse: [^self].	(poly := self valueOfProperty: #polygon) ifNil: [^ self].	cColor := self getColorFor: evt.	poly borderColor: cColor; borderWidth: (self getNibFor: evt) width.	poly changed.! !!TransitionMorph methodsFor: 'stepping and presenter' stamp: 'di 12/14/1998 12:30'!step	(stepNumber := stepNumber + 1) <= nSteps		ifTrue: [self changed]		ifFalse: [self completeReplacement]! !!TextComponent methodsFor: 'components' stamp: 'di 5/1/1998 13:39'!initPinSpecs 	pinSpecs := Array		with: (PinSpec new pinName: 'text' direction: #inputOutput				localReadSelector: nil localWriteSelector: nil				modelReadSelector: getTextSelector modelWriteSelector: setTextSelector				defaultValue: 'some text' pinLoc: 1.5)! !!CommandHistory methodsFor: 'menu' stamp: 'ar 8/31/2000 22:41'!nextCommandToUndo	| anIndex |	lastCommand ifNil: [^ nil].	lastCommand phase == #done ifTrue: [^ lastCommand].	(lastCommand phase == #undone and:		[(anIndex := history indexOf: lastCommand) > 1])		ifTrue: [^ history at: anIndex - 1]		ifFalse: [^ nil]! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 8/22/2000 11:57'!setAction: aSelector evt: evt	"Find this button and turn it on.  Does not work for stamps or pickups"	| button |	button := self submorphNamed: aSelector. 	button ifNotNil: [		button state: #on.		button doButtonAction: evt].	"select it!!"! !!GraphMorph methodsFor: 'accessing' stamp: ''!startIndex: aNumber	startIndex ~= aNumber ifTrue:  [		startIndex := aNumber asInteger.		self flushCachedForm].! !!InternalThreadNavigationMorph class methodsFor: 'thumbnails' stamp: 'RAA 5/10/2001 17:09'!clearThumbnailCache	CachedThumbnails := nil! !!ThumbnailMorph methodsFor: 'initialization' stamp: 'sw 6/9/2000 18:35'!objectToView: objectOrNil	(objectOrNil isMorph and: [objectOrNil allMorphs includes: self]) ifTrue:		["cannot view a morph containing myself or drawOn: goes into infinite recursion"		objectToView := nil.		^ self].	objectToView := objectOrNil! !!ClockMorph methodsFor: '24hr' stamp: 'fc 2/8/2004 11:39'!toggleShowing24hr	show24hr := (show24hr == true) not! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 3/25/2004 16:06'!fontSampler	"Produces a Postscript .eps file on disk, returns a Morph."	"PostscriptCanvas fontSampler"	"PostscriptCanvas fontSampler openInWorld"	| morph file |	morph := Morph new		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		wrapDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: Color white.	TextStyle actualTextStyles keysAndValuesDo: [ :styleName :style |		{ style fontArray first. style fontArray last } do: [ :baseFont | | info |			0 to: 2 do: [ :i | | font string string2 textMorph row |				font := baseFont emphasized: i.				(i isZero or: [ font ~~ baseFont ]) ifTrue: [					string := font fontNameWithPointSize.					row := Morph new						layoutPolicy: TableLayout new;						listDirection: #topToBottom;						hResizing: #shrinkWrap;						vResizing: #shrinkWrap;						cellSpacing: 20@0;						color: Color white.							textMorph := TextMorph new hResizing: #spaceFill; backgroundColor: Color white; beAllFont: font; contentsAsIs: string.					row addMorphBack: (textMorph imageForm asMorph).					info := self postscriptFontInfoForFont: font.					string2 := String streamContents: [ :stream |						stream nextPutAll: info first; space; print: (font pixelSize * info second) rounded.					].					textMorph := TextMorph new hResizing: #spaceFill; backgroundColor: Color white; beAllFont: font; contentsAsIs: string2.					row addMorphBack: textMorph.										morph addMorphBack: row.				]			]		]	].	morph bounds: World bounds.	morph layoutChanged; fullBounds.	file := (FileDirectory default newFileNamed: 'PSFontSampler.eps').	Cursor wait showWhile: [ 		file nextPutAll: (EPSCanvas morphAsPostscript: morph) ].	^morph! !!ListComponent methodsFor: 'initialization' stamp: 'di 5/6/1998 11:09'!list: listOfItems	super list: listOfItems.	self selectionIndex: 0.	selectedItem := nil.	setSelectionSelector ifNotNil:		[model perform: setSelectionSelector with: selectedItem]! !!TabbedPalette methodsFor: 'initialization' stamp: 'sw 1/11/2000 11:16'!addTabFor: aReferent font: aFont	| aTab |	aTab := tabsMorph addTabFor: aReferent font: aFont.	pages add: aReferent.	currentPage ifNil: [currentPage := aReferent].	^ aTab! !!InterimSoundMorph methodsFor: 'as yet unclassified' stamp: 'jm 9/18/97 15:01'!sound: aSound	sound := aSound.! !!BookMorph class methodsFor: 'booksAsProjects' stamp: 'RAA 11/10/2000 11:26'!makeBookOfProjects: aListOfProjects named: aString"BookMorph makeBookOfProjects: (Project allProjects select: [ :each | each world isMorph])"	| book pvm page |	book := self new.	book setProperty: #transitionSpec toValue: {'silence'. #none. #none}.	aListOfProjects do: [ :each |		pvm := ProjectViewMorph on: each.		page := PasteUpMorph new addMorph: pvm; extent: pvm extent.		book insertPage: page pageSize: page extent	].	book goToPage: 1.	book deletePageBasic.	book setProperty: #nameOfThreadOfProjects toValue: aString.	book removeProperty: #transitionSpec.	book openInWorld! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/6/2000 17:13'!setMinVal: newMinVal	minVal := newMinVal asNumber.	maxVal := maxVal max: minVal! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'ar 8/13/2003 11:41'!intoWorld: aWorld	"Make sure report damage at least once"	damageReported := false.	super intoWorld: aWorld.! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 15:12'!valuesForHand: anEventOrHand	| hand valuesForHand |	forEachHand ifNil: [forEachHand := IdentityDictionary new].	hand := (anEventOrHand isKindOf: HandMorph) 				ifTrue: [anEventOrHand] ifFalse: [anEventOrHand hand].	valuesForHand := forEachHand at: hand ifAbsentPut: [Dictionary new].	^valuesForHand! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/1/2004 23:05'!initializeFontMap	"Initialize the dictionary mapping font names to substitutions for Postscript code generation."	"PostscriptCanvas initializeFontMap"	| f |	FontMap := Dictionary new.	FontMap		at: 'NewYork' put: (f := self fontsForNewYork);		at: 'Accuny' put: f;		at: 'Helvetica' put: (f := self fontsForHelvetica);		at: 'Accujen' put: f;						at: 'Palatino' put: self fontsForPalatino;				at: 'ComicBold' put: (f := self fontsForComicBold);		at: 'Accuat' put: self fontsForAccuAt;				at: 'ComicPlain' put: self fontsForComicPlain! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'sw 7/25/2004 03:16'!rect: evt 	"While moving corner, just write on the canvas. When done, write on the paintingForm"	| rect oldRect now diff cor cColor sOrigin priorEvt |	sOrigin := self get: #strokeOrigin for: evt.	rect := sOrigin rect: (now := evt cursorPoint).	cColor := self getColorFor: evt.	evt shiftPressed		ifTrue: [diff := evt cursorPoint - sOrigin.			now := sOrigin						+ (Point r: (diff x abs min: diff y abs)									* 2 degrees: diff degrees // 90 * 90 + 45).			rect := sOrigin rect: now].	(priorEvt := self get: #lastEvent for: evt) isNil		ifFalse: [oldRect := sOrigin rect: priorEvt cursorPoint.			priorEvt shiftPressed				ifTrue: [diff := priorEvt cursorPoint - sOrigin.					cor := sOrigin								+ (Point r: (diff x abs min: diff y abs)											* 2 degrees: diff degrees // 90 * 90 + 45).					oldRect := sOrigin rect: cor].		self restoreRect: oldRect].  		"Last draw will stick out, must erase the area"	cColor == Color transparent		ifTrue: [formCanvas				frameAndFillRectangle: rect				fillColor: Color transparent				borderWidth: (self getNibFor: evt) width				borderColor: Color black]		ifFalse: [formCanvas				frameAndFillRectangle: rect				fillColor: Color transparent				borderWidth: (self getNibFor: evt) width				borderColor: cColor].	self invalidRect: rect! !!BOBTransformationMorph methodsFor: 'drawing' stamp: 'RAA 6/4/2001 16:21'!drawSubmorphsOn: aCanvas	| t | 	t := [		self drawSubmorphsOnREAL: aCanvas	] timeToRun."Q1 at: 3 put: t."! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/26/2000 19:24'!changeWorldBoundsToShow: aRectangle	aRectangle area = 0 ifTrue: [^self].	worldBoundsToShow := aRectangle.	owner myWorldChanged.! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 9/25/1999 22:27'!backgroundColor: aColor        backgroundColor := aColor.        self changed! !!Component methodsFor: 'naming' stamp: 'di 5/3/1998 19:51'!renameMe	| newName |	newName := self chooseNameLike: self knownName.	newName ifNil: [^ nil].	self setNamePropertyTo: newName! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:02'!drawSlideBothOn: aCanvas	"endMorph slides in the given direction, as startMorph slides out of its way."	| endLoc endRect startLoc |	startLoc := self stepFrom: self position to: self position + (self extent * direction).	aCanvas drawImage: startForm at: startLoc.	endLoc := self stepFrom: self position - (self extent * direction) to: self position.	aCanvas drawImage: endForm at: endLoc.	endRect := endForm boundingBox translateBy: endLoc.	((endRect translateBy: direction) areasOutside: endRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!EnvelopeEditorMorph methodsFor: 'editing' stamp: 'ar 3/17/2001 14:24'!limitHandleMove: index event: evt from: handle	"index is the handle index = 1, 2 or 3"	| ix p ms x points limIx |	ix := limits at: index.  "index of corresponding vertex"	p := evt cursorPoint adhereTo: graphArea bounds.	ms := self msFromX: p x + (self handleOffset: handle) x.	"Constrain move to adjacent points on ALL envelopes"	sound envelopes do:		[:env | limIx := env perform:			(#(loopStartIndex loopEndIndex decayEndIndex) at: index).		ms := self constrain: ms adjacentTo: limIx in: env points].	"Update the handle, the vertex and the line being edited"	x := self xFromMs: ms.	handle position: (x @ graphArea top) - (self handleOffset: handle).	line verticesAt: ix put: x @ (line vertices at: ix) y.	sound envelopes do:		[:env | limIx := env perform:			(#(loopStartIndex loopEndIndex decayEndIndex) at: index).		points := env points.		points at: limIx put: ms @ (points at: limIx) y.		env setPoints: points loopStart: env loopStartIndex loopEnd: env loopEndIndex].! !!GeeMailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/3/2001 13:06'!scrollToPage: pageNumber	| rects oneRect |	rects := self valueOfProperty: #pageBreakRectangles ifAbsent: [#()].	oneRect := rects at: pageNumber - 1 ifAbsent: [0@0 extent: 0@0].	self scrollToYAbsolute: oneRect bottom.! !!ClockMorph methodsFor: 'menu' stamp: 'fc 2/8/2004 11:57'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Note minor loose end here -- if the menu is persistent, then the wording will be wrong half the time"	| item |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	item := showSeconds == true		ifTrue:	['stop showing seconds']		ifFalse: ['start showing seconds'].	aCustomMenu add: item translated target: self action: #toggleShowingSeconds.	item := show24hr == true		ifTrue: ['display Am/Pm']		ifFalse: ['display 24 hour'].	aCustomMenu add: item translated target: self action: #toggleShowing24hr.			! !!TwoWayScrollPane methodsFor: 'initialization' stamp: 'jam 3/9/2003 17:52'!createScrollBarNamed: aString "creates a scroll bar named as aString"	| result |	result := ScrollBar new model: self slotName: aString.	result borderWidth: 2;		 borderColor: #inset.	^ result! !!ThumbnailMorph methodsFor: 'initialization' stamp: 'sw 6/9/2000 18:35'!objectToView: objectOrNil viewSelector: aSelector	self objectToView: objectOrNil.	viewSelector := aSelector! !!BookMorph class methodsFor: 'scripting' stamp: 'sw 3/6/1999 01:21'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| book |	book := self new markAsPartsDonor.	book removeEverything; pageSize: 360@228; color: (Color gray: 0.9).	book borderWidth: 1; borderColor: Color black.	book beSticky.	book showPageControls; insertPage.	^ book! !!ObjectsTool methodsFor: 'alphabetic' stamp: 'dgd 4/4/2006 16:43'!alphabeticTabs	"Answer a list of buttons which, when hit, will trigger the choice of a morphic category"	| buttonList aButton tabLabels |	self flag: #todo. "includes non-english characters"	tabLabels := (($a to: $z) collect: [:ch | ch asString]) asOrderedCollection.	buttonList := tabLabels collect:		[:catName |			aButton := SimpleButtonMorph new label: catName.			aButton actWhen: #buttonDown.			aButton target: self; actionSelector: #showAlphabeticCategory:fromButton:; arguments: {catName. aButton}].	^ buttonList"ObjectsTool new tabsForMorphicCategories"! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/19/2000 16:27'!linkNewlyDroppedMorph: aMorph	| ed para lineToUse |	ed := self editor.	para := self paragraph.	lineToUse := para lines detect: [ :each | each bottom > aMorph top] ifNone: [para lines last].	ed selectFrom: lineToUse first to: lineToUse last.	self addAlansAnchorFor: aMorph.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:17'!toggleDirType: evt in: handle	"Toggle from 'rotate' to 'to and fro' to 'up and down' to 'none'for the kind of rotation the object does.  An actor's rotationStyle is oneof #(normal leftRight upDown none)."| rr ii |"Clear the indicator""Find new style, store it, install the indicator"rr := self rotationStyle.ii := #(normal leftRight upDown none) indexOf: rr.self setProperty: #rotationStyle toValue:	(#(leftRight upDown none normal) at: ii).ii = 4 ifTrue: ["normal" self forward: self forwardDirection			direction: (self valueOfProperty: #fwdButton)]	ifFalse: [self showDirType.].! !!TabbedPalette methodsFor: 'misc menu items' stamp: 'sw 3/3/1999 13:06'!showNoPaletteAndHighlightTab: aTab	| oldTab morphToInstall aSketchEditor |	oldTab := tabsMorph highlightedTab.	(oldTab notNil and: [(morphToInstall := oldTab morphToInstall) isKindOf: PaintBoxMorph])		ifTrue:			[(aSketchEditor := self world submorphOfClass: SketchEditorMorph) ifNotNil:				[aSketchEditor cancelOutOfPainting].			morphToInstall delete].	currentPage ifNotNil: [currentPage delete].	currentPage := nil.	submorphs size > 1 ifTrue: "spurious submorphs, yecch"		[(submorphs copyFrom: 2 to: submorphs size) do: [:m | m delete]].	tabsMorph highlightTab: aTab! !!RemoteHandMorph methodsFor: 'private' stamp: 'ar 10/26/2000 01:55'!getNextRemoteEvent	"Return the next remote event, or nil if the receive buffer does not contain a full event record. An event record is the storeString for a MorphicEvent terminated by a <CR> character."	| i s evt |	self receiveData.	receiveBuffer isEmpty ifTrue: [^ nil].	i := receiveBuffer indexOf: Character cr ifAbsent: [^ nil].	s := receiveBuffer copyFrom: 1 to: i - 1.	receiveBuffer := receiveBuffer copyFrom: i + 1 to: receiveBuffer size.	evt := (MorphicEvent readFromString: s).	evt ifNil:[^nil].	evt setHand: self.	evt isKeyboard ifTrue:[evt setPosition: self position].	^evt resetHandlerFields! !!GraphicalMenu methodsFor: 'as yet unclassified' stamp: 'ar 6/25/1999 11:54'!okay	| nArgs |	target ifNotNil:[		nArgs := selector numArgs.		nArgs = 1 ifTrue:[target perform: selector with: (formChoices at: currentIndex)].		nArgs = 2 ifTrue:[target perform: selector with: (formChoices at: currentIndex) with: argument]].	coexistWithOriginal		ifTrue:			[self delete]		ifFalse:			[owner replaceSubmorph: self topRendererOrSelf by: target]! !!FancyMailComposition methodsFor: 'actions' stamp: 'dvf 6/15/2002 19:09'!completeTheMessage	| newText strm |	textFields do: [ :each | each hasUnacceptedEdits ifTrue: [ each accept ] ].	newText := String new: 200.	strm := WriteStream on: newText.	strm 		nextPutAll: 'Content-Type: text/html'; cr;		nextPutAll: 'From: ', MailSender userName; cr;		nextPutAll: 'To: ',to; cr;		nextPutAll: 'Subject: ',subject; cr;		cr;		nextPutAll: '<HTML><BODY><BR>';		nextPutAll: messageText asString asHtml;		nextPutAll: '<BR><BR>',theLinkToInclude,'<BR></BODY></HTML>'.	^strm contents! !!TextOnCurve methodsFor: 'selection' stamp: 'di 12/3/97 09:06'!selectionRectsFrom: characterBlock1 to: characterBlock2	"Return an array of rectangles encompassing the area	between the two character blocks, presumably a selection."	| rects |	rects := OrderedCollection new.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(characterBlock1 stringIndex <= line last			and: [characterBlock2 stringIndex >= line first]) ifTrue:			[rects addLast: destRect].		line first > characterBlock2 stringIndex ifTrue:			[^ rects]].	^ rects! !!SimpleSliderMorph methodsFor: 'copying' stamp: 'jm 1/29/98 16:18'!updateReferencesUsing: aDictionary	"Copy and update references in the arguments array during copying."	super updateReferencesUsing: aDictionary.	arguments := arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 21:03'!loopLength: aNumber	loopLength := aNumber.	((loopCycles > 0) and: [loopLength > 0]) ifTrue: [		perceivedFrequency := samplingRate asFloat * loopCycles / loopLength].! !!ZASMScriptMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:46'!initialize	"initialize the state of the receiver"	super initialize.	""	somethingChanged := true.	self dragEnabled: true;		 layoutPolicy: TableLayout new;		 listDirection: #topToBottom;		 wrapCentering: #topLeft;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 6;				 rubberBandCells: true! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'sw 5/23/2001 13:54'!loadCursors	"Display the form containing the cursors.  Transparent is (Color r: 1.0 g: 0 b: 1.0).  Grab the forms one at a time, and they are stored away.	self loadCursors.	"	| button transp cursor map |	transp := Color r: 1.0 g: 0 b: 1.0.	map := Color indexedColors copy.	"just in case"	1 to: 256 do: [:ind | (map at: ind) = transp ifTrue: 				[map at: ind put: Color transparent]].	#(erase: eyedropper: fill: paint: rect: ellipse: polygon: line: star: ) do: [:sel |		self inform: 'Rectangle for ',sel.		cursor := ColorForm fromUser.		cursor colors: map.	"share it"		button := self submorphNamed: sel.		button arguments at: 3 put: cursor].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/26/2000 01:55'!readFromV0: aStream	| cr line lineStream t evt |	cr := Character cr.	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:			[line := aStream upTo: cr.			line isEmpty "Some MW tapes have an empty record at the end"				ifFalse: [lineStream := ReadStream on: line.						t := Integer readFrom: lineStream.						[lineStream peek isLetter] whileFalse: [lineStream next].						evt := MorphicEvent readFromObsolete: lineStream.						tStream nextPut: t -> evt]]].! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 3/25/2004 20:13'!postscriptFontInfoForFont: font	| fontName decoded desired mask decodedName keys match |	fontName := font textStyleName asString.	decoded := TextStyle decodeStyleName: fontName.	decodedName := decoded second.	keys := self fontMap keys asArray sort: [ :a :b | a size > b size ].	match := keys select: [ :k | decoded first = k or: [ fontName = k ] ].	match do: [ :key | | subD |		subD := self fontMap at: key.		desired := font emphasis.		mask := 31.		[			desired := desired bitAnd: mask.			subD at: desired ifPresent: [ :answer | ^answer].			mask := mask bitShift: -1.			desired > 0		] whileTrue.	].	"No explicit lookup found; try to convert the style name into the canonical Postscript name.	This name will probably still be wrong."	fontName := String streamContents: [ :s |		s nextPutAll: decodedName.		decoded third do: [ :nm | s nextPut: $-; nextPutAll: nm ].		(font emphasis == 0 and: [ (decoded last includes: 0) not ])			ifTrue: [ s nextPutAll:  '-Regular' ].		(font emphasis == 1 and: [ (decoded first anyMask: 1) not ])			ifTrue: [ s nextPutAll:  '-Bold' ].		(font emphasis == 2 and: [ (decoded first anyMask: 2) not ])			ifTrue: [ s nextPutAll:  '-Italic' ].		(font emphasis == 3 and: [ (decoded first anyMask: 3) not ])			ifTrue: [ s nextPutAll:  '-BoldItalic' ].	].	^ {fontName. 1.0}! !!TabSorterMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/2/1999 16:47'!sortTabsFor: aTabbedPalette	| actualTabs |	actualTabs := aTabbedPalette tabMorphs.	self book: aTabbedPalette morphsToSort:		(actualTabs collect: [:aTab | aTab sorterToken]).	pageHolder color: aTabbedPalette tabsMorph color. 	self position: aTabbedPalette position.	pageHolder extent: self extent.	self setNameTo: 'Tab Sorter for ', aTabbedPalette externalName.	aTabbedPalette owner addMorphFront: self! !!BookMorph class methodsFor: 'scripting' stamp: 'sw 6/13/2001 17:14'!nextPageButton	"Answer a button that will take the user to the next page of its enclosing book"	| aButton |	aButton := SimpleButtonMorph new.	aButton target: aButton; actionSelector: #nextOwnerPage; label: '->'; color: Color yellow.	aButton setNameTo: 'next'.	^ aButton! !!TabSorterMorph methodsFor: 'initialization' stamp: 'tk 10/30/2001 18:41'!initialize	super initialize.	self removeAllMorphs.	self extent: 300@100.	pageHolder := PasteUpMorph new.	pageHolder vResizeToFit: true; autoLineLayout: true.	pageHolder extent: self extent - borderWidth.	pageHolder padding: 8.	pageHolder cursor: 0.	self addControls.	self addMorphBack: pageHolder! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!changeOffsetTo: aPoint	| transform trialOffset innerPasteup keepWidth keepHeight |	transform := self myTransformMorph.	keepWidth := transform width "// 4".	keepHeight := transform height "// 4".	innerPasteup := transform firstSubmorph.	trialOffset := aPoint.	trialOffset := 		(trialOffset x 			min: (innerPasteup width * transform scale) - keepWidth 			max: keepWidth - transform width) @ 		(trialOffset y 			min: (innerPasteup height * transform scale) - keepHeight 			max: keepHeight - transform height).	transform offset: trialOffset.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'JMM 9/13/2004 09:47'!eyedropper: aButton action: aSelector cursor: aCursor evt: evt 	"Take total control and pick up a color!!!!"	| pt feedbackColor delay |	delay := Delay forMilliseconds: 10.	aButton state: #on.	tool ifNotNil: [tool state: #off].	currentCursor := aCursor.	evt hand showTemporaryCursor: currentCursor		hotSpotOffset: 6 negated @ 4 negated.	"<<<< the form was changed a bit??"	feedbackColor := Display colorAt: Sensor cursorPoint.	colorMemory align: colorMemory bounds topRight		with: colorMemoryThin bounds topRight.	self addMorphFront: colorMemory.	"Full color picker"	[Sensor anyButtonPressed] whileFalse: 			[pt := Sensor cursorPoint.			"deal with the fact that 32 bit displays may have garbage in the 			alpha bits"			feedbackColor := Display depth = 32 						ifTrue: 							[Color colorFromPixelValue: ((Display pixelValueAt: pt) bitOr: 4278190080)								depth: 32]						ifFalse: [Display colorAt: pt].			"the hand needs to be drawn"			evt hand position: pt.			currentColor ~= feedbackColor ifTrue: [				currentColor := feedbackColor.				self showColor ].			self world displayWorldSafely.			delay wait].	"Now wait for the button to be released."	[Sensor anyButtonPressed] whileTrue:		[ pt := Sensor cursorPoint.		"the hand needs to be drawn"		evt hand position: pt.		self world displayWorldSafely.		delay wait].	evt hand showTemporaryCursor: nil hotSpotOffset: 0 @ 0.	self currentColor: feedbackColor evt: evt.	colorMemory delete.	tool ifNotNil: 			[tool state: #on.			currentCursor := tool arguments third].	aButton state: #off! !!InternalThreadNavigationMorph methodsFor: 'private' stamp: 'dao 10/1/2004 13:31'!loadPageWithProgress	"Load the desired page, showing a progress indicator as we go"		| projectInfo projectName beSpaceHandler |	projectInfo := listOfPages at: currentIndex.	projectName := projectInfo first.	loadedProject := Project named: projectName.	self class know: listOfPages as: threadName.	beSpaceHandler := (ActiveWorld keyboardNavigationHandler == self).	WorldState addDeferredUIMessage:		[InternalThreadNavigationMorph openThreadNamed: threadName atIndex: currentIndex beKeyboardHandler: beSpaceHandler] fixTemps.	loadedProject ifNil: [		ComplexProgressIndicator new 			targetMorph: self;			historyCategory: 'project loading' translated;			withProgressDo: [				[					loadedProject := Project current 							fromMyServerLoad: projectName				] 					on: ProjectViewOpenNotification					do: [ :ex | ex resume: false]								"we probably don't want a project view morph in this case"			].	].	loadedProject ifNil: [		^self inform: 'I cannot find that project' translated	].	self delete.	loadedProject enter.! !!GraphicalMenu methodsFor: 'event handling' stamp: 'nk 1/11/2004 14:44'!updateThumbnail	| f |	f := formChoices at: currentIndex.	formDisplayMorph 		makeThumbnailFromForm: f.! !!ProjectNavigationMorph methodsFor: 'stepping and presenter' stamp: 'RAA 8/23/2001 18:11'!step	| wb |	owner ifNil: [^ self].	(self ownerThatIsA: HandMorph) ifNotNil: [^self].	self checkForRebuild.	owner == self world ifTrue: [		owner addMorphInLayer: self.		wb := self worldBounds.		self left < wb left ifTrue: [self left: wb left].		self right > wb right ifTrue: [self right: wb right].		self positionVertically.	].! !!GraphMorph methodsFor: 'commands' stamp: 'jm 4/22/1999 14:23'!loadSoundData: aCollection	| scale absV newData |	scale := 0.	aCollection do: [:v | (absV := v abs) > scale ifTrue: [scale := absV]].	scale := 100.0 / scale.	newData := OrderedCollection new: aCollection size.	1 to: aCollection size do: [:i | newData addLast: (scale * (aCollection at: i))].	self data: newData.	self startIndex: 1.	self cursor: 1.! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 9/25/1999 16:18'!selectionAsForm        | relativeBounds scaledBounds |        currentSelectionMorph ifNil: [^nil].        relativeBounds := currentSelectionMorph bounds translateBy: self position negated.        scaledBounds := relativeBounds scaleBy: 1 / magnification.        ^ self unmagnifiedForm copy: scaledBounds! !!FancyMailComposition methodsFor: 'actions' stamp: 'mir 5/13/2003 10:58'!submit: sendNow	| message |	messageText := self breakLines: self completeTheMessage atWidth: 999.	message := MailMessage from: messageText.	SMTPClient			deliverMailFrom: message from 			to: (Array with: message to) 			text: message text 			usingServer: self smtpServer.	self forgetIt.! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 8/6/1998 23:45'!pageNumber: n inBook: b	pageNumber := n.	bookMorph := b! !!PaintBoxMorph methodsFor: 'actions' stamp: 'ar 10/10/2000 16:38'!plainCursor: aCursor event: anEvent	"Set the cursor to use with this painting action/tool. Offset of the form must be set."	currentCursor := aCursor.	anEvent hand showTemporaryCursor: aCursor.	self notifyWeakDependentsWith: {#currentCursor. anEvent. currentCursor}.! !!SimpleSwitchMorph methodsFor: 'switching' stamp: 'jm 1/29/98 20:18'!offColor: aColor	offColor := aColor.! !!FatBitsPaint methodsFor: 'events' stamp: 'nk 4/18/2004 19:04'!toolMenu: evt	| menu |	menu := MenuMorph new.	menu		addTitle: 'Tools';		addStayUpItem.	{		{'paint brush'. self toolsForPaintBrush}.		{'selections'. self toolsForSelection}	} do: [:each |		menu add: each first			target: self			selector: #setCurrentToolTo:			argumentList: {each second}].	menu toggleStayUp: evt.	menu popUpEvent: evt in: self world! !!PaintBoxColorPicker methodsFor: 'drawing' stamp: 'jm 4/29/1998 20:00'!drawOn: aCanvas	"Image plus circles for currently selected color."	| c |	super drawOn: aCanvas.	locOfCurrent ifNotNil: [		c := self ringColor.		aCanvas			fillOval: (Rectangle center: locOfCurrent + self topLeft extent: 9@9)			color: Color transparent			borderWidth: 1			borderColor: c].! !!SimpleButtonMorph methodsFor: '*MorphicExtras-e-toy support' stamp: 'ar 3/17/2001 20:17'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target := target adaptedToWorld: aWorld.! !!PartsBin class methodsFor: 'thumbnail cache' stamp: 'sw 7/12/2001 18:56'!clearThumbnailCache	"Clear the cache of thumbnails:		PartsBin clearThumbnailCache"	Thumbnails := Dictionary new! !!MVCWiWPasteUpMorph methodsFor: 'activation' stamp: 'RAA 11/25/1999 10:09'!revertToParentWorldWithEvent: evt">>unused, but we may want some of this later	self damageRecorder reset.	World := parentWorld.	World assuredCanvas.	World installFlaps.	owner changed.	hostWindow setStripeColorsFrom: Color red.	World restartWorldCycleWithEvent: evt.<<<"! !!WorldState methodsFor: '*MorphicExtras-update cycle' stamp: 'di 6/10/1999 22:40'!startBackgroundProcess	"Start a process to update this world in the background. Return the process created."	| p |	p := [[true] whileTrue: [		self doOneCycleInBackground.		(Delay forMilliseconds: 20) wait]] newProcess.	p resume.	^ p! !!PreferencesPanel methodsFor: 'initialization' stamp: 'md 2/24/2006 16:04'!findPreferencesMatching: incomingTextOrString	"find all preferences matching incomingTextOrString"	| result aList aPalette controlPage  |	result := incomingTextOrString asString asLowercase.	result := result asLowercase withBlanksTrimmed.	result isEmptyOrNil ifTrue: [^ self].	aList := Preferences allPreferenceObjects select:		[:aPreference | 			(aPreference name includesSubstring: result caseSensitive: false) or:				[aPreference helpString includesSubstring: result caseSensitive: false]].	aPalette := (self containingWindow ifNil: [^ self]) findDeeplyA: TabbedPalette.	aPalette ifNil: [^ self].	aPalette selectTabNamed:  'search results'.	aPalette currentPage ifNil: [^ self].  "bkwd compat"	controlPage := aPalette currentPage.	controlPage removeAllMorphs.	controlPage addMorph: (StringMorph contents: ('Preferences matching "', self searchString, '"') font: Preferences standardButtonFont).	controlPage color: Color transparent.	aList := aList asSortedCollection:		[:a :b | a name < b name].	aList do:		[:aPreference | | button |			button := aPreference representativeButtonWithColor:  Color transparent inPanel: self.			button ifNotNil: [controlPage addMorphBack: button]].	aPalette world startSteppingSubmorphsOf: aPalette! !!ZoomAndScrollControllerMorph methodsFor: 'stepping and presenter' stamp: 'RAA 12/18/2000 14:55'!step	| delta halfDW action |	(self valueOfProperty: #currentCameraVersion ifAbsent: [0]) = 							self currentCameraVersion ifFalse: [		self patchOldVersion1.		self setProperty: #currentCameraVersion toValue: self currentCameraVersion.	].	super step.	self doProgrammedMoves.	(currentKeyDown ifNil: [#()]) do: [ :each |		action := upDownCodes at: each ifAbsent: [#fugeddaboutit].		action == #in ifTrue: [			target scaleImageBy: -10.		].		action == #out ifTrue: [			target scaleImageBy: 10.		].		action == #up ifTrue: [			target tiltImageBy: -20.		].		action == #down ifTrue: [			target tiltImageBy: 20.		].	].	mouseMovePoint ifNil: [^self].	mouseDownPoint ifNil: [^self].	target ifNil: [^self].	halfDW := self deadZoneWidth // 2.	delta := mouseMovePoint - mouseDownPoint.	delta x abs <= halfDW ifTrue: [delta := 0@delta y].	delta y abs <= halfDW ifTrue: [delta := delta x@0].		target panImageBy: delta x.! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:01'!drawPageBackOn: aCanvas	"endForm grows in the given direction, overlaying endForm."	| offset growRect scale |	aCanvas drawImage: startForm at: self position.	offset := self stepFrom: self extent * direction negated to: 0@0.	growRect := (bounds translateBy: offset) intersect: bounds.	scale := growRect extent asFloatPoint / bounds extent.	aCanvas drawImage: (endForm magnify: endForm boundingBox by: scale smoothing: 1)		at: growRect topLeft.	((growRect translateBy: direction) areasOutside: growRect) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!CanvasCharacterScanner methodsFor: 'stop conditions' stamp: 'ls 9/25/1999 16:07'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex:= lastIndex + 1.	^false! !!DSCPostscriptCanvas methodsFor: 'drawing-general' stamp: 'nk 1/2/2004 16:53'!fullDraw: aMorph 	(morphLevel = 0 and: [aMorph pagesHandledAutomatically not]) 		ifTrue: 			[pages := pages + 1.			target				print: '%%Page: 1 1';				cr].	super fullDraw: aMorph.	morphLevel = 0 		ifTrue: 			[ self writeTrailer: pages. ]! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 2/24/2001 13:15'!threadName: aString index: anInteger	threadName := aString.	preferredIndex := anInteger.	self currentIndex.! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 12:49'!computeBounds	| w ratio |	w := pasteUp width.	self printSpecs scaleToFitPage ifTrue: [		^0@0 extent: w@(w * self hOverW) rounded.	].	ratio := 8.5 @ 11.	self printSpecs landscapeFlag ifTrue: [		ratio := ratio transposed	].	^0@0 extent: (ratio * 72) rounded! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'ar 4/10/2005 18:45'!objectForDataStream: refStrm	"I am about to be written on an object file.  It would be bad to write a whole BookMorph out.  Store a string that is the url of the book or page in my inst var."	| clone bookUrl bb stem ind |	(bookMorph isString) & (page isString) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page isString) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page url notNil) ifTrue: [		^ super objectForDataStream: refStrm].	(bookMorph isNil) & (page url isNil) ifTrue: [		self error: 'page should already have a url' translated.		"find page's book, and remember it"		"bookMorph := "].		clone := self clone.	(bookUrl := bookMorph url)		ifNil: [bookUrl := self valueOfProperty: #futureUrl].	bookUrl 		ifNil: [	bb := RectangleMorph new.	"write out a dummy"			bb bounds: bounds.			refStrm replace: self with: bb.			^ bb]		ifNotNil: [clone instVarNamed: 'bookMorph' put: bookUrl].	page url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem := SqueakPage stemUrl: bookUrl.		ind := bookMorph pages identityIndexOf: page.		page reserveUrl: stem,(ind printString),'.sp'].	clone instVarNamed: 'page' put: page url.	refStrm replace: self with: clone.	^ clone! !!FunctionComponent methodsFor: 'model access' stamp: 'di 5/3/1998 22:12'!getText	| ps |	^ ('"type a function of' ,		(String streamContents:			[:s | 2 to: pinSpecs size do:				[:i | ps := pinSpecs at: i.				(i>2 and: [i = pinSpecs size]) ifTrue: [s nextPutAll: ' and'].				s nextPutAll: ' ', ps pinName]]) ,		'"') asText! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 6/1/2001 13:37'!positionAppropriately	| others otherRects overlaps |	(self ownerThatIsA: HandMorph) ifNotNil: [^self].	others := self world submorphs select: [ :each | each ~~ self and: [each isKindOf: self class]].	otherRects := others collect: [ :each | each bounds].	self align: self fullBounds bottomRight with: self world bottomRight.	self setProperty: #previousWorldBounds toValue: self world bounds.	[		overlaps := false.		otherRects do: [ :r |			(r intersects: bounds) ifTrue: [overlaps := true. self bottom: r top].		].		self top < self world top ifTrue: [			self bottom: self world bottom.			self right: self left - 1.		].		overlaps	] whileTrue.! !!FrameRateMorph methodsFor: 'stepping and presenter' stamp: 'sw 10/5/2000 06:52'!step	"Compute and display (every half second or so) the current framerate"	| now mSecs mSecsPerFrame framesPerSec newContents |	framesSinceLastDisplay := framesSinceLastDisplay + 1.	now := Time millisecondClockValue.	mSecs := now - lastDisplayTime.	(mSecs > 500 or: [mSecs < 0 "clock wrap-around"]) ifTrue: 		[mSecsPerFrame := mSecs // framesSinceLastDisplay.		framesPerSec := (framesSinceLastDisplay * 1000) // mSecs.		newContents := mSecsPerFrame printString, ' mSecs (', framesPerSec printString, ' frame', (framesPerSec == 1 ifTrue: [''] ifFalse: ['s']), '/sec)'.		self contents: newContents.		lastDisplayTime := now.		framesSinceLastDisplay := 0]! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:38'!getTiltFactor	^panAndTiltFactor ifNil: [panAndTiltFactor := 0.5].! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:48'!keep: keepButton with: keepSelector evt: evt	"Showing of the corrent palette (viewer or noPalette) is done by the block submitted to the SketchMorphEditor, see (EToyHand makeNewDrawing) and (SketchMorph editDrawingInWorld:forBackground:)."	| ss |	owner ifNil: [^ self].	keepButton ifNotNil: [keepButton state: #off].	(ss := self focusMorph) 		ifNotNil: [ss savePainting: self evt: evt]		ifNil:		[keepSelector == #silent ifTrue: [^ self].		self notCurrentlyPainting].! !!InternalThreadNavigationMorph class methodsFor: 'known threads' stamp: 'sw 3/18/2003 23:12'!openThreadNamed: nameOfThread atIndex: anInteger beKeyboardHandler: aBoolean	"Activate the thread of the given name, from the given index; set it up to be navigated via desktop keys if indicated"	| coll nav |	coll := self knownThreads at: nameOfThread ifAbsent: [^self].	nav := World 		submorphThat: [ :each | (each isKindOf: self) and: [each threadName = nameOfThread]]		ifNone:			[nav := self basicNew.			nav				listOfPages: coll;				threadName: nameOfThread index: anInteger;				initialize;				openInWorld;				positionAppropriately.			aBoolean ifTrue: [ActiveWorld keyboardNavigationHandler: nav].			^ self].	nav		listOfPages: coll;		threadName: nameOfThread index: anInteger;		removeAllMorphs;		addButtons.	aBoolean ifTrue: [ActiveWorld keyboardNavigationHandler: nav]! !!GraphMorph methodsFor: 'commands' stamp: ''!reverse	data := data reversed.	self flushCachedForm.! !!ClockMorph methodsFor: 'initialization' stamp: 'fc 2/8/2004 11:33'!initialize"initialize the state of the receiver"	super initialize.""	showSeconds := true.	show24hr := false.	self step! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/31/1998 11:54'!interpolatedWindowAt: index width: nSamples	"Return an array of N samples starting at the given index in my data."	| scale data baseIndex scaledFrac scaledOneMinusFrac prevSample nextSample v |	scale := 10000.	data := graph data.	index isInteger		ifTrue: [^ (index to: index + nSamples - 1) collect: [:i | data at: i]].	baseIndex := index truncated.	scaledFrac := ((index asFloat - baseIndex) * scale) truncated.	scaledOneMinusFrac := scale - scaledFrac.	prevSample := data at: baseIndex.	^ (baseIndex + 1 to: baseIndex + nSamples) collect: [:i |		nextSample := data at: i.		v := ((nextSample * scaledFrac) + (prevSample * scaledOneMinusFrac)) // scale.		prevSample := nextSample.		v].! !!ZoomAndScrollMorph methodsFor: 'initialization' stamp: 'RAA 11/30/2000 16:45'!createInteriorTransform	| innerPasteUp tm |	innerPasteUp := PasteUpMorph new.	innerPasteUp 		borderWidth: 0;		minHeight: 100;		minWidth: 100;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		position: 0@0;		extent: 100@100.	tm := TransformationB2Morph new.	tm setProperty: #rotationCenter toValue: 0@0.	tm useRegularWarpBlt: usingBalloon not.	self addMorph: tm.	tm addMorph: innerPasteUp.	tm beSticky.	innerPasteUp beSticky.	tm		scale: 1.0;		offset: 0@0.	! !!GraphMorph methodsFor: 'e-toy support' stamp: 'jm 6/17/1999 21:41'!cursor: aNumber	| truncP |	cursor ~= aNumber ifTrue:  [		cursor := aNumber.		truncP := aNumber truncated.		truncP > data size ifTrue: [cursor := data size].		truncP < 0 ifTrue: [cursor := 1].		self keepIndexInView: truncP.		hasChanged := true].! !!MarqueeMorph methodsFor: 'stepping and presenter' stamp: 'RAA 9/25/1999 21:27'!step        count := count + 1.        count > colors size ifTrue: [count := 1].        self borderColor: (colors at: count)! !!SquishedNameMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/11/2000 23:31'!target: aTarget getSelector: symbol1 setSelector: symbol2	target := aTarget.	getSelector := symbol1.	setSelector := symbol2.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph := GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BookPageThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:53'!initialize	"initialize the state of the receiver"	| f |	super initialize.	""	flipOnClick := false.		f := Form extent: 60 @ 80 depth: Display depth.	f fill: f boundingBox fillColor: color.	self form: f! !!BasicButton methodsFor: 'as yet unclassified' stamp: 'sw 12/10/1999 09:08'!setLabel	| newLabel |	newLabel := FillInTheBlank		request:'Enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!StringButtonMorph methodsFor: 'accessing' stamp: ''!arguments: aCollection	arguments := aCollection asArray copy.! !!UpdatingMenuItemMorph methodsFor: '*MorphicExtras-e-toy support' stamp: 'ar 3/17/2001 20:18'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	wordingProvider := wordingProvider adaptedToWorld: aWorld.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 9/29/1998 09:10'!updateLabel	| label |	(label := self findA: StringMorph) ifNil: [^ self].	label contents: (self controllerName: controller), ', ch: ', (channel + 1) printString.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 10/10/2000 16:40'!polyEdit: evt	"Add handles and let user drag'em around"	| poly |	poly := self valueOfProperty: #polygon.	poly ifNil:[^self].	poly addHandles.	self polyEditing: true.	self setProperty: #polyCursor toValue: palette plainCursor.	palette plainCursor: Cursor normal event: evt.! !!TabMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/2/1999 15:55'!convertToReferenceMorph	| aMorph |	aMorph := ReferenceMorph new referent: morphToInstall.	aMorph position: self position.	self become: aMorph.! !!URLMorph methodsFor: 'event handling' stamp: 'ar 4/10/2005 18:54'!mouseUp: evt	| pg ow newPage mm bookUrl bk |	"If url of a book, open it to that page, or bring it in and open to that page."	book ifNotNil: [book == false ifFalse: [		(bookUrl := book) isString ifFalse: [			bookUrl := (SqueakPage stemUrl: url), '.bo'].		(bk := BookMorph isInWorld: self world withUrl: bookUrl) class ~~ Symbol 			ifTrue: [^ bk goToPageUrl: url].		bk == #conflict ifTrue: [			^ self inform: 'This book is already open in some other project'].		(bk := BookMorph new fromURL: bookUrl) ifNil: [^ self].		bk goToPageUrl: url.	"turn to the page"		^ HandMorph attach: bk]].	"If inside a SqueakPage, replace it!!"	pg := self enclosingPage.	pg ifNotNil: [		(ow := pg contentsMorph owner) ifNotNil: [			pg contentsMorph delete.	"from its owner"			newPage := SqueakPageCache atURL: url.			mm := newPage fetchContents.			mm ifNotNil: [ow addMorph: mm.				page := newPage].			^ self]].	"If I am a project, jump  -- not done yet"	"For now, just put new page on the hand"	newPage := SqueakPageCache atURL: url.	mm := newPage fetchInformIfError.	mm ifNotNil: [self primaryHand attachMorph: mm.		page := newPage].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'ar 10/26/2000 00:50'!resumeRecordIn: aWorld	recHand := aWorld activeHand ifNil: [aWorld primaryHand].	recHand newKeyboardFocus: aWorld.	recHand addEventListener: self.	lastEvent := nil.	state := #record.	voiceRecorder ifNotNil:		[voiceRecorder clearRecordedSound.		voiceRecorder resumeRecording.		startSoundEvent := MorphicUnknownEvent new setType: #startSound argument: nil hand: nil stamp: Time millisecondClockValue.		tapeStream nextPut: startSoundEvent].	self synchronize.! !!BookMorph methodsFor: 'accessing' stamp: 'tk 10/22/1998 15:47'!pages: aMorphList	pages := aMorphList asOrderedCollection.	"It is tempting to force the first page to be the current page.  But then, two pages might be shown at once!!  Just trust the copying mechanism and let currentPage be copied correctly. --Ted."! !!InternalThreadNavigationMorph methodsFor: 'initialization' stamp: 'dgd 11/29/2003 17:35'!addButtons	| marginPt i sz data images pageNumber f m b1 b2 dot arrowWidth arrowCenter vertices arrowHeight nameMorph sizeRatio controlsColor |	sizeRatio := self sizeRatio.	controlsColor := Color orange lighter.	self changeNoLayout.	self hResizing: #rigid.	self vResizing: #rigid.	marginPt := (4 @ 4 * sizeRatio) rounded..	i := self currentIndex.	sz := self myThumbnailSize.	arrowWidth := (14 * sizeRatio) rounded.	arrowHeight := (14 * sizeRatio) rounded.	data := {		{i - 1. 'Previous:'. #previousPage. #leftCenter. arrowWidth. 'Prev'}.		{i + 1. 'Next:'. #nextPage. #rightCenter. arrowWidth negated. 'Next'}	}.	images := data collect: [ :tuple |		pageNumber := tuple first.		(pageNumber between: 1 and: listOfPages size) ifTrue: [			f := self 				makeThumbnailForPageNumber: pageNumber 				scaledToSize: sz 				default: tuple sixth.			f := f deepCopy.		"we're going to mess it up"			arrowCenter := f boundingBox perform: tuple fourth.			vertices := {				arrowCenter + (tuple fifth @ arrowHeight negated).				arrowCenter + (tuple fifth @ arrowHeight).				arrowCenter.			}.			f getCanvas				drawPolygon: vertices 				color: controlsColor				borderWidth: 0 				borderColor: Color transparent.			m := ImageMorph new image: f.			m setBalloonText: tuple second translated,' ',(listOfPages at: pageNumber) first.			m addMouseUpActionWith: (				MessageSend receiver: self selector: tuple third			).		] ifFalse: [			f := (Form extent: sz depth: 16) fillColor: Color lightGray.			m := ImageMorph new image: f.		].		m	].	b1 := images first.	b2 := images second.	dot := EllipseMorph new extent: (18@18 * sizeRatio) rounded; color: controlsColor; borderWidth: 0.	self addMorph: (b1 position: self position + marginPt).	self addMorph: (b2 position: b1 topRight + (marginPt x @ 0)).	self extent: (b1 bottomRight max: b2 bottomRight) - self position + marginPt.	self addMorph: dot.	dot align: dot center with: b1 bounds rightCenter + ((marginPt x @ 0) // 2).	dot setBalloonText: threadName,'more commands'.	dot on: #mouseDown send: #moreCommands to: self.	self fullBounds.	self addMorph: (nameMorph := SquishedNameMorph new).	nameMorph		target: self getSelector: #threadName setSelector: nil;		color: Color transparent;		width: self width;		height: (15 * sizeRatio) rounded;		align: nameMorph bottomLeft with: self bottomLeft.! !!StickyPadMorph class methodsFor: 'parts bin' stamp: 'sw 7/5/2004 18:09'!launchPartVia: aSelector label: aString	"Obtain a morph by sending aSelector to self, and attach it to the morphic hand.  This provides a general protocol for parts bins.  Overridden here so that all instances will be given the name, unlike the prevailing convention for other object types"	| aMorph |	aMorph := self perform: aSelector.	aMorph setNameTo: self defaultNameStemForInstances.  "i.e., circumvent uniqueness in this case"	aMorph setProperty: #beFullyVisibleAfterDrop toValue: true.	aMorph openInHand! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/16/2000 00:38'!labelsAbove: aBoolean	labelsAbove := aBoolean.! !!ObjectsTool methodsFor: 'search' stamp: 'nk 9/3/2004 11:20'!newSearchPane	"Answer a type-in pane for searches"	| aTextMorph |	aTextMorph := TextMorph new		setProperty: #defaultContents toValue: ('' asText allBold addAttribute: (TextFontChange font3));		setTextStyle: (TextStyle fontArray: { Preferences standardEToysFont });		setDefaultContentsIfNil;		on: #keyStroke send: #searchPaneCharacter: to: self;		setNameTo: 'SearchPane';		setBalloonText: 'Type here and all entries that match will be shown.' translated;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		margins: 4@6;		backgroundColor: Color white.	^ aTextMorph! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 8/30/2000 15:32'!fullScreenOff	self setProperty: #showingFullScreenMode toValue: false.	ScreenController new fullScreenOff.	self removeProperty: #currentNavigatorVersion.	mouseInside := false.! !!CommandHistory methodsFor: 'called by programmer' stamp: 'ar 8/31/2000 22:47'!promoteToCurrent: aCommand	"Very unusual and speculative and unfinished!!.  Not currently reachable.  For the real thing, we presumably march forward or backward from the current command pointer to the target command in an orderly fashion, doing or undoing each command in turn."	| itsIndex |	Preferences useUndo ifFalse: [^ self].	itsIndex := history indexOf: aCommand ifAbsent: [nil].	itsIndex ifNotNil:		[history remove: aCommand ifAbsent: []].	history add: (lastCommand := aCommand).	itsIndex < history size ifTrue:		[excursions add: (history copyFrom: (itsIndex to: history size))].	history := (history copyFrom: 1 to: itsIndex) copyWith: aCommand.	lastCommand := aCommand.	aCommand doCommand.	lastCommand phase: #done.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:04'!buildThreadOfProjects	| thisPVM projectNames threadName |	projectNames := pages collect: [ :each |		(thisPVM := each findA: ProjectViewMorph) ifNil: [			nil		] ifNotNil: [			{thisPVM project name}.		].	].	projectNames := projectNames reject: [ :each | each isNil].	threadName := FillInTheBlank 		request: 'Please name this thread.' translated 		initialAnswer: (			self valueOfProperty: #nameOfThreadOfProjects ifAbsent: ['Projects on Parade' translated]		).	threadName isEmptyOrNil ifTrue: [^self].	InternalThreadNavigationMorph 		know: projectNames as: threadName;		openThreadNamed: threadName atIndex: nil.! !!RemoteHandMorph methodsFor: 'private' stamp: 'jm 11/4/97 07:15'!receiveData	"Check my connection status and withdraw from the world if the connection has been broken. Append any data that has arrived to receiveBuffer. "	socket ifNotNil: [		socket isConnected			ifTrue: [  "connected"				waitingForConnection ifTrue: [					Transcript show: 'Remote hand ', userInitials, ' connected'; cr.					waitingForConnection := false].				self appendNewDataToReceiveBuffer]			ifFalse: [  "not connected"				waitingForConnection ifFalse: [					"connection was established, then broken"					self withdrawFromWorld.					receiveBuffer := '']]].! !!LedTimerMorph methodsFor: 'stepping and presenter' stamp: 'djp 10/23/1999 21:35'!start	counting := true! !!TextPlusPasteUpMorph methodsFor: 'drawing' stamp: 'RAA 9/18/2000 15:55'!drawOn: aCanvas	| clip rects |	super drawOn: aCanvas.	showPageBreaks == false ifTrue: [^self].	clip := aCanvas clipRect.	rects := self printer pageRectangles.	rects do: [ :each |		each bottom > clip bottom ifTrue: [^self].		aCanvas 			fillRectangle: (self left @ each bottom corner: self right @ each bottom + 1) 			color: Color red	].! !!StringButtonMorph methodsFor: 'menu' stamp: 'dgd 2/22/2003 18:55'!setTarget: evt 	| rootMorphs |	rootMorphs := self world rootMorphsAt: evt hand targetOffset.	target := rootMorphs size > 1		ifTrue: [rootMorphs second]		ifFalse: [nil]! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'sw 5/1/2005 00:13'!deliverPainting: result evt: evt	"Done painting.  May come from resume, or from original call.  Execute user's post painting instructions in the block.  Always use this standard one.  4/21/97 tk"	| newBox newForm ans |	palette ifNotNil: "nil happens" [palette setAction: #paint: evt: evt].	"Get out of odd modes"	"rot := palette getRotations."	"rotate with heading, or turn to and fro"	"palette setRotation: #normal."	result == #cancel ifTrue: [		ans := PopUpMenu withCaption: 'Do you really want to throw away what you just painted?' translated 				chooseFrom: 'throw it away\keep painting it' translated.		^ ans = 1 ifTrue: [self cancelOutOfPainting]				ifFalse: [nil]].	"cancelled out of cancelling."	"hostView rotationStyle: rot."		"rotate with heading, or turn to and fro"	newBox := paintingForm rectangleEnclosingPixelsNotOfColor: Color transparent.	registrationPoint ifNotNil:		[registrationPoint := registrationPoint - newBox origin]. "relative to newForm origin"	newForm := 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [		(self valueOfProperty: #background) == true 			ifFalse: [^ self cancelOutOfPainting]].	newForm fixAlpha. "so alpha channel stays intact for 32bpp"	self delete.	"so won't find me again"	dimForm ifNotNil: [dimForm delete].	newPicBlock value: newForm value: (newBox copy translateBy: bounds origin).	ActiveWorld resumeScriptsPausedByPainting! !!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'ar 3/17/2001 14:30'!buildKeyboard	| wtWid bkWid keyRect octavePt nWhite nBlack |	self removeAllMorphs.	wtWid := 8. bkWid := 5.	self extent: 10@10.	1 to: nOctaves+1 do:		[:i | i <= nOctaves ifTrue: [nWhite := 7.  nBlack := 5]						ifFalse: [nWhite := 1.  nBlack := 0 "High C"].		octavePt := self innerBounds topLeft + ((7*wtWid*(i-1)-1)@-1).		1 to: nWhite do:			[:j | keyRect := octavePt + (j-1*wtWid@0) extent: (wtWid+1)@36.			self addMorph: ((RectangleMorph newBounds: keyRect color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i-1*12 + (#(1 3 5 6 8 10 12) at: j))].		1 to: nBlack do:			[:j | keyRect := octavePt + ((#(6 15 29 38 47) at: j)@1) extent: bkWid@21.			self addMorph: ((Morph newBounds: keyRect color: blackKeyColor)				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i-1*12 + (#(2 4 7 9 11) at: j))]].	self submorphsDo:		[:m | m on: #mouseMove send: #mouseMovePitch:event:noteMorph: to: self;				on: #mouseUp send: #mouseUpPitch:event:noteMorph: to: self;				on: #mouseEnterDragging send: #mouseDownPitch:event:noteMorph: to: self;				on: #mouseLeaveDragging send: #mouseUpPitch:event:noteMorph: to: self].	self extent: (self fullBounds extent + borderWidth - 1)! !!BackgroundMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:43'!initialize	"initialize the state of the receiver"	super initialize.""	offset := 0 @ 0.	delta := 1 @ 0.	running := true! !!DescriptionForPartsBin methodsFor: 'initialization' stamp: 'sw 10/24/2001 16:37'!sampleImageForm: aForm	"Set the sample image form"	sampleImageForm := aForm! !!SimpleButtonMorph methodsFor: '*MorphicExtras-copying' stamp: 'jm 7/28/97 11:52'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments := arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:46'!toggleTruncate	truncate := truncate not.! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 15:27'!fromStream: aStream	| reader |	reader := AnimatedGIFReadWriter formsFromStream: aStream.	^reader forms size = 1		ifTrue: [ ImageMorph new image: reader forms first ]		ifFalse: [ self new fromReader: reader ]! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:30'!erasePrep: evt	"Transparent paint, square brush.  Be careful not to let this be undone by asking palette for brush and color."	| size pfPen myBrush |	pfPen := self get: #paintingFormPen for: evt.	size := (self getNibFor: evt) width.	self set: #brush for: evt to: (myBrush := Form extent: size@size depth: 1).	myBrush offset: (0@0) - (myBrush extent // 2).	myBrush fillWithColor: Color black.	pfPen sourceForm: myBrush.	"transparent"	pfPen combinationRule: Form erase1bitShape.	pfPen color: Color black.! !!Flaps class methodsFor: 'flaps registry' stamp: 'edc 7/20/2009 09:51'!defaultsQuadsDefiningWidgetsFlap	"Answer a structure defining the default Widgets flap.     previously in quadsDefiningWidgetsFlap"	^ #(	(TrashCanMorph			new						'Trash'				'A tool for discarding objects')	"(AllScriptsTool			allScriptsToolForActiveWorld	'AllScripts' 		'A tool that lets you see and control all the runningscripts in your project')"	(PaintInvokingMorph	new						'Paint'				'Drop this into an area to start making a fresh painting there')	(GeeMailMorph			new						'Gee-Mail'			'A place to present annotated content')	(RecordingControlsMorph	authoringPrototype		'Sound'				'A device for making sound recordings.')	"(MPEGMoviePlayerMorph	authoringPrototype		'MoviePlayer'		'A Player for MPEG movies')"	(FrameRateMorph		authoringPrototype			'FrameRate'		'An indicator of how fast your system is running')	(MagnifierMorph		newRound					'Magnifier'			'A magnifying glass')	"(ScriptingSystem		newScriptingSpace			'Scripting'			'A confined place for drawing and scripting, with its ownprivate stop/step/go buttons.')	(ScriptingSystem		holderWithAlphabet			'Alphabet'			'A source for single-letter objects')	(BouncingAtomsMorph	new						'BouncingAtoms'	'Atoms, mate')"	(ObjectsTool				newStandAlone				'ObjectCatalog'		'A tool that lets you browse the catalog of objects')	) asOrderedCollection! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'yo 2/11/2005 09:56'!buttonFor: data 	| b |	b := SimpleButtonMorph new 		target: self;		label: data first asString translated;		actionSelector: data first.	data second ifNotNil: [b width < data second ifTrue: [b width: data second]].	data third ifNotNil: [b setBalloonText: data third translated].	^b! !!PostscriptCharacterScanner methodsFor: 'accessing' stamp: ''!canvas:newCanvas    canvas:=newCanvas.	! !!DropDownChoiceMorph methodsFor: 'accessing' stamp: 'bolot 11/2/1999 12:20'!items	(target notNil and: [getItemsSelector notNil])		ifTrue: [items := target perform: getItemsSelector withArguments: getItemsArgs].	items ifNil: [items := #()].	^items! !!PaintBoxMorph methodsFor: 'actions' stamp: 'ar 9/23/2000 20:00'!takeColor: aColor event: evt	"Accept the given color programmatically"	currentColor := aColor.	self notifyWeakDependentsWith: {#currentColor. evt. currentColor}.	self showColor.	self colorable ifFalse: [self setAction: #paint: evt: evt].	"User now thinking of painting"! !!TextPlusJumpStart methodsFor: 'as yet unclassified' stamp: 'RAA 9/13/2000 12:21'!jumpLabel: aString	jumpLabel := aString! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'di 5/2/2001 10:03'!setScrollDeltas	| range scrollDelta totalRange innerBounds |	totalRange := self totalScrollRange ifNil: [^ self].	range := self leftoverScrollRange.	innerBounds := self innerBounds.	scrollDelta := 10 @ 10.	self hideOrShowScrollBar: xScrollBar		forRange: totalRange x - (innerBounds width - yScrollBar width).	range x <= 0		ifTrue: [xScrollBar scrollDelta: 0.02 pageDelta: 0.2.				xScrollBar interval: 1.0]		ifFalse: [xScrollBar scrollDelta: (scrollDelta x / range x) asFloat						pageDelta: (innerBounds width - scrollDelta x / range x) asFloat.				xScrollBar interval: (innerBounds width - scrollDelta x / totalRange x) asFloat].	self hideOrShowScrollBar: yScrollBar		forRange: totalRange y - (innerBounds height - xScrollBar height).	range y <= 0		ifTrue: [yScrollBar scrollDelta: 0.02 pageDelta: 0.2.				yScrollBar interval: 1.0]		ifFalse: [yScrollBar scrollDelta: (scrollDelta y / range y) asFloat						pageDelta: (innerBounds height - scrollDelta y / range y) asFloat.				yScrollBar interval: (innerBounds height - scrollDelta y / totalRange y) asFloat]! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:13'!redoEnabled	| w |	^(w := self currentWorld) == nil ifTrue:[false] ifFalse:[w commandHistory redoEnabled]! !!IndexTabs methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:29'!highlightColor: aColor	highlightColor := aColor! !!WorldState methodsFor: '*MorphicExtras-update cycle' stamp: 'ar 1/22/2001 14:26'!doOneCycleInBackground	"Do one cycle of the interactive loop. This method is called repeatedly when this world is not the active window but is running in the background."self halt.		"not ready for prime time"	"process user input events, but only for remote hands"	self handsDo: [:h |		(h isKindOf: RemoteHandMorph) ifTrue: [			ActiveHand := h.			h processEvents.			ActiveHand := nil]].	self runStepMethods.	self displayWorldSafely.! !!BookMorph methodsFor: 'initialization' stamp: 'sw 7/4/1998 16:45'!removeEverything	currentPage := nil.	pages := OrderedCollection new.	self removeAllMorphs! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/15/2000 17:43'!stamp: evt	"plop one copy of the user's chosen Form down."	"Check depths"	| pt sForm |	sForm := self get: #stampForm for: evt.	pt := evt cursorPoint - (sForm extent // 2).	sForm displayOn: paintingForm 		at: pt - bounds origin		clippingBox: paintingForm boundingBox		rule: Form paint		fillColor: nil.	self render: (pt extent: sForm extent).! !!PaintBoxMorph methodsFor: 'other' stamp: 'di 10/14/97 10:15'!colorMemory: aMorph	colorMemory := aMorph! !!WireMorph methodsFor: 'as yet unclassified' stamp: 'di 5/2/1998 16:05'!fromPin: pin1 toPin: pin2	pins := Array with: pin1 with: pin2! !!LedMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:36'!initialize"initialize the state of the receiver"	super initialize.""	flashing := false.	flash := false.	self scrollInit.	self digits: 2.	self value: 0! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:02'!setChannel: evt	| menu |	menu := MenuMorph new.	1 to: 16 do: [:chan |		menu add: chan printString			target: self			selector: #channel:			argumentList: (Array with: chan - 1)].	menu popUpEvent: evt in: self world! !!BouncingAtomsMorph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:42'!invalidRect: damageRect from: aMorph	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw := true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds from: self].  "just report once"		damageReported := true.	] ifFalse: [super invalidRect: damageRect from: aMorph].  "ordinary damage report"! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 3/25/2004 15:55'!postscriptFontMappingSummary	"	Transcript nextPutAll: 	PostscriptCanvas postscriptFontMappingSummary	; endEntry	"	| stream |	stream := WriteStream on: (String new: 1000).	TextStyle actualTextStyles keysAndValuesDo: [ :styleName :style |		stream nextPutAll: styleName; cr.		style fontArray do: [ :baseFont | | info |			0 to: 3 do: [ :i | | font |				font := baseFont emphasized: i.				font emphasis = i ifTrue: [					stream tab; nextPutAll: font fontNameWithPointSize; tab.					info := self postscriptFontInfoForFont: font.					stream nextPutAll: info first; space; print: (font pixelSize * info second) rounded.					stream cr.				]			]		]	].	^stream contents! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 12/23/1998 15:53'!toggleBookmark	"Enable or disable sensitivity as a bookmark		enabled means that a normal click will cause a pageFlip		disabled means this morph can be picked up normally by the hand."	flipOnClick := flipOnClick not! !!InternalThreadNavigationMorph methodsFor: 'initialization' stamp: 'dgd 9/19/2003 15:30'!ensureSuitableDefaults	listOfPages ifNil: [		listOfPages := Project allMorphicProjects collect: [ :each | {each name}].		threadName := 'all (default)' translated.		self class know: listOfPages as: threadName.	].	currentIndex ifNil: [currentIndex := 0].! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'mu 8/9/2003 22:40'!defaultTextColor	defaultTextColor ifNil:[defaultTextColor := Color black].	^defaultTextColor! !!ObjectsTool methodsFor: 'categories' stamp: 'nk 8/23/2004 18:18'!tabsForCategories	"Answer a list of buttons which, when hit, will trigger the choice of a category"	| buttonList aButton classes categoryList basic |	classes := Morph withAllSubclasses.	categoryList := Set new.	classes do: [:aClass |		(aClass class includesSelector: #descriptionForPartsBin) ifTrue:			[categoryList addAll: aClass descriptionForPartsBin translatedCategories].		(aClass class includesSelector: #supplementaryPartsDescriptions) ifTrue:			[aClass supplementaryPartsDescriptions do:				[:aDescription | categoryList addAll: aDescription translatedCategories]]].	categoryList := OrderedCollection withAll: (categoryList asSortedArray).		basic := categoryList remove: ' Basic' translated ifAbsent: [ ].	basic ifNotNil: [ categoryList addFirst: basic ].	basic := categoryList remove: 'Basic' translated ifAbsent: [ ].	basic ifNotNil: [ categoryList addFirst: basic ].	buttonList := categoryList collect:		[:catName |			aButton := SimpleButtonMorph new label: catName.			aButton actWhen: #buttonDown.			aButton target: self; actionSelector: #showCategory:fromButton:; arguments: {catName. aButton}].	^ buttonList"ObjectsTool new tabsForCategories"! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 9/21/1998 17:54'!openOn: aWorldMorph label: aString cautionOnClose: aBoolean	"Open a view with the given label on the given WorldMorph."	| aModel |	aModel := aBoolean		ifTrue:		[CautiousModel new]		ifFalse:		[WorldViewModel new].	^ self openOn: aWorldMorph label: aString model: (aModel initialExtent: aWorldMorph initialExtent)! !!TheWorldMenu methodsFor: '*MorphicExtras-windows & flaps menu' stamp: 'sw 4/23/2001 11:24'!flapsMenu	"Build the flaps menu for the world."	| aMenu |	aMenu := UpdatingMenuMorph new updater: self updateSelector: #formulateFlapsMenu:.	self formulateFlapsMenu: aMenu.	^ aMenu! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 01:45'!toss: cancelButton with: cancelSelector evt: evt	"Reject the painting.  Showing noPalette is done by the block submitted to the SketchEditorMorph"	| focus |	owner ifNil: ["it happens"  ^ self].	(focus := self focusMorph) 		ifNotNil: [focus cancelPainting: self evt: evt]		ifNil:			[self delete].	cancelButton state: #off.! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/10/1998 15:08'!zeroCrossingAfter: index	"Find the index of the next negative-to-non-negative transition at or after the current index. The result is the index, i, of a zero crossing such that the sample at i-1 is negative and the sample at i is zero or positive. Answer the index of the last sample if the end of the array is encountered before finding a zero crossing."	| data end i |	data := graph data.	end := data size.	index <= 1 ifTrue: [^ 1].	i := index - 1.	[(i <= end) and: [(data at: i) >= 0]] whileTrue: [i := i + 1].  "find next negative sample"	i >= end ifTrue: [^ end].	i := i + 1.	[(i <= end) and: [(data at: i) < 0]] whileTrue: [i := i + 1].  "find next non-negative sample"	^ i! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/16/2000 17:53'!target: x	target := x.! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'dao 10/1/2004 13:36'!insertNewProjectActionFor: newProj	| me |	me := Project current name.	listOfPages withIndexDo: [ :each :index |		each first = me ifTrue: [			listOfPages add: {newProj name} afterIndex: index.			^self switchToThread: threadName.		].	].	listOfPages add: {newProj name} afterIndex: listOfPages size.	^self switchToThread: threadName		! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'di 2/17/1999 17:44'!caption: butnCaption voiceRecorder: butnRecorder tape: butnTape	caption := butnCaption.	voiceRecorder := butnRecorder.	tape := butnTape! !!ObjectsTool methodsFor: 'alphabetic' stamp: 'nk 9/3/2004 13:47'!installQuads: quads fromButton: aButton	"Install items in the bottom pane that correspond to the given set of quads, as triggered from the given button"	| aPartsBin sortedQuads oldResizing |	aPartsBin := self partsBin.	oldResizing := aPartsBin vResizing.	aPartsBin removeAllMorphs.	sortedQuads := (PartsBin translatedQuads: quads)							asSortedCollection: [:a :b | a third < b third].	aPartsBin listDirection: #leftToRight quadList: sortedQuads.	aButton ifNotNil: [self tabsPane highlightOnlySubmorph: aButton].	aPartsBin vResizing: oldResizing.	aPartsBin layoutChanged; fullBounds.	self isFlap ifFalse: [ self minimizePartsBinSize ].! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/8/2000 12:27'!changeOffsetBy: aPoint	| transform rounder roundPt |	"improve behavior at high magnification by rounding change to whole source pixels"	transform := self myTransformMorph.	rounder := [ :val |		"(val abs + (transform scale * 0.99) roundTo: transform scale) * val sign"		"looks like rounding wasn't a good solution"		val	].	roundPt := (rounder value: aPoint x) @ (rounder value: aPoint y).	self changeOffsetTo: transform offset + roundPt.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'tk 9/3/97 21:11'!showDirType	"Display the proper symbol for this direction type.  rotationStyleis one of #(normal leftRight upDown none)."| rr poly |rr := self rotationStyle.poly := self valueOfProperty: #fwdButton.rr == #normal ifTrue: [^ poly makeBackArrow].rr == #leftRight ifTrue: [	poly makeBothArrows.	^ poly setVertices: (Array with: poly center - (7@0) with:  polycenter + (7@0))].rr == #upDown ifTrue: [	poly makeBothArrows.	^ poly setVertices: (Array with: poly center - (0@7) with:  polycenter + (0@7))].rr == #none ifTrue: [	poly makeNoArrows.	^ poly setVertices: (Array with: poly center - (7@0) with:  polycenter + (7@0)		 with: poly center with: poly center - (0@7) with:  polycenter + (0@7))].! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/16/2000 17:53'!turnToPage: page position: aPoint scale: aNumber transition: aSpec 	| myBook |	target == page ifTrue: [^false].	page ifNil: [^false].	myBook := (self ownerThatIsA: StoryboardBookMorph) ifNil: [^ false].	2 timesRepeat: [		page			cameraPoint: aPoint;			changeScaleTo: aNumber	].	BookMorph turnOffSoundWhile: [		myBook 			goToPageMorph: page 			transitionSpec: aSpec.	].	^true! !!IndexTabs methodsFor: 'selection' stamp: 'sw 7/3/1998 18:43'!selectTab: aTab	| aWorld |	(aWorld := self world) ifNotNil: [aWorld abandonAllHalos].  "nil can happen at init time"	self highlightTab: aTab.! !!GeeBookPageMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/3/2000 11:57'!geeMail: aGeeMail geeMailRectangle: aRectangle	geeMail := aGeeMail.	geeMailRectangle := aRectangle.	self extent: aRectangle extent.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 14:17'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ setValueSelector := nil].	setValueSelector := aSymbolOrString asSymbol.! !!CommandHistory methodsFor: 'command history' stamp: 'ar 8/31/2000 22:45'!nextCommand	"Answer the command object that would be sent the #redoCommand message if the user were to request Redo, or nil if none"	| anIndex |	lastCommand ifNil: [^ nil].	lastCommand phase == #undone ifTrue: [^ lastCommand].	anIndex := history indexOf: lastCommand ifAbsent: [^ nil].	^ anIndex = history size ifTrue: [nil] ifFalse: [history at: (anIndex + 1)]! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 11/11/1998 12:54'!contentsMorph: aPasteUpMorph	contentsMorph := aPasteUpMorph! !!DropDownChoiceMorph class methodsFor: 'class initialization' stamp: 'bolot 11/2/1999 12:19'!initialize	"DropDownChoiceMorph initialize"	| f |	f := Form		extent: 5@9		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)		offset: 0@0.	SubMenuMarker := ColorForm mappingWhiteToTransparentFrom: f.! !!SketchEditorMorph methodsFor: 'morphic' stamp: 'yo 11/17/2002 21:32'!mouseDown: evt	"Start a new stroke.  Check if any palette setting have changed.  6/11/97 20:30 tk"	| cur pfPen myAction |	"verify that we are in a good state"	self verifyState: evt.		"includes prepareToPaint and #scalingOrRotate"	pfPen := self get: #paintingFormPen for: evt.	paintingForm extent = undoBuffer extent ifTrue: [		paintingForm displayOn: undoBuffer at: 0@0 rule: Form over.	] ifFalse: [		undoBuffer := paintingForm deepCopy.	"know we will draw something"	].	pfPen place: (evt cursorPoint - bounds origin).	myAction := self getActionFor: evt.	myAction == #paint: ifTrue:[		palette recentColor: (self getColorFor: evt)].	self set: #strokeOrigin for: evt to: evt cursorPoint.		"origin point for pickup: rect: ellispe: polygon: line: star:.  Always take it."	myAction == #pickup: ifTrue: [		cur := Cursor corner clone.		cur offset: 0@0  "cur offset abs".		evt hand showTemporaryCursor: cur].	myAction == #polygon: ifTrue: [self polyNew: evt].	"a mode lets you drag vertices"	self mouseMove: evt.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 10/12/1998 16:02'!newSliderValue: newValue	"Send a control command out the MIDI port."	| val |	midiPort ifNil: [^ self].	val := newValue asInteger.	lastValue = val ifTrue: [^ self].	lastValue := val.	midiPort midiCmd: 16rB0 channel: channel byte: controller byte: val.! !!PostscriptCanvas methodsFor: 'private' stamp: 'nk 3/25/2004 15:36'!setFont:aFont	| fInfo |	aFont = currentFont ifTrue: [^self].	currentFont := aFont.	self defineFont: aFont.	fInfo := self class postscriptFontInfoForFont: aFont.	target 		selectflippedfont: fInfo first		size: (aFont pixelSize * fInfo second)		ascent: aFont ascent.! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'md 11/14/2003 17:09'!navigator: aThreadNavigator listOfPages: listOfPages	| morphsForPageSorter pixelsAvailable pixelsNeeded scale |	"a bit of fudging to try to outguess the layout mechanism and get best possible scale"	pixelsAvailable := Display extent - 130.	pixelsAvailable := pixelsAvailable x * pixelsAvailable y.	pixelsNeeded := 100@75.	pixelsNeeded := pixelsNeeded x * pixelsNeeded y  * listOfPages size.	scale := (pixelsAvailable / pixelsNeeded min: 1) sqrt.	sizeOfEachMorph := (100@75 * scale) rounded.	morphsForPageSorter := self morphsForMyContentsFrom: listOfPages sizedTo: sizeOfEachMorph.	morphsForPageSorter := morphsForPageSorter reject: [ :each | each isNil].	self changeExtent: Display extent.	self		book: aThreadNavigator 		morphsToSort: morphsForPageSorter.	pageHolder 		cursor: aThreadNavigator currentIndex;		fullBounds;		hResizing: #rigid.! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/29/2000 10:01'!rotateScalePrep: evt	"Make a source that is the paintingForm.  Work from that.  3/26/97 tk"	| newBox myBuff |	(self getActionFor: evt) == #scaleOrRotate ifTrue: [^ self].	"Already doing it"	paintingForm width > 120 		ifTrue: [newBox := paintingForm rectangleEnclosingPixelsNotOfColor: Color transparent.			"minimum size"			newBox := newBox insetBy: 				((18 - newBox width max: 0)//2) @ ((18 - newBox height max: 0)//2) * -1]		ifFalse: [newBox := paintingForm boundingBox].	newBox := newBox expandBy: 1.	self set: #buff for: evt to: (myBuff := Form extent: newBox extent depth: paintingForm depth).	myBuff offset: newBox center - paintingForm center.	myBuff copyBits: newBox from: paintingForm at: 0@0 		clippingBox: myBuff boundingBox rule: Form over fillColor: nil.	"Could just run up owner chain asking colorUsed, but may not be embedded"	cumRot := 0.0.  cumMag := 1.0.	"start over"	self set: #changed for: evt to: true.	self set: #action for: evt to: #scaleOrRotate.		"Only changed by mouseDown with tool in paint area"! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/18/2000 15:38'!setProgrammedMoves: aCollection	programmedMoves := aCollection! !!ListComponent methodsFor: 'model access' stamp: 'ls 5/17/2001 23:07'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	setIndexSelector		ifNil: 	["If model is not hooked up to index, then we won't get					an update, so have to do it locally."				self selectionIndex: anInteger]		ifNotNil: [model perform: setIndexSelector with: anInteger].	selectedItem := anInteger = 0 ifTrue: [nil] ifFalse: [self getListItem: anInteger].	setSelectionSelector ifNotNil:		[model perform: setSelectionSelector with: selectedItem]! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/25/2000 22:11'!writeFileNamed: fileName	| file noVoice delta |	file := FileStream newFileNamed: fileName.	noVoice := true.	tape do:[:evt | evt type = #startSound ifTrue: [noVoice := false]].	noVoice		ifTrue: ["Simple format (reads fast) for no voice"				file nextPutAll:'Event Tape v1 ASCII'; cr.				delta := tape first timeStamp.				tape do: [:evt | file store: (evt copy setTimeStamp: evt timeStamp-delta); cr].				file close]		ifFalse: ["Inclusion of voice events requires general object storage"				file nextPutAll:'Event Tape v1 BINARY'; cr.				file fileOutClass: nil andObject: tape].	saved := true.	^ file name! !!Canvas methodsFor: '*MorphicExtras-drawing' stamp: 'ls 3/19/2000 15:12'!paragraph2: para bounds: bounds color: c	| scanner |	scanner := CanvasCharacterScanner new.	scanner		 canvas: self;		text: para text textStyle: para textStyle;		textColor: c.	para displayOn: self using: scanner at: bounds topLeft.! !!SpeakerMorph methodsFor: 'initialization' stamp: 'nk 6/12/2004 10:05'!addGraphic	| graphic |	graphic := World drawingClass withForm: self speakerGraphic.	graphic position: bounds center - (graphic extent // 2).	self addMorph: graphic.! !!BooklikeMorph methodsFor: 'page controls' stamp: 'tk 2/19/2001 18:34'!makePageControlsFrom: controlSpecs	"From the controlSpecs, create a set of page control and return them -- this method does *not* add the controls to the receiver."	| c col row b lastGuy |	c := (color saturation > 0.1) ifTrue: [color slightlyLighter] ifFalse: [color slightlyDarker].	col := AlignmentMorph newColumn.	col color: c; borderWidth: 0; layoutInset: 0.	col hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	row := AlignmentMorph newRow.	row color: c; borderWidth: 0; layoutInset: 0.	row hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	controlSpecs do: [:spec |		spec == #spacer			ifTrue:				[row addTransparentSpacerOfSize: (10 @ 0)]			ifFalse:				[spec == #variableSpacer					ifTrue:						[row addMorphBack: AlignmentMorph newVariableTransparentSpacer]					ifFalse:						[b := SimpleButtonMorph new target: self; borderWidth: 1; 								borderColor: Color veryLightGray; color: c.						b label: spec first;						actionSelector: spec second;						borderWidth: 0;	 					setBalloonText: spec third.						row addMorphBack: b.						(((lastGuy := spec last asLowercase) includesSubString: 'menu') or:								[lastGuy includesSubString: 'designations'])							ifTrue: [b actWhen: #buttonDown]]]].  "pop up menu on mouseDown"		col addMorphBack: row.	^ col! !!IndexTabs methodsFor: 'layout' stamp: 'sw 1/13/2000 15:18'!fixedWidth: aWidth	fixedWidth := aWidth! !!BookMorph class methodsFor: 'url' stamp: 'sma 4/30/2000 10:36'!grabURL: aURLString	"Create a BookMorph for this url and put it in the hand."	| book |	book := self new fromURL: aURLString.	"If this book is already in, we will steal the pages out of it!!!!!!!!"	book goToPage: 1.	"install it"	HandMorph attach: book! !!TrashCanMorph methodsFor: 'event handling' stamp: 'ar 12/11/2000 12:14'!doubleClick: evt	| palette |	palette := self standardPalette.	((palette notNil and: [palette isInWorld]) and: [palette hasScrapsTab])		ifTrue:			[palette showScrapsTab]		ifFalse:			[self world openScrapsBook: evt].! !!TwoWayScrollPane methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:03'!initialize	"initialize the state of the receiver"	super initialize.	""	self addMorph: (yScrollBar := self createScrollBarNamed: 'yScrollBar');		 addMorph: (xScrollBar := self createScrollBarNamed: 'xScrollBar');		 addMorph: (scroller := self createScroller).	""	self extent: 150 @ 120! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 1/31/98 16:41'!saveToDisk: evt	| newName f |	newName := FillInTheBlank request: 'Please confirm name for save...'						initialAnswer: soundName.	newName isEmpty ifTrue: [^ self].	f := FileStream newFileNamed: newName , '.fmp'.	sound storeOn: f.	f close! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2000 18:31'!scaleImageBy: pixels	| scalePerPixel steps transform factor |	transform := self myTransformMorph.	(steps := (pixels * self getZoomFactor * 0.2) rounded) = 0 ifTrue: [^self].	scalePerPixel := 1.01.	factor := scalePerPixel raisedTo: steps abs.	steps > 0 ifTrue: [		factor := 1.0 / factor.	].	self changeScaleTo: (transform scale * factor min: 10.0 max: 0.1).! !!BOBTransformationMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/4/2001 16:19'!drawSubmorphsOnREAL: aCanvas 	| newClip |	(self innerBounds intersects: aCanvas clipRect) ifFalse: [^self].	newClip := ((self innerBounds intersect: aCanvas clipRect) expandBy: 1) truncated.	useRegularWarpBlt == true ifTrue: [		transform scale asFloat = 1.0 ifFalse: [			newClip := self innerBounds.		"avoids gribblies"		].		^aCanvas 			transformBy: transform			clippingTo: newClip			during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]			]			smoothing: smoothing	].	aCanvas 		transform2By: transform		"#transformBy: for pure WarpBlt"		clippingTo: newClip		during: [:myCanvas |			submorphs reverseDo:[:m | myCanvas fullDrawMorph: m]		]		smoothing: smoothing! !!TextPlusPasteUpMorph methodsFor: 'layout' stamp: 'RAA 4/30/2001 10:13'!acceptDroppingMorph: aMorph event: evt	| allTextPlus |	(aMorph isKindOf: NewHandleMorph) ifTrue: [^self].	(aMorph isKindOf: GeeBookMorph) ifTrue: [^self].	"avoid looping"	(aMorph isKindOf: TextPlusMorph) ifTrue: [		^self addMorphBack: aMorph.	].	self addMorph: aMorph.	allTextPlus := self allTextPlusMorphs.	aMorph allMorphsDo: [ :each | 		allTextPlus do: [ :e2 | e2 removeAlansAnchorFor: each].	].	(self nearestTextPlusMorphTo: aMorph) linkNewlyDroppedMorph: aMorph! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'dgd 8/27/2004 18:35'!doFindButtonMenuEvent: evt	| menu selection |	menu := CustomMenu new.	menu 		add: 'find a project' translated action: [self findAProjectSimple];		add: 'find a project (more places)' translated action: [self findAProject];		add: 'find any file' translated action: [self findAnything];		add: 'search the SuperSwiki' translated action: [self findSomethingOnSuperSwiki].	selection := menu build startUpCenteredWithCaption: 'Find options' translated.	selection ifNil: [^self].	selection value.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/13/2000 14:41'!allJumpEndStrings	| answer |	answer := OrderedCollection new.	text runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			(att isMemberOf: TextPlusJumpEnd) ifTrue: [				(answer includes: att jumpLabel) ifFalse: [answer add: att jumpLabel].			]		]	].	^answer! !!ZASMCameraMarkMorph methodsFor: 'copying' stamp: 'RAA 12/11/2000 15:34'!veryDeepCopyWith: deepCopier	| camera page |	"Keep the same camera???" 	(camera := self cameraController) ifNotNil: [		(deepCopier references includesKey: camera) ifFalse: [			"not recorded, outside our tree, use same camera"			deepCopier references at: camera put: camera]].	(page := self valueOfProperty: #bookPage) ifNotNil: [		(deepCopier references includesKey: page) ifFalse: [			deepCopier references at: page put: page]].	^ super veryDeepCopyWith: deepCopier! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'ar 10/10/2000 16:22'!polygon: evt	| poly |	poly := self valueOfProperty: #polygon.	poly ifNil:[^self].	evt cursorPoint > poly bounds origin ifTrue:[		poly extent: ((evt cursorPoint - poly bounds origin) max: 5@5)].! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossings: aColor	cursorColorAtZeroCrossings := aColor.	self flushCachedForm.! !!EmbeddedWorldBorderMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/13/2000 10:18'!goNormalProjectEntry	| w |	w := self worldIEnclose.	self delete.	w project enter.! !!GraphicalDictionaryMenu class methodsFor: 'example' stamp: 'sd 5/11/2003 20:56'!example2	"GraphicalDictionaryMenu example2"	| aDict |	aDict := Dictionary new.	self openOn: aDict withLabel: 'Testing Zero'! !!IndexTabs methodsFor: 'highlighting' stamp: 'sw 7/2/1998 13:43'!highlightColor: color1 regularColor: color2	"Apply these colors to all of the receiver's tabs"	highlightColor := color1.	regularColor := color2.	self tabMorphs do:		[:m | m highlightColor: color1.  m regularColor: color2]! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/6/2000 13:08'!fractionLeftInMove: thisMove	| steps stepsRemaining fractionLeft endTime startTime |	(thisMove includesKey: #steps) ifTrue: [		steps := thisMove at: #steps ifAbsentPut: [1].		stepsRemaining := thisMove at: #stepsRemaining ifAbsentPut: [steps].		stepsRemaining < 1 ifTrue: [^nil].		stepsRemaining := stepsRemaining - 1.		fractionLeft := stepsRemaining / steps. 		thisMove at: #stepsRemaining put: stepsRemaining.	] ifFalse: [		endTime := thisMove at: #endTime ifAbsent: [^nil].		startTime := thisMove at: #startTime ifAbsent: [^nil].		fractionLeft := (endTime - Time millisecondClockValue) / (endTime - startTime).	].	^fractionLeft max: 0! !!BookMorph class methodsFor: 'url' stamp: 'tk 3/28/2000 13:30'!isInWorld: aWorld withUrl: aUrl	| urls bks short |	"If a book with this url is in the that (current) world, return it.  Say if it is out or in another world."	urls := OrderedCollection new.	bks := OrderedCollection new.	aWorld allMorphsDo: [:aBook | (aBook isKindOf: BookMorph) ifTrue: [			bks add: aBook.			 (urls add: (aBook valueOfProperty: #url)) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]]]]. 	"shortcut"			self withAllSubclassesDo: [:cls |		cls allInstancesDo: [:aBook | 			 (aBook valueOfProperty: #url) = aUrl ifTrue: [				aBook world == aWorld 					ifTrue: [^ aBook]					ifFalse: [						self inform: 'Book may be open in some other project'.						^ aBook]]]].	"if same book name, use it"	short := (aUrl findTokens: '/') last.	urls withIndexDo: [:kk :ind | (kk findTokens: '/') last = short ifTrue: [			^ bks at: ind]].	^ #out! !!ReferenceMorph methodsFor: 'event handling' stamp: 'sw 10/24/2000 14:45'!mouseMove: evt	"The mouse moved while the butten was down in the receiver"	| aForm |	aForm := self imageForm.	(self containsPoint: evt cursorPoint)		ifTrue:			[aForm reverse displayOn: Display]		ifFalse:			[aForm displayOn: Display]! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'mir 11/19/2003 13:40'!stepTime: anInteger	stepTime := anInteger! !!WaveEditor methodsFor: 'menu' stamp: 'dgd 9/19/2003 12:48'!showFFTAtCursor	| data start availableSamples nu n fft r |	data := graph data.	start := graph cursor max: 1.	availableSamples := (data size - start) + 1.	nu := 12.	nu > (availableSamples highBit - 1) ifTrue:		[^ self inform: 'Too few samples after the cursor to take an FFT.' translated].	n := 2 raisedTo: nu.	fft := FFT new nu: nu.	fft realData: ((start to: start + n - 1) collect: [:i | data at: i]).	fft transformForward: true.	r := (1 to: n // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	WaveEditor openOn: r.! !!SketchMorph methodsFor: '*MorphicExtras-testing' stamp: 'RAA 12/4/2000 10:56'!canDrawAtHigherResolution		| pt |	pt := self scalePoint.	^pt x < 1.0 or: [pt y < 1.0]! !!MorphThumbnail methodsFor: 'copying' stamp: 'tk 1/8/1999 09:39'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.morphRepresented := deepCopier references at: morphRepresented 		ifAbsent: [morphRepresented].! !!SketchEditorMorph methodsFor: 'actions & preps' stamp: 'RAA 8/16/2000 11:22'!paint: evt	"While the mouse is down, lay down paint, but only within window bounds.	 11/28/96 sw: no longer stop painting when pen strays out of window; once it comes back in, resume painting rather than waiting for a mouse up"	|  mousePoint startRect endRect startToEnd pfPen myBrush |	pfPen := self get: #paintingFormPen for: evt.	myBrush := self getBrushFor: evt.	mousePoint := evt cursorPoint.	startRect := pfPen location + myBrush offset extent: myBrush extent.	pfPen goto: mousePoint - bounds origin.	endRect := pfPen location + myBrush offset extent: myBrush extent.	"self render: (startRect merge: endRect).	Show the user what happened"	startToEnd := startRect merge: endRect.	self invalidRect: (startToEnd translateBy: bounds origin).! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 7/14/2000 13:08'!addControls	| chooser |	chooser := PopUpChoiceMorph new extent: 110@14;		contentsClipped: 'Editing: ' , envelope name;		target: self;		actionSelector: #chooseFrom:envelopeItem:;		getItemsSelector: #curveChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topLeft with: graphArea bounds bottomLeft + (0@5).	chooser := PopUpChoiceMorph new extent: 130@14;		contentsClipped: 'Timbre: ' , soundName;		target: self;		actionSelector: #chooseFrom:soundItem:;		getItemsSelector: #soundChoices.	chooser arguments: (Array with: chooser).	self addMorph: chooser.	chooser align: chooser bounds topRight with: graphArea bounds bottomRight + (-50@5).! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 8/31/2000 23:13'!undoEnabled	| w |	^(w := self currentWorld) == nil ifTrue:[false] ifFalse:[w commandHistory undoEnabled]! !!TextPlusJumpEnd methodsFor: 'as yet unclassified' stamp: 'RAA 9/13/2000 12:08'!jumpLabel: aString	jumpLabel := aString! !!GraphicalDictionaryMenu methodsFor: 'initialization' stamp: 'sw 12/24/1998 11:59'!baseDictionary: aDictionary	baseDictionary := aDictionary.	entryNames := aDictionary keys asSortedArray.	formChoices := entryNames collect: [:n | aDictionary at: n].	currentIndex := 1! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ar 10/10/2000 16:47'!verifyState: evt	| myAction |	"We are sure we will make a mark now.  Make sure the palette has not changed state while we were away.  If so, end this action and start another one.  6/11/97 19:52 tk  action, currentColor, brush"	"Install the brush, color, (replace mode), and cursor."	palette isInWorld ifFalse:		[self world addMorphFront: palette].  "It happens.  might want to position it also"	myAction := self getActionFor: evt.	(self get: #changed for: evt) == false ifFalse: [		self set: #changed for: evt to: false.		self invalidRect: rotationButton bounds.	"snap these back"		rotationButton position: bounds topCenter - (6@0).		"later adjust by button width?"		self invalidRect: rotationButton bounds.		self invalidRect: scaleButton bounds.		scaleButton position: bounds rightCenter - ((scaleButton width)@6).		self invalidRect: scaleButton bounds.		myAction == #polygon: ifFalse: [self polyFreeze].		"end polygon mode"		^ self set: #action for: evt to: (self prepareToPaint: evt)].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/97 15:57'!noVeneer	"For a palette with a background (off) image, clear that image.But first, for each button, cut that chunk out and save it in the offImagepart."	"	self noVeneer.		AllOffImage := nil.	'save space.  irreversible'.	"	| aa on |	AllOffImage ifNil: [AllOffImage := image].	aa := AllOffImage.	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			on := Form extent: button extent depth: 16.			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in:aa rule: Form over.			button offImage: on]].	self image: (Form extent: AllOffImage extent depth: 1).	self invalidRect: bounds.	! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 11/10/2000 12:10'!jumpToIndex: anInteger	currentIndex := anInteger.	self loadPageWithProgress.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'md 2/15/2006 18:38'!addAlansAnchorFor: aMorph	| ed attribute selRects |	self removeAlansAnchorFor: aMorph.	ed := self editor.	attribute := TextAnchor new anchoredMorph: aMorph.	aMorph setProperty: #geeMailLeftOffset toValue: aMorph left - self left.	ed replaceSelectionWith: (ed selection addAttribute: attribute).	selRects := self paragraph selectionRects.	selRects isEmpty ifFalse: [		aMorph top: selRects first top	].	self releaseParagraphReally.	self layoutChanged.! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 1/11/1999 21:46'!updateFromOriginal	| intermediateForm |	intermediateForm := originalMorph imageForm offset: 0@0.	intermediateForm border: intermediateForm boundingBox		widthRectangle: (borderWidth corner: borderWidth+1)		rule: Form over fillColor: borderColor.	self form: intermediateForm.	originalMorph fullReleaseCachedState! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/2/1998 12:07'!atURL: aURLString	"Answer the page corresponding to this URL. Evaluate the given block if there is no entry for the given URL."	| pg |	^ PageCache at: aURLString ifAbsent: [		pg := SqueakPage new.		"stamp := Utilities authorInitialsPerSe ifNil: ['*']."		"pg author: stamp."		"Need to deal with inst vars if we turn out to be new!!"		"pg url: aURLString. 	done by atURL:put:"		self atURL: aURLString put: pg.		pg]! !!ThumbnailMorph methodsFor: 'what to view' stamp: 'nk 8/29/2004 17:18'!actualViewee	"Return the actual morph to be viewed, or nil if there isn't an appropriate morph to view."	| aMorph actualViewee |	aMorph := self morphToView ifNil: [^ nil]. 	aMorph isInWorld ifFalse: [^ nil].	actualViewee := viewSelector ifNil: [aMorph] ifNotNil: [objectToView perform: viewSelector].	actualViewee == 0 ifTrue: [^ nil].  "valueAtCursor result for an empty HolderMorph"	actualViewee ifNil: [actualViewee := objectToView].	(actualViewee isPlayerLike) ifTrue: [actualViewee := actualViewee costume].	(actualViewee isMorph and: 		[actualViewee isFlexMorph and: [actualViewee submorphs size = 1]])			ifTrue: [actualViewee := actualViewee firstSubmorph].	^ actualViewee! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/15/2000 21:46'!majorTickLength: anInteger 	majorTickLength := anInteger! !!GeeMailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 13:25'!pageRectanglesForPrinting	| pageBreaks prevBottom pageRects r |	pageBreaks := self valueOfProperty: #pageBreakRectangles ifAbsent: [^nil].	prevBottom := 0.	pageRects := pageBreaks collect: [ :each |		r := 0@prevBottom corner: self width @ each top.		prevBottom := each bottom.		r	].	pageRects add: (0@prevBottom corner: self width @ thePasteUp bottom).	^pageRects! !!ThumbnailMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:57'!initialize	"Initialize the receiver, obeying a #nominalExtent property if I  	have one"	| anExtent |	super initialize.	""	anExtent := self				valueOfProperty: #nominalExtent				ifAbsent: [25 @ 25].	self		extent: (anExtent				)! !!BookMorph methodsFor: 'other' stamp: 'RAA 8/23/2000 12:42'!goFullScreen	| floater |	self isInFullScreenMode ifTrue: [^self].	self setProperty: #fullScreenMode toValue: true.	self position: (currentPage topLeft - self topLeft) negated.	self adjustCurrentPageForFullScreen.	floater := self buildFloatingPageControls.	self setProperty: #floatingPageControls toValue: floater.	floater openInWorld.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!controller: anInteger	controller := anInteger.	lastValue := nil.	self updateLabel.! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 15:40'!morphsForMyContentsFrom: listOfPages sizedTo: sz	| morphsForPageSorter |	'Assembling thumbnail images...'		displayProgressAt: self cursorPoint		from: 0 to: listOfPages size		during: [:bar |			morphsForPageSorter := listOfPages withIndexCollect: [ :each :index | 				bar value: index.				self sorterMorphForProjectNamed: each first			].		].	^morphsForPageSorter! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'ar 10/5/2000 18:52'!changeBorderColor: evt	| aHand |	aHand := evt ifNotNil: [evt hand] ifNil: [self primaryHand].	self changeColorTarget: self selector: #borderColor: originalColor: self borderColor hand: aHand.! !!SoundLoopMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/14/97 11:21'!addCursorMorph	self addMorph:		(cursor := (RectangleMorph				newBounds: (self innerBounds topLeft extent: 1@self innerBounds height)				color: Color red)						borderWidth: 0)! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'sw 2/24/2003 15:59'!showMenu	"Show the receiver's menu"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Graphics Library'.	aMenu addStayUpItem.	aMenu addList: #(		('remove'			removeEntry			'Remove this entry from the dictionary')		('rename'			renameEntry			'Rename this entry')		('repaint'			repaintEntry			'Edit the actual graphic for this entry' )		-		('hand me one'		handMeOne				'Hand me a morph with this picture as its form')		('browse symbol references'							browseIconReferences	'Browse methods that refer to this icon''s name')		('browse string references'							browseStringIconReferences'													'Browse methods that refer to string constants that contian this icon''s name)		('copy name'		copyName				'Copy the name of this graphic to the clipboard')		-		('find...'			findEntry				'Find an entry by name')		('find again'		findAgain				'Find the next match for the keyword previously searched for')).	aMenu popUpInWorld! !!FlexMorph methodsFor: 'initialization' stamp: 'di 1/11/1999 21:37'!initialize	super initialize.	borderWidth := 2@2.	borderColor := Color black.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: ''!startInfection	self submorphsDo: [:m | m infected: false].	self firstSubmorph infected: true.	infectionHistory := OrderedCollection new: 500.	transmitInfection := true.	self startStepping.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:38'!getZoomFactor	^zoomFactor ifNil: [zoomFactor := 0.5]! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/15/2000 15:13'!get: aSymbol for: anEventOrHand	| valuesForHand |	valuesForHand := self valuesForHand: anEventOrHand.	^valuesForHand at: aSymbol ifAbsent: [nil].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 11:40'!toggleDescending	descending := self descending not! !!PinMorph methodsFor: 'initialization' stamp: 'di 5/4/1998 09:13'!initialize	super initialize.	wires := OrderedCollection new! !!TextOnCurveContainer methodsFor: 'as yet unclassified' stamp: 'di 12/3/97 09:29'!textSegments: segments	textSegments := segments! !!ThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 6/28/2000 08:29'!deleteCurrentPage	| outerWrapper |	loadedProject ifNil: [^self].	outerWrapper := loadedProject world ownerThatIsA: EmbeddedWorldBorderMorph.	outerWrapper ifNil: [^self].	outerWrapper delete.	loadedProject := nil.! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'yo 6/23/2003 18:09'!defaultTextColor: color	"This defaultTextColor inst var is equivalent to paragraphColor of DisplayScanner."	defaultTextColor := color.! !!BookMorph class methodsFor: 'scripting' stamp: 'sw 6/13/2001 17:13'!previousPageButton	"Answer a button that will take the user to the previous page of its enclosing book"	| aButton |	aButton := SimpleButtonMorph new.	aButton target: aButton; actionSelector: #previousOwnerPage; color: Color yellow; label: '<-'.	aButton setNameTo: 'previous'.	^ aButton! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 9/18/2000 09:33'!printSpecs	^printSpecs ifNil: [printSpecs := PrintSpecifications defaultSpecs].! !!InterimSoundMorph methodsFor: 'as yet unclassified' stamp: 'di 2/17/2000 20:30'!addGraphic	graphic := SketchMorph withForm: self speakerGraphic.	graphic position: bounds center - (graphic extent // 2).	self addMorph: graphic.! !!PrintSpecifications methodsFor: 'as yet unclassified' stamp: 'RAA 2/22/2001 07:35'!initialize	landscapeFlag := false.	scaleToFitPage := false.	drawAsBitmapFlag := false.! !!EmbeddedWorldBorderMorph methodsFor: 'geometry' stamp: 'RAA 6/26/2000 19:10'!extent: aPoint	bounds extent = aPoint ifFalse: [		self changed.		bounds := bounds topLeft extent: aPoint.		self myWorldChanged.	].! !!BookPageSorterMorph methodsFor: 'as yet unclassified' stamp: 'dgd 10/26/2003 13:21'!addControls	| bb r aButton str |	r := AlignmentMorph newRow color: Color transparent; borderWidth: 0; layoutInset: 0.	r wrapCentering: #center; cellPositioning: #topCenter; 			hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (self wrapperFor: (bb label: 'Okay' translated;	actionSelector: #acceptSort)).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (self wrapperFor: (bb label: 'Cancel' translated;	actionSelector: #delete)).	r addTransparentSpacerOfSize: 8 @ 0.	r addMorphBack: (self wrapperFor: (aButton := UpdatingThreePhaseButtonMorph checkBox)).	aButton		target: self;		actionSelector: #togglePartsBinStatus;		arguments: #();		getSelector: #getPartsBinStatus.	str := StringMorph contents: 'Parts bin' translated.	r addMorphBack: (self wrapperFor: str lock).	self addMorphFront: r.! !!ScreeningMorph methodsFor: 'menu' stamp: ''!showScreened	displayMode := #showScreened.	self changed! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setOneCycle	"Set the approximate frequency based on a single cycle specified by the user. To use this, first set the loop end, then place the cursor one full cycle before the loop end and invoke this method."	| len |	len := loopEnd - graph cursor.	len > 0 ifTrue: [		loopCycles := 1.		self loopLength: len].! !!ThumbnailMorph class methodsFor: 'as yet unclassified' stamp: 'sw 5/3/1998 19:12'!recursionReset	"ThumbnailMorph recursionReset"	"Reset the RecursionDepth counter in case the user interruptedduring a thumbnail being drawn.  Do this just once in a while when nodrawOn: is being called.  tk 9/8/97"	RecursionDepth := 0.! !!IndexTabs methodsFor: 'layout' stamp: 'sw 11/30/1998 15:38'!basicWidth	basicWidth ifNil: [basicWidth := owner ifNotNil: [owner width] ifNil: [100]].	^ basicWidth! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:04'!setAtomCount	| countString count |	countString := FillInTheBlank		request: 'Number of atoms?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count := Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!StoryboardBookMorph methodsFor: 'initialization' stamp: 'RAA 12/1/2000 15:22'!initialize	newPagePrototype := ZoomAndScrollMorph new extent: Display extent // 3.	zoomController := ZoomAndScrollControllerMorph new			setBalloonText: 'Drag in here to zoom, tilt and pan the page above'.	super initialize.	self addMorphBack: zoomController.	alansSliders := {		{#changeTiltFactor: . #getTiltFactor . 'Pan and tilt sensitivity'}.		{#changeZoomFactor: . #getZoomFactor . 'Zoom sensitivity'}.	} collect: [ :sData |		{			SimpleSliderMorph new				extent: 150@10;				color: Color orange;				sliderColor: Color gray;				target: self; 				actionSelector: sData first;				setBalloonText: sData third;				adjustToValue: (self perform: sData second).			sData second		}	].	alansSliders do: [ :each | self addMorphBack: each first]! !!GradientFillMorph methodsFor: 'menu' stamp: 'di 11/2/97 14:35'!beVertical	gradientDirection := #vertical.	self changed! !!GraphMorph methodsFor: 'layout' stamp: ''!layoutChanged	super layoutChanged.	cachedForm := nil.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/17/2000 14:59'!pickupForm: stampForm evt: evt	"Install the new picture in this stamp"	| stampButton |	stampHolder stampForm: stampForm for: tool.	stampButton := action == #pickup: 		ifTrue: [stampHolder otherButtonFor: tool]		ifFalse: [tool].	"was a nil stampForm"	stampButton state: #on.	stampButton doButtonAction: evt.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 1/29/98 14:09'!target: anObject	target := anObject! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:02'!setController: evt	| menu |	menu := MenuMorph new.	self controllerList do: [:pair |		menu add: (pair last)			target: self			selector: #controller:			argumentList: (Array with: pair first)].	menu popUpEvent: evt in: self world! !!TextMorph methodsFor: '*MorphicExtras-copying' stamp: 'di 11/11/97 20:45'!updateReferencesUsing: refDict	| anchors range new |	super updateReferencesUsing: refDict.	"Update any anchors in the text of a newly copied morph"	anchors := IdentityDictionary new.	text runs withStartStopAndValueDo:		[:start :stop :attributes |		attributes do: [:att | (att isMemberOf: TextAnchor)							ifTrue: [anchors at: att put: (start to: stop)]]].	anchors isEmpty ifTrue: [^ self].	anchors keysDo:		[:old |  range := anchors at: old.		text removeAttribute: old from: range first to: range last.		new := TextAnchor new anchoredMorph:					(refDict at: old anchoredMorph).		text addAttribute: new from: range first to: range last].	self layoutChanged "for good measure"! !!BouncingAtomsMorph methodsFor: 'drawing' stamp: ''!drawOn: aCanvas	"Clear the damageReported flag when redrawn."	super drawOn: aCanvas.	damageReported := false.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!channel: anInteger	channel := anInteger.	lastValue := nil.	self updateLabel.! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 6/12/2000 08:58'!setPenSize: evt	| menu sizes | 	menu := MenuMorph new.	sizes := (1 to: 5), (6 to: 12 by: 2), (15 to: 40 by: 5).	sizes do: [:w |		menu add: w printString			target: self			selector: #penSize:			argumentList: (Array with: w).		(brushSize // magnification) = w ifTrue: [menu lastSubmorph color: Color red]].	menu popUpEvent: evt in: self world! !!CommandHistory methodsFor: 'called from the ui' stamp: 'nb 6/17/2003 12:25'!undoTo	"Not yet functional, and not yet sent.  Allow the user to choose a point somewhere in the undo/redo tape, and undo his way to there.   Applicable only if infiniteUndo is set. "	| anIndex commandList aMenu reply |	(anIndex := self historyIndexOfLastCommand) == 0 ifTrue: [^ Beeper beep].	commandList := history		copyFrom:	((anIndex - 10) max: 1)		to:			((anIndex + 10) min: history size).	aMenu := SelectionMenu labels:  (commandList collect: [:cmd | cmd cmdWording truncateWithElipsisTo: 20]) selections: commandList.	reply := aMenu startUpWithCaption: 'undo or redo to...'.	reply ifNotNil: [self inform: #deferred]	"ActiveWorld commandHistory undoTo"! !!TabbedPalette methodsFor: 'user-interface' stamp: 'sw 1/19/2001 12:47'!selectTabNamed: aName	"If the receiver has a tab with the given name, select it"	| aTab |	aTab := self tabNamed: aName.	aTab ifNotNil: [self selectTab: aTab]! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 7/14/2000 12:44'!editSoundNamed: name	name = 'new...' ifTrue: [^ self editNewSound].	soundName := name.	self editSound: (AbstractSound soundNamed: soundName) copy! !!WorldWindow methodsFor: 'menu' stamp: 'RAA 11/21/1999 23:05'!buildWindowMenu	| aMenu |	aMenu := super buildWindowMenu.	{640@480. 800@600. 832@624. 1024@768} do: [ :each |		aMenu 			add: each x printString,' x ',each y printString 			target: self 			selector: #extent: 			argument: each + (0@self labelHeight).	].	^aMenu! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnpitched	"Make this instrument be unpitched and unlooped. Suitable for percussive sounds that should not be pitch-shifted when played. By convention, such sounds are played at a pitch of 100.0 to obtain their original pitch."	loopLength := 0.	loopCycles := 0.	perceivedFrequency := 100.0.! !!WorldViewModel methodsFor: 'as yet unclassified' stamp: 'sw 9/21/1998 17:51'!initialExtent: anExtent	initialExtent := anExtent! !!ZASMCameraMarkMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/11/2000 23:26'!setCameraValues	| camera |	camera := self cameraController.	"ick... since one may fail to fully take due to constraints, retry"	2 timesRepeat: [		camera cameraPoint: (self valueOfProperty: #cameraPoint).		camera cameraScale: (self valueOfProperty: #cameraScale).	].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'ar 5/28/2000 12:10'!loadPressedImage: fileName	"Read in and convert the image for the paintBox with the buttonson.  A .bmp 24-bit image.  For each button, cut that chunk out and save it."	"	self loadPressedImage: 'NoSh:=on.bmp'.		AllPressedImage := nil.	'save space'.	"	| pic16Bit blt aa on type |	type := 'gif'.  "   gif or bmp  "type = 'gif' ifTrue: [	pic16Bit "really 8" := GIFReadWriter formFromFileNamed: fileName.	pic16Bit display.	aa := AllPressedImage := Form extent: OriginalBounds extent depth: 8.	blt := BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	].type = 'bmp' ifTrue: [	pic16Bit := (Form fromBMPFileNamed: fileName) asFormOfDepth: 16.	pic16Bit display.	aa := AllPressedImage := Form extent: OriginalBounds extent depth: 16.	blt := BitBlt current toForm: aa.	blt sourceForm: pic16Bit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.	aa mapColor: Color transparent to: Color black.	].	"Collect all the images for the buttons in the on state"	self allMorphsDo: [:button |		(button isKindOf: ThreePhaseButtonMorph) ifTrue: [			type = 'gif' ifTrue: [on := ColorForm extent: button extent depth: 8.					 on colors: pic16Bit colors]				ifFalse: [on := Form extent: button extent depth: 16].			on copy: (0@0 extent: button extent)				from: (button topLeft - self topLeft) in: aa rule: Form over.			button pressedImage: on]].	self invalidRect: bounds.	! !!URLMorph methodsFor: 'accessing' stamp: 'tk 2/17/1999 12:38'!book: aUrl	"A notation about what book this page is in.  true means page is in same book as url strm says.  Set to the url of the Book if the book has a different stem url.  nil or false if not for a book page at all."	book := aUrl! !!ReferenceMorph methodsFor: 'menu' stamp: 'sma 6/18/2000 10:36'!changeTabText	| reply |	reply := FillInTheBlank		request: 'new wording for this tab:'		initialAnswer: submorphs first contents.	reply isEmptyOrNil ifFalse: [submorphs first contents: reply]! !!PinMorph methodsFor: 'initialization' stamp: 'di 5/4/1998 09:13'!component: aComponent pinSpec: spec	component := aComponent.	pinSpec := spec.	pinSpec isInput ifTrue: [pinForm := InputPinForm].	pinSpec isOutput ifTrue: [pinForm := OutputPinForm].	pinSpec isInputOutput ifTrue: [pinForm := IoPinForm].	self image: pinForm! !!WaveEditor methodsFor: 'initialization' stamp: 'dgd 9/19/2003 12:23'!addLoopPointControls	| r m |	r := AlignmentMorph newRow.	r color: self color; borderWidth: 0; layoutInset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; wrapCentering: #center; cellPositioning: #leftCenter.	m := StringMorph new contents: 'Loop end: ' translated.	r addMorphBack: m.	m := UpdatingStringMorph new		target: self; getSelector: #loopEnd; putSelector: #loopEnd:;		growable: false; width: 50; step.	r addMorphBack: m.	m := StringMorph new contents: 'Loop length: ' translated.	r addMorphBack: m.	m := UpdatingStringMorph new		target: self; getSelector: #loopLength; putSelector: #loopLength:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m := StringMorph new contents: 'Loop cycles: ' translated.	r addMorphBack: m.	m := UpdatingStringMorph new		target: self; getSelector: #loopCycles; putSelector: #loopCycles:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m := StringMorph new contents: 'Frequency: ' translated.	r addMorphBack: m.	m := UpdatingStringMorph new		target: self; getSelector: #perceivedFrequency; putSelector: #perceivedFrequency:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	self addMorphBack: r.! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'RAA 2/24/2001 13:15'!threadOfAllProjects	| nameList nav |	nameList := Project allMorphicProjects collect: [ :each | {each name}].	nav := self class basicNew.	nav		listOfPages: nameList;		threadName: '' index: nil;		initialize.	nav editThisThread.! !!MorphWorldView class methodsFor: 'instance creation' stamp: ''!fullColorWhenInactive	FullColorWhenInactive ifNil: [FullColorWhenInactive := true].	^ FullColorWhenInactive! !!ImageMorph methodsFor: '*MorphicExtras-*morphic-Postscript Canvases' stamp: 'RAA 4/20/2001 12:11'!drawPostscriptOn: aCanvas	| top f2 c2 clrs |	clrs := image colorsUsed.	(clrs includes: Color transparent) 		ifFalse: [^super drawPostscriptOn: aCanvas].		"no need for this, then"	top := aCanvas topLevelMorph.	f2 := Form extent: self extent depth: image depth.	c2 := f2 getCanvas.	c2 fillColor: Color white.	c2 translateBy: bounds origin negated clippingTo: f2 boundingBox during: [ :c |		top fullDrawOn: c	].	aCanvas paintImage: f2 at: bounds origin! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 3/9/98 13:17'!normalize	"Correspondence between buttons and stamp forms has changed.  Make all thumbnails show up right."	| shrunkForm button trans |	1 to: stampButtons size do: [:ind |		shrunkForm := thumbnailPics atWrap: ind+start-1.		button := stampButtons at: ind.		shrunkForm 			ifNil: [trans := Form extent: button extent depth: 8.				trans fill: trans boundingBox fillColor: Color transparent.				button onImage: trans]			ifNotNil: [button onImage: shrunkForm].		button offImage: shrunkForm; pressedImage: shrunkForm.	"later modify them"		].! !!FlexMorph methodsFor: 'accessing' stamp: 'di 1/11/1999 21:43'!borderWidth: width	borderWidth := width asPoint.	self updateFromOriginal! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'ar 11/9/2000 20:41'!doPrintPreview	| pageDisplay sz newPage subBounds pic align |	sz := (85 @ 110) * 3.	self printSpecs landscapeFlag ifTrue: [		sz := sz transposed	].	pageDisplay := BookMorph new		color: Color paleYellow;		borderWidth: 1.	self allPages withIndexDo: [ :each :index |		pic := ImageMorph new image: (each pageThumbnailOfSize: sz).		align := AlignmentMorph newColumn			addMorph: pic;			borderWidth: 1;			layoutInset: 0;			borderColor: Color blue.		newPage := pageDisplay 			insertPageLabel: 'Page ',index printString			morphs: {align}.		subBounds := newPage boundingBoxOfSubmorphs.		newPage extent: subBounds corner - newPage topLeft + ((subBounds left - newPage left)@0).	].	pageDisplay 		goToPage: 1;		deletePageBasic;		position: Display extent - pageDisplay extent // 2;		openInWorld.! !!ProjectNavigationMorph methodsFor: 'stepping and presenter' stamp: 'sw 1/31/2006 04:06'!undoButtonWording	"Answer the wording for the Undo button."	| wdng |	wdng := ActiveWorld commandHistory undoOrRedoMenuWording.	(wdng endsWith: ' (z)') ifTrue:		[wdng := wdng copyFrom: 1to: wdng size - 4].	^ wdng! !!TabbedPalette methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:08'!initialize	"Initialize the receiver, which was just created via a call to the  	class's #basicNew"	super initialize.	""	pageSize := self defaultPageSize.	self removeEverything.		tabsMorph := IndexTabs new.	self addMorph: tabsMorph! !!ReferenceMorph methodsFor: 'misc' stamp: 'sw 12/21/1998 15:50'!morphToInstall: aMorph	"Create a new tab consisting of a string holding the morph's name"	| aLabel nameToUse |	aLabel := StringMorph new contents: (nameToUse := aMorph externalName).	self addMorph: aLabel.	aLabel lock.	self referent: aMorph.	self setNameTo: nameToUse.	self fitContents.! !!ReferenceMorph methodsFor: 'menu' stamp: 'sw 10/30/2000 11:11'!setLabelFontTo: aFont	"Change the receiver's label font to be as indicated"	| aLabel oldLabel |	aLabel := StringMorph contents:  (oldLabel := self findA: StringMorph) contents font: aFont.	self replaceSubmorph: oldLabel by: aLabel.	aLabel position: self position.	aLabel highlightColor: self highlightColor; regularColor: self regularColor.	aLabel lock.	self fitContents.	self layoutChanged.	(owner isKindOf: IndexTabs) ifTrue:		[self borderWidth: 0.		owner laySubpartsOutInOneRow.		isHighlighted ifTrue:			[self highlight]]! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/16/2000 17:51'!changeScaleTo: aNumber	| transform innerPasteup min1 min2 newScale oldPoint |	transform := self myTransformMorph.	"oldScale := transform scale."	innerPasteup := transform firstSubmorph.	min1 := transform width / innerPasteup width asFloat.	min2 := transform height / innerPasteup height asFloat.	newScale := (aNumber max: min1) max: min2.	oldPoint := self cameraPoint.	transform scale: newScale.	self cameraPoint: oldPoint.	"scaleR := newScale / oldScale.	half := transform extent // 2.	half := 0@0.	self changeOffsetBy: scaleR * (transform offset + half) - half - transform offset.""==Alan's preferred factorspan = 0.0425531914893617zoom = 0.099290780141844==="! !!TransformationB2Morph methodsFor: 'geometry' stamp: 'RAA 11/20/2000 18:17'!extent: aPoint	| newExtent |	newExtent := aPoint truncated.	bounds extent = newExtent ifTrue: [^self].	bounds := bounds topLeft extent: newExtent.	"self recomputeExtent."! !!PartsBin class methodsFor: 'class initialization' stamp: 'sw 7/12/2001 19:07'!initialize	"Initialize the PartsBin class, by starting it out with an empty Thumbnails dictionary"	Thumbnails := Dictionary new	"PartsBin initialize"! !!WaveEditor methodsFor: 'accessing' stamp: 'nk 6/22/2004 16:17'!sound: aSound	| buffer |	buffer := aSound samples mergeStereo.	graph data: buffer.	loopLength := loopEnd := buffer size.	self samplingRate: aSound originalSamplingRate.	loopCycles :=  buffer size / aSound originalSamplingRate * 400.	perceivedFrequency := 400.! !!SketchMorph methodsFor: '*MorphicExtras-*morphic-Postscript Canvases' stamp: 'RAA 9/22/2000 15:14'!drawPostscriptOn: aCanvas	| top f2 c2 tfx clrs |	tfx := self transformFrom: self world.	tfx angle = 0.0 ifFalse: [^super drawPostscriptOn: aCanvas].	"can't do rotated yet"	clrs := self rotatedForm colorsUsed.	(clrs includes: Color transparent) 		ifFalse: [^super drawPostscriptOn: aCanvas].		"no need for this, then""Smalltalk at: #Q put: OrderedCollection new""Q add: {self. tfx. clrs}.""(self hasProperty: #BOB) ifTrue: [self halt]."	top := aCanvas topLevelMorph.	f2 := Form extent: self extent depth: self rotatedForm depth.	c2 := f2 getCanvas.	c2 fillColor: Color white.	c2 translateBy: bounds origin negated clippingTo: f2 boundingBox during: [ :c |		top fullDrawOn: c	].	aCanvas paintImage: f2 at: bounds origin! !!ReferenceMorph methodsFor: 'menu' stamp: 'di 2/17/2000 20:32'!graphicalMorphForTab	| formToUse |	formToUse := self valueOfProperty: #priorGraphic ifAbsent: [ScriptingSystem formAtKey: 'squeakyMouse'].	^ SketchMorph withForm: formToUse! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:15'!getTiltFactor	^panAndTiltFactor ifNil: [panAndTiltFactor := 0.5].	! !!WiWPasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'RAA 11/20/1999 08:05'!say: x	(Debug ifNil: [Debug := OrderedCollection new])		add: x asString,''.	Debug size > 500 ifTrue: [Debug := Debug copyFrom: 200 to: Debug size]! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'wiz 1/1/2007 20:21'!step	| d |	images isEmpty ifTrue: [^ self].			nextTime > Time millisecondClockValue		ifTrue: [^self].	self changed .	self image: (images at:	(imageIndex := imageIndex \\ images size + 1)).	self changed . 	d := (delays at: imageIndex) ifNil: [0].	nextTime := Time millisecondClockValue + d! !!DSCPostscriptCanvasToDisk class methodsFor: 'as yet unclassified' stamp: 'nk 12/30/2003 16:58'!morphAsPostscript: aMorph rotated: rotateFlag offsetBy: offset specs: specsOrNil	| newFileName stream |	^[		(self new morphAsPostscript: aMorph rotated: rotateFlag offsetBy: offset) close	]		on: PickAFileToWriteNotification		do: [ :ex |			newFileName := FillInTheBlank				request: 'Name of file to write:' translated				initialAnswer: 'xxx',Time millisecondClockValue printString, self defaultExtension. 			newFileName isEmptyOrNil ifFalse: [				stream := FileStream fileNamed: newFileName.				stream ifNotNil: [ex resume: stream].			].		].! !!LedDigitMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:34'!initialize	"initialize the state of the receiver"	super initialize.	""	highlighted := false.	digit := 0 ! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:38'!playTestNote	| data end snd loopDur dur |	(loopEnd = 0 or: [loopLength = 0]) ifTrue: [^ self].	data := graph data.	end := (loopEnd min: data size) max: 1.	snd := LoopedSampledSound new		samples: data loopEnd: end loopLength: loopLength		pitch: 100.0 samplingRate: samplingRate.	loopDur := (4.0 * loopLength / samplingRate) max: 2.0.  "longer of 4 loops or 2 seconds"	dur := (data size / samplingRate) + loopDur.	(snd		addReleaseEnvelope;		setPitch: 100.0 dur: dur loudness: 0.5) play.! !!EmbeddedWorldBorderMorph methodsFor: 'layout' stamp: 'RAA 6/26/2000 18:45'!minHeight: anInteger	minHeight := anInteger! !!SketchEditorMorph methodsFor: 'event handling' stamp: 'ar 12/19/2000 00:20'!mouseUp: evt	| myAction |	"Do nothing except those that work on mouseUp."	myAction := self getActionFor: evt.	myAction == #fill: ifTrue: [		self perform: myAction with: evt.		"Each action must do invalidRect:"		].	myAction == #pickup: ifTrue: [		self pickupMouseUp: evt].	myAction == #polygon: ifTrue: [self polyEdit: evt].	"a mode lets you drag vertices"	self set: #lastEvent for: evt to: nil.! !!ProjectNavigationMorph methodsFor: 'event handling' stamp: 'RAA 9/1/2000 07:51'!mouseLeave: evt	self world ifNil: [^self].		"can happen after delete from control menu"	(self worldBounds containsPoint: evt cursorPoint) ifFalse: [^self].	mouseInside := false.	self positionVertically.! !!MorphThumbnail methodsFor: 'copying' stamp: 'tk 1/8/1999 09:39'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.morphRepresented := morphRepresented.		"Weakly copied"! !!IndexTabs methodsFor: 'layout' stamp: 'sw 1/19/2000 13:57'!laySubpartsOutInOneRow	| aPosition neededHeight widthToUse mid |	fixedWidth ifNotNil: [self error: 'incompatibility in IndexTabs'].	verticalPadding ifNil: [verticalPadding := 4].  "for benefit of old structures"	aPosition := self topLeft.	neededHeight := self basicHeight.	submorphs do:		[:aMorph |			aMorph position: (aPosition + (padding @ 0)).			aPosition := aMorph topRight.			neededHeight := neededHeight max: aMorph height].	neededHeight := neededHeight + (verticalPadding * 2).	mid := self top + (neededHeight // 2).	submorphs do:		[:aMorph |			aMorph top: (mid - (aMorph height // 2))].	widthToUse := self widthImposedByOwner max: self requiredWidth.	self extent: (((aPosition x + padding - self left) max: widthToUse) @ neededHeight)! !!BooklikeMorph class methodsFor: 'class initialization' stamp: 'sw 7/4/1998 15:59'!initialize	"BooklikeMorph initialize"	PageFlipSoundOn := true! !!SketchEditorMorph methodsFor: 'Nebraska support' stamp: 'RAA 8/16/2000 13:40'!getCursorFor: anEventOrHand	| plainCursor |	plainCursor := (self get: #currentCursor for: anEventOrHand) ifNil: [		self set: #currentCursor for: anEventOrHand to: palette plainCursor	].	^palette		cursorFor: (self getActionFor: anEventOrHand) 		oldCursor: plainCursor 		currentNib: (self getNibFor: anEventOrHand) 		color: (self getColorFor: anEventOrHand)! !!RemoteHandMorph methodsFor: 'initialization' stamp: 'ar 10/24/2000 14:38'!initialize	super initialize.	remoteWorldExtent := 100@100.  "initial guess"	socket := nil.	waitingForConnection := false.	receiveBuffer := ''.	sendState := #unconnected.! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'dao 10/1/2004 13:36'!jumpWithinThread	| aMenu me weHaveOthers myIndex |	me := Project current name.	aMenu := MenuMorph new defaultTarget: self.	weHaveOthers := false.	myIndex := self currentIndex.	listOfPages withIndexDo: [ :each :index |		index = myIndex ifTrue: [			aMenu add: 'you are here' translated action: #yourself.			aMenu lastSubmorph color: Color red.		] ifFalse: [			weHaveOthers := true.			aMenu add: ('jump to <{1}>' translated format:{each first}) selector: #jumpToIndex: argument: index.			myIndex = (index - 1) ifTrue: [				aMenu lastSubmorph color: Color blue			].			myIndex = (index + 1) ifTrue: [				aMenu lastSubmorph color: Color orange			].		].	].	weHaveOthers ifFalse: [^self inform: 'This is the only project in this thread' translated].	aMenu popUpEvent: self world primaryHand lastEvent in: self world! !!TwoWayScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 6/12/2000 09:01'!yellowButtonActivity: shiftKeyState	| menu |	(menu := self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu popUpEvent: self activeHand lastEvent in: self world]! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'jm 7/28/97 11:54'!updateReferencesUsing: aDictionary	"Fix up the Morphs I own"	"Note: Update this method when adding new inst vars that could contain Morphs."	stampButtons := stampButtons collect:		[:old | aDictionary at: old ifAbsent: [old]].	pickupButtons := pickupButtons collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!WaveEditor methodsFor: 'menu' stamp: 'dgd 10/8/2003 20:12'!chooseLoopStart 	| bestLoops menu secs choice start |	possibleLoopStarts ifNil: [		Utilities			informUser: 'Finding possible loop points...' translated			during: [possibleLoopStarts := self findPossibleLoopStartsFrom: graph cursor]].	bestLoops := possibleLoopStarts copyFrom: 1 to: (100 min: possibleLoopStarts size).	menu := CustomMenu new.	bestLoops do: [:entry |		secs := ((loopEnd - entry first) asFloat / self samplingRate) roundTo: 0.01.		menu add: ('{1} cycles; {2} secs' translated format:{entry third. secs}) action: entry].	choice := menu startUp.	choice ifNil: [^ self].	loopCycles := choice third.	start := self fractionalLoopStartAt: choice first.	self loopLength: (loopEnd asFloat - start) + 1.0.! !!ZoomAndScrollControllerMorph methodsFor: 'event handling' stamp: 'RAA 12/1/2000 15:23'!mouseMove: evt	mouseMovePoint := evt cursorPoint.! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/15/2000 21:42'!caption: aString	caption := aString.! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/2/97 14:37'!scroll: amt	"Move the stamps over"	start := start - 1 + amt \\ stamps size + 1.	self normalize.	"show them"! !!ZoomAndScrollControllerMorph methodsFor: 'event handling' stamp: 'di 11/30/2001 10:54'!mouseLeave: evt	currentKeyDown := Set new.	hasFocus := false.	mouseMovePoint := mouseDownPoint := nil.! !!ClockMorph methodsFor: 'stepping and presenter' stamp: 'fc 2/8/2004 11:40'!step	| time |	super step.	time := String streamContents:		[:aStrm | Time now print24: (show24hr == true) showSeconds: (showSeconds == true) on: aStrm].	self contents: time			! !!GeeMailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/30/2000 15:06'!adjustPasteUpSize	| newBottom |	thePasteUp ifNil: [^self].	newBottom := thePasteUp bottom max: thePasteUp boundingBoxOfSubmorphs bottom + 20.	thePasteUp height: (newBottom - thePasteUp top max: self height).	thePasteUp width: (thePasteUp width max: scroller innerBounds width - 5).! !!GraphMorph methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:46'!convertToCurrentVersion: varDict refStream: smartRefStrm		hasChanged ifNil: [hasChanged := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:32'!perceivedFrequency: aNumber	perceivedFrequency := aNumber.	(loopCycles > 0) ifTrue: [		loopLength := samplingRate asFloat * loopCycles / perceivedFrequency].! !!GeePrinterPage methodsFor: 'as yet unclassified' stamp: 'RAA 9/17/2000 16:51'!totalPages: x	totalPages := x! !!SpeakerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:51'!initialize"initialize the state of the receiver"	super initialize.""	self addGraphic.	bufferSize := 5000.	buffer := WriteStream				on: (SoundBuffer newMonoSampleCount: bufferSize).	lastConePosition := 0.	sound := SequentialSound new! !!MultiResolutionCanvas methodsFor: 'drawing-general' stamp: 'RAA 12/4/2000 12:00'!fullDraw: aMorph	aMorph canDrawAtHigherResolution ifTrue: [		deferredMorphs ifNil: [deferredMorphs := OrderedCollection new].		deferredMorphs add: aMorph.	] ifFalse: [		super fullDraw: aMorph	].! !!DropDownChoiceMorph methodsFor: 'copying' stamp: 'bolot 11/2/1999 12:17'!veryDeepInner: deepCopier	super veryDeepInner: deepCopier.	items := items veryDeepCopyWith: deepCopier.	border := border veryDeepCopyWith: deepCopier! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/6/2000 17:19'!setMaxVal: newMaxVal	maxVal := newMaxVal asNumber.	minVal := maxVal min: minVal! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sma 6/12/2000 14:18'!openWorldWith: aMorph labelled: labelString	| w |	(w := MVCWiWPasteUpMorph newWorldForProject: nil) addMorph: aMorph.	w extent: aMorph fullBounds extent.	w startSteppingSubmorphsOf: aMorph.	self openOn: w		label: labelString		extent: w fullBounds extent + 2.! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'ar 10/25/2000 21:42'!addJournalFile	"In case there is a chance of not regaining control to stop recording and save a file, the EventRecorder can write directly to file as it is recording.  This is useful for capturing a sequence that results in a nasty crash."	journalFile ifNotNil: [journalFile close].	journalFile := FileStream newFileNamed: 'EventRecorder.tape'.	journalFile nextPutAll:'Event Tape v1 ASCII'; cr.! !!BOBTransformationMorph methodsFor: 'private' stamp: 'RAA 6/10/2000 14:22'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| |		"oldRefPos := self referencePosition."	changeBlock value.	self chooseSmoothing.		"self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)]."	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!EventRecorderMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:21'!initialize	"initialize the state of the receiver"	super initialize.	""	saved := true.	self listDirection: #topToBottom;		 wrapCentering: #center;		 cellPositioning: #topCenter;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 2;		 minCellSize: 4;		 addButtons! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 12/2/1998 17:53'!addTabForBook: aBook	|  aTab |	aTab := ReferenceMorph forMorph: aBook.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab unHighlight.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!LedMorph methodsFor: 'accessing' stamp: 'tk 4/19/2001 16:55'!stringToLed	| i k actualString |	i := scroller ifNil: [1].	k := 1.	actualString := String new: chars.	actualString do: 		[:m | 		i > string size ifFalse: [actualString at: k put: (string at: i) asUppercase asCharacter].		i := i + 1.		k := k + 1].	i := 1.	submorphs do: 		[:m | 		m char: (actualString at: i).		i := i + 1].	self changed! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 2/4/2001 15:55'!insertNewProject: evt	| newProj |	[newProj := Project newMorphicOn: nil.]		on: ProjectViewOpenNotification		do: [ :ex | ex resume: false].		EToyProjectDetailsMorph 		getFullInfoFor: newProj		ifValid: [			evt hand attachMorph: (self sorterMorphForProjectNamed: newProj name)		]		expandedFormat: false.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'JMV 1/9/2001 13:43'!editSound: aSound	| p |	(aSound respondsTo: #envelopes)		ifFalse: [			PopUpMenu inform: 'You selected a ', aSound class name, '.', String cr,				'I can''t handle these kinds of sounds.'.			^self ].	sound := aSound.	sound envelopes isEmpty ifTrue: [		"provide a default volume envelope"		p := OrderedCollection new.		p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.		sound addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3)].	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound.! !!ScreeningMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 13:42'!passingColor: aColor	passingColor := aColor.! !!StoryboardBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:37'!changeTiltFactor: x	currentPage changeTiltFactor: x.	panAndTiltFactor := x.! !!TextOnCurve methodsFor: 'selection' stamp: 'ar 5/18/2000 18:33'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| sourcePoint cb curvePoint |	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		(destRect containsPoint: aPoint) ifTrue:			["It's in the destRect; now convert to source coords"			sourcePoint := self pointInLine: line forDestPoint: aPoint							segStart: segStart segAngle: segAngle.			cb := (CharacterBlockScanner new text: text textStyle: textStyle)				characterBlockAtPoint: (sourcePoint adhereTo: line rectangle)				index: nil in: line.			(sourcePoint x between: line left and: line right) ifTrue:				["Definitely in this segment"				^ cb]]].	"Point is off curve -- try again with closest point on curve"	curvePoint := curve closestPointTo: aPoint.	curvePoint = aPoint ifFalse:		[^ self characterBlockAtPoint: curvePoint].	"If all else fails, at least return something acceptable."	^ cb ifNil: [self defaultCharacterBlock]! !!BookMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:09'!initialize"initialize the state of the receiver"	super initialize.""	self setInitialState.	pages := OrderedCollection new.	self showPageControls.	self class		turnOffSoundWhile: [self insertPage]! !!TheWorldMenu methodsFor: '*MorphicExtras-mechanics' stamp: 'RAA 6/15/2000 10:16'!adaptToWorld: aWorld        myWorld := aWorld.        myProject := nil.                "figure it out if and when needed. maybe make it easier to find"        myHand := aWorld primaryHand.! !!StringButtonMorph methodsFor: 'event handling' stamp: ''!mouseDown: evt	oldColor := color.	actWhen == #buttonDown		ifTrue: [self doButtonAction].! !!StringButtonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:44'!initialize	"initialize the state of the receiver"	super initialize.	""	target := nil.	actionSelector := #flash.	arguments := EmptyArray.	actWhen := #buttonUp.	self contents: 'Flash' ! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/13/2000 12:28'!chooseOneJumpEnd	| menu |	menu := CustomMenu new.	self allJumpEndStrings do: [ :each |		menu 			add: each 			action: each	].	^menu build startUpCenteredWithCaption: 'Possible jump ends'.	! !!EventRecorderMorph methodsFor: 'commands' stamp: 'yo 2/11/2005 09:59'!button	"Make a simple button interface for replay only"	| butnCaption erm |	butnCaption := FillInTheBlank request: 'Caption for this butn?' translated initialAnswer: 'play' translated.	butnCaption isEmpty ifTrue: [^ self].	erm := (EventRecorderMorph basicNew				caption: butnCaption				voiceRecorder: voiceRecorder copy				tape: tape) initialize.	self world primaryHand attachMorph: erm! !!BookMorph methodsFor: 'scripting' stamp: 'tk 9/7/2000 15:10'!chooseAndRevertToVersion	| time which |	"Let the user choose an older version for all code in MethodMorphs in this book.  Run through that code and revert each one to that time."	self methodHolders.	"find them in me"	self methodHolderVersions.	which := PopUpMenu withCaption: 					'Put all scripts in this book back the way they were at this time:' 				chooseFrom: #('leave as is'), VersionNames.	which <= 1 ifTrue: [^ self].	time := VersionTimes at: which-1.	self revertToCheckpoint: time.! !!ScreeningMorph methodsFor: 'layout' stamp: 'panda 4/25/2000 15:43'!layoutChanged	screenForm := nil.	submorphs size >= 2		ifTrue: [self disableDragNDrop]		ifFalse: [self enableDragNDrop].	submorphs size = 2 ifTrue:		[bounds := ((self sourceMorph bounds merge: self screenMorph bounds) expandBy: 4)].	^ super layoutChanged! !!BookMorph methodsFor: 'insert and delete' stamp: 'ar 11/9/2000 21:10'!insertPageLabel: labelString morphs: morphList	| m c labelAllowance |	self insertPage.	labelString ifNotNil:			[m := (TextMorph new extent: currentPage width@20; contents: labelString).		m lock.		m position: currentPage position + (((currentPage width - m width) // 2) @ 5).		currentPage addMorph: m.		labelAllowance := 40]		ifNil:			[labelAllowance := 0].	"use a column to align the given morphs, then add them to the page"	c := AlignmentMorph newColumn wrapCentering: #center; cellPositioning: #topCenter.	c addAllMorphs: morphList.	c position: currentPage position + (0 @ labelAllowance).	currentPage addAllMorphs: morphList.	^ currentPage! !!StringButtonMorph methodsFor: 'menu' stamp: 'yo 3/16/2005 20:54'!setActionSelector	| newSel |	newSel := FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed' translated		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!LedCharacterMorph methodsFor: 'drawing' stamp: 'kfr 6/3/2000 21:29'!drawOn: aCanvas 	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset bOrigin i |	i := 0.	foregroundColor := highlighted				ifTrue: [Color white]				ifFalse: [color].	backgroundColor := color darker darker darker.	hThickness := self height * 0.1.	vThickness := self width * 0.1.	thickness := hThickness min: vThickness.	vOffset := hThickness - thickness // 2 max: 0.	hOffset := vThickness - thickness // 2 max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	CHSegmentOrigins with: (CHSegments at: char + 1)		do: [:o :isLit | aCanvas fillRectangle: (Rectangle origin: (self position + (0 @ vOffset) + (o * self extent)) rounded extent: (self width * 0.6 @ thickness) rounded)				color: (isLit						ifTrue: [foregroundColor]						ifFalse: [backgroundColor])].	CVSegmentOrigins with: (CVSegments at: char + 1)		do: [:o :isLit | aCanvas fillRectangle: (Rectangle origin: (self position + (hOffset @ 0) + (o * self extent)) rounded extent: (thickness @ (self height * 0.25)) rounded)				color: (isLit						ifTrue: [foregroundColor]						ifFalse: [backgroundColor])].	TSegments with: (DSegments at: char + 1)		do: 			[:tOrigin :isLit | 			i := i + 1.			bOrigin := BSegments at: i.			aCanvas				line: self position x - hOffset + (self width * tOrigin x) @ (self position y - vOffset + (self height * tOrigin y))				to: self position x + hOffset + (self width * bOrigin x) @ (self position y + vOffset + (self height * bOrigin y))				width: thickness + 1 // 1.25				color: (isLit						ifTrue: [foregroundColor]						ifFalse: [Color transparent])]! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/16/2000 00:38'!captionAbove: aBoolean 	captionAbove := aBoolean! !!BookMorph methodsFor: 'accessing' stamp: 'sw 10/16/1998 22:39'!currentPage	(submorphs includes: currentPage) ifFalse: [currentPage := nil].	^ currentPage! !!BookMorph methodsFor: 'insert and delete' stamp: 'di 9/7/1999 21:57'!deletePageBasic	| thisPage |	thisPage := self pageNumberOf: currentPage.	pages remove: currentPage.	currentPage delete.	currentPage := nil.	pages isEmpty ifTrue: [^ self insertPage].	self goToPage: (thisPage min: pages size)! !!PrintSpecifications methodsFor: 'as yet unclassified' stamp: 'RAA 9/18/2000 09:24'!landscapeFlag: aBoolean	landscapeFlag := aBoolean! !!BackgroundMorph methodsFor: 'accessing' stamp: ''!slideBy: inc	submorphs isEmpty ifTrue: [^ self].	offset := offset + inc \\ self subBounds extent.	self changed! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'tk 4/6/1999 10:00'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| aMorph myUrl oldFlag response |	"Transcript show: thisContext sender selector; cr." "useful for debugging"	oldFlag := recursionFlag.	recursionFlag := true.	myUrl := url.	"can't use inst vars after become"	"fetch the object"	aMorph := self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	oldFlag == true ifTrue: [		response := (PopUpMenu labels: 'proceed normally\debug' withCRs)			startUpWithCaption: 'Object being fetched for a second time.Should not happen, and needs to be fixed later.'.		response = 2 ifTrue: [self halt]].	"We are already the new object"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	"Can't be a super message, since this is the first message sent to this object"	^ aMorph perform: aMessage selector withArguments: aMessage arguments! !!DropDownChoiceMorph methodsFor: 'accessing' stamp: 'bolot 11/2/1999 12:20'!items: someItems	items := someItems! !!AlignmentMorphBob1 methodsFor: 'as yet unclassified' stamp: 'RAA 3/10/2001 13:54'!acceptDroppingMorph: aMorph event: evt	| handlerForDrops |	handlerForDrops := self valueOfProperty: #handlerForDrops ifAbsent: [		^super acceptDroppingMorph: aMorph event: evt	].	(handlerForDrops acceptDroppingMorph: aMorph event: evt in: self) ifFalse: [		aMorph rejectDropMorphEvent: evt.		"send it back where it came from"	].! !!CanvasCharacterScanner methodsFor: 'private' stamp: 'ls 9/25/1999 16:24'!textColor: color	foregroundColor := color! !!PaintBoxMorph methodsFor: 'other' stamp: 'ar 3/23/2000 14:20'!focusMorph: newFocus	"Set the new focus morph"	focusMorph ifNotNil:[focusMorph paletteDetached: self]. "In case the morph is interested"	focusMorph := newFocus.	focusMorph ifNotNil:[focusMorph paletteAttached: self]. "In case the morph is interested"! !!ZoomAndScrollControllerMorph methodsFor: 'drawing' stamp: 'RAA 12/2/2000 14:24'!drawOn: aCanvas	| dw bullsEye f |	super drawOn: aCanvas.	changeKeysState ifNotNil: [		f := (			StringMorph contents: 'Press the key to be used for "',changeKeysState first,'"'		) imageForm.		aCanvas paintImage: f at: self center - (f extent // 2).		^self	].	mouseDownPoint ifNil: [^self].	dw := self deadZoneWidth.	bullsEye := mouseDownPoint - (dw@dw//2) extent: dw@dw.	aCanvas 		fillRectangle: (bullsEye left @ self top corner: bullsEye right @ self bottom) 		color: (Color red alpha: 0.3).	aCanvas 		fillRectangle: (self left @ bullsEye top corner: self right @ bullsEye bottom) 		color: (Color red alpha: 0.3).	aCanvas 		fillRectangle: bullsEye 		color: (Color red alpha: 0.4).! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'di 7/14/2000 12:48'!initialize	super initialize.	prevMouseDown := false.	showAllEnvelopes := true.	soundName ifNil: [soundName := 'test'].	self editSound: (sound ifNil: [FMSound brass1 copy]).	sound duration: 0.25.	denominator := 7.	self extent: 10@10.  "ie the minimum"! !!GradientFillMorph methodsFor: 'menu' stamp: 'di 11/2/97 14:35'!beHorizontal	gradientDirection := #horizontal.	self changed! !!Flaps class methodsFor: 'flap mechanics' stamp: 'edc 7/25/2008 08:47'!reinstateDefaultFlaps	"Remove all existing 'standard' global flaps clear the global list, and and add fresh ones.  To be called by doits in updates etc.  This is a radical step, but it does *not* clobber non-standard global flaps or local flaps.  To get the effect of the *former* version of this method, call Flaps freshFlapsStart"	"Flaps reinstateDefaultFlaps"	self globalFlapTabsIfAny do:		[:aFlapTab |			({								'Squeak' translated.				'Menu' translated.				'Widgets' translated.				'Tools' translated.				'Supplies' translated.								'Objects' translated.				'Navigator' translated			  } includes: aFlapTab flapID) ifTrue:				[self removeFlapTab: aFlapTab keepInList: false]].	"The following reduces the risk that flaps will be created with variant IDs		such as 'Stack Tools2', potentially causing some shared flap logic to fail."		"Smalltalk garbageCollect."  "-- see if we are OK without this"	self addStandardFlaps.	"self disableGlobalFlapWithID: 'Scripting'.	self disableGlobalFlapWithID: 'Objects'."	self currentWorld addGlobalFlaps.	self currentWorld reformulateUpdatingMenus.! !!WaveEditor methodsFor: 'other' stamp: 'gm 2/27/2003 23:31'!normalize: sampleArray 	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max scale out |	max := 0.	sampleArray do: 			[:s | 			max := max max: s abs].	scale := ((1 << 15) - 1) asFloat / max.	out := sampleArray species new: sampleArray size.	1 to: sampleArray size		do: [:i | out at: i put: (scale * (sampleArray at: i)) truncated].	^out! !!FlexMorph methodsFor: 'as yet unclassified' stamp: 'di 1/11/1999 20:19'!originalMorph: aMorph	originalMorph := aMorph.	scalePoint := 0.25@0.25.	self updateFromOriginal.! !!ThreadNavigationMorph methodsFor: 'stepping' stamp: 'RAA 11/9/2000 16:33'!step	| delta |	owner == self world ifFalse: [^ self].	owner addMorphInLayer: self.	delta := self bounds amountToTranslateWithin: self worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 1/30/98 22:58'!editNewSound	| known i |	known := AbstractSound soundNames.	i := 0.	[soundName := 'unnamed' , i printString.	known includes: soundName]		whileTrue: [i := 1+1].	soundName := soundName.	self editSound: FMSound default copy! !!Command methodsFor: 'copying' stamp: 'tk 2/25/2001 17:53'!veryDeepFixupWith: deepCopier	| old |	"ALL inst vars were weakly copied.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.1 to: self class instSize do:	[:ii | old := self instVarAt: ii.	self instVarAt: ii put: (deepCopier references at: old ifAbsent: [old])].! !!EventRecorderMorph methodsFor: 'pause/resume' stamp: 'ar 10/25/2000 20:58'!resumePlayIn: aWorld	playHand := HandMorphForReplay new recorder: self.	playHand position: tapeStream peek position.	aWorld addHand: playHand.	playHand newKeyboardFocus: aWorld.	playHand userInitials: 'play' andPicture: nil.	lastEvent := nil.	lastDelta := 0@0.	state := #play.	self synchronize.! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 1/26/98 22:05'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mixes the next count samples of this sound into the given buffer starting at the given index, updating the receiver's control parameters at periodic intervals."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol := AbstractSound scaleFactor.	samplesBetweenControlUpdates := self samplingRate // self controlRate.	pastEnd := startIndex + n.  "index just index of after last sample"	i := startIndex.	[i < pastEnd] whileTrue: [		remainingSamples := self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count := pastEnd - i.		samplesUntilNextControl < count ifTrue: [count := samplesUntilNextControl].		remainingSamples < count ifTrue: [count := remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl := samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl := samplesBetweenControlUpdates].		i := i + count].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'yo 1/13/2005 12:20'!loadJapanesePaintBoxBitmaps"	PaintBoxMorph new loadJapanesePaintBoxBitmaps."	| formTranslator form bb |	self position: 0@0.	formTranslator := NaturalLanguageFormTranslator localeID: (LocaleID isoString: 'ja').	form := Form fromFileNamed: 'offPaletteJapanese(children).form'.	#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		bb := (self submorphs detect: [:e | e externalName = extName]) bounds.		formTranslator name: label, '-off' form: (form copy: bb)	].	form := Form fromFileNamed: 'pressedPaletteJapanese(children).form'.	#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		bb := (self submorphs detect: [:e | e externalName = extName]) bounds.		formTranslator name: label, '-pressed' form: (form copy: bb)	].! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:06'!getStemUrl	"Try to find the old place where this book was stored. Confirm with the 	user. Else ask for new place."	| initial pg url knownURL |	knownURL := false.	initial := ''.	(pg := currentPage valueOfProperty: #SqueakPage)		ifNotNil: [pg contentsMorph == currentPage				ifTrue: [initial := pg url.					knownURL := true]].	"If this page has a url"	pages		doWithIndex: [:aPage :ind | initial isEmpty				ifTrue: [aPage isInMemory						ifTrue: [(pg := aPage valueOfProperty: #SqueakPage)								ifNotNil: [initial := pg url]]]].	"any page with a url"	initial isEmpty		ifTrue: [initial := ServerDirectory defaultStemUrl , '1.sp'].	"A new legal place"	url := knownURL		ifTrue: [initial]		ifFalse: [FillInTheBlank request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' translated initialAnswer: initial].	^ SqueakPage stemUrl: url! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 2/3/98 16:50'!colorForEnvelope: env	| name index |	name := env name.	index := #('volume' 'modulation' 'pitch' 'ratio') indexOf: name				ifAbsent: [5].	^ Color perform: (#(red green blue magenta black) at: index)! !!PaintBoxMorph methodsFor: 'actions' stamp: 'ar 12/19/2000 19:16'!showColorPalette: evt	| w box |	self comeToFront.	colorMemory align: colorMemory bounds topRight 			with: colorMemoryThin bounds topRight.	"make sure color memory fits or else align with left"	w := self world.	box := self bounds: colorMemory fullBounds in: w.	box left < 0 ifTrue:[		colorMemory align: colorMemory bounds topLeft			with: colorMemoryThin bounds topLeft].	self addMorphFront: colorMemory.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'yo 11/4/2002 21:20'!loadPressedForm: pic16Bit 	"Prototype loadPressedForm: (Smalltalk imageImports at: #pressedPaletteJapanese)"	| blt on |	AllPressedImage := AllPressedImage := Form extent: OriginalBounds extent depth: 16.	blt := BitBlt current toForm: AllPressedImage.	blt sourceForm: pic16Bit;		 combinationRule: Form over;		 sourceRect: OriginalBounds;		 destOrigin: 0 @ 0;		 copyBits.	AllPressedImage mapColor: Color black to: Color transparent.	self		allMorphsDo: [:button | (button isKindOf: ThreePhaseButtonMorph)				ifTrue: [on := Form extent: button extent depth: 16.					on						copy: (0 @ 0 extent: button extent)						from: button topLeft - self topLeft						in: AllPressedImage						rule: Form over.					button pressedImage: on]].	AllPressedImage := nil.	self invalidRect: bounds! !!IndexTabs methodsFor: 'tabs' stamp: 'sw 1/11/2000 11:15'!addTabFor: aReferent font: aFont	|  aTab |	aTab := ReferenceMorph forMorph: aReferent font: aFont.	self addMorphBack: aTab.	aTab highlightColor: self highlightColor; regularColor: self regularColor.	aTab unHighlight.	self laySubpartsOutInOneRow; layoutChanged.	^ aTab! !!PinSpec methodsFor: 'accessing' stamp: 'di 5/1/1998 10:14'!pinLoc: x	pinLoc := x! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'sw 5/23/2001 14:26'!saveLibToDisk: evt	"Save the library to disk"	| newName f snd |	newName := FillInTheBlank request: 'Please confirm name for library...'						initialAnswer: 'MySounds'.	newName isEmpty ifTrue: [^ self].	f := FileStream newFileNamed: newName , '.fml'.	AbstractSound soundNames do:		[:name | snd := AbstractSound soundNamed: name.		"snd isStorable" true ifTrue: [f nextChunkPut: 'AbstractSound soundNamed: ' , name , ' put: ' , snd storeString; cr; cr]			ifFalse: [self inform: name , ' is not currently storable']].	f close! !!RecordingControlsMorph methodsFor: 'other' stamp: 'ar 11/9/2000 21:21'!addRecordLevelSlider	| levelSlider r |	levelSlider := SimpleSliderMorph new		color: color;		extent: 100@2;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	r := AlignmentMorph newRow		color: color;		layoutInset: 0;		wrapCentering: #center; cellPositioning: #leftCenter;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!StringMorph methodsFor: '*MorphicExtras-accessing' stamp: 'sw 9/9/1999 18:09'!handsWithMeForKeyboardFocus	| foc |	"Answer the hands that have me as their keyboard focus"	hasFocus ifFalse: [^ #()].	^ self currentWorld hands select:		[:aHand | (foc := aHand keyboardFocus) notNil and: [foc owner == self]]! !!BookMorph methodsFor: 'navigation' stamp: 'ar 11/9/2000 20:37'!buildFloatingPageControls	| pageControls |	pageControls := self makePageControlsFrom: self fullControlSpecs.	pageControls borderWidth: 0; layoutInset: 4.	pageControls  setProperty: #pageControl toValue: true.	pageControls setNameTo: 'Page Controls'.	pageControls color: Color yellow.	^FloatingBookControlsMorph new addMorph: pageControls.! !!PostscriptCharacterScanner methodsFor: 'accessing' stamp: ''!paragraph:newPara    paragraph:=newPara.	! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'sw 3/3/2004 19:49'!makeTile	"Make a tile representing my sound.  Get a sound-name from the user by which the sound is to be known."	| newStyleTile sndName tile |	recorder verifyExistenceOfRecordedSound ifFalse: [^ self].	recorder pause.	newStyleTile := true.	newStyleTile		ifTrue:			[sndName := FillInTheBlank				request: 'Please name your new sound' translated				initialAnswer: 'sound' translated.			sndName isEmpty ifTrue: [^ self].			sndName := SampledSound unusedSoundNameLike: sndName.			SampledSound				addLibrarySoundNamed: sndName				samples: recorder condensedSamples				samplingRate: recorder samplingRate.			tile := SoundTile new literal: sndName]		ifFalse:			[tile := InterimSoundMorph new sound: 				(SampledSound					samples: recorder condensedSamples					samplingRate: recorder samplingRate)].	tile bounds: tile fullBounds.	tile openInHand! !!Component methodsFor: 'initialize' stamp: 'di 5/3/1998 20:23'!initComponentIn: aLayout	model := aLayout model.	self nameMeIn: aLayout world.	self color: Color lightCyan.	self showPins.	model addDependent: self! !!TextOnCurveContainer methodsFor: 'as yet unclassified' stamp: 'di 12/4/97 09:23'!textDirection: plusOrMinusOne	textDirection := plusOrMinusOne! !!GeeBookMorph methodsFor: 'as yet unclassified' stamp: 'RAA 10/3/2000 12:44'!rebuildPages	pages := self geePageRectangles collect: [ :each |		GeeBookPageMorph new 			disableDragNDrop;			geeMail: geeMail geeMailRectangle: each.	].	currentPage delete.	currentPage := nil.	pages isEmpty ifTrue: [^ self insertPage].	self goToPage: 1.! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:53'!truncate: aBoolean	truncate := aBoolean! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 12:49'!bounds	^computedBounds ifNil: [computedBounds := self computeBounds]! !!PostscriptCanvas methodsFor: 'private' stamp: 'mpw 9/14/1999 06:58'!topLevelMorph:newMorph	topLevelMorph := newMorph.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'yo 2/17/2005 15:40'!doNewPainting		| w f |	w := self world.	w assureNotPaintingElse: [^ self].	(f := self owner flapTab) ifNotNil: [f hideFlap].	w makeNewDrawing: (self primaryHand lastEvent copy setPosition: w center)! !!LedMorph methodsFor: 'stepping and presenter' stamp: 'tk 4/19/2001 17:02'!step	(flash or: [flashing])		ifTrue: 			[flashing := flashing not.			self highlighted: flashing].	scroller ifNil: [scroller := 1].	chars ifNil: [^ self].	scroller + chars < (string size + 1)		ifTrue: 			[scroller := scroller + 1.			self stringToLed]		ifFalse: [scrollLoop ifTrue: [scroller := 1]]! !!WireMorph methodsFor: 'as yet unclassified' stamp: 'di 5/6/1998 14:22'!pinMoved	| newVerts |	newVerts := vertices copy.	newVerts at: 1 put: pins first wiringEndPoint.	newVerts at: newVerts size put: pins last wiringEndPoint.	self setVertices: newVerts! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:55'!midiPort: anInteger	midiPort := anInteger.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'RAA 8/30/2000 15:32'!fullScreenOn	self setProperty: #showingFullScreenMode toValue: true.	ScreenController new fullScreenOn.	self removeProperty: #currentNavigatorVersion.	mouseInside := false.! !!StringButtonMorph methodsFor: 'menu' stamp: ''!setLabel	| newLabel |	newLabel := FillInTheBlank		request:'Please type a new label for this button'		initialAnswer: self contents.	newLabel isEmpty ifFalse: [self contents: newLabel].! !!TwoWayScrollPane methodsFor: 'menu' stamp: 'nk 4/19/2002 12:58'!menuSelector: aSelector	getMenuSelector := aSelector! !!TransitionMorph methodsFor: 'updating' stamp: 'di 12/22/1998 20:59'!changed	"The default (super) method is, generally much slower than need be, since many transitions only change part of the screen on any given step of the animation.  The purpose of this method is to effect some of those savings."	| loc box boxPrev h w |	(stepNumber between: 1 and: nSteps) ifFalse: [^ super changed].	effect = #slideBoth ifTrue: [^ super changed].	effect = #slideOver ifTrue:		[loc := self stepFrom: self position - (self extent * direction) to: self position.		^ self invalidRect: (((loc extent: self extent) expandBy: 1) intersect: bounds)].	effect = #slideAway ifTrue:		[loc := self prevStepFrom: self position to: self position + (self extent * direction).		^ self invalidRect: (((loc extent: self extent) expandBy: 1) intersect: bounds)].	effect = #slideBorder ifTrue:		[box := endForm boundingBox translateBy:				(self stepFrom: self topLeft - (self extent * direction) to: self topLeft).		boxPrev := endForm boundingBox translateBy:				(self prevStepFrom: self topLeft - (self extent * direction) to: self topLeft).		^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].	effect = #pageForward ifTrue:		[loc := self prevStepFrom: 0@0 to: self extent * direction.		^ self invalidRect: (((bounds translateBy: loc) expandBy: 1) intersect: bounds)].	effect = #pageBack ifTrue:		[loc := self stepFrom: self extent * direction negated to: 0@0.		^ self invalidRect: (((bounds translateBy: loc) expandBy: 1) intersect: bounds)].	effect = #frenchDoor ifTrue:		[h := self height. w := self width.		direction = #in ifTrue:			[box := Rectangle center: self center							extent: (self stepFrom: 0@h to: self extent).			boxPrev := Rectangle center: self center							extent: (self prevStepFrom: 0@h to: self extent).			^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].		direction = #out ifTrue:			[box := Rectangle center: self center							extent: (self stepFrom: self extent to: 0@h).			boxPrev := Rectangle center: self center							extent: (self prevStepFrom: self extent to: 0@h).			^ self invalidate: (boxPrev expandBy: 1) areasOutside: box].		direction = #inH ifTrue:			[box := Rectangle center: self center							extent: (self stepFrom: w@0 to: self extent).			boxPrev := Rectangle center: self center							extent: (self prevStepFrom: w@0 to: self extent).			^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].		direction = #outH ifTrue:			[box := Rectangle center: self center							extent: (self stepFrom: self extent to: w@0).			boxPrev := Rectangle center: self center							extent: (self prevStepFrom: self extent to: w@0).			^ self invalidate: (boxPrev expandBy: 1) areasOutside: box]].	effect = #zoomFrame ifTrue:		[direction = #in ifTrue:			[box := Rectangle center: self center							extent: (self stepFrom: 0@0 to: self extent).			boxPrev := Rectangle center: self center							extent: (self prevStepFrom: 0@0 to: self extent).			^ self invalidate: (box expandBy: 1) areasOutside: boxPrev].		direction = #out ifTrue:			[box := Rectangle center: self center							extent: (self stepFrom: self extent to: 0@0).			boxPrev := Rectangle center: self center							extent: (self prevStepFrom: self extent to: 0@0).			^ self invalidate: (boxPrev expandBy: 1) areasOutside: box]].	effect = #zoom ifTrue:		[box := Rectangle center: self center extent:			(direction = #in				ifTrue: [self stepFrom: 0@0 to: self extent]				ifFalse: [self prevStepFrom: self extent to: 0@0]).		^ self invalidRect: ((box expandBy: 1) intersect: bounds)].	^ super changed! !!GraphMorph methodsFor: 'commands' stamp: ''!appendValue: aPointOrNumber	| newVal |	(data isKindOf: OrderedCollection) ifFalse: [data := data asOrderedCollection].	newVal := self asNumber: aPointOrNumber.	data addLast: newVal.	newVal < minVal ifTrue: [minVal := newVal].	newVal > maxVal ifTrue: [maxVal := newVal].	self cursor: data size.	self flushCachedForm.! !!FatBitsPaint methodsFor: 'menu' stamp: 'jm 12/1/97 12:09'!penSize: aNumber	brushSize := (aNumber * magnification) asInteger.	brush squareNib: brushSize.! !!WorldWindow class methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 11:12'!test1	"WorldWindow test1."	| window world |	world := WiWPasteUpMorph newWorldForProject: nil.	window := (WorldWindow labelled: 'Inner World') model: world.	window addMorph: world.	world hostWindow: window.	window openInWorld! !!GeePrinterDialogMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/18/2000 11:26'!printSpecs: aPrintSpecification printBlock: aTwoArgBlock	printSpecs := aPrintSpecification.	printBlock := aTwoArgBlock.! !!CommandHistory methodsFor: 'called from the ui' stamp: 'nb 6/17/2003 12:25'!undoLastCommand	"Undo the last command, i.e. move backward in the recent-commands tape, if possible."	| aPhase anIndex |	lastCommand ifNil: [^ Beeper beep].	(aPhase := lastCommand phase) == #done		ifFalse:			[aPhase == #undone				ifTrue:					[anIndex := history indexOf: lastCommand.					anIndex > 1 ifTrue:						[lastCommand := history at: anIndex - 1]]].	lastCommand undoCommand.	lastCommand phase: #undone	"Command undoLastCommand"! !!BookPageSorterMorph methodsFor: 'initialization' stamp: 'dgd 2/17/2003 19:56'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: Display extent - 100;		 listDirection: #topToBottom;		 wrapCentering: #topLeft;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 layoutInset: 3.	pageHolder := PasteUpMorph new behaveLikeHolder extent: self extent -self borderWidth.	pageHolder hResizing: #shrinkWrap.	"pageHolder cursor: 0."	"causes a walkback as of 5/25/2000"	self addControls.	self addMorphBack: pageHolder! !!DropDownChoiceMorph methodsFor: 'drawing' stamp: 'ar 12/31/2001 02:51'!maxExtent: listOfStrings	| h w maxW f |	maxW := 0.	listOfStrings do: [:str |		f := self fontToUse.		w := f widthOfString: str.		h := f height.		maxW := maxW max: w].	self extent: (maxW + 4 + h) @ (h + 4).	self changed! !!PolygonMorph methodsFor: '*MorphicExtras-*morphic-Postscript Canvases' stamp: 'ar 11/26/2001 23:15'!drawPostscriptOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight 	line segments."	| array |	vertices size < 1		ifTrue: [self error: 'a polygon must have at least one point'].	array := self drawArrowsOn: aCanvas.	closed		ifTrue: [aCanvas				drawPolygon: self getVertices				color: self color				borderWidth: self borderWidth				borderColor: self borderColor]		ifFalse: [self drawClippedBorderOn: aCanvas usingEnds: array].! !!CommandHistory methodsFor: 'called from the ui' stamp: 'nb 6/17/2003 12:25'!redoNextCommand	"If there is a way to 'redo' (move FORWARD) in the undo/redo history tape, do it."	| anIndex |	lastCommand ifNil: [^ Beeper beep].	lastCommand phase == #undone		ifFalse:			[anIndex := history indexOf: lastCommand.			(anIndex < history size)				ifTrue:					[lastCommand := history at: anIndex + 1]				ifFalse:					[^ Beeper beep]].	lastCommand redoCommand.	lastCommand phase: #done! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 9/13/2000 15:01'!addJumpBeginning	| ed attribute jumpEnd mySelection a1 ax |	ed := self editor.	(mySelection := ed selection) isEmpty ifTrue: [^self inform: 'Please select something first'].	jumpEnd := self chooseOneJumpEnd.	jumpEnd isEmptyOrNil ifTrue: [^self].	attribute := TextPlusJumpStart new jumpLabel: jumpEnd.	a1 := (mySelection attributesAt: 1) reject: [ :each | each isKindOf: TextPlusJumpStart].	ax := (mySelection attributesAt: mySelection size) reject: [ :each | each isKindOf: TextPlusJumpStart].	ed replaceSelectionWith: 		(Text string: '*' attributes: a1),		(mySelection addAttribute: attribute),		(Text string: '*' attributes: ax).	self releaseParagraphReally.	self layoutChanged.! !!GraphicalDictionaryMenu class methodsFor: 'instance creation' stamp: 'nk 1/11/2004 15:50'!openOn: aFormDictionary withLabel: aLabel	"open a graphical dictionary in a window having the label aLabel.      aFormDictionary should be a dictionary containing as value a form."	| inst aWindow |	aFormDictionary size isZero ifTrue: [^ self inform: 'Empty!!'].		inst := self new initializeFor: nil fromDictionary: aFormDictionary.	aWindow := (SystemWindow labelled: aLabel) model: inst.	aWindow addMorph: inst frame: (0@0 extent: 1@1).	aWindow extent: inst fullBounds extent + (3 @ aWindow labelHeight + 3);		minimumExtent: inst minimumExtent + (3 @ aWindow labelHeight + 3).	     HandMorph attach: aWindow.	^ inst! !!InterimSoundMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:57'!initialize	"initialize the state of the receiver"	super initialize.	""		self extent: 30 @ 30.	self addGraphic.	sound := PluckedSound				pitch: 880.0				dur: 2.0				loudness: 0.5! !!BookMorph methodsFor: 'navigation' stamp: 'di 1/14/1999 12:07'!goToPage: pageNumber transitionSpec: transitionSpec	| pageMorph |	pages isEmpty ifTrue: [^ self].	pageMorph := (self hasProperty: #dontWrapAtEnd)		ifTrue: [pages atPin: pageNumber]		ifFalse: [pages atWrap: pageNumber].	^ self goToPageMorph: pageMorph transitionSpec: transitionSpec! !!BooklikeMorph methodsFor: 'menu commands' stamp: 'tk 2/25/1999 11:04'!sortPages	| sorter |	sorter := BookPageSorterMorph new		book: self morphsToSort: self morphsForPageSorter.	sorter pageHolder cursor: self pageNumber.	"Align at bottom right of screen, but leave 20-pix margin."	self bottom + sorter height < Display height ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter topLeft with: self bottomLeft)].	self right + sorter width < Display width ifTrue: "Place it below if it fits"		[^ self world addMorphFront: (sorter align: sorter bottomLeft with: self bottomRight)].	"Otherwise, place it at lower right of screen"	self world addMorphFront: (sorter position: Display extent - (20@20) - sorter extent).! !!RemoteHandMorph methodsFor: 'other' stamp: 'ar 10/24/2000 14:34'!withdrawFromWorld	"Close the socket, if any, and remove this hand from the world."	| addr |	addr := self remoteHostAddress.	addr = 0 ifFalse: [self stopTransmittingEvents].	self stopListening.	Transcript show: 'Remote hand ', self userInitials, ' closed'; cr.	owner ifNotNil: [owner removeHand: self].! !!StringButtonMorph methodsFor: 'e-toy support' stamp: 'ar 3/17/2001 20:17'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target := target adaptedToWorld: aWorld.! !!BookMorph methodsFor: 'menu' stamp: 'dgd 10/26/2003 13:14'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url := self valueOfProperty: #url) ifNil: ["for .bo index file"	url := FillInTheBlank 		request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' translated		initialAnswer: (self getStemUrl, '.bo').	url notEmpty ifTrue: [self setProperty: #url toValue: url]				ifFalse: [^ self]].	onServer := self class new fromURL: url.	"Later: test book times?"	onPgs := onServer pages collect: [:out |		sq := SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq notNil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph isNil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	which := (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!TextOnCurve methodsFor: 'private' stamp: 'nk 6/23/2004 15:06'!moveBy: delta	positionWhenComposed := (positionWhenComposed ifNil: [ container origin ]) + delta.	container := container translateBy: delta! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 6/6/2000 17:42'!resetViewBoxForReal	| newClip |	self viewBox ifNil: [^self].	newClip := self viewBox intersect: parentWorld viewBox.	worldState canvas: (		Display getCanvas			copyOffset:  0@0			clipRect: newClip	)! !!MagnifierMorph methodsFor: 'menu' stamp: 'nk 3/17/2004 11:34'!showPointer	^showPointer ifNil: [ showPointer := false ].! !!GraphMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:28'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 365 @ 80.	dataColor := Color darkGray.	cursor := 1.0.	"may be fractional"	cursorColor := Color red.	cursorColorAtZeroCrossings := Color red.	startIndex := 1.	hasChanged := false.	self		data: ((0 to: 360 - 1)				collect: [:x | (100.0 * x degreesToRadians sin) asInteger])! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'md 2/15/2006 18:44'!removeAlansAnchorFor: aMorph	| anchors |	anchors := OrderedCollection new.	text runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			(att isMemberOf: TextAnchor) ifTrue: [				(att anchoredMorph isNil or: [					att anchoredMorph == aMorph or: [att anchoredMorph world isNil]]) ifTrue: [					anchors add: {att. start. stop}				]			]		]	].	anchors do: [ :old |		text removeAttribute: old first from: old second to: old third.	].! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/6/2001 01:45'!setSearchStringTo: aText	"The user submitted aText as the search string; now search for it"	searchString := aText asString.	self findPreferencesMatching: searchString.	^ true! !!BackgroundMorph methodsFor: 'accessing' stamp: ''!startRunning	running := true.	self changed! !!SimpleSwitchMorph methodsFor: 'switching' stamp: 'jm 1/29/98 20:18'!onColor: aColor	onColor := aColor.! !!SquishedNameMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/11/2000 23:18'!fontForName	| pickem |	pickem := 3.	pickem = 1 ifTrue: [		^(((TextStyle named: #Helvetica) ifNil: [TextStyle default]) fontOfSize: 13) emphasized: 1.	].	pickem = 2 ifTrue: [		^(((TextStyle named: #Palatino) ifNil: [TextStyle default]) fontOfSize: 12) emphasized: 1.	].	^((TextStyle default) fontAt: 1) emphasized: 1! !!LedCharacterMorph class methodsFor: 'class initialization' stamp: 'kfr 6/3/2000 21:32'!initialize	CHSegmentOrigins := {0.2@0.1. 0.2@0.45. 0.2@0.8}.	CVSegmentOrigins := {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	TSegments := { 0.25@0.25. 0.45@0.25. 0.55@0.25. 0.75@0.25. 0.25@0.6. 0.45@0.6. 0.55@0.6. 0.75@0.6. }.	BSegments := { 0.45@0.4. 0.25@0.4. 0.75@0.4. 0.55@0.4. 0.45@0.76. 0.25@0.76. 0.75@0.76. 0.55@0.76. }.	DSegments  := {	{false. false. false. false. false. false. false. false. }."0"	{false. false. false. false. false. false. false. false. }."1"	{false. false. false. false. false. false. false. false. }."2"	{false. false. false. false. false. false. false. false. }."3"	{false. false. false. false. false. false. false. false. }."4"	{false. false. false. false. false. false. false. false. }."5"	{false. false. false. false. false. false. false. false. }."6"	{false. false. false. false. false. false. false. false. }."7"	{false. false. false. false. false. false. false. false. }."8"	{false. false. false. false. false. false. false. false. }."9"	{false. false. false. false. false. false. false. false. }."A"	{false. false. false. false. false. false. false. false. }."B"	{false. false. false. false. false. false. false. false. }."C"	{false. false. false. false. false. false. false. false. }."D"	{false. false. false. false. false. false. false. false. }."E"	{false. false. false. false. false. false. false. false. }."F"	{false. false. false. false. false. false. false. false. }."G"	{false. false. false. false. false. false. false. false. }."H"	{false. false. false. false. false. false. false. false. }."I"	{false. false. false. false. false. false. false. false. }."J"	{false. false. false. true. false. false. false. false. }."K"	{false. false. false. false. false. false. false. false. }."L"	{true. false. false. true. false. false. false. false. }."M"	{true. false. false. false. false. false. true. false. }."N"	{false. true. true. false. true. false. false. true.  }."O"	{false. false. false. false. false. false. false. false. }."P"	{false. false. false. false. false. false. true. false. }."Q"	{false. false. false. false. false. false. true. false. }."R"	{false. false. false. false. false. false. false. false. }."S"	{false. false. false. false. false. false. false. false. }."T"	{false. false. false. false. false. false. false. false. }."U"	{false. false. false. false. true. false. false. true. }."V"	{false. false. false. false. false. true. true. false. }."W"	{true. false. false. true. false. true. true. false. }."X"	{false. false. false. false. false. false. false. false. }."Y"	{false. false. false. true. false. true. false. false. }."Z"	{false. false. false. false. false. false. false. false. }}."SPACE"	CHSegments := {		{true. false. true}."0"		{false. false. false}."1"		{true. true. true}."2"		{true. true. true}."3"		{false. true. false}."4"		{true. true. true}."5"		{true. true. true}."6"		{true. false. false}."7"		{true. true. true}."8"		{true. true. true}."9"		{true. true. false}."A"		{true. true. true}."B"		{true. false. true}."C"		{true. false. true}."D"		{true. true. true}."E"		{true. true. false}."F"		{true. true. true}."G"		{false. true. false}."H"		{false. false. false}."I"		{false. false. true}."J"		{false. true. false}."K"		{false. false. true}."L"		{false. false. false}."M"		{false. false. false}."N"		{false. false. false}."O"		{true. true. false}."P"		{true. false. true}."Q"		{true. true. false}."R"		{true. true. true}."S"		{false. true. true}."t"		{false. false. true}."U"		{false. false. false}."V"		{false. false. false}."W"		{false. false. false}."X"		{false. true. true}."Y"		{true. false. true}."Z"		{false. false. false.}}."SPACE"	CVSegments := {		{true. true.  true. true}."0"		{false. false. true. true}."1"		{false. true. true. false}."2"		{false. false. true. true}."3"		{true. false. true. true}."4"		{true. false. false. true}."5"		{true. true. false. true}."6"		{false. false. true. true}."7"		{true. true. true. true}."8"		{true. false. true. true}."9"		{true. true. true. true}."A"		{true. true. true. true}."B"		{true. true. false. false}."C"		{true. true. true. true}."D"		{true. true. false. false}."E"		{true. true. false. false}."F"		{true. true. false. true}."G"		{true. true. true. true}."H"		{true. true. false. false}."I"		{false. true. true. true}."J"		{true. true. false. true}."K"		{true. true. false. false}."L"		{true. true.  true. true}."N"		{true. true. true. true}."N"		{false. false. false. false}."O"		{true. true. true. false}."P"		{true. true.  true. true}."q"		{true. true. true. false}."R"		{true. false. false. true}."S"		{true. true. false. false}."t"		{true. true. true. true}."U"		{true. false. true. false}."V"		{true. true.  true. true}."w"		{false. false. false. false}."x"		{true. false. true. true}."y"		{false. false. false. false}."z"		{false. false. false. false}}."SPACE"! !!ZoomAndScrollMorph methodsFor: 'scripting' stamp: 'RAA 12/5/2000 18:31'!offsetX: aNumber	| transform |	transform := self myTransformMorph.	transform offset: aNumber @ transform offset y! !!PaintBoxMorph methodsFor: 'actions' stamp: 'RAA 8/16/2000 11:15'!undo: undoButton with: undoSelector evt: evt	| ss |	(ss := self focusMorph) 		ifNotNil: [ss undoPainting: self evt: evt]		ifNil: [self notCurrentlyPainting].	undoButton state: #off.! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ar 8/31/2000 22:49'!commandToUndo	"Undo the last command, i.e. move backward in the recent-commands tape, if possible."	| anIndex |	lastCommand ifNil: [^ nil].	lastCommand phase == #done ifTrue: [^ lastCommand].	(lastCommand phase == #undone and:		[(anIndex := history indexOf: lastCommand) > 1])		ifTrue: [^ history at: anIndex - 1]		ifFalse: [^ nil]! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 12/16/1998 08:30'!purge	"Replace morphs with tombstones in all pages that are clean and not being shown.  Write any dirty ones first, if allowed to."	| list |	list := OrderedCollection new.	GlobalPolicy == #neverWrite 		ifTrue: [PageCache doPagesInMemory: [:aPage | list add: aPage prePurge]]			"Writing only done by user's command"		ifFalse: [			PageCache doPagesInMemory: [:aPage | aPage write					 list add: aPage prePurge]].	list := list select: [:each | each notNil].	"do bulk become:"	(list collect: [:each | each contentsMorph])		elementsExchangeIdentityWith:			(list collect: [:pg | MorphObjectOut new xxxSetUrl: pg url page: pg])! !!SqueakPage methodsFor: 'accessing' stamp: 'tk 2/23/1999 14:39'!copyForSaving	"Make a copy and configure me to be put out on the disk.  When it is brought in and touched, it will turn into the object at the url."	| forDisk holder |	forDisk := self clone.	holder := MorphObjectOut new xxxSetUrl: url page: forDisk.	forDisk contentsMorph: holder.	^ holder		"directly representing the object"! !!BooklikeMorph methodsFor: 'e-toy support' stamp: 'sw 8/11/1998 16:51'!currentPlayerDo: aBlock	| aPlayer aPage |	(aPage := self currentPage) ifNil: [^ self].	(aPlayer := aPage player) ifNotNil:		[aBlock value: aPlayer]! !!InternalThreadNavigationMorph class methodsFor: 'thumbnails' stamp: 'RAA 5/10/2001 17:07'!getThumbnailFor: aProject	CachedThumbnails ifNil: [CachedThumbnails := Dictionary new].	^CachedThumbnails		at: aProject name		ifAbsentPut: [self sorterFormForProject: aProject sized: nil]! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'di 2/26/98 09:17'!fullColorWhenInactive: fullColor	"MorphWorldView fullColorWhenInactive: true"	"If FullColorWhenInactive is true then WorldMorphViews will created inside StandardSystemViews that cache their contents in full-color when the window is inactive. If it is false, only a half-tone gray approximation of the colors will be cached to save space."	FullColorWhenInactive := fullColor.	"Retroactively convert all extant windows"	((fullColor ifTrue: [StandardSystemView] ifFalse: [ColorSystemView])		allInstances select:			[:v | v subViews notNil and: [v subViews isEmpty not and: [v firstSubView isKindOf: MorphWorldView]]])		do: [:v | v uncacheBits.			v controller toggleTwoTone]! !!BookMorph methodsFor: 'menus' stamp: 'yo 7/2/2004 13:05'!printPSToFile	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag |	fileName := ('MyBook') translated asFileName.	fileName := FillInTheBlank request: 'File name? (".ps" will be added to end)' translated 			initialAnswer: fileName.	fileName isEmpty ifTrue: [^ Beeper beep].	(fileName endsWith: '.ps') ifFalse: [fileName := fileName,'.ps'].	rotateFlag := ((PopUpMenu labels:'portrait (tall)landscape (wide)' translated) 			startUpWithCaption: 'Choose orientation...' translated) = 2.	(FileStream newFileNamed: fileName asFileName)		nextPutAll: (DSCPostscriptCanvas morphAsPostscript: self rotated: rotateFlag); close.! !!PostscriptCharacterScanner methodsFor: 'textstyle support' stamp: ''!setActualFont: newFont	font := newFont.! !!GeePrinterDialogMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 19:52'!initialize	"initialize the state of the receiver"	super initialize.	""	self vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 layoutInset: 4;		 useRoundedCorners.	printSpecs		ifNil: [printSpecs := PrintSpecifications defaultSpecs].	self rebuild ! !!BookMorph methodsFor: 'menu' stamp: 'dgd 4/3/2006 13:08'!invokeBookMenu	"Invoke the book's control panel menu."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Book' translated.	Preferences noviceMode		ifFalse:[aMenu addStayUpItem].	aMenu add: 'find...' translated action: #textSearch.	aMenu add: 'go to page...' translated action: #goToPage.	aMenu addLine.	aMenu addList: {		{'sort pages' translated.		#sortPages}.		{'uncache page sorter' translated.	#uncachePageSorter}}.	(self hasProperty: #dontWrapAtEnd)		ifTrue: [aMenu add: 'wrap after last page' translated selector: #setWrapPages: argument: true]		ifFalse: [aMenu add: 'stop at last page' translated selector: #setWrapPages: argument: false].	aMenu addList: {		{'make bookmark' translated.		#bookmarkForThisPage}.		{'make thumbnail' translated.		#thumbnailForThisPage}}.	aMenu addUpdating: #showingPageControlsString action: #toggleShowingOfPageControls.	aMenu addUpdating: #showingFullScreenString action: #toggleFullScreen.	aMenu addLine.	aMenu add: 'sound effect for all pages' translated action: #menuPageSoundForAll:.	aMenu add: 'sound effect this page only' translated action: #menuPageSoundForThisPage:.	aMenu add: 'visual effect for all pages' translated action: #menuPageVisualForAll:.	aMenu add: 'visual effect this page only' translated action: #menuPageVisualForThisPage:.	aMenu addLine.	(self primaryHand pasteBuffer class isKindOf: PasteUpMorph class) ifTrue:		[aMenu add: 'paste book page' translated   action: #pasteBookPage].	aMenu add: 'save as new-page prototype' translated action: #setNewPagePrototype.	newPagePrototype ifNotNil: [		aMenu add: 'clear new-page prototype' translated action: #clearNewPagePrototype].	aMenu add: (self dragNDropEnabled ifTrue: ['close dragNdrop'] ifFalse: ['open dragNdrop']) translated			action: #toggleDragNDrop.	aMenu add: 'make all pages this size' translated action: #makeUniformPageSize.		aMenu		addUpdating: #keepingUniformPageSizeString		target: self		action: #toggleMaintainUniformPageSize.	aMenu addLine.	aMenu add: 'send all pages to server' translated action: #savePagesOnURL.	aMenu add: 'send this page to server' translated action: #saveOneOnURL.	aMenu add: 'reload all from server' translated action: #reload.	aMenu add: 'copy page url to clipboard' translated action: #copyUrl.	aMenu add: 'keep in one file' translated action: #keepTogether.	aMenu addLine.	aMenu add: 'load PPT images from slide #1' translated action: #loadImagesIntoBook.	aMenu add: 'background color for all pages...' translated action: #setPageColor.	aMenu add: 'make a thread of projects in this book' translated action: #buildThreadOfProjects.	aMenu popUpEvent: self world activeHand lastEvent in: self world! !!TextOnCurve methodsFor: 'display' stamp: 'ar 5/25/2000 18:01'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| maxExtent lineForm leftInRun lineRect warp sourceQuad backgroundColor lineCanvas |	warp := nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may hot have to display at all."				maxExtent := lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm := Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect := lineForm boundingBox.				leftInRun := 0.				backgroundColor := (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp := (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas := lineForm getCanvas].			sourceQuad := destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun := displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/26/2000 01:55'!readFromV1: aStream	| cr |	cr := Character cr.	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:[			tStream nextPut: (MorphicEvent readFromString: (aStream upTo: cr))]]! !!PinMorph methodsFor: 'variables' stamp: 'di 5/4/1998 00:11'!addModelVariable	| accessors |	accessors := component model addVariableNamed: component knownName , pinSpec pinName.	pinSpec modelReadSelector: accessors first modelWriteSelector: accessors second.	component initFromPinSpecs.	self connectedPins do: [:connectee | connectee shareVariableOf: self]! !!PaintBoxMorph methodsFor: 'other' stamp: 'yo 1/13/2005 14:08'!addGraphicLabels	"translate button labels"	| formTranslator ext pos newForm |	formTranslator := NaturalLanguageFormTranslator localeID: (Locale current localeID).	#('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:label |		(formTranslator translate: label, '-off') ifNil: [^ false].		(formTranslator translate: label, '-pressed') ifNil: [^ false].	].		#('keep:' 'undo:' 'clear:' 'toss:') with: #('KEEP' 'UNDO' 'CLEAR' 'TOSS') do: [:extName :label |		| button |		button := submorphs detect: [:m | m externalName = extName] ifNone: [nil].		button ifNotNil: [			button removeAllMorphs.			ext := button extent.			pos := button position.			(newForm := formTranslator translate: label, '-off') ifNotNil: [				button offImage: newForm.			].			(newForm := formTranslator translate: label, '-pressed') ifNotNil: [				button pressedImage: newForm.			].			button extent: ext.			button position: pos.		].	].	^ true.! !!ProjectSorterMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/10/2001 17:07'!sorterMorphForProjectNamed: projName	| pvm proj |	(proj := Project named: projName) ifNil: [^nil].	pvm := (InternalThreadNavigationMorph getThumbnailFor: proj) asMorph.	pvm setProperty: #nameOfThisProject toValue: projName.	pvm setBalloonText: projName.	pvm on: #mouseDown send: #clickFromSorterEvent:morph: to: self.	pvm on: #mouseUp send: #clickFromSorterEvent:morph: to: self.	^pvm! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 10/11/97 17:04'!remove: tool	"Remove a stamp.  Make this stamp blank.  OK to have a bunch of blank ones."	| which |	which := stampButtons indexOf: tool ifAbsent: [				pickupButtons indexOf: tool ifAbsent: [^ self]].	stamps atWrap: which+start-1 put: nil.	thumbnailPics atWrap: which+start-1 put: nil.	self normalize.	"show them"! !!WaveEditor methodsFor: 'menu' stamp: 'dgd 9/19/2003 12:48'!setLoopStart	"Assuming that the loop end and approximate frequency have been set, this method uses the current cursor position to determine the loop length and the number of cycles."	| start len |	start := graph cursor.	((start >= loopEnd) or: [perceivedFrequency = 0]) ifTrue: [		^ self inform:'Please set the loop end and the approximate frequencyfirst, then position the cursor one or more cyclesbefore the loop end and try this again.' translated].	len := (loopEnd - start) + 1.	loopCycles := (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!ThreadNavigationMorph methodsFor: 'private' stamp: 'RAA 6/27/2000 18:49'!listOfPages: aCollection	listOfPages := aCollection! !!PreferencesPanel methodsFor: 'find' stamp: 'sw 2/18/2001 04:03'!findCategoryFromPreference: prefSymbol	"Find all categories in which the preference occurs"	| aMenu| 	aMenu := MenuMorph new defaultTarget: self.	(Preferences categoriesContainingPreference: prefSymbol) do:		[:aCategory | aMenu add: aCategory target: self selector: #switchToCategoryNamed:event: argumentList: {aCategory. MorphicEvent new}].	aMenu popUpInWorld! !!ZASMCameraMarkMorph methodsFor: 'dropping/grabbing' stamp: 'RAA 12/11/2000 23:26'!justDroppedInto: newOwner event: anEvent	| holder |	newOwner isWorldMorph ifTrue: [		holder := ZASMScriptMorph new.		holder 			position: self position;			setProperty: #cameraController toValue: self cameraController.		self world addMorph: holder.		holder addMorph: self.		holder startStepping.	].	super justDroppedInto: newOwner event: anEvent! !!PreferencesPanel class methodsFor: 'cleanup' stamp: 'RAA 4/14/2001 11:03'!killExistingMVCViews	"Kill all existing preferences views in mvc""PreferencesPanel killExistingMVCViews"	| byebye |	ControlManager allInstances do: [ :cm |		byebye := cm controllersSatisfying: [ :eachC |			self isAPreferenceViewToKill: eachC view].		byebye do: [ :each | 			each status: #closed.			each view release.			cm unschedule: each]]! !!FatBitsPaint methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:40'!drawOn: aCanvas	| f |	f := self rotatedForm.	backgroundColor ifNotNil: [aCanvas fillRectangle: bounds fillStyle: backgroundColor].	aCanvas translucentImage: f at: bounds origin.! !!ZoomAndScrollMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/30/2000 16:16'!getZoomFactor	^zoomFactor ifNil: [zoomFactor := 0.5].	! !!LedCharacterMorph methodsFor: 'accessing' stamp: 'kfr 5/26/2000 19:03'!highlighted: aBoolean	highlighted := aBoolean.	self changed.! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 10/26/2000 01:04'!convertV0Tape: anArray	"Convert the tape into the new format"	| lastKey evt |	lastKey := 0.	^anArray collect:[:assn| 		evt := assn value.		evt setTimeStamp: (lastKey := lastKey + assn key).		evt]! !!TransitionMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:01'!drawFrenchDoorOn: aCanvas	"startForm and endFrom are both fixed, but a border expands out from a vertical (or H) slit, revealing endForm.	It's like opening a pair of doors."	| box innerForm outerForm boxExtent h w |	h := self height. w := self width.	direction = #in ifTrue: [innerForm := endForm.  outerForm := startForm.							boxExtent := self stepFrom: 0@h to: self extent].	direction = #out ifTrue: [innerForm := startForm.  outerForm := endForm.							boxExtent := self stepFrom: self extent to: 0@h].	direction = #inH ifTrue: [innerForm := endForm.  outerForm := startForm.							boxExtent := self stepFrom: w@0 to: self extent].	direction = #outH ifTrue: [innerForm := startForm.  outerForm := endForm.							boxExtent := self stepFrom: self extent to: w@0].			aCanvas drawImage: outerForm at: self position.	box := Rectangle center: self center extent: boxExtent.	aCanvas drawImage: innerForm at: box topLeft sourceRect: (box translateBy: self position negated).	((box expandBy: 1) areasOutside: box) do:		[:r | aCanvas fillRectangle: r color: Color black].! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'nk 1/1/2004 22:32'!convertFontName: aName	"Break apart aName on case boundaries, inserting hyphens as needed."	| lastCase |	lastCase := aName first isUppercase.	^ String streamContents: [ :s |		aName do: [ :c | | thisCase |			thisCase := c isUppercase.			(thisCase and: [ lastCase not ]) ifTrue: [ s nextPut: $- ].			lastCase := thisCase.			s nextPut: c ]]! !!PartsBin class methodsFor: 'thumbnail cache' stamp: 'sw 10/24/2001 15:29'!thumbnailForPartsDescription: aPartsDescription	"Answer a thumbnail for the given parts description creating it if necessary.  If it is created afresh, it will also be cached at this time"	| aThumbnail aSymbol |	aSymbol := aPartsDescription formalName asSymbol.	^ Thumbnails at: aSymbol ifAbsent:		[aThumbnail := Thumbnail new makeThumbnailFromForm: aPartsDescription sampleImageForm.		self cacheThumbnail: aThumbnail forSymbol: aSymbol.		^ aThumbnail]"PartsBin initialize"! !!WorldWindow class methodsFor: 'as yet unclassified' stamp: 'di 11/17/1999 11:39'!test2	"WorldWindow test2."	| window world scrollPane |	world := WiWPasteUpMorph newWorldForProject: nil.	window := (WorldWindow labelled: 'Scrollable World') model: world.	window addMorph: (scrollPane := TwoWayScrollPane new model: world)		frame: (0@0 extent: 1.0@1.0).	scrollPane scroller addMorph: world.	world hostWindow: window.	window openInWorld! !!PostscriptCanvas methodsFor: 'private' stamp: 'di 8/12/2000 09:42'!drawPostscriptContext: subCanvas	| contents |	(contents := subCanvas contents) ifNil: [^ self].	^ target comment: ' sub-canvas start';		preserveStateDuring: [:inner | inner print: contents];		comment: ' sub-canvas stop'.	! !!FancyMailComposition methodsFor: 'access' stamp: 'RAA 5/19/2000 19:02'!to: x	to := x.		self changed: #to.	^true	! !!BasicButton methodsFor: 'as yet unclassified' stamp: 'sw 6/16/1998 16:49'!label	| s |	s := ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s := m contents]].	^ s! !!FatBitsPaint methodsFor: 'menu' stamp: 'RAA 9/28/1999 13:03'!revert"since WarpBits may mangle an 8-bit ColorForm, make it 32 first"        self form: ((formToEdit asFormOfDepth: 32)                 magnify: formToEdit boundingBox                 by: magnification                 smoothing: 1).        brush := Pen newOnForm: originalForm.        brush squareNib: brushSize.        brush color: brushColor! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'mpw 8/10/1930 21:02'!subCanvas:patchRect	subCanvas ifNil:		[ subCanvas := PostscriptCanvas new reset setOrigin:patchRect topLeft clipRect:(-10000@-10000 extent:20000@20000)].	^subCanvas.! !!StringButtonMorph methodsFor: 'copying' stamp: 'jm 7/28/97 11:55'!updateReferencesUsing: aDictionary	"If the arguments array points at a morph we are copying, then point at the new copy.  And also copies the array, which is important!!"	super updateReferencesUsing: aDictionary.	arguments := arguments collect:		[:old | aDictionary at: old ifAbsent: [old]].! !!ThumbnailMorph methodsFor: 'stepping and presenter' stamp: 'nk 6/14/2004 16:47'!step	"Optimization: Don't redraw if we're viewing some kind of SketchMorph and its rotated Form hasn't changed."	| viewee f |	viewee := self actualViewee.	viewee ifNil: [ self stopStepping. ^self ].	(viewee isSketchMorph) ifTrue: [		f := viewee rotatedForm.		f == lastSketchForm ifTrue: [^ self].		lastSketchForm := f].	self changed.! !!SoundEventMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/7/2000 13:01'!sound: aSound	sound := aSound.	self setBalloonText: 'a sound of duration ',(sound duration roundTo: 0.1) printString,' seconds'.! !!ScaleMorph methodsFor: 'accessing' stamp: 'RCS 3/15/2000 21:46'!minorTickLength: anInteger	minorTickLength := anInteger.! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/24/1999 18:13'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component. Used by scrollIntoView:"	| r newOffset |	newOffset := (scroller offset - delta max: 0@0) min: self leftoverScrollRange.	scroller offset: newOffset.	r := self leftoverScrollRange.	r y = 0		ifTrue: [yScrollBar value: 0.0]		ifFalse: [yScrollBar value: newOffset y asFloat / r y].	r x = 0		ifTrue: [xScrollBar value: 0.0]		ifFalse: [xScrollBar value: newOffset x asFloat / r x].! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'tk 8/22/2000 11:56'!init4	"Just a record of how Ted loaded in the paintbox button images, Feb 98"| bb im pp newImage pic24Bit picNewBit blt |"self loadoffImage: 'roundedPalette3.bmp'."pic24Bit := GIFReadWriter formFromServerFile: 'updates/137roundedPalette3.bmp'.picNewBit := Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.OriginalBounds := picNewBit boundingBox.AllOffImage := Form extent: OriginalBounds extent depth: 16.blt := BitBlt current toForm: AllOffImage.blt sourceForm: picNewBit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0@0; copyBits.AllOffImage mapColor: Color transparent to: Color black.self image: AllOffImage.self invalidRect: bounds.self submorphsDo: [:button | button position: button position + (10@10)].(im := submorphs at: 28) class == ImageMorph ifTrue: [	im position: im position + (2@0)].	"color picker""exercise it once"(bb := self submorphNamed: #keep:) position: bb position + (0@25).(bb := self submorphNamed: #toss:) position: bb position + (0@25).(bb := self submorphNamed: #undo:) position: bb position + (0@-25).(bb := self submorphNamed: #clear:) position: bb position + (0@-25).(bb := self submorphNamed: #undo:) position: bb position + (0@-69).(bb := self submorphNamed: #clear:) position: bb position + (0@-69).self submorphsDo: [:button | 	button class == AlignmentMorph ifTrue: [		button position: button position + (0@25)].	(button printString includesSubString: 'stamp:') ifTrue: [		button position: button position + (0@25)]].(bb := self submorphNamed: #prevStamp:) position: bb position + (0@25).(bb := self submorphNamed: #nextStamp:) position: bb position + (0@25).bb := self submorphNamed: #keep:.newImage := bb pressedImage copy: (0@4 corner: (bb pressedImage boundingBox extent)).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (4@1).pp := (bb := self submorphNamed: #toss:) pressedImage.newImage := pp copy: (0@4 corner: (bb pressedImage extent - (3@0))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@1).pp := (bb := self submorphNamed: #undo:) pressedImage.newImage := pp copy: (0@0 corner: (bb pressedImage extent - (3@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pp := (bb := self submorphNamed: #clear:) pressedImage.newImage := pp copy: (0@0 corner: (bb pressedImage extent - (0@5))).bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.bb position: bb position + (3@-1).pic24Bit := GIFReadWriter formFromServerFile: 'updates/137pencil.bmp'.picNewBit := Form extent: pic24Bit extent depth: 16.pic24Bit displayOn: picNewBit.newImage := picNewBit as8BitColorForm.newImage transparentColor: (Color r: 0 g: 0 b: 0).(bb := self submorphNamed: #erase:) pressedImage: newImage; onImage: newImage;	extent: newImage extent.bb position: bb position + (-11@-1).! !!ZoomAndScrollMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:32'!initialize	"initialize the state of the receiver"	super initialize.	""	usingBalloon := true.	self createInteriorTransform ! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/8/2000 16:22'!setScaledValue: aNumber	| denom |	(denom := maxVal - minVal) > 0		ifTrue:			[self setValue: (aNumber - minVal) / denom]		ifFalse:			[self setValue: maxVal]	"If minVal = maxVal, that value is the only one this (rather unuseful!!) slider can bear"! !!InternalThreadNavigationMorph methodsFor: 'sorting' stamp: 'dgd 9/19/2003 15:27'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| nameOfThisProject cachedData proj |	threadName isEmpty ifTrue: [threadName := 'I need a name' translated].	threadName := FillInTheBlank 		request: 'Name this thread.' translated 		initialAnswer: threadName.	threadName isEmptyOrNil ifTrue: [^self].	listOfPages := OrderedCollection new.	aHolder submorphs doWithIndex: [:m :i |		(nameOfThisProject := m valueOfProperty: #nameOfThisProject) ifNotNil: [			cachedData := {nameOfThisProject}.			proj := Project named: nameOfThisProject.			(proj isNil or: [proj thumbnail isNil]) ifFalse: [				cachedData := cachedData, {proj thumbnail scaledToSize: self myThumbnailSize}.			].			listOfPages add: cachedData.		].	].	self class know: listOfPages as: threadName.	self removeAllMorphs; addButtons.	self world ifNil: [		self openInWorld; positionAppropriately.	].! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'di 2/17/98 11:05'!saveSound: evt	| newName |	newName := FillInTheBlank request: 'Please confirm name for save...'						initialAnswer: soundName.	newName isEmpty ifTrue: [^ self].	AbstractSound soundNamed: newName put: sound.	soundName := newName.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'mir 11/15/2004 10:25'!publishStyle: aSymbol forgetURL: aBoolean withRename: renameBoolean	| w saveOwner primaryServer rename |	w := self world ifNil: [^Beeper beep].	w setProperty: #SuperSwikiPublishOptions toValue: aSymbol.	primaryServer := w project primaryServerIfNil: [nil].	rename := ((primaryServer notNil		and: [primaryServer acceptsUploads]) not)		or: [renameBoolean].	w setProperty: #SuperSwikiRename toValue: rename.	saveOwner := owner.	self delete.	[w project 		storeOnServerShowProgressOn: self 		forgetURL: aBoolean | rename]		ensure: [saveOwner addMorphFront: self]! !!EventRecorderMorph methodsFor: 'commands' stamp: 'RAA 6/14/2001 16:42'!record	self isInWorld ifFalse: [^ self].	self stop.	self writeCheck.	self addJournalFile.	tapeStream := WriteStream on: (Array new: 10000).	self resumeRecordIn: self world.	self setStatusLight: #nowRecording.! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 13:32'!pageRectangles	| pageBounds allPageRects maxExtent |	geeMail ifNotNil: [		allPageRects := geeMail pageRectanglesForPrinting.		allPageRects ifNotNil: [			maxExtent := allPageRects inject: 0@0 into: [ :max :each |				max max: each extent			].			computedBounds := 0@0 extent: maxExtent.			^allPageRects		].	].	pageBounds := self bounds.	allPageRects := OrderedCollection new.	[pageBounds top <= pasteUp bottom] whileTrue: [		allPageRects add: pageBounds.		pageBounds := pageBounds translateBy: 0 @ pageBounds height.	].	^allPageRects! !!ObjectsTool methodsFor: 'search' stamp: 'sw 6/30/2001 14:26'!searchPaneCharacter: evt	"A character represented by the event handed in was typed in the search pane by the user"	^ self showMorphsMatchingSearchString"	| char |  *** The variant below only does a new search if RETURN or ENTER is hit ***	char := evt keyCharacter.	(char == Character enter or: [char == Character cr]) ifTrue:		[self showMorphsMatchingSearchString]"! !!PostscriptCanvas methodsFor: 'private' stamp: ''!setColor: color      currentColor ~= color ifTrue:[          target write:color asColor.		currentColor := color.	].! !!GradientFillMorph methodsFor: 'as yet unclassified' stamp: 'jm 11/5/97 12:40'!gradientFillColor: aColor	fillColor2 := aColor.	self changed.! !!BookMorph methodsFor: 'navigation' stamp: 'sw 11/8/2002 13:31'!goToPage: pageNumber transitionSpec: transitionSpec runTransitionScripts: aBoolean	"Go the the given page number; use the transitionSpec supplied, and if the boolean parameter is true, run opening and closing scripts as appropriate"	| pageMorph |	pages isEmpty ifTrue: [^ self].	pageMorph := (self hasProperty: #dontWrapAtEnd)		ifTrue: [pages atPin: pageNumber]		ifFalse: [pages atWrap: pageNumber].	^ self goToPageMorph: pageMorph transitionSpec: transitionSpec runTransitionScripts: aBoolean! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'di 1/4/1999 13:39'!page: aMorph	page := aMorph.	self computeThumbnail.	self setNameTo: aMorph externalName.	page fullReleaseCachedState.! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'sw 10/12/2004 05:04'!findAgain	"Look for the next occurrence of the search string"	| toFind searchIndex |	lastSearchString ifNil: [lastSearchString := 'controls'].	searchIndex := currentIndex + 1.	searchIndex > entryNames size ifTrue:		[currentIndex := 0.		self inform: 'not found' translated.		^ self].	toFind := '*', lastSearchString, '*'.	[toFind match: (entryNames at: searchIndex) asString]		whileFalse:			[searchIndex := (searchIndex \\ entryNames size) + 1.			searchIndex == currentIndex ifTrue:				[^ (toFind match: (entryNames at: searchIndex) asString)					ifFalse:						[self inform: 'not found' translated]					ifTrue:						[self flash]]].	currentIndex := searchIndex.	self updateThumbnail! !!PostscriptCanvas methodsFor: 'drawing-support' stamp: 'nk 4/1/2004 19:52'!preserveStateDuring: aBlock	| retval saveClip saveTransform |	target preserveStateDuring: [ :innerTarget |		saveClip := clipRect.		saveTransform := currentTransformation.		gstateStack addLast: currentFont.		gstateStack addLast: currentColor.		gstateStack addLast: shadowColor.		retval := aBlock value: self.		shadowColor := gstateStack removeLast.		currentColor := gstateStack removeLast.		currentFont := gstateStack removeLast.		clipRect := saveClip.		currentTransformation := saveTransform.	].	^ retval! !!ThumbnailMorph methodsFor: 'caching' stamp: 'ar 3/3/2001 19:37'!releaseCachedState	super releaseCachedState.	lastSketchForm := lastFormShown := nil.! !!LedTimerMorph methodsFor: 'accessing' stamp: 'djp 10/31/1999 19:02'!resume	counting ifFalse: [		counting := true.		startSeconds :=  (Time totalSeconds) - self value]! !!ScrollingToolHolder methodsFor: 'as yet unclassified' stamp: 'tk 7/17/97 09:59'!stampForm: stampForm for: aPickupButton	"Install this form to stamp. Find its index.  Make a thumbnail."	| which scale shrunkForm stampBtn mini |	which := pickupButtons indexOf: aPickupButton.	which = 0 ifTrue: [which := stampButtons indexOf: aPickupButton].	stamps atWrap: which+start-1 put: stampForm.	"Create the thumbnail"	stampBtn := stampButtons at: which.	scale := stampBtn width / (stampForm extent x max: stampForm extent y).	scale := scale min: 1.0.	"do not expand it"	mini := stampForm magnify: stampForm boundingBox by: scale smoothing: 1.	shrunkForm := mini class extent: stampBtn extent depth: stampForm depth.	mini displayOn: shrunkForm at: (stampBtn extent - mini extent)//2.	thumbnailPics atWrap: which+start-1 put: shrunkForm.	stampBtn offImage: shrunkForm; onImage: shrunkForm; pressedImage: shrunkForm.		"Emphasis is done by border of enclosing layoutMorph, not modifying image"	(stamps indexOf: nil) = 0 ifTrue: ["Add an extra blank place"		"Keep stamp we just installed in the same location!!"		start+which-1 > stamps size ifTrue: [start := start + 1].		stamps addLast: nil.		thumbnailPics addLast: nil.		self normalize].! !!TrashCanMorph methodsFor: 'private' stamp: 'jm 5/22/1998 10:13'!showStampIn: aHand	"If painting and in stamp mode, show the stamp that is about to be thrown away."	| paintBox curs |	paintBox := self findActivePaintBox.	paintBox ifNotNil: [		"See if a stamp is being dropped into the trash. It is not actually held by the hand."		paintBox getSpecial == #stamp: ifTrue: [			curs := paintBox actionCursor.			aHand showTemporaryCursor: curs hotSpotOffset: curs center]].! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'RAA 11/8/2000 09:53'!buttonPaint	| pb oldArgs brush myButton m |	myButton := self makeButton: '' balloonText: 'Make a painting' for: #doNewPainting.	pb := PaintBoxMorph new submorphNamed: #paint:.	pb ifNil: [		(brush := Form extent: 16@16 depth: 16) fillColor: Color red	] ifNotNil: [		oldArgs := pb arguments.		brush := oldArgs third.		brush := brush copy: (2@0 extent: 42@38).		brush := brush scaledToSize: brush extent // 2.	].	myButton addMorph: (m := brush asMorph lock).	myButton extent: m extent + (myButton borderWidth + 6).	m position: myButton center - (m extent // 2).	^myButton"brush := (ScriptingSystem formAtKey: 'Painting')."! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'yo 3/14/2005 13:09'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:47'!value: aNumber	| val |	value := aNumber.	val := value.	submorphs reverseDo:		[:m |		m digit: val \\ 10.		val := val // 10].	self changed.! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:27'!fractionalLoopStartAt: index	"Answer the fractional index starting point near the given integral index that results in the closest match with the cycle following the loop end."	"Note: could do this more efficiently by sliding downhill on the error curve to find lowest error."	| oneCycle w1 minErr w2 err bestIndex |	oneCycle := (samplingRate / perceivedFrequency) rounded.	w1 := self interpolatedWindowAt: loopEnd + 1 width: oneCycle.	minErr := SmallInteger maxVal.	((index - 2) max: 1) to: ((index + 2) min: graph data size) by: 0.01 do: [:i |		w2 := self interpolatedWindowAt: i width: oneCycle.		err := self errorBetween: w1 and: w2.		err < minErr ifTrue: [			bestIndex := i.			minErr := err]].	^ bestIndex! !!FlexMorph methodsFor: 'caching' stamp: 'di 1/11/1999 19:44'!releaseCachedState	"Clear cache of rotated, scaled Form."	originalForm := Form extent: 10@10.  "So super hibernate won't have to work hard												but won't crash either."	super releaseCachedState.	rotatedForm := nil.	originalForm := nil.! !!Command methodsFor: 'copying' stamp: 'tk 2/25/2001 17:53'!veryDeepInner: deepCopier	"ALL fields are weakly copied!!  Can't duplicate an object by duplicating a Command that involves it.  See DeepCopier."	super veryDeepInner: deepCopier.	"just keep old pointers to all fields"	parameters := parameters.! !!GeeMailMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/5/2001 11:15'!makeBookStyle: nColumns	| all totalWidth second columnWidth currY prev columnHeight currX currColumn pageBreakRectangles r rm columnGap pageGap starter |	pageBreakRectangles := OrderedCollection new.	all := thePasteUp allTextPlusMorphs.	all size = 1 ifFalse: [^self].	Cursor wait show.	starter := prev := all first.	totalWidth := self width - 16.	columnGap := 32.	pageGap := 16.	columnWidth := totalWidth - (columnGap * (nColumns - 1)) // nColumns.	columnHeight := self height - 12.	currY := 4.	currX := 4.	currColumn := 1.	prev		position: currX@currY;		width: columnWidth.	[		second := prev makeSuccessorMorph.		thePasteUp addMorphBack: second.		prev 			setProperty: #autoFitContents toValue: false;			height: columnHeight.		(currColumn := currColumn + 1) <= nColumns ifTrue: [			currX := currX + columnWidth + columnGap.		] ifFalse: [			r := 4@(prev bottom + 4) corner: (self right - 4 @ (prev bottom + pageGap - 4)).			rm := RectangleMorph new bounds: r; color: (Color gray alpha: 0.3); borderWidth: 0.			pageBreakRectangles add: rm beSticky.			thePasteUp addMorphBack: rm.			currColumn := 1.			currX := 4.			currY := prev bottom + pageGap.		].		second 			autoFit: true;			position: currX@currY;			width: columnWidth.		prev recomposeChain.		"was commented"		prev := second.		prev height > columnHeight	] whileTrue.	prev autoFit: true.	thePasteUp height: (prev bottom + 20 - self top).	self layoutChanged.	self setProperty: #pageBreakRectangles toValue: pageBreakRectangles.	thePasteUp allTextPlusMorphs do: [ :each |		each repositionAnchoredMorphs	].	Cursor normal show.! !!URLMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	"Draw thumbnail for my page, if it is available. Otherwise, just draw a rectangle." | thumbnail oldExt |color == Color transparent 	ifTrue: ["show thumbnail"		thumbnail := self thumbnailOrNil.		thumbnail			ifNil: [aCanvas frameRectangle: bounds width: borderWidth 						color: borderColor.				aCanvas fillRectangle: (bounds insetBy: borderWidth) color: color]			ifNotNil: [oldExt := bounds extent.				bounds := bounds origin extent: thumbnail extent + (2@2).				aCanvas frameRectangle: bounds width: borderWidth color: borderColor.				aCanvas paintImage: thumbnail at: bounds origin + borderWidth.				oldExt = thumbnail extent ifFalse: [self layoutChanged]]]	ifFalse: ["show labeled button"		^ super drawOn: aCanvas]! !!TickIndicatorMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:59'!initialize	"initialize the state of the receiver"	super initialize.	""	self extent: 20 @ 20.	index := 0! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'jm 6/18/1999 18:58'!loadColorChooser	"Load Forms for ColorMemoryMorph."	| doc closedForm openForm |	doc := Utilities objectStrmFromUpdates: 'colorPalClosed.obj'.	closedForm := doc fileInObjectAndCode mapColor: Color transparent to: Color black.	doc := Utilities objectStrmFromUpdates: 'colorPalOpen.obj'.	openForm := doc fileInObjectAndCode mapColor: Color transparent to: Color black.	colorMemoryThin image: closedForm.	colorMemoryThin position: self position + (0@140).	colorMemory delete.	"delete old one"	colorMemory := PaintBoxColorPicker new image: openForm.! !!EnvelopeEditorMorph methodsFor: 'construction' stamp: 'di 9/4/1998 15:56'!buildGraphAreaIn: frame	| r y |	graphArea := RectangleMorph		newBounds: ((frame left + 40) @ (frame top + 40)		corner: (frame right+1) @ (frame bottom - 60))		color: Color lightGreen lighter lighter.	graphArea borderWidth: 1.	self addMorph: graphArea.	(envelope updateSelector = #pitch: and: [envelope scale <= 2.0]) ifTrue:		["Show half-steps"		r := graphArea innerBounds.		0.0 to: 1.0 by: 1.0/12.0/envelope scale do:			[:val |			y := self yFromValue: val.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].	(envelope updateSelector = #ratio: and: [denominator ~= 9999]) ifTrue:		["Show denominator gridding"		r := graphArea innerBounds.		(0.0 to: 1.0 by: 1.0/denominator/envelope scale) do:			[:v |			y := self yFromValue: v.			graphArea addMorph: ((RectangleMorph					newBounds: (r left@y extent: r width@1)					color: Color veryLightGray)						borderWidth: 0)]].! !!ReferenceMorph methodsFor: 'menu' stamp: 'sw 10/24/2000 14:39'!useTextualTab	"Use a textually-emblazoned tab"	| aLabel stringToUse font aColor |	self preserveDetails.	stringToUse := self valueOfProperty: #priorWording ifAbsent: [self externalName].	font := self valueOfProperty: #priorFont ifAbsent: [Preferences standardButtonFont].	aColor := self valueOfProperty: #priorColor ifAbsent: [Color green darker].	aLabel := StringMorph contents: stringToUse font: font.	self replaceSubmorph: submorphs first by: aLabel.	aLabel position: self position.	self color: aColor.	aLabel highlightColor: self highlightColor; regularColor: self regularColor.	aLabel lock.	self fitContents.	self layoutChanged.	(owner isKindOf: IndexTabs) ifTrue:		[self borderWidth: 0.		owner laySubpartsOutInOneRow.		isHighlighted ifTrue:			[self highlight]]! !!ObjectsTool methodsFor: 'search' stamp: 'nk 9/3/2004 10:39'!setSearchStringFromSearchPane	"Set the search string by obtaining its contents from the search pane, and doing a certain amount of munging"	searchString := self searchPane text string asLowercase withBlanksTrimmed.	searchString := searchString copyWithoutAll: {Character enter. Character cr}! !!ListComponent methodsFor: 'components' stamp: 'di 5/1/1998 13:38'!initPinSpecs 	pinSpecs := Array		with: (PinSpec new pinName: 'list' direction: #input				localReadSelector: nil localWriteSelector: nil				modelReadSelector: getListSelector modelWriteSelector: nil				defaultValue: #(one two three) pinLoc: 1.5)		with: (PinSpec new pinName: 'index' direction: #inputOutput				localReadSelector: nil localWriteSelector: nil				modelReadSelector: getIndexSelector modelWriteSelector: setIndexSelector				defaultValue: 0 pinLoc: 2.5)		with: (PinSpec new pinName: 'selectedItem' direction: #output				localReadSelector: nil localWriteSelector: nil				modelReadSelector: nil modelWriteSelector: setSelectionSelector				defaultValue: nil pinLoc: 3.5)! !!SquishedNameMorph methodsFor: 'drawing' stamp: 'RAA 11/11/2000 23:17'!drawOn: aCanvas	| font stringToShow nameForm rectForName |	super drawOn: aCanvas.	self isEditingName ifTrue: [^self].	font := self fontForName.	stringToShow := self stringToShow.	nameForm := (StringMorph contents: stringToShow font: font) imageForm.	nameForm := nameForm scaledToSize: (self extent - (4@2) min: nameForm extent).	rectForName := self bottomLeft + 			(self width - nameForm width // 2 @ (nameForm height + 2) negated)				extent: nameForm extent.	rectForName topLeft eightNeighbors do: [ :pt |		aCanvas			stencil: nameForm 			at: pt			color: self colorAroundName.	].	aCanvas		stencil: nameForm 		at: rectForName topLeft 		color: Color black.	! !!GeePrinter methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 13:37'!allPages	| pageNumber allPages maxPages |	maxPages := 9999.	pageNumber := 0.	allPages := self pageRectangles collect: [ :rect |		pageNumber := pageNumber + 1.		(self as: GeePrinterPage) pageNumber: pageNumber bounds: rect	].	allPages size > maxPages ifTrue: [allPages := allPages first: maxPages].	allPages do: [ :each | each totalPages: allPages size].	^allPages! !!TwoWayScrollPane methodsFor: 'geometry' stamp: 'RAA 8/21/1999 10:17'!scrollIntoView: desiredRectangle extra: anumber	| shift |	shift := desiredRectangle deltaToEnsureInOrCentered: (		scroller offset extent: scroller bounds extent	)  extra: anumber.	shift = (0 @ 0) ifFalse: [self scrollBy: (0@0) - shift].! !!FatBitsPaint methodsFor: 'menu' stamp: 'nk 4/18/2004 19:04'!selectionMenu: evt        | menu |         (menu := MenuMorph new)                addTitle: 'Edit';                addStayUpItem.        {                {'edit separately'. #editSelection}.                {'copy'. #copySelection}.                {'cut'. #cutSelection}.                {'paste'. #pasteSelection}        } do: [:each |                menu add: each first                        target: self                        selector: each second                        argumentList: #()].        menu toggleStayUp: evt.        menu popUpEvent: evt in: self world! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'di 11/26/1999 11:46'!openWorld	| w |	(w := MVCWiWPasteUpMorph newWorldForProject: nil).	w bounds: (0@0 extent: 400@300).	self openOn: w		label: 'A Morphic World'		extent: w fullBounds extent + 2.! !!PaintBoxMorph class methodsFor: 'class initialization' stamp: 'tk 8/21/2000 12:58'!initialize	"PaintBoxMorph initialize"	Prototype eventHandler: nil.	Prototype focusMorph: nil.	Prototype stampHolder clear.  "clear stamps"	Prototype delete.  "break link to world, if any"	AllOnImage := AllOffImage := AllPressedImage := nil.	OriginalBounds := nil.! !!AtomMorph methodsFor: 'initialization' stamp: 'RAA 12/15/2000 07:32'!randomPositionIn: aRectangle maxVelocity: maxVelocity	"Give this atom a random position and velocity."	| origin extent |	origin := aRectangle origin.	extent := (aRectangle extent - self bounds extent) rounded.	self position:		(origin x + extent x atRandom) @		(origin y + extent y atRandom).	velocity :=		(maxVelocity - (2 * maxVelocity) atRandom) @		(maxVelocity - (2 * maxVelocity) atRandom).! !!LedTimerMorph methodsFor: 'accessing' stamp: 'djp 10/31/1999 19:36'!continue	counting := true! !!PostscriptCanvas methodsFor: 'private' stamp: 'nk 1/2/2004 15:34'!defineFont: aFont	| psNameFor alreadyRemapped |	(usedFonts includesKey: aFont) ifFalse:[		psNameFor := self postscriptFontNameForFont: aFont.		alreadyRemapped := usedFonts includes: psNameFor.		usedFonts at: aFont put: psNameFor.		" here: define as Type-3 unless we think its available "		" or, just remap"		" I had some problems if same font remapped twice"		alreadyRemapped ifFalse: [target remapFontForSqueak: psNameFor].	].! !!BookPageThumbnailMorph methodsFor: 'as yet unclassified' stamp: 'tk 2/24/1999 00:01'!computeThumbnail	| f scale |	self objectsInMemory.	f := page imageForm.	scale := (self height / f height).  "keep height invariant""(Sensor shiftPressed) ifTrue: [scale := scale * 1.4]."	self form: (f magnify: f boundingBox by: scale@scale smoothing: 2).! !!Command class methodsFor: 'dog simple ui' stamp: 'ar 11/9/2000 20:38'!undoRedoButtons	"Answer a morph that offers undo and redo buttons"	| aButton wrapper |	"self currentHand attachMorph: Command undoRedoButtons"	wrapper := AlignmentMorph newColumn.	wrapper color: Color veryVeryLightGray lighter;		borderWidth: 0;		layoutInset: 0;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap.	#((CrudeUndo undoLastCommand 'undo last command done' undoEnabled CrudeUndoDisabled CrudeUndoDisabled) 	(CrudeRedo redoNextCommand 'redo last undone command' redoEnabled CrudeRedoDisabled CrudeRedoDisabled)) do:		[:tuple |			wrapper addTransparentSpacerOfSize: (8@0).			aButton := UpdatingThreePhaseButtonMorph new.			aButton				onImage: (ScriptingSystem formAtKey: tuple first);				offImage: (ScriptingSystem formAtKey: tuple fifth);				pressedImage: (ScriptingSystem formAtKey: tuple sixth);				getSelector: tuple fourth;				color: Color transparent; 				target: self;				actionSelector: tuple second;				setNameTo: tuple second;				setBalloonText: tuple third;				extent: aButton onImage extent.			wrapper addMorphBack: aButton.			wrapper addTransparentSpacerOfSize: (8@0)].	^ wrapper! !!SqueakPageCache class methodsFor: 'cache access' stamp: 'tk 10/20/1998 15:51'!atURL: aURLString oldPage: aPage	"Bring in page and return the object.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| myPage |	(myPage := PageCache at: aURLString ifAbsent: [nil]) ifNotNil: [		^ myPage].	aPage url: aURLString.	"for consistancy"	PageCache at: aPage url put: aPage.	^ aPage! !!FatBitsPaint methodsFor: 'events' stamp: 'sw 3/30/2002 16:47'!mouseMovePaintBrushMode: evt        | p p2 |        p := self pointGriddedFromEvent: evt.        lastMouse = p ifTrue: [^ self].        lastMouse ifNil: [lastMouse := p].  "first point in a stroke"        "draw etch-a-sketch style-first horizontal, then vertical"        p2 := p x@lastMouse y.        brush drawFrom: lastMouse to: p2.        brush drawFrom: p2 to: p.                                self revealPenStrokes.        lastMouse := p! !!ScaleMorph methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		labelsAbove ifNil: [labelsAbove := true].	captionAbove ifNil: [captionAbove := true].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ScreeningMorph methodsFor: 'initialization' stamp: 'panda 4/25/2000 15:42'!initialize	super initialize.	passingColor := Color black.	passElseBlock := true.	displayMode := #showScreened.	self enableDragNDrop! !!LedMorph methodsFor: 'accessing' stamp: 'kfr 6/12/2000 15:29'!string: aString 	string := aString.	chars = 0		ifTrue: 			[chars := string size.			self chars: chars].	self stringToLed! !!InternalThreadNavigationMorph methodsFor: 'navigation' stamp: 'dao 10/1/2004 13:36'!threadOfNoProjects	| nameList nav |	nameList := { {Project current name} }.	nav := self class basicNew.	nav		listOfPages: nameList;		threadName: '' index: nil;		initialize.	nav editThisThread.! !!FunctionComponent methodsFor: 'as yet unclassified' stamp: 'di 5/4/1998 08:56'!addPin 	| i prev sideLength wasNew |	wasNew := self getText = textMorph asText.	i := pinSpecs size.	prev := pinSpecs last.	sideLength := prev pinLoc asInteger odd ifTrue: [self height] ifFalse: [self width].	pinSpecs := pinSpecs copyWith:		(PinSpec new pinName: ('abcdefghi' copyFrom: i to: i) direction: #input				localReadSelector: nil localWriteSelector: nil				modelReadSelector: nil modelWriteSelector: nil				defaultValue: nil pinLoc: prev pinLoc + (8/sideLength) asFloat \\ 4).	self initFromPinSpecs.	self addPinFromSpec: pinSpecs last.	wasNew ifTrue: [self setText: self getText].	self accept	! !!TabMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/2/1998 15:38'!morphToInstall: m	morphToInstall := m.	self contents: m externalName.	self actionSelector: #tabSelected.	self target: self! !!InternalThreadNavigationMorph methodsFor: 'private' stamp: 'dao 10/1/2004 13:36'!currentIndex	| currentName |	currentName := Project current name.	listOfPages withIndexDo: [ :each :index |		(each first = currentName and: [preferredIndex = index]) ifTrue: [^currentIndex := index]	].	listOfPages withIndexDo: [ :each :index |		each first = currentName ifTrue: [^currentIndex := index]	].		currentIndex isNil		ifTrue: [^ 1].	^ currentIndex min: listOfPages size! !!SoundLoopMorph methodsFor: 'playing' stamp: 'jm 11/14/97 11:21'!doControl	seqSound doControl.	controlIndex := controlIndex + 1.	controlIndex >= (self controlRate * (self innerBounds width // 128))		ifTrue: [controlIndex := 0].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'jm 1/29/98 14:08'!clearTarget	target := nil.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'RAA 5/6/2001 15:15'!addColumnBreak	| ed old new break |	ed := self editor.	old := ed selection.	break := TextComposer characterForColumnBreak asString.	break := Text string: break attributes: {}.	new := old ,break.	ed replaceSelectionWith: new.	self releaseParagraphReally.	self layoutChanged.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'tk 4/3/97'!setRotations: num	"Tell the palette what number of rotations (or background) to show.  "	| key |	key := 'ItTurns'.	"default and value for num > 1"	num == 1 ifTrue: [key := 'JustAsIs'].	num == 18 ifTrue: [key := 'ItTurns'].	num == 99 ifTrue: [key := 'ToAndFro'].	num == #Background ifTrue: [key := 'Background'].	num == #Repeated ifTrue: [key := 'Repeated'].	palette setRotations: (palette contentsAtKey: key).! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'RAA 12/3/2000 11:45'!runAScript	| d names reply |	d := self targetScriptDictionary.	names := d keys asSortedCollection.	reply := (SelectionMenu labelList: names selections: names) startUpWithCaption: 'Script to run?'.	reply ifNil: [^ self].	programmedMoves := (d at: reply) veryDeepCopy.! !!Command methodsFor: 'initialization' stamp: 'di 8/30/2000 20:53'!redoTarget: target selector: selector arguments: arguments	"Give target morph a chance to refine its undo operation"	target refineRedoTarget: target selector: selector arguments: arguments in:		[:rTarget :rSelector :rArguments |		redoTarget := rTarget.		redoSelector := rSelector.		redoArguments := rArguments]! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:02'!playFrom: start to: end	| sz i1 i2 snd |	sz := graph data size.	i1 := ((start + 1) min: sz) max: 1.	i2 := ((end + 1) min: sz) max: i1.	(i1 + 2) >= i2 ifTrue: [^ self].	snd := SampledSound		samples: (graph data copyFrom: i1 to: i2)		samplingRate: samplingRate.	snd play.! !!ObjectsTool methodsFor: 'major modes' stamp: 'dgd 4/4/2006 16:47'!modeTabs	"Answer a list of buttons which, when hit, will trigger the choice of mode of the receiver"	| buttonList aButton tupleList |	tupleList :=  #(		('alphabetic'		alphabetic	showAlphabeticTabs	'A separate tab for each letter of the alphabet')		('find'				search			showSearchPane			'Provides a type-in pane allowing you to match')		('categories'		categories	showCategories			'Grouped by category')		"('standard'		standard		showStandardPane		'Standard Squeak tools supplies for building')"	).					buttonList := tupleList collect:		[:tuple |			aButton := SimpleButtonMorph new label: tuple first translated.			aButton actWhen: #buttonUp.			aButton setProperty: #modeSymbol toValue: tuple second.			aButton target: self; actionSelector: tuple third.			aButton setBalloonText: tuple fourth translated.			aButton borderWidth: 0.			aButton].	^ buttonList"ObjectsTool new modeTabs"! !!WiWPasteUpMorph methodsFor: 'WiW support' stamp: 'dao 10/1/2004 13:39'!restartWorldCycleWithEvent: evt	"redispatch that click in outer world"	pendingEvent := evt.	Project spawnNewProcessAndTerminateOld: true! !!BookPageThumbnailMorph methodsFor: 'fileIn/Out' stamp: 'ar 4/10/2005 18:45'!objectsInMemory	"See if page or bookMorph need to be brought in from a server."	| bookUrl bk wld try |	bookMorph ifNil: ["fetch the page"		page isString ifFalse: [^ self].	"a morph"		try := (SqueakPageCache atURL: page) fetchContents.		try ifNotNil: [page := try].		^ self].	bookMorph isString ifTrue: [		bookUrl := bookMorph.		(wld := self world) ifNil: [wld := Smalltalk currentWorld].		bk := BookMorph isInWorld: wld withUrl: bookUrl.		bk == #conflict ifTrue: [			^ self inform: 'This book is already open in some other project' translated].		bk == #out ifTrue: [			(bk := BookMorph new fromURL: bookUrl) ifNil: [^ self]].		bookMorph := bk].	page isString ifTrue: [		page := (bookMorph pages detect: [:pg | pg url = page] 					ifNone: [bookMorph pages first])].! !!WaveEditor methodsFor: 'initialization' stamp: 'dgd 9/19/2003 12:23'!addControls	| slider bb r m |	r := AlignmentMorph newRow.	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r color: bb color; borderWidth: 0; layoutInset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r wrapCentering: #topLeft.	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'X';					actionSelector: #delete).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: '<>'; actWhen: #buttonDown;															actionSelector: #invokeMenu).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Play' translated;				actionSelector: #play).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Play Before' translated;		actionSelector: #playBeforeCursor).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Play After' translated;			actionSelector: #playAfterCursor).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Play Loop' translated;			actionSelector: #playLoop).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Test' translated;				actionSelector: #playTestNote).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Save' translated;				actionSelector: #saveInstrument).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Set Loop End' translated;		actionSelector: #setLoopEnd).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'One Cycle' translated;			actionSelector: #setOneCycle).	bb := SimpleButtonMorph new target: self; borderColor: Color black.	r addMorphBack: (bb label: 'Set Loop Start' translated;		actionSelector: #setLoopStart).	self addMorphBack: r.	r := AlignmentMorph newRow.	r color: self color; borderWidth: 0; layoutInset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; wrapCentering: #center; cellPositioning: #leftCenter.	m := StringMorph new contents: 'Index: ' translated.	r addMorphBack: m.	m := UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 71; step.	r addMorphBack: m.	m := StringMorph new contents: 'Value: ' translated.	r addMorphBack: m.	m := UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 50; step.	r addMorphBack: m.	slider := SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #scrollTime:.	r addMorphBack: slider.	m := Morph new color: r color; extent: 10@5.  "spacer"	r addMorphBack: m.	m := UpdatingStringMorph new		target: graph; getSelector: #startIndex; putSelector: #startIndex:;		width: 40; step.	r addMorphBack: m.	self addMorphBack: r.! !!PaintBoxMorph methodsFor: 'actions' stamp: 'tk 7/2/97 22:13'!pickupForm: stampForm	"Install the new picture in this stamp"	| stampButton |	stampHolder stampForm: stampForm for: tool.	stampButton := action == #pickup: 		ifTrue: [stampHolder otherButtonFor: tool]		ifFalse: [tool].	"was a nil stampForm"	stampButton state: #on.	stampButton doButtonAction.! !!MIDIControllerMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:37'!initialize"initialize the state of the receiver"	| slider |	super initialize.""	self listDirection: #topToBottom.	self wrapCentering: #center;		 cellPositioning: #topCenter.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	channel := 0.	controller := 7.	"channel volume"	slider := SimpleSliderMorph new target: self;				 actionSelector: #newSliderValue:;				 minVal: 0;				 maxVal: 127;				 extent: 128 @ 10.	self addMorphBack: slider.	self		addMorphBack: (StringMorph contents: 'Midi Controller').	self updateLabel! !!WiWPasteUpMorph methodsFor: 'activation' stamp: 'sw 4/25/2001 01:55'!becomeTheActiveWorldWith: evt	"Make the receiver become the active world, and give its hand the event provided, if not nil"	| outerWorld |	World == self ifTrue: [^ self].	worldState resetDamageRecorder.	"since we may have moved, old data no longer valid"	hostWindow setStripeColorsFrom: Color green.	worldState canvas: nil.	"safer to start from scratch"	displayChangeSignatureOnEntry := Display displayChangeSignature.	"Messy stuff to clear flaps from outer world"	Flaps globalFlapTabsIfAny do: [:f | f changed].	outerWorld := World.	World := self.	self installFlaps.	World := outerWorld.	outerWorld displayWorld.	World := self.	self viewBox: hostWindow panelRect.	self startSteppingSubmorphsOf: self.	self changed.	pendingEvent := nil.	evt ifNotNil: [self primaryHand handleEvent: (evt setHand: self primaryHand)].! !!DescriptionForPartsBin methodsFor: 'initialization' stamp: 'sw 8/2/2001 01:04'!formalName: aName categoryList: aList documentation: aDoc globalReceiverSymbol: aSym nativitySelector: aSel	"Set all of the receiver's instance variables from the parameters provided"	formalName := aName.	categoryList := aList.	documentation := aDoc.	globalReceiverSymbol := aSym.	nativitySelector  := aSel! !!URLMorph methodsFor: 'private' stamp: 'RAA 8/30/2000 11:56'!label: aString font: aFontOrNil	| oldLabel m aFont |	(oldLabel := self findA: StringMorph)		ifNotNil: [oldLabel delete].	(oldLabel := self findA: TextMorph)		ifNotNil: [oldLabel delete].	aFont := aFontOrNil ifNil: [Preferences standardButtonFont].	m := TextMorph new contents: aString; beAllFont: aFont.	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'yo 2/10/2005 15:42'!doPublishButtonMenuEvent: evt	| menu selection |	menu := CustomMenu new.	menu 		add: 'Publish' translated action: [self publishProject];		add: 'Publish As...' translated action: [self publishProjectAs];		add: 'Publish to Different Server' translated action: [self publishDifferent];		add: 'edit project info' translated action: [self editProjectInfo].	selection := menu build startUpCenteredWithCaption: 'Publish options' translated.	selection ifNil: [^self].	selection value.! !SqueakPageCache initialize!ThumbnailMorph initialize!PinMorph initialize!LedDigitMorph initialize!StickyPadMorph initialize!SqueakPage initialize!DropDownChoiceMorph initialize!PartsBin initialize!BooklikeMorph initialize!LedCharacterMorph initialize!PaintBoxMorph initialize!