"Change Set:		8606Tools-nice.151Tools-nice.151:Cosmetic: move or remove a few temps inside closuresTools-nice.150:Cosmetic: move or remove a few temps inside closures"!!Debugger methodsFor: 'toolbuilder' stamp: 'nice 12/27/2009 03:10'!buildNotifierWith: builder label: label message: messageString	| windowSpec listSpec textSpec panelSpec quads |	windowSpec := builder pluggableWindowSpec new.	windowSpec model: self.	windowSpec extent: 450 @ 156. "nice and wide to show plenty of the error msg"	windowSpec label: label.	windowSpec children: OrderedCollection new.	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	quads := self preDebugButtonQuads.	(self interruptedContext selector == #doesNotUnderstand:) ifTrue: [		quads := quads copyWith: 			{ 'Create'. #createMethod. #magenta. 'create the missing method' }	].	quads do:[:spec| | buttonSpec |		buttonSpec := builder pluggableButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		buttonSpec help: spec fourth.		panelSpec children add: buttonSpec.	].	panelSpec layout: #horizontal. "buttons"	panelSpec frame: (0@0 corner: 1@0.2).	windowSpec children add: panelSpec.	Preferences eToyFriendly | messageString notNil ifFalse:[		listSpec := builder pluggableListSpec new.		listSpec 			model: self;			list: #contextStackList; 			getIndex: #contextStackIndex; 			setIndex: #debugAt:; 			frame: (0@0.2 corner: 1@1).		windowSpec children add: listSpec.	] ifTrue:[		message := messageString.		textSpec := builder pluggableTextSpec new.		textSpec 			model: self;			getText: #preDebugMessageString; 			setText: nil; 			selection: nil; 			menu: #debugProceedMenu:;			frame: (0@0.2corner: 1@1).		windowSpec children add: textSpec.	].	^windowSpec! !!CodeHolder methodsFor: 'categories' stamp: 'nice 12/26/2009 09:46'!categoryFromUserWithPrompt: aPrompt for: aClass	"self new categoryFromUserWithPrompt: 'testing' for: SystemDictionary"	|  labels myCategories reject lines newName menuIndex | 	labels := OrderedCollection with: 'new...'.	labels addAll: (myCategories := aClass organization categories asSortedCollection:		[:a :b | a asLowercase < b asLowercase]).	reject := myCategories asSet.	reject		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines := OrderedCollection with: 1 with: (myCategories size + 1).	aClass allSuperclasses do:		[:cls |			| cats |			cats := cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse:				[lines add: labels size.				labels addAll: (cats asSortedCollection:					[:a :b | a asLowercase < b asLowercase]).				reject addAll: cats]].	newName := (labels size = 1 or:		[menuIndex := (UIManager default chooseFrom: labels lines: lines title: aPrompt).		menuIndex = 0 ifTrue: [^ nil].		menuIndex = 1])			ifTrue:				[UIManager default request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: 				[labels at: menuIndex].	^ newName ifNotNil: [newName asSymbol]! !!CodeHolder methodsFor: 'commands' stamp: 'nice 12/26/2009 09:47'!copyUpOrCopyDown	"Used to copy down code from a superclass to a subclass or vice-versa in one easy step, if you know what you're doing.  Prompt the user for which class to copy down or copy up to, then spawn a fresh browser for that class, with the existing code planted in it, and with the existing method category also established."	| aClass aSelector allClasses implementors aMenu |	Smalltalk isMorphic ifFalse: [^ self inform: 'Sorry, for the moment you have to be inMorphic to use this feature.'].	((aClass := self selectedClassOrMetaClass) isNil or: [(aSelector := self selectedMessageName) == nil]) 		ifTrue:	[^ Beeper beep].	allClasses := self systemNavigation hierarchyOfClassesSurrounding: aClass.	implementors := self systemNavigation hierarchyOfImplementorsOf: aSelector forClass: aClass.	aMenu := MenuMorph new defaultTarget: self.	aMenu title: aClass name, '.', aSelector, 'Choose where to insert a copy of this method(blue = current, black = available, red = other implementors'.	allClasses do:		[:cl |			| aColor |			aColor := cl == aClass				ifTrue:	[#blue]				ifFalse:					[(implementors includes: cl)						ifTrue:	[#red]						ifFalse:	[#black]].			(aColor == #red)				ifFalse:					[aMenu add: cl name selector: #spawnToClass: argument: cl]				ifTrue:					[aMenu add: cl name selector: #spawnToCollidingClass: argument: cl].			aMenu lastItem color: (Color colorFrom: aColor)].	aMenu popUpInWorld! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/27/2009 03:10'!selectNewMethods	"Selects all method definitions for which there is no counterpart method in the current image"		Cursor read showWhile: 		[ | change class |1 to: changeList size do:			[:i | change := changeList at: i.			listSelections at: i put:				((change type = #method and:					[((class := change methodClass) isNil) or:						[(class includesSelector: change methodSelector) not]]))]].	self changed: #allSelections! !!Debugger methodsFor: 'context stack menu' stamp: 'nice 12/26/2009 01:30'!mailOutBugReport	"Compose a useful bug report showing the state of the process as well as vital image statistics as suggested by Chris Norton - 'Squeak could pre-fill the bug form with lots of vital, butoft-repeated, information like what is the image version, last updatenumber, VM version, platform, available RAM, author...'and address it to the list with the appropriate subject prefix."	MailSender default ifNil: [^self].	Cursor write		showWhile: 			["Prepare the message"			| messageStrm |			messageStrm := WriteStream on: (String new: 1500).			messageStrm nextPutAll: 'From: ';			 nextPutAll: MailSender userName;			 cr;			 nextPutAll: 'To: squeak-dev@lists.squeakfoundation.org';			 cr;			 nextPutAll: 'Subject: ';			 nextPutAll: '[BUG]'; nextPutAll: self interruptedContext printString;			 cr;cr;			 nextPutAll: 'here insert explanation of what you were doing, suspect changes you''ve made and so forth.';cr;cr.			self interruptedContext errorReportOn: messageStrm.			MailSender sendMessage: (MailMessage from: messageStrm contents)].! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/26/2009 00:38'!removeExistingMethodVersions	"Remove all up to date version of entries from the receiver"	| newChangeList newList |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	changeList with: list do:[:chRec :strNstamp | 			| str keep cls sel |			keep := true.			(cls := chRec methodClass) ifNotNil:[				str := chRec string.				sel := cls parserClass new parseSelector: str.				keep := (cls sourceCodeAt: sel ifAbsent:['']) asString ~= str.			].			keep ifTrue:[					newChangeList add: chRec.					newList add: strNstamp]].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList.			list := newList.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list! !!TimeProfileBrowser methodsFor: 'message list' stamp: 'nice 12/27/2009 03:10'!selectedMessage	"Answer the source method for the currently selected message."		self setClassAndSelectorIn: 			[:class :selector | | source | 			source := class sourceMethodAt: selector ifAbsent: [^'Missing'].			Preferences browseWithPrettyPrint 				ifTrue: 					[source := class prettyPrinterClass 								format: source								in: class								notifying: nil								decorated: false].			self selectedClass: class.			self selectedSelector: selector.			^source asText makeSelectorBoldIn: class].	^''! !!ProtocolBrowser methodsFor: 'private' stamp: 'nice 12/26/2009 20:38'!initListFrom: selectorCollection highlighting: aClass 	"Make up the messageList with items from aClass in boldface."	messageList := OrderedCollection new.	selectorCollection do: [ :selector |  		| defClass item |		defClass := aClass whichClassIncludesSelector: selector.		item := selector, '     (' , defClass name , ')'.		defClass == aClass ifTrue: [item := item asText allBold].		messageList add: (			MethodReference new				setClass: defClass 				methodSymbol: selector 				stringVersion: item		)	].	selectedClass := aClass.! !!Lexicon methodsFor: 'toolbuilder' stamp: 'nice 12/27/2009 03:10'!buildCustomButtonsWith: builder	"This method if very similar to StringHolder>>buildOptionalButtonsWith:.	Refactor and pass in button specs?"	| panelSpec |	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	self customButtonSpecs do: [:spec | | buttonSpec |		buttonSpec := builder pluggableActionButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		spec size > 2 ifTrue: [buttonSpec help: spec third].		panelSpec children add: buttonSpec.	].	panelSpec layout: #horizontal. "buttons"	self addSpecialButtonsTo: panelSpec with: builder.	^panelSpec! !!ObjectExplorer methodsFor: 'monitoring' stamp: 'nice 12/26/2009 18:56'!step	"If there's anything in my monitor list, see if the strings have changed."	| changes |	changes := false.	self monitorList keysAndValuesDo: [ :k :v |		k ifNotNil: [			| string |			k refresh.			(string := k asString) ~= v ifTrue: [ self monitorList at: k put: string. changes := true ].		]	].	changes ifTrue: [ | sel |		sel := currentSelection.		self changed: #getList.		self noteNewSelection: sel.	].	self monitorList isEmpty ifTrue: [ ActiveWorld stopStepping: self selector: #step ].! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:10'!quickList	"Compute the selectors for the single example of receiver and args, in the very top pane" 	| data result resultArray dataStrings mf dataObjects aa statements |	data := contents asString.	"delete t railing period. This should be fixed in the Parser!!" 	[data last isSeparator] whileTrue: [data := data allButLast]. 	data last = $. ifTrue: [data := data allButLast]. 	"Eval"	mf := MethodFinder new.	data := mf cleanInputs: data.	"remove common mistakes"	dataObjects := Compiler evaluate: '{', data, '}'. "#( data1 data2 result )"	statements := (Compiler new parse: 'zort ' , data in: Object notifying: nil)				body statements select: [:each | (each isKindOf: ReturnNode) not]. 	dataStrings := statements collect:				[:node | String streamContents:					[:strm | (node isMessage) ifTrue: [strm nextPut: $(].					node shortPrintOn: strm.					(node isMessage) ifTrue: [strm nextPut: $)].]].	dataObjects size < 2 ifTrue: [self inform: 'If you are giving an example of receiver, \args, and result, please put periods between the parts.\Otherwise just type one selector fragment' withCRs. ^#()]. 	dataObjects := Array with: dataObjects allButLast with: dataObjects last. "#( (data1  data2) result )" 	result := mf load: dataObjects; findMessage.	(result first beginsWith: 'no single method') ifFalse: [		aa := self testObjects: dataObjects strings: dataStrings.		dataObjects := aa second.  dataStrings := aa third].	resultArray := self listFromResult: result. 	resultArray isEmpty ifTrue: [self inform: result first].	dataStrings size = (dataObjects first size + 1) ifTrue:		[resultArray := resultArray collect: [:expression | | newExp |		newExp := expression.		dataObjects first withIndexDo: [:lit :i |			newExp := newExp copyReplaceAll: 'data', i printString							with: (dataStrings at: i)].		newExp, ' --> ', dataStrings last]]. 	^ resultArray! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!initHierarchyForClass: aClassOrMetaClass	| index nonMetaClass tab |	centralClass := aClassOrMetaClass.	nonMetaClass := aClassOrMetaClass theNonMetaClass.	self systemOrganizer: SystemOrganization.	metaClassIndicated := aClassOrMetaClass isMeta.	classList := OrderedCollection new.	tab := ''.	nonMetaClass allSuperclasses reverseDo: 		[:aClass | 		classList add: tab , aClass name.		tab := tab , '  '].	index := classList size + 1.	nonMetaClass allSubclassesWithLevelDo:		[:aClass :level | | stab |		stab := ''.  1 to: level do: [:i | stab := stab , '  '].		classList add: tab , stab , aClass name]	 	startingLevel: 0.	self classListIndex: index! !!CodeHolder class methodsFor: 'controls' stamp: 'nice 12/26/2009 09:49'!addContentsSymbolQuint: quint afterEntry: aSymbol 	"Register a menu selection item in the position after the entry with	selection symbol aSymbol."	"CodeHolder		addContentsSymbolQuint: #(#altSyntax #toggleAltSyntax #showingAltSyntaxString 'altSyntax' 'alternative syntax')		afterEntry: #colorPrint"	ContentsSymbolQuints		detect: [:e | (e isKindOf: Collection) and: [e first = quint first]]		ifNone: [			| entry |			entry := ContentsSymbolQuints						detect: [:e | (e isKindOf: Collection) and: [e first = aSymbol]].			ContentsSymbolQuints add: quint after: entry.			^ self].	self notify: 'entry already exists for ', quint first! !!ChangeList methodsFor: 'scanning' stamp: 'nice 12/27/2009 03:10'!scanFile: aFile from: startPosition to: stopPosition		file := aFile.	changeList := OrderedCollection new.	list := OrderedCollection new.	listIndex := 0.	file position: startPosition.'Scanning ', aFile localName, '...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar | | prevChar itemPosition item |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar := file next].		(file peekFor: $!!)		ifTrue:			[(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [self scanCategory]]		ifFalse:			[itemPosition := file position.			item := file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 50)]]]].	listSelections := Array new: list size withAll: false! !!MessageSet methodsFor: 'filtering' stamp: 'nice 12/27/2009 03:10'!filterToNotSendersOf	"Filter the receiver's list down to only those items which do not send a given selector"	| aFragment inputWithBlanksTrimmed |	aFragment := UIManager default request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed := aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector | | aMethod |					(aMethod := aClass compiledMethodAt: aSelector) isNil or:						[(aMethod hasLiteralThorough: aSymbol) not]]]! !!MessageSet methodsFor: 'message list' stamp: 'nice 12/27/2009 03:10'!sortByDate	"Sort the message-list by date of time-stamp"	| assocs inOrder |	assocs := messageList collect:		[:aRef | | aDate aCompiledMethod |			aDate := aRef methodSymbol == #Comment				ifTrue:					[aRef actualClass organization dateCommentLastSubmitted]				ifFalse:					[aCompiledMethod := aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: [nil].					aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].			aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"	inOrder := assocs asSortedCollection:		[:a :b | a value < b value].	messageList := inOrder asArray collect: [:assoc | assoc key].	self changed: #messageList! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:10'!testObjects: dataObjects strings: dataStrings	| dataObjs dataStrs selectors classes didUnmodifiedAnswer |	"Try to make substitutions in the user's inputs and search for the selector again.1 no change to answer.2 answer Array -> OrderedCollection.2 answer Character -> String4 answer Symbol or String of len 1 -> Character	For each of these, try straight, and try converting args:Character -> StringSymbol or String of len 1 -> Character	Return array with result, dataObjects, dataStrings.  Don't ever do a find on the same set of data twice."dataObjs := dataObjects.  dataStrs := dataStrings.selectors := {#asString. #first. #asOrderedCollection}.classes := {Character. String. Array}.didUnmodifiedAnswer := false.selectors withIndexDo: [:ansSel :ansInd | | ds do result answerMod | "Modify the answer object"	answerMod := false.	do := dataObjs copyTwoLevel.  ds := dataStrs copy.	(dataObjs last isKindOf: (classes at: ansInd)) ifTrue: [		((ansSel ~~ #first) or: [dataObjs last size = 1]) ifTrue: [			do at: do size put: (do last perform: ansSel).	"asString"			ds at: ds size put: ds last, ' ', ansSel.			result := MethodFinder new load: do; findMessage.			(result first beginsWith: 'no single method') ifFalse: [				"found a selector!!"				^ Array with: result first with: do with: ds].				answerMod := true]].	selectors allButLast withIndexDo: [:argSel :argInd | | ddo dds | "Modify an argument object"			"for args, no reason to do Array -> OrderedCollection.  Identical protocol."		didUnmodifiedAnswer not | answerMod ifTrue: [		ddo := do copyTwoLevel.  dds := ds copy.		dataObjs first withIndexDo: [:arg :ind |			(arg isKindOf: (classes at: argInd))  ifTrue: [				((argSel ~~ #first) or: [arg size = 1]) ifTrue: [					ddo first at: ind put: ((ddo first at: ind) perform: argSel).	"asString"					dds at: ind put: (dds at: ind), ' ', argSel.					result := MethodFinder new load: ddo; findMessage.					(result first beginsWith: 'no single method') ifFalse: [						"found a selector!!"						^ Array with: result first with: ddo with: dds]	.						didUnmodifiedAnswer not & answerMod not ifTrue: [						didUnmodifiedAnswer := true].					]]]]].	].^ Array with: 'no single method does that function' with: dataObjs with: dataStrs! !!MessageSet methodsFor: 'filtering' stamp: 'nice 12/27/2009 03:10'!filterToNotCurrentAuthor	"Filter down only to messages not stamped with my initials"	| myInitials |	(myInitials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	self filterFrom:		[:aClass :aSelector | | aTimeStamp aMethod |			(aClass notNil and: [aSelector notNil]) and:							[aMethod := aClass compiledMethodAt: aSelector ifAbsent: [nil].				aMethod notNil and:					[(aTimeStamp := Utilities timeStampForMethod: aMethod) isNil or:						[(aTimeStamp beginsWith: myInitials) not]]]]! !!Browser methodsFor: 'message category functions' stamp: 'nice 12/27/2009 03:10'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines menuIndex oldIndex newName |	self okToChange ifFalse: [^ self].	classListIndex = 0 ifTrue: [^ self].	labels := OrderedCollection with: 'new...'.	reject := Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines := OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls | | cats |		cls = Object ifFalse: [			cats := cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asSortedCollection.				reject addAll: cats]]].	newName := (labels size = 1 or: [		menuIndex := (UIManager default chooseFrom: labels lines: lines title: 'Add Category').		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex := messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName := newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: (messageCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedMessageCategoryName]).	self changed: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [self classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self changed: #messageCategoryList.! !!MessageNames methodsFor: 'search' stamp: 'nice 12/26/2009 10:25'!computeSelectorListFromSearchString	"Compute selector list from search string"	searchString := searchString asString copyWithout: $ .	selectorList := Cursor wait				showWhile: [					| raw sorted |					raw := Symbol selectorsContaining: searchString.					sorted := raw as: SortedCollection.					sorted						sortBlock: [:x :y | x asLowercase <= y asLowercase].					sorted asArray].	selectorList size > 19		ifFalse: ["else the following filtering is considered too expensive. This 19  			should be a system-maintained Parameter, someday"			selectorList := self systemNavigation allSelectorsWithAnyImplementorsIn: selectorList].	^ selectorList! !!Browser methodsFor: 'class functions' stamp: 'nice 12/26/2009 00:30'!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"	| aClass |	(aClass := self selectedClassOrMetaClass) ifNotNil:		[aClass instVarNames do: 			[:aName |				| newMessage setter |				(aClass canUnderstand: aName asSymbol)					ifFalse:						[newMessage := aName, '	"Answer the value of ', aName, '"	^ ', aName.						aClass compile: newMessage classified: 'accessing' notifying: nil].				(aClass canUnderstand: (setter := aName, ':') asSymbol)					ifFalse:						[newMessage := setter, ' anObject	"Set the value of ', aName, '"	', aName, ' := anObject'.						aClass compile: newMessage classified: 'accessing' notifying: nil]]]! !!CodeHolder methodsFor: 'annotation' stamp: 'nice 12/27/2009 03:10'!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| separator aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream := ReadWriteStream on: ''.	requestList := self annotationRequests.	separator := requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | | aString sendersCount aComment aCategory implementorsCount aList stamp | 			aRequest == #firstComment				ifTrue: [aComment := aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment := aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment := aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp := self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory := aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount := (self systemNavigation allCallsOn: aSelector) size.					sendersCount := sendersCount == 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount := self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount := implementorsCount == 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp := VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString := ChangesOrganizer mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList := ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!ArchiveViewer methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!createButtonBar	| bar narrowFont registeredFonts |	registeredFonts := OrderedCollection new.	TextStyle knownTextStylesWithoutDefault do:		[:st | (TextStyle named: st) fonts do: [:f | registeredFonts addLast: f]].			narrowFont := registeredFonts detectMin:			[:ea | ea widthOfString: 'Contents' from: 1 to: 8].	bar := AlignmentMorph newRow.	bar		color: self defaultBackgroundColor;		rubberBandCells: false;		vResizing: #shrinkWrap;		cellInset: 6 @ 0.	#(#('New\Archive' #canCreateNewArchive #createNewArchive 'Create a new, empty archive and discard this one') #('Load\Archive' #canOpenNewArchive #openNewArchive 'Open another archive and discard this one') #('Save\Archive As' #canSaveArchive #saveArchive 'Save this archive under a new name') #('Extract\All' #canExtractAll #extractAll 'Extract all this archive''s members into a directory') #('Add\File' #canAddMember #addMember 'Add a file to this archive') #('Add from\Clipboard' #canAddMember #addMemberFromClipboard 'Add the contents of the clipboard as a new file') #('Add\Directory' #canAddMember #addDirectory 'Add the entire contents of a directory, with all of its subdirectories') #('Extract\Member As' #canExtractMember #extractMember 'Extract the selected member to a file') #('Delete\Member' #canDeleteMember #deleteMember 'Remove the selected member from this archive') #('Rename\Member' #canRenameMember #renameMember 'Rename the selected member') #('View All\Contents' #canViewAllContents #changeViewAllContents 'Toggle the view of all the selected member''s contents')) 		do: 			[:arr | 			| buttonLabel button |			buttonLabel := (TextMorph new)						string: arr first withCRs							fontName: narrowFont familyName							size: narrowFont pointSize							wrap: false;						hResizing: #shrinkWrap;						lock;						yourself.			(button := PluggableButtonMorph 						on: self						getState: arr second						action: arr third)				vResizing: #shrinkWrap;				hResizing: #spaceFill;				onColor: self buttonOnColor offColor: self buttonOffColor;				label: buttonLabel;				setBalloonText: arr fourth.			bar addMorphBack: button.			buttonLabel composeToBounds].	^bar! !!Browser methodsFor: 'class functions' stamp: 'nice 12/26/2009 00:28'!copyClass	| originalName copysName oldDefinition newDefinition |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	originalName := self selectedClass name.	copysName := self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName := copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk includesKey: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	oldDefinition := self selectedClass definition.	newDefinition := oldDefinition copyReplaceAll: '#' , originalName asString with: '#' , copysName asString.	Cursor wait 		showWhile: [| class |					class := Compiler evaluate: newDefinition logged: true.					class copyAllCategoriesFrom: (Smalltalk at: originalName).					class class copyAllCategoriesFrom: (Smalltalk at: originalName) class].	self classListIndex: 0.	self changed: #classList! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/27/2009 03:10'!selectUnchangedMethods	"Selects all method definitions for which there is already a method in the current image, whose source is exactly the same.  9/18/96 sw"		Cursor read showWhile: 	[ | class change |1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put:			((change type = #method and:				[(class := change methodClass) notNil]) and:					[(class includesSelector: change methodSelector) and:						[change string withBlanksCondensed = (class sourceCodeAt: change methodSelector) asString withBlanksCondensed ]])]].	self changed: #allSelections! !!Lexicon methodsFor: 'within-tool queries' stamp: 'nice 12/27/2009 03:10'!selectorsChanged	"Return a list of methods in the current change set (or satisfying some 	other such criterion) that are in the protocol of this object"	| aList targetedClass |	targetedClass := self targetObject				ifNil: [targetClass]				ifNotNil: [self targetObject class].	aList := OrderedCollection new.	ChangeSet current methodChanges		associationsDo: [:classChgAssoc | classChgAssoc value				associationsDo: [:methodChgAssoc | | aClass | (methodChgAssoc value == #change							or: [methodChgAssoc value == #add])						ifTrue: [(aClass := targetedClass whichClassIncludesSelector: methodChgAssoc key)								ifNotNil: [aClass name = classChgAssoc key										ifTrue: [aList add: methodChgAssoc key]]]]].	^ aList! !!MessageSet methodsFor: 'filtering' stamp: 'nice 12/27/2009 03:10'!filterToSendersOf	"Filter the receiver's list down to only those items which send a given selector"	| aFragment inputWithBlanksTrimmed |	aFragment := UIManager default request: 'type selector:' initialAnswer: ''.	aFragment  isEmptyOrNil ifTrue: [^ self].	inputWithBlanksTrimmed := aFragment withBlanksTrimmed.	Symbol hasInterned: inputWithBlanksTrimmed ifTrue:		[:aSymbol | 			self filterFrom:				[:aClass :aSelector | | aMethod |					(aMethod := aClass compiledMethodAt: aSelector) notNil and:						[aMethod hasLiteralThorough: aSymbol]]]! !!BrowserHierarchicalListTest methodsFor: 'tests' stamp: 'nice 12/26/2009 00:33'!testListClassesHierarchicallyIndent	| result dict  |	result := self hierarchicalClassListForCategory: 'Tools-Browser'.	"Create class->indent mapping"	dict := result inject: Dictionary new into: [:classIndentMapping :className |		| indent |		indent := className count: [:char | char = Character space or: [char = Character tab]].		classIndentMapping at: (self nameToClass: className) put: indent.		classIndentMapping].	"assert that indent of class is larger than indent of superclass"	dict keysAndValuesDo: [:class :myIndent |		dict at: class superclass ifPresent: [:superIndent |			self assert: myIndent > superIndent]].! !!MessageSet methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!initializeMessageList: anArray	"Initialize my messageList from the given list of MethodReference or string objects.  NB: special handling for uniclasses."		messageList := OrderedCollection new.	anArray do: [ :each |		MessageSet 			parse: each  			toClassAndSelector: [ :class :sel | | s |				class ifNotNil:					[class isUniClass						ifTrue:							[s := class typicalInstanceName, ' ', sel]						ifFalse:							[s := class name , ' ' , sel , ' {' , 								((class organization categoryOfElement: sel) ifNil: ['']) , '}'].					messageList add: (						MethodReference new							setClass: class  							methodSymbol: sel 							stringVersion: s)]]].	messageListIndex := messageList isEmpty ifTrue: [0] ifFalse: [1].	contents := ''! !!ParagraphEditor methodsFor: '*Tools' stamp: 'nice 12/26/2009 19:10'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol b |	(((b := model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol := self selectedSymbol) ifNil: [^ view flash].	self terminateAndInitializeAround:		[| foundClass |		foundClass := (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass ifNil: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 21:12'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	| tokens |	contents := aString.	classList := #().  classListIndex := 0.	selectorIndex := 0.	tokens := contents asString findTokens: ' .'.	selectorList := Cursor wait showWhile: [		| raw sorted |		tokens size = 1 			ifTrue: [raw := (Symbol selectorsContaining: contents asString).				sorted := raw as: SortedCollection.				sorted sortBlock: [:x :y | x asLowercase <= y asLowercase].				sorted asArray]			ifFalse: [self quickList]].	"find selectors from a single example of data"	self changed: #messageList.	self changed: #classList.	^ true! !!Lexicon methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!initListFrom: selectorCollection highlighting: aClass 	"Make up the messageList with items from aClass in boldface.  Provide a final filtering in that only selectors whose implementations fall within my limitClass will be shown."		messageList := OrderedCollection new.	selectorCollection do: 		[:selector | | item defClass |  defClass := aClass whichClassIncludesSelector: selector.		(defClass notNil and: [defClass includesBehavior: self limitClass]) ifTrue:			[item := selector, '     (' , defClass name , ')'.			item := item asText.			defClass == aClass ifTrue: [item allBold].			"(self isThereAnOverrideOf: selector) ifTrue: [item addAttribute: TextEmphasis struckOut]."			"The above has a germ of a good idea but could be very slow"			messageList add: item]]! !!ChangesOrganizer class methodsFor: 'utilities' stamp: 'nice 12/27/2009 03:12'!fileOutChangeSetsNamed: nameList	"File out the list of change sets whose names are provided"     "ChangeSorter fileOutChangeSetsNamed: #('New Changes' 'miscTidies-sw')"	| notFound empty infoString |	notFound := OrderedCollection new.	empty := OrderedCollection new.	nameList do:		[:aName | | aChangeSet | (aChangeSet := self changeSetNamed: aName)			ifNotNil:				[aChangeSet isEmpty					ifTrue:						[empty add: aName]					ifFalse:						[aChangeSet fileOut]]			ifNil:				[notFound add: aName]].	infoString := (nameList size - notFound size) printString, ' change set(s) filed out'.	notFound size > 0 ifTrue:		[infoString := infoString, '', notFound size printString, ' change set(s) not found:'.		notFound do:			[:aName | infoString := infoString, '', aName]].	empty size > 0 ifTrue:		[infoString := infoString, '', empty size printString, ' change set(s) were empty:'.		empty do:			[:aName | infoString := infoString, '', aName]].	self inform: infoString! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nice 12/27/2009 03:10'!drawOn: aCanvas		| tRect sRect columnScanner columnLeft |		tRect := self toggleRectangle.		sRect := bounds withLeft: tRect right + 4.	self drawToggleOn: aCanvas in: tRect.	icon isNil ifFalse:[		aCanvas			translucentImage: icon				at: sRect left @ (self top + (self height - icon height // 2)).			sRect := sRect left: sRect left + icon width + 2.	].	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [		sRect := sRect top: sRect top + sRect bottom - self fontToUse height // 2.		aCanvas drawString: contents asString in: sRect font: self fontToUse color: color.		] ifFalse: [		columnLeft := sRect left.		columnScanner := ReadStream on: contents asString.		container columns do: [ :width | | columnRect columnData |			columnRect := columnLeft @ sRect top extent: width @ sRect height.			columnData := columnScanner upTo: Character tab.			columnData isEmpty ifFalse: [				aCanvas drawString: columnData in: columnRect font: self fontToUse color: color.			].			columnLeft := columnRect right + 5.		].	]! !!CodeHolder methodsFor: 'what to show' stamp: 'nice 12/26/2009 09:47'!offerWhatToShowMenu	"Offer a menu governing what to show"	| builder menuSpec |	builder := ToolBuilder default.	menuSpec := builder pluggableMenuSpec new.	self contentsSymbolQuints do: [:aQuint | aQuint == #-		ifTrue: [menuSpec addSeparator]		ifFalse: [			| item |			item := menuSpec add: (self perform: aQuint third) 					target: self selector: aQuint second argumentList: #().			item help: aQuint fifth.		].	].	builder runModal: (builder open: menuSpec).! !!Browser methodsFor: 'class list' stamp: 'nice 12/26/2009 00:28'!createHierarchyTreeOf: col	"Create a tree from a flat collection of classes"	| transformed |	transformed := col collect: [:ea | 		| childs indexes |		childs := col select: [:class | class isTrait not and: [class superclass = ea]].		indexes := childs collect: [:child | col indexOf: child].		ea -> indexes].	transformed copy do: [:ea |		ea value: (ea value collect: [:idx | 			| val |			val := transformed at: idx.			transformed at: idx put: nil.			val])].	^ transformed select: [:ea | ea notNil].! !!Browser methodsFor: 'class list' stamp: 'nice 12/26/2009 00:32'!flattenHierarchyTree: classHierarchy on: col indent: indent	| plusIndent |	plusIndent := String space.	classHierarchy do: [:assoc |		| class childs |		class := assoc key.		col add: indent , class name.		childs := assoc value.		self			flattenHierarchyTree: childs			on: col			indent: indent , plusIndent].	^ col! !!MessageSet methodsFor: 'filtering' stamp: 'nice 12/27/2009 03:10'!filterToMessagesInChangesFile	"Filter down only to messages whose source code risides in the Changes file.  This allows one to ignore long-standing methods that live in the .sources file."		self filterFrom:		[:aClass :aSelector | | cm |			aClass notNil and: [aSelector notNil and:				[(self class isPseudoSelector: aSelector) not and:					[(cm := aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex ~~ 1]]]]]! !!FileChooser methodsFor: 'ui creation' stamp: 'nice 12/26/2009 10:05'!addFullPanesTo: aMorph from: aCollection	aCollection do: [ :each |		| frame |		frame := LayoutFrame 			fractions: each second 			offsets: each third.		aMorph addMorph: each first fullFrame: frame.	]! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 03:11'!browseStream: aStream named: aString	| browser |	Cursor wait showWhile: [ | package packageDict organizer |		packageDict := Dictionary new.		browser := self new.		organizer := SystemOrganizer defaultList: Array new.		package := (FilePackage new fullName: aString; fileInFrom: aStream).		packageDict 			at: package packageName 			put: package.		organizer 			classifyAll: package classes keys 			under: package packageName.		(browser := self systemOrganizer: organizer)			packages: packageDict].	self		openBrowserView: browser createViews		label: 'File Contents Browser'.! !!MessageSet methodsFor: 'filtering' stamp: 'nice 12/27/2009 03:10'!filterToMessagesInSourcesFile	"Filter down only to messages whose source code resides in the .sources file."		self filterFrom: [:aClass :aSelector | | cm |		(aClass notNil and: [aSelector notNil]) and:			[(self class isPseudoSelector: aSelector) not and:				[(cm := aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex == 1]]]]! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/27/2009 03:10'!selectConflicts: changeSetOrList	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList"	| systemChanges |	Cursor read showWhile: 	[ | change class |(changeSetOrList isKindOf: ChangeSet) ifTrue: [	1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put:			(change type = #method			and: [(class := change methodClass) notNil			and: [(changeSetOrList atSelector: change methodSelector						class: class) ~~ #none]])]]	ifFalse: ["a ChangeList"	1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put:			(change type = #method			and: [(class := change methodClass) notNil			and: [changeSetOrList list includes: (list at: i)]])]]	].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/27/2009 03:10'!selectConflicts	"Selects all method definitions for which there is ALSO an entry in changes"		Cursor read showWhile: 	[ | change class |1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put:			(change type = #method			and: [(class := change methodClass) notNil			and: [(ChangeSet current atSelector: change methodSelector						class: class) ~~ #none]])]].	self changed: #allSelections! !!ChangeList class methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 03:11'!browseCompressedChangesFile: fullName 	"Browse the selected file in fileIn format."	| unzipped stream |	fullName ifNil: [^Beeper beep].	stream := FileStream readOnlyFileNamed: fullName.	[ | zipped |stream converter: Latin1TextConverter new.	zipped := GZipReadStream on: stream.	unzipped := zipped contents asString]		ensure: [stream close].	stream := (MultiByteBinaryOrTextStream with: unzipped) reset.	ChangeList browseStream: stream! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/27/2009 03:10'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."		Cursor read showWhile: 		[ | aClass aChange |1 to: changeList size do:			[:i | aChange := changeList at: i.			listSelections at: i put:				(aChange type = #method				and: [(aClass := aChange methodClass) notNil				and: [ChangesOrganizer doesAnyChangeSetHaveClass: aClass andSelector:  aChange methodSelector]])]].	self changed: #allSelections! !!Model methodsFor: '*Tools' stamp: 'nice 12/27/2009 03:10'!addItem: classAndMethod	"Make a linked message list and put this method in it"		self flag: #mref.	"classAndMethod is a String"	MessageSet 		parse: classAndMethod  		toClassAndSelector: [ :class :sel | | list |			class ifNil: [^self].			list := OrderedCollection with: (				MethodReference new					setClass: class  					methodSymbol: sel 					stringVersion: classAndMethod			).			MessageSet 				openMessageList: list 				name: 'Linked by HyperText'.		]! !!ClassCommentVersionsBrowser class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 02:54'!browseCommentOf: class	Cursor read showWhile:		[| changeList |		changeList := self new scanVersionsOf: class.	 	 changeList ifNil: [^ self inform: 'No versions available'].		 self open: changeList name: 'Recent versions of ',class name,'''s comments' multiSelect: false ]! !!Lexicon methodsFor: 'senders' stamp: 'nice 12/27/2009 03:10'!selectorsSendingSelectedSelector	"Assumes lastSendersSearchSelector is already set"	| selectorSet |	autoSelectString := (self lastSendersSearchSelector upTo: $:) asString.	selectorSet := Set new.	(self systemNavigation allCallsOn: self lastSendersSearchSelector)		do: [:anItem | | sel cl | 			sel := anItem methodSymbol.			cl := anItem actualClass.			((currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass)					and: [targetClass includesBehavior: cl])				ifTrue: [selectorSet add: sel]].	^ selectorSet asSortedArray! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 03:11'!browseFiles: fileList	| browser |	Cursor wait showWhile: [ | organizer packageDict |		packageDict := Dictionary new.		organizer := SystemOrganizer defaultList: Array new.		fileList do: [:fileName | | package |			package := FilePackage fromFileNamed: fileName.			packageDict 				at: package packageName 				put: package.			organizer 				classifyAll: package classes keys 				under: package packageName].		(browser := self systemOrganizer: organizer)			packages: packageDict].	self		openBrowserView: browser createViews		label: 'File Contents Browser'.! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'nice 12/26/2009 09:45'!buildOptionalButtonsWith: builder	| panelSpec |	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	self optionalButtonPairs do:[:spec|		| buttonSpec |		buttonSpec := builder pluggableActionButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		spec second == #methodHierarchy ifTrue:[			buttonSpec color: #inheritanceButtonColor.		]. 		spec size > 2 ifTrue:[buttonSpec help: spec third].		panelSpec children add: buttonSpec.	].	"What to show"	panelSpec children add: (self buildCodeProvenanceButtonWith: builder).	panelSpec layout: #horizontal. "buttons"	^panelSpec! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 03:11'!browseCompressedCodeStream: aStandardFileStream 	"Browse the selected file in fileIn format."	| unzipped |	[ | zipped |zipped := GZipReadStream on: aStandardFileStream.	unzipped := MultiByteBinaryOrTextStream with: zipped contents asString]		ensure: [aStandardFileStream close].	unzipped reset.	self browseStream: unzipped named: aStandardFileStream name! !!Browser methodsFor: 'message category list' stamp: 'nice 12/26/2009 00:32'!recategorizeMethodSelector: sel 	"Categorize method named sel by looking in parent classes for a 	method category. 	Answer true if recategorized."	self selectedClassOrMetaClass allSuperclasses		do: [:ea | 			| thisCat |			thisCat := ea organization categoryOfElement: sel.			(thisCat ~= ClassOrganizer default					and: [thisCat notNil])				ifTrue: [self classOrMetaClassOrganizer classify: sel under: thisCat.					self changed: #messageCategoryList.					^ true]].	^ false! !!FileContentsBrowser methodsFor: 'diffs' stamp: 'nice 12/26/2009 10:05'!modifiedClassDefinition	| pClass rClass old new diff |	pClass := self selectedClassOrMetaClass.	pClass hasDefinition ifFalse:[^pClass definition].	rClass := Smalltalk at: self selectedClass name asSymbol ifAbsent:[nil].	rClass isNil ifTrue:[^pClass definition].	self metaClassIndicated ifTrue:[ rClass := rClass class].	old := rClass definition.	new := pClass definition.	diff := Cursor wait showWhile:[		ClassDiffBuilder buildDisplayPatchFrom: old to: new	].	^diff! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/27/2009 03:10'!removeOlderMethodVersions	"Remove older versions of entries from the receiver."	| newChangeList newList found |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	found := OrderedCollection new.	changeList reverseWith: list do:		[:chRec :strNstamp | | str | str := strNstamp copyUpTo: $;.			(found includes: str)				ifFalse:					[found add: str.					newChangeList add: chRec.					newList add: strNstamp]].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList reversed.			list := newList reversed.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list! !!TimeProfileBrowser methodsFor: 'private' stamp: 'nice 12/27/2009 03:34'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	self flag: #mref.	"fix for faster references to methods"	[ | strm string class parens sel |	string := self selection asString.	string first == $* ifTrue: [^contents := nil].		"Ignore lines starting with *"	parens := string includes: $(.					"Does it have open-paren?"	strm := ReadStream on: string.	parens		ifTrue: [strm skipTo: $(.		"easy case"			class := strm upTo: $).			strm next: 2.			sel := strm upToEnd]		ifFalse: [strm position: (string findString: ' class>>').			strm position > 0				ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])]				ifTrue:					[ | subString |  "find the next to last space character"					subString := strm contents copyFrom: 1 to: (string findLast: [ :ch | ch == $ ]) - 1.					strm position: (subString findLast: [ :ch | ch == $ ])].		"ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])."			class := strm upTo: $>.			strm next.			sel := strm upToEnd].	^ MessageSet parse: (class, ' ', sel) toClassAndSelector: csBlock]		on: Error do: [:ex | ^ contents := nil]! !!MessageSet methodsFor: 'filtering' stamp: 'nice 12/27/2009 03:10'!filterToCurrentAuthor	"Filter down only to messages with my initials as most recent author"	| myInitials |	(myInitials := Utilities authorInitialsPerSe) ifNil: [^ self inform: 'No author initials set in this image'].	self filterFrom:		[:aClass :aSelector | | aMethod aTimeStamp |			(aClass notNil and: [aSelector notNil]) and:							[aMethod := aClass compiledMethodAt: aSelector ifAbsent: [nil].				aMethod notNil and:					[(aTimeStamp := Utilities timeStampForMethod: aMethod) notNil and:						[aTimeStamp beginsWith: myInitials]]]]! !!ChangeList methodsFor: 'menu actions' stamp: 'nice 12/26/2009 00:36'!browseCurrentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	| aList |	aList := OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				|  aClass aChange |				aChange := changeList at: i.				(aChange type = #method					and: [(aClass := aChange methodClass) notNil					and: [aClass includesSelector: aChange methodSelector]])						ifTrue: [							aList add: (								MethodReference new									setStandardClass: aClass  									methodSymbol: aChange methodSelector							)						]]]].	aList size == 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].	MessageSet 		openMessageList: aList 		name: 'Current versions of selected methods in ', file localName! !!MessageSet methodsFor: 'contents' stamp: 'nice 12/27/2009 03:10'!selectedMessage	"Answer the source method for the currently selected message."		self setClassAndSelectorIn: [:class :selector | | source | 		class ifNil: [^ 'Class vanished'].		selector first isUppercase ifTrue:			[selector == #Comment ifTrue:				[currentCompiledMethod := class organization commentRemoteStr.				^ class comment].			selector == #Definition ifTrue:				[^ class definitionST80].			selector == #Hierarchy ifTrue: [^ class printHierarchy]].		source := class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod := nil.			^ 'Missing'].		self showingDecompile ifTrue: [^ self decompiledSourceIntoContents].		currentCompiledMethod := class compiledMethodAt: selector ifAbsent: [nil].		self showingDocumentation ifTrue: [^ self commentContents].	source := self sourceStringPrettifiedAndDiffed.	^ source asText makeSelectorBoldIn: class]! !!PackagePaneBrowser methodsFor: 'package list' stamp: 'nice 12/27/2009 03:10'!packageList	"Answer a list of the packages in the current system organization."	| str stream |	str := Set new: 100.	stream := WriteStream on: (Array new: 100).	systemOrganizer categories do:		[ :categ | | cats | 		cats := categ asString copyUpTo: $-.		(str includes: cats) ifFalse: 			[str add: cats.			stream nextPut: cats]].	^stream contents! !!VersionsBrowser methodsFor: 'menu' stamp: 'nice 12/27/2009 03:10'!versionFrom: secsSince1901		"Return changeRecord of the version in effect at that time.  Accept in the VersionsBrowser does not use this code."	changeList do: [:cngRec | | vTime strings |		(strings := cngRec stamp findTokens: ' ') size > 2 ifTrue: [				vTime := strings second asDate asSeconds + 							strings third asTime asSeconds.				vTime <= secsSince1901 ifTrue: ["this one"					^ cngRec == changeList first ifTrue: [nil] ifFalse: [cngRec]]]].	"was not defined that early.  Don't delete the method."	^ changeList last	"earliest one may be OK"	! !