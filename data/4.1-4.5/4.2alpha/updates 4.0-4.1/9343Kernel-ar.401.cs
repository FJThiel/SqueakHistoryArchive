"Change Set:		9343Kernel-ar.401Kernel-ar.401:Raise DuplicateVariableError in ClassBuilder.Kernel-nice.393:Separate NumberParser as abstract class and SqNumberParser as Squeak syntax special case.Provide a hook for allowing plus sign before number and plus sign in exponent.Provide a FORTRANNumberParser example to demonstrate how simple it is to subclass.My goal is to not let this class in Kernel, but to replace it with an ExtendedNumberParser to handle String asNumber. We will have to agree on expectations first.More subclasses can be found in VW public store SYSEXT-NumberParserKernel-nice.394:Comment the NumberParser classes and subclasses.Add an ExtendedNumberParser that can read all Squeak numbers plus numbers like these:+1+1.+1.e-21.e+2.1-.1e33r.023r-1.e-2.1s2+1.s3Cerise sur le gÃ¢teau:   +10r+1.e+2(use only if you really feel positive)Now we just have to decide where to connect this ExtendedNumberParser.It cannot be used in Parser because it would currently gobble the sentence period separator after a digit....Either we connect it directly in String>>#asNumberOr we change Parser to use a #smalltalkReadFrom: or SqNumberParser instead of Number>>#readFrom:.Kernel-nice.395:Arrange for ExtendedNumberParser to return the valid leading number instead of failing because of invalid radixExample:'1r' -> 1'2r3' -> 2Kernel-nice.396:Now read Float 'exactly' (answer nearest Float) by using SqNumberParser.This solves http://bugs.squeak.org/view.php?id=6982This requires a fix of Float initialize, otherwise the old max float literal would overflow.As mentionned by John McIntosh, this change has side effects and makes a few tests fail:1) reading an invalid number raise an Error rather than answering 02) undocumented syntax .1e2 and 1.e2 are no more acceptedIMO, we should not fix 1), we should fix the users. For this we provide a #readFrom:ifFail:We can fix 2) later by using ExtendedNumberParser where due.Kernel-nice.397:Change coercion policy: a Fraction is now converted to ScaledDecimal when involved with ScaledDecimal arithmetic as would an Integer do.Rationale: (1/1) is a Fraction represented as an Integer, so we cannot really dissociate the two behaviors.Kernel-nice.398:Fixhttp://bugs.squeak.org/view.php?id=3360http://bugs.squeak.org/view.php?id=3374http://bugs.squeak.org/view.php?id=6601hash and = are now reconciled for numbers.= is now transitive for numbers.WARNING: now, tests like (1/10 = 0.1) will answer false.This is expected, and more than expected, this is wanted.Float are inexact and testing for strict equality is not a clever thing to do.All this has been longly debated at http://permalink.gmane.org/gmane.comp.lang.smalltalk.pharo.devel/10642http://thread.gmane.org/gmane.comp.lang.smalltalk.sapphire.devel/10223/focus=10228Please, read carefully this thread to make an opinion before raising your voice.It can break code eventually,  so I'm all ears to real case, and willing to help fixing. But please, real examples, not theoretical (after 8 month change in Pharo, I'm not aware of further complaints).Kernel-nice.399:Merge minor changes from Pharo.Correct a bug (concatenating aString , aCharacter)Kernel-nice.400:Change the policy for conversions to ScaledDecimalAlways honour the number of decimal places (scale) passed as argument to asScaledDecimal:When no scale is passed, uses strictly necessary number of decimal places if the number is exact (not Float) and if a finite decimal representation exists.Otherwise uses the default of 8 decimal places.This makes more sense IMO than previous implementation. Integer version was screwing the user by not fulfiling the requested number of decimal places, I can't believe it was the right interpretation of the ANSI standard.... Or someone gives me a good rationale."!SqNumberParser subclass: #ExtendedNumberParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!NumberParser subclass: #FORTRANNumberParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!NumberParser subclass: #SqNumberParser	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!Object subclass: #NumberParser	instanceVariableNames: 'sourceStream base neg integerPart fractionPart exponent scale nDigits lastNonZero requestor failBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Numbers'!!NumberParser methodsFor: 'accessing' stamp: 'nice 5/1/2006 01:58'!failBlock: aBlockOrNil	failBlock := aBlockOrNil! !!FORTRANNumberParser methodsFor: 'accessing' stamp: 'nice 2/13/2010 00:10'!allowPlusSign	^true! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 2/12/2010 23:57'!peekSignIsMinus	"Peek an optional sign from sourceStream.	Answer true if it is minus sign"	| isMinus |	isMinus := sourceStream peekFor: $-.	isMinus ifFalse: [self allowPlusSign ifTrue: [sourceStream peekFor: $+]].	^isMinus! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:04'!<= operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction <= operand asFraction].	^ operand adaptToScaledDecimal: self andCompare: #<=! !!Float methodsFor: 'converting' stamp: 'nice 1/4/2009 20:31'!adaptToScaledDecimal: rcvr andCompare: selector 	"If I am involved in comparison with a scaled Decimal, convert myself to a	Fraction. This way, no bit is lost and comparison is exact."		self isFinite		ifFalse: [			selector == #= ifTrue: [^false].			selector == #~= ifTrue: [^true].			self isNaN ifTrue: [^ false].			(selector = #< or: [selector = #'<='])				ifTrue: [^ self positive].			(selector = #> or: [selector = #'>='])				ifTrue: [^ self positive not].			^self error: 'unknow comparison selector'].	^ rcvr perform: selector with: self asTrueFraction! !!Integer class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 00:36'!readFrom: aStringOrStream 	"Answer a new Integer as described on the stream, aStream.	Embedded radix specifiers not allowed - use Number readFrom: for that."	^self readFrom: aStringOrStream base: 10! !!Number class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 00:27'!readFrom: stringOrStream base: base	"Answer a number as described on aStream in the given number base."	^(SqNumberParser on: stringOrStream) nextNumberBase: base! !!Integer class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 01:09'!readFrom: aStringOrStream ifFail: aBlock	"Answer an instance of one of the concrete subclasses if Integer. 	Initial minus sign accepted.	Imbedded radix specifiers not allowed;  use Number 	class readFrom: for that.	Execute aBlock if there are no digits."	^(SqNumberParser on: aStringOrStream) nextIntegerBase: 10 ifFail: aBlock! !!Integer methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:03'!>= aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) <= 0]						ifFalse: [^(self digitCompare: aNumber) >= 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andCompare: #>=! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 2/13/2010 16:34'!readNamedFloatOrFail	"This method is used when there is no digit encountered:	It try and read a named Float NaN or Infinity.	Negative sign for -Infinity has been read before sending this method, and is indicated in the neg inst.var.	Fail if no named Float is found"			neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].	(sourceStream nextMatchAll: 'Infinity')		ifTrue: [^ neg			ifTrue: [Float infinity negated]			ifFalse: [Float infinity]].	^self expected: 'a digit between 0 and ' , (String with: (Character digitValue: base - 1))! !!ExtendedNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/13/2010 02:10'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [(sourceStream peekFor: $.)		ifTrue: [			"Try .1 syntax"			^self readNumberWithoutIntegerPart]		ifFalse: [			"This is not a regular number beginning with a digit			It is time to check for exceptional condition NaN and Infinity"			^self readNamedFloatOrFail]].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			| oldNeg pos |			pos := sourceStream position.			(base := integerPart) < 2				ifTrue: ["A radix currently need to be greater than 1, ungobble the r and return the integer part"					sourceStream skip: -1.					^neg						ifTrue: [base negated]						ifFalse: [base]].			oldNeg := neg.			self peekSignIsMinus ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerOrNilBase: base.			integerPart ifNil: [				(sourceStream peekFor: $.) ifTrue: [self readNumberWithoutIntegerPartOrNil ifNotNil: [:aNumber | ^aNumber]].				sourceStream position: pos.					^oldNeg						ifTrue: [base negated]						ifFalse: [base]].			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !!Float class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 00:54'!readFrom: aStream ifFail: aBlock	"Answer a new Float as described on the stream, aStream."	^(super readFrom: aStream ifFail: [^aBlock value]) asFloat! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:07'!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := sourceStream peekFor: $-.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 2/13/2010 15:53'!readExponent	"read the exponent if any (stored in instVar).	Answer true if found, answer false if none.	If exponent letter is not followed by a digit,	this is not considered as an error.	Exponent are always read in base 10."		| eneg epos |	exponent := 0.	sourceStream atEnd ifTrue: [^ false].	(self exponentLetters includes: sourceStream peek)		ifFalse: [^ false].	sourceStream next.	eneg := sourceStream peekFor: $-.	epos := eneg not and: [self allowPlusSignInExponent and: [sourceStream peekFor: $+]].	exponent := self nextUnsignedIntegerOrNilBase: 10.	exponent ifNil: ["Oops, there was no digit after the exponent letter.Ungobble the letter"		exponent := 0.		sourceStream						skip: ((eneg or: [epos])								ifTrue: [-2]								ifFalse: [-1]).					^ false].	eneg ifTrue: [exponent := exponent negated].	^true! !!NumberParser class methodsFor: 'instance creation' stamp: 'nice 5/1/2006 00:45'!on: aStringOrStream	^self new on: aStringOrStream! !!Float methodsFor: 'comparing' stamp: 'nice 7/10/2009 22:14'!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ aNumber adaptToFloat: self andCompare: #>=! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:38'!< operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction < operand asFraction].	^ operand adaptToScaledDecimal: self andCompare: #<! !!Fraction methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:05'!>= aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator >= (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andCompare: #>=! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:05'!nextUnsignedIntegerBase: aRadix ifFail: errorBlock	"Form an unsigned integer with incoming digits from sourceStream.	Answer this integer, or execute errorBlock if no digit found.	Count the number of digits and the position of lastNonZero digit and store them in instVar"		| value |	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^errorBlock value].	^value! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:41'!= comparand 	"Implementation of Number 'comparing' method."	comparand isNumber ifFalse: [^ false].	(comparand isKindOf: ScaledDecimal) ifTrue: [^ fraction = comparand asFraction].	^ comparand adaptToScaledDecimal: self andCompare: #=! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:04'!> operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction > operand asFraction].	^ operand adaptToScaledDecimal: self andCompare: #>! !!Float methodsFor: 'converting' stamp: 'nice 1/4/2009 20:31'!adaptToInteger: rcvr andCompare: selector 	"If I am involved in comparison with an Integer, convert myself to a	Fraction. This way, no bit is lost and comparison is exact."		self isFinite		ifFalse: [			selector == #= ifTrue: [^false].			selector == #~= ifTrue: [^true].			self isNaN ifTrue: [^ false].			(selector = #< or: [selector = #'<='])				ifTrue: [^ self positive].			(selector = #> or: [selector = #'>='])				ifTrue: [^ self positive not].			^self error: 'unknow comparison selector'].			"Try to avoid asTrueFraction because it can cost"	selector == #= ifTrue: [		self fractionPart = 0.0 ifFalse: [^false]].	selector == #~= ifTrue: [		self fractionPart = 0.0 ifFalse: [^true]].		^ rcvr perform: selector with: self asTrueFraction! !!Object methodsFor: 'converting' stamp: 'nice 3/28/2006 23:29'!adaptToFraction: rcvr andCompare: selector 	"If I am involved in comparison with a Fraction.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFraction: rcvr andSend: selector! !!NumberParser methodsFor: 'accessing' stamp: 'nice 2/12/2010 23:56'!allowPlusSign	"return a boolean indicating if plus sign is allowed or not"	^self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'nice 1/4/2009 20:31'!adaptToFloat: rcvr andCompare: selector 	"If I am involved in comparison with a Float, convert rcvr to a	Fraction. This way, no bit is lost and comparison is exact."		rcvr isFinite		ifFalse: [			selector == #= ifTrue: [^false].			selector == #~= ifTrue: [^true].			rcvr isNaN ifTrue: [^ false].			(selector = #< or: [selector = #'<='])				ifTrue: [^ rcvr positive not].			(selector = #> or: [selector = #'>='])				ifTrue: [^ rcvr positive].			^self error: 'unknow comparison selector'].	^ rcvr asTrueFraction perform: selector with: self! !!NumberParser methodsFor: 'parsing-large int' stamp: 'nice 8/31/2008 23:00'!nextElementaryLargeIntegerBase: aRadix	"Form an unsigned integer with incoming digits from sourceStream.	Return this integer, or zero if no digits found.	Stop reading if end of digits or if a LargeInteger is formed.	Count the number of digits and the position of lastNonZero digit and store them in instVar"	| value digit |	value := 0.	nDigits := 0.	lastNonZero := 0.	aRadix <= 10		ifTrue: ["Avoid using digitValue which is awfully slow"			[value isLarge or: [sourceStream atEnd				or: [digit := sourceStream next charCode - 48.					(0 > digit							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]]				whileFalse: [nDigits := nDigits + 1.					0 = digit						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]]		ifFalse: [			[value isLarge or: [sourceStream atEnd				or: [digit := sourceStream next digitValue.					(0 > digit							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]]				whileFalse: [nDigits := nDigits + 1.					0 = digit						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]].	^value! !!NumberParser class methodsFor: 'instance creation' stamp: 'nice 5/1/2006 02:02'!parse: aStringOrStream onError: failBlock 	^(self new)		on: aStringOrStream;		failBlock: failBlock;		nextNumber! !!ClassBuilder methodsFor: 'validation' stamp: 'abc 2/12/2010 12:35'!validateClassvars: classVarArray from: oldClass forSuper: newSuper	"Check if any of the classVars of oldClass conflict with the new superclass"	| usedNames classVars temp |	classVarArray isEmpty ifTrue:[^true]. "Okay"	"Validate the class var names"	usedNames := classVarArray asSet.	usedNames size = classVarArray size 		ifFalse:[	classVarArray do:[:var|					usedNames remove: var ifAbsent:[temp := var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp := var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames := newSuper allClassVarNames asSet.		classVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl classVarNames includes: iv) ifTrue:[temp := cl]].				(DuplicateVariableError new)					superclass: temp;					variable: iv;					signal: iv,' is already defined in ', temp name]]].	oldClass == nil ifFalse:[		usedNames := Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl classVarNames].		classVars := classVarArray.		newSuper == nil ifFalse:[classVars := classVars, newSuper allClassVarNames asArray].		classVars do:[:iv|			(usedNames includes: iv) ifTrue:[				(DuplicateVariableError new)					superclass: oldClass;					variable: iv;					signal: iv, ' is already defined in a subclass of ', oldClass name]]].	^true! !!ExtendedNumberParser methodsFor: 'parsing-private' stamp: 'nice 2/13/2010 00:57'!readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart	"at this stage, sign integerPart and a decimal point have been read.	try and form a number with a fractionPart"		| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart mantissa value |	fractionPart := self nextUnsignedIntegerOrNilBase: base.	fractionPart		ifNil: [			"No fractionPart found, but can be a 1.e2 syntax"			fractionPart := 0.			numberOfNonZeroFractionDigits := 0.			numberOfTrailingZeroInFractionPart := 0]		ifNotNil: [.			numberOfNonZeroFractionDigits := lastNonZero.			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero].	self readExponent		ifFalse: [self readScale				ifTrue: [^self makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits					andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart]].	fractionPart isZero		ifTrue: [mantissa := integerPart						// (base raisedToInteger: numberOfTrailingZeroInIntegerPart).			exponent := exponent + numberOfTrailingZeroInIntegerPart]		ifFalse: [mantissa := integerPart						* (base raisedToInteger: numberOfNonZeroFractionDigits) + (fractionPart // (base raisedToInteger: numberOfTrailingZeroInFractionPart)).			exponent := exponent - numberOfNonZeroFractionDigits].	value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.	^ neg		ifTrue: [value isZero				ifTrue: [Float negativeZero]				ifFalse: [value negated]]		ifFalse: [value]! !!ClassDescription methodsFor: 'private' stamp: 'abc 2/13/2010 15:01'!instVarMappingFrom: oldClass	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."	| oldInstVarNames |	oldInstVarNames := oldClass allInstVarNames.	"Using #lastIndexOf: to ensure proper behavior in case where we have duplicate ivars."	^self allInstVarNames collect: [:instVarName | oldInstVarNames lastIndexOf: instVarName].! !!Integer methodsFor: 'converting' stamp: 'nice 2/13/2010 22:46'!asScaledDecimal	"The number of significant digits of the answer is the same as the number of decimal digits in the receiver."	^ ScaledDecimal newFromNumber: self scale: 0! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/13/2010 16:05'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [^ self expected: 'an integer greater than 1 as valid radix'].			self peekSignIsMinus				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !!Float methodsFor: 'comparing' stamp: 'nice 1/4/2009 18:02'!hash	"Hash is reimplemented because = is implemented. Both words of the float are used. (The bitShift:'s ensure that the intermediate results do not become a large integer.) Care is taken to answer same hash as an equal Integer."	(self isFinite and: [self fractionPart = 0.0]) ifTrue: [^self truncated hash].	^ ((self basicAt: 1) bitShift: -4) +	   ((self basicAt: 2) bitShift: -4)! !!Object methodsFor: 'converting' stamp: 'nice 3/28/2006 23:29'!adaptToFloat: rcvr andCompare: selector 	"If I am involved in comparison with a Float.	Default behaviour is to process comparison as any other selectors."	^ self adaptToFloat: rcvr andSend: selector! !!Fraction methodsFor: 'comparing' stamp: 'nice 1/4/2009 20:36'!hash	"Hash is reimplemented because = is implemented.	Care is taken that a Fraction equal to a Float also have an equal hash"	| tmp |	denominator isPowerOfTwo ifTrue: [		"If denominator is a power of two, I can be exactly equal to a Float		Assume the fraction is already reduced"		tmp := self asFloat.		tmp isFinite ifTrue: [^tmp hash]].	^numerator hash bitXor: denominator hash! !!Integer methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:03'!<= aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) >= 0]						ifFalse: [^ (self digitCompare: aNumber) <= 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andCompare: #<=! !!FORTRANNumberParser methodsFor: 'accessing' stamp: 'nice 2/13/2010 00:12'!exponentLetters	"answer the list of possible exponents for Numbers.	Note: this parser will not honour precision attached to the exponent.	different exponent do not lead to different precisions.	only IEEE 754 double precision floating point numbers will be created"	^'ED'! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 00:22'!makeFloatFromMantissa: m exponent: k base: aRadix 	"Convert infinite precision arithmetic into Floating point.	This alogrithm rely on correct IEEE rounding mode	being implemented in Integer>>asFloat and Fraction>>asFloat"	^(k positive		ifTrue: [m * (aRadix raisedToInteger: k)]		ifFalse: [Fraction numerator: m denominator: (aRadix raisedToInteger: k negated)]) asFloat! !!ExtendedNumberParser methodsFor: 'parsing-private' stamp: 'nice 2/13/2010 01:54'!readNumberWithoutIntegerPartOrNil	"at this stage, sign followed by a decimal point have been read, but no intergerPart	try and form a number with a fractionPart"		| numberOfNonZeroFractionDigits numberOfTrailingZeroInFractionPart mantissa value |	integerPart := 0.	fractionPart := self nextUnsignedIntegerOrNilBase: base.	fractionPart ifNil: [		"No integer part, no fractionPart, this does not look like a number..."		^nil].	numberOfNonZeroFractionDigits := lastNonZero.	numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.	self readExponent		ifFalse: [self readScale				ifTrue: [^self makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits					andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart]].	fractionPart isZero		ifTrue: [mantissa := 0]		ifFalse: [mantissa := (fractionPart // (base raisedToInteger: numberOfTrailingZeroInFractionPart)).			exponent := exponent - numberOfNonZeroFractionDigits].	value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.	^ neg		ifTrue: [value isZero				ifTrue: [Float negativeZero]				ifFalse: [value negated]]		ifFalse: [value]! !!Float class methodsFor: 'class initialization' stamp: 'nice 3/15/2008 22:42'!initialize	"Float initialize"	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288		Pi/2 = 1.57079632679489661923132169163975144		Pi*2 = 6.28318530717958647692528676655900576		Pi/180 = 0.01745329251994329576923690768488612		2.0 ln = 0.69314718055994530941723212145817657		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi := 3.14159265358979323846264338327950288.	Halfpi := Pi / 2.0.	Twopi := Pi * 2.0.	ThreePi := Pi * 3.0.	RadiansPerDegree := Pi / 180.0.	Ln2 := 0.69314718055994530941723212145817657.	Ln10 := 10.0 ln.	Sqrt2 := 1.41421356237309504880168872420969808.	E := 2.718281828459045235360287471353.	Epsilon := 0.000000000001.  "Defines precision of mathematical functions"	MaxVal := 1.7976931348623157e308.	MaxValLn := 709.782712893384.	MinValLogBase2 := -1074.	Infinity := MaxVal * MaxVal.	NegativeInfinity := 0.0 - Infinity.	NaN := Infinity - Infinity.	NegativeZero := 1.0 / Infinity negated.! !!FORTRANNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/13/2010 00:11'!nextNumber	"main method for reading a number with FORTRAN syntax.	This one can read Real and Integer (not complex)"	| numberOfTrailingZeroInIntegerPart numberOfNonZeroFractionDigits mantissa value numberOfTrailingZeroInFractionPart noInt |	base := 10.	(self nextMatchAll: 'NaN') ifTrue: [^Float nan].	neg := self peekSignIsMinus.	(self nextMatchAll: 'Infinity') 		ifTrue: [^neg ifTrue: [Float infinity negated] ifFalse: [Float infinity]].	(noInt := sourceStream peekFor: $.) 		ifTrue: 			[integerPart := 0.			numberOfTrailingZeroInIntegerPart := 0]		ifFalse: 			[integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	(noInt or: [sourceStream peekFor: $.]) 		ifTrue: 			[fractionPart := self nextUnsignedIntegerBase: base ifFail: [nil].			fractionPart isNil 				ifTrue: 					[noInt 						ifTrue: 							["no interger part, no fraction part..."							self expected: 'a digit 0 to 9'.							^nil].					fractionPart := 0]				ifFalse: 					[numberOfNonZeroFractionDigits := lastNonZero.					numberOfTrailingZeroInFractionPart := nDigits - lastNonZero].			self readExponent]		ifFalse: 			[self readExponent ifFalse: [^neg ifTrue: [integerPart negated] ifFalse: [integerPart]].			fractionPart := 0].	fractionPart isZero 		ifTrue: 			[mantissa := integerPart // (base raisedTo: numberOfTrailingZeroInIntegerPart).			exponent := exponent + numberOfTrailingZeroInIntegerPart]		ifFalse: 			[mantissa := integerPart * (base raisedTo: numberOfNonZeroFractionDigits) 						+ (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)).			exponent := exponent - numberOfNonZeroFractionDigits].	value := self 				makeFloatFromMantissa: mantissa				exponent: exponent				base: base.	^neg ifTrue: [value isZero ifTrue: [Float negativeZero] ifFalse: [value negated]] ifFalse: [value]! !!NumberParser methodsFor: 'error' stamp: 'NikoSchwarz 10/23/2009 12:26'!expected: errorString 	requestor isNil		ifFalse: [requestor				notify: errorString , ' ->'				at: sourceStream position				in: sourceStream].	^ self fail! !!Object methodsFor: 'converting' stamp: 'nice 3/28/2006 23:30'!adaptToScaledDecimal: rcvr andCompare: selector 	"If I am involved in comparison with a ScaledDecimal.	Default behaviour is to process comparison as any other selectors."	^ self adaptToScaledDecimal: rcvr andSend: selector! !!Fraction methodsFor: 'converting' stamp: 'nice 2/13/2010 22:58'!asScaledDecimal	"Convert the receiver to a ScaledDecimal.	If there is a finite decimal representation of the receiver, then use the exact number of decimal places required.	Else, use a default number of decimals."		| pow2 pow5 q q5 |	pow2 := denominator lowBit - 1.	q := denominator bitShift: pow2 negated.	pow5 := 0.	[q = 1]		whileFalse: [			q5 := q // 5.			(q - (5 * q5)) = 0 ifFalse: [^super asScaledDecimal].			q := q5.			pow5 := pow5 + 1].	^self asScaledDecimal: (pow2 max: pow5)! !!Number class methodsFor: 'instance creation' stamp: 'nice 10/22/2009 18:46'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	be any accepted Smalltalk literal Number format.	It can include a leading radix specification, as in 16rFADE.	It can as well be NaN, Infinity or -Infinity for conveniency.	If stringOrStream does not start with a valid number description, fail."		^(SqNumberParser on: stringOrStream) nextNumber! !!Float methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:36'!<= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 45>	^ aNumber adaptToFloat: self andCompare: #<=! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 7/26/2009 00:21'!nextUnsignedIntegerOrNilBase: aRadix	"Form an unsigned integer with incoming digits from sourceStream.	Answer this integer, or nil if no digit found.	Count the number of digits and the position of lastNonZero digit and store them in instVar"		| nPackets high nDigitsHigh lastNonZeroHigh low |	"read no more digits than one elementary LargeInteger"	high :=  self nextElementaryLargeIntegerBase: aRadix.	nDigits = 0 ifTrue: [^nil].		"Not enough digits to form a LargeInteger, stop iteration"	high isLarge ifFalse: [^high].	"We now have to engage arithmetic with LargeInteger	Decompose the integer in a high and low packets of growing size:"	nPackets := 1.	nDigitsHigh := nDigits.	lastNonZeroHigh := lastNonZero.	[	low := self nextLargeIntegerBase: aRadix nPackets: nPackets .	high := high * (aRadix raisedToInteger: nDigits) + low.	lastNonZero = 0 ifFalse: [lastNonZeroHigh := lastNonZero + nDigitsHigh].	nDigitsHigh := nDigitsHigh + nDigits.	low isLarge]		whileTrue: [nPackets := nPackets * 2].	nDigits := nDigitsHigh.	lastNonZero := lastNonZeroHigh.	^high! !!Number class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 00:42'!readFrom: stringOrStream ifFail: aBlock	"Answer a number as described on aStream.  The number may	be any accepted Smalltalk literal Number format.	It can include a leading radix specification, as in 16rFADE.	It can as well be NaN, Infinity or -Infinity for conveniency.	If input does not represent a valid number, then execute fail block	and leave the stream positioned before offending character"		^(SqNumberParser on: stringOrStream) failBlock: aBlock; nextNumber! !!ClassBuilder methodsFor: 'validation' stamp: 'abc 2/12/2010 12:32'!validateInstvars: instVarArray from: oldClass forSuper: newSuper	"Check if any of the instVars of oldClass conflict with the new superclass"	| instVars usedNames temp |	instVarArray isEmpty ifTrue:[^true]. "Okay"	newSuper allowsSubInstVars ifFalse: [		self error: newSuper printString, ' does not allow subclass inst vars. See allowsSubInstVars.'. ^ false].	"Validate the inst var names"	usedNames := instVarArray asSet.	usedNames size = instVarArray size 		ifFalse:[	instVarArray do:[:var|					usedNames remove: var ifAbsent:[temp := var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp := var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames := newSuper allInstVarNames asSet.		instVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl instVarNames includes: iv) ifTrue:[temp := cl]].				(DuplicateVariableError new)					superclass: temp;					variable: iv;					signal: iv,' is already defined in ', temp name]]].	oldClass == nil ifFalse:[		usedNames := Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl instVarNames].		instVars := instVarArray.		newSuper == nil ifFalse:[instVars := instVars, newSuper allInstVarNames].		instVars do:[:iv|			(usedNames includes: iv) ifTrue:[				(DuplicateVariableError new)					superclass: oldClass;					variable: iv;					signal: iv,' is already defined in a subclass of ', temp name]]].	^true! !!Integer class methodsFor: 'instance creation' stamp: 'nice 3/15/2008 01:09'!readFrom: aStringOrStream base: base 	"Answer an instance of one of the concrete subclasses if Integer. 	Initial minus sign accepted, and bases > 10 use letters A-Z.	Imbedded radix specifiers not allowed;  use Number 	class readFrom: for that.	Raise an Error if there are no digits."	^(SqNumberParser on: aStringOrStream) nextIntegerBase: base! !!Fraction methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:03'!<= aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator <= (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andCompare: #<=! !!ExtendedNumberParser methodsFor: 'accessing' stamp: 'nice 2/13/2010 00:40'!allowPlusSign	^true! !!Integer methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:38'!< aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) > 0]						ifFalse: [^ (self digitCompare: aNumber) < 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andCompare: #<! !!NumberParser methodsFor: 'parsing-private' stamp: 'nice 7/26/2009 00:23'!makeScaledDecimalWithNumberOfNonZeroFractionDigits: numberOfNonZeroFractionDigits andNumberOfTrailingZeroInFractionPart: numberOfTrailingZeroInFractionPart	"at this point integerPart fractionPart and scale have been read out (in inst var).	Form a ScaledDecimal.	Care of eliminating trailing zeroes from the fractionPart"		| decimalMultiplier decimalFraction |	decimalMultiplier := base raisedToInteger: numberOfNonZeroFractionDigits.	decimalFraction := integerPart * decimalMultiplier + (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)) / decimalMultiplier.	^ ScaledDecimal		newFromNumber: (neg			ifTrue: [decimalFraction negated]			ifFalse: [decimalFraction])		scale: scale! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:04'!>= operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction >= operand asFraction].	^ operand adaptToScaledDecimal: self andCompare: #>=! !!Integer methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:41'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue:		[aNumber negative == self negative			ifTrue: [^ (self digitCompare: aNumber) = 0]			ifFalse: [^ false]].	^ aNumber adaptToInteger: self andCompare: #=! !!NumberParser class methodsFor: 'instance creation' stamp: 'nice 5/1/2006 02:02'!parse: aStringOrStream 	^(self new)		on: aStringOrStream;		nextNumber! !!NumberParser methodsFor: 'accessing' stamp: 'nice 5/1/2006 01:59'!requestor: anObjectOrNil	requestor := anObjectOrNil! !!NumberParser methodsFor: 'parsing-large int' stamp: 'nice 7/26/2009 00:24'!nextLargeIntegerBase: aRadix nPackets: nPackets 	"Form a Large integer with incoming digits from sourceStream.	Return this integer, or zero if no digits found.	Stop reading when no more digits or when nPackets elementary LargeInteger have been encountered.	Count the number of digits and the lastNonZero digit and store them in instVar"		| high nDigitsHigh low nDigitsLow halfPackets |	halfPackets := nPackets bitShift: -1.	halfPackets = 0 ifTrue: [^self nextElementaryLargeIntegerBase: aRadix].	high := self nextLargeIntegerBase: aRadix nPackets: halfPackets.	high isLarge ifFalse: [^high].	nDigitsHigh := nDigits.	low := self nextLargeIntegerBase: aRadix nPackets: halfPackets.	nDigitsLow := nDigits.	nDigits := nDigitsHigh + nDigitsLow.	lastNonZero = 0 ifFalse: [lastNonZero := lastNonZero + nDigitsHigh].	^high * (aRadix raisedToInteger: nDigitsLow) + low! !!NumberParser methodsFor: 'initialize-release' stamp: 'damiencassou 5/30/2008 10:56'!on: aStringOrStream 	sourceStream := aStringOrStream isString 		ifTrue: [ aStringOrStream readStream ]		ifFalse: [ aStringOrStream ].	base := 10.	neg := false.	integerPart := fractionPart := exponent := scale := 0.	requestor := failBlock := nil! !!FORTRANNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/13/2010 00:11'!nextFloat	^self nextNumber asFloat! !!Integer methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:38'!> aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) < 0]						ifFalse: [^(self digitCompare: aNumber) > 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andCompare: #>! !!Float methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:36'!< aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 43>	^ aNumber adaptToFloat: self andCompare: #<! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 00:49'!nextIntegerBase: aRadix ifFail: aBlock	"Form an integer with following digits"		| isNeg value |	isNeg := sourceStream peekFor: $-.	value := self nextUnsignedIntegerOrNilBase: aRadix.	value isNil ifTrue: [^aBlock value].	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!Fraction methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:37'!< aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator < (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andCompare: #<! !!ExtendedNumberParser methodsFor: 'parsing-private' stamp: 'nice 2/13/2010 01:55'!readNumberWithoutIntegerPart	"at this stage, sign followed by a decimal point have been read, but no intergerPart	try and form a number with a fractionPart"		^self readNumberWithoutIntegerPartOrNil ifNil: [		"No integer part, no fractionPart, this does not look like a number..."		^self expected: 'a digit between 0 and 9'].! !!Float methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:36'!= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 47>	aNumber isNumber ifFalse: [^ false].	^ aNumber adaptToFloat: self andCompare: #=! !!Fraction methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:41'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [numerator = 0 ifTrue: [^ aNumber numerator = 0].				^ (numerator * aNumber denominator) =					(aNumber numerator * denominator)				"Note: used to just compare num and denom,					but this fails for improper fractions"].	^ aNumber adaptToFraction: self andCompare: #=! !!Class methodsFor: 'initialize-release' stamp: 'abc 2/12/2010 12:37'!declare: varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| newVars conflicts |	newVars := 		(Scanner new scanFieldNames: varString)			collect: [:x | x asSymbol].	newVars do:		[:var | var first canBeGlobalVarInitial			ifFalse: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].	conflicts := false.	classPool == nil 		ifFalse: [(classPool keys reject: [:x | newVars includes: x]) do: 					[:var | self removeClassVarName: var]].	(newVars reject: [:var | self classPool includesKey: var])		do: [:var | "adding"			"check if new vars defined elsewhere"			(self bindingOf: var) ifNotNil:[					(DuplicateVariableError new)						superclass: superclass; "fake!!!!!!"						variable: var;						signal: var , ' is defined elsewhere'.					conflicts := true]].	newVars size > 0		ifTrue: 			[classPool := self classPool.			"in case it was nil"			newVars do: [:var | classPool declare: var from: Undeclared]].	^conflicts! !!Object methodsFor: 'converting' stamp: 'nice 3/28/2006 23:29'!adaptToInteger: rcvr andCompare: selector 	"If I am involved in comparison with an Integer.	Default behaviour is to process comparison as any other selectors."	^ self adaptToInteger: rcvr andSend: selector! !!Float methodsFor: 'converting' stamp: 'nice 1/4/2009 20:31'!adaptToFraction: rcvr andCompare: selector 	"If I am involved in comparison with a Fraction, convert myself to a	Fraction. This way, no bit is lost and comparison is exact."		self isFinite		ifFalse: [			selector == #= ifTrue: [^false].			selector == #~= ifTrue: [^true].			self isNaN ifTrue: [^ false].			(selector = #< or: [selector = #'<='])				ifTrue: [^ self positive].			(selector = #> or: [selector = #'>='])				ifTrue: [^ self positive not].			^self error: 'unknow comparison selector'].			"Try to avoid asTrueFraction because it can cost"	selector == #= ifTrue: [		rcvr denominator isPowerOfTwo ifFalse: [^false]].	selector == #~= ifTrue: [		rcvr denominator isPowerOfTwo ifFalse: [^true]].	^ rcvr perform: selector with: self asTrueFraction! !!NumberParser methodsFor: 'accessing' stamp: 'nice 2/12/2010 23:56'!allowPlusSignInExponent	"return a boolean indicating if plus sign is allowed or not in exponent"	^self allowPlusSign! !!NumberParser methodsFor: 'accessing' stamp: 'nice 2/12/2010 23:55'!exponentLetters	"answer the list of possible exponents for Numbers."	^self subclassResponsibility! !!Float methodsFor: 'comparing' stamp: 'nice 3/28/2006 23:36'!> aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 44>	^ aNumber adaptToFloat: self andCompare: #>! !!Fraction methodsFor: 'comparing' stamp: 'nice 2/13/2010 04:05'!> aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator > (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andCompare: #>! !!Fraction methodsFor: 'converting' stamp: 'nice 2/13/2010 03:44'!adaptToScaledDecimal: receiverScaledDecimal andSend: arithmeticOpSelector 	"Convert self to a ScaledDecimal and do the arithmetic. 	receiverScaledDecimal arithmeticOpSelector self."		^ receiverScaledDecimal perform: arithmeticOpSelector with: (self asScaledDecimal: receiverScaledDecimal scale)! !!ScaledDecimal methodsFor: 'converting' stamp: 'nice 2/13/2010 03:44'!adaptToFraction: receiver andSend: arithmeticOpSelector 	"Convert a Fraction to aScaledDecimal and do the arithmetic. 	receiver arithmeticOpSelector self."	^(receiver asScaledDecimal: scale) perform: arithmeticOpSelector with: self! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 2/12/2010 23:59'!nextNumber	"read next number from sourceStream contents"	^self subclassResponsibility! !!SqNumberParser methodsFor: 'accessing' stamp: 'nice 2/13/2010 00:00'!allowPlusSign	"return a boolean indicating if plus sign is allowed or not"	^false! !!NumberParser methodsFor: 'error' stamp: 'NikoSchwarz 10/17/2009 10:45'!fail	failBlock ifNotNil: [^failBlock value].	self error: 'Reading a number failed'! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 10/16/2008 01:05'!nextUnsignedIntegerBase: aRadix 	"Form an unsigned integer with incoming digits from sourceStream.	Fail if no digit found.	Count the number of digits and the lastNonZero digit and store int in instVar "		| value |	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^self expected: ('a digit between 0 and ' copyWith: (Character digitValue: aRadix - 1))].	^value! !Integer removeSelector: #asScaledDecimal:!SqNumberParser removeSelector: #makeFloatFromMantissa:exponent:base:!SqNumberParser removeSelector: #expected:!Number class removeSelector: #readScaledDecimal:fractionPart:digits:base:sign:from:!SqNumberParser removeSelector: #nextUnsignedIntegerOrNilBase:!SqNumberParser removeSelector: #requestor:!SqNumberParser removeSelector: #on:!SqNumberParser removeSelector: #nextLargeIntegerBase:nPackets:!Number class removeSelector: #readExponent:base:from:!SqNumberParser removeSelector: #nextIntegerBase:ifFail:!SqNumberParser removeSelector: #fail!SqNumberParser removeSelector: #nextUnsignedIntegerBase:!SqNumberParser removeSelector: #failBlock:!Number class removeSelector: #readRemainderOf:from:base:withSign:!SqNumberParser removeSelector: #nextIntegerBase:!SqNumberParser removeSelector: #readExponent!SqNumberParser removeSelector: #nextUnsignedIntegerBase:ifFail:!SqNumberParser removeSelector: #nextElementaryLargeIntegerBase:!Float initialize!