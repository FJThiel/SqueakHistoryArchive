"Change Set:		7857Collections-ar.142Collections-ar.142:Merging Collections-ul.141:- rewritten Set >> #fixCollisionsFrom: and WeakSet >> #fixCollisionsFrom:, they use #scanFor: instead of #findElementOrNil:- replaced KeyedSet >> #fixCollisionsFrom: with #keyAt:- added #postCopy to Set and subclasses, to replace it's similar but unique mechanism with #copy and #withArray:, these methods have to be removed in another version, but MethodDictionary >> #postCopy has to be added first.- Dictionary >> #values doesn't create an unnecessary copy of the result anymore."!!Set methodsFor: 'private' stamp: 'ul 9/22/2009 04:37'!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one.	We can be sure that there is an empty slot in this collection	so it's safe to use #scanFor: instead of #findElementOrNil:."	| element newIndex |	start + 1 to: array size do: [ :index |		(element := self keyAt: index) ifNil: [ ^self ].		(newIndex := self scanFor: element) = index ifFalse: [			self swap: index with: newIndex ] ].	1 to: start do: [ :index |		(element := self keyAt: index) ifNil: [ ^self ].		(newIndex := self scanFor: element) = index ifFalse: [			self swap: index with: newIndex ] ]! !!Set methodsFor: 'copying' stamp: 'ul 9/22/2009 04:48'!postCopy	array := array shallowCopy! !!WeakSet methodsFor: 'private' stamp: 'ul 9/22/2009 04:37'!fixCollisionsFrom: start	"The element at start has been removed and replaced by flag.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one.	We can be sure that there is an empty slot in this collection	so it's safe to use #scanFor: instead of #findElementOrNil:."	| element newIndex |	start + 1 to: array size do: [ :index |		(element := self keyAt: index) == flag ifTrue: [ ^self ].		(newIndex := self scanFor: element) = index ifFalse: [			self swap: index with: newIndex ] ].	1 to: start do: [ :index |		(element := self keyAt: index) == flag ifTrue: [ ^self ].		(newIndex := self scanFor: element) = index ifFalse: [			self swap: index with: newIndex ] ]! !!KeyedSet methodsFor: 'private' stamp: 'ul 9/22/2009 04:45'!keyAt: index		^keyBlock value: (array at: index)! !!Dictionary methodsFor: 'accessing' stamp: 'ul 9/22/2009 04:02'!values	"Answer a Collection containing the receiver's values."	^Array new: self size streamContents: [ :stream |		self valuesDo: [ :value | stream nextPut: value] ]! !!Dictionary methodsFor: 'copying' stamp: 'ul 9/22/2009 04:51'!postCopy	"Must copy the associations, or later store will affect both theoriginal and the copy"	array := array collect: [ :association |		association ifNotNil: [ association copy ] ]! !KeyedSet removeSelector: #fixCollisionsFrom:!