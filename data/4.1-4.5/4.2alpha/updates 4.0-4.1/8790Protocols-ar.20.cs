"Change Set:		8790Protocols-ar.20Protocols-ar.20:Make Protocols unloadable: Move ProtocolBrowser, Lexicon, and InstanceBrowser to Protocols. Classify various extension methods in Protocols."!MessageSet subclass: #ProtocolBrowser	instanceVariableNames: 'selectedClass selectedSelector'	classVariableNames: 'TextMenu'	poolDictionaries: ''	category: 'Protocols-Tools'!Lexicon subclass: #InstanceBrowser	instanceVariableNames: 'objectViewed'	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Tools'!ProtocolBrowser subclass: #Lexicon	instanceVariableNames: 'currentVocabulary categoryList categoryListIndex targetClass limitClass currentQuery currentQueryParameter selectorsVisited'	classVariableNames: ''	poolDictionaries: ''	category: 'Protocols-Tools'!!Lexicon methodsFor: 'message list menu' stamp: 'sw 4/20/2001 20:54'!messageListKey: aChar from: view	"Respond to a Command key"	aChar == $f ifTrue: [^ self obtainNewSearchString].	^ super messageListKey: aChar from: view! !!Lexicon methodsFor: 'selection' stamp: 'sd 11/20/2005 21:27'!setToShowSelector: aSelector	"Set up the receiver so that it will show the given selector"	| catName catIndex detectedItem messageIndex aList |	catName := (aList := currentVocabulary categoriesContaining: aSelector  forClass: targetClass) size > 0		ifTrue:			[aList first]		ifFalse:			[self class allCategoryName].	catIndex := categoryList indexOf: catName ifAbsent: [1].	self categoryListIndex: catIndex.	detectedItem := messageList detect:		[:anItem | (anItem upTo: $ ) asString asSymbol == aSelector] ifNone: [^ self].	messageIndex := messageList indexOf: detectedItem.	self messageListIndex: messageIndex! !!Lexicon methodsFor: 'category list' stamp: 'sw 12/12/2000 11:50'!categoryListKey: aChar from: aView	"The user hit a command-key while in the category-list.  Do something"	(aChar == $f and: [self hasSearchPane not]) ifTrue:		[^ self obtainNewSearchString].! !!Lexicon methodsFor: 'limit class' stamp: 'sw 10/12/2001 21:30'!limitClass	"Answer the most generic class to show in the browser.  By default, we go all the way up to ProtoObject"	^ limitClass ifNil: [self initialLimitClass]! !!InstanceBrowser methodsFor: 'initialization' stamp: 'ar 8/8/2009 00:31'!openOnObject: anObject inWorld: ignored showingSelector: aSelector	"Create and open a SystemWindow to house the receiver, showing the categories pane."	^self openOnObject: anObject showingSelector: aSelector! !!Lexicon class methodsFor: 'visible category names' stamp: 'sw 12/13/2000 10:54'!sendersCategoryName	"Answer the name to be used for the senders-results category"	true ifTrue: [^ #'-- "senders" results --'].	^ '-- "senders" results --'.  "so methods-strings-containing will find this"! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!setLocalClassVarRefs	"Put up a list of the class variables in the viewed object, and when the user selects one, let the query results category show all the references to that class variable."	| aName |	(aName := targetClass theNonMetaClass chooseClassVarName) ifNil: [^ self].	currentQuery := #classVarRefs.	currentQueryParameter := aName.	self showQueryResultsCategory! !!Lexicon methodsFor: 'search' stamp: 'sd 11/20/2005 21:27'!lastSearchString	"Answer the last search string, initializing it to an empty string if it has not been initialized yet"	^ currentQueryParameter ifNil: [currentQueryParameter := 'contents']! !!Lexicon methodsFor: 'transition' stamp: 'sd 11/20/2005 21:27'!retainMethodSelectionWhileSwitchingToCategory: aCategoryName	"retain method selection while switching the category-pane selection to show the category of the given name"	| aSelectedName |	aSelectedName := self selectedMessageName.	self categoryListIndex: (categoryList indexOf: aCategoryName ifAbsent: [^ self]).	aSelectedName ifNotNil: [self selectWithinCurrentCategory: aSelectedName]! !!StringHolder methodsFor: '*Protocols-Tools' stamp: 'ar 8/7/2009 23:26'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.    If in mvc, an old-style protocol browser is opened instead.  Someone who still uses mvc might wish to make the protocol-category-browser work there too, thanks."	| aClass |	(Smalltalk isMorphic and: [Smalltalk includesKey: #Lexicon]) ifFalse: [^ self spawnFullProtocol].	((aClass := self selectedClassOrMetaClass) notNil and: [aClass isTrait not]) ifTrue:		[(Smalltalk at: #Lexicon) new openOnClass: aClass showingSelector: self selectedMessageName]! !!Lexicon methodsFor: 'model glue' stamp: 'sw 3/20/2001 12:25'!targetObject	"Answer the object to which this tool is bound."	^ nil! !!Lexicon class methodsFor: 'window color' stamp: 'sw 2/26/2002 14:35'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name wording: 'Lexicon' brightColor: #(0.878 1.000 0.878) pastelColor: #(0.925 1.000 0.925) helpMessage: 'A tool for browsing the full protocol of a class.'! !!Lexicon methodsFor: 'search' stamp: 'sd 11/20/2005 21:27'!selectorsMatching	"Anwer a list of selectors in the receiver that match the current search string"	| fragment aList |	fragment := self lastSearchString asLowercase.	aList := targetClass allSelectors select:		[:aSelector | (aSelector includesSubstring: fragment caseSensitive: false) and:			[currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass]].	^ aList asSortedArray! !!Lexicon methodsFor: 'within-tool queries' stamp: 'rbb 3/1/2005 10:59'!showMethodsWithInitials	"Prompt the user for initials to scan for; then show, in the query-results category, all methods with those initials in their time stamps"	| initials |	initials := UIManager default request: 'whose initials? ' initialAnswer: Utilities authorInitials.	initials isEmptyOrNil ifTrue: [^ self].	self showMethodsWithInitials: initials! !!Lexicon methodsFor: 'limit class' stamp: 'rkrk 8/23/2009 05:29'!setLimitClass: aClass	"Set aClass as the limit class for this browser"	| currentClass currentSelector |	currentClass := self selectedClassOrMetaClass.	currentSelector := self selectedMessageName.	self limitClass: aClass.	categoryList := nil.	self categoryListIndex: 0.	self changed: #categoryList.	self changed: #methodList.	self changed: #contents.	self changed: #limitClassString.	self adjustWindowTitle.	self hasSearchPane		ifTrue:			[self setMethodListFromSearchString].	self maybeReselectClass: currentClass selector: currentSelector	! !!Lexicon methodsFor: 'category list' stamp: 'sw 12/12/2000 19:38'!selectedCategoryName	"Answer the selected category name"	^ categoryList ifNotNil:		[categoryList at: categoryListIndex ifAbsent: [nil]]! !!Lexicon methodsFor: 'limit class' stamp: 'sd 11/20/2005 21:27'!initialLimitClass	"Choose a plausible initial vlaue for the limit class, and answer it"	| oneTooFar |	limitClass := targetClass.	(#('ProtoObject' 'Object' 'Behavior' 'ClassDescription' 'Class' 'ProtoObject class' 'Object class') includes: targetClass name asString) ifTrue: [^ targetClass].	oneTooFar := (targetClass isKindOf: Metaclass)		ifTrue:			["use the fifth back from the superclass chain for Metaclasses, which is the immediate subclass of ProtoObject class.  Print <ProtoObject class allSuperclasses> to count them yourself."			targetClass allSuperclasses at: (targetClass allSuperclasses size - 5)]		ifFalse:			[targetClass allSuperclasses at: targetClass allSuperclasses size].	[limitClass superclass ~~ oneTooFar]		whileTrue: [limitClass := limitClass superclass].	^ limitClass! !!InstanceBrowser methodsFor: 'menu commands' stamp: 'sd 11/20/2005 21:27'!offerMenu	"Offer a menu to the user, in response to the hitting of the menu button on the tool pane"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'Messages of ', objectViewed nameForViewer.	aMenu addStayUpItem.	aMenu addList: #(		('vocabulary...' 			chooseVocabulary)		('what to show...'			offerWhatToShowMenu)		-		('inst var refs (here)'		setLocalInstVarRefs)		('inst var defs (here)'		setLocalInstVarDefs)		('class var refs (here)'		setLocalClassVarRefs)		-		('navigate to a sender...' 	navigateToASender)		('recent...' 					navigateToRecentMethod)		('show methods in current change set'									showMethodsInCurrentChangeSet)		('show methods with initials...'									showMethodsWithInitials)		-		"('toggle search pane' 		toggleSearch)"		-		-		('browse full (b)' 			browseMethodFull)		('browse hierarchy (h)'		classHierarchy)		('browse method (O)'		openSingleMessageBrowser)		('browse protocol (p)'		browseFullProtocol)		-		('fileOut'					fileOutMessage)		('printOut'					printOutMessage)		-		('senders of... (n)'			browseSendersOfMessages)		('implementors of... (m)'		browseMessages)		('versions (v)' 				browseVersions)		('inheritance (i)'			methodHierarchy)		-		('inst var refs' 				browseInstVarRefs)		('inst var defs' 				browseInstVarDefs)		('class var refs' 			browseClassVarRefs)		-		('viewer on me'				viewViewee)		('inspector on me'			inspectViewee)		-		('more...'					shiftedYellowButtonActivity)).	aMenu popUpInWorld: ActiveWorld! !!Lexicon methodsFor: 'history' stamp: 'sw 3/19/2001 07:43'!removeFromSelectorsVisited: aSelector	"remove aSelector from my history list"	self selectorsVisited remove: aSelector ifAbsent: []! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!getList	"Answer the receiver's message list."	^ messageList! !!Object methodsFor: '*Protocols' stamp: 'sw 5/17/2001 12:08'!currentVocabulary	"Answer the currently-prevailing default vocabulary."	^ Smalltalk isMorphic ifTrue:			[ActiveWorld currentVocabulary]		ifFalse:			[Vocabulary fullVocabulary]! !!Lexicon methodsFor: 'window title' stamp: 'sd 11/20/2005 21:27'!adjustWindowTitle	"Set the title of the receiver's window, if any, to reflect the current choices"	| aWindow aLabel catName |	(catName := self selectedCategoryName) ifNil: [^ self].	(aWindow := self containingWindow) ifNil: [^ self].	aLabel := nil.	#(	(viewedCategoryName		'Messages already viewed - ')		(allCategoryName			'All messages - ')) do:			[:aPair | catName = (self categoryWithNameSpecifiedBy: aPair first) ifTrue: [aLabel := aPair second]].	aLabel ifNil:		[aLabel := catName = self class queryCategoryName			ifTrue:				[self queryCharacterization, ' - ']			ifFalse:				['Vocabulary of ']].	aWindow setLabel: aLabel, (self targetObject ifNil: [targetClass]) nameForViewer! !!PasteUpMorph methodsFor: '*Protocols' stamp: 'sw 7/10/2005 03:55'!abandonVocabularyPreference	"Remove any memory of a preferred vocabulary in the project"	| standardViewers aVocabulary |	self removeProperty: #currentVocabularySymbol.	standardViewers := (self submorphsSatisfying: [:m | m isKindOf: ViewerFlapTab]) collect:		[:m | m referent firstSubmorph].	aVocabulary := Vocabulary vocabularyNamed: #eToy.	standardViewers do:		[:m | ((m valueOfProperty: #currentVocabularySymbol ifAbsent: [nil]) == #Vector) ifTrue:			[m switchToVocabulary: aVocabulary]]"ActiveWorld abandonVocabularyPreference"! !!Behavior methodsFor: '*Protocols' stamp: 'al 7/30/2004 22:35'!implementsVocabulary: aVocabulary	"Answer whether instances of the receiver respond to the messages in aVocabulary."	(aVocabulary isKindOf: FullVocabulary orOf: ScreenedVocabulary) ifTrue: [^ true].	^ self fullyImplementsVocabulary: aVocabulary! !!Lexicon methodsFor: 'transition' stamp: 'sw 3/20/2001 12:11'!maybeReselectClass: aClass selector: aSelector	"The protocol or limitClass may have changed, so that there is a different categoryList.  Formerly, the given class and selector were selected; if it is possible to do so, reselect them now"	aClass ifNil: [^ self].	(currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass)		ifTrue:			[self selectSelectorItsNaturalCategory: aSelector]! !!Lexicon methodsFor: 'menu commands' stamp: 'sd 11/20/2005 21:27'!showHomeCategory	"Continue to show the current selector, but show it within the context of its primary category"	| aSelector |	(aSelector := self selectedMessageName) ifNotNil:		[self preserveSelectorIfPossibleSurrounding:			[self setToShowSelector: aSelector]]! !!Lexicon methodsFor: 'message category functions' stamp: 'sw 10/8/2001 14:25'!canShowMultipleMessageCategories	"Answer whether the receiver is capable of showing multiple message categories"	^ true! !!Lexicon methodsFor: 'history' stamp: 'sd 11/20/2005 21:27'!navigateToPreviousMethod	"Navigate to the 'previous' method in the current viewing sequence"	| anIndex aSelector |	self selectorsVisited size == 0 ifTrue: [^ self].	anIndex := (aSelector := self selectedMessageName) notNil		ifTrue: [selectorsVisited indexOf: aSelector ifAbsent: [selectorsVisited size]]		ifFalse: [selectorsVisited size].	self selectedCategoryName == self class viewedCategoryName 		ifTrue:			[self selectWithinCurrentCategory: (selectorsVisited atWrap: (anIndex - 1))]		ifFalse:			[self displaySelector: (selectorsVisited atWrap: (anIndex - 1))]! !!ProtocolBrowser methodsFor: 'class list' stamp: 'nk 4/10/2001 08:16'!selectedClassOrMetaClass	^selectedClass! !!Lexicon methodsFor: 'history' stamp: 'ar 8/6/2009 18:53'!navigateToRecentMethod	"Put up a menu of recent selectors visited and navigate to the one chosen"	| visited aSelector |	(visited := self selectorsVisited) size > 1 ifTrue:		[visited := visited copyFrom: 1 to: (visited size min: 20).		aSelector := UIManager default chooseFrom: visited values: visited 			title: 'Recent methods visited in this browser'.		aSelector isEmptyOrNil ifFalse: [self displaySelector: aSelector]]! !!Lexicon methodsFor: 'history' stamp: 'sd 11/20/2005 21:27'!navigateToNextMethod	"Navigate to the 'next' method in the current viewing sequence"	| anIndex aSelector |	self selectorsVisited size == 0 ifTrue: [^ self].	anIndex := (aSelector := self selectedMessageName) notNil ifTrue: [selectorsVisited indexOf: aSelector ifAbsent: [selectorsVisited size]] ifFalse: [1].	self selectedCategoryName == self class viewedCategoryName 		ifTrue:			[self selectWithinCurrentCategory: (selectorsVisited atWrap: (anIndex + 1))]		ifFalse:			[self displaySelector: (selectorsVisited atWrap: (anIndex + 1))]! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'ar 8/7/2009 23:27'!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.  If in mvc, an old-style protocol browser is opened instead."	| objectToRepresent |	Smalltalk isMorphic ifFalse: [^ self spawnProtocol].	objectToRepresent := self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	InstanceBrowser new openOnObject: objectToRepresent showingSelector: nil! !!Object methodsFor: '*Protocols' stamp: 'ar 9/27/2005 21:04'!haveFullProtocolBrowsedShowingSelector: aSelector	"Open up a Lexicon on the receiver, having it open up showing aSelector, which may be nil"	| aBrowser |	aBrowser := (Smalltalk at: #InstanceBrowser ifAbsent:[^nil]) new useVocabulary: Vocabulary fullVocabulary.	aBrowser openOnObject: self inWorld: ActiveWorld showingSelector: aSelector	"(2@3) haveFullProtocolBrowsed"! !!Lexicon methodsFor: 'menu commands' stamp: 'sd 11/20/2005 21:27'!removeMessage	"Remove the selected message from the system."	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	super removeMessage.	"my #reformulateList method, called from the super #removeMethod method, will however try to preserve the selection, so we take pains to clobber it by the below..."	messageListIndex := 0.	self changed: #messageList.	self changed: #messageListIndex.	contents := nil.	self contentsChanged! !!Lexicon methodsFor: 'new-window queries' stamp: 'sd 4/15/2003 16:12'!browseClassVarRefs	"Let the search pertain to the target class regardless of selection"	self systemNavigation  browseClassVarRefs: targetClass theNonMetaClass ! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sw 11/21/2001 10:53'!selectorsRetrieved	"Anwer a list of selectors in the receiver that have been retrieved for the query category.  This protocol is used when reformulating a list after, say, a limitClass change"	currentQuery == #classVarRefs ifTrue: [^ self selectorsReferringToClassVar].	currentQuery == #currentChangeSet ifTrue: [^ self selectorsChanged].	currentQuery == #instVarDefs ifTrue: [^ self selectorsDefiningInstVar].	currentQuery == #instVarRefs ifTrue: [^ self selectorsReferringToInstVar].	currentQuery == #methodsWithInitials ifTrue: [^ self methodsWithInitials].	currentQuery == #selectorName ifTrue: [^ self selectorsMatching].	currentQuery == #senders ifTrue: [^ self selectorsSendingSelectedSelector].	^ #()! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 7/13/97 16:26'!on: aClass 	"Initialize with the entire protocol for the class, aClass."	self initListFrom: aClass allSelectors asSortedCollection		highlighting: aClass! !!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openFullProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openFullProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new on: aClass.	label := 'Entire protocol of: ', aClass name.	self open: aPBrowser name: label! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!categoryList	"Answer the category list for the protcol, creating it if necessary, and prepending the -- all -- category, and appending the other special categories for search results, etc."	| specialCategoryNames |	categoryList ifNil:		[specialCategoryNames := #(queryCategoryName  viewedCategoryName "searchCategoryName sendersCategoryName  changedCategoryName activeCategoryName")  collect:			[:sym | self class perform: sym].		categoryList :=			(currentVocabulary categoryListForInstance: self targetObject ofClass: targetClass limitClass: limitClass),			specialCategoryNames,			(Array with: self class allCategoryName)].	^ categoryList! !!Lexicon methodsFor: 'transition' stamp: 'sd 11/20/2005 21:27'!preserveSelectorIfPossibleSurrounding: aBlock	"Make a note of the currently-selected method; perform aBlock and then attempt to reestablish that same method as the selected one in the new circumstances"	| aClass aSelector |	aClass := self selectedClassOrMetaClass.	aSelector := self selectedMessageName.	aBlock value.		self hasSearchPane		ifTrue:			[self setMethodListFromSearchString]		ifFalse:			[self maybeReselectClass: aClass selector: aSelector]! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!selectWithinCurrentCategoryIfPossible: aSelector	"If the receiver's message list contains aSelector, navigate right to it without changing categories" 	| detectedItem messageIndex |	aSelector ifNil: [^ self].	detectedItem := messageList detect:		[:anItem | (anItem asString upTo: $ ) asSymbol == aSelector] ifNone: [^ self].	messageIndex := messageList indexOf: detectedItem.	self messageListIndex: messageIndex! !!Lexicon methodsFor: 'selection' stamp: 'tk 9/15/2001 08:14'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])"	self selection ifNil: [^ csBlock value: targetClass value: nil].	^ super setClassAndSelectorIn: csBlock! !!Lexicon methodsFor: 'history' stamp: 'sd 11/20/2005 21:27'!selectorsVisited	"Answer the list of selectors visited in this tool"	^ selectorsVisited ifNil: [selectorsVisited := OrderedCollection new]! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!reformulateCategoryList	"Reformulate the category list"	categoryList := nil.	self categoryListIndex: 0.	self changed: #categoryList.	self contentsChanged! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!showMethodsWithInitials: initials	"Make the current query be for methods stamped with the given initials"	currentQuery := #methodsWithInitials.	currentQueryParameter := initials.	self showQueryResultsCategory.	autoSelectString := nil.	self changed: #messageList.	self adjustWindowTitle! !!Lexicon methodsFor: 'transition' stamp: 'sw 3/20/2001 00:41'!noteAcceptanceOfCodeFor: newSelector	"The user has submitted new code for the given selector; take a note of it.  NB that the selectors-changed list gets added to here, but is not currently used in the system."	(self selectorsVisited includes: newSelector) ifFalse: [selectorsVisited add: newSelector].! !!Lexicon methodsFor: 'selection' stamp: 'sd 11/20/2005 21:27'!selectSelectorItsNaturalCategory: aSelector	"Make aSelector be the current selection of the receiver, with the category being its home category."	| cat catIndex detectedItem |	cat := self categoryOfSelector: aSelector.	catIndex := categoryList indexOf: cat ifAbsent:		["The method's own category is not seen in this browser; the method probably occurs in some other category not known directly to the class, but for now, we'll just use the all category"		1].	self categoryListIndex: catIndex.	detectedItem := messageList detect:		[:anItem | (anItem asString upTo: $ ) asSymbol == aSelector] ifNone: [^ self].	self messageListIndex:  (messageList indexOf: detectedItem ifAbsent: [^ self])! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString.	self changed: #selector! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!showCategoriesPane	"Show the categories pane instead of the search pane"	| aPane |	(aPane := self searchPane) ifNil: [^ Beeper beep].	self containingWindow replacePane: aPane with: self newCategoryPane.	categoryList := nil.	self changed: #categoryList.	self changed: #messageList! !!Lexicon methodsFor: 'vocabulary' stamp: 'sd 11/20/2005 21:27'!useVocabulary: aVocabulary	"Set up the receiver to use the given vocabulary"	currentVocabulary := aVocabulary! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!setLocalInstVarRefs	"Put up a list of the instance variables in the viewed object, and when the user seletcts one, let the query results category show all the references to that instance variable."	| instVarToProbe |	targetClass chooseInstVarThenDo:		[:aName | instVarToProbe := aName].	instVarToProbe isEmptyOrNil ifTrue: [^ self].	currentQuery := #instVarRefs.	currentQueryParameter := instVarToProbe.	self showQueryResultsCategory! !!Lexicon methodsFor: 'selection' stamp: 'sd 11/20/2005 21:27'!selectImplementedMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any.  In this variant, only selectors "	| selector method messages |	(selector := self selectedMessageName) ifNil: [^ self].	method := (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages := method messages) size == 0])		 ifTrue: [^ aBlock value: selector].	(messages size == 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	messages := messages select: [:aSelector | currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass].	self systemNavigation 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!Lexicon methodsFor: 'menu commands' stamp: 'sd 11/20/2005 21:27'!offerMenu	"Offer a menu to the user, in response to the hitting of the menu button on the tool pane"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: 'Lexicon'.	aMenu addStayUpItem.	aMenu addList: #(		('vocabulary...' 			chooseVocabulary)		('what to show...'			offerWhatToShowMenu)		-		('inst var refs (here)'		setLocalInstVarRefs)		('inst var defs (here)'		setLocalInstVarDefs)		('class var refs (here)'		setLocalClassVarRefs)		-		('navigate to a sender...' 	navigateToASender)		('recent...' 					navigateToRecentMethod)		('show methods in current change set'									showMethodsInCurrentChangeSet)		('show methods with initials...'									showMethodsWithInitials)		-		"('toggle search pane' 		toggleSearch)"		-		('browse full (b)' 			browseMethodFull)		('browse hierarchy (h)'		classHierarchy)		('browse method (O)'		openSingleMessageBrowser)		('browse protocol (p)'		browseFullProtocol)		-		('fileOut'					fileOutMessage)		('printOut'					printOutMessage)		-		('senders of... (n)'			browseSendersOfMessages)		('implementors of... (m)'		browseMessages)		('versions (v)' 				browseVersions)		('inheritance (i)'			methodHierarchy)		-		('inst var refs' 				browseInstVarRefs)		('inst var defs' 				browseInstVarDefs)		('class var refs' 			browseClassVarRefs)		-		('more...'					shiftedYellowButtonActivity)).	aMenu popUpInWorld: ActiveWorld! !!Lexicon methodsFor: 'within-tool queries' stamp: 'md 10/22/2003 16:14'!seeAlso	"Present a menu offering the selector of the currently selected message, as well as of all messages sent by it.  If the chosen selector is showable in the current browser, show it here, minding unsubmitted edits however"	self selectImplementedMessageAndEvaluate:		[:aSelector |			((currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass)  			 "i.e., is this aSelector available in this browser"					and: [self okToChange])				ifTrue:					[self displaySelector: aSelector]				ifFalse:					[Beeper beep.  "SysttemNavigation new browseAllImplementorsOf: aSelector"]].					"Initially I tried making this open an external implementors browser in this case, but later decided that the user model for this was unstable"! !!Lexicon methodsFor: 'vocabulary' stamp: 'ar 1/4/2010 02:21'!chooseVocabulary	"Put up a dialog affording the user a chance to choose a different vocabulary to be installed in the receiver"	| aMenu |	Smalltalk at: #Vocabulary ifPresent:[:aClass|		aMenu := MenuMorph new defaultTarget: self.		aMenu addTitle: 'Choose a vocabularyblue = currentred = imperfect' translated.		aMenu addStayUpItem.		aClass allStandardVocabularies do:[:aVocabulary |			(targetClass implementsVocabulary: aVocabulary)				ifTrue:					[aMenu add: aVocabulary vocabularyName selector: #switchToVocabulary: argument: aVocabulary.					(targetClass fullyImplementsVocabulary: aVocabulary) ifFalse:						[aMenu lastItem color: Color red].					aVocabulary == currentVocabulary ifTrue:						[aMenu lastItem color: Color blue]. 					aMenu balloonTextForLastItem: aVocabulary documentation]].		aMenu popUpInWorld: self currentWorld	].! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!selectorsReferringToInstVar	"Return a list of methods that refer to a given inst var that are in the protocol of this object"	| aList  |	aList := OrderedCollection new.	targetClass withAllSuperclassesDo: [:aClass | 		(aClass whichSelectorsAccess: currentQueryParameter asString) do: [:sel | 			sel isDoIt ifFalse: [aList add: sel]		]	].	^ aList! !!Lexicon methodsFor: 'within-tool queries' stamp: 'nb 6/17/2003 12:25'!seeAlso: aSelector	"If the requested selector is showable in the current browser, show it here, minding unsubmitted edits however"	((currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass)   "i.e., is aSelector available in this browser"					and: [self okToChange])		ifTrue:			[self displaySelector: aSelector]		ifFalse:			[Beeper beep]! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!currentQueryParameter	"Answer the current query parameter"	^ currentQueryParameter ifNil: [currentQueryParameter := 'contents']! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'sw 1/28/2001 21:01'!growable	"Answer whether the receiver is subject to manual additions and deletions"	^ false! !!Lexicon methodsFor: 'menu commands' stamp: 'sw 10/8/2001 14:34'!showMainCategory	"Continue to show the current selector, but show it within the context of its primary category.  Preserved for backward compatibility with pre-existing buttons."	^ self showHomeCategory! !!InstanceBrowser methodsFor: 'menu commands' stamp: 'sw 3/20/2001 13:20'!inspectViewee	"Open an Inspector on the object I view"	objectViewed inspect! !!Lexicon methodsFor: 'new-window queries' stamp: 'sd 4/15/2003 16:12'!browseInstVarRefs	"Let the search pertain to the target class regardless of selection"	self systemNavigation  browseInstVarRefs: targetClass! !!Lexicon methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 00:30'!openOnClass: aTargetClass inWorld: ignored showingSelector: aSelector	^self openOnClass: aTargetClass showingSelector: aSelector! !!Lexicon methodsFor: 'search' stamp: 'sd 11/20/2005 21:27'!methodListFromSearchString: fragment	"Answer a method list of methods whose selectors match the given fragment"	|  aList searchFor |	currentQueryParameter := fragment.	currentQuery := #selectorName.	autoSelectString := fragment.	searchFor := fragment asString asLowercase withBlanksTrimmed.	aList := targetClass allSelectors select:		[:aSelector | currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass].	searchFor size > 0 ifTrue:		[aList := aList select:			[:aSelector | aSelector includesSubstring: searchFor caseSensitive: false]].	^ aList asSortedArray! !!Lexicon methodsFor: 'senders' stamp: 'rbb 3/1/2005 10:59'!setSendersSearch	"Put up a list of messages sent in the current message, find all methods 	of the browsee which send the one the user chooses, and show that list 	in the message-list pane, with the 'query results' item selected in the 	category-list pane"	| selectorSet aSelector aString |	self selectedMessageName		ifNil: [aString := UIManager default request: 'Type selector to search for' initialAnswer: 'flag:'.			aString isEmptyOrNil				ifTrue: [^ self].			Symbol				hasInterned: aString				ifTrue: [:sel | aSelector := sel]]		ifNotNil: [self				selectMessageAndEvaluate: [:sel | aSelector := sel]].	aSelector		ifNil: [^ self].	selectorSet := Set new.	(self systemNavigation allCallsOn: aSelector)		do: [:anItem | selectorSet add: anItem methodSymbol].	selectorSet := selectorSet				select: [:sel | currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass].	selectorSet size > 0		ifTrue: [currentQuery := #senders.			currentQueryParameter := aSelector.			self				categoryListIndex: (categoryList indexOf: self class queryCategoryName).			self messageListIndex: 0]! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!categoryListIndex	"Answer the index of the currently-selected item in in the category list"	^ categoryListIndex ifNil: [categoryListIndex := 1]! !!CodeHolder methodsFor: '*Protocols-Tools' stamp: 'sd 11/20/2005 21:27'!spawnFullProtocol	"Create and schedule a new protocol browser on the currently selected class or meta."	| aClassOrMetaclass |	(aClassOrMetaclass := self selectedClassOrMetaClass) ifNotNil:       	[ProtocolBrowser openFullProtocolForClass: aClassOrMetaclass]! !!Lexicon methodsFor: 'search' stamp: 'sd 11/20/2005 21:27'!setMethodListFromSearchString	"Set the method list of the receiver based on matches from the search string"	| fragment aList |	self okToChange ifFalse: [^ self].	fragment := currentQueryParameter.	fragment := fragment asString asLowercase withBlanksTrimmed.	aList := targetClass allSelectors select:		[:aSelector | currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass].	fragment size > 0 ifTrue:		[aList := aList select:			[:aSelector | aSelector includesSubstring: fragment caseSensitive: false]].	aList size == 0 ifTrue:		[^ Beeper beep].	self initListFrom: aList asSortedArray highlighting: targetClass.	messageListIndex :=  messageListIndex min: messageList size.	self changed: #messageList! !!Lexicon methodsFor: 'new-window queries' stamp: 'sd 4/16/2003 19:43'!browseInstVarDefs	"Let the search pertain to the target class regardless of selection"	 self systemNavigation browseInstVarDefs: targetClass! !!Lexicon methodsFor: 'category list' stamp: 'sw 12/13/2000 10:38'!categoryWithNameSpecifiedBy: aSelector	"Answer the category name obtained by sending aSelector to my class.  This provides a way to avoid hard-coding the wording of conventions such as '-- all --'"	^ self class perform: aSelector! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!showMethodsInCurrentChangeSet	"Set the current query to be for methods in the current change set"	currentQuery := #currentChangeSet.	autoSelectString := nil.	self categoryListIndex: (categoryList indexOf: self class queryCategoryName).! !!Lexicon methodsFor: 'basic operation' stamp: 'sd 11/20/2005 21:27'!messageListIndex: anIndex	"Set the message list index as indicated, and update the history list if appropriate"	| newSelector current |	current := self selectedMessageName.	super messageListIndex: anIndex.	anIndex = 0 ifTrue: [		self editSelection: #newMessage.		self contentsChanged].	(newSelector := self selectedMessageName) ifNotNil: 		[self updateSelectorsVisitedfrom: current to: newSelector]! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!setLocalInstVarDefs	"Put up a list of the instance variables in the viewed object, and when the user seletcts one, let the query results category show all the references to that instance variable."	| instVarToProbe |	targetClass chooseInstVarThenDo:		[:aName | instVarToProbe := aName].	instVarToProbe isEmptyOrNil ifTrue: [^ self].	currentQuery := #instVarDefs.	currentQueryParameter := instVarToProbe.	self showQueryResultsCategory! !!Lexicon methodsFor: 'category list' stamp: 'sw 3/7/2001 12:19'!categoriesPane	"If there is a pane defined by #categoryList in my containing window, answer it, else answer nil"	^ self listPaneWithSelector: #categoryList! !!Lexicon class methodsFor: 'visible category names' stamp: 'sw 3/19/2001 08:03'!viewedCategoryName	"Answer the name to be used for the previously-viewed-methods category"	true ifTrue: [^ #'-- active --'].	^ '-- active --' asSymbol	 "For benefit of method-strings-containing-it search"! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!selector	"Answer the receiver's selected selector."	^ selectedSelector! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!categoryListIndex: anIndex	"Set the category list index as indicated"	| categoryName aList found existingSelector |	existingSelector := self selectedMessageName.	categoryListIndex := anIndex.	anIndex > 0		ifTrue:			[categoryName := categoryList at: anIndex]		ifFalse:			[contents := nil].	self changed: #categoryListIndex.	found := false.	#(	(viewedCategoryName		selectorsVisited)		(queryCategoryName		selectorsRetrieved)) do:			[:pair |				categoryName = (self class perform: pair first)					ifTrue:						[aList := self perform: pair second.						found := true]].	found ifFalse:		[aList := currentVocabulary allMethodsInCategory: categoryName forInstance: self targetObject ofClass: targetClass].	categoryName = self class queryCategoryName ifFalse: [autoSelectString := nil].	self initListFrom: aList highlighting: targetClass.	messageListIndex := 0.	self changed: #messageList.	contents := nil.	self contentsChanged.	self selectWithinCurrentCategoryIfPossible: existingSelector.	self adjustWindowTitle! !!Lexicon methodsFor: 'toolbuilder' stamp: 'rkrk 8/23/2009 05:27'!buildCodePaneWith: builder		| spec standardButtonPanel codePane customPanelSpec |	spec := super buildCodePaneWith: builder.	standardButtonPanel := spec children		detect: [:ea | ea isKindOf:  PluggablePanelSpec]		ifNone: [^ spec]. "do nothing if optionalButtons not enabled"	customPanelSpec := self buildCustomButtonsWith: builder.	customPanelSpec frame: (0@0.12 corner: 1@0.24).	spec children add: customPanelSpec after: standardButtonPanel.	"resize code pane so that new panel fits in"	codePane := spec children detect: [:ea | ea isKindOf:  PluggableCodePaneSpec].	codePane frame:  (codePane frame withTop: 0.24).	^ spec.! !!Lexicon methodsFor: 'toolbuilder' stamp: 'rkrk 8/23/2009 05:31'!addSpecialButtonsTo: buttonPanelSpec with: builder	| homeCatBtnSpec menuBtnSpec mostGenericBtnSpec |	homeCatBtnSpec := builder pluggableButtonSpec new		model: self;		action: #showHomeCategory;		label: (ScriptingSystem formAtKey: #Cat) asMorph;		help: 'show this method''s home category';		yourself.	menuBtnSpec := builder pluggableButtonSpec new		model: self;		action: #offerMenu;		label: (ScriptingSystem formAtKey: #TinyMenu) asMorph;		help: 'click here to get a menu with further options';		yourself.	mostGenericBtnSpec :=builder pluggableButtonSpec new		model: self;		action: #chooseLimitClass;		label: #limitClassString;		help: 'Governs which classes'' methods should be shown.  If this is the same as the viewed class, then only methods implemented in that class will be shown.  If it is ProtoObject, then methods of all classes in the vocabulary will be shown.'.	buttonPanelSpec children		add: homeCatBtnSpec;		addFirst: mostGenericBtnSpec;		addFirst: menuBtnSpec.! !!Lexicon methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!initListFrom: selectorCollection highlighting: aClass 	"Make up the messageList with items from aClass in boldface.  Provide a final filtering in that only selectors whose implementations fall within my limitClass will be shown."		messageList := OrderedCollection new.	selectorCollection do: 		[:selector | | item defClass |  defClass := aClass whichClassIncludesSelector: selector.		(defClass notNil and: [defClass includesBehavior: self limitClass]) ifTrue:			[item := selector, '     (' , defClass name , ')'.			item := item asText.			defClass == aClass ifTrue: [item allBold].			"(self isThereAnOverrideOf: selector) ifTrue: [item addAttribute: TextEmphasis struckOut]."			"The above has a germ of a good idea but could be very slow"			messageList add: item]]! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'sd 11/20/2005 21:27'!spawnFullProtocol	"Spawn a window showing full protocol for the receiver's selection"	| objectToRepresent |	objectToRepresent := self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openFullProtocolForClass: objectToRepresent class! !!Lexicon methodsFor: 'toolbuilder' stamp: 'ar 8/7/2009 23:24'!openOnClass: aTargetClass showingSelector: aSelector	currentVocabulary ifNil: [currentVocabulary := Vocabulary fullVocabulary].	targetClass := aTargetClass.	self initialLimitClass.		self reformulateCategoryList.	ToolBuilder open: self.	self adjustWindowTitle.! !!Lexicon methodsFor: 'category list' stamp: 'sw 12/12/2000 11:50'!categoryListMenu: aMenu shifted: aBoolean	"Answer the menu for the category list"	^ aMenu labels: 'find...(f)' lines: #() selections: #(obtainNewSearchString)! !!Lexicon methodsFor: 'toolbuilder' stamp: 'ar 8/8/2009 17:07'!buildWith: builder	"Create the ui for the browser"	| windowSpec max |	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	windowSpec := self buildWindowWith: builder specs: {		(0@0 corner: 0.5@max) -> [self buildCategoryListWith: builder].		(0.5@0 corner: 1@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	^builder build: windowSpec! !!ProtocolBrowser methodsFor: 'private' stamp: 'sd 11/20/2005 21:27'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])"	| i classAndSelString selString sel |	sel := self selection ifNil: [^ csBlock value: nil value: nil].	(sel isKindOf: MethodReference) ifTrue: [		sel setClassAndSelectorIn: csBlock	] ifFalse: [		selString := sel asString.		i := selString indexOf: $(.		"Rearrange to  <className> [class] <selectorName> , and use MessageSet"		classAndSelString := (selString copyFrom: i + 1 to: selString size - 1) , ' ' ,							(selString copyFrom: 1 to: i - 1) withoutTrailingBlanks.		MessageSet parse: classAndSelString toClassAndSelector: csBlock.	].! !!Lexicon methodsFor: 'search' stamp: 'rbb 3/1/2005 10:59'!obtainNewSearchString	"Put up a box allowing the user to enter a fresh search string"	| fragment |		fragment := UIManager default request: 'type method name or fragment: ' initialAnswer: self currentQueryParameter.	fragment ifNil: [^ self].	(fragment := fragment copyWithout: $ ) size == 0  ifTrue: [^ self].	currentQueryParameter := fragment.	fragment := fragment asLowercase.	currentQuery := #selectorName.	self showQueryResultsCategory.	self messageListIndex: 0! !!Lexicon methodsFor: 'basic operation' stamp: 'sd 11/20/2005 21:27'!annotation	"Provide a line of annotation material for a middle pane."	| aCategoryName |	self selectedMessageName ifNotNil: [^ super annotation].	(aCategoryName := self selectedCategoryName) ifNil:		[^ self hasSearchPane			ifTrue:				['type a message name or fragment in the top pane and hit RETURN or ENTER']			ifFalse:				[''  "currentVocabulary documentation"]].	(aCategoryName = self class queryCategoryName) ifTrue:		[^ self queryCharacterization].			#(	(allCategoryName			'Shows all methods, whatever other category they belong to')	(viewedCategoryName		'Methods visited recently.  Use  "-" button to remove a method from this category.')	(queryCategoryName		'Query results'))		do:			[:pair | (self categoryWithNameSpecifiedBy: pair first) = aCategoryName ifTrue: [^ pair second]].	^ currentVocabulary categoryCommentFor: aCategoryName! !!Lexicon methodsFor: 'control buttons' stamp: 'sd 11/20/2005 21:27'!customButtonSpecs	"Answer a triplet defining buttons, in the format:			button label			selector to send			help message"	| aa |	aa := contentsSymbol == #tiles ifTrue: [{   "Consult Ted Kaehler regarding this bit"	{'tiles'.				#tilesMenu.					'tiles for assignment and constants'. 	true}.	{'vars'.				#varTilesMenu.	'tiles for instance variables and a new temporary'. 	true}		}] ifFalse: [#()].	"true in 4th place means act on mouseDown"	^ aa, #(	('follow'			seeAlso							'view a method I implement that is called by this method')	('find'				obtainNewSearchString			'find methods by name search')	('sent...'			setSendersSearch				'view the methods I implement that send a given message')	('<'					navigateToPreviousMethod 		'view the previous active method')	('>'					navigateToNextMethod 			'view the next active method')	('-'					removeFromSelectorsVisited		'remove this method from my active list'))! !!CodeHolder methodsFor: '*Protocols-Tools' stamp: 'sd 11/20/2005 21:27'!spawnProtocol	| aClassOrMetaclass |	"Create and schedule a new protocol browser on the currently selected class or meta."	(aClassOrMetaclass := self selectedClassOrMetaClass) ifNotNil:       	[ProtocolBrowser openSubProtocolForClass: aClassOrMetaclass]! !!Lexicon methodsFor: 'senders' stamp: 'ar 8/6/2009 18:52'!navigateToASender	"Present the user with a list of senders of the currently-selected 	message, and navigate to the chosen one"	| selectorSet chosen aSelector |	aSelector := self selectedMessageName.	selectorSet := Set new.	(self systemNavigation allCallsOn: aSelector)		do: [:anItem | selectorSet add: anItem methodSymbol].	selectorSet := selectorSet				select: [:sel | currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass].	selectorSet size == 0		ifTrue: [^ Beeper beep].	self okToChange		ifFalse: [^ self].	chosen := UIManager default chooseFrom: selectorSet asSortedArray values: selectorSet asSortedArray.	chosen isEmptyOrNil		ifFalse: [self displaySelector: chosen]! !!Lexicon methodsFor: 'search' stamp: 'sw 12/11/2000 14:46'!toggleSearch	"Toggle the determination of whether a categories pane or a search pane shows"	self hasSearchPane		ifTrue:	[self showCategoriesPane]		ifFalse:	[self showSearchPane]! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:33'!list	"Answer the receiver's message list."	^ messageList! !!Lexicon methodsFor: 'selection' stamp: 'md 2/20/2006 15:03'!selectedMessage	"Answer the source method for the currently selected message."	(categoryList notNil and: [(categoryListIndex isNil or: [categoryListIndex == 0])])		ifTrue:			[^ '---'].	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'here would go the documentation for the protocol category, if any.'].		self showingDecompile ifTrue: [^ self decompiledSourceIntoContents].		self showingDocumentation ifTrue: [^ self commentContents].		currentCompiledMethod := class compiledMethodAt: selector ifAbsent: [nil].		^ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: class]! !!Lexicon methodsFor: 'vocabulary' stamp: 'sw 1/26/2001 19:40'!switchToVocabulary: aVocabulary	"Make aVocabulary be the current one in the receiver"	self preserveSelectorIfPossibleSurrounding:		[self useVocabulary: aVocabulary.		self reformulateCategoryList.		self adjustWindowTitle]! !!Lexicon class methodsFor: 'visible category names' stamp: 'sw 3/19/2001 08:17'!queryCategoryName	"Answer the name to be used for the query-results category"	true ifTrue: [^ #'-- query results --'].	^ '-- query results --' asSymbol   "Placed here so a message-strings-containing-it query will find this method"! !!InstanceBrowser methodsFor: 'menu commands' stamp: 'sw 3/20/2001 13:19'!viewViewee	"Open a viewer on the object I view"	objectViewed beViewed! !!ProtocolBrowser methodsFor: 'private' stamp: 'nice 12/26/2009 20:38'!initListFrom: selectorCollection highlighting: aClass 	"Make up the messageList with items from aClass in boldface."	messageList := OrderedCollection new.	selectorCollection do: [ :selector |  		| defClass item |		defClass := aClass whichClassIncludesSelector: selector.		item := selector, '     (' , defClass name , ')'.		defClass == aClass ifTrue: [item := item asText allBold].		messageList add: (			MethodReference new				setClass: defClass 				methodSymbol: selector 				stringVersion: item		)	].	selectedClass := aClass.! !!Lexicon methodsFor: 'search' stamp: 'sd 11/20/2005 21:27'!lastSendersSearchSelector	"Answer the last senders search selector, initializing it to a default value if it does not already have a value"	^ currentQueryParameter ifNil: [currentQueryParameter := #flag:]! !!Lexicon methodsFor: 'limit class' stamp: 'sd 11/20/2005 21:27'!limitClassString	"Answer a string representing the current choice of most-generic-class-to-show"	| most |	(most := self limitClass) == ProtoObject		ifTrue:	[^ 'All'].	most == targetClass		ifTrue:	[^ most name].	^ 'Only through ', most name! !!Lexicon methodsFor: 'category list' stamp: 'nb 6/17/2003 12:25'!chooseCategory: aCategory	"Choose the category of the given name, if there is one"	self categoryListIndex: (categoryList indexOf: aCategory ifAbsent: [^ Beeper beep])! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!selectorsReferringToClassVar	"Return a list of methods that refer to given class var that are in the 	protocol of this object"	| aList aClass nonMeta poolAssoc |	nonMeta := targetClass theNonMetaClass.	aClass := nonMeta classThatDefinesClassVariable: currentQueryParameter.	aList := OrderedCollection new.	poolAssoc := aClass classPool associationAt: currentQueryParameter asSymbol.	(self systemNavigation allCallsOn: poolAssoc)		do: [:elem | (nonMeta isKindOf: elem actualClass)				ifTrue: [aList add: elem methodSymbol]].	^ aList! !!Lexicon methodsFor: 'history' stamp: 'sd 11/20/2005 21:27'!removeFromSelectorsVisited	"Remove the currently-selected method from the active set"	| aSelector |	(aSelector := self selectedMessageName) ifNil: [^ self].	self removeFromSelectorsVisited: aSelector.	self chooseCategory: self class viewedCategoryName! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'sd 11/20/2005 21:27'!spawnProtocol	"Spawn a protocol on browser on the receiver's selection"	| objectToRepresent |	objectToRepresent := self selectionIndex == 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openSubProtocolForClass: objectToRepresent class! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sw 11/21/2001 10:48'!methodsWithInitials	"Answer the list of method selectors within the scope of this tool whose time stamps begin with the initials designated by my currentQueryParameter"	^ self methodsWithInitials: currentQueryParameter! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!showQueryResultsCategory	"Point the receiver at the query-results category and set the search string accordingly"	autoSelectString := self currentQueryParameter.	self categoryListIndex: (categoryList indexOf: self class queryCategoryName).	self messageListIndex: 0! !!PasteUpMorph methodsFor: '*Protocols' stamp: 'sw 7/10/2005 02:53'!makeVectorUseConformToPreference	"Make certain that the use of vectors in this project conforms to the current preference setting."	| prefValue currentValue |	prefValue := Preferences useVectorVocabulary.	currentValue := self currentlyUsingVectorVocabulary.	prefValue ~~ currentValue ifTrue:		[currentValue			ifTrue:				[self abandonVocabularyPreference]			ifFalse:				[self installVectorVocabulary]]! !!Lexicon methodsFor: 'contents' stamp: 'tk 9/14/2001 16:37'!contents	"We have a class, allow new messages to be defined"	editSelection == #newMessage ifTrue: [^ targetClass sourceCodeTemplate].	^ super contents! !!Lexicon methodsFor: 'transition' stamp: 'sw 1/12/2001 00:33'!reformulateListNoting: newSelector	"A method has possibly been submitted for the receiver with newSelector as its selector; If the receiver has a way of reformulating its message list, here is a chance for it to do so"	super reformulateListNoting: newSelector.	newSelector ifNotNil:		[self displaySelector: newSelector]! !!InstanceBrowser methodsFor: 'window title' stamp: 'sw 3/20/2001 12:18'!startingWindowTitle	"Answer the initial window title to apply"	^ 'Vocabulary of ', objectViewed nameForViewer! !!Lexicon methodsFor: 'within-tool queries' stamp: 'nice 12/27/2009 03:10'!selectorsChanged	"Return a list of methods in the current change set (or satisfying some 	other such criterion) that are in the protocol of this object"	| aList targetedClass |	targetedClass := self targetObject				ifNil: [targetClass]				ifNotNil: [self targetObject class].	aList := OrderedCollection new.	ChangeSet current methodChanges		associationsDo: [:classChgAssoc | classChgAssoc value				associationsDo: [:methodChgAssoc | | aClass | (methodChgAssoc value == #change							or: [methodChgAssoc value == #add])						ifTrue: [(aClass := targetedClass whichClassIncludesSelector: methodChgAssoc key)								ifNotNil: [aClass name = classChgAssoc key										ifTrue: [aList add: methodChgAssoc key]]]]].	^ aList! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!newCategoryPane	"Formulate a category pane for insertion into the receiver's pane list"	| aListMorph |	aListMorph := PluggableListMorph on: self list: #categoryList			selected: #categoryListIndex changeSelected: #categoryListIndex:			menu: #categoryListMenu:shifted:			keystroke: #categoryListKey:from:.	aListMorph setNameTo: 'categoryList'.	aListMorph menuTitleSelector: #categoryListMenuTitle.	^ aListMorph! !!Lexicon class methodsFor: 'visible category names' stamp: 'sw 12/13/2000 10:56'!allCategoryName	"Answer the name to be used for the all category"	true ifTrue: [^ #'-- all --'].	'-- all --' asSymbol  "Placed here so a message-strings-containing-it query will find this method"! !!ProtocolBrowser class methodsFor: 'instance creation' stamp: 'di 7/13/97 15:15'!openSubProtocolForClass: aClass 	"Create and schedule a browser for the entire protocol of the class."	"ProtocolBrowser openSubProtocolForClass: ProtocolBrowser."	| aPBrowser label |	aPBrowser := ProtocolBrowser new onSubProtocolOf: aClass.	label := 'Sub-protocol of: ', aClass name.	self open: aPBrowser name: label! !!Lexicon methodsFor: 'model glue' stamp: 'sw 3/20/2001 12:11'!doItReceiver	"This class's classPool has been jimmied to be the classPool of the class being browsed. A doIt in the code pane will let the user see the value of the class variables.  Here, if the receiver is affiliated with a specific instance, we give give that primacy"	^ self targetObject ifNil: [self selectedClass ifNil: [FakeClassPool new]]! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 11/26/1999 19:39'!onSubProtocolOf: aClass 	"Initialize with the entire protocol for the class, aClass,		but excluding those inherited from Object."	| selectors |	selectors := Set new.	aClass withAllSuperclasses do:		[:each | (each == Object or: [each == ProtoObject]) 			ifFalse: [selectors addAll: each selectors]].	self initListFrom: selectors asSortedCollection		highlighting: aClass! !!Lexicon methodsFor: 'toolbuilder' stamp: 'nice 12/27/2009 03:10'!buildCustomButtonsWith: builder	"This method if very similar to StringHolder>>buildOptionalButtonsWith:.	Refactor and pass in button specs?"	| panelSpec |	panelSpec := builder pluggablePanelSpec new.	panelSpec children: OrderedCollection new.	self customButtonSpecs do: [:spec | | buttonSpec |		buttonSpec := builder pluggableActionButtonSpec new.		buttonSpec model: self.		buttonSpec label: spec first.		buttonSpec action: spec second.		spec size > 2 ifTrue: [buttonSpec help: spec third].		panelSpec children add: buttonSpec.	].	panelSpec layout: #horizontal. "buttons"	self addSpecialButtonsTo: panelSpec with: builder.	^panelSpec! !!Lexicon methodsFor: 'search' stamp: 'sd 11/20/2005 21:27'!lastSearchString: aString	"Make a note of the last string searched for in the receiver"	currentQueryParameter := aString asString.	currentQuery := #selectorName.	autoSelectString := aString.	self setMethodListFromSearchString.	^ true! !!Lexicon methodsFor: 'history' stamp: 'sw 12/11/2000 08:49'!updateSelectorsVisitedfrom: oldSelector to: newSelector	"Update the list of selectors visited."	newSelector == oldSelector ifTrue: [^ self].	self selectorsVisited remove: newSelector ifAbsent: [].			(selectorsVisited includes:  oldSelector)		ifTrue:			[selectorsVisited add: newSelector after: oldSelector]		ifFalse:			[selectorsVisited add: newSelector]! !!Lexicon methodsFor: 'toolbuilder' stamp: 'rkrk 8/23/2009 03:04'!buildCategoryListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #categoryList; 		getIndex: #categoryListIndex; 		setIndex: #categoryListIndex:; 		menu: #categoryListMenu:shifted:; 		keyPress: #categoryListKey:from:.	^listSpec! !!Lexicon methodsFor: 'selection' stamp: 'sd 11/20/2005 21:27'!categoryOfSelector: aSelector 	"Answer the name of the defining category for aSelector, or nil if none"	| classDefiningSelector |	classDefiningSelector := targetClass whichClassIncludesSelector: aSelector.	classDefiningSelector		ifNil: [^ nil].	"can happen for example if one issues this from a change-sorter for a 	message that is recorded as having been removed"	^ classDefiningSelector whichCategoryIncludesSelector: aSelector! !!Lexicon methodsFor: 'search' stamp: 'sw 12/11/2000 15:26'!hasSearchPane	"Answer whether receiver has a search pane"	^ self searchPane notNil! !!InstanceBrowser class methodsFor: 'window color' stamp: 'sw 2/26/2002 14:31'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name wording: 'Instance Browser' brightColor: #(0.806 1.0 1.0) pastelColor: #(0.925 1.000 1.0) helpMessage: 'A tool for browsing the full protocol of an instance.'! !!Object methodsFor: '*Protocols' stamp: 'sw 1/30/2001 22:24'!haveFullProtocolBrowsed	"Open up a Lexicon on the receiver"	^ self haveFullProtocolBrowsedShowingSelector: nil	"(2@3) haveFullProtocolBrowsed"! !!Lexicon methodsFor: 'search' stamp: 'sd 11/20/2005 21:27'!showSearchPane	"Given that the receiver is showing the categories pane, replace that with a search pane.  Though there is a residual UI for obtaining this variant, it is obscure and the integrity of the protocol-category-browser when there is no categories pane is not necessarily assured at the moment."	| aPane |	(aPane := self categoriesPane) ifNil: [^ Beeper beep].	self containingWindow replacePane: aPane with: self newSearchPane.	categoryList := nil.	self changed: #categoryList.	self changed: #messageList! !!Lexicon methodsFor: 'transition' stamp: 'sw 12/11/2000 02:00'!reformulateList	"Make the category list afresh, and reselect the current selector if appropriate"	self preserveSelectorIfPossibleSurrounding:		[super reformulateList.		self categoryListIndex: categoryListIndex]! !!Lexicon class methodsFor: 'visible category names' stamp: 'sw 12/14/2000 14:15'!activeCategoryName	"Answer the name to be used for the active-methods category"	true ifTrue: [^ #'-- current working set --'].	'-- current working set --' asSymbol "Placed here so a message-strings-containing-it query will find this method"! !!Lexicon methodsFor: 'menu commands' stamp: 'sw 10/18/2001 08:10'!showCategory	"A revectoring blamable on history.  Not sent in the image, but grandfathered buttons may still send this."	^ self showHomeCategory! !!Lexicon methodsFor: 'window title' stamp: 'sw 3/19/2001 08:45'!addModelItemsToWindowMenu: aMenu	"Add model-related item to the window menu"	super addModelItemsToWindowMenu: aMenu. 	aMenu add: 'choose vocabulary...' target: self action: #chooseVocabulary! !!Lexicon methodsFor: 'basic operation' stamp: 'sd 11/20/2005 21:27'!displaySelector: aSelector	"Set aSelector to be the one whose source shows in the browser.  If there is a category list, make it highlight a suitable category"	| detectedItem messageIndex |	self chooseCategory: (self categoryDefiningSelector: aSelector).	detectedItem := messageList detect:		[:anItem | (anItem asString upTo: $ ) asSymbol == aSelector] ifNone: [^ Beeper beep].	messageIndex := messageList indexOf: detectedItem.	self messageListIndex: messageIndex! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!selectorsDefiningInstVar	"Return a list of methods that define a given inst var that are in the protocol of this object"	| aList  |	aList := OrderedCollection new.	targetClass withAllSuperclassesDo:		[:aClass | 			(aClass whichSelectorsStoreInto: currentQueryParameter asString) do: 				[:sel | sel isDoIt ifFalse: [aList add: sel]			]		].	^ aList! !!Lexicon methodsFor: 'selection' stamp: 'sd 11/20/2005 21:27'!selectWithinCurrentCategory: aSelector	"If aSelector is one of the selectors seen in the current category, select it"	| detectedItem |	detectedItem := self messageList detect:		[:anItem | (anItem asString upTo: $ ) asSymbol == aSelector] ifNone: [^ self].	self messageListIndex:  (messageList indexOf: detectedItem ifAbsent: [^ self])! !!PasteUpMorph methodsFor: '*Protocols' stamp: 'sw 6/4/2001 19:38'!currentVocabulary	"Answer the default Vocabulary object to be applied when scripting"	| aSym aVocab |	aSym := self valueOfProperty: #currentVocabularySymbol.	aSym ifNil:		[aVocab := self valueOfProperty: #currentVocabulary.		aVocab ifNotNil:			[aSym := aVocab vocabularyName.			self setProperty: #currentVocabularySymbol toValue: aSym.			self removeProperty: #currentVocabulary]].	^ aSym		ifNotNil:			[Vocabulary vocabularyNamed: aSym]		ifNil:			[Vocabulary fullVocabulary]! !!Lexicon methodsFor: 'category list' stamp: 'sw 12/1/2000 22:13'!categoryListMenuTitle	"Answer the menu title for the category list menu"	^ 'categories'! !!Lexicon methodsFor: 'model glue' stamp: 'sd 11/20/2005 21:27'!okayToAccept	"Answer whether it is okay to accept the receiver's input"	| ok aClass reply |	(ok := super okayToAccept) ifTrue:		[((aClass := self selectedClassOrMetaClass) ~~ targetClass) ifTrue:			[reply := UIManager default chooseFrom: 	{'okay, no problem'. 	'cancel - let me reconsider'. 	'compile into ', targetClass name, ' instead'.	'compile into a new uniclass'} title:'Caution!!  This would beaccepted into class ', aClass name, '.Is that okay?' .			reply = 1 ifTrue: [^ true].			reply ~~ 2 ifTrue:				[self notYetImplemented].			^ false]].	^ ok! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sd 11/20/2005 21:27'!methodsWithInitials: initials	"Return a list of selectors representing methods whose timestamps have the given initials and which are in the protocol of this object and within the range dictated by my limitClass."	| classToUse |	classToUse := self targetObject ifNotNil: [self targetObject class] ifNil: [targetClass].  "In support of lightweight uniclasses"	^ targetClass allSelectors select:		[:aSelector | (currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: classToUse limitClass: limitClass) and:			[Utilities doesMethod: aSelector forClass: classToUse bearInitials: initials]].! !!Lexicon methodsFor: 'limit class' stamp: 'sd 11/20/2005 21:27'!chooseLimitClass	"Put up a menu allowing the user to choose the most generic class to show"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	targetClass withAllSuperclasses do:		[:aClass | 			aClass == ProtoObject				ifTrue:					[aMenu addLine].			aMenu add: aClass name selector: #setLimitClass: argument: aClass.			aClass == limitClass ifTrue:				[aMenu lastItem color: Color red].			aClass == targetClass ifTrue: [aMenu addLine]].	aMenu addTitle: 'Show only methodsimplemented at or above...'.  "heh heh -- somebody please find nice wording here!!"	aMenu popUpInWorld: self currentWorld! !!Lexicon methodsFor: 'limit class' stamp: 'sd 11/20/2005 21:27'!limitClass: aClass	"Set the most generic class to show as indicated"	limitClass := aClass! !!Lexicon methodsFor: 'within-tool queries' stamp: 'sw 7/23/2002 12:43'!queryCharacterization	"Answer a characterization of the most recent query"	currentQuery == #selectorName		ifTrue: [^ 'My methods whose names include "', self lastSearchString, '"'].	currentQuery == #methodsWithInitials		ifTrue: [^ 'My methods stamped with initials ', currentQueryParameter].	currentQuery == #senders		ifTrue: [^ 'My methods that send #', self lastSendersSearchSelector].	currentQuery == #currentChangeSet		ifTrue: [^ 'My methods in the current change set'].	currentQuery == #instVarRefs		ifTrue:	[^ 'My methods that refer to instance variable "', currentQueryParameter, '"'].	currentQuery == #instVarDefs		ifTrue:	[^ 'My methods that store into instance variable "', currentQueryParameter, '"'].	currentQuery == #classVarRefs		ifTrue:	[^ 'My methods that refer to class variable "', currentQueryParameter, '"'].	^ 'Results of queries will show up here'! !!InstanceBrowser methodsFor: 'initialization' stamp: 'ar 8/7/2009 23:26'!openOnObject: anObject showingSelector: aSelector	"Create and open a SystemWindow to house the receiver, showing the categories pane."	objectViewed := anObject.	self openOnClass: anObject class showingSelector: aSelector! !!InstanceBrowser methodsFor: 'target-object access' stamp: 'sw 3/20/2001 12:10'!targetObject	"Answer the object to which this tool is bound"	^ objectViewed! !!ProtocolBrowser methodsFor: 'accessing' stamp: 'di 7/13/97 16:35'!setSelector: aString	"Set the currently selected message selector to be aString."	selectedSelector := aString! !!Lexicon methodsFor: 'senders' stamp: 'nice 12/27/2009 03:10'!selectorsSendingSelectedSelector	"Assumes lastSendersSearchSelector is already set"	| selectorSet |	autoSelectString := (self lastSendersSearchSelector upTo: $:) asString.	selectorSet := Set new.	(self systemNavigation allCallsOn: self lastSendersSearchSelector)		do: [:anItem | | sel cl | 			sel := anItem methodSymbol.			cl := anItem actualClass.			((currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass)					and: [targetClass includesBehavior: cl])				ifTrue: [selectorSet add: sel]].	^ selectorSet asSortedArray! !!Lexicon methodsFor: 'window title' stamp: 'sw 3/20/2001 12:18'!startingWindowTitle	"Answer the initial window title to apply"	^ 'Vocabulary of ', targetClass nameForViewer! !!Vocabulary class methodsFor: 'class initialization' stamp: 'ar 1/4/2010 02:34'!initializeStandardVocabularies	"Initialize a few standard vocabularies and place them in the AllStandardVocabularies list."	AllStandardVocabularies _ nil.	Smalltalk at: #EToyVocabulary		ifPresent:[:aClass| self addStandardVocabulary: aClass new].	Smalltalk at: #EToyVectorVocabulary		ifPresent:[:aClass| self addStandardVocabulary: aClass new].	self addStandardVocabulary: self newPublicVocabulary.	self addStandardVocabulary: FullVocabulary new.	self addStandardVocabulary: self newQuadVocabulary.	self addStandardVocabulary: ColorType new.	self addStandardVocabulary: BooleanType new.	self addStandardVocabulary: GraphicType new.	Smalltalk at: #PlayerType		ifPresent:[:aClass| self addStandardVocabulary: aClass new].	self addStandardVocabulary: SoundType new.	self addStandardVocabulary: StringType new.	self addStandardVocabulary: MenuType new.	self addStandardVocabulary: UnknownType new.	Smalltalk at: #ScriptNameType		ifPresent:[:aClass| self addStandardVocabulary: aClass new].	self addStandardVocabulary: (SymbolListType new symbols: #(simple raised inset complexFramed complexRaised complexInset complexAltFramed complexAltRaised complexAltInset); vocabularyName: #BorderStyle; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(lines arrows arrowheads dots); vocabularyName: #TrailStyle; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(leftToRight rightToLeft topToBottom bottomToTop); vocabularyName: #ListDirection; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(topLeft bottomRight center justified); vocabularyName: #ListCentering; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(buttonDown whilePressed buttonUp); vocabularyName: #ButtonPhase; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(rotate #'do not rotate' #'flip left right' #'flip up down'); vocabularyName: #RotationStyle; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(rigid spaceFill shrinkWrap); vocabularyName: #Resizing; yourself).	self addStandardVocabulary: self newSystemVocabulary.  "A custom vocabulary for Smalltalk -- still under development)"	self numberVocabulary.  		"creates and adds it"	"self wonderlandVocabulary."  	"creates and adds it"	self vocabularyForClass: Time.   "creates and adds it"	Smalltalk at: #KedamaPatchType ifPresent:[:aClass| 		self addStandardVocabulary: (aClass new vocabularyName: #Patch; yourself).	].	self addStandardVocabulary: (SymbolListType new symbols: #(wrap stick bouncing); vocabularyName: #EdgeMode; yourself).	self addStandardVocabulary: (SymbolListType new symbols: #(logScale linear color); vocabularyName: #PatchDisplayMode; yourself).	"Vocabulary initialize"! !!PasteUpMorph methodsFor: '*Protocols' stamp: 'sw 7/9/2005 12:58'!installVectorVocabulary	"Install the experimental Vector vocabulary as the default for the current project"	| standardViewers aVocabulary |	self setProperty: #currentVocabularySymbol toValue: #Vector.	standardViewers := (self submorphsSatisfying: [:m | m isKindOf: ViewerFlapTab]) collect:		[:m | m referent firstSubmorph].	aVocabulary := Vocabulary vocabularyNamed: #Vector.	standardViewers do: [:m | m switchToVocabulary: aVocabulary]! !!Lexicon methodsFor: 'category list' stamp: 'sd 11/20/2005 21:27'!categoryDefiningSelector: aSelector	"Answer a category in which aSelector occurs"	| categoryNames |	categoryNames := categoryList copyWithoutAll: #('-- all --').	^ currentVocabulary categoryWithNameIn: categoryNames thatIncludesSelector: aSelector forInstance: self targetObject ofClass: targetClass! !!Lexicon methodsFor: 'selection' stamp: 'tk 9/15/2001 08:17'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	self setClassAndSelectorIn: [:c :s | ^c]! !!Lexicon methodsFor: 'toolbuilder' stamp: 'sw 1/24/2001 21:25'!wantsAnnotationPane	"This kind of browser always wants annotation panes, so answer true"	^ true! !