"Change Set:		7313Kernel-ar.189Kernel-ar.189:Closure compiler, main part."!ProtoObject subclass: #MessageCatcher	instanceVariableNames: 'accumulator'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!Object variableSubclass: #BlockClosure	instanceVariableNames: 'outerContext startpc numArgs'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!ByteArray variableByteSubclass: #CompiledMethod	instanceVariableNames: ''	classVariableNames: 'SmallFrame LargeFrame'	poolDictionaries: ''	category: 'Kernel-Methods'!InstructionPrinter subclass: #RelativeInstructionPrinter	instanceVariableNames: 'printCode labels labelling'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!InstructionClient subclass: #InstructionPrinter	instanceVariableNames: 'method scanner stream oldPC innerIndents indent printPC indentSpanOfFollowingJump'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!InstructionClient subclass: #BlockStartLocator	instanceVariableNames: 'nextJumpIsAroundBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!ContextPart variableSubclass: #MethodContext	instanceVariableNames: 'method closureOrNil receiver'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!ClassDescription methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream 	aStream nextPutAll: self name! !!BlockContext methodsFor: 'accessing' stamp: 'eem 6/15/2008 11:32'!contextForLocalVariables	"Answer the context in which local variables (temporaries) are stored."	^home! !!CompiledMethod methodsFor: 'comparing' stamp: 'eem 7/29/2008 14:46'!= method	| numLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(numLits := self numLiterals) ~= method numLiterals ifTrue: [^false].	"``Dont bother checking FFI and named primitives''	 (#(117 120) includes: self primitive) ifTrue: [^ true]."	1 to: numLits do:		[:i| | lit1 lit2 |		lit1 := self literalAt: i.		lit2 := method literalAt: i.		lit1 = lit2 ifFalse:			[(i = 1 and: [#(117 120) includes: self primitive])				ifTrue: [lit1 isArray							ifTrue:								[(lit2 isArray and: [lit1 allButLast = lit2 allButLast]) ifFalse:									[^false]]							ifFalse: "ExternalLibraryFunction"								[(lit1 analogousCodeTo: lit2) ifFalse:									[^false]]] ifFalse:			[i = (numLits - 1) ifTrue: "properties"				[(lit1 analogousCodeTo: lit2) ifFalse:					[^false]] ifFalse:			 [lit1 isFloat				ifTrue:					["Floats match if values are close, due to roundoff error."					(lit1 closeTo: lit2) ifFalse: [^false]. self flag: 'just checking'. self halt]				ifFalse:					["any other discrepancy is a failure"					^ false]]]]].	^true! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/16/2008 09:52'!thirdByte	"Answer the third byte of the current bytecode."	^self method at: pc + 2! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/3/2008 14:10'!value: firstArg value: secondArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	| newContext ncv |	<primitive: 203>	numArgs ~= 2 ifTrue:		[self numArgsError: 2].	newContext := self asContextWithSender: thisContext sender.	ncv := self numCopiedValues.	newContext stackp: ncv + 2.	newContext at: 1 put: firstArg.	newContext at: 2 put: secondArg.	1 to: ncv do:		[:i| newContext at: i + 2 put: (self at: i)].	thisContext privSender: newContext! !!BlockClosure methodsFor: 'exceptions' stamp: 'ajh 10/9/2001 16:51'!onDNU: selector do: handleBlock	"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)"	^ self on: MessageNotUnderstood do: [:exception |		exception message selector = selector			ifTrue: [handleBlock valueWithPossibleArgs: {exception}]			ifFalse: [exception pass]	  ]! !!BlockClosure methodsFor: 'exceptions' stamp: 'eem 8/22/2008 14:22'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue b |	<primitive: 198>	returnValue := self valueNoContextSwitch.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b := aBlock.		thisContext tempAt: 1 put: nil.  "Could be aBlock := nil, but arguments cannot be modified"		b value.	].	^ returnValue! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/15/2008 11:29'!jump: offset	"Print the Unconditional Jump bytecode."	labelling		ifTrue:			[labels at: scanner pc + offset + 1 put: true.			 self print: 'jumpBy: ', offset printString,				' to: ', (scanner pc + offset - method initialPC) printString]		ifFalse:			[self print: 'jumpTo: ', (labels at: scanner pc + offset + 1)]! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 6/1/2008 09:39'!startpc	^startpc! !!BlockClosure class methodsFor: 'instance creation' stamp: 'eem 9/3/2008 14:02'!outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil	^(self new: anArrayOrNil basicSize)		outerContext: aContext		startpc: aStartpc		numArgs: argCount		copiedValues: anArrayOrNil! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 6/15/2008 11:34'!popIntoTemporaryVariable: offset 	"Simulate the action of bytecode that removes the top of the stack and 	stores it into one of my temporary variables."	self contextForLocalVariables at: offset + 1 put: self pop! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 8/29/2008 06:28'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	"Simulate the action of a 'closure copy' bytecode whose result is the	 new BlockClosure for the following code"	| copiedValues |	numCopied > 0		ifTrue:			[copiedValues := Array new: numCopied.			 numCopied to: 1 by: -1 do:				[:i|				copiedValues at: i put: self pop]]		ifFalse:			[copiedValues := nil].	self push: (BlockClosure				outerContext: self				startpc: pc				numArgs: numArgs				copiedValues: copiedValues).	self jump: blockSize! !!ContextPart methodsFor: 'debugger access' stamp: ''!swapSender: coroutine 	"Replace the receiver's sender with coroutine and answer the receiver's 	previous sender. For use in coroutining."	| oldSender |	oldSender := sender.	sender := coroutine.	^oldSender! !!BlockClosure methodsFor: 'exceptions' stamp: 'eem 8/22/2008 14:29'!ifCurtailed: aBlock	"Evaluate the receiver with an abnormal termination action.	 Evaluate aBlock only if execution is unwound during execution	 of the receiver.  If execution of the receiver finishes normally	 do not evaluate aBlock."	<primitive: 198>	^self valueNoContextSwitch! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/25/2008 14:06'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	self print: 'popIntoTemp: ', remoteTempIndex printString, ' inVectorAt: ', tempVectorIndex printString! !!InstructionPrinter methodsFor: 'initialize-release' stamp: 'eem 8/4/2008 16:26'!printInstructionsOn: aStream do: aBlock	"Append to the stream, aStream, a description of each bytecode in the	 instruction stream. Evaluate aBlock with the receiver, the scanner and	 the stream after each instruction."	| end |	stream := aStream.	scanner := InstructionStream on: method.	end := method endPC.	oldPC := scanner pc.	innerIndents := Array new: end withAll: 0.	[scanner pc <= end] whileTrue:		[scanner interpretNextInstructionFor: self.		 aBlock value: self value: scanner value: stream]! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 7/29/2008 17:23'!headerDescription	"Answer a description containing the information about the form of the 	receiver and the form of the context needed to run the receiver."	| s |	s := '' writeStream.	self header printOn: s.	s cr; nextPutAll: '"primitive: '.	self primitive printOn: s.	s cr; nextPutAll: ' numArgs: '.	self numArgs printOn: s.	s cr; nextPutAll: ' numTemps: '.	self numTemps printOn: s.	s cr; nextPutAll: ' numLiterals: '.	self numLiterals printOn: s.	s cr; nextPutAll: ' frameSize: '.	self frameSize printOn: s.	s cr; nextPutAll: ' isClosureCompiled: '.	self isBlueBookCompiled not printOn: s.	s nextPut: $"; cr.	^ s contents! !!MethodContext methodsFor: 'accessing' stamp: 'eem 7/22/2008 11:58'!outerContext	"Answer the context within which the receiver is nested."	^closureOrNil == nil ifFalse:		[closureOrNil outerContext]! !!BlockStartLocator methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 13:54'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	"Answer the size of the block"	^blockSize! !!MethodContext methodsFor: 'private-exceptions' stamp: 'eem 7/22/2008 11:57'!cannotReturn: result	closureOrNil notNil ifTrue:		[^self cannotReturn: result to: sender].	ToolSet		debugContext: thisContext		label: 'computation has been terminated'		contents: nil! !!MethodContext methodsFor: 'private' stamp: 'eem 6/15/2008 11:27'!aboutToReturn: result through: firstUnwindContext 	"Called from VM when an unwindBlock is found between self and its home.	 Return to home's sender, executing unwind blocks on the way."	self methodReturnContext return: result! !!MethodContext methodsFor: 'private' stamp: 'eem 7/22/2008 11:59'!setSender: s receiver: r method: m arguments: args 	"Create the receiver's initial state."	sender := s.	receiver := r.	method := m.	closureOrNil := nil.	pc := method initialPC.	self stackp: method numTemps.	1 to: args size do: [:i | self at: i put: (args at: i)]! !!InstructionStream class methodsFor: 'compiling' stamp: 'eem 6/19/2008 10:00'!isContextClass	^false! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 5/15/2008 10:57'!longPrintRelativeOn: aStream indent: tabs	"List of all the byte codes in a method with a short description of each" 	self isQuick ifTrue: 		[^self longPrintOn: aStream indent: tabs].	self primitive = 0 ifFalse:		[aStream tab: tabs. self printPrimitiveOn: aStream].	(RelativeInstructionPrinter on: self)		indent: tabs;		printCode: false;		printInstructionsOn: aStream.! !!BlockClosure methodsFor: 'evaluating' stamp: 'brp 9/25/2003 13:49'!durationToRun	"Answer the duration taken to execute this block."	^ Duration milliSeconds: self timeToRun! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/27/2008 10:45'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 212>	"The number of indexable fields of fixed-length objects is 0"	^self primitiveFail! !!RelativeInstructionPrinter methodsFor: 'initialize-release' stamp: 'eem 5/15/2008 10:56'!printCode: aBoolean	printCode := aBoolean! !!CompiledMethod methodsFor: 'debugger support' stamp: 'emm 5/30/2002 09:22'!hasBreakpoint	^BreakpointManager methodHasBreakpoint: self! !!ContextPart methodsFor: 'controlling' stamp: 'eem 8/29/2008 06:27'!closureCopy: numArgs copiedValues: anArray	"Distinguish a block of code from its enclosing method by 	creating a BlockClosure for that block. The compiler inserts into all 	methods that contain blocks the bytecodes to send the message 	closureCopy:copiedValues:. Do not use closureCopy:copiedValues: in code that you write!! Only the 	compiler can decide to send the message closureCopy:copiedValues:. Fail if numArgs is 	not a SmallInteger. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 200>	^BlockClosure outerContext: self startpc: pc + 2 numArgs: numArgs copiedValues: anArray! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/16/2008 09:51'!scanFor: scanBlock	"Answer the index of the first bytecode for which scanBlock answer true	 when supplied with that bytecode."	| method end byte type |	method := self method.	end := method endPC.	[pc <= end] whileTrue: 		[(scanBlock value: (byte := method at: pc)) ifTrue:			[^true].		 type := byte // 16.		 pc :=	type = 8 "extensions"					ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: byte \\ 16 + 1)]					ifFalse: [type = 10 "long jumps"								ifTrue: [pc + 2]								ifFalse: [pc + 1]]].	^false! !!BlockClosure methodsFor: 'controlling' stamp: 'ls 9/24/1999 09:45'!repeatWithGCIf: testBlock	| ans |	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"	ans := self value.	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self value ].	^ans! !!BlockClosure methodsFor: 'controlling' stamp: 'jcg 7/8/2007 18:25'!whileNotNil: aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	^ [self value notNil] whileTrue: [aBlock value]	! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 13:51'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Remove Top Of Stack And Store Into Offset of Temp Vector bytecode."! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/3/2008 14:11'!value: firstArg value: secondArg value: thirdArg value: fourthArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	| newContext ncv |	<primitive: 205>	numArgs ~= 4 ifTrue:		[self numArgsError: 4].	newContext := self asContextWithSender: thisContext sender.	ncv := self numCopiedValues.	newContext stackp: ncv + 4.	newContext at: 1 put: firstArg.	newContext at: 2 put: secondArg.	newContext at: 3 put: thirdArg.	newContext at: 4 put: fourthArg.	1 to: ncv do:		[:i| newContext at: i + 4 put: (self at: i)].	thisContext privSender: newContext! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 5/15/2008 13:17'!printInstructionsOn: aStream do: aBlock	"Append to the stream, aStream, a description of each bytecode in the instruction stream.	  Evaluate aBlock with the receiver, the scanner and the stream after each instruction."		| label |	labelling := true.	labels := Array new: method size withAll: false.	super printInstructionsOn: (String new: 1024) writeStream do: [:ig :no :re|].	label := 0.	labels withIndexDo:		[:bool :index|		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].	labelling := false.	super printInstructionsOn: aStream do: aBlock! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 6/16/2008 14:04'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	self print: 'closureNumCopied: ', numCopied printString			, ' numArgs: ', numArgs printString			, ' bytes ', scanner pc printString			, ' to ', (scanner pc + blockSize - 1) printString.	innerIndents		atAll: (scanner pc to: scanner pc + blockSize - 1)		put: (innerIndents at: scanner pc - 1) + 1! !!BlockClosure methodsFor: 'private' stamp: 'eem 5/28/2008 14:50'!copyForSaving	"Answer a copy of the receiver suitable for serialization.	 Notionally, if the receiver's outerContext has been returned from then nothing	 needs to be done and we can use the receiver. But there's a race condition	 determining if the receiver has been returned from (it could be executing in a	 different process). So answer a copy anyway."	^self shallowCopy postCopy! !!BlockStartLocator methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 14:16'!send: selector super: supered numArgs: numberArguments	nextJumpIsAroundBlock := #closureCopy:copiedValues: == selector	"Don't use		nextJumpIsAroundBlock := #(blockCopy: closureCopy:copiedValues:) includes: selector	 since BlueBook BlockContexts do not have their own temps."! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 6/26/2008 09:17'!receiver	^outerContext receiver! !!BlockClosure methodsFor: 'controlling' stamp: ''!whileFalse	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is false." 	^ [self value] whileFalse: []! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/3/2008 14:11'!value: firstArg value: secondArg value: thirdArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	| newContext ncv |	<primitive: 204>	numArgs ~= 3 ifTrue:		[self numArgsError: 3].	newContext := self asContextWithSender: thisContext sender.	ncv := self numCopiedValues.	newContext stackp: ncv + 3.	newContext at: 1 put: firstArg.	newContext at: 2 put: secondArg.	newContext at: 3 put: thirdArg.	1 to: ncv do:		[:i| newContext at: i + 3 put: (self at: i)].	thisContext privSender: newContext! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/27/2008 15:57'!basicAt: index put: value	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not	 an Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 211>	index isInteger ifTrue:		[self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 5/15/2008 11:04'!abstractSymbolic	"Answer a String that contains a list of all the byte codes in a method with a	 short description of each, using relative addresses and not including code bytes."	| aStream |	aStream := WriteStream on: (String new: 1000).	self longPrintRelativeOn: aStream indent: 0.	^aStream contents! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/3/2008 14:09'!value	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	| newContext ncv |	<primitive: 201>	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	newContext := self asContextWithSender: thisContext sender.	(ncv := self numCopiedValues) > 0 ifTrue:		[newContext stackp: ncv.		1 to: ncv do: "nil basicSize = 0"			[:i| newContext at: i put: (self at: i)]].	thisContext privSender: newContext! !!BlockClosure methodsFor: 'controlling' stamp: 'sma 5/12/2000 13:22'!repeat	"Evaluate the receiver repeatedly, ending only if the block explicitly returns."	[self value. true] whileTrue! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/27/2008 15:56'!basicAt: index	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not an	 Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 210>	index isInteger ifTrue:		[self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/4/2008 10:57'!selectorToSendOrSelf	"If this instruction is a send, answer the selector, otherwise answer self."	| byte byte2 |	byte := self method at: pc.	byte < 131 ifTrue: [^self].	byte >= 176		ifTrue: 			["special byte or short send"			byte >= 208				ifTrue: [^self method literalAt: (byte bitAnd: 15) + 1]				ifFalse: [^Smalltalk specialSelectorAt: byte - 176 + 1]]		ifFalse: 			[byte <= 134 ifTrue: 				[byte2 := self method at: pc + 1.				 byte = 131 ifTrue: [^self method literalAt: byte2 \\ 32 + 1].				 byte = 132 ifTrue: [byte2 < 64 ifTrue: [^self method literalAt: (self method at: pc + 2) + 1]].				 byte = 133 ifTrue: [^self method literalAt: byte2 \\ 32 + 1].				 byte = 134 ifTrue: [^self method literalAt: byte2 \\ 64 + 1]]]! !!CompiledMethod methodsFor: 'decompiling' stamp: 'md 2/18/2006 19:40'!decompileClass: aClass selector: selector	"Return the decompiled parse tree that represents self"	self deprecated: 'just call #decompile on the CompiledMethod'.	^ self decompilerClass new decompile: selector in: aClass method: self! !!MethodProperties methodsFor: 'testing' stamp: 'eem 5/15/2008 09:25'!hasAtLeastTheSamePropertiesAs: aMethodProperties	"Answer if the recever has at least the same properties as the argument.	 N.B. The receiver may have additional properties and still answer true."	aMethodProperties keysAndValuesDo:		[:k :v|		properties ifNil: [^false].		^(properties at: k ifAbsent: [^false]) = v].	^true! !!BlockClosure methodsFor: 'exceptions' stamp: 'sma 5/11/2000 19:38'!assert	self assert: self! !!BlockClosure methodsFor: 'scheduling' stamp: 'ajh 10/16/2002 11:14'!forkAndWait	"Suspend current process and execute self in new process, when it completes resume current process"	| semaphore |	semaphore := Semaphore new.	[self ensure: [semaphore signal]] fork.	semaphore wait.! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 6/10/2008 09:47'!tempsAndValues	"Return a string of the temporary variabls and their current values"	^self debuggerMap tempsAndValuesForContext: self! !!MethodContext methodsFor: 'accessing' stamp: 'eem 7/22/2008 11:58'!methodReturnContext	"Answer the context from which an ^-return should return from."	closureOrNil == nil ifTrue:		[^self].	^closureOrNil outerContext methodReturnContext! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 13:49'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	"Push Closure bytecode."! !!Behavior methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream 	"Refer to the comment in Object|printOn:." 	aStream nextPutAll: 'a descendent of '.	superclass printWithClosureAnalysisOn: aStream! !!BlockContext methodsFor: 'accessing' stamp: 'eem 5/24/2008 11:20'!closureHome	"Answer the context from which an ^-return should return from."	^self home! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/3/2008 16:15'!blockExtentsInto: aDictionary from: initialPC to: endPC scanner: scanner numberer: numbererBlock	"Support routine for startpcsToBlockExtents"	| extentStart blockSizeOrLocator |	self flag: 'belongs in DebuggerMethodMap'.	extentStart := numbererBlock value.	[scanner pc <= endPC] whileTrue:		[blockSizeOrLocator := scanner interpretNextInstructionFor: BlockStartLocator new.		 blockSizeOrLocator isInteger ifTrue:			[self				blockExtentsInto: aDictionary				from: scanner pc				to: scanner pc + blockSizeOrLocator - 1				scanner: scanner				numberer: numbererBlock]].	aDictionary at: initialPC put: (extentStart to: numbererBlock value).	^aDictionary! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/29/2008 14:02'!send: selector super: supered numArgs: numberArguments	"Print the Send Message With Selector, selector, bytecode. The argument, 	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found in 	the top numArguments locations on the stack and the receiver just 	below them."	self print: (supered ifTrue: ['superSend: '] ifFalse: ['send: ']) , selector.	indentSpanOfFollowingJump := #(blockCopy: #closureCopy:copiedValues:) includes: selector! !!MethodContext methodsFor: 'system simulation' stamp: 'eem 9/3/2008 13:58'!pushArgs: args "<Array>" from: sendr "<ContextPart>" 	"Helps simulate action of the value primitive for closures.	 This is used by ContextPart>>runSimulated:contextAtEachStep:"	stackp ~= 0 ifTrue:		[self error: 'stack pointer should be zero!!'].	closureOrNil ifNil:		[self error: 'context needs a closure!!'].	args do: [:arg| self push: arg].	1 to: closureOrNil numCopiedValues do:		[:i|		self push: (closureOrNil copiedValueAt: i)].	sender := sendr! !!BlockClosure methodsFor: 'controlling' stamp: 'jf 9/3/2003 16:39'!doWhileTrue: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is true." 	| result |	[result := self value.	conditionBlock value] whileTrue.	^ result! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 6/15/2008 11:27'!methodReturnTop	"Simulate the action of a 'return top of stack' bytecode. This corresponds	 to source expressions like '^something'."	^self return: self pop from: self methodReturnContext! !!InstructionStream methodsFor: 'private' stamp: 'eem 6/16/2008 09:49'!interpretExtension: offset in: method for: client	| type offset2 byte2 byte3 byte4 |	offset <= 6 ifTrue: 		["Extended op codes 128-134"		byte2 := method at: pc. pc := pc + 1.		offset <= 2 ifTrue:			["128-130:  extended pushes and pops"			type := byte2 // 64.			offset2 := byte2 \\ 64.			offset = 0 ifTrue: 				[type = 0 ifTrue: [^client pushReceiverVariable: offset2].				type = 1 ifTrue: [^client pushTemporaryVariable: offset2].				type = 2  ifTrue: [^client pushConstant: (method literalAt: offset2 + 1)].				type = 3 ifTrue: [^client pushLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 1 ifTrue: 				[type = 0 ifTrue: [^client storeIntoReceiverVariable: offset2].				type = 1 ifTrue: [^client storeIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: offset2 + 1)]].			offset = 2 ifTrue: 				[type = 0 ifTrue: [^client popIntoReceiverVariable: offset2].				type = 1 ifTrue: [^client popIntoTemporaryVariable: offset2].				type = 2 ifTrue: [self error: 'illegalStore'].				type = 3  ifTrue: [^client popIntoLiteralVariable: (method literalAt: offset2 + 1)]]].		"131-134: extended sends"		offset = 3 ifTrue:  "Single extended send"			[^client send: (method literalAt: byte2 \\ 32 + 1)					super: false numArgs: byte2 // 32].		offset = 4 ifTrue:    "Double extended do-anything"			[byte3 := method at: pc. pc := pc + 1.			type := byte2 // 32.			type = 0 ifTrue: [^client send: (method literalAt: byte3 + 1)									super: false numArgs: byte2 \\ 32].			type = 1 ifTrue: [^client send: (method literalAt: byte3 + 1)									super: true numArgs: byte2 \\ 32].			type = 2 ifTrue: [^client pushReceiverVariable: byte3].			type = 3 ifTrue: [^client pushConstant: (method literalAt: byte3 + 1)].			type = 4 ifTrue: [^client pushLiteralVariable: (method literalAt: byte3 + 1)].			type = 5 ifTrue: [^client storeIntoReceiverVariable: byte3].			type = 6 ifTrue: [^client popIntoReceiverVariable: byte3].			type = 7 ifTrue: [^client storeIntoLiteralVariable: (method literalAt: byte3 + 1)]].		offset = 5 ifTrue:  "Single extended send to super"			[^client send: (method literalAt: byte2 \\ 32 + 1)					super: true numArgs: byte2 // 32].		offset = 6 ifTrue:   "Second extended send"			[^client send: (method literalAt: byte2 \\ 64 + 1)					super: false numArgs: byte2 // 64]].	offset = 7 ifTrue: [^client doPop].	offset = 8 ifTrue: [^client doDup].	offset = 9 ifTrue: [^client pushActiveContext].	byte2 := method at: pc. pc := pc + 1.	offset = 10 ifTrue:		[^byte2 < 128			ifTrue: [client pushNewArrayOfSize: byte2]			ifFalse: [client pushConsArrayWithElements: byte2 - 128]].	offset = 11 ifTrue: [^self error: 'unusedBytecode'].	byte3 := method at: pc.  pc := pc + 1.	offset = 12 ifTrue: [^client pushRemoteTemp: byte2 inVectorAt: byte3].	offset = 13 ifTrue: [^client storeIntoRemoteTemp: byte2 inVectorAt: byte3].	offset = 14 ifTrue: [^client popIntoRemoteTemp: byte2 inVectorAt: byte3].	"offset = 15"	byte4 := method at: pc.  pc := pc + 1.	^client		pushClosureCopyNumCopiedValues: (byte2 bitShift: -4)		numArgs: (byte2 bitAnd: 16rF)		blockSize: (byte3 * 256) + byte4! !!InstructionPrinter methodsFor: 'printing' stamp: 'eem 5/29/2008 13:53'!print: instruction 	"Append to the receiver a description of the bytecode, instruction." 	| code |	stream tab: self indent.	printPC ifTrue: [stream print: oldPC; space].	stream tab: (innerIndents at: oldPC).	stream nextPut: $<.	oldPC to: scanner pc - 1 do: 		[:i | 		code := (method at: i) radix: 16.		stream nextPut: 			(code size < 2				ifTrue: [$0]				ifFalse: [code at: 1]).		stream nextPut: code last; space].	stream skip: -1.	stream nextPut: $>.	stream space.	stream nextPutAll: instruction.	stream cr.	oldPC := scanner pc.	"(InstructionPrinter compiledMethodAt: #print:) symbolic."! !!ContextPart methodsFor: 'debugger access' stamp: 'md 2/17/2006 12:04'!methodSelector	"Answer the selector of the method that created the receiver."	self deprecated: 'use #selector'.	^self selector.! !!BlockClosure methodsFor: 'scheduling' stamp: 'eem 5/28/2008 16:16'!asContext	"Create a MethodContext that is ready to execute self.  Assumes self takes no args (if it does the args will be nil)"	^self asContextWithSender: nil! !!BlockClosure methodsFor: 'controlling' stamp: ''!whileFalse: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is false."	^ [self value] whileFalse: [aBlock value]! !!CompiledMethod methodsFor: 'printing' stamp: 'md 2/16/2006 13:26'!decompileString	^self decompile decompileString! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 5/24/2008 16:21'!writesField: varIndex	"Answer whether the receiver stores into the instance variable indexed	 by the argument."	"eem 5/24/2008 Rewritten to no longer assume the compler uses the	 most compact encoding available (for EncoderForLongFormV3 support)."	| varIndexCode scanner |	self isQuick ifTrue: [^false].	varIndexCode := varIndex - 1.	^(scanner := InstructionStream on: self) scanFor:		[:b|		b >= 96		and: [b <= 103				ifTrue: [b - 96 = varIndexCode]				ifFalse:					[(b = 129 or: [b = 130])						ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]						ifFalse:							[b = 132							 and: [(scanner followingByte between: 160 and: 223)							 and: [scanner thirdByte = varIndexCode]]]]]]! !!MethodContext methodsFor: 'accessing' stamp: 'eem 6/15/2008 11:28'!activeHome	"If executing closure, search senders for the activation of the original	 (outermost) method that (indirectly) created my closure (the closureHome).	 If the closureHome is not found on the sender chain answer nil."	| methodReturnContext |	self isExecutingBlock ifFalse: [^self].	self sender ifNil: [^nil].	methodReturnContext := self methodReturnContext.	^self sender findContextSuchThat: [:ctxt | ctxt = methodReturnContext]! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/27/2008 11:32'!pushNewArrayOfSize: arraySize 	self push: (Array new: arraySize)! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 9/3/2008 13:57'!copiedValueAt: i	<primitive: 60>	^self basicAt: i! !!BlockClosure methodsFor: 'testing' stamp: 'eem 5/23/2008 13:48'!isClosure	^true! !!BlockContext methodsFor: 'accessing' stamp: 'eem 6/15/2008 11:33'!methodReturnContext	"Answer the context from which an ^-return should return from."	^home! !!BlockClosure methodsFor: 'private' stamp: 'eem 5/28/2008 14:56'!reentrant	"Answer a version of the recever that can be reentered.	 Closures are reentrant (unlike BlockContect) so simply answer self."	^self! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 5/24/2008 16:19'!readsRef: literalAssociation 	"Answer whether the receiver loads the argument."	"eem 5/24/2008 Rewritten to no longer assume the compler uses the	 most compact encoding available (for EncoderForLongFormV3 support)."	| litIndex scanner |	(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:		[^false].	litIndex := litIndex - 1.	^(scanner := InstructionStream on: self) scanFor:		[:b|		b >= 64		and:			[b <= 95				ifTrue: [b - 64 = litIndex]				ifFalse:					[b = 128						ifTrue: [scanner followingByte - 192 = litIndex]						ifFalse:							[b = 132							 and: [(scanner followingByte between: 128 and: 159)							 and: [scanner thirdByte = litIndex]]]]]]! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/30/2008 17:42'!pushConsArrayWithElements: numElements 	self print: 'pop ', numElements printString, ' into (Array new: ', numElements printString, ')'! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/15/2008 11:29'!jump: offset if: condition 	"Print the Conditional Jump bytecode."	labelling		ifTrue:			[labels at: scanner pc + offset + 1 put: true.			 self print: 				(condition ifTrue: ['jumpTrueBy: '] ifFalse: ['jumpFalseBy: ']), offset printString,				' to: ', (labelling							ifTrue: [(scanner pc + offset - method initialPC) printString]							ifFalse: [labels at: scanner pc + offset])]		ifFalse:			[self print: 				(condition ifTrue: ['jumpTrueTo: '] ifFalse: ['jumpFalseTo: ']), (labels at: scanner pc + offset + 1)]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/3/2008 14:04'!simulateValueWithArguments: anArray caller: aContext	| newContext sz |	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	newContext := (MethodContext newForMethod: outerContext method)						setSender: aContext						receiver: outerContext receiver						method: outerContext method						closure: self						startpc: startpc.	sz := self basicSize.	newContext stackp: sz + numArgs.	1 to: numArgs do:		[:i| newContext at: i put: (anArray at: i)].	1 to: sz do:		[:i| newContext at: i + numArgs put: (self at: i)].	^newContext! !!BlockClosure methodsFor: 'error handing' stamp: 'eem 5/21/2008 15:23'!numArgsError: numArgsForInvocation	| printNArgs |	printNArgs := [:n| n printString, ' argument', (n = 1 ifTrue: [''] ifFalse:['s'])]. 	self error: 			'This block accepts ', (printNArgs value: numArgs), 			', but was called with ', (printNArgs value: numArgsForInvocation printString), '.'! !!InstructionPrinter methodsFor: 'accessing' stamp: 'eem 5/29/2008 14:00'!method: aMethod	method :=  aMethod.	printPC := true.	indentSpanOfFollowingJump := false! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/27/2008 15:57'!at: index put: value	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not	 an Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 211>	index isInteger ifTrue:		[self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!MethodProperties methodsFor: 'testing' stamp: 'eem 5/15/2008 09:36'!analogousCodeTo: aMethodProperties	pragmas		ifNil: [aMethodProperties pragmas notEmpty ifTrue: [^false]]		ifNotNil:			[aMethodProperties pragmas empty ifTrue: [^false].			 pragmas size ~= aMethodProperties pragmas size ifTrue:				[^false].			 pragmas with: aMethodProperties pragmas do:				[:mine :others|				(mine analogousCodeTo: others) ifFalse: [^false]]].	^(self hasAtLeastTheSamePropertiesAs: aMethodProperties)	  and: [aMethodProperties hasAtLeastTheSamePropertiesAs: self]! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 5/28/2008 16:02'!numArgs	"Answer the number of arguments that must be used to evaluate this block"	^numArgs! !!ContextPart methodsFor: 'private' stamp: 'eem 9/5/2008 12:29'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	 simulated receiver and arguments are given as arguments to this message.	 Any primitive which provikes execution needs to be intercepted and simulated	 to avoid execution running away."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:		[ToolSet 			debugContext: self			label:'Code simulation error'			contents: nil].	"ContextPart>>blockCopy:; simulated to get startpc right"	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart]) 		ifTrue: [^self push: ((BlockContext newForMethod: receiver method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext]) "BlockContext>>value[:value:...]"		ifTrue: [^receiver pushArgs: arguments from: self].	(primitiveIndex = 82 and: [receiver isMemberOf: BlockContext]) "BlockContext>>valueWithArguments:"		ifTrue: [^receiver pushArgs: arguments first from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50" "Object>>perform:[with:...]"		ifTrue: [^self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50" "Object>>perform:withArguments:"		ifTrue: [^self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	primitiveIndex = 188 ifTrue: "eem 5/27/2008 11:10 Object>>withArgs:executeMethod:"		[^MethodContext			sender: self			receiver: receiver			method: (arguments at: 2)			arguments: (arguments at: 1)].	"Closure primitives"	(primitiveIndex = 200 and: [receiver == self]) ifTrue:		"ContextPart>>closureCopy:copiedValues:; simulated to get startpc right"		[^self push: (BlockClosure						outerContext: receiver						startpc: pc + 2						numArgs: arguments first						copiedValues: arguments last)].	((primitiveIndex between: 201 and: 205)			 "BlockClosure>>value[:value:...]"	or: [primitiveIndex between: 221 and: 222]) ifTrue: "BlockClosure>>valueNoContextSwitch[:]"		[^receiver simulateValueWithArguments: arguments caller: self].	primitiveIndex = 206 ifTrue:						"BlockClosure>>valueWithArguments:"		[^receiver simulateValueWithArguments: arguments first caller: self].	arguments size > 6 ifTrue: [^PrimitiveFailToken].	value := primitiveIndex = 117 "named primitives"				ifTrue:[self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]				ifFalse:[receiver tryPrimitive: primitiveIndex withArgs: arguments].	^value == PrimitiveFailToken		ifTrue: [PrimitiveFailToken]		ifFalse: [self push: value]! !!BlockClosure methodsFor: 'scheduling' stamp: 'svp 6/23/2003 10:59'!forkNamed: aString	"Create and schedule a Process running the code in the receiver and	having the given name."	^ self newProcess name: aString; resume! !!BlockContext methodsFor: 'printing' stamp: 'eem 7/28/2008 14:10'!fullPrintOn: aStream	aStream print: self; cr.	(self decompile ifNil: ['--source missing--']) printOn: aStream indent: 0! !!RelativeInstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/16/2008 17:10'!send: selector super: supered numArgs: numArgs	"Print the Send Message With Selector, selector, bytecode. The argument, 	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found in 	the top numArguments locations on the stack and the receiver just 	below them."	self print: (supered				ifTrue: ['superSend: ']				ifFalse: ['send: '])			, selector storeString			, (numArgs = 1				ifTrue: [' (1 arg)']				ifFalse: [' (', numArgs printString, ' args)'])! !!CompiledMethod methodsFor: 'printing' stamp: 'md 2/16/2006 15:45'!who	"Answer an Array of the class in which the receiver is defined and the 	selector to which it corresponds."		self deprecated: 'use #methodClass and #selector directly'.	self isInstalled ifFalse: [^#(unknown unknown)].	^{self methodClass . self selector}.! !!BlockClosure methodsFor: 'printing' stamp: 'eem 5/24/2008 11:23'!printOn: aStream	aStream nextPutAll: '[closure] in '.	outerContext printOn: aStream! !!BlockContext methodsFor: 'accessing' stamp: 'eem 5/28/2008 10:43'!activeHome	"Search senders for the home context.  If the home	 context is not found on the sender chain answer nil."	^self caller findContextSuchThat: [:ctxt | ctxt = home]! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 5/29/2008 13:49'!print: instruction 	"Append to the receiver a description of the bytecode, instruction." 	stream tab: self indent.	labelling		ifTrue: [stream print: oldPC - method initialPC; space]		ifFalse: [stream tab].	stream tab: (innerIndents at: oldPC).	self printCode ifTrue:		[stream nextPut: $<.		 oldPC to: scanner pc - 1 do: 			[:i | | code |			code := (method at: i) radix: 16.			stream				nextPut: (code size < 2 ifTrue: [$0] ifFalse: [code at: 1]);				nextPut: code last;				space].		 stream skip: -1; nextPut: $>; space].	stream nextPutAll: instruction.	stream cr.	labelling ifFalse:		[(labels at: scanner pc + 1) ~~ false ifTrue:			[stream nextPutAll: (labels at: scanner pc + 1); nextPut: $:; cr]].	oldPC := scanner pc! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 5/24/2008 15:35'!indexOfLiteral: literal	"Answer the literal index of the argument, literal, or zero if none."	| max |	max := self numLiterals.	max := self hasNewPropertyFormat				ifTrue: [max - 1] "exclude superclass + properties"				ifFalse: [max + 1].	2 to: max do:		[:index |		literal == (self objectAt: index) ifTrue: [^index - 1]].	^0! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/16/2008 09:53'!fourthByte	"Answer the fourth byte of the current bytecode."	^self method at: pc + 3! !!ContextPart methodsFor: 'controlling' stamp: 'ar 3/6/2001 14:26'!terminateTo: previousContext	"Terminate all the Contexts between me and previousContext, if previousContext is on my Context stack. Make previousContext my sender."	| currentContext sendingContext |	<primitive: 196>	(self hasSender: previousContext) ifTrue: [		currentContext := sender.		[currentContext == previousContext] whileFalse: [			sendingContext := currentContext sender.			currentContext terminate.			currentContext := sendingContext]].	sender := previousContext! !!MethodContext methodsFor: 'instruction decoding (closures)' stamp: 'eem 7/22/2008 11:56'!blockReturnTop	"Simulate the interpreter's action when a ReturnTopOfStackToCaller bytecode is 	 encountered in the receiver.  This should only happen in a closure activation."	self assert: closureOrNil isClosure.	^self return: self pop from: self! !!BlockContext methodsFor: 'accessing' stamp: 'eem 5/29/2008 13:14'!caller	^sender! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/25/2008 15:02'!pushNewArrayOfSize: numElements 	self print: 'push: (Array new: ', numElements printString, ')'! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 6/16/2008 14:26'!pushConsArrayWithElements: numElements	"Push Cons Array of size numElements popping numElements items from the stack into the array bytecode."! !!BlockClosure methodsFor: 'controlling' stamp: ''!whileTrue	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the receiver, as long as its value is true." 	^ [self value] whileTrue: []! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 5/28/2008 15:03'!valueWithPossibleArgs: anArray 	^numArgs = 0		ifTrue: [self value]		ifFalse:			[self valueWithArguments:				(numArgs = anArray size					ifTrue: [anArray]					ifFalse:						[numArgs > anArray size							ifTrue: [anArray, (Array new: numArgs - anArray size)]							ifFalse: [anArray copyFrom: 1 to: numArgs]])]! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/27/2008 10:46'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 212>	"The number of indexable fields of fixed-length objects is 0"	^self primitiveFail! !!MessageSend methodsFor: 'tiles' stamp: 'eem 7/21/2008 12:09'!stringFor: anObject	"Return a string suitable for compiling.  Literal or reference from global ref dictionary.  self is always named via the ref dictionary."	| generic aName |	anObject isLiteral ifTrue: [^ anObject printString].	anObject class == Color ifTrue: [^ anObject printString].	anObject class superclass == Boolean ifTrue: [^ anObject printString].	anObject isBlock ifTrue: [^ '[''do nothing'']'].	"default block"		"Real blocks need to construct tiles in a different way"	anObject class isMeta ifTrue: ["a class" ^ anObject name].	generic := anObject knownName.	"may be nil or 'Ellipse' "	aName := anObject uniqueNameForReference.	generic ifNil:		[(anObject respondsTo: #renameTo:) 			ifTrue: [anObject renameTo: aName]			ifFalse: [aName := anObject storeString]].	"for Fraction, LargeInt, etc"	^ aName! !!InstructionPrinter methodsFor: 'accessing' stamp: 'eem 5/29/2008 13:50'!printPC	^printPC! !!MethodContext methodsFor: 'accessing' stamp: 'eem 7/22/2008 11:57'!home 	"Answer the context in which the receiver was defined."	closureOrNil == nil ifTrue:		[^self].	^closureOrNil outerContext home! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 7/29/2008 17:15'!methodNode	"Return the parse tree that represents self"	| aClass source |	aClass := self methodClass.	^ (source := self getSourceFromFile)		ifNil: [self decompile]		ifNotNil: [aClass parserClass new					encoderClass: (self isBlueBookCompiled									ifTrue: [EncoderForV3]									ifFalse: [EncoderForV3PlusClosures]);					parse: source class: aClass]! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/27/2008 11:44'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that pushes the value at remoteTempIndex	 in one of my local variables being used as a remote temp vector."	self push: ((self at: tempVectorIndex + 1) at: remoteTempIndex + 1)! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 6/15/2008 11:27'!methodReturnReceiver	"Simulate the action of a 'return receiver' bytecode. This corresponds to	 the source expression '^self'."	^self return: self receiver from: self methodReturnContext! !!BlockStartLocator methodsFor: 'initialize-release' stamp: 'eem 5/31/2008 13:43'!initialize	nextJumpIsAroundBlock := false! !!MethodContext methodsFor: 'controlling' stamp: 'md 2/17/2006 10:04'!answer: anObject	"ar 3/6/2001: OBSOLETE. Must not be used. Will be removed VERY SOON."		self deprecated: 'ar 3/6/2001: OBSOLETE. Must not be used. Will be removed VERY SOON.'.		"Modify my code, from the current program counter value, to answer anObject."	self push: anObject.	(method at: pc) = 124 ifFalse: [		method _ (			(method clone)				at: pc + 1 put: 124;				yourself)]! !!BlockClosure methodsFor: 'exceptions' stamp: 'ajh 2/1/2003 00:30'!on: exception do: handlerAction	"Evaluate the receiver in the scope of an exception handler."	| handlerActive |	<primitive: 199>  "just a marker, fail and execute the following"	handlerActive := true.	^ self value! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 8/17/2007 13:15'!valueWithin: aDuration onTimeout: timeoutBlock	"Evaluate the receiver.	If the evaluation does not complete in less than aDuration evaluate the timeoutBlock instead"	| theProcess delay watchdog |	aDuration <= Duration zero ifTrue: [^ timeoutBlock value ].	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := aDuration asDelay.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: TimedOut ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	^ [	watchdog resume.				"start up the watchdog"		self ensure:[						"evaluate the receiver"			theProcess := nil.				"it has completed, so ..."			delay delaySemaphore signal.	"arrange for the watchdog to exit"		]] on: TimedOut do: [ :e | timeoutBlock value ].! !!InstructionStream methodsFor: 'testing' stamp: 'eem 6/4/2008 15:58'!willStore	"Answer whether the next bytecode is a store or store-pop"	| byte |	byte := self method at: pc.	^(byte between: 96 and: 142)		and: [byte <= 111			"96 103		storeAndPopReceiverVariableBytecode"									"104 111	storeAndPopTemporaryVariableBytecode"			or: [byte >= 129		"129		extendedStoreBytecode"				and: [byte <= 130	"130		extendedStoreAndPopBytecode"					or: [(byte = 132	"132		doubleExtendedDoAnythingBytecode"						and: [(self method at: pc+1) >= 160])					or: [byte = 141	"141		storeRemoteTempLongBytecode"					or: [byte = 142	"142		storeAndPopRemoteTempLongBytecode"]]]]]]! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 5/15/2008 10:56'!printCode	^printCode ~~ false! !!ClassBuilder methodsFor: 'private' stamp: 'eem 7/21/2008 14:16'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		ProtoObject Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext BlockClosure		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod TranslatedMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 5/29/2008 12:18'!method	^outerContext method! !!MethodContext methodsFor: 'accessing' stamp: 'eem 5/28/2008 10:45'!activeOuterContext	"If executing closure, search senders for the activation in which the receiver's	 closure was created (the receiver's outerContext).  If the outerContext is not	 found on the sender chain answer nil."	| outerContext |	self isExecutingBlock ifFalse: [^self].	self sender ifNil: [^nil].	outerContext := self outerContext.	^self sender findContextSuchThat: [:ctxt | ctxt = outerContext]! !!MethodContext methodsFor: 'instruction decoding (closures)' stamp: 'eem 5/30/2008 18:40'!pushConsArrayWithElements: numElements 	| array |	array := Array new: numElements.	numElements to: 1 by: -1 do:		[:i|		array at: i put: self pop].	self push: array! !!MethodContext methodsFor: 'accessing' stamp: 'eem 8/20/2008 09:28'!tempAt: index 	"Answer the value of the temporary variable whose index is the 	 argument, index.  Primitive. Assumes receiver is indexable. Answer the	 value of an indexable element in the receiver. Fail if the argument index	 is not an Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default at: primitive to give latitude to the	 VM in context management."	<primitive: 210>	^self at: index! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 13:50'!pushNewArrayOfSize: numElements 	"Push New Array of size numElements bytecode."! !!MethodContext methodsFor: 'private' stamp: 'eem 7/22/2008 12:00'!startpc	^closureOrNil		ifNil:	[self method initialPC]		ifNotNil: [closureOrNil startpc]! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 5/6/2008 11:28'!allLiterals	^self literals! !!BlockClosure methodsFor: 'controlling' stamp: 'jf 9/3/2003 16:45'!doWhileFalse: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is false." 	| result |	[result := self value.	conditionBlock value] whileFalse.	^ result! !!BlockClosure methodsFor: 'initialize-release' stamp: 'eem 9/3/2008 14:08'!outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil	outerContext := aContext.	startpc := aStartpc.	numArgs := argCount.	1 to: self numCopiedValues do:		[:i|		self at: i put: (anArrayOrNil at: i)]! !!BlockClosure methodsFor: 'copying' stamp: 'eem 5/28/2008 14:53'!postCopy	"To render a copy safe we need to provide a new outerContext that	 cannot be returned from and a copy of any remoteTemp vectors.	 When a block is active it makes no reference to state in its nested	 contexts (this is the whole point of the indirect temps scheme; any	 indirect state is either copied or in indirect temp vectors.  So we	 need to substitute a dummy outerContext and copy the copiedValues,	 copying anything looking like a remote temp vector.  if we accidentally	 copy an Array that isn't actually an indirect temp vector we do extra work	 but don't break anything."	outerContext := MethodContext						sender: nil						receiver: outerContext receiver						method: outerContext method						arguments: #().	self fixTemps! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/3/2008 14:09'!value: anArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the argument and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	| newContext ncv |	<primitive: 202>	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	newContext := self asContextWithSender: thisContext sender.	ncv := self numCopiedValues.	newContext stackp: ncv + 1.	newContext at: 1 put: anArg.	1 to: ncv do:		[:i| newContext at: i + 1 put: (self at: i)].	thisContext privSender: newContext! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 5/24/2008 11:21'!outerContext	^outerContext! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/4/2008 10:58'!addSelectorTo: set 	"If this instruction is a send, add its selector to set."	| selectorOrSelf |	(selectorOrSelf := self selectorToSendOrSelf) == self ifFalse:		[set add: selectorOrSelf]! !!ContextPart class methodsFor: 'private' stamp: 'eem 6/19/2008 10:00'!isContextClass	^true! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/3/2008 14:08'!valueWithArguments: anArray	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this message.	 Supply the arguments in an anArray and copied values to the activation as its arguments and copied temps.	 Primitive. Optional (but you're going to want this for performance)."	| newContext ncv |	<primitive: 206>	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	newContext := self asContextWithSender: thisContext sender.	ncv := self numCopiedValues.	newContext stackp: ncv + numArgs.	1 to: numArgs do:		[:i| newContext at: i put: (anArray at: i)].	1 to: ncv do:		[:i| newContext at: i + numArgs put: (self at: i)].	thisContext privSender: newContext! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/25/2008 00:00'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex 	self print: 'pushTemp: ', remoteTempIndex printString, ' inVectorAt: ', tempVectorIndex printString! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 6/24/2008 14:27'!qCompress: string firstTry: firstTry	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble.	Normal call is with firstTry == true."	| charTable odd ix oddNibble names shorterStr maybe str temps |	 str := string isOctetString				ifTrue: [string]				ifFalse: [temps := string findTokens: ' '.					String						streamContents: [:stream | 1								to: temps size								do: [:index | 									stream nextPut: $t.									stream nextPutAll: index asString.									stream space]]].	charTable :=  "Character encoding table must match qDecompress:"	' eatrnoislcm_bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd := true.  "Flag for odd or even nibble out"		oddNibble := nil.		str do:			[:char | ix := (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd := odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble := nibble]]].		strm position > 251 ifTrue:			["Only values 1...251 are available for the flag byte			that signals compressed temps. See the logic in endPC."			"Before giving up completely, we attempt to encode most of			the temps, but with the last few shortened to tNN-style names."			firstTry ifFalse: [^ nil "already tried --give up now"].			names := str findTokens: ' '.			names size < 8 ifTrue: [^ nil  "weird case -- give up now"].			4 to: names size//2 by: 4 do:				[:i | shorterStr := String streamContents:					[:s |					1 to: names size - i do: [:j | s nextPutAll: (names at: j); space].					1 to: i do: [:j | s nextPutAll: 't' , j printString; space]].				(maybe := self qCompress: shorterStr firstTry: false) ifNotNil: [^ maybe]].			^ nil].		strm nextPut: strm position]"  | m s |  m := CompiledMethod new.s := 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 5/24/2008 16:14'!writesRef: literalAssociation 	"Answer whether the receiver stores into the argument."	"eem 5/24/2008 Rewritten to no longer assume the compler uses the	 most compact encoding available (for EncoderForLongFormV3 support)."	| litIndex scanner |	(litIndex := self indexOfLiteral: literalAssociation) = 0 ifTrue:		[^false].	litIndex := litIndex - 1.	^(scanner := InstructionStream on: self) scanFor:		[:b|		(b = 129 or: [b = 130])			ifTrue: [scanner followingByte - 192 = litIndex]			ifFalse:				[b = 132				 and: [scanner followingByte >= 224				 and: [scanner thirdByte = litIndex]]]]! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 6/24/2008 14:30'!qDecompress: byteArray	"Decompress strings compressed by qCompress:.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble"	|  charTable extended ext |	charTable :=  "Character encoding table must match qCompress:"	' eatrnoislcm_bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ String streamContents:		[:strm | extended := false.  "Flag for 2-nibble characters"		byteArray do:			[:byte | 			(Array with: byte//16 with: byte\\16) do:				[:nibble |				extended					ifTrue: [strm nextPut: (charTable at: ext*16+nibble + 1). extended := false]					ifFalse: [nibble < 12								ifTrue: [strm nextPut: (charTable at: nibble + 1)]								ifFalse: [ext := nibble-12.  extended := true]]]]]! !!BlockClosure methodsFor: 'evaluating' stamp: 'ajh 1/13/2002 13:36'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock valueWithPossibleArgs: {ex description. ex receiver}]! !!InstructionStream methodsFor: 'testing' stamp: 'eem 6/4/2008 15:56'!willStorePop	"Answer whether the next bytecode is a store-pop."	| byte |	byte := self method at: pc.	^byte = 130					"130		extendedStoreAndPopBytecode"	  or: [byte = 142				"142		storeAndPopRemoteTempLongBytecode"	  or: [byte between: 96 and: 111	"96 103		storeAndPopReceiverVariableBytecode"									"104 111	storeAndPopTemporaryVariableBytecode"]]! !!BlockClosure methodsFor: 'private' stamp: 'eem 9/3/2008 14:01'!fixTemps	"Fix the values of the temporary variables used in the block that are 	 ordinarily shared with the method in which the block is defined.  We	 need to copy the copiedValues, copying anything looking like a remote	 temp vector.  if we accidentally copy an Array that isn't actually an	 indirect temp vector we may break things, so this is a real hack."	1 to: self numCopiedValues do:		[:i| | each |		(each := self at: i) isArray ifTrue:			[self at: i put: each shallowCopy]]! !!Object methodsFor: 'testing' stamp: 'eem 5/23/2008 13:47'!isClosure	^false! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/15/2008 11:31'!contextForLocalVariables	"Answer the context in which local variables (temporaries) are stored."	self subclassResponsibility! !!BlockClosure methodsFor: 'evaluating' stamp: 'jm 6/3/1998 14:25'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 9/3/2008 14:07'!numCopiedValues	"Answer the number of copied values of the receiver.  Since these are	 stored in the receiver's indexable fields this is the receiver's basic size.	 Primitive. Answer the number of indexable variables in the receiver. 	 This value is the same as the largest legal subscript."	<primitive: 62>	^self basicSize! !!MethodContext methodsFor: 'private' stamp: 'eem 7/22/2008 12:00'!setSender: s receiver: r method: m closure: c startpc: startpc	"Create the receiver's initial state."	sender := s.	receiver := r.	method := m.	closureOrNil := c.	pc := startpc.	stackp := 0! !!BlockClosure methodsFor: 'private' stamp: 'eem 6/11/2008 11:38'!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^(MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc! !!MethodContext methodsFor: 'accessing' stamp: 'eem 7/22/2008 11:57'!closure	^closureOrNil! !!ClassDescription methodsFor: 'instance variables' stamp: 'ar 7/11/2009 01:07'!instVarNameForIndex: index	"Answer the named instance variable with index index or nil if none."	| superInstSize |	index > self instSize ifTrue: [^nil].	superInstSize := superclass isNil ifTrue: [0] ifFalse: [superclass instSize].	index > superInstSize ifTrue:		[^instanceVariables at: index - superInstSize].	superclass isNil ifTrue: [^nil].	^superclass instVarNameForIndex: index! !!BlockClosure methodsFor: 'evaluating' stamp: 'cmm 2/16/2003 16:08'!bench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count |	count := 0.	endTime := Time millisecondClockValue + 5000.	startTime := Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count := count + 1 ].	endTime := Time millisecondClockValue.	^count = 1		ifTrue: [ ((endTime - startTime) // 1000) printString, ' seconds.' ]		ifFalse:			[ ((count * 1000) / (endTime - startTime)) asFloat printString, ' per second.' ]! !!CompiledMethod methodsFor: 'testing' stamp: 'md 1/21/2006 10:54'!hasReportableSlip	"Answer whether the receiver contains anything that should be brought 	to the attention of the author when filing out. Customize the lists here 	to suit your preferences. If slips do not get reported in spite of your 	best efforts here, make certain that the Preference 'checkForSlips' is set 	to true."	| assoc |	#(#doOnlyOnce: #halt #halt: #hottest #printDirectlyToDisplay #toRemove #personal #urgent  #haltOnce #haltOnce: #haltIf: )		do: [:aLit | (self hasLiteral: aLit)				ifTrue: [^ true]].	#(#Transcript #AA #BB #CC #DD #EE )		do: [:aSymbol | (assoc := Smalltalk						associationAt: aSymbol						ifAbsent: [])				ifNotNil: [(self hasLiteral: assoc)						ifTrue: [^ true]]].	^ false! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/16/2008 09:52'!secondByte	"Answer the second byte of the current bytecode."	^self method at: pc + 1! !!InstructionStream methodsFor: 'testing' stamp: 'eem 5/16/2008 16:22'!willSend	"Answer whether the next bytecode is a message-send."	| byte |	byte := self method at: pc.	^byte >= 131	  and: [byte >= 176 "special send or short send"		or: [byte <= 134]]	"long sends"! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 6/16/2008 09:52'!firstByte	"Answer the first byte of the current bytecode."	^self method at: pc! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/3/2008 16:15'!startpcsToBlockExtents	"Answer a Dictionary of startpc to Interval of blockExtent, using the	 identical numbering scheme described in and orchestrated by	 BlockNode>>analyseArguments:temporaries:rootNode:.  This is	 used in part to find the temp names for any block in a method, as	 needed by the debugger.  The other half is to recompile the method,	 obtainign the temp names for each block extent.  By indirecting through	 the blockExtent instead of using the startpc directly we decouple the	 debugger's access to temp names form the exact bytecode; insulating	 debugging from minor changes in the compiler (e.g. changes in literal	 pooling, adding prefix bytecodes, adding inst vars to CompiledMethod	 in literals towards the end of the literal frame, etc).  If the recompilation	 doesn't produce exactly the same bytecode at exactly the same offset	 no matter; the blockExtents will be the same."	| index |	self flag: 'belongs in DebuggerMethodMap'.	index := 0.	^self		blockExtentsInto: Dictionary new		from: self initialPC		to: self endPC		scanner: (InstructionStream on: self)		numberer: [| value | value := index. index := index + 2. value]! !!ContextPart methodsFor: 'controlling' stamp: 'eem 6/14/2008 19:17'!blockCopy: numArgs 	"Primitive. Distinguish a block of code from its enclosing method by 	creating a new BlockContext for that block. The compiler inserts into all 	methods that contain blocks the bytecodes to send the message 	blockCopy:. Do not use blockCopy: in code that you write!! Only the 	compiler can decide to send the message blockCopy:. Fail if numArgs is 	not a SmallInteger. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 80>	^ (BlockContext newForMethod: self method)		home: self home		startpc: pc + 2		nargs: numArgs! !!InstructionPrinter methodsFor: 'accessing' stamp: 'eem 5/29/2008 13:50'!printPC: aBoolean	printPC := aBoolean! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 13:54'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Push Contents at Offset in Temp Vector bytecode."! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'eem 6/5/2008 09:05'!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame := 16.	"Context range for temps+stack"	LargeFrame := 56! !!BlockClosure methodsFor: 'private' stamp: 'ar 3/2/2001 01:16'!valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| activeProcess oldPriority result |	activeProcess := Processor activeProcess.	oldPriority := activeProcess priority.	activeProcess priority: Processor highestPriority.	result := self ensure: [activeProcess priority: oldPriority].	"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 8/22/2008 14:21'!valueNoContextSwitch	"An exact copy of BlockClosure>>value except that this version will not preempt	 the current process on block activation if a higher-priority process is runnable.	 Primitive. Essential."	<primitive: 221>	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	self primitiveFailed! !!MethodFinder methodsFor: 'search' stamp: 'eem 7/21/2008 12:08'!testPerfect: aSelector	"Try this selector!! Return true if it answers every example perfectly.  Take the args in the order they are.  Do not permute them.  Survive errors.  later cache arg lists."| sz argList val rec activeSel perform |	"Transcript cr; show: aSelector.		debug"perform := aSelector beginsWith: 'perform:'.sz := argMap size.1 to: thisData size do: [:ii | "each example set of args"	argList := (thisData at: ii) copyFrom: 2 to: sz.	perform		ifFalse: [activeSel := aSelector]		ifTrue: [activeSel := argList first.	"what will be performed"			((Approved includes: activeSel) or: [AddAndRemove includes: activeSel])				ifFalse: [^ false].	"not approved"			aSelector == #perform:withArguments: 				ifTrue: [activeSel numArgs = (argList at: 2) basicSize "avoid error" 							ifFalse: [^ false]]				ifFalse: [activeSel numArgs = (aSelector numArgs - 1) 							ifFalse: [^ false]]].	1 to: sz do: [:num | 		(Blocks includes: (Array with: activeSel with: num)) ifTrue: [			(argList at: num) isBlock ifFalse: [^ false]]].	rec := (AddAndRemove includes: activeSel) 			ifTrue: [(thisData at: ii) first isSymbol ifTrue: [^ false].						"vulnerable to modification"				(thisData at: ii) first copyTwoLevel] 	"protect from damage"			ifFalse: [(thisData at: ii) first].	val := [rec perform: aSelector withArguments: argList] 				ifError: [:aString :aReceiver | 							"self test3."							"self test2: (thisData at: ii)."							^ false].	"self test3."	"self test2: (thisData at: ii)."	((answers at: ii) closeTo: val) ifFalse: [^ false].	].^ true! !!CompiledMethod methodsFor: 'testing' stamp: 'eem 7/29/2008 16:51'!isBlueBookCompiled	"Answer whether the receiver was compiled using the closure compiler.	 This is used to help DebuggerMethodMap choose which mechanisms to	 use to inspect activations of the receiver.	 This method answers false negatives in that it only identifies methods	 that create old BlockClosures or use the new BlockClosure bytecodes.	 It cannot tell if a method which uses neither the old nor the new block	 bytecodes is compiled with the blue-book compiler or the new compiler.	 But since methods that don't create blocks have essentially the same	 code when compiled with either compiler this makes little difference."	^((InstructionStream on: self) scanFor:		[:instr |		(instr >= 138 and: [instr <= 143]) ifTrue: [^false].		instr = 200])	   or: [(self hasLiteral: #blockCopy:)		   and: [self messages includes: #blockCopy:]]! !!BlockClosure methodsFor: 'printing' stamp: 'eem 7/28/2008 14:06'!decompile	^Decompiler new decompileBlock: self! !!InstructionPrinter methodsFor: 'initialize-release' stamp: 'eem 5/29/2008 13:26'!printInstructionsOn: aStream 	"Append to the stream, aStream, a description of each bytecode in the	 instruction stream."		| end |	stream := aStream.	scanner := InstructionStream on: method.	end := method endPC.	oldPC := scanner pc.	innerIndents := Array new: end withAll: 0.	[scanner pc <= end] whileTrue:		[scanner interpretNextInstructionFor: self]! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 5/29/2008 13:59'!symbolicLinesDo: aBlock	"Evaluate aBlock with each of the lines in the symbolic output."	| aStream pc |	aStream := ReadWriteStream on: (String new: 64).	self isQuick ifTrue:		[self longPrintOn: aStream.		 aBlock value: 0 value: aStream contents.		 ^self].	self primitive ~= 0 ifTrue:		[self printPrimitiveOn: aStream.		 aBlock value: 1 value: aStream contents.		 aStream resetContents].	pc := self initialPC.	(InstructionPrinter on: self)		indent: 0;		printPC: false; "explorer provides pc anyway"		printInstructionsOn: aStream		do:	[:printer :scanner :stream| | line index |			line := stream contents allButLast.			(line includes: Character cr) ifTrue:				[line := (line copyUpTo: Character cr), '...'' (continues)'].			(index := line indexOf: $>) > 0 ifTrue:				[[(line at: index + 1) isSeparator] whileTrue: [index := index + 1].				 line := ((line copyFrom: 1 to: index) copyReplaceAll: (String with: Character tab) with: (String new: 8 withAll: Character space)),						(line copyFrom: index + 1 to: line size)].			aBlock value: pc value: line.			pc := scanner pc.			stream resetContents]! !!InstructionStream methodsFor: 'debugger access' stamp: 'eem 6/5/2008 10:28'!abstractPC	^self method abstractPCForConcretePC: pc! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/27/2008 11:53'!storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that stores the top of the stack at	 an offset in one of my local variables being used as a remote temp vector."	(self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self top! !!BlockClosure methodsFor: 'controlling' stamp: ''!whileTrue: aBlock 	"Ordinarily compiled in-line, and therefore not overridable.	This is in case the message is sent to other than a literal block.	Evaluate the argument, aBlock, as long as the value of the receiver is true."	^ [self value] whileTrue: [aBlock value]! !!MethodContext methodsFor: 'accessing' stamp: 'eem 7/22/2008 11:57'!isExecutingBlock	"Is this executing a block versus a method?  In the new closure	 implemetation this is true if closureOrNil is not nil, in which case	 it should be holding a BlockClosure."	^closureOrNil isClosure! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 6/19/2008 09:21'!readsField: varIndex 	"Answer whether the receiver loads the instance variable indexed by the 	 argument."	"eem 5/24/2008 Rewritten to no longer assume the compiler uses the	 most compact encoding available (for EncoderForLongFormV3 support)."	| varIndexCode scanner |	varIndexCode := varIndex - 1.	self isReturnField ifTrue: [^self returnField = varIndexCode].	^(scanner := InstructionStream on: self) scanFor:		[:b|		b < 16			ifTrue: [b = varIndexCode]			ifFalse:				[b = 128					ifTrue: [scanner followingByte = varIndexCode and: [varIndexCode <= 63]]					ifFalse:						[b = 132						 and: [(scanner followingByte between: 64 and: 95)						 and: [scanner thirdByte = varIndexCode]]]]]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 5/25/2008 14:47'!valueWithPossibleArgument: anArg 	"Evaluate the block represented by the receiver. 	 If the block requires one argument, use anArg, if it requires more than one,	 fill up the rest with nils."	| a |	numArgs = 0 ifTrue: [^self value].	numArgs = 1 ifTrue: [^self value: anArg].	a := Array new: numArgs.	a at: 1 put: anArg.	^self valueWithArguments: a! !!MethodContext methodsFor: 'accessing' stamp: 'eem 8/20/2008 09:29'!tempAt: index put: value 	"Store the argument, value, as the temporary variable whose index is the 	 argument, index.  Primitive. Assumes receiver is indexable. Answer the	 value of an indexable element in the receiver. Fail if the argument index	 is not an Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default at:put: primitive to give latitude to	 the VM in context management."	<primitive: 211>	^self at: index put: value! !!BlockStartLocator methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 13:48'!jump: offset	"If this jump is around a block answer the size of that block."	nextJumpIsAroundBlock ifTrue:		[nextJumpIsAroundBlock := false.		 ^offset]! !!BlockClosure methodsFor: 'printing' stamp: 'eem 7/28/2008 14:09'!fullPrintOn: aStream	aStream print: self; cr.	(self decompile ifNil: ['--source missing--']) printOn: aStream indent: 0! !!InstructionStream class methodsFor: 'compiling' stamp: 'eem 7/17/2008 13:16'!instVarNamesAndOffsetsDo: aBinaryBlock	"This is part of the interface between the compiler and a class's instance or field names.	 We override here to arrange that the compiler will use MaybeContextInstanceVariableNodes	 for instances variables of ContextPart or any of its superclasses and subclasses.  The	 convention to make the compiler use the special nodes is to use negative indices"	| superInstSize |	(self withAllSubclasses noneSatisfy: [:class|class isContextClass]) ifTrue:		[^super instVarNamesAndOffsetsDo: aBinaryBlock].	(superInstSize := superclass notNil ifTrue: [superclass instSize] ifFalse: [0]) > 0 ifTrue:		[superclass instVarNamesAndOffsetsDo: aBinaryBlock].	1 to: self instSize - superInstSize do:		[:i| aBinaryBlock value: (instanceVariables at: i) value: (i + superInstSize) negated]! !!BlockClosure methodsFor: 'controlling' stamp: 'jcg 7/8/2007 18:25'!whileNil: aBlock 	"Unlike #whileTrue/False: this is not compiled inline."	^ [self value isNil] whileTrue: [aBlock value]	! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 6/1/2008 09:43'!stackOfSize: limit 	"Answer an OrderedCollection of the top 'limit' contexts	 on the receiver's sender chain."	| stack ctxt |	stack := OrderedCollection new.	stack addLast: (ctxt := self).	[(ctxt := ctxt sender) ~~ nil	 and: [stack size < limit]] whileTrue:		[stack addLast: ctxt].	^stack! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 8/22/2008 14:21'!valueNoContextSwitch: anArg	"An exact copy of BlockClosure>>value: except that this version will not preempt	 the current process on block activation if a higher-priority process is runnable.	 Primitive. Essential."	<primitive: 222>	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	self primitiveFailed! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 6/15/2008 11:34'!pushTemporaryVariable: offset 	"Simulate the action of bytecode that pushes the contents of the 	temporary variable whose index is the argument, index, on the top of 	the stack."	self push: (self contextForLocalVariables at: offset + 1)! !!BlockClosure methodsFor: 'scheduling' stamp: 'ajh 2/10/2003 14:25'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive] asContext		priority: Processor activePriority! !!BlockClosure methodsFor: 'testing' stamp: 'eem 5/29/2008 12:20'!hasMethodReturn	"Answer whether the receiver has a method-return ('^') in its code."	| myMethod scanner preceedingBytecodeMessage end |	"Determine end of block from the instruction preceding it.	 Find the instruction by using an MNU handler to capture	 the instruction message sent by the scanner."	myMethod := outerContext method.	scanner := InstructionStream new method: myMethod pc: myMethod initialPC.	[scanner pc < startpc] whileTrue:		[[scanner interpretNextInstructionFor: nil]			on: MessageNotUnderstood			do: [:ex| preceedingBytecodeMessage := ex message]].	end := preceedingBytecodeMessage arguments last + startpc - 1.	scanner method: myMethod pc: startpc.	scanner scanFor: [:byte | (byte between: 120 and: 124) or: [scanner pc > end]].	^scanner pc <= end! !!RelativeInstructionPrinter methodsFor: 'printing' stamp: 'eem 5/21/2008 12:24'!printInstructionsOn: aStream	"Append to the stream, aStream, a description of each bytecode in the instruction stream."		| label |	labelling := true.	labels := Array new: method size + 1 withAll: false.	super printInstructionsOn: (String new: 1024) writeStream.	label := 0.	labels withIndexDo:		[:bool :index|		bool ifTrue: [labels at: index put: 'L', (label := label + 1) printString]].	labelling := false.	super printInstructionsOn: aStream! !!MethodContext methodsFor: 'printing' stamp: 'eem 5/27/2008 17:23'!printOn: aStream	self outerContext		ifNil: [super printOn: aStream]		ifNotNil:			[:outerContext|			 aStream nextPutAll: '[] in '.			 outerContext printOn: aStream]! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/25/2008 14:06'!storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex 	self print: 'storeIntoTemp: ', remoteTempIndex printString, ' inVectorAt: ', tempVectorIndex printString! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 6/15/2008 11:34'!storeIntoTemporaryVariable: offset 	"Simulate the action of bytecode that stores the top of the stack into one 	of my temporary variables."	self contextForLocalVariables at: offset + 1 put: self top! !!BlockClosure methodsFor: 'scheduling' stamp: 'svp 6/23/2003 10:59'!forkAt: priority named: name	"Create and schedule a Process running the code in the receiver at the	given priority and having the given name. Answer the newly created 	process."	| forkedProcess |	forkedProcess := self newProcess.	forkedProcess priority: priority.	forkedProcess name: name.	^ forkedProcess resume! !!Object methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!InstructionPrinter methodsFor: 'instruction decoding' stamp: 'eem 5/29/2008 14:02'!jump: offset	"Print the Unconditional Jump bytecode."	self print: 'jumpTo: ' , (scanner pc + offset) printString.	indentSpanOfFollowingJump ifTrue:		[indentSpanOfFollowingJump := false.		 innerIndents atAll: (scanner pc to: scanner pc + offset - 1) put: (innerIndents at: scanner pc - 1) + 1]! !!InstructionStream methodsFor: 'testing' stamp: 'eem 6/19/2008 23:32'!willReallySend	"Answer whether the next bytecode is a real message-send,	not blockCopy:."	| byte |	byte := self method at: pc.	^byte >= 131	  and: [byte ~~ 200	  and: [byte >= 176   "special send or short send"		or: [byte <= 134 "long sends"				and: [| litIndex |				"long form support demands we check the selector"				litIndex := byte = 132							ifTrue: [(self method at: pc + 1) // 32 > 1 ifTrue: [^false].									self method at: pc + 2]							ifFalse: [byte = 134										ifTrue: [(self method at: pc + 1) bitAnd: 2r111111]										ifFalse: [(self method at: pc + 1) bitAnd: 2r11111]].				(self method literalAt: litIndex + 1) ~~ #blockCopy:]]]]! !!MethodContext methodsFor: 'accessing' stamp: 'eem 6/15/2008 11:31'!contextForLocalVariables	"Answer the context in which local variables (temporaries) are stored."	^self! !!ContextPart methodsFor: 'debugger access' stamp: 'md 2/17/2006 09:35'!mclass 	"Answer the class in which the receiver's method was found."	self deprecated: 'use #methodClass'.	^ self methodClass! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 5/27/2008 11:38'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Simulate the action of bytecode that removes the top of the stack and  stores	 it into an offset in one of my local variables being used as a remote temp vector."	(self at: tempVectorIndex + 1) at: remoteTempIndex + 1 put: self pop! !!MethodContext methodsFor: 'initialize-release' stamp: 'eem 8/22/2008 09:57'!privRefreshWith: aCompiledMethod 	"Reinitialize the receiver as though it had been for a different method. 	 Used by a Debugger when one of the methods to which it refers is 	 recompiled."	aCompiledMethod isCompiledMethod ifFalse:		[self error: 'method can only be set to aCompiledMethod'].	method := aCompiledMethod.	self assert: closureOrNil == nil.	"was: receiverMap := nil."	self privRefresh! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/27/2008 15:55'!at: index	"Primitive. Assumes receiver is indexable. Answer the value of an	 indexable element in the receiver. Fail if the argument index is not an	 Integer or is out of bounds. Essential. See Object documentation	 whatIsAPrimitive.  Override the default primitive to give latitude to	 the VM in context management."	<primitive: 210>	index isInteger ifTrue:		[self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!MethodContext methodsFor: 'printing' stamp: 'md 2/17/2006 12:02'!who	self deprecated: 'please use #methodClass and #selector'.		self method ifNil: [^ #(unknown unkown)].	^ {self methodClass . self selector}.! !!ContextPart methodsFor: 'debugger access' stamp: 'eem 6/10/2008 09:42'!tempNames	"Answer a SequenceableCollection of the names of the receiver's temporary 	 variables, which are strings."	^ self debuggerMap tempNamesForContext: self! !!ContextPart methodsFor: 'accessing' stamp: 'eem 6/15/2008 11:27'!methodReturnContext	"Answer the context from which an ^-return should return from."	self subclassResponsibility! !!InstructionStream methodsFor: 'decoding' stamp: 'eem 9/29/2008 11:59'!interpretJumpIfCond	| byte |	byte := self method at: pc.	(byte between: 152 and: 159) ifTrue:		[pc := pc + 1. ^byte - 151].	(byte between: 168 and: 175) ifTrue:		[pc := pc + 2. ^(byte bitAnd: 3) * 256 + (self method at: pc - 1)].	^nil! !!ContextPart methodsFor: 'instruction decoding' stamp: 'eem 6/15/2008 11:27'!methodReturnConstant: value	"Simulate the action of a 'return constant' bytecode whose value is the	 argument, value. This corresponds to a source expression like '^0'."	^self return: value from: self methodReturnContext! !!BlockClosure methodsFor: 'accessing' stamp: 'eem 7/28/2008 13:58'!home	^outerContext home! !!InstructionClient methodsFor: 'instruction decoding' stamp: 'eem 5/31/2008 13:52'!storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Store Top Of Stack And Store Into Offset of Temp Vector bytecode."! !!CompiledMethod methodsFor: 'accessing' stamp: 'lr 2/6/2006 20:52'!properties: aMethodProperties	"Set the method-properties of the receiver to aMethodProperties."	aMethodProperties pragmas do: [ :each | each setMethod: self ].	^ self literalAt: self numLiterals - 1 put: aMethodProperties.! !PseudoPoolVariable removeSelector: #canAssign!BlockClosure removeSelector: #method:!MethodContext removeSelector: #finalBlockHome!BlockClosure removeSelector: #=!BlockContext removeSelector: #finalBlockHome!BlockContext removeSelector: #ifProperUnwindSupportedElseSignalAboutToReturn!MethodContext removeSelector: #isMethodContext!ClosureEnvironment removeSelector: #hash!BlockContext removeSelector: #isMethodContext!Object removeSelector: #isBlockClosure!BlockClosure removeSelector: #env:!PseudoPoolVariable removeSelector: #value!BlockClosure removeSelector: #valueError!BlockClosure removeSelector: #hasLiteralSuchThat:!Smalltalk removeClassNamed: #PseudoPoolVariable!PseudoPoolVariable removeSelector: #setter:!ContextPart removeSelector: #blockHome!BlockClosure removeSelector: #callCC!BlockClosure removeSelector: #valueWithExit!ClosureEnvironment removeSelector: #return:!BlockClosure removeSelector: #env!PseudoPoolVariable removeSelector: #name:!ClosureEnvironment removeSelector: #=!BlockClosure removeSelector: #hasLiteralThorough:!BlockClosure removeSelector: #simulate!PseudoPoolVariable removeSelector: #value:!BlockClosure removeSelector: #hash!PseudoPoolVariable removeSelector: #name!MethodContext removeSelector: #blockHome!BlockContext removeSelector: #blockHome!PseudoPoolVariable removeSelector: #getter:!BlockClosure removeSelector: #veryDeepInner:!Smalltalk removeClassNamed: #ClosureEnvironment!CompiledMethod initialize!