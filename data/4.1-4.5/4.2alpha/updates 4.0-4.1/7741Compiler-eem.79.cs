"Change Set:		7741Compiler-eem.79Compiler-eem.79:Fourth package of eight in closure compiler fixes 9/5/2009.Second stage of the closure compiler fixes for- miscompilation of optimized blocks- bugs in statement highlighting in the debugger- storing the selector as the penultimate literal of a method  directly unless it has properties, in which case it has an  AdditionalMethodState.  Saves significant space.Throws the switch to the new closure analysis in BlockNode>>analyseArguments:temporaries:rootNode: using in place of analyseTempsWithin:rootNode:assignmentPools: analyseTempsWithin:rootNode:.This requires	Exceptions-eem.12	Kernel-eem.242	Compiler-eem.78"!!Parser methodsFor: 'pragmas' stamp: 'eem 11/29/2008 16:44'!addPragma: aPragma	properties := properties copyWith: aPragma! !!TempVariableNode methodsFor: 'printing' stamp: 'eem 7/24/2009 12:44'!printWithClosureAnalysisOn: aStream indent: level 	aStream nextPutAll: name.	readingScopes notNil ifTrue:		[(readingScopes inject: Set new into: [:them :reads| them addAll: reads. them]) asSortedCollection do:			[:location|			aStream space; nextPut: $r; nextPut: $@; print: location]].	writingScopes notNil ifTrue:		[(writingScopes inject: Set new into: [:them :writes| them addAll: writes. them]) asSortedCollection do:			[:location|			aStream space; nextPut: $w; nextPut: $@; print: location]]! !!Parser methodsFor: 'expression types' stamp: 'eem 12/1/2008 11:07'!method: doit context: ctxt encoder: encoderToUse	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	properties := AdditionalMethodState new.	encoder := encoderToUse.	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	self interactive ifTrue: [self removeUnusedTemps].	methodNode := self newMethodNode comment: messageComment.	^methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties! !!Decompiler class methodsFor: 'testing' stamp: 'ls 1/29/2004 23:54'!recompileAllTest	"[Decompiler recompileAllTest]"	"decompile every method and compile it back; if the decompiler is correct then the system should keep running.  :)"		| decompiled ast compiled |	SystemNavigation default allBehaviorsDo: [ :behavior |		Utilities informUser: (behavior printString) during: [			behavior selectors do: [ :sel |				decompiled := Decompiler new decompile: sel in: behavior.				ast := Compiler new compile: decompiled in: behavior notifying: nil ifFail: [ self error: 'failed' ].				compiled := ast generate: (behavior compiledMethodAt: sel) trailer.				behavior addSelector: sel withMethod: compiled. ] ] ]! !!BlockNode methodsFor: 'printing' stamp: 'eem 7/21/2009 13:12'!printTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries.  If there are any evaluate aBlock	 prior to printing.  Answer whether any temporaries were printed."	| tempStream seen |	tempSequence ifNil:		[^false].	tempStream := (String new: 16) writeStream.	"This is for the decompiler which canmot work out which optimized block a particular temp is	 local to and hence may produce diplicates as in		expr ifTrue: [| aTemp | ...] ifFalse: [| aTemp | ...]"	seen := Set new.	tempSequence do:		[:tempNode |		tempNode isIndirectTempVector			ifTrue:				[tempNode remoteTemps do:					[:tempVariableNode|					 (tempVariableNode scope >= 0					  and: [(seen includes: tempNode key) not]) ifTrue:						[tempStream space; nextPutAll: (seen add: tempVariableNode key)]]]			ifFalse:				[(tempNode scope >= -1				  and: ["This is for the decompiler which may create a block arg when converting						a while into a to:do: but won't remove it form temporaries"					   tempNode isBlockArg not				  and: [(seen includes: tempNode key) not]]) ifTrue:					[tempStream space; nextPutAll: (seen add: tempNode key)]]].	tempStream position = 0 ifTrue:		[^false].	aBlock value.	aStream nextPut: $|; nextPutAll: tempStream contents; space; nextPut: $|.	^true! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/1/2008 14:36'!printWithClosureAnalysisOn: aStream 	precedence = 1		ifTrue: 			[(self selector includesSubString: '()/')				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).						arguments							do: [:arg| aStream nextPutAll: arg key]							separatedBy: [aStream nextPutAll: ', '].						aStream nextPut: $)]				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				arg printDefinitionForClosureAnalysisOn: aStream.				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			 self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1; nextPut: $|.			temporaries do: [:temp | 				aStream space.				temp printDefinitionForClosureAnalysisOn: aStream].			aStream space; nextPut: $|].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'initialize-release' stamp: ''!selector: selOrFalse arguments: args precedence: p temporaries: temps block: blk encoder: anEncoder primitive: prim 	"Initialize the receiver with respect to the arguments given."	encoder := anEncoder.	selectorOrFalse := selOrFalse.	precedence := p.	arguments := args.	temporaries := temps.	block := blk.	primitive := prim! !!MethodNode methodsFor: 'source mapping' stamp: 'eem 3/14/2009 17:01'!rawSourceRangesAndMethodDo: aBinaryBlock	"Evaluate aBinaryBlock with the rawSourceRanges and method generated from the receiver."	| methNode method |	methNode := encoder classEncoding parserClass new					encoderClass: encoder class;					parse: (sourceText "If no source, use decompile string as source to map from"							ifNil: [self decompileString]							ifNotNil: [sourceText])					class: self methodClass.	method := methNode generate: #(0 0 0 0).  "set bytecodes to map to"	^aBinaryBlock		value: methNode encoder rawSourceRanges		value: method! !!Encoder methodsFor: 'encoding' stamp: 'eem 9/5/2009 20:04'!doItInContextName	^'ThisContext'! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 7/20/2009 14:27'!isDefinedWithinBlockExtent: anInterval	^anInterval rangeIncludes: definingScope actualScope blockExtent first! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/1/2008 14:25'!printPropertiesOn: aStream	properties ifNil: [^self].	properties propertyKeysAndValuesDo:		[:prop :val|		aStream crtab; nextPut: $<.		prop = #on:in:			ifTrue:				[prop keywords with: val do:					[:k :v | aStream nextPutAll: k; space; nextPutAll: v; space]]			ifFalse:				[prop = #on					ifTrue: [aStream nextPutAll: prop; nextPutAll:': '; nextPutAll: val] 					ifFalse: [aStream nextPutAll: prop; nextPutAll:': '; print: val]]. 		aStream nextPut: $>]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2009 16:43'!addRemoteTemp: aTempVariableNode rootNode: rootNode "<MethodNode>"	"Add aTempVariableNode to my actualScope's sequence of	 remote temps.  If I am an optimized block then the actual	 scope is my actualScopeIfOptimized, otherwise it is myself."	temporaries isArray ifTrue:		[temporaries := temporaries asOrderedCollection].	remoteTempNode == nil ifTrue:		[remoteTempNode := RemoteTempVectorNode new								name: self remoteTempNodeName								index: arguments size + temporaries size								type: LdTempType								scope: 0.		 actualScopeIfOptimized			ifNil:				[temporaries addLast: remoteTempNode.				 remoteTempNode definingScope: self]			ifNotNil: [actualScopeIfOptimized addHoistedTemps: { remoteTempNode }]].	remoteTempNode addRemoteTemp: aTempVariableNode encoder: rootNode encoder.	"use remove:ifAbsent: because the deferred analysis for optimized	 loops can result in the temp has already been hoised into the root."	temporaries remove: aTempVariableNode ifAbsent: [].	^remoteTempNode! !!Decompiler methodsFor: 'initialize-release' stamp: 'eem 7/1/2009 14:45'!initSymbols: aClass	constructor method: method class: aClass literals: method literals.	constTable := constructor codeConstants.	instVars := Array new: aClass instSize.	tempVarCount := method numTemps.	"(tempVars isNil	 and: [method holdsTempNames]) ifTrue:		[tempVars := method tempNamesString]."	tempVars isString		ifTrue:			[blockStartsToTempVars := self mapFromBlockStartsIn: method											toTempVarsFrom: tempVars											constructor: constructor.			 tempVars := blockStartsToTempVars at: method initialPC]		ifFalse:			[| namedTemps |			namedTemps := tempVars ifNil: [(1 to: tempVarCount) collect: [:i| 't', i printString]].			tempVars := (1 to: tempVarCount) collect:							[:i | i <= namedTemps size								ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]								ifFalse: [constructor codeTemp: i - 1]]].	1 to: method numArgs do:		[:i|		(tempVars at: i) beMethodArg]! !!ParseNode methodsFor: 'printing' stamp: 'eem 9/5/2009 11:27'!printCommentOn: aStream indent: indent 	| thisComment |	self comment == nil ifTrue: [^ self].	1 to: self comment size	   do: [:index |		index > 1 ifTrue: [aStream crtab: indent].		aStream nextPut: $".		thisComment := self comment at: index.		self printSingleComment: thisComment			on: aStream			indent: indent.		aStream nextPut: $"]! !!Decompiler methodsFor: 'initialize-release' stamp: 'eem 6/29/2009 09:41'!withTempNames: tempNames "<Array|String>"	"Optionally initialize the temp names to be used when decompiling.	 For backward-copmpatibility, if tempNames is an Array it is a single	 vector of temp names, probably for a blue-book-compiled method.	 If tempNames is a string it is a schematic string that encodes the	 layout of temp vars in the method and any closures/blocks within it.	 Decoding encoded tempNames is done in decompile:in:method:using:	 which has the method from which to derive blockStarts.	 See e.g. BytecodeEncoder>>schematicTempNamesString for syntax."	tempVars := tempNames! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 6/11/2009 17:04'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries |	selectorNode := self codeSelector: selector code: nil.	tempVars := vars.	visibleTemps := OrderedCollection new.	invisibleTemps := OrderedCollection new.	tempVars do: [:t|				   ((t isIndirectTempVector or: [t scope >= 0])						ifTrue: [visibleTemps]						ifFalse: [invisibleTemps]) addLast: t].	arguments := visibleTemps copyFrom: 1 to: nArgs.	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.	block		arguments: arguments;		temporaries: temporaries.	blockNode := BytecodeAgnosticMethodNode new		selector: selectorNode		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (EncoderForV3PlusClosures new initScopeAndLiteralTables					temps: visibleTemps, invisibleTemps					literals: literalValues					class: class)		primitive: primitive		properties: method properties copy.	blockNode properties method: blockNode.	^blockNode! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/4/2009 11:43'!popIntoTemporaryVariable: offset	| maybeTVTag tempVector start |	maybeTVTag := stack last.	((maybeTVTag isMemberOf: Association)	 and: [maybeTVTag key == #pushNewArray]) ifTrue:		[blockStartsToTempVars notNil "implies we were intialized with temp names."			ifTrue: "Use the provided temps"				[self assert: ((tempVector := tempVars at: offset + 1 ifAbsent: [ParseNode basicNew]) isTemp							 and: [tempVector isIndirectTempVector							 and: [tempVector remoteTemps size = maybeTVTag value size]])]			ifFalse: "Synthesize some remote temps"				[tempVector := maybeTVTag value.				 offset + 1 <= tempVars size					ifTrue:						[start := 2.						 tempVector at: 1 put: (tempVars at: offset + 1)]					ifFalse:						[tempVars := (Array new: offset + 1)										replaceFrom: 1										to: tempVars size										with: tempVars.						start := 1].				 start to: tempVector size do:					[:i|					tempVector						at: i						put: (constructor								codeTemp: numLocalTemps + offset + i - 1								named: 't', (tempVarCount + i) printString)].				tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector)].		 tempVarCount := tempVarCount + maybeTVTag value size.		 stack removeLast.		 ^self].	self pushTemporaryVariable: offset; doStore: statements! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2009 13:29'!analyseArguments: methodArguments temporaries: methodTemporaries rootNode: rootNode "<MethodNode>" "^<Sequence of: <TempVarNade>>"	"Top level entry-point for analysing temps within the hierarchy of blocks in the receiver's method.	 Answer the (possibly modified) sequence of temp vars.	 Need to hoist temps out of macro-optimized blocks into their actual blocks.	 Need to note reads and writes to temps from blocks other than their actual blocks to determine	 whether blocks can be local (simple slots within a block/method context) or remote (slots in	 indirection vectors that are shared between contexts by sharing indirection vectors).	 The algorithm is based on numbering temporary reads and writes and block extents.	 The index used for numbering starts at zero and is incremented on every block entry	 and block exit.  So the following		| a b blk r1 r2 t |		a := 1. b := 2. t := 0.		blk := [ | s | s := a + b. t := t + s].		r1 := blk value.		b := -100.		r2 := blk value.		r1 -> r2 -> t	is numbered as		method block 0 to: 6:		| a b blk r1 r2 t |		a w@1 := 1. b w@1 := 2. t w@1 := 0.		blk w@5 := [entry@2 | s |					 t  w@3 := t r@3 + a r@3 + b r@3					] exit@4.		r1 w@5 := blk r@5 value.		b w@5 := nil.		r2 w@5 := blk r@5 value.		r1 r@5 -> r2 r@5 -> t r@5	So:		b and blk cannot be copied because for both there exists a write @5 that follows a			read @4 within block 2 through 4		t must be remote because there exists a write @3 within block (2 to: 4)	Complications are introduced by optimized blocks.  In the following temp is written to	after it is closed over by [ temp ] since the inlined block is executed more than once.		| temp coll |		coll := OrderedCollection new.		1 to: 5 do: [ :index | 			temp := index. 			coll add: [ temp ] ].		self assert: (coll collect: [:ea| ea value]) asArray = #(5 5 5 5 5)	In the following i is local to the block and must be initialized each time around the loop	but if the block is inlined it must be declared at method level.		| col |		col := OrderedCollection new.		1 to: 3 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].		self assert: (col collect: [ :each | each value ]) asArray = #(2 3 4)"	self assert: (arguments isEmpty or: [arguments hasEqualElements: methodArguments]).	arguments := methodArguments asArray. "won't change"	self assert: (temporaries isNil or: [temporaries isEmpty or: [temporaries hasEqualElements: methodTemporaries]]).	temporaries := OrderedCollection withAll: methodTemporaries.	self assert: optimized not. "the top-level block should not be optimized."	self analyseTempsWithin: self rootNode: rootNode assignmentPools: Dictionary new.	"The top-level block needs to reindex temporaries since analysis may have rearranged them.	 This happens when temps are made remote and/or a remote node is added."	temporaries withIndexDo:		[:temp :offsetPlusOne| temp index: arguments size + offsetPlusOne - 1].	"Answer the (possibly modified) sequence of temps."	^temporaries asArray! !!MethodNode methodsFor: 'code generation' stamp: 'eem 12/1/2008 12:03'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| literals blkSize method nArgs nLits primErrNode stack strm |	self generate: trailer ifQuick: 		[:m |		literals := encoder allLiterals.		(nLits := literals size) > 255 ifTrue:			[^self error: 'Too many literals referenced'].		1 to: nLits do: [:lit | m literalAt: lit put: (literals at: lit)].		m properties: properties.		^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	nArgs := arguments size.	blkSize := (block sizeForEvaluatedValue: encoder)				+ (primErrNode ifNil: [0] ifNotNil: [2 "We force store-long (129)"]).	(nLits := (literals := encoder allLiterals) size) > 255 ifTrue:		[^self error: 'Too many literals referenced'].	method := CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm := ReadWriteStream with: method.	strm position: method initialPC - 1.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitStore: stack on: strm].	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue:		[^self error: 'Compiler stack discrepancy'].	strm position ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method properties: properties.	^method! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2009 15:07'!analyseClosure: rootNode "<MethodNode>"	"Analyse whether the temporary needs to be made remote	 or not, and answer whether it was made remote.	 A temp cannot be local if it is written to remotely,	 or if it is written to after it is closed-over.  An exception	 is an inlined block argument that appears to be written	 remotely but is actually local to a block."	| latestWrite |	self isBlockArg ifTrue: [^false].	remoteNode ifNotNil: [^false]. "If already remote, don't remote a second time"	latestWrite := 0.	((writingScopes notNil	 and: [writingScopes associations anySatisfy: [:assoc|			[:blockScope :refs|			refs do: [:write| latestWrite := write max: latestWrite].			"A temp cannot be local if it is written to remotely."			blockScope actualScope ~~ definingScope actualScope]				value: assoc key value: assoc value]])	or: [readingScopes notNil		and: [readingScopes associations anySatisfy: [:assoc|				[:blockScope :refs|				 "A temp cannot be local if it is written to after it is closed-over."				 blockScope actualScope ~~ definingScope actualScope				 and: [refs anySatisfy: [:read| read < latestWrite]]]					value: assoc key value: assoc value]]]) ifTrue:		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode.		 ^true].	^false! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2009 11:56'!computeCopiedValues: rootNode	| referencedValues |	referencedValues := rootNode referencedValuesWithinBlockExtent: blockExtent.	^((referencedValues reject: [:temp| temp isDefinedWithinBlockExtent: blockExtent])		asSortedCollection: ParseNode tempSortBlock)			asArray! !!Parser methodsFor: 'error correction' stamp: 'eem 9/5/2009 11:59'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str end start madeChanges | 	madeChanges := false.	str := requestor text asString.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		(UnusedVariable name: temp) ifTrue:			[(encoder encodeVariable: temp) isUndefTemp				ifTrue:					[end := tempsMark.					["Beginning at right temp marker..."					start := end - temp size + 1.					end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]						whileFalse:							["Search left for the unused temp"							end := requestor nextTokenFrom: end direction: -1].					end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start := start-1].						requestor correctFrom: start to: end with: ''.						str := str copyReplaceFrom: start to: end with: ''. 						madeChanges := true.						tempsMark := tempsMark - (end-start+1)]]				ifFalse:					[self inform:'You''ll first have to remove the\statement where it''s stored into' withCRs]]].	madeChanges ifTrue: [ReparseAfterSourceEditing signal]! !!Parser methodsFor: 'error correction' stamp: 'cwp 10/17/2007 22:38/eem 9/5/2009 11:10 - => :='!queryUndefined	| varStart varName | 	varName := parseNode key.	varStart := self endOfLastToken + requestorOffset - varName size + 1.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	(UndefinedVariable name: varName) ifFalse: [^ self fail]! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/5/2008 09:49'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primDecl |	primitive = 0 ifTrue:		[^self].	primitive = 120 ifTrue: "External call spec"		[^aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primitive = 117		ifTrue:			[primDecl := encoder literals at: 1.			 (primDecl at: 2) asString printOn: aStream.			 (primDecl at: 1) ifNotNil:				[:moduleName|				aStream nextPutAll:' module: '.				moduleName asString printOn: aStream]]		ifFalse:			[aStream print: primitive].	self primitiveErrorVariableName ifNotNil:		[:primitiveErrorVariableName|		 aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].	aStream nextPut: $>.	Smalltalk at: #Interpreter ifPresent:[:cls|		aStream nextPutAll: ' "',							((cls classPool at: #PrimitiveTable) at: primitive + 1),							'" ']! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/1/2008 14:36'!printOn: aStream	| selectorNode |	selectorNode := self selectorNode.	precedence = 1		ifTrue:			[selectorNode isForFFICall				ifTrue: [selectorNode							printAsFFICallWithArguments: arguments							on: aStream							indent: 0]				ifFalse: [aStream nextPutAll: selectorNode key]]		ifFalse:			[selectorNode key keywords with: arguments do:				[:kwd :arg |				aStream nextPutAll: kwd; space; nextPutAll: arg key; space]].	comment == nil ifFalse:		[aStream crtab: 1.		 self printCommentOn: aStream indent: 1].	block printTemporaries: temporaries on: aStream doPrior: [aStream crtab: 1].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printStatementsOn: aStream indent: 0! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 8/3/2009 18:54'!addReadWithin: scopeBlock "<BlockNode>" at: location "<Integer>"	readingScopes ifNil: [readingScopes := Dictionary new].	(readingScopes at: scopeBlock ifAbsentPut: [Set new]) add: location.	remoteNode ifNotNil:		[remoteNode addReadWithin: scopeBlock at: location]! !!Parser methodsFor: 'pragmas' stamp: 'eem 12/1/2008 14:33'!pragmaPrimitives	| primitives |	properties isEmpty ifTrue:		[^0].	primitives := properties pragmas select:					[:pragma|					self class primitivePragmaSelectors includes: pragma keyword].	primitives isEmpty ifTrue:		[^0].	primitives size > 1 ifTrue:		[^self notify: 'Ambigous primitives'].	^self perform: primitives first keyword withArguments: primitives first arguments! !!Compiler methodsFor: 'public access' stamp: 'eem 7/1/2009 13:53'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value toLog itsSelection itsSelectionString |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method := methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method := method copyWithTempsFromMethodNode: methodNode].		value := receiver				withArgs: (context ifNil: [#()] ifNotNil: [{context}])				executeMethod: method.	logFlag ifTrue:[		toLog := ((requestor respondsTo: #selection)  			and:[(itsSelection := requestor selection) notNil			and:[(itsSelectionString := itsSelection asString) isEmptyOrNil not]])				ifTrue:[itsSelectionString]				ifFalse:[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext].	^ value! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2009 11:42'!addHoistedTemps: additionalTemporaries "<SequenceableCollection>"	additionalTemporaries do:		[:temp|		temp definingScope ifNil:			[temp definingScope: self]].	temporaries := (temporaries isNil or: [temporaries isEmpty])					ifTrue: [additionalTemporaries copy]					ifFalse:						[temporaries last isIndirectTempVector							ifTrue: [temporaries allButLast, additionalTemporaries, { temporaries last }]							ifFalse: [temporaries, additionalTemporaries]]! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2009 13:26'!index: anInteger	"For renumbering temps in the closure compiler."	index := anInteger.	code := self code: index type: LdTempType! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 7/1/2009 10:35'!jump: dist if: condition	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock	  thenJump elseJump condHasValue isIfNil saveStack blockBody |	stack last == CascadeFlag ifTrue: [^ self case: dist].	elsePc := lastPc.	elseStart := pc + dist.	end := limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign := condition.	savePc := pc.	self interpretJump ifNotNil:		[:elseDist|		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:			 [sign := sign not.  elseStart := pc + elseDist]].	pc := savePc.	ifExpr := stack removeLast.	(isIfNil := stack size > 0 and: [stack last == IfNilFlag]) ifTrue:		[stack removeLast].	saveStack := stack.	stack := OrderedCollection new.	thenBlock := self blockTo: elseStart.	condHasValue := hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			  thenJump will jump to the beginning of the while expr.  In the case of while's			  with a block in the condition, the while expr should include more than just			  the last expression: find all the statements needed by re-decompiling."			stack := saveStack.			pc := thenJump.			blockBody := self statementsTo: elsePc.			"discard unwanted statements from block"			blockBody size - 1 timesRepeat: [statements removeLast].			statements addLast:				(constructor					codeMessage: (constructor codeBlock: blockBody returns: false)					selector: (constructor								codeSelector: (sign												ifTrue: [#whileFalse:]												ifFalse: [#whileTrue:])								code: #macro)					arguments: { thenBlock }).			pc := elseStart.			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock := self blockTo: thenJump.			elseJump := exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc ifTrue:				[pc := lastPc].			cond := isIfNil						ifTrue:							[constructor								codeMessage: ifExpr ifNilReceiver								selector: (constructor											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])											code: #macro)								arguments: (Array with: thenBlock)]						ifFalse:							[constructor								codeMessage: ifExpr								selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)								arguments:	(sign												ifTrue: [{elseBlock. thenBlock}]												ifFalse: [{thenBlock. elseBlock}])].			stack := saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!Compiler methodsFor: 'public access' stamp: 'eem 9/4/2009 08:47'!compiledMethodFor: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code	 into a method, and answers it.  If receiver is not nil, then the text can	 refer to instance variables of that receiver (the Inspector uses this).	 If aContext is not nil, the text can refer to temporaries in that context	 (the Debugger uses this). If aRequestor is not nil, then it will receive a 	 notify:at: message before the attempt to evaluate is aborted."	| methodNode method |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail: [^failBlock value].	method := methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method := method copyWithTempsFromMethodNode: methodNode].	logFlag ifTrue:		[SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext].	^method! !!Decompiler methodsFor: 'public access' stamp: 'eem 7/1/2009 14:43'!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home source |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home who first) == #unknown ifTrue: [^ nil].	constructor := self constructorForMethod: aBlock method.	method fileIndex ~~ 0 ifTrue: "got any source code?"		[source := [method getSourceFromFile]						on: Error						do: [:ex | ^ nil].		 methodNode := [homeClass compilerClass new								parse: source								in: homeClass								notifying: nil]							on: (Smalltalk classNamed: 'SyntaxErrorNotification')							do: [:ex | ^ nil].		 self withTempNames: methodNode schematicTempNamesString].	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock isClosure				ifTrue: [(method at: startpc - 2) * 256					  + (method at: startpc - 1) + startpc - 1]				ifFalse:					[(method at: startpc - 2) \\ 16 - 4 * 256					+ (method at: startpc - 1) + startpc - 1].	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super		method: method		pc: (aBlock isClosure ifTrue: [startpc - 4] ifFalse: [startpc - 5]).	aBlock isClosure ifTrue:		[numLocalTemps := #decompileBlock: "Get pushClosureCopy... to hack fake temps for copied values"].	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!Decompiler methodsFor: 'public access' stamp: 'eem 7/1/2009 14:45'!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block node |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			numLocalTemps := 0.			super method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self willStore]) ifTrue:				[pc := pc + 2.				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	node := constructor				codeMethod: aSelector				block: block				tempVars: tempVars				primitive: method primitive				class: aClass.	method primitive > 0 ifTrue:		[node removeAndRenameLastTempIfErrorCode].	^node! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 8/3/2009 18:55'!addWriteWithin: scopeBlock "<BlockNode>" at: location "<Integer>"	writingScopes ifNil: [writingScopes := Dictionary new].	(writingScopes at: scopeBlock ifAbsentPut: [Set new]) add: location.	remoteNode ifNotNil:		[remoteNode addReadWithin: scopeBlock at: location]! !!Decompiler methodsFor: 'control' stamp: 'eem 7/1/2009 14:37'!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| savedTemps savedTempVarCount savedNumLocalTemps	  jump blockArgs blockTemps blockTempsOffset block |	savedTemps := tempVars.	savedTempVarCount := tempVarCount.	savedNumLocalTemps := numLocalTemps.	jump := blockSize + pc.	numLocalTemps := BlockLocalTempCounter tempCountForBlockAt: pc - 4 in: method.	blockTempsOffset := numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: pc])		ifTrue:			[tempVars := blockStartsToTempVars at: pc]		ifFalse:			[blockArgs := (1 to: numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	tempVarCount := tempVarCount + numArgs + numLocalTemps.	block := self blockTo: jump.	stack addLast: (constructor					codeArguments: (tempVars copyFrom: 1 to: numArgs)					temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)					block: block).	tempVars := savedTemps.	tempVarCount := savedTempVarCount.	numLocalTemps := savedNumLocalTemps! !PrimitiveNode removeSelector: #printOn:!PrimitiveNode removeSelector: #num!Parser removeSelector: #properties!TempNumberNormalizingVisitor removeSelector: #renumberTemp:!TempNumberNormalizingVisitor removeSelector: #visitBlockNode:!TempVariableNode removeSelector: #analyseTempsWithin:rootNode:!Smalltalk removeClassNamed: #PrimitiveNode!LeafNode removeSelector: #analyseTempsWithin:rootNode:!RemoteTempVectorNode removeSelector: #cleanUpForRegeneration!BlockNode removeSelector: #analyseTempsWithin:rootNode:!BlockNode removeSelector: #printTemporariesOn:indent:!BraceNode removeSelector: #analyseTempsWithin:rootNode:!BlockNode removeSelector: #cleanUpForRegeneration!BytecodeAgnosticMethodNode removeSelector: #copiedValuesWithinBlockExtent:!ParseNode removeSelector: #ifOptimizedBlockHoistTempsInto:!PrimitiveNode removeSelector: #printPrimitiveOn:!MethodNode removeSelector: #prepareForRegeneration!TempVariableNode removeSelector: #beingAssignedToAnalyseTempsWithin:rootNode:!CascadeNode removeSelector: #analyseTempsWithin:rootNode:!TempNumberNormalizingVisitor removeSelector: #initialize!BytecodeAgnosticMethodNode removeSelector: #prepareForRegeneration!PrimitiveNode classSide removeSelector: #null!BytecodeAgnosticMethodNode removeSelector: #blockExtentsToTempRefs!VariableNode removeSelector: #beingAssignedToAnalyseTempsWithin:rootNode:!RegenerationPreparingVisitor removeSelector: #visitBlockNode:!PrimitiveNode removeSelector: #sourceText!PrimitiveNode removeSelector: #num:!PrimitiveNode removeSelector: #spec:!AssignmentNode removeSelector: #analyseTempsWithin:rootNode:!Smalltalk removeClassNamed: #RegenerationPreparingVisitor!BytecodeEncoder removeSelector: #blockExtentsToTempRefs!NewArrayNode removeSelector: #analyseTempsWithin:rootNode:!PrimitiveNode removeSelector: #spec!ReturnNode removeSelector: #analyseTempsWithin:rootNode:!BlockNode removeSelector: #postNumberingProcessTemps:!RegenerationPreparingVisitor removeSelector: #visitTempVariableNode:!Compiler class removeSelector: #closureDecompilerClass!Compiler class removeSelector: #closureParserClass!BlockNode removeSelector: #ifOptimizedBlockHoistTempsInto:!TempNumberNormalizingVisitor removeSelector: #visitTempVariableNode:!MessageNode removeSelector: #analyseTempsWithin:rootNode:!Smalltalk removeClassNamed: #TempNumberNormalizingVisitor!