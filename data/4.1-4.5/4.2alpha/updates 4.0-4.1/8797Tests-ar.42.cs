"Change Set:		8797Tests-ar.42Tests-ar.42:More unloading work: Move MC mock package to tests. Update tests to account for the change.Tests-ar.41:Making Tests unloadable: Move tests from Exceptions, Files, Compiler, System, Monticello into Tests package."!TestCase subclass: #SmalltalkImageTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Support'!MCMock subclass: #MCMockClassB	instanceVariableNames: 'ivarb'	classVariableNames: 'CVar'	poolDictionaries: 'MCMockAPoolDictionary'	category: 'Tests-Monticello-Mocks'!TestCase subclass: #CompilerExceptionsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!TestCase subclass: #ArrayLiteralTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!Notification subclass: #ParserRemovedUnusedTemps	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!TestCase subclass: #ExpandedSourceFileArrayTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Files'!Object variableSubclass: #MCMockClassE	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!LongTestCase subclass: #DecompilerTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!TestResource subclass: #MCSnapshotResource	instanceVariableNames: 'snapshot'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCTestCase subclass: #MCSnapshotBrowserTest	instanceVariableNames: 'model morph'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!TestCase subclass: #MirrorPrimitiveTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!TestCase subclass: #SystemVersionTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Support'!TestCase subclass: #StandardSystemFontsTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-System-Support'!Object subclass: #MCMockClassF	instanceVariableNames: ''	classVariableNames: 'Foo'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCMock subclass: #MCMockDependentItem	instanceVariableNames: 'name provides requires'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCRepositoryTest	instanceVariableNames: 'repository ancestors'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCTestCase subclass: #MCSerializationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!ClassTestCase subclass: #EventManagerTest	instanceVariableNames: 'eventSource eventListener succeeded'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Object Events'!TestCase subclass: #ObjectFinalizerTests	instanceVariableNames: 'log'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Finalization'!TestCase subclass: #DosFileDirectoryTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Files'!MCTestCase subclass: #MCClassDefinitionTest	instanceVariableNames: 'previousChangeSet'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!Error subclass: #MyTestError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!Object weakSubclass: #MCMockClassI	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCPatchTest	instanceVariableNames: 'patch'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCTestCase subclass: #MCOrganizationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!Notification subclass: #MyTestNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!DecompilerTests subclass: #DecompilerTestFailuresCollector	instanceVariableNames: 'failures'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!SharedPool subclass: #MCMockAPoolDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCChangeNotificationTest	instanceVariableNames: 'workingCopy'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!TestCase subclass: #ExceptionTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!TestCase subclass: #MacFileDirectoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Files'!PackageInfo subclass: #MCEmptyPackageInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!TestCase subclass: #CompilerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!MCTestCase subclass: #MCStReaderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!ClassTestCase subclass: #FileDirectoryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Files'!MCTestCase subclass: #MCScannerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCMockClassA subclass: #MCMockASubclass	instanceVariableNames: 'x'	classVariableNames: 'Y'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!ClosureCompilerTest subclass: #MethodHighlightingTests	instanceVariableNames: 'creator timeStamp duration tracks'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!TestCase subclass: #ContextCompilationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!MCTestCase subclass: #MCVersionTest	instanceVariableNames: 'version visited'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!Object subclass: #MCMockDependency	instanceVariableNames: 'name children hasResolution'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCFileInTest	instanceVariableNames: 'stream expected diff'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!Object subclass: #ExceptionTester	instanceVariableNames: 'log suiteLog iterationsBeforeTimeout'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!TestCase subclass: #ClosureTests	instanceVariableNames: 'collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!MCTestCase subclass: #MCAncestryTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!Object subclass: #MCMock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCMczInstallerTest	instanceVariableNames: 'expected diff'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!PackageInfo subclass: #MCMockPackageInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!Object subclass: #MCMockClassD	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!TestCase subclass: #ProcessTerminateBug	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!MCRepositoryTest subclass: #MCDictionaryRepositoryTest	instanceVariableNames: 'dict'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCTestCase subclass: #MCInitializationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCTestCase subclass: #MCPackageTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!TestCase subclass: #MCSortingTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCRepositoryTest subclass: #MCDirectoryRepositoryTest	instanceVariableNames: 'directory'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!TestCase subclass: #MCDependencySorterTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!ClassTestCase subclass: #SecureHashAlgorithmTest	instanceVariableNames: 'hash'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Digital Signatures'!TestCase subclass: #LocaleTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Localization'!Object variableWordSubclass: #MCMockClassG	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCSnapshotTest	instanceVariableNames: 'snapshot'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!MCTestCase subclass: #MCMethodDefinitionTest	instanceVariableNames: 'navigation isModified'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!TestCase subclass: #ClosureCompilerTest	instanceVariableNames: ''	classVariableNames: 'CmpRR CogRTLOpcodes Jump MoveCqR Nop'	poolDictionaries: ''	category: 'Tests-Compiler'!MCDefinition subclass: #MCMockDefinition	instanceVariableNames: 'token'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!TestCase subclass: #TextDiffBuilderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-FilePackage'!MCTestCase subclass: #MCWorkingCopyTest	instanceVariableNames: 'savedInitials workingCopy repositoryGroup versions versions2'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!Object variableByteSubclass: #MCMockClassH	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!TestCase subclass: #StandardSourceFileArrayTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Files'!TestCase subclass: #MCTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!PackageInfo subclass: #MCDirtyPackageInfo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCMergingTest	instanceVariableNames: 'conflictBlock conflicts'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!Error subclass: #MyResumableTestError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Exceptions'!TestCase subclass: #ScannerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Compiler'!MCMock subclass: #MCMockClassA	instanceVariableNames: 'ivar'	classVariableNames: 'CVar'	poolDictionaries: ''	category: 'Tests-Monticello-Mocks'!MCTestCase subclass: #MCStWriterTest	instanceVariableNames: 'stream writer'	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Monticello'!ClassTestCase subclass: #FileStreamTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Tests-Files'!!EventManagerTest methodsFor: 'running' stamp: 'jws 11/28/2000 16:25'!tearDown	eventSource releaseActionMap.	eventSource := nil.	eventListener := nil.	super tearDown.! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'klub 12/28/2009 00:02'!testEmptyLcs3	| patch |	patch := self patchSequenceFor: #(a b c) and: #(d e f g).	self assert: patch size = 7.		patch do: [ :each |		each key = #remove ifTrue: [ self assert: ('abc' includes: each value first) ].		each key = #insert ifTrue: [ self assert: ('defg' includes: each value first) ] ]! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/30/2003 19:24'!mockMessageString	^ 'A version generated for testing purposes.'! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesXAtoXM	self decompileClassesSelect: [:cn| cn first = $X and: [cn second asUppercase <= $M]]! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:25'!testExample3	"This is the third example from the specification document (FIPS PUB 180-1). 	This example may take several minutes."	hash := SecureHashAlgorithm new hashMessage: (String new: 1000000 withAll: $a).	self assert: (hash = 16r34AA973CD4C4DAA4F61EEB2BDBAD27316534016F).! !!MCTestCase methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertSnapshot: actual matches: expected	| diff |	diff := actual patchRelativeToBase: expected.	self assert: diff isEmpty! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'mha 7/30/2009 11:24'!testAttemptExistenceCheckWhenFile	"How should a FileDirectory instance respond with an existent file name?"		| directory filename |		filename := 'aTestFile'.	FileDirectory default forceNewFileNamed: filename.	directory := FileDirectory default directoryNamed: filename.	self shouldnt: [directory exists] description: 'Files are not directories.'.		"clean up disk"	FileDirectory default deleteFileNamed: filename ifAbsent: [ ]! !!MCMergingTest methodsFor: 'asserting' stamp: 'ab 1/15/2003 16:46'!assert: aCollection hasElements: anArray	self assert: (aCollection collect: [:ea | ea token]) asSet = anArray asSet! !!StandardSystemFontsTest methodsFor: 'testing' stamp: 'bp 8/9/2009 20:07'!testRestoreDefaultFonts	self saveStandardSystemFontsDuring: [		Preferences restoreDefaultFonts.		self assert: #standardDefaultTextFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardListFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardFlapFont familyName: 'Accushi' pointSize: 12.		self assert: #standardEToysFont familyName: 'BitstreamVeraSans' pointSize: 9.		self assert: #standardMenuFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #windowTitleFont familyName: 'Bitmap DejaVu Sans' pointSize: 12.		self assert: #standardBalloonHelpFont familyName: 'Accujen' pointSize: 9.		self assert: #standardCodeFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardButtonFont familyName: 'BitstreamVeraSansMono' pointSize: 9]! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/8/1999 09:38'!logTestResult: aString	| index |	index := self suiteLog size.	self suiteLog 		at: index		put: ((self suiteLog at: index), ' ', aString)! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:43'!testSimpleResignalAs	self assertSuccess: (ExceptionTester new runTest: #simpleResignalAsTest ) ! !!MCStWriterTest methodsFor: 'asserting' stamp: 'al 7/21/2006 22:14'!assertMethodChunkIsWellFormed: chunk	self class parserClass new		parse: chunk readStream 		class: UndefinedObject 		noPattern: false		context: nil		notifying: nil		ifFail: [self assert: false]! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!name: aString	name := aString! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'avi 10/7/2004 22:12'!testUnusedAlternateProvider	self assertItems: #(		(a (x) (z))		(b () (x))		(c (x) ()))	orderAs: #(c b)	withRequired: #(z)	toLoad: #(a)	! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testSimpleOrdering	self assertItems: #((a (x) ())								 (c () (y))								 (b (y) (x)))		orderAs: #(a b c)		withRequired: #()		toLoad: #()! !!MCVersionTest methodsFor: 'building' stamp: 'cwp 11/7/2004 12:40'!versionFromTree: sexpr	^ (self dependencyFromTree: sexpr) resolve! !!MCTestCase class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:05'!resources	^ Array with: MCSnapshotResource! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'stephaneducasse 2/4/2006 20:47'!protocolsForClass: aClass	| protocols |	protocols := aClass organization categories.	protocols size > 1 ifTrue: [protocols := protocols copyWith: '-- all --'].	^ protocols.! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'dtl 6/1/2004 21:56'!doublePassOuterTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNoChange	| actual |	actual := MCSnapshotResource takeSnapshot.	diff := actual patchRelativeToBase: expected snapshot.	self assert: diff isEmpty! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!printString	^ token! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesFNtoFZ	self decompileClassesSelect: [:cn| cn first = $F and: [cn second asUppercase > $M]]! !!CompilerExceptionsTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/25/2009 20:27'!griffle | goo |! !!MCStWriterTest methodsFor: 'data' stamp: 'cwp 8/2/2003 12:14'!expectedOrganizationDefinition	^ 'SystemOrganization addCategory: ''Monticello-Mocks''!!'! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:14'!doSomethingExceptionalString	^'Do something exceptional.'! !!MCFileInTest methodsFor: 'running' stamp: 'cwp 8/10/2003 00:27'!tearDown	(diff isNil or: [diff isEmpty not])		 ifTrue: [expected updatePackage: self mockPackage]! !!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'ar 1/4/2010 18:26'!override ^ 1! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:46'!testSimpleIsNested	self assertSuccess: (ExceptionTester new runTest: #simpleIsNestedTest ) ! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:27'!testUnusedVariable	self 		should: 			[self class 				compile: self unusedVariableSource				notifying: self]		raise: UnusedVariable! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:13'!doSomethingString	^'Do something.'! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/28/2003 22:21'!annotationTextMorph	^ (self morphsOfClass: TextMorph) first! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesUNtoUZ	self decompileClassesSelect: [:cn| cn first = $U and: [cn second asUppercase > $M]]! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 09:19'!findButtonWithLabel: aString	^ self buttonMorphs detect: [:m | m label = aString]! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:28'!test6	self should: [MCScanner scan: '(a b' readStream] raise: Error! !!MCMockPackageInfo class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 14:04'!initialize	[self new register] on: MessageNotUnderstood do: []! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'dtl 6/1/2004 21:56'!doubleOuterPassTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/24/2008 11:03'!testDebuggerTempAccess	self doTestDebuggerTempAccessWith: 1 with: 2! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 1/19/2004 15:54'!mockDependencies	^ Array with: (MCVersionDependency package: self mockEmptyPackage info: (self mockVersionInfo: 'x'))! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 05:59'!testIfSequence3	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(b d c a).	self assert: patch size = 6.	"lcs is bd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bd' includes: each value first) ]			ifFalse: [ self assert: ('ac' includes: each value first) ] ]! !!MCRepositoryTest methodsFor: 'building' stamp: 'ab 7/10/2003 01:03'!snapshot1	^ (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: #('y'))))! !!MCTestCase methodsFor: 'compiling' stamp: 'abc 2/16/2006 09:24'!compileClass: aClass source: source category: category	aClass compileSilently: source classified: category! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:09'!classNames	^ #(	MCMockClassA		 	MCMockASubclass			MCMockClassB			MCMockClassD			MCMockClassE			MCMockClassF			MCMockClassG			MCMockClassH			MCMockClassI		)! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 11/10/2008 16:52'!isFailure: cls sel: selector 	"self new isKnowProblem: PNMReaderWriter sel: #nextImage"	"#((PNMReadWriter nextImage)) includes: {PNMReadWriter	name asSymbol . #nextImage}."	^(#(#DoIt #DoItIn:) includes: selector)	   or: [self decompilerFailures includes: {cls name asSymbol. selector}]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesNAtoNM	self decompileClassesSelect: [:cn| cn first = $N and: [cn second asUppercase <= $M]]! !!MCStWriterTest methodsFor: 'data' stamp: 'cwp 8/2/2003 14:43'!expectedClassMethodDefinition	^ '!!MCMockClassA class methodsFor: ''as yet unclassified'' stamp: ''ab 7/7/2003 23:21''!!one	^ 1!! !!'! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 01:28'!findListContaining: aString	^ self listMorphs detect: [:m | m getList includes: aString]! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'dtl 6/1/2004 21:54'!testDoublePassOuter	self assertSuccess: (ExceptionTester new runTest: #doublePassOuterTest ) ! !!MCSortingTest methodsFor: 'building' stamp: 'ab 4/8/2003 17:56'!classNamed: aSymbol	^ MCClassDefinition		name: aSymbol		superclassName: #Object		category: ''		instVarNames: #()		comment: ''! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:44'!testSignalFromHandlerActionTest	self assertSuccess: (ExceptionTester new runTest: #signalFromHandlerActionTest ) ! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!provides: anArray	provides := anArray! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 18:25'!= definition	^definition token = token! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 16:54'!simpleNoTimeoutTestResults	^OrderedCollection new		add: self doSomethingString;		yourself! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 01:31'!testSubtractiveConflictlessMerge	self assertMerge: #(a1 b1)				with: #()				base: #(a1)								gives: #(b1)				conflicts: #()! !!ObjectFinalizerTests methodsFor: 'running' stamp: 'apb 9/14/2005 08:39'!setUp	super setUp.	log := OrderedCollection new.! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:26'!text	^ self unusedVariableSource! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 p i |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)]! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:46'!testSimpleEnsureTestWithNotification	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithNotification ) ! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 20:10'!methodWithCopiedTemps	| a b c r |	a := 1.	b := 2.	c := 4.	r := [a + b + c] value.	b := nil.	r	"Parser new		parse: (self class sourceCodeAt: #methodWithCopiedTemps)		class: self class"	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!MCMockClassA methodsFor: 'numeric' stamp: ''!b	^ 'b1'! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testSnapshotAndLoad	| base inst |	inst := self mockInstanceA.	base :=  self snapshot.	self change: #one toReturn: 2.	self assert: inst one = 2.	self load: base.	self assert: inst one = 1.! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/12/1999 23:54'!runBasicANSISignaledExceptionTests	self basicANSISignaledExceptionTestSelectors		do:			[:eachTestSelector |			self runTest: eachTestSelector]! !!MCRepositoryTest methodsFor: 'asserting' stamp: 'ab 7/19/2003 23:59'!assertMissing: aVersionInfo	self assert: (repository versionWithInfo: aVersionInfo) isNil! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 00:28'!testAdditiveConflictlessMerge	self		assertMerge: #(a1 b1)				with: #(a1 c1)				base: #(a1)							gives: #(a1 b1 c1)				conflicts: #()! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!token	^ token! !!MCRepositoryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testLoadMissingNode	| node |	node := MCVersionInfo new.	self assertMissing: node! !!MCMockDependency class methodsFor: 'instance creation' stamp: 'cwp 11/7/2004 14:43'!fromTree: anArray 	^ self new initializeWithTree: anArray! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!directory	directory ifNil:		[directory := FileDirectory default directoryNamed: 'mctest'.		directory assureExistence].	^ directory! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesDNtoDZ	self decompileClassesSelect: [:cn| cn first = $D and: [cn second asUppercase > $M]]! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'JWS 9/7/2000 17:20'!testTwoArgumentEvent	eventSource when: #anEvent:info: send: #addArg1:addArg2: to: self.	eventSource triggerEvent: #anEvent:info: withArguments: #( 9 42 ).	self should: [(eventListener includes: 9) and: [eventListener includes: 42]]! !!MCSnapshotBrowserTest methodsFor: 'simulating' stamp: 'stephaneducasse 2/4/2006 20:47'!clickOnListItem: aString	| listMorph |	listMorph := self findListContaining: aString.	listMorph changeModelSelection: (listMorph getList indexOf: aString).! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:12'!testSimpleUnresolved	self assertItems: #(		(a () (z)))	orderAs: #()	withRequired: #(z)	toLoad: #(a)		! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:24'!methodWithOptimizedBlocksA	| s c |	s := self isNil			ifTrue: [| a | a := 'isNil'. a]			ifFalse: [| a | a := 'notNil'. a].	c := String new: s size.	1 to: s size do:		[:i| c at: i put: (s at: i)].	^c	"Parser new		parse: (self class sourceCodeAt: #methodWithOptimizedBlocksA)		class: self class"! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'bf 5/20/2005 17:18'!includesSystemCategory: categoryName	^self systemCategories anySatisfy: [:cat | cat sameAs: categoryName]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 19:44'!supportTestSourceRangeAccessForDecompiledNoBytecodeInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	'at: 1 put: t1'								'do: [:t4 | t3 at: 1 put: (t2 value: (t3 at: 1) value: t4)]'								'value: (t3 at: 1) value: t4'								'at: 1 put: (t2 value: (t3 at: 1) value: t4)'								']'								'value: (t3 at: 1) value: t4'								'at: 1 put: (t2 value: (t3 at: 1) value: t4)'								']'								'^t3 at: 1')! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 11/6/2004 16:03'!mockVersionWithAncestor: aMCVersion 	^ MCVersion		package: self mockPackage		info: (self mockVersionInfoWithAncestor: aMCVersion info)		snapshot: self mockSnapshot! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!one	^ 1! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'avi 2/13/2004 14:30'!basicMerge: aVersion	aVersion merge! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 18:15'!fileName	^ 'InstallerTest.mcz'! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/9/1999 16:07'!resumableFallOffTheEndHandler	[self doSomething.	MyTestNotification signal.	self doSomethingElse]		on: MyTestNotification		do: [:ex | self doSomethingExceptional].	self doYetAnotherThing! !!ScannerTest methodsFor: 'testing' stamp: 'nice 10/10/2008 20:42'!testLiteralSymbols	self assert: ('*+-/\~=<>&@%,|' allSatisfy: [:char | Scanner isLiteralSymbol: (Symbol with: char)])		description: 'single letter binary symbols can be printed without string quotes'.			self assert: (#('x' 'x:' 'x:y:' 'from:to:by:' 'yourself') allSatisfy: [:str | Scanner isLiteralSymbol: str asSymbol])		description: 'valid ascii selector symbols can be printed without string quotes'.			((32 to: 126) collect: [:ascii | Character value: ascii]) ,	#(':x:yourself' '::' 'x:yourself' '123' 'x0:1:2:' 'x.y.z' '1abc' 'a1b0c2' ' x' 'x ' '+x-y' '||' '--' '++' '+-' '+/-' '-/+' '<|>' '#x' '()' '[]' '{}' '')		do: [:str |			self assert: (Compiler evaluate: str asSymbol printString) = str asSymbol				description: 'in all case, a Symbol must be printed in an interpretable fashion']! !!DecompilerTests methodsFor: 'utilities' stamp: 'sd 9/25/2004 15:30'!blockingClasses	^ #(CompiledMethod)! !!MCVersionTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	visited := OrderedCollection new.! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesSNtoSZ	self decompileClassesSelect: [:cn| cn first = $S and: [cn second asUppercase > $M]]! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 9/14/2003 19:39'!testClassDefinitionB	writer visitClassDefinition: (self mockClassB asClassDefinition).	self assertContentsOf: stream match: self expectedClassDefinitionB.	! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:44'!myAssuredDirectory	^self myDirectory assureExistence! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'm 7/28/2003 19:10'!testSchedulerTermination   | process sema gotHere sema2 |   gotHere := false.   sema := Semaphore new.   sema2 := Semaphore new.   process := [       sema signal.       sema2 wait.       "will be suspended here"       gotHere := true. "e.g., we must *never* get here"   ] forkAt: Processor activeProcess priority.   sema wait. "until process gets scheduled"   process terminate.   sema2 signal.   Processor yield. "will give process a chance to continue andhorribly screw up"   self assert: gotHere not.! !!MCRepositoryTest methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!saveSnapshot: aSnapshot named: aString	| version |	version := self versionWithSnapshot: aSnapshot name: aString.	repository storeVersion: version.	^ version info	! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	repository := MCDirectoryRepository new directory: self directory! !!MCPatchTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/2/2003 17:24'!tearDown	self restoreMocks! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 09:44'!simpleEnsureTest	[self doSomething.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!MCAncestryTest methodsFor: 'asserting' stamp: 'jf 8/16/2003 23:42'!assertPathTo: aSymbol is: anArray	self		assertNamesOf: (self tree allAncestorsOnPathTo: (self treeFrom: {aSymbol}))		are: anArray! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesLAtoLM	self decompileClassesSelect: [:cn| cn first = $L and: [cn second asUppercase <= $M]]! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/16/2003 23:35'!commentWithStyle	^ '!!AEDesc commentStamp: ''<historical>'' prior: 0!!I represent an Apple Event Descriptor.  I am a low-level representation of Apple Event (and hence Applescript) information.  For further Information, see Apple''s Inside Macintosh: Interapplication Communications, at	http://developer.apple.com/techpubs/mac/IAC/IAC-2.html.Essentially, I represent a record comprising a one-word "string" (treating the word as fourbyte characters) representing a data type, followed by a pointer to a pointer (a handle) to the data I represent.  Care must be taken to assure that the Handle data is disposed after use, or memory leaks result.  At this time, I make no effort to do this automatically through finalization.!!]style[(218 54 384)f1,f1Rhttp://developer.apple.com/techpubs/mac/IAC/IAC-2.html;,f1!!'! !!MCDirtyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCDirtyPackage'! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:28'!testFileDirectoryEntryFor	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory root directoryEntryFor: 'C:'.	self assert: (fd name sameAs: 'C:').! !!MCAncestryTest methodsFor: 'asserting' stamp: 'avi 9/17/2005 21:09'!assertCommonAncestorOf: leftName and: rightName is: ancestorName in: tree	self assertCommonAncestorOf: leftName and: rightName in: (Array with: ancestorName) in: tree! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithManyListeners	| value newListener |	newListener := 'busybody'.	eventSource		when: #needsValue		send: #yourself		to: eventListener.	eventSource		when: #needsValue		send: #yourself		to: newListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == newListener]! !!MCInitializationTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/11/2003 23:06'!tearDown	(MCWorkingCopy forPackage: self mockPackage) unregister! !!MCChangeNotificationTest methodsFor: 'running' stamp: 'bf 5/20/2005 17:02'!tearDown	workingCopy unregister! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/22/2004 14:08'!mockEmptyPackage	^ MCPackage named: (MCEmptyPackageInfo new packageName)! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 20:37'!testNextLine	| filename lines text |	filename := 'filestream.tst'.	lines := #('line 1' ' and line 2' '' 'fourth').	text := lines first , String cr , lines second , String crlf , lines third , String lf , lines fourth.		[ | file |	(StandardFileStream forceNewFileNamed: filename)		nextPutAll: text;		close.			file := StandardFileStream readOnlyFileNamed: filename.	lines do: [:e |		self assert: file nextLine = e].	self assert: file nextLine = nil.	file close]		ensure: [FileDirectory default deleteFileNamed: filename ifAbsent: [] ]! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:45'!testSimpleEnsureTestWithError	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithError ) ! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:04'!testFileDirectoryLocalName	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: fd localName = 'C:'.! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'ar 7/27/2003 19:49'!testUnwindFromForeignProcess	| sema process |	sema := Semaphore forMutualExclusion.	self assert: sema isSignaled.	process := [		sema critical:[			self deny: sema isSignaled.			sema wait. "deadlock"		]	] forkAt: Processor userInterruptPriority.	self deny: sema isSignaled.	"This is for illustration only - the BlockCannotReturn cannot 	be handled here (it's truncated already)"	self shouldnt: [process terminate] raise: BlockCannotReturn.	self assert: sema isSignaled.	! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:52'!testWhileWithTemp	| index |	index := 0.	[ index < 5 ] whileTrue: [		| temp |		temp := index := index + 1.		collection add: [ temp ] ].	self assertValues: #(1 2 3 4 5)! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 02:12'!simpleResignalAsTest	"ExceptionTester new simpleResignalAsTest"	[self doSomething.	MyTestNotification signal.	self doSomethingElse]		on: MyTestNotification		do:			[:ex | ex resignalAs: MyTestError new]! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:15'!testString	^'This is only a test.'! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoInsideTempNotInlined	| block |	block := [ :index | 		| temp | 		temp := index. 		collection add: [ temp ] ].	1 to: 5 do: block.	self assertValues: #(1 2 3 4 5)! !!MCOrganizationTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testReordering	|dec cats newCats |	dec := MCOrganizationDefinition categories: #(A B C).	cats := #(X Y B Z C A Q).	newCats := dec reorderCategories: cats original: #(B C A).	self assert: newCats asArray = #(X Y A B C Z Q).! !!MCChangeNotificationTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	workingCopy := MCWorkingCopy forPackage: self mockPackage.	! !!MCEmptyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCEmptyPackage'! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 11/10/2008 15:47'!failures	^failures! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!snapshot	| version |	[version := workingCopy newVersion]		on: MCVersionNameAndMessageRequest		do: [:n | n resume: (Array with: n suggestedName with: '')].	versions at: version info put: version.	^ version! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testEmptyLcs1	| patch |	patch := self patchSequenceFor: #(a b c) and: #().	self assert: patch size = 3.	self assert: (patch allSatisfy: [ :each | each key = #remove ])! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 8/19/1999 01:51'!signalFromHandlerActionTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: 'Unhandled Exception';		yourself! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testLoadAndUnload	|definition|	definition := self mockMethod: #one class: 'MCMockClassA' source: 'one ^2' meta: false.	self assert: self mockInstanceA one = 1.	definition load.	self assert: self mockInstanceA one = 2.	definition unload.	self deny: (self mockInstanceA respondsTo: #one)! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:23'!simpleRetryUsingTestResults	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			yourself! !!MCWorkingCopyTest methodsFor: 'accessing' stamp: 'ab 7/7/2003 18:02'!description	^ self class name! !!MCAncestryTest methodsFor: 'tests' stamp: 'jf 8/16/2003 20:45'!testLinearPath	self assertPathTo: #b1 is: #(b3 b2)! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample1	"This is the first example from the specification document (FIPS PUB 180-1)"	hash := SecureHashAlgorithm new hashMessage: 'abc'.	self assert: (hash = 16rA9993E364706816ABA3E25717850C26C9CD0D89D).		! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:17'!testIsDriveForShare	self assert: (DosFileDirectory isDrive: '\\server').	self deny: (DosFileDirectory isDrive: '\\server\').	self deny: (DosFileDirectory isDrive: '\\server\foo').! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 9/14/2003 19:39'!mockClassB	^ Smalltalk at: #MCMockClassB! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/22/2009 16:55'!testInlineBlockCollectionSD1	| a1 b1 a2 b2 |	b1 := OrderedCollection new.	1 to: 3 do:		[:i |		a1 := i.		b1 add: [a1]].	b1 := b1 asArray collect: [:b | b value].	b2 := OrderedCollection new.	1 to: 3 do:		[:i |		a2 := i.		b2 add: [a2]] yourself. "defeat optimization"	b2 := b2 asArray collect: [:b | b value].	self assert: b1 = b2! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/8/2009 09:52'!testMirrorAt	| stackpBefore stackpAfter array byteArray |	stackpBefore := thisContext stackPtr.	array := { 1. 2. 3 }.	byteArray := ByteArray with: 1 with: 2 with: 3.	self assert: (thisContext object: array basicAt: 1) = 1.	self assert: (thisContext object: byteArray basicAt: 2) = 2.	thisContext object: array basicAt: 2 put: #two.	self assert: array = #(1 #two 3).	thisContext object: byteArray basicAt: 2 put: 222.	self assert: byteArray asArray = #(1 222 3).	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"	self should: [thisContext object: array basicAt: 4] raise: Error.	self should: [thisContext object: byteArray basicAt: 0] raise: Error.	self should: [thisContext object: byteArray basicAt: 1 put: -1] raise: Error! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:50'!testAllMissing	self 		assert: #allDependenciesDo: 		orders: #(a ((b (d e)) (c missing))) 		as: #(d e b)! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:15'!doYetAnotherThingString	^'Do yet another thing.'! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesINtoIZ	self decompileClassesSelect: [:cn| cn first = $I and: [cn second asUppercase > $M]]! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/12/2009 21:17'!testMirrorPerform	| stackpBefore stackpAfter anInterval |	stackpBefore := thisContext stackPtr.	anInterval := 1 to: 2.	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval) == Array.	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval superclass) == Interval.	self should: [thisContext object: anInterval perform:# species withArguments: #() inClass: Point]		raise: Error.	self should: [thisContext object: anInterval perform:# species withArguments: OrderedCollection new inClass: Interval]		raise: Error.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!MCMergingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMultiPackageMerge	| merger |	conflicts := #().	merger := MCThreeWayMerger new.	merger addBaseSnapshot: (self snapshotWithElements: #(a1 b1)).	merger applyPatch: ((self snapshotWithElements: #()) patchRelativeToBase: (self snapshotWithElements: #(a1))).	merger applyPatch: ((self snapshotWithElements: #(a2 b1)) patchRelativeToBase: (self snapshotWithElements: #(b1))).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: #(a2 b1).	self assert: conflicts isEmpty! !!MCMockDependency methodsFor: 'accessing' stamp: 'cwp 11/7/2004 14:38'!name	^ name! !!MCStWriterTest methodsFor: 'asserting' stamp: 'cwp 8/2/2003 12:13'!assertAllChunksAreWellFormed	stream reset.	stream 		untilEnd: [self assertChunkIsWellFormed: stream nextChunk]		displayingProgress: 'Checking syntax...'! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 09:14'!testThreeButtons	self assertButtonExists: 'instance'.	self assertButtonExists: '?'.	self assertButtonExists: 'class'.! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:25'!testUnknownSelector	self 		should: 			[self class 				compile: 'griffle self reallyHopeThisIsntImplementedAnywhere'				notifying: self]		raise: UnknownSelector! !!MCSnapshotBrowserTest methodsFor: 'selecting' stamp: 'cwp 7/13/2003 13:04'!selectMockClassA	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/7/1999 14:28'!warningTest	self log: 'About to signal warning.'.	Warning signal: 'Ouch'.	self log: 'Warning signal handled and resumed.'! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesBAtoBM	self decompileClassesSelect: [:cn| cn first = $B and: [cn second asUppercase <= $M]]! !!MCStWriterTest methodsFor: 'testing' stamp: 'ar 1/4/2010 18:03'!methodWithBangs	^ '	^ ReadStream on: ''MCRevisionInfo packageName: ''MonticelloCompatibilityTest''!!!!MCOrganizationDeclaration categories:   #(  ''Tests-Monticello-Mocks'')!!!!MCClassDeclaration  name: #MCMockClassD  superclassName: #Object  category: #''Tests-Monticello-Mocks''  instVarNames: #()  comment: ''''!!!!MCMethodDeclaration className: #MCMockClassD selector: #one category: #''as yet unclassified'' timeStamp: ''cwp 7/8/2003 21:21'' source: ''one	^ 1''!!!!'''! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'tpr 8/15/2003 16:30'!testExists	self should: [FileDirectory default exists]		description: 'Should know default directory exists.'.	self should: [self myAssuredDirectory exists]		description: 'Should know created directory exists.'.	self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: [(self myDirectory containingDirectory directoryNamed: self myLocalDirectoryName) exists]		description: 'Should know that recently deleted directory no longer exists.'.! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:16'!methodWithNotification	MyTestNotification signal: self testString! !!MCPackageTest methodsFor: 'running' stamp: 'cwp 8/9/2003 23:43'!tearDown	self mockSnapshot install! !!MCMock class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:40'!wantsChangeSetLogging	^ false! !!MCInitializationTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/13/2003 12:11'!isAbstract	^ (Smalltalk hasClassNamed: #MczInstaller) not		! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testLoadAndUnload	| d c |	d :=  self mockClass: 'MCMockClassC' super: 'Object'.	d load.	self assert: (Smalltalk hasClassNamed: 'MCMockClassC').	c := (Smalltalk classNamed: 'MCMockClassC').	self assert: (c isKindOf: Class).	self assert: c superclass = Object.	self assert: c instVarNames isEmpty.	self assert: c classVarNames isEmpty.	self assert: c sharedPools isEmpty.	self assert: c category = self mockCategoryName.	self assert: c organization classComment = (self commentForClass: 'MCMockClassC').	self assert: c organization commentStamp = (self commentStampForClass: 'MCMockClassC').	d unload.	self deny: (Smalltalk hasClassNamed: 'MCMockClassC').! !!MCSortingTest methodsFor: 'building' stamp: 'ab 7/19/2003 17:56'!sortKeyFor: aDefinition	^ String streamContents:		[:s |		aDefinition description			do: [:ea | s nextPutAll: ea asString]			separatedBy: [s nextPut: $.]]! !!MCMethodDefinitionTest methodsFor: 'running' stamp: 'cwp 11/13/2003 14:15'!ownPackage	^ MCWorkingCopy forPackage: (MCPackage named: 'Monticello')! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/14/2009 00:10'!testFilePositionFromSourcePointer	"Test derivation of file position for sources or changes file from source pointers"	| sf |	sf := StandardSourceFileArray new.	"sources file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r1000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r1000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r1FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r3000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r3000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r3FFFFFF).	"changes file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r2000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r2000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r2FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r4000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r4000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r4FFFFFF).	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf filePositionFromSourcePointer: 16r0000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r0000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r0FFFFFF)! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:12'!classes	^ self classNames 		select: [:name | Smalltalk hasClassNamed: name]		thenCollect: [:name | Smalltalk at: name]! !!MCAncestryTest methodsFor: 'building' stamp: 'jf 8/16/2003 22:55'!twoPersonTree	^ self treeFrom:		#(c1			((a4				((a1)				(b3					((b2						((a1)))))))			(b5				((b2					((a1)))))))! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesQAtoQM	self decompileClassesSelect: [:cn| cn first = $Q and: [cn second asUppercase <= $M]]! !!MCVersionTest methodsFor: 'building' stamp: 'cwp 11/7/2004 12:29'!dependencyFromTree: sexpr	^ MCMockDependency fromTree: sexpr! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/9/1999 16:04'!simpleEnsureTestWithUparrow	[self doSomething.	true ifTrue: [^nil].	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/7/1999 15:16'!contents	^( self log		inject: (WriteStream on: (String new: 80))		into: 			[:result :item |			result 				cr; 				nextPutAll: item;				yourself] ) contents! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:36'!testMethodArgument	| temp block |	temp := 0.	block := [ [ temp ] ].	temp := 1.	block := block value.	temp := 2.	self assert: block value = 2! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:23'!test4	self assertScans: #(a '23' (x () ')''q' y12)).! !!MCSerializationTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testMcdSerialization	| stream expected actual |	expected := self mockDiffyVersion.	stream := RWBinaryOrTextStream on: String new.	MCMcdWriter fileOut: expected on: stream.	actual := MCMcdReader versionFromStream: stream reset.	self assertVersion: actual matches: expected.! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCommentWithoutStyle	| reader |	reader := MCStReader on: self commentWithoutStyle readStream.	self assert: (reader definitions anySatisfy: [:ea | ea isMethodDefinition]).! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:12'!testIfSequence1	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d c b a).	self assert: patch size = 7.	"lcs is any one letter sequence"	self assert: (patch count: [ :each | each key = #match ]) = 1.	self assert: (patch count: [ :each | each key = #insert ]) = 3.	self assert: (patch count: [ :each | each key = #remove ]) = 3.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $d ]			ifFalse: [ self assert: ('abc' includes: each value first) ] ]! !!ExceptionTests methodsFor: 'testing' stamp: 'brp 10/21/2004 16:42'!testNoTimeout	self assertSuccess: (ExceptionTester new runTest: #simpleNoTimeoutTest ) ! !!MCDirtyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 14:04'!initialize	[self new register] on: MessageNotUnderstood do: []! !!MCClassDefinitionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 17:59'!classACommentStamp	^  'cwp 8/10/2003 16:43'! !!MCStWriterTest methodsFor: 'testing' stamp: 'ab 8/8/2003 17:01'!expectedInitializerA	^ 'MCMockClassA initialize'! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'avi 2/10/2004 12:30'!tearDown	workingCopy unregister.	self restoreMocks.	self clearPackageCache.	Utilities setAuthorInitials: savedInitials.! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'JWS 9/7/2000 17:20'!testOneArgumentEvent	eventSource when: #anEvent: send: #add: to: eventListener.	eventSource triggerEvent: #anEvent: with: 9.	self should: [eventListener includes: 9]! !!MCRepositoryTest methodsFor: 'actions' stamp: 'ab 7/19/2003 16:20'!saveSnapshot2	^ self saveSnapshot: self snapshot2 named: 'rev2'! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 19:36'!tearDown	expected snapshot updatePackage: self mockPackage.	self deleteFile.! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesGNtoGZ	self decompileClassesSelect: [:cn| cn first = $G and: [cn second asUppercase > $M]]! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 8/19/1999 02:39'!resumableFallOffTheEndHandlerResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingExceptionalString;		add: self doYetAnotherThingString;		yourself! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testEqualsSensitivity	| message a b defA args defB |	message := self creationMessage.	a := #(ClassA SuperA CategoryA #(iVarA) #(CVarA) #(PoolA) #(ciVarA)			typeA 'A comment' 'A').	b := #(ClassB SuperB CategoryB #(iVarB) #(CVarB) #(PoolB) #(ciVarB)			typeB 'B comment' 'B').		defA := message valueWithArguments: a.	1 to: 8 do: [:index |				args := a copy.				args at: index put: (b at: index).				defB := message valueWithArguments: args.				self deny: defA = defB.]! !!DecompilerTests methodsFor: 'utilities' stamp: 'Igor.Stasenko 12/20/2009 03:55'!checkDecompileMethod: oldMethod		| cls selector oldMethodNode methodNode newMethod oldCodeString newCodeString |	cls := oldMethod methodClass.	selector := oldMethod selector.	oldMethodNode := cls decompilerClass new						decompile: selector						in: cls						method: oldMethod.	[oldMethodNode properties includesKey: #warning] whileTrue:		[oldMethodNode properties removeKey: #warning].	oldCodeString := oldMethodNode decompileString.	methodNode := [cls compilerClass new						compile: oldCodeString						in: cls						notifying: nil						ifFail: []]						on: SyntaxErrorNotification						do: [:ex|							ex errorMessage = 'Cannot store into' ifTrue:								[ex return: #badStore].							ex pass].	"Ignore cannot store into block arg errors; they're not our issue."	methodNode ~~ #badStore ifTrue:		[newMethod := methodNode generate.		 newCodeString := (cls decompilerClass new							decompile: selector							in: cls							method: newMethod) decompileString.		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldCodeString to: newCodeString))				openLabel: 'Decompilation Differences for ', cls name,'>>',selector"		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldMethod abstractSymbolic to: newMethod abstractSymbolic))				openLabel: 'Bytecode Differences for ', cls name,'>>',selector"		 self assert: oldCodeString = newCodeString			description: cls name asString, ' ', selector asString			resumable: true]! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 11/14/1999 17:26'!doubleResumeTest       [self doSomething.       MyResumableTestError signal.       self doSomethingElse.       MyResumableTestError signal.       self doYetAnotherThing]               on: MyResumableTestError               do: [:ex | ex resume].! !!ArrayLiteralTest methodsFor: 'initialize-release' stamp: 'avi 2/16/2004 21:09'!tearDown	self class removeSelector: #array! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testMethodWithStyle	| reader |	reader := MCStReader on: self methodWithStyle readStream.	self assert: reader definitions first isMethodDefinition.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'Igor.Stasenko 12/20/2009 03:58'!testBlockNumberingForInjectInto	"Test that the compiler and CompiledMethod agree on the block numbering of Collection>>inject:into:	 and that temp names for inject:into: are recorded."	"self new testBlockNumberingForInjectInto"	| methodNode method tempRefs |	methodNode := Parser new						encoderClass: EncoderForV3PlusClosures;						parse: (Collection sourceCodeAt: #inject:into:)						class: Collection.	method := methodNode generate.	tempRefs := methodNode encoder blockExtentsToTempsMap.	self assert: tempRefs keys asSet = method startpcsToBlockExtents values asSet.	self assert: ((tempRefs includesKey: (0 to: 6))				and: [(tempRefs at: (0 to: 6)) hasEqualElements: #(('thisValue' 1) ('binaryBlock' 2) ('nextValue' (3 1)))]).	self assert: ((tempRefs includesKey: (2 to: 4))				and: [(tempRefs at: (2 to: 4)) hasEqualElements: #(('each' 1) ('binaryBlock' 2) ('nextValue' (3 1)))])! !!MCRepositoryTest methodsFor: 'tests' stamp: 'avi 2/17/2004 03:24'!testIncludesName	self deny: (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev1').	self saveSnapshot1.	self assert: (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev1').	self deny: (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev2').	self saveSnapshot2.	self assert:  (repository includesVersionNamed: 'MonticelloTest-xxx.1-rev2').! !!MCSnapshotResource methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 14:51'!snapshot	^ snapshot! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!clearPackageCache	| dir |	dir := MCCacheRepository default directory.	(dir fileNamesMatching: 'MonticelloMocks*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'MonticelloTest*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'rev*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'foo-*') do: [:ea | dir deleteFileNamed: ea].	(dir fileNamesMatching: 'foo2-*') do: [:ea | dir deleteFileNamed: ea].! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	expected := self mockVersion.	self change: #one toReturn: 2.! !!ClosureTests methodsFor: 'utilities' stamp: 'cwp 11/16/2009 08:12'!methodWithNonLocalReturn	self evaluateCopyOf: [^ self].	self signalFailure: 'Should never reach here'! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesVNtoVZ	self decompileClassesSelect: [:cn| cn first = $V and: [cn second asUppercase > $M]]! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 16:53'!commentStampForClass: name	^ 'tester-', name,  ' 1/1/2000 00:00'! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	repository :=  MCDictionaryRepository new dictionary: self dictionary! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationAfter	| index |	index := 0.	[ index < 5 ] whileTrue: [		collection add: [ index ].		index := index + 1 ].	self assertValues: #(5 5 5 5 5)! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testBackport	| inst base final backported |	inst := self mockInstanceA.	base :=  self snapshot.	self assert: inst one = 1.	self change: #one toReturn: 2.	self change: #two toReturn: 3.	final := self snapshot.	[workingCopy backportChangesTo: base info]		on: MCChangeSelectionRequest		do: [:e | e resume: e patch].	self assert: inst one = 2.	self assert: inst two = 3.	self assert: workingCopy ancestry ancestors size = 1.	self assert: workingCopy ancestry ancestors first = base info.	self assert: workingCopy ancestry stepChildren size = 1.	self assert: workingCopy ancestry stepChildren first = final info.	backported := self snapshot.	[workingCopy backportChangesTo: base info]		on: MCChangeSelectionRequest		do: [:e | e resume: e patch].	self assert: workingCopy ancestry ancestors size = 1.	self assert: workingCopy ancestry ancestors first = base info.	self assert: workingCopy ancestry stepChildren size = 1.	self assert: workingCopy ancestry stepChildren first = backported info.	! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:13'!doSomething	self log: self doSomethingString! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:24'!testUndefinedVariable	self 		should: 			[self class 				compile: 'griffle | goo | ^ goo'				notifying: self]		raise: UndefinedVariable! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 01:19'!assertAListIncludes: anArrayOfStrings	self listMorphs 			detect: [:m | m getList includesAllOf: anArrayOfStrings]			ifNone: [self assert: false].! !!MCChangeNotificationTest methodsFor: 'tests' stamp: 'bf 5/20/2005 19:54'!testCoreMethodModified	| event |	workingCopy modified: false.	event := self modifiedEventFor: #one ofClass: self mockClassA.	MCWorkingCopy methodModified: event.	self assert: workingCopy modified! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'CdG 10/19/2005 22:41'!testOldFileOrNoneNamed	| file |	file := self myAssuredDirectory oldFileOrNoneNamed: 'test.txt'.	[self assert: file isNil.		"Reproduction of Mantis #1049"	(self myAssuredDirectory fileNamed: 'test.txt')		nextPutAll: 'foo';		close.			file := self myAssuredDirectory oldFileOrNoneNamed: 'test.txt'.	self assert: file notNil]		ensure: [			file ifNotNil: [file close].			self myAssuredDirectory deleteFileNamed: 'test.txt' ifAbsent: nil]	! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesOAtoOM	self decompileClassesSelect: [:cn| cn first = $O and: [cn second asUppercase <= $M]]! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:53'!testAllAvailablePostOrder	self 		assert: #allAvailableDependenciesDo: 		orders: #(a ((b (d e)) c)) 		as: #(d e b c)! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:27'!simpleIsNestedTest	"uses resignalAs:"	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex |			ex isNested "expecting to detect handler in #runTest:"				ifTrue:					[self doYetAnotherThing.					ex resignalAs: MyTestNotification new]]! !!MCChangeNotificationTest methodsFor: 'events' stamp: 'cwp 11/6/2004 22:32'!modifiedEventFor: aSelector ofClass: aClass	| method |	method := aClass compiledMethodAt: aSelector.	^ ModifiedEvent 				methodChangedFrom: method				to: method				selector: aSelector				inClass: aClass.! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!summary	^ token! !!SmalltalkImageTest methodsFor: 'testing' stamp: 'nice 5/11/2009 23:47'!testImageName	"Non regression test for http://bugs.squeak.org/view.php?id=7351"	| shortImgName fullImgName fullChgName |	shortImgName := 'Squeak3.10.2-7179-basic'.	fullImgName := SmalltalkImage current fullNameForImageNamed: shortImgName.	fullChgName := SmalltalkImage current fullNameForChangesNamed: shortImgName.	FileDirectory splitName: fullImgName to: [:path :name |		self assert: path = SmalltalkImage current imagePath.		self assert: name = 'Squeak3.10.2-7179-basic.image'.].	FileDirectory splitName: fullChgName to: [:path :name |		self assert: path = SmalltalkImage current imagePath.		self assert: name = 'Squeak3.10.2-7179-basic.changes'.].! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:21'!testMultipleValueSuppliersEventHasArguments	eventSource		when: #needsValue:		send: #getFalse:		to: self.	eventSource		when: #needsValue:		send: #getTrue:		to: self.	succeeded := eventSource triggerEvent: #needsValue: with: 'kolme'.	self should: [succeeded]! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/8/2009 09:54'!testMirrorEqEq	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext object: Array new eqeq: Array new) == false.	self assert: (thisContext object: Array eqeq: Array) == true.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:23'!simpleRetryTestResults	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			add: self doSomethingString;			add: self doSomethingElseString;			yourself! !!EventManagerTest methodsFor: 'private' stamp: 'jws 9/7/2000 16:37'!addArg1: arg1addArg2: arg2	eventListener		add: arg1;		add: arg2! !!MCWorkingCopyTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNumberWhenSavingTo: aRepository is: aNumber	| name |	name := nil.	[aRepository storeVersion: workingCopy newVersion]		on: MCVersionNameAndMessageRequest		do: [:n | name := n suggestedName. n resume: (Array with: name with: '')].	self assert: name = (self packageName, '-', Utilities authorInitials, '.', aNumber asString)! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCommentWithStyle	| reader |	reader := MCStReader on: self commentWithStyle readStream.	reader definitions! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 22:45'!testMirrorInstVarAt	| stackpBefore stackpAfter array point |	stackpBefore := thisContext stackPtr.	array := { 1. 2. 3 }.	point := Point x: 1 y: 2.	self assert: (thisContext object: array instVarAt: 1) = 1.	self assert: (thisContext object: point instVarAt: 2) = 2.	thisContext object: array instVarAt: 2 put: #two.	self assert: array = #(1 #two 3).	thisContext object: point instVarAt: 1 put: 1/2.	self assert: point = (Point x: 1 / 2 y: 2).	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"	self should: [thisContext object: array instVarAt: 4] raise: Error.	self should: [thisContext object: point instVarAt: 3] raise: Error! !!MethodHighlightingTests methodsFor: 'tests' stamp: 'eem 9/5/2009 10:58'!testMethodHighlighting	| map before after method retpc |	"Test the highlighting of the asXML method.  Test the highlighting of the return	 statement which should include the whole block supplied to streamContents:."	"DebuggerMethodMap voidMapCache"	"DebuggerMethodMap forMethod: MethodHighlightingTests >> #asXML"	method := MethodHighlightingTests >> #asXML.	map := DebuggerMethodMap forMethod: method.	retpc := method endPC.	before := map rangeForPC: retpc contextIsActiveContext: false.	map instVarNamed: 'abstractSourceRanges' put: nil.	after := map rangeForPC: retpc contextIsActiveContext: false.	self assert: before size > 500.	self assert: before = after! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/22/2004 13:56'!mockExtensionMethodCategory	^ MCMockPackageInfo new methodCategoryPrefix.! !!MCMczInstallerTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/13/2003 12:11'!isAbstract	^ (Smalltalk hasClassNamed: #MczInstaller) not		! !!MCMockDependency methodsFor: 'comparing' stamp: 'cwp 11/7/2004 13:33'!hash	^ self name hash! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:15'!doYetAnotherThing	self log: self doYetAnotherThingString! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 12:52'!testComment	self clickOnButton: '?'.	self assertTextIs: ''.		self clickOnListItem: self mockCategoryName.	self assertTextIs: ''.		self clickOnListItem: 'MCMockClassA'.	self assertTextIs: self classAComment.! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:02'!simpleRetryTest	| theMeaningOfLife |	theMeaningOfLife := nil.	[self doSomething.	theMeaningOfLife == nil		ifTrue: [MyTestError signal]		ifFalse: [self doSomethingElse]]			on: MyTestError			do:				[:ex |				theMeaningOfLife := 42.				self doYetAnotherThing.				ex retry]! !!MCAncestryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testDescendants	| c1 a1 b3 q1 q2 c2 |	c1 := self tree.	a1 := self treeFrom: #(a1 (('00'))).	b3 := self treeFrom: #(b3				((b2					((b1						((b0							(('00')))))))				(a1					(('00'))))).	q1 := MCWorkingAncestry new addAncestor: a1.	q2 := MCWorkingAncestry new addAncestor: q1.	self assert: (q2 commonAncestorWith: b3) = a1.	self assert: (b3 commonAncestorWith: q2) = a1.	self assert: (q2 commonAncestorWith: c1) = a1.	self assert: (c1 commonAncestorWith: q2) = a1.	q1 addStepChild: c1.	self assert: (q2 commonAncestorWith: c1) = q1.	self assert: (c1 commonAncestorWith: q2) = q1.	c2 := MCWorkingAncestry new addAncestor: c1.	self assert: (q2 commonAncestorWith: c2) = q1.	self assert: (c2 commonAncestorWith: q2) = q1.! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/12/1999 23:07'!logTest: aSelector	self suiteLog add: aSelector! !!MCStWriterTest methodsFor: 'data' stamp: 'cwp 8/2/2003 17:27'!expectedMethodDefinition	^ '!!MCMockClassA methodsFor: ''numeric'' stamp: ''cwp 8/2/2003 17:26''!!one	^ 1!! !!'! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!description	^ token first! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:16'!methodWithError	MyTestError signal: self testString! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testComparison	|d1 d2 d3 d4 d5 |	d1 := self mockMethod: #one class: 'A' source: '1' meta: false.	d2 := self mockMethod: #one class: 'A' source: '2' meta: false.	d3 := self mockMethod: #one class: 'A' source: '1' meta: true.	d4 := self mockMethod: #two class: 'A' source: '1' meta: false.	d5 := self mockMethod: #two class: 'A' source: '1' meta: false.		self assert: (d1 isRevisionOf: d2).	self deny: (d1 isSameRevisionAs: d2).		self deny: (d1 isRevisionOf: d3).	self deny: (d1 isRevisionOf: d4).		self assert: (d4 isSameRevisionAs: d5).! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testCannotLoad	| definition |	definition := self mockMethod: #kjahs87 class: 'NoSuchClass' source: 'kjahs87 ^self' meta: false.	self should: [definition load] raise: Error.	self assert: (navigation allImplementorsOf: #kjahs87) isEmpty! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForClosureBytecodeInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForClosureBytecodeInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForV3PlusClosures;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesTNtoTZ	self decompileClassesSelect: [:cn| cn first = $T and: [cn second asUppercase > $M]]! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!testSelectiveBackport	| inst base intermediate final |	inst := self mockInstanceA.	base :=  self snapshot.	self assert: inst one = 1.	self change: #one toReturn: 2.	intermediate := self snapshot.	self change: #two toReturn: 3.	final := self snapshot.	[workingCopy backportChangesTo: base info]		on: MCChangeSelectionRequest		do: [:e | | selected patch |			patch := e patch.			selected := patch operations select: [:ea | ea definition selector = #two].			e resume: (MCPatch operations: selected)]. 	self assert: inst one = 1.	self assert: inst two = 3.	self assert: workingCopy ancestry ancestors size = 1.	self assert: workingCopy ancestry ancestors first = base info.	self assert: workingCopy ancestry stepChildren size = 1.	self assert: workingCopy ancestry stepChildren first = final info! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:30'!testFourColumns	self assert: self listMorphs size = 4.! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:05'!testFileDirectoryContainingDirectoryExistence	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: (fd containingDirectory fileOrDirectoryExists: 'C:').! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 11/10/2008 15:30'!decompilerFailures	"here is the list of failures: DNU resulting in trying to decompile the following methods"	^ #((BalloonEngineSimulation circleCosTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		 (BalloonEngineSimulation circleSinTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		 (GeniePlugin primSameClassAbsoluteStrokeDistanceMyPoints:otherPoints:myVectors:otherVectors:mySquaredLengths:otherSquaredLengths:myAngles:otherAngles:maxSizeAndReferenceFlag:rowBase:rowInsertRemove:rowInsertRemoveCount: "Cannot compile -- stack including temps is too deep")		(QPickable2D pick:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(QUsersPane userEntryCompare:to:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(TShaderProgram vertexStrings) "foo ifTrue: []. => foo. => ."		(TShaderProgram fragmentStrings) "foo ifTrue: []. => foo. => ."		(TWindow zoomWindow:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		"(PNMReadWriter nextImage) (Collection #ifEmpty:ifNotEmpty:) (Collection #ifEmpty:) (Collection #ifNotEmpty:ifEmpty:) (Text #alignmentAt:ifAbsent:) (ObjectWithDocumentation propertyAt:ifAbsent:)")! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:33'!testBlockArgument	| block block1 block2 |	block := [ :arg | | temp | temp := arg. [ temp ] ].	block1 := block value: 1.	block2 := block value: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!MCMczInstallerTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/13/2003 11:56'!suite	^ (Smalltalk hasClassNamed: #MczInstaller)		ifTrue: [super suite]		ifFalse: [TestSuite new name: self name asString]! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'dtl 6/1/2004 21:54'!testDoubleOuterPass	self assertSuccess: (ExceptionTester new runTest: #doubleOuterPassTest ) ! !!MCInitializationTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/11/2003 23:50'!testWorkingCopy	MczInstaller storeVersionInfo: self mockVersion.	MCWorkingCopy initialize.	MCWorkingCopy allManagers						detect: [:man | man package name = self mockPackage name]						ifNone: [self assert: false]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/7/2009 11:39'!testInlineBlockCollectionLR2	"Test case from Lukas Renggli"	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesEAtoEM	self decompileClassesSelect: [:cn| cn first = $E and: [cn second asUppercase <= $M]]! !!MCSnapshotResource methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	snapshot := self class takeSnapshot.! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:23'!select	! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertSnapshotsMatchWith: writerClass	| readerClass expected stream actual |	readerClass := writerClass readerClass.	expected := self mockSnapshot.	stream := RWBinaryOrTextStream on: String new.	(writerClass on: stream) writeSnapshot: expected.	actual := readerClass snapshotFromStream: stream reset.	self assertSnapshot: actual matches: expected.! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!touchCVar	CVar := #touched! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 10:15'!simpleEnsureTestWithNotification	[self doSomething.	self methodWithNotification.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'ul 12/12/2009 14:10'!assertDict: dict matchesInfo: info	#(name id message date time author)		do: [:sel |  (info perform: sel) ifNotNil: [:i | dict at: sel ifPresent: [:d | self assert: i = d]]].	info ancestors 			with: (dict at: #ancestors) 			do: [:i :d | self assertDict: d matchesInfo: i]! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getFalse	^false! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:42'!myDirectory	^FileDirectory default directoryNamed: self myLocalDirectoryName! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:23'!selectFrom: start to: end 	! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testAnnotationPane	| oldPref |	oldPref := Preferences annotationPanes.	Preferences disable: #annotationPanes.	morph := model buildWindow.	self assert: (self morphsOfClass: TextMorph) size = 1.	Preferences enable: #annotationPanes.	morph := model buildWindow.	self assert: (self morphsOfClass: TextMorph) size = 2.	Preferences setPreference: #annotationPanes toValue: oldPref! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testSimpleMerge	| mother base inst |	inst := self mockInstanceA.	base :=  self snapshot.	self change: #one toReturn: 2.	mother :=  self snapshot.	self load: base.	self change: #two toReturn: 3.	self snapshot.	self assert: inst one = 1.	self assert: inst two = 3.		self merge: mother.	self assert: inst one = 2.	self assert: inst two = 3.! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables2	^ ivar + CVar! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testComparison	| d1 d2 d3 d4 |	d1 := self mockClass: 'A' super: 'X'.	d2 := self mockClass: 'A' super: 'Y'.	d3 := self mockClass: 'B' super: 'X'.	d4 := self mockClass: 'B' super: 'X'.		self assert: (d1 isRevisionOf: d2).	self deny: (d1 isSameRevisionAs: d2).	self assert: (d3 isRevisionOf: d4).	self assert: (d3 isSameRevisionAs: d4).		self deny: (d1 isRevisionOf: d3).	self deny: (d4 isRevisionOf: d2).! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCannotLoad	| d |	d :=  self mockClass: 'MCMockClassC' super: 'NotAnObject'.	self should: [d load] raise: Error.	self deny: (Smalltalk hasClassNamed: 'MCMockClassC').! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 00:59'!simpleReturnTest	| it |	it :=		[self doSomething.		MyTestError signal.		self doSomethingElse]			on: MyTestError			do: [:ex | ex return: 3].	it = 3 ifTrue: [self doYetAnotherThing]! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:20'!classAComment	^ self class classAComment! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 10:13'!simpleEnsureTestWithNotificationResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingElseString;		add: self doYetAnotherThingString;		yourself! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'ab 7/19/2003 16:06'!deleteNode: aNode	dict removeKey: aNode! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 20:45'!methodWithCopiedAndPostClosedOverAssignedTemps	| blk a b c r1 r2 |	a := 1.	b := 2.	c := 4.	blk := [a + b + c].	r1 := blk value.	b := nil.	r2 := blk value.	r1 -> r2	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedAndPostClosedOverAssignedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:22'!test2	self assertScans: 'it''s alive'! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!provisions	^ provides ifNil: [#()]! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/22/2009 23:05'!testSourcePointerFromFileIndexAndPosition	"Test valid input ranges"	| sf |	sf := ExpandedSourceFileArray new.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 2 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 3] raise: Error.	self should: [sf sourcePointerFromFileIndex: 1 andPosition: -1] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 16r2000000] raise: Error.	self should: [sf sourcePointerFromFileIndex: 3 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 4 andPosition: 0] raise: Error.		self assert: 16r1000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 0).	self assert: 16r1000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r13).	self assert: 16r1FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16rFFFFFF).	self assert: 16r2000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 0).	self assert: 16r2000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r13).	self assert: 16r2FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16rFFFFFF).	self assert: 16r3000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000000).	self assert: 16r3000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000013).	self assert: 16r3FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF).	self assert: 16r4000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000000).	self assert: 16r4000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000013).	self assert: 16r4FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1FFFFFF)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesJNtoJZ	self decompileClassesSelect: [:cn| cn first = $J and: [cn second asUppercase > $M]]! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:01'!testRemoveActionsForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self shouldnt: [eventSource hasActionForEvent: #anEvent]! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMergeIntoUnmodifiedImage	| base revA |	base := self snapshot.	self change: #a toReturn: 'a1'.	revA := self snapshot.		self load: base.	self merge: revA.	self assert: (workingCopy ancestors size = 1)	! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 02:38'!assertTextIs: aString	self assert: self textMorph contents = aString.! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 13:55'!testDependencyOrder	self 		assert: #allDependenciesDo: 		orders: #(a (b c)) 		as: #(b c)! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:45'!testSimpleEnsureTestWithUparrow	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTestWithUparrow ) ! !!MCTestCase methodsFor: 'mocks' stamp: 'ab 1/15/2003 17:55'!mockToken: aSymbol	^ MCMockDefinition token: aSymbol! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:44'!testResumableFallOffTheEndHandler	self assertSuccess: (ExceptionTester new runTest: #resumableFallOffTheEndHandler ) ! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/14/2009 00:09'!testSourcePointerFromFileIndexAndPosition	"Test valid input ranges"	| sf |	sf := StandardSourceFileArray new.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 0] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 2 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 0 andPosition: 3] raise: Error.	self should: [sf sourcePointerFromFileIndex: 1 andPosition: -1] raise: Error.	self shouldnt: [sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF] raise: Error.	self should: [sf sourcePointerFromFileIndex: 1 andPosition: 16r2000000] raise: Error.	self should: [sf sourcePointerFromFileIndex: 3 andPosition: 0] raise: Error.	self should: [sf sourcePointerFromFileIndex: 4 andPosition: 0] raise: Error.		self assert: 16r1000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 0).	self assert: 16r1000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r13).	self assert: 16r1FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16rFFFFFF).	self assert: 16r2000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 0).	self assert: 16r2000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r13).	self assert: 16r2FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16rFFFFFF).	self assert: 16r3000000 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000000).	self assert: 16r3000013 = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1000013).	self assert: 16r3FFFFFF = (sf sourcePointerFromFileIndex: 1 andPosition: 16r1FFFFFF).	self assert: 16r4000000 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000000).	self assert: 16r4000013 = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1000013).	self assert: 16r4FFFFFF = (sf sourcePointerFromFileIndex: 2 andPosition: 16r1FFFFFF)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesCAtoCM	self decompileClassesSelect: [:cn| cn first = $C and: [cn second asUppercase <= $M]]! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 18:18'!deleteFile	(FileDirectory default fileExists: self fileName)		ifTrue: [FileDirectory default deleteFileNamed: self fileName]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesYNtoYZ	self decompileClassesSelect: [:cn| cn first = $Y and: [cn second asUppercase > $M]]! !!MCVersionTest methodsFor: 'asserting' stamp: 'md 9/6/2005 18:41'!assert: aSelector orders: sexpr as: expected unresolved: unresolved	| missing |	missing := OrderedCollection new.	version := self versionFromTree: sexpr.	version 		perform: aSelector 		with: [:ea | visited add: ea info name]		with: [:ea | missing add: ea name].	self assert: visited asArray = expected.	self assert: missing asArray = unresolved.! !!MCMethodDefinitionTest methodsFor: 'running' stamp: 'bf 5/20/2005 18:23'!tearDown	self restoreMocks.	(MCWorkingCopy forPackage: (MCPackage named: 'FooBarBaz')) unregister.	self class compile: 'override ^ 1' classified: 'mocks'.	self ownPackage modified: isModified! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/26/2009 14:56'!testFileIndexFromSourcePointer	"Test derivation of file index for sources or changes file from source pointers"	| sf |	sf := ExpandedSourceFileArray new.	"sources file mapping"	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1FFFFFF).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3FFFFFF).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r5000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r5000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r5FFFFFF).	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	(16r3000000 to: 16r3FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	"changes file mapping"	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2FFFFFF).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4FFFFFF).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r6000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r6000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r6FFFFFF).	(16r2000000 to: 16r2FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	(16r4000000 to: 16r4FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000000).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000013).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0FFFFFF)! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!denyAListHasSelection: aString	| found |	found := true.	self listMorphs 			detect: [:m | m selection = aString]			ifNone: [found := false].	self deny: found.! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'jws 9/7/2000 16:39'!testNoArgumentEvent	eventSource when: #anEvent send: #heardEvent to: self.	eventSource triggerEvent: #anEvent.	self should: [succeeded]! !!MCStWriterTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testInitializerDefinition	|chunk lastChunk|	writer writeSnapshot: self mockSnapshot.	stream reset.	[stream atEnd] whileFalse:		[chunk := stream nextChunk.		chunk isAllSeparators ifFalse: [lastChunk := chunk]].	self assertContentsOf: lastChunk readStream match: self expectedInitializerA! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 09:26'!assertButtonOn: aString	self assert: (self findButtonWithLabel: aString) getModelState.	! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:13'!testFileDirectoryRootExistence	"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	self assert: (FileDirectory root fileOrDirectoryExists: 'C:').! !!EventManagerTest methodsFor: 'running-dependent action supplied arguments' stamp: 'JWS 9/7/2000 17:20'!testNoArgumentEventDependentSuppliedArgument	eventSource when: #anEvent send: #add: to: eventListener with: 'boundValue'.	eventSource triggerEvent: #anEvent.	self should: [eventListener includes: 'boundValue']! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:10'!testIfSequence6	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d a b c).	self assert: patch size = 5.	"lcs is abc"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('abc' includes: each value first) ]			ifFalse: [ self assert: each value first = $d ] ]! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:10'!simpleOuterTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesRAtoRM	self decompileClassesSelect: [:cn| cn first = $R and: [cn second asUppercase <= $M]]! !!MCMethodDefinitionTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	navigation := (Smalltalk hasClassNamed: #SystemNavigation)		ifTrue: [(Smalltalk at: #SystemNavigation) new]		ifFalse: [Smalltalk].	isModified := self ownPackage modified.! !!FileDirectoryTest methodsFor: 'resources' stamp: 'nk 11/13/2002 19:56'!tearDown	[ self deleteDirectory ] on: Error do: [ :ex | ]! !!ExceptionTests methodsFor: 'testing' stamp: 'brp 10/21/2004 16:41'!testTimeoutWithZeroDuration	self assertSuccess: (ExceptionTester new runTest: #simpleTimeoutWithZeroDurationTest ) ! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:28'!testFullNameFor	"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	self assert: (FileDirectory default fullNameFor: 'C:') = 'C:'.	self assert: (FileDirectory default fullNameFor: 'C:\test') = 'C:\test'.	self assert: (FileDirectory default fullNameFor: '\\share') = '\\share'.	self assert: (FileDirectory default fullNameFor: '\\share\test') = '\\share\test'.	self assert: (FileDirectory default fullNameFor: '\test') = (FileDirectory default pathParts first, '\test').! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 01:27'!testSimultaneousRemove	self assertMerge: #(a1)				with: #(a1)				base: #(a1 b1)								gives: #(a1)				conflicts: #()! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:21'!testFileDirectoryExists	"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	self assert: (FileDirectory root directoryExists: 'C:').! !!MCRepositoryTest methodsFor: 'actions' stamp: 'ab 7/19/2003 16:20'!saveSnapshot1	^ self saveSnapshot: self snapshot1 named: 'rev1'! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testMultiRequirementOrdering	self assertItems: #(		(a (x) (z))		(b (y) ())		(c (z) ())		(d () (x y z)))		orderAs: #(b c a d)		withRequired: #()		toLoad: #()! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:47'!testAllUnresolved	self 		assert: #allDependenciesDo:ifUnresolved: 		orders: #(a ((b (d e)) (c missing)))		as: #(d e b)		unresolved: #(c)! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'ar 8/26/2009 21:37'!testBlockReceiverNoArgs	eventSource when: #anEvent evaluate:[self heardEvent].	eventSource triggerEvent: #anEvent.	self should: [succeeded]! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/7/2003 18:16'!fileStream	^ FileStream forceNewFileNamed: self fileName.! !!MCTestCase methodsFor: 'mocks' stamp: 'stephaneducasse 2/4/2006 20:47'!treeFrom: anArray	| name id |	name := anArray first.	id := '00000000-0000-0000-0000-0000000000', (name asString size = 1 ifTrue: [name asString, '0'] ifFalse: [name asString]).	^ MCVersionInfo		name: name		id: (UUID fromString: id)		message: ''		date: nil		time: nil		author: ''		ancestors: (anArray size > 1 ifTrue: [(anArray second collect: [:ea | self treeFrom: ea])] ifFalse: [#()])! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 22:00'!testResumablePass	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex pass. ex return: 5].	self assert: result == 4! !!MCSortingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testSortOrder	| aA aAm aB bA bB A B cA bAm cAm |	aA := self methodNamed: #a class: #A meta: false.	bA := self methodNamed: #b class: #A meta: false.	cA := self methodNamed: #c class: #A meta: false.	aAm := self methodNamed: #a class: #A meta: true.	bAm := self methodNamed: #b class: #A meta: true.	cAm := self methodNamed: #c class: #A meta: true.	aB := self methodNamed: #a class: #B meta: false.	bB := self methodNamed: #b class: #B meta: false.	A := self classNamed: #A.	B := self classNamed: #B.	self assert: (self sortDefinitions: {aA. aAm. cAm. aB. bAm. bA. bB. A. cA. B})					= {A. aAm. bAm. cAm. aA. bA. cA. B. aB.  bB}! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 7/31/2003 15:30'!systemCategories	^ Array with: 'Monticello-Mocks'! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesHNtoHZ	self decompileClassesSelect: [:cn| cn first = $H and: [cn second asUppercase > $M]]! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testOptimizedLoad	| inst base diffy |	inst := self mockInstanceA.	base := self snapshot.	self change: #one toReturn: 2.	self assert: inst one = 2.	diffy := self snapshot asDiffAgainst: base.	self deny: diffy canOptimizeLoading.	self load: base.	self assert: inst one = 1.	self assert: diffy canOptimizeLoading.	self load: diffy.	self assert: inst one = 2.! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 16:25'!testInstallFromFile	MCMczWriter fileOut: expected on: self fileStream.	MczInstaller installFileNamed: self fileName.	self assertNoChange.! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tpr 5/27/2004 21:50'!simpleOuterTest	"uses #resume"	[[self doSomething.	MyTestNotification signal.	"self doSomethingElse"	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex outer. self doSomethingElse]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 16:57'!tearDown	Smalltalk at: 'MCMockClassC' ifPresent: [:c | c removeFromSystem]! !!MCRepositoryTest methodsFor: 'asserting' stamp: 'ab 8/16/2003 18:07'!assertVersionInfos: aCollection	self assert: repository allVersionInfos asSet = aCollection asSet! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getTrue	^true! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!asString	^ token! !!MCStWriterTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	stream := RWBinaryOrTextStream on: String new.	writer := MCStWriter on: stream.! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesWNtoWZ	self decompileClassesSelect: [:cn| cn first = $W and: [cn second asUppercase > $M]]! !!MCAncestryTest methodsFor: 'building' stamp: 'ul 12/12/2009 14:10'!versionForName: name in: tree	(tree name = name) ifTrue: [^ tree].		tree ancestors do: [:ea | (self versionForName: name in: ea) ifNotNil: [:v | ^ v]].		^ nil! !!MCMockDependency methodsFor: 'mocks' stamp: 'nk 2/22/2005 21:17'!uuidForName: aName 	| nm id |	nm := aName asString.	id := '00000000-0000-0000-0000-0000000000' 				, (nm size = 1 ifTrue: [nm , '0'] ifFalse: [nm]).	^UUID fromString: id! !!ArrayLiteralTest methodsFor: 'tests' stamp: 'avi 2/16/2004 21:09'!testSymbols	self class compile: 'array ^ #(#nil #true #false #''nil'' #''true'' #''false'')'.	self assert: self array = {#nil. #true. #false. #nil. #true. #false}.! !!MCMergingTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertMerge: local with: remote base: ancestor gives: result conflicts: conflictResult	| merger |	conflicts := #().	merger := MCThreeWayMerger				base: (self snapshotWithElements: local)				target: (self snapshotWithElements: remote)				ancestor: (self snapshotWithElements: ancestor).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: result.	self assert: conflicts asSet = conflictResult asSet.! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:22'!testNoValueSupplier	succeeded := eventSource 		triggerEvent: #needsValue		ifNotHandled: [true].	self should: [succeeded]! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 16:50'!mockClass: className super: superclassName	^ MCClassDefinition		name:  className		superclassName:  superclassName		category: self mockCategoryName		instVarNames: #()		classVarNames: #()		poolDictionaryNames: #()		classInstVarNames: #()		type: #normal		comment: (self commentForClass: className)		commentStamp: (self commentStampForClass: className)! !!LocaleTest methodsFor: 'testing' stamp: 'tak 8/7/2005 12:25'!testFontFullName	"self debug: #testFontFullName"	| env dir |	env := (Locale isoLanguage: 'ja') languageEnvironment.	dir := FileDirectory on: SecurityManager default untrustedUserDirectory.	[dir recursiveDelete]		on: Error		do: [:e | e].	env fontFullName.	self assert: dir exists! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesPAtoPM	self decompileClassesSelect: [:cn| cn first = $P and: [cn second asUppercase <= $M]]! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleTimeoutTest	| n |	[1 to: 1000000 do: [ :i | n := i. self doSomething ] ]		valueWithin: 50 milliSeconds onTimeout:			[ self iterationsBeforeTimeout: n.			self doSomethingElse ]! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'mha 7/30/2009 11:25'!testDetectFileDo	"Mantis #1838"		| filename |	filename := 'filestream.tst'.		[(FileDirectory default forceNewFileNamed: filename)		nextPutAll: '42';		close.			FileStream 		detectFile: [FileDirectory default oldFileNamed: filename]		do: [:file |			self assert: file notNil.			self deny: file closed.			self assert: file contentsOfEntireFile = '42']]			ensure: [FileDirectory default deleteFileNamed: filename ifAbsent: [] ]! !!MyResumableTestError methodsFor: 'exceptionDescription' stamp: 'tfei 6/13/1999 00:46'!isResumable	^true! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'cwp 8/25/2009 20:28'!unusedVariableSource	^ 'griffle 		| goo |		^ nil'! !!EventManagerTest methodsFor: 'running' stamp: 'JWS 9/7/2000 17:19'!setUp	super setUp.	eventSource := EventManager new.	eventListener := Bag new.	succeeded := false! !!EventManagerTest methodsFor: 'running-dependent action supplied arguments' stamp: 'JWS 9/7/2000 17:21'!testNoArgumentEventDependentSuppliedArguments	eventSource 		when: #anEvent 		send: #addArg1:addArg2: 		to: self 		withArguments: #('hello' 'world').	eventSource triggerEvent: #anEvent.	self should: [(eventListener includes: 'hello') and: [eventListener includes: 'world']]! !!MCTestCase methodsFor: 'mocks' stamp: 'ar 1/4/2010 18:02'!mockCategoryName	^ 'Tests-Monticello-Mocks'! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:17'!testIsDriveForDrive	self assert: (DosFileDirectory isDrive: 'C:').	self deny: (DosFileDirectory isDrive: 'C:\').	self deny: (DosFileDirectory isDrive: 'C:\foo').	self deny: (DosFileDirectory isDrive: 'C:foo').! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 17:44'!simpleTimeoutTestResults	| things |	things := OrderedCollection new: self iterationsBeforeTimeout.	self iterationsBeforeTimeout timesRepeat: [ things add: self  doSomethingString ].	things add: self doSomethingElseString.	^ things! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:24'!methodWithOptimizedBlocks	| s c |	s := self isNil			ifTrue: [| a | a := 'isNil'. a]			ifFalse: [| b | b := 'notNil'. b].	c := String new: s size.	1 to: s size do:		[:i| c at: i put: (s at: i)].	^c	"Parser new		parse: (self class sourceCodeAt: #methodWithOptimizedBlocks)		class: self class"! !!MCAncestryTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertCommonAncestorOf: leftName and: rightName in: options in: tree	| left right ancestor |	left := self versionForName: leftName in: tree.	right := self versionForName: rightName in: tree.		ancestor := left commonAncestorWith: right.		self assert: (options includes: ancestor name)! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:53'!testWhileWithTempNotInlined	| index block |	index := 0.	block := [		| temp |		temp := index := index + 1.		collection add: [ temp ] ].	[ index < 5 ] whileTrue: block.	self assertValues: #(1 2 3 4 5)! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!denyAListIncludesAnyOf: anArrayOfStrings	| found |	found := true.	self listMorphs 			detect: [:m | m getList includesAnyOf: anArrayOfStrings]			ifNone: [found := false].	self deny: found.! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 17:17'!creationMessage	^ MessageSend		receiver: MCClassDefinition		selector: #name:superclassName:category:instVarNames:classVarNames:poolDictionaryNames:classInstVarNames:type:comment:commentStamp:! !!MCWorkingCopyTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNameWhenSavingTo: aRepository is: aString	| name |	name := nil.	[aRepository storeVersion: workingCopy newVersion]		on: MCVersionNameAndMessageRequest		do: [:n | name := n suggestedName. n resume: (Array with: name with: '')].	self assert: name = aString! !!ProcessTerminateBug methodsFor: 'tests' stamp: 'ar 7/27/2003 19:44'!testUnwindFromActiveProcess	| sema process |	sema := Semaphore forMutualExclusion.	self assert:(sema isSignaled).	process := [		sema critical:[			self deny: sema isSignaled.			Processor activeProcess terminate.		]	] forkAt: Processor userInterruptPriority.	self assert: sema isSignaled.! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 11/13/2003 13:24'!mockOverrideMethodCategory	^ self mockExtensionMethodCategory, '-override'! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'aka 5/20/2003 23:33'!testDirectoryExists	self assert: self myAssuredDirectory exists.	self should: [self myDirectory containingDirectory 					directoryExists: self myLocalDirectoryName].	self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: [self myDirectory containingDirectory 						directoryExists: self myLocalDirectoryName]! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/7/1999 15:03'!log: aString	self log add: aString! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleTimeoutWithZeroDurationTest	[ self doSomething ]		valueWithin: 0 seconds onTimeout:			[ self doSomethingElse ].	! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:11'!testMethodDefinition	writer visitMethodDefinition: (MethodReference class: self mockClassA selector: #one) 									asMethodDefinition.	self assertContentsOf: stream match: self expectedMethodDefinition.	stream reset.	self assert: stream nextChunk isAllSeparators.	self assertChunkIsWellFormed: stream nextChunk.	self assertMethodChunkIsWellFormed: stream nextChunk.	self assert: stream nextChunk isAllSeparators ! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:16'!iterationsBeforeTimeout: anInteger	iterationsBeforeTimeout := anInteger! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'avi 1/24/2004 20:13'!load: aVersion	aVersion load! !!MCSerializationTest methodsFor: 'asserting' stamp: 'cwp 8/1/2003 14:57'!assertExtensionProvidedBy: aClass	self shouldnt: [aClass readerClass extension] raise: Exception.! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'sd 10/27/2003 18:05'!testMacFileDirectory	"(self run: #testMacFileDirectory)"		"This fails before the the fix if the Squeak directory is on the root	directory like: 'HardDisk:Squeak'	But should work both before and after the fix of John if there is several	directories in the hieracry: HardDisk:User:Squeak"	"If somebody can find a way to make the test failed all the time when the fix is not 	present we should replace it"	self assert: (FileDirectory default fullName) = (FileDirectory default fullNameFor: (FileDirectory default fullName))! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesMNtoMZ	self decompileClassesSelect: [:cn| cn first = $M and: [cn second asUppercase > $M]]! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:43'!testDoubleResume	self assertSuccess: (ExceptionTester new runTest: #doubleResumeTest ) ! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:41'!testSimpleOuter	self assertSuccess: (ExceptionTester new runTest: #simpleOuterTest ) ! !!MCFileInTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	expected := self mockSnapshot.	stream := RWBinaryOrTextStream on: String new.! !!MCSnapshotTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testInstanceReuse	| x m n y |	x := (MCPackage new name: self mockCategoryName) snapshot.	Smalltalk garbageCollect.	n := MCDefinition allSubInstances size.	y := (MCPackage new name: self mockCategoryName) snapshot.	Smalltalk garbageCollect.	m := MCDefinition allSubInstances size.	self assert: m = n! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesFAtoFM	self decompileClassesSelect: [:cn| cn first = $F and: [cn second asUppercase <= $M]]! !!MCChangeNotificationTest methodsFor: 'private' stamp: 'bf 5/20/2005 16:19'!foreignMethod	"see testForeignMethodModified"! !!StandardSystemFontsTest methodsFor: 'utilities' stamp: 'bp 8/9/2009 19:57'!assert: selector familyName: aString pointSize: anInteger	| font |	font := Preferences perform: selector.	self assert: aString equals: font familyName.	self assert: anInteger equals: font pointSize! !!MCPatchTest methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:31'!testPatchContents	self assert: patch operations size = 1.	self assert: patch operations first isModification.	self assert: patch operations first definition selector = #one.! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'DF 5/26/2006 11:57'!testFileDirectoryNonExistence	| inexistentFileName |		"Hoping that you have 'C:' of course..."	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].		inexistentFileName := DosFileDirectory default nextNameFor: 'DosFileDirectoryTest' extension: 'temp'.		"This test can fail if another process creates a file with the same name as inexistentFileName	(the probability of that is very very remote)"	self deny: (DosFileDirectory default fileOrDirectoryExists: inexistentFileName)! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'Igor.Stasenko 12/20/2009 03:57'!testInjectIntoDecompilations	"Test various compilations decompile to the same code for a method sufficiently	 simple that this is possible and sufficiently complex that the code generated	 varies between the compilations."	"self new testInjectIntoDecompilations"	| source |	source := (Collection sourceCodeAt: #inject:into:) asString.	{ Encoder.	   EncoderForV3. EncoderForLongFormV3.	   EncoderForV3PlusClosures. EncoderForLongFormV3PlusClosures } do:		[:encoderClass| | method |		method := (Parser new							encoderClass: encoderClass;							parse: source							class: Collection)						generate.		self assert: (Scanner new scanTokens: method decompileString)					= #(inject: t1 into: t2							| t3 |							t3 ':=' t1 .							self do: [ ':t4' | t3 ':=' t2 value: t3 value: t4 ] .							^ t3)]! !!MCDirtyPackageInfo methodsFor: 'as yet unclassified' stamp: 'al 2/16/2006 09:53'!methods	^ MCMockClassA selectors		select: [:ea | ea beginsWith: 'ordinal']		thenCollect:			[:ea | 				MethodReference new 					setStandardClass: MCMockClassA 					methodSymbol: ea].! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 11/6/2004 16:06'!mockVersionInfoWithAncestor: aVersionInfo 	^ MCVersionInfo		name: aVersionInfo name, '-child'		id: UUID new		message: self mockMessageString		date: Date today		time: Time now		author: Utilities authorInitials 		ancestors: {aVersionInfo}! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/29/2008 17:16'!supportTestSourceRangeAccessForInjectInto: method source: source selectionSequence: selections	"Test debugger source range selection for inject:into:"	| evaluationCount sourceMap debugTokenSequence debugCount |	DebuggerMethodMap voidMapCache.	evaluationCount := 0.	sourceMap := method debuggerMap abstractSourceMap.	debugTokenSequence := selections collect: [:string| Scanner new scanTokens: string].	debugCount := 0.	thisContext		runSimulated: [(1 to: 2)						withArgs:							{	0.								[:sum :each|								 evaluationCount := evaluationCount + 1.								 sum + each]}						executeMethod: method]		contextAtEachStep:			[:ctxt| | range debugTokens |			(ctxt method == method			and: ["Exclude the send of #blockCopy: or #closureCopy:copiedValues: and braceWith:with:				    to create the block, and the #new: and #at:'s for the indirect temp vector.				   This for compilation without closure bytecodes. (Note that at:put:'s correspond to stores)"				(ctxt willSend					and: [(#(closureCopy:copiedValues: blockCopy: new: at: braceWith:with:) includes: ctxt selectorToSendOrSelf) not])				"Exclude the store of the argument into the home context (for BlueBook blocks)				 and the store of an indirection vector into an initial temp"				or: [(ctxt willStore					and: [(ctxt isBlock and: [ctxt pc = ctxt startpc]) not					and: [(ctxt isBlock not						and: [(method usesClosureBytecodes and: [ctxt abstractPC = 2])]) not]])				or: [ctxt willReturn]]]) ifTrue:				[debugTokens := debugTokenSequence at: (debugCount := debugCount + 1) ifAbsent: [#(bogusToken)].				 self assert: (sourceMap includesKey: ctxt abstractPC).				 range := sourceMap at: ctxt abstractPC ifAbsent: [(1 to: 0)].				 self assert: (Scanner new scanTokens: (source copyFrom: range first to: range last)) = debugTokens]].	self assert: evaluationCount = 2! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesUAtoUM	self decompileClassesSelect: [:cn| cn first = $U and: [cn second asUppercase <= $M]]! !!MCMockClassE class methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:22'!two	^ 2! !!MCPackageTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testUnload	| mock |	self mockPackage unload.	self deny: (Smalltalk hasClassNamed: #MCMockClassA).	self deny: (MCSnapshotTest includesSelector: #mockClassExtension).	mock := (Smalltalk at: #MCMock).	self assert: (mock subclasses detect: [:c | c name = #MCMockClassA] ifNone: []) isNil! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 00:28'!testIdenticalModification	self		assertMerge: #(a2 b1)				with: #(a2 b1)				base: #(a1 b1)								gives: #(a2 b1)				conflicts: #()! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/26/2009 15:22'!testCompatibilityWithStandardSourceFileArray	"Test compatibility with StandardSourceFileArray across the address range of	StandardSourceFileArray, including the unused address space below 16r1000000"		| ssf esf i1 i2 p1 p2 a1 a2 |	ssf := StandardSourceFileArray new.	esf := ExpandedSourceFileArray new.	(0 to: 16rFFFFFF by: 811) do: [:e |		i1 := ssf fileIndexFromSourcePointer: e.		i2 := esf fileIndexFromSourcePointer: e.		self assert: i1 = i2.		self assert: i1 = 0. "This is unused address space"		p1 := ssf filePositionFromSourcePointer: e.		p2 := esf filePositionFromSourcePointer: e.		self assert: p1 = p2].	(16r4FFFFFF to: 16r4FFFFFF by: 811) do: [:e |		i1 := ssf fileIndexFromSourcePointer: e.		i2 := esf fileIndexFromSourcePointer: e.		self assert: i1 = i2.		p1 := ssf filePositionFromSourcePointer: e.		p2 := esf filePositionFromSourcePointer: e.		self assert: p1 = p2.		a1 := ssf sourcePointerFromFileIndex: i1 andPosition: p1.		a2 := esf sourcePointerFromFileIndex: i2 andPosition: p2.		self assert: a1 = a2.		self assert: a1= e]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:00'!testIfSequence4	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d b c a).	self assert: patch size = 6.	"lcs is bc"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bc' includes: each value first) ]			ifFalse: [ self assert: ('ad' includes: each value first) ] ]! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:30'!suiteLog	suiteLog == nil		ifTrue: [suiteLog := OrderedCollection new].	^suiteLog! !!MCRepositoryTest methodsFor: 'building' stamp: 'ab 7/10/2003 01:03'!snapshot2	^ (MCSnapshot fromDefinitions: (Array with: (MCOrganizationDefinition categories: #('x'))))! !!MCEmptyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!methods	^ #()! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!dictionary	^ dict ifNil: [dict := Dictionary new]! !!MCRepositoryTest class methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 12:45'!isAbstract	^ self = MCRepositoryTest! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 09:00'!testMethodIsCleared	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	self clickOnListItem: 'boolean'.	self clickOnListItem: 'falsehood'.	self clickOnListItem: '-- all --'.		self denyAListHasSelection: 'falsehood'.! !!MCRepositoryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testAddAndLoad	| node |	node := self addVersionWithSnapshot: self snapshot1 name: 'rev1'.	self assert: (self snapshotAt: node) = self snapshot1.! !!MCStWriterTest methodsFor: 'data' stamp: 'ar 1/4/2010 18:03'!expectedClassDefinitionA ^ 'MCMock subclass: #MCMockClassA	instanceVariableNames: ''ivar''	classVariableNames: ''CVar''	poolDictionaries: ''''	category: ''Tests-Monticello-Mocks''!!!!MCMockClassA commentStamp: ''cwp 8/10/2003 16:43'' prior: 0!!This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.!!'! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 16:51'!commentForClass: name	^ 'This is a comment for ', name! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationBefore	| index |	index := 0.	[ index < 5 ] whileTrue: [ 		index := index + 1.		collection add: [ index ] ].	self assertValues: #(5 5 5 5 5)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesKNtoKZ	self decompileClassesSelect: [:cn| cn first = $K and: [cn second asUppercase > $M]]! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!requires: anArray	requires := anArray! !!MCMockClassA methodsFor: 'numeric' stamp: ''!c	^ 'c1'! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'hg 2/2/2002 16:44'!testDirectoryNamed	self should: [(self myDirectory containingDirectory 					directoryNamed: self myLocalDirectoryName) pathName 						= self myDirectory pathName]! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:54'!basicTestSelectors	^ #(#simpleEnsureTest #simpleEnsureTestWithNotification #simpleEnsureTestWithUparrow #simpleEnsureTestWithError #signalFromHandlerActionTest #resumableFallOffTheEndHandler #nonResumableFallOffTheEndHandler #doubleResumeTest #simpleTimeoutWithZeroDurationTest #simpleTimeoutTest simpleNoTimeoutTest)! !!MCMockASubclass methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!variables	^ x + Y + MCMockClassA! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:10'!simplePassTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: 'Unhandled Exception';		yourself! !!FileDirectoryTest methodsFor: 'create/delete tests' stamp: 'stephaneducasse 2/4/2006 20:31'!testDeleteDirectory	"Test deletion of a directory"		| aContainingDirectory preTestItems |	aContainingDirectory := self myDirectory containingDirectory.	preTestItems := aContainingDirectory fileAndDirectoryNames.		self assert: self myAssuredDirectory exists.	aContainingDirectory deleteDirectory: self myLocalDirectoryName.	self shouldnt: 		[aContainingDirectory directoryNames 			includes: self myLocalDirectoryName ]		description: 'Should successfully delete directory.'.	self should: 		[preTestItems = aContainingDirectory fileAndDirectoryNames]		description: 'Should only delete the indicated directory.'.		! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesDAtoDM	self decompileClassesSelect: [:cn| cn first = $D and: [cn second asUppercase <= $M]]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'dtl 6/1/2004 21:49'!doubleOuterTest	"uses #resume"	[[[self doSomething.	MyTestNotification signal.	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex outer.			self doSomethingExceptional]]			on: MyTestNotification			do: [:ex | ex outer.				self doSomethingElse]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!MCTestCase class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:12'!isAbstract	^ self = MCTestCase! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'Igor.Stasenko 12/20/2009 03:58'!testBlockNumbering	"Test that the compiler and CompiledMethod agree on the block numbering of a substantial doit."	"self new testBlockNumbering"	| methodNode method tempRefs |	methodNode :=		Parser new			encoderClass: EncoderForV3PlusClosures;			parse: 'foo					| numCopiedValuesCounts |					numCopiedValuesCounts := Dictionary new.					0 to: 32 do: [:i| numCopiedValuesCounts at: i put: 0].					Transcript clear.					Smalltalk allClasses remove: GeniePlugin; do:						[:c|						{c. c class} do:							[:b|							Transcript nextPut: b name first; endEntry.							b selectorsAndMethodsDo:								[:s :m| | pn |								m isQuick not ifTrue:									[pn := b parserClass new												encoderClass: EncoderForV3PlusClosures;												parse: (b sourceCodeAt: s)												class: b.									 pn generate.									 [pn accept: nil]										on: MessageNotUnderstood										do: [:ex| | msg numCopied |											msg := ex message.											(msg selector == #visitBlockNode:											 and: [(msg argument instVarNamed: ''optimized'') not]) ifTrue:												[numCopied := (msg argument computeCopiedValues: pn) size.												 numCopiedValuesCounts													at: numCopied													put: (numCopiedValuesCounts at: numCopied) + 1].											msg setSelector: #==.											ex resume: nil]]]]].					numCopiedValuesCounts'			class: Object.	method := methodNode generate.	tempRefs := methodNode encoder blockExtentsToTempsMap.	self assert: tempRefs keys asSet = method startpcsToBlockExtents values asSet! !!DecompilerTests methodsFor: 'utilities' stamp: 'nice 10/23/2009 22:49'!decompileClassesSelect: aBlock		(Smalltalk classNames select: aBlock) do:		[:cn | | cls |		cls := Smalltalk at: cn.		Smalltalk garbageCollect.		 Transcript cr; show: cn.		 cls selectorsDo:			[:selector | | methodNode oldMethod newMethod oldCodeString newCodeString |			(self isFailure: cls sel: selector) ifFalse:				[" to help making progress					(self						isStoredProblems: cls theNonMetaClass						sel: selector						meta: cls isMeta)					ifFalse: [ "				Transcript nextPut: $.; flush.				self checkDecompileMethod: (cls compiledMethodAt: selector)]]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'Igor.Stasenko 12/20/2009 03:57'!testMethodAndNodeTempNames	"self new testMethodAndNodeTempNames"	"Test that BytecodeAgnosticMethodNode>>blockExtentsToTempRefs answers the same	 structure as CompiledMethod>>blockExtentsToTempRefs when the method has been	 copied with the appropriate temps.  This tests whether doit methods are debuggable	 since they carry their own temps."	self closureCases do:		[:source| | mn om m mbe obe |		mn := source first isLetter					ifTrue:						[self class compilerClass new							compile: source							in: self class							notifying: nil							ifFail: [self error: 'compilation error']]					ifFalse:						[self class compilerClass new							compileNoPattern: source							in: self class							context: nil							notifying: nil							ifFail: [self error: 'compilation error']].		m := (om := mn generate) copyWithTempsFromMethodNode: mn.		self assert: m holdsTempNames.		self assert: m endPC = om endPC.		mbe := m blockExtentsToTempsMap.		obe := mn blockExtentsToTempsMap.		self assert: mbe keys asSet = obe keys asSet.		(mbe keys intersection: obe keys) do:			[:interval|			self assert: (mbe at: interval) = (obe at: interval)]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesZNtoZZ	self decompileClassesSelect: [:cn| cn first = $Z and: [cn second asUppercase > $M]]! !!MCPatchTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	|rev1 rev2|	rev1 :=  MCSnapshotResource takeSnapshot.	self change: #one toReturn: 2.	rev2 :=  MCSnapshotResource takeSnapshot.	patch := rev2 patchRelativeToBase: rev1.	self change: #one toReturn: 1.! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:44'!testLocalModifyRemoteRemove	self assertMerge: #(a2 b1)				with: #(b1)				base: #(a1 b1)								gives: #(b1)				conflicts: #((removed a2)).					self assertMerge: #(a1 b1)				with: #(b1)				base: #(a2 b1)								gives: #(b1)				conflicts: #((removed a1)).! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classAClassProtocols	^ self protocolsForClass: self mockClassA class.! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/12/2004 21:01'!mockVersionInfo: tag 	^ MCVersionInfo		name: self mockVersionName, '-', tag asString		id: UUID new		message: self mockMessageString, '-', tag asString		date: Date today		time: Time now		author: Utilities authorInitials 		ancestors: #()! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 2/12/2004 19:58'!mockVersionInfo	^ self treeFrom: #(d ((b ((a))) (c)))! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'nice 12/27/2009 21:06'!simpleResumeTest	"see if we can resume twice"		[ | it |	self doSomething.	it := MyResumableTestError signal.	it = 3 ifTrue: [self doSomethingElse].	it := MyResumableTestError signal.	it = 3 ifTrue: [self doSomethingElse].	]		on: MyResumableTestError		do:			[:ex |			self doYetAnotherThing.			ex resume: 3]! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoArgument	1 to: 5 do: [ :index |		collection add: [ index ] ].	self assertValues: #(1 2 3 4 5)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesSAtoSM	self decompileClassesSelect: [:cn| cn first = $S and: [cn second asUppercase <= $M]]! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testEquals	| a b |	a := self mockClass: 'ClassA' super: 'SuperA'.	b := self mockClass: 'ClassA' super: 'SuperA'.	self assert: a = b! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!initialize	CVar := #initialized! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/13/2003 02:23'!classABooleanMethods	^ #(falsehood moreTruth truth)! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:10'!testRemoveActionsWithReceiver	| action |	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsWithReceiver: self.	action := eventSource actionForEvent: #anEvent.	self assert: (action respondsTo: #receiver).	self assert: ((action receiver == self) not)! !!MCMergingTest methodsFor: 'emulating' stamp: 'ab 7/6/2003 23:48'!snapshotWithElements: anArray	^ MCSnapshot		fromDefinitions: (anArray collect: [:t | self mockToken: t])! !!MCTestCase methodsFor: 'compiling' stamp: 'cwp 8/2/2003 15:05'!restoreMocks	self mockSnapshot updatePackage: self mockPackage! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!token: aString	token := aString! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testAncestorMerge	| base revA revB revC |	base := self snapshot.	self change: #a toReturn: 'a1'.	revA :=  self snapshot.	self change: #b toReturn: 'b1'.	revB :=  self snapshot.		self change: #c toReturn: 'c1'.	revC :=  self snapshot.		self should: [self basicMerge: revA] raise: MCNoChangesException.	! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesANtoAZ	self decompileClassesSelect: [:cn| cn first = $A and: [cn second asUppercase > $M]]! !!MCMockClassA methodsFor: 'drag''n''drop' stamp: 'avi 9/23/2003 17:14'!q! !!MCMergingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMultiPackageMerge2	| merger |	conflicts := #().	merger := MCThreeWayMerger new.	merger addBaseSnapshot: (self snapshotWithElements: #(a1 b1)).	merger applyPatch: ((self snapshotWithElements: #()) patchRelativeToBase: (self snapshotWithElements: #(a1))).	merger applyPatch: ((self snapshotWithElements: #(a1 b1)) patchRelativeToBase: (self snapshotWithElements: #(b1))).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: #(a1 b1).	self assert: conflicts isEmpty! !!MCTestCase methodsFor: 'compiling' stamp: 'cwp 8/10/2003 02:12'!change: aSelector toReturn: anObject	self 		compileClass: self mockClassA 		source: aSelector, ' ^ ', anObject printString 		category: 'numeric'! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:58'!allMethods	^ MCSnapshotResource current definitions		select: [:def | def isMethodDefinition]		thenCollect: [:def | def selector]		! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testCascadingUnresolved	self assertItems: #(		(a (x) (z))		(b () (x))		(c () ()))	orderAs: #(c)	withRequired: #(z)	toLoad: #(a b)	! !!ClosureTests methodsFor: 'testing' stamp: 'cwp 11/16/2009 08:11'!testCopyNonLocalReturn	self		shouldnt: [self methodWithNonLocalReturn]		raise: Error! !!MCRepositoryTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testStoreAndLoad	| node node2 |	node := self saveSnapshot1.	node2 := self saveSnapshot2.	self assert: (self snapshotAt: node) = self snapshot1.	self assert: (self snapshotAt: node2) = self snapshot2.! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:31'!packageName	^ 'MonticelloMocks'! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testEmptyLcs2	| patch |	patch := self patchSequenceFor: #() and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #insert ])! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 02:06'!mockInstanceA	^ self mockClassA new! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 13:06'!testClassSideClassSelected	self clickOnButton: 'class'.	self selectMockClassA.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAClassProtocols.	self denyAListIncludesAnyOf: self allMethods.	self assertTextIs: self classADefinitionString.! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'dtl 6/1/2004 21:51'!doubleOuterPassTest	"uses #resume"	[[[self doSomething.	MyTestNotification signal.	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex outer.			self doSomethingElse]]			on: MyTestNotification			do: [:ex | ex pass.				self doSomethingExceptional]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!SecureHashAlgorithmTest methodsFor: 'testing - examples' stamp: 'md 4/21/2003 12:23'!testExample2	"This is the second example from the specification document (FIPS PUB 180-1)"	hash := SecureHashAlgorithm new hashMessage:		'abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq'.	self assert: (hash = 16r84983E441C3BD26EBAAE4AA1F95129E5E54670F1).! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesXNtoXZ	self decompileClassesSelect: [:cn| cn first = $X and: [cn second asUppercase > $M]]! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'md 7/23/2006 15:28'!methodWithStyle	^ '!!EventHandler methodsFor: ''copying'' stamp: ''tk 1/22/2001 17:39''!!veryDeepInner: deepCopier	"ALL fields are weakly copied.  Can''t duplicate an object by duplicating a button that activates it.  See DeepCopier."	super veryDeepInner: deepCopier.	"just keep old pointers to all fields"	clickRecipient := clickRecipient.!!]style[(25 108 10 111)f1b,f1,f1LDeepCopier Comment;,f1!! !!'! !!MCTestCase methodsFor: 'mocks' stamp: 'ab 4/1/2003 02:02'!mockMethod: aSymbol class: className source: sourceString meta: aBoolean	^ MCMethodDefinition		className: className		classIsMeta: aBoolean		selector:  aSymbol		category: 'as yet unclassified'		timeStamp: ''		source: sourceString! !!LocaleTest methodsFor: 'testing' stamp: 'tak 8/4/2005 14:42'!testIsFontAvailable	"self debug: #testIsFontAvailable"	(Locale isoLanguage: 'ja') languageEnvironment removeFonts.	self assert: (Locale isoLanguage: 'en') languageEnvironment isFontAvailable.	"Next test should fail after installing Japanese font"	self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable not.	(Locale isoLanguage: 'ja') languageEnvironment installFont.	self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable! !!MCScannerTest methodsFor: 'asserting' stamp: 'avi 1/22/2004 20:23'!assertScans: anArray	self assert: (MCScanner scan: anArray printString readStream) = anArray! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 11:40'!testSourceRangeAccessForInjectInto	"Test debugger source range selection for inject:into: for the current version of the method"	"self new testSourceRangeAccessForInjectInto"	self supportTestSourceRangeAccessForInjectInto: (Collection compiledMethodAt: #inject:into:)		source: (Collection sourceCodeAt: #inject:into:) asString! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testRevertOverrideMethod	| definition |	self class compile: 'override ^ 2' classified: self mockOverrideMethodCategory.	definition := (MethodReference class: self class selector: #override) asMethodDefinition.	self assert: definition isOverrideMethod.	self assert: self override = 2.	definition unload.	self assert: self override = 1.	self assert: (MethodReference class: self class selector: #override) category = 'mocks'.	! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/9/1999 16:06'!runBasicTests	self basicTestSelectors		do:			[:eachTestSelector |			self runTest: eachTestSelector]! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'kfr 7/28/2004 15:06'!testMacIsAbsolute	"(self selector: #testMacIsAbsolute) run"			self deny: (MacFileDirectory isAbsolute: 'Volumes').	self assert: (MacFileDirectory isAbsolute: 'Volumes:Data:Stef').	self deny: (MacFileDirectory isAbsolute: ':Desktop:test.st')! !!MCTestCase methodsFor: 'asserting' stamp: 'cwp 8/8/2003 14:58'!assertVersion: actual matches: expected	self assertPackage: actual package matches: expected package.		self assertVersionInfo: actual info matches: expected info.	self assertSnapshot: actual snapshot matches: expected snapshot.! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesIAtoIM	self decompileClassesSelect: [:cn| cn first = $I and: [cn second asUppercase <= $M]]! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classAProtocols	^ self protocolsForClass: self mockClassA.! !!ExceptionTester methodsFor: 'results' stamp: 'brp 10/21/2004 16:52'!simpleTimeoutWithZeroDurationTestResults	^OrderedCollection new		add: self doSomethingElseString;		yourself! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:22'!testWithAll	self 		assert: #withAllDependenciesDo: 		orders: #(a ((b (d e)) c)) 		as: #(d e b c a)! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:44'!testNonResumableFallOffTheEndHandler	self assertSuccess: (ExceptionTester new runTest: #nonResumableFallOffTheEndHandler ) ! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:46'!allCategories	^ Array with: model extensionsCategory with: self mockCategoryName.! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'RAA 12/8/2000 12:59'!simpleResumeTestResults	"see if we can resume twice"	^OrderedCollection new			add: self doSomethingString;			add: self doYetAnotherThingString;			add: self doSomethingElseString;			add: self doYetAnotherThingString;			add: self doSomethingElseString;			yourself! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 11/14/1999 17:29'!doubleResumeTestResults       ^OrderedCollection new               add: self doSomethingString;               add: self doSomethingElseString;               add: self doYetAnotherThingString;               yourself! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:24'!testSameSequenceWithRepetitions	| patch |	patch := self patchSequenceFor: #(a a b a) and: #(a a b a).	self assert: patch size = 4.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!MCSnapshotBrowserTest methodsFor: 'simulating' stamp: 'cwp 7/13/2003 09:22'!clickOnButton: aString	(self findButtonWithLabel: aString) performAction.! !!ClosureTests methodsFor: 'utilities' stamp: 'cwp 11/16/2009 08:12'!evaluateCopyOf: aBlock	aBlock copy value! !!LocaleTest methodsFor: 'testing' stamp: 'tak 8/4/2005 11:02'!testEncodingName	"self debug: #testEncodingName"	| locale |	locale := Locale isoLanguage: 'ja'.	self assert: locale languageEnvironment fontEncodingName = #FontJapaneseEnvironment! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleEnsure	self assertSuccess: (ExceptionTester new runTest: #simpleEnsureTest ) ! !!MCEmptyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 14:04'!initialize	[self new register] on: MessageNotUnderstood do: []! !!MCWorkingCopyTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	| repos1 repos2 |	self clearPackageCache.	repositoryGroup := MCRepositoryGroup new.	workingCopy := MCWorkingCopy forPackage: self mockPackage.	versions := Dictionary new.	versions2 := Dictionary new.	repos1 := MCDictionaryRepository new dictionary: versions.	repos2 := MCDictionaryRepository new dictionary: versions2.	repositoryGroup addRepository: repos1.	repositoryGroup addRepository: repos2.	MCRepositoryGroup default removeRepository: repos1; removeRepository: repos2.	workingCopy repositoryGroup: repositoryGroup.	savedInitials := Utilities authorInitials.	Utilities setAuthorInitials: 'abc'.! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/22/2009 23:05'!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	(0 to: 16r1FFFFFFF by: 4093) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)].	(16r2000000 to: 16r2FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r6000000 and: 16r6FFFFFF)].	(16r3000000 to: 16r3FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r8000000 and: 16r8FFFFFF)].	(16r4000000 to: 16r4FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rA000000 and: 16rAFFFFFF)].	(16r5000000 to: 16r5FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rC000000 and: 16rCFFFFFF)].	(16r6000000 to: 16r6FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rE000000 and: 16rEFFFFFF)].	(16r7000000 to: 16r7FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r10000000 and: 16r10FFFFFF)]! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:26'!test5	self assertScans: #((a) b)! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:22'!testNoValueSupplierHasArguments	succeeded := eventSource 		triggerEvent: #needsValue:		with: 'nelja'		ifNotHandled: [true].	self should: [succeeded]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:12'!testIfPatchIsMinimal	| patch |	patch := self patchSequenceFor: #(a a a b) and: #(a b a a).	self assert: patch size = 5.	"lcs is aaa"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $a ]			ifFalse: [ self assert: each value first = $b ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 05:58'!testIfSequence2	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(c d b a).	self assert: patch size = 6.	"lcs is cd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('cd' includes: each value first) ]			ifFalse: [ self assert: ('ab' includes: each value first) ] ]! !!MCChangeNotificationTest methodsFor: 'tests' stamp: 'bf 5/20/2005 17:00'!testForeignMethodModified	| event |	workingCopy modified: false.	event := self modifiedEventFor: #foreignMethod ofClass: self class.	MCWorkingCopy methodModified: event.	self deny: workingCopy modified! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 02:22'!simpleReturnTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		yourself! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesNNtoNZ	self decompileClassesSelect: [:cn| cn first = $N and: [cn second asUppercase > $M]]! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 i p |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)]! !!MCMockClassA methodsFor: 'boolean' stamp: ''!truth	^ true! !!LocaleTest methodsFor: 'testing' stamp: 'tak 8/4/2005 14:48'!testLocaleChanged	"self debug: #testLocaleChanged"	"LanguageEnvironment >> startUp is called from Prject >> localeChanged"	Project current updateLocaleDependents.	self assert: (ActiveHand instVarNamed: 'keyboardInterpreter') isNil.	self assert: (Clipboard default instVarNamed: 'interpreter') isNil.	Locale switchToID: (LocaleID isoLanguage: 'ja').	self assert: Preferences useFormsInPaintBox.	Locale switchToID: (LocaleID isoLanguage: 'en').	self assert: Preferences useFormsInPaintBox not.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForBlueBookLongFormInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForBlueBookLongFormInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForLongFormV3;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!MCMergingTest methodsFor: 'emulating' stamp: 'ul 12/12/2009 14:12'!handleConflict: aConflict		|l r|	l := #removed.	r := #removed.	aConflict localDefinition ifNotNil: [:d | l := d token].	aConflict remoteDefinition ifNotNil: [:d | r := d token].		conflicts := conflicts copyWith: (Array with: r with: l).	(l = #removed or: [r = #removed])		ifTrue: [aConflict chooseRemote]		ifFalse:			[l > r				ifTrue: [aConflict chooseLocal]				ifFalse: [aConflict chooseRemote]]		! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!addVersion: aVersion	| file |	file := FileStream newFileNamed: (directory fullNameFor: aVersion fileName).	aVersion fileOutOn: file.	file close.! !!MCFileInTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 00:13'!testStWriter	self		assertFileOutFrom: MCStWriter		canBeFiledInWith: [stream fileIn].! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesGAtoGM	self decompileClassesSelect: [:cn| cn first = $G and: [cn second asUppercase <= $M]]! !!MCMockClassA methodsFor: 'numeric' stamp: ''!a	^ 'a2'! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testDoubleRepeatedMerge	| base motherA1 motherA2 motherB1 motherB2 inst |	base := self snapshot.	self change: #a toReturn: 'a1'.	motherA1 :=  self snapshot.	self change: #c toReturn: 'c1'.	motherA2 :=  self snapshot.			self load: base.	self change: #b toReturn: 'b1'.	motherB1 :=  self snapshot.	self change: #d toReturn: 'd1'.	motherB2 :=  self snapshot.		self load: base.	self merge: motherA1.	self merge: motherB1.	self change: #a toReturn: 'a2'.	self change: #b toReturn: 'b2'.	self snapshot.	self shouldnt: [self merge: motherA2] raise: Error.	self shouldnt: [self merge: motherB2] raise: Error.		inst := self mockInstanceA.	self assert: inst a = 'a2'.	self assert: inst b = 'b2'.	self assert: inst c = 'c1'.	self assert: inst d = 'd1'.	! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:33'!testBlockTemp	| block block1 block2 |	block := [ :arg | [ arg ] ].	block1 := block value: 1.	block2 := block value: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:09'!simpleIsNestedTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doYetAnotherThingString;		add: self doSomethingElseString;		yourself! !!MCSnapshotTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	snapshot :=  self mockSnapshot.! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:42'!testSimplePass	self assertSuccess: (ExceptionTester new runTest: #simplePassTest ) ! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/22/2009 23:05'!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	(0 to: 16r1FFFFFFF by: 4093) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i == 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)].	(16r2000000 to: 16r2FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r5000000 and: 16r5FFFFFF)].	(16r3000000 to: 16r3FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r7000000 and: 16r7FFFFFF)].	(16r4000000 to: 16r4FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r9000000 and: 16r9FFFFFF)].	(16r5000000 to: 16r5FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rB000000 and: 16rBFFFFFF)].	(16r6000000 to: 16r6FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rD000000 and: 16rDFFFFFF)].	(16r7000000 to: 16r7FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rF000000 and: 16rFFFFFFF)]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'dtl 6/1/2004 21:52'!doublePassOuterTest	"uses #resume"	[[[self doSomething.	MyTestNotification signal.	self doSomethingExceptional]		on: MyTestNotification		do: [:ex | ex pass.			self doSomethingExceptional]]			on: MyTestNotification			do: [:ex | ex outer.				self doSomethingElse]]				on: MyTestNotification				do: [:ex | self doYetAnotherThing. ex resume]! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMergeIntoImageWithNoChanges	| base revB revA1 |	self change: #a toReturn: 'a'.	base := self snapshot.	self change: #b toReturn: 'b'.	revB := self snapshot.		self load: base.	self change: #a toReturn: 'a1'.	revA1 := self snapshot.	self change: #a toReturn: 'a'.	self snapshot.	self merge: revB.	self assert: (workingCopy ancestors size = 2)	! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesVAtoVM	self decompileClassesSelect: [:cn| cn first = $V and: [cn second asUppercase <= $M]]! !!StandardSystemFontsTest methodsFor: 'utilities' stamp: 'bp 8/9/2009 20:09'!saveStandardSystemFontsDuring: aBlock	| standardDefaultTextFont standardListFont standardEToysFont standardMenuFont 	windowTitleFont standardBalloonHelpFont standardCodeFont standardButtonFont |	standardDefaultTextFont := Preferences standardDefaultTextFont.	standardListFont := Preferences standardListFont.	standardEToysFont := Preferences standardEToysFont.	standardMenuFont := Preferences standardMenuFont.	windowTitleFont := Preferences windowTitleFont.	standardBalloonHelpFont := Preferences standardBalloonHelpFont.	standardCodeFont := Preferences standardCodeFont.	standardButtonFont := Preferences standardButtonFont.	[aBlock value] ensure: [		Preferences setSystemFontTo: standardDefaultTextFont.		Preferences setListFontTo: standardListFont.		Preferences setEToysFontTo: standardEToysFont.		Preferences setMenuFontTo: standardMenuFont.		Preferences setWindowTitleFontTo: windowTitleFont.		Preferences setBalloonHelpFontTo: standardBalloonHelpFont.		Preferences setCodeFontTo: standardCodeFont.		Preferences setButtonFontTo: standardButtonFont]! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 00:37'!simplePassTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex |			self doYetAnotherThing.			ex pass "expecting handler in #runTest:"]! !!MCRepositoryTest methodsFor: 'building' stamp: 'stephaneducasse 2/4/2006 20:47'!versionWithSnapshot: aSnapshot name: aString	| info |	info := self mockVersionInfo: aString. 	^ MCVersion 		package: (MCPackage new name: aString)		info: info		snapshot: aSnapshot! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/8/1999 09:14'!doSomethingElseString	^'Do something else.'! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 11/10/2008 15:46'!assert: aBoolean description: aString resumable: resumableBoolean 	aBoolean ifFalse: 		[failures isNil ifTrue:			[failures := OrderedCollection new].		 failures addLast: (thisContext sender tempAt: 1) methodReference]! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/14/2003 15:07'!mockSnapshot	^ MCSnapshotResource current snapshot! !!MCVersionTest methodsFor: 'asserting' stamp: 'cwp 11/7/2004 14:32'!assert: aSelector orders: sexpr as: array	| expected |	expected := OrderedCollection new.	version := self versionFromTree: sexpr.	version perform: aSelector with: [:ea | expected add: ea info name].	self assert: expected asArray = array! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/30/2003 19:25'!mockVersionName	^ 'MonticelloTest-xxx.1'! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:11'!testClassDefinitionA	writer visitClassDefinition: (self mockClassA asClassDefinition).	self assertContentsOf: stream match: self expectedClassDefinitionA.	stream reset.	2 timesRepeat: [self assertChunkIsWellFormed: stream nextChunk]! !!MCAncestryTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNamesOf: versionInfoCollection are: nameArray	| names |	names := versionInfoCollection collect: [:ea | ea name].		self assert: names asArray = nameArray! !!MCSortingTest methodsFor: 'actions' stamp: 'ab 7/19/2003 18:01'!sortDefinitions: aCollection	^ aCollection asSortedCollection asArray! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/9/1999 17:44'!simpleEnsureTestWithErrorResults	^OrderedCollection new		add: self doSomethingString;		add: 'Unhandled Exception';		add: self doYetAnotherThingString;		yourself! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesLNtoLZ	self decompileClassesSelect: [:cn| cn first = $L and: [cn second asUppercase > $M]]! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 09:12'!assertButtonExists: aString	self buttonMorphs detect: [:m | m label = aString] ifNone: [self assert: false].				! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testPartiallyRevertOverrideMethod	| definition |	self class compile: 'override ^ 2' classified: '*foobarbaz'.	self class compile: 'override ^ 3' classified: self mockOverrideMethodCategory.	self class compile: 'override ^ 4' classified: self mockOverrideMethodCategory.	definition := (MethodReference class: self class selector: #override) asMethodDefinition.	self assert: definition isOverrideMethod.	self assert: self override = 4.	definition unload.	self assert: self override = 2.	self assert: (MethodReference class: self class selector: #override) category = '*foobarbaz'.	! !!MCDirectoryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'ab 7/6/2003 12:53'!tearDown	self directory recursiveDelete! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'nice 12/27/2009 20:37'!testDirectoryExistsWhenLikeNamedFileExists[ | testFileName |testFileName := self myAssuredDirectory fullNameFor: 'zDirExistsTest.testing'.(FileStream newFileNamed: testFileName) close.self should: [FileStream isAFileNamed: testFileName].self shouldnt: [(FileDirectory on: testFileName) exists]]ensure: [self myAssuredDirectory deleteFileNamed: 'zDirExistsTest.testing']! !!MCAncestryTest methodsFor: 'tests' stamp: 'jf 8/16/2003 20:42'!testPathToMissingAncestor	self assert: (self tree allAncestorsOnPathTo: MCVersionInfo new) isEmpty! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoOutsideTempNotInlined	| block temp |	block := [ :index | 		temp := index. 		collection add: [ temp ] ].	1 to: 5 do: block.	self assertValues: #(5 5 5 5 5)! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 12/5/2002 00:27'!testComplexConflictlessMerge	self 		assertMerge: #(a1 b1 d1)				with: #(a2 c1)				base: #(a1 c1 d1)								gives: #(a2 b1)				conflicts: #()! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testDefinitionString	| d |	d := self mockClassA asClassDefinition.	self assert: d definitionString = self mockClassA definition.! !!FileDirectoryTest methodsFor: 'resources' stamp: 'hg 2/2/2002 16:42'!myLocalDirectoryName	^'zTestDir'! !!TextDiffBuilderTest methodsFor: 'private' stamp: 'klub 12/28/2009 00:04'!convertToString: array	^String streamContents: [ :stream |		array do: [ :each |			stream nextPutAll: each asString; cr ] ]! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/20/2008 09:40'!methodWithCopiedAndAssignedTemps	| blk "0w" a "0w" b "0w" c "0w" t "0w" r1 "0w" r2 "0w" |	a := 1. "1w"	b := 2. "1w"	c := 4. "1w"	t := 0. "1w"	blk "5w" := ["2" t  "3w" := t "3r" + a "3r" + b "3r" + c "3r" ] "4".	r1 "5w" := blk "5r" value.	b "5w" := -100.	r2 "5w" := blk "5r" value.	^r1 "5r" -> r2 "5r" -> t "5r"	"a: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read	 b: main(read(),write(0,1,5)), block(read(3),write()) => remote; write follows contained read	 blk: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 c: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read	 r1: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 r2: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 t: main(read(5),write(0,1)), block(read(3),write(3)) => remote; read follows contained write"	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedAndAssignedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!MCMockClassA class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 02:31'!cVar	^ CVar! !!MCClassDefinitionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 18:01'!restoreClassAComment	Smalltalk 		at: #MCMockClassA 		ifPresent: [:a | a classComment: self classAComment stamp: self classACommentStamp]! !!ClosureCompilerTest methodsFor: 'source' stamp: 'eem 7/1/2009 10:51'!closureCases	^#('| n |n := 1.^n + n''| i |i := 0.[i := i + 1. i <= 10] whileTrue.^i''[:c :s| | mn |mn := Compiler new		compile: (c sourceCodeAt: s)		in: c		notifying: nil		ifFail: [self halt].mn generate: #(0 0 0 0).{mn blockExtentsToTempsMap.  mn encoder schematicTempNames}]			value: AbstractInstructionTests			value: #runBinaryConditionalJumps:''inject: thisValue into: binaryBlock	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue''runBinaryConditionalJumps: assertPrintBar	"CogIA32CompilerTests new runBinaryConditionalJumps: false"	| mask reg1 reg2 reg3 |	mask := 1 << self processor bitsInWord - 1.	self concreteCompilerClass dataRegistersWithAccessorsDo:		[:n :get :set|		n = 0 ifTrue: [reg1 := get].		n = 1 ifTrue: [reg2 := set].		n = 2 ifTrue: [reg3 := set]].	#(	(JumpAbove > unsigned)			(JumpBelowOrEqual <= unsigned)		(JumpBelow < unsigned)			(JumpAboveOrEqual >= unsigned)		(JumpGreater > signed)			(JumpLessOrEqual <= signed)		(JumpLess < signed)				(JumpGreaterOrEqual >= signed)		(JumpZero = signed)				(JumpNonZero ~= signed)) do:		[:triple|		[:opName :relation :signednessOrResult| | opcode jumpNotTaken jumpTaken nop memory bogus |		self resetGen.		opcode := CogRTLOpcodes classPool at: opName.		self gen: CmpRR operand: 2 operand: 1.		jumpTaken := self gen: opcode.		self gen: MoveCqR operand: 0 operand: 0.		jumpNotTaken := self gen: Jump.		jumpTaken jmpTarget: (self gen: MoveCqR operand: 1 operand: 0).		jumpNotTaken jmpTarget: (nop := self gen: Nop).		memory := self generateInstructions.		bogus := false.		self pairs: (-2 to: 2)  do:			[:a :b| | taken |			self processor				reset;				perform: reg2 with: a signedIntToLong;				perform: reg3 with: b signedIntToLong.			[self processor singleStepIn: memory.			 self processor pc ~= nop address] whileTrue.			taken := (self processor perform: reg1) = 1.			assertPrintBar				ifTrue:					[self assert: taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b])]				ifFalse:					[Transcript						nextPutAll: reg2; nextPut: $(; print: a; nextPutAll: '') ''; nextPutAll: relation; space;						nextPutAll: reg3; nextPut: $(; print: b; nextPutAll: '') = '';						print: taken; cr; flush.					 taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b]) ifFalse:						[bogus := true]]].			 bogus ifTrue:				[self processor printRegistersOn: Transcript.				 Transcript show: (self processor disassembleInstructionAt: jumpTaken address In: memory); cr]]					valueWithArguments: triple]''mapFromBlockStartsIn: aMethod toTempVarsFrom: schematicTempNamesString constructor: aDecompilerConstructor	| map |	map := aMethod				mapFromBlockKeys: aMethod startpcsToBlockExtents keys asSortedCollection				toSchematicTemps: schematicTempNamesString.	map keysAndValuesDo:		[:startpc :tempNameTupleVector| | subMap tempVector numTemps |		subMap := Dictionary new.		"Find how many temp slots there are (direct & indirect temp vectors)		 and for each indirect temp vector find how big it is."		tempNameTupleVector do:			[:tuple|			tuple last isArray				ifTrue:					[subMap at: tuple last first put: tuple last last.					 numTemps := tuple last first]				ifFalse:					[numTemps := tuple last]].		"create the temp vector for this scope level."		tempVector := Array new: numTemps.		"fill it in with any indirect temp vectors"		subMap keysAndValuesDo:			[:index :size|			tempVector at: index put: (Array new: size)].		"fill it in with temp nodes."		tempNameTupleVector do:			[:tuple| | itv |			tuple last isArray				ifTrue:					[itv := tempVector at: tuple last first.					 itv at: tuple last last						put: (aDecompilerConstructor								codeTemp: tuple last last - 1								named: tuple first)]				ifFalse:					[tempVector						at: tuple last						put: (aDecompilerConstructor								codeTemp: tuple last - 1								named: tuple first)]].		"replace any indirect temp vectors with proper RemoteTempVectorNodes"		subMap keysAndValuesDo:			[:index :size|			tempVector				at: index				put: (aDecompilerConstructor						codeRemoteTemp: index						remoteTemps: (tempVector at: index))].		"and update the entry in the map"		map at: startpc put: tempVector].	^map' 'gnuifyFrom: inFileStream to: outFileStream"convert interp.c to use GNU features"	| inData beforeInterpret inInterpret inInterpretVars beforePrimitiveResponse inPrimitiveResponse |	inData := inFileStream upToEnd withSqueakLineEndings.	inFileStream close.	"print a header"	outFileStream		nextPutAll: ''/* This file has been post-processed for GNU C */'';		cr; cr; cr.	beforeInterpret := true.    "whether we are before the beginning of interpret()"	inInterpret := false.     "whether we are in the middle of interpret"	inInterpretVars := false.    "whether we are in the variables of interpret"	beforePrimitiveResponse := true.  "whether we are before the beginning of primitiveResponse()"	inPrimitiveResponse := false.   "whether we are inside of primitiveResponse"	''Gnuifying''		displayProgressAt: Sensor cursorPoint		from: 1 to: (inData occurrencesOf: Character cr)		during:			[:bar | | lineNumber |			lineNumber := 0.			inData linesDo:				[ :inLine | | outLine extraOutLine caseLabel |				bar value: (lineNumber := lineNumber + 1).				outLine := inLine. 	"print out one line for each input line; by default, print out the line that was input, but some rules modify it"				extraOutLine := nil.   "occasionally print a second output line..."				beforeInterpret ifTrue: [					inLine = ''#include "sq.h"'' ifTrue: [						outLine := ''#include "sqGnu.h"'' ].					inLine = ''interpret(void) {'' ifTrue: [						"reached the beginning of interpret"						beforeInterpret := false.						inInterpret := true.						inInterpretVars := true ] ]				ifFalse: [				inInterpretVars ifTrue: [					(inLine findString: ''register struct foo * foo = &fum;'') > 0 ifTrue: [						outLine := ''register struct foo * foo FOO_REG = &fum;'' ].					(inLine findString: '' localIP;'') > 0 ifTrue: [						outLine := ''    char* localIP IP_REG;'' ].					(inLine findString: '' localFP;'') > 0 ifTrue: [						outLine := ''    char* localFP FP_REG;'' ].					(inLine findString: '' localSP;'') > 0 ifTrue: [						outLine := ''    char* localSP SP_REG;'' ].					(inLine findString: '' currentBytecode;'') > 0 ifTrue: [						outLine := ''    sqInt currentBytecode CB_REG;'' ].					inLine isEmpty ifTrue: [						"reached end of variables"						inInterpretVars := false.						outLine := ''    JUMP_TABLE;''.						extraOutLine := inLine ] ]				ifFalse: [				inInterpret ifTrue: [					"working inside interpret(); translate the switch statement"					(inLine beginsWith: ''		case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''		CASE('', caseLabel, '')'' ].					inLine = ''			break;'' ifTrue: [						outLine := ''			BREAK;'' ].					inLine = ''}'' ifTrue: [						"all finished with interpret()"						inInterpret := false ] ]				ifFalse: [				beforePrimitiveResponse ifTrue: [					(inLine beginsWith: ''primitiveResponse('') ifTrue: [						"into primitiveResponse we go"						beforePrimitiveResponse := false.						inPrimitiveResponse := true.						extraOutLine := ''    PRIM_TABLE;'' ] ]				ifFalse: [				inPrimitiveResponse ifTrue: [					inLine = ''	switch (primitiveIndex) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					inLine = ''	switch (GIV(primitiveIndex)) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					(inLine beginsWith: ''	case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''	CASE('', caseLabel, '')'' ].					inLine = ''}'' ifTrue: [						inPrimitiveResponse := false ] ]				] ] ] ].				outFileStream nextPutAll: outLine; cr.				extraOutLine ifNotNil: [					outFileStream nextPutAll: extraOutLine; cr ]]].	outFileStream close' )! !!MCMockClassD methodsFor: 'as yet unclassified' stamp: 'cwp 7/8/2003 21:21'!one	^ 1! !!MCFileInTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!assertInitializersCalled	| cvar |	cvar := self mockClassA cVar.	self assert: cvar = #initialized! !!MCMockDependency methodsFor: 'accessing' stamp: 'cwp 11/7/2004 14:43'!children	^ children collect: [:ea | self class fromTree: ea]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesTAtoTM	self decompileClassesSelect: [:cn| cn first = $T and: [cn second asUppercase <= $M]]! !!MCFileInTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:30'!assertSuccessfulLoadWith: aBlock	stream reset.	aBlock value.	self assertNoChange.	self assertInitializersCalled.! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithOneListener	| value |	eventSource		when: #needsValue		send: #yourself		to: eventListener.	value := eventSource triggerEvent: #needsValue.	self should: [value == eventListener]! !!MCDependencySorterTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertItems: anArray orderAs: depOrder withRequired: missingDeps toLoad: unloadableItems extraProvisions: provisions	| order sorter items missing unloadable |	items := anArray collect: [:ea | self itemWithSpec: ea].	sorter := MCDependencySorter items: items.	sorter addExternalProvisions: provisions.	order := (sorter orderedItems collect: [:ea | ea name]) asArray.	self assert: order = depOrder.	missing := sorter externalRequirements.	self assert: missing asSet = missingDeps asSet.	unloadable := (sorter itemsWithMissingRequirements collect: [:ea | ea name]) asArray.	self assert: unloadable asSet = unloadableItems asSet! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/10/2003 02:05'!mockClassA	^ Smalltalk at: #MCMockClassA! !!CompilerTest methodsFor: 'literals' stamp: 'nice 12/3/2007 22:20'!testScaledDecimalLiterals	"Equal ScaledDecimal with different scales should use different slots	This is related to http://bugs.squeak.org/view.php?id=6797"		"This correctly works when evaluated separately"	self deny: (Compiler evaluate: '0.5s1') scale = (Compiler evaluate: '0.5s2') scale.		"But not when evaluated together if literal reduction is too agressive"	self deny: (Compiler evaluate: '0.5s1 scale =  0.5s2 scale').! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 8/1/2003 20:27'!mockPackage	^ MCSnapshotResource mockPackage! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:36'!testMethodTemp	| block1 block2 |	block1 := self methodArgument: 1.	block2 := self methodArgument: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 16:58'!supportTestSourceRangeAccessForDecompiledInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	':= t1'								'do: [:t4 | t3 := t2 value: t3 value: t4]'								'value: t3 value: t4'								':= t2 value: t3 value: t4'								']'								'value: t3 value: t4'								':= t2 value: t3 value: t4'								']'								'^t3')! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/9/2009 11:00'!testInlineBlockCollectionLR3	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].	self assert: (col collect: [ :each | each value ]) asArray = (2 to: 12) asArray! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleReturn	self assertSuccess: (ExceptionTester new runTest: #simpleReturnTest ) ! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 4/27/2004 23:19'!testFileDirectoryNamed	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory root directoryNamed: 'C:'.	self assert: fd pathName = 'C:'.! !!MCMockDependency methodsFor: 'resolving' stamp: 'cwp 11/7/2004 14:42'!hasResolution	^ hasResolution! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 12/27/2009 20:58'!assertAListMatches: strings	| listMorphs |	listMorphs := self listMorphs.	listMorphs 		detect: [:m | | list |			list := m getList. (list size = strings size) and: [list includesAllOf: strings]]		ifNone: [self assert: false].! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertVersionsMatchWith: writerClass	| stream readerClass expected actual |	readerClass := writerClass readerClass.	expected := self mockVersion.	stream := RWBinaryOrTextStream on: String new.	writerClass fileOut: expected on: stream.	actual := readerClass versionFromStream: stream reset.	self assertVersion: actual matches: expected.! !!MCTestCase methodsFor: 'mocks' stamp: 'avi 1/19/2004 15:15'!mockVersionWithDependencies	^ MCVersion 		package: self mockPackage		info: self mockVersionInfo		snapshot: self mockSnapshot		dependencies: self mockDependencies! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertDependenciesMatchWith: writerClass	| stream readerClass expected actual |	readerClass := writerClass readerClass.	expected := self mockVersionWithDependencies.	stream := RWBinaryOrTextStream on: String new.	writerClass fileOut: expected on: stream.	actual := (readerClass on: stream reset) dependencies.	self assert: actual = expected dependencies.! !!EventManagerTest methodsFor: 'running-copying' stamp: 'SqR 11/12/2000 19:38'!testCopy	"Ensure that the actionMap is zapped when	you make a copy of anEventManager"	eventSource when: #blah send: #yourself to: eventListener.	self assert: eventSource actionMap keys isEmpty not.	self assert: eventSource copy actionMap keys isEmpty! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classAComment	^ self mockClassA organization classComment.! !!MCWorkingCopyTest methodsFor: 'private' stamp: 'cwp 8/2/2003 15:03'!packageName	^ self mockPackage name! !!MCSortingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testConsistentSorting	| definitions shuffledAndSorted|	definitions :=		{self methodNamed: #a class: #A meta: false.		self methodNamed: #a class: #A meta: true.		self methodNamed: #a class: #B meta: false.		self methodNamed: #b class: #A meta: false.		self methodNamed: #b class: #B meta: false.		self classNamed: #A.		self classNamed: #B}.	shuffledAndSorted :=		(1 to: 100) collect: [:ea | self sortDefinitions: definitions shuffled].	self assert: shuffledAndSorted asSet size = 1.! !!MCDependencySorterTest methodsFor: 'building' stamp: 'ab 5/24/2003 14:08'!itemWithSpec: anArray	^ MCMockDependentItem new		name: anArray first;		provides: anArray second;		requires: anArray third! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'stephaneducasse 2/4/2006 20:47'!morphsOfClass: aMorphClass	| morphs |	morphs := OrderedCollection new.	morph allMorphsDo: [:m | (m isKindOf: aMorphClass) ifTrue: [morphs add: m]].	^ morphs! !!MCDirtyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!classes	^ Array new: 0.! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationAfterNotInlined	| index block |	index := 0.	block := [ 		collection add: [ index ].		index := index + 1 ].	[ index < 5 ] whileTrue: block.	self assertValues: #(5 5 5 5 5)! !!EventManagerTest methodsFor: 'running-dependent value' stamp: 'JWS 9/7/2000 17:21'!testReturnValueWithNoListeners	| value |	value := eventSource triggerEvent: #needsValue.	self should: [value == nil]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesBNtoBZ	self decompileClassesSelect: [:cn| cn first = $B and: [cn second asUppercase > $M]]! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:29'!testWithAllUnresolved	self 		assert: #withAllDependenciesDo:ifUnresolved: 		orders: #(a ((b (d e)) (c missing)))		as: #(d e b a)		unresolved: #(c)! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForClosureLongFormBytecodeInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForClosureLongFormBytecodeInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForLongFormV3PlusClosures;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:56'!testWithAllMissing	self 		assert: #withAllDependenciesDo: 		orders: #(a ((b (d e)) (c missing))) 		as: #(d e b a)! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testRepeatedMerge	| base mother1 mother2 inst |	base :=  self snapshot.	self change: #one toReturn: 2.	mother1 :=  self snapshot.	self change: #two toReturn: 3.	mother2 :=  self snapshot.			self load: base.	self change: #truth toReturn: false.	self snapshot.	inst := self mockInstanceA.	self assert: inst one = 1.	self assert: inst two = 2.		self merge: mother1.	self assert: inst one = 2.	self assert: inst two = 2.			self change: #one toReturn: 7.	self assert: inst one = 7.	self assert: inst two = 2.		self shouldnt: [self merge: mother2] raise: Error.	self assert: inst one = 7.	self assert: inst two = 3.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'Igor.Stasenko 12/20/2009 07:19'!testDecompiledDoitMethodTempNames	"self new testDecompiledDoitMethodTempNames"	"Test that a decompiled doit that has been copied with temps decompiles to the input"	| removeComments |	removeComments := [:n| n comment: nil].	self closureCases do:		[:source| | mns m mps mnps |		"Need to compare an ungenerated tree with the generated method's methodNode		 because generating code alters the tree when it introduces remote temp vectors."		mns := #(first last) collect:					[:ignored|					source first isLetter						ifTrue:							[self class compilerClass new								compile: source								in: self class								notifying: nil								ifFail: [self error: 'compilation error']]						ifFalse:							[self class compilerClass new								compileNoPattern: source								in: self class								context: nil								notifying: nil								ifFail: [self error: 'compilation error']]].		m := (mns last generateWithTempNames).		removeComments value: mns first.		mns first nodesDo: removeComments.		self assert: (mnps := mns first printString) = (mps := m methodNode printString)]! !!MCSortingTest methodsFor: 'building' stamp: 'ab 4/8/2003 18:03'!methodNamed: aSymbol class: className meta: aBoolean	^ MCMethodDefinition		className: className		classIsMeta: aBoolean		selector: aSymbol		category: ''		timeStamp: ''		source: ''! !!MCEmptyPackageInfo methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!classes	^ #()! !!MCSnapshotTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testCreation	|d|	d :=  self mockSnapshot definitions.	self assert: (d anySatisfy: [:ea | ea isClassDefinition and: [ea className = #MCMockClassA]]).	self assert: (d anySatisfy: [:ea | ea isMethodDefinition and: [ea selector = #mockClassExtension]]).	self assert: (d allSatisfy: [:ea | ea isClassDefinition not or: [ea category endsWith: 'Mocks']]).	! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesQNtoQZ	self decompileClassesSelect: [:cn| cn first = $Q and: [cn second asUppercase > $M]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/24/2009 11:51'!testInlineBlockCollectionEM1	| a1 b1 i1 a2 b2 i2 we wb |	b1 := OrderedCollection new.	i1 := 1.	[a1 := i1.	 i1 <= 3] whileTrue:		[b1 add: [a1].		i1 := i1 + 1].	b1 := b1 asArray collect: [:b | b value].	b2 := OrderedCollection new.	i2 := 1.	we := [a2 := i2. i2 <= 3].	wb := [b2 add: [a2]. i2 := i2 + 1].	we whileTrue: wb. "defeat optimization"	b2 := b2 asArray collect: [:b | b value].	self assert: b1 = b2! !!MCMockDependency methodsFor: 'mocks' stamp: 'cwp 11/7/2004 14:41'!mockVersionInfo	^ MCVersionInfo		name: self name		id: (self uuidForName: name)		message: ''		date: nil		time: nil		author: ''		ancestors: #()! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:23'!test3	self assert: (MCScanner scan: '(a #b c)' readStream) = #(a #b c)! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/13/2003 02:53'!falsehoodMethodSource	^ 'falsehood	^ false'! !!MCAncestryTest methodsFor: 'tests' stamp: 'avi 9/17/2005 21:08'!testCommonAncestors	self assertCommonAncestorOf: #a2 and: #e2 is: #a1 in: self tree.	self assertCommonAncestorOf: #e2 and: #b3 is: #a1 in: self tree.	self assertCommonAncestorOf: #b2 and: #e2 is: #'00' in: self tree.		self assertCommonAncestorOf: #a4 and: #b5 in: #(b2 a1) in: self twoPersonTree.	self assertCommonAncestorOf: #b5 and: #b3 is: #b2 in: self twoPersonTree.	self assertCommonAncestorOf: #b2 and: #a4 is: #b2 in: self twoPersonTree.	self assertCommonAncestorOf: #b2 and: #b2 is: #b2 in: self twoPersonTree.	self assertCommonAncestorOf: #b2 and: #a1 is: #a1 in: self twoPersonTree.	self assertCommonAncestorOf: #a1 and: #b2 is: #a1 in: self twoPersonTree.! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 09:21'!nonResumableFallOffTheEndHandlerResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingExceptionalString;		add: self doYetAnotherThingString;		yourself! !!MCMockClassA methodsFor: 'boolean' stamp: 'cwp 7/13/2003 02:49'!falsehood	^ false! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:40'!testCategorySelected	self clickOnListItem: self mockCategoryName.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self denyAListIncludesAnyOf: self allProtocols.	self denyAListIncludesAnyOf: self allMethods.	self assertTextIs: ''.! !!ExceptionTests methodsFor: 'private' stamp: 'md 3/25/2003 23:40'!assertSuccess: anExceptionTester	self should: [ ( anExceptionTester suiteLog first) endsWith:  'succeeded'].! !!MCStReaderTest methodsFor: 'as yet unclassified' stamp: 'ab 8/17/2003 16:52'!commentWithoutStyle	^ 'CharacterScanner subclass: #CanvasCharacterScanner	instanceVariableNames: ''canvas fillBlt foregroundColor runX lineY ''	classVariableNames: ''''	poolDictionaries: ''''	category: ''Morphic-Support''!!!!CanvasCharacterScanner commentStamp: ''<historical>'' prior: 0!!A displaying scanner which draws its output to a Morphic canvas.!!!!CanvasCharacterScanner methodsFor: ''stop conditions'' stamp: ''ar 12/15/2001 23:27''!!setStopConditions	"Set the font and the stop conditions for the current run."	self setFont.	stopConditions		at: Space asciiValue + 1		put: (alignment = Justified ifTrue: [#paddedSpace])!! !!'! !!FileDirectoryTest methodsFor: 'existence tests' stamp: 'stephaneducasse 2/4/2006 20:31'!testNonExistentDirectory	| directory parentDirectory |	directory :=FileDirectory default				directoryNamed: 'nonExistentFolder'.	self shouldnt: [directory exists] 		description: 'A FileDirectory instance should know if it points to a non-existent directory.'.	parentDirectory :=FileDirectory default.	self shouldnt: [parentDirectory directoryExists: 'nonExistentFolder'] 		description: 'A FileDirectory instance should know when a directory of the given name doesn''t exist'.! !!MCMockClassA methodsFor: 'boolean' stamp: 'ab 7/7/2003 23:21'!moreTruth	^ true! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationBeforeNotInlined	| index block |	index := 0.	block := [ 		index := index + 1.		collection add: [ index ] ].	[ index < 5 ] whileTrue: block.	self assertValues: #(5 5 5 5 5)! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertClass: readerClass providesServices: labels	| services suffix |	suffix := readerClass extension.	self assert: (FileList isReaderNamedRegistered: readerClass name).	services := readerClass fileReaderServicesForFile: 'foo' suffix: suffix.	self assert: ((services collect: [:service | service buttonLabel]) includesAllOf: labels)! !!MCChangeNotificationTest methodsFor: 'tests' stamp: 'bf 5/20/2005 17:05'!testExtMethodModified	| event mref |	workingCopy modified: false.	mref := workingCopy packageInfo extensionMethods first.	event := self modifiedEventFor: mref methodSymbol ofClass: mref actualClass.	MCWorkingCopy methodModified: event.	self assert: workingCopy modified! !!MCDictionaryRepositoryTest methodsFor: 'as yet unclassified' stamp: 'ab 8/16/2003 17:53'!addVersion: aVersion	dict at: aVersion info put: aVersion! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesJAtoJM	self decompileClassesSelect: [:cn| cn first = $J and: [cn second asUppercase <= $M]]! !!ExceptionTester methodsFor: 'accessing' stamp: 'brp 10/21/2004 17:15'!iterationsBeforeTimeout	^ iterationsBeforeTimeout! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/14/2009 00:05'!testFileIndexFromSourcePointer	"Test derivation of file index for sources or changes file from source pointers"	| sf |	sf := StandardSourceFileArray new.	"sources file mapping"	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r1FFFFFF).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000000).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3000013).	self assert: 1 = (sf fileIndexFromSourcePointer: 16r3FFFFFF).	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	(16r3000000 to: 16r3FFFFFF by: 811) do: [:e | self assert: 1 = (sf fileIndexFromSourcePointer: e)].	"changes file mapping"	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r2FFFFFF).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000000).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4000013).	self assert: 2 = (sf fileIndexFromSourcePointer: 16r4FFFFFF).	(16r2000000 to: 16r2FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	(16r4000000 to: 16r4FFFFFF by: 811) do: [:e | self assert: 2 = (sf fileIndexFromSourcePointer: e)].	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000000).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0000013).	self assert: 0 = (sf fileIndexFromSourcePointer: 16r0FFFFFF)! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/26/2009 14:56'!testFilePositionFromSourcePointer	"Test derivation of file position for sources or changes file from source pointers"	| sf |	sf := ExpandedSourceFileArray new.	"sources file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r1000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r1000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r1FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r3000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r3000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r3FFFFFF).	"changes file"	self assert: 0 = (sf filePositionFromSourcePointer: 16r2000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r2000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r2FFFFFF).	self assert: 16r1000000 = (sf filePositionFromSourcePointer: 16r4000000).	self assert: 16r1000013 = (sf filePositionFromSourcePointer: 16r4000013).	self assert: 16r1FFFFFF = (sf filePositionFromSourcePointer: 16r4FFFFFF).	"the following numeric ranges are unused but currently produces results as follows"	self assert: 0 = (sf filePositionFromSourcePointer: 16r0000000).	self assert: 16r13 = (sf filePositionFromSourcePointer: 16r0000013).	self assert: 16rFFFFFF = (sf filePositionFromSourcePointer: 16r0FFFFFF)! !!MCMockDependency methodsFor: 'resolving' stamp: 'cwp 11/7/2004 14:16'!resolve	^ self hasResolution		ifTrue: [MCVersion new					setPackage: MCSnapshotResource mockPackage					info: self mockVersionInfo					snapshot: MCSnapshotResource current snapshot					dependencies: self children]		ifFalse: [nil]! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:14'!doSomethingElse	self log: self doSomethingElseString! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'cwp 8/25/2009 20:22'!testUndeclaredVariable	self 		should: 			[self class 				compile: 'griffle ^ goo'				notifying: self]		raise: UndeclaredVariable! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'bf 5/20/2005 16:15'!<= other	^ self name <= other name! !!MCRepositoryTest methodsFor: 'accessing' stamp: 'ab 7/7/2003 14:32'!snapshotAt: aVersionInfo	^ (repository versionWithInfo: aVersionInfo) snapshot! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'JWS 9/7/2000 17:21'!testMultipleValueSuppliers	eventSource		when: #needsValue		send: #getFalse		to: self.	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:11'!testClassMethodDefinition	writer visitMethodDefinition: (MethodReference class: self mockClassA class selector: #one) 									asMethodDefinition.	self assertContentsOf: stream match: self expectedClassMethodDefinition.	stream reset.	self assert: stream nextChunk isAllSeparators.	self assertChunkIsWellFormed: stream nextChunk.	self assertMethodChunkIsWellFormed: stream nextChunk.	self assert: stream nextChunk isAllSeparators ! !!MCSerializationTest methodsFor: 'mocks' stamp: 'stephaneducasse 2/4/2006 20:47'!mockDiffyVersion	| repos workingCopy base next |	repos := MCDictionaryRepository new.	workingCopy := MCWorkingCopy forPackage: self mockPackage.	workingCopy repositoryGroup addRepository: repos.	MCRepositoryGroup default removeRepository: repos.	base := self mockVersion.	repos storeVersion: base.	self change: #a toReturn: 'a2'.	next := self mockVersionWithAncestor: base.	^ next asDiffAgainst: base	! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'bf 5/20/2005 16:54'!includesClass: aClass	^self classes includes: aClass! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'dtl 12/22/2009 23:05'!testAddressRange	"Test source pointer to file position address translation across a wide address range"		| sf i p a |	sf := ExpandedSourceFileArray new.	(16r1000000 to: 16r10000000 by: 4093) do: [:e |		i := sf fileIndexFromSourcePointer: e.		p := sf filePositionFromSourcePointer: e.		a := sf sourcePointerFromFileIndex: i andPosition: p.		self assert: a = e]! !!MCMockClassA methodsFor: 'numeric' stamp: 'avi 9/11/2004 15:59'!two	^ 2! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesYAtoYM	self decompileClassesSelect: [:cn| cn first = $Y and: [cn second asUppercase <= $M]]! !!ClosureTests methodsFor: 'utilities' stamp: 'lr 3/9/2009 16:48'!assertValues: anArray	| values |	values := collection collect: [ :each | each value ].	self 		assert: anArray asArray = values asArray		description: 'Expected: ' , anArray asArray printString , 			', but got ' , values asArray printString! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'cwp 8/25/2009 20:22'!selectionInterval	^ 1 to: 0! !!MCDirtyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:45'!wantsChangeSetLogging	^ false! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 09:12'!buttonMorphs	^ self morphsOfClass: PluggableButtonMorph! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!name	^ name! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testAddressRange	"Test source pointer to file position address translation across the full address range"		| sf |	sf := StandardSourceFileArray new.	(16r1000000 to: 16r4FFFFFF by: 811) do: [:e | | i a p |		i := sf fileIndexFromSourcePointer: e.		p := sf filePositionFromSourcePointer: e.		a := sf sourcePointerFromFileIndex: i andPosition: p.		self assert: a = e]! !!ExceptionTester methodsFor: 'tests' stamp: 'brp 10/22/2004 12:00'!simpleNoTimeoutTest	[ self doSomething ]		valueWithin: 1 day onTimeout:			[ self doSomethingElse ].	! !!ExceptionTester methodsFor: 'accessing' stamp: 'tfei 6/7/1999 15:03'!log	log == nil		ifTrue: [log := OrderedCollection new].	^log! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testInstallFromStream	| stream |	stream := RWBinaryOrTextStream on: String new.	MCMczWriter fileOut: expected on: stream.	MczInstaller installStream: stream reset.	self assertNoChange.	self assertVersionInfoPresent.	! !!MCSerializationTest methodsFor: 'testing' stamp: 'avi 1/19/2004 15:14'!testMczSerialization	self assertVersionsMatchWith: MCMczWriter.	self assertExtensionProvidedBy: MCMczWriter.	self assertVersionInfosMatchWith: MCMczWriter.	self assertDependenciesMatchWith: MCMczWriter.! !!MCTestCase methodsFor: 'asserting' stamp: 'cwp 8/8/2003 14:58'!assertPackage: actual matches: expected	self assert: actual = expected! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!testKindOfSubclass	| classes |	classes := {self mockClassA. String. MethodContext. WeakArray. Float}.	classes do: [:c | | d |		d :=  c asClassDefinition.		self assert: d kindOfSubclass = c kindOfSubclass.	].! !!MCEmptyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:45'!wantsChangeSetLogging	^ false! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesONtoOZ	self decompileClassesSelect: [:cn| cn first = $O and: [cn second asUppercase > $M]]! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getTrue: anArg	^true! !!MCSnapshotResource class methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:18'!mockPackage	^ (MCPackage new name: self mockPackageName)! !!MCVersionTest methodsFor: 'tests' stamp: 'cwp 11/7/2004 14:25'!testPostOrder	self 		assert: #allDependenciesDo: 		orders: #(a ((b (d e)) c)) 		as: #(d e b c)! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 21:59'!testNonResumableOuter	self should: [		[Error signal. 4] 			on: Error 			do: [:ex | ex outer. ex return: 5]		] raise: Error! !!MCSnapshotBrowserTest methodsFor: 'running' stamp: 'stephaneducasse 2/4/2006 20:47'!setUp	model := MCSnapshotBrowser forSnapshot: MCSnapshotResource current snapshot.	morph := model buildWindow.! !!ContextCompilationTest methodsFor: 'tests' stamp: 'eem 6/19/2008 10:11'!testVariablesAndOffsetsDo	"ContextCompilationTest new testVariablesAndOffsetsDo"	| contextClasses |	contextClasses := ContextPart withAllSuperclasses, ContextPart allSubclasses asArray.	contextClasses do:		[:class|		class variablesAndOffsetsDo:			[:var :offset|			self assert: offset < 0.			self assert: (class instVarNameForIndex: offset negated) == var]].	InstructionStream withAllSuperclasses, InstructionStream allSubclasses asArray do:		[:class|		(contextClasses includes: class) ifFalse:			[class variablesAndOffsetsDo:				[:var :offset|				(InstructionStream instVarNames includes: var) ifFalse:					[self assert: offset > 0.					 self assert: (class instVarNameForIndex: offset) == var]]]]! !!MCTestCase methodsFor: 'mocks' stamp: 'cwp 7/30/2003 19:23'!mockVersion	^ MCVersion 		package: self mockPackage		info: self mockVersionInfo		snapshot: self mockSnapshot! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'Igor.Stasenko 12/20/2009 03:57'!testInjectIntoDecompiledDebugs	"Test various debugs of the decompiled form debug correctly."	"self new testInjectIntoDecompiledDebugs"	| source |	source := (Collection sourceCodeAt: #inject:into:) asString.	{ Encoder.	   EncoderForV3PlusClosures. EncoderForLongFormV3PlusClosures } do:		[:encoderClass| | method |		method := (Parser new							encoderClass: encoderClass;							parse: source							class: Collection)						generate.		self supportTestSourceRangeAccessForDecompiledInjectInto: method source: method decompileString]! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:04'!testFileDirectoryDirectoryEntry	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: fd directoryEntry notNil.! !!MCAncestryTest methodsFor: 'building' stamp: 'jf 8/16/2003 21:21'!tree	^ self treeFrom:		#(c1			((e2				((e1					((a1						(('00')))))))			(a2				((a1					(('00')))))			(b3				((b2					((b1						((b0							(('00')))))))				(a1					(('00')))))			(d1)))! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesHAtoHM	self decompileClassesSelect: [:cn| cn first = $H and: [cn second asUppercase <= $M]]! !!MCOrganizationTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testReorderingWithRemovals	|dec cats newCats |	dec := MCOrganizationDefinition categories: #(A B C).	cats := #(X Y B Z C A Q).	newCats := dec reorderCategories: cats original: #(Y B C A Q).	self assert: newCats asArray = #(X A B C Z).! !!MCMockDependency methodsFor: 'comparing' stamp: 'cwp 11/7/2004 13:32'!= other	^ self name = other name! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:43'!testLocalRemoveRemoteModify	self assertMerge: #(b1)				with: #(a1 b1)				base: #(a2 b1)								gives: #(a1 b1)				conflicts: #((a1 removed)).	self assertMerge: #(b1)				with: #(a2 b1)				base: #(a1 b1)								gives: #(a2 b1)				conflicts: #((a2 removed)).! !!MCFileInTest methodsFor: 'testing' stamp: 'avi 2/17/2004 03:21'!assertFileOutFrom: writerClass canBeFiledInWith: aBlock	(writerClass on: stream) writeSnapshot: self mockSnapshot.	self alterInitialState.	self assertSuccessfulLoadWith: aBlock.	self mockPackage unload.	self assertSuccessfulLoadWith: aBlock.! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:12'!methodWithVariousTemps	| classes total totalLength |	classes := self withAllSuperclasses.	total := totalLength := 0.	classes do: [:class| | className |		className := class name.		total := total + 1.		totalLength := totalLength + className size].	^total -> totalLength	"Parser new		parse: (self class sourceCodeAt: #methodWithVariousTemps)		class: self class"! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForBlueBookInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForBlueBookInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForV3;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!MCFileInTest methodsFor: 'testing' stamp: 'cwp 8/10/2003 02:08'!alterInitialState	self mockClassA touchCVar! !!MacFileDirectoryTest methodsFor: 'test' stamp: 'sd 10/27/2003 18:02'!testMakeAbsolute	self assert: (MacFileDirectory isAbsolute: (MacFileDirectory makeAbsolute: 'Data')).	self assert: (MacFileDirectory isAbsolute: (MacFileDirectory makeAbsolute: ':Data')).! !!MCMockDefinition class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!token: aString	^ self new token: aString! !!MCMockClassA methodsFor: 'numeric' stamp: 'cwp 8/2/2003 17:26'!one	^ 1! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 08:46'!testProtocolIsCleared	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockASubclass'.	self clickOnListItem: 'as yet unclassified'.	self clickOnListItem: 'MCMockClassA'.		self denyAListHasSelection: 'as yet unclassified'.! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesWAtoWM	self decompileClassesSelect: [:cn| cn first = $W and: [cn second asUppercase <= $M]]! !!MCMockDependency methodsFor: 'accessing' stamp: 'stephaneducasse 2/4/2006 20:47'!initializeWithTree: expr	expr isSymbol		ifTrue: [name := expr.				children := Array new.				hasResolution := true.]		ifFalse: [name := expr first.				expr second isSymbol					ifTrue: [hasResolution := false.							children := Array new]					ifFalse: [hasResolution := true.							children := expr second]]! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoInsideTemp	1 to: 5 do: [ :index | 		| temp | 		temp := index. 		collection add: [ temp ] ].	self assertValues: #(1 2 3 4 5)! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:38'!testMultipleConflicts	self assertMerge: #(a1 b3 c1)				with: #(a1 b2 d1)				base: #(a1 b1 c2)								gives: #(a1 b3 d1)				conflicts: #((removed c1) (b2 b3))! !!MCMethodDefinitionTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testRevertOldMethod	| definition changeRecord |	Object compile: 'yourself ^ self' classified: MCMockPackageInfo new methodCategoryPrefix.	definition := (MethodReference class: Object selector: #yourself) asMethodDefinition.	changeRecord := definition scanForPreviousVersion.	self assert: changeRecord notNil.	self assert: changeRecord category = 'accessing'.	changeRecord fileIn.! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/7/1999 13:43'!nonResumableFallOffTheEndHandler		[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do: [:ex | self doSomethingExceptional].	self doYetAnotherThing! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:58'!allProtocols	^ MCSnapshotResource current definitions		select: [:def | def isMethodDefinition]		thenCollect: [:def | def category]		! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 18:55'!simpleEnsureTestWithUparrowResults	^OrderedCollection new		add: self doSomethingString;"		add: self doSomethingElseString;"		add: self doYetAnotherThingString;		yourself! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:19'!getFalse: anArg	^false! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 7/14/2003 14:59'!definedClasses	^ MCSnapshotResource current definitions 		select: [:def | def isClassDefinition] 		thenCollect: [:def | def className].! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testSameSequence	| patch |	patch := self patchSequenceFor: #(a b c) and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/7/2009 11:25'!testInlineBlockCollectionLR1	"Test case from Lukas Renggli"	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | col add: [ each ] ].	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !!ClosureTests methodsFor: 'running' stamp: 'lr 3/9/2009 16:48'!setUp	super setUp.	collection := OrderedCollection new! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesENtoEZ	self decompileClassesSelect: [:cn| cn first = $E and: [cn second asUppercase > $M]]! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoArgumentNotInlined	| block |	block := [ :index |		collection add: [ index ] ].	1 to: 5 do: block.	self assertValues: #(1 2 3 4 5)! !!MCFileInTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertNoChange	| actual |	actual := MCSnapshotResource takeSnapshot.	diff := actual patchRelativeToBase: expected.	self assert: diff isEmpty! !!MCDependencySorterTest methodsFor: 'asserting' stamp: 'avi 10/7/2004 22:32'!assertItems: anArray orderAs: depOrder withRequired: missingDeps toLoad: unloadableItems	self assertItems: anArray orderAs: depOrder withRequired: missingDeps  toLoad: unloadableItems  extraProvisions: #()! !!EventManagerTest methodsFor: 'private' stamp: 'JWS 9/7/2000 17:20'!heardEvent	succeeded := true! !!ExceptionTester methodsFor: 'testing' stamp: 'brp 10/21/2004 17:40'!runTest: aSelector	| actualResult expectedResult |	[ self 		logTest: aSelector;		clearLog;		perform: aSelector ]			on: MyTestError do: 				[ :ex | self log: 'Unhandled Exception'.					ex return: nil ].	actualResult	:= self log.	expectedResult := self perform: (aSelector, #Results) asSymbol.	actualResult = expectedResult		ifTrue: [self logTestResult: 'succeeded']		ifFalse: [self logTestResult: 'failed' ].! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:03'!testFileDirectoryContainingDirectory	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: fd containingDirectory pathName = ''.! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 6/8/1999 12:50'!simpleEnsureTestWithError	[self doSomething.	MyTestError signal.	self doSomethingElse]		ensure:			[self doYetAnotherThing].	! !!MCStWriterTest methodsFor: 'data' stamp: 'ar 1/4/2010 18:09'!expectedMethodDefinitionWithBangs	^'!!MCStWriterTest methodsFor: ''testing'' stamp: ''ar 1/4/2010 18:03''!!methodWithBangs	^ ''	^ ReadStream on: ''''MCRevisionInfo packageName: ''''MonticelloCompatibilityTest''''!!!!!!!!MCOrganizationDeclaration categories:   #(  ''''Tests-Monticello-Mocks'''')!!!!!!!!MCClassDeclaration  name: #MCMockClassD  superclassName: #Object  category: #''''Tests-Monticello-Mocks''''  instVarNames: #()  comment: ''''''''!!!!!!!!MCMethodDeclaration className: #MCMockClassD selector: #one category: #''''as yet unclassified'''' timeStamp: ''''cwp 7/8/2003 21:21'''' source: ''''one	^ 1''''!!!!!!!!''''''!! !!'! !!MCSerializationTest methodsFor: 'testing' stamp: 'cwp 8/3/2003 18:43'!testStSerialization	self assertSnapshotsMatchWith: MCStWriter.! !!ArrayLiteralTest methodsFor: 'tests' stamp: 'avi 2/16/2004 21:08'!testReservedIdentifiers	self class compile: 'array ^ #(nil true false)'.	self assert: self array = {nil. true. false}.! !!ExceptionTester methodsFor: 'pseudo actions' stamp: 'tfei 6/8/1999 09:14'!doSomethingExceptional	self log: self doSomethingExceptionalString! !!MCMczInstallerTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!assertVersionInfoPresent	| dict info |	dict := MczInstaller versionInfo at: self mockPackage name.	info := expected info.	self assertDict: dict matchesInfo: info.! !!MCSnapshotBrowserTest methodsFor: 'private' stamp: 'cwp 8/10/2003 02:10'!classADefinitionString	^ self mockClassA definition! !!FileDirectoryTest methodsFor: 'create/delete tests' stamp: 'nk 11/13/2002 19:39'!deleteDirectory		(self myDirectory exists) ifTrue:		[self myDirectory containingDirectory deleteDirectory: self myLocalDirectoryName]! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 19:44'!testMirrorClass	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext objectClass: Array new) = Array.	self assert: (thisContext objectClass: 1) = 1 class.	self assert: (thisContext objectClass: ProtoObject new) = ProtoObject.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesMAtoMM	self decompileClassesSelect: [:cn| cn first = $M and: [cn second asUppercase <= $M]]! !!DosFileDirectoryTests methodsFor: 'as yet unclassified' stamp: 'ar 3/6/2004 04:04'!testFileDirectoryContainingEntry	"Hoping that you have 'C:' of course..."	| fd |	FileDirectory activeDirectoryClass == DosFileDirectory ifFalse:[^self].	fd := FileDirectory on: 'C:'.	self assert: (fd containingDirectory entryAt: fd localName) notNil.! !!ObjectFinalizerTests methodsFor: 'tests' stamp: 'stephaneducasse 10/28/2005 21:15'!testFinalization	"self run: #testFinalization"		| repetitions |	repetitions := 100.	1 to: repetitions		do: [:i | 			log addLast: 'o' , i asString , ' created'.			Object new				toFinalizeSend: #finalize:				to: self				with: 'o' , i asString].	Smalltalk garbageCollect.	self finalizationRegistry finalizeValues.	1 to: repetitions		do: [:i | 			self assert: (log includes: 'o' , i asString , ' created').			self assert: (log includes: 'o' , i asString , ' finalized')]! !!MCScannerTest methodsFor: 'tests' stamp: 'avi 1/22/2004 20:19'!test1	self assertScans: #(a '23' (x))! !!ExceptionTester methodsFor: 'suites' stamp: 'tfei 6/13/1999 01:25'!runAllTests	"ExceptionTester new runAllTests"	self		runBasicTests;		runBasicANSISignaledExceptionTests! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoOutsideTemp	| temp |	1 to: 5 do: [ :index | 		temp := index. 		collection add: [ temp ] ].	self assertValues: #(5 5 5 5 5)! !!MCMergingTest methodsFor: 'tests' stamp: 'ab 6/2/2003 01:38'!testSimultaneousModification	self assertMerge: #(a2)				with: #(a3)				base: #(a1)								gives: #(a3)				conflicts: #((a3 a2)).! !!ExceptionTester methodsFor: 'signaledException tests' stamp: 'tfei 6/13/1999 01:03'!simpleRetryUsingTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[:ex | ex retryUsing: [self doYetAnotherThing]]! !!MCWorkingCopyTest methodsFor: 'actions' stamp: 'jf 8/21/2003 20:22'!merge: aVersion	[[self basicMerge: aVersion]		on: MCMergeResolutionRequest do: [:n | n resume: true]]			on: MCNoChangesException do: [:n | ]! !!MCStWriterTest methodsFor: 'testing' stamp: 'stephaneducasse 2/4/2006 20:47'!testOrganizationDefinition	| definition |	definition := MCOrganizationDefinition categories: 					(self mockPackage packageInfo systemCategories).	writer visitOrganizationDefinition: definition.	self assertContentsOf: stream match: self expectedOrganizationDefinition.	self assertAllChunksAreWellFormed.! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:50'!testMethodSelected	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	self clickOnListItem: 'boolean'.	self clickOnListItem: 'falsehood'.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAProtocols.	self assertAListMatches: self classABooleanMethods.	self assertTextIs: self falsehoodMethodSource.! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 22:00'!testNonResumablePass	self should: [		[Error signal. 4] 			on: Error 			do: [:ex | ex pass. ex return: 5]		] raise: Error! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testCreation	| d |	d :=  self mockClassA asClassDefinition.	self assert: d className = #MCMockClassA.	self assert: d superclassName = #MCMock.	self assert: d type = #normal.	self assert: d category = self mockCategoryName.	self assert: d instVarNames asArray = #('ivar').	self assert: d classVarNames asArray = #('CVar').	self assert: d classInstVarNames asArray = #().	self assert: d comment isString.	self assert: d comment = self classAComment.	self assert: d commentStamp = self mockClassA organization commentStamp! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 13:04'!testClassSelected	self selectMockClassA.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAProtocols.	self denyAListIncludesAnyOf: self allMethods.	self assertTextIs: self classADefinitionString.! !!ExceptionTester methodsFor: 'logging' stamp: 'tfei 6/8/1999 09:17'!clearLog	log := nil! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'dtl 6/1/2004 22:00'!testResumableOuter	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex outer. ex return: 5].	self assert: result == 5! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 08:52'!testProtocolSelected	self clickOnListItem: self mockCategoryName.	self clickOnListItem: 'MCMockClassA'.	self clickOnListItem: 'boolean'.		self assertAListMatches: self allCategories.	self assertAListMatches: self definedClasses.	self assertAListMatches: self classAProtocols.	self assertAListMatches: self classABooleanMethods.	self assertTextIs: ''.		! !!MCStWriterTest methodsFor: 'asserting' stamp: 'al 7/21/2006 22:14'!assertChunkIsWellFormed: chunk	self class parserClass new		parse: chunk readStream 		class: UndefinedObject 		noPattern: true		context: nil		notifying: nil		ifFail: [self assert: false]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesCNtoCZ	self decompileClassesSelect: [:cn| cn first = $C and: [cn second asUppercase > $M]]! !!ExceptionTester methodsFor: 'tests' stamp: 'tfei 8/19/1999 01:39'!signalFromHandlerActionTest	[self doSomething.	MyTestError signal.	self doSomethingElse]		on: MyTestError		do:			[self doYetAnotherThing.			MyTestError signal]! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:35'!methodArgument: anObject	^ [ anObject ]	! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleResume	self assertSuccess: (ExceptionTester new runTest: #simpleResumeTest ) ! !!EventManagerTest methodsFor: 'running-broadcast query' stamp: 'jws 11/28/2000 15:52'!testSingleValueSupplier	eventSource		when: #needsValue		send: #getTrue		to: self.	succeeded := eventSource triggerEvent: #needsValue.	self should: [succeeded]! !!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'cwp 7/13/2003 09:27'!denyButtonOn: aString	self deny: (self findButtonWithLabel: aString) getModelState.	! !!MCMockDefinition methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!hash	^ token hash! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'tfel 8/28/2009 20:43'!testNoSelection	self assertAListMatches: self allCategories.	self denyAListIncludesAnyOf: self definedClasses.	self denyAListIncludesAnyOf: self allProtocols.	self denyAListIncludesAnyOf: self allMethods.	"and if there I need to see the packages scripts (or none)"	self assertTextIs: '(package defines no scripts)'.! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'ar 8/26/2009 21:38'!testBlockReceiverTwoArgs	eventSource when: #anEvent:info: evaluate:[:arg1 :arg2| self addArg1: arg1 addArg2: arg2].	eventSource triggerEvent: #anEvent:info: withArguments: #( 9 42 ).	self should: [(eventListener includes: 9) and: [eventListener includes: 42]]! !!ExceptionTester methodsFor: 'signaledException results' stamp: 'tfei 6/13/1999 01:11'!simpleResignalAsTestResults	^OrderedCollection new		add: self doSomethingString;		add: 'Unhandled Exception';		yourself! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:09'!testIfSequence5	| patch matches nonMatches |	patch := self patchSequenceFor: #(a b c d) and: #(c d a b).	self assert: patch size = 6.	"lcs is ab or cd"	matches := (patch select: [ :each | each key = #match ])		collect: [ :each | each value first ] as: String.	self assert: (#('ab' 'cd') includes: matches).	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	nonMatches := #('ab' 'cd') detect: [ :each | each ~= matches ].	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: (matches includes: each value first) ]			ifFalse: [ self assert: (nonMatches includes: each value first) ] ]! !!MCSerializationTest methodsFor: 'asserting' stamp: 'stephaneducasse 2/4/2006 20:47'!assertVersionInfosMatchWith: writerClass	| stream readerClass expected actual |	readerClass := writerClass readerClass.	expected := self mockVersion.	stream := RWBinaryOrTextStream on: String new.	writerClass fileOut: expected on: stream.	actual := readerClass versionInfoFromStream: stream reset.	self assert: actual = expected info.! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 22:50'!testMirrorSize	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext objectSize: #(1 2 3)) = 3.	self assert: (thisContext objectSize: '123') = 3.	self assert: (thisContext objectSize: nil) = 0.	self assert: (thisContext objectSize: 1) = 0.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesRNtoRZ	self decompileClassesSelect: [:cn| cn first = $R and: [cn second asUppercase > $M]]! !!EventManagerTest methodsFor: 'running-remove actions' stamp: 'SqR 2/19/2001 14:01'!testRemoveActionsTwiceForEvent	eventSource		when: #anEvent send: #size to: eventListener;		when: #anEvent send: #getTrue to: self;		when: #anEvent: send: #fizzbin to: self.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.	eventSource removeActionsForEvent: #anEvent.	self assert: (eventSource hasActionForEvent: #anEvent) not.! !!MCStWriterTest methodsFor: 'data' stamp: 'ar 1/4/2010 18:03'!expectedClassDefinitionB ^ 'MCMock subclass: #MCMockClassB	instanceVariableNames: ''ivarb''	classVariableNames: ''CVar''	poolDictionaries: ''MCMockAPoolDictionary''	category: ''Tests-Monticello-Mocks''!!MCMockClassB class	instanceVariableNames: ''ciVar''!!!!MCMockClassB commentStamp: '''' prior: 0!!This comment has a bang!!!! Bang!!!! Bang!!!!!!'! !!MCSnapshotResource methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 14:50'!definitions	^ snapshot definitions! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/28/2003 22:21'!textMorph	^ (self morphsOfClass: TextMorph) last! !!MCMockDefinition class methodsFor: 'as yet unclassified' stamp: 'cwp 7/21/2003 19:46'!wantsChangeSetLogging	^ false! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'avi 10/7/2004 22:35'!testExtraProvisions	self assertItems:		#((a (x) (z))		(b () (x)))	orderAs: #(a b)	withRequired: #()	toLoad: #()		extraProvisions: #(x z)! !!MCMockClassB methodsFor: 'numeric' stamp: 'ab 7/7/2003 23:21'!two	^ 2! !!MCSnapshotBrowserTest methodsFor: 'morphic' stamp: 'cwp 7/13/2003 02:34'!listMorphs	^ self morphsOfClass: PluggableListMorph! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesKAtoKM	self decompileClassesSelect: [:cn| cn first = $K and: [cn second asUppercase <= $M]]! !!MCSnapshotBrowserTest methodsFor: 'testing' stamp: 'cwp 7/13/2003 02:37'!testTextPane	self shouldnt: [self textMorph] raise: Exception.! !!SystemVersionTest methodsFor: 'as yet unclassified' stamp: 'tlk 11/14/2004 10:55'!testMajorMinorVersion	"	SystemVersionTest run: #testMajorMinorVersion	"	self assert: (SystemVersion new version: 'Squeak3.7alpha') majorMinorVersion = 'Squeak3.7'.	self assert: (SystemVersion new version: 'Squeak3.7') majorMinorVersion = 'Squeak3.7'.	self assert: (SystemVersion new version: 'Squeak3') majorMinorVersion = 'Squeak3'.	self assert: (SystemVersion new version: '') majorMinorVersion = ''.! !!MCRepositoryTest methodsFor: 'actions' stamp: 'stephaneducasse 2/4/2006 20:47'!addVersionWithSnapshot: aSnapshot name: aString	| version |	version := self versionWithSnapshot: aSnapshot name: aString.	self addVersion: version.	^ version info! !!MCMockClassA methodsFor: 'as yet classified' stamp: ''!d	^ 'd'! !!MCOrganizationTest methodsFor: 'as yet unclassified' stamp: 'stephaneducasse 2/4/2006 20:47'!testReorderingWithNoCategoriesInVersion	|dec cats newCats |	dec := MCOrganizationDefinition categories: #().	cats := #(X Y B Z C A Q).	newCats := dec reorderCategories: cats original: #().	self assert: newCats asArray = cats.! !!MethodHighlightingTests methodsFor: 'tests' stamp: 'ar 1/3/2010 14:23'!asXML	"self new asXML"	"Convert the master index into external XML representation"		^String streamContents:[:s| | writer |		writer := self xmlWriter on: s.		writer xmlDeclaration: '1.0'.		writer startTag: 'recording'; endTag.			writer tag: 'creator' pcData: creator.			writer tag: 'timestamp' pcData: timeStamp.			writer tag: 'duration' pcData: duration.			writer startTag: 'tracks'; endTag.				tracks do:[:tdata|					writer startTag: 'track'; attribute: 'type' value: tdata value; endTag.					writer pcData: tdata key.					writer endTag: 'track'.				].			writer endTag: 'tracks'.		writer endTag: 'recording'.	].! !!ExceptionTester methodsFor: 'results' stamp: 'tfei 6/8/1999 09:47'!simpleEnsureTestResults	^OrderedCollection new		add: self doSomethingString;		add: self doSomethingElseString;		add: self doYetAnotherThingString;		yourself! !!EventManagerTest methodsFor: 'running-dependent action' stamp: 'ar 8/26/2009 21:37'!testBlockReceiverOneArg	eventSource when: #anEvent: evaluate:[:arg1| eventListener add: arg1].	eventSource triggerEvent: #anEvent: with: 9.	self should: [eventListener includes: 9]! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:48'!testSimpleRetry	self assertSuccess: (ExceptionTester new runTest: #simpleRetryTest ) ! !!MCMockDependentItem methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!requirements	^ requires ifNil: [#()]! !!MCStWriterTest methodsFor: 'asserting' stamp: 'nk 2/22/2005 21:17'!assertContentsOf: strm match: expected 	| actual |	actual := strm contents.	self assert: actual size = expected size.	actual with: expected do: [:a :e | self assert: a = e]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesZAtoZM	self decompileClassesSelect: [:cn| cn first = $Z and: [cn second asUppercase <= $M]]! !!MCSnapshotBrowserTest class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 14:59'!resources	^ Array with: MCSnapshotResource! !!MirrorPrimitiveTests methodsFor: 'testing' stamp: 'ul 12/15/2009 20:23'!expectedFailures	^#(testMirrorAt testMirrorEqEq testMirrorInstVarAt testMirrorPerform testMirrorSize)! !!MCStWriterTest methodsFor: 'testing' stamp: 'cwp 8/9/2003 14:52'!testMethodDefinitionWithBangs	writer visitMethodDefinition: (MethodReference 									class: self class 									selector: #methodWithBangs) asMethodDefinition.	self assertContentsOf: stream match: self expectedMethodDefinitionWithBangs.	stream reset.	self assert: stream nextChunk isAllSeparators.	self assertChunkIsWellFormed: stream nextChunk.	self assertMethodChunkIsWellFormed: stream nextChunk.	self assert: stream nextChunk isAllSeparators ! !!ExceptionTester methodsFor: 'accessing' stamp: 'dtl 6/1/2004 21:53'!basicANSISignaledExceptionTestSelectors	^#( simpleIsNestedTest simpleOuterTest doubleOuterTest doubleOuterPassTest doublePassOuterTest simplePassTest simpleResignalAsTest simpleResumeTest simpleRetryTest simpleRetryUsingTest simpleReturnTest)! !!MCSnapshotResource class methodsFor: 'as yet unclassified' stamp: 'avi 2/22/2004 13:54'!mockPackageName	^ MCMockPackageInfo new packageName! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'Igor.Stasenko 12/20/2009 03:57'!testTempNameAccessForInjectInto	"self new testTempNameAccessForInjectInto"	| methodNode method evaluationCount block debuggerMap |	methodNode := Parser new						encoderClass: EncoderForV3PlusClosures;						parse: (Collection sourceCodeAt: #inject:into:)						class: Collection.	method := methodNode generate.	debuggerMap := DebuggerMethodMap forMethod: method methodNode: methodNode.	evaluationCount := 0.	block := [:prev :each| | theContext tempNames |			evaluationCount := evaluationCount + 1.			theContext := thisContext sender.			tempNames := debuggerMap tempNamesForContext: theContext.			self assert: (tempNames hasEqualElements: tempNames).			#('thisValue' 'each' 'binaryBlock' 'nextValue')				with: { 0. each. block. prev}				do: [:tempName :value|					self assert: (debuggerMap namedTempAt: (tempNames indexOf: tempName) in: theContext) == value.					tempName ~= 'each' ifTrue:						[self assert: (debuggerMap namedTempAt: (tempNames indexOf: tempName) in: theContext home) == value]]].	(1 to: 10) withArgs: { 0. block } executeMethod: method.	self assert: evaluationCount = 10! !!MCTestCase methodsFor: 'asserting' stamp: 'cwp 8/8/2003 15:50'!assertVersionInfo: actual matches: expected	self assert: actual name = expected name.	self assert: actual message = expected message.	self assert: actual ancestors size = expected ancestors size.	actual ancestors with: expected ancestors do: [:a :e | self assertVersionInfo: a matches: e]	! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesPNtoPZ	self decompileClassesSelect: [:cn| cn first = $P and: [cn second asUppercase > $M]]! !!ExceptionTests methodsFor: 'testing-ExceptionTester' stamp: 'md 3/25/2003 23:47'!testSimpleRetryUsing	self assertSuccess: (ExceptionTester new runTest: #simpleRetryUsingTest ) ! !!MCRepositoryTest methodsFor: 'actions' stamp: 'ab 8/16/2003 17:46'!addVersion: aVersion	self subclassResponsibility ! !!MCClassDefinitionTest class methodsFor: 'as yet unclassified' stamp: 'cwp 8/10/2003 01:20'!classAComment	^ 'This is a mock class. The Monticello tests manipulated it to simulate a developer modifying code in the image.'! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/24/2008 12:28'!doTestDebuggerTempAccessWith: one with: two	"Test debugger access for temps"	| outerContext local1 remote1 |	outerContext := thisContext.	local1 := 3.	remote1 := 1/2.	self assert: (Compiler new evaluate: 'one' in: thisContext to: self) == one.	self assert: (Compiler new evaluate: 'two' in: thisContext to: self) == two.	self assert: (Compiler new evaluate: 'local1' in: thisContext to: self) == local1.	self assert: (Compiler new evaluate: 'remote1' in: thisContext to: self) == remote1.	Compiler new evaluate: 'local1 := -3.0' in: thisContext to: self.	self assert: local1 = -3.0.	(1 to: 2) do:		[:i| | local2 r1 r2 r3 r4 |		local2 := i * 3.		remote1 := local2 / 7.		self assert: thisContext ~~ outerContext.		self assert: (r1 := Compiler new evaluate: 'one' in: thisContext to: self) == one.		self assert: (r2 := Compiler new evaluate: 'two' in: thisContext to: self) == two.		self assert: (r3 := Compiler new evaluate: 'i' in: thisContext to: self) == i.		self assert: (r4 := Compiler new evaluate: 'local2' in: thisContext to: self) == local2.		self assert: (r4 := Compiler new evaluate: 'remote1' in: thisContext to: self) == remote1.		self assert: (r4 := Compiler new evaluate: 'remote1' in: outerContext to: self) == remote1.		Compiler new evaluate: 'local2 := 15' in: thisContext to: self.		self assert: local2 = 15.		Compiler new evaluate: 'local1 := 25' in: thisContext to: self.		self assert: local1 = 25.		{ r1. r2. r3. r4 } "placate the compiler"].	self assert: local1 = 25.	self assert: remote1 = (6/7)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesAAtoAM	self decompileClassesSelect: [:cn| cn first = $A and: [cn second asUppercase <= $M]]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:09'!testEmptySequences	| patch |	patch := self patchSequenceFor: #() and: #().	self assert: patch isEmpty! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testRedundantMerge	| base |	base :=  self snapshot.	self merge: base.	self shouldnt: [self merge: base] raise: Error.! !!MCMockPackageInfo methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:25'!extensionMethods	^ Array with: (MethodReference new 					setStandardClass: MCSnapshotTest 					methodSymbol: #mockClassExtension)! !!MCDependencySorterTest methodsFor: 'tests' stamp: 'ab 5/25/2003 01:11'!testCycle	self assertItems: #(		(a (x) (y))		(b (y) (x)))	orderAs: #()	withRequired: #()	toLoad: #(a b)	! !!MCSnapshotResource class methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2003 15:19'!takeSnapshot	^ self mockPackage snapshot! !!MCMergingTest methodsFor: 'tests' stamp: 'stephaneducasse 2/4/2006 20:47'!testMultiPackageMerge3	| merger |	conflicts := #().	merger := MCThreeWayMerger new.	merger addBaseSnapshot: (self snapshotWithElements: #(a1 b1)).	merger applyPatch: ((self snapshotWithElements: #(a1 b1)) patchRelativeToBase: (self snapshotWithElements: #(b1))).	merger applyPatch: ((self snapshotWithElements: #()) patchRelativeToBase: (self snapshotWithElements: #(a1))).	merger conflicts do: [:ea | self handleConflict: ea].	self assert: merger mergedSnapshot definitions hasElements: #(a1 b1).	self assert: conflicts isEmpty! !!ObjectFinalizerTests methodsFor: 'finalization handling' stamp: 'apb 9/14/2005 08:33'!finalize: anObject	log addLast: anObject asString, ' ', 'finalized'.! !!TextDiffBuilderTest methodsFor: 'private' stamp: 'ul 12/27/2009 21:03'!patchSequenceFor: x and: y	^(TextDiffBuilder		from: (self convertToString: x)		to:  (self convertToString: y)) buildPatchSequence! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/24/2009 20:53'!supportTestSourceRangeAccessForInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	':= thisValue'								'do: [:each | nextValue := binaryBlock value: nextValue value: each]'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								'nextValue := binaryBlock value: nextValue value: each'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								'nextValue := binaryBlock value: nextValue value: each'								'^nextValue')! !MCMockPackageInfo initialize!MCDirtyPackageInfo initialize!MCMockClassA initialize!MCEmptyPackageInfo initialize!