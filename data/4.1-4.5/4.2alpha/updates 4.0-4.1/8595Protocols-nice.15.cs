"Change Set:		8595Protocols-nice.15Protocols-nice.15:Cosmetic: move or remove a few temps inside closures"!!Vocabulary methodsFor: 'private' stamp: 'nice 12/27/2009 03:11'!setCategoryStrings: categoryTriplets	"Establish the category strings as per (internalCategorySymbol newCategoryWording balloon-help)"		categoryTriplets do:		[:triplet | | category |			(category := self categoryAt: triplet first) ifNotNil: [				category wording: triplet second.				category helpMessage: triplet third]]! !!NumberType methodsFor: 'initialization' stamp: 'nice 12/26/2009 18:47'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"	super initialize.	"Vocabulary replaceNumberVocabulary"	"Vocabulary addVocabulary: Vocabulary newNumberVocabulary"	self vocabularyName: #Number.	self documentation: 'Numbers are things that can do arithmetic, have their magnitudes compared, etc.'.#((comparing				'Determining which of two numbers is larger'		(= < > <= >= ~= ~~))(arithmetic 				'Basic numeric operation'		(* + - / // \\ abs negated quo: rem:))(testing 					'Testing a number'		(even isDivisibleBy: negative odd positive sign))(#'mathematical functions'	'Trigonometric and exponential functions'		(cos exp ln log log: raisedTo: sin sqrt squared tan raisedToInteger:))(converting 				'Converting a number to another form'		(@ asInteger asPoint degreesToRadians radiansToDegrees asSmallAngleDegrees asSmallPositiveDegrees))(#'truncation and round off' 'Making a real number (with a decimal point) into an integer'		(ceiling floor roundTo: roundUpTo: rounded truncateTo: truncated))) do:		[:item | 			| aMethodCategory |			aMethodCategory := ElementCategory new categoryName: item first.			aMethodCategory documentation: item second.			item third do:				[:aSelector | 					| aMethodInterface |					aMethodInterface := MethodInterface new conjuredUpFor: aSelector class: (Number whichClassIncludesSelector: aSelector).					aMethodInterface argumentVariables do:							[:var | var variableType: #Number].					(#(* + - / // \\ abs negated quo: rem:						cos exp ln log log: raisedTo: sin sqrt squared tan raisedToInteger:						asInteger degreesToRadians radiansToDegrees asSmallAngleDegrees asSmallPositiveDegrees)							includes: aSelector) ifTrue:								[aMethodInterface resultType: #Number].					(#( @  asPoint ) includes: aSelector) ifTrue:						[aMethodInterface resultType: #Point].					(#(= < > <= >= ~= ~~ even isDivisibleBy: negative odd positive) includes: aSelector) ifTrue:						[aMethodInterface resultType: #Boolean].					aMethodInterface setNotToRefresh.  					self atKey: aSelector putMethodInterface: aMethodInterface.					aMethodCategory elementAt: aSelector put: aMethodInterface].			self addCategory: aMethodCategory]."(('truncation and round off' ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated)('testing' basicType even isDivisibleBy: isInf isInfinite isNaN isNumber isZero negative odd positive sign strictlyPositive)('converting' @ adaptToCollection:andSend: adaptToFloat:andSend: adaptToFraction:andSend: adaptToInteger:andSend: adaptToPoint:andSend: adaptToString:andSend: asInteger asNumber asPoint asSmallAngleDegrees asSmallPositiveDegrees degreesToRadians radiansToDegrees)('intervals' to: to:by: to:by:do: to:do:)('printing' defaultLabelForInspector isOrAreStringWith: newTileMorphRepresentative printOn: printStringBase: storeOn: storeOn:base: storeStringBase: stringForReadout)('comparing' closeTo:)('filter streaming' byteEncode:)('as yet unclassified' reduce)"! !!FullVocabulary methodsFor: 'initialization' stamp: 'nice 12/26/2009 10:13'!rigAFewCategories	"Formerly used to rig generic categories, now seemingly disfunctional and in abeyance"	true ifTrue: [^ self].	self flag: #deferred."Vocabulary fullVocabulary rigAFewCategories "	#(	(accessing	'Generally holds methods to read and write instance variables')		(initialization	'messages typically sent when an object is created, to set up its initial state'))		do:			[:pair |				| aMethodCategory |				aMethodCategory := ElementCategory new categoryName: pair first.				aMethodCategory documentation: pair second.				self addCategory: aMethodCategory]! !!Vocabulary methodsFor: 'queries' stamp: 'nice 12/27/2009 03:11'!methodInterfacesInCategory: categoryName forInstance: anObject ofClass: aClass limitClass: aLimitClass	"Answer a list of method interfaces of all methods in the given category, provided they are implemented no further away than aLimitClass."		^ ((self allMethodsInCategory: categoryName forInstance: anObject ofClass: aClass) collect:		[:sel | methodInterfaces at: sel ifAbsent:			[MethodInterface new conjuredUpFor: sel class: aClass]]) select:				[:aMethodInterface | | defClass |					defClass := aClass whichClassIncludesSelector: aMethodInterface selector.					(defClass notNil and: [defClass includesBehavior: aLimitClass])]! !!Vocabulary methodsFor: 'queries' stamp: 'nice 12/27/2009 04:10'!categoryWithNameIn: categoryNames thatIncludesSelector: aSelector forInstance: targetInstance ofClass: targetClass	"Answer the name of a category, from among the provided categoryNames, which defines the selector for the given class.  Note reimplementor"		self categories do:		[:aCategory | | itsName |		((categoryNames includes: (itsName := aCategory categoryName)) and:  [aCategory includesKey: aSelector])			ifTrue:				[^ itsName]].	^ nil! !!Vocabulary methodsFor: 'queries' stamp: 'nice 12/27/2009 03:11'!categoryList	"Answer the category list considering only code implemented in my 	limitClass and lower. This variant is used when the limitClass and 	targetObjct are known"	| classToUse |	classToUse := object class.	^ categories		select: [:aCategory | | foundAMethod | 			foundAMethod := false.			aCategory elementsInOrder				do: [:aSpec | | classThatImplements | 					classThatImplements := classToUse whichClassIncludesSelector: aSpec selector.					(classThatImplements notNil							and: [classThatImplements includesBehavior: limitClass])						ifTrue: [foundAMethod := true]].			foundAMethod]		thenCollect: [:aCategory | aCategory categoryName]! !!StringType methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:11'!initialize	"Initialize the receiver (automatically called when instances are created via 'new')"		super initialize.	self vocabularyName: #String.#((accessing 			'The basic info'		(at: at:put: size endsWithDigit findString: findTokens: includesSubString: indexOf: indexOf:startingAt: indexOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: startsWithDigit numArgs))(#'more accessing' 		'More basic info'		(allButFirst allButFirst: allButLast allButLast: at:ifAbsent: atAllPut: atPin: atRandom: atWrap: atWrap:put: fifth first first: fourth from:to:put: last last: lastIndexOf: lastIndexOf:ifAbsent: middle replaceAll:with: replaceFrom:to:with: replaceFrom:to:with:startingAt: second sixth third))(comparing				'Determining which comes first alphabeticly'		(< <= = > >= beginsWith: endsWith: endsWithAnyOf: howManyMatch: match:))(testing 				'Testing'		(includes: isEmpty ifNil: ifNotNil: isAllDigits isAllSeparators isString lastSpacePosition))(converting 			'Converting it to another form'		(asCharacter asDate asInteger asLowercase asNumber asString asStringOrText asSymbol asText asTime asUppercase asUrl capitalized keywords numericSuffix romanNumber reversed splitInteger surroundedBySingleQuotes withBlanksTrimmed withSeparatorsCompacted withoutTrailingBlanks withoutTrailingDigits asSortedCollection))(copying 				'Make another one like me'		(copy copyFrom:to: copyUpTo: copyUpToLast: shuffled))(enumerating		'Passing over the letters'		(collect: collectWithIndex: do: from:to:do: reverseDo: select: withIndexDo: detect: detect:ifNone:))) do: [:item | | aMethodCategory | 			aMethodCategory := ElementCategory new categoryName: item first.			aMethodCategory documentation: item second.			item third do:				[:aSelector | | aMethodInterface | 					aMethodInterface := MethodInterface new initializeFor: aSelector.					self atKey: aSelector putMethodInterface: aMethodInterface.					aMethodCategory elementAt: aSelector put: aMethodInterface].			self addCategory: aMethodCategory].! !!Vocabulary methodsFor: 'initialization' stamp: 'nice 12/27/2009 04:09'!initializeFromTable: aTable	"Initialize the receiver from a list of method-specification tuples, each of the form:		(1)	selector		(2)	companion setter selector (#none or nil indicate none)		(3)  argument specification array, each element being an array of the form				<arg name>  <arg type>		(4)  result type, (#none or nil indicate none)		(5)  array of category symbols, i.e. the categories in which this element should appear.		(6)  help message. (optional)		(7)  wording (optional)		(8)  auto update flag (optional) - if #updating, set readout to refetch automatically	Consult Vocabulary class.initializeTestVocabulary for an example of use"					| categoryList |	categoryList := Set new.	aTable do:		[:tuple | categoryList addAll: tuple fifth].	categoryList := categoryList asSortedArray.	categoryList do:		[:aCategorySymbol | | aMethodCategory |			aMethodCategory := ElementCategory new categoryName: aCategorySymbol.			aTable do:				[:tuple | | doc aSelector wording aMethodInterface |				(tuple fifth includes: aCategorySymbol) ifTrue:					[aMethodInterface := MethodInterface new.					aSelector := tuple first.					aMethodInterface selector: aSelector type: tuple fourth setter: tuple second.					aMethodCategory elementAt: aSelector put: aMethodInterface.					self atKey: aSelector putMethodInterface: aMethodInterface.					((tuple third ~~ #none) and: [tuple third isEmptyOrNil not])						ifTrue:							[aMethodInterface argumentVariables: (tuple third collect:								[:pair | Variable new name: pair first type: pair second])].					doc := (tuple size >= 6 and: [(#(nil none unused) includes: tuple sixth) not])						ifTrue:							[tuple sixth]						ifFalse:							[nil]. 					wording := (tuple size >= 7 and: [(#(nil none unused) includes: tuple seventh) not])						ifTrue:							[tuple seventh]						ifFalse:							[aSelector asString].					aMethodInterface						wording: wording;						helpMessage: doc.					tuple size >= 8 ifTrue:						[aMethodInterface setToRefetch]]].			self addCategory: aMethodCategory]! !!Vocabulary methodsFor: 'queries' stamp: 'nice 12/27/2009 03:11'!categoryListForInstance: targetObject ofClass: aClass limitClass: mostGenericClass 	"Answer the category list for the given instance (may be nil) of the 	given class, considering only code implemented in mostGenericClass and 	lower "	| classToUse |	classToUse := targetObject				ifNil: [aClass]				ifNotNil: [targetObject class].	^ categories		select: [:aCategory | | foundAMethod | 			foundAMethod := false.			aCategory elementsInOrder				do: [:aSpec | | classThatImplements | 					classThatImplements := classToUse whichClassIncludesSelector: aSpec selector.					(classThatImplements notNil							and: [classThatImplements includesBehavior: mostGenericClass])						ifTrue: [foundAMethod := true]].			foundAMethod]		thenCollect: [:aCategory | aCategory categoryName]! !!Vocabulary class methodsFor: 'standard vocabulary access' stamp: 'nice 12/27/2009 03:11'!newTimeVocabulary	"Answer a Vocabulary object representing me" 	| aVocabulary |	"Vocabulary newTimeVocabulary"	"Vocabulary addStandardVocabulary: Vocabulary newTimeVocabulary"	aVocabulary := self new vocabularyName: #Time.	aVocabulary documentation: 'Time knows about hours, minutes, and seconds.  For long time periods, use Date'.#((accessing 			'The basic info'		(hours minutes seconds))(arithmetic 				'Basic numeric operations'		(addTime: subtractTime: max: min: min:max:))(comparing				'Determining which is larger'		(= < > <= >= ~= between:and:))(testing 				'Testing'		(ifNil: ifNotNil:))(printing 				'Return a string for this Time'		(hhmm24 print24 intervalString printMinutes printOn:))(converting 			'Converting it to another form'		(asSeconds asString))(copying 				'Make another one like me'		(copy))) do: [:item | | aMethodCategory | 			aMethodCategory := ElementCategory new categoryName: item first.			aMethodCategory documentation: item second.			item third do:				[:aSelector | | aMethodInterface | 					aMethodInterface := MethodInterface new initializeFor: aSelector.					aVocabulary atKey: aSelector putMethodInterface: aMethodInterface.					aMethodCategory elementAt: aSelector put: aMethodInterface].			aVocabulary addCategory: aMethodCategory].	#(#addTime: subtractTime: max: min: = < > <= >= ~= ) do: [:sel |		(aVocabulary methodInterfaceAt: sel ifAbsent: [self error: 'fix this method']) 			argumentVariables: (OrderedCollection with:				(Variable new name: nil type: aVocabulary vocabularyName))].	^ aVocabulary! !!Vocabulary methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:11'!addFromTable: aTable	"Add each method-specification tuples, each of the form:		(1)	selector		(2)	companion setter selector (#none or nil indicate none)		(3)  argument specification array, each element being an array of the form				<arg name>  <arg type>		(4)  result type, (#none or nil indicate none)		(5)  array of category symbols, i.e. the categories in which this element should appear.		(6)  help message. (optional)		(7)  wording (optional)		(8)  auto update flag (optional) - if #updating, set readout to refetch automatically	Make new categories as needed.	Consult Vocabulary class.initializeTestVocabulary for an example of use"						aTable do:		[:tuple |   tuple fifth do: [:aCategorySymbol | | aSelector aMethodInterface aMethodCategory doc wording |			(aMethodCategory := self categoryAt: aCategorySymbol) ifNil: [ 					aMethodCategory := ElementCategory new categoryName: aCategorySymbol.					self addCategory: aMethodCategory].							aMethodInterface := MethodInterface new.			aSelector := tuple first.			aMethodInterface selector: aSelector type: tuple fourth setter: tuple second.			aMethodCategory elementAt: aSelector put: aMethodInterface.			self atKey: aSelector putMethodInterface: aMethodInterface.			((tuple third ~~ #none) and: [tuple third isEmptyOrNil not])				ifTrue:					[aMethodInterface argumentVariables: (tuple third collect:						[:pair | Variable new name: pair first type: pair second])].					doc := (tuple size >= 6 and: [(#(nil none unused) includes: tuple sixth) not])				ifTrue:					[tuple sixth]				ifFalse:					[nil].			wording := (tuple size >= 7 and: [(#(nil none unused) includes: tuple seventh) not])				ifTrue:					[tuple seventh]				ifFalse:					[aSelector].			aMethodInterface				wording: wording;				helpMessage: doc.			tuple size >= 8 ifTrue:				[aMethodInterface setToRefetch]]].! !!Vocabulary class methodsFor: 'class initialization' stamp: 'nice 12/27/2009 03:11'!embraceAddedTypeVocabularies	"If there are any type-vocabulary subclases not otherwise accounted for, acknowledge them at this time"		DataType allSubclasses do:		[:dataType | | vocabulary |			vocabulary := dataType new.			vocabulary representsAType				ifTrue: [(self allStandardVocabularies includesKey: vocabulary vocabularyName)					ifFalse: 	[self addStandardVocabulary: vocabulary]]]! !