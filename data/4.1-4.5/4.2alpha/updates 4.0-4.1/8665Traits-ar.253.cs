"Change Set:		8665Traits-ar.253Traits-ar.253:Install NanoTraits.Traits-ar.252:Shipping NanoTraits part 1: Put NanoTraits into Traits package for delivery."!Error subclass: #NanoTraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!Trait named: #TTransformationCompatibility	uses: {}	category: 'Traits-Kernel-Traits'!ClassDescription subclass: #NanoTraitBehavior	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!NanoTraitTransformation subclass: #NanoTraitAlias	instanceVariableNames: 'aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!NanoTraitDescription subclass: #NanoTrait	instanceVariableNames: 'name environment category'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!NanoTraitTransformation subclass: #NanoTraitExclusion	instanceVariableNames: 'exclusions'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!AdditionalMethodState variableSubclass: #NanoTraitMethodState	instanceVariableNames: 'originalTraitMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!NanoTraitBehavior subclass: #NanoTraitDescription	instanceVariableNames: 'users traitComposition'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!NanoTraitDescription subclass: #NanoClassTrait	instanceVariableNames: 'baseTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!Object subclass: #NanoTraitTransformation	instanceVariableNames: 'subject users'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!OrderedCollection subclass: #NanoTraitComposition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-NanoKernel'!!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method has a trait conflict"	^self traitConflict! !!NanoTraitDescription methodsFor: 'copying' stamp: 'ar 11/28/2007 20:55'!copyTraitExpression	"Copy all except the actual traits"	^self! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/21/2009 19:53'!resolveTraitsConflict: aSelector from: oldMethod to: newMethod	"Resolve a traits conflict. Rules:		- If one method is required the other one wins		- Otherwise we compile a traits conflict	"	| marker selector |	oldMethod methodHome == newMethod methodHome ifTrue:[^oldMethod].	marker := oldMethod markerOrNil.	(#(requirement explicitRequirement subclassResponsibility shouldNotImplement) includes: marker)		ifTrue:[^newMethod].	marker := newMethod markerOrNil.	(#(requirement explicitRequirement subclassResponsibility shouldNotImplement) includes: marker)		ifTrue:[^oldMethod].	"Create a conflict marker"	selector := #(conflict conflict: conflict:with: conflict:with:with: conflict:with:with:with:	conflict:with:with:with:with: conflict:with:with:with:with:with: conflict:with:with:with:with:with:with:	conflict:with:with:with:with:with:with:with:) at: oldMethod numArgs+1.	^NanoTraitDescription class compiledMethodAt: selector.! !!NanoTraitAlias methodsFor: 'operations' stamp: 'ar 12/20/2009 13:49'!printOn: s	"Answer the trait composition string (used for class definitions)"	s nextPutAll: subject asString.	s nextPutAll: ' @ {'.	aliases do:[:assoc| s print: assoc] separatedBy:[s nextPutAll:'. '].	s nextPutAll: '}'.! !!NanoTrait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:48'!asClassDefinition	^Smalltalk at: #MCTraitDefinition ifPresent:[:aClass|		aClass			name: self name			traitComposition: self traitCompositionString			category: self category 			comment: self organization classComment asString			commentStamp: self organization commentStamp].! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 11/28/2007 21:00'!removeFromSystem: logged	self environment forgetClass: self logged: logged.	self obsolete! !!NanoTraitDescription methodsFor: 'printing' stamp: 'ar 12/27/2009 19:14'!printHierarchy	"For hierarchy view in the browser; print the users of a trait"	^String streamContents:[:s| self printUsersOf: self on: s level: 0].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 13:38'!installTraitsFrom: aTraitComposition	"Install the traits from the given composition"	| allTraits methods oldMethod removals oldCategories |	(aTraitComposition isKindOf: NanoTraitComposition) 		ifFalse:[self error: 'Invalid composition'].	(self traitComposition isEmpty and: [aTraitComposition isEmpty]) ifTrue: [^self].	"Check for cycles"	allTraits := aTraitComposition gather: [:t | t allTraits copyWith: t].	(allTraits includes: self) ifTrue:[^self error: 'Cyclic trait definition detected'].	"XXXX: addUser/removeUser should be part of setter, but subclass 	override prevents it until we've got rid of Traits mess."	self traitComposition removeTraitUser: self.	self traitComposition: aTraitComposition.	aTraitComposition addTraitUser: self.	"Assemble the methods in a new dictionary first.	Uses a Dictionary instead of a MethodDictionary for speed (MDs grow by #become:)"	methods := Dictionary new.	"Stick in the local methods first, since this avoids generating conflict methods unnecessarily"	self selectorsAndMethodsDo:[:sel :newMethod|		(self isLocalMethod: newMethod)			ifTrue:[methods at: sel put:newMethod]].	"Now assemble the traits methods"	aTraitComposition do:[:trait|		trait selectorsAndMethodsDo:[:sel :newMethod|			oldMethod := methods at: sel ifAbsentPut:[newMethod].			newMethod == oldMethod ifFalse:["a conflict"				(self isLocalMethod: oldMethod) ifFalse:[					methods at: sel put: (self resolveTraitsConflict: sel from: oldMethod to: newMethod).				].			].		].	].	"Apply the changes. We first add the new or changed methods."	oldCategories := Set new.	methods keysAndValuesDo:[:sel :newMethod|		oldMethod := self compiledMethodAt: sel ifAbsent:[nil].		oldMethod == newMethod ifFalse:[			self traitAddSelector: sel withMethod: newMethod.			(self organization categoryOfElement: sel) ifNotNil:[:cat| oldCategories add: cat].			self organization classify: sel under: 				(newMethod methodHome organization categoryOfElement: newMethod selector).		]].	"Now remove the old or obsoleted ones"	removals := OrderedCollection new.	self selectorsDo:[:sel| (methods includesKey: sel) ifFalse:[removals add: sel]].	removals do:[:sel| self traitRemoveSelector: sel].	"Clean out empty categories"	oldCategories do:[:cat|		(self organization isEmptyCategoryNamed: cat)			ifTrue:[self organization removeCategory: cat]].	self isMeta ifFalse:[self class updateTraitsFrom: aTraitComposition].! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 11/18/2007 15:33'!setName: aSymbol andRegisterInCategory: categorySymbol environment: aSystemDictionary	(self isValidTraitName: aSymbol) ifFalse: [self error:'Invalid trait name'].	(self environment == aSystemDictionary		and: [self name = aSymbol			and: [self category = categorySymbol]]) ifTrue: [^self].			((aSystemDictionary includes: aSymbol) and: [(aSystemDictionary at: aSymbol) ~~ self])		ifTrue: [self error: 'The name ''' , aSymbol , ''' is already used'].	(self environment notNil and: [self name notNil and: [self name ~= aSymbol]]) ifTrue: [		self environment renameClass: self as: aSymbol].		self name: aSymbol.	self environment: aSystemDictionary.		self environment at: self name put: self.	self environment organization classify: self name under: categorySymbol.	^ true! !!NanoTrait class methodsFor: 'public' stamp: 'ar 12/27/2009 14:12'!named: aSymbol uses: aTraitCompositionOrCollection category: aString	"Dispatch through ClassDescription for alternative implementations"	^ClassDescription newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString! !!NanoTraitTransformation methodsFor: 'converting' stamp: 'ar 12/7/2009 20:39'!- anArrayOfSelectors	^self subclassResponsibility! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!name: aSymbol	name := aSymbol! !!NanoTraitExclusion class methodsFor: 'instance creation' stamp: 'ar 11/18/2007 18:04'!with: aTraitComposition exclusions: anArrayOfSelectors	^self new		subject: aTraitComposition;		exclusions: anArrayOfSelectors;		yourself! !!NanoTraitDescription methodsFor: 'operations' stamp: 'ar 12/19/2009 23:56'!addSelectorSilently: selector withMethod: compiledMethod	"Overridden to update the users of this trait"	super addSelectorSilently: selector withMethod: compiledMethod.	self users do:[:each| each updateTraits].! !!NanoTraitAlias methodsFor: 'converting' stamp: 'ar 12/20/2009 12:37'!- anArrayOfSelectors	^NanoTraitExclusion		with: self		exclusions: anArrayOfSelectors! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 13:31'!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^(self includesLocalSelector: aSymbol) not		and: [self hasTraitComposition]		and: [self traitComposition isLocalAliasSelector: aSymbol]! !!NanoTrait class methodsFor: 'installing' stamp: 'ar 12/27/2009 23:58'!unloadBerneTraits	"Unload Berne traits via Monticello"	#(TraitBehavior TraitDescription ClassTrait) do:[:clsName|		Smalltalk at: clsName ifPresent:[:aClass| aClass traitComposition: nil]].	"Special for Trait since it becomes a plain old global"	Smalltalk at: #Trait ifPresent:[:aClass|		aClass name == #Trait ifTrue:[aClass traitComposition: nil].	].	Smalltalk at: #ModelExtension ifPresent:[:aClass|		aClass withAllSubclassesDo:[:subclass|			SystemChangeNotifier uniqueInstance noMoreNotificationsFor: subclass.			SystemChangeNotifier uniqueInstance noMoreNotificationsFor: subclass current.	]].	(MCPackage named: 'Traits') unload.	Smalltalk allClassesDo:[:aClass|		aClass basicLocalSelectors: nil.		aClass class basicLocalSelectors: nil.		aClass traitComposition class isObsolete 			ifTrue:[aClass traitComposition: nil].		aClass classSide traitComposition class isObsolete 			ifTrue:[aClass classSide traitComposition: nil].	].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 01:06'!traitCompositionString	"Answer the trait composition string for the receiver"	^self traitComposition isEmpty 		ifTrue:['{}'] 		ifFalse:[self traitComposition asString].! !!NanoTraitAlias methodsFor: 'accessing' stamp: 'ar 12/19/2009 21:56'!aliases: aCollection	"Collection of associations where key is the	alias and value the original selector."	aliases := aCollection! !!NanoTraitDescription methodsFor: 'operations' stamp: 'ar 12/20/2009 12:35'!@ anArrayOfAssociations 	"Creates an alias"	^ NanoTraitAlias with: self aliases: anArrayOfAssociations! !!NanoTraitAlias methodsFor: 'accessing' stamp: 'ar 12/19/2009 21:55'!aliases	"Collection of associations where key is the	alias and value the original selector."	^aliases! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/27/2009 14:26'!allTraits	"Answer all the traits that are used by myself without their transformations"	^self traitComposition isEmpty 		ifTrue:[#()]		ifFalse:[self traitComposition allTraits].! !!NanoTraitComposition methodsFor: 'converting' stamp: 'ar 12/21/2009 15:14'!+ aTrait	self traitsDo:[:t| (t == aTrait trait) ifTrue:[^NanoTraitCompositionException			signal: 'Trait ' , aTrait trait asString, ' already in composition']].	self addLast: aTrait.	^self! !!Metaclass methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 00:08'!updateTraitsFrom: instanceTraits	"Update me from the given instance traits"	| map newTraits trait |	((instanceTraits isKindOf: NanoTraitComposition) or:[instanceTraits isEmpty]) 		ifFalse:[self error: 'Invalid trait'].	map := Dictionary new.	self traitComposition isEmpty ifFalse:[		self traitComposition do:[:composed| map at: composed trait put: composed].	].	newTraits := (instanceTraits collect:[:composed|		trait := composed trait classTrait.		map at: trait ifAbsent:[trait]]).	self traitComposition isEmpty ifFalse:[		newTraits := newTraits, (self traitComposition select:[:comp| comp trait isBaseTrait]).	].	self installTraitsFrom: newTraits! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4	"This method has a trait conflict"	^self traitConflict! !!NanoTraitComposition methodsFor: 'testing' stamp: 'ar 11/28/2007 21:09'!isTraitTransformation	"Polymorphic with TraitTransformation"	^false! !!NanoClassTrait methodsFor: 'compiling' stamp: 'ar 12/21/2009 20:18'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^baseTrait bindingOf: varName! !!NanoTraitComposition methodsFor: 'operations' stamp: 'ar 5/11/2008 02:13'!isAliasSelector: selector	"enumerates all selectors and methods in a trait composition"	^self anySatisfy:[:any| any isAliasSelector: selector]! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1	"This method has a trait conflict"	^self traitConflict! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!environment: anObject	environment := anObject! !!NanoTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 15:41'!isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent: [nil]) ~~ self! !!NanoTraitDescription methodsFor: 'testing' stamp: 'ar 12/20/2009 02:35'!includesTrait: aTrait	^self == aTrait or:[super includesTrait: aTrait]! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:55'!users: aCollection	users := aCollection! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 12/19/2009 18:38'!soleInstance	^baseTrait! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/27/2009 14:16'!setTraitCompositionFrom: aTraitComposition	"OBSOLETE. Use Class uses: aTraitComposition instead."	(aTraitComposition isKindOf: NanoTraitComposition)		ifTrue:[^self uses: aTraitComposition].	(aTraitComposition isKindOf: TraitComposition)		ifTrue:[^super setTraitCompositionFrom: aTraitComposition].	"Unspecified. Check for prevailing traitOverride"	ClassDescription traitImpl == NanoTrait 		ifTrue:[^self uses: aTraitComposition]		ifFalse:[^super setTraitCompositionFrom: aTraitComposition].! !!NanoTraitExclusion methodsFor: 'composition' stamp: 'ar 11/27/2007 22:10'!includesSelector: selector	"Answers true if the receiver provides the selector"	^(subject includesSelector: selector) and:[(exclusions includes: selector) not]! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:38'!category: aString 	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."	| oldCategory |	oldCategory := category.	aString isString		ifTrue: [			category := aString asSymbol.			SystemOrganization classify: self name under: category ]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance		class: self recategorizedFrom: oldCategory to: category! !!NanoTraitTransformation methodsFor: 'initialize' stamp: 'ar 11/18/2007 17:32'!initialize	super initialize.	users := #().! !!NanoTraitTransformation methodsFor: 'operations' stamp: 'ar 11/22/2007 06:18'!copyTraitExpression	"Copy all except the actual traits"	^self subclassResponsibility! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 08:33'!traitComposition: aTraitComposition	"Install my traits"	^self subclassResponsibility! !!NanoTraitComposition methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:39'!removeTraitUser: aUser	self do:[:each| each removeTraitUser: aUser]! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 11/18/2007 15:33'!isValidTraitName: aSymbol	^(aSymbol isEmptyOrNil		or: [aSymbol first isLetter not]		or: [aSymbol anySatisfy: [:character | character isAlphaNumeric not]]) not! !!NanoTraitAlias methodsFor: 'initialize-release' stamp: 'ar 12/19/2009 22:00'!initialize	super initialize.	aliases := #().! !!NanoTraitAlias class methodsFor: 'instance creation' stamp: 'ar 12/20/2009 12:36'!assertValidAliasDefinition: anArrayOfAssociations	"Throw an exceptions if the alias definition is not valid.	It is expected to be a collection of associations and	the number of arguments of the alias selector has to	be the same as the original selector."	((anArrayOfAssociations isKindOf: Collection) and: [		anArrayOfAssociations allSatisfy: [:each |			each isKindOf: Association]]) ifFalse: [		self error: 'Invalid alias definition: Not a collection of associations.'].		(anArrayOfAssociations allSatisfy: [:association |		(association key numArgs = association value numArgs and: [			(association key numArgs = -1) not])]) ifFalse: [		NanoTraitCompositionException signal: 'Invalid alias definition: Alias and original selector have to have the same number of arguments.']! !!NanoTraitAlias methodsFor: 'operations' stamp: 'ar 12/20/2009 12:35'!copyTraitExpression	"Copy all except the actual traits"	^NanoTraitAlias 		with: subject		aliases: aliases! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:55'!users	^users ifNil:[#()]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/27/2009 14:44'!traitComposition	"Answer my trait composition"	^#()! !!NanoTraitExclusion methodsFor: 'accessing' stamp: 'ar 11/18/2007 18:04'!exclusions	^exclusions! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 03:55'!definition	^String streamContents: [:stream |		stream nextPutAll: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.	].! !!NanoTraitDescription methodsFor: 'operations' stamp: 'ar 12/20/2009 12:36'!+ aTrait	"Creates a composition with the receiver and aTrait"	aTrait traitsDo:[:t| self == t ifTrue:[NanoTraitCompositionException			signal: 'Trait ' , self asString, ' already in composition']].	^NanoTraitComposition withAll: {self}, aTrait asTraitComposition! !!NanoTrait methodsFor: 'testing' stamp: 'ar 5/11/2008 01:57'!hasClassTrait	^true! !!NanoTraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 20:56'!isTraitTransformation	"Polymorphic with TraitTransformation"	^false! !!NanoTraitExclusion methodsFor: 'composition' stamp: 'ar 11/22/2007 06:12'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	^subject selectorsAndMethodsDo:[:sel :meth|		(exclusions includes: sel) ifFalse:[aBlock value: sel value: meth].	].! !!NanoTraitTransformation methodsFor: 'converting' stamp: 'ar 12/7/2009 20:39'!@ anArrayOfAssociations	^self subclassResponsibility! !!NanoTraitMethodState methodsFor: 'accessing' stamp: 'ar 12/22/2009 07:54'!methodHome	"The behavior (trait/class) this method was originally defined in. 	Derived from the originalTraitMethod if any."	^originalTraitMethod ifNil:[super methodHome] ifNotNil:[:m| m methodHome]! !!NanoTrait methodsFor: 'compiling' stamp: 'ar 12/21/2009 20:17'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^self environment bindingOf: varName asSymbol.! !!NanoTraitAlias methodsFor: 'converting' stamp: 'ar 12/20/2009 12:35'!@ anArrayOfAssociations 	^NanoTraitAlias 		with: subject		aliases: (anArrayOfAssociations, self aliases)! !!AdditionalMethodState methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 08:15'!originalTraitMethod	"The original method from the trait.	Only available in TraitMethodState."	^nil! !!NanoTraitComposition methodsFor: 'operations' stamp: 'ar 11/22/2007 06:12'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	self do:[:each| each selectorsAndMethodsDo: aBlock].! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 12/21/2009 15:13'!trait	^self! !!NanoTraitComposition methodsFor: 'accessing' stamp: 'ar 11/22/2007 06:21'!traitsDo: aBlock	^self do:[:each| each traitsDo: aBlock]! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:58'!sharedPools	"Traits have no shared pools"	^ Dictionary new! !!NanoTraitTransformation methodsFor: 'testing' stamp: 'ar 12/20/2009 02:35'!includesTrait: aTrait	^subject includesTrait: aTrait! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 21:48'!classTrait	^self class! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:39'!removeTraitUser: aTrait	users := self users copyWithout: aTrait.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 10:02'!traitAddSelector: selector withMethod: traitMethod	"Add a method inherited from a trait. 	Recompiles to avoid sharing and implement aliasing."	| oldMethod source methodNode newMethod originalSelector |	oldMethod := self compiledMethodAt: selector ifAbsent:[nil].	oldMethod ifNotNil:[		"The following is an important optimization as it prevents exponential		growth in recompilation. If T1 is used by T2 and T2 by T3 then (without		this optimization) any change in T1 would cause all methods in T2 to be		recompiled and each recompilation of a method in T2 would cause T3		to be fully recompiled. The test eliminates all such situations."		(oldMethod sameTraitCodeAs: traitMethod) ifTrue:[^oldMethod].	].	originalSelector := traitMethod selector.	source := traitMethod methodClass sourceCodeAt: originalSelector.	originalSelector == selector ifFalse:[		"Replace source selectors for aliases"		source := self replaceSelector: originalSelector withAlias: selector in: source.	].	methodNode := self compilerClass new 		compile: source in: self classified: nil notifying: nil ifFail:[^nil].	newMethod := methodNode generate: self defaultMethodTrailer.	newMethod putSource: source fromParseNode: methodNode inFile: 2		withPreamble: [:f | f cr; nextPut: $!!; nextChunkPut: 'Trait method'; cr].	newMethod originalTraitMethod: traitMethod.	^super addSelectorSilently: selector withMethod: newMethod.! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 02:55'!theMetaClass	^self! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 11/28/2007 21:00'!obsolete	self name: ('AnObsolete' , self name) asSymbol.	super obsolete! !!NanoTraitDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 16:09'!fileOut	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."	^ self fileOutAsHtml: false! !!NanoTraitComposition methodsFor: 'operations' stamp: 'ar 12/19/2009 18:56'!isLocalAliasSelector: selector	"Return true if the selector aSymbol is an alias defined in the receiver."	^self anySatisfy:[:any| any isTraitTransformation and:[any isLocalAliasSelector: selector]]! !!NanoTraitComposition methodsFor: 'operations' stamp: 'ar 12/20/2009 13:17'!traitCompositionString	"Answer the trait composition string (used for class definitions)"	self size = 0 ifTrue:[^'{}'].	self  size = 1 ifTrue:[^self first asString].	^String streamContents:[:s|		self do:[:each| s nextPutAll: each asString] separatedBy:[s nextPutAll: ' + '].	].! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 12/27/2009 19:40'!definition	^String streamContents: [:stream |		stream nextPutAll: 'Trait named: ';				store: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.		stream cr; tab; nextPutAll: 'category: ';				store: self category asString].! !!NanoClassTrait class methodsFor: 'instance creation' stamp: 'ar 12/20/2009 12:34'!new	| newMeta |	newMeta := super new.	newMeta 		superclass: NanoTrait 		methodDictionary: MethodDictionary new 		format: NanoTrait format.	^newMeta! !!NanoTraitDescription methodsFor: 'operations' stamp: 'ar 12/20/2009 00:52'!notifyOfRecategorizedSelector: element from: oldCategory to: newCategory	super notifyOfRecategorizedSelector: element from: oldCategory to: newCategory.	self users do:[:each| each classify: element under: newCategory from: oldCategory trait: self].! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method has a trait conflict"	^self traitConflict! !!NanoTraitMethodState methodsFor: 'accessing' stamp: 'ar 12/22/2009 07:44'!originalTraitMethod	"The original method from the trait"	^originalTraitMethod! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method has a trait conflict"	^self traitConflict! !!NanoTraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 20:56'!isTrait	^true! !!NanoTraitTransformation methodsFor: 'operations' stamp: 'ar 12/27/2009 14:46'!updateTraits	"Recompute my users traits composition"	users do:[:each| each updateTraits].! !!NanoTraitComposition methodsFor: 'accessing' stamp: 'ar 12/21/2009 15:14'!allTraits	^self gather:[:each| each allTraits copyWith: each trait]! !!NanoTraitComposition methodsFor: 'converting' stamp: 'ar 12/4/2009 21:09'!asTraitComposition	^self! !!NanoTraitTransformation methodsFor: 'testing' stamp: 'ar 11/22/2007 04:24'!isTraitTransformation	"Polymorphic with Trait"	^true! !!NanoTrait class methodsFor: 'initialize' stamp: 'ar 12/29/2009 16:26'!initialize	"Install NanoTraits"	self install.! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 10:04'!sameTraitCodeAs: method	"Answer whether the receiver implements the same code as the 	argument, method. Does not look at properties/pragmas since they	do not affect the resulting code."	| numLits |	(method isKindOf: CompiledMethod) ifFalse: [^false].	self methodHome == method methodHome ifFalse:[^false].	(self properties analogousCodeTo: method properties) ifFalse:[^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(numLits := self numLiterals) ~= method numLiterals ifTrue: [^false].	1 to: numLits-2 do:[:i| | lit1 lit2 |		lit1 := self literalAt: i.		lit2 := method literalAt: i.		lit1 = lit2 ifFalse:[			(i = 1 and: [#(117 120) includes: self primitive]) ifTrue: [				lit1 isArray ifTrue:[					(lit2 isArray and: [lit1 allButLast = lit2 allButLast]) ifFalse:[^false]				] ifFalse: "ExternalLibraryFunction"					[(lit1 analogousCodeTo: lit2) ifFalse:[^false]].			] ifFalse:[				lit1 isFloat 					ifTrue:[(lit1 closeTo: lit2) ifFalse: [^false]]					ifFalse:["any other discrepancy is a failure"^ false]]]].	^true! !!NanoTraitTransformation methodsFor: 'converting' stamp: 'ar 12/20/2009 12:36'!+ aTrait	"Just like ordered collection"	^NanoTraitComposition withAll: {self. aTrait}! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 00:06'!basicRemoveSelector: aSelector	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Update the trait composition."	| oldMethod |	oldMethod := super basicRemoveSelector: aSelector.	oldMethod ifNotNil:[self updateTraits].	^oldMethod! !!NanoTraitTransformation methodsFor: 'testing' stamp: 'ar 5/11/2008 02:13'!isAliasSelector: selector	^subject isAliasSelector: selector! !!NanoTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:59'!isBaseTrait	^true! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 02:50'!includesLocalSelector: selector	self traitComposition isEmpty "guard for Berne traits"		ifTrue:[^self includesSelector: selector].	^(self traitComposition isKindOf: NanoTraitComposition)		ifTrue:[(self compiledMethodAt: selector ifAbsent:[^false]) methodHome == self]		ifFalse:[super includesLocalSelector: selector].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 11/28/2007 20:51'!isLocalMethod: aCompiledMethod	"Answer true if the method is a local method, e.g., defined in the receiver instead of a trait."	^aCompiledMethod methodHome == self! !!NanoTraitExclusion methodsFor: 'composition' stamp: 'ar 12/20/2009 13:48'!printOn: aStream	"Answer the trait composition string (used for class definitions)"	aStream nextPutAll: subject asString.	aStream nextPutAll: ' - {'.	exclusions asArray sort do:[:exc| aStream store: exc] separatedBy:[aStream nextPutAll: '. '].	aStream nextPutAll: '}'.! !!NanoTraitDescription methodsFor: 'operations' stamp: 'ar 11/28/2007 20:59'!traitsDo: aBlock	aBlock value: self.! !!NanoTraitDescription methodsFor: 'operations' stamp: 'ar 12/19/2009 23:54'!installTraitsFrom: aTraitComposition	super installTraitsFrom: aTraitComposition.	self users do:[:each| each updateTraits].! !!NanoTraitAlias methodsFor: 'testing' stamp: 'ar 12/19/2009 22:01'!isAliasSelector: selector	^(self isLocalAliasSelector: selector) or:[super isAliasSelector: selector]! !!NanoTraitTransformation methodsFor: 'accessing' stamp: 'ar 12/21/2009 15:13'!trait	^subject trait! !!NanoTrait methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 18:06'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	super fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex.	self classSide hasMethods ifTrue:[		aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.			self classSide				fileOutOn: aFileStream				moveSource: moveSource				toFile: fileIndex].! !!NanoTraitTransformation methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:40'!removeTraitUser: aTrait	users := users copyWithout: aTrait.	subject removeTraitUser: aTrait.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 12:38'!uses: aTraitComposition	| newTraits |	newTraits := (aTraitComposition isKindOf: NanoTrait orOf: NanoTraitTransformation) 		ifTrue:[NanoTraitComposition with: aTraitComposition]		ifFalse:[(aTraitComposition isKindOf: SequenceableCollection)					ifTrue:[NanoTraitComposition withAll: aTraitComposition asArray]					ifFalse:[self error: 'Invalid traits specification']].	self installTraitsFrom: newTraits.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/21/2009 15:13'!traits	"Answer an array of my traits"	^self traitComposition asArray collect:[:composed| composed trait]! !!NanoTraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 21:01'!isBaseTrait	^false! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 11/18/2007 15:41'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	(newName := aString asSymbol) ~= self name		ifFalse: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	self environment renameClass: self as: newName.	name := newName! !!NanoTraitComposition methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:41'!addTraitUser: aUser	self do:[:each| each addTraitUser: aUser]! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 08:23'!originalTraitMethod	"Remember the original trait method for the receiver."	^self properties originalTraitMethod! !!NanoTraitTransformation methodsFor: 'operations' stamp: 'ar 11/22/2007 06:12'!updateSelector: aSelector withTraitMethod: compiledMethod from: aTrait	"broadcasts the change of a selector to all users of a trait"	^self subclassResponsibility! !!NanoClassTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:59'!isClassTrait	^true! !!NanoTrait class methodsFor: 'installing' stamp: 'ar 12/29/2009 16:26'!install		"NanoTrait install"	"Installs NanoTraits"	"Force recompilation of basic classes to get traits aliasing right"	{Behavior. ClassDescription. Class. Metaclass} do:[:aClass| 		aClass selectorsDo:[:sel|			aClass 				compile: (aClass sourceCodeAt: sel)				classified: (aClass organization categoryOfElement: sel)				withStamp: (aClass compiledMethodAt: sel) timeStamp 				notifying: nil].		aClass setTraitCompositionFrom: {}].	ClassDescription traitImpl: self. 		"Create all new traits as NanoTraits"	self updateTraits: Smalltalk allTraits.	"And convert everything to NanoTraits"	Smalltalk allClassesAndTraitsDo:[:aClass|		aClass traitComposition isEmpty 			ifTrue:[aClass traitComposition: nil].		aClass classSide traitComposition isEmpty 			ifTrue:[aClass classSide traitComposition: nil]].	"TWriteStreamTest has the class traits reversed which which will be undone	by installation. Put it back in reverse order to keep MC happy."	TWriteStreamTest classTrait		uses: TSequencedStreamTest classTrait + TPuttableStreamTest classTrait! !!NanoTraitComposition methodsFor: 'converting' stamp: 'ar 12/20/2009 02:38'!printOn: aStream	"Answer the trait composition string (used for class definitions)"	aStream nextPutAll: self traitCompositionString.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/27/2009 14:16'!setTraitComposition: aTraitComposition	"OBSOLETE. Use Class uses: aTraitComposition instead."	(aTraitComposition isKindOf: NanoTraitComposition)		ifTrue:[^self uses: aTraitComposition].	(aTraitComposition isKindOf: TraitComposition)		ifTrue:[^super setTraitComposition: aTraitComposition].	"Unspecified. Check for prevailing traitOverride"	ClassDescription traitImpl == NanoTrait 		ifTrue:[^self uses: aTraitComposition]		ifFalse:[^super setTraitComposition: aTraitComposition].! !!Array methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 02:33'!asTraitComposition	"For convenience the composition {T1. T2 ...} is the same as T1 + T2 + ..."	^self isEmpty		ifFalse: [			self size = 1				ifTrue: [self first asTraitComposition]				ifFalse: [					self copyWithoutFirst 						inject: self first						into: [:left :right | left + right]]]		ifTrue: [ClassDescription newTraitComposition]! !!NanoTrait class methodsFor: 'instance creation' stamp: 'ar 12/20/2009 12:34'!named: aSymbol uses: aTraitComposition category: aString env: anEnvironment	| trait oldTrait systemCategory oldCategory |	systemCategory := aString asSymbol.	oldTrait := anEnvironment at: aSymbol ifAbsent: [nil].	oldTrait ifNil:[		trait := NanoClassTrait new new.	] ifNotNil:[		oldCategory := oldTrait category.		trait := oldTrait.	].	(trait isKindOf: NanoTrait) ifFalse: [		^self error: trait name , ' is not a Trait'].	trait		setName: aSymbol		andRegisterInCategory: systemCategory		environment: anEnvironment.	trait uses: aTraitComposition.		"... notify interested clients ..."	oldTrait ifNil:[		SystemChangeNotifier uniqueInstance classAdded: trait inCategory: systemCategory.	] ifNotNil:[		systemCategory = oldCategory  ifFalse:[			SystemChangeNotifier uniqueInstance class: trait 				recategorizedFrom: oldTrait category to: systemCategory].	].	^ trait! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 02:36'!includesTrait: aTrait	^self traitComposition includesTrait: aTrait! !!NanoTraitExclusion methodsFor: 'converting' stamp: 'ar 12/20/2009 12:38'!- anArrayOfSelectors	^NanoTraitExclusion		with: subject		exclusions: (anArrayOfSelectors, exclusions asArray)! !!NanoTrait class methodsFor: 'public' stamp: 'ar 12/27/2009 19:07'!newTemplateIn: categoryString	^String streamContents: [:stream |		stream			nextPutAll: 'Trait named: #NameOfTrait';			cr; tab;			nextPutAll: 'uses: {}';			cr; tab;			nextPutAll: 'category: ';			nextPut: $';			nextPutAll: categoryString;			nextPut: $' ]! !!AdditionalMethodState methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 00:30'!originalTraitOrClass	"The original trait for this method"	^method methodClass! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/19/2009 21:14'!replaceSelector: originalSelector withAlias: aliasSelector in: source	"replaces originalSelector with aliasSelector in in given source code"	| oldKeywords newKeywords args selectorWithArgs s |	oldKeywords := originalSelector keywords.	newKeywords := aliasSelector keywords.	oldKeywords size = newKeywords size ifFalse:[self error: 'Keyword mismatch'].	args := (self parserClass new parseArgsAndTemps: source asString notifying: nil) 				copyFrom: 1 to: originalSelector numArgs.	selectorWithArgs := String streamContents: [:stream |		newKeywords keysAndValuesDo: [:index :keyword |			stream nextPutAll: keyword.			stream space.			args size >= index ifTrue: [				stream nextPutAll: (args at: index); space]]].	s := source asString readStream.	oldKeywords do: [ :each | s match: each ].	args isEmpty ifFalse: [ s match: args last ].	^selectorWithArgs withBlanksTrimmed asText , s upToEnd! !!NanoTraitAlias methodsFor: 'operations' stamp: 'ar 12/19/2009 22:00'!includesSelector: selector	"Answers true if the receiver provides the selector"	^(subject includesSelector: selector) or:[aliases anySatisfy:[:assoc| assoc key == selector]]! !!NanoTraitDescription methodsFor: 'converting' stamp: 'ar 12/20/2009 12:35'!asTraitComposition	^NanoTraitComposition with: self! !!NanoTraitDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 16:08'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| internalStream |	internalStream := WriteStream on: (String new: 100).	internalStream header; timeStamp.	self fileOutOn: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true useHtml: useHtml.! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 21:44'!name	^baseTrait name, ' classTrait'! !!NanoTrait class methodsFor: 'public' stamp: 'ar 12/27/2009 14:32'!allTraitsDo: aBlock	"Evaluate aBlock with all the instance and class traits present in the system"	NanoClassTrait allInstances do: [:metaTrait|		aBlock value: metaTrait instanceSide.		aBlock value: metaTrait.	].! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 14:29'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^baseTrait! !!NanoTrait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:46'!classDefinitions	| definitions |	definitions := OrderedCollection with: self asClassDefinition.	(self hasClassTrait		and: [self classTrait hasTraitComposition]		and: [self classTrait traitComposition isEmpty not])			ifTrue: [definitions add: self classTrait asMCDefinition].	^definitions asArray! !!NanoTraitComposition methodsFor: 'converting' stamp: 'ar 11/18/2007 23:13'!- anArray	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"		self addLast: (self removeLast - anArray)! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:08'!classSide	^self! !!NanoTraitDescription methodsFor: 'printing' stamp: 'ar 12/27/2009 19:16'!printUsersOf: aClass on: aStream level: indent	aStream crtab: indent.	aStream nextPutAll: aClass name.	aClass isTrait ifTrue:[		aClass users do:[:each| self printUsersOf: aClass on: aStream level: indent+1].	].! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!environment	^environment! !!NanoTraitComposition methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:33'!addUser: aUser	^self addTraitUser: aUser! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/19/2009 23:43'!users	^#()! !!NanoTraitTransformation methodsFor: 'converting' stamp: 'ar 11/18/2007 17:44'!asTraitTransform	^self! !!NanoTraitTransformation methodsFor: 'operations' stamp: 'ar 11/22/2007 06:12'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	^self subclassResponsibility! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 00:57'!localSelectors	^(self traitComposition isKindOf: NanoTraitComposition)		ifTrue:[self selectors select:[:sel| self includesLocalSelector: sel]]		ifFalse:[super localSelectors].! !!NanoTraitComposition methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:33'!removeUser: aUser	^self removeTraitUser: aUser! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 13:19'!updateTraits	"Recompute my local traits composition"	(self traitComposition isKindOf: NanoTraitComposition)		ifTrue:[self installTraitsFrom: self traitComposition].! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:42'!traitComposition: aTraitComposition	traitComposition := aTraitComposition.! !!NanoTraitTransformation methodsFor: 'accessing' stamp: 'ar 11/22/2007 06:08'!traitsDo: aBlock	^subject traitsDo: aBlock! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method has a trait conflict"	^self traitConflict! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:42'!addTraitUser: aTrait	users := self users copyWith: aTrait.! !!NanoTrait class methodsFor: 'public' stamp: 'ar 12/21/2009 20:24'!newTraitComposition	"Creates a new TraitComposition"	^NanoTraitComposition new! !!NanoTraitMethodState methodsFor: 'accessing' stamp: 'ar 12/28/2009 00:30'!originalTraitOrClass	"The original trait for this method"	^originalTraitMethod originalTraitOrClass! !!NanoTraitAlias methodsFor: 'operations' stamp: 'ar 12/19/2009 22:14'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	subject selectorsAndMethodsDo:[:sel :meth|		aBlock value: sel value: meth.	].	aliases do:[:assoc| | method |		"Method can be nil during removals"		method := subject compiledMethodAt: assoc value ifAbsent:[nil].		method ifNotNil:[aBlock value: assoc key value: method].	].! !!NanoTrait class methodsFor: 'installing' stamp: 'ar 12/28/2009 03:03'!unloadNanoTraits	"Unload NanoTraits"	ClassDescription traitImpl == self 		ifTrue:[ClassDescription traitImpl: nil].	CompiledMethod allInstancesDo:[:cm|		"Clean out NanoTraitState for all methods; this makes all methods local"		(cm properties isKindOf: NanoTraitMethodState) ifTrue:[			cm penultimateLiteral: (AdditionalMethodState newFrom: cm properties).		].	].	self allTraitsDo:[:trait|		"Clean out the existing users for this trait"		trait users do:[:user| user uses: {}].	].	"We need a stub updateTraits method during unload"	[Behavior halt compileSilently: 'updateTraits' classified: nil.	"Finally, unload NanoTraits"	(MCPackage named: 'NanoTraits') unload.	] ensure:[Behavior removeSelectorSilently: #updateTraits].	Smalltalk allClassesAndTraitsDo:[:aClass|		"Clean out existing NanoTraitCompositions"		(aClass traitComposition class isObsolete) 			ifTrue:[aClass traitComposition: #()].		(aClass classSide traitComposition class isObsolete) 			ifTrue:[aClass classSide traitComposition: #()].	].	Smalltalk at: #Trait ifPresent:[:aClass|		aClass isObsolete ifTrue:[Smalltalk at: #Trait put: nil].	].	Compiler recompileAll.! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 23:00'!baseTrait	^baseTrait! !!NanoTraitAlias class methodsFor: 'instance creation' stamp: 'ar 11/18/2007 17:45'!with: aTraitComposition aliases: anArrayOfAssociations	self assertValidAliasDefinition: anArrayOfAssociations.	^self new		subject: aTraitComposition;		initializeFrom: anArrayOfAssociations;		yourself! !!NanoTraitDescription methodsFor: 'copying' stamp: 'ar 11/28/2007 20:55'!copy 	self error: 'Traits cannot be trivially copied'! !!NanoTraitComposition methodsFor: 'compat' stamp: 'ar 12/20/2009 14:00'!removeFromComposition: aTrait	"--- ignore ---"! !!NanoTrait class methodsFor: 'public' stamp: 'ar 12/27/2009 14:11'!newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString	"Creates a new trait."	| env |	env := self environment.	^self		named: aSymbol		uses: aTraitCompositionOrCollection		category: aString		env: env! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 03:55'!definitionST80	^String streamContents: [:stream |		stream nextPutAll: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.	].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 13:31'!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in my or in another composition somewhere deeper in 	the tree of traits compositions."	^(self includesLocalSelector: aSymbol) not		and: [self hasTraitComposition]		and: [self traitComposition isAliasSelector: aSymbol]! !!NanoClassTrait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:49'!asMCDefinition	^Smalltalk at: #MCClassTraitDefinition ifPresent:[:aClass|		aClass			baseTraitName: self baseTrait name			classTraitComposition: self traitCompositionString	].! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:14'!traitComposition	^traitComposition ifNil:[traitComposition := NanoTraitComposition new]! !!NanoTraitExclusion methodsFor: 'composition' stamp: 'ar 12/20/2009 12:38'!copyTraitExpression	"Copy all except the actual traits"	^NanoTraitExclusion 		with: subject		exclusions: exclusions asArray! !!NanoTraitExclusion methodsFor: 'initialize' stamp: 'ar 11/18/2007 17:16'!initialize	super initialize.	exclusions := Set new.! !!NanoTraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 21:01'!isClassTrait	^false! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 12:52'!classify: selector under: heading from: category trait: aTrait	"Update the organization for a trait. the dumb, unoptimized version"	self updateTraits.! !!NanoClassTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:21'!isMeta	^true! !!NanoTraitTransformation methodsFor: 'testing' stamp: 'ar 5/11/2008 02:17'!isLocalAliasSelector: selector	^false! !!NanoTraitComposition methodsFor: 'operations' stamp: 'ar 11/22/2007 06:20'!copyTraitExpression	"Copy all except the actual traits"	^self collect:[:each| each copyTraitExpression].! !!NanoTraitMethodState methodsFor: 'accessing' stamp: 'ar 12/22/2009 07:44'!originalTraitMethod: aCompiledMethod	"The original method from the trait"	originalTraitMethod := aCompiledMethod! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!name	^name! !!NanoTraitAlias methodsFor: 'testing' stamp: 'ar 12/19/2009 22:01'!isLocalAliasSelector: selector	^(aliases anySatisfy:[:assoc| assoc key == selector])! !!NanoClassTrait methodsFor: 'initialize' stamp: 'ar 12/21/2009 15:14'!updateTraitsFrom: instanceTraits	"Update me from the given instance traits"	| map newTraits trait |	map := Dictionary new.	self traitComposition do:[:composed| map at: composed trait put: composed].	newTraits := (instanceTraits collect:[:composed|		trait := composed trait classTrait.		map at: trait ifAbsent:[trait]] 	), (self traitComposition select:[:comp| comp trait isBaseTrait]).	self installTraitsFrom: newTraits! !!NanoTraitDescription methodsFor: 'operations' stamp: 'ar 12/20/2009 12:37'!- anArrayOfSelectors	"Creates an exclusion"	^NanoTraitExclusion		with: self		exclusions: anArrayOfSelectors! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 11/28/2007 21:00'!removeFromSystem	self removeFromSystem: true! !!NanoTrait class methodsFor: 'installing' stamp: 'ar 12/27/2009 23:50'!updateTraits: aCollection	"Convert all the traits in aCollection to NanoTraits. Used during installation."	"ClassDescription traitImpl: NanoTrait.	NanoTrait updateTraits:{		TSequencedStreamTest. TGettableStreamTest. TReadStreamTest.		TStreamTest. TPuttableStreamTest. TWriteStreamTest	}"	| remain processed classes oldTrait classDef newTrait count instTraits classSelectors |	ClassDescription traitImpl == self ifFalse:[self error: 'What are you doing???'].	remain := (aCollection reject:[:tc| tc isKindOf: self]) asSet.	processed := Set new.	classes := Set new.	count := 0.	'Converting ....' displayProgressAt: Sensor cursorPoint from: 1 to: remain size during:[:bar|	[remain isEmpty] whileFalse:[		"Pick any trait whose traits are already converted"		oldTrait := remain detect:[:any| 			any traitComposition traits allSatisfy:[:t| (Smalltalk at: t name) isKindOf: self].		] ifNone:[self error: 'Cannot convert cyclic traits'].		remain remove: oldTrait.		bar value: (count := count +1).		ProgressNotification signal: '' extra: 'Converting ', oldTrait name.		"Silently remove the old trait class and recreate it based on NanoTrait"		classDef := oldTrait definition.		Smalltalk removeKey: oldTrait name.		"Create the NanoTrait from the same definition"		newTrait := Compiler evaluate: classDef.		"Update comment"		oldTrait organization classComment ifNotEmpty:[			newTrait classComment: oldTrait organization commentRemoteStr 						stamp: oldTrait organization commentStamp.		].		"Copy local methods to new trait"		oldTrait localSelectors do:[:sel|			newTrait 				compile: (oldTrait sourceCodeAt: sel)				classified: (oldTrait organization categoryOfElement: sel)				withStamp: (oldTrait compiledMethodAt: sel) timeStamp 				notifying: nil		].		oldTrait classSide localSelectors do:[:sel|			newTrait classSide				compile: (oldTrait classSide sourceCodeAt: sel)				classified: (oldTrait classSide organization categoryOfElement: sel)				withStamp: (oldTrait classSide compiledMethodAt: sel) timeStamp 				notifying: nil		].		newTrait selectors sort = oldTrait selectors sort			ifFalse:[self error: 'Something went VERY wrong'].		newTrait classSide selectors sort = oldTrait classSide selectors sort			ifFalse:[self error: 'Something went VERY wrong'].		processed add: oldTrait.		classes addAll: (oldTrait users reject:[:aClass| aClass isObsolete]).	].	].	classes := classes asArray select:[:cls| cls isKindOf: ClassDescription].	'Updating ....' displayProgressAt: Sensor cursorPoint from: 1 to: classes size during:[:bar|	"The traits are all converted, next update the classes"	classes keysAndValuesDo:[:index :aClass|		bar value: index.		ProgressNotification signal: '' extra: 'Updating ', aClass name.		instTraits := Compiler evaluate: aClass traitComposition asString.		"Keep the local selectors from before"		localSelectors := aClass localSelectors.		classSelectors := aClass class localSelectors.		"Nuke the old traits composition"		aClass traitComposition: nil.		aClass class traitComposition: nil.		"Install the new one"		aClass uses: instTraits.		"Remove the old trait (now local) selectors"		(aClass selectors reject:[:sel| localSelectors includes: sel]) do:[:sel| 			aClass removeSelectorSilently: sel.			(aClass includesSelector: sel) ifFalse:[self halt: 'Where is the code?'].		].		(aClass class selectors reject:[:sel| classSelectors includes: sel]) do:[:sel|			aClass class removeSelectorSilently: sel.			(aClass class includesSelector: sel) ifFalse:[self halt: 'Where is the code?'].		].	].	].	"Finally, obsolete all the old traits"	processed do:[:trait| trait obsolete].! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	category ifNotNilDo: [ :symbol |		((SystemOrganization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	category := (result := SystemOrganization categoryOfElement: self name).	^result! !!NanoTraitExclusion methodsFor: 'accessing' stamp: 'ar 11/18/2007 18:04'!exclusions: aCollection	exclusions := Set withAll: aCollection! !!NanoTraitTransformation methodsFor: 'accessing' stamp: 'ar 11/18/2007 19:12'!allTraits	^subject allTraits! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 14:01'!addUser: aTrait	^self addTraitUser: aTrait! !!NanoTraitTransformation methodsFor: 'converting' stamp: 'ar 12/20/2009 13:44'!asTraitComposition	^NanoTraitComposition with: self! !!NanoTraitExclusion methodsFor: 'converting' stamp: 'ar 12/20/2009 12:37'!@ anArrayOfAssociations 	NanoTraitCompositionException signal: 'Invalid trait exclusion. Aliases have to be specified before exclusions.'! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 03:13'!traitRemoveSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	| priorMethod priorProtocol | 	priorMethod := self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol := self whichCategoryIncludesSelector: selector.	SystemChangeNotifier uniqueInstance doSilently: [		self organization removeElement: selector].	super basicRemoveSelector: selector.	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.	(self organization isEmptyCategoryNamed: priorProtocol)		ifTrue:[self organization removeCategory: priorProtocol].! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3	"This method has a trait conflict"	^self traitConflict! !!NanoClassTrait methodsFor: 'initialize' stamp: 'ar 12/20/2009 12:36'!uses: aTraitComposition	| newTraits |	newTraits := (aTraitComposition isTrait or:[aTraitComposition isTraitTransformation]) 		ifTrue:[NanoTraitComposition with: aTraitComposition]		ifFalse:[(aTraitComposition isKindOf: SequenceableCollection)					ifTrue:[NanoTraitComposition withAll: aTraitComposition asArray]					ifFalse:[self error: 'Invalid traits specification']].	newTraits traitsDo:[:t|		(t isBaseTrait and:[t classSide hasMethods]) 			ifTrue:[self error: 'Cannot add: ', t].		(t isClassTrait and:[(baseTrait includesTrait: t baseTrait) not]) 			ifTrue:[self error: 'Cannot add: ', t].	].	self installTraitsFrom: newTraits.! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2	"This method has a trait conflict"	^self traitConflict! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 14:01'!removeUser: aTrait	^self removeTraitUser: aTrait! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:57'!allClassVarNames	"Traits have no class var names"	^#()! !!NanoTraitTransformation methodsFor: 'accessing' stamp: 'ar 11/18/2007 19:12'!subject: aSubject	subject := aSubject.! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/28/2009 00:30'!originalTraitOrClass	"The original trait for this method"	^self properties originalTraitOrClass! !!NanoTraitAlias methodsFor: 'initialize-release' stamp: 'ar 12/20/2009 12:37'!initializeFrom: anArrayOfAssociations	| newNames |	newNames := (anArrayOfAssociations collect: [:each | each key]) asIdentitySet.	newNames size < anArrayOfAssociations size ifTrue: [		NanoTraitCompositionException signal: 'Cannot use the same alias name twice'].	anArrayOfAssociations do: [:each |		(newNames includes: each value) ifTrue: [			NanoTraitCompositionException signal: 'Cannot define an alias for an alias']].	aliases := anArrayOfAssociations.! !!NanoTraitComposition methodsFor: 'converting' stamp: 'ar 11/18/2007 23:12'!@ anArrayOfAssociations	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"	self addLast: (self removeLast @ anArrayOfAssociations)! !!NanoTraitComposition methodsFor: 'accessing' stamp: 'ar 5/11/2008 02:30'!traits	^Array streamContents:[:s| self traitsDo:[:t| s nextPut: t]]! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 21:45'!new	baseTrait ifNotNil:[self error: 'Already initialized'].	baseTrait := self basicNew initialize.	baseTrait		superclass: nil 		methodDictionary: MethodDictionary new 		format: Object format.	^baseTrait! !!NanoClassTrait methodsFor: 'accessing' stamp: 'ar 5/11/2008 01:51'!instanceSide	^self baseTrait! !!NanoTraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:58'!classPool	"Traits have no class pool"	^ Dictionary new! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 12/20/2009 03:55'!definitionST80	^String streamContents: [:stream |		stream nextPutAll: 'Trait named: ';				store: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.		stream cr; tab; nextPutAll: 'category: ';				store: self category asString].! !!NanoTraitTransformation methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:42'!addTraitUser: aTrait	users := users copyWith: aTrait.	subject addTraitUser: aTrait.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/20/2009 12:59'!hasTraitComposition	^self traitComposition notEmpty! !!NanoTrait methodsFor: 'accessing' stamp: 'ar 12/21/2009 19:49'!baseTrait	^self! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/22/2009 07:57'!originalTraitMethod: aCompiledMethod	"Remember the original trait method for the receiver."	| methodState |	methodState := NanoTraitMethodState newFrom: self properties.	methodState originalTraitMethod: aCompiledMethod.	self penultimateLiteral:  methodState.! !!NanoTraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:47'!conflict	"This method has a trait conflict"	^self traitConflict! !!NanoTraitComposition methodsFor: 'testing' stamp: 'ar 12/20/2009 02:35'!includesTrait: aTrait	^self anySatisfy:[:each| each includesTrait: aTrait]! !NanoTrait initialize!