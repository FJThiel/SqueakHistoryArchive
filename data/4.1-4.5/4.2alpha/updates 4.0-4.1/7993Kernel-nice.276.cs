"Change Set:		7993Kernel-nice.276Kernel-nice.276:Track keys and selectors usage, use #includesSelector: #selectorsDo: and #asSet where due+ make #classVarNames a sorted ArrayKernel-nice.274:use #fasterKeysMy guess is that ClassDescription >> #organization and #classVariablesString should be traitified, so I did not publish my changes.Though I got no warning, no indication of trait, no nothing...I wonder how to work in a traitified image without trait aware tools...Kernel-nice.275:use #fasterKeys bisclassVariablesString was not traitified"!!Behavior methodsFor: 'testing method dictionary' stamp: 'nice 10/20/2009 20:08'!whichSelectorsAccess: instVarName 	"Answer a collection of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex := self allInstVarNames indexOf: instVarName ifAbsent: [^IdentitySet new].	^ self methodDict keys select: 		[:sel | 		((self methodDict at: sel)			readsField: instVarIndex)			or: [(self methodDict at: sel) writesField: instVarIndex]]	"Point whichSelectorsAccess: 'x'."! !!Object methodsFor: 'events-removing' stamp: 'nice 10/19/2009 22:19'!removeActionsSatisfying: aBlock	self actionMap fasterKeys do:		[:eachEventSelector |			self   				removeActionsSatisfying: aBlock				forEvent: eachEventSelector		]! !!Behavior methodsFor: 'testing method dictionary' stamp: 'nice 10/20/2009 20:08'!whichSelectorsStoreInto: instVarName 	"Answer a collection of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex := self allInstVarNames indexOf: instVarName ifAbsent: [^IdentitySet new].	^ self methodDict keys select: 		[:sel | (self methodDict at: sel) writesField: instVarIndex]	"Point whichSelectorsStoreInto: 'x'."! !!ClassDescription methodsFor: 'instance variables' stamp: 'nice 10/20/2009 20:48'!chooseClassVarName 	"Present the user with a list of class variable names and answer the one selected, or nil if none"	| lines labelStream allVars index |	lines := OrderedCollection new.	allVars := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[:class | | vars |		vars := class classVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^Beeper beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index := (UIManager default chooseFrom: (labelStream contents substrings) lines: lines).	index = 0 ifTrue: [^ nil].	^ allVars at: index! !!Class methodsFor: 'class variables' stamp: 'nice 10/20/2009 22:02'!classVarNames	"Answer a collection of the names of the class variables defined in the receiver."	^self classPool keys asArray sort! !!Class methodsFor: 'fileIn/Out' stamp: 'nice 10/19/2009 21:56'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName aValue |	(aPool  isKindOf: SharedPool class) ifTrue:[^self notify: 'we do not fileout SharedPool type shared pools for now'].	aPoolName := self environment keyAtIdentityValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool fasterKeys sort do: [ :aKey |		aValue := aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'nice 10/19/2009 21:56'!cleanupClassHierarchyFor: aClassDescription		| myName mySuperclass |	mySuperclass := aClassDescription superclass.	(self isReallyObsolete: aClassDescription) ifTrue: [				"Remove class >>>from SystemDictionary if it is obsolete"		myName := aClassDescription name asString.		Smalltalk fasterKeys do: [:each | 			(each asString = myName and: [(Smalltalk at: each) == aClassDescription])				ifTrue: [Smalltalk removeKey: each]].		"Make class officially obsolete if it is not"		(aClassDescription name asString beginsWith: 'AnObsolete')			ifFalse: [aClassDescription obsolete].		aClassDescription isObsolete 			ifFalse: [self error: 'Something wrong!!'].		"Add class to obsoleteSubclasses of its superclass"		mySuperclass			ifNil: [self error: 'Obsolete subclasses of nil cannot be stored'].		(mySuperclass obsoleteSubclasses includes: aClassDescription)			ifFalse: [mySuperclass addObsoleteSubclass: aClassDescription].	] ifFalse:[		"check if superclass has aClassDescription in its obsolete subclasses"		mySuperclass ifNil:[mySuperclass := Class]. "nil subclasses"		mySuperclass removeObsoleteSubclass: aClassDescription.	].	"And remove its obsolete subclasses if not actual superclass"	aClassDescription obsoleteSubclasses do:[:obs|		obs superclass == aClassDescription ifFalse:[			aClassDescription removeObsoleteSubclass: obs]].! !!ClassDescription methodsFor: 'printing' stamp: 'nice 10/19/2009 23:59'!classVariablesString	"Answer a string of my class variable names separated by spaces."	^String streamContents: [ :stream | 		self classPool fasterKeys sort 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream space ] ]! !!ClassDescription methodsFor: 'instance variables' stamp: 'nice 10/20/2009 20:56'!replaceSilently: old to: new	"text-replace any part of a method.  Used for class and pool variables.  Don't touch the header.  Not guaranteed to work if name appears in odd circumstances"	| oldCode newCode parser header body sels oldName newName |	oldName := old asString.	newName := new asString.	self withAllSubclasses do:		[:cls | sels := cls selectors asSet.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode := cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser := cls parserClass new) parseSelector: oldCode.			header := oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body := header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode := header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode := cls comment.				newCode := oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!Class methodsFor: 'class variables' stamp: 'nice 10/20/2009 20:47'!allClassVarNames	"Answer a Set of the names of the receiver's class variables, including those	defined in the superclasses of the receiver."	| aSet |	self superclass == nil		ifTrue: 			[^self classVarNames asSet]  "This is the keys so it is a new Set."		ifFalse: 			[aSet := self superclass allClassVarNames.			aSet addAll: self classVarNames.			^aSet]! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'nice 10/20/2009 22:03'!classVarNames	"Answer a collection of the receiver's class variable names."	^#()! !!InstructionPrinter class methodsFor: 'printing' stamp: 'nice 10/20/2009 21:16'!printClass: class 	"Create a file whose name is the argument followed by '.bytes'. Store on 	the file the symbolic form of the compiled methods of the class."	| file |	file := FileStream newFileNamed: class name , '.bytes'.	class selectorsDo: 		[:sel | 		file cr; nextPutAll: sel; cr.		(self on: (class compiledMethodAt: sel)) printInstructionsOn: file].	file close	"InstructionPrinter printClass: Parser."! !!Class methodsFor: 'initialize-release' stamp: 'nice 10/19/2009 21:56'!declare: varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| newVars conflicts |	newVars := 		(Scanner new scanFieldNames: varString)			collect: [:x | x asSymbol].	newVars do:		[:var | var first canBeGlobalVarInitial			ifFalse: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].	conflicts := false.	classPool == nil 		ifFalse: [(classPool fasterKeys reject: [:x | newVars includes: x]) do: 					[:var | self removeClassVarName: var]].	(newVars reject: [:var | self classPool includesKey: var])		do: [:var | "adding"			"check if new vars defined elsewhere"			(self bindingOf: var) notNil				ifTrue: 					[self error: var , ' is defined elsewhere'.					conflicts := true]].	newVars size > 0		ifTrue: 			[classPool := self classPool.			"in case it was nil"			newVars do: [:var | classPool declare: var from: Undeclared]].	^conflicts! !