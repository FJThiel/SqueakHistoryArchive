"Change Set:		7185Kernel-auto.172Kernel-auto.172:This is an automatic commit from the 3.10.2 to cover the delta between 3.10 and 3.10.2 in the repositories"!!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 3/10/2008 23:13'!makeFloatFromMantissa: m exponent: k base: aRadix 	"Convert infinite precision arithmetic into Floating point.	This alogrithm rely on correct IEEE rounding mode	being implemented in Integer>>asFloat and Fraction>>asFloat"	| p |	p := aRadix lowBit - 1.	^k positive		ifTrue: [(m * (((aRadix bitShift: p negated) raisedToInteger: k))) asFloat timesTwoPower: p*k]		ifFalse: [(Fraction numerator: m denominator: (((aRadix bitShift: p negated) raisedToInteger: k negated) bitShift: p*k negated)) asFloat]! !!Duration methodsFor: 'ansi protocol' stamp: 'KLC 5/12/2008 13:42'!seconds	"Answer the number of seconds the receiver represents."	^seconds rem: SecondsInMinute! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'KLC 5/9/2008 20:13'!now 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick := nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [	 	 		LastTick _  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:50'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart numberOfNonZeroFractionDigits mantissa decimalMultiplier decimalFraction value numberOfTrailingZeroInFractionPart |	neg := sourceStream peekFor: $-.	integerPart := self nextUnsignedIntegerBase: base ifFail: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].		(sourceStream nextMatchAll: 'Infinity')			ifTrue: [^ neg					ifTrue: [Float infinity negated]					ifFalse: [Float infinity]].		^self expected: ['a digit between 0 and 9']].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [^ self expected: 'an integer greater than 1 as valid radix'].			(sourceStream peekFor: $-)				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [fractionPart := self						nextUnsignedIntegerBase: base						ifFail: [sourceStream skip: -1.							^ neg								ifTrue: [integerPart negated]								ifFalse: [integerPart]].			numberOfNonZeroFractionDigits := lastNonZero.			numberOfTrailingZeroInFractionPart := nDigits - lastNonZero.			self readExponent				ifFalse: [self readScale						ifTrue: [decimalMultiplier := base raisedTo: numberOfNonZeroFractionDigits.							decimalFraction := integerPart * decimalMultiplier + fractionPart / decimalMultiplier.							neg								ifTrue: [decimalFraction := decimalFraction negated].							^ ScaledDecimal newFromNumber: decimalFraction scale: scale]].			fractionPart isZero				ifTrue: [mantissa := integerPart								// (base raisedTo: numberOfTrailingZeroInIntegerPart).					exponent := exponent + numberOfTrailingZeroInIntegerPart]				ifFalse: [mantissa := integerPart								* (base raisedTo: numberOfNonZeroFractionDigits) + (fractionPart // (base raisedTo: numberOfTrailingZeroInFractionPart)).					exponent := exponent - numberOfNonZeroFractionDigits].			"very naive algorithm"			value := self makeFloatFromMantissa: mantissa exponent: exponent base: base.			^ neg				ifTrue: [value isZero						ifTrue: [Float negativeZero]						ifFalse: [value negated]]				ifFalse: [value]]		ifFalse: [self makeIntegerOrScaledInteger]! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:44'!nextUnsignedIntegerBase: aRadix 	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in	instVar "		^ self		nextUnsignedIntegerBase: aRadix		ifFail: [self expected: ('a digit between 0 and ' copyWith: (Character digitValue: aRadix - 1))]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'kph 10/20/2007 13:56'!milliSecondsSinceMidnight		| msm msClock |		msClock := self millisecondClockValue. 	(msClock < LastMilliSeconds) 		ifTrue:[ "rolled over" MilliSecondOffset := MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds := msClock.	[ msm := msClock + MilliSecondOffset. 	 (msm >= 86400000) ] 		whileTrue: [ "next day" 			LastTick := -1.			DaysSinceEpoch := DaysSinceEpoch + 1. 			MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	((LastTick = -1) and: [		(Duration days: SqueakEpoch hours: 0 minutes: 0 seconds: 								(self clock totalSeconds)) days ~= DaysSinceEpoch ]) 		ifTrue: 				[  self initializeOffsets. 				 ^ self milliSecondsSinceMidnight ].		^msm! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 3/10/2008 22:27'!nextUnsignedIntegerBase: aRadix ifFail: errorBlock	"Form an unsigned integer with incoming digits from sourceStream.	Count the number of digits and the lastNonZero digit and store int in instVar"		| value digit |	value := 0.	nDigits := 0.	lastNonZero := 0.	aRadix <= 10		ifTrue: ["Avoid using digitValue which is awfully slow"			[sourceStream atEnd				or: [digit := sourceStream next charCode - 48.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]]		ifFalse: [			[sourceStream atEnd				or: [digit := sourceStream next digitValue.					(digit < 0							or: [digit >= aRadix])						and: [sourceStream skip: -1.							true]]]				whileFalse: [nDigits := nDigits + 1.					digit isZero						ifFalse: [lastNonZero := nDigits].					value := value * aRadix + digit]].	nDigits = 0		ifTrue: [errorBlock value].	^value! !