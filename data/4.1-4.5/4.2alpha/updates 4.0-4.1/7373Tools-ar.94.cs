"Change Set:		7373Tools-ar.94Tools-ar.94:Post-closure cleanup and underscore removal."!!CodeHolder methodsFor: 'traits' stamp: 'al 4/24/2004 12:46'!makeSampleInstance	| aClass nonMetaClass anInstance |	((aClass := self selectedClassOrMetaClass) isNil or: [aClass isTrait]) ifTrue: [^ self].	nonMetaClass := aClass theNonMetaClass.	anInstance := self sampleInstanceOfSelectedClass.	(anInstance isNil and: [nonMetaClass ~~ UndefinedObject]) ifTrue: 		[^ self inform: 'Sorry, cannot make an instance of ', nonMetaClass name].	(Smalltalk isMorphic and: [anInstance isMorph])		ifTrue:			[self currentHand attachMorph: anInstance]		ifFalse:			[anInstance inspectWithLabel: 'An instance of ', nonMetaClass name]! !!Debugger methodsFor: 'initialize' stamp: 'ab 3/23/2005 14:03'!customButtonSpecs	"Answer an array of elements of the form wording, selector, help-message, that characterize the custom button row of a debugger."	| list |	list := #(('Proceed'	proceed				'close the debugger and proceed.')		('Restart'		restart				'reset this context to its start.')		('Into'			send				'step Into message sends')		('Over'			doStep				'step Over message sends')		('Through'		stepIntoBlock		'step into a block')		('Full Stack'		fullStack			'show full stack')		('Where'		where				'select current pc range')		('Tally'			tally				'time in milliseconds to execute')).	Preferences restartAlsoProceeds ifTrue:		[list := list collect: [:each |			each second == #restart				ifTrue: [each copy at: 3 put: 'proceed from the beginning of this context.'; yourself]				ifFalse: [each]]].	^ list! !!Browser methodsFor: 'message functions' stamp: 'al 4/24/2004 11:49'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName := self selectedMessageName.	confirmation := self systemNavigation   confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation == 3		ifTrue: [^ self].	(self selectedClassOrMetaClass includesLocalSelector: messageName)		ifTrue: [self selectedClassOrMetaClass removeSelector: messageName]		ifFalse: [self removeNonLocalSelector: messageName].	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation == 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!Browser methodsFor: 'metaclass' stamp: 'md 2/18/2006 16:31'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer := nil.	metaClassOrganizer := nil.	classListIndex = 0 ifTrue: [^ self].	theClass := self selectedClass ifNil: [ ^self ].	classOrganizer := theClass organization.	metaClassOrganizer := theClass classSide organization.! !!Browser methodsFor: 'message functions' stamp: 'al 4/24/2004 12:48'!inspectSubInstances	"Inspect all instances of the selected class and all its subclasses  1/26/96 sw"	| aClass |	((aClass := self selectedClassOrMetaClass) isNil or: [aClass isTrait])		ifFalse: [			aClass := aClass theNonMetaClass.			aClass inspectSubInstances].! !!Browser methodsFor: 'accessing' stamp: 'al 12/6/2005 22:36'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod := currentCompiledMethod.	currentCompiledMethod := nil.	editSelection == #newTrait		ifTrue: [^Trait newTemplateIn: self selectedSystemCategoryName].	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass := self selectedClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^self classDefinitionText].	editSelection == #editComment 		ifTrue:			[(theClass := self selectedClass) ifNil: [^ ''].			comment := theClass comment.			currentCompiledMethod := theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [			self selectedClassOrMetaClass isTrait				ifTrue: [^'']				ifFalse: [^self selectedClassOrMetaClass printHierarchy]].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass := self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[self showingByteCodes ifTrue: [^ self selectedBytecodes].			currentCompiledMethod := latestCompiledMethod.			^ self selectedMessage].	self error: 'Browser internal error: unknown edit selection.'! !!CodeHolder methodsFor: 'traits' stamp: 'al 4/24/2004 12:44'!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size == 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport := String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList)		startUpWithCaption: 'Unreferencedclass variables in ' , cls name! !!Workspace methodsFor: 'initialize-release' stamp: 'md 3/7/2006 10:25'!embeddedInMorphicWindowLabeled: labelString	| window pane |	window := (SystemWindow labelled: labelString) model: self.	pane := PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:.	pane  font: Preferences standardCodeFont.	window addMorph: pane frame: (0@0 corner: 1@1).	^ window! !!VersionsBrowser methodsFor: 'init & update' stamp: 'bf 2/13/2006 00:14'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp cat |	selectorOfMethod := selector.	currentCompiledMethod := method.	classOfMethod := meta ifTrue: [class class] ifFalse: [class].	cat := category ifNil: [''].	changeList := OrderedCollection new.	list := OrderedCollection new.	self addedChangeRecord ifNotNilDo: [ :change |		self addItem: change text: ('{1} (in {2})' translated format: { change stamp. change fileName }) ].	listIndex := 0.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				cat := tokens at: tokens size-4.				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size].				cat := tokens at: tokens size-2]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector, ' {', cat, '}'.		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections := Array new: list size withAll: false! !!CodeHolder methodsFor: 'traits' stamp: 'al 4/24/2004 12:43'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClassOrMetaClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport := String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name! !!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'nk 10/14/2003 10:36'!openPath: anArray 	| found |	anArray isEmpty		ifTrue: [^ container setSelectedMorph: nil].	found := nil.	self		withSiblingsDo: [:each | found				ifNil: [(each complexContents asString = anArray first							or: [anArray first isNil])						ifTrue: [found := each]]].	found		ifNil: ["try again with no case sensitivity"			self				withSiblingsDo: [:each | found						ifNil: [(each complexContents asString sameAs: anArray first)								ifTrue: [found := each]]]].	found		ifNotNil: [found isExpanded				ifFalse: [found toggleExpandedState.					container adjustSubmorphPositions].			found changed.			anArray size = 1				ifTrue: [^ container setSelectedMorph: found].			^ found firstChild				ifNil: [container setSelectedMorph: nil]				ifNotNil: [found firstChild openPath: anArray allButFirst]].	^ container setSelectedMorph: nil! !!IndentingListItemMorph methodsFor: 'accessing' stamp: 'RAA 7/31/1998 00:48'!isExpanded: aBoolean	isExpanded := aBoolean! !!Browser methodsFor: 'traits' stamp: 'al 4/24/2004 11:48'!newClass	(self selectedClassOrMetaClass notNil and: 		[self selectedClassOrMetaClass isTrait]) ifTrue: [self classListIndex: 0].	self editClass.	editSelection := #newClass.	self contentsChanged! !!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'RAA 7/30/2000 19:17'!toggleExpandedState 	| newChildren toDelete c |	isExpanded := isExpanded not.	toDelete := OrderedCollection new.	firstChild ifNotNil: [		firstChild withSiblingsDo: [ :aNode | aNode recursiveAddTo: toDelete].	].	container noteRemovalOfAll: toDelete.	(isExpanded and: [complexContents hasContents]) ifFalse: [		^self changed	].	(c := complexContents contents) isEmpty ifTrue: [^self changed].	newChildren := container 		addSubmorphsAfter: self 		fromCollection: c 		allowSorting: true.	firstChild := newChildren first.! !!Browser methodsFor: 'traits' stamp: 'al 4/24/2004 11:49'!removeNonLocalSelector: aSymbol	| traits isAlias |	traits := self selectedClassOrMetaClass traitsProvidingSelector: aSymbol.	isAlias := self selectedClassOrMetaClass isLocalAliasSelector: aSymbol.	isAlias		ifTrue: [			self assert: traits size = 1.			self selectedClassOrMetaClass removeAlias: aSymbol of: traits first]		ifFalse: [			traits do: [:each |				self selectedClassOrMetaClass addExclusionOf: aSymbol to: each ]]	! !!CodeHolder methodsFor: 'traits' stamp: 'al 4/24/2004 12:12'!spawnHierarchy	"Create and schedule a new hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |	(selectedClassOrMetaClass := self selectedClassOrMetaClass)		ifNil: [^ self].	selectedClassOrMetaClass isTrait ifTrue: [^self].	newBrowser := HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.	((aSymbol := self selectedMessageName) notNil and: [(MessageSet isPseudoSelector: aSymbol) not])		ifTrue:			[aBehavior := selectedClassOrMetaClass.			messageCatIndex := aBehavior organization numberOfCategoryOfElement: aSymbol.			newBrowser messageCategoryListIndex: messageCatIndex + 1.			newBrowser messageListIndex:				((aBehavior organization listAtCategoryNumber: messageCatIndex) indexOf: aSymbol)].	Browser		openBrowserView: (newBrowser openSystemCatEditString: nil)		label: newBrowser labelString.	Smalltalk isMorphic		ifTrue: ["this workaround only needed in morphic"			newBrowser assureSelectionsShow]! !!IndentingListItemMorph methodsFor: 'private' stamp: 'RAA 7/29/2000 22:06'!toggleRectangle	| h |	h := bounds height.	^(bounds left + (12 * indentLevel)) @ bounds top extent: 12@h! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 2/19/2004 18:19'!drawToggleOn: aCanvas in: aRectangle	| aForm centeringOffset |	complexContents hasContents ifFalse: [^self].	aForm := isExpanded 		ifTrue: [container expandedForm]		ifFalse: [container notExpandedForm].	centeringOffset := ((aRectangle height - aForm extent y) / 2.0) rounded.	^aCanvas 		paintImage: aForm 		at: (aRectangle topLeft translateBy: 0 @ centeringOffset).! !!Browser methodsFor: 'drag and drop' stamp: 'al 4/24/2004 11:50'!acceptMethod: methodSel messageCategory: srcMessageCategorySel class: srcClassOrMeta atListMorph: dstListMorph internal: internal copy: copyFlag 	| success dstClassOrMeta dstClass dstMessageCategorySel |	dstClass := self dstClassDstListMorph: dstListMorph.	dstClassOrMeta := dstClass				ifNotNil: [self metaClassIndicated						ifTrue: [dstClass classSide]						ifFalse: [dstClass]].	dstMessageCategorySel := self dstMessageCategoryDstListMorph: dstListMorph.	success := (dstClassOrMeta notNil				and: [dstClassOrMeta == srcClassOrMeta])						ifTrue: ["one class"							self								changeMessageCategoryForMethod: methodSel								dstMessageCategory: dstMessageCategorySel								srcMessageCategory: srcMessageCategorySel								insideClassOrMeta: dstClassOrMeta								internal: internal								copySemantic: copyFlag]						ifFalse: ["different classes"							self								acceptMethod: methodSel								dstMessageCategory: dstMessageCategorySel								srcMessageCategory: srcMessageCategorySel								dstClass: dstClass								dstClassOrMeta: dstClassOrMeta								srcClassOrMeta: srcClassOrMeta								internal: internal								copySemantic: copyFlag].	^ success! !!IndentingListItemMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	indentLevel := 0.	isExpanded := false! !!Browser methodsFor: 'traits' stamp: 'md 3/3/2006 10:58'!defineTrait: defString notifying: aController  	| defTokens keywdIx envt oldTrait newTraitName trait |	oldTrait := self selectedClassOrMetaClass.	defTokens := defString findTokens: Character separators.	keywdIx := defTokens findFirst: [:x | x = 'category'].	envt := self selectedEnvironment.	keywdIx := defTokens findFirst: [:x | x = 'named:'].	newTraitName := (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldTrait isNil or: [oldTrait baseTrait name asString ~= newTraitName])		and: [envt includesKey: newTraitName asSymbol]) ifTrue:			["Attempting to define new class/trait over existing one when				not looking at the original one in this browser..."			(self confirm: ((newTraitName , ' is an existing class/trait in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newTraitName size))				ifFalse: [^ false]].	trait := Compiler evaluate: defString notifying: aController logged: true.	^(trait isKindOf: TraitBehavior)		ifTrue: [			self changed: #classList.			self classListIndex: (self classList indexOf: trait baseTrait name).			self clearUserEditFlag; editClass.			true]		ifFalse: [ false ]! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'dgd 9/25/2004 22:36'!drawOn: aCanvas	| tRect sRect columnRect columnScanner columnData columnLeft colorToUse |	tRect := self toggleRectangle.	sRect := bounds withLeft: tRect right + 4.	self drawToggleOn: aCanvas in: tRect.	colorToUse := complexContents preferredColor ifNil: [color].	icon isNil ifFalse:[		aCanvas			translucentImage: icon			at: sRect left @ (self top + (self height - icon height // 2)).		sRect := sRect left: sRect left + icon width + 2.	].	(container columns isNil or: [(contents asString indexOf: Character tab) = 0]) ifTrue: [		sRect := sRect top: sRect top + sRect bottom - self fontToUse height // 2.		aCanvas drawString: contents asString in: sRect font: self fontToUse color: colorToUse.	] ifFalse: [		columnLeft := sRect left.		columnScanner := ReadStream on: contents asString.		container columns do: [ :width |			columnRect := columnLeft @ sRect top extent: width @ sRect height.			columnData := columnScanner upTo: Character tab.			columnData isEmpty ifFalse: [				aCanvas drawString: columnData in: columnRect font: self fontToUse color: colorToUse.			].			columnLeft := columnRect right + 5.		].	]! !!IndentingListItemMorph methodsFor: 'drawing' stamp: 'nk 3/8/2004 11:43'!drawLinesOn: aCanvas lineColor: lineColor 	| hasToggle |	hasToggle := self hasToggle.	"Draw line from toggle to text"	self drawLineToggleToTextOn: aCanvas lineColor: lineColor hasToggle: hasToggle.	"Draw the line from my toggle to the nextSibling's toggle"	self nextSibling ifNotNil: [ self drawLinesToNextSiblingOn: aCanvas lineColor: lineColor hasToggle: hasToggle ].	"If I have children and am expanded, draw a line to my first child"	(self firstChild notNil and: [ self isExpanded ])		ifTrue: [ self drawLinesToFirstChildOn: aCanvas lineColor: lineColor]! !!IndentingListItemMorph methodsFor: 'accessing' stamp: 'panda 4/28/2000 15:30'!children	| children |	children := OrderedCollection new.	self childrenDo: [:each | children add: each].	^children! !!IndentingListItemMorph methodsFor: 'private' stamp: 'RAA 7/11/1998 14:25'!withSiblingsDo: aBlock	| node |	node := self.	[node isNil] whileFalse: [		aBlock value: node.		node := node nextSibling	].! !!Browser methodsFor: 'class functions' stamp: 'md 3/3/2006 11:02'!defineClass: defString notifying: aController  	"The receiver's textual content is a request to define a new class. The	source code is defString. If any errors occur in compilation, notify	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass := self selectedClassOrMetaClass.	defTokens := defString findTokens: Character separators.		((defTokens first = 'Trait' and: [defTokens second = 'named:'])		or: [defTokens second = 'classTrait'])		ifTrue: [^self defineTrait: defString notifying: aController].			keywdIx := defTokens findFirst: [:x | x beginsWith: 'category'].	envt := Smalltalk.	keywdIx := defTokens findFirst: [:x | '*subclass*' match: x].	newClassName := (defTokens at: keywdIx+1) copyWithoutAll: '#()'.	((oldClass isNil or: [oldClass theNonMetaClass name asString ~= newClassName])		and: [envt includesKey: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass := oldClass superclass].	class := oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: [self changed: #systemCategoryList.				self changed: #classList.				self clearUserEditFlag.				self setClass: class selector: nil.				"self clearUserEditFlag; editClass."				^ true]		ifFalse: [^ false]! !!Browser methodsFor: 'accessing' stamp: 'al 4/24/2004 12:01'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be	 updated. The information can be a variety of things, depending on	 the list selections (such as templates for class or message definition,	 methods) or the user menu commands (such as definition, comment,	 hierarchy).  Answer the result of updating the source."	| aString aText theClass |	self changed: #annotation.	aString := input asString.	aText := input asText.	editSelection == #newTrait ifTrue: [^self defineTrait: input asString notifying: aController].	editSelection == #editSystemCategories ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment		ifTrue: 			[theClass := self selectedClass.			theClass				ifNil: 					[self inform: 'You must select a classbefore giving it a comment.'.					^ false].			theClass comment: aText stamp: Utilities changeStamp.			self changed: #classCommentText.			^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage)		ifTrue:			[^ self okayToAccept				ifFalse:					[false]				ifTrue:					[self compileMessage: aText notifying: aController]].	editSelection == #none		ifTrue: 			[self inform: 'This text cannot be acceptedin this part of the browser.'.			^ false].	self error: 'unacceptable accept'! !!IndentingListItemMorph methodsFor: 'private-container protocol' stamp: 'RAA 7/30/2000 19:49'!addChildrenForList: hostList addingTo: morphList withExpandedItems: expandedItems	firstChild ifNotNil: [		firstChild withSiblingsDo: [ :aNode | aNode delete].	].	firstChild := nil.	complexContents hasContents ifFalse: [^self].	firstChild := hostList 		addMorphsTo: morphList		from: complexContents contents 		allowSorting: true		withExpandedItems: expandedItems		atLevel: indentLevel + 1.	! !!Browser methodsFor: 'metaclass' stamp: 'al 4/24/2004 11:47'!selectedClassOrMetaClass	"Answer the selected class/trait or metaclass/classTrait."	| cls |	^self metaClassIndicated		ifTrue: [(cls := self selectedClass) ifNil: [nil] ifNotNil: [cls classSide]]		ifFalse: [self selectedClass]! !!ChangeSorter methodsFor: 'traits' stamp: 'wiz 2/3/2007 01:34'!selectedClassOrMetaClass	"Careful, the class may have been removed!!"	| cName tName className |	currentClassName ifNil: [^ nil].	className := (self withoutItemAnnotation: currentClassName) .	(className endsWith: ' class')		ifTrue: [cName := (className copyFrom: 1 to: className size-6) asSymbol.				^ (Smalltalk at: cName ifAbsent: [^nil]) class].	(currentClassName endsWith: ' classTrait')		ifTrue: [tName := (className copyFrom: 1 to: className size-11) asSymbol.				^ (Smalltalk at: tName ifAbsent: [^nil]) classTrait].	cName := className asSymbol.	^ Smalltalk at: cName ifAbsent: [nil]! !!Browser methodsFor: 'message functions' stamp: 'al 4/24/2004 12:48'!inspectInstances	"Inspect all instances of the selected class.  1/26/96 sw"	| myClass |	((myClass := self selectedClassOrMetaClass) isNil or: [myClass isTrait])		ifFalse: [myClass theNonMetaClass inspectAllInstances]! !!IndentingListItemMorph methodsFor: 'accessing' stamp: 'RAA 8/1/1998 01:05'!nextSibling: anotherMorph	nextSibling := anotherMorph! !!Browser methodsFor: 'traits' stamp: 'al 4/24/2004 11:48'!newTrait	self classListIndex: 0.	self editClass.	editSelection := #newTrait.	self contentsChanged! !!IndentingListItemMorph methodsFor: 'initialization' stamp: 'dgd 9/25/2004 22:33'!initWithContents: anObject prior: priorMorph forList: hostList indentLevel: newLevel	container := hostList.	complexContents := anObject.	self initWithContents: anObject asString font: Preferences standardListFont emphasis: nil.	indentLevel := 0.	isExpanded := false. 	nextSibling := firstChild := nil.	priorMorph ifNotNil: [		priorMorph nextSibling: self.	].	indentLevel := newLevel.	icon := anObject icon.	self extent: self minWidth @ self minHeight! !