"Change Set:		8679Traits-ar.261Traits-ar.261:Revert the use of ClassTrait being the class of Trait. It causes problems when modifying class Trait itself since the subclass machinery isn't present and ClassBuilder is not ready for supporting alternative metaclasses in this form.Traits-ar.257:Almost there now. Fill in the old classes with the NanoTraits implementation so we can switch back later.Traits-ar.258:Don't change the class category - it looks as if diffs have problems with changing categories containing traits.Traits-ar.259:Some fixes for conversion back to Trait."!TraitTransformation subclass: #TraitExclusion	instanceVariableNames: 'exclusions'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!Object subclass: #TraitTransformation	instanceVariableNames: 'subject users'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!TraitTransformation subclass: #TraitAlias	instanceVariableNames: 'aliases'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!OrderedCollection subclass: #TraitComposition	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!TraitDescription subclass: #ClassTrait	instanceVariableNames: 'baseTrait'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitBehavior subclass: #TraitDescription	instanceVariableNames: 'users traitComposition'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!ClassDescription subclass: #TraitBehavior	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!Error subclass: #TraitCompositionException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Composition'!AdditionalMethodState variableSubclass: #TraitMethodState	instanceVariableNames: 'originalTraitMethod'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!TraitDescription subclass: #Trait	instanceVariableNames: 'name environment classTrait category'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Kernel'!!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!- anArray	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"		self addLast: (self removeLast - anArray)! !!TraitComposition methodsFor: 'compat' stamp: 'ar 12/29/2009 18:11'!removeFromComposition: aTrait	"--- ignore ---"! !!TraitAlias methodsFor: 'testing' stamp: 'ar 12/29/2009 18:14'!isLocalAliasSelector: selector	^(aliases anySatisfy:[:assoc| assoc key == selector])! !!ClassTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:21'!isMeta	^true! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!addTraitUser: aTrait	users := users copyWith: aTrait.	subject addTraitUser: aTrait.! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 03:55'!definition	^String streamContents: [:stream |		stream nextPutAll: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.	].! !!TraitAlias methodsFor: 'testing' stamp: 'ar 12/29/2009 18:14'!isAliasSelector: selector	^(self isLocalAliasSelector: selector) or:[super isAliasSelector: selector]! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 21:01'!isClassTrait	^false! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!addUser: aUser	^self addTraitUser: aUser! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4	"This method has a trait conflict"	^self traitConflict! !!Trait class methodsFor: 'class initialization' stamp: 'ar 12/29/2009 18:43'!updateTraits: aCollection	"Convert all the traits in aCollection to NanoTraits. Used during installation."	"ClassDescription traitImpl: Trait.	Trait updateTraits:{		TSequencedStreamTest. TGettableStreamTest. TReadStreamTest.		TStreamTest. TPuttableStreamTest. TWriteStreamTest	}"	| remain processed classes oldTrait classDef newTrait count instTraits classSelectors |	ClassDescription traitImpl == self ifFalse:[self error: 'What are you doing???'].	remain := (aCollection reject:[:tc| tc isKindOf: self]) asSet.	processed := Set new.	classes := Set new.	count := 0.	'Converting ....' displayProgressAt: Sensor cursorPoint from: 1 to: remain size during:[:bar|	[remain isEmpty] whileFalse:[		"Pick any trait whose traits are already converted"		oldTrait := remain detect:[:any| 			any traitComposition traits allSatisfy:[:t| (Smalltalk at: t name) isKindOf: self].		] ifNone:[self error: 'Cannot convert cyclic traits'].		remain remove: oldTrait.		bar value: (count := count +1).		ProgressNotification signal: '' extra: 'Converting ', oldTrait name.		"Silently remove the old trait class and recreate it based on NanoTrait"		classDef := oldTrait definition.		Smalltalk removeKey: oldTrait name.		"Create the NanoTrait from the same definition"		newTrait := Compiler evaluate: classDef.		"Update comment"		oldTrait organization classComment ifNotEmpty:[			newTrait classComment: oldTrait organization commentRemoteStr 						stamp: oldTrait organization commentStamp.		].		"Copy local methods to new trait"		oldTrait localSelectors do:[:sel|			newTrait 				compile: (oldTrait sourceCodeAt: sel)				classified: (oldTrait organization categoryOfElement: sel)				withStamp: (oldTrait compiledMethodAt: sel) timeStamp 				notifying: nil		].		oldTrait classSide localSelectors do:[:sel|			newTrait classSide				compile: (oldTrait classSide sourceCodeAt: sel)				classified: (oldTrait classSide organization categoryOfElement: sel)				withStamp: (oldTrait classSide compiledMethodAt: sel) timeStamp 				notifying: nil		].		newTrait selectors sort = oldTrait selectors sort			ifFalse:[self error: 'Something went VERY wrong'].		newTrait classSide selectors sort = oldTrait classSide selectors sort			ifFalse:[self error: 'Something went VERY wrong'].		processed add: oldTrait.		classes addAll: (oldTrait users reject:[:aClass| aClass isObsolete]).	].	].	classes := classes asArray select:[:cls| cls isKindOf: ClassDescription].	'Updating ....' displayProgressAt: Sensor cursorPoint from: 1 to: classes size during:[:bar|	"The traits are all converted, next update the classes"	classes keysAndValuesDo:[:index :aClass|		bar value: index.		ProgressNotification signal: '' extra: 'Updating ', aClass name.		instTraits := Compiler evaluate: aClass traitComposition asString.		"Keep the local selectors from before"		localSelectors := aClass localSelectors.		classSelectors := aClass class localSelectors.		"Nuke the old traits composition"		aClass traitComposition: nil.		aClass class traitComposition: nil.		"Install the new one"		aClass uses: instTraits.		"Remove the old trait (now local) selectors"		(aClass selectors reject:[:sel| localSelectors includes: sel]) do:[:sel| 			aClass removeSelectorSilently: sel.			(aClass includesSelector: sel) ifFalse:[self halt: 'Where is the code?'].		].		(aClass class selectors reject:[:sel| classSelectors includes: sel]) do:[:sel|			aClass class removeSelectorSilently: sel.			(aClass class includesSelector: sel) ifFalse:[self halt: 'Where is the code?'].		].	].	].	"Finally, obsolete all the old traits"	processed do:[:trait| trait obsolete].! !!Trait methodsFor: 'initialize' stamp: 'ar 11/18/2007 15:33'!isValidTraitName: aSymbol	^(aSymbol isEmptyOrNil		or: [aSymbol first isLetter not]		or: [aSymbol anySatisfy: [:character | character isAlphaNumeric not]]) not! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2	"This method has a trait conflict"	^self traitConflict! !!Trait methodsFor: 'initialize' stamp: 'ar 12/27/2009 19:40'!definition	^String streamContents: [:stream |		stream nextPutAll: 'Trait named: ';				store: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.		stream cr; tab; nextPutAll: 'category: ';				store: self category asString].! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:11'!includesSelector: selector	"Answers true if the receiver provides the selector"	^(subject includesSelector: selector) and:[(exclusions includes: selector) not]! !!TraitExclusion methodsFor: 'initialize' stamp: 'ar 12/29/2009 18:11'!initialize	super initialize.	exclusions := Set new.! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:14'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	subject selectorsAndMethodsDo:[:sel :meth|		aBlock value: sel value: meth.	].	aliases do:[:assoc| | method |		"Method can be nil during removals"		method := subject compiledMethodAt: assoc value ifAbsent:[nil].		method ifNotNil:[aBlock value: assoc key value: method].	].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:34'!uses: aTraitComposition	self installTraitsFrom: aTraitComposition asTraitComposition.! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!originalTraitOrClass	"The original trait for this method"	^originalTraitMethod originalTraitOrClass! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!updateTraits	"Recompute my users traits composition"	users do:[:each| each updateTraits].! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!environment	^environment! !!TraitExclusion methodsFor: 'converting' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	^TraitExclusion		with: subject		exclusions: (anArrayOfSelectors, exclusions asArray)! !!TraitExclusion class methodsFor: 'instance creation' stamp: 'ar 12/29/2009 18:11'!with: aTraitComposition exclusions: anArrayOfSelectors	^self new		subject: aTraitComposition;		exclusions: anArrayOfSelectors;		yourself! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method has a trait conflict"	^self traitConflict! !!Trait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:59'!isBaseTrait	^true! !!TraitComposition methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!includesTrait: aTrait	^self anySatisfy:[:each| each includesTrait: aTrait]! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!trait	^subject trait! !!Trait methodsFor: 'converting' stamp: 'ar 12/29/2009 18:34'!asTraitComposition	"Convert me into a trait composition"	^TraitComposition with: self! !!TraitDescription methodsFor: 'copying' stamp: 'ar 11/28/2007 20:55'!copy 	self error: 'Traits cannot be trivially copied'! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/20/2009 00:52'!notifyOfRecategorizedSelector: element from: oldCategory to: newCategory	super notifyOfRecategorizedSelector: element from: oldCategory to: newCategory.	self users do:[:each| each classify: element under: newCategory from: oldCategory trait: self].! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:20'!traitComposition	^traitComposition ifNil:[traitComposition := TraitComposition new]! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!copyTraitExpression	"Copy all except the actual traits"	^self subclassResponsibility! !!Trait methodsFor: 'initialize' stamp: 'ar 11/28/2007 21:00'!removeFromSystem	self removeFromSystem: true! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!removeTraitUser: aUser	self do:[:each| each removeTraitUser: aUser]! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/30/2009 01:59'!baseTrait: aTrait	baseTrait ifNotNil:[self error: 'Already initialized'].	baseTrait := aTrait.! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/29/2009 18:17'!@ anArrayOfAssociations 	"Creates an alias"	^TraitAlias with: self aliases: anArrayOfAssociations! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!traitsDo: aBlock	^subject traitsDo: aBlock! !!TraitDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 16:08'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| internalStream |	internalStream := WriteStream on: (String new: 100).	internalStream header; timeStamp.	self fileOutOn: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true useHtml: useHtml.! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:21'!+ aTrait	self traitsDo:[:t| (t == aTrait trait) ifTrue:[^TraitCompositionException			signal: 'Trait ' , aTrait trait asString, ' already in composition']].	self addLast: aTrait.	^self! !!ClassTrait methodsFor: 'initialize' stamp: 'ar 12/21/2009 15:14'!updateTraitsFrom: instanceTraits	"Update me from the given instance traits"	| map newTraits trait |	map := Dictionary new.	self traitComposition do:[:composed| map at: composed trait put: composed].	newTraits := (instanceTraits collect:[:composed|		trait := composed trait classTrait.		map at: trait ifAbsent:[trait]] 	), (self traitComposition select:[:comp| comp trait isBaseTrait]).	self installTraitsFrom: newTraits! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 14:01'!removeUser: aTrait	^self removeTraitUser: aTrait! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	"Creates an exclusion"	^TraitExclusion		with: self		exclusions: anArrayOfSelectors! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:17'!copyTraitExpression	"Copy all except the actual traits"	^TraitAlias 		with: subject		aliases: aliases! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isTraitTransformation	"Polymorphic with Trait"	^true! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/19/2009 23:56'!addSelectorSilently: selector withMethod: compiledMethod	"Overridden to update the users of this trait"	super addSelectorSilently: selector withMethod: compiledMethod.	self users do:[:each| each updateTraits].! !!CompiledMethod methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:22'!originalTraitMethod: aCompiledMethod	"Remember the original trait method for the receiver."	| methodState |	methodState := TraitMethodState newFrom: self properties.	methodState originalTraitMethod: aCompiledMethod.	self penultimateLiteral:  methodState.! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 14:01'!addUser: aTrait	^self addTraitUser: aTrait! !!Trait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:48'!asClassDefinition	^Smalltalk at: #MCTraitDefinition ifPresent:[:aClass|		aClass			name: self name			traitComposition: self traitCompositionString			category: self category 			comment: self organization classComment asString			commentStamp: self organization commentStamp].! !!TraitAlias class methodsFor: 'instance creation' stamp: 'ar 12/29/2009 18:14'!with: aTraitComposition aliases: anArrayOfAssociations	self assertValidAliasDefinition: anArrayOfAssociations.	^self new		subject: aTraitComposition;		initializeFrom: anArrayOfAssociations;		yourself! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!isLocalAliasSelector: selector	"Return true if the selector aSymbol is an alias defined in the receiver."	^self anySatisfy:[:any| any isTraitTransformation and:[any isLocalAliasSelector: selector]]! !!Trait methodsFor: 'initialize' stamp: 'ar 11/18/2007 15:41'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	(newName := aString asSymbol) ~= self name		ifFalse: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	self environment renameClass: self as: newName.	name := newName! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!asTraitComposition	^self! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!isAliasSelector: selector	"enumerates all selectors and methods in a trait composition"	^self anySatisfy:[:any| any isAliasSelector: selector]! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!allTraits	^subject allTraits! !!TraitDescription methodsFor: 'testing' stamp: 'ar 12/20/2009 02:35'!includesTrait: aTrait	^self == aTrait or:[super includesTrait: aTrait]! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:18'!updateTraits	"Recompute my local traits composition"	self installTraitsFrom: self traitComposition.! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!subject: aSubject	subject := aSubject.! !!Trait methodsFor: 'testing' stamp: 'ar 11/18/2007 15:41'!isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent: [nil]) ~~ self! !!ClassTrait methodsFor: 'compiling' stamp: 'ar 12/21/2009 20:18'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^baseTrait bindingOf: varName! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:14'!printOn: s	"Answer the trait composition string (used for class definitions)"	s nextPutAll: subject asString.	s nextPutAll: ' @ {'.	aliases do:[:assoc| s print: assoc] separatedBy:[s nextPutAll:'. '].	s nextPutAll: '}'.! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	self do:[:each| each selectorsAndMethodsDo: aBlock].! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:57'!allClassVarNames	"Traits have no class var names"	^#()! !!TraitDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 16:09'!fileOut	"Create a file whose name is the name of the receiver with '.st' as the 	extension, and file a description of the receiver onto it."	^ self fileOutAsHtml: false! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:11'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	^subject selectorsAndMethodsDo:[:sel :meth|		(exclusions includes: sel) ifFalse:[aBlock value: sel value: meth].	].! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!addTraitUser: aUser	self do:[:each| each addTraitUser: aUser]! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!environment: anObject	environment := anObject! !!Trait methodsFor: 'fileIn/Out' stamp: 'ar 12/19/2009 18:06'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	super fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex.	self classSide hasMethods ifTrue:[		aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.			self classSide				fileOutOn: aFileStream				moveSource: moveSource				toFile: fileIndex].! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 23:00'!baseTrait	^baseTrait! !!Trait methodsFor: 'compiling' stamp: 'ar 12/21/2009 20:17'!bindingOf: varName	"Answer the binding of some variable resolved in the scope of the receiver"	^self environment bindingOf: varName asSymbol.! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:39'!removeTraitUser: aTrait	users := self users copyWithout: aTrait.! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!methodHome	"The behavior (trait/class) this method was originally defined in. 	Derived from the originalTraitMethod if any."	^originalTraitMethod ifNil:[super methodHome] ifNotNil:[:m| m methodHome]! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 5/11/2008 01:51'!instanceSide	^self baseTrait! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/29/2009 18:20'!+ aTrait	"Creates a composition with the receiver and aTrait"	aTrait traitsDo:[:t| self == t ifTrue:[TraitCompositionException			signal: 'Trait ' , self asString, ' already in composition']].	^TraitComposition withAll: {self}, aTrait asTraitComposition! !!TraitAlias methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:14'!aliases	"Collection of associations where key is the	alias and value the original selector."	^aliases! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:58'!classPool	"Traits have no class pool"	^ Dictionary new! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!@ anArrayOfAssociations	^self subclassResponsibility! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!traits	^Array streamContents:[:s| self traitsDo:[:t| s nextPut: t]]! !!TraitDescription methodsFor: 'printing' stamp: 'ar 12/27/2009 19:16'!printUsersOf: aClass on: aStream level: indent	aStream crtab: indent.	aStream nextPutAll: aClass name.	aClass isTrait ifTrue:[		aClass users do:[:each| self printUsersOf: aClass on: aStream level: indent+1].	].! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 20:56'!isTrait	^true! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:42'!traitComposition: aTraitComposition	traitComposition := aTraitComposition.! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:22'!resolveTraitsConflict: aSelector from: oldMethod to: newMethod	"Resolve a traits conflict. Rules:		- If one method is required the other one wins		- Otherwise we compile a traits conflict	"	| marker selector |	oldMethod methodHome == newMethod methodHome ifTrue:[^oldMethod].	marker := oldMethod markerOrNil.	(#(requirement explicitRequirement subclassResponsibility shouldNotImplement) includes: marker)		ifTrue:[^newMethod].	marker := newMethod markerOrNil.	(#(requirement explicitRequirement subclassResponsibility shouldNotImplement) includes: marker)		ifTrue:[^oldMethod].	"Create a conflict marker"	selector := #(conflict conflict: conflict:with: conflict:with:with: conflict:with:with:with:	conflict:with:with:with:with: conflict:with:with:with:with:with: conflict:with:with:with:with:with:with:	conflict:with:with:with:with:with:with:with:) at: oldMethod numArgs+1.	^TraitDescription class compiledMethodAt: selector.! !!Trait methodsFor: 'accessing' stamp: 'ar 12/30/2009 02:31'!classTrait	^classTrait! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!category	"Answer the system organization category for the receiver. First check whether the	category name stored in the ivar is still correct and only if this fails look it up	(latter is much more expensive)"	| result |	category ifNotNilDo: [ :symbol |		((SystemOrganization listAtCategoryNamed: symbol) includes: self name)			ifTrue: [ ^symbol ] ].	category := (result := SystemOrganization categoryOfElement: self name).	^result! !!Trait class methodsFor: 'class initialization' stamp: 'ar 12/29/2009 20:25'!install	"Trait install"	ClassDescription traitImpl: self. 		"Create all new traits as NanoTraits"	self updateTraits: Smalltalk allTraits.	"And convert everything to NanoTraits"	"TWriteStreamTest has the class traits reversed which which will be undone	by installation. Put it back in reverse order to keep MC happy."	(Smalltalk at: #TWriteStreamTest) classTrait		uses: 			(Smalltalk at: #TSequencedStreamTest) classTrait + 			(Smalltalk at: #TPuttableStreamTest) classTrait.	Smalltalk allClassesAndTraits do:[:cls | | tc |		((tc := cls traitComposition) isKindOf: TraitComposition) 			ifFalse:[cls traitComposition: (TraitComposition withAll: tc)].		((tc := cls class traitComposition) isKindOf: TraitComposition) 			ifFalse:[cls class traitComposition: (TraitComposition withAll: tc)].	].! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!copyTraitExpression	"Copy all except the actual traits"	^self collect:[:each| each copyTraitExpression].! !!Metaclass methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 18:36'!updateTraitsFrom: instanceTraits	"Update me from the given instance traits"	| map newTraits trait |	map := Dictionary new.	self traitComposition isEmpty ifFalse:[		self traitComposition do:[:composed| map at: composed trait put: composed].	].	newTraits := (instanceTraits collect:[:composed|		trait := composed trait classTrait.		map at: trait ifAbsent:[trait]]).	self traitComposition isEmpty ifFalse:[		newTraits := newTraits, (self traitComposition select:[:comp| comp trait isBaseTrait]).	].	self installTraitsFrom: newTraits! !!Trait methodsFor: 'accessing' stamp: 'ar 12/21/2009 19:49'!baseTrait	^self! !!ClassTrait methodsFor: 'testing' stamp: 'ar 11/18/2007 22:59'!isClassTrait	^true! !!TraitAlias methodsFor: 'converting' stamp: 'ar 12/29/2009 18:17'!@ anArrayOfAssociations 	^TraitAlias 		with: subject		aliases: (anArrayOfAssociations, self aliases)! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method has a trait conflict"	^self traitConflict! !!TraitExclusion methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!exclusions: aCollection	exclusions := Set withAll: aCollection! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!updateSelector: aSelector withTraitMethod: compiledMethod from: aTrait	"broadcasts the change of a selector to all users of a trait"	^self subclassResponsibility! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/30/2009 02:06'!installTraitsFrom: aTraitComposition	"Install the traits from the given composition"	| allTraits methods oldMethod removals oldCategories |	(self traitComposition isEmpty and: [aTraitComposition isEmpty]) ifTrue: [^self].	"Check for cycles"	allTraits := aTraitComposition gather: [:t | t allTraits copyWith: t].	(allTraits includes: self) ifTrue:[^self error: 'Cyclic trait definition detected'].	"XXXX: addUser/removeUser should be part of setter, but subclass 	override prevents it until we've got rid of Traits mess."	self traitComposition removeTraitUser: self.	self traitComposition: aTraitComposition.	aTraitComposition addTraitUser: self.	"Assemble the methods in a new dictionary first.	Uses a Dictionary instead of a MethodDictionary for speed (MDs grow by #become:)"	methods := Dictionary new.	"Stick in the local methods first, since this avoids generating conflict methods unnecessarily"	self selectorsAndMethodsDo:[:sel :newMethod|		(self isLocalMethod: newMethod)			ifTrue:[methods at: sel put:newMethod]].	"Now assemble the traits methods"	aTraitComposition do:[:trait|		trait selectorsAndMethodsDo:[:sel :newMethod|			oldMethod := methods at: sel ifAbsentPut:[newMethod].			newMethod == oldMethod ifFalse:["a conflict"				(self isLocalMethod: oldMethod) ifFalse:[					methods at: sel put: (self resolveTraitsConflict: sel from: oldMethod to: newMethod).				].			].		].	].	"Apply the changes. We first add the new or changed methods."	oldCategories := Set new.	methods keysAndValuesDo:[:sel :newMethod|		oldMethod := self compiledMethodAt: sel ifAbsent:[nil].		oldMethod == newMethod ifFalse:[			self traitAddSelector: sel withMethod: newMethod.			(self organization categoryOfElement: sel) ifNotNil:[:cat| oldCategories add: cat].			self organization classify: sel under: 				(newMethod methodHome organization categoryOfElement: newMethod selector).		]].	"Now remove the old or obsoleted ones"	removals := OrderedCollection new.	self selectorsDo:[:sel| (methods includesKey: sel) ifFalse:[removals add: sel]].	removals do:[:sel| self traitRemoveSelector: sel].	"Clean out empty categories"	oldCategories do:[:cat|		(self organization isEmptyCategoryNamed: cat)			ifTrue:[self organization removeCategory: cat]].	self isMeta ifFalse:[self classSide updateTraitsFrom: aTraitComposition].! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:55'!users: aCollection	users := aCollection! !!Trait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:46'!classDefinitions	| definitions |	definitions := OrderedCollection with: self asClassDefinition.	(self hasClassTrait		and: [self classTrait hasTraitComposition]		and: [self classTrait traitComposition isEmpty not])			ifTrue: [definitions add: self classTrait asMCDefinition].	^definitions asArray! !!TraitTransformation methodsFor: 'initialize' stamp: 'ar 12/29/2009 18:11'!initialize	super initialize.	users := #().! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/19/2009 18:38'!soleInstance	^baseTrait! !!Trait class methodsFor: 'instance creation' stamp: 'ar 12/30/2009 02:00'!named: aSymbol uses: aTraitComposition category: aString env: anEnvironment	| trait oldTrait systemCategory oldCategory |	systemCategory := aString asSymbol.	oldTrait := anEnvironment at: aSymbol ifAbsent: [nil].	oldTrait ifNil:[		trait := Trait new.	] ifNotNil:[		oldCategory := oldTrait category.		trait := oldTrait.	].	(trait isMemberOf: Trait) ifFalse: [		^self error: trait name , ' is not a Trait'].	trait		setName: aSymbol		andRegisterInCategory: systemCategory		environment: anEnvironment.	trait uses: aTraitComposition.		"... notify interested clients ..."	oldTrait ifNil:[		SystemChangeNotifier uniqueInstance classAdded: trait inCategory: systemCategory.	] ifNotNil:[		systemCategory = oldCategory  ifFalse:[			SystemChangeNotifier uniqueInstance class: trait 				recategorizedFrom: oldTrait category to: systemCategory].	].	^ trait! !!Trait methodsFor: 'initialize' stamp: 'ar 11/28/2007 21:00'!removeFromSystem: logged	self environment forgetClass: self logged: logged.	self obsolete! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method has a trait conflict"	^self traitConflict! !!ClassTrait class methodsFor: 'instance creation' stamp: 'ar 12/30/2009 01:58'!for: baseTrait	^self new baseTrait: baseTrait! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method has a trait conflict"	^self traitConflict! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!- anArrayOfSelectors	^self subclassResponsibility! !!NanoTrait methodsFor: 'initialize' stamp: 'ar 12/29/2009 20:21'!obsolete	self name: ('AnObsolete' , self name) asSymbol.	self class obsolete.	super obsolete! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 13:08'!classSide	^self! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:22'!copyTraitExpression	"Copy all except the actual traits"	^TraitExclusion 		with: subject		exclusions: exclusions asArray! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!includesTrait: aTrait	^subject includesTrait: aTrait! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 21:01'!isBaseTrait	^false! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 12/29/2009 17:51'!localSelectors	^self selectors select:[:sel| self includesLocalSelector: sel]! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1	"This method has a trait conflict"	^self traitConflict! !!TraitDescription methodsFor: 'converting' stamp: 'ar 12/29/2009 18:20'!asTraitComposition	^TraitComposition with: self! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!traitsDo: aBlock	^self do:[:each| each traitsDo: aBlock]! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!originalTraitMethod	"The original method from the trait"	^originalTraitMethod! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!printOn: aStream	"Answer the trait composition string (used for class definitions)"	aStream nextPutAll: self traitCompositionString.! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 11/18/2007 21:44'!name	^baseTrait name, ' classTrait'! !!NanoClassTrait methodsFor: 'initialize' stamp: 'ar 12/29/2009 18:38'!uses: aTraitComposition	| newTraits |	newTraits := aTraitComposition asTraitComposition.	newTraits traitsDo:[:t|		(t isBaseTrait and:[t classSide hasMethods]) 			ifTrue:[self error: 'Cannot add: ', t].		(t isClassTrait and:[(baseTrait includesTrait: t baseTrait) not]) 			ifTrue:[self error: 'Cannot add: ', t].	].	self installTraitsFrom: newTraits.! !!Trait class methodsFor: 'public' stamp: 'ar 12/29/2009 18:20'!newTraitComposition	"Creates a new TraitComposition"	^TraitComposition new! !!TraitAlias methodsFor: 'operations' stamp: 'ar 12/29/2009 18:14'!includesSelector: selector	"Answers true if the receiver provides the selector"	^(subject includesSelector: selector) or:[aliases anySatisfy:[:assoc| assoc key == selector]]! !!TraitAlias methodsFor: 'initialize-release' stamp: 'ar 12/29/2009 18:14'!initialize	super initialize.	aliases := #().! !!TraitDescription methodsFor: 'printing' stamp: 'ar 12/27/2009 19:14'!printHierarchy	"For hierarchy view in the browser; print the users of a trait"	^String streamContents:[:s| self printUsersOf: self on: s level: 0].! !!Trait methodsFor: 'testing' stamp: 'ar 5/11/2008 01:57'!hasClassTrait	^true! !!TraitAlias methodsFor: 'converting' stamp: 'ar 12/29/2009 18:22'!- anArrayOfSelectors	^TraitExclusion		with: self		exclusions: anArrayOfSelectors! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:38'!category: aString 	"Categorize the receiver under the system category, aString, removing it from 	any previous categorization."	| oldCategory |	oldCategory := category.	aString isString		ifTrue: [			category := aString asSymbol.			SystemOrganization classify: self name under: category ]		ifFalse: [self errorCategoryName].	SystemChangeNotifier uniqueInstance		class: self recategorizedFrom: oldCategory to: category! !!TraitAlias methodsFor: 'initialize-release' stamp: 'ar 12/29/2009 18:21'!initializeFrom: anArrayOfAssociations	| newNames |	newNames := (anArrayOfAssociations collect: [:each | each key]) asIdentitySet.	newNames size < anArrayOfAssociations size ifTrue: [		TraitCompositionException signal: 'Cannot use the same alias name twice'].	anArrayOfAssociations do: [:each |		(newNames includes: each value) ifTrue: [			TraitCompositionException signal: 'Cannot define an alias for an alias']].	aliases := anArrayOfAssociations.! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!name	^name! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:48'!conflict: arg1 with: arg2 with: arg3	"This method has a trait conflict"	^self traitConflict! !!TraitComposition methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isTraitTransformation	"Polymorphic with TraitTransformation"	^false! !!TraitTransformation methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!removeTraitUser: aTrait	users := users copyWithout: aTrait.	subject removeTraitUser: aTrait.! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/20/2009 00:42'!addTraitUser: aTrait	users := self users copyWith: aTrait.! !!Trait methodsFor: 'accessing' stamp: 'ar 11/18/2007 15:37'!name: aSymbol	name := aSymbol! !!ClassTrait methodsFor: 'monticello' stamp: 'ar 12/22/2009 08:49'!asMCDefinition	^Smalltalk at: #MCClassTraitDefinition ifPresent:[:aClass|		aClass			baseTraitName: self baseTrait name			classTraitComposition: self traitCompositionString	].! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:55'!users	^users ifNil:[#()]! !!Trait methodsFor: 'initialize-release' stamp: 'ar 12/30/2009 01:59'!initialize	super initialize.	classTrait := ClassTrait for: self.! !!TraitExclusion methodsFor: 'composition' stamp: 'ar 12/29/2009 18:11'!printOn: aStream	"Answer the trait composition string (used for class definitions)"	aStream nextPutAll: subject asString.	aStream nextPutAll: ' - {'.	exclusions asArray sort do:[:exc| aStream store: exc] separatedBy:[aStream nextPutAll: '. '].	aStream nextPutAll: '}'.! !!Trait methodsFor: 'initialize' stamp: 'ar 12/30/2009 01:55'!obsolete	self name: ('AnObsolete' , self name) asSymbol.	self classTrait obsolete.	super obsolete! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 14:29'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^baseTrait! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 03:55'!definitionST80	^String streamContents: [:stream |		stream nextPutAll: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.	].! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!allTraits	^self gather:[:each| each allTraits copyWith: each trait]! !!Trait methodsFor: 'initialize' stamp: 'ar 11/18/2007 15:33'!setName: aSymbol andRegisterInCategory: categorySymbol environment: aSystemDictionary	(self isValidTraitName: aSymbol) ifFalse: [self error:'Invalid trait name'].	(self environment == aSystemDictionary		and: [self name = aSymbol			and: [self category = categorySymbol]]) ifTrue: [^self].			((aSystemDictionary includes: aSymbol) and: [(aSystemDictionary at: aSymbol) ~~ self])		ifTrue: [self error: 'The name ''' , aSymbol , ''' is already used'].	(self environment notNil and: [self name notNil and: [self name ~= aSymbol]]) ifTrue: [		self environment renameClass: self as: aSymbol].		self name: aSymbol.	self environment: aSystemDictionary.		self environment at: self name put: self.	self environment organization classify: self name under: categorySymbol.	^ true! !!TraitAlias methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:14'!aliases: aCollection	"Collection of associations where key is the	alias and value the original selector."	aliases := aCollection! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 12/21/2009 15:13'!trait	^self! !!Trait methodsFor: 'initialize' stamp: 'ar 12/20/2009 03:55'!definitionST80	^String streamContents: [:stream |		stream nextPutAll: 'Trait named: ';				store: self name.		stream cr; tab; nextPutAll: 'uses: ';				nextPutAll: self traitComposition asString.		stream cr; tab; nextPutAll: 'category: ';				store: self category asString].! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:20'!+ aTrait	"Just like ordered collection"	^TraitComposition withAll: {self. aTrait}! !!Trait class methodsFor: 'public' stamp: 'ar 12/30/2009 02:00'!allTraitsDo: aBlock	"Evaluate aBlock with all the instance and class traits present in the system"	Trait allInstances do: [:aTrait|		aBlock value: aTrait instanceSide.		aBlock value: aTrait classSide.	].! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isLocalAliasSelector: selector	^false! !!TraitComposition methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!@ anArrayOfAssociations	"the modifier operators #@ and #- bind stronger than +.	Thus, #@ or #- sent to a sum will only affect the most right summand"	self addLast: (self removeLast @ anArrayOfAssociations)! !!Trait class methodsFor: 'class initialization' stamp: 'ar 12/29/2009 20:28'!initialize	"Trait initialize"	self install.! !!TraitDescription methodsFor: 'accessing' stamp: 'ar 11/28/2007 20:58'!sharedPools	"Traits have no shared pools"	^ Dictionary new! !!TraitDescription methodsFor: 'copying' stamp: 'ar 11/28/2007 20:55'!copyTraitExpression	"Copy all except the actual traits"	^self! !!TraitComposition methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!traitCompositionString	"Answer the trait composition string (used for class definitions)"	self size = 0 ifTrue:[^'{}'].	self  size = 1 ifTrue:[^self first asString].	^String streamContents:[:s|		self do:[:each| s nextPutAll: each asString] separatedBy:[s nextPutAll: ' + '].	].! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:11'!asTraitTransform	^self! !!Trait class methodsFor: 'public' stamp: 'ar 12/27/2009 14:11'!newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString	"Creates a new trait."	| env |	env := self environment.	^self		named: aSymbol		uses: aTraitCompositionOrCollection		category: aString		env: env! !!TraitComposition methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!removeUser: aUser	^self removeTraitUser: aUser! !!TraitDescription methodsFor: 'operations' stamp: 'ar 11/28/2007 20:59'!traitsDo: aBlock	aBlock value: self.! !!ClassTrait methodsFor: 'accessing' stamp: 'ar 12/20/2009 02:55'!theMetaClass	^self! !!TraitTransformation methodsFor: 'operations' stamp: 'ar 12/29/2009 18:11'!selectorsAndMethodsDo: aBlock	"enumerates all selectors and methods in a trait composition"	^self subclassResponsibility! !!TraitDescription class methodsFor: 'conflict methods' stamp: 'ar 12/19/2009 22:47'!conflict	"This method has a trait conflict"	^self traitConflict! !!TraitMethodState methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!originalTraitMethod: aCompiledMethod	"The original method from the trait"	originalTraitMethod := aCompiledMethod! !!TraitAlias class methodsFor: 'instance creation' stamp: 'ar 12/29/2009 18:21'!assertValidAliasDefinition: anArrayOfAssociations	"Throw an exceptions if the alias definition is not valid.	It is expected to be a collection of associations and	the number of arguments of the alias selector has to	be the same as the original selector."	((anArrayOfAssociations isKindOf: Collection) and: [		anArrayOfAssociations allSatisfy: [:each |			each isKindOf: Association]]) ifFalse: [		self error: 'Invalid alias definition: Not a collection of associations.'].		(anArrayOfAssociations allSatisfy: [:association |		(association key numArgs = association value numArgs and: [			(association key numArgs = -1) not])]) ifFalse: [		TraitCompositionException signal: 'Invalid alias definition: Alias and original selector have to have the same number of arguments.']! !!TraitExclusion methodsFor: 'accessing' stamp: 'ar 12/29/2009 18:11'!exclusions	^exclusions! !!TraitDescription methodsFor: 'operations' stamp: 'ar 12/19/2009 23:54'!installTraitsFrom: aTraitComposition	super installTraitsFrom: aTraitComposition.	self users do:[:each| each updateTraits].! !!ClassTrait methodsFor: 'initialize' stamp: 'ar 12/29/2009 18:38'!uses: aTraitComposition	| newTraits |	newTraits := aTraitComposition asTraitComposition.	newTraits traitsDo:[:t|		(t isBaseTrait and:[t classSide hasMethods]) 			ifTrue:[self error: 'Cannot add: ', t].		(t isClassTrait and:[(baseTrait includesTrait: t baseTrait) not]) 			ifTrue:[self error: 'Cannot add: ', t].	].	self installTraitsFrom: newTraits.! !!Trait methodsFor: 'accessing' stamp: 'ar 12/30/2009 01:55'!theMetaClass	^self classTrait! !!TraitDescription methodsFor: 'testing' stamp: 'ar 11/28/2007 20:56'!isTraitTransformation	"Polymorphic with TraitTransformation"	^false! !!TraitTransformation methodsFor: 'converting' stamp: 'ar 12/29/2009 18:20'!asTraitComposition	^TraitComposition with: self! !!TraitExclusion methodsFor: 'converting' stamp: 'ar 12/29/2009 18:21'!@ anArrayOfAssociations 	TraitCompositionException signal: 'Invalid trait exclusion. Aliases have to be specified before exclusions.'! !!TraitTransformation methodsFor: 'testing' stamp: 'ar 12/29/2009 18:11'!isAliasSelector: selector	^subject isAliasSelector: selector! !!NanoTrait methodsFor: 'converting' stamp: 'ar 12/29/2009 18:34'!asTraitComposition	"Convert me into a trait composition"	^TraitComposition with: self! !!Trait class methodsFor: 'public' stamp: 'ar 12/27/2009 14:12'!named: aSymbol uses: aTraitCompositionOrCollection category: aString	"Dispatch through ClassDescription for alternative implementations"	^ClassDescription newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString! !!Trait class methodsFor: 'public' stamp: 'ar 12/27/2009 19:07'!newTemplateIn: categoryString	^String streamContents: [:stream |		stream			nextPutAll: 'Trait named: #NameOfTrait';			cr; tab;			nextPutAll: 'uses: {}';			cr; tab;			nextPutAll: 'category: ';			nextPut: $';			nextPutAll: categoryString;			nextPut: $' ]! !TraitAlias removeSelector: #aliasesForSelector:!TraitComposition removeSelector: #transformations!TraitComposition removeSelector: #add:!TraitComposition removeSelector: #copyWithoutAlias:of:!TraitMethodDescription removeSelector: #selector!TraitTransformation removeSelector: #normalized!Smalltalk removeClassNamed: #TraitException!TraitComposition class removeSelector: #with:!TraitComposition removeSelector: #transformationOfTrait:!TraitTransformation removeSelector: #theNonMetaClass!TraitTransformation removeSelector: #selectors!TraitMethodDescription removeSelector: #requiredMethod!TraitComposition removeSelector: #size!TraitTransformation removeSelector: #changedSelectorsComparedTo:!TraitExclusion removeSelector: #methodReferencesInCategory:!TraitComposition removeSelector: #notEmpty!Smalltalk removeClassNamed: #TraitMethodDescription!TraitMethodDescription removeSelector: #effectiveMethodCategoryCurrent:new:!NanoTrait classSide removeSelector: #unloadNanoTraits!TraitMethodDescription removeSelector: #locatedMethods!TraitTransformation removeSelector: #traitTransformations!TraitTransformation removeSelector: #isEmpty!TraitTransformation removeSelector: #removeAlias:!TraitAlias removeSelector: #isEmpty!TraitMethodDescription removeSelector: #effectiveMethodCategory!TraitComposition removeSelector: #assertValidUser:!TraitComposition removeSelector: #initialize!TraitComposition removeSelector: #includesMethod:!TraitComposition removeSelector: #changedSelectorsComparedTo:!TraitAlias removeSelector: #removeAlias:!TraitMethodDescription removeSelector: #isProvided!TraitComposition removeSelector: #remove:!TraitMethodDescription removeSelector: #providedMethod!TraitTransformation removeSelector: #collectMethodsFor:into:!TraitComposition removeSelector: #transformations:!TraitComposition removeSelector: #isEmpty!TraitExclusion removeSelector: #isEmpty!TraitMethodDescription classSide removeSelector: #selector:!TraitComposition removeSelector: #normalizeTransformations!TraitMethodDescription removeSelector: #size!TraitAlias removeSelector: #collectMethodsFor:into:!TraitTransformation removeSelector: #copy!TraitAlias removeSelector: #copy!TraitMethodDescription removeSelector: #selector:!TraitMethodDescription removeSelector: #conflictMethod!TraitComposition class removeSelector: #with:with:!TraitTransformation removeSelector: #sourceCodeTemplate!TraitMethodDescription classSide removeSelector: #initialize!TraitComposition removeSelector: #asArray!TraitExclusion removeSelector: #collectMethodsFor:into:!TraitMethodDescription classSide removeSelector: #maxArguments!TraitTransformation removeSelector: #allAliasesDict!TraitComposition removeSelector: #methodDescriptionsForSelector:!TraitMethodDescription removeSelector: #getArgumentNames!TraitComposition removeSelector: #copy!TraitComposition removeSelector: #addCompositionOnLeft:!TraitMethodDescription removeSelector: #initialize!TraitAlias removeSelector: #aliasNamed:ifAbsent:!TraitExclusion removeSelector: #copy!TraitAlias removeSelector: #allAliasesDict!TraitTransformation removeSelector: #isMeta!TraitTransformation removeSelector: #allSelectors!TraitMethodDescription classSide removeSelector: #new!TraitMethodDescription removeSelector: #isAliasSelector!TraitMethodDescription removeSelector: #isEmpty!TraitAlias removeSelector: #allSelectors!TraitMethodDescription removeSelector: #conflictMethodForArguments:ifAbsentPut:!TraitTransformation removeSelector: #printOn:!TraitTransformation removeSelector: #addExclusionOf:!TraitMethodDescription removeSelector: #effectiveMethod!TraitComposition removeSelector: #printString!TraitComposition removeSelector: #methodDescriptionForSelector:!TraitMethodDescription removeSelector: #isConflict!TraitMethodDescription removeSelector: #providedLocatedMethod!TraitExclusion removeSelector: #allSelectors!TraitMethodDescription removeSelector: #generateTemplateMethodWithMarker:forArgs:binary:!TraitComposition removeSelector: #copyWithExclusionOf:to:!TraitMethodDescription removeSelector: #isRequired!TraitMethodDescription removeSelector: #requiredMethodForArguments:ifAbsentPut:!TraitTransformation removeSelector: #aliasesForSelector:!TraitMethodDescription removeSelector: #isLocalAliasSelector!TraitMethodDescription removeSelector: #methodsDo:!TraitTransformation removeSelector: #subject!TraitMethodDescription removeSelector: #addLocatedMethod:!TraitComposition removeSelector: #errorIfNotAddable:!TraitMethodDescription removeSelector: #isBinarySelector!TraitComposition removeSelector: #addOnTheLeft:!TraitExclusion removeSelector: #addExclusionOf:!Trait initialize!TraitMethodDescription initialize!