"Change Set:		8232Collections-nice.213Collections-nice.213:Support for literal ByteArray #[1 2 3]Collections-ul.201:- added a class comment to WeakSet (this is required to avoid the failure of ClassTestCase)Collections-ul.202:- a fix for the bug in WeakSet >> #includes:Collections-ar.204:Merging Collections-ul.200, Collections-ul.201, Collections-ul.202, Collections-ul.203:- moved #like: from HashedCollection to Set- HashedCollection doesn't implmenet #do: anymore, implementation is moved to Set >> #do: and Dictionary >> #associationsDo:- Dictionary >> #do: sends #valuesDo:- Set >> collect: sends #do: to self, instead of it's array. This enables one to change the way enumeration methods work, by reimplementing only #do: in subclasses.- minor enhancement in #scanForEmptySlotFor: in identity based hashedcollections.- added missing #yourself sends to #copyEmpty implementors- removed #noCheckAdd: implementations since they were private- other cosmetic changes, like isNil ifTrue: replaced by ifNil:, etc.- added a class comment to WeakSet (this is required to avoid the failure of ClassTestCase)- a fix for the bug in WeakSet >> #includes:- removed HashedCollection >> #do: because it was the same as in CollectionCollections-ar.205:Collection>>ifEmpty: and Collection>>ifNotEmpty: should behave like #ifNil: and return self unless the condition is met. Makes collection manipulation easier, for example 	port := ((hostname copyAfter: $:) ifEmpty:['80']) asIntegerinstead of 	portString:= hostname copyAfter: $:.	portString ifEmpty:[portString := '80'].	port := portString asInteger.etc.Collections-nice.206:1) merge ul.205 (collect:into: collect:as:)2) correct #nextLine and #upToAnyOf: using a new message #collectionSpeciesCollections-nice.207:remove duplicated code from #convertToSystemStringCollections-nice.208:Speedup OrderedCollection and SortedCollection asArray (a usual pattern)size 1 -> 1.6xsize 10 -> 2.8xsize 100 -> 12.1xsize 1000 -> 27.7xCollections-ul.209:- fix: String >> #withInternetLineEndings raised an MNU: WriteStream doesNotUnderstand: #lfCollections-ar.212:Merging Collections-ul.210, Collections-ul.211:- HashedCollections have prime capacity (if they are not oversized)- HashedCollections' growth rate is not 2, but 1.5 (2 for small sizes which decreases to 1.5 as the size increases)(based on AndrÃ©s Valloud's changes made for pharo)Load Kernel-ul.305 before this.- replaced 32359813 with 32435981 in HashedCollection >> #goodPrimes."!Set subclass: #WeakSet	instanceVariableNames: 'flag'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Weak'!!PositionableStream methodsFor: 'accessing' stamp: 'nice 11/22/2009 18:09'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream := WriteStream on: (self collectionSpecies new: 100).	[self atEnd or: [(element := self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!Collection methodsFor: 'private' stamp: 'ul 11/21/2009 01:14'!fillFrom: aCollection with: aBlock	"Evaluate aBlock with each of aCollections's elements as the argument.  	Collect the resulting values into self. Answer self."	aCollection do: [ :each |		self add: (aBlock value: each) ]! !!OrderedCollection methodsFor: 'converting' stamp: 'nice 11/22/2009 21:38'!asArray	"Overriden for speed"	 ^array copyFrom: firstIndex to: lastIndex! !!ArrayedCollection methodsFor: 'private' stamp: 'ul 11/21/2009 01:15'!fillFrom: aCollection with: aBlock	"Evaluate aBlock with each of aCollections's elements as the argument.  	Collect the resulting values into self. Answer self."	| index |	index := 0.	aCollection do: [ :each |		self at: (index := index + 1) put: (aBlock value: each) ]! !!KeyedSet methodsFor: 'copying' stamp: 'ul 11/20/2009 18:37'!copyEmpty	^super copyEmpty		keyBlock: keyBlock;		yourself! !!ByteArray methodsFor: 'printing' stamp: 'stephane.ducasse 2/1/2009 22:39'!printOn: aStream	aStream nextPutAll: '#['.	self		do: [ :each | each printOn: aStream ]		separatedBy: [ aStream nextPut: $ ].	aStream nextPut: $]! !!WeakSet methodsFor: 'public' stamp: 'ul 11/20/2009 17:47'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject"	| index element |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self scanFor: newObject.	((element := array at: index) == flag or: [ element == nil ])		ifTrue: [self atNewIndex: index put: newObject].	^newObject! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ul 11/20/2009 17:35'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size >= 8192		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!PositionableStream methodsFor: 'private' stamp: 'nice 11/22/2009 18:03'!collectionSpecies	"Answer the species of collection into which the receiver can stream"		^collection species! !!WeakSet methodsFor: 'public' stamp: 'ul 11/20/2009 23:03'!includes: anObject 		| element |	^((element := array at: (self scanFor: anObject)) == flag or: [ element == nil ]) not! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ul 11/20/2009 17:40'!keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."		self associationsDo: [ :association |		| key |		(key := association key) ifNotNil: [ "Don't let the key go away"			aBlock value: key ] ].! !!Collection methodsFor: 'testing' stamp: 'ar 11/21/2009 00:36'!ifNotEmptyDo: aBlock	"Evaluate the given block with the receiver as its argument."	self isEmpty ifFalse: [^ aBlock value: self].! !!Dictionary methodsFor: 'adding' stamp: 'ul 11/20/2009 17:16'!add: anAssociation	| index element |	index := self scanFor: anAssociation key.	(element := array at: index)		ifNil: [ self atNewIndex: index put: anAssociation ]		ifNotNil: [ element value: anAssociation value ].	^anAssociation! !!Dictionary methodsFor: 'private' stamp: 'ul 11/21/2009 01:15'!fillFrom: aCollection with: aBlock	"Evaluate aBlock with each of aCollections's elements as the argument.  	Collect the resulting values into self. Answer self."	aCollection keysAndValuesDo: [ :key :value |		self at: key put: (aBlock value: value) ]! !!Set methodsFor: 'accessing' stamp: 'ul 11/20/2009 16:54'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	^array at: (self scanFor: anObject)! !!Set methodsFor: 'enumerating' stamp: 'ul 11/20/2009 17:33'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newSet |	newSet := Set new: self size.	self do: [ :each | newSet add: (aBlock value: each) ].	^newSet! !!String methodsFor: 'internet' stamp: 'ul 11/23/2009 14:31'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably in prepration for sending a string over the Internet"		^self class		new: self size * 16 // 15 "provisions for CR-LF pairs"		streamContents: [ :stream |			self lineIndicesDo: [:start :endWithoutDelimiters :end |				stream nextPutAll: (self copyFrom: start to: endWithoutDelimiters).				endWithoutDelimiters = end ifFalse: [					stream cr; nextPut: Character lf ] ] ]! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/25/2009 04:00'!growSize	"Answer what my next higher table size should be"		^self class goodPrimeAtLeast: array size * 3 // 2 + 2! !!Collection methodsFor: 'testing' stamp: 'ar 11/21/2009 00:34'!ifEmpty: aBlock	"Evaluate the block if I'm empty"	self isEmpty ifTrue: [ ^aBlock value ]! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 11/20/2009 17:42'!finalizeValues	"remove all nil keys and rehash the receiver afterwards"		| assoc |	1 to: array size do: [ :index |		(assoc := array at: index) ifNotNil: [			assoc key ifNil: [ array at: index put: nil ] ] ].	self rehash! !!HashedCollection class methodsFor: 'sizing' stamp: 'ul 11/25/2009 03:34'!goodPrimeAtLeast: lowerLimit	"Answer the next good prime >= lowerlimit.	If lowerLimit is larger than the largest known good prime,	just make it odd."		| primes low mid high prime |	primes := self goodPrimes.	low := 1.	high := primes size.	lowerLimit > (primes at: high) ifTrue: [		^lowerLimit even 			ifTrue: [ lowerLimit + 1 ]			ifFalse: [ lowerLimit ] ].	[ high - low <= 1 ] whileFalse: [		mid := high + low // 2.		prime := primes at: mid.		prime = lowerLimit ifTrue: [ ^prime ].		prime < lowerLimit			ifTrue: [ low := mid ]			ifFalse: [ high := mid ] ].	(primes at: low) >= lowerLimit ifTrue: [ ^primes at: low ].	^primes at: high! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 11/22/2009 18:10'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override 	because default uses self contents species, which might involve a large 	collection."	| newArray |	newArray := self collectionSpecies new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!PluggableDictionary methodsFor: 'copying' stamp: 'ul 11/20/2009 17:36'!copyEmpty	^super copyEmpty		hashBlock: hashBlock;		equalBlock: equalBlock;		yourself! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 11/22/2009 18:06'!upToAnyOf: aCollection 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of any object in the collection. If 	no matching object is found, answer the entire rest of the receiver."	| newStream element |	newStream := WriteStream on: (self collectionSpecies new: 100).	[self atEnd or: [aCollection includes: (element := self next)]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!HashedCollection class methodsFor: 'sizing' stamp: 'ul 11/25/2009 04:24'!sizeFor: nElements	"Large enough prime (or odd if too large) size to hold nElements with some slop (see fullCheck)"		nElements < 4 ifTrue: [ ^5 ].	^self goodPrimeAtLeast: nElements + 1 * 4 // 3! !!PluggableSet methodsFor: 'copying' stamp: 'ul 11/20/2009 17:36'!copyEmpty	^super copyEmpty		hashBlock: hashBlock;		equalBlock: equalBlock;		yourself! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 11/22/2009 18:07'!nextLine	"Answer next line (may be empty), or nil if at end.	Handle a zoo of line delimiters CR, LF, or CR-LF pair"	| newStream element crlf |	self atEnd ifTrue: [^nil].	crlf := CharacterSet crlf.	newStream := WriteStream on: (self collectionSpecies new: 100).	[self atEnd ifTrue: [^newStream contents].	crlf includes: (element := self next)]		whileFalse: [newStream nextPut: element].	element = Character cr ifTrue: [self peekFor: Character lf]. "handle an eventual CR LF pair"	^newStream contents! !!Collection methodsFor: 'testing' stamp: 'ar 11/21/2009 00:36'!ifNotEmpty: aBlock	"Evaluate the given block unless the receiver is empty.      If the block has an argument, eval with the receiver as its argument,      but it might be better to use ifNotEmptyDo: to make the code easier to      understand"	self isEmpty ifFalse: [^ aBlock valueWithPossibleArgument: self].! !!Dictionary methodsFor: 'accessing' stamp: 'ul 11/20/2009 17:09'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	^((array at: (self scanFor: key)) ifNil: [ aBlock ]) value "Blocks and Associations expect #value"! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/25/2009 04:01'!grow	"Grow the elements array and reinsert the old elements"		self growTo: self growSize! !!String methodsFor: 'converting' stamp: 'nice 11/22/2009 21:06'!convertToSystemString	^self convertToWithConverter: LanguageEnvironment defaultSystemConverter! !!Dictionary methodsFor: 'removing' stamp: 'ul 11/20/2009 17:25'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index association |	index := self scanFor: key.	association := (array at: index) ifNil: [ ^aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^association value! !!Dictionary methodsFor: 'accessing' stamp: 'ul 11/20/2009 16:59'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	^(array at: (self scanFor: key)) ifNil: [ aBlock value ]! !!Collection methodsFor: 'enumerating' stamp: 'ul 11/21/2009 01:16'!collect: aBlock as: aClass	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into an instance of aClass. Answer the resulting collection."	^(aClass new: self size) fillFrom: self with: aBlock! !!HashedCollection class methodsFor: 'sizing' stamp: 'ul 11/25/2009 04:51'!goodPrimes	"Answer a sorted array of prime numbers less than one billion that make good	hash table sizes. Should be expanded as needed.  See comments below code"		^#(5 11 17 23 31 43 59 79 107 149 199 269 359 479 641 857 1151 1549 2069		2237 2423 2617 2797 2999 3167 3359 3539 3727 3911		4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853		8887 9587 10243 10937 11617 12289 12967 13649 14341 15013 15727		17749 19121 20479 21859 23209 24593 25939 27329 28669 30047 31469		35507 38231 40961 43711 46439 49157 51893 54617 57347 60077 62801		70583 75619 80669 85703 90749 95783 100823 105871 110909 115963 120997 126031		141157 151237 161323 171401 181499 191579 201653 211741 221813 231893 241979 252079		282311 302483 322649 342803 362969 383143 403301 423457 443629 463787 483953 504121		564617 604949 645313 685609 725939 766273 806609 846931 887261 927587 967919 1008239		1123477 1198397 1273289 1348177 1423067 1497983 1572869 1647761 1722667 1797581 1872461 1947359 2022253		2246953 2396759 2546543 2696363 2846161 2995973 3145739 3295541 3445357 3595117 3744941 3894707 4044503		4493921 4793501 5093089 5392679 5692279 5991883 6291469 6591059 6890641 7190243 7489829 7789447 8089033		8987807 9586981 10186177 10785371 11384539 11983729 12582917 13182109 13781291 14380469 14979667 15578861 16178053		17895707 19014187 20132683 21251141 22369661 23488103 24606583 25725083 26843549 27962027 29080529 30198989 31317469 32435981		35791397 38028379 40265327 42502283 44739259 46976221 49213237 51450131 53687099 55924061 58161041 60397993 62634959 64871921		71582857 76056727 80530643 85004567 89478503 93952427 98426347 102900263 107374217 111848111 116322053 120795971 125269877 129743807		143165587 152113427 161061283 170009141 178956983 187904819 196852693 205800547 214748383 223696237 232644089 241591943 250539763 259487603		285212677 301989917 318767107 335544323 352321547 369098771 385876021 402653189 419430419 436207619 452984849 469762049 486539323 503316511 520093703		570425377 603979799 637534277 671088667 704643083 738197549 771751961 805306457 838860817 872415239 905969671 939524129 973078537 1006632983 1040187403		1073741789)"The above primes past 2069 were chosen carefully so that they do not interact badly with 1664525 (used by hashMultiply), and so that gcd(p, (256^k) +/- a) = 1, for 0<a<=32 and 0<k<=8.  See Knuth's TAOCP for details."! !!Dictionary methodsFor: 'enumerating' stamp: 'ul 11/20/2009 17:21'!associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's elements (key/value 	associations)."	tally = 0 ifTrue: [ ^self].	1 to: array size do: [ :index |		| each |		(each := array at: index)			ifNotNil: [ aBlock value: each ] ]! !!IdentitySet methodsFor: 'private' stamp: 'ul 11/20/2009 17:35'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size >= 8192		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!Set methodsFor: 'enumerating' stamp: 'ul 11/20/2009 17:32'!do: aBlock 	tally = 0 ifTrue: [ ^self ].	1 to: array size do: [ :index |		| each |		(each := array at: index)			ifNotNil: [ aBlock value: each ] ]! !!Collection methodsFor: 'enumerating' stamp: 'ul 11/21/2009 01:16'!collect: aBlock into: aCollection	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into aCollection. Answer aCollection."	^aCollection fillFrom: self with: aBlock! !!IdentityDictionary methodsFor: 'private' stamp: 'ul 11/20/2009 17:34'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size >= 8192		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!PositionableStream methodsFor: 'accessing' stamp: 'nice 11/22/2009 18:09'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream |	newStream := WriteStream on: (self collectionSpecies new: 100).	[self atEnd] whileFalse: [ newStream nextPut: self next ].	^ newStream contents! !!ByteArray methodsFor: 'testing' stamp: 'stephane.ducasse 2/1/2009 23:10'!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^ true! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ul 11/20/2009 17:40'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."		| index element |	key ifNil: [ ^anObject ].	index := self scanFor: key.	(element := array at: index)		ifNil: [ self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject) ]		ifNotNil: [ element value: anObject ].	^anObject! !!KeyedIdentitySet methodsFor: 'private' stamp: 'ul 11/20/2009 17:35'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size >= 8192		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!ByteArray methodsFor: 'printing' stamp: 'stephane.ducasse 2/1/2009 22:40'!storeOn: aStream	aStream nextPutAll: '#['.	self		do: [ :each | each storeOn: aStream ]		separatedBy: [ aStream nextPut: $ ].	aStream nextPut: $]! !!Dictionary methodsFor: 'enumerating' stamp: 'ul 11/20/2009 17:21'!do: aBlock	self valuesDo: aBlock! !HashedCollection removeSelector: #do:!Dictionary removeSelector: #remove:!Set removeSelector: #noCheckAdd:!Dictionary removeSelector: #noCheckAdd:!HashedCollection removeSelector: #like:!