"Change Set:		9226Morphic-kb.318Morphic-kb.318: - fix: MenuMorph releases selection for keyboard events. Before this you could not move through menu items with the cursor if it had a submenu. - fix: With left or right arrow now you can only move into a submenu. Before this those keystrokes were added to the filter if the selectedItem had no submenu.Morphic-kb.316: - fix for: http://bugs.squeak.org/view.php?id=7462The fix adds a check to SystemWindow >> activate, to avoid sending #addPaneSplitters if the window isCollapsed. Morphic-kb.317: - quick fix for: http://lists.squeakfoundation.org/pipermail/squeak-dev/2010-February/144057.htmlThe fix adds a check to MenuMorph >> displayFiltered: to prevent invoking selectItem:event: without an event, because the current implementation doesn't support that."!!MenuMorph methodsFor: 'events' stamp: 'kb 2/4/2010 02:10'!releasesSelection: evt	" The MenuMorph releases its selection if the selected item releases it. 	Used in #selectItem:event: "	self selectedItem ifNil: [ ^true ].	evt ifNil: [ ^true ].	evt isKeyboard ifTrue: [ ^true ].	(self selectedItem containsPoint: evt position) ifTrue: [ ^true ].	^self selectedItem releasesSelection: evt! !!MenuMorph methodsFor: 'keyboard control' stamp: 'kb 2/4/2010 02:27'!keyStroke: evt 	| matchString char asc selectable help |	help := BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.	(self rootMenu hasProperty: #hasUsedKeyboard) 		ifFalse: 			[self rootMenu setProperty: #hasUsedKeyboard toValue: true.			self changed].	(evt commandKeyPressed and: [self commandKeyHandler notNil]) 		ifTrue: 			[self commandKeyHandler commandKeyTypedIntoMenu: evt.			^self deleteIfPopUp: evt].	char := evt keyCharacter.	asc := char asciiValue.	char = Character cr 		ifTrue: 			[selectedItem ifNotNil: 					[selectedItem hasSubMenu 						ifTrue: 							[evt hand newMouseFocus: selectedItem subMenu.							^evt hand newKeyboardFocus: selectedItem subMenu]						ifFalse: 							["self delete."							^selectedItem invokeWithEvent: evt]].			(selectable := self items) size = 1 				ifTrue: [^selectable first invokeWithEvent: evt].			^self].	asc = 27 		ifTrue: 			["escape key"			self valueOfProperty: #matchString				ifPresentDo: 					[:str | 					str isEmpty 						ifFalse: 							["If filtered, first ESC removes filter"							self setProperty: #matchString toValue: String new.							self selectItem: nil event: evt.							^self displayFiltered: evt]].			"If a stand-alone menu, just delete it"			popUpOwner ifNil: [^self delete].			"If a sub-menu, then deselect, and return focus to outer menu"			self selectItem: nil event: evt.			evt hand newMouseFocus: popUpOwner owner.			^evt hand newKeyboardFocus: popUpOwner owner ].		(asc = 28 or: [asc = 29]) 		ifTrue: 			["left or right arrow key"			(selectedItem notNil and: [selectedItem hasSubMenu]) 				ifTrue: 					[evt hand newMouseFocus: selectedItem subMenu.					selectedItem subMenu moveSelectionDown: 1 event: evt.					^evt hand newKeyboardFocus: selectedItem subMenu]				ifFalse: [ ^self ] ].	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: evt].	"up arrow key"	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: evt].	"down arrow key"	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: evt].	"page up key"	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: evt].	"page down key"	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].	matchString := char = Character backspace 				ifTrue: 					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]				ifFalse: [matchString copyWith: evt keyCharacter].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt.	help := BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.! !!SystemWindow methodsFor: 'top window' stamp: 'kb 2/2/2010 15:48'!activate	"Activate the owner too."	|mo mc|	mo := self modalOwner.	mc := self modalChild.	mc isNil		ifFalse: [mc owner notNil ifTrue: [				mc activate.				^mc modalChild isNil ifTrue: [mc flash]]].	(isCollapsed not and: [ 		self paneMorphs size > 1 and: [ 			self splitters isEmpty ] ]) ifTrue: [ self addPaneSplitters ].	self activateWindow.	self rememberedKeyboardFocus		ifNil: [(self respondsTo: #navigateFocusForward)				ifTrue: [self navigateFocusForward]]		ifNotNil: [:m | m world						ifNil: [self rememberKeyboardFocus: nil] "deleted"						ifNotNil: [:w | 							m wantsKeyboardFocus								ifTrue: [m takeKeyboardFocus]								ifFalse: [(self respondsTo: #navigateFocusForward)											ifTrue: [self navigateFocusForward]]]].	(mo notNil and: [mo isKindOf: SystemWindow])		ifTrue: [mo bringBehind: self]! !!MenuMorph methodsFor: 'keyboard control' stamp: 'kb 2/4/2010 00:32'!displayFiltered: evt	| matchStr allItems matches feedbackMorph |	matchStr := self valueOfProperty: #matchString.	allItems := self submorphs select: [:m | m isKindOf: MenuItemMorph].	matches :=  allItems select: [:m | | isMatch | 		isMatch := 			matchStr isEmpty or: [				m contents includesSubstring: matchStr caseSensitive: false].		m isEnabled: isMatch.		isMatch].	feedbackMorph := self valueOfProperty: #feedbackMorph.	feedbackMorph ifNil: [		feedbackMorph := 			TextMorph new 				autoFit: true;				color: Color darkGray.		self			addLine;			addMorphBack: feedbackMorph lock.		self setProperty: #feedbackMorph toValue: feedbackMorph.		self fullBounds.  "Lay out for submorph adjacency"].	feedbackMorph contents: '<', matchStr, '>'.	matchStr isEmpty ifTrue: [		feedbackMorph delete.		self submorphs last delete.		self removeProperty: #feedbackMorph].	" This method is invoked with evt = nil from MenuMorph >> removeMatchString. 	The current implementation can't select an item without an event. "	(evt notNil and: [ matches size >= 1 ]) ifTrue: [		self selectItem: matches first event: evt]! !