"Change Set:		8607TrueType-nice.12TrueType-nice.12:Cosmetic: move or remove a few temps inside closures"!!TTFileDescription class methodsFor: 'instance creation' stamp: 'nice 12/27/2009 03:12'!installFamilyNamed: familyName	"Install all the corresponding fonts for this family"	"		TTFileDescription installFamilyNamed: 'Arial'.		TTFileDescription installFamilyNamed: 'Batang'.	"	| fontFiles |	fontFiles := self allFontsAndFiles at: familyName ifAbsent:[#()].	fontFiles do:[:fileName| | ttDesc |		ttDesc := (self readFontsFrom: fileName) detect:[:fnt| fnt familyName = familyName].		TTCFont newTextStyleFromTT: ttDesc.	].	^TextStyle named: familyName! !!TTFileDescription class methodsFor: 'font paths' stamp: 'nice 12/27/2009 03:12'!allFamilyNamesAndFiles	"Answer a dictionary of all known family names and their corresponding file names."		AllFontsAndFiles ifNil:[		AllFontsAndFiles := Dictionary new.		Cursor wait showWhile:[self allFontsDo:[:font| | names |			names := AllFontsAndFiles at: font familyName 					ifAbsentPut:[OrderedCollection new].			names add: font fileName]]].	^AllFontsAndFiles ! !!TTFileDescription class methodsFor: 'user interaction' stamp: 'nice 12/27/2009 03:12'!fontFromUser: priorFont allowKeyboard: aBoolean	"TTFileDescription fontFromUser"	| fontMenu fontNames builder resultBlock style font widget result |	builder := ToolBuilder default.	fontNames := self allFontsAndFiles keys asArray sort.	fontMenu := builder pluggableMenuSpec new.	fontMenu label: 'Non-portable fonts'.	resultBlock := [:value| result := value].	fontNames do: [:fontName | | active ptMenu item |		active := priorFont familyName sameAs: fontName.		ptMenu := builder pluggableMenuSpec new.		TTCFont pointSizes do: [:pt | | label |			label := pt printString, ' pt'.			item := ptMenu add: label 				target: resultBlock				selector: #value:				argumentList: {{fontName. pt}}.			item checked: (active and:[pt = priorFont pointSize]).		].		item := fontMenu add: fontName action: nil.		item subMenu: ptMenu.		item checked: active.	].	widget := builder open: fontMenu.	builder runModal: widget.	result ifNil:[^nil].	style := (TextStyle named: result first) ifNil:[self installFamilyNamed: result first].	style ifNil: [^ self].	font := style fonts detect: [:any | any pointSize = result last] ifNone: [nil].	^ font! !!TTFontReader methodsFor: 'processing' stamp: 'nice 12/27/2009 03:10'!processGlyphDataTable: entry offsets: offsetArray	"Read the actual glyph data from the font.	offsetArray contains the start offsets in the data for each glyph."	| initialOffset |	initialOffset := entry offset.	glyphs := Array new: nGlyphs.	1 to: nGlyphs do:[:i | 		glyphs at: i put: (TTGlyph new glyphIndex: i-1)].	'Reading glyph data' 		displayProgressAt: Sensor cursorPoint		from: 1 to: nGlyphs during:[:bar| | nContours glyphOffset origin corner glyphLength glyph nextOffset |	1 to: nGlyphs do:[:glyphIndex |		bar value: glyphIndex.		glyph := glyphs at: glyphIndex.		glyphOffset := offsetArray at: glyphIndex.		nextOffset := offsetArray at: glyphIndex+1.		glyphLength := nextOffset - glyphOffset.		glyphLength = 0 ifFalse:[			entry offset: initialOffset + glyphOffset.			nContours := entry nextShort.			origin := entry nextShort @ entry nextShort.			corner := entry nextShort @ entry nextShort.			glyph bounds: (origin corner: corner).			nContours >= 0 ifTrue:[				self processSimpleGlyph: glyph contours: nContours from: entry			] ifFalse:[				glyph := self processCompositeGlyph: glyph contours: nContours from: entry.				glyphs at: glyphIndex put: glyph]]]	].! !!TTFontReader methodsFor: 'private' stamp: 'nice 12/27/2009 03:10'!decodeCmapFmtTable: entry	| cmapFmt length entryCount segCount segments offset cmap firstCode |	cmapFmt := entry nextUShort.	length := entry nextUShort.	entry skip: 2. "skip version"	cmapFmt = 0 ifTrue: "byte encoded table"		[length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^ nil].	"but sometimes, this table is empty"		cmap := Array new: length.		entry nextBytes: length into: cmap startingAt: entry offset.		^ cmap].	cmapFmt = 4 ifTrue: "segment mapping to deltavalues"		[segCount := entry nextUShort // 2.		entry skip: 6. "skip searchRange, entrySelector, rangeShift"		segments := Array new: segCount.		segments := (1 to: segCount) collect: [:e | Array new: 4].		1 to: segCount do: [:i | (segments at: i) at: 2 put: entry nextUShort]. "endCount"		entry skip: 2. "skip reservedPad"		1 to: segCount do: [:i | (segments at: i) at: 1 put: entry nextUShort]. "startCount"		1 to: segCount do: [:i | (segments at: i) at: 3 put: entry nextShort]. "idDelta"		offset := entry offset.		1 to: segCount do: [:i | (segments at: i) at: 4 put: entry nextUShort]. "idRangeOffset"		entryCount := segments inject: 0 into: [:max :seg | max max: seg second].		cmap := Array new: entryCount+1 withAll: 0..		segments withIndexDo:			[:seg :si | | code |			seg first to: seg second do:				[:i |				seg last > 0 ifTrue:					["offset to glypthIdArray - this is really C-magic!!"					entry offset: i - seg first - 1 * 2 + seg last + si + si + offset. 					code := entry nextUShort.					code > 0 ifTrue: [code := code + seg third]]				ifFalse:					["simple offset"					code := i + seg third].				cmap at: i + 1 put: code]].		^ cmap].	cmapFmt = 6 ifTrue: "trimmed table"		[firstCode := entry nextUShort.		entryCount := entry nextUShort.		cmap := Array new: entryCount + firstCode withAll: 0.		entryCount timesRepeat:			[cmap at: (firstCode := firstCode + 1) put: entry nextUShort].		^ cmap].	^ nil! !!TTFileDescription class methodsFor: 'font paths' stamp: 'nice 12/27/2009 03:12'!findFontFile: fontFileName	"Find the path containing the font with the given name.	If it can't be found, return nil."		self fontPathsDo:[:path| | fd |		fd := FileDirectory on: path.		([fd fileExists: fontFileName] on: Error do:[false]) 			ifTrue:[^fd fullNameFor: fontFileName].	].	^nil! !!TTGlyph methodsFor: 'private-initialization' stamp: 'nice 12/27/2009 03:10'!referenceVertexAt: index	"Only used while reading before constructing contours"	| count |	count := 0.	contours do: [:construction | | vertices |		vertices := construction points.		index - count > vertices size			ifTrue: [count := count + vertices size]			ifFalse: [^(vertices at: index - count) asPoint]].	^count! !!TTFileDescription methodsFor: 'glyphs' stamp: 'nice 12/27/2009 03:12'!glyphAt: charOrCode	"Answer the glyph with the given code point"	| codePoint glyph |	codePoint := charOrCode asCharacter charCode.	self withFileDo:[:fontFile| | glyphIndex |		glyphIndex := self readCmapTableAt: codePoint fromFile: fontFile.		glyph := self readGlyphAt: glyphIndex fromFile: fontFile.		self updateGlyphMetrics: glyph fromFile: fontFile.	].	^glyph! !!TTFileDescription class methodsFor: 'font paths' stamp: 'nice 12/27/2009 03:12'!allFontsAndFiles	"Answer a dictionary of all known family names and their corresponding file names."		AllFontsAndFiles ifNil:[		AllFontsAndFiles := Dictionary new.		Cursor wait showWhile:[self allFontsDo:[:font| | names |			names := AllFontsAndFiles at: font familyName 					ifAbsentPut:[OrderedCollection new].			names add: font fileName]]].	^AllFontsAndFiles ! !!TTFileDescription methodsFor: 'glyphs' stamp: 'nice 12/27/2009 03:12'!readCmapTableAt: codePoint fromFile: fontFile	| cmapFmt length firstCode entryCount segCount segIndex startCode idDelta idRangeOffset offset |	fontFile position: cmapOffset.	cmapFmt := fontFile nextNumber: 2.	length := fontFile nextNumber: 2.	fontFile skip: 2. "skip version"	cmapFmt = 0 ifTrue:["byte encoded table"		codePoint > 255 ifTrue:[^0].		length := length - 6. 		"should be always 256"		length <= 0 ifTrue: [^0].	"but sometimes, this table is empty"		fontFile skip: codePoint.		"move to correct byte offset in table"		^fontFile next].	cmapFmt = 4 ifTrue:[ "segment mapping to deltavalues"		codePoint > 16rFFFF ifTrue:[^0].		segCount := (fontFile nextNumber: 2) // 2.		fontFile skip: 6. "skip searchRange, entrySelector, rangeShift"		segIndex := (0 to: segCount-1) 			detect:[:i| | endCode | (endCode := (fontFile nextNumber: 2)) >= codePoint].		fontFile position: cmapOffset + 16 + (segCount*2) + (segIndex*2).		startCode := fontFile nextNumber: 2.		startCode <= codePoint ifFalse:[^0]. "not in segment range"		fontFile position: cmapOffset + 16 + (segCount*4) + (segIndex*2).		idDelta := fontFile nextNumber: 2.		fontFile position: cmapOffset + 16 + (segCount*6) + (segIndex*2).		idRangeOffset := fontFile nextNumber: 2.		idRangeOffset = 0 ifTrue:[^(idDelta + codePoint) bitAnd: 16rFFFF].		offset := (fontFile position - 2) + idRangeOffset + ((codePoint - startCode) * 2).		fontFile position: offset.		^fontFile nextNumber: 2.	].	cmapFmt = 6 ifTrue:[ "trimmed table"		firstCode := fontFile nextNumber: 2.		entryCount := fontFile nextNumber: 2.		(codePoint between: firstCode and: firstCode+entryCount) ifFalse:[^0].		fontFile skip: (codePoint-firstCode) * 2.		^fontFile nextNumber: 2].	^0! !!TTCompositeGlyph methodsFor: 'initialize' stamp: 'nice 12/27/2009 03:10'!referenceVertexAt: index	"Only used while reading before constructing contours"	| i |	i := index.	self glyphsAndTransformationsDo: [:glyph :transform | | p |		p := glyph referenceVertexAt: i.		p isPoint			ifTrue: [^transform localPointToGlobal: p].		i := i - p].	self error: ['this should not happen']! !!TTGlyph methodsFor: 'private-initialization' stamp: 'nice 12/27/2009 03:10'!buildContours	"Build the contours in the receiver glyph.	The contour is constructed by converting the points	form each contour into an absolute value and then	compressing the contours into PointArrays."	| tx ty |	tx := ty := 0.	contours := contours collect:[:contour| | points |		contour isCollection ifTrue:[^self]. "already built"		points := contour points.		points do:[:pt|			pt x: (tx := tx + pt x).			pt y: (ty := ty + pt y)].		contour asCompressedPoints].! !