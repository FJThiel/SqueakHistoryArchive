"Change Set:		8019Compiler-nice.91Compiler-nice.91:forgot one #asArray sortCompiler-nice.90:Use #keys rather than #fasterKeysNote that pattern (x keys asArray sort) could as well be written (x keys sort) now that keys returns an Array...This #asArray is here solely for cross-dialect/fork compatibility."!!BytecodeEncoder methodsFor: 'results' stamp: 'nice 10/21/2009 00:02'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occurr	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with teh schematicTempNamesString."	blockExtentsToLocals ifNil:		[self error: 'blockExtentsToLocals uninitialized.  method not yet generated?'].	^String streamContents:		[:aStream|		self printSchematicTempNamesOn: aStream			blockExtents: (blockExtentsToLocals keys asArray sort:							[:range1 :range2|							range1 first <= range2 first])			fromIndex: 1]! !!Decompiler methodsFor: 'initialize-release' stamp: 'nice 10/21/2009 00:29'!mapFromBlockStartsIn: aMethod toTempVarsFrom: schematicTempNamesString constructor: aDecompilerConstructor	| map |	map := aMethod				mapFromBlockKeys: aMethod startpcsToBlockExtents keys asArray sort				toSchematicTemps: schematicTempNamesString.	map keysAndValuesDo:		[:startpc :tempNameTupleVector|		tempNameTupleVector isEmpty ifFalse:			[| subMap numTemps tempVector |			subMap := Dictionary new.			"Find how many temp slots there are (direct & indirect temp vectors)			 and for each indirect temp vector find how big it is."			tempNameTupleVector do:				[:tuple|				tuple last isArray					ifTrue:						[subMap at: tuple last first put: tuple last last.						 numTemps := tuple last first]					ifFalse:						[numTemps := tuple last]].			"create the temp vector for this scope level."			tempVector := Array new: numTemps.			"fill it in with any indirect temp vectors"			subMap keysAndValuesDo:				[:index :size|				tempVector at: index put: (Array new: size)].			"fill it in with temp nodes."			tempNameTupleVector do:				[:tuple| | itv |				tuple last isArray					ifTrue:						[itv := tempVector at: tuple last first.						 itv at: tuple last last							put: (aDecompilerConstructor									codeTemp: tuple last last - 1									named: tuple first)]					ifFalse:						[tempVector							at: tuple last							put: (aDecompilerConstructor									codeTemp: tuple last - 1									named: tuple first)]].			"replace any indirect temp vectors with proper RemoteTempVectorNodes"			subMap keysAndValuesDo:				[:index :size|				tempVector					at: index					put: (aDecompilerConstructor							codeRemoteTemp: index							remoteTemps: (tempVector at: index))].			"and update the entry in the map"			map at: startpc put: tempVector]].	^map! !