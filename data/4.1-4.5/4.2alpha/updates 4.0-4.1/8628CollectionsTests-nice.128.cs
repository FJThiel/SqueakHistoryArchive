"Change Set:		8628CollectionsTests-nice.128CollectionsTests-nice.128:Cosmetic: move or remove a few temps inside closures"!!IntegerArrayTest methodsFor: 'tests' stamp: 'nice 12/27/2009 20:52'!testStoreNegativeOutOfRange	"A value too small for a 32-bit signed integer should raise an error."	| ia val |	ia := IntegerArray new: 1.	val := (2 raisedTo: 31) negated - 1. " -16r80000001 of range for 32-bit twos complement integer"	self should: [ | storedValue |				ia at: 1 put: val. "should raise error here"				storedValue := ia at: 1. "lack of range check leads to value of 16r7FFFFFFF"				self assert: val = storedValue "fail here"]		raise: Error! !!IntegerArrayTest methodsFor: 'tests' stamp: 'nice 12/27/2009 20:52'!testStorePositiveOutOfRange	"A value too large for a 32-bit signed integer should raise an error."	| ia val |	ia := IntegerArray new: 1.	val := 2 raisedTo: 31. "16r80000000 is out of range for 32-bit twos complement"	self should: [ | storedValue |				ia at: 1 put: val. "should raise error here"				storedValue := ia at: 1. "lack of range check leads to value of 16r-80000000"				self assert: val = storedValue "fail here"]		raise: Error! !!HeapTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!test1	| data |	"The first element of each array is the sort value, and the second will be updated by the heap with the index of the element within the heap."	data :=  (1 to: 8) collect: [:i | {i*2. 0}].	"Repeat with different data ordering."	5 timesRepeat: [ | h |		h := Heap new sortBlock: [:e1 :e2 | e1 first < e2 first].		h indexUpdateBlock: [:array :index | array at: 2 put: index].		data shuffled do: [:d | h add: d].		data do: [:d | self should: (h at: d second) == d].	]! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testAsStringOnDelimiter	| delim |	delim := ', '.	{OrderedCollection new. Set new.} do:		[ :coll | | oneItemStream emptyStream multiItemStream |		emptyStream := ReadWriteStream on: ''.		coll asStringOn: emptyStream delimiter: delim.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll asStringOn: oneItemStream delimiter: delim.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll asStringOn: multiItemStream delimiter: ', '.		self assert: multiItemStream contents = '1, 2, 3'.]! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testPrintOnDelimiterLast	| delim last |	delim := ', '.	last := ' & '.	{OrderedCollection new. Set new.} do:		[ :coll | | emptyStream oneItemStream multiItemStream |		emptyStream := ReadWriteStream on: ''.		coll printOn: emptyStream delimiter: delim last: last.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll printOn: oneItemStream delimiter: delim last: last.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll printOn: multiItemStream delimiter: ', ' last: last.		self assert: multiItemStream contents = '1'', ''2'' & ''3'.]! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testAsStringOnDelimiterLast	| delim last |	delim := ', '.	last := ' & '.	{OrderedCollection new. Set new.} do:		[ :coll | | multiItemStream emptyStream oneItemStream |		emptyStream := ReadWriteStream on: ''.		coll asStringOn: emptyStream delimiter: delim last: last.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll asStringOn: oneItemStream delimiter: delim last: last.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll asStringOn: multiItemStream delimiter: ', ' last: last.		self assert: multiItemStream contents = '1, 2 & 3'.]! !!CollectionTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testPrintOnDelimiter	| delim |	delim := ', '.	{OrderedCollection new. Set new.} do:		[ :coll | | emptyStream oneItemStream multiItemStream |		emptyStream := ReadWriteStream on: ''.		coll printOn: emptyStream delimiter: delim.		self assert: emptyStream contents = ''.		coll add: 1.		oneItemStream := ReadWriteStream on: ''.		coll printOn: oneItemStream delimiter: delim.		self assert: oneItemStream contents = '1'.		coll add: 2; add: 3.		multiItemStream := ReadWriteStream on: ''.		coll printOn: multiItemStream delimiter: ', '.		self assert: multiItemStream contents = '1'', ''2'', ''3'.]! !