"Change Set:		7809Kernel-nice.250Kernel-nice.250:Fix nan comparison from http://bugs.squeak.org/view.php?id=6719Note: the fix does use adpatToXXX:andSend:instead of proposed adpatToXXX:andCompare:This way, it is independant of  http://bugs.squeak.org/view.php?id=3374(I don't want to fight now with lengthy argumentation)Kernel-nice.245:Part of fix for http://bugs.squeak.org/view.php?id=6797Implement #literalEqual: in ScaledDecimal so as to be able to differentiate 0.5s1 and 0.50s2.Kernel-nice.246:Another #removeAll for hackers.Don't know if anyone would use this (unless attacking some squeak services).Kernel-nice.247:Fix for #printShowingDecimalPlaces: The fix comes from http://bugs.squeak.org/view.php?id=5640 with an additional test for printing exceptional values (Inf/NaN).The implementation relies on exact arithmetic (Fraction/LargeInteger) and thus avoid inexact Float rounding operations.Kernel-nice.248:Fix for http://bugs.squeak.org/view.php?id=6695Float storeStringBase: does not store the radixSince Integer and Fraction do store the radix, no reason to differ...Kernel-ar.249:Put the delay guard back which prevented scheduling the same delay multiple times. It got accidentally removed in a recent cleanup."!!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:36'!<= operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction <= operand asFraction].	^ operand adaptToScaledDecimal: self andSend: #<=! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 8/28/2008 19:18'!literalEqual: other	"Testing equality is not enough.	It is also necessary to test number of decimal places (scale).	Otherwise we cannot compile both literals 0.5s1 and 0.50s2 in the same method"		^(super literalEqual: other) and: [self scale = other scale]! !!Integer methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:35'!>= aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) <= 0]						ifFalse: [^(self digitCompare: aNumber) >= 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andSend: #>=! !!Float methodsFor: 'printing' stamp: 'nice 9/25/2007 01:44'!storeOn: aStream base: base	"Defined here to handle special cases of NaN Infinity and negative zero"		| abs |	self isNaN ifTrue: [aStream nextPutAll: 'NaN'. ^ self]. "check for NaN before sign"	abs := self sign = -1 "Test sign rather than > 0 for special case of negative zero"		ifTrue:			[aStream nextPutAll: '-'.			self negated]		 ifFalse: [self].	abs isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	aStream print: base; nextPut: $r.	self = 0.0		ifTrue: [aStream nextPutAll: '0.0'. ^ self]		ifFalse: [abs absPrintOn: aStream base: base]! !!Fraction methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:35'!>= aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator >= (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #>=! !!MethodDictionary methodsFor: 'removing' stamp: 'nice 1/10/2009 00:34'!removeAll	"This provides a faster way than repeated become.	a single become is still in use to prevent system crash."		| newSelf |	tally = 0 ifTrue: [^self].	newSelf := self species new: self size.  "This will preserve the capacity"	self become: newSelf! !!Delay methodsFor: 'private' stamp: 'ar 9/21/2009 22:19'!schedule	"Schedule this delay"	beingWaitedOn ifTrue: [^self error: 'This Delay has already been scheduled.'].	resumptionTime := Time millisecondClockValue + delayDuration.	AccessProtect critical:[		ScheduledDelay := self.		TimingSemaphore signal.	].! !!Number methodsFor: 'printing' stamp: 'nice 4/24/2008 00:38'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point."	| rounder rounded frac sign integerString fractionString result |	placesDesired <= 0 ifTrue: [^ self rounded printString].	rounder := 10 raisedToInteger: placesDesired.	rounded := self roundTo: rounder reciprocal.	sign := rounded negative ifTrue: ['-'] ifFalse: [''].	integerString := rounded abs integerPart truncated printString.	frac := ((rounded abs fractionPart) * rounder) truncated.	fractionString := frac printString padded: #left to: placesDesired with: $0.	result := sign , integerString , '.' , fractionString.	^result"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 5-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2"! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:36'!> operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction > operand asFraction].	^ operand adaptToScaledDecimal: self andSend: #>! !!Magnitude methodsFor: 'comparing' stamp: 'nice 12/31/2008 04:06'!>= aMagnitude 	"Answer whether the receiver is greater than or equal to the argument."	^aMagnitude <= self! !!Integer methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:35'!<= aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) >= 0]						ifFalse: [^ (self digitCompare: aNumber) <= 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andSend: #<=! !!Fraction methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:34'!<= aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator <= (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #<=! !!ScaledDecimal methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:36'!>= operand 	"Implementation of Number 'comparing' method."	(operand isKindOf: ScaledDecimal) ifTrue: [^ fraction >= operand asFraction].	^ operand adaptToScaledDecimal: self andSend: #>=! !!Fraction methodsFor: 'comparing' stamp: 'nice 1/4/2009 17:35'!> aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator > (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #>! !!Float methodsFor: 'printing' stamp: 'nice 9/19/2009 20:17'!printShowingDecimalPlaces: placesDesired	"This implementation avoids any rounding error caused by rounded or roundTo:"		self isFinite ifFalse: [^self printString].	^self asTrueFraction printShowingDecimalPlaces: placesDesired! !