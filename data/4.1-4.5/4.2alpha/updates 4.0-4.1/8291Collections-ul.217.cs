"Change Set:		8291Collections-ul.217Collections-ul.217:Replace sends of #scanForEmptySlotFor: with #scanFor:. This enables atomic changes of the hash implementation.Collections-dtl.214:Use 'Project current' idiom in TestSqkProjectLink>>actOnClickFor:Move SharedQueue2>>removeAll and SharedQueue2>>removeAllSuchThat: from category '*39Deprecated' back to 'accessing'. These had been put in the 39Deprecated package, but have never been marked deprecated (and should not be).Collections-ul.215:- added CollectionRehashingUtility- updated Set >> #do:, WeakSet >> #do: and Dictionary >> #associationsDo: to allow iteration while being rehashedCollections-ul.216:Ensure prime capacity for all HashedCollections but MethodDictionaries."!Object subclass: #CollectionRehashingUtility	instanceVariableNames: 'changes'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!SharedQueue2 methodsFor: 'accessing' stamp: 'ls 6/25/2005 14:01'!removeAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."	monitor critical: [		items removeAllSuchThat: aBlock ]! !!Set methodsFor: 'private' stamp: 'ul 11/30/2009 04:45'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		| object |		(object := anArray at: index) ifNotNil: [			array				at: (self scanFor: object)				put: object ] ]! !!CollectionRehashingUtility methodsFor: 'rehashing' stamp: 'SqR 10/25/2009 00:39'!quickRehashBecause: aSymbol	(self changes includes: aSymbol) ifTrue: [^self].	self changes add: aSymbol.	self quickRehashAllSets! !!WeakSet methodsFor: 'private' stamp: 'ul 11/30/2009 04:45'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		| object |		((object := anArray at: index) == flag or: [			object == nil ]) ifFalse: [ 				array					at: (self scanFor: object)					put: object.				tally := tally + 1 ] ]! !!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 11/30/2009 04:45'!finalizeValues: finiObjects	"Remove all associations with key == nil and value is in finiObjects.	This method is folded with #rehash for efficiency."		| oldArray |	oldArray := array.	array := Array new: oldArray size.	tally := 0.	1 to: array size do:[ :i |		| association |		(association := oldArray at: i) ifNotNil: [			| key |			((key := association key) == nil and: [ "Don't let the key go away"				finiObjects includes: association value ])					ifFalse: [						array 							at: (self scanFor: key) 							put: association.						tally := tally + 1 ] ] ]! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ls 6/25/2005 14:03'!removeAll	monitor critical: [		items next: (items size) ].! !!CollectionRehashingUtility class methodsFor: 'rehashing' stamp: 'SqR 10/25/2009 00:16'!quickRehashBecause: aSymbol	self new quickRehashBecause: aSymbol! !!Dictionary methodsFor: 'private' stamp: 'ul 11/30/2009 04:45'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		| object |		(object := anArray at: index) ifNotNil: [			array				at: (self scanFor: object key)				put: object ] ]! !!CollectionRehashingUtility class methodsFor: 'private - accessing' stamp: 'SqR 10/24/2009 23:15'!current: anInstance	current := anInstance! !!CollectionRehashingUtility methodsFor: 'rehashing' stamp: 'SqR 10/25/2009 00:39'!rehashBecause: aSymbol	(self changes includes: aSymbol) ifTrue: [^self].	self changes add: aSymbol.	self rehashAllSets.	self rehashSymbolTable! !!CollectionRehashingUtility methodsFor: 'private - rehashing' stamp: 'ul 11/30/2009 03:58'!rehashAllSets	HashedCollection rehashAll! !!TextSqkProjectLink methodsFor: 'as yet unclassified' stamp: 'dtl 11/27/2009 14:18'!actOnClickFor: textMorph	Project current enterIfThereOrFind: url.	^ true! !!CollectionRehashingUtility methodsFor: 'private - rehashing' stamp: 'ul 11/30/2009 03:58'!quickRehashAllSets	HashedCollection withAllSubclassesDo:		[:class |			class = MethodDictionary ifFalse:				[class allInstances do: [:each | each rehash]]		]! !!CollectionRehashingUtility methodsFor: 'private - rehashing' stamp: 'SqR 10/25/2009 00:38'!rehashSymbolTable	Symbol rehash! !!CollectionRehashingUtility methodsFor: 'private' stamp: 'SqR 10/24/2009 23:16'!initialize	self changes: OrderedCollection new! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 11/30/2009 04:45'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do:[ :i |		| association |		(association := anArray at: i) ifNotNil: [			array				at: (self scanFor: association key)				put: association.			tally := tally + 1 ] ]! !!WeakKeyToCollectionDictionary methodsFor: 'as yet unclassified' stamp: 'ul 11/30/2009 04:45'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and associations with empty collections (or with only nils) to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do:[ :i |		| association cleanedValue |		((association := anArray at: i) == nil or: [ 			(cleanedValue := association value copyWithout: nil) isEmpty ]) 				ifFalse: [					association value: cleanedValue.					array						at: (self scanFor: association key)						put: association.					tally := tally + 1 ] ]! !!KeyedSet methodsFor: 'private' stamp: 'ul 11/30/2009 04:45'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		| object |		(object := anArray at: index) ifNotNil: [			array				at: (self scanFor: (keyBlock value: object))				put: object ] ]! !!Dictionary methodsFor: 'enumerating' stamp: 'ul 11/30/2009 04:20'!associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's elements (key/value 	associations)."	tally = 0 ifTrue: [ ^self].	array do: [ :each | each ifNotNil: [ aBlock value: each ] ]! !!Set methodsFor: 'enumerating' stamp: 'ul 11/30/2009 04:17'!do: aBlock 	tally = 0 ifTrue: [ ^self ].	array do: [ :each | each ifNotNil: [ aBlock value: each ] ]! !!CollectionRehashingUtility methodsFor: 'private - accessing' stamp: 'SqR 10/24/2009 23:16'!changes	^changes! !!CollectionRehashingUtility class methodsFor: 'rehashing' stamp: 'SqR 10/24/2009 23:26'!rehashBecause: aSymbol	self new rehashBecause: aSymbol! !!WeakSet methodsFor: 'public' stamp: 'ul 11/30/2009 04:18'!do: aBlock	tally = 0 ifTrue: [^self].	array do: [ :each |		(each == nil or: [each == flag])			ifFalse: [ aBlock value: each ] ]! !!CollectionRehashingUtility class methodsFor: 'instance creation' stamp: 'SqR 10/24/2009 23:15'!new	self current notNil ifTrue: [^self current].	self current: super new initialize.	^self current! !!CollectionRehashingUtility methodsFor: 'private - accessing' stamp: 'SqR 10/24/2009 23:24'!changes: aCollection	"aCollection must not be a hashed collection"	changes := aCollection! !!CollectionRehashingUtility class methodsFor: 'private - accessing' stamp: 'SqR 10/24/2009 23:14'!current	^current! !