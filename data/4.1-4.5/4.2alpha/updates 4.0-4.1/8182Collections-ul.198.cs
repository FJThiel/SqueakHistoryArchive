"Change Set:		8182Collections-ul.198Collections-ul.198:Introduced a new abstract collection class: HashedCollection.- Moved methods common with Dictionary from Set to HashedCollection.- Set is now a subclass of HashedCollection.- Added necessary stub methods to HashedCollection with #subclassResponsibility sends.- Deprecated Set >> #rehashAllSets, replaced it with HashedCollection rehashAll.- Moved deprecation of #someElement from comment to code.Collections-nice.193:Handle more crlf casesCollections-nice.194:Avoid an off end line indexAdd cr/lf/crlf support for one more message (with speed up versus simple cr version...)Collections-nice.195:Correct my own #withNoLineLongerThan: error and make the test passCollections-nice.196:Correct bug reported on beginners list'aa aa éé aa aa' encodeForHTTP Collections-nice.197:revert PositionnableStream>>nextLine which is broken for some subclass - until a better fix"!Collection subclass: #HashedCollection	instanceVariableNames: 'tally array'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Abstract'!HashedCollection subclass: #Set	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Unordered'!!HashedCollection methodsFor: 'accessing' stamp: 'ul 11/19/2009 00:51'!size	^ tally! !!HashedCollection methodsFor: 'objects from disk' stamp: 'ul 11/19/2009 00:54'!comeFullyUpOnReload: smartRefStream	"Symbols have new hashes in this image."	self rehash.	"^ self"! !!String methodsFor: 'converting' stamp: 'nice 11/17/2009 11:13'!encodeForHTTPWithTextEncoding: encodingName conditionBlock: conditionBlock	"change dangerous characters to their %XX form, for use in HTTP transactions"	| httpSafeStream encodedStream cont |	httpSafeStream := WriteStream on: (String new).	encodedStream := MultiByteBinaryOrTextStream on: (String new: 6).	encodedStream converter: (TextConverter newForEncoding: encodingName).	self do: [:c |		(conditionBlock value: c)			ifTrue: [httpSafeStream nextPut: (Character value: c charCode)]			ifFalse: [				encodedStream text; resetToStart.				encodedStream nextPut: c.				encodedStream position: 0.				encodedStream binary.				cont := encodedStream contents.				cont do: [:byte |					httpSafeStream nextPut: $%.					httpSafeStream nextPut: (byte // 16) asHexDigit.					httpSafeStream nextPut: (byte \\ 16) asHexDigit.				].			].	].	^ httpSafeStream contents.! !!HashedCollection methodsFor: 'copying' stamp: 'ul 11/19/2009 00:52'!copyEmpty	"Answer an empty copy of this collection"		"Note: this code could be moved to super"		^self species new! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:06'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	self subclassResponsibility! !!HashedCollection class methodsFor: 'instance creation' stamp: 'ul 11/19/2009 01:07'!new	^ self basicNew initialize: 5! !!HashedCollection methodsFor: 'accessing' stamp: 'ul 11/19/2009 00:50'!someElement	self deprecated: 'Use #anyOne'.	^self anyOne! !!HashedCollection methodsFor: 'accessing' stamp: 'ul 11/19/2009 00:47'!atRandom: aGenerator	"Answer a random element of the receiver. Uses aGenerator which    should be kept by the user in a variable and used every time. Use    this instead of #atRandom for better uniformity of random numbers because 	only you use the generator. Causes an error if self has no elements."	| rand |	self emptyCheck.	rand := aGenerator nextInt: self size.	self doWithIndex:[:each :ind |		ind = rand ifTrue:[^each]].	^ self errorEmptyCollection! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:01'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."		self subclassResponsibility! !!HashedCollection methodsFor: 'enumerating' stamp: 'ul 11/19/2009 00:54'!union: aCollection	"Answer the set theoretic union of the receiver and aCollection, using the receiver's notion of equality and not side effecting the receiver at all."	^ self copy addAll: aCollection; yourself! !!Set class methodsFor: 'initialization' stamp: 'ul 11/19/2009 01:15'!quickRehashAllSets		self deprecated: 'Use HashedCollection >> #rehashAll'.		HashedCollection rehashAll! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:00'!growTo: anInteger	"Grow the elements array and reinsert the old elements"		| oldElements |	oldElements := array.	array := Array new: anInteger.	self noCheckNoGrowFillFrom: oldElements! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:01'!initialize: n	"Initialize array to an array size of n"	array := Array new: n.	tally := 0! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 00:59'!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."		self subclassResponsibility! !!HashedCollection methodsFor: 'enumerating' stamp: 'ul 11/19/2009 00:53'!doWithIndex: aBlock2	"Support Set enumeration with a counter, even though not ordered"	| index |	index := 0.	self do: [:item | aBlock2 value: item value: (index := index+1)]! !!String methodsFor: 'internet' stamp: 'nice 11/16/2009 15:51'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all 	valid line endings.  Replace each occurence with a single CR"	| cr lf crlf inPos outPos outString lineEndPos newOutPos |	cr := Character cr.	lf := Character linefeed.	crlf := CharacterSet crlf.	inPos := 1.	outPos := 1.	outString := String new: self size.	[ lineEndPos := self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].		lineEndPos ~= 0 ] whileTrue: [			newOutPos := outPos + (lineEndPos - inPos + 1).			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos-1 put: cr.			outPos := newOutPos.			((self at: lineEndPos) = cr and: [ lineEndPos < self size and: [ (self at: lineEndPos+1) = lf ] ]) ifTrue: [				"CRLF ending"				inPos := lineEndPos + 2 ]			ifFalse: [ 				"CR or LF ending"				inPos := lineEndPos + 1 ]. ].	"no more line endings.  copy the rest"	newOutPos := outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos-1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos-1	! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:05'!rehash		self growTo: array size! !!HashedCollection class methodsFor: 'instance creation' stamp: 'ul 11/19/2009 01:07'!new: nElements	"Create a Set large enough to hold nElements without growing"	^ self basicNew initialize: (self sizeFor: nElements)! !!String methodsFor: 'internet' stamp: 'nice 11/16/2009 17:30'!withInternetLineEndings	"change line endings from CR's to CRLF's.  This is probably in prepration for sending a string over the Internet"	^self class		new: self size * 16 // 15 "provisions for CR-LF pairs"		streamContents: [ :stream |			self lineIndicesDo: [:start :endWithoutDelimiters :end |				stream nextPutAll: (self copyFrom: start to: endWithoutDelimiters).				endWithoutDelimiters = end ifFalse: [	stream cr; lf] ] ]! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:00'!growSize	^ array size max: 2! !!HashedCollection methodsFor: 'enumerating' stamp: 'ul 11/19/2009 00:53'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: array size do:		[:index |		| each |		(each := array at: index) ifNotNil: [aBlock value: each]]! !!Set class methodsFor: 'initialization' stamp: 'ul 11/19/2009 01:15'!rehashAllSets		self deprecated: 'Use HashedCollection >> #rehashAll'.		HashedCollection rehashAll! !!String methodsFor: 'accessing' stamp: 'nice 11/16/2009 20:09'!lineIndicesDo: aBlock	"execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"		| start end endWithoutDelimiters |	start := 1.	[ start <= self size ] whileTrue: [		end := self indexOfAnyOf: CSLineEnders startingAt: start ifAbsent: [ 0 ].		end = 0			ifTrue: [endWithoutDelimiters := end := self size]			ifFalse: [endWithoutDelimiters := end - 1.				(end < self size					and: [(self at: end + 1) = Character lf					and: [(self at: end)	= Character cr]])				ifTrue: [end := end + 1]].		aBlock value: start value: endWithoutDelimiters value: end.		start := end + 1]! !!HashedCollection methodsFor: 'adding' stamp: 'ul 11/19/2009 00:52'!add: newObject withOccurrences: anInteger	^ self add: newObject! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 00:58'!array	^ array! !!HashedCollection class methodsFor: 'instance creation' stamp: 'ul 11/19/2009 01:09'!sizeFor: nElements	"Large enough size to hold nElements with some slop (see fullCheck)"	nElements <= 0 ifTrue: [^ 1].	^ nElements+1*4//3! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 00:59'!findElementOrNil: anObject	"Answer the index of a first slot containing either a nil (indicating an empty slot) or an element that matches the given object. Answer the index of that slot or zero. Fail if neither a match nor an empty slot is found."	| index |	self deprecated: 'Use #scanFor:.'.	index := self scanFor: anObject.	index > 0 ifTrue: [^index].	"Bad scene.  Neither have we found a matching element	nor even an empty slot.  No hashed set is ever supposed to get	completely full."	self error: 'There is no free space in this set!!'.! !!HashedCollection class methodsFor: 'initialization' stamp: 'ul 11/19/2009 01:10'!rehashAll	"HashedCollection rehashAll"				self allSubclassesDo: [ :each | each rehashAllInstances ]! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:00'!fullCheck	"Keep array at least 1/4 free for decent hash behavior"	array size - tally < (array size // 4 max: 1)		ifTrue: [self grow]! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:00'!grow	"Grow the elements array and reinsert the old elements"		self growTo: array size + self growSize! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 00:58'!errorNoFreeSpace	self error: 'There is no free space in this collection!!'! !!String methodsFor: 'converting' stamp: 'nice 11/16/2009 17:19'!withBlanksTrimmed	"Return a copy of the receiver from which leading and trailing blanks have been trimmed."	| first last |	first := self indexOfAnyOf: CSNonSeparators startingAt: 1 ifAbsent: [0].	first = 0 ifTrue: [ ^'' ].  "no non-separator character"	last := self lastIndexOfAnyOf: CSNonSeparators startingAt: self size ifAbsent: [self size].	(first = 1 and: [ last = self size ]) ifTrue: [ ^self copy ].	^self		copyFrom: first		to: last! !!String methodsFor: 'converting' stamp: 'nice 11/16/2009 21:37'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end | | lineStart |				lineStart := self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [endWithoutDelimiters + 1].				[| lineEnd spacePosition |				lineEnd := 0.				spacePosition := lineStart.				[spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [lineStart + aNumber + 1].				spacePosition - lineStart <= (aNumber min: endWithoutDelimiters - lineStart)]						whileTrue: [lineEnd := spacePosition].				lineEnd = 0					ifTrue: ["no space - split arbitrarily"						lineEnd := lineStart + aNumber - 1 min: endWithoutDelimiters.						stream nextPutAll: (self copyFrom: lineStart to: lineEnd).						lineStart := lineEnd + 1]					ifFalse: ["split before space"						stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).						"eliminate conscutive spaces at split"						lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd + 1 ifAbsent: [endWithoutDelimiters + 1] ].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: endWithoutDelimiters + 1 to: end) ] ]! !!HashedCollection methodsFor: 'accessing' stamp: 'ul 11/19/2009 00:47'!capacity	"Answer the current capacity of the receiver."	^ array size! !!HashedCollection methodsFor: 'copying' stamp: 'ul 11/19/2009 00:52'!postCopy	super postCopy.	array := array copy! !!HashedCollection methodsFor: 'testing' stamp: 'ul 11/19/2009 00:58'!occurrencesOf: anObject 	^ (self includes: anObject) ifTrue: [1] ifFalse: [0]! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 01:05'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := anObject hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!HashedCollection methodsFor: 'private' stamp: 'ul 11/19/2009 00:58'!atNewIndex: index put: anObject	array at: index put: anObject.	tally := tally + 1.	self fullCheck! !!HashedCollection class methodsFor: 'initialization' stamp: 'ul 11/19/2009 01:09'!rehashAllInstances	"Do not use #allInstancesDo: because rehash may create new instances."	self allInstances do: [ :each | each rehash ] ! !!HashedCollection methodsFor: 'accessing' stamp: 'ul 11/19/2009 00:47'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	^array at: (self scanFor: anObject)! !!HashedCollection methodsFor: 'removing' stamp: 'ul 11/19/2009 00:57'!removeAll	"remove all elements from this collection.	Preserve the capacity"		self initialize: self capacity! !Set removeSelector: #fullCheck!Set removeSelector: #grow!Set removeSelector: #errorNoFreeSpace!Set removeSelector: #capacity!Set removeSelector: #postCopy!Set removeSelector: #doWithIndex:!Set removeSelector: #occurrencesOf:!Set removeSelector: #rehash!Set removeSelector: #scanForEmptySlotFor:!Set removeSelector: #atNewIndex:put:!Set removeSelector: #like:!Set removeSelector: #removeAll!Set removeSelector: #size!Set removeSelector: #comeFullyUpOnReload:!Set removeSelector: #copyEmpty!Set class removeSelector: #new!Set removeSelector: #someElement!Set removeSelector: #atRandom:!Set removeSelector: #union:!Set removeSelector: #growTo:!Set removeSelector: #initialize:!Set class removeSelector: #new:!Set removeSelector: #growSize!Set removeSelector: #do:!Set class removeSelector: #rehashAllInstances!Set removeSelector: #add:withOccurrences:!Set removeSelector: #array!Set class removeSelector: #sizeFor:!Set removeSelector: #findElementOrNil:!