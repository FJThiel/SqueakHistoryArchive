"Change Set:		7370Network-ar.33Network-ar.33:Underscore removal."!!ServerDirectory methodsFor: 'file directory' stamp: 'hg 2/8/2002 17:44'!directoryNamed: localFileName 	"Return a copy of me pointing at this directory below me"	| new newPath newAltUrl |	new := self copy.	urlObject		ifNotNil: [new urlObject path: new urlObject path copy.			new urlObject path removeLast; addLast: localFileName; addLast: ''.			^ new].	"sbw.  When working from an FTP server, the first time we access	a subdirectory the <directory> variable is empty.  In that case we	cannot begin with a leading path delimiter since that leads us to	the wrong place."	newPath := directory isEmpty				ifTrue: [localFileName]				ifFalse: [directory , self pathNameDelimiter asString , localFileName].	self altUrl ifNotNil: [		newAltUrl := self altUrl, self pathNameDelimiter asString , localFileName].	new directory: newPath; altUrl: newAltUrl.	^ new! !!GenericUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:46'!schemeName: schemeName0  locator: locator0	schemeName := schemeName0.	locator := locator0.! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextAtom	| start end |	start := pos.	pos := text indexOfAnyOf: CSNonAtom startingAt: start ifAbsent: [ text size + 1].	end := pos - 1.	^MailAddressToken		type: #Atom		text: (text copyFrom: start to: end)! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 12/8/2003 14:17'!rename: fullName toBe: newName	"Rename a remote file.  fullName is just be a fileName, or can be directory path that includes name of the server.  newName is just a fileName"	| file |	file := self asServerFileNamed: fullName.	file isTypeFile ifTrue: [		(FileDirectory forFileName: (file fileNameRelativeTo: self)) 			rename: file fileName toBe: newName	].		client := self openFTPClient.	[client renameFileNamed: fullName to: newName]		ensure: [self quit].	! !!HierarchicalURI methodsFor: 'accessing' stamp: 'mir 11/30/2003 23:59'!baseName	"returns the last component stripped of its extension"	| baseName i |	baseName := self pathComponents last.	i := baseName findLast: [:c | c = $.].	^i = 0		ifTrue: [baseName]		ifFalse: [baseName copyFrom: 1 to: i-1].! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 11/24/1998 14:45'!fileName: aStringurlObject ~~ nil  "type == #file" 	ifTrue: [urlObject path at: urlObject path size put: aString]	ifFalse: [fileName := aString]! !!FtpUrl methodsFor: 'downloading' stamp: 'mir 6/27/2003 19:42'!retrieveContents	"currently assumes directories end in /, and things that don't end in / are files.  Also, doesn't handle errors real well...."	| server contents pathString listing auth idx fileName serverName userName password |	pathString := self pathString.	pathString := pathString copyFrom: 2 to: pathString size. "remove the leading /"	pathString last = $/ ifTrue:["directory?!!"		fileName := nil.	] ifFalse:[		fileName := pathString copyFrom: (pathString lastIndexOf: $/)+1 to: pathString size.		pathString := pathString copyFrom: 1 to: (pathString lastIndexOf: $/) - 1.	].	auth := self authority.	idx := auth indexOf: $@.	idx > 0 ifTrue:[		serverName := (auth copyFrom: idx+1 to: auth size).		userName := (auth copyFrom: 1 to: idx-1).		password := nil.	] ifFalse:[		serverName := auth.		userName := 'anonymous'.		password := 'SqueakUser'.	].	server := ServerDirectory servers 		detect:[:s| s isTypeFTP and:[s server asLowercase = serverName asLowercase]]		ifNone:[nil].	server ifNil:[		server := ServerDirectory new.		server server: serverName.	] ifNotNil:[server := server copy reset].	server user: userName.	password ifNotNil:[server password: password].	server directory: pathString.	fileName == nil ifFalse:[		"a file"		contents := (server getFileNamed: fileName).		server sleep.		^MIMEDocument contentType: (MIMEDocument guessTypeFromName: self path last) content: contents].	"a directory?"	listing := String streamContents: [ :stream |		stream nextPutAll: '<title>', self pathString, '</title>'; cr.		stream nextPutAll: '<h1>Listing for ', self pathString, '</h1>'; cr.		stream nextPutAll: '<ul>'; cr.		server entries do: [ :entry |			stream nextPutAll: '<li>';				nextPutAll: '<a href="', entry name encodeForHTTP.			entry isDirectory ifTrue: [ stream nextPut: $/ ].			stream nextPutAll: '">';				nextPutAll: entry name;				nextPutAll: '</a>';				cr ] ].	server sleep.	^MIMEDocument contentType: 'text/html' content: listing! !!ServerDirectory class methodsFor: 'misc' stamp: 'tk 9/8/1998 11:57'!newFrom: aSimilarObject	"Must copy the urlObject, so they won't be shared"	| inst |	inst := super newFrom: aSimilarObject.	inst urlObject: aSimilarObject urlObject copy.	^ inst! !!HierarchicalURI methodsFor: 'private' stamp: 'mir 6/20/2005 18:49'!absoluteFromString: aString scheme: schemeName	| remainder |	super absoluteFromString: aString scheme: schemeName.	"We now have the interesting part in schemeSpecficPart and can parse it further"	"This check is somewhat redundant, just in case somebody calls this directly."	remainder := schemeSpecificPart.	(remainder isEmpty		or: [remainder first ~~ $/])		ifTrue: [(IllegalURIException new uriString: remainder) signal: 'Invalid absolute URI'].	(aString beginsWith: '//')		ifTrue: [remainder := self extractAuthority: (remainder copyFrom: 3 to: remainder size)].	self extractSchemeSpecificPartAndFragment: remainder! !!ConnectionQueue methodsFor: 'private' stamp: 'jm 3/10/98 11:07'!initPortNumber: anInteger queueLength: queueLength	"Private!! Initialize the receiver to listen on the given port number. Up to queueLength connections will be queued."	portNumber := anInteger.	maxQueueLength := queueLength.	connections := OrderedCollection new.	accessSema := Semaphore forMutualExclusion.	socket := nil.	process := [self listenLoop] newProcess.	process priority: Processor highIOPriority.	process resume.! !!MailMessage methodsFor: 'initialize-release' stamp: 'ls 2/10/2001 12:15'!initialize	"initialize as an empty message"	text := String cr.	fields := Dictionary new.	body := MIMEDocument contentType: 'text/plain' content: String cr! !!SocksSocket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 15:49'!connectTo: hostAddress port: port	self initializeNetwork.	self shouldUseSocks		ifFalse: [^super connectTo: hostAddress port: port].	super connectTo: socksIP port: socksPort.	self waitForConnectionUntil: Socket standardDeadline.	dstIP := hostAddress.	dstPort := port.	vers == 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!UUIDGenerator methodsFor: 'generator' stamp: 'JMM 11/21/2001 15:12'!generateRandomBitsOfLength: aNumberOfBits| target |	target := 0.	aNumberOfBits isZero ifTrue: [^target].	target := self generateOneOrZero.	(aNumberOfBits - 1)  timesRepeat:		[target := (target bitShift: 1)  bitOr: self generateOneOrZero].	^target! !!SocketStream class methodsFor: 'instance creation' stamp: 'gk 2/3/2005 20:35'!openConnectionToHost: hostIP port: portNumber	| socket |	socket := Socket new.	socket connectTo: hostIP port: portNumber.	^self on: socket! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'sd 9/30/2003 13:58'!determineLocalServerDirectory: directoryName	"This is part of a workaround for Mac file name oddities regarding relative file names.	The real fix should be in fullNameFor: but that seems to break other parts of the system."	| dirName |	dirName := directoryName.	(SmalltalkImage current platformName = 'Mac OS'		and: [directoryName beginsWith: ':'])			ifTrue: [				dirName := (FileDirectory default pathName endsWith: directoryName)					ifTrue: [FileDirectory default pathName]					ifFalse: [(FileDirectory default pathName , directoryName) replaceAll: '::' with: ':']].	^FileDirectory default directoryNamed: dirName! !!Socket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 16:25'!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!SuperSwikiServer methodsFor: 'testing' stamp: 'md 11/14/2003 17:28'!queryProjects: criteria	| result |	"SuperSwikiServer defaultSuperSwiki queryProjects: #('submittedBy: mir' )"	result := self sendToSwikiProjectServer: {		'action: findproject'.	}  , criteria.	(result beginsWith: 'OK') ifFalse: [^self inform: result printString].	^self parseQueryResult: (ReadStream on: result).! !!OldSimpleClientSocket class methodsFor: 'other examples' stamp: 'mir 5/13/2003 10:45'!timeTest	"SimpleClientSocket timeTest"	| addr s |	addr := NetNameResolver promptUserForHostAddress.	s := OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 13.  "time port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!MailMessage methodsFor: 'printing/formatting' stamp: 'dvf 6/14/2000 00:29'!asSendableText	"break lines in the given string into shorter lines"	| result start end pastHeader atAttachment width aString |	width := 72.	aString := self text.	result := WriteStream on: (String new: aString size * 50 // 49).	pastHeader := false.	atAttachment := false.	aString asString		linesDo: 			[:line | 			line isEmpty ifTrue: [pastHeader := true].			pastHeader				ifTrue: 					["(line beginsWith: '--==')						ifTrue: [atAttachment := true]."					atAttachment						ifTrue: 							["at or after an attachment line; no more 							wrapping for the rest of the message"							result nextPutAll: line.							result cr]						ifFalse: [(line beginsWith: '>')								ifTrue: 									["it's quoted text; don't wrap it"									result nextPutAll: line.									result cr]								ifFalse: 									["regular old line.  Wrap it to multiple 									lines "									start := 1.									"output one shorter line each time 									through this loop"									[start + width <= line size]										whileTrue: 											["find the end of the line"											end := start + width - 1.											[end >= start and: [(line at: end + 1) isSeparator not]]												whileTrue: [end := end - 1].											end < start ifTrue: ["a word spans the entire 												width!! "												end := start + width - 1].											"copy the line to the output"											result nextPutAll: (line copyFrom: start to: end).											result cr.											"get ready for next iteration"											start := end + 1.											(line at: start) isSeparator ifTrue: [start := start + 1]].									"write out the final part of the line"									result nextPutAll: (line copyFrom: start to: line size).									result cr]]]				ifFalse: 					[result nextPutAll: line.					result cr]].	^ result contents! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 4/10/2005 18:48'!httpShowChunk: url	"From a Swiki server, get a text chunk in the changes file.  Show its text in a window with style.  Vertical bar separates class and selector.  BE SURE TO USE ; instead of : in selectors!!"	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Socket|Comment'	 "	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Point|class|x;y;'	"	| doc text |	doc := (self httpGet: url accept: 'application/octet-stream')."	doc size = 0 ifTrue: [doc := 'The server does not seem to be responding']."	doc isString ifTrue: [text := doc] ifFalse: [text := doc nextChunkText].	(StringHolder new contents: text) openLabel: url.! !!SocksSocket methodsFor: 'socks4' stamp: 'mir 2/22/2002 15:49'!sendSocks4ConnectionRequestUserId: userId	"The client connects to the SOCKS server and sends a CONNECT request whenit wants to establish a connection to an application server. The clientincludes in the request packet the IP address and the port number of thedestination host, and userid, in the following format.	+----+----+----+----+----+----+----+----+----+----+....+----+	| VN | CD | DSTPORT |      DSTIP        | USERID       |NULL|	+----+----+----+----+----+----+----+----+----+----+....+----+	   1    1      2              4           variable       1	"	| requestString |	requestString := WriteStream on: ByteArray new.	dstIP		ifNil: [dstIP := NetNameResolver addressForName: dstName].	requestString		nextPut: 4;		nextPut: self connectCommandCode;		nextWordPut: dstPort;		nextPutAll: self dstIP;		nextPutAll: userId asByteArray;		nextPut: 0.	self sendData: requestString contents! !!MailMessage methodsFor: 'parsing' stamp: 'ajh 10/1/2001 17:10'!timeFrom: aString 	"Parse the date and time (rfc822) and answer the result as the number of seconds 	since the start of 1980."	| s t rawDelta delta plusOrMinus |	s := ReadStream on: aString.	"date part"	t := ((self readDateFrom: s) ifNil: [Date today]) asSeconds.	[s atEnd or: [s peek isAlphaNumeric]]		whileFalse: [s next].	"time part"	s atEnd ifFalse: ["read time part (interpreted as local, regardless of sender's timezone)"		(s peek isDigit) ifTrue: [t := t + (Time readFrom: s) asSeconds].		].	s skipSeparators.	"Check for a numeric time zone offset"	('+-' includes: s peek) ifTrue: 		[plusOrMinus := s next.		rawDelta := (s peek isDigit) ifTrue: [Integer readFrom: s] ifFalse: [0].		delta := (rawDelta // 100 * 60 + (rawDelta \\ 100)) * 60.		t := plusOrMinus = $+ ifTrue: [t - delta] ifFalse: [t + delta]].	"We ignore text time zone offsets like EST, GMT, etc..."	^ t - (Date newDay: 1 year: 1980) asSeconds"MailMessage new timeFrom: 'Thu, 22 Jun 2000 14:17:47 -500'""MailMessage new timeFrom: 'Thu, 22 Jun 2000 14:17:47 --500'""MailMessage new timeFrom: 'on, 04 apr 2001 14:57:32'"! !!OldSocket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore := true.	^self primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex ! !!MIMEDocument methodsFor: 'accessing' stamp: 'mdr 5/7/2001 11:47'!parts	"Return the parts of this message.  There is a far more reliable implementation of parts in MailMessage, but for now we are continuing to use this implementation"	| parseStream currLine separator msgStream messages |	self isMultipart ifFalse: [^ #()].	parseStream := ReadStream on: self content.	currLine := ''.	['--*' match: currLine]		whileFalse: [currLine := parseStream nextLine].	separator := currLine copy.	msgStream := LimitingLineStreamWrapper on: parseStream delimiter: separator.	messages := OrderedCollection new.	[parseStream atEnd]		whileFalse: 			[messages add: msgStream upToEnd.			msgStream skipThisLine].	^ messages collect: [:e | MailMessage from: e]! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'jm 9/15/97 12:06'!proxyTestingComment	"Test Kevin's SmartCache on this machine"	"	HTTPSocket useProxyServerNamed: '127.0.0.1' port: 8080.		HTTPSocket httpShowPage: 'http://www.disneyblast.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test getting to outside world from DOL"	"	HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.		HTTPSocket httpShowPage: 'http://www.apple.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test Windows Machine in our cubicle at DOL"	"	HTTPSocket useProxyServerNamed: '206.18.67.150' port: 8080.		HTTPSocket httpShowPage: 'http://kids.online.disney.com/~kevin/squeak/k:=t.morph'.		HTTPSocket stopUsingProxyServer.	"	"	HTTPSocket httpShowPage: 'kids.online.disney.com/'	"	"	HTTPSocket httpShowGif: 'kids.online.disney.com/~kevin/images/dlogo.gif'	"! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:39'!remoteFile: aServerFile	remoteFile := aServerFile.	localDataValid := false.	"need to read from the server"! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:28'!socks5RequestReply	| response |	response := self waitForReply: 4 for: self defaultTimeOutDuration.	"Skip rest for now."	(response at: 4) = self hostIPCode		ifTrue: [self waitForReply: 6 for: self defaultTimeOutDuration].	(response at: 4) = self qualifiedHostNameCode		ifTrue: [self skipQualifiedHostName].	(response at: 4) = self hostIP6Code		ifTrue: [self waitForReply: 18 for: self defaultTimeOutDuration].	(response at: 2) ~= 0		ifTrue: [^self socksError: 'Connection failed: ', (response at: 2) printString].! !!Socket class methodsFor: 'utilities' stamp: 'mir 5/15/2003 18:30'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort := 7.  "7 = echo port, 13 = time port, 19 = character generator port"	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		^ self inform: 'Could not find an address for ', hostName].	sock := Socket new.	sock connectNonBlockingTo: serverAddr port: tcpPort.	[sock waitForConnectionFor: 10]		on: ConnectionTimedOut		do: [:ex |			(self confirm: 'Continue to wait for connection to ', hostName, '?')				ifTrue: [ex retry]				ifFalse: [					sock destroy.					^ self]].	sock sendData: 'echo!!'.	startTime := Time millisecondClockValue.	[sock waitForDataFor: 15]		on: ConnectionTimedOut		do: [:ex | (self confirm: 'Packet sent but no echo yet; keep waiting?')			ifTrue: [ex retry]].	echoTime := Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!ServerDirectory class methodsFor: 'available servers' stamp: 'mir 11/14/2001 16:26'!projectServers	"ServerDirectory projectServers"	| projectServers projectServer |	projectServers := OrderedCollection new.	self serverNames do: [ :n | 		projectServer := ServerDirectory serverNamed: n.		(projectServer isProjectSwiki and: [projectServer isSearchable])			ifTrue: [projectServers add: projectServer]].	^projectServers! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 5/20/1998 12:26'!moniker: nickName	"a plain language name for this directory"	moniker := nickName! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:52'!nextChar	self atEndOfChars ifTrue: [ ^nil ].	pos := pos + 1.	^text at: (pos-1)! !!HierarchicalURI methodsFor: 'accessing' stamp: 'mir 2/27/2002 16:17'!resolveRelativeURI: aURI	| relativeURI newAuthority newPath pathComponents newURI relComps |	relativeURI := aURI asURI.	relativeURI isAbsolute		ifTrue: [^relativeURI].	relativeURI authority		ifNil: [			newAuthority := self authority.			(relativeURI path beginsWith: '/')				ifTrue: [newPath := relativeURI path]				ifFalse: [					pathComponents := (self path copyUpToLast: $/) findTokens: $/.					relComps := relativeURI pathComponents.					relComps removeAllSuchThat: [:each | each = '.'].					pathComponents addAll: relComps.					pathComponents removeAllSuchThat: [:each | each = '.'].					self removeComponentDotDotPairs: pathComponents.					newPath := self buildAbsolutePath: pathComponents.					((relComps isEmpty						or: [relativeURI path last == $/ ]						or: [(relativeURI path endsWith: '/..') or: [relativeURI path = '..']]						or: [relativeURI path endsWith: '/.' ])						and: [newPath size > 1])						ifTrue: [newPath := newPath , '/']]]		ifNotNil: [			newAuthority := relativeURI authority.			newPath := relativeURI path].	newURI := String streamContents: [:stream |		stream nextPutAll: self scheme.		stream nextPut: $: .		newAuthority notNil			ifTrue: [				stream nextPutAll: '//'.				newAuthority printOn: stream].		newPath notNil			ifTrue: [stream nextPutAll: newPath].		relativeURI query notNil			ifTrue: [stream nextPutAll: relativeURI query].		relativeURI fragment notNil			ifTrue: [				stream nextPut: $# .				stream nextPutAll: relativeURI fragment]].	^newURI asURI! !!MailMessage methodsFor: 'multipart' stamp: 'mdr 3/23/2001 13:30'!parseParts	"private -- parse the parts of the message and store them into a collection"	| parseStream msgStream messages separator |	"If this is not multipart, store an empty collection"	self body isMultipart ifFalse: [parts := #().  ^self].	"If we can't find a valid separator, handle it as if the message is not multipart"	separator := self attachmentSeparator.	separator ifNil: [Transcript show: 'Ignoring bad attachment separater'; cr. parts := #(). ^self].	separator := '--', separator withoutTrailingBlanks.	parseStream := ReadStream on: self bodyText.	msgStream := LimitingLineStreamWrapper on: parseStream delimiter: separator.	msgStream limitingBlock: [:aLine |		aLine withoutTrailingBlanks = separator or:			"Match the separator"		[aLine withoutTrailingBlanks = (separator, '--')]].	"or the final separator with --"	"Throw away everything up to and including the first separator"	msgStream upToEnd.	msgStream skipThisLine.	"Extract each of the multi-parts as strings"	messages := OrderedCollection new.	[parseStream atEnd]		whileFalse: 			[messages add: msgStream upToEnd.			msgStream skipThisLine].	parts := messages collect: [:e | MailMessage from: e]! !!Socket methodsFor: 'datagrams' stamp: 'mir 5/15/2003 18:34'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 20)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		bytesSent := bytesSent + count].	^ bytesSent! !!OldSimpleClientSocket class methodsFor: 'other examples' stamp: 'mir 5/13/2003 10:45'!finger: userName	"OldSimpleClientSocket finger: 'stp'"	| addr s |	addr := NetNameResolver promptUserForHostAddress.	s := OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 79.  "finger port number"	s waitForConnectionUntil: self standardDeadline.	s sendCommand: userName.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!HierarchicalURI methodsFor: 'private' stamp: 'mir 2/27/2002 14:16'!relativeFromString: aString	| remainder authorityEnd |	remainder := (aString beginsWith: '//')		ifTrue: [			authorityEnd := aString indexOf: $/ startingAt: 3.			authorityEnd == 0				ifTrue: [authorityEnd := aString size+1].			self extractAuthority: (aString copyFrom: 3 to: authorityEnd-1)]		ifFalse: [aString].	self extractSchemeSpecificPartAndFragment: remainder! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:35'!connectionInfo	connectInfo ifNil: [connectInfo := Dictionary new].	^connectInfo! !!ServerDirectory methodsFor: 'updates' stamp: 'rbb 2/18/2005 14:39'!outOfDate: aServer	"Inform the user that this server does not have a current version of 'Updates.list'  Return true if the user does not want any updates to happen."| response |response := UIManager default chooseFrom: #('Install on others' 'Cancel entire update')		title: 'The server ', aServer moniker, ' is not up to date.Please store the missing updates maually.'.^ response ~= 1! !!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!tcpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	self initializeNetwork.	sock := super new initialize: TCPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!NetNameResolver class methodsFor: 'address string utils' stamp: 'jm 9/15/97 16:52'!stringFromAddress: addr	"Return a string representing the given host address as four decimal bytes delimited with decimal points."	"NetNameResolver stringFromAddress: NetNameResolver localHostAddress"	| s |	s := WriteStream on: ''.	1 to: 3 do: [ :i | (addr at: i) printOn: s. s nextPut: $.].	(addr at: 4) printOn: s.	^ s contents! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/28/2000 13:46'!splitName: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. FileName must be of the form: <dirPath><delimiter><localName>, where <dirPath><delimiter> is optional. The <dirPath> part may contain delimiters."	| delimiter i dirName localName |	delimiter := self pathNameDelimiter.	(i := fullName findLast: [:c | c = delimiter]) = 0		ifTrue:			[dirName := String new.			localName := fullName]		ifFalse:			[dirName := fullName copyFrom: 1 to: (i - 1 max: 1).			localName := fullName copyFrom: i + 1 to: fullName size].	^ pathAndNameBlock value: dirName value: localName! !!Socket methodsFor: 'other' stamp: 'mir 2/22/2002 16:25'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO:=KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo := Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options := {'SO:=DEBUG'. 'SO:=REUSEADDR'. 'SO:=REUSEPORT'. 'SO:=DONTROUTE'.'SO:=BROADCAST'. 'SO:=SNDBUF'. 'SO:=RCVBUF'. 'SO:=KEEPALIVE'.'SO:=OOBINLINE'. 'SO:=PRIORITY'. 'SO:=LINGER'. 'SO:=RCVLOWAT'.'SO:=SNDLOWAT'. 'IP:=TTL'. 'IP:=HDRINCL'. 'IP:=RCVOPTS'.'IP:=RCVDSTADDR'. 'IP:=MULTICAST:=IF'. 'IP:=MULTICAST:=TTL'.'IP:=MULTICAST:=LOOP'. 'UDP:=CHECKSUM'. 'TCP:=MAXSEG'.'TCP:=NODELAY'. 'TCP:=ABORT:=THRESHOLD'. 'TCP:=CONN:=NOTIFY:=THRESHOLD'. 'TCP:=CONN:=ABORT:=THRESHOLD'. 'TCP:=NOTIFY:=THRESHOLD'.'TCP:=URGENT:=PTR:=TYPE'}.1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo := Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!OldSocket methodsFor: 'sending-receiving' stamp: 'tak 3/16/2005 16:51'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneUntil: (Socket deadlineSecs: 60))			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: (bytesToSend - bytesSent min: 5000).		bytesSent := bytesSent + count].	^ bytesSent! !!NameLookupFailure methodsFor: 'accessing' stamp: 'rbb 2/18/2005 14:27'!defaultAction	"Backward compatibility"	| response |	response := (UIManager default  chooseFrom: #( 'Retry' 'Give Up')			title: self messageText).	^ response = 2		ifFalse: [self retry]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'avi 2/10/2004 14:02'!httpGet: url args: args user: user passwd: passwd	| authorization |	authorization := (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	^self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , CrLf! !!HierarchicalURI methodsFor: 'accessing' stamp: 'mir 1/8/2004 00:50'!extension	"This method assumes a $. as extension delimiter"	| i leafName |	leafName := self pathComponents last.	i := leafName findLast: [:c | c = $.].	^i = 0		ifTrue: ['']		ifFalse: [leafName copyFrom: i + 1 to: leafName size].! !!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:16'!peekForAll: aString	"Answer whether or not the next string of characters in the receiver	matches aString. If a match is made, advance over that string in the receiver and	answer true. If no match, then leave the receiver alone and answer false.	We use findString:startingAt: to avoid copying.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	| sz start |	sz := aString size.	self receiveData: sz.	(inNextToWrite - lastRead - 1) < sz ifTrue: [^false].	start := lastRead + 1.	(inBuffer findString: aString startingAt: start) = start		ifFalse: [^false].	lastRead := lastRead + sz.	^true! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/19/1998 18:54'!copy	| new |	new := self clone.	new urlObject: urlObject copy.	^ new! !!POP3Client methodsFor: 'private protocol' stamp: 'mir 11/14/2002 17:40'!getMultilineResponse	"Get a multiple line response to the last command, filtering out LF characters. A multiple line response ends with a line containing only a single period (.) character."	| response done chunk |	response := WriteStream on: ''.	done := false.	[done] whileFalse: [		chunk := self stream nextLine.		(chunk beginsWith: '.')			ifTrue: [response nextPutAll: (chunk copyFrom: 2 to: chunk size); cr ]			ifFalse: [response nextPutAll: chunk; cr ].		done := (chunk = '.') ].	^ response contents! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/5/1998 17:20'!url: aString	altURL := aString! !!HierarchicalUrl methodsFor: 'access' stamp: 'gk 10/21/2005 11:15'!path: aCollection	"Set the collection of path elements."	path := aCollection! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:10'!oldFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile |	rFile := self asServerFileNamed: aName.	rFile readOnly.	rFile isTypeFile ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	^self streamOnBeginningOf: rFile! !!Socket class methodsFor: 'registry' stamp: 'ar 12/12/2001 19:12'!registryThreshold: aNumber	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	RegistryThreshold := aNumber! !!FTPClient methodsFor: 'private' stamp: 'mir 10/31/2000 18:23'!dataSocket: aSocket	dataSocket := aSocket! !!Socket methodsFor: 'waiting' stamp: 'mir 5/15/2003 18:33'!waitForSendDoneFor: timeout	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone deadline |	deadline := Socket deadlineSecs: timeout.	[self isConnected & (sendDone := self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!ServerDirectory methodsFor: 'file directory' stamp: 'tk 9/19/1998 18:59'!on: fullName	"Answer another ServerDirectory on the partial path name.  fullName is directory path, and does include the name of the server."	| new |	new := self copy.	new fullPath: fullName.		"sets server, directory(path)"	^ new! !!ProtocolClient methodsFor: 'accessing' stamp: 'mir 2/22/2002 17:33'!stream: aStream	stream := aStream! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'gk 3/2/2004 11:10'!openOnHostNamed: hostName	"If the hostname uses the colon syntax to express a certain portnumber	we use that instead of the default port number."	| i |	i := hostName indexOf: $:.	i = 0 ifTrue: [			^self openOnHostNamed: hostName port: self defaultPortNumber]		ifFalse: [			| s p | 			s := hostName truncateTo: i - 1.			p := (hostName copyFrom: i + 1 to: hostName size) asInteger.			^self openOnHostNamed: s port: p]	! !!ServerDirectory class methodsFor: 'available servers' stamp: 'ar 9/5/2001 16:11'!resetLocalProjectDirectories	LocalProjectDirectories := nil.	LocalEToyUserListUrls := nil.	LocalEToyBaseFolderSpecs := nil.! !!OldSocket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:54'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil ifFalse: 		[self isValid ifTrue: [self primSocketDestroy: socketHandle].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle := nil.		readSemaphore := writeSemaphore := semaphore := nil.		self unregister].! !!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:17'!next: anInteger	"Answer anInteger bytes of data.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	| start |	self receiveData: anInteger.	start := lastRead + 1.	lastRead := (lastRead + anInteger) min: inNextToWrite - 1.	^inBuffer copyFrom: start to: lastRead! !!OldSocket methodsFor: 'sending-receiving' stamp: 'jm 9/15/97 12:22'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf := String new: 10000.	totalBytesDiscarded := 0.	[self isConnected and: [self dataAvailable]] whileTrue: [		totalBytesDiscarded :=			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!HTTPSocket class methodsFor: 'get the page' stamp: 'avi 2/10/2004 15:04'!httpPost: url args: args user: user passwd: passwd	| authorization |	authorization := (Base64MimeConverter mimeEncode: (user , ':' , passwd) readStream) contents.	^self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , CrLf! !!SuperSwikiServer methodsFor: 'testing' stamp: 'KR 1/30/2006 21:59'!showQueryAsPVM: resultStream	| answer gif whatToShow projectName fileName firstURL wrapper currX currY maxX maxY rawProjectName |"SuperSwikiServer testOnlySuperSwiki queryProjectsAndShow"	resultStream reset; nextLine.	answer := RectangleMorph new		useRoundedCorners;		borderWidth: 0;		borderColor: Color blue;		color: Color paleBlue.	currX := currY := maxX := maxY := 10.	[resultStream atEnd] whileFalse: [		rawProjectName := resultStream nextLine.		projectName := rawProjectName convertFromEncoding: self encodingName.		fileName := resultStream nextLine convertFromEncoding: self encodingName.		gif := self oldFileOrNoneNamed: rawProjectName,'.gif'.		gif ifNotNil: [gif := GIFReadWriter formFromStream: gif].		currX > 600 ifTrue: [			currX := 10.			currY := maxY + 10.		].		gif ifNil: [			gif := AlignmentMorph newColumn				hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				borderWidth: 8;				borderColor: Color red;				color: Color lightRed;				addMorph: (StringMorph contents: 'No GIF for ',projectName);				fullBounds;				imageForm		].		firstURL := self url.		firstURL last == $/ ifFalse: [firstURL := firstURL, '/'].		whatToShow := ProjectViewMorph new			image: (gif asFormOfDepth: Display depth);			lastProjectThumbnail: gif;			setProperty: #SafeProjectName toValue: projectName;			project: (DiskProxy 				global: #Project 				selector: #namedUrl: 				args: {firstURL,fileName}			).		answer addMorphBack: (whatToShow position: currX @ currY).		currX := currX + whatToShow width + 10.		maxX := maxX max: currX.		maxY := maxY max: currY + whatToShow height.	].	maxX = 10 ifTrue: [		^self inform: 'No projects found for your criteria'	].	answer extent: (maxX @ maxY) + (0@10).	wrapper := ScrollPane new extent: (answer width + 10) @ (answer height min: 400).	wrapper color: Color white.	wrapper scroller addMorph: answer.	wrapper 		becomeModal;		openCenteredInWorld;		useRoundedCorners;		setScrollDeltas.! !!Password methodsFor: 'accessing' stamp: 'tk 1/5/98 21:14'!sequence: anNumber	sequence := anNumber! !!HttpUrl methodsFor: 'downloading' stamp: 'fbs 2/2/2005 13:24'!retrieveContentsArgs: args accept: mimeType	| contents request |	request := realm ifNotNil: [Passwords at: realm ifAbsent: ['']] ifNil: [''].	request = '' ifFalse: [request := 'Authorization: Basic ' , request , String crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents := (HTTPSocket		httpGetDocument: self withoutFragment asString		args: args		accept: mimeType		request: request).	self checkAuthorization: contents retry: [^ self retrieveContentsArgs: args].	^ self normalizeContents: contents! !!Url methodsFor: 'fragment' stamp: 'ls 8/4/1998 01:02'!privateFragment: aString	fragment := aString! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 12/8/2003 14:17'!deleteFileNamed: fullName	"Detete a remote file.  fullName is directory path, and does include name of the server.  Or it can just be a fileName."	| file |	file := self asServerFileNamed: fullName.	file isTypeFile ifTrue: [		^ (FileDirectory forFileName: (file fileNameRelativeTo: self)) 			deleteFileNamed: file fileName	].		client := self openFTPClient.	[client deleteFileNamed: fullName]		ensure: [self quit].! !!Socket class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 15:49'!udpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	self initializeNetwork.	sock := super new initialize: UDPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!SocketStream methodsFor: 'private-socket' stamp: 'gk 2/9/2005 22:53'!receiveDataIfAvailable	"Only used to check that there really is data to read	from the socket after it signals dataAvailable.	It has been known to signal true and then still	not have anything to read. See also isDataAvailable.	Return the position in the buffer where the	new data starts, regardless if anything	was read, see #adjustInBuffer."	recentlyRead := socket receiveSomeDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!Socket methodsFor: 'connection open/close' stamp: 'mir 5/8/2003 16:03'!connectToHostNamed: hostName port: portNumber	| serverIP |	serverIP := NetNameResolver addressForName: hostName timeout: 20.	^self connectTo: serverIP port: portNumber! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 9/8/1998 11:56'!urlObject: aUrl	urlObject := aUrl! !!ProtocolClient class methodsFor: 'instance creation' stamp: 'mir 2/25/2002 15:58'!openOnHostNamed: hostName port: portNumber	| serverIP |	serverIP := NetNameResolver addressForName: hostName timeout: 20.	^self openOnHost: serverIP port: portNumber! !!SuperSwikiServer methodsFor: 'squeaklets' stamp: 'KR 1/30/2006 22:15'!upLoadProject: projectName members: archiveMembers retry: aBool	| answer |	archiveMembers do:[:entry|		ProgressNotification signal: '4:uploadingFile' extra:'(uploading ' translated, entry fileName convertFromSystemString , '...)' translated.		answer := self sendToSwikiProjectServer: {			'uploadproject2: ', entry fileName convertFromSystemString convertToEncoding: self encodingName.			'password: ',ProjectPasswordNotification signal.			entry contents.		}.		answer = 'OK' ifFalse:[			self inform:'Server responded ' translated, answer.			^false].	].	ProgressNotification signal: '4:uploadingFile' extra:''.	^true! !!SocksSocket methodsFor: 'connection open/close' stamp: 'mir 3/6/2000 15:17'!connectToHostNamed: hostName port: port	super connectTo: socksIP port: socksPort.	self waitForConnectionUntil: Socket standardDeadline.	dstName := hostName.	dstPort := port.	vers == 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SuperSwikiServer methodsFor: 'for real' stamp: 'RAA 10/17/2000 14:54'!oldFileOrNoneNamed: fullName	| answer aName |	self flag: #bob.		"fix this up for full names"	aName := fullName.	answer := self sendToSwikiProjectServer: {		'action: readnamedfile'.		'projectname: ',(self localNameFor: aName).	}.	(answer beginsWith: 'OK') ifFalse: [^nil].	^(SwikiPseudoFileStream with: (answer allButFirst: 3))		reset;		directory: self;		localName: aName;		yourself! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'jm 9/15/97 11:35'!contentsLength: header	"extract the data length from the header.  Content-length: 1234<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens := header findTokens: ParamDelimiters keep: (String with: CR).	1 to: headerTokens size do: [:ii | 		this := headerTokens at: ii.		(this first asLowercase = $c and: [this asLowercase = 'content-length:']) ifTrue: [			^ (headerTokens at: ii+1) asNumber]].	^ nil	"not found"! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:03'!streamOnBeginningOf: serverFile	| remoteStrm |	remoteStrm := RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: serverFile.	serverFile getFileNamed: serverFile fileName into: remoteStrm.	"prefetch data"	^ remoteStrm! !!OldSocket methodsFor: 'waiting' stamp: 'JMM 5/22/2000 22:05'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone := self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 5/13/2003 10:44'!entries 	"Return a collection of directory entries for the files and directories in this directory. Each entry is a five-element array: (<name> <creationTime> <modificationTime> <dirFlag> <fileSize>)."	| dir ftpEntries |	"We start with ftp directory entries of the form...d---------   1 owner    group               0 Apr 27 22:01 blasttest----------   1 owner    group           93812 Jul 21  1997 COMMAND.COM    1        2   3           4                 5    6  7    8       9   -- token index"	self isTypeFile ifTrue: [		urlObject isAbsolute ifFalse: [urlObject default].		^ (FileDirectory on: urlObject pathForDirectory) entries	].	dir := self getDirectory.	(dir respondsTo: #contentsOfEntireFile) ifFalse: [^ #()].	ftpEntries := dir contentsOfEntireFile findTokens: String crlf."ftpEntries inspect."	^ ftpEntries 		collect:[:ftpEntry | self class parseFTPEntry: ftpEntry]		thenSelect: [:entry | entry notNil]! !!ConnectionQueue methodsFor: 'private' stamp: 'jm 3/10/98 17:30'!pruneStaleConnections	"Private!! The client may establish a connection and then disconnect while it is still in the connection queue. This method is called periodically to prune such sockets out of the connection queue and make room for fresh connections."	| foundStaleConnection |	accessSema critical: [		foundStaleConnection := false.		connections do: [:s |			s isUnconnected ifTrue: [				s destroy.				foundStaleConnection := true]].		foundStaleConnection ifTrue: [			connections := connections select: [:s | s isValid]]].! !!HttpUrl methodsFor: 'downloading' stamp: 'nk 8/30/2004 07:50'!checkAuthorization: webDocument retry: retryBlock	"authorization failed if webDocument is a String"	| oldRealm i end encoded |	((webDocument isString)		and: [(webDocument beginsWith: 'HTTP/1.0 401')			or: [webDocument beginsWith: 'HTTP/1.1 401']])	ifFalse: [^self].	oldRealm := realm.	i := webDocument findString: 'realm="'.	i = 0 ifTrue: [^self].	end := webDocument indexOf: $" startingAt: i.	realm := webDocument copyFrom: i+7 to: end.	"realm := (webDocument findTokens: '""') at: 2."	Passwords ifNil: [Passwords := Dictionary new].	encoded := Passwords at: realm ifAbsent: [nil].	(oldRealm ~= realm) & (encoded ~~ nil) 		ifTrue: [^ retryBlock value]		ifFalse: ["ask the user"			self askNamePassword ifTrue: [^ retryBlock value]]! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 15:16'!socks5MethodSelection	"The client connects to the server, and sends a version   identifier/method selection message.	The server selects from one of the methods given in METHODS, and   sends a METHOD selection message."	| requestString response |	requestString := WriteStream on: ByteArray new.	requestString		nextPut: 5;		nextPut: 1;		nextPut: 0.	self sendData: requestString contents.	response := self waitForReply: 2 for: self defaultTimeOutDuration.	(response at: 2) == 16rFF		ifTrue: [self socksError: 'No acceptable methods.']		ifFalse: [method := response at: 2]! !!ServerDirectory methodsFor: 'up/download' stamp: 'hg 2/5/2002 16:50'!fileExists: fileName	"Does the file exist on this server directory?  fileName must be simple with no / or references to other directories."	| stream |	self isTypeFile ifTrue: [^ self fileNames includes: fileName].	self isTypeHTTP ifTrue: [		stream := self readOnlyFileNamed: fileName.		^stream contents notEmpty].	"ftp"	^ self entries anySatisfy: [:entry | entry name = fileName]! !!SocketStream methodsFor: 'stream in' stamp: 'gk 9/9/2005 02:57'!upTo: aCharacterOrByte	"Return data up to, but not including given character or byte.		NOTE: Does not honour timeouts if shouldSignal is false!!		This method looks a bit complicated, and this is mainly because there is no fast search method	in String that takes a stoppingAt: argument. This means we need to ignore getting hits in the	dead buffer area above inNextToWrite.	Another measure is that this implementation is greedy and will load data into the buffer	until there is nothing more available, or it has loaded 100kb - and not until then we search the buffer.	A totally non greedy variant would search on every loop."	| index result lastRecentlyRead searchedSoFar |	searchedSoFar := 0.	lastRecentlyRead := 0.	index := 0.	[self atEnd not and: [		((lastRecentlyRead = 0 and: [self isInBufferEmpty not]) or: [self inBufferSize > 100000]) ifTrue: [			"Data begins at lastRead + 1, we add searchedSoFar as offset."			index := inBuffer indexOf: aCharacterOrByte startingAt: lastRead + searchedSoFar + 1.			searchedSoFar := self inBufferSize.			(index > 0 and: [(index + 1) > inNextToWrite]) ifTrue: [				"Oops, hit in dead buffer area.				This is probably due to old data, so we ignore it.				No point in cleaning the dead area to avoid hits - it will still search it."				index := 0]].		index = 0]]				whileTrue: [					recentlyRead = 0						ifTrue: ["blocking call for now, we don't want to poll"							self receiveData]						ifFalse: [							self receiveAvailableData].					lastRecentlyRead := recentlyRead].	index > 0		ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result]		ifFalse: ["atEnd"			^ self nextAllInBuffer]! !!MIMEHeaderValue methodsFor: 'printing' stamp: 'dvf 4/28/2000 02:48'!asHeaderValue	| strm |	strm := WriteStream on: (String new: 20).	strm nextPutAll: mainValue.	parameters associationsDo: [:e | strm nextPut: $; ; nextPutAll: e key;		 nextPutAll: '="';		 nextPutAll: e value , '"'].	^ strm contents! !!MailComposition methodsFor: 'private' stamp: 'ls 2/10/2001 13:57'!breakLines: aString  atWidth: width	"break lines in the given string into shorter lines"	| result start end atAttachment |	result := WriteStream on: (String new: (aString size * 50 // 49)).	atAttachment := false.	aString asString linesDo: [ :line | 		(line beginsWith: '====') ifTrue: [ atAttachment := true ].		atAttachment ifTrue: [			"at or after an attachment line; no more wrapping for the rest of the message"			result nextPutAll: line.  result cr ]		ifFalse: [			(line beginsWith: '>') ifTrue: [				"it's quoted text; don't wrap it"				result nextPutAll: line. result cr. ]			ifFalse: [				"regular old line.  Wrap it to multiple lines"				start := 1.					"output one shorter line each time through this loop"				[ start + width <= line size ] whileTrue: [						"find the end of the line"					end := start + width - 1.					[end >= start and: [ (line at: (end+1)) isSeparator not ]] whileTrue: [						end := end - 1 ].					end < start ifTrue: [						"a word spans the entire width!!"						end := start + width - 1 ].					"copy the line to the output"					result nextPutAll: (line copyFrom: start to: end).					result cr.					"get ready for next iteration"					start := end+1.					(line at: start) isSeparator ifTrue: [ start := start + 1 ].				].				"write out the final part of the line"				result nextPutAll: (line copyFrom: start to: line size).				result cr.			].		].	].	^result contents! !!Socket methodsFor: 'waiting' stamp: 'gk 12/14/2005 09:59'!waitForDisconnectionFor: timeout	"Wait for the given nr of seconds for the connection to be broken.	Return true if it is broken by the deadline, false if not.	The client should know the connection is really going to be closed	(e.g., because he has called 'close' to send a close request to the other end)	before calling this method."	| status deadline |	status := self primSocketConnectionStatus: socketHandle.	deadline := Socket deadlineSecs: timeout.	[((status == Connected) or: [(status == ThisEndClosed)]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self discardReceivedData.		self readSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status := self primSocketConnectionStatus: socketHandle].	^ status ~= Connected! !!OldSimpleClientSocket class methodsFor: 'class initialization' stamp: 'jm 9/15/97 11:42'!initialize	"SimpleClientSocket initialize"	CR := Character cr.	LF := Character linefeed.	"string for command line termination:"	CrLf := String with: CR with: LF.! !!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:16'!peek: anInteger	"Answer anInteger bytes of data.	Do not consume data.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	| start |	self receiveData: anInteger.	start := lastRead + 1.	^inBuffer copyFrom: start to: ((lastRead + anInteger) min: inNextToWrite - 1).! !!FileUrl methodsFor: 'accessing' stamp: 'gk 10/21/2005 11:11'!path: aCollection	"Set the collection of path elements."	path := aCollection! !!OldSimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:25'!parseHeaderList: aString	"Parse a list of newsgroup headers."	| results s lineStart |	results := WriteStream on: (String new: aString size).	s := ReadStream on: aString.	[s atEnd]		whileFalse: [			lineStart := s position + 1.			3 timesRepeat: [s skipTo: Character tab].  "find fourth tab"			lineStart to: s position - 1 do: [:i | results nextPut: (aString at: i)].			results cr.			s skipTo: Character cr].	^ results contents! !!ServerDirectory class methodsFor: 'misc' stamp: 'mir 4/13/2001 12:44'!secondsForDay: dayToken month: monthToken yearOrTime: ytToken thisMonth: thisMonth thisYear: thisYear	| ftpDay ftpMonth pickAYear jDateToday trialJulianDate |	ftpDay := dayToken asNumber.	ftpMonth := Date indexOfMonth: monthToken.	(ytToken includes: $:) ifFalse: [		^(Date newDay: ftpDay month: ftpMonth year: ytToken asNumber) asSeconds	].	jDateToday := Date today dayOfYear.	trialJulianDate := (Date newDay: ftpDay month: ftpMonth year: thisYear) dayOfYear.		"Date has no year if within six months (do we need to check the day, too?)"	"Well it appear to be pickier than that... it isn't just 6 months or 6 months and the day of the month, put perhaps the julian date AND the time as well. I don't know what the precise standard is, but this seems to produce better results"	pickAYear := (jDateToday - trialJulianDate) > 182 ifTrue: [		thisYear + 1	"his clock could be ahead of ours??"	] ifFalse: [		pickAYear := (trialJulianDate - jDateToday) > 182 ifTrue: [			thisYear - 1		] ifFalse: [			thisYear		].	].	^(Date newDay: ftpDay month: ftpMonth year: pickAYear) asSeconds +		(Time readFrom: (ReadStream on: ytToken)) asSeconds! !!ProtocolClientError methodsFor: 'accessing' stamp: 'mir 10/30/2000 13:48'!protocolInstance: aProtocolInstance	protocolInstance := aProtocolInstance! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!directory: anObject	directory := anObject! !!SuperSwikiServer methodsFor: 'testing' stamp: 'RAA 10/17/2000 19:23'!queryProjectsAndShow	| result |"SuperSwikiServer testOnlySuperSwiki queryProjectsAndShow"	result := self sendToSwikiProjectServer: {		'action: findproject'.		"'projectname: *proj*'."	}.	(result beginsWith: 'OK') ifFalse: [^self inform: result printString].	self showQueryAsPVM: (ReadStream on: result).! !!OldSimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'jm 9/16/1998 14:37'!waitForDataQueryingUserEvery: seconds	"Wait for data to arrive, asking the user periodically if they wish to keep waiting. If they don't wish to keep waiting, destroy the socket and raise an error."	| gotData |	gotData := false.	[gotData]		whileFalse: [			gotData := self waitForDataUntil: (Socket deadlineSecs: seconds).			gotData ifFalse: [				self isConnected ifFalse: [					self destroy.					self error: 'server closed connection'].				(self confirm: 'server not responding; keep trying?')					ifFalse: [						self destroy.						self error: 'no response from server']]].! !!MailMessage methodsFor: 'printing/formatting' stamp: ''!format	"Replace the text of this message with a formatted version."	"NOTE: This operation discards extra header fields."	text := self formattedText.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 16:54'!putFileNamed: filePath as: fileNameOnServer	"FTP a file to the server."	| fileStream |	fileStream := FileStream readOnlyFileNamed: filePath.	fileStream		ifNil: [(FileDoesNotExistException fileName: filePath) signal].	self putFileStreamContents: fileStream as: fileNameOnServer! !!HTTPSocket class methodsFor: 'get the page' stamp: 'gk 12/15/2005 00:24'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| s header length page list firstData aStream type newUrl httpUrl argString |	Socket initializeNetwork.	httpUrl := Url absoluteFromText: url.	page := httpUrl fullPath.	"add arguments"	argString := argsDict		ifNotNil: [			argString := self argString: argsDict.			argString first = $? ifTrue: [ argString := argString copyFrom: 2 to: argString size]]		ifNil: [''].	s := HTTPSocket new. 	s := self initHTTPSocket: httpUrl wait: (self deadlineSecs: 30) ifError: [:errorString | ^errorString].	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPProxyCredentials,		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		self userAgentString, CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argString size printString, CrLf,		'Host: ', httpUrl authority, CrLf.  "blank line automatically added"	"umur - IE sends argString without a $? and swiki expects so"	s sendCommand: argString.	"get the header of the reply"	list := s getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header := list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData := list at: 3.	"dig out some headers"	s header: header.	length := s getHeader: 'content-length'.	length ifNotNil: [ length := length asNumber ].	type := s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl := s getHeader: 'location'.		newUrl ifNotNil: [			"umur 6/25/2003 12:58 - If newUrl is relative then we need to make it absolute."			newUrl := (httpUrl newFromRelativeText: newUrl) asString.			self flag: #refactor. "get, post, postmultipart are almost doing the same stuff"			s destroy.			"^self httpPostDocument: newUrl  args: argsDict  accept: mimeType"			^self httpGetDocument: newUrl accept: mimeType ] ].	aStream := s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!FTPClient methodsFor: 'private protocol' stamp: 'mir 2/13/2002 18:06'!getData	| dataStream |	dataStream := RWBinaryOrTextStream on: (String new: 4000).	self getDataInto: dataStream.	self closeDataSocket.	^dataStream contents! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:31'!fileNamed: fullName	"Create a RemoteFileStream for writing.  If the file exists, do not complain.  fullName is directory path, and does include name of the server.  Or it can just be a fileName.  Only write the data upon close."	| file remoteStrm |	file := self asServerFileNamed: fullName.	file readWrite.	file isTypeFile ifTrue: [		^ FileStream fileNamed: (file fileNameRelativeTo: self)	].	remoteStrm := RemoteFileStream on: (String new: 2000).	remoteStrm remoteFile: file.	^ remoteStrm	"no actual writing till close"! !!OldSocket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:56'!statusString	"Return a string describing the status of this socket."	| status |	socketHandle == nil ifTrue: [^ 'destroyed'].	status := self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:46'!receiveSomeData	"Receive currently available data (if any). Do not wait." 	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveSomeDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!OldSocket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 23:04'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle :=		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore := writeSemaphore := semaphore := nil	] ifFalse:[self register].! !!URI class methodsFor: 'instance creation' stamp: 'mir 2/20/2002 17:21'!absoluteFromString: aString scheme: scheme	| remainder |	remainder := aString copyFrom: scheme size+2 to: aString size.	remainder isEmpty		ifTrue: [(IllegalURIException new uriString: aString) signal: 'Invalid absolute URI'].	^(remainder first = $/		ifTrue: [HierarchicalURI]		ifFalse: [OpaqueURI]) new absoluteFromString: remainder scheme: scheme! !!ServerDirectory class methodsFor: 'class initialization' stamp: 'mir 6/25/2001 18:46'!initialize	"ServerDirectory initialize"	"ServerDirectory resetLocalProjectDirectories.	Servers := Dictionary new."	ExternalSettings registerClient: self! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:51'!next	| ans |	cachedToken ifNil: [ ^self nextToken ].	ans := cachedToken.	cachedToken := nil.	^ans! !!SwikiPseudoFileStream methodsFor: 'as yet unclassified' stamp: 'RAA 10/13/2000 11:50'!localName: x	localName := x! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'hg 2/11/2002 20:13'!getRestOfBuffer: beginning	"We don't know the length.  Keep going until connection is closed.  Part of it has already been received.  Response is of type text, not binary."	| buf response bytesRead |	response := RWBinaryOrTextStream on: (String new: 2000).	response nextPutAll: beginning.	buf := String new: 2000.	[self isConnected | self dataAvailable] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead := self primSocket: socketHandle receiveDataInto: buf 				startingAt: 1 count: buf size. 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	self logToTranscript ifTrue: [		Transcript cr; show: 'data byte count: ', response position printString].	response reset.	"position: 0."	^ response! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 6/23/2000 09:47'!getOnly: nnn from: fileNameOnServer	| file ff resp |	"Use FTP to just capture the first nnn characters of the file.  Break the connection after that.  Goes faster for long files.  Return the contents, not a stream."	self isTypeFile ifTrue: [		file := self as: ServerFile.		file fileName: fileNameOnServer.		ff := FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self).		^ ff next: nnn].	self isTypeHTTP ifTrue: [		resp := HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				accept: 'application/octet-stream'.			"For now, get the whole file.  This branch not used often."		^ resp truncateTo: nnn].		^ self getOnlyBuffer: (String new: nnn) from: fileNameOnServer! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'mas 2/8/2001 11:36'!nextComment	| start nestLevel paren |	start := pos.	pos := pos + 1.	nestLevel := 1.	[ nestLevel > 0 ] whileTrue: [		pos := text indexOfAnyOf: CSParens startingAt: pos  ifAbsent: [ 0 ].		pos = 0 ifTrue: [ 			self error: 'unterminated comment.  ie, more (''s than )''s' ].		paren := self nextChar.		paren = $( ifTrue: [ nestLevel := nestLevel + 1 ] ifFalse: [ nestLevel := nestLevel - 1 ]].	^ MailAddressToken type: #Comment		text: (text copyFrom: start to: pos - 1)! !!FTPClient methodsFor: 'private protocol' stamp: 'gk 9/9/2005 09:31'!lookForCode: code ifDifferent: handleBlock 	"We are expecting a certain numeric code next.  	However, in the FTP protocol, multiple lines are allowed.  	If the response is multi-line, the fourth character of the first line is a  	$- and the last line repeats the numeric code but the code is followed by 	a space. So it's possible that there are more lines left of the last response that 	we need to throw away. We use peekForAll: so that we don't discard the	next response that is not a continuation line."	| headToDiscard |	"check for multi-line response"	(self lastResponse size > 3			and: [(self lastResponse at: 4) = $-])		ifTrue: ["Discard continuation lines."			[headToDiscard := self lastResponse first: 4.			[[self stream peekForAll: headToDiscard]				whileTrue: [self stream nextLine]]				on: Exception				do: [:ex | ^handleBlock value: nil]]].	^ super lookForCode: code ifDifferent: handleBlock! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 3/13/2000 16:53'!directoryUrl	| ru |	"A url to the directory this file is in"	ru := self realUrl.	^ ru copyFrom: 1 to: (ru size - fileName size)! !!UUID methodsFor: 'converting' stamp: 'ar 2/8/2004 12:16'!asString	| result data |	data := String new: 36.	result := WriteStream on: data.	1 to: 4 do:[:i| self printHexAt: i to: result].	result nextPut: $-.	5 to: 6 do:[:i| self printHexAt: i to: result].	result nextPut: $-.	7 to: 8 do:[:i| self printHexAt: i to: result].	result nextPut: $-.	9 to: 10 do:[:i| self printHexAt: i to: result].	result nextPut: $-.	11 to: 16 do:[:i| self printHexAt: i to: result].	^data.	! !!UrlArgumentList class methodsFor: 'instance creation' stamp: 'mir 7/27/1999 16:26'!with: firstArgAssoc with: secondArgAssoc	| argList |	argList := self with: firstArgAssoc.	argList add: secondArgAssoc key value: secondArgAssoc value.	^argList! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 13:52'!receiveAvailableData	"Receive all available data (if any). Do not wait." 	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveAvailableDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!finishAddress	"we've finished one address.  Bundle it up and add it to the list of addresses"	| address |	address := String streamContents: [ :str |		curAddrTokens do: [ :tok | str nextPutAll: tok text ] ].	addresses addFirst: address.	curAddrTokens := nil.! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 14:54'!progressObservers	progressObservers ifNil: [progressObservers := OrderedCollection new].	^progressObservers! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:27'!randomGenerator: aGenerator	randomGenerator := aGenerator! !!NetNameResolver class methodsFor: 'lookups' stamp: 'mir 2/22/2002 15:12'!localHostName	"Return the local name of this host."	"NetNameResolver localHostName"	| hostName |	hostName := NetNameResolver		nameForAddress: self localHostAddress		timeout: 5.	^hostName		ifNil: [self localAddressString]		ifNotNil: [hostName]! !!SocketStream methodsFor: 'configuration' stamp: 'gk 2/10/2005 18:03'!shouldSignal: aBoolean	"If shouldSignal is enabled the Socket Exceptions	ConnectionClosed and ConnectionTimedOut will not be swallowed.	Default is true. And please - don't set it to false - it is better to	use an exception handler (see below)  and several methods	in this class will not honour timeouts (says so in their method comments).	Also, it is quite hard to understand what for example #upToEnd	should return to indicate a timeout.		Wrap your use of SocketStream with a handler like:		[stuff := mySocketStream next: 10]		on: ConnectionClosed, ConnectionTimedOut		do: [:ex |			Transcript show: 'Oops!! Did not get my ten bytes!!;cr]	"	shouldSignal := aBoolean! !!OldSimpleClientSocket class methodsFor: 'net news example' stamp: 'mir 5/13/2003 10:45'!nntpTest	"SimpleClientSocket nntpTest"	| addr s headers msgs header allNewsGroups |	addr := NetNameResolver promptUserForHostAddress.	s := OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: addr port: 119.  "119 is the NNTP port number"	s waitForConnectionUntil: self standardDeadline.	Transcript show: s getResponse.	s sendCommand: 'group comp.lang.smalltalk'.	Transcript show: s getResponse.	"get all the message headers for the current newsgroup"	s sendCommand: 'xover 1-1000000'.	headers := s getMultilineResponseShowing: true.	"print the headers of the first 10 messages of comp.lang.smalltalk"	s sendCommand: 'listgroup comp.lang.smalltalk'.	msgs := self parseIntegerList: s getMultilineResponse.	msgs ifNotNil: [		1 to: 5 do: [:i |			s sendCommand: 'head ', (msgs at: i) printString.			header := s getMultilineResponse.			Transcript show: (self extractDateFromAndSubjectFromHeader: header); cr]].	"get a full list of usenet newsgroups"	s sendCommand: 'newgroups 010101 000000'.	allNewsGroups := s getMultilineResponse.	Transcript show: allNewsGroups size printString, ' bytes in full newsgroup list'; cr.	Transcript show: 'Sending quit...'; cr.	s sendCommand: 'QUIT'.	Transcript show: s getResponse.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	(headers ~~ nil and:	 [self confirm: 'show article headers from comp.lang.smalltalk?'])		ifTrue: [			(StringHolder new contents: (self parseHeaderList: headers))				openLabel: 'Newsgroup Headers'].	(allNewsGroups ~~ nil and:	 [self confirm: 'show list of all newsgroups available on your server?'])		ifTrue: [			(StringHolder new contents: allNewsGroups)				openLabel: 'All Usenet Newsgroups'].! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'mir 8/22/2001 17:01'!releaseExternalSettings	"Release for server configurations"	"ServerDirectory releaseExternalSettings"	Preferences externalServerDefsOnly		ifTrue: [			self resetLocalProjectDirectories.			Servers := Dictionary new]! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/8/2002 11:35'!resetConnectionInfo	connectInfo := nil! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'ls 6/15/2003 13:40'!privateInitializeFromText: aString relativeTo: aUrl 	| remainder ind basePath |	remainder := aString.	"set the scheme"	schemeName := aUrl schemeName.	"a leading // means the authority is specified, meaning it is absolute"	(remainder beginsWith: '//')		ifTrue: [^ self privateInitializeFromText: aString].	"otherwise, use the same authority"	authority := aUrl authority.	port := aUrl port.	username := aUrl username.	password := aUrl password.	"get the query"	ind := remainder indexOf: $?.	ind > 0		ifTrue: [query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the path"	(remainder beginsWith: '/')		ifTrue: [ basePath := #() ]		ifFalse: [ basePath := aUrl path ].	path := self privateParsePath: remainder  relativeTo: basePath.! !!ServerDirectory methodsFor: 'up/download' stamp: 'di 3/14/2001 15:34'!putFileSavingOldVersion: fileStream named: fileNameOnServer	| tempName oldName |	"Put a copy of this file out after saving the prior version.	Nothing happens to the old version until the new vers is successfully stored." 	tempName := fileNameOnServer , '.beingWritten'.	oldName := fileNameOnServer , '.prior'.	self putFile: fileStream named: tempName retry: true.	(self includesKey: oldName) ifTrue: [self deleteFileNamed: oldName].	self rename: fileNameOnServer toBe: oldName.	self rename: tempName toBe: fileNameOnServer.! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 11:35'!waitForCompletionUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is ready, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status := self resolverStatus.	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status := self resolverStatus].	status = ResolverReady		ifTrue: [^ true]		ifFalse: [			status = ResolverBusy ifTrue: [self primAbortLookup].			^ false].! !!InternetConfiguration class methodsFor: 'lookups' stamp: 'JMM 10/5/2001 23:45'!getMacintoshFileTypeAndCreatorFrom: aFileName	"Return the application type and application signature for the file	 for the macintosh file system based on the file ending, the file does not need to exist	failure to find a signature based on the file ending, or because of primitive failure turns nil"	"InternetConfiguration getMacintoshFileTypeAndCreatorFrom: 'test.jpg'"	| string |	string := self primitiveGetMacintoshFileTypeAndCreatorFrom: aFileName.	string = '********' ifTrue: [^nil].	^Array with: (string first: 4) with: (string last: 4)! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore := true.	^self primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex ! !!Socket methodsFor: 'waiting' stamp: 'gk 12/15/2005 01:09'!waitForConnectionFor: timeout ifTimedOut: timeoutBlock	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status deadline |	deadline := Socket deadlineSecs: timeout.	status := self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [Time millisecondClockValue < deadline]]		whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status := self primSocketConnectionStatus: socketHandle].	status = Connected ifFalse: [^timeoutBlock value]! !!MIMEDocument class methodsFor: 'initialize-release' stamp: 'st 9/18/2004 23:36'!defaultMIMEdatabase	| d |	(d := Dictionary new)	at: 'html' put: 'text/html';	at: 'htm' put: 'text/html';	at: 'xml' put: 'text/xml';	at: 'txt' put: 'text/plain';	at: 'c' put: 'text/plain';	at: 'gif' put: 'image/gif';	at: 'jpg' put: 'image/jpeg';	at: 'jpeg' put: 'image/jpeg';	at: 'gif' put: 'image/gif';	at: 'png' put: 'image/png';	at: 'pnm' put: 'image/pnm';	at: 'xbm' put: 'image/x-xbitmap';	at: 'mid' put: 'audio/midi';	at: 'doc' put: 'application/ms-word-document'.	^d! !!ServerDirectory methodsFor: 'updates' stamp: 'rbb 2/18/2005 14:33'!copyUpdatesNumbered: selectList toVersion: otherVersion	"Into the section of updates.list corresponding to otherVersion,	copy all the fileNames from this version matching the selectList.""		(ServerDirectory serverInGroupNamed: 'Disney Internal Updates*')			copyUpdatesNumbered: #(4411 4412) to version: 'Squeak3.1beta'."	| myServers updateStrm seq indexPrefix listContents version versIndex lastNum otherVersIndex additions outOfOrder |	self openGroup.	indexPrefix := (self groupName includes: $*) 		ifTrue: [(self groupName findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers := self checkServersWithPrefix: indexPrefix					andParseListInto: [:x | listContents := x].	myServers size = 0 ifTrue: [self closeGroup.  ^ self].	version := SystemVersion current version.	versIndex := (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	otherVersIndex := (listContents collect: [:pair | pair first]) indexOf: otherVersion.	otherVersIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for the target version'.		self closeGroup.  ^ nil].	"abort"	versIndex < listContents size ifTrue:		[(self confirm: 'This system, ', version ,				' is not the latest version.\OK to copy updates from that old version?' withCRs)			ifFalse: [self closeGroup.  ^ nil]].	"abort"	"Append all fileNames in my list that are not in the export list"	additions := OrderedCollection new.	outOfOrder := OrderedCollection new.	lastNum := (listContents at: otherVersIndex) last isEmpty		ifTrue: [0]  "no checking if the current list is empty"		ifFalse: [(listContents at: otherVersIndex) last last initialIntegerOrNil].	(listContents at: versIndex) last do:		[:fileName | seq := fileName initialIntegerOrNil.		(selectList includes: seq) ifTrue:			[seq > lastNum				ifTrue: [additions addLast: fileName]				ifFalse: [outOfOrder addLast: seq]]].	outOfOrder isEmpty ifFalse:		[UIManager default inform: 'Updates numbered ' , outOfOrder asArray printString,		' are out of order.\ The last update in ' withCRs,		otherVersion, ' is ', lastNum printString,		'.\No update will take place.' withCRs.		self closeGroup.  ^ nil].	"abort"	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: indexPrefix , 'updates.list.bk'.	Utilities writeList: listContents toStream: (FileStream fileNamed: indexPrefix , 'updates.list.bk').	"Write a new copy of updates.list on all servers..."	listContents at: otherVersIndex put:		{otherVersion. (listContents at: otherVersIndex) last , additions}.	updateStrm := ReadStream on:		(String streamContents: [:s | Utilities writeList: listContents toStream: s]).	myServers do:		[:aServer |		updateStrm reset.		aServer putFile: updateStrm named: indexPrefix , 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', aServer moniker; cr].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.! !!SuperSwikiServer methodsFor: 'testing' stamp: 'ar 8/24/2001 15:12'!parseQueryResult: resultStream	| projectInfos projectName  downloadUrl |	projectInfos := OrderedCollection new.	downloadUrl := self downloadUrl.	resultStream reset; nextLine.	[resultStream atEnd] whileFalse: [		projectName := resultStream nextLine.		projectInfos add: projectName.		"Transcript show: projectName; cr."		].	"Transcript show: 'done'; cr."	^projectInfos! !!MIMEHeaderValue class methodsFor: 'instance creation' stamp: 'mdr 4/11/2001 12:02'!fromTraditionalHeader: aString	"This is a traditional non-MIME header (like Subject:) and so should be stored whole"	| newValue |	newValue := self new.	newValue mainValue: aString.	newValue parameters: #().	^newValue.! !!SocketStream methodsFor: 'stream out' stamp: 'gk 2/10/2005 11:14'!nextPutAllFlush: aCollection	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self flush. "first flush pending stuff, then directly send"	socket isOtherEndClosed ifFalse: [		[socket sendData: toPut count: toPut size]			on: ConnectionTimedOut			do: [:ex | shouldSignal ifFalse: ["swallow"]]]! !!SocksSocket methodsFor: 'initialize' stamp: 'mir 9/26/2000 00:05'!socks5	vers := 5.	method := self class noAutorizationMethod.	socksIP := self class defaultSocksHostAddress.	socksPort := self class defaultSocksPort! !!URI class methodsFor: 'instance creation' stamp: 'mir 2/20/2002 17:07'!fromString: aString	| parseString scheme |	parseString := aString withBlanksTrimmed.	scheme := self extractSchemeFrom: parseString.	^scheme		ifNil: [HierarchicalURI new relativeFromString: aString]		ifNotNil: [self absoluteFromString: aString scheme: scheme]! !!UUID methodsFor: 'converting' stamp: 'JMM 11/22/2001 13:13'!createStringStartingAt: index for: bytes	| results candidate data |	data := String new: bytes*2.	results := WriteStream on: data.	index to: index+bytes -1 do: 		[:i |		candidate := ((self at: i) printStringBase: 16) last: 2.		candidate first = $r ifTrue: [candidate := String with: $0 with: candidate last].		results nextPutAll: candidate].	^data asLowercase! !!MailComposition methodsFor: 'interface' stamp: 'mdr 4/10/2001 14:27'!addAttachment	| file fileResult fileName |	textEditor		ifNotNil: [self hasUnacceptedEdits ifTrue: [textEditor accept]].	(fileResult := StandardFileMenu oldFile)		ifNotNil: 			[fileName := fileResult directory fullNameFor: fileResult name.			file := FileStream readOnlyFileNamed: fileName.			file ifNotNil:				[file binary.				self messageText:						((MailMessage from: self messageText asString)							addAttachmentFrom: file withName: fileResult name; text).				file close]] ! !!UUID methodsFor: 'converting' stamp: 'JMM 11/22/2001 13:09'!asUUID: aString	| stream token byte |	stream := ReadStream on: (aString copyReplaceAll: '-' with: '') asUppercase.	1 to: stream size/2 do: [:i | 		token := stream next: 2.		byte := Integer readFrom: (ReadStream on: token ) base: 16.		self at: i put: byte].	^self! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 11:36'!waitForResolverReadyUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is not busy, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status := self resolverStatus.	status = ResolverUninitialized ifTrue: [^ false].	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status := self resolverStatus].	^ status ~= ResolverBusy! !!ConnectionRefused methodsFor: 'accessing' stamp: 'len 12/14/2002 11:39'!host: addressOrHostName port: portNumber	host := addressOrHostName.	port := portNumber! !!SocketStream methodsFor: 'stream out' stamp: 'gk 2/7/2005 22:51'!nextPutAll: aCollection	"Put a String or a ByteArray onto the stream.	Currently a large collection will allocate a large buffer."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self adjustOutBuffer: toPut size.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + toPut size - 1 with: toPut startingAt: 1.	outNextToWrite := outNextToWrite + toPut size.	self checkFlush! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!semaphoreForGenerator: aSema	semaphoreForGenerator := aSema! !!ServerDirectory methodsFor: 'file directory' stamp: 'mir 12/8/2003 14:17'!exists	"It is difficult to tell if a directory exists.  This is ugly, but it works for writable directories.  http: will fall back on ftp for this"	| probe success |	success := false.	self isTypeFile ifTrue: [		self entries size > 0 ifTrue: [^ true].		probe := self newFileNamed: 'withNoName23'. 		probe ifNotNil: [			probe close.			probe directory deleteFileNamed: probe localName].		^success := probe notNil].	[client := self openFTPClient.	[client pwd]		ensure: [self quit].		success := true]		on: Error		do: [:ex | ].	^success! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'tao 6/22/1999 07:56'!getResponseUpTo: markerString ignoring: ignoreString	"Keep reading, until the marker is seen, skipping characters in ignoreString when      comparing to the marker.  Return three parts: header, marker, beginningOfData.     Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm skipped |	buf := String new: 2000.	response := WriteStream on: buf.	tester := 1. mm := 1.	skipped := 0.	[tester := tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifFalse:			[[ignoreString includes: (markerString at: mm)] whileTrue:				[mm := mm + 1. skipped := skipped + 1]].		(buf at: tt) = (markerString at: mm)			ifTrue: [mm := mm + 1]			ifFalse: [mm := 1. skipped := 0].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm+skipped)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester := 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead := self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'mir 5/30/2001 15:28'!fetchExternalSettingsIn: aDirectory	"Scan for server configuration files"	"ServerDirectory fetchExternalSettingsIn: (FileDirectory default directoryNamed: 'prefs')"	| serverConfDir stream |	(aDirectory directoryExists: self serverConfDirectoryName)		ifFalse: [^self].	self resetLocalProjectDirectories.	serverConfDir := aDirectory directoryNamed: self serverConfDirectoryName.	serverConfDir fileNames do: [:fileName |		stream := serverConfDir readOnlyFileNamed: fileName.		stream			ifNotNil: [				[self parseServerEntryFrom: stream] ifError: [:err :rcvr | ].				stream close]]! !!HttpUrl methodsFor: 'downloading' stamp: 'tk 9/22/1998 19:49'!privateInitializeFromText: aString relativeTo: aUrl	super privateInitializeFromText: aString relativeTo: aUrl.	realm := aUrl realm.! !!OldSocket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:47'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle := self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore := writeSemaphore := semaphore := nil	] ifFalse:[self register].! !!FileUrl methodsFor: 'private-initialization' stamp: 'gk 2/10/2004 13:05'!host: aHostString pathParts: aCollection isAbsolute: aBoolean	host := aHostString.	path := aCollection.	isAbsolute := aBoolean! !!ServerDirectory class methodsFor: 'misc' stamp: 'kfr 7/18/2003 11:18'!parseFTPEntry: ftpEntry	| tokens longy dateInSeconds thisYear thisMonth |	thisYear := Date today year.	thisMonth := Date today monthIndex.	tokens := ftpEntry findTokens: ' '. 	tokens size = 8 ifTrue:		[((tokens at: 6) size ~= 3 and: [(tokens at: 5) size = 3]) ifTrue:			["Fix for case that group is blank (relies on month being 3 chars)"			tokens := tokens copyReplaceFrom: 4 to: 3 with: {'blank'}]].	tokens size >= 9 ifFalse:[^nil].	((tokens at: 6) size ~= 3 and: [(tokens at: 5) size = 3]) ifTrue:		["Fix for case that group is blank (relies on month being 3 chars)"		tokens := tokens copyReplaceFrom: 4 to: 3 with: {'blank'}].	tokens size > 9 ifTrue:		[longy := tokens at: 9.		10 to: tokens size do: [:i | longy := longy , ' ' , (tokens at: i)].		tokens at: 9 put: longy].	dateInSeconds := self		secondsForDay: (tokens at: 7) 		month: (tokens at: 6) 		yearOrTime: (tokens at: 8) 		thisMonth: thisMonth 		thisYear: thisYear. 	^DirectoryEntry name: (tokens last)  "file name"		creationTime: dateInSeconds "creation date"		modificationTime: dateInSeconds "modification time"		isDirectory:( (tokens first first) = $d or: [tokens first first =$l]) "is-a-directory flag"		fileSize: tokens fifth asNumber "file size"! !!SuperSwikiServer methodsFor: 'for real' stamp: 'RAA 2/16/2001 18:22'!sendToSwikiProjectServer: anArray	| argsDict answer buildStream |	buildStream := WriteStream on: String new.	anArray do: [ :each | 		buildStream 			nextPutAll: each size printString;			space;			nextPutAll: each	].	(argsDict := Dictionary new)		at: 'swikicommands'		put: {buildStream contents}.	answer := HTTPSocket 		httpPostToSuperSwiki: self url		args: argsDict		accept: 'application/octet-stream' 		request: ''.	^(answer isKindOf: MIMEDocument) ifTrue: [answer content] ifFalse: [answer]! !!OldSocket methodsFor: 'primitives' stamp: 'ar 7/18/2000 11:42'!primSocket: socketID setOption: aString value: aStringValue	"Set some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP:=NODELAY, SO:=KEEPALIVE are valid options for example	returns an array containing the error code and the negotiated value"	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	^nil! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'al 1/8/2004 12:27'!proxyUser: userName password: password	"Store  HTTP 1.0 basic authentication credentials	Note: this is an ugly hack that stores your password	in your image.  It's just enought to get you going	if you use a firewall that requires authentication"    | stream encodedStream |	stream := ReadWriteStream on: (String new: 16).	stream nextPutAll: userName ,':' , password.	encodedStream := Base64MimeConverter mimeEncode: stream.	HTTPProxyCredentials := 'Proxy-Authorization: Basic ' , (encodedStream contents) , String crlf! !!MailAddressToken methodsFor: 'private' stamp: 'ls 9/12/1998 20:24'!type: type0  text: text0	type := type0.	text := text0.! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/19/1998 13:35'!readWrite	"Set the receiver to be writable"	rwmode := true! !!ServerDirectory methodsFor: 'updates' stamp: 'mir 6/26/2001 12:07'!updateInstallVersion: newVersion	"For each server group, ask whether we want to put the new version marker (eg 'Squeak2.3') at the end of the file.  Current version of Squeak must be the old one when this is done.		ServerDirectory new updateInstallVersion: 'Squeak9.9test'"	| myServers updateStrm names choice indexPrefix listContents version versIndex |	[names := ServerDirectory groupNames asSortedArray.	choice := (SelectionMenu labelList: names selections: names) startUp.	choice == nil]		whileFalse:		[indexPrefix := (choice endsWith: '*') 			ifTrue: [(choice findTokens: ' ') first]	"special for internal updates"			ifFalse: ['']. 	"normal"		myServers := (ServerDirectory serverInGroupNamed: choice)						checkServersWithPrefix: indexPrefix						andParseListInto: [:x | listContents := x].		myServers size = 0 ifTrue: [^ self].		version := SystemVersion current version.		versIndex := (listContents collect: [:pair | pair first]) indexOf: version.		versIndex = 0 ifTrue:			[^ self inform: 'There is no section in updates.list for your version'].  "abort"		"Append new version to updates following my version"		listContents := listContents copyReplaceFrom: versIndex+1 to: versIndex with: {{newVersion. {}}}.		updateStrm := ReadStream on:			(String streamContents: [:s | Utilities writeList: listContents toStream: s]).		myServers do:			[:aServer | updateStrm reset.			aServer putFile: updateStrm named: indexPrefix ,'updates.list'.			Transcript cr; show: indexPrefix ,'updates.list written on server ', aServer moniker].		self closeGroup]! !!SocketStream methodsFor: 'stream in' stamp: 'gk 9/9/2005 02:55'!upToAll: aStringOrByteArray	"Answer a subcollection from the current access position to the occurrence (if any, but not	inclusive) of aStringOrByteArray. If aCollection is not in the stream, answer the entire rest of	the stream.		NOTE: Does not honour timeouts if shouldSignal is false!!		This method looks a bit complicated, and this is mainly because there is no fast search method	in String that takes a stoppingAt: argument. This means we need to ignore getting hits in the	dead buffer area above inNextToWrite.	Another measure is that this implementation is greedy and will load data into the buffer	until there is nothing more available, or it has loaded 100kb - and not until then we search the buffer.	A totally non greedy variant would search on every loop."	| index sz result lastRecentlyRead searchedSoFar |	sz := aStringOrByteArray size.	searchedSoFar := 0.	lastRecentlyRead := 0.	index := 0.	[self atEnd not and: [		((lastRecentlyRead = 0 and: [self isInBufferEmpty not]) or: [self inBufferSize > 100000]) ifTrue: [			"Data begins at lastRead + 1, we add searchedSoFar as offset and backs up sz - 1			so that we can catch any borderline hits."			index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: lastRead + searchedSoFar - sz + 2.			searchedSoFar := self inBufferSize.			(index > 0 and: [(index + sz) > inNextToWrite]) ifTrue: [				"Oops, hit partially or completely in dead buffer area.				This is probably due to old data, so we ignore it.				No point in cleaning the dead area to avoid hits - it will still search it."				index := 0]].		index = 0]]				whileTrue: [					recentlyRead = 0						ifTrue: ["blocking call for now, we don't want to poll"							self receiveData]						ifFalse: [							self receiveAvailableData].					lastRecentlyRead := recentlyRead].	index > 0		ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result]		ifFalse: ["atEnd"			^ self nextAllInBuffer]! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'CdG 11/19/2002 21:30'!setupRandom	randomCounter := 0.	randomGenerator := Random seed: self makeSeed.! !!SocketStream methodsFor: 'private' stamp: 'gk 2/9/2005 22:36'!resetBuffers	"Recreate the buffers with default start sizes."	inBuffer := self streamBuffer: bufferSize.	lastRead := 0.	inNextToWrite := 1.	outBuffer := self streamBuffer: bufferSize.	outNextToWrite := 1! !!MIMEHeaderValue methodsFor: 'accessing' stamp: 'dvf 4/27/2000 18:13'!mainValue: anObject	mainValue := anObject! !!Socket class methodsFor: 'utilities' stamp: 'mir 2/22/2002 15:49'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.cs.uiuc.edu' timeOutSecs: 15"	| serverAddr sockets sock deadline done unconnectedCount connectedCount waitingCount result |	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		self inform: 'Could not find an address for ', hostName.		^ #()].	sockets := portList collect: [:portNum |		sock := Socket new.		sock connectTo: serverAddr port: portNum].	deadline := self deadlineSecs: timeOutSecs.	done := false.	[done] whileFalse: [		unconnectedCount := 0.		connectedCount := 0.		waitingCount := 0.		sockets do: [:s |			s isUnconnectedOrInvalid				ifTrue: [unconnectedCount := unconnectedCount + 1]				ifFalse: [					s isConnected ifTrue: [connectedCount := connectedCount + 1].					s isWaitingForConnection ifTrue: [waitingCount := waitingCount + 1]]].		waitingCount = 0 ifTrue: [done := true].		connectedCount = sockets size ifTrue: [done := true].		Time millisecondClockValue > deadline ifTrue: [done := true]].	result := (sockets select: [:s | s isConnected])		collect: [:s | self nameForWellKnownTCPPort: s remotePort].	sockets do: [:s | s destroy].	^ result! !!HierarchicalURI methodsFor: 'private' stamp: 'mir 2/26/2002 14:13'!extractSchemeSpecificPartAndFragment: remainder	super extractSchemeSpecificPartAndFragment: remainder.	schemeSpecificPart := self extractQuery: schemeSpecificPart! !!Socket methodsFor: 'sending' stamp: 'mir 5/15/2003 18:33'!sendData: aStringOrByteArray	"Send all of the data in the given array, even if it requires multiple calls to send it all. Return the number of bytes sent."	"An experimental version use on slow lines: Longer timeout and smaller writes to try to avoid spurious timeouts."	| bytesSent bytesToSend count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneFor: 60)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendData: aStringOrByteArray			startIndex: bytesSent + 1			count: (bytesToSend - bytesSent min: 5000).		bytesSent := bytesSent + count].	^ bytesSent! !!Url class methodsFor: 'parsing' stamp: 'gk 10/21/2005 10:41'!schemeNameForString: aString	"Get the scheme name from a string, or return nil if it's not specified. 	Used in internal parsing routines - an outsider may as well use asUrl. 	Return scheme in lowercases."		"Url schemeNameForString: 'http://www.yahoo.com'"	"Url schemeNameForString: '/etc/passwed'"	"Url schemeNameForString: '/etc/testing:1.2.3'"	| index schemeName |	index := aString indexOf: $: ifAbsent: [^ nil].	schemeName := aString first: index - 1.	(schemeName allSatisfy: [:each | each isLetter]) ifFalse: [^ nil].	^ schemeName asLowercase! !!ServerDirectory methodsFor: 'server groups' stamp: 'mir 6/26/2001 12:13'!groupName: groupName	group := groupName! !!HTTPSocket class methodsFor: 'utilities' stamp: 'ar 4/10/2005 18:47'!argStringUnencoded: args	"Return the args in a long string, as encoded in a url"	| argsString first |	args isString ifTrue: ["sent in as a string, not a dictionary"		^ (args first = $? ifTrue: [''] ifFalse: ['?']), args].	argsString := WriteStream on: String new.	argsString nextPut: $?.	first := true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first := false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key.			argsString nextPut: $=.			argsString nextPutAll: value. ] ].	^ argsString contents! !!OldSocket methodsFor: 'connection open/close' stamp: 'ikp 9/1/2003 20:47'!listenOn: portNumber backlogSize: backlog interface: ifAddr	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog interface: ifAddr.! !!OldSocket methodsFor: 'sending-receiving' stamp: 'ar 7/20/1999 17:23'!sendData: buffer count: n	"Send the amount of data from the given buffer"	| sent |	sent := 0.	[sent < n] whileTrue:[		sent := sent + (self sendSomeData: buffer startIndex: sent+1 count: (n-sent))].! !!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString relativeTo: aUrl	schemeName := aUrl schemeName.	locator := aString.! !!GenericUrl class methodsFor: 'parsing' stamp: 'ls 7/26/1998 21:24'!absoluteFromText: aString	| schemeName locator |	schemeName := Url schemeNameForString: aString.	schemeName ifNil: [ ^self schemeName: 'xnoscheme' locator: aString ].	locator := aString copyFrom: (schemeName size + 2) to: aString size.	^self schemeName: schemeName locator: locator! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:08'!asServerFileNamed: aName	| rFile |	rFile := self as: ServerFile.	(aName includes: self pathNameDelimiter)		ifTrue: [rFile fullPath: aName]			"sets server, directory(path), fileName.  If relative, merge with self."		ifFalse: [rFile fileName: aName].	"JUST a single NAME, already have the rest"			"Mac files that include / in name, must encode it as %2F "	^rFile! !!SuperSwikiServer methodsFor: 'testing' stamp: 'ar 7/8/2001 17:06'!speedTest2"SuperSwikiServer testOnlySuperSwiki speedTest2""==observed results10 forks of 10 reads of 88K in 12.7 seconds100 * 88110 / 12.7 ===> 693779 bytes per second---10 forks of 10 reads of 88K in 10.7 seconds100 * 88110 / 10.7 ===> 823457 bytes per second---at priority 510 forks of 10 reads of 88K in 9.8 seconds100 * 88110 / 9.8 ===> 899081 bytes per second==="	| answer bigAnswer tRealBegin tRealEnd |	bigAnswer := SharedQueue new.	tRealBegin := tRealEnd := Time millisecondClockValue.	10 timesRepeat: [		[			answer := SuperSwikiServer testOnlySuperSwiki speedTest1.			tRealEnd := Time millisecondClockValue.			bigAnswer nextPut: {				{tRealBegin. tRealEnd. tRealEnd - tRealBegin}.				answer			}.		] forkAt: Processor userInterruptPriority.	].	bigAnswer inspect.! !!SMTPClient class methodsFor: 'sending mail' stamp: 'mir 2/22/2002 12:30'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"Deliver a single email to a list of users and then close the connection.  For delivering multiple messages, it is best to create a single connection and send all mail over it.  NOTE: the recipient list should be a collection of simple internet style addresses -- no '<>' or '()' stuff"	| smtpClient |	smtpClient := self openOnHostNamed: serverName.	[smtpClient mailFrom: fromAddress to: recipientList text: messageText.	smtpClient quit]		ensure: [smtpClient close]! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 16:50'!getFileList	| dirList |	self openPassiveDataConnection.	self sendCommand: 'NLST'.	dirList := self getData.	self checkResponse.	self checkResponse.	^dirList! !!HTTPServerDirectory methodsFor: 'file directory' stamp: 'mir 4/16/2001 17:54'!oldFileNamed: aName	|  contents |	contents := HTTPLoader default retrieveContentsFor: (self altUrl , '/' , aName).	^(SwikiPseudoFileStream with: contents content)		reset;		directory: self;		localName: aName;		yourself! !!SwikiPseudoFileStream methodsFor: 'as yet unclassified' stamp: 'RAA 10/17/2000 14:53'!directory: x	directory := x! !!NetNameResolver class methodsFor: 'class initialization' stamp: 'jm 9/17/97 16:18'!initialize	"NetNameResolver initialize"	"Note: On the Mac, the name resolver is asynchronous (i.e., Squeak can do other things while it is working), but can only handle one request at a time. On other platforms, such as Unix, the resolver is synchronous; a call to, say, the name lookup primitive will block all Squeak processes until it returns."	"Resolver Status Values"	ResolverUninitialized := 0.	"network is not initialized"	ResolverReady := 1.			"resolver idle, last request succeeded"	ResolverBusy := 2.			"lookup in progress"	ResolverError := 3.			"resolver idle, last request failed"	DefaultHostName := ''.! !!OldSimpleClientSocket class methodsFor: 'POP mail example' stamp: 'jm 9/15/97 14:47'!extractDateFromAndSubjectFromHeader: headerString	| date from subject s lineBuf c line i |	date := from := subject := ''.	s := ReadStream on: headerString.	lineBuf := WriteStream on: ''.	[s atEnd] whileFalse: [		c := s next.		c = CR			ifTrue: [				line := lineBuf contents.				(line beginsWith: 'Date: ')	ifTrue: [date := line copyFrom: 7 to: line size].				(line beginsWith: 'From: ')	ifTrue: [from := line copyFrom: 7 to: line size].				(line beginsWith: 'Subject: ')	ifTrue: [subject := line copyFrom: 10 to: line size].				lineBuf := WriteStream on: '']			ifFalse: [lineBuf nextPut: c]].	i := date indexOf: $' ifAbsent: [0].	date := date copyFrom: i + 1 to: date size.	^ (self simpleDateString: date), ', ', from, ':  ', subject! !!FileUrl methodsFor: 'downloading' stamp: 'ASF 4/30/2005 16:37'!retrieveContents	| file pathString s type entries |	pathString := self pathForFile.	file := [FileStream readOnlyFileNamed: pathString] 			on: FileDoesNotExistException do:[:ex| ex return: nil].	file ifNotNil: [		type := file mimeTypes.		type ifNotNil:[type := type first].		type ifNil:[type := MIMEDocument guessTypeFromName: self path last].		^MIMELocalFileDocument 			contentType: type			contentStream: file].	"see if it's a directory..."	entries := [(FileDirectory on: pathString) entries] 				on: InvalidDirectoryError do:[:ex| ex return: nil].	entries ifNil:[^nil].	s := WriteStream on: String new.	(pathString endsWith: '/') ifFalse: [ pathString := pathString, '/' ].	s nextPutAll: '<title>Directory Listing for ', pathString, '</title>'.	s nextPutAll: '<h1>Directory Listing for ', pathString, '</h1>'.	s nextPutAll: '<ul>'.	s cr.	entries do: [ :entry |		s nextPutAll: '<li><a href="'.		s nextPutAll: entry name.		s nextPutAll: '">'.		s nextPutAll: entry name.		s nextPutAll: '</a>'.		s cr. ].	s nextPutAll: '</ul>'.	^MIMEDocument  contentType: 'text/html'  content: s contents  url: ('file://', pathString)! !!MailMessage methodsFor: 'initialize-release' stamp: 'mdr 4/11/2001 11:58'!from: aString 	"Parse aString to initialize myself."	| parseStream contentType bodyText contentTransferEncoding |	text := aString withoutTrailingBlanks, String cr.	parseStream := ReadStream on: text.	contentType := 'text/plain'.	contentTransferEncoding := nil.	fields := Dictionary new.	"Extract information out of the header fields"	self fieldsFrom: parseStream do: 		[:fName :fValue | 		"NB: fName is all lowercase"		fName = 'content-type' ifTrue: [contentType := (fValue copyUpTo: $;) asLowercase].		fName = 'content-transfer-encoding' ifTrue: [contentTransferEncoding := fValue asLowercase].		(fields at: fName ifAbsentPut: [OrderedCollection new: 1])			add: (MIMEHeaderValue forField: fName fromString: fValue)].	"Extract the body of the message"	bodyText := parseStream upToEnd.	contentTransferEncoding = 'base64'		ifTrue: 			[bodyText := Base64MimeConverter mimeDecodeToChars: (ReadStream on: bodyText).			bodyText := bodyText contents].	contentTransferEncoding = 'quoted-printable' ifTrue: [bodyText := bodyText decodeQuotedPrintable].	body := MIMEDocument contentType: contentType content: bodyText! !!FileUrl methodsFor: 'private-initialization' stamp: 'gk 2/12/2004 16:29'!privateInitializeFromText: pathString relativeTo: aUrl	"<pathString> should be a filesystem path.	This url is adjusted to be aUrl + the path."	| bare newPath |	self host: aUrl host.	self initializeFromPathString: pathString.	self isAbsolute: aUrl isAbsolute.	newPath := aUrl path copy.	newPath removeLast.	"empty string that says its a directory"	path do: [ :token |		((token ~= '..') and: [token ~= '.']) ifTrue: [ 			newPath addLast: token unescapePercents ].		token = '..' ifTrue: [ 			newPath isEmpty ifFalse: [ 				newPath last = '..' ifFalse: [ newPath removeLast ] ] ].		"token = '.' do nothing" ].	path := newPath	! !!SuperSwikiServer methodsFor: 'testing' stamp: 'RAA 10/18/2000 12:23'!queryProjectsAndShow: thingsToSearchFor	| result |"SuperSwikiServer testOnlySuperSwiki queryProjectsAndShow"	result := self sendToSwikiProjectServer: {		'action: findproject'.	}, thingsToSearchFor.	(result beginsWith: 'OK') ifFalse: [^self inform: result printString].	self showQueryAsPVM: (ReadStream on: result).! !!OldSocket methodsFor: 'connection open/close' stamp: 'ar 7/16/1999 18:26'!listenOn: portNumber backlogSize: backlog	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.! !!IllegalURIException methodsFor: 'accessing' stamp: 'mir 2/20/2002 17:20'!uriString: aString	uriString := aString! !!OldSocket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle == nil ifTrue: [^ true].	status := self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:54'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil ifFalse: 		[self isValid ifTrue: [self primSocketDestroy: socketHandle].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle := nil.		readSemaphore := writeSemaphore := semaphore := nil.		self unregister].! !!Socket methodsFor: 'receiving' stamp: 'gk 12/14/2005 10:02'!discardReceivedData	"Discard any data received up until now, and return the number of bytes discarded."	| buf totalBytesDiscarded |	buf := String new: 10000.	totalBytesDiscarded := 0.	[self isConnected] whileTrue: [		totalBytesDiscarded :=			totalBytesDiscarded + (self receiveDataInto: buf)].	^ totalBytesDiscarded! !!SocketStream methodsFor: 'control' stamp: 'gk 9/9/2005 09:33'!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	((outNextToWrite > 1) and: [socket isOtherEndClosed not])		ifTrue: [			[socket sendData: outBuffer count: outNextToWrite - 1]				on: ConnectionTimedOut				do: [:ex | shouldSignal ifFalse: ["swallow"]].			outNextToWrite := 1]! !!OldSimpleClientSocket class methodsFor: 'other examples' stamp: 'mir 5/13/2003 10:45'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.disney.com' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr := NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s := OldSimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 10).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result := WriteStream on: (String new: 10000).	buf := String new: 10000.	totalBytes := 0.	t := Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes := s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes := totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !!URIAuthority methodsFor: 'private' stamp: 'mir 2/25/2002 19:04'!fromString: authorityString	| userInfoEnd remainder hostEnd |	userInfoEnd := authorityString indexOf: $@.	remainder := userInfoEnd > 0		ifTrue: [			userInfo := authorityString copyFrom: 1 to: userInfoEnd-1.			authorityString copyFrom: userInfoEnd+1 to: authorityString size]		ifFalse: [authorityString].	hostEnd := remainder indexOf: $: .	hostEnd > 0		ifTrue: [			host := remainder copyFrom: 1 to: hostEnd-1.			port := (remainder copyFrom: hostEnd+1 to: remainder size) asNumber]		ifFalse: [host := remainder]! !!ServerDirectory methodsFor: 'updates' stamp: 'rbb 2/18/2005 14:42'!putUpdate: fileStrm	"Put this file out as an Update on the servers of my group.  Each version of the system may have its own set of update files, or they may all share the same files.  'updates.list' holds the master list.  Each update is a fileIn whose name begins with a number.  See Utilities class readServerUpdatesThrough:saveLocally:updateImage:.	When two sets of updates are stored on the same directory, one of them has a * in its serverUrls description.  When that is true, the first word of the description is put onthe front of 'updates.list', and that index file is used."	| myServers updateStrm newName response localName seq indexPrefix listContents version versIndex lastNum stripped |	localName := fileStrm localName.	fileStrm size = 0 ifTrue:		[^ self inform: 'That file has zero bytes!!  May have a new name.'].	(fileStrm contentsOfEntireFile includes: Character linefeed)		ifTrue: [self notifyWithLabel:  'That file contains linefeeds.  Proceed if...you know that this is okay (e.g. the file contains raw binary data).'].	fileStrm reset.	(self checkNames: {localName}) ifFalse: [^ nil].	"illegal characters"	response := UIManager default chooseFrom: #('Install update' 'Cancel update')		title: 'Do you really want to broadcast the file ', localName, 			'\to every Squeak user who updates from ' withCRs, self groupName, '?'.	response = 1 ifFalse: [^ nil].	"abort"	self openGroup.	indexPrefix := (self groupName includes: $*) 		ifTrue: [(self groupName findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers := self checkServersWithPrefix: indexPrefix					andParseListInto: [:x | listContents := x].	myServers size = 0 ifTrue: [self closeGroup.  ^ self].	version := SystemVersion current version.	versIndex := (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	"A few affirmations..."	versIndex < listContents size ifTrue:		[(self confirm: 'This system, ', version ,				' is not the latest version.\Make update for an older version?' withCRs)			ifFalse: [self closeGroup.  ^ nil]].	"abort"	(listContents at: versIndex) last isEmpty ifTrue:		[(self confirm: 'Please confirm that you mean to issue the first update for ' ,						version , '\(otherwise something is wrong).' withCRs)			ifFalse: [self closeGroup.  ^ nil]].	"We now determine next update number to be max of entire index"	lastNum := listContents inject: 0 into:		[:max :pair | pair last isEmpty					ifTrue: [max]					ifFalse: [max max: pair last last initialIntegerOrNil]].	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: indexPrefix , 'updates.list.bk'.	Utilities writeList: listContents toStream: (FileStream fileNamed: indexPrefix , 'updates.list.bk').	"append name to updates with new sequence number"	seq := (lastNum + 1) printString padded: #left to: 4 with: $0.	"strip off any old seq number"	stripped := localName copyFrom: (localName  findFirst: [:c | c isDigit not]) to: localName size.	newName := seq , stripped.	listContents at: versIndex put:		{version. (listContents at: versIndex) last copyWith: newName}.	"Write a new copy on all servers..."	updateStrm := ReadStream on:		(String streamContents: [:s | Utilities writeList: listContents toStream: s]).	myServers do:		[:aServer |		fileStrm reset.	"reopen"		aServer putFile: fileStrm named: newName retry: true.		updateStrm reset.		aServer putFile: updateStrm named: indexPrefix , 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', aServer moniker; cr].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.	"rename the file locally (may fail)"	fileStrm directory rename: localName toBe: newName.! !!OldSimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/11/1998 03:34'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response := WriteStream on: ''.	done := false.	[done] whileFalse: [		showFlag			ifTrue: [chunk := self getResponseShowing: true]			ifFalse: [chunk := self getResponse].		(chunk beginsWith: '.')			ifTrue: [ response nextPutAll: (chunk copyFrom: 2 to: chunk size) ]			ifFalse: [ response nextPutAll: chunk ].		done := (chunk = ('.', String cr)) ].	^ response contents! !!OldSocket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:51'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle == nil ifTrue: [^ false].	status := self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!MailAddressParser class methodsFor: 'parsing' stamp: 'ls 9/13/1998 01:34'!addressesIn: aString	"return a collection of the bare addresses listed in aString"	| tokens |	tokens := MailAddressTokenizer tokensIn: aString.	^(self new initialize: tokens) grabAddresses! !!FileUrl methodsFor: 'accessing' stamp: 'gk 2/12/2004 16:22'!host: hostName	"Set the host name, either 'localhost', '', or a fully qualified domain name."		host := hostName! !!SuperSwikiServer methodsFor: 'for real' stamp: 'KR 1/30/2006 21:59'!fastParseEntriesFrom: aString	| c first strm xEntryName xCreationTime xModificationTime xIsDirectory xFileSize ch |	c := OrderedCollection new.	first := true.	aString linesDo: [ :x |		first ifFalse: [			strm := ReadStream on: x.			(strm upTo: $ ) = '(DirectoryEntry' ifFalse: [^nil].			(strm upTo: $ ) = 'name:' ifFalse: [^nil].			xEntryName := WriteStream on: String new.			strm next = $' ifFalse: [^nil].			[				ch := strm next.				ch = $' and: [(strm peekFor: $') not]			] whileFalse: [				xEntryName nextPut: ch.			].			xEntryName := xEntryName contents.			strm skipSeparators.			(strm upTo: $ ) = 'creationTime:' ifFalse: [^nil].			xCreationTime := (strm upTo: $ ) asNumber.			(strm upTo: $ ) = 'modificationTime:' ifFalse: [^nil].			xModificationTime := (strm upTo: $ ) asNumber.			(strm upTo: $ ) = 'isDirectory:' ifFalse: [^nil].			xIsDirectory := (strm upTo: $ ) = 'true'.			(strm upTo: $ ) = 'fileSize:' ifFalse: [^nil].			xFileSize := (strm upTo: $ ) asNumber.			c add: (DirectoryEntry 				name: (xEntryName convertFromEncoding: self encodingName)				creationTime: xCreationTime 				modificationTime: xModificationTime 				isDirectory: xIsDirectory 				fileSize: xFileSize			)		].		first := false.	].	^c! !!MIMELocalFileDocument methodsFor: 'accessing' stamp: 'ar 4/24/2001 16:27'!contentStream: aFileStream	contentStream := aFileStream.	content := nil.! !!OldSocket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:56'!deadServer: aStringOrNil	"Keep the machine name of the most recently encoutered non-responding machine.  Next time the user can move it to the last in a list of servers to try."	DeadServer := aStringOrNil! !!SocketStream methodsFor: 'private' stamp: 'gk 2/9/2005 22:42'!adjustOutBuffer: bytesToWrite	"Possibly grow outBuffer to accommodate the new data.	Currently grows through doubling when less	than 1024 bytes are left. If bytesToWrite is even	larger we double that instead. Never shrinks."	(outBuffer size - outNextToWrite - bytesToWrite) < 1024 ifTrue: [		outBuffer := (self streamBuffer: ((outBuffer size max: bytesToWrite) * 2))						replaceFrom: 1 to: outBuffer size with: outBuffer startingAt: 1]! !!OldSocket class methodsFor: 'class initialization' stamp: 'ar 12/12/2001 19:12'!initialize	"Socket initialize"	"Socket Types"	TCPSocketType := 0.	UDPSocketType := 1.	"Socket Status Values"	InvalidSocket := -1.	Unconnected := 0.	WaitingForConnection := 1.	Connected := 2.	OtherEndClosed := 3.	ThisEndClosed := 4.	RegistryThreshold := 100. "# of sockets"! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'RAA 6/23/2000 09:45'!fullPath: serverAndDirectory	"Parse and save a full path.  Separate out fileName at the end."	| delim ii |	super fullPath: serverAndDirectory.		"set server and directory"	self isTypeFile ifTrue: [		fileName :=  ''.		^ self	].	delim := self pathNameDelimiter.	ii := directory findLast: [:c | c = delim].	ii = 0		ifTrue: [self error: 'expecting directory and fileName']		ifFalse: [fileName := directory copyFrom: ii+1 to: directory size.			directory := (directory copyFrom: 1 to: directory size - fileName size - 1)].! !!MailComposition methodsFor: 'access' stamp: 'yo 7/26/2004 22:47'!messageText: aText	"change the current text"	messageText := aText.	self changed: #messageText.	^true! !!Socket methodsFor: 'receiving' stamp: 'svp 9/23/2003 00:03'!receiveDataTimeout: timeout	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once."	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveDataTimeout: timeout into: buffer.	^buffer copyFrom: 1 to: bytesRead! !!SocksSocket class methodsFor: 'accessing' stamp: 'mir 9/26/2000 00:07'!defaultSocksVersion: anInteger	"nil means no socks"	DefaultSocksVersion := anInteger! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:35'!skipQualifiedHostName	| startTime response bytesRead |	startTime := Time millisecondClockValue.	response := ByteArray new: 1.	[(bytesRead := self receiveDataInto: response) < 1		and: [(Time millisecondClockValue - startTime) < self defaultTimeOutDuration]] whileTrue.	bytesRead < 1		ifTrue: [self socksError: 'Time out reading data'].	self waitForReply: (response at: 1) + 2 for: self defaultTimeOutDuration! !!FileUrl methodsFor: 'downloading' stamp: 'gk 2/10/2004 13:06'!default	"Use the default local Squeak file directory."		| local |	local := self class pathParts: (FileDirectory default pathParts), #('') isAbsolute: true.	self privateInitializeFromText: self pathString relativeTo: local.		"sets absolute also"! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 4/10/2005 18:48'!httpGif: url	"Fetch the given URL, parse it using the GIF reader, and return the resulting Form."	"	HTTPSocket httpShowGif: 'www.altavista.digital.com/av/pix/default/av-adv.gif'	 "	"	HTTPSocket httpShowGif: 'www.webPage.com/~kaehler2/ainslie.gif'	 "	| doc ggg |	doc := self httpGet: url accept: 'image/gif'.	doc isString ifTrue: [		self inform: 'The server with that GIF is not responding'.		^ ColorForm extent: 20@20 depth: 8].	doc binary; reset.	(ggg := GIFReadWriter new) setStream: doc.	^ ggg nextImage.! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 6/23/2000 09:30'!typeWithDefault	^ type ifNil: [type := #ftp]! !!Socket class methodsFor: 'tests' stamp: 'gk 12/15/2005 01:03'!newAcceptCheck	"Check if the platform has support for the BSD style accept()."	"Socket newAcceptCheck"		| socket |	self initializeNetwork.	socket := self newTCP.	socket listenOn: 44444 backlogSize: 4.	socket isValid ifTrue: [		self inform: 'Everything looks OK for the BSD style accept()'	] ifFalse: [		self inform: 'It appears that you DO NOT have support for the BSD style accept()'].	socket destroy! !!HTTPSocket class methodsFor: 'get the page' stamp: 'nk 8/30/2004 07:50'!httpGetNoError: url args: args accept: mimeType	"Return the exact contents of a web file.  Do better error checking.  Asks for the given MIME type.  To fetch raw data, you can use the MIMI type 'application/octet-stream'.  If mimeType is nil, use 'text/html'.  The parsed header is saved. Use a proxy server if one has been registered.""Edited to remove a lineFeed from the source 4/4/99 - di"	| document data |	document := self httpGetDocument: url  args: args  accept: mimeType.	(document isString) ifTrue: [		"strings indicate errors"		^ document ].	data := document content.	(data beginsWith: '<HTML><HEAD>' , (String with: Character linefeed) , '<TITLE>4')		ifTrue: ["an error message  404 File not found"				^ data copyFrom: 21 to: data size-16].		^ (RWBinaryOrTextStream with: data) reset! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/21/2001 14:30'!initialize	self setupRandom.	semaphoreForGenerator := Semaphore forMutualExclusion.	! !!OldSocket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 21:48'!primSocket: socketID getOption: aString 	"Get some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP:=NODELAY, SO:=KEEPALIVE are valid options for example	returns an array containing the error code and the option value"	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!ServerDirectory methodsFor: 'updates' stamp: 'rbb 2/18/2005 14:40'!checkServersWithPrefix: prefix andParseListInto: listBlock	"Check that all servers are up and have the latest Updates.list.	Warn user when can't write to a server that can still be read.	The contents of updates.list is parsed into {{vers. {fileNames*}}*},	and returned via the listBlock."	|  serverList updateLists listContents maxSize outOfDateServers |	serverList := self serversInGroup.	serverList isEmpty		ifTrue: [^Array new].	updateLists := Dictionary new.	serverList do: [:updateServer |		[listContents := updateServer getFileNamed: prefix , 'updates.list'.		updateLists at: updateServer put: listContents]			on: Error			do: [:ex | 				UIManager default chooseFrom: #('Cancel entire update')					title: 'Server ', updateServer moniker,					' is unavailable.\Please consider phoning the administator.\' withCRs, listContents.				^Array new]].	maxSize := (updateLists collect: [:each | each size]) max.	outOfDateServers := updateLists keys select: [:updateServer |		(updateLists at: updateServer) size < maxSize].	outOfDateServers do: [:updateServer |		(self outOfDate: updateServer) ifTrue: [^Array new]].	listBlock value: (Utilities parseListContents: listContents).	serverList removeAll: outOfDateServers.	^serverList! !!MIMEDocument class methodsFor: 'initialize-release' stamp: 'bolot 9/9/1999 16:48'!readMIMEdatabaseFrom: someStream	| d line tokens stream |	"type/subtype    extension"	"white spaces are separators"	"apache conf file format: mime.types"	"must normalize line endings"	stream := ReadStream on: someStream contentsOfEntireFile withSqueakLineEndings.	d := Dictionary new.	[(line := stream nextLine) isNil not]		whileTrue: [tokens := line findTokens: ' 	'.			(tokens size = 2 and: [line first ~= $#])				ifTrue: [d at: tokens second put: tokens first]].	^d! !!Socket methodsFor: 'connection open/close' stamp: 'mir 5/9/2003 18:13'!connectNonBlockingTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	self initializeNetwork.	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: hostAddress port: port.! !!HierarchicalURI methodsFor: 'private' stamp: 'mir 2/26/2002 14:13'!extractQuery: remainder	| queryIndex |	queryIndex := remainder indexOf: $?.	queryIndex > 0		ifFalse: [^remainder].	query := remainder copyFrom: queryIndex to: remainder size.	^remainder copyFrom: 1 to: queryIndex-1! !!ServerDirectory methodsFor: 'file directory' stamp: 'RAA 7/4/2000 10:08'!readOnlyFileNamed: aName	"If the file exists, answer a read-only RemoteFileStream on it.  aName is directory path, and does include name of the server.  Or it can just be a fileName.  For now, pre-read the file."	| rFile |	rFile := self asServerFileNamed: aName.	rFile readOnly.	rFile isTypeFile ifTrue: [		^ FileStream oldFileNamed: (rFile fileNameRelativeTo: self)].	^self streamOnBeginningOf: rFile! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:51'!nextQuotedString	| res c |	res := WriteStream on: String new.	res nextPut: self nextChar.   "record the starting quote"	[ self atEndOfChars ] whileFalse: [		c := self nextChar.		c = $\ ifTrue: [			res nextPut: c.			res nextPut: self nextChar ]		ifFalse: [			c = $" ifTrue: [				res nextPut: c.				^MailAddressToken type: #QuotedString  text: res contents ]			ifFalse: [				res nextPut: c ] ] ].	"hmm, never saw the final quote mark"	^MailAddressToken type: #QuotedString  text: (res contents, '"')! !!ServerDirectory methodsFor: 'accessing' stamp: 'KR 1/30/2006 22:15'!encodingName: aName	encodingName := aName! !!OldSocket methodsFor: 'datagrams' stamp: 'JMM 6/7/2000 14:58'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self receiveDataInto: aStringOrByteArray].	[true] whileTrue: 		[datagram := self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]]! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 14:49'!parseSensorStateString: aString	"Parse the given sensor stat string and return an array whose first element is the cursor point and whose second is the cursor button state."	"SimpleClientSocket parseSensorStateString: SimpleClientSocket sensorStateString"	| s buttons x y |	s := ReadStream on: aString.	x := Integer readFrom: s.	s skipSeparators.	y := Integer readFrom: s.	s skipSeparators.	buttons := Integer readFrom: s.	^ Array with: x@y with: buttons! !!OldSocket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:48'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations	ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for	reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore := true.	^ self primSocketCreateNetwork: netType			type: socketType			receiveBufferSize: rcvBufSize			sendBufSize: sendBufSize			semaIndex: semaIndex! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'md 11/14/2003 16:39'!header: headerText	"set the headers.  Then getHeader: can be used"	"divide into basic lines"	| lines foldedLines i statusLine |	lines := headerText findTokens: (String with: Character cr  with: Character linefeed).	statusLine := lines first.	lines := lines copyFrom: 2 to: lines size.	"parse the status (pretty trivial right now)"	responseCode := (statusLine findTokens: ' ') second.	"fold lines that start with spaces into the previous line"	foldedLines := OrderedCollection new.	lines do: [ :line |		line first isSeparator ifTrue: [			foldedLines at: foldedLines size  put: (foldedLines last, line) ]		ifFalse: [ foldedLines add: line ] ].	"make a dictionary mapping headers to header contents"	headers := Dictionary new.	foldedLines do: [ :line |		i := line indexOf: $:.		i > 0 ifTrue: [			headers 			at: (line copyFrom: 1 to: i-1) asLowercase 			put: (line copyFrom: i+1 to: line size) withBlanksTrimmed ] ].! !!FTPClient methodsFor: 'protocol' stamp: 'mir 2/20/2002 13:53'!getDirectory	| dirList |	self openPassiveDataConnection.	self sendCommand: 'LIST'.	dirList := self getData.	self checkResponse.	self checkResponse.	^dirList! !!SMTPClient methodsFor: 'private protocol' stamp: 'fbs 3/23/2004 17:16'!mailFrom: fromAddress	" MAIL <SP> FROM:<reverse-path> <CRLF>"	| address |	address := (MailAddressParser addressesIn: fromAddress) first.	self sendCommand: 'MAIL FROM: <', address, '>'.	self checkResponse.! !!ServerDirectory class methodsFor: 'server groups' stamp: 'mir 6/26/2001 12:11'!groupNames	"Return the names of all registered groups of servers, including individual servers not in any group."	"ServerDirectory groupNames"	| names |	names := Set new.	self servers do: [:server |		names add: server groupName].	^names asSortedArray! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:47'!contentsOfEntireFile	"Fetch the data off the server and store it in me.  But not if I already have it."	readLimit := readLimit max: position.	localDataValid ifTrue: [^ super contentsOfEntireFile].	collection size = 0 ifTrue: [self on: (String new: 2000)].	remoteFile getFileNamed: remoteFile fileName into: self.	"sets localDataValid := true"	^ super contentsOfEntireFile! !!SocketStream class methodsFor: 'example' stamp: 'md 8/14/2005 18:25'!finger: userName	"SocketStream finger: 'stp'"	| addr s |	addr := NetNameResolver promptUserForHostAddress.	s := SocketStream openConnectionToHost: addr port: 79.  "finger port number"	Transcript show: '---------- Connecting ----------'; cr.	s sendCommand: userName.	Transcript show: s getLine.	s close.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.! !!SocketStream methodsFor: 'configuration' stamp: 'gk 2/3/2005 20:35'!socket: aSocket	socket := aSocket! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:56'!statusString	"Return a string describing the status of this socket."	| status |	socketHandle == nil ifTrue: [^ 'destroyed'].	status := self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 23:04'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle :=		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore := writeSemaphore := semaphore := nil	] ifFalse:[self register].! !!MailComposition methodsFor: 'interface' stamp: 'fc 1/19/2005 21:00'!openInMorphic	"open an interface for sending a mail message with the given initial 	text "	| textMorph buttonsList sendButton attachmentButton |	morphicWindow := SystemWindow labelled: 'Mister Postman'.	morphicWindow model: self.	textEditor := textMorph := PluggableTextMorph						on: self						text: #messageText						accept: #messageText:						readSelection: nil						menu: #menuGet:shifted:.	morphicWindow addMorph: textMorph frame: (0 @ 0.1 corner: 1 @ 1).	buttonsList := AlignmentMorph newRow.	sendButton := PluggableButtonMorph				on: self				getState: nil				action: #submit.	sendButton		hResizing: #spaceFill;		vResizing: #spaceFill;		label: 'send message';		setBalloonText: 'Accept any unaccepted edits and add this to the queue of messages to be sent';		onColor: Color white offColor: Color white.	buttonsList addMorphBack: sendButton.		attachmentButton := PluggableButtonMorph				on: self				getState: nil				action: #addAttachment.	attachmentButton		hResizing: #spaceFill;		vResizing: #spaceFill;		label: 'add attachment';		setBalloonText: 'Send a file with the message';		onColor: Color white offColor: Color white.	buttonsList addMorphBack: attachmentButton.		morphicWindow addMorph: buttonsList frame: (0 @ 0 extent: 1 @ 0.1).	morphicWindow openInMVC! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 2/14/1999 21:44'!type: aSymbol	type := aSymbol! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/12/1998 00:23'!contentType: header	"extract the content type from the header.  Content-type: text/plain<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens ifNil: [ headerTokens := header findTokens: ParamDelimiters keep: (String with: CR) ].	1 to: headerTokens size do: [:ii | 		this := headerTokens at: ii.		(this first asLowercase = $c and: [#('content-type:' 'content type') includes: this asLowercase]) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!SMTPClient methodsFor: 'utility' stamp: 'dvf 11/18/2002 23:39'!encodeString: aString 	| str dec |	str := String new: (aString size * 4 / 3 + 3) ceiling.	dec := Base64MimeConverter new.	dec		mimeStream: (WriteStream on: str);		dataStream: (ReadStream on: aString);		mimeEncode.	^ str! !!Url methodsFor: 'parsing' stamp: 'ls 8/5/1998 00:57'!newFromRelativeText: aString	"return a URL relative to the current one, given by aString.  For instance, if self is 'http://host/dir/file', and aString is '/dir2/file2', then the return will be a Url for 'http://host/dir2/file2'"	"if the scheme is the same, or not specified, then use the same class"	| newSchemeName remainder fragmentStart newFragment newUrl bare |	bare := aString withBlanksTrimmed.	newSchemeName := Url schemeNameForString: bare.	(newSchemeName isNil not and: [ newSchemeName ~= self schemeName ]) ifTrue: [		"different scheme -- start from scratch"		^Url absoluteFromText: aString ].	remainder := bare.	"remove the fragment, if any"	fragmentStart := remainder indexOf: $#.	fragmentStart > 0 ifTrue: [		newFragment := remainder copyFrom: fragmentStart+1 to: remainder size. 		remainder := remainder copyFrom: 1 to: fragmentStart-1].	"remove the scheme name"	newSchemeName ifNotNil: [		remainder := remainder copyFrom: (newSchemeName size + 2) to: remainder size ].	"create and initialize the new url"	newUrl := self class new privateInitializeFromText: remainder  relativeTo: self.	"set the fragment"	newUrl privateFragment: newFragment.	^newUrl! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'mir 6/26/2001 09:49'!storeCurrentServersIn: aDirectory	| file |	self servers do: [:each |		file := aDirectory fileNamed: (ServerDirectory nameForServer: each).		each storeServerEntryOn: file.		file close].	self localProjectDirectories do: [:each |		file := aDirectory fileNamed: each localName.		each storeServerEntryOn: file.		file close].! !!OldSocket methodsFor: 'waiting' stamp: 'jm 3/2/98 18:15'!waitForConnectionUntil: deadline	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| status |	status := self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [Time millisecondClockValue < deadline]]		whileTrue: [			semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status := self primSocketConnectionStatus: socketHandle].	^ status = Connected! !!SMTPClient class methodsFor: 'instance creation' stamp: 'mir 2/22/2002 17:37'!openOnHost: hostIP port: portNumber	| client |	client := super openOnHost: hostIP port: portNumber.	client initiateSession.	^client! !!Password methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!cache: anObject	cache := anObject! !!Socket methodsFor: 'other' stamp: 'mir 2/22/2002 16:30'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO:=KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [InvalidSocketStatusException signal: 'Socket status must valid before setting an option'].	value := aValue asString.	aValue == true ifTrue: [value := '1'].	aValue == false ifTrue: [value := '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!FileUrl methodsFor: 'paths' stamp: 'gk 10/21/2005 10:01'!pathForDirectory	"Path using local file system's pathname delimiter.	DOS paths with drive letters should not	be prepended with a delimiter even though	they are absolute. Filename is left out."	| delimiter |	delimiter :=  FileDirectory default pathNameDelimiter.	^String streamContents: [ :s |		(self isAbsolute and: [self firstPartIsDriveLetter not])			ifTrue: [ s nextPut: delimiter ].		1 to: self path size - 1 do: [ :ii |			s nextPutAll: (path at: ii); nextPut: delimiter]]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 9/27/2005 20:07'!httpFileInNewChangeSet: url	"Do a regular file-in of a file that is served from a web site.  Put it into a new changeSet."	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones."	"	HTTPSocket httpFileInNewChangeSet: '206.18.68.12/squeak/updates/83tk:=test.cs'	 "	| doc |	doc := self httpGet: url accept: 'application/octet-stream'.	doc isString ifTrue:			[self inform: 'Cannot seem to contact the web site'].	doc reset.	ChangeSet newChangesFromStream: doc				named: (url findTokens: '/') last.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'nk 8/30/2004 07:50'!httpGet: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| document |	document := self httpGetDocument: url  args: args  accept: mimeType request: requestString.	(document isString) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!OldSimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:26'!parseIntegerList: aString	"Parse a list of integers, each on a line by itself."	| s out |	s := ReadStream on: aString.	s skipTo: Character cr.  "skip the first line"	out := OrderedCollection new.	[s atEnd]		whileFalse: [			out addLast: (Integer readFrom: s).			s skipTo: Character cr].	^ out asArray! !!OldSocket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 12:13'!nameForWellKnownTCPPort: portNum	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."	| portList entry |	portList := #(		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')		(21 'ftp') (23 'telnet') (25 'smtp')		(80 'http') (110 'pop3') (119 'nntp')).	entry := portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].	^ entry last! !!HttpUrl class methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 23:13'!shutDown	"Forget all cached passwords, so they won't stay in the image"	Passwords := nil.! !!ProjectSwikiServer methodsFor: 'accessing' stamp: 'mir 6/25/2001 12:40'!acceptsUploads: aBoolean	acceptsUploads := aBoolean! !!ProtocolClient methodsFor: 'private' stamp: 'mir 3/7/2002 13:35'!lastResponse: aString	lastResponse := aString.! !!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 13:33'!next	"Return next byte, if inBuffer is empty	we recieve some more data and try again."	self atEnd ifTrue: [^nil].	self isInBufferEmpty ifTrue:		[self receiveData.		self atEnd ifTrue: [^nil]].	lastRead := lastRead + 1.	^inBuffer at: lastRead! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'mir 2/22/2002 15:03'!initializeNetwork	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetwork"	| semaIndex |	self resolverStatus = ResolverUninitialized		ifFalse: [^HaveNetwork := true].  "network is already initialized"	HaveNetwork := false.	"in case abort"	ResolverSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: ResolverSemaphore.	"result is nil if network initialization failed, self if it succeeds"	(self primInitializeNetwork: semaIndex)		ifNil: [NoNetworkError signal: 'failed network initialization']		ifNotNil: [HaveNetwork := true].! !!HierarchicalUrl methodsFor: 'printing' stamp: 'mir 9/29/2000 14:16'!fullPath	| ans |	ans := WriteStream on: String new.	path do: [ :pathElem |		ans nextPut: $/.		ans nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		ans nextPut: $?.		ans nextPutAll: self query. ].	self fragment isNil ifFalse: [		ans nextPut: $#.		ans nextPutAll: self fragment encodeForHTTP. ].		^ans contents! !!ServerDirectory class methodsFor: 'available servers' stamp: 'mir 5/24/2001 17:48'!localProjectDirectories	LocalProjectDirectories ifNil: [LocalProjectDirectories := OrderedCollection new].	^LocalProjectDirectories! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:44'!nextSpecial	| c |	c := self nextChar.	^MailAddressToken type: c  text: c asString.! !!OldSimpleClientSocket class methodsFor: 'net news example' stamp: 'jm 9/15/97 13:26'!parseNTTPMsgList: aString	"Parse a list of integers, each on a line by itself."	| s out |	s := ReadStream on: aString.	s skipTo: Character cr.  "skip the first line"	out := OrderedCollection new.	[s atEnd]		whileFalse: [			out addLast: (Integer readFrom: s).			s skipTo: Character cr].	^ out asArray! !!TelnetProtocolClient methodsFor: 'private' stamp: 'mir 11/14/2002 18:27'!lastResponse: aString	super lastResponse: aString.	responseCode := self determineResponseCode! !!SuperSwikiServer methodsFor: 'for real' stamp: 'KR 1/30/2006 22:02'!oldFileNamed: aName	| answer |	answer := self sendToSwikiProjectServer: {		'action: readnamedfile'.		'projectname: ',aName convertToEncoding: self encodingName.	}.	(answer beginsWith: 'OK') ifFalse: [ ^nil].	^(SwikiPseudoFileStream with: (answer allButFirst: 3))		reset;		directory: self;		localName: (aName convertToEncoding: self encodingName);		yourself! !!URI methodsFor: 'private' stamp: 'mir 2/20/2002 17:18'!absoluteFromString: remainder scheme: schemeName	scheme := schemeName.	self extractSchemeSpecificPartAndFragment: remainder! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/13/1998 01:39'!nextDomainLiteral	| start end |	start := pos.	end := text indexOf: $] startingAt: start ifAbsent: [ 0 ].	end = 0 ifTrue: [		"not specified"		self error: 'saw [ without a matching ]' ].	pos := end+1.	^MailAddressToken		type: #DomainLiteral		text: (text copyFrom: start to: end)! !!MIMEDocument methodsFor: 'private' stamp: 'ls 7/23/1998 20:06'!privateSubType: aString	subType := aString! !!ConnectionQueue methodsFor: 'public' stamp: 'RAA 7/15/2000 12:36'!getConnectionOrNilLenient	"Return a connected socket, or nil if no connection has been established."	| result |	accessSema critical: [		connections isEmpty ifTrue: [			result := nil		] ifFalse: [			result := connections removeFirst.			(result isValid and: [result isConnected or: [result isOtherEndClosed]]) ifFalse: [				"stale connection"				result destroy.				result := nil			]		]	].	^ result! !!Socket methodsFor: 'sending' stamp: 'mir 2/19/2002 18:31'!sendStreamContents: stream checkBlock: checkBlock	"Send the data in the stream. Close the stream after you are done. After each block of data evaluate checkBlock and abort if it returns false.	Usefull for directly sending contents of a file without reading into memory first."	| chunkSize buffer |	chunkSize := 5000.	buffer := ByteArray new: chunkSize.	stream binary.	[[stream atEnd and: [checkBlock value]]		whileFalse: [			buffer := stream next: chunkSize into: buffer.			self sendData: buffer]]		ensure: [stream close]! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 13:57'!readDecimalByteFrom: aStream	"Read a positive, decimal integer from the given stream. Stop when a non-digit or end-of-stream is encountered. Return nil if stream is not positioned at a decimal digit or if the integer value read exceeds 255.JMM - 000503 fixed didn't work correctly"	| digitSeen value digit |	digitSeen := false.	value := 0.	[aStream atEnd] whileFalse: 		[digit := aStream next digitValue.		(digit < 0 or: [digit > 9]) ifTrue: [			aStream skip: -1.			(digitSeen not or: [value > 255]) ifTrue: [^ nil].			^ value].		digitSeen := true.		value := (value * 10) + digit].	(digitSeen not or: [value > 255]) ifTrue: [^ nil].	^ value! !!NetNameResolver class methodsFor: 'lookups' stamp: 'mu 9/7/2003 22:53'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"	| deadline result |	self initializeNetwork.	"check if this is a valid numeric host address (e.g. 1.2.3.4)"	result := self addressFromString: hostName.	result isNil ifFalse: [^result].	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"	deadline := Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex		critical: [			(self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfName: hostName.					(self waitForCompletionUntil: deadline)						ifTrue: [result := self primNameLookupResult]						ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]]				ifFalse: [(NameLookupFailure hostName: hostName) signal: 'Could not resolve the server named: ', hostName]].	^result! !!UUIDGenerator methodsFor: 'accessors and mutators' stamp: 'JMM 11/21/2001 14:29'!randomCounter: aNumber	randomCounter := aNumber! !!HttpUrl methodsFor: 'downloading' stamp: 'fbs 2/2/2005 13:24'!postFormArgs: args	| contents request |	request := realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request := 'Authorization: Basic ', request, String crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents := (HTTPSocket httpPostDocument: self asString args: args				accept: 'application/octet-stream' request: request).	self checkAuthorization: contents retry: [^ self postFormArgs: args].	^self normalizeContents: contents! !!SMTPClient methodsFor: 'private protocol' stamp: 'mir 2/22/2002 16:42'!data: messageData	"send the data of a message"	"DATA <CRLF>"	| cookedLine |	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkResponse.	"process the data one line at a time"	messageData linesDo:  [ :messageLine |		cookedLine := messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine := '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkResponse.! !!FTPClient methodsFor: 'protocol' stamp: 'mir 10/31/2000 19:03'!getPartial: limit fileNamed: remoteFileName into: dataStream	| data |	self openPassiveDataConnection.	self sendCommand: 'RETR ', remoteFileName.	[self checkResponse]		on: TelnetProtocolError		do: [:ex |			self closeDataSocket.			ex pass].	data := self get: limit dataInto: dataStream.	self abortDataConnection.	^data! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'ls 9/12/1998 20:14'!skipSeparators	pos := text indexOfAnyOf: CSNonSeparators  startingAt: pos  ifAbsent: [ text size + 1 ].! !!UrlArgumentList methodsFor: 'adding' stamp: 'mir 7/27/1999 16:19'!add: argName value: argValue	| argAssociation |	argAssociation := self argumentNamed: argName.	argAssociation isNil		ifTrue: [self add: (argName -> (OrderedCollection with: argValue))]		ifFalse: [argAssociation value add: argValue]! !!MacFileDirectory class methodsFor: '*network-uri' stamp: 'mir 3/24/2005 17:03'!privateFullPathForURI: aURI	| first path |	path := String streamContents: [ :s |		first := false.		aURI pathComponents do: [ :p |			first ifTrue: [ s nextPut: self pathNameDelimiter ].			first := true.			s nextPutAll: p ] ].	^path unescapePercents! !!Socket methodsFor: 'initialize-destroy' stamp: 'JMM 5/22/2000 22:47'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle := self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore := writeSemaphore := semaphore := nil	] ifFalse:[self register].! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/14/2002 17:51'!openDataSocket: remoteHostAddress port: dataPort	dataSocket := Socket new.	dataSocket connectTo: remoteHostAddress port: dataPort! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 5/4/1998 17:01'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc := (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	(StringHolder new contents: doc) openLabel: url.! !!Socket methodsFor: 'primitives' stamp: 'ar 7/18/2000 11:42'!primSocket: socketID setOption: aString value: aStringValue	"Set some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP:=NODELAY, SO:=KEEPALIVE are valid options for example	returns an array containing the error code and the negotiated value"	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	^nil! !!SuperSwikiServer methodsFor: 'private' stamp: 'mir 8/23/2001 22:04'!parseListEntries: listResult	| c first |	c := self fastParseEntriesFrom: listResult.	c ifNotNil: [^c].	c := OrderedCollection new.	first := true.	listResult linesDo: [ :x |		first ifFalse: [c add: (Compiler evaluate: x)].		first := false.	].	^c! !!NetNameResolver class methodsFor: 'private' stamp: 'mir 6/18/2001 21:05'!resolverMutex	ResolverMutex ifNil: [ResolverMutex := Semaphore forMutualExclusion].	^ResolverMutex! !!UrlArgumentList class methodsFor: 'instance creation' stamp: 'mir 7/27/1999 16:25'!with: argAssoc	| argList |	argList := self new.	argList add: argAssoc key value: argAssoc value.	^argList! !!HierarchicalURI methodsFor: 'private' stamp: 'mir 2/27/2002 12:46'!extractAuthority: aString	| endAuthorityIndex authorityString |	endAuthorityIndex := (aString indexOf: $/ ) - 1.	endAuthorityIndex < 0		ifTrue: [endAuthorityIndex := aString size].	authorityString := aString copyFrom: 1 to: endAuthorityIndex.	authority := URIAuthority fromString: authorityString.	^aString copyFrom: endAuthorityIndex+1 to: aString size! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 2/14/1999 20:44'!password	passwordHolder ifNil: [passwordHolder := Password new].	^ passwordHolder passwordFor: self	"may ask the user"! !!Socket methodsFor: 'connection open/close' stamp: 'ikp 9/1/2003 20:32'!listenOn: portNumber backlogSize: backlog interface: ifAddr	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog interface: ifAddr.! !!OldSimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'di 4/13/1999 14:43'!displayString: aString	"Display the given string on the Display. Used for testing."	| s |	aString isEmpty ifTrue: [^ self].	aString size > 60		ifTrue: [s := aString copyFrom: 1 to: 60]  "limit to 60 characters"		ifFalse: [s := aString].	s displayOn: Display.! !!Socket methodsFor: 'sending' stamp: 'ar 7/20/1999 17:23'!sendData: buffer count: n	"Send the amount of data from the given buffer"	| sent |	sent := 0.	[sent < n] whileTrue:[		sent := sent + (self sendSomeData: buffer startIndex: sent+1 count: (n-sent))].! !!SwikiPseudoFileStream methodsFor: 'as yet unclassified' stamp: 'RAA 10/13/2000 11:50'!directoryUrl: x	directoryUrl := x! !!HTTPSocket class methodsFor: 'get the page' stamp: 'nk 7/7/2003 18:37'!httpJpeg: url	"Fetch the given URL, parse it using the JPEG reader, and return the resulting Form."	| doc ggg |	doc := self httpGet: url.	doc binary; reset.	(ggg := JPEGReadWriter new) setStream: doc.	^ ggg nextImage.! !!HTTPServerDirectory methodsFor: 'accessing' stamp: 'mir 4/16/2001 18:02'!directoryNamed: localFileName	| newDir |	newDir := super directoryNamed: localFileName.	newDir altUrl: (self altUrl , '/' , localFileName).	^newDir! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/14/1998 10:17'!contentType	| type i |	type := self getHeader: 'content-type' default: nil.	type ifNil: [ ^nil ].	type := type withBlanksTrimmed.	i := type indexOf: $;.	i = 0 ifTrue: [ ^type ].	^(type copyFrom: 1 to: i-1) withBlanksTrimmed	! !!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 12:51'!nextInBuffer: anInteger	"Answer anInteger bytes of data at most,	but only from the inBuffer."	| start amount |	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	^inBuffer copyFrom: start to: lastRead! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'mir 7/30/1999 15:03'!httpProxyExceptions	HTTPProxyExceptions ifNil: [HTTPProxyExceptions := OrderedCollection new].	^HTTPProxyExceptions! !!UUIDGenerator methodsFor: 'generator' stamp: 'JMM 11/22/2001 13:51'!generateOneOrZero	| result |	self semaphoreForGenerator		critical: [| value | 			value := self randomGenerator next.			self randomCounter: self randomCounter + 1.			self randomCounter > 100000				ifTrue: [self setupRandom].			result := value < 0.5						ifTrue: [0]						ifFalse: [1]].	^ result! !!MailMessage methodsFor: 'parsing' stamp: ''!skipWeekdayName: aStream	"If the given stream starts with a weekday name or its abbreviation, advance the stream to the first alphaNumeric character following the weekday name."	| position name abbrev |	aStream skipSeparators.	(aStream peek isDigit) ifTrue: [^self].	(aStream peek isLetter) ifTrue:		[position := aStream position.		 name := WriteStream on: (String new: 10).		 [aStream peek isLetter] whileTrue: [name nextPut: aStream next].		 abbrev := (name contents copyFrom: 1 to: (3 min: name position)).		 abbrev := abbrev asLowercase.		 (#('sun' 'mon' 'tue' 'wed' 'thu' 'fri' 'sat') includes: abbrev asLowercase)			ifTrue:				["found a weekday; skip to the next alphanumeric character"				 [aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1]]			ifFalse:				["didn't find a weekday so restore stream position"				 aStream position: position]].! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'tk 9/21/1998 10:45'!blabEmail: aRequest	"Of the form 'From: me@isp.com <crlf>'"	HTTPBlabEmail := aRequest! !!OldSocket methodsFor: 'other' stamp: 'JMM 6/3/2000 19:39'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO:=KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before setting an option'].	value := aValue asString.	aValue == true ifTrue: [value := '1'].	aValue == false ifTrue: [value := '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!HTTPServerDirectory methodsFor: 'file directory' stamp: 'mir 4/20/2001 18:44'!directoryNames	| dirNames projectNames entries |	"Return a collection of names for the subdirectories of this directory but filter out project directories."	entries := self entries.	dirNames := (entries select: [:entry | entry at: 4])		collect: [:entry | entry first].	projectNames := Set new.	entries do: [:entry | 		((entry at: 4) not			and: ['*.pr' match: entry first])			ifTrue: [projectNames add: (entry first copyFrom: 1 to: entry first size-3)]].	^dirNames reject: [:each | projectNames includes: each]! !!URI class methodsFor: 'class initialization' stamp: 'mir 3/1/2002 15:18'!initialize	"URI initialize"	ClientClasses := Dictionary new.	ClientClasses		at: 'http' put: #HTTPClient;		at: 'ftp' put: #FTPClient;		at: 'file' put: #FileDirectory! !!Socket methodsFor: 'connection open/close' stamp: 'mir 2/22/2002 16:25'!listenOn: portNumber backlogSize: backlog	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [InvalidSocketStatusException signal: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!server: anObject	server := anObject! !!OldSimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/11/1998 03:27'!getResponseShowing: showFlag	| line idx |	line := WriteStream on: String new.	buffer ifNil: [		buffer := String new.		bufferPos := 0 ].	[		"look for a LF in the buffer"		idx := buffer indexOf: Character lf startingAt: bufferPos+1 ifAbsent: [ 0 ].		idx > 0 ifTrue: [			"found it!! we have a line"			line nextPutAll: (buffer copyFrom: bufferPos+1 to: idx-1).			bufferPos := idx.			^line contents ].				"didn't find it.  add the whole buffer to the line, and retrieve some more data"		line nextPutAll: (buffer copyFrom: bufferPos+1 to: buffer size).		bufferPos := 0.		buffer := String new.		self waitForDataQueryingUserEvery: 30.		buffer := self getData.		true	] whileTrue.! !!SuperSwikiServer methodsFor: 'testing' stamp: 'RAA 10/7/2000 16:12'!test1	| localDirectory localFileName local resp |	localDirectory := FileDirectory default.	localFileName := 'superTest1.07Oct1611.cs'.	local := localDirectory oldFileNamed: localFileName.	resp := self putFile: local named: localFileName retry: false.	local close.	^resp! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle == nil ifTrue: [^ true].	status := self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/14/1999 20:56'!altUrl: aString	altURL := aString! !!MailComposition class methodsFor: 'instance creation' stamp: 'dvf 5/11/2002 01:25'!sendMailMessage: aMailMessage	| newComposition |	newComposition := self new.	newComposition messageText: aMailMessage text; open! !!MailAddressParser methodsFor: 'parsing' stamp: 'bf 3/12/2000 20:06'!grabAddresses	"grab all the addresses in the string"	| token |	"remove comments"	tokens removeAllSuchThat: [:t | t type == #Comment].	"grab one address or address group each time through this loop"	[ 		"remove commas"		[			tokens isEmpty not and: [ tokens last type = $, ]		] whileTrue: [ tokens removeLast ].		"check whether any tokens are left"		tokens isEmpty 	] whileFalse: [		token := tokens last.		"delegate, depending on what form the address is in"		"the from can be determined from the last token"		token type = $> ifTrue: [			self grabAddressWithRoute ]		ifFalse: [ 			(#(Atom DomainLiteral QuotedString) includes: token type)  ifTrue: [				self grabBasicAddress ]		ifFalse: [			token type = $; ifTrue: [				self grabGroupAddress ]		ifFalse: [			^self error: 'un-recognized address format' ] ] ]	].	^addresses! !!SocketStream methodsFor: 'stream in' stamp: 'gk 2/7/2005 14:04'!peekFor: aCharacterOrByte	"Read and return next character or byte	if it is equal to the argument.	Otherwise return false."	| nextObject |	self atEnd ifTrue: [^false].	self isInBufferEmpty ifTrue: 		[self receiveData.		self atEnd ifTrue: [^false]].	nextObject := inBuffer at: lastRead.	nextObject = aCharacterOrByte ifTrue: [		lastRead := lastRead + 1.		^true].	^false! !!ServerDirectory class methodsFor: 'server groups' stamp: 'mir 6/26/2001 12:06'!serverInGroupNamed: groupName	"Return the first (available) server in the group of this name."	| servers |	servers := self serversInGroupNamed: groupName.	servers isEmpty		ifTrue: [self error: 'No server found in group "' , groupName asString , '".'].	^servers first! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:18'!receiveDataWithTimeout	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveDataWithTimeoutInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!UrlArgumentList class methodsFor: 'instance creation' stamp: 'mir 7/27/1999 16:26'!with: firstArgAssoc with: secondArgAssoc with: thirdArgAssoc	| argList |	argList := self with: firstArgAssoc with: secondArgAssoc.	argList add: thirdArgAssoc key value: thirdArgAssoc value.	^argList! !!MailMessage methodsFor: 'printing/formatting' stamp: 'yo 7/26/2004 22:06'!cleanedHeader	"Reply with a cleaned up version email header.  First show fields people would normally want to see (in a regular order for easy browsing), and then any other fields not explictly excluded"	| new priorityFields omittedFields |	new := WriteStream on: (String new: text size).	priorityFields := #('Date' 'From' 'Subject' 'To' 'Cc').	omittedFields := MailMessage omittedHeaderFields.	"Show the priority fields first, in the order given in priorityFields"	priorityFields do: [ :pField |		"We don't check whether the priority field is in the omitted list!!"		self headerFieldsNamed: pField do:			[: fValue | new nextPutAll: pField, ': ', fValue decodeMimeHeader; cr]].	"Show the rest of the fields, omitting the uninteresting ones and ones we have already shown"	omittedFields := omittedFields, priorityFields.	self fieldsFrom: (ReadStream on: text) do:		[: fName : fValue |		((fName beginsWith: 'x-') or:			[omittedFields anySatisfy: [: omitted | fName sameAs: omitted]])				ifFalse: [new nextPutAll: fName, ': ', fValue; cr]].	^new contents! !!Password methodsFor: 'as yet unclassified' stamp: 'tk 10/15/2002 14:39'!serverPasswords	"Get the server passwords off the disk and decode them. The file 'sqk.info' must be in some folder that Squeak thinks is special (vm folder, or default directory).  (Note: This code works even if you are running with no system sources file.)"	| sfile |	(sfile := FileDirectory lookInUsualPlaces: 'sqk.info') ifNil: [^ nil].		"If not there, Caller will ask user for password"		"If you don't have this file, and you really do want to release an update, 		 contact Ted Kaehler."	^ (self decode: (sfile contentsOfEntireFile)) findTokens: String cr! !!AcornFileDirectory class methodsFor: '*network-uri' stamp: 'tpr 5/4/2005 17:22'!privateFullPathForURI: aURI	"derive the full filepath from aURI"	| first path |	path := String streamContents: [ :s |		first := false.		aURI pathComponents do: [ :p |			first ifTrue: [ s nextPut: self pathNameDelimiter ].			first := true.			s nextPutAll: p ] ].	^path unescapePercents! !!Socket methodsFor: 'receiving' stamp: 'mir 5/15/2003 16:05'!receiveData	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.	Either returns data or signals a time out or connection close."	| buffer bytesRead |	buffer := String new: 2000.	bytesRead := self receiveDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!HttpUrl methodsFor: 'downloading' stamp: 'mir 10/13/1999 19:41'!loadRemoteObjects	"Load a remote image segment and extract the root objects.	Check if the remote file is a zip archive."	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.extSeg' 		asUrl loadRemoteObjects" 	"'http://bradley.online.disney.com/games/subgame/squeak-test/assetInfo.zip' 		asUrl loadRemoteObjects" 	| stream info data extension | 	data := self retrieveContents content.	extension := (FileDirectory extensionFor: self path last) asLowercase.	(#('zip' 'gzip') includes: extension)		ifTrue: [data := (GZipReadStream on: data) upToEnd]."	stream := StreamWrapper streamOver: (ReadStream on: data)."	stream := RWBinaryOrTextStream on: data.	stream reset.	info := stream fileInObjectAndCode.	stream close.	^info arrayOfRoots! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:51'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle == nil ifTrue: [^ false].	status := self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!MailMessage methodsFor: 'multipart' stamp: 'ls 3/18/2001 16:26'!decoderClass	| encoding |	encoding := self fieldNamed: 'content-transfer-encoding' ifAbsent: [^ nil].	encoding := encoding mainValue.	encoding asLowercase = 'base64' ifTrue: [^ Base64MimeConverter].	encoding asLowercase = 'quoted-printable' ifTrue: [^ QuotedPrintableMimeConverter].	^ nil! !!SocketStream methodsFor: 'printing' stamp: 'gk 2/25/2005 14:19'!debug	"Display debug info."	| data |	data := self inBufferSize.	^String streamContents: [:s |		s			nextPutAll: 'Buffer size: ', inBuffer size asString;cr;			nextPutAll: 'InBuffer data size: ', data asString; cr;			nextPutAll: 'In data (20):', (inBuffer copyFrom: lastRead + 1 to: lastRead + (data min: 20)); cr;			nextPutAll: 'OutBuffer data size: ', (outNextToWrite - 1) asString; cr;			nextPutAll: 'Out data (20):', (outBuffer copyFrom: 1 to: ((outNextToWrite - 1) min: 20)); cr]! !!ServerDirectory methodsFor: 'squeaklets' stamp: 'yo 7/2/2004 21:18'!upLoadProject: projectName members: archiveMembers retry: aBool	| dir okay m dirName idx |	m := archiveMembers detect:[:any| any fileName includes: $/] ifNone:[nil].	m == nil ifFalse:[		dirName := m fileName copyUpTo: $/.		self createDirectory: dirName.		dir := self directoryNamed: dirName].	archiveMembers do:[:entry|		ProgressNotification signal: '4:uploadingFile'			extra: ('(uploading {1}...)' translated format: {entry fileName}).		idx := entry fileName indexOf: $/.		okay := (idx > 0			ifTrue:[				dir putFile: entry contentStream 					named: (entry fileName copyFrom: idx+1 to: entry fileName size) 					retry: aBool]			ifFalse:[				self putFile: entry contentStream					named: entry fileName					retry: aBool]).		(okay == false			or: [okay isString])			ifTrue: [				self inform: ('Upload for {1} did not succeed ({2}).' translated format: {entry fileName printString. okay}).				^false].	].	ProgressNotification signal: '4:uploadingFile' extra:''.	^true! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:48'!openReadOnly	"If we have data, don't reread."	self readOnly.	readLimit := readLimit max: position.	localDataValid ifFalse: [remoteFile getFileNamed: remoteFile fileName into: self].		"sets localDataValid := true"! !!SuperSwikiServer methodsFor: 'for real' stamp: 'RAA 10/17/2000 12:49'!getOnly: numberOfBytes from: aName	| answer |	answer := self sendToSwikiProjectServer: {		'action: readnamedfile'.		'projectname: ',aName.		'bytestoread: ',numberOfBytes printString.	}.	(answer beginsWith: 'OK') ifFalse: [ ^nil].	^answer allButFirst: 3! !!ServerDirectory methodsFor: 'file directory' stamp: 'di 3/9/2001 01:25'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data." 	| file |	^ Cursor wait showWhile:		[file := self asServerFileNamed: fullName.		file readOnly.		"file exists ifFalse: [^ nil]."		"on the server"		file isTypeFile			ifTrue: [FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self)]			ifFalse: [self streamOnBeginningOf: file]]! !!Socket class methodsFor: 'utilities' stamp: 'tk 4/9/98 15:56'!deadServer: aStringOrNil	"Keep the machine name of the most recently encoutered non-responding machine.  Next time the user can move it to the last in a list of servers to try."	DeadServer := aStringOrNil! !!Socket class methodsFor: 'class initialization' stamp: 'ar 12/12/2001 19:12'!initialize	"Socket initialize"	"Socket Types"	TCPSocketType := 0.	UDPSocketType := 1.	"Socket Status Values"	InvalidSocket := -1.	Unconnected := 0.	WaitingForConnection := 1.	Connected := 2.	OtherEndClosed := 3.	ThisEndClosed := 4.	RegistryThreshold := 100. "# of sockets"! !!MailMessage methodsFor: 'printing/formatting' stamp: 'ls 11/11/2001 13:27'!printOn: aStream 	"For text parts with no filename show: 'text/plain: first line of text...'    	for attachments/filenamed parts show: 'attachment: filename.ext'"	| name |	aStream nextPutAll: ((name := self name) ifNil: ['Text: ' , self excerpt]			ifNotNil: ['File: ' , name])! !!MIMEHeaderValue methodsFor: 'accessing' stamp: 'dvf 4/27/2000 18:11'!parameters: anObject	parameters := anObject! !!MailAddressTokenizer methodsFor: 'initialization' stamp: 'ls 9/12/1998 20:13'!initialize: aString	text := aString.	pos := 1.! !!ServerDirectory class methodsFor: 'available servers' stamp: 'gk 10/21/2005 10:29'!serverForURL: aURLString	| serversForURL server urlPath serverPath relPath |	serversForURL := self servers values select: [:each |		(aURLString beginsWith: each downloadUrl)		or: [(aURLString beginsWith: each realUrl)		or: [aURLString , '/' beginsWith: each downloadUrl]]].	serversForURL isEmpty		ifTrue: [^nil].	server := serversForURL first.	urlPath := aURLString asUrl path.	(urlPath isEmpty not		and: [urlPath last isEmpty])		ifTrue: [urlPath removeLast].	serverPath := server downloadUrl asUrl path.	(serverPath isEmpty not		and: [serverPath last isEmpty])		ifTrue: [serverPath removeLast].	urlPath size < serverPath size		ifTrue: [^nil].	relPath := String new.	serverPath size +1 to: urlPath size do: [:i | relPath := relPath , '/' , (urlPath at: i)].	^relPath isEmpty		ifTrue: [server]		ifFalse: [server directoryNamed: (relPath copyFrom: 2 to: relPath size)]! !!OldSocket methodsFor: 'connection open/close' stamp: ''!connectTo: hostAddress port: port	"Initiate a connection to the given port at the given host address. This operation will return immediately; follow it with waitForConnectionUntil: to wait until the connection is established."	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before opening a new connection'].	self primSocket: socketHandle connectTo: hostAddress port: port.! !!Socket methodsFor: 'receiving' stamp: 'yo 10/10/2005 18:47'!receiveAvailableDataIntoBuffer: buffer	"Receive all available data (if any). Do not wait." 	| bytesRead |	bytesRead := self receiveAvailableDataInto: buffer.	^buffer copyFrom: 1 to: bytesRead! !!POP3Client methodsFor: 'public protocol' stamp: 'mir 4/7/2003 17:17'!messageCount	"Query the server and answer the number of messages that are in the user's mailbox."	| answerString numMessages |	self ensureConnection.	self sendCommand: 'STAT'.	self checkResponse.	self logProgress: self lastResponse.	[answerString := (self lastResponse findTokens: Character separators) second.	numMessages := answerString asNumber asInteger]		on: Error		do: [:ex | (ProtocolClientError protocolInstance: self) signal: 'Invalid STAT response.'].	^numMessages! !!ServerDirectory methodsFor: 'up/download' stamp: 'ar 4/10/2005 18:52'!getFileNamed: fileNameOnServer into: dataStream httpRequest: requestString	"Just FTP a file from a server.  Return a stream.  (Later -- Use a proxy server if one has been registered.)"	| resp |	self isTypeFile ifTrue: [		dataStream nextPutAll: 			(resp := FileStream oldFileNamed: server,(self serverDelimiter asString), 				self bareDirectory, (self serverDelimiter asString),				fileNameOnServer) contentsOfEntireFile.		dataStream dataIsValid.		^ resp].	self isTypeHTTP ifTrue: [		resp := HTTPSocket httpGet: (self fullNameFor: fileNameOnServer) 				args: nil accept: 'application/octet-stream' request: requestString.		resp isString ifTrue: [^ dataStream].	"error, no data"		dataStream copyFrom: resp.		dataStream dataIsValid.		^ dataStream].	client := self openFTPClient.	"Open passive.  Do everything up to RETR or STOR"	[client getFileNamed: fileNameOnServer into: dataStream]		ensure: [self quit].	dataStream dataIsValid.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'hpt 12/10/2004 23:17'!httpProxyServer: aStringOrNil	| serverName |	self checkHTTPProxyPreferences.	serverName := aStringOrNil 						ifNil: [''] 						ifNotNil: [aStringOrNil withBlanksTrimmed ].	Preferences setPreference: #httpProxyServer toValue: serverName! !!MailMessage methodsFor: 'access' stamp: 'ls 3/18/2001 16:26'!name	"return a default name for this part, if any was specified.  If not, return nil"	| type nameField disposition |	"try in the content-type: header"	type := self fieldNamed: 'content-type' ifAbsent: [nil].	(type notNil and: [(nameField := type parameters at: 'name' ifAbsent: [nil]) notNil])		ifTrue: [^ nameField].	"try in content-disposition:"	disposition := self fieldNamed: 'content-disposition' ifAbsent: [nil].	(disposition notNil and: [(nameField := disposition parameters at: 'filename' ifAbsent: [nil]) notNil])		ifTrue: [^ nameField].	"give up"	^ nil! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'jm 9/26/97 18:28'!redirect	"See if the header has a 'Location: url CrLf' in it.  If so, return the new URL of this page.  tk 6/24/97 18:03"	| this |	1 to: headerTokens size do: [:ii | 		this := headerTokens at: ii.		(this first asLowercase = $l and: [this asLowercase = 'location:']) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!MailMessage methodsFor: 'printing/formatting' stamp: 'nk 6/12/2004 09:36'!viewImageInBody	| stream image |	stream := self body contentStream.	image := Form fromBinaryStream: stream.	(World drawingClass withForm: image) openInWorld! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 21:48'!primSocket: socketID getOption: aString 	"Get some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP:=NODELAY, SO:=KEEPALIVE are valid options for example	returns an array containing the error code and the option value"	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!MailAddressParser methodsFor: 'private-initialization' stamp: 'ls 9/13/1998 01:25'!initialize: tokenList	tokens := tokenList asOrderedCollection copy.	addresses := OrderedCollection new.! !!ServerDirectory methodsFor: 'accessing' stamp: 'mir 6/29/2001 01:16'!passwordSequence: aNumber	passwordHolder ifNil: [passwordHolder := Password new].	passwordHolder sequence: aNumber! !!ServerDirectory methodsFor: 'accessing' stamp: 'ar 4/10/2005 18:52'!password: pp	passwordHolder := Password new.	pp isString 		ifTrue: [passwordHolder cache: pp. ^ self].	pp isInteger 		ifTrue: [passwordHolder sequence: pp]		ifFalse: [passwordHolder := pp].! !!Socket methodsFor: 'sending' stamp: 'mir 5/15/2003 18:34'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	(self waitForSendDoneFor: 20)		ifTrue: [			bytesSent := self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: startIndex				count: count]		ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].	^ bytesSent! !!OldSocket methodsFor: 'connection open/close' stamp: ''!listenOn: port	"Listen for a connection on the given port. This operation will return immediately; follow it with waitForConnectionUntil: to wait until a connection is established."	| status |	status := self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: port.! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/5/1998 08:00'!contentType: aString  content: content	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans := self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx := aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	^ans! !!FileUrl methodsFor: 'accessing' stamp: 'gk 10/21/2005 11:13'!isAbsolute: aBoolean	"Set if the path should be considered absolute to	the filesystem instead of relative to the default directory."	isAbsolute := aBoolean! !!HTTPSocket class methodsFor: 'utilities' stamp: 'rbb 2/18/2005 13:23'!retry: tryBlock asking: troubleString ifGiveUp: abortActionBlock	"Execute the given block. If it evaluates to true, return true. If it evaluates to false, prompt the user with the given string to see if he wants to try again. If not, evaluate the abortActionBlock and return false."	| response  |	[tryBlock value] whileFalse: [		| sema |		sema := Semaphore new.		WorldState addDeferredUIMessage: [			response := UIManager default chooseFrom: #('Retry' 'Give Up')				title: troubleString.			sema signal.		].		sema wait.		response = 2 ifTrue: [abortActionBlock value. ^ false]].	^ true! !!MIMEDocument class methodsFor: 'content-types' stamp: 'bolot 11/27/1999 14:26'!resetMIMEdatabase	MIMEdatabase := self extendedMIMEdatabase! !!Socket methodsFor: 'datagrams' stamp: 'JMM 6/7/2000 14:58'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self receiveDataInto: aStringOrByteArray].	[true] whileTrue: 		[datagram := self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]]! !!ServerDirectory methodsFor: 'accessing' stamp: 'tk 1/3/98 21:36'!user: anObject	user := anObject! !!NameLookupFailure methodsFor: 'accessing' stamp: 'len 12/14/2002 11:57'!hostName: aString	hostName := aString! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:48'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations	ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for	reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore := true.	^ self primSocketCreateNetwork: netType			type: socketType			receiveBufferSize: rcvBufSize			sendBufSize: sendBufSize			semaIndex: semaIndex! !!NetNameResolver class methodsFor: 'address string utils' stamp: 'jm 9/15/97 06:19'!addressFromString: addressString	"Return the internet address represented by the given string. The string should contain four positive decimal integers delimited by periods, commas, or spaces, where each integer represents one address byte. Return nil if the string is not a host address in an acceptable format."	"NetNameResolver addressFromString: '1.2.3.4'"	"NetNameResolver addressFromString: '1,2,3,4'"	"NetNameResolver addressFromString: '1 2 3 4'"	| newAddr s byte delimiter |	newAddr := ByteArray new: 4.	s := ReadStream on: addressString.	s skipSeparators.	1 to: 4 do: [:i |		byte := self readDecimalByteFrom: s.		byte = nil ifTrue: [^ nil].		newAddr at: i put: byte.		i < 4 ifTrue: [			delimiter := s next.			((delimiter = $.) or: [(delimiter = $,) or: [delimiter = $ ]])				ifFalse: [^ nil]]].	^ newAddr! !!FtpUrl methodsFor: 'downloading' stamp: 'mir 8/5/2004 11:55'!downloadUrl	"Returns a http download url for the location defined by this url."	| ans |	ans := WriteStream on: String new.	ans nextPutAll: self schemeName.	ans nextPutAll: '://'.	ans nextPutAll: self authority.	port ifNotNil: [ans nextPut: $:; print: port].	path do: [ :pathElem |		ans nextPut: $/.		ans nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		ans nextPut: $?.		ans nextPutAll: self query. ].	self fragment isNil ifFalse: [		ans nextPut: $#.		ans nextPutAll: self fragment encodeForHTTP. ].		^ans contents! !!ServerDirectory methodsFor: 'squeaklets' stamp: 'ar 3/2/2001 19:08'!upLoadProject: projectFile named: fileNameOnServer resourceUrl: resUrl retry: aBool	"Upload the given project file. If it's an archive, upload only the files that are local to the project."	| archive members upload prefix |	self isTypeFile ifTrue:[ 		^(FileDirectory on: urlObject pathForDirectory)			upLoadProject: projectFile named: fileNameOnServer resourceUrl: resUrl retry: aBool].	projectFile isZipArchive		ifFalse:[^self putFile: projectFile named: fileNameOnServer retry: aBool].	projectFile binary.	archive := ZipArchive new readFrom: projectFile.	resUrl last = $/ 		ifTrue:[prefix := resUrl copyFrom: 1 to: resUrl size-1] "remove last slash"		ifFalse:[prefix := resUrl].	prefix := prefix copyFrom: 1 to: (prefix lastIndexOf: $/).	members := archive members select:[:entry|		"figure out where it's coming from"		upload := false.		(entry fileName indexOf: $:) = 0 ifTrue:[			upload := true. "one of the core files, e.g., project itself, resource map, meta info"		] ifFalse:[			(entry fileName asLowercase beginsWith: resUrl asLowercase) ifTrue:[				upload := true.				entry fileName: (entry fileName copyFrom: prefix size+1 to: entry fileName size).			].		].		upload].	members := members asArray sort:[:m1 :m2| m1 compressedSize < m2 compressedSize].	^self upLoadProject: fileNameOnServer members: members retry: aBool.! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 9/14/2000 13:26'!fullPath: serverAndDirectory	"Parse and save a full path.  Convention:  if ftp://user@server/dir, then dir is relative to user's directory.  dir has no slash at beginning.  If ftp://server/dir, then dir is absolute to top of machine, give dir a slash at the beginning."	| start bare sz userAndServer both slash score match best sd |	bare := serverAndDirectory.	sz := serverAndDirectory size.	bare size > 0 ifTrue: [ 		start := (bare copyFrom: 1 to: (8 min: sz)) asLowercase.		((start beginsWith: 'ftp:') or: [start beginsWith: 'nil:']) "fix bad urls"			ifTrue: [type := #ftp.				bare := bare copyFrom: (7 min: sz) to: bare size].		(start beginsWith: 'http:') 			ifTrue: [type := #http.				bare := bare copyFrom: (8 min: sz) to: serverAndDirectory size].		((start beginsWith: 'file:') or: [type == #file])			ifTrue: [type := #file.				urlObject := FileUrl absoluteFromText: serverAndDirectory.				^ self]].	userAndServer := bare copyUpTo: self pathNameDelimiter.	both := userAndServer findTokens: '@'.	slash := both size.	"absolute = 1, relative = 2"	server := both last.	both size > 1 ifTrue: [user := both at: 1].	bare size > (userAndServer size + 1) 		ifTrue: [directory := bare copyFrom: userAndServer size + slash to: bare size]		ifFalse: [directory := ''].	"If this server is already known, copy in its userName and password"	type == #ftp ifFalse: [^ self].	score := -1.	ServerDirectory serverNames do: [:name |		sd := ServerDirectory serverNamed: name.		server = sd server ifTrue: [			match := directory asLowercase charactersExactlyMatching: sd directory asLowercase.			match > score ifTrue: [score := match.  best := sd]]].	best ifNil: [		self fromUser	] ifNotNil: [		user := best user.		altURL := best altUrl.		loaderUrl := best loaderUrl.		self password: best password	].! !!MIMEDocument class methodsFor: 'content-types' stamp: 'bolot 11/27/1999 14:26'!guessTypeFromName: url	"guesses a content type from the url"	| extension |	extension := url asString.	(extension includes: $.) ifFalse: [ ^self defaultContentType].	extension := (extension findTokens: '.') last asLowercase.	MIMEdatabase ifNil: [self resetMIMEdatabase].	^ MIMEdatabase at: extension ifAbsent: [self defaultContentType].! !!MailMessage methodsFor: 'parsing' stamp: 'dvf 5/10/2002 21:43'!fieldsFrom: aStream do: aBlock	"Invoke the given block with each of the header fields from the given stream. The block arguments are the field name and value. The streams position is left right after the empty line separating header and body."	| savedLine line s |	savedLine := self readStringLineFrom: aStream.	[aStream atEnd] whileFalse: [		line := savedLine.		(line isEmpty) ifTrue: [^self].  "quit when we hit a blank line"		[savedLine := self readStringLineFrom: aStream.		 (savedLine size > 0) and: [savedLine first isSeparator]] whileTrue: [			"lines starting with white space are continuation lines"			s := ReadStream on: savedLine.			s skipSeparators.			line := line, ' ', s upToEnd].		self reportField: line withBlanksTrimmed to: aBlock].	"process final header line of a body-less message"	(savedLine isEmpty) ifFalse: [self reportField: savedLine withBlanksTrimmed to: aBlock].! !!ConnectionQueue methodsFor: 'private' stamp: 'mir 5/15/2003 18:28'!oldStyleListenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	[true] whileTrue: [		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [			"try to create a new socket for listening"			socket := Socket createIfFail: [nil]].		socket == nil			ifTrue: [(Delay forMilliseconds: 100) wait]			ifFalse: [				socket isUnconnected ifTrue: [socket listenOn: portNumber].				[socket waitForConnectionFor: 10]					on: ConnectionTimedOut					do: [:ex |						socket isConnected							ifTrue: [  "connection established"								accessSema critical: [connections addLast: socket].								socket := nil]							ifFalse: [								socket isWaitingForConnection									ifFalse: [socket destroy. socket := nil]]]].  "broken socket; start over"		self pruneStaleConnections].! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'hg 9/29/2001 14:35'!transferServerDefinitionsToExternal	"ServerDirectory transferServerDefinitionsToExternal"	| serverDir |	serverDir := ExternalSettings preferenceDirectory directoryNamed: self serverConfDirectoryName.	serverDir assureExistence.	ServerDirectory storeCurrentServersIn: serverDir! !!MailMessage class methodsFor: 'testing' stamp: 'mdr 3/21/2001 15:59'!selfTest	| msgText msg |	msgText := 'Date: Tue, 20 Feb 2001 13:52:53 +0300From: mdr@scn.rg (Me Ru)Subject: RE: Windows 2000 on your laptopTo: "Greg Y" <to1@mail.com>cc: cc1@scn.org, cc1also@test.orgTo: to2@no.scn.org, to2also@op.orgcc: cc2@scn.orgHmmm... Good.  I will try to swap my German copy for something inEnglish, and then do the deed.  Oh, and expand my RAM to 128 first.Mike'.	msg := self new from: msgText.	[msg text = msgText] assert.	[msg subject = 'RE: Windows 2000 on your laptop'] assert.	[msg from = 'mdr@scn.rg (Me Ru)'] assert.	[msg date = '2/20/01'] assert.	[msg time = 667133573] assert.	"[msg name] assert."	[msg to = '"Greg Y" <to1@mail.com>, to2@no.scn.org, to2also@op.org'] assert.	[msg cc = 'cc1@scn.org, cc1also@test.org, cc2@scn.org'] assert.	"MailMessage selfTest"! !!ConnectionQueue methodsFor: 'public' stamp: 'jm 3/10/98 09:18'!getConnectionOrNil	"Return a connected socket, or nil if no connection has been established."	| result |	accessSema critical: [		connections isEmpty			ifTrue: [result := nil]			ifFalse: [				result := connections removeFirst.				((result isValid) and: [result isConnected]) ifFalse: [  "stale connection"					result destroy.					result := nil]]].	^ result! !!SocketStream methodsFor: 'private-socket' stamp: 'gk 2/25/2005 14:20'!receiveAvailableData	"Receive available data (as much as fits in the inBuffer)	but not waiting for more to arrive.	Return the position in the buffer where the	new data starts, regardless if anything	was read, see #adjustInBuffer."		recentlyRead := socket receiveAvailableDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!MailAddressTokenizer methodsFor: 'stream protocol' stamp: 'ls 9/12/1998 20:53'!peek	cachedToken ifNil: [ cachedToken := self nextToken. ].		^cachedToken	! !!FileUrl methodsFor: 'private-initialization' stamp: 'gk 2/12/2004 16:01'!initializeFromPathString: aPathString	"<aPathString> is a file path as a String.	We construct a path collection using various heuristics."	| pathString hasDriveLetter |	pathString := aPathString.	pathString isEmpty ifTrue: [pathString := '/'].	path := (pathString findTokens: '/') collect: [:token | token unescapePercents].	"A path like 'C:' refers in practice to 'c:/'"	((pathString endsWith: '/') or:		[(hasDriveLetter := self firstPartIsDriveLetter) and: [path size = 1]])			ifTrue: [path add: ''].	"Decide if we are absolute by checking for leading $/ or	beginning with drive letter. Smarts for other OSes?"	self isAbsolute: ((pathString beginsWith: '/')						or: [hasDriveLetter ifNil: [self firstPartIsDriveLetter]])! !!MailAddressTokenizer methodsFor: 'tokenizing' stamp: 'bf 3/12/2000 19:53'!nextToken	| c |	self skipSeparators.	c := self peekChar.	c ifNil: [ ^nil ].	c = $( ifTrue: [ ^self nextComment ].	c = $" ifTrue: [ ^self nextQuotedString ].	c = $[ ifTrue: [ ^self nextDomainLiteral ].	(CSSpecials includes: c) ifTrue: [ ^self nextSpecial ].	^self nextAtom! !!OldSocket methodsFor: 'waiting' stamp: 'JMM 5/17/2000 14:52'!waitForDisconnectionUntil: deadline	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method.JMM 00/5/17 note that other end can close which will terminate wait"	| extraBytes status |	extraBytes := 0.	status := self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [(status = ThisEndClosed)]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes := extraBytes + self discardReceivedData].		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status := self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!FileDirectory class methodsFor: '*network-uri' stamp: 'tb 5/24/2006 22:01'!retrieveMIMEDocument: uri	| file |	file  := [self contentStreamForURI: uri] 			on: FileDoesNotExistException do:[:ex| ex return: nil].	file ifNotNil: [^MIMEDocument contentType: (MIMEDocument guessTypeFromName: uri) content: file contents url: uri].	^nil! !!HierarchicalUrl methodsFor: 'private' stamp: 'ls 6/20/1998 19:41'!schemeName: schemeName0  authority: authority0  path: path0  query: query0	"initialize a new instance"	schemeName := schemeName0.	authority := authority0.	path := path0.	query := query0.! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'mir 5/13/2003 10:45'!remoteCursorReceiver	"Wait for a connection, then display data sent by the client until the client closes the stream. This server process is usually started first (optionally in a forked process), then the sender process is started (optionally on another machine). Note this machine's address, which is printed in the transcript, since the sender process will ask for it."	"[SimpleClientSocket remoteCursorReceiver] fork"	| sock response |	Transcript show: 'starting remote cursor receiver'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'opening connection'; cr.	sock := OldSimpleClientSocket new.	sock listenOn: 54323.	sock waitForConnectionUntil: (Socket deadlineSecs: 60).	sock isConnected		ifFalse: [			 sock destroy.			Transcript show: 'remote cursor receiver did not receive a connection in 60 seconds; aborting.'.			^ self].	Transcript show: 'connection established'; cr.	[sock isConnected]		whileTrue: [			sock dataAvailable				ifTrue: [					response := sock getResponse.					response displayOn: Display at: 10@10]				ifFalse: [					"if no data available, let other processes run for a while"					(Delay forMilliseconds: 20) wait]].	sock destroy.	Transcript show: 'remote cursor receiver done'; cr.! !!SocksSocket methodsFor: 'socks4' stamp: 'mir 3/6/2000 15:11'!waitForSocks4ConnectionReply	| response |	response := self waitForReply: 8 for: self defaultTimeOutDuration.	(response at: 2) = self requestGrantedCode		ifFalse: [^self socksError: 'Connection failed: ' , (response at: 2) printString].! !!ServerDirectory class methodsFor: 'available servers' stamp: 'mir 6/26/2001 09:45'!servers	Servers ifNil: [Servers := Dictionary new].	^Servers! !!ConnectionQueue methodsFor: 'public' stamp: 'jm 3/9/98 14:34'!destroy	"Terminate the listener process and destroy all sockets in my possesion."	process ifNotNil: [		process terminate.		process := nil].	socket ifNotNil: [		socket destroy.		socket := nil].	connections do: [:s | s destroy].	connections := OrderedCollection new.! !!SocksSocket methodsFor: 'private' stamp: 'len 12/14/2002 11:39'!waitForReply: replySize for: timeOutDuration	| startTime response delay bytesRead |	startTime := Time millisecondClockValue.	response := ByteArray new: replySize.	bytesRead := 0.	delay := Delay forMilliseconds: 500.	[bytesRead < replySize		and: [(Time millisecondClockValue - startTime) < timeOutDuration]] whileTrue: [		bytesRead := bytesRead + (self receiveDataInto: response).		delay wait.		Transcript show: '.'].	bytesRead < replySize		ifTrue: [self close; destroy.				^ (ConnectionRefused host: self dstIP port: self dstPort) signal].	^response! !!HTTPSocket class methodsFor: 'utilities' stamp: 'ar 4/10/2005 18:47'!argString: args	"Return the args in a long string, as encoded in a url"	| argsString first |	args isString ifTrue: ["sent in as a string, not a dictionary"		^ (args first = $? ifTrue: [''] ifFalse: ['?']), args].	argsString := WriteStream on: String new.	argsString nextPut: $?.	first := true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first := false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key encodeForHTTP.			argsString nextPut: $=.			argsString nextPutAll: value encodeForHTTP. ] ].	^ argsString contents! !!Password methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 21:08'!decode: string	"Xor with secret number -- just so file won't have raw password in it"	| kk rand |	rand := Random new seed: 234237.	kk := (ByteArray new: string size) collect: [:bb | (rand next * 255) asInteger].	1 to: kk size do: [:ii |		kk at: ii put: ((kk at: ii) bitXor: (string at: ii) asciiValue)].	^ kk asString! !!OldSocket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:14'!tcpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock := super new initialize: TCPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 12:13'!nameForWellKnownTCPPort: portNum	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."	| portList entry |	portList := #(		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')		(21 'ftp') (23 'telnet') (25 'smtp')		(80 'http') (110 'pop3') (119 'nntp')).	entry := portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].	^ entry last! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'mir 5/13/2003 10:45'!forkingRemoteCursorSender	"This is the client side of a test that sends samples of the local input sensor state to the server, which may be running on a local or remote host. This method opens the connection, then forks a process to send the cursor data. Data is sent continuously until the user clicks in a 20x20 pixel square at the top-left corner of the display. The server should be started first. Note the server's address, since this method will prompt you for it."	"SimpleClientSocket forkingRemoteCursorSender"	| sock addr stopRect |	Transcript show: 'starting remote cursor sender'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	addr := NetNameResolver promptUserForHostAddress.	Transcript show: 'opening connection'; cr.	sock := OldSimpleClientSocket new.	sock connectTo: addr port: 54323.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [self error: 'sock not connected'].	Transcript show: 'connection established'; cr.	stopRect := 0@0 corner: 20@20.  "click in this rectangle to stop sending"	Display reverse: stopRect.	["the sending process"		[(stopRect containsPoint: Sensor cursorPoint) and:		 [Sensor anyButtonPressed]]			whileFalse: [				sock sendCommand: self sensorStateString.				(Delay forMilliseconds: 20) wait].		sock waitForSendDoneUntil: self standardDeadline.		sock destroy.		Transcript show: 'remote cursor sender done'; cr.		Display reverse: stopRect.	] fork.! !!ServerDirectory class methodsFor: 'available servers' stamp: 'mir 6/26/2001 09:45'!resetServers	Servers := nil! !!MIMEDocument class methodsFor: 'content-types' stamp: 'bolot 11/27/1999 14:26'!guessTypeFromExtension: ext	"guesses a content type from the extension"	| extension |	extension := ext asString.	(extension includes: $.) ifTrue: [ ^self defaultContentType].	MIMEdatabase ifNil: [self resetMIMEdatabase].	^ MIMEdatabase at: extension ifAbsent: [self defaultContentType].! !!SocketStream methodsFor: 'stream out' stamp: 'md 2/24/2006 19:51'!nextPut: char	"Put a single Character or byte onto the stream."	| toPut |	toPut := binary ifTrue: [char asInteger] ifFalse: [char asCharacter].	self adjustOutBuffer: 1.	outBuffer at: outNextToWrite put: toPut.	outNextToWrite := outNextToWrite + 1.	self checkFlush.	"return the argument - added by kwl"	^ char! !!ServerDirectory methodsFor: 'updates' stamp: 'rbb 2/18/2005 14:31'!exportUpdatesExcept: skipList	"Into the section of updates.list corresponding to this version,	copy all the fileNames in the named updates.list for this group	that are more recently numbered.""		(ServerDirectory serverInGroupNamed: 'Disney Internal Updates*')			exportUpdatesExcept: #(3959)."	| myServers updateStrm response seq indexPrefix listContents version versIndex lastNum expContents expVersIndex additions |	self openGroup.	indexPrefix := (self groupName includes: $*) 		ifTrue: [(self groupName findTokens: ' ') first]	"special for internal updates"		ifFalse: ['']. 	"normal"	myServers := self checkServersWithPrefix: indexPrefix					andParseListInto: [:x | listContents := x].	myServers size = 0 ifTrue: [self closeGroup.  ^ self].	version := SystemVersion current version.	versIndex := (listContents collect: [:pair | pair first]) indexOf: version.	versIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	versIndex < listContents size ifTrue:		[response := UIManager default 			chooseFrom: #('Make update from an older version' 'Cancel update')			title: 'This system, ', SystemVersion current version,				' is not the latest version'.		response = 1 ifFalse: [self closeGroup.  ^ nil]].	"abort"	"Get the old export updates.list."	expContents :=  Utilities parseListContents: 			(myServers first getFileNamed: 'updates.list').	expVersIndex := (expContents collect: [:pair | pair first]) indexOf: version.	expVersIndex = 0 ifTrue:		[self inform: 'There is no section in updates.list for your version'.		self closeGroup.  ^ nil].	"abort"	lastNum := (expContents at: expVersIndex) last isEmpty		ifTrue: [0]  "no checking if the current list is empty"		ifFalse: [(expContents at: expVersIndex) last last initialIntegerOrNil].	"Save old copy of updates.list on local disk"	FileDirectory default deleteFileNamed: 'updates.list.bk'.	Utilities writeList: expContents toStream: (FileStream fileNamed: 'updates.list.bk').	"Append all fileNames in my list that are not in the export list"	additions := OrderedCollection new.	(listContents at: versIndex) last do:		[:fileName | seq := fileName initialIntegerOrNil.		(seq > lastNum and: [(skipList includes: seq) not]) ifTrue:			[additions addLast: fileName]].	expContents at: expVersIndex put:		{version. (expContents at: expVersIndex) last , additions}.	(self confirm: 'Do you really want to export ' , additions size printString , ' recent updates?')		ifFalse: [self closeGroup.  ^ nil].	"abort"	"Write a new copy of updates.list on all servers..."	updateStrm := ReadStream on:		(String streamContents: [:s | Utilities writeList: expContents toStream: s]).	myServers do:		[:aServer |		updateStrm reset.		aServer putFile: updateStrm named: 'updates.list' retry: true.		Transcript show: 'Update succeeded on server ', aServer moniker; cr].	self closeGroup.			Transcript cr; show: 'Be sure to test your new update!!'; cr.! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'sma 4/22/2000 17:34'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close.  Response is of type text, not binary."	| buf response bytesRead |	length ifNil: [^ self getRestOfBuffer: beginning].	buf := String new: length.	response := RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf := String new: length.	[(response position < length) & (self isConnected | self dataAvailable)] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead := self primSocket: socketHandle receiveDataInto: buf startingAt: 1 				count: (length - response position). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	"Transcript cr; show: 'data byte count: ', response position printString."	"Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed'])."	response position < length ifTrue: [^ 'server aborted early'].	response reset.	"position: 0."	^ response! !!ConnectionQueue methodsFor: 'public' stamp: 'jm 3/10/98 17:31'!connectionCount	"Return an estimate of the number of currently queued connections. This is only an estimate since a new connection could be made, or an existing one aborted, at any moment."	| count |	self pruneStaleConnections.	accessSema critical: [count := connections size].	^ count! !!OldSocket methodsFor: 'other' stamp: 'JMM 6/3/2000 19:39'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO:=KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo := Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options := {'SO:=DEBUG'. 'SO:=REUSEADDR'. 'SO:=REUSEPORT'. 'SO:=DONTROUTE'.'SO:=BROADCAST'. 'SO:=SNDBUF'. 'SO:=RCVBUF'. 'SO:=KEEPALIVE'.'SO:=OOBINLINE'. 'SO:=PRIORITY'. 'SO:=LINGER'. 'SO:=RCVLOWAT'.'SO:=SNDLOWAT'. 'IP:=TTL'. 'IP:=HDRINCL'. 'IP:=RCVOPTS'.'IP:=RCVDSTADDR'. 'IP:=MULTICAST:=IF'. 'IP:=MULTICAST:=TTL'.'IP:=MULTICAST:=LOOP'. 'UDP:=CHECKSUM'. 'TCP:=MAXSEG'.'TCP:=NODELAY'. 'TCP:=ABORT:=THRESHOLD'. 'TCP:=CONN:=NOTIFY:=THRESHOLD'. 'TCP:=CONN:=ABORT:=THRESHOLD'. 'TCP:=NOTIFY:=THRESHOLD'.'TCP:=URGENT:=PTR:=TYPE'}.1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo := Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum :=foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!SocketStream methodsFor: 'private' stamp: 'gk 2/8/2005 22:15'!moveInBufferDown	"Move down contents of inBuffer to the start.	Return distance moved."	| sz distanceMoved |	sz := inNextToWrite - lastRead - 1.	inBuffer replaceFrom: 1 to: sz with: inBuffer startingAt: lastRead + 1.	distanceMoved := lastRead.	lastRead := 0.	inNextToWrite := sz + 1.	^distanceMoved! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'jrp 8/28/2004 14:53'!privateInitializeFromText: aString 	| remainder ind specifiedSchemeName |	remainder := aString.	schemeName ifNil: 			[specifiedSchemeName := Url schemeNameForString: remainder.			specifiedSchemeName ifNotNil: 					[schemeName := specifiedSchemeName.					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].			schemeName ifNil: 					["assume HTTP"					schemeName := 'http']].	"remove leading // if it's there"	(remainder beginsWith: '//') 		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].	"get the query"	ind := remainder indexOf: $?.	ind > 0 		ifTrue: 			[query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the authority"	ind := remainder indexOf: $/.	ind > 0 		ifTrue: 			[ind = 1 				ifTrue: [authority := '']				ifFalse: 					[authority := remainder copyFrom: 1 to: ind - 1.					remainder := remainder copyFrom: ind + 1 to: remainder size]]		ifFalse: 			[authority := remainder.			remainder := ''].	"extract the username+password"	(authority includes: $@) 		ifTrue: 			[username := authority copyUpTo: $@.			authority := authority copyFrom: (authority indexOf: $@) + 1						to: authority size.			(username includes: $:) 				ifTrue: 					[password := username copyFrom: (username indexOf: $:) + 1 to: username size.					username := username copyUpTo: $:]].	"Extract the port"	(authority includes: $:) 		ifTrue: 			[| lastColonIndex portString |			lastColonIndex := authority findLast: [:c | c = $:].			portString := authority copyFrom: lastColonIndex + 1 to: authority size.			portString isAllDigits 				ifTrue: 					[port := Integer readFromString: portString.					(port > 65535) ifTrue: [self error: 'Invalid port number'].					 authority := authority copyFrom: 1 to: lastColonIndex - 1]				ifFalse:[self error: 'Invalid port number']].	"get the path"	path := self privateParsePath: remainder relativeTo: #() .! !!MIMEDocument methodsFor: 'private' stamp: 'ls 7/23/1998 20:11'!privateContent: aString	content := aString! !!OldSocket class methodsFor: 'registry' stamp: 'ar 12/12/2001 19:12'!registryThreshold: aNumber	"Return the registry threshold above which socket creation may fail due to too many already open sockets. If the threshold is reached, a full GC will be issued if the creation of a socket fails."	RegistryThreshold := aNumber! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'mir 5/13/2003 10:45'!remoteCursorTest	"This version of the remote cursor test runs both the client and the server code in the same loop."	"SimpleClientSocket remoteCursorTest"	| sock1 sock2 samplesToSend samplesSent done t |	Transcript show: 'starting remote cursor test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'opening connection'; cr.	sock1 := OldSimpleClientSocket new.	sock2 := OldSimpleClientSocket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	samplesToSend := 100.	t := Time millisecondsToRun: [		samplesSent := 0.		done := false.		[done]			whileFalse: [				(sock1 sendDone and: [samplesSent < samplesToSend]) ifTrue: [					sock1 sendCommand: self sensorStateString.					samplesSent := samplesSent + 1].				sock2 dataAvailable ifTrue: [					sock2 getResponse displayOn: Display at: 10@10].				done := samplesSent = samplesToSend]].	sock1 destroy.	sock2 destroy.	Transcript show: 'remote cursor test done'; cr.	Transcript show:		samplesSent printString, ' samples sent in ',		t printString, ' milliseconds'; cr.	Transcript show: ((samplesSent * 1000) // t) printString, ' samples/sec'; cr.! !!SocksSocket methodsFor: 'socks5' stamp: 'mir 3/6/2000 17:25'!sendSocks5ConnectionRequest	"Once the method-dependent subnegotiation has completed, the client   sends the request details."	| requestString |	requestString := WriteStream on: ByteArray new.	requestString		nextPut: 5;		nextPut: self connectCommandCode;		nextPut: 0. "Reserved slot"	dstName isNil		ifTrue: [			requestString				nextPutAll: self hostIPCode;				nextPutAll: dstIP]		ifFalse: [			requestString				nextPut: self qualifiedHostNameCode;				nextPut: dstName size;				nextPutAll: dstName asByteArray].	requestString nextWordPut: dstPort.	self sendData: requestString contents! !!UUIDGenerator methodsFor: 'instance creation' stamp: 'JMM 11/22/2001 23:13'!generateFieldsVersion4	timeLow := self generateRandomBitsOfLength: 32.	timeMid := self generateRandomBitsOfLength: 16.	timeHiAndVersion := 16r4000 bitOr: (self generateRandomBitsOfLength: 12).	clockSeqHiAndReserved := 16r80 bitOr: (self generateRandomBitsOfLength: 6).	clockSeqLow := self generateRandomBitsOfLength: 8.	node := self generateRandomBitsOfLength: 48.	! !!Url class methodsFor: 'parsing' stamp: 'gk 10/21/2005 10:47'!absoluteFromText: aString	"Return a URL from a string and handle	a String without a scheme as a HttpUrl."	"Url absoluteFromText: 'http://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part'" 	"Url absoluteFromText: 'msw://chaos.resnet.gatech.edu:9000/testbook?top'"	"Url absoluteFromText: 'telnet:chaos.resnet.gatech.edu'"	"Url absoluteFromText: 'file:/etc/passwd'"	| remainder index scheme fragment newUrl |	"trim surrounding whitespace"	remainder := aString withBlanksTrimmed.		"extract the fragment, if any"	index := remainder indexOf: $#.	index > 0 ifTrue: [		fragment := remainder copyFrom: index + 1 to: remainder size.		remainder := remainder copyFrom: 1 to: index - 1].	"choose class based on the scheme name, and let that class do the bulk of the parsing"	scheme := self schemeNameForString: remainder.	newUrl := (self urlClassForScheme: scheme) new privateInitializeFromText: remainder.	newUrl privateFragment: fragment.	^newUrl! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'ls 8/12/1998 00:26'!contentType: aString  content: content  url: aUrl	"create a MIMEObject with the given content-type and content"	"MIMEObject contentType: 'text/plain' content: 'This is a test'"		| ans idx |	ans := self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx := aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	ans privateUrl: aUrl asUrl.	^ans! !!URI class methodsFor: 'instance creation' stamp: 'mir 2/20/2002 17:23'!extractSchemeFrom: aString	| colonIndex slashIndex |	colonIndex := aString indexOf: $: .	^colonIndex > 0		ifTrue: [			slashIndex := aString indexOf: $/ .			(slashIndex == 0				or: [colonIndex < slashIndex])				ifTrue: [aString copyFrom: 1 to: colonIndex-1]				ifFalse: [nil]]		ifFalse: [nil]! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'hg 2/11/2002 13:55'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm tries |	buf := String new: 2000.	response := WriteStream on: buf.	tester := 1. mm := 1.	tries := 3.	[tester := tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm := mm + 1] ifFalse: [mm := 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester := 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable) 			& ((tries := tries - 1) >= 0)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: ' <response was late> '].		bytesRead := self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!FileUrl methodsFor: 'paths' stamp: 'gk 2/10/2004 10:22'!pathString	"Path as it appears in a URL with $/ as delimiter."		| first |	^String streamContents: [ :s |		"isAbsolute ifTrue:[ s nextPut: $/ ]."		first := true.		self path do: [ :p |			first ifFalse: [ s nextPut: $/ ].			first := false.			s nextPutAll: p encodeForHTTP ] ]! !!OldSocket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:14'!udpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock := super new initialize: UDPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!SocksSocket methodsFor: 'initialize' stamp: 'mir 9/26/2000 00:05'!socks4	vers := 4.	method := nil.	socksIP := self class defaultSocksHostAddress.	socksPort := self class defaultSocksPort! !!MIMELocalFileDocument methodsFor: 'accessing' stamp: 'ar 4/24/2001 16:28'!content	^content ifNil:[content := contentStream contentsOfEntireFile].! !!ServerDirectory methodsFor: 'up/download' stamp: 'nk 8/30/2004 08:00'!putFile: fileStream named: fileNameOnServer retry: aBool	"ar 11/24/1998 Do the usual putFile:named: operation but retry if some error occurs and aBool is set. Added due to having severe transmission problems on shell.webpage.com."	| resp |	self isTypeFile ifTrue: [		^ (FileDirectory on: urlObject pathForDirectory)			putFile: fileStream named: fileNameOnServer].	[[resp := self putFile: fileStream named: fileNameOnServer] 		ifError:[:err :rcvr| resp := '5xx ',err]. "Report as error"	aBool and:[((resp isString) and: [resp size > 0]) and:[resp first ~= $2]]] whileTrue:[		(self confirm:('Error storing ',fileNameOnServer,' on the server.\(',resp,',)\Retry operation?') withCRs) ifFalse:[^resp].	].	^resp! !!HttpUrl methodsFor: 'downloading' stamp: 'fbs 2/2/2005 13:24'!postMultipartFormArgs: args	| contents request |	request := realm ifNotNil: [Passwords at: realm ifAbsent: ['']]		ifNil: [''].	request = '' ifFalse: [request := 'Authorization: Basic ', request, String crlf].		"Why doesn't Netscape send the name of the realm instead of Basic?"	contents := (HTTPSocket httpPostMultipart: self asString args: args				accept: 'application/octet-stream' request: request).	self checkAuthorization: contents retry: [^ self postMultipartFormArgs: args].	^self normalizeContents: contents! !!FTPClient methodsFor: 'private protocol' stamp: 'svp 10/28/2003 11:06'!get: limit dataInto: dataStream	"Reel in data until the server closes the connection or the limit is reached.	At the same time, watch for errors on otherSocket."	| buf bytesRead currentlyRead |	currentlyRead := 0.	buf := String new: 4000.	[currentlyRead < limit and: 	[self dataSocket isConnected or: [self dataSocket dataAvailable]]]		whileTrue: [			self checkForPendingError.			bytesRead := self dataSocket receiveDataWithTimeoutInto: buf.			1 to: (bytesRead min: (limit - currentlyRead)) do: [:ii | dataStream nextPut: (buf at: ii)].			currentlyRead := currentlyRead + bytesRead].	dataStream reset.	"position: 0."	^ dataStream! !!SuperSwikiServer methodsFor: 'for real' stamp: 'md 11/14/2003 17:28'!matchingEntries: criteria	| result |	eToyUserListUrl ifNil:[^self entries].	result := self sendToSwikiProjectServer: {		'action: listmatchingprojects'.	}  , criteria.	(result beginsWith: 'OK')		ifFalse: [^self entries]. "If command not supported"	^self parseListEntries: result! !!FTPClient methodsFor: 'protocol' stamp: 'mir 11/19/2002 19:23'!getFileNamed: remoteFileName	| data |	self openPassiveDataConnection.	self sendCommand: 'RETR ', remoteFileName.	[self checkResponse]		on: TelnetProtocolError		do: [:ex |			self closeDataSocket.			ex pass].	data := self getData.	self checkResponse.	^data! !!ServerDirectory class methodsFor: 'server prefs' stamp: 'KR 1/30/2006 22:16'!parseServerEntryFrom: stream		| server type directory entries serverName |	entries := ExternalSettings parseServerEntryArgsFrom: stream.	serverName := entries at: 'name' ifAbsent: [^nil].	directory := entries at: 'directory' ifAbsent: [^nil].	type := entries at: 'type' ifAbsent: [^nil].	type = 'file'		ifTrue: [			server := self determineLocalServerDirectory: directory.			entries at: 'userListUrl' ifPresent:[:value | server eToyUserListUrl: value].			entries at: 'baseFolderSpec' ifPresent:[:value | server eToyBaseFolderSpec: value].			^self addLocalProjectDirectory: server].	type = 'bss'		ifTrue: [server := SuperSwikiServer new type: #http].	type = 'http'		ifTrue: [server := HTTPServerDirectory new type: #ftp].	type = 'ftp'		ifTrue: [server := ServerDirectory new type: #ftp].	server directory: directory.	entries at: 'server' ifPresent: [:value | server server: value].	entries at: 'user' ifPresent: [:value | server user: value].	entries at: 'group' ifPresent: [:value | server groupName: value].	entries at: 'passwdseq' ifPresent: [:value | server passwordSequence: value asNumber].	entries at: 'url' ifPresent: [:value | server altUrl: value].	entries at: 'loaderUrl' ifPresent: [:value | server loaderUrl: value].	entries at: 'acceptsUploads' ifPresent: [:value | server acceptsUploads: value asLowercase = 'true'].	entries at: 'userListUrl' ifPresent:[:value | server eToyUserListUrl: value].	entries at: 'encodingName' ifPresent:[:value | server encodingName: value].	ServerDirectory addServer: server named: serverName.! !!FileUrl methodsFor: 'testing' stamp: 'gk 2/9/2004 20:32'!firstPartIsDriveLetter	"Return true if the first part of the path is a letter	followed by a $: like 'C:' "		| firstPart |	path isEmpty ifTrue: [^false].	firstPart := path first.	^firstPart size = 2 and: [		firstPart first isLetter			and: [firstPart last = $:]]! !!MailMessage methodsFor: 'parsing' stamp: 'mdr 2/11/2001 17:58'!reportField: aString to: aBlock	"Evaluate the given block with the field name a value in the given field. Do nothing if the field is malformed."	| s fieldName fieldValue |	(aString includes: $:) ifFalse: [^self].	s := ReadStream on: aString.	fieldName := (s upTo: $:) asLowercase.	"fieldname must be lowercase"	fieldValue := s upToEnd withBlanksTrimmed.	fieldValue isEmpty ifFalse: [aBlock value: fieldName value: fieldValue].! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 4/10/2005 18:47'!httpFileIn: url	"Do a regular file-in of a file that is served from a web site.  If the file contains an EToy, then open it.  Might just be code instead.  tk 7/23/97 17:10"	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones.  The server does not have to know about the .sqo extension in order to send your file.  (We do not need a new MIME type and .sqo does not have to be registered with the server.)"	"	HTTPSocket httpFileIn: 'www.webPage.com/~kaehler2/sample.etoy'	 "	"	HTTPSocket httpFileIn: '206.18.68.12/squeak/car.sqo'	 "	"	HTTPSocket httpFileIn: 'jumbo/tedk/sample.etoy'	 "	| doc eToyHolder |	doc := self httpGet: url accept: 'application/octet-stream'.	doc isString ifTrue:			[self inform: 'Cannot seem to contact the web site'].	doc reset.	eToyHolder := doc fileInObjectAndCode.	eToyHolder ifNotNil: [eToyHolder open].	"Later may want to return it, instead of open it"! !!SocketStream class methodsFor: 'instance creation' stamp: 'gk 2/3/2005 20:35'!openConnectionToHostNamed: hostName port: portNumber	| hostIP |	hostIP := NetNameResolver addressForName: hostName timeout: 20.	^self openConnectionToHost: hostIP port: portNumber! !!OldSimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'jm 9/15/97 13:11'!sensorStateString	"SimpleClientSocket sensorStateString"	| pt buttons s |	pt := Sensor cursorPoint.	buttons := Sensor primMouseButtons.	s := WriteStream on: (String new: 100).	s nextPutAll: pt x printString.	s space.	s nextPutAll: pt y printString.	s space.	s nextPutAll: buttons printString.	^ s contents! !!OldSocket methodsFor: 'waiting' stamp: 'JMM 5/22/2000 22:04'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived := self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self readSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!HTTPSocket class methodsFor: 'get the page' stamp: 'nk 8/30/2004 07:50'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document := self httpPostDocument: url  args: argsDict  accept: mimeType  request: ''.	(document isString) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!SuperSwikiServer methodsFor: 'for real' stamp: 'mir 8/23/2001 22:15'!allEntries	| answer |	answer := self sendToSwikiProjectServer: {		'action: listallprojects'.	}.	(answer beginsWith: 'OK') ifFalse: [^#()].	^self parseListEntries: answer! !!GenericUrl methodsFor: 'parsing' stamp: 'ls 8/4/1998 01:28'!privateInitializeFromText: aString	schemeName := Url schemeNameForString: aString.	schemeName ifNil: [ self error: 'opaque URL with no scheme--shouldn''t happen!!'. ].	locator := aString copyFrom: (schemeName size+2) to: aString size.! !!MailMessage methodsFor: 'parsing' stamp: ''!readDateFrom: aStream	"Parse a date from the given stream and answer nil if the date can't be parsed. The date may be in any of the following forms:		<day> <monthName> <year>		(5 April 1982; 5-APR-82)		<monthName> <day> <year>		(April 5, 1982)		<monthNumber> <day> <year>		(4/5/82)	In addition, the date may be preceded by the day of the week and an optional comma, such as:		Tue, November 14, 1989"	| day month year |	self skipWeekdayName: aStream.	aStream peek isDigit ifTrue: [day := Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue:		"month name or weekday name"			[month := WriteStream on: (String new: 10).			 [aStream peek isLetter] whileTrue: [month nextPut: aStream next].			 month := month contents.			 day isNil ifTrue:		"name/number..."				[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].				 (aStream peek isDigit) ifFalse: [^nil].				 day := Integer readFrom: aStream]]		ifFalse:		"number/number..."			[month := Date nameOfMonth: day.			 day := Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	(aStream peek isDigit) ifFalse: [^nil].	year := Integer readFrom: aStream.	^Date newDay: day month: month year: year! !!SocketStream methodsFor: 'private' stamp: 'gk 9/9/2005 02:29'!resizeInBuffer: newSize	"Resize the inBuffer by recreating it.	This also has the effect of getting rid of	dead data above inNextToWrite.	<newSize> must >= inBuffer size!!"	inBuffer := (self streamBuffer: newSize)					replaceFrom: 1 to: inNextToWrite - 1 with: inBuffer startingAt: 1! !!OldSimpleClientSocket class methodsFor: 'POP mail example' stamp: 'tk 4/10/1998 06:47'!simpleDateString: dateString	| s |	s := ReadStream on: dateString.	s skipTo: $,.  "scan thru first comma"	s atEnd ifTrue: [s reset].  "no comma found; reset s"	s skipSeparators.	^ (Date readFrom: s) mmddyyyy! !!ServerDirectory methodsFor: 'dis/connect' stamp: 'rbb 2/18/2005 14:41'!openFTPClient	| loginSuccessful what |	client		ifNotNil: [client isConnected			ifTrue: [^client]			ifFalse: [client := nil]].	client := FTPClient openOnHostNamed: server.	loginSuccessful := false.	[loginSuccessful]		whileFalse: [			[loginSuccessful := true.			client loginUser: self user password: self password]				on: LoginFailedException				do: [:ex | 					passwordHolder := nil.					what := UIManager default 						chooseFrom: #('enter password' 'give up') 						title: 'Would you like to try another password?'.					what = 1 ifFalse: [self error: 'Login failed.'. ^nil].					loginSuccessful := false]].	client changeDirectoryTo: directory.	^client! !!MIMEHeaderValue class methodsFor: 'instance creation' stamp: 'mdr 4/11/2001 13:21'!fromMIMEHeader: aString	"This is the value of a MIME header field and so is parsed to extract the various parts"	| parts newValue parms separatorPos parmName parmValue |	newValue := self new.	parts := ReadStream on: (aString findTokens: ';').	newValue mainValue: parts next.	parms := Dictionary new.	parts do: 		[:e | 		separatorPos := e findAnySubStr: '=' startingAt: 1. 		separatorPos <= e size			ifTrue: 				[parmName := (e copyFrom: 1 to: separatorPos - 1) withBlanksTrimmed asLowercase.				parmValue := (e copyFrom: separatorPos + 1 to: e size) withBlanksTrimmed withoutQuoting.				parms at: parmName put: parmValue]].	newValue parameters: parms.	^ newValue! !!MailMessage methodsFor: 'fields' stamp: 'ls 2/10/2001 13:47'!rewriteFields: aBlock append: appendBlock	"Rewrite header fields. The body is not modified.	Each field's key and value is reported to aBlock. The block's return value is the replacement for the entire header line. Nil means don't change the line, empty means delete it. After all fields are processed, evaluate appendBlock and append the result to the header."	| old new result appendString |	self halt: 'this method is out of date.  it needs to update body, at the very least.  do we really need this now that we have setField:to: and setField:toString: ?!!'.	old := ReadStream on: text.	new := WriteStream on: (String new: text size).	self fieldsFrom: old do: [ :fName :fValue |		result := aBlock value: fName value: fValue.		result ifNil: [new nextPutAll: fName, ': ', fValue; cr]			ifNotNil: [result isEmpty				ifFalse: [new nextPutAll: result.					result last = Character cr ifFalse: [new cr]]]].	appendString := appendBlock value.	appendString isEmptyOrNil ifFalse:		[new nextPutAll: appendString.		appendString last = Character cr ifFalse: [new cr]].	new cr. "End of header"	text := new contents, old upToEnd.! !!SocketStream methodsFor: 'private' stamp: 'gk 2/9/2005 22:44'!adjustInBuffer: bytesRead	"Adjust markers and possibly grow inBuffer or move data down.	Currently grows through doubling when less than 1024 bytes are left.	Never shrinks. Returns the position in the buffer where any new	data can be found."	| old |	bytesRead = 0 ifTrue: [^inNextToWrite].	old := inNextToWrite.	inNextToWrite := inNextToWrite + bytesRead.	(inBuffer size - inNextToWrite) < 1024		ifTrue: [			"Hit the roof, move data down (if enough has been read) or do we grow?"			(lastRead > 512)				ifTrue: [^old - self moveInBufferDown]				ifFalse: [self growInBuffer]].	^old! !!URI methodsFor: 'private' stamp: 'mir 2/27/2002 14:18'!extractSchemeSpecificPartAndFragment: remainder	| fragmentIndex |	fragmentIndex := remainder indexOf: $# .	fragmentIndex > 0		ifTrue: [			schemeSpecificPart := remainder copyFrom: 1 to: fragmentIndex-1.			fragment := remainder copyFrom: fragmentIndex+1 to: remainder size]		ifFalse: [schemeSpecificPart := remainder]! !!TextMessageLink methodsFor: 'acting' stamp: 'rbb 2/18/2005 09:33'!actOnClickFor: evt 	| choice viewMsg |	viewMsg := message containsViewableImage		ifTrue: ['view this image attachment']		ifFalse: ['view this attachment'].	choice := UIManager default chooseFrom: (Array with: viewMsg 													with: 'save this attachment' ).	choice = 1		ifTrue: ["open a new viewer"			message viewBody].	choice = 2		ifTrue: ["save the mesasge"			message save].	^ true! !!ServerDirectory class methodsFor: 'misc' stamp: 'tk 12/29/1998 22:46'!defaultStemUrl	"For writing on an FTP directory.  Users should insert their own server url here.""ftp://jumbo.rd.wdi.disney.com/raid1/people/dani/Books/Grp/Grp""	ServerDirectory defaultStemUrl	"| rand dir |rand := String new: 4.1 to: rand size do: [:ii |	rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].dir := self serverNamed: 'DaniOnJumbo'.^ 'ftp://', dir server, dir slashDirectory, '/BK', rand! !!FileUrl methodsFor: 'private-initialization' stamp: 'gk 2/12/2004 16:11'!privateInitializeFromText: aString	"Calculate host and path from a file URL in String format.	Some malformed formats are allowed and interpreted by guessing."	| schemeName pathString bare hasDriveLetter stream char i |	bare := aString withBlanksTrimmed.	schemeName := Url schemeNameForString: bare.	(schemeName isNil or: [schemeName ~= self schemeName])		ifTrue: [			host := ''.			pathString := bare]		ifFalse: [			"First remove schemeName and colon"			bare := bare copyFrom: (schemeName size + 2) to: bare size.			"A proper file URL then has two slashes before host,			A malformed URL is interpreted as using syntax file:<path>."			(bare beginsWith: '//')				ifTrue: [i := bare indexOf: $/ startingAt: 3.						i=0 ifTrue: [								host := bare copyFrom: 3 to: bare size.								pathString := '']							ifFalse: [								host := bare copyFrom: 3 to: i-1.								pathString := bare copyFrom: host size + 3 to: bare size]]				ifFalse: [host := ''.						pathString := bare]].	self initializeFromPathString: pathString! !!MIMEDocument methodsFor: 'private' stamp: 'ls 7/23/1998 20:06'!privateMainType: aString	mainType := aString! !!FTPClient methodsFor: 'private protocol' stamp: 'svp 10/28/2003 11:04'!getDataInto: dataStream	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf := String new: 4000.	[self dataSocket isConnected or: [self dataSocket dataAvailable]]		whileTrue: [			self checkForPendingError.			bytesRead := self dataSocket receiveDataWithTimeoutInto: buf.			1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)]].	dataStream reset.	"position: 0."	^ dataStream! !!SuperSwikiServer methodsFor: 'testing' stamp: 'RAA 10/25/2000 12:14'!speedTest1"SuperSwikiServer testOnlySuperSwiki speedTest1"	| answer t totalTime |	totalTime := [		answer := (1 to: 10) collect: [ :x |			t := [answer := self sendToSwikiProjectServer: {				'action: readnamedfile'.				'projectname: xyz.002.pr'.			}] timeToRun.			{t. answer size}		].	] timeToRun.	^{totalTime. answer}! !!NetNameResolver class methodsFor: 'lookups' stamp: 'nk 6/27/2003 10:51'!nameForAddress: hostAddress timeout: secs	"Look up the given host address and return its name. Return nil if the lookup fails or is not completed in the given number of seconds. Depends on the given host address being known to the gateway, which may not be the case for dynamically allocated addresses."	"NetNameResolver		nameForAddress: (NetNameResolver addressFromString: '128.111.92.2')		timeout: 30"	| deadline result |	self initializeNetwork.	deadline := Time millisecondClockValue + (secs * 1000).	"Protect the execution of this block, as the ResolverSemaphore is used for both parts of the transaction."	self resolverMutex		critical: [			result := (self waitForResolverReadyUntil: deadline)				ifTrue: [					self primStartLookupOfAddress: hostAddress.					(self waitForCompletionUntil: deadline)						ifTrue: [self primAddressLookupResult]						ifFalse: [nil]]				ifFalse: [nil]].	^result! !!SocketStream methodsFor: 'stream in' stamp: 'gk 2/15/2005 14:15'!skip: anInteger	"Skip a number of bytes.	This is faster than #next: since it does not	have to copy and return a new String or ByteArray.	NOTE: This method doesn't honor timeouts if shouldSignal is false!!"	self receiveData: anInteger.	lastRead := (lastRead + anInteger) min: inNextToWrite - 1! !!SuperSwikiServer methodsFor: 'for real' stamp: 'KR 2/20/2006 12:50'!updateProjectInfoFor: aProject	| data details projectLinks linkString uploader |	data := OrderedCollection new.	data add: 'action: updatepage'.	data add: 'password: ',ProjectPasswordNotification signal.	data add: 'projectimage: ', (aProject name convertToEncoding: self encodingName) , '.gif'.	uploader := Utilities authorNamePerSe.	uploader isEmptyOrNil ifTrue: [uploader := Utilities authorInitialsPerSe].	uploader isEmptyOrNil ifFalse: [		data add: ('submittedBy: ',uploader convertToEncoding: self encodingName).	].	projectLinks := Set new.	aProject world allMorphsDo: [ :each |		(each isKindOf: ProjectViewMorph) ifTrue: [			projectLinks add: each safeProjectName.		].	].	details := aProject world valueOfProperty: #ProjectDetails ifAbsent: [Dictionary new].	details at: 'projectname' ifAbsentPut: [aProject name].	projectLinks isEmpty ifTrue: [		details removeKey: 'projectlinks' ifAbsent: []	] ifFalse: [		linkString := String streamContents: [ :strm |			projectLinks asSortedCollection do: [ :each |				strm nextPutAll: each			] separatedBy: [				strm nextPut: $.			].		].		details at: 'projectlinks' put: linkString	].	details keysAndValuesDo: [ :k :v |		data add: k , ': ' , (v convertToEncoding: self encodingName). self flag: #yoFlag.	].	^self sendToSwikiProjectServer: data! !!POP3Client methodsFor: 'private protocol' stamp: 'BG 3/16/2005 08:27'!apopLogin	"Attempt to authenticate ourselves to the server without sending the password as cleartext."	"For secure authentication, we look for a timestamp in the initial response string we get from the server, and then try the APOP command as specified in RFC 1939.  If the initial response from the server is	+OK POP3 server ready <1896.697170952@dbc.mtview.ca.us>we extract the timestamp	<1896.697170952@dbc.mtview.ca.us>then form a string of the form	<1896.697170952@dbc.mtview.ca.us>USERPASSWORDand then send only the MD5 hash of that to the server.  Thus the password never hits the wire"	| timestamp hash |	[	"Look for a timestamp in the response we received from the server"	timestamp := self lastResponse findTokens: '<>' includes: '@'.	timestamp		ifNil: [(POP3LoginError protocolInstance: self) signal: 'APOP not supported.'].	(Smalltalk includesKey: #MD5)		ifTrue: [			hash := ((Smalltalk at: #MD5) hashMessage: ('<', timestamp, '>', self password)) storeStringHex asLowercase.			"trim starting 16r and zero pad it to 32 characters if needed"			hash := hash  padded: #left to: 32 with: $0]		ifFalse: [(POP3LoginError protocolInstance: self) signal: 'APOP (MD5) not supported.'].	self sendCommand: 'APOP ', self user, ' ', hash.	self checkResponse.	self logProgress: self lastResponse]		on: ProtocolClientError		do: [:ex |			self close.			(LoginFailedException protocolInstance: self) signal: 'Login failed.']! !!FileDirectory methodsFor: '*network-uri' stamp: 'mir 10/20/2003 16:03'!uri	"Convert my path into a file:// type url.  Use slash instead of the local delimiter (:), and convert odd characters to %20 notation."	"If slash (/) is not the file system delimiter, encode slashes before converting."	| list |	list := self pathParts.	^(String streamContents: [:strm |		strm nextPutAll: 'file:'.		list do: [:each | strm nextPut: $/; nextPutAll: each "encodeForHTTP"].		strm nextPut: $/]) asURI! !!HierarchicalURI methodsFor: 'private' stamp: 'mir 2/27/2002 14:30'!removeComponentDotDotPairs: pathComponents	| dotDotIndex |	dotDotIndex := pathComponents indexOf: '..'.	[dotDotIndex > 1]		whileTrue: [			pathComponents				removeAt: dotDotIndex;				removeAt: dotDotIndex-1.			dotDotIndex := pathComponents indexOf: '..']! !!SocketStream methodsFor: 'initialize-release' stamp: 'gk 2/25/2005 14:20'!initialize	autoFlush := true.	shouldSignal := true.	recentlyRead := 0.	bufferSize := 4096.	self ascii! !!MIMEDocument methodsFor: 'private' stamp: 'ls 8/12/1998 00:25'!privateUrl: aUrl	url := aUrl! !!RemoteFileStream methodsFor: 'as yet unclassified' stamp: 'tk 1/13/2000 21:45'!dataIsValid	localDataValid := true.! !!ProtocolClient methodsFor: 'actions' stamp: 'mir 3/7/2002 13:10'!close	self stream		ifNotNil: [			self stream close.			stream := nil]! !!FTPClient methodsFor: 'private protocol' stamp: 'mir 4/7/2003 16:59'!openPassiveDataConnection	| portInfo list dataPort remoteHostAddress |	self sendCommand: 'PASV'.	self lookForCode: 227 ifDifferent: [:response | (TelnetProtocolError protocolInstance: self) signal: 'Could not enter passive mode: ' , response].	portInfo := (self lastResponse findTokens: '()') at: 2.	list := portInfo findTokens: ','.	remoteHostAddress := ByteArray		with: (list at: 1) asNumber		with: (list at: 2) asNumber		with: (list at: 3) asNumber		with: (list at: 4) asNumber.	dataPort := (list at: 5) asNumber * 256 + (list at: 6) asNumber.	self openDataSocket: remoteHostAddress port: dataPort! !!ServerFile methodsFor: 'as yet unclassified' stamp: 'tk 5/18/1998 16:42'!readOnly	"Set the receiver to be read-only"	rwmode := false! !!ServerDirectory methodsFor: 'accessing' stamp: 'RAA 9/14/2000 13:24'!loaderUrl: aString	loaderUrl := aString! !!MailAddressParser methodsFor: 'building address list' stamp: 'ls 9/13/1998 01:30'!startNewAddress	"set up data structures to begin a new address"	(curAddrTokens ~~ nil) ifTrue: [		self error: 'starting new address before finishing the last one!!' ].	curAddrTokens := OrderedCollection new.	! !OldSimpleClientSocket initialize!ServerDirectory initialize!NetNameResolver initialize!OldSocket initialize!URI initialize!Socket initialize!