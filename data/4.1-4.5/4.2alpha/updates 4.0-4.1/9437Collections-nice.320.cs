"Change Set:		9437Collections-nice.320Collections-nice.320:Let findAnySubStr:startingAt: use inject:into:Minor speed up, better code, no outer temp assignmentCollections-ul.313:Finalization enhancement (part 2)- cleanupCollections-edc.314:Added String-lastPositionOf convenience methodCollections-ar.315:Fix an ancient bug in RunArray class>>scanFrom: which was never triggered in the past since RunArray contents would never be empty (initialized to a TextFontChange at least). Now they can be, which unveiled the bug, namely that when a RunArray of the form:	RunArray 		runs: #(1 1 1) 		values: { {}. {TextEmphasis bold}. {} }.would be stored, the last value element would be lost when reading it back. With rather hairy consequences.Also, we can afford meaningful variable names in our code instead of 'aa', 'rr', and 'vv'.Collections-ar.316:Oops, RunArray values should be arrays not ordered collections.Collections-ul.317:- removed String >> #lastPositionOf: because it does the same as SequenceableCollection >> #lastIndexOf:Collections-ar.318:Introducing NullStream - a generator and consumer of an infinite number of elements just like /dev/null. Useful for testing and benchmarks.Collections-nice.319:Let ByteArray readHexFrom: read both upper and lower case        ByteArray readHexFrom: '7A2BD507'                => #[122 43 213 7]"!Collection subclass: #WeakRegistry	instanceVariableNames: 'valueDictionary accessLock'	classVariableNames: 'Default'	poolDictionaries: ''	category: 'Collections-Weak'!Stream subclass: #NullStream	instanceVariableNames: 'binary position'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Streams'!!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!reset	"Set the receiver's position to the beginning of the sequence of objects."	position := 0! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!collectionSpecies	"The type of collection returned by the stream"	^binary ifTrue:[ByteArray] ifFalse:[ByteString]! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 04:20'!peek	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	^self element! !!ByteArray methodsFor: 'initialize' stamp: 'nice 2/26/2010 00:04'!readHexFrom: aStream	"Initialize the receiver from a hexadecimal string representation"	| map v ch value |	map := '0123456789abcdefABCDEF'.	1 to: self size do:[:i|		ch := aStream next.		v := (map indexOf: ch) - 1.		((v between: 0 and: 15) or: [((v:= v - 6) between: 0 and: 15)]) ifFalse:[^self error: 'Hex digit expected'].		value := v bitShift: 4.		ch := aStream next.		v := (map indexOf: ch) - 1.		((v between: 0 and: 15) or: [((v:= v - 6) between: 0 and: 15)]) ifFalse:[^self error: 'Hex digit expected'].		value := value + v.		self at: i put: value.	].! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!element	"The element returned by the stream"	^binary ifTrue:[0] ifFalse:[Character value: 0]! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!ascii	"Switches the stream to ascii mode"	binary := false.! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 04:19'!nextInto: aCollection startingAt: startIndex	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: (aCollection size - startIndex+1) into: aCollection startingAt: startIndex.! !!RunArray class methodsFor: 'instance creation' stamp: 'ar 2/24/2010 18:18'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds.  These are written by the implementors of writeScanOn:"	| runs values attrList char |	(strm peekFor: $( ) ifFalse: [^ nil].	runs := OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[runs add: (Number readFrom: strm)].	values := OrderedCollection new.	"Value array"	attrList := OrderedCollection new.	"Attributes list"	[(char := strm next) == nil] whileFalse: [		char == $, ifTrue: [values add: attrList asArray.  attrList := OrderedCollection new].		char == $a ifTrue: [attrList add: 			(TextAlignment new alignment: (Integer readFrom: strm ifFail: [0]))].		char == $f ifTrue: [attrList add: 			(TextFontChange new fontNumber: (Integer readFrom: strm ifFail: [0]))].		char == $F ifTrue: [attrList add: (TextFontReference toFont: 			(StrikeFont familyName: (strm upTo: $#) size: (Integer readFrom: strm ifFail: [0])))].		char == $b ifTrue: [attrList add: (TextEmphasis bold)].		char == $i ifTrue: [attrList add: (TextEmphasis italic)].		char == $u ifTrue: [attrList add: (TextEmphasis underlined)].		char == $= ifTrue: [attrList add: (TextEmphasis struckOut)].		char == $n ifTrue: [attrList add: (TextEmphasis normal)].		char == $- ifTrue: [attrList add: (TextKern kern: -1)].		char == $+ ifTrue: [attrList add: (TextKern kern: 1)].		char == $c ifTrue: [attrList add: (TextColor scanFrom: strm)]. "color"		char == $L ifTrue: [attrList add: (TextLink scanFrom: strm)].	"L not look like 1"		char == $R ifTrue: [attrList add: (TextURL scanFrom: strm)].				"R capitalized so it can follow a number"		char == $q ifTrue: [attrList add: (TextSqkPageLink scanFrom: strm)].		char == $p ifTrue: [attrList add: (TextSqkProjectLink scanFrom: strm)].		char == $P ifTrue: [attrList add: (TextPrintIt scanFrom: strm)].		char == $d ifTrue: [attrList add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	values add: attrList asArray.	^ self runs: runs asArray values: (values copyFrom: 1 to: runs size) asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 04:19'!next: anInteger putAll: aCollection	"Store the next anInteger elements from the given collection."	^self next: anInteger putAll: aCollection startingAt: 1! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 04:19'!nextInto: aCollection	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: aCollection size into: aCollection startingAt: 1.! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 14:48'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override 	because default uses self contents species, which might involve a large 	collection."	position := position +anInteger.	^self collectionSpecies new: anInteger! !!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!position: anInteger 	"Set the current position for accessing the objects to be anInteger, as long 	as anInteger is within the bounds of the receiver's contents. If it is not, 	create an error notification."	(anInteger >= 0)		ifTrue: [position := anInteger]		ifFalse: [self positionError]! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 14:48'!nextPut: anObject 	"Insert the argument, anObject, as the next object accessible by the 	receiver. Answer anObject."	position := position +1.	^anObject! !!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!skip: anInteger 	"Set the receiver's position to be the current position+anInteger. A 	subclass might choose to be more helpful and select the minimum of the 	receiver's size and position+anInteger, or the maximum of 1 and 	position+anInteger for the repositioning."	self position: position + anInteger! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 14:48'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	position := position +n.	^aCollection! !!String methodsFor: 'accessing' stamp: 'nice 2/26/2010 00:53'!findAnySubStr: delimiters startingAt: start 	"Answer the index of the character within the receiver, starting at start, that begins a substring matching one of the delimiters.  delimiters is an Array of Strings (Characters are permitted also).  If the receiver does not contain any of the delimiters, answer size + 1."	^delimiters inject: 1 + self size into: [:min :delim |		"delim may be a char, a string of length 1, or a substring"		| ind |		ind := delim isCharacter 			ifTrue: [self indexOf: delim						startingAt: start ifAbsent: [min]]			ifFalse: [self indexOfSubCollection: delim 						startingAt: start ifAbsent: [min]].		min min: ind]! !!NullStream methodsFor: 'testing' stamp: 'ar 2/25/2010 04:19'!isEmpty	"Answer whether the receiver's contents has no elements."	^false! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 14:48'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	position := position + anInteger.	^aCollection! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 04:18'!binary	"Switches the stream to binary mode"	binary := true! !!WeakRegistry methodsFor: 'copying' stamp: 'ul 2/22/2010 14:23'!postCopy	self protected: [ "Uses the original accessLock"		accessLock := Semaphore forMutualExclusion.		valueDictionary := valueDictionary copy.		self installFinalizer ]! !!NullStream methodsFor: 'initialize' stamp: 'ar 2/25/2010 14:45'!initialize	"Initialize the receiver"	binary := false.	position := 0.! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 04:19'!next: n into: aCollection	"Read n objects into the given collection.	Return aCollection or a partial copy if less than	n elements have been read."	^self next: n into: aCollection startingAt: 1! !!WeakRegistry methodsFor: 'finalization' stamp: 'ul 2/22/2010 14:23'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."		self protected: [ valueDictionary finalizeValues ]! !!NullStream methodsFor: 'accessing' stamp: 'ar 2/25/2010 03:35'!contents	"Answer all of the contents of the receiver."	self shouldNotImplement! !!NullStream methodsFor: 'writing' stamp: 'ar 2/25/2010 14:48'!nextPutAll: aCollection 	"Append the elements of aCollection to the sequence of objects accessible 	by the receiver. Answer aCollection."	position := position + aCollection size.	^aCollection! !!NullStream methodsFor: 'testing' stamp: 'ar 2/25/2010 04:19'!atEnd	"Answer whether the receiver can access any more objects."	^false! !!NullStream methodsFor: 'testing' stamp: 'ar 2/25/2010 04:19'!isBinary	"Return true if the receiver is a binary byte stream"	^binary! !!NullStream class methodsFor: 'instance creation' stamp: 'ar 2/25/2010 04:20'!new	"Creates a new instance"	^self basicNew initialize! !!NullStream methodsFor: 'reading' stamp: 'ar 2/25/2010 14:48'!next	"Answer the next object accessible by the receiver."	position := position +1.	^self element! !!NullStream methodsFor: 'positioning' stamp: 'ar 2/25/2010 14:47'!position	"Answer the current position of accessing the sequence of objects."	^position! !