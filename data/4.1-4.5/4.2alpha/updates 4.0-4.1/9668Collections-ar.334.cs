"Change Set:		9668Collections-ar.334Collections-ar.334:Give Base64MimeConverter the ability to not break lines longer than 70 characters. Useful (for example) when using long base64 encodings in urls.Collections-ul.331:- removed the postscriptCollections-ar.332:- Comments for Collection>>min,max- Optimized implementations for Bag>>min,max,sumCollections-ar.333:Signal KeyNotFound instead of a generic error and provide the key in the exception and error message."!MimeConverter subclass: #Base64MimeConverter	instanceVariableNames: 'data multiLine'	classVariableNames: 'FromCharTable ToCharTable'	poolDictionaries: ''	category: 'Collections-Streams'!!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!mimeEncode: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	^self mimeEncode: aStream multiLine: true atStart: true! !!Dictionary methodsFor: 'accessing' stamp: 'ar 11/20/2007 14:47'!at: key 	"Answer the value associated with the key."	^ self at: key ifAbsent: [self errorKeyNotFound: key]! !!KeyedSet methodsFor: 'removing' stamp: 'ar 11/20/2007 14:47'!removeKey: key 	^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]! !!Collection methodsFor: 'private' stamp: 'ar 3/9/2010 22:08'!errorKeyNotFound: key	"Signal KeyNotFound error"	^(KeyNotFound key: key) signal! !!Dictionary methodsFor: 'removing' stamp: 'ar 11/20/2007 14:47'!removeKey: key 	"Remove key from the receiver.	If key is not in the receiver, notify an error."	^ self removeKey: key ifAbsent: [self errorKeyNotFound: key]! !!Bag methodsFor: 'math functions' stamp: 'jcg 11/16/2008 23:03'!max	"Answer the maximum value in the collection.  This optimized version only looks at each unique value once."	^contents keys inject: contents keys anyOne into: [:max :each | max max: each]! !!Bag methodsFor: 'math functions' stamp: 'jcg 11/16/2008 23:03'!min	"Answer the minimum value in the collection.  This optimized version only looks at each unique value once."	^contents keys inject: contents keys anyOne into: [:min :each | min min: each]! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!mimeEncode: aStream multiLine: aBool	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	^self mimeEncode: aStream multiLine: aBool atStart: true! !!Base64MimeConverter methodsFor: 'conversion' stamp: 'ar 4/15/2008 17:58'!mimeEncode	"Convert from data to 6 bit characters."	| phase1 phase2 raw nib lineLength |	phase1 := phase2 := false.	lineLength := 0.	[dataStream atEnd] whileFalse: [		(multiLine and:[lineLength >= 70]) ifTrue: [ mimeStream cr.  lineLength := 0. ].		data := raw := dataStream next asInteger.		nib := (data bitAnd: 16rFC) bitShift: -2.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase1 := true].		data := ((data bitAnd: 3) bitShift: 8) + raw asInteger.		nib := (data bitAnd: 16r3F0) bitShift: -4.		mimeStream nextPut: (ToCharTable at: nib+1).		(raw := dataStream next) ifNil: [raw := 0. phase2 := true].		data := ((data bitAnd: 16rF) bitShift: 8) + (raw asInteger).		nib := (data bitAnd: 16rFC0) bitShift: -6.		mimeStream nextPut: (ToCharTable at: nib+1).		nib := (data bitAnd: 16r3F).		mimeStream nextPut: (ToCharTable at: nib+1).		lineLength := lineLength + 4.].	phase1 ifTrue: [mimeStream skip: -2; nextPut: $=; nextPut: $=.			^ mimeStream].	phase2 ifTrue: [mimeStream skip: -1; nextPut: $=.			^ mimeStream].! !!Collection methodsFor: 'math functions' stamp: 'jcg 11/16/2008 23:01'!max	"Answer the maximum value in the collection.  The collection must be non-empty and contain 'compatible' Magnitudes (eg: don't try this with a collection containing both Dates and Characters)."	^ self inject: self anyOne into: [:max :each | max max: each]! !!Collection methodsFor: 'math functions' stamp: 'jcg 11/16/2008 23:02'!min	"Answer the minimum value in the collection.  The collection must be non-empty and contain 'compatible' Magnitudes (eg: don't try this with a collection containing both Dates and Characters)."	^ self inject: self anyOne into: [:min :each | min min: each]! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:16'!mimeEncode: aStream multiLine: aBool atStart: resetInput	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	| me |	resetInput ifTrue:[aStream position: 0].	me := self new dataStream: aStream.	me multiLine: aBool.	me mimeStream: (ReadWriteStream on: (String new: aStream size + 20 * 4 // 3)).	me mimeEncode.	me mimeStream position: 0.	^ me mimeStream! !!KeyedSet methodsFor: 'accessing' stamp: 'ar 11/20/2007 14:47'!at: key 	"Answer the value associated with the key."	^ self at: key ifAbsent: [self errorKeyNotFound: key]! !!Bag methodsFor: 'math functions' stamp: 'jcg 11/13/2008 16:46'!sum	"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag)."	| sum |	sum := 0.	contents keysAndValuesDo: [:value :count | sum := sum + (value * count)].	^sum! !!Base64MimeConverter methodsFor: 'accessing' stamp: 'ar 4/15/2008 17:58'!multiLine	"Determines whether we allow multi-line encodings (the default) or force everything into a single line (for use with URLs etc. where the continuation marker and the line break cause problems)"	^multiLine! !!Dictionary methodsFor: 'accessing' stamp: 'ar 11/20/2007 14:47'!associationAt: key 	^ self associationAt: key ifAbsent: [self errorKeyNotFound: key]! !!Base64MimeConverter methodsFor: 'accessing' stamp: 'ar 4/15/2008 17:58'!multiLine: aBool	"Determines whether we allow multi-line encodings (the default) or force everything into a single line (for use with URLs etc. where the continuation marker and the line break cause problems)"	multiLine := aBool! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'ar 3/9/2010 22:17'!mimeEncodeContinue: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	^self mimeEncode: aStream multiLine: true atStart: false! !Dictionary removeSelector: #errorKeyNotFound!KeyedSet removeSelector: #errorKeyNotFound!