"Change Set:		7568Multilingual-ar.40Multilingual-ar.40:Merge Multilingual-sn.38:Added missed UTF32InputInterpreter class.Corrected MacUnicodeInterpreter for working with v.4.x Mac VMs Multilingual-ar.38:Several font display fixes:- CharacterScanner will no longer interpret characters 256/257 as stop conditions when occuring in a string- The 'stops' argument is used consistently instead of the ivar stopConditions- The default fallbackFont substitution font *must* use the font it is backing since the fallback font will not be installed independently from the original.Multilingual-sn.38:Added missed UTF32InputInterpreter class.Corrected MacUnicodeInterpreter for working with v.4.x Mac VMs Multilingual-bf.39:- remove null characters from LanguageEnvironment's class comment"!Object subclass: #LanguageEnvironment	instanceVariableNames: 'id'	classVariableNames: 'ClipboardInterpreterClass Current FileNameConverterClass InputInterpreterClass KnownEnvironments SystemConverterClass'	poolDictionaries: ''	category: 'Multilingual-Languages'!KeyboardInputInterpreter subclass: #UTF32InputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-TextConversion'!UTF32InputInterpreter subclass: #UTF32RussianInputInterpreter	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Languages'!!MacUnicodeInputInterpreter methodsFor: 'initialization' stamp: 'sn 8/1/2009 20:01'!initialize	| satisfiesVersion |	satisfiesVersion := self				majorMinorBuildFrom: SmalltalkImage current vmVersion				satisfies: [:major :minor :build |  (major >= 3 						and: [minor >= 8								and: [build >= 7]]) or: [major >= 4]].							satisfiesVersion		ifTrue: [keyValueIndex := 6]		ifFalse: [keyValueIndex := 3]! !!TTCFont methodsFor: 'accessing' stamp: 'ar 8/15/2009 11:29'!fallbackFont	"Answers the fallbackFont for the receiver. The fallback font must be some derivative of the receiver since it will not be asked to install itself properly on the target BitBlt so rendering a completely different font here is simply not possible. The default implementation uses a synthetic font that maps all characters to question marks."	^ fallbackFont		ifNil: [fallbackFont := FixedFaceFont new errorFont baseFont: self]! !!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 8/15/2009 11:36'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX startEncoding char charValue |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		spaceWidth := f widthOf: Space.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		(encoding = 0 and: [charValue < 256 and:[(stops at: charValue + 1) notNil]]) ifTrue: [			^ stops at: charValue + 1		].		nextDestX := destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'ar 8/15/2009 11:35'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| charCode encoding f startEncoding combining combined combiningIndex c |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].	].	spaceWidth := font widthOf: Space.	combining := nil.	[lastIndex <= stopIndex] whileTrue: [		charCode := (sourceString at: lastIndex) charCode.		c := (sourceString at: lastIndex).		combining ifNil: [			combining := CombinedChar new.			combining add: c.			combiningIndex := lastIndex.			lastIndex := lastIndex + 1.		] ifNotNil: [			(combining add: c) ifFalse: [				self addCharToPresentation: (combined := combining combined).				combining := CombinedChar new.				combining add: c.				charCode := combined charCode.				encoding := combined leadingChar.				encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1.					(encoding = 0 and: [charCode < 256 and:[(stops at: charCode + 1) notNil]]) ifTrue: [						^ stops at: charCode + 1					] ifFalse: [						 ^ stops at: EndOfRun					].				].				(encoding = 0 and: [charCode < 256 and:[(stops at: charCode + 1) notNil]]) ifTrue: [					combining ifNotNil: [						self addCharToPresentation: (combining combined).					].					^ stops at: charCode + 1				].				(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [					self registerBreakableIndex.				].						destX > rightX ifTrue: [					destX ~= firstDestX ifTrue: [						lastIndex := combiningIndex.						self removeLastCharFromPresentation.						^ stops at: CrossedX]].				combiningIndex := lastIndex.				lastIndex := lastIndex + 1.			] ifTrue: [				lastIndex := lastIndex + 1.				numOfComposition := numOfComposition + 1.			].		].	].	lastIndex := stopIndex.	combining ifNotNil: [		combined := combining combined.		self addCharToPresentation: combined.		"assuming that there is always enough space for at least one character".		destX := destX + (self widthOf: combined inFont: font).	].	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'ar 8/15/2009 10:52'!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		spaceWidth := f widthOf: Space.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		(encoding = 0 and: [ascii < 256 and: [(stops at: ascii + 1) notNil]]) 			ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [destX ~= firstDestX ifTrue: [^ stops at: CrossedX]].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!UTF32InputInterpreter methodsFor: 'as yet unclassified' stamp: 'bf 11/29/2007 15:38'!nextCharFrom: sensor firstEvt: evtBuf 	"Fall back on MacRoman if char is 0"	^(evtBuf at: 6) > 0		ifTrue: [(evtBuf at: 6) asCharacter]		ifFalse: [(evtBuf at: 3) asCharacter macToSqueak].! !!MultiDisplayScanner methodsFor: 'multilingual scanning' stamp: 'ar 8/15/2009 11:30'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX startEncoding char charValue |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		spaceWidth := f widthOf: Space.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		(encoding = 0 and: [charValue < 256 and:[(stops at: charValue + 1) notNil]]) 			ifTrue: [^stops at: charValue + 1].		nextDestX := destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops at: CrossedX].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'ar 8/15/2009 11:35'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := EncodedCharSet scanSelectorAt: startEncoding.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stops with: kernDelta).	].		^ stops at: EndOfRun! !!FontTest methodsFor: 'testing' stamp: 'ar 8/15/2009 10:46'!testDisplay	"self debug: #testDisplay"	| text font bb destPoint width |	text := 'test' asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text asString on: bb from: 1 to: 4 at: 0@0 kern: 1.	width := text inject: 0 into: [:max :char | max + (font widthOf: char)].	self assert: destPoint x = (width + 4).	"bb destForm asMorph openInHand."! !!FixedFaceFont methodsFor: 'displaying' stamp: 'ar 8/15/2009 10:45'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint |	destPoint := self				displayString: aString				on: aBitBlt				from: startIndex				to: stopIndex				at: aPoint				kern: kernDelta				baselineY: baselineY.	^destPoint! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'ar 8/15/2009 11:32'!scanJapaneseCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops at: EndOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		[f := font fontArray at: startEncoding + 1]			on: Exception do: [:ex | f := font fontArray at: 1].		f ifNil: [ f := font fontArray at: 1].		spaceWidth := f widthOf: Space.	] ifFalse: [		(font isMemberOf: HostFont) ifTrue: [			f := font.			spaceWidth := f widthOf: Space.		].	].	[lastIndex <= stopIndex] whileTrue: [		"self halt."		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops at: EndOfRun].		ascii := (sourceString at: lastIndex) charCode.		(encoding = 0 and: [ascii < 256 and:[(stops at: ascii + 1) notNil]]) 			ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: (EncodedCharSet charsetAt: encoding)) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [firstDestX ~= destX ifTrue: [^ stops at: CrossedX]].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops at: EndOfRun! !!FontTest methodsFor: 'testing' stamp: 'ar 8/15/2009 10:39'!testFallback	"self debug: #testFallback"	| text font bb destPoint |	text := (Character value: 257) asString asText.	font := TextStyle default fontOfSize: 21.	text addAttribute: (TextFontReference toFont: font).	bb := (Form extent: 100 @ 30) getCanvas privatePort.	bb combinationRule: Form paint.	font installOn: bb foregroundColor: Color black backgroundColor: Color white.	destPoint := font displayString: text asString on: bb from: 1 to: 1 at: 0@0 kern: 1.	"bb destForm asMorph openInHand."	self assert: destPoint x = ((font widthOf: $?) + 1).! !!StrikeFontSet methodsFor: 'displaying' stamp: 'ar 8/15/2009 10:45'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint leftX rightX glyphInfo g tag char destY |	destPoint := aPoint.	rIndex := startIndex.	tag := (aString at: rIndex) leadingChar.	glyphInfo := Array new: 5.	[rIndex <= stopIndex] whileTrue: [		char := aString at: rIndex.		((fromFont hasGlyphOf: char) or: [char leadingChar ~= tag]) ifTrue: [^destPoint].		self glyphInfoOf: char into: glyphInfo.		g := glyphInfo first.		leftX := glyphInfo second.		rightX := glyphInfo third.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		aBitBlt sourceForm: g.		destY := baselineY - glyphInfo fourth. 		aBitBlt destX: destPoint x.		aBitBlt destY: destY.		aBitBlt sourceOrigin: leftX @ 0.		aBitBlt width: rightX - leftX.		aBitBlt height: self height.		aBitBlt copyBits.		destPoint := destPoint + (rightX - leftX + kernDelta @ 0).		rIndex := rIndex + 1.	].	^destPoint.! !MultiCharacterScanner removeSelector: #scanMultiCharactersR2LFrom:to:in:rightX:stopConditions:kern:!