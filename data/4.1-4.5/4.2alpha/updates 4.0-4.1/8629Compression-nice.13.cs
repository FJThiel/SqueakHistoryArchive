"Change Set:		8629Compression-nice.13Compression-nice.13:Cosmetic: move or remove a few temps inside closures"!!ZipWriteStream class methodsFor: 'regression test' stamp: 'nice 12/27/2009 03:11'!regressionTestFrom: fd using: tempName stats: stats	| files |	files := fd fileNames asSortedCollection.	files do:[:fName| | fullName file |		file := nil.		fullName := fd fullNameFor: fName.		fullName = tempName ifFalse:[			file := StandardFileStream new open: fullName forWrite: false].		self compressAndDecompress: file using: tempName stats: stats].	stats at: #numFiles put: (stats at: #numFiles ifAbsent:[0]) + files size.	files := nil.	self printRegressionStats: stats from: fd.	fd directoryNames asSortedCollection do:[:dName|		self regressionTestFrom: (fd directoryNamed: dName) using: tempName stats: stats.	].! !!ZipArchive methodsFor: 'archive operations' stamp: 'nice 12/27/2009 03:11'!extractAllTo: aDirectory informing: bar overwrite: allOverwrite	"Extract all elements to the given directory"	| overwriteAll |	overwriteAll := allOverwrite.	self members do:[:entry| | dir |		entry isDirectory ifTrue:[			bar ifNotNil:[bar value: 'Creating ', entry fileName].			dir := (entry fileName findTokens:'/') 					inject: aDirectory into:[:base :part| base directoryNamed: part].			dir assureExistence.		].	].	self members do:[:entry| | response |		entry isDirectory ifFalse:[			bar ifNotNil:[bar value: 'Extracting ', entry fileName].			response := entry extractInDirectory: aDirectory overwrite: overwriteAll.			response == #retryWithOverwrite ifTrue:[				overwriteAll := true.				response := entry extractInDirectory: aDirectory overwrite: overwriteAll.			].			response == #abort ifTrue:[^self].			response == #failed ifTrue:[				(self confirm: 'Failed to extract ', entry fileName, '. Proceed?') ifFalse:[^self].			].		].	].! !!ZipArchive methodsFor: 'private' stamp: 'nice 12/26/2009 22:32'!readMembersFrom: stream named: fileName	[		| newMember signature |		newMember := self memberClass newFromZipFile: stream named: fileName.		signature := self readSignatureFrom: stream.		signature = EndOfCentralDirectorySignature ifTrue: [ ^self ].		signature = CentralDirectoryFileHeaderSignature			ifFalse: [ self error: 'bad CD signature at ', (stream position - 4) printStringHex ].		newMember readFrom: stream.		newMember looksLikeDirectory ifTrue: [ newMember := newMember asDirectory ].		self addMember: newMember.	] repeat.! !!ZipFileMember methodsFor: 'private-writing' stamp: 'nice 12/27/2009 20:46'!uncompressDataTo: aStream	| decoder buffer crcErrorMessage |	decoder := ZipReadStream on: stream.	decoder expectedCrc: self crc32.	buffer := ByteArray new: (32768 min: readDataRemaining).	crcErrorMessage := nil.	[[ readDataRemaining > 0 ] whileTrue: [		| chunkSize |		chunkSize := 32768 min: readDataRemaining.		buffer := decoder next: chunkSize into: buffer startingAt: 1.		aStream next: chunkSize putAll: buffer startingAt: 1.		readDataRemaining := readDataRemaining - chunkSize.	]] on: CRCError do: [ :ex | crcErrorMessage := ex messageText. ex proceed ].	crcErrorMessage ifNotNil: [ self isCorrupt: true. CRCError signal: crcErrorMessage ]! !