"Change Set:		7862Collections-ar.145Collections-ar.145:Pseudo-merging Collections-ul.144:- replaced all uses of #findElementOrNil: with #scanFor:- #scanFor: raises an error if it can't find a slot- new #scanFor:, #scanForEmptySlotFor: and #fixCollisionsFrom: implementations- removed unnecessary WeakKeyDictionary >> #scanFor:- added Set >> #errorNoFreeSpace as a common error message for #scanFor: and #scanForEmptySlotFor:"!!IdentitySet methodsFor: 'private' stamp: 'ul 9/26/2009 01:35'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ element == anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!IdentityDictionary methodsFor: 'private' stamp: 'ul 9/26/2009 01:28'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ element key == anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!Set methodsFor: 'adding' stamp: 'ul 9/23/2009 21:14'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self scanFor: newObject.	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'private' stamp: 'ul 9/23/2009 20:59'!errorNoFreeSpace	self error: 'There is no free space in this collection!!'! !!WeakValueDictionary methodsFor: 'accessing' stamp: 'ul 9/23/2009 21:14'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index := self scanFor: key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!KeyedIdentitySet methodsFor: 'private' stamp: 'ul 9/26/2009 01:35'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ (keyBlock value: element) == anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!KeyedSet methodsFor: 'private' stamp: 'ul 9/26/2009 01:36'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ (keyBlock value: element) = anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!Set methodsFor: 'private' stamp: 'ul 9/25/2009 00:44'!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| element index |	index := start.	[ (element := self keyAt: (index := index \\ array size + 1)) == nil ] whileFalse: [		| newIndex |		(newIndex := self scanFor: element) = index ifFalse: [			self swap: index with: newIndex ] ]! !!KeyedSet methodsFor: 'adding' stamp: 'ul 9/23/2009 21:13'!member: newObject	"Include newObject as one of the receiver's elements, if already exists just return it"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self scanFor: (keyBlock value: newObject).	(array at: index) ifNotNil: [^ array at: index].	self atNewIndex: index put: newObject.	^ newObject! !!WeakSet methodsFor: 'public' stamp: 'ul 9/23/2009 21:14'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self scanFor: newObject.	((array at: index) == flag or: [(array at: index) isNil])		ifTrue: [self atNewIndex: index put: newObject].	^newObject! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ul 9/26/2009 00:47'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!KeyedSet methodsFor: 'private' stamp: 'ul 9/23/2009 21:13'!noCheckAdd: anObject	array at: (self scanFor: (keyBlock value: anObject)) put: anObject.	tally := tally + 1! !!WeakSet methodsFor: 'private' stamp: 'ul 9/25/2009 23:37'!fixCollisionsFrom: start	"The element at start has been removed and replaced by flag.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| element index |	index := start.	[ (element := self keyAt: (index := index \\ array size + 1)) == flag ] whileFalse: [		| newIndex |		(newIndex := self scanFor: element) = index ifFalse: [			self swap: index with: newIndex ] ]! !!KeyedSet methodsFor: 'accessing' stamp: 'ul 9/23/2009 21:13'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| obj |	obj := array at: (self scanFor: key).	obj ifNil: [^ aBlock value].	^ obj! !!WeakSet methodsFor: 'public' stamp: 'ul 9/23/2009 21:14'!includes: anObject 	^(array at: (self scanFor: anObject)) ~~ flag! !!Set methodsFor: 'private' stamp: 'ul 9/25/2009 23:57'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := anObject hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!Dictionary methodsFor: 'adding' stamp: 'ul 9/23/2009 21:12'!add: anAssociation	| index element |	index := self scanFor: anAssociation key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: anAssociation]		ifFalse: [element value: anAssociation value].	^ anAssociation! !!Set methodsFor: 'accessing' stamp: 'ul 9/23/2009 22:20'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| index |	index := self scanFor: anObject.	^array at: index! !!KeyedSet methodsFor: 'testing' stamp: 'ul 9/23/2009 21:13'!includesKey: key	^ (array at: (self scanFor: key)) ~~ nil! !!PluggableDictionary methodsFor: 'private' stamp: 'ul 9/26/2009 00:45'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := (hashBlock		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!PluggableSet methodsFor: 'private' stamp: 'ul 9/26/2009 00:46'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := (hashBlock		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!WeakSet methodsFor: 'public' stamp: 'ul 9/23/2009 21:14'!do: aBlock after: anElement	| each startIndex |	tally = 0 ifTrue: [^self].	startIndex := anElement ifNil: [1] ifNotNil:		[self scanFor: anElement].	startIndex + 1 to: array size do:		[:index |			((each := array at: index) == nil or: [each == flag])				ifFalse: [aBlock value: each]		]! !!WeakSet methodsFor: 'public' stamp: 'ul 9/23/2009 21:14'!remove: oldObject ifAbsent: aBlock	| index |	index := self scanFor: oldObject.	(array at: index) == flag ifTrue: [ ^ aBlock value ].	array at: index put: flag.	tally := tally - 1.	self fixCollisionsFrom: index.	^oldObject! !!Set methodsFor: 'private' stamp: 'ul 9/26/2009 01:12'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ element = anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!Dictionary methodsFor: 'accessing' stamp: 'ul 9/23/2009 21:13'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index assoc |	index := self scanFor: key.	assoc := array at: index.	assoc		ifNil: [self atNewIndex: index put: (Association key: key value: anObject)]		ifNotNil: [assoc value: anObject].	^ anObject! !!KeyedSet methodsFor: 'removing' stamp: 'ul 9/23/2009 21:13'!remove: oldObject ifAbsent: aBlock	| index |	index := self scanFor: (keyBlock value: oldObject).	(array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!Set methodsFor: 'private' stamp: 'ul 9/23/2009 21:14'!noCheckAdd: anObject	array at: (self scanFor: anObject) put: anObject.	tally := tally + 1! !!WeakSet methodsFor: 'private' stamp: 'ul 9/26/2009 01:50'!scanFor: anObject	"Scan the key array for the first slot containing either a nil or a flag (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == flag or: [ element = anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!PluggableDictionary methodsFor: 'private' stamp: 'ul 9/26/2009 01:48'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := (hashBlock		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [			equalBlock				ifNil: [ element key = anObject ]				ifNotNil: [ equalBlock value: element key value: anObject ] ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!PluggableSet methodsFor: 'private' stamp: 'ul 9/26/2009 01:49'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := (hashBlock		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [			equalBlock				ifNil: [ element = anObject ]				ifNotNil: [ equalBlock value: element value: anObject ] ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!Set methodsFor: 'testing' stamp: 'ul 9/23/2009 21:14'!includes: anObject 	^ (array at: (self scanFor: anObject)) ~~ nil! !!Dictionary methodsFor: 'private' stamp: 'ul 9/26/2009 01:27'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ element key = anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!Dictionary methodsFor: 'private' stamp: 'ul 9/23/2009 21:13'!noCheckAdd: anObject	"Must be defined separately for Dictionary because (self scanFor:) expects a key,	not an association.  9/7/96 tk"	array at: (self scanFor: anObject key) put: anObject.	tally := tally + 1! !!KeyedSet methodsFor: 'removing' stamp: 'ul 9/23/2009 21:13'!removeKey: key ifAbsent: aBlock	| index obj |	index := self scanFor: key.	(obj := array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ obj! !!Dictionary methodsFor: 'accessing' stamp: 'ul 9/23/2009 21:12'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| assoc |	assoc := array at: (self scanFor: key).	assoc ifNil: [^ aBlock value].	^ assoc value! !!Dictionary methodsFor: 'removing' stamp: 'ul 9/25/2009 02:53'!removeKey: key ifAbsent: aBlock 	"Remove key (and its associated value) from the receiver. If key is not in 	the receiver, answer the result of evaluating aBlock. Otherwise, answer 	the value externally named by key."	| index association |	index := self scanFor: key.	(association := array at: index) ifNil: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^association value! !!Dictionary methodsFor: 'accessing' stamp: 'ul 9/23/2009 21:12'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	| index assoc |	index := self scanFor: key.	assoc := array at: index.	nil == assoc ifTrue: [ ^ aBlock value ].	^ assoc! !!KeyedSet methodsFor: 'adding' stamp: 'ul 9/23/2009 21:13'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index := self scanFor: (keyBlock value: newObject).	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!IdentitySet methodsFor: 'private' stamp: 'ul 9/26/2009 00:44'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!KeyedSet methodsFor: 'testing' stamp: 'ul 9/23/2009 21:13'!includes: anObject 	^ (array at: (self scanFor: (keyBlock value: anObject))) ~~ nil! !!IdentityDictionary methodsFor: 'private' stamp: 'ul 9/26/2009 00:44'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!Set methodsFor: 'removing' stamp: 'ul 9/25/2009 00:38'!remove: oldObject ifAbsent: aBlock	| index |	index := self scanFor: oldObject.	(array at: index) ifNil: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ oldObject! !!WeakSet methodsFor: 'private' stamp: 'ul 9/26/2009 00:47'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by flag or a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == flag or: [ element == nil ]) ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!WeakIdentityKeyDictionary methodsFor: 'private' stamp: 'ul 9/26/2009 02:18'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ element key == anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ul 9/23/2009 21:14'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index := self scanFor: key.	element := array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!KeyedIdentitySet methodsFor: 'private' stamp: 'ul 9/26/2009 00:45'!scanForEmptySlotFor: anObject	"Scan the key array for the first slot containing an empty slot (indicated by a nil). Answer the index of that slot. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start hash |	array size > 4096		ifTrue: [ hash := anObject identityHash * (array size // 4096) ]		ifFalse: [ hash := anObject identityHash ].	index := start := hash \\ array size + 1.	[ 		(array at: index) ifNil: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse: [ ].	self errorNoFreeSpace! !WeakKeyDictionary removeSelector: #scanFor:!