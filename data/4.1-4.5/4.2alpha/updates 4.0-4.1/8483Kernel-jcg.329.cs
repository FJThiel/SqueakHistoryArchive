"Change Set:		8483Kernel-jcg.329Kernel-jcg.329:Support for using #future and #future: keywords to conveniently send asynchronous messages.Core support is in the Kernel package, and the default behavior is defined by Project, in the System package.Kernel-ul.328:- added a mirror primitive"!Object subclass: #Promise	instanceVariableNames: 'isResolved value resolvers mutex'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!ProtoObject subclass: #FutureMaker	instanceVariableNames: 'myTarget deltaMSecs'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!FutureMaker methodsFor: 'printing' stamp: 'das 9/7/2005 10:10'!printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^ self printStringLimitedTo: 50000! !!Promise methodsFor: 'resolving' stamp: 'jcg 12/17/2009 01:09'!whenResolved: aBlock	"Evaluate aBlock when I am resolved"	aBlock numArgs <= 1 ifFalse:[self error: 'Must be 0- or 1-argument block'].	mutex critical: [		resolvers := resolvers copyWith: aBlock.		self isResolved ifTrue:[self evaluateResolver: aBlock].	]! !!FutureMaker methodsFor: 'private' stamp: 'jcg 12/17/2009 23:20'!setDeltaMSecs: delta target: futureTarget	deltaMSecs := delta.	myTarget := futureTarget.! !!Object methodsFor: 'futures' stamp: 'jcg 12/17/2009 23:25'!future	"See FutureMaker class comment.  In practice, this code is optimized away by the Compiler (see FutureNode)."	^(FutureMaker new) 		setDeltaMSecs: 0.0 target: self! !!FutureMaker methodsFor: 'accessing' stamp: 'jcg 12/17/2009 23:20'!doesNotUnderstand: aMessage	"Package up the message and send it"	^myTarget futureSend: aMessage selector at: deltaMSecs args: aMessage arguments! !!Promise methodsFor: 'testing' stamp: 'jcg 12/17/2009 01:04'!isResolved	^isResolved! !!Object methodsFor: 'futures' stamp: 'jcg 12/17/2009 01:42'!futureDo: aSelector at: deltaMSecs args: args	"Send a message deltaMSecs into the future (some implementations may requires 'deltaMSecs' to be zero).  No response is expected.  See comment in class FutureNode."	Project current future: self do: aSelector at: deltaMSecs args: args.	^nil! !!FutureMaker methodsFor: 'accessing' stamp: 'das 9/7/2005 10:09'!isMemberOf: aClass 	"Answer whether the receiver is an instance of the class, aClass."	^self class == aClass! !!Promise methodsFor: 'resolving' stamp: 'jcg 12/17/2009 01:08'!resolveWith: arg	"Resolve this promise"	mutex critical: [		isResolved ifTrue: [self error: 'Promise was already resolved'].		value := arg.		isResolved := true.		resolvers ifNotNil: [resolvers do: [:r | self evaluateResolver: value]].	].! !!FutureMaker methodsFor: 'printing' stamp: 'das 9/7/2005 10:10'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString := String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Promise methodsFor: 'private' stamp: 'jcg 12/17/2009 01:03'!evaluateResolver: resolverBlock	resolverBlock numArgs = 0 		ifTrue: [resolverBlock value]		ifFalse: [resolverBlock value: value].	! !!FutureMaker methodsFor: 'printing' stamp: 'das 9/7/2005 10:10'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Promise methodsFor: 'waiting' stamp: 'jcg 12/17/2009 01:10'!waitTimeoutMSecs: msecs	"Wait for at most the given number of milliseconds for this promise to resolve. Answer true if it is resolved, false otherwise."	| sema delay |	sema := Semaphore new.	self whenComplete:[sema signal].	delay := Delay timeoutSemaphore: sema afterMSecs: msecs.	[sema wait] ensure: [delay unschedule].	^isResolved! !!FutureMaker methodsFor: 'accessing' stamp: 'das 9/7/2005 10:09'!instVarAt: index 	"Primitive. Answer a fixed variable in an object. The numbering of the 	variables corresponds to the named instance variables. Fail if the index 	is not an Integer or is not the index of a fixed variable. Essential. See 	Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self basicAt: index - self class instSize		! !!Object methodsFor: 'futures' stamp: 'jcg 12/17/2009 01:42'!futureSend: aSelector at: deltaMSecs args: args	"Send a message deltaSeconds into the future (some implementations may requires 'deltaMSecs' to be zero).  Answers a Promise that will be resolved at some time in the future.  See comment in class FutureNode."	^Project current future: self send: aSelector at: deltaMSecs args: args.! !!FutureMaker methodsFor: 'accessing' stamp: 'das 9/7/2005 10:09'!instVarAt: anInteger put: anObject 	"Primitive. Store a value into a fixed variable in the receiver. The 	numbering of the variables corresponds to the named instance variables. 	Fail if the index is not an Integer or is not the index of a fixed variable. 	Answer the value stored as the result. Using this message violates the 	principle that each object has sovereign control over the storing of 	values into its instance variables. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject! !!ContextPart methodsFor: 'mirror primitives' stamp: 'ul 12/15/2009 19:04'!objectClass: anObject	<primitive: 111>	self primitiveFailed! !!Promise methodsFor: 'accessing' stamp: 'jcg 12/17/2009 01:03'!value	^value! !!FutureMaker methodsFor: 'comparing' stamp: 'das 9/7/2005 10:09'!hash	^self identityHash! !!Promise methodsFor: 'initialize' stamp: 'jcg 12/17/2009 01:06'!initialize	isResolved := false.	resolvers := #().	mutex := Mutex new.! !!Object methodsFor: 'futures' stamp: 'jcg 12/17/2009 23:25'!future: deltaMSecs	"See FutureMaker class comment.  In practice, this code is optimized away by the Compiler (see FutureNode)."	^(FutureMaker new)		setDeltaMSecs: deltaMSecs target: self! !!FutureMaker methodsFor: 'accessing' stamp: 'das 9/7/2005 10:10'!basicSize	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. Do not 	override in any subclass. See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!Promise methodsFor: 'waiting' stamp: 'jcg 12/17/2009 01:09'!wait	"Wait unconditionally for this promise to resolve."	| sema |	sema := Semaphore new.	self whenResolved:[sema signal].	sema wait.	^value! !!FutureMaker methodsFor: 'accessing' stamp: 'das 9/7/2005 10:09'!basicAt: index put: value 	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!FutureMaker methodsFor: 'debug' stamp: 'das 9/7/2005 10:09'!inspectorClass	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 	use basicInspect to get a normal (less useful) type of inspector."	^ Inspector! !!FutureMaker methodsFor: 'accessing' stamp: 'das 9/7/2005 10:08'!basicAt: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!FutureMaker methodsFor: 'accessing' stamp: 'das 9/7/2005 10:09'!isKindOf: aClass 	"--- needed for debugging ---"	self class == aClass		ifTrue: [^true]		ifFalse: [^self class inheritsFrom: aClass]! !!FutureMaker methodsFor: 'comparing' stamp: 'das 9/7/2005 10:10'!= anObject	^self == anObject! !!FutureMaker methodsFor: 'private' stamp: 'das 9/6/2005 12:29'!setTarget: aTarget	myTarget := aTarget.! !!FutureMaker methodsFor: 'debug' stamp: 'das 9/7/2005 10:09'!defaultLabelForInspector	"Answer the default label to be used for an Inspector window on the receiver."	^self class name! !!FutureMaker methodsFor: 'testing' stamp: 'das 9/7/2005 10:09'!isText	^false! !!Promise methodsFor: 'waiting' stamp: 'jcg 12/17/2009 01:11'!waitTimeoutSeconds: seconds	"Wait for at most the given number of seconds for this promise to resolve. Answer true if it is resolved, false otherwise."	^self waitTimeoutMSecs: seconds*1000! !