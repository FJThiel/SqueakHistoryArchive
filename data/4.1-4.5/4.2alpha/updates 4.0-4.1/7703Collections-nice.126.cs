"Change Set:		7703Collections-nice.126Collections-nice.126:Avoid invoking super when self would do the job.( super basicNew issue http://bugs.squeak.org/view.php?id=6977 )Collections-ar.123:Some fixes for RWBinaryOrTextStream which was too agressive optimizing some paths. Also fixes Character>>codePoint: which has no reason to raise an exception for values > 256.Collections-jcg.124:#mimeEncode: no longer resets the input-stream position before encoding; that was just silly.  See updated tests in CollectionsTests.Add #base64Encoded to ByteArray (for symmetry with String).Collections-ar.125:http://bugs.squeak.org/view.php?id=7314Summary  	 0007314: UTF8 conversion speedupDescription 	The conversions between Squeak and UTF8 can be fairly slow. The attached changes speed up the typical conversions dramatically. "!String variableByteSubclass: #ByteString	instanceVariableNames: ''	classVariableNames: 'Latin1ToUtf8Encodings Latin1ToUtf8Map'	poolDictionaries: ''	category: 'Collections-Strings'!!RWBinaryOrTextStream methodsFor: 'accessing' stamp: 'ar 9/1/2009 00:20'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element species |	species := isBinary ifTrue:[ByteArray] ifFalse:[String].	newStream := WriteStream on: (species new: 100).	[self atEnd or: [(element := self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!RWBinaryOrTextStream methodsFor: 'writing' stamp: 'ar 9/1/2009 00:22'!nextPutAll: aCollection	"Optimized for ByteArrays"	aCollection class == ByteArray 		ifTrue:[^super nextPutAll: aCollection asString].	^super nextPutAll: aCollection! !!ByteString methodsFor: 'converting' stamp: 'ar 3/12/2009 21:33'!squeakToUtf8	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex |	Latin1ToUtf8Map ifNil:[^super squeakToUtf8]. "installation guard"	lastIndex := 1.	nextIndex := ByteString findFirstInString: self inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self].	outStream := (String new: self size * 2) writeStream.	[outStream next: nextIndex-lastIndex putAll: self startingAt: lastIndex.	outStream nextPutAll: (Latin1ToUtf8Encodings at: (self byteAt: nextIndex)+1).	lastIndex := nextIndex + 1.	nextIndex := ByteString findFirstInString: self inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0] whileFalse.	outStream next: self size-lastIndex+1 putAll: self startingAt: lastIndex.	^outStream contents! !!Base64MimeConverter class methodsFor: 'as yet unclassified' stamp: 'jcg 9/1/2009 00:16'!mimeEncode: aStream	"Return a ReadWriteStream of characters.  The data of aStream is encoded as 65 innocuous characters.  (See class comment). 3 bytes in aStream goes to 4 bytes in output."	| me |	me := self new dataStream: aStream.	me mimeStream: (ReadWriteStream on: (String new: aStream size + 20 * 4 // 3)).	me mimeEncode.	me mimeStream position: 0.	^ me mimeStream! !!ByteString methodsFor: 'converting' stamp: 'ar 3/12/2009 21:32'!utf8ToSqueak	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex byte1 byte2 byte3 byte4 unicode |	Latin1ToUtf8Map ifNil:[^super utf8ToSqueak]. "installation guard"	lastIndex := 1.	nextIndex := ByteString findFirstInString: self inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self].	outStream := (String new: self size) writeStream.	[outStream next: nextIndex-lastIndex putAll: self startingAt: lastIndex.	byte1 := self byteAt: nextIndex.	(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"		byte2 := self byteAt: (nextIndex := nextIndex+1).		(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63)].	(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"		byte2 := self byteAt: (nextIndex := nextIndex+1).		(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		byte3 := self byteAt: (nextIndex := nextIndex+1).		(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)			+ (byte3 bitAnd: 63)].	(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"		byte2 := self byteAt: (nextIndex := nextIndex+1).		(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		byte3 := self byteAt: (nextIndex := nextIndex+1).		(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		byte4 := self byteAt: (nextIndex := nextIndex+1).		(byte4 bitAnd: 16rC0) = 16r80 ifFalse:[^self]. "invalid UTF-8; presume Latin-1"		unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +						((byte2 bitAnd: 63) bitShift: 12) + 						((byte3 bitAnd: 63) bitShift: 6) +						(byte4 bitAnd: 63)].	unicode ifNil:[^self]. "invalid UTF-8; presume Latin-1"	outStream nextPut: (Character value: unicode).	lastIndex := nextIndex + 1.	nextIndex := ByteString findFirstInString: self inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0] whileFalse.	outStream next: self size-lastIndex+1 putAll: self startingAt: lastIndex.	^outStream contents! !!ByteArray methodsFor: 'converting' stamp: 'jcg 9/1/2009 00:30'!base64Encoded	"Encode the receiver as base64"	"'Hello World' asByteArray base64Encoded"	^(Base64MimeConverter mimeEncode: self readStream) contents! !!Character class methodsFor: 'instance creation' stamp: 'ar 9/1/2009 00:23'!codePoint: integer 	"Return a character whose encoding value is integer.	For ansi compability."	^self value: integer! !!ByteString class methodsFor: 'initialization' stamp: 'ar 3/12/2009 21:32'!initialize	"ByteString initialize"	| latin1 utf8 |	Latin1ToUtf8Map := ByteArray new: 256.	Latin1ToUtf8Encodings := Array new: 256.	0 to: 255 do:[:i|		latin1 := String with: (Character value: i).		utf8 := latin1 convertToWithConverter: UTF8TextConverter new.		latin1 = utf8 ifTrue:[			Latin1ToUtf8Map at: i+1 put: 0. "no translation needed"		] ifFalse:[			Latin1ToUtf8Map at: i+1 put: 1. "no translation needed"			Latin1ToUtf8Encodings at: i+1 put: utf8.		].	].! !!Set class methodsFor: 'instance creation' stamp: 'nice 9/5/2009 22:18'!new: nElements	"Create a Set large enough to hold nElements without growing"	^ self basicNew initialize: (self sizeFor: nElements)! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'nice 9/5/2009 22:17'!new: anInteger withAll: anObject	^ self basicNew setContents: (Array new: anInteger withAll: anObject)! !!RWBinaryOrTextStream methodsFor: 'writing' stamp: 'ar 9/1/2009 00:23'!next: anInteger putAll: aCollection startingAt: startIndex	"Optimized for ByteArrays"	aCollection class == ByteArray 		ifTrue:[^super next: anInteger putAll: aCollection asString startingAt: startIndex].	^super next: anInteger putAll: aCollection startingAt: startIndex! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'nice 9/5/2009 22:17'!new: anInteger 	^ self basicNew setCollection: (Array new: anInteger)! !ByteString initialize!