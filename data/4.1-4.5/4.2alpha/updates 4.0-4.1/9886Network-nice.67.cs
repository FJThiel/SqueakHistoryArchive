"Change Set:		9886Network-nice.67Network-nice.67:1) fix some _ assignment2) add Socket support for #next:putAll:startingAt: and #readInto:startingAt:count:3) do not let ascii/binary resetBuffers gratuitously"!!SocketStream methodsFor: 'configuration' stamp: 'nice 3/16/2010 22:34'!ascii	"Tell the SocketStream to send data	as Strings instead of ByteArrays.	This is default."	binary := false.	inBuffer		ifNil: [self resetBuffers]		ifNotNil:			[inBuffer := inBuffer asString.			outBuffer := outBuffer asString]! !!SocketStream methodsFor: 'configuration' stamp: 'nice 3/16/2010 22:35'!binary	"Tell the SocketStream to send data	as ByteArrays instead of Strings.	Default is ascii."	binary := true.	inBuffer		ifNil: [self resetBuffers]		ifNotNil:			[inBuffer := inBuffer asByteArray.			outBuffer := outBuffer asByteArray]! !!SocketStream methodsFor: 'stream out' stamp: 'nice 3/17/2010 20:27'!next: n putAll: aCollection startingAt: startIndex	"Put a String or a ByteArray onto the stream.	Currently a large collection will allocate a large buffer.	Warning: this does not work with WideString: they have to be converted first."	self adjustOutBuffer: n.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + n - 1 with: aCollection startingAt: startIndex.	outNextToWrite := outNextToWrite + n.	self checkFlush.	^aCollection! !!SocketStream methodsFor: 'stream in' stamp: 'nice 3/16/2010 23:02'!readInto: aCollection startingAt: startIndex count: anInteger	"Read n objects into the given collection starting at startIndex. 	Return number of elements that have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self receiveData: anInteger] on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount! !!ServerDirectory methodsFor: 'file directory' stamp: 'nice 1/19/2010 01:57'!oldFileOrNoneNamed: fullName	"If the file exists, answer a read-only RemoteFileStream on it. If it doesn't, answer nil.  fullName is directory path, and does include name of the server.  Or just a simple fileName.  Do prefetch the data." 		^ Cursor wait showWhile:		[ | file |		file := self asServerFileNamed: fullName.		file readOnly.		"file exists ifFalse: [^ nil]."		"on the server"		file isTypeFile			ifTrue: [FileStream oldFileOrNoneNamed: (file fileNameRelativeTo: self)]			ifFalse: [self streamOnBeginningOf: file]]! !!MailAddressTokenizer class methodsFor: 'class initialization' stamp: 'ls 12/2/2001 15:15'!initialize	"Initalize class variables using   MailAddressTokenizer initialize"	| atomChars |	CSParens := CharacterSet empty.	CSParens addAll: '()'.	CSSpecials := CharacterSet empty.	CSSpecials addAll: '()<>@,;:\".[]'.	CSNonSeparators := CharacterSet separators complement.	"(from RFC 2822)"	atomChars := CharacterSet empty.	atomChars addAll: ($A to: $Z).	atomChars addAll: ($a to: $z).	atomChars addAll: ($0 to: $9).	atomChars addAll: '!!#$%^''*+-/=?^_`{|}~'.	CSNonAtom :=  atomChars complement.! !MailAddressTokenizer initialize!