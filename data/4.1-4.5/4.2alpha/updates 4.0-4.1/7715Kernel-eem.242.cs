"Change Set:		7715Kernel-eem.242Kernel-eem.242:Second package of eight in closure compiler fixes 9/5/2009.AdditionalMethodState replaces MethodProperties.  Kernel support for Compiler-eem.78 & Compiler-eem.79.Add ProtoObject>>withArgs:executeMethod: for compiler'suse indtead of adding a method under #DoIt.Make doesNotUnderstand: support resume:.  RequiresExceptions-eem.12.Speed up instVarNamed: et al using ClassDescription>>instVarIndexFor:ifAbsent:Speed up Object>>species by using class prim directly.Kernel-ar.233:Restore traits composition when printing class definitions.Kernel-ar.234:BlockClosure>>argumentCount for ansi compatibility.Kernel-tfel.235:Changed the parsing from Stream in Date and Time classes to be more forgiving and esp. in the Date class to allow the ISO8601 format. Also changed the DateAndTime parsing to use the methods of Date and Time to parse their parts of the Stream making the whole method more forgiving if they don't properly keep to the standard.Kernel-tfel.236:This fixes Bug #0006764 where Duration couldn't deal with trailing spaces properly.Kernel-ar.237:http://bugs.squeak.org/view.php?id=7321Change Set:		DelayCleanupDate:			23 March 2009Author:			Andreas RaabCleans up Delay by removing many of the no longer used methods (timerInterruptWatcher etc). It also provides some fixes for methods that got mysteriously broken even though their original versions were perfectly fine, including Delay class>>timeoutSemaphore:after:.Kernel-ar.238:http://bugs.squeak.org/view.php?id=7321Change Set:		AtomicProcessSuspendDate:			23 March 2009Author:			Andreas RaabIn-image support for atomic process suspend.Kernel-ar.239:Ah, yes. Our version of Monticello removes methods before installing the new ones and that doesn't play very well when it comes to Delay. Silly, silly Monticello. Restore the methods so people can load the update and leave in the cruft for now.Kernel-ar.240:http://bugs.squeak.org/view.php?id=7321(three more change sets at once since I can't wait three hours for the commits to complete)Change Set:		SignalExceptionFixDate:			23 March 2009Author:			Andreas RaabA fix for Process>>signalException: which would not work properly for Process subclasses and should use atomic suspend if at all available.Change Set:		ProcessTerminateFixDate:			23 March 2009Author:			Andreas RaabFixes a problem in Process>>isTerminated which can cause severe problems if the process which is being asked runs at a higher priority than the process asking. In this situation the answer may be incorrect if an external signal occurs while the code is trying to find the bottom context of an executing process.Change Set:		DelayWaitTimeoutDate:			23 March 2009Author:			Andreas RaabProvides a light-weight, correct implementation of waitTimeoutMSecs:Kernel-laza.241:Removes the warning of too long delays from the Delay class comment"!Object subclass: #Delay	instanceVariableNames: 'delayDuration resumptionTime delaySemaphore beingWaitedOn'	classVariableNames: 'AccessProtect ActiveDelay ActiveDelayStartTime DelaySuspended FinishedDelay RunTimerEventLoop ScheduledDelay SuspendedDelays TimerEventLoop TimingSemaphore'	poolDictionaries: ''	category: 'Kernel-Processes'!Object variableSubclass: #AdditionalMethodState	instanceVariableNames: 'method selector'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!Object subclass: #Pragma	instanceVariableNames: 'method keyword arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!Delay subclass: #DelayWaitTimeout	instanceVariableNames: 'process expired'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Processes'!!CompiledMethod methodsFor: 'source code management' stamp: 'eem 7/1/2009 13:52'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString |	(SourceFiles == nil or: [(file := SourceFiles at: fileIndex) == nil]) ifTrue:		[^self become: (self copyWithTempsFromMethodNode: methodNode)].	SmalltalkImage current assureStartupStampLogged.	file setToEnd.	preambleBlock value: file.  "Write the preamble"	remoteString := RemoteString newString: sourceStr onFileNumber: fileIndex toFile: file.	file nextChunkPut: ' '.	InMidstOfFileinNotification signal ifFalse: [file flush].	self checkOKToAdd: sourceStr size at: remoteString position.	self setSourcePosition: remoteString position inFile: fileIndex! !!MethodProperties methodsFor: 'forward compatibility' stamp: 'eem 9/5/2009 14:31'!setMethod: ignored	"For forward compatibility wth AdditionalMethodState"! !!Delay class methodsFor: 'instance creation' stamp: 'dtl 12/11/2004 11:59'!forMilliseconds: anInteger	"Return a new Delay for the given number of milliseconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	anInteger < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: anInteger asInteger		forSemaphore: Semaphore new! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 10:25'!properties	| propertyStream |	propertyStream := WriteStream on: (Array new: self basicSize * 2).	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[propertyStream nextPut: propertyOrPragma key; nextPut: propertyOrPragma value]].	^IdentityDictionary newFromPairs: propertyStream contents! !!Pragma class methodsFor: 'instance creation' stamp: 'eem 11/29/2008 14:00'!for: aMethod selector: aSelector arguments: anArray	^self new		setMethod: aMethod;		setKeyword: aSelector;		setArguments: anArray;		yourself! !!ClassDescription methodsFor: 'instance variables' stamp: 'eem 5/14/2008 13:15'!instVarIndexFor: instVarName ifAbsent: aBlock	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 				ifTrue: [0]				ifFalse: [instanceVariables indexOf: instVarName ifAbsent: [0]].	index == 0 ifTrue: 		[^superclass == nil 			ifTrue: [aBlock value]			ifFalse: [superclass instVarIndexFor: instVarName ifAbsent: aBlock]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!MethodProperties methodsFor: 'accessing' stamp: 'ar 2/28/2006 18:31'!pragmas: anArray	pragmas := anArray! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 7/1/2009 12:56'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| flagByte |	flagByte := self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) allSatisfy: [:i | (self at: self size - i) = 0])]])		ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNamesString)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"	^self getSourceFromFile ifNil:		["Something really wrong -- decompile blind (no temps)"		 (class decompilerClass new decompile: selector in: class method: self)			decompileString]! !!MethodContext methodsFor: 'private-exceptions' stamp: 'eem 2/7/2009 18:07'!cannotReturn: result	closureOrNil notNil ifTrue:		[^self cannotReturn: result to: self home sender].	ToolSet		debugContext: thisContext		label: 'computation has been terminated'		contents: nil! !!MethodProperties methodsFor: 'testing' stamp: 'ar 3/7/2006 16:35'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	properties ifNil:[^false].	properties keysAndValuesDo: [:key :value |		key == literal ifTrue: [^true].		value == literal ifTrue:[^true].		(value class == Array and: [value hasLiteral: literal]) ifTrue: [^ true]].	^false! !!Pragma methodsFor: 'comparing' stamp: 'eem 3/7/2009 11:54'!analogousCodeTo: anObject 	^self class == anObject class	  and: [keyword == anObject keyword	  and: [arguments = anObject arguments]]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/29/2008 11:38'!methodClassAssociation	"answer the association to the class that I am installed in, or nil if none."	^self literalAt: self numLiterals! !!Semaphore methodsFor: 'communication' stamp: 'ar 3/27/2009 22:37'!waitTimeoutSeconds: anInteger	"Wait on this semaphore for up to the given number of seconds, then timeout.	Return true if the deadline expired, false otherwise."	^self waitTimeoutMSecs: anInteger * 1000.! !!AdditionalMethodState methodsFor: 'testing' stamp: 'md 2/19/2006 11:24'!isMethodProperties	^true! !!Message methodsFor: 'comparing' stamp: 'eem 11/27/2008 13:17'!analogousCodeTo: anObject	"For MethodPropertires comparison."	^self class == anObject class	  and: [selector == anObject selector	  and: [args = anObject arguments	  and: [lookupClass == anObject lookupClass]]]! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 10:18'!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifTrue:			[aBlock value: propertyOrPragma key value: propertyOrPragma value]]! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 12/1/2008 16:49'!notEmpty	^self basicSize > 0! !!MethodProperties methodsFor: 'private' stamp: 'ar 2/28/2006 18:30'!addPragma: aPragma	pragmas := self pragmas copyWith: aPragma.! !!AdditionalMethodState methodsFor: 'testing' stamp: 'bgf 12/6/2008 12:15'!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [(aBlock value: propertyOrPragma key)					or: [(aBlock value: propertyOrPragma value)					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteralSuchThat: aBlock]]]]			ifFalse: [propertyOrPragma hasLiteralSuchThat: aBlock]) ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector	^selector! !!ContextPart methodsFor: 'query' stamp: 'eem 11/26/2008 20:21'!isContext	^true! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/30/2008 08:55'!properties	"Answer the method properties of the receiver."	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector]		ifFalse: [AdditionalMethodState forMethod: self selector: propertiesOrSelector]! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 12/5/2008 09:48'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	(primIndex := self primitive) = 0 ifTrue:		[^self].	primIndex = 120 ifTrue: "External call spec"		[^aStream print: (self literalAt: 1); cr].	aStream nextPutAll: '<primitive: '.	primIndex = 117		ifTrue:			[primDecl := self literalAt: 1.			 (primDecl at: 2) asString printOn: aStream.			 (primDecl at: 1) ifNotNil:				[:moduleName|				aStream nextPutAll:' module: '.				moduleName asString printOn: aStream]]		ifFalse:			[aStream print: primIndex].	self primitiveErrorVariableName ifNotNil:		[:primitiveErrorVariableName|		 aStream nextPutAll: ' error: '; nextPutAll: primitiveErrorVariableName].	aStream nextPut: $>; cr! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 11:45'!propertyValueAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma key == aKey]) ifTrue:			[^propertyOrPragma value]].	^aBlock value! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 4/30/2009 18:14'!parserClass	^self methodClass 		ifNil: [Compiler parserClass] 		ifNotNil: [:class | class parserClass].! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 6/30/2009 12:38'!endPC	"Answer the index of the last bytecode."	| size flagByte |	"Can't create a zero-sized CompiledMethod so no need to use last for the errorEmptyCollection check.	 We can reuse size."	size := self size.	flagByte := self at: size.	flagByte = 0 ifTrue:		["If last byte = 0, may be either 0, 0, 0, 0 or just 0"		1 to: 4 do: [:i | (self at: size - i) = 0 ifFalse: [^size - i]]].	flagByte < 252 ifTrue:		["Magic sources (temp names encoded in last few bytes)"		^flagByte <= 127			ifTrue: [size - flagByte - 1]			ifFalse: [size - (flagByte - 128 * 128) - (self at: size - 1) - 2]].	"Normal 4-byte source pointer"	^size - 4! !!BlockClosure methodsFor: 'testing' stamp: 'eem 11/26/2008 20:27'!isDead	"Has self finished"	^false! !!Delay class methodsFor: 'class initialization' stamp: 'bgf 2/25/2009 18:36'!initialize	"Delay initialize."	self startTimerEventLoop.! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 12/1/2008 10:53'!includesKey: aKey	"Test if the property aKey or pragma with selector aKey is present."	1 to: self basicSize do:		[:i |		(self basicAt: i) key == aKey ifTrue:			[^true]].	^false! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 11/29/2008 13:47'!isEmpty	^self basicSize = 0! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/29/2009 09:48'!mapFromBlockKeys: keys toSchematicTemps: schematicTempNamesString	"Decode a schematicTempNamesString that encodes the layout of temp names	 in a method and any closures/blocks within it, matching keys in keys to	 vectors of temp names."	| map tempNames |	map := Dictionary new.	tempNames := schematicTempNamesString readStream.	keys do:		[:key| | tempSequence tempIndex |		tempSequence := OrderedCollection new.		tempIndex := 0.		[(tempNames skipSeparators; peek) ifNil: [true] ifNotNil: [:ch| '[]' includes: ch]] whileFalse:			[tempNames peek = $(				ifTrue: [tempSequence addAllLast: ((self tempsSubSequenceFrom: (tempNames next; yourself)) withIndexCollect:														[:temp :index|														{ temp. { tempIndex + 1. index } }]).						tempNames peek ~= $) ifTrue: [self error: 'parse error'].						tempIndex := tempIndex + 1.						tempNames next]				ifFalse: [tempSequence addAllLast: ((self tempsSubSequenceFrom: tempNames) withIndexCollect:														[:temp :index|														{ temp. tempIndex := tempIndex + 1 }])]].		map at: key put: tempSequence asArray.		[tempNames peek = $]] whileTrue: [tempNames next].		tempNames peek = $[ ifTrue:			[tempNames next]].	^map! !!Object methodsFor: 'system primitives' stamp: 'eem 5/14/2008 13:20'!instVarNamed: aString	"Return the value of the instance variable in me with that name.  Slow and unclean, but very useful. "	^ self instVarAt: (self class						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])! !!Object methodsFor: 'testing' stamp: 'eem 11/26/2008 20:22'!isContext	^false! !!Process methodsFor: 'changing process state' stamp: 'ar 3/23/2009 20:04'!terminate 	"Stop the process that the receiver represents forever.  Unwind to execute pending ensure:/ifCurtailed: blocks before terminating."	| ctxt unwindBlock oldList |	self isActiveProcess ifTrue: [		ctxt := thisContext.		[	ctxt := ctxt findNextUnwindContextUpTo: nil.			ctxt isNil		] whileFalse: [			unwindBlock := ctxt tempAt: 1.			unwindBlock ifNotNil: [				ctxt tempAt: 1 put: nil.				thisContext terminateTo: ctxt.				unwindBlock value].		].		thisContext terminateTo: nil.		self suspend.	] ifFalse:[		myList ifNotNil:[oldList := self suspend].		suspendedContext ifNotNil:[			"Figure out if we are terminating the process while waiting in Semaphore>>critical:			In this case, pop the suspendedContext so that we leave the ensure: block inside			Semaphore>>critical: without signaling the semaphore."			(oldList class == Semaphore and:[				suspendedContext method == (Semaphore compiledMethodAt: #critical:)]) ifTrue:[					suspendedContext := suspendedContext home.			].			ctxt := self popTo: suspendedContext bottomContext.			ctxt == suspendedContext bottomContext ifFalse: [				self debug: ctxt title: 'Unwind error during termination']].	].! !!MethodProperties methodsFor: 'accessing' stamp: 'ar 2/28/2006 18:30'!pragmas	^pragmas ifNil:[#()]! !!CompiledMethod methodsFor: 'testing' stamp: 'eem 11/29/2008 11:28'!hasNewPropertyFormat	"As of the closure compiler all methods have (or better have) the new	 format where the penultimate literal is either the method's selector	 or its properties and the ultimate literal is the class association."	^true! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 18:28'!setMethod: aMethod	method := aMethod.	1 to: self basicSize do:		[:i| | propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifFalse:			[propertyOrPragma setMethod: aMethod]]! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 1/9/2008 11:21'!printOn: aStream 	"Overrides method inherited from the byte arrayed collection."	self printNameOn: aStream.	aStream nextPut: $(; print: self identityHash; nextPutAll: ': '; 		print: self methodClass; nextPutAll: '>>'; nextPutAll: self selector; nextPut: $).	"aStream space; nextPutAll: self identityHashPrintString"! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 12/1/2008 16:58'!pragmaAt: aKey	"Answer the pragma with selector aKey, or nil if none."	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector at: aKey ifAbsent: [nil]]		ifFalse: [nil]! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 17:33'!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	| propertiesOrSelector |	(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifTrue:		[propertiesOrSelector propertyKeysAndValuesDo: aBlock]! !!DelayWaitTimeout methodsFor: 'private' stamp: 'ar 3/23/2009 16:38'!setDelay: anInteger forSemaphore: aSemaphore	super setDelay: anInteger forSemaphore: aSemaphore.	process := Processor activeProcess.	expired := false.! !!Object methodsFor: 'private' stamp: 'eem 5/9/2008 09:04'!species	"Answer the preferred class for reconstructing the receiver.  For example, 	collections create new collections whenever enumeration messages such as 	collect: or select: are invoked.  The new kind of collection is determined by 	the species of the original collection.  Species and class are not always the 	same.  For example, the species of Interval is Array."	<primitive: 111>	^self class! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 11/29/2008 17:01'!hasLiteralSuchThat: litBlock	"Answer true if litBlock returns true for any literal in this method, even if embedded in array structure."	(self penultimateLiteral isMethodProperties	 and: [self penultimateLiteral hasLiteralSuchThat: litBlock]) ifTrue:		[^true].	2 to: self numLiterals + 1 do:		[:index | | lit |		lit := self objectAt: index.		((litBlock value: lit)		or: [lit isArray and: [lit hasLiteralSuchThat: litBlock]]) ifTrue:			[^true]].	^false! !!MethodContext methodsFor: 'accessing' stamp: 'eem 4/25/2009 09:50'!hasMethodReturn	^closureOrNil hasMethodReturn! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 6/5/2009 18:07'!qDecompressFrom: input "<ReadStream on: ByteArray> ^<String>"	"Decompress strings compressed by qCompress:.	Most common 11 chars get values 0-10 packed in one 4-bit nibble;	next most common 52 get values 12-15 (2 bits) * 16 plus next nibble;	escaped chars get three nibbles"	^ String streamContents:		[:strm | | nextNibble nibble peek charTable char |		charTable :=  "Character encoding table must match qCompress:"		'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'.		peek := true.		nextNibble := [peek						ifTrue: [peek := false. input peek ifNil: [0] ifNotNil: [:b| b // 16]]						ifFalse: [peek := true. input next ifNil: [0] ifNotNil: [:b| b \\ 16]]].		[input atEnd] whileFalse:			[(nibble := nextNibble value) = 0				ifTrue: [input atEnd ifFalse:						[strm nextPut: (Character value: nextNibble value * 16 + nextNibble value)]]				ifFalse:					[nibble <= 11						ifTrue:							[strm nextPut: (charTable at: nibble)]						ifFalse:							[strm nextPut: (charTable at: nibble-12 * 16 + nextNibble value)]]]]! !!Delay methodsFor: 'private' stamp: 'ar 3/2/2009 14:41'!schedule	"Schedule this delay"	resumptionTime := Time millisecondClockValue + delayDuration.	AccessProtect critical:[		ScheduledDelay := self.		TimingSemaphore signal.	].! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 9/5/2009 13:05'!simulateValueWithArguments: anArray caller: aContext	| newContext sz |	(anArray class ~~ Array	 or: [numArgs ~= anArray size]) ifTrue:		[^ContextPart primitiveFailToken].	newContext := (MethodContext newForMethod: outerContext method)						setSender: aContext						receiver: outerContext receiver						method: outerContext method						closure: self						startpc: startpc.	sz := self basicSize.	newContext stackp: sz + numArgs.	1 to: numArgs do:		[:i| newContext at: i put: (anArray at: i)].	1 to: sz do:		[:i| newContext at: i + numArgs put: (self at: i)].	^newContext! !!BlockClosure methodsFor: 'error handing' stamp: 'eem 11/26/2008 20:03'!numArgsError: numArgsForInvocation	| printNArgs |	printNArgs := [:n| n printString, ' argument', (n = 1 ifTrue: [''] ifFalse:['s'])]. 	self error: 			'This block accepts ', (printNArgs value: numArgs), 			', but was called with ', (printNArgs value: numArgsForInvocation), '.'! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 6/8/2009 14:32'!copyWithTempsFromMethodNode: aMethodNode	^self copyWithTrailerBytes: (self qCompress: aMethodNode schematicTempNamesString)! !!Delay class methodsFor: 'instance creation' stamp: 'di 6/16/1999 23:04'!forSeconds: aNumber	"Return a new Delay for the given number of seconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	aNumber < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: (aNumber * 1000) asInteger		forSemaphore: Semaphore new! !!MethodProperties methodsFor: 'testing' stamp: 'eem 5/15/2008 09:36'!analogousCodeTo: aMethodProperties	pragmas		ifNil: [aMethodProperties pragmas notEmpty ifTrue: [^false]]		ifNotNil:			[aMethodProperties pragmas empty ifTrue: [^false].			 pragmas size ~= aMethodProperties pragmas size ifTrue:				[^false].			 pragmas with: aMethodProperties pragmas do:				[:mine :others|				(mine analogousCodeTo: others) ifFalse: [^false]]].	^(self hasAtLeastTheSamePropertiesAs: aMethodProperties)	  and: [aMethodProperties hasAtLeastTheSamePropertiesAs: self]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/28/2008 12:54'!selector	"Answer a method's selector.  This is either the penultimate literal,	 or, if the method has any properties or pragmas, the selector of	 the MethodProperties stored in the penultimate literal."	| penultimateLiteral | 	^(penultimateLiteral := self penultimateLiteral) isMethodProperties		ifTrue: [penultimateLiteral selector]		ifFalse: [penultimateLiteral]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/29/2008 11:38'!methodClass	"answer the class that I am installed in"	^(self literalAt: self numLiterals) value.! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 11/29/2008 16:40'!hasLiteralThorough: literal	"Answer true if any literal in these properties is literal,	 even if embedded in array structure."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding			ifTrue: [propertyOrPragma key == literal					or: [propertyOrPragma value == literal					or: [propertyOrPragma value isArray						and: [propertyOrPragma value hasLiteral: literal]]]]			ifFalse: [propertyOrPragma hasLiteral: literal]) ifTrue:			[^true]].	^false! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 6/11/2008 17:08'!who	"Answer an Array of the class in which the receiver is defined and the 	selector to which it corresponds."	self hasNewPropertyFormat ifTrue:[^{self methodClass. self selector}].	self systemNavigation allBehaviorsDo: 		[:class | 		(class methodDict keyAtIdentityValue: self ifAbsent: [nil]) ifNotNil:			[:sel| ^Array with: class with: sel]].	^Array with: #unknown with: #unknown! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 11/29/2008 18:35'!copyWith: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which includes aPropertyOrPragma"	| bs copy |	(Association == aPropertyOrPragma class	 or: [Pragma == aPropertyOrPragma class]) ifFalse:		[self error: self class name, ' instances should hold only Associations or Pragmas.'].	copy := self class new: (bs := self basicSize) + 1.	1 to: bs do:		[:i|		copy basicAt: i put: (self basicAt: i)].	copy basicAt: bs + 1 put: aPropertyOrPragma.	^copy		selector: selector;		setMethod: method;		yourself! !!Date class methodsFor: 'squeak protocol' stamp: 'tfel 9/1/2009 07:08'!readFrom: aStream 	"Read a Date from the stream in any of the forms:  		<day> <month> <year>		(15 April 1982; 15-APR-82; 15.4.82; 15APR82)  		<month> <day> <year>		(April 15, 1982; 4/15/82)		<year>-<month>-<day>			(1982-04-15) (ISO8601)"	| day month year parsedNumber prefix |	aStream peek = $-		ifTrue: [prefix := -1]		ifFalse: [prefix := 1].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	aStream peek isDigit		ifTrue: [			parsedNumber := (Integer readFrom: aStream) * prefix.			(parsedNumber < 0 or: [parsedNumber > 31])				ifTrue: [year := parsedNumber]].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"			month := WriteStream on: (String new: 10).			[aStream peek isLetter]				whileTrue: [month nextPut: aStream next].			month := month contents.			[aStream peek isAlphaNumeric]				whileFalse: [aStream skip: 1].			parsedNumber isNil				ifTrue: ["MM DD YY"					day := Integer readFrom: aStream]				ifFalse: [					year isNil						ifTrue: ["DD MM YY"							day := parsedNumber]]]		ifFalse: ["MM-DD-YY or DD-MM-YY or YY-MM-DD"			year isNil 				ifTrue: ["MM-DD-YY or DD-MM-YY"					parsedNumber > 12						ifTrue: ["DD-MM-YY"							day := parsedNumber.							month := Month nameOfMonth: (Integer readFrom: aStream)]						ifFalse: ["MM-DD-YY"							month := Month nameOfMonth: parsedNumber.							day := Integer readFrom: aStream]]				ifFalse: ["YY-MM-DD"					month := Month nameOfMonth: (Integer readFrom: aStream)]].	[aStream peek isAlphaNumeric]		whileFalse: [aStream skip: 1].	year isNil		ifTrue: [year := Integer readFrom: aStream]		ifFalse: [day := Integer readFrom: aStream].	(year < 100 and: [year >= 0]) 		ifTrue: [			year < 69 				ifTrue: [	year := 2000 + year]				ifFalse: [year := 1900 + year]].	^ self		year: year		month: month		day: day! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 11/29/2008 11:38'!indexOfLiteral: literal	"Answer the literal index of the argument, literal, or zero if none."	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	   do:		[:index |		literal == (self objectAt: index) ifTrue: [^index - 1]].	^0! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 12/1/2008 11:02'!removeProperty: propName	"Remove the property propName if it exists.	 Do _not_ raise an error if the property is missing."	| value |	value := self propertyValueAt: propName ifAbsent: [^nil].	self penultimateLiteral: (self penultimateLiteral copyWithout:									(Association										key: propName										value: value)).	^value! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 11:50'!propertyValueAt: propName ifAbsent: aBlock	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector propertyValueAt: propName ifAbsent: aBlock]		ifFalse: [aBlock value]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 8/20/2009 11:43'!clearFlag	"Clear the user-level flag bit"	self objectAt: 1 put: (self header bitAnd: (1 << 29) bitInvert)! !!Semaphore methodsFor: 'communication' stamp: 'ar 3/27/2009 22:38'!waitTimeoutMSecs: anInteger	"Wait on this semaphore for up to the given number of milliseconds, then timeout. 	Return true if the deadline expired, false otherwise."	| d |	d := DelayWaitTimeout new setDelay: (anInteger max: 0) forSemaphore: self.	^d wait! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/30/2008 08:55'!propertyValueAt: propName put: propValue	"Set or add the property with key propName and value propValue.	 If the receiver does not yet have a method properties create one and replace	 the selector with it.  Otherwise, either relace propValue in the method properties	 or replace method properties with one containing the new property."	| propertiesOrSelector |	(propertiesOrSelector := self penultimateLiteral) isMethodProperties ifFalse:		[self penultimateLiteral: ((AdditionalMethodState									selector: propertiesOrSelector									with: (Association											key: propName asSymbol											value: propValue))									setMethod: self;									yourself).		^propValue].	(propertiesOrSelector includesProperty: propName) ifTrue:		[^propertiesOrSelector at: propName put: propValue].	self penultimateLiteral: (propertiesOrSelector								copyWith: (Association												key: propName asSymbol												value: propValue)).	^propValue! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 7/21/2009 13:26'!qCompress: string	"A very simple text compression routine designed for method temp names.	 Most common 11 chars get values 1-11 packed in one 4-bit nibble;	 the next most common get values 12-15 (2 bits) * 16 plus next nibble;	 unusual ones get three nibbles, the first being the escape nibble 0.	 CompiledMethod>>endPC determines the maximum length of encoded	 output, which means 1 to (251 - 128) * 128 + 127, or 15871 bytes"	string isEmpty ifTrue:		[^self qCompress: ' '].	^ ByteArray streamContents:		[:strm | | ix oddNibble sz |		oddNibble := nil.		string do:			[:char |			ix := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'					indexOf: char ifAbsent: 0.			(ix = 0				ifTrue:					[char asInteger > 255 ifTrue: [^nil]. "Could use UTF8 here; too lazy right now"					{ 0. char asInteger // 16. char asInteger \\ 16 }]				ifFalse:					[ix <= 11						ifTrue: [{ ix }]						ifFalse: [{ ix//16+12. ix\\16 }]])					do: [:nibble |						oddNibble							ifNotNil: [strm nextPut: oddNibble*16 + nibble. oddNibble := nil]							ifNil: [oddNibble := nibble]]].		oddNibble ifNotNil: "4 = 'ear tonsil' indexOf: Character space"			[strm nextPut: oddNibble * 16 + 4].		(sz := strm position) > ((251 - 128) * 128 + 127) ifTrue:			[^nil].		sz <= 127			ifTrue: [strm nextPut: sz]			ifFalse:				[strm nextPut: sz \\ 128; nextPut: sz // 128 + 128]]! !!Process methodsFor: 'changing process state' stamp: 'ar 12/7/2007 17:10'!suspend	"Primitive. Stop the process that the receiver represents in such a way 	that it can be restarted at a later time (by sending the receiver the 	message resume). If the receiver represents the activeProcess, suspend it. 	Otherwise remove the receiver from the list of waiting processes.	The return value of this method is the list the receiver was previously on (if any)."	| oldList |	<primitive: 88>	"This is fallback code for VMs which only support the old primitiveSuspend which 	would not accept processes that are waiting to be run."	myList ifNil:[^nil]. "this allows us to use suspend multiple times"	oldList := myList.	myList := nil.	oldList remove: self ifAbsent:[].	^oldList! !!Delay methodsFor: 'private' stamp: 'jm 9/12/97 08:56'!setDelay: millisecondCount forSemaphore: aSemaphore	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."	delayDuration := millisecondCount.	delaySemaphore := aSemaphore.	beingWaitedOn := false.! !!Delay class methodsFor: 'snapshotting' stamp: 'ar 9/30/2007 12:46'!shutDown	"Suspend the active delay, if any, before snapshotting. It will be reactived when the snapshot is resumed."	"Details: This prevents a timer interrupt from waking up the active delay in the midst snapshoting, since the active delay will be restarted when resuming the snapshot and we don't want to process the delay twice."	AccessProtect wait.	self primSignal: nil atMilliseconds: 0.	self saveResumptionTimes.	DelaySuspended := true.! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 5/29/2009 12:16'!holdsTempNames	"Are tempNames stored in trailer bytes"	| flagByte |	flagByte := self last.	(flagByte = 0 or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [(1 to: 3) allSatisfy: [:i | (self at: self size - i) = 0]]])		ifTrue: [^ false].  "No source pointer & no temp names"	flagByte < 252 ifTrue: [^ true].  "temp names compressed"	^ false	"Source pointer"! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 12/1/2008 10:54'!at: aKey ifAbsentPut: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^method propertyValueAt: aKey put: aBlock value! !!Delay class methodsFor: 'instance creation' stamp: 'jm 9/15/97 17:10'!timeoutSemaphore: aSemaphore afterMSecs: anInteger	"Create and schedule a Delay to signal the given semaphore when the given number of milliseconds has elapsed. Return the scheduled Delay. The timeout can be cancelled by sending 'unschedule' to this Delay."	"Details: This mechanism is used to provide a timeout when waiting for an external event, such as arrival of data over a network connection, to signal a semaphore. The timeout ensures that the semaphore will be signalled within a reasonable period of time even if the event fails to occur. Typically, the waiting process cancels the timeout request when awoken, then determines if the awaited event has actually occurred."	anInteger < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ (self new setDelay: anInteger forSemaphore: aSemaphore) schedule! !!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 11/28/2008 12:26'!selector: aSelector with: aPropertyOrPragma	^(self basicNew: 1)		selector: aSelector;		basicAt: 1 put: aPropertyOrPragma;		yourself! !!Object methodsFor: 'error handling' stamp: 'jcg 8/10/2008 21:58'!caseError	"Report an error from an in-line or explicit case statement."	self error: 'Case not found (', self printString, '), and no otherwise clause'! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 7/6/2009 15:57'!methodNode	"Return the parse tree that represents self"	| aClass source |	aClass := self methodClass.	source := self				getSourceFor: (self selector ifNil: [self defaultSelector])				in: aClass.	^(aClass parserClass new		encoderClass: (self isBlueBookCompiled						ifTrue: [EncoderForV3]						ifFalse: [EncoderForV3PlusClosures]);		parse: source class: aClass)			sourceText: source;			yourself! !!AdditionalMethodState methodsFor: 'copying' stamp: 'eem 11/29/2008 18:35'!copyWithout: aPropertyOrPragma "<Association|Pragma>"	"Answer a copy of the receiver which no longer includes aPropertyOrPragma"	| bs copy offset |	copy := self class new: (bs := self basicSize) - ((self includes: aPropertyOrPragma)													ifTrue: [1]													ifFalse: [0]).	offset := 0.	1 to: bs do:		[:i|		(self basicAt: i) = aPropertyOrPragma			ifTrue: [offset := 1]			ifFalse: [copy basicAt: i - offset put: (self basicAt: i)]].	^copy		selector: selector;		setMethod: method;		yourself! !!AdditionalMethodState class methodsFor: 'instance creation' stamp: 'eem 11/29/2008 18:48'!forMethod: aMethod selector: aSelector	^(self basicNew: 0)		selector: aSelector;		setMethod: aMethod;		yourself! !!Object methodsFor: 'error handling' stamp: 'eem 12/19/2008 10:46'!doesNotUnderstand: aMessage 	 "Handle the fact that there was an attempt to send the given	  message to the receiver but the receiver does not understand	  this message (typically sent from the machine when a message	 is sent to the receiver and no method is defined for that selector)."	"Testing: (3 activeProcess)"	| exception resumeValue |	(Preferences autoAccessors	 and: [self tryToDefineVariableAccess: aMessage]) ifTrue:		[^aMessage sentTo: self].	(exception := MessageNotUnderstood new)		message: aMessage;		receiver: self.	resumeValue := exception signal.	^exception reachedDefaultHandler		ifTrue: [aMessage sentTo: self]		ifFalse: [resumeValue]! !!Object methodsFor: 'system primitives' stamp: 'eem 5/14/2008 13:20'!instVarNamed: aString put: aValue	"Store into the value of the instance variable in me of that name.  Slow and unclean, but very useful. "	^self		instVarAt: (self class						instVarIndexFor: aString asString						ifAbsent: [self error: 'no such inst var'])		put: aValue! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 10:19'!at: aKey	"Answer the property value or pragma associated with aKey."		^self at: aKey ifAbsent: [self error: 'not found']! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 11/29/2008 11:37'!hasLiteral: literal	"Answer whether the receiver references the argument, literal."	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	  do:[:index |		literal == (self objectAt: index) ifTrue: [^true]].	^false! !!Delay class methodsFor: 'timer process' stamp: 'ar 3/2/2009 14:40'!startTimerEventLoop	"Start the timer event loop"	"Delay startTimerEventLoop"	self stopTimerEventLoop.	AccessProtect := Semaphore forMutualExclusion.	ActiveDelayStartTime := Time millisecondClockValue.	SuspendedDelays := 		Heap withAll: (SuspendedDelays ifNil:[#()])			sortBlock: [:d1 :d2 | d1 resumptionTime <= d2 resumptionTime].	TimingSemaphore := Semaphore new.	RunTimerEventLoop := true.	TimerEventLoop := [self runTimerEventLoop] newProcess.	TimerEventLoop priority: Processor timingPriority.	TimerEventLoop resume.	TimingSemaphore signal. "get going"! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 11:46'!propertyValueAt: aKey	"Answer the property value associated with aKey."		^ self propertyValueAt: aKey ifAbsent: [ self error: 'Property not found' ].! !!Process methodsFor: 'accessing' stamp: 'bgf 12/31/2008 11:56'!isTerminated	self isActiveProcess ifTrue: [^ false].	^suspendedContext isNil	  or: ["If the suspendedContext is the bottomContext it is the block in Process>>newProcess.		   If so, and the pc is greater than the startpc, the bock has alrteady sent and returned		   from value and there is nothing more to do."		suspendedContext isBottomContext		and: [suspendedContext pc > suspendedContext startpc]]! !!Message methodsFor: 'accessing' stamp: 'eem 1/3/2009 10:42'!numArgs	"Answer the number of arguments in this message"	^args size! !!ClassDescription methodsFor: 'instance variables' stamp: 'eem 6/11/2008 16:53'!chooseClassVarName 	"Present the user with a list of class variable names and answer the one selected, or nil if none"	| lines labelStream allVars index |	lines := OrderedCollection new.	allVars := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[:class | | vars |		vars := class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^Beeper beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index := (UIManager default chooseFrom: (labelStream contents substrings) lines: lines).	index = 0 ifTrue: [^ nil].	^ allVars at: index! !!Pragma methodsFor: 'testing' stamp: 'eem 11/29/2008 17:03'!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in the receiver, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	^(aBlock value: keyword)	   or: [arguments hasLiteralSuchThat: aBlock]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 9/1/2009 00:59'!definition	"Answer a String that defines the receiver."	| aStream path |	aStream := WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'ProtoObject']		ifFalse: [path := ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path := remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass;			store: self name.	(self hasTraitComposition and: [self traitComposition notEmpty]) ifTrue: [		aStream cr; tab; nextPutAll: 'uses: ';			nextPutAll: self traitCompositionString].	aStream cr; tab; nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: ';			store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: ';			store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: ';			store: (SystemOrganization categoryOfElement: self name) asString.	superclass ifNil: [ 		aStream nextPutAll: '.'; cr.		aStream nextPutAll: self name.		aStream space; nextPutAll: 'superclass: nil'. ].	^ aStream contents! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'md 2/16/2006 17:50'!selector: aSymbol	selector := aSymbol! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 12/13/2008 15:48'!messagesSequence	"Answer a Set of all the message selectors sent by this method."	^Array streamContents:		[:str| | scanner |		scanner := InstructionStream on: self.		scanner	scanFor: 			[:x | | selectorOrSelf |			(selectorOrSelf := scanner selectorToSendOrSelf) == scanner ifFalse:				[str nextPut: selectorOrSelf].			false	"keep scanning"]]! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 8/7/2009 11:43'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	(self penultimateLiteral isMethodProperties	 and: [self penultimateLiteral hasLiteralThorough: literal]) ifTrue:[^true].	2 to: self numLiterals - 1 "exclude superclass + selector/properties"	   do:[:index | | lit |		((lit := self objectAt: index) == literal		 or: [(lit isVariableBinding and: [lit key == literal])		 or: [lit isArray and: [lit hasLiteral: literal]]]) ifTrue:			[^ true]].	^ false ! !!Pragma methodsFor: 'accessing-method' stamp: 'eem 12/1/2008 10:43'!selector	"Answer the selector of the method containing the pragma.	 Do not confuse this with the selector of the pragma's message pattern."		^method selector! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 9/5/2009 14:17'!decompilerClass	^self compilerClass decompilerClass! !!MethodProperties methodsFor: 'properties' stamp: 'ar 3/8/2006 00:24'!keysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	^properties ifNotNil:[properties keysAndValuesDo: aBlock]! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 14:11'!pragmas	"Answer the raw messages comprising my pragmas."	| pragmaStream |	pragmaStream := WriteStream on: (Array new: self basicSize).	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Message>" |		(propertyOrPragma := self basicAt: i) isVariableBinding ifFalse:			[pragmaStream nextPut: propertyOrPragma]].	^pragmaStream contents! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 4/30/2009 18:13'!compilerClass	^self methodClass 		ifNil: [Compiler] 		ifNotNil: [:class | class compilerClass].! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 12/1/2008 11:02'!removeProperty: propName ifAbsent: aBlock	"Remove the property propName if it exists.	 Answer the evaluation of aBlock if the property is missing."	| value |	value := self propertyValueAt: propName ifAbsent: [^aBlock value].	self penultimateLiteral: (self penultimateLiteral copyWithout:									(Association										key: propName										value: value)).	^value! !!BlockClosure methodsFor: 'private' stamp: 'eem 12/14/2008 16:47'!fixTemps	"Fix the values of the temporary variables used in the block that	 are  ordinarily shared with the method in which the block is defined.	 This is a no-op for closures, provided for backward-compatibility with	 old BlockContexts that needed the fixTemps hack to persist."! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 7/1/2009 10:09'!tempsSubSequenceFrom: tempNamesStream	^Array streamContents:		[:tsss|		[tempNamesStream skipSeparators.		 tempNamesStream atEnd		 or: ['[]()' includes: tempNamesStream peek]] whileFalse:			[tsss nextPut: (String streamContents:							[:s|							[s nextPut: tempNamesStream next.							 tempNamesStream peek								ifNil: [true]								ifNotNil: [:peek| ' []()' includes: peek]] whileFalse])]]	"thisContext method tempsSubSequenceFrom: 'les temps perdu(sont n''est pas la)' readStream"	"thisContext method tempsSubSequenceFrom: ('les temps perdu(sont n''est pas la)' readStream skipTo: $(; yourself)"! !!ContextPart methodsFor: 'private' stamp: 'eem 1/19/2009 10:23'!stackPtr  "For use only by the SystemTracer and the Debugger, Inspectors etc"	^ stackp! !!Process methodsFor: 'signaling' stamp: 'ar 12/7/2007 17:09'!signalException: anException	"Signal an exception in the receiver process...if the receiver is currently	suspended, the exception will get signaled when the receiver is resumed.  If 	the receiver is blocked on a Semaphore, it will be immediately re-awakened	and the exception will be signaled; if the exception is resumed, then the receiver	will return to a blocked state unless the blocking Semaphore has excess signals"	| oldList |	"If we are the active process, go ahead and signal the exception"	self isActiveProcess ifTrue: [^anException signal].	"Suspend myself first to ensure that I won't run away in the	midst of the following modifications."	myList ifNotNil:[oldList := self suspend].	"Add a new method context to the stack that will signal the exception"	suspendedContext := MethodContext		sender: suspendedContext		receiver: self		method: (self class lookupSelector: #pvtSignal:list:)		arguments: (Array with: anException with: oldList).	"If we are on a list to run, then suspend and restart the receiver 	(this lets the receiver run if it is currently blocked on a semaphore).  If	we are not on a list to be run (i.e. this process is suspended), then when the	process is resumed, it will signal the exception"	oldList ifNotNil: [self resume].! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/29/2009 09:50'!startpcsToBlockExtents	"Answer a Dictionary of startpc to Interval of blockExtent, using the	 identical numbering scheme described in and orchestrated by	 BlockNode>>analyseArguments:temporaries:rootNode:.  This is	 used in part to find the temp names for any block in a method, as	 needed by the debugger.  The other half is to recompile the method,	 obtaining the temp names for each block extent.  By indirecting through	 the blockExtent instead of using the startpc directly we decouple the	 debugger's access to temp names from the exact bytecode; insulating	 debugging from minor changes in the compiler (e.g. changes in literal	 pooling, adding prefix bytecodes, adding inst vars to CompiledMethod	 in literals towards the end of the literal frame, etc).  If the recompilation	 doesn't produce exactly the same bytecode at exactly the same offset	 no matter; the blockExtents will be the same."	| index |	self flag: 'belongs in DebuggerMethodMap'.	index := 0.	^self		blockExtentsInto: Dictionary new		from: self initialPC		to: self endPC		scanner: (InstructionStream on: self)		numberer: [| value | value := index. index := index + 2. value]! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 11/27/2008 13:12'!analogousCodeTo: aMethodProperties	| bs |	(bs := self basicSize) ~= aMethodProperties basicSize ifTrue:		[^false].	1 to: bs do:		[:i|		((self basicAt: i) analogousCodeTo: (aMethodProperties basicAt: i)) ifFalse:			[^false]].	^true! !!Pragma methodsFor: 'accessing-pragma' stamp: 'eem 12/1/2008 10:42'!key	"Answer the keyword of the pragma (the selector of its message pattern).	 This accessor provides polymorphism with Associations used for properties."	^keyword! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 21:00'!setSourcePointer: srcPointer	srcPointer = 0 ifTrue: [		self at: self size put: 0.		^self].	(srcPointer between: 16r1000000 and: 16r4FFFFFF) ifFalse: [self error: 'Source pointer out of range'].	self at: self size put: (srcPointer bitShift: -24) + 251.	1 to: 3 do: [:i |		self at: self size-i put: ((srcPointer bitShift: (i-3)*8) bitAnd: 16rFF)]! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 19:32'!removeKey: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma key]				ifFalse: [propertyOrPragma keyword])			== aKey ifTrue:			[^method removeProperty: aKey]].	^aBlock value! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 11:45'!propertyValueAt: propName	| propertiesOrSelector |	^(propertiesOrSelector := self penultimateLiteral) isMethodProperties		ifTrue: [propertiesOrSelector propertyValueAt: propName ifAbsent: [nil]]		ifFalse: [nil]! !!Process methodsFor: 'accessing' stamp: 'ar 12/7/2007 17:06'!offList	"OBSOLETE. Process>>suspend will atomically reset myList if the process is suspended. 	There should never be a need to send #offList but some older users may not be aware 	of the changed semantics to suspend and may try the old hickadidoo seen here:		(suspendingList := process suspendingList) == nil			ifTrue: [process == Processor activeProcess ifTrue: [process suspend]]			ifFalse: [suspendingList remove: process ifAbsent:[].					process offList].	Usages like the above should be replaced by a simple 'process suspend' "	myList := nil! !!Pragma methodsFor: 'testing' stamp: 'eem 11/29/2008 16:39'!hasLiteral: aLiteral	^keyword == aLiteral 	   or: [arguments hasLiteral: aLiteral]! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 4/30/2009 18:03'!literalStrings	| litStrs |	litStrs := OrderedCollection new: self numLiterals.	self literalsDo:		[:lit | 		(lit isVariableBinding)			ifTrue: [litStrs addLast: lit key]			ifFalse: [(lit isSymbol)				ifTrue: [litStrs addAll: lit keywords]				ifFalse: [litStrs addLast: lit printString]]].	^ litStrs! !!MessageSend methodsFor: 'accessing' stamp: 'eem 1/3/2009 10:42'!numArgs	"Answer the number of arguments in this message"	^arguments size! !!DelayWaitTimeout methodsFor: 'signaling' stamp: 'ar 3/24/2009 23:24'!signalWaitingProcess	"Release the given process from the semaphore it is waiting on.	This method relies on running at highest priority so that it cannot be preempted	by the process being released."	beingWaitedOn := false.	"Release the process but only if it is still waiting on its original list"	process suspendingList == delaySemaphore ifTrue:[		expired := true.		process suspend; resume.	].! !!CompiledMethod methodsFor: 'private' stamp: 'eem 11/29/2008 11:52'!penultimateLiteral: anObject	"Answer the penultimate literal of the receiver, which holds either	 the receiver's selector or its properties (which will hold the selector)."	| pIndex |	(pIndex := self numLiterals - 1) > 0 		ifTrue: [self literalAt: pIndex put: anObject]		ifFalse: [self error: 'insufficient literals']! !!ContextPart methodsFor: 'accessing' stamp: 'ar 4/11/2006 01:49'!methodNode	^ self method methodNode.! !!AdditionalMethodState methodsFor: 'properties' stamp: 'eem 11/29/2008 10:28'!includesProperty: aKey	"Test if the property aKey is present."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		propertyOrPragma := self basicAt: i.		(propertyOrPragma isVariableBinding		 and: [propertyOrPragma key == aKey]) ifTrue:			[^true]].	^false! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/28/2008 12:58'!selector: aSelector	"Set a method's selector.  This is either the penultimate literal,	 or, if the method has any properties or pragmas, the selector of	 the MethodProperties stored in the penultimate literal."	| penultimateLiteral nl | 	(penultimateLiteral := self penultimateLiteral) isMethodProperties		ifTrue: [penultimateLiteral selector: aSelector]		ifFalse: [(nl := self numLiterals) < 2 ifTrue:					[self error: 'insufficient literals to hold selector'].				self literalAt: nl - 1 put: aSelector]! !!Delay class methodsFor: 'primitives' stamp: 'ar 3/2/2009 14:43'!primSignal: aSemaphore atMilliseconds: aSmallInteger	"Signal the semaphore when the millisecond clock reaches the value of the second argument. Fail if the first argument is neither a Semaphore nor nil. Essential. See Object documentation whatIsAPrimitive."	<primitive: 136>	^self primitiveFailed! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'tfel 9/1/2009 22:29'!readFrom: aStream	| offset date time ch |	date := Date readFrom: aStream.	[aStream peek isDigit]		whileFalse: [aStream next].	time := Time readFrom: aStream.	aStream atEnd		ifTrue: [ offset := self localOffset ]		ifFalse: [			ch := aStream next.			ch = $+ ifTrue: [ch := Character space].			offset := Duration fromString: ch asString, '0:', aStream upToEnd, ':0'].			^ self		year: date year		month: date monthIndex		day: date dayOfMonth		hour: time hour		minute: time minute		second: time second		nanoSecond: time nanoSecond		offset: offset	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!Pragma methodsFor: 'accessing-pragma' stamp: 'eem 12/1/2008 10:42'!keyword	"Answer the keyword of the pragma (the selector of its message pattern).	 For a pragma defined as <key1: val1 key2: val2> this will answer #key1:key2:."		^ keyword! !!CompiledMethod methodsFor: 'scanning' stamp: 'eem 6/11/2008 17:07'!scanVeryLongStore: extension offset: offset	"Answer whether the receiver contains a long load with the given offset.	Note that the constant +32 is the known difference between a	store and a storePop for instVars, and it will always fail on literal variables,	but these only use store (followed by pop) anyway."	| scanner |	scanner := InstructionStream on: self.	^scanner scanFor:		[:instr | | ext |		(instr = 132 and: [(ext := scanner followingByte) = extension											or: ["might be a store/pop into rcvr"												ext = (extension+32)]])		and: [scanner thirdByte = offset]]! !!Time class methodsFor: 'smalltalk-80' stamp: 'tfel 9/1/2009 22:51'!readFrom: aStream	"Read a Time from the stream in the form:		<hour>:<minute>:<second> <am/pm>	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"	| hour minute second ampm nanos nanosBuffer |	hour := Integer readFrom: aStream.	minute := 0.	second := 0.	nanosBuffer := '000000000' copy.	nanos := WriteStream on: nanosBuffer.	(aStream peekFor: $:) 		ifTrue: [			minute := Integer readFrom: aStream.			(aStream peekFor: $:) 				ifTrue: [					second := Integer readFrom: aStream].					(aStream peekFor: $.)						ifTrue: [							[aStream atEnd not and: [aStream peek isDigit]]								whileTrue: [nanos nextPut: aStream next]]].	aStream skipSeparators.	(aStream atEnd not and: [aStream peek isLetter]) ifTrue: 		[ampm := aStream next asLowercase.		(ampm = $p and: [hour < 12]) ifTrue: [hour := hour + 12].		(ampm = $a and: [hour = 12]) ifTrue: [hour := 0].		(aStream peekFor: $m) ifFalse: [aStream peekFor: $M ]].	^ self 		hour: hour 		minute: minute 		second: second 		nanoSecond: nanosBuffer asInteger	"Time readFrom: (ReadStream on: '2:23:09 pm')"! !!AdditionalMethodState methodsFor: 'decompiling' stamp: 'eem 6/11/2009 17:06'!method: aMethodNodeOrNil	"For decompilation"	method := aMethodNodeOrNil! !!CompiledMethod methodsFor: 'accessing-pragmas & properties' stamp: 'eem 11/29/2008 16:36'!pragmas	| selectorOrProperties |	^(selectorOrProperties := self penultimateLiteral) isMethodProperties		ifTrue: [selectorOrProperties pragmas]		ifFalse: [#()]! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/19/2006 20:55'!message	"Answer the message of the receiving pragma."		^ Message selector: self keyword arguments: self arguments. ! !!AdditionalMethodState methodsFor: 'testing' stamp: 'eem 12/1/2008 10:53'!includes: aPropertyOrPragma "<Association|Pragma>"	"Test if the property or pragma is present."	1 to: self basicSize do:		[:i |		(self basicAt: i) = aPropertyOrPragma ifTrue:			[^true]].	^false! !!CompiledMethod methodsFor: 'literals' stamp: 'eem 10/28/2008 10:47'!literalsDo: aBlock	"Evaluate aBlock for each of the literals referenced by the receiver."	1 to: self numLiterals do:		[:index |		aBlock value: (self objectAt: index + 1)]! !!MethodProperties methodsFor: 'properties' stamp: 'eem 12/1/2008 14:20'!propertyKeysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	^self propertyKeysAndValuesDo: aBlock! !!MethodProperties methodsFor: 'testing' stamp: 'eem 12/1/2008 16:49'!notEmpty	^(properties notNil and: [properties notEmpty])	   or: [pragmas notNil and: [pragmas notEmpty]]! !!CompiledMethod methodsFor: 'source code management' stamp: 'eem 6/8/2009 10:29'!tempNamesString	"Decompress the encoded temp names into a schematicTempNames string."	| sz flagByte |	flagByte := self at: (sz := self size).	(flagByte = 0 or: [flagByte > 251]) ifTrue: [^self error: 'not yet implemented'].	(flagByte = 251	 and: [(1 to: 3) allSatisfy: [:i | (self at: self size - i) = 0]]) ifTrue:		[^self error: 'not yet implemented'].	^self qDecompressFrom: (flagByte <= 127								ifTrue:									[ReadStream on: self from: sz - flagByte to: sz - 1]								ifFalse:									[ReadStream on: self from: sz - (flagByte - 128 * 128 + (self at: sz - 1)) - 1 to: sz - 2])! !!MethodProperties methodsFor: 'testing' stamp: 'eem 12/3/2008 11:00'!hasLiteralSuchThat: aBlock	"Answer true if litBlock returns true for any literal in this array, even if embedded in further array structure.	 This method is only intended for private use by CompiledMethod hasLiteralSuchThat:"	properties ifNil:[^false].	properties keysAndValuesDo: [:key :value |		((aBlock value: key)		 or: [(aBlock value: value)		 or: [value isArray			and: [value hasLiteralSuchThat: aBlock]]]) ifTrue: [^true]].	^false! !!CompiledMethod methodsFor: 'testing' stamp: 'eem 12/1/2008 11:14'!isInstalled	self methodClass ifNotNil:		[:class|		self selector ifNotNil:			[:selector|			^self == (class methodDict at: selector ifAbsent: [])]].	^false! !!BlockClosure methodsFor: 'accessing' stamp: 'ar 9/1/2009 01:19'!argumentCount	"Answers the number of arguments needed to evaluate the receiver.	For ansi compatibility."	^ self numArgs! !!Delay methodsFor: 'printing' stamp: 'ar 7/10/2007 22:12'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('; print: delayDuration; nextPutAll: ' msecs'.	beingWaitedOn ifTrue:[		aStream nextPutAll: '; '; print: resumptionTime - Time millisecondClockValue; nextPutAll: ' msecs remaining'.	].	aStream nextPutAll: ')'.! !!DelayWaitTimeout methodsFor: 'waiting' stamp: 'ar 3/27/2009 22:26'!wait	"Wait until either the semaphore is signaled or the delay times out"	[self schedule.	"It is critical that the following has no suspension point so that	the test and the wait primitive are atomic. In addition, if the delay	is no longer being waited on while entering the way we know that it 	is expired because the delay has already fired."	beingWaitedOn 		ifTrue:[delaySemaphore wait]		ifFalse:[expired := true]] ensure:[self unschedule].	^self isExpired! !!CompiledMethod methodsFor: 'printing' stamp: 'eem 1/19/2009 10:28'!primitiveErrorVariableName	"Answer the primitive error code temp name, or nil if none."	self primitive > 0 ifTrue:		[self pragmas do:			[:pragma| | kwds ecIndex |			((kwds := pragma keyword keywords) first = 'primitive:'			and: [(ecIndex := kwds indexOf: 'error:') > 0]) ifTrue:				[^pragma argumentAt: ecIndex]]].	^nil! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 11/29/2008 18:36'!keysAndValuesDo: aBlock	"Enumerate the receiver with all the keys and values."	1 to: self basicSize do: [:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) isVariableBinding			ifTrue: [aBlock value: propertyOrPragma key value: propertyOrPragma value]			ifFalse: [aBlock value: propertyOrPragma keyword value: propertyOrPragma]]! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 12/1/2008 10:56'!at: aKey put: aValue	"Replace the property value or pragma associated with aKey."		1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value: aValue]				ifFalse: [self basicAt: i put: aValue]]].	^method propertyValueAt: aKey put: aValue! !!DelayWaitTimeout methodsFor: 'testing' stamp: 'ar 3/23/2009 16:37'!isExpired	"Did this timeout fire before the associated semaphore was signaled?"	^expired! !!Delay class methodsFor: 'snapshotting' stamp: 'ar 3/2/2009 14:44'!startUp	"Restart active delay, if any, when resuming a snapshot."	DelaySuspended ifFalse:[^self error: 'Trying to activate Delay twice'].	DelaySuspended := false.	self restoreResumptionTimes.	AccessProtect signal.! !!Delay class methodsFor: 'timer process' stamp: 'ar 3/2/2009 14:40'!runTimerEventLoop	"Run the timer event loop."	[RunTimerEventLoop] whileTrue: [self handleTimerEvent]! !!AdditionalMethodState methodsFor: 'properties' stamp: 'lr 2/6/2006 20:48'!removeKey: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeKey: aKey ifAbsent: [ self error: 'Property not found' ].! !!MethodProperties methodsFor: 'properties' stamp: 'eem 12/1/2008 17:49'!propertyValueAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."	^self at: aKey ifAbsent: aBlock! !!CompiledMethod methodsFor: 'private' stamp: 'eem 11/29/2008 11:10'!penultimateLiteral	"Answer the penultimate literal of the receiver, which holds either	 the receiver's selector or its properties (which will hold the selector)."	| pIndex |	^(pIndex := self numLiterals - 1) > 0 		ifTrue: [self literalAt: pIndex]		ifFalse: [nil]! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 8/20/2009 11:42'!flag	"Answer the user-level flag bit"	^((self header bitShift: -29) bitAnd: 1) = 1! !!ProtoObject methodsFor: 'debugging' stamp: 'eem 4/8/2009 19:10'!withArgs: argArray executeMethod: compiledMethod	"Execute compiledMethod against the receiver and args in argArray"	<primitive: 188>	self primitiveFailed! !!Delay methodsFor: 'private' stamp: 'ar 3/2/2009 14:42'!unschedule	AccessProtect critical:[		FinishedDelay := self.		TimingSemaphore signal.	].! !!ContextPart methodsFor: 'query' stamp: 'eem 12/31/2008 11:28'!isBottomContext	"Answer if this is the last context (the first context invoked) in my sender chain"	^sender isNil! !!Delay class methodsFor: 'snapshotting' stamp: 'ar 3/2/2009 14:44'!restoreResumptionTimes	"Private!! Restore the resumption times of all scheduled Delays after a snapshot or clock roll-over. This method should be called only while the AccessProtect semaphore is held."	| newBaseTime |	newBaseTime := Time millisecondClockValue.	SuspendedDelays do: [:d | d adjustResumptionTimeOldBase: 0 newBase: newBaseTime].	ActiveDelay == nil ifFalse: [		ActiveDelay adjustResumptionTimeOldBase: 0 newBase: newBaseTime.	].! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'eem 12/1/2008 10:55'!at: aKey ifAbsent: aBlock	"Answer the property value or pragma associated with aKey or,	 if aKey isn't found, answer the result of evaluating aBlock."	1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue:			[^propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value]				ifFalse: [propertyOrPragma]]].	^aBlock value! !!Duration class methodsFor: 'squeak protocol' stamp: 'tfel 9/1/2009 22:29'!readFrom: aStream	"Formatted as per ANSI 5.8.2.16: [-]D:HH:MM:SS[.S]"	| sign days hours minutes seconds nanos nanosBuffer |	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	days := (aStream upTo: $:) asInteger sign: sign.	hours := (aStream upTo: $:) asInteger sign: sign.	minutes := (aStream upTo: $:) asInteger sign: sign.	seconds := (aStream upTo: $.) asInteger sign: sign.	nanosBuffer := '000000000' copy.	nanos := WriteStream on: nanosBuffer.	[aStream atEnd not and: [aStream peek isDigit]]		whileTrue: [nanos nextPut: aStream next].			^ self 		days: days 		hours: hours 		minutes: minutes 		seconds: seconds 		nanoSeconds: (nanosBuffer asInteger sign: sign)	"	'0:00:00:00' asDuration		'0:00:00:00.000000001' asDuration		'0:00:00:00.999999999' asDuration		'0:00:00:00.100000000' asDuration		'0:00:00:00.001 ' asDuration		'0:00:00:00.1' asDuration		'0:00:00:01 ' asDuration		'0:12:45:45' asDuration		'1:00:00:00' asDuration		'365:00:00:00' asDuration		'-7:09:12:06.10' asDuration		'+0:01:02:3' asDuration 	"! !!CompiledMethod methodsFor: 'debugger support' stamp: 'eem 6/30/2009 12:37'!blockExtentsToTempsMap	"If the receiver has been copied with temp names answer a	 map from blockExtent to temps map in the same format as	 BytecodeEncoder>>blockExtentsToTempNamesMap.  if the	 receiver has not been copied with temps answer nil."	^self holdsTempNames ifTrue:		[self mapFromBlockKeys: ((self startpcsToBlockExtents associations asSortedCollection:										[:a1 :a2| a1 key < a2 key]) collect:									[:assoc| assoc value])			toSchematicTemps: self tempNamesString]! !!MethodProperties methodsFor: 'testing' stamp: 'eem 11/29/2008 13:48'!isEmpty	^(properties isNil or: [properties isEmpty])	   and: [pragmas isNil or: [pragmas isEmpty]]! !!Pragma methodsFor: 'accessing-pragma' stamp: 'lr 1/19/2006 20:54'!arguments	"Answer the arguments of the receiving pragma. For a pragma defined as <key1: val1 key2: val2> this will answer #(val1 val2)."		^ arguments! !!Categorizer class methodsFor: 'class initialization' stamp: 'eem 1/7/2009 16:04'!allCategory	"Return a symbol that represents the virtual all methods category."	^#'-- all --'! !!CompiledMethod methodsFor: 'accessing' stamp: 'eem 11/29/2008 17:23'!properties: aMethodProperties	"Set the method-properties of the receiver to aMethodProperties."	self literalAt: self numLiterals - 1		put: (aMethodProperties isEmpty				ifTrue: [aMethodProperties selector]				ifFalse: [aMethodProperties							setMethod: self;							yourself])! !Delay class removeSelector: #guardianDelay!Delay removeSelector: #beGuardianDelay!Delay removeSelector: #activate!Process removeSelector: #primitiveSuspend!Delay class removeSelector: #timerInterruptWatcher!Delay class removeSelector: #startTimerInterruptWatcher!Delay class removeSelector: #stopTimerInterruptWatcher!Delay initialize!