"Change Set:		9529ShoutCore-kb.11ShoutCore-kb.11:Adapted monticello's snapshot and patch browser shout styling from ShoutMonticello.1-tween.2ShoutCore-kb.10:Adapted monticello's snapshot and patch browser shout styling from ShoutMonticello.1-tween.2"!Object subclass: #SHMCClassDefinition	instanceVariableNames: 'classDefinition items meta'	classVariableNames: ''	poolDictionaries: ''	category: 'ShoutCore-Monticello'!!MCSnapshotBrowser methodsFor: '*ShoutCore' stamp: 'kb 2/26/2010 14:59'!hasBindingThatBeginsWith: aString	^false! !!SHMCClassDefinition methodsFor: 'act like environment' stamp: 'tween 5/9/2004 12:27'!bindingOf: aSymbol	| binding |	(binding := Smalltalk bindingOf: aSymbol)		ifNotNil: [^binding].	items do:[:each |		(each isClassDefinition and: [each className = aSymbol])			ifTrue:[^aSymbol -> each]].	^nil! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'tween 5/1/2004 12:17'!classPool	| d |	d := Dictionary new.	classDefinition classVarNames do:[:each |		d at: each put: nil].	^d! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'tween 5/1/2004 12:20'!sharedPools	| d |	d := Set new.	classDefinition poolDictionaries do:[:each |		d add: [Smalltalk at: each asSymbol ifAbsent:[nil]] ].	^d! !!SHMCClassDefinition methodsFor: 'accessing' stamp: 'tween 5/1/2004 11:37'!items: anObject	items := anObject! !!MCSnapshotBrowser methodsFor: '*ShoutCore' stamp: 'kb 2/26/2010 15:00'!bindingOf: aSymbol	(Smalltalk bindingOf: aSymbol) ifNotNil: [ :binding | ^binding ].	items do: [ :each |		(each isClassDefinition and: [			each className = aSymbol ]) ifTrue: [ ^aSymbol -> each ] ].	^nil! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'tween 5/9/2004 12:21'!environment	^self! !!MCSnapshotBrowser methodsFor: '*ShoutCore' stamp: 'kb 2/26/2010 15:36'!aboutToStyle: aStyler		| classDefinition shouldStyle |	classSelection ifNil: [ ^false ].	self switchIsComment ifTrue: [ ^false ].	methodSelection 		ifNotNil: [ 			classDefinition := items 				detect: [:ea | 					ea isClassDefinition and: [ ea className = classSelection ] ]				ifNone: [ 					(Smalltalk at: classSelection ifAbsent: [ Object ]) asClassDefinition ].			shouldStyle := true ]		ifNil: [ 			classDefinition := nil.			shouldStyle := categorySelection ~= self extensionsCategory ].	aStyler 		environment: self;		classOrMetaClass: (classDefinition ifNotNil: [			SHMCClassDefinition 				classDefinition: classDefinition 				items: items 				meta: switch = #class ]).	^shouldStyle! !!SHMCClassDefinition methodsFor: 'accessing' stamp: 'tween 5/1/2004 11:38'!classDefinition: aMCClassDefinition	classDefinition := aMCClassDefinition! !!SHMCClassDefinition methodsFor: 'accessing' stamp: 'tween 5/1/2004 12:35'!allInstVarNames	| superclassOrDef answer classOrDef instVars|		answer := meta		ifTrue:[classDefinition classInstVarNames asArray]		ifFalse:[	classDefinition instVarNames asArray].	classOrDef := classDefinition.	[superclassOrDef := (classOrDef isKindOf: MCClassDefinition)		ifTrue:[ |s|			s := classOrDef superclassName.			items 				detect: [:ea | ea isClassDefinition and: [ea className = s]]				ifNone: [Smalltalk at: s asSymbol ifAbsent:[nil]]]		ifFalse:[ | sc |			sc := classOrDef superclass.			sc ifNotNil:[				items 					detect: [:ea | ea isClassDefinition and: [ea className = sc name asString]]					ifNone: [sc]	]].	superclassOrDef isNil	] whileFalse:[		instVars := (superclassOrDef isKindOf: MCClassDefinition)			ifTrue:[				meta 					ifTrue:[superclassOrDef classInstVarNames]					ifFalse:[superclassOrDef instVarNames]]			ifFalse:["real"				meta					ifTrue:[superclassOrDef theNonMetaClass class  instVarNames]					ifFalse:[superclassOrDef theNonMetaClass instVarNames]].				answer := answer, instVars.		classOrDef := superclassOrDef].	^answer! !!SHMCClassDefinition class methodsFor: 'as yet unclassified' stamp: 'tween 5/1/2004 12:27'!classDefinition: aMCClassDefinition items: anObject meta: aBoolean	^self new		classDefinition: aMCClassDefinition;		items: anObject;		meta: aBoolean;		yourself! !!SHMCClassDefinition methodsFor: 'accessing' stamp: 'kb 2/26/2010 14:38'!shoutParserClass	"Answer the parser class"	^SHParserST80! !!MCPatchBrowser methodsFor: '*ShoutCore' stamp: 'kb 2/26/2010 15:24'!aboutToStyle: aStyler 		selection ifNotNil: [		selection isConflict ifTrue: [ ^false ].		(selection isAddition or: [ selection isRemoval ]) ifTrue: [			selection definition isOrganizationDefinition ifTrue: [ ^false ].				aStyler classOrMetaClass: self selectedClassOrMetaClass.				^true ] ].	^false! !!SHMCClassDefinition methodsFor: 'accessing' stamp: 'tween 5/1/2004 12:13'!withAllSuperclasses	| superclassOrDef answer classOrDef |		answer := Array with: self.	classOrDef := classDefinition.	[superclassOrDef := (classOrDef isKindOf: MCClassDefinition)		ifTrue:[ |s|			s := classOrDef superclassName.			items 				detect: [:ea | ea isClassDefinition and: [ea className = s]]				ifNone: [Smalltalk at: s asSymbol ifAbsent:[nil]]]		ifFalse:[ | sc |			sc := classOrDef superclass.			sc ifNotNil:[				items 					detect: [:ea | ea isClassDefinition and: [ea className = sc name asString]]					ifNone: [sc]	]].	superclassOrDef isNil	] whileFalse:[		answer := answer, (Array with: superclassOrDef).		classOrDef := superclassOrDef].	^answer! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'tween 5/1/2004 12:28'!theNonMetaClass	^self copy meta: false; yourself! !!SHMCClassDefinition methodsFor: 'act like environment' stamp: 'tween 5/9/2004 12:38'!hasBindingThatBeginsWith: aString	(Smalltalk hasBindingThatBeginsWith: aString) ifTrue: [^true].	items do:[:each |		(each isClassDefinition and: [each className beginsWith: aString])			ifTrue:[^true]].	^false! !!SHMCClassDefinition methodsFor: 'accessing' stamp: 'tween 5/1/2004 12:26'!meta: aBoolean	meta := aBoolean! !