"Change Set:		7379MonticelloConfigurations-ar.58MonticelloConfigurations-ar.58:Fixes an interesting issue in the MCM updater. Apparently, #allAncestorsDo: can loop indefinitely. Use ancestorsDoWhileTrue: instead and keep track of the versions that we've seen already to avoid this problem.MonticelloConfigurations-ar.55:Progress while loading configurations.MonticelloConfigurations-ar.56:Optimizes updateFromRepositories so that we do not need to download new versions if the this version is already loaded in the image in question. This greatly simplifies the update process.MonticelloConfigurations-ar.57:UIManagerization. Replaces all the trivial references to PopUpMenu, SelectionMenu, CustomMenu, and FillInTheBlank."!!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 20:41'!pickName	| name |	name := UIManager default		request: 'Name (.', self configuration writerClass extension, ' will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	^ name isEmpty ifFalse: [name]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 20:41'!pickWorkingCopiesSatisfying: aBlock	| copies item |	copies := (MCWorkingCopy allManagers select: aBlock)		asSortedCollection: [:a :b | a packageName <= b packageName].	item := UIManager default chooseFrom: #('match ...'),(copies collect: [:ea | ea packageName]) lines: #(1) title: 'Package:'.	item = 1 ifTrue: [		| pattern |		pattern := UIManager default request: 'Packages matching:' initialAnswer: '*'.		^pattern isEmptyOrNil			ifTrue: [#()]			ifFalse: [				(pattern includes: $*) ifFalse: [pattern := '*', pattern, '*'].				copies select: [:ea | pattern match: ea packageName]]	].	^ item = 0		ifTrue: [#()]		ifFalse: [{copies at: item - 1}]! !!MCConfiguration methodsFor: 'updating' stamp: 'ar 7/31/2009 20:13'!updateFromRepositories	| oldInfos newNames sortedNames newDeps |	oldInfos := self dependencies collect: [:dep | dep versionInfo].	newNames := Dictionary new.	self repositories		do: [:repo | 			ProgressNotification signal: '' extra: 'Checking ', repo description.			(repo possiblyNewerVersionsOfAnyOf: oldInfos)				do: [:newName | newNames at: newName put: repo]]		displayingProgress: 'Searching new versions'.	sortedNames := newNames keys asSortedCollection:		[:a :b | a numericSuffix > b numericSuffix].	newDeps := OrderedCollection new.	self dependencies do: [:dep |		| newName |		newName := sortedNames			detect: [:each | (each copyUpToLast: $-) = dep package name]			ifNone: [nil].		newDeps add: (newName			ifNil: [dep]			ifNotNil: [				| repo info  |				repo := newNames at: newName.				info := self versionInfoNamed: newName for: dep from: repo.				info ifNil: [dep]					ifNotNil: [MCVersionDependency package: dep package info: info]			])	] displayingProgress: 'downloading new versions'.	self dependencies: newDeps.! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'ar 8/6/2009 18:23'!pickRepositorySatisfying: aBlock	| index list |	list := MCRepositoryGroup default repositories select: aBlock.	index := UIManager default chooseFrom: (list collect: [:ea | ea description])		title: 'Repository:'.	^ index = 0 ifFalse: [list at: index]! !!MCConfiguration methodsFor: 'private' stamp: 'ar 8/6/2009 21:48'!versionInfoNamed: newName for: dep from: repo	"Retrieves the version info instead of the version. Searches in-image first, in case the desired version is part of an already loaded package (usual case when doing a partial update). If not present defaults to versionNamed:for:from: an uses its result."	MCWorkingCopy registry at: dep package ifPresent:[:workingCopy| | seen |		"Don't use allAncestorsDo: - apparently this can loop indefinitely.		Rather keep track of the versions that we've seen and make sure we don't loop."		seen := Set new.		workingCopy ancestry ancestorsDoWhileTrue:[:vInfo|			vInfo name = newName ifTrue:[^vInfo].			(seen includes: vInfo) ifTrue:[false] ifFalse:[seen add: vInfo. false]		].	].	^(self versionNamed: newName for: dep from: repo) info! !!MCConfigurationBrowser methodsFor: 'actions' stamp: 'ar 8/6/2009 20:41'!post	"Take the current configuration and post an update"	| name update managers names choice |	(self checkRepositories and: [self checkDependencies]) ifFalse: [^self].	name := UIManager default		request: 'Update name (.cs) will be appended):'		initialAnswer: (self configuration name ifNil: ['']).	name isEmpty ifTrue:[^self].	self configuration name: name.	update := MCPseudoFileStream on: (String new: 100).	update localName: name, '.cs'.	update nextPutAll: '"Change Set:		', name.	update cr; nextPutAll: 'Date:			', Date today printString.	update cr; nextPutAll: 'Author:			Posted by Monticello'.	update cr; cr; nextPutAll: 'This is a configuration map created by Monticello."'.	update cr; cr; nextPutAll: '(MCConfiguration fromArray: #'.	self configuration fileOutOn: update.	update nextPutAll: ') upgrade.'.	update position: 0.	managers := Smalltalk at: #UpdateManager ifPresent:[:mgr| mgr allRegisteredManagers].	managers ifNil:[managers := #()].	managers size > 0 ifTrue:[		| servers index |		servers := ServerDirectory groupNames asSortedArray.		names := (managers collect:[:each| each packageVersion]), servers.		index := UIManager default chooseFrom: names lines: {managers size}.		index = 0 ifTrue:[^self].		index <= managers size ifTrue:[			| mgr |			mgr := managers at: index.			^mgr publishUpdate: update.		].		choice := names at: index.	] ifFalse:[		names := ServerDirectory groupNames asSortedArray.		choice := UIManager default chooseFrom: names values: names.		choice == nil ifTrue: [^ self].	].	(ServerDirectory serverInGroupNamed: choice) putUpdate: update.! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'ar 7/21/2009 19:50'!updateFromRepositories: repositoryUrls	"MCMcmUpdater updateFromRepositories: #(		'http://squeaksource.com/MCUpdateTest'	)"	| repos updateList parts base author version type config |	Preferences enable: #upgradeIsMerge.	"The list of repositories to consult in order"	repos := repositoryUrls collect:[:url| 		MCRepositoryGroup default repositories 			detect:[:r| r description = url]			ifNone:[ | r |				r := MCHttpRepository location: url user: '' password: ''.				MCRepositoryGroup default addRepository: r.				r]].	"The list of updates-author.version.mcm sorted by version"	repos do:[:r|		updateList := SortedCollection new.		"Find all the updates-author.version.mcm files"		r allFileNames do:[:versionedName|			parts := versionedName findTokens: '.-'.			parts size = 4 ifTrue:[				base := parts at: 1.				author := parts at: 2.				version := [(parts at: 3) asNumber] on: Error do:[:ex| ex return: 0].				type := parts at: 4.			].			(base = 'update' and:[version > 0 and:[type = 'mcm']]) 				ifTrue:[updateList add: version -> versionedName]].				"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				ProgressNotification signal: '' extra: 'Processing ', assoc value.				config := r versionFromFileNamed: assoc value.				(config dependencies allSatisfy:[:dep| dep isFulfilled]) 					ifFalse:[config upgrade].			] displayingProgress: 'Processing configurations'.			"We've loaded all the provided update configurations.			Use the latest configuration to update all the remaining packages."			config updateFromRepositories.			config upgrade.		].	].! !