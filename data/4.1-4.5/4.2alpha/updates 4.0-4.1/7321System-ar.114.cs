"Change Set:		7321System-ar.114System-ar.114:Closure compiler, main part."!!ImageSegment methodsFor: 'fileIn/Out' stamp: 'eem 7/21/2008 12:09'!storeDataOn: aDataStream	"Don't wrote the array of Roots.  Also remember the structures of the classes of objects inside the segment."	| tempRoots tempOutP list |	state = #activeCopy ifFalse: [self error: 'wrong state'].		"real state is activeCopy, but we changed it will be right when coming in"	tempRoots := arrayOfRoots.	tempOutP := outPointers.	outPointers := outPointers clone.	self prepareToBeSaved.	arrayOfRoots := nil.	state := #imported.	super storeDataOn: aDataStream.		"record my inst vars"	arrayOfRoots := tempRoots.	outPointers := tempOutP.	state := #activeCopy.	aDataStream references at: #AnImageSegment put: false.	"the false is meaningless"		"This key in refs is the flag that there is an ImageSegment in this file."	"Find the receivers of blocks in the segment.  Need to get the structure of their classes into structures.  Put the receivers into references."	(aDataStream byteStream isKindOf: DummyStream) ifTrue: [		list := Set new.		arrayOfRoots do: [:ea | 			ea isBlock | (ea class == MethodContext) ifTrue: [ 				list add: ea receiver class ]].		aDataStream references at: #BlockReceiverClasses put: list].! !!Preferences class methodsFor: 'standard queries' stamp: ''!allowUnderscoreAssignment	^ self		valueOfFlag: #allowUnderscoreAssignment		ifAbsent: [false]! !!MessageTally methodsFor: 'initialize-release' stamp: 'eem 7/21/2008 12:09'!spyEvery: millisecs on: aBlock 	"Create a spy and spy on the given block at the specified rate."	| myDelay startTime time0 |	aBlock isBlock		ifTrue: [self class: aBlock receiver class method: aBlock method]		ifFalse: [self class: aBlock class method: aBlock method].		"set up the probe"	ObservedProcess := Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer :=		[[true] whileTrue: 			[startTime := Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor userInterruptPriority.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure:		["Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo:			[:idx :gcVal| gcStats at: idx put: (gcVal - (gcStats at: idx))].		"cancel the probe and return the value"		Timer terminate.		time := Time millisecondClockValue - time0]! !!Utilities class methodsFor: 'closure support' stamp: 'ar 7/13/2009 21:10'!postRecompileCleanup	"Utilities postRecompileCleanup"	"Cleanup after loading closure bootstrap"	| unboundMethods contexts |	ProcessorScheduler startUp.	WeakArray restartFinalizationProcess.	MethodChangeRecord allInstancesDo:[:x| x noteNewMethod: nil].	Undeclared removeUnreferencedKeys.	Delay startTimerEventLoop.	EventSensor install.	WorldState allInstancesDo:[:ws| ws convertAlarms; convertStepList].	(Workspace canUnderstand: #initializeBindings) 		ifTrue:[Workspace allInstancesDo:[:ws| ws initializeBindings]].	ExternalDropHandler initialize.	ScrollBar initializeImagesCache.	Vocabulary initialize.	Smalltalk garbageCollect.	GradientFillStyle initPixelRampCache.	Smalltalk at: #ServiceGui ifPresent:[:sg| sg initialize].	Smalltalk		at: #SokobanMorph		ifPresent: [:sm| sm initFields].	Smalltalk		at: #DebuggerMethodMap		ifPresent: [:dmm| dmm voidMapCache].	Smalltalk		at: #KClipboard		ifPresent: [:kcb| kcb clearDefault].	Smalltalk		at: #ServiceRegistry		ifPresent: [:sr| sr rebuild].	(ProcessBrowser respondsTo: #registerWellKnownProcesses) ifTrue:		[ProcessBrowser registerWellKnownProcesses].	Smalltalk		at: #DebuggerMethodMap		ifPresent: [:dmm| dmm voidMapCache].	Smalltalk at: #ServiceRegistry ifPresent:[:cls| cls rebuild].	Smalltalk forgetDoIts.	Smalltalk garbageCollect.	unboundMethods := CompiledMethod allInstances select:[:m|		m methodClass isNil or: [m ~~ (m methodClass compiledMethodAt: m selector ifAbsent: nil)]].	unboundMethods := unboundMethods reject:[:m| m selector isDoIt].	unboundMethods notEmpty ifTrue:		[(ToolSet inspect: unboundMethods) setLabel: 'Unbound Methods'].	contexts := BlockContext allInstances.	contexts ifNotEmpty:[contexts inspect. self inform: 'There are left-over BlockContexts'].	(unboundMethods isEmpty and:[contexts isEmpty]) ifTrue:[		self inform:'Congratulations - The bootstrap is now complete.'.	].! !!Preferences class methodsFor: 'standard queries' stamp: ''!allowBlockArgumentAssignment	^ self		valueOfFlag: #allowBlockArgumentAssignment		ifAbsent: [false]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'eem 7/21/2008 12:10'!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object sets receiverClasses inSeg |	object := segment.	sets := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	inSeg := true.	[object := object nextObject.  		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: Set) ifTrue: [sets add: object].			object isBlock ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	sets do: [:each | each rehash].	"our purpose"	^ receiverClasses	"our secondary job"! !!SystemDictionary methodsFor: 'special objects' stamp: 'eem 7/22/2008 18:37'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used	by the	Squeak virtual machine. Its contents are critical and	unchecked, so don't even think of playing here unless you	know what you are doing."	| newArray |	newArray := Array new: 50.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	"array of objects referred to by external code"	newArray at: 40 put: PseudoContext.	newArray at: 41 put: TranslatedMethod.	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!Utilities class methodsFor: 'closure support' stamp: 'ar 7/14/2009 22:09'!initializeClosures	"Utilities initializeClosures"	"Eliminate the prototype BlockContext from the specialObjectsArray.  The VM doesn't use it. This paves the way for removing BlockCOntext altogether and merging ContextPart and MethodContext into e.g. Context."	(Smalltalk specialObjectsArray at: 38) class == BlockContext 		ifTrue:[Smalltalk specialObjectsArray at: 38 put: nil].	"Remove unused class vars from CompiledMethod since we can't redefine its class definition directly. Add the new BlockClosure to the specialObjectsArray"	(#(	BlockNodeCache MethodProperties SpecialConstants) 			intersection: CompiledMethod classPool keys) 				do:[:classVarName| CompiledMethod removeClassVarName: classVarName].	Smalltalk recreateSpecialObjectsArray.	"Recompile methods in ContextPart, superclasses and subclasses that access inst vars"	ContextPart withAllSuperclasses, ContextPart allSubclasses asArray do:[:class|		class instSize > 0 ifTrue:[			class allInstVarNames do:[:ivn|				(class whichSelectorsAccess: ivn) do:[:sel| class recompile: sel]]]]! !!ImageSegment methodsFor: 'read/write segment' stamp: 'eem 7/21/2008 14:18'!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder dummy replacements naughtyBlocks goodToGo allClasses sizeHint proj |	Smalltalk forgetDoIts.	"self halt."	symbolHolder := Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	(proj :=dummy project) ifNotNil: [self dependentsSave: dummy].	allClasses := SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	allClasses do: [:cls | 		dummy references at: cls class put: false.	"put Player5 class in roots"		dummy blockers removeKey: cls class ifAbsent: []].	"refs := dummy references."	arrayOfRoots := self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements := dummy blockers.	dummy project "recompute it" ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy := nil.	"force GC?"	naughtyBlocks := arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	"since the caller switched ActiveWorld, put the real one back temporarily"	naughtyBlocks isEmpty ifFalse: [		World becomeActiveDuring: [			goodToGo := (UIManager default				chooseFrom: #('keep going' 'stop and take a look')				title:'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?') == 1.			goodToGo ifFalse: [				naughtyBlocks inspect.				self error: 'Here are the bad blocks'].		].	].	"Creation of the segment happens here"	"try using one-quarter of memory min: four megs to publish (will get bumped later)"	sizeHint := (Smalltalk garbageCollect // 4 // 4) min: 1024*1024.	self copyFromRoots: arrayOfRoots sizeHint: sizeHint areUnique: true.	segSize := segment size.	[(newRoots := self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots := self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list := self compactClassesArray.	outPointers := outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) isBlock ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	proj ifNotNil: [self dependentsCancel: proj].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'eem 7/21/2008 12:10'!copyFromRootsForExport: rootArray 	"When possible, use copySmartRootsExport:.  This way may not copy a complete tree of objects.  Add to roots: all of the methods pointed to from the outside by blocks."	| newRoots list segSize symbolHolder |	arrayOfRoots := rootArray.	Smalltalk forgetDoIts.	"self halt."	symbolHolder := Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	(newRoots := self rootsIncludingPlayers) ifNotNil: [		arrayOfRoots := newRoots].		"world, presenter, and all Player classes"	"Creation of the segment happens here"	self copyFromRoots: arrayOfRoots sizeHint: 0.	segSize := segment size.	[(newRoots := self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods pointed at from outside"	[(newRoots := self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize].		"with methods, blocks from outPointers"	"classes of receivers of blocks"	list := self compactClassesArray.	outPointers := outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	"Zap sender of a homeContext. Can't send live stacks out."	1 to: outPointers size do: [:ii | 		(outPointers at: ii) isBlock ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil]].	symbolHolder.! !!ImageSegment methodsFor: 'read/write segment' stamp: 'eem 7/21/2008 12:11'!rootsIncludingBlocks	"For export segments only.  Return a new roots array with more objects.  (Caller should store into rootArray.)  Collect Blocks and external methods pointed to by them.  Put them into the roots list.  Then ask for the segment again."	| extras have |	userRootCnt ifNil: [userRootCnt := arrayOfRoots size].	extras := OrderedCollection new.	outPointers do: [:anOut | 		anOut class == CompiledMethod ifTrue: [extras add: anOut].		(anOut isBlock) ifTrue: [extras add: anOut].		(anOut class == MethodContext) ifTrue: [extras add: anOut].		anOut := nil].	"don't hang onto it"	[have := extras size.	 extras copy do: [:anOut |		anOut isBlock ifTrue: [			anOut home ifNotNil: [				(extras includes: anOut home) ifFalse: [extras add: anOut home]]].		(anOut class == MethodContext) ifTrue: [			anOut method ifNotNil: [				(extras includes: anOut method) ifFalse: [extras add: anOut method]]]].	 have = extras size] whileFalse.	extras := extras select: [:ea | (arrayOfRoots includes: ea) not].	extras isEmpty ifTrue: [^ nil].	"no change"	^ arrayOfRoots, extras! !!Utilities class methodsFor: 'closure support' stamp: 'ar 7/15/2009 22:27'!compileUsingClosures	"Utilities compileUsingClosures"	"Recompile the system and do some minimal clean-ups"	| classes compilationErrors |	Preferences setPreference: #allowBlockArgumentAssignment toValue: true.	compilationErrors := Set new.	classes := Smalltalk forgetDoIts allClasses reject: [:c| c name == #GeniePlugin].	'Recompiling The System' displayProgressAt: Sensor cursorPoint		from: 0 to: classes size during:[:bar |			classes withIndexDo:[:c :i|				bar value: i.				{ c. c class } do:[:b|					"Transcript cr; print: b; endEntry."					b selectors "asSortedCollection" do:[:s| 						"Transcript cr; show: b asString, '>>', s."						[b recompile: s from: b] on: Error do:[:ex|							Transcript								cr; nextPutAll: 'COMPILATION ERROR: ';								print: b; nextPutAll: '>>'; nextPutAll: s; flush.							compilationErrors add: (MethodReference class: b selector: s)]]]]].	(Smalltalk respondsTo: #allTraits) ifTrue:[		'Recompiling Traits' displayProgressAt: Sensor cursorPoint		from: 0 to: Smalltalk allTraits size during:[:bar |			Smalltalk allTraits do:[:t|				t selectors do:[:s|					[t recompile: s] on: Error do:[:ex|							Transcript								cr; nextPutAll: 'COMPILATION ERROR: ';								print: t; nextPutAll: '>>'; nextPutAll: s; flush.							compilationErrors add: (MethodReference class: t selector: s)]]]]].	compilationErrors notEmpty ifTrue:[		SystemNavigation default			browseMessageList: compilationErrors asSortedCollection			name: 'Compilation Errors'].! !