"Change Set:		8581Morphic-nice.275Morphic-nice.275:#assertSlopesWith:from:to: did return selfI did not dare removing it though http://bugs.squeak.org/view.php?id=6698 recommandationsMorphic-nice.273:Simplify #lines and handle eventual crlf pairs correctly(Old code did assume there was a single separator using index := index + 1)Morphic-nice.274:Cosmetic changes1) let #preserveStateDuring: always return the result of evaluating the block argument.2) suppress a useless block argument assignment."!!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'nice 12/26/2009 21:56'!deletePrivateGraphics: nameList afterStoringToFileNamed: aFileName	"This method is used to strip private graphics from the FormDictionary and store them on a file of the given name"	| replacement toRemove aReferenceStream |	toRemove := Dictionary new.	replacement := FormDictionary at: #Gets.	nameList do:		[:aKey |			| keySymbol |			keySymbol := aKey asSymbol.			(toRemove at: keySymbol put: (self formAtKey: keySymbol)).			FormDictionary at: keySymbol put: replacement].	aReferenceStream := ReferenceStream fileNamed: aFileName.	aReferenceStream nextPut: toRemove.	aReferenceStream close! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'nice 12/26/2009 21:21'!nilTransitions	"Return an OrderedCollection of transition indexes.  	Indexes represent where the list elements transitions 	from nil to nonNil 		or from nonNil to nil.	1 is an index in the list iff the first element is nonNil. "		| changes nilSkip |	changes := OrderedCollection new.	nilSkip := true .		1 to: self size		do: [:i | (self atWrap: i) isNil == nilSkip				ifFalse: [changes add: i.					nilSkip := nilSkip not]].	^ changes ! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 01:21'!backgroundWorldDisplay	self flag: #bob.		"really need a better way to do this"			"World displayWorldSafely."	"ugliness to try to track down a possible error"	[World displayWorld] ifError: [ :a :b |		| f |		stageCompleted := 999.		f := FileDirectory default fileNamed: 'bob.errors'.		f nextPutAll: a printString,'  ',b printString; cr; cr.		f nextPutAll: 'worlds equal ',(formerWorld == World) printString; cr; cr.		f nextPutAll: thisContext longStack; cr; cr.		f nextPutAll: formerProcess suspendedContext longStack; cr; cr.		f close. Beeper beep.	].! !!PolygonMorph methodsFor: 'editing' stamp: 'nice 12/26/2009 19:18'!addHandles	"Put moving handles at the vertices. Put adding handles at	edge midpoints.	Moving over adjacent vertex and dropping will delete a	vertex. "	| tri |	self removeHandles.	handles := OrderedCollection new.	tri := Array				with: 0 @ -4				with: 4 @ 3				with: -3 @ 3.	vertices		withIndexDo: [:vertPt :vertIndex | 			| handle |			handle := EllipseMorph						newBounds: (Rectangle center: vertPt extent: 8 @ 8)						color: (self handleColorAt: vertIndex) .			handle				on: #mouseMove				send: #dragVertex:event:fromHandle:				to: self				withValue: vertIndex.			handle				on: #mouseUp				send: #dropVertex:event:fromHandle:				to: self				withValue: vertIndex.				handle				on: #click				send: #clickVertex:event:fromHandle:				to: self				withValue: vertIndex.			self addMorph: handle.			handles addLast: handle.			(closed					or: [1 = vertices size						"Give a small polygon a chance to grow. 						-wiz"]					or: [vertIndex < vertices size])				ifTrue: [| newVert |					newVert := PolygonMorph								vertices: (tri										collect: [:p | p + (vertPt													+ (vertices atWrap: vertIndex + 1) // 2)])								color: Color green								borderWidth: 1								borderColor: Color black.					newVert						on: #mouseDown						send: #newVertex:event:fromHandle:						to: self						withValue: vertIndex.					self addMorph: newVert.					handles addLast: newVert]].	self isCurvy		ifTrue: [self updateHandles; layoutChanged].	self changed! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'nice 12/26/2009 21:15'!assertSlopesWith: knots from: start to: end   "	We trust everything has been checked. 	The following assertions should hold at this point: "		self assert: [ self size = knots size ] . 	"Sizes must be consistent." 	self assert: [ end > start]. 	"There must be at least one slope to clamp." 	self assert: [ 0 < start and: [start <= knots size] ]. 	"The clamped slope may be the last one."	self assert: [  end  <= knots size + start ] . 	"We can wrap. There may be only one known slope."	"xxx self assert: [ end = knots size + start ifTrue: [ (self at: start) notNil ] ] . xxx"		"xxx If we overlap slope must be known. xxx"	{ start . end } 		do: [ :index |			| slope |			slope := (self at: index ).			self assert: [ slope isNil 				or: [ slope isNumber 				or: [ slope isPoint ] ] ] ] . 	"And a known and reasonalble value or nil." 	^true 	! !!WorldState methodsFor: 'initialization' stamp: 'nice 12/26/2009 22:28'!stepListSortBlock	"Please pardon the hackery below. Since the block provided by this method is retained elsewhere, it is possible that the block argument variables would retain references to objects that were no longer really needed. In one case, this feature resulted in doubling the size of a published project."	^[ :stepMsg1 :stepMsg2 | 		| answer |		answer := stepMsg1 scheduledTime <= stepMsg2 scheduledTime.		stepMsg1 := stepMsg2 := nil.		answer	]! !!TextEditor methodsFor: 'undoers' stamp: 'nice 12/26/2009 22:58'!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize := (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText := self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i |		| index subject |		index := indices at: i.		(subject := index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!Editor methodsFor: 'private' stamp: 'nice 12/25/2009 15:56'!lines	"Compute lines based on logical line breaks, not optical (which may change due to line wrapping of the editor).	Subclasses using kinds of Paragraphs can instead use the service provided by it."	| lines string lineIndex |	string := self string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	lines := OrderedCollection new: (string size // 15).	lineIndex := 0.	string lineIndicesDo: [:start :endWithoutDelimiters :end |		lines addLast: {start. (lineIndex := lineIndex + 1). end}].	"Special workaround for last line empty."	(string last == Character cr or: [string last == Character lf])		ifTrue: [lines addLast: {string size + 1. lineIndex + 1. string size}].	^lines! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 01:22'!forkProgressWatcher	[	| killTarget |		[stageCompleted < 999 and: 				[formerProject == Project current and: 				[formerWorld == World and: 				[translucentMorph world notNil and:				[formerProcess suspendedContext notNil and: 				[Project uiProcess == formerProcess]]]]]] whileTrue: [			translucentMorph setProperty: #revealTimes toValue: 					{(Time millisecondClockValue - start max: 1). (estimate * newRatio max: 1)}.			translucentMorph changed.			translucentMorph owner addMorphInLayer: translucentMorph.			(Time millisecondClockValue - WorldState lastCycleTime) abs > 500 ifTrue: [				self backgroundWorldDisplay			].			(Delay forMilliseconds: 100) wait.		].		translucentMorph removeProperty: #revealTimes.		self loadingHistoryAt: 'total' add: (Time millisecondClockValue - start max: 1).		killTarget := targetMorph ifNotNil: [			targetMorph valueOfProperty: #deleteOnProgressCompletion		].		formerWorld == World ifTrue: [			translucentMorph delete.			killTarget ifNotNil: [killTarget delete].		] ifFalse: [			translucentMorph privateDeleteWithAbsolutelyNoSideEffects.			killTarget ifNotNil: [killTarget privateDeleteWithAbsolutelyNoSideEffects].		].	] forkAt: Processor lowIOPriority.! !!SequenceableCollection methodsFor: '*Morphic-NewCurves-cubic support' stamp: 'nice 12/26/2009 21:20'!closedCubicSlopes	"Sent to knots returns the slopes of a closed cubic spline.	From the same set of java sources as naturalCubic. This is a squeak  	transliteration of the java code."	"from java code NatCubicClosed extends NatCubic  	solves for the set of equations for all knots: 	b1+4*b2+b3=3*(a3-a1)	where a1 is (knots atWrap: index + 1) etc.	and the b's are the slopes .		by decomposing the matrix into upper triangular and lower matrices  	and then back sustitution. See Spath 'Spline Algorithms for Curves  	and Surfaces' pp 19--21. The D[i] are the derivatives at the knots.  	"		| v w x y z n1  D F G H |	n1 := self size.	n1 < 3		ifTrue: [self error: 'Less than 3 points makes a poor curve'].	v := Array new: n1.	w := Array new: n1.	y := Array new: n1.		D := Array new: n1.	x := self.	z := 1.0 / 4.0.	v at: 2 put: z.	w at: 2 put: z.	y at: 1 put: z * 3.0 * ((x at: 2)				- (x at: n1)).	H := 4.0.	F := 3 * ((x at: 1)					- (x at: n1 - 1)).	G := 1.	2 to: n1 - 1		do: [:k | 			z := 1.0 / (4.0							- (v at: k)).			v at: k + 1 put: z.			w at: k + 1 put: z negated					* (w at: k).			y at: k put: z * (3.0 * ((x at: k + 1)							- (x at: k - 1))						- (y at: k - 1)).			H := H - (G						* (w at: k)).			F := F - (G						* (y at: k - 1)).			G := (v at: k) negated * G].	H := H - (G + 1 * ((v at: n1)						+ (w at: n1))).	y at: n1 put: F - (G + 1				* (y at: n1 - 1)).	D at: n1 put: (y at: n1)			/ H.	D at: n1 - 1 put: (y at: n1 - 1)			- ((v at: n1)					+ (w at: n1)					* (D at: n1)).	(1 to: n1 - 2)		reverseDo: [:k | D at: k put: (y at: k)					- ((v at: k + 1)							* (D at: k + 1)) - ((w at: k + 1)						* (D at: n1))].	^ D .! !!SmalltalkEditor methodsFor: 'editing keys' stamp: 'nice 12/26/2009 21:40'!changeEmphasis: characterStream	"Change emphasis without styling if necessary"	styler ifNil: [^super changeEmphasis: characterStream].	^styler evaluateWithoutStyling: [super changeEmphasis: characterStream].! !!ComplexProgressIndicator class methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 01:23'!historyReport"ComplexProgressIndicator historyReport"	| answer |	History ifNil: [^Beeper beep].	answer := String streamContents: [ :strm |		| data |		(History keys asArray sort: [ :a :b | a asString <= b asString]) do: [ :k |			strm nextPutAll: k printString; cr.			data := History at: k.			(data keys asArray sort: [ :a :b | a asString <= b asString]) do: [ :dataKey |				strm tab; nextPutAll: dataKey printString,'  ',					(data at: dataKey) asArray printString; cr.			].			strm cr.		].	].	StringHolder new		contents: answer contents;		openLabel: 'Progress History'! !!ColorMappingCanvas methodsFor: 'drawing-support' stamp: 'nice 12/26/2009 19:22'!preserveStateDuring: aBlock	"Preserve the full canvas state during the execution of aBlock"	| oldCanvas result |	oldCanvas := myCanvas.	result := myCanvas preserveStateDuring:[:newCanvas|		myCanvas := newCanvas.		aBlock value: self].	myCanvas := oldCanvas.	^result! !!TextEditor methodsFor: 'explain' stamp: 'nice 12/26/2009 23:05'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class := model selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class := class soleInstance].	classes := class withAllSuperclasses.	"class variables"	reply := classes detect: [:each | each classVarNames anySatisfy: [:name | symbol = name]]				ifNone: [].	reply == nil ifFalse: [^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | each sharedPools			anySatisfy: [:pool | (pool includesKey: symbol)					and: 						[reply := pool.						true]]].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [^ '"is an undeclared variable.' , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes := WriteStream on: Array new.			self systemNavigation				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: [])						~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply) asString , ', which is used by the following classes ' , classes contents printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , (Smalltalk keyAtIdentityValue: reply) asString , ' bindingOf: #' , symbol , ').'].	^ nil! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'nice 12/26/2009 19:22'!preserveStateDuring: aBlock	"Preserve the full canvas state during the execution of aBlock.	Note: This does *not* include the state in the receiver (e.g., foundMorph)."	| tempCanvas result |	tempCanvas := self copy.	result := aBlock value: tempCanvas.	foundMorph := tempCanvas foundMorph.	^result! !!SketchMorph methodsFor: 'drawing' stamp: 'nice 12/26/2009 21:35'!canBeEnlargedWithB3D	^self 		valueOfProperty: #canBeEnlargedWithB3D		ifAbsent: [			| answer |			answer := self rotatedForm colorsUsed allSatisfy: [ :c | c isTranslucent not].			self setProperty: #canBeEnlargedWithB3D toValue: answer.			answer		]! !!TextEditor methodsFor: 'editing keys' stamp: 'nice 12/26/2009 01:07'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |	sensor keyboard.  "Flush typeahead"	cr := Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart := self startIndex.	realStop := self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue:					[morph flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^true].	lines := paragraph lines.	startLine := paragraph lineIndexOfCharacterIndex: realStart.	stopLine := paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start := (lines at: startLine) first.	stop := (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart := realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation := (startLine to: stopLine) inject: 1000 into:		[:m :l |		m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size :=  stop + 1 - start.	numLines := stopLine + 1 - startLine.	inStream := ReadStream on: paragraph string from: start to: stop.	newString := String new: size + ((numLines * delta) max: 0).	outStream := ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart := (realStart + delta) max: start].	realStop := realStop + outStream position - size.	"Prepare for another iteration"	indentation := indentation + delta.	size := outStream position.	inStream := outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[morph flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString := outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!DamageRecorder methodsFor: 'recording' stamp: 'nice 12/26/2009 01:28'!recordInvalidRect: newRect	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	| mergeRect |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	invalidRects do:		[:rect |		| a |		((a := (rect intersect: newRect) area) > 40			and: ["Avoid combining a vertical and horizontal rects.				  Can make a big diff and we only test when likely."				  a > (newRect area // 4) or: [a > (rect area // 4)]])			ifTrue:			["merge rectangle in place (see note below) if there is significant overlap"			rect setOrigin: (rect origin min: newRect origin) truncated				corner: (rect corner max: newRect corner) truncated.			^ self]].	invalidRects size >= 15 ifTrue:		["if there are too many separate areas, merge them all"		mergeRect := Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect].	"add the given rectangle to the damage list"	"Note: We make a deep copy of all rectangles added to the damage list,		since rectangles in this list may be extended in place."	invalidRects addLast:		(newRect topLeft truncated corner: newRect bottomRight truncated).! !!WorldState methodsFor: 'hands' stamp: 'nice 12/26/2009 22:28'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result |	result := OrderedCollection new.	hands do: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					| hBnds |					hBnds := h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: [nil])						ifNotNil: [result add: h]]]].	^ result! !!Cubic methodsFor: 'cubic support' stamp: 'nice 12/26/2009 01:28'!measureFor: n 	"Return a distance measure for cubic curve with n segments. 	For convienence and accuracy we use the sum of the	distances. "	"first point is poly of 0."	| p1 p2 measure |	p1 := self first.	measure := 0.	1 to: n		do: [:i | 			p2 := self polynomialEval: i / n asFloat.			measure := measure						+ (p2 dist: p1).			p1 := p2].	^ measure! !