"Change Set:		9222System-nice.243System-nice.243:1) move some temp assignments outside blocks2) move some temps declaration inside blocks3) remove some now useless fixTempsSystem-ar.242:Merge latest MessageTally changes from Cuis."!Magnitude subclass: #MessageTally	instanceVariableNames: 'class method process tally receivers senders time gcStats maxClassNameSize maxClassPlusSelectorSize maxTabs reportOtherProcesses'	classVariableNames: 'DefaultPollPeriod ShowProcesses Timer'	poolDictionaries: ''	category: 'System-Tools'!!MessageTally methodsFor: 'printing' stamp: 'jmv 9/24/2009 15:47'!leavesPrintExactOn: aStream	| dict |	dict := IdentityDictionary new: 100.	self leavesInto: dict fromSender: nil.	dict asSortedCollection		do: [ :node |			node printOn: aStream total: tally totalTime: nil tallyExact: true.			node printSenderCountsOn: aStream ]! !!MessageTally methodsFor: 'initialize-release' stamp: 'nice 2/4/2010 19:58'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ Timer terminate ].	Timer := [			[				| startTime |				startTime := Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal | 		gcStats at: idx put: (gcVal - gcStats at: idx)].	time := Time millisecondClockValue - time0! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 3/4/2009 09:42'!tally: context by: count	"Explicitly tally the specified context and its stack."	| sender |		"Add to this node if appropriate"	context method == method ifTrue: [^self bumpBy: count].		"No sender? Add new branch to the tree."	(sender :=  context home sender)ifNil: [		^ (self bumpBy: count) tallyPath: context by: count].		"Find the node for the sending context (or add it if necessary)"	^ (self tally: sender by: count) tallyPath: context by: count! !!MessageTally class methodsFor: 'spying' stamp: 'ar 2/3/2010 21:17'!tallySendsTo: receiver inBlock: aBlock showTree: treeOption	"	MessageTally tallySends: [3.14159 printString]	"	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. If receiver is not nil, then only sends	to that receiver are tallied.	Results are presented as leaves, sorted by frequency,	preceded, optionally, by the whole tree."	| prev tallies startTime totalTime |	startTime := Time millisecondClockValue.	tallies := MessageTally new class: aBlock receiver class method: aBlock method.	tallies reportOtherProcesses: true.	"Do NOT filter nodes with nil process"	prev := aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: 				["call or return"				prev sender == nil ifFalse: 					["call only"					(receiver == nil or: [current receiver == receiver])						ifTrue: [tallies tally: current by: 1]].				prev := current]].	totalTime := Time millisecondClockValue - startTime // 1000.0 roundTo: 0.01.	(StringHolder new contents:		(String streamContents:			[:s |			s nextPutAll: 'This simulation took ' , totalTime printString							, ' seconds.'; cr.			treeOption				ifTrue: [ tallies fullPrintExactOn: s ]				ifFalse: [ tallies leavesPrintExactOn: s ].			tallies close ]))		openLabel: 'Spy Results'! !!MessageTally methodsFor: 'printing' stamp: 'nice 2/4/2010 20:01'!rootPrintOn: aStream total: total totalTime: totalTime threshold: threshold	| groups sons |	sons := self sonsOver: threshold.	groups := sons groupBy: [ :aTally | aTally process] having: [ :g | true].	groups do:[:g|		| p |		p := g anyOne process.		(reportOtherProcesses or: [ p notNil ]) ifTrue: [			aStream nextPutAll: '--------------------------------'; cr.			aStream nextPutAll: 'Process: ',  (p ifNil: [ 'other processes'] ifNotNil: [ p browserPrintString]); cr.			aStream nextPutAll: '--------------------------------'; cr.			g asSortedCollection do:[:aSon | 				aSon 					treePrintOn: aStream					tabs: OrderedCollection new					thisTab: ''					total: total					totalTime: totalTime					tallyExact: false					orThreshold: threshold]].	]! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 9/24/2009 16:02'!spyOn: aBlock toFileNamed: fileName reportOtherProcesses: aBoolean	"Spy on the evaluation of aBlock. Write the data collected on a file	named fileName."	| file value node |	node := self new.	node reportOtherProcesses: aBoolean.	value := node spyEvery: self defaultPollPeriod on: aBlock.	file := FileStream newFileNamed: fileName.	node report: file; close.	file close.	^value! !!MessageTally methodsFor: 'initialize-release' stamp: 'nice 2/4/2010 19:55'!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay time0 |	(aBlock isMemberOf: BlockClosure)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ Timer terminate ].	Timer := [		[true] whileTrue: [			| observedProcess startTime |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		"cancel the probe and return the value"		Timer terminate.		Timer := nil.		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'collecting leaves' stamp: 'jmv 9/24/2009 16:07'!leavesInto: leafDict fromSender: senderTally	| rcvrs |	rcvrs := self sonsOver: 0.	rcvrs size = 0		ifTrue: [ self into: leafDict fromSender: senderTally ]		ifFalse: [						(reportOtherProcesses not and: [ rcvrs anyOne process isNil ]) ifTrue: [				^self].						rcvrs do: [ :node |				node isPrimitives					ifTrue: [ node leavesInto: leafDict fromSender: senderTally ]					ifFalse: [ node leavesInto: leafDict fromSender: self ]]]! !!MessageTally methodsFor: 'printing' stamp: 'nice 2/4/2010 19:58'!printSenderCountsOn: aStream	| mergedSenders |	mergedSenders := IdentityDictionary new.	senders do:		[:node |		| mergedNode |		mergedNode := mergedSenders at: node method ifAbsent: [nil].		mergedNode == nil			ifTrue: [mergedSenders at: node method put: node]			ifFalse: [mergedNode bump: node tally]].	mergedSenders asSortedCollection do:		[:node | 		10 to: node tally printString size by: -1 do: [:i | aStream space].		node printOn: aStream total: tally totalTime: nil tallyExact: true]! !!MessageTally methodsFor: 'initialize-release' stamp: 'nice 2/4/2010 19:57'!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	(aBlock isMemberOf: BlockClosure)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess := Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ Timer terminate ].	Timer := [ 		[true] whileTrue: [			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal | 			gcStats at: idx put: (gcVal - (gcStats at: idx))].		"cancel the probe and return the value"		Timer terminate.		Timer := nil.		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'printing' stamp: 'nice 2/4/2010 19:52'!treePrintOn: aStream tabs: tabs thisTab: myTab total: total totalTime: totalTime tallyExact: isExact orThreshold: threshold 	| sons |	tabs do: [:tab | aStream nextPutAll: tab].	tabs size > 0 		ifTrue: 			[self 				printOn: aStream				total: total				totalTime: totalTime				tallyExact: isExact].	sons := isExact ifTrue: [receivers] ifFalse: [self sonsOver: threshold].	sons isEmpty 		ifFalse: 			[tabs addLast: myTab.			sons := sons asSortedCollection.			(1 to: sons size) do: 					[:i | | sonTab | 					sonTab := i < sons size ifTrue: ['  |'] ifFalse: ['  '].					(sons at: i) 						treePrintOn: aStream						tabs: (tabs size < self maxTabs 								ifTrue: [tabs]								ifFalse: [(tabs select: [:x | x = '[']) copyWith: '['])						thisTab: sonTab						total: total						totalTime: totalTime						tallyExact: isExact						orThreshold: threshold].			tabs removeLast]! !!Utilities class methodsFor: 'fetching updates' stamp: 'nice 1/19/2010 02:02'!objectStrmFromUpdates: fileName	"Go to the known servers and look for this file in the updates folder.  It is an auxillery file, like .morph or a .gif.  Return a RWBinaryOrTextStream on it.    Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."	Cursor wait showWhile:		[ | urls |		urls := Utilities serverUrls collect: [:url | url, 'updates/', fileName].		urls do: [:aUrl | | doc |			doc := HTTPSocket httpGet: aUrl accept: 'application/octet-stream'.			"test here for server being up"			doc class == RWBinaryOrTextStream ifTrue: [^ doc reset]]].	self inform: 'All update servers are unavailable, or bad file name'.	^ nil! !!MessageTally class methodsFor: 'spying' stamp: 'ar 2/3/2010 21:14'!spyOnProcess: aProcess forMilliseconds: msecDuration 	"Spy on aProcess for a certain amount of time	| p1 p2 |  	p1 := [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  	p2 := [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.	p1 resume.	p2 resume.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000	"	^self spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: ShowProcesses! !!MessageTally class methodsFor: 'spying' stamp: 'ar 2/3/2010 21:33'!spyAllOn: aBlock	"Spy on all the processes in the system		[1000 timesRepeat: [3.14159 printString. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	[1000 timesRepeat: [20 factorial. Processor yield]] fork.	MessageTally spyAllOn: [ (Delay forMilliseconds: 100) wait]		"	| node result |	node := self new.	node reportOtherProcesses: true.	result := node spyAllEvery: self defaultPollPeriod on: aBlock.	self showReport: node.	^ result! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 3/4/2009 10:37'!tally: context in: aProcess by: count	"Explicitly tally the specified context and its stack."	| sender |	"Add to this node if appropriate"	context method == method ifTrue: [^self bumpBy: count].		"No sender? Add new branch to the tree."	(sender :=  context home sender) ifNil: [		^ (self bumpBy: count) tallyPath: context in: aProcess by: count].		"Find the node for the sending context (or add it if necessary)"	^ (self tally: sender in: aProcess by: count) tallyPath: context in: aProcess by: count! !!MessageTally methodsFor: 'accessing' stamp: 'ar 2/3/2010 21:21'!reportOtherProcesses	"If true, reports all processes in the system"	^reportOtherProcesses! !!MessageTally methodsFor: 'collecting leaves' stamp: 'jmv 9/24/2009 16:10'!into: leafDict fromSender: senderTally	| leafNode |	leafNode := leafDict at: method		ifAbsent: [leafDict at: method			put: ((MessageTally new class: class method: method)				process: process;				reportOtherProcesses: reportOtherProcesses)].	leafNode bump: tally fromSender: senderTally! !!ImageSegment methodsFor: 'read/write segment' stamp: 'nice 1/19/2010 01:29'!copyFromRoots: aRootArray sizeHint: segSizeHint areUnique: areUnique	"Copy a tree of objects into a WordArray segment.  The copied objects in the segment are not in the normal Squeak space.  	[1] For exporting a project.  Objects were enumerated by ReferenceStream and aRootArray has them all.	[2] For exporting some classes.  See copyFromRootsForExport:. (Caller must hold Symbols, or they will not get registered in the target system.)	[3] For 'local segments'.  outPointers are kept in the image.	If this method yields a very small segment, it is because objects just below the roots are pointed at from the outside.  (See findRogueRootsImSeg: for a *destructive* diagnostic of who is pointing in.)"	| segmentWordArray outPointerArray segSize rootSet uniqueRoots |	aRootArray ifNil: [self errorWrongState].	uniqueRoots := areUnique 		ifTrue: [aRootArray]		ifFalse: [rootSet := IdentitySet new: aRootArray size * 3.			uniqueRoots := OrderedCollection new.			1 to: aRootArray size do: [:ii |	"Don't include any roots twice"				(rootSet includes: (aRootArray at: ii)) 					ifFalse: [						uniqueRoots addLast: (aRootArray at: ii).						rootSet add: (aRootArray at: ii)]					ifTrue: [userRootCnt ifNotNil: ["adjust the count"								ii <= userRootCnt ifTrue: [userRootCnt := userRootCnt - 1]]]].			uniqueRoots].	arrayOfRoots := uniqueRoots asArray.	rootSet := uniqueRoots := nil.	"be clean"	userRootCnt ifNil: [userRootCnt := arrayOfRoots size].	arrayOfRoots do: [:aRoot | 		aRoot indexIfCompact > 0 ifTrue: [			self error: 'Compact class ', aRoot name, ' cannot be a root']].	outPointers := nil.	"may have used this instance before"	segSize := segSizeHint > 0 ifTrue: [segSizeHint *3 //2] ifFalse: [50000].	["Guess a reasonable segment size"	segmentWordArray := WordArrayForSegment new: segSize.	outPointerArray := [Array new: segSize // 20] ifError: [		state := #tooBig.  ^ self].	"Smalltalk garbageCollect."	(self storeSegmentFor: arrayOfRoots					into: segmentWordArray					outPointers: outPointerArray) == nil]		whileTrue:			["Double the segment size and try again"			segmentWordArray := outPointerArray := nil.			segSize := segSize * 2].	segment := segmentWordArray.	outPointers := outPointerArray.	state := #activeCopy.	endMarker := segment nextObject. 	"for enumeration of objects"	endMarker == 0 ifTrue: [endMarker := 'End' clone].! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 9/24/2009 16:11'!tallyPath: context in: aProcess by: count	| aMethod path |	aMethod := context method.		"Find the correct child (if there)"	receivers do: [ :oldTally | 		(oldTally method == aMethod and: [oldTally process == aProcess])			ifTrue: [path := oldTally]].			"Add new child if needed"	path ifNil:[		path := MessageTally new class: context receiver class method: aMethod;			process: aProcess;			reportOtherProcesses: reportOtherProcesses;			maxClassNameSize: maxClassNameSize;			maxClassPlusSelectorSize: maxClassPlusSelectorSize;			maxTabs: maxTabs.		receivers := receivers copyWith: path].	^ path bumpBy: count! !!MessageTally methodsFor: 'initialization' stamp: 'ar 2/3/2010 21:22'!initialize	"Initialize the receiver"	super initialize.	maxClassNameSize := self class defaultMaxClassNameSize.	maxClassPlusSelectorSize := self class defaultMaxClassPlusSelectorSize.	maxTabs := self class defaultMaxTabs.	reportOtherProcesses := false.! !!Project methodsFor: 'file in/out' stamp: 'nice 1/11/2010 20:56'!storeOnServerShowProgressOn: aMorphOrNil forgetURL: forget	"Save to disk as an Export Segment.  Then put that file on the server I came from, as a new version.  Version is literal piece of file name.  Mime encoded and http encoded."	world setProperty: #optimumExtentFromAuthor toValue: world extent.	self validateProjectNameIfOK: [		self isCurrentProject ifTrue: ["exit, then do the command"			forget				ifTrue: [self forgetExistingURL]				ifFalse: [urlList isEmptyOrNil ifTrue: [urlList := parentProject urlList copy]].			^self				armsLengthCommand: #storeOnServerAssumingNameValid				withDescription: 'Publishing' translated		].		self storeOnServerWithProgressInfoOn: aMorphOrNil.	].! !!MessageTally methodsFor: 'private' stamp: 'ar 2/3/2010 21:22'!copyWithTally: hitCount	^ (MessageTally new class: class method: method)		reportOtherProcesses: reportOtherProcesses;		process: process;		bump: hitCount! !!MessageTally methodsFor: 'printing' stamp: 'jmv 9/24/2009 15:49'!fullPrintOn: aStream threshold: perCent	| threshold |  	threshold := (perCent asFloat / 100 * tally) rounded.	aStream nextPutAll: '**Tree**'; cr.	self		rootPrintOn: aStream		total: tally		totalTime: time		threshold: threshold.	aStream nextPut: Character newPage; cr.	aStream nextPutAll: '**Leaves**'; cr.	self		leavesPrintOn: aStream		threshold: threshold! !!Project methodsFor: 'menu messages' stamp: 'nice 1/11/2010 20:56'!validateProjectNameIfOK: aBlock	| details |	details := world valueOfProperty: #ProjectDetails.	details ifNotNil: ["ensure project info matches real project name"		details at: 'projectname' put: self name.	].	self doWeWantToRename ifFalse: [^aBlock value].	(Smalltalk at: #EToyProjectDetailsMorph) ifNotNil: [:etpdm |		etpdm			getFullInfoFor: self 			ifValid: [				World displayWorldSafely.				aBlock value.			]			expandedFormat: false]! !!MessageTally methodsFor: 'printing' stamp: 'jmv 9/24/2009 15:49'!fullPrintExactOn: aStream	aStream nextPutAll: '**Tree**'; cr.	self		treePrintOn: aStream		tabs: OrderedCollection new		thisTab: ''		total: tally		totalTime: time		tallyExact: true		orThreshold: nil.	aStream nextPut: Character newPage; cr.	aStream nextPutAll: '**Leaves**'; cr.	self leavesPrintExactOn: aStream! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 9/24/2009 16:02'!spyOnProcess: aProcess forMilliseconds: msecDuration toFileNamed: fileName reportOtherProcesses: aBoolean	"Spy on the evaluation of aProcess. Write the data collected on a file  	named fileName. Will overwrite fileName"	| file node |	node := self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	file := FileStream fileNamed: fileName.	node report: file;		 close.	file close! !!MessageTally class methodsFor: 'spying' stamp: 'jmv 9/24/2009 16:17'!tallySends: aBlock	"	MessageTally tallySends: [3.14159 printString]	"	^ self tallySendsTo: nil inBlock: aBlock showTree: true! !!MessageTally methodsFor: 'reporting' stamp: 'jmv 9/24/2009 15:35'!report: strm cutoff: threshold 	tally = 0		ifTrue: [strm nextPutAll: ' - no tallies obtained']		ifFalse: 			[strm nextPutAll: ' - '; print: tally; nextPutAll: ' tallies, ', time printString, ' msec.'; cr; cr.			self fullPrintOn: strm threshold: threshold].			time isZero ifFalse:			[self reportGCStatsOn: strm].! !!MessageTally class methodsFor: 'spying' stamp: 'ar 2/3/2010 21:15'!showReport: node	"Open a string holder with the reports from the given node"	(StringHolder new contents: 		(String streamContents: [:s | node report: s; close]))			openLabel: 'Spy Results'! !!MessageTally methodsFor: 'accessing' stamp: 'ar 2/3/2010 21:21'!reportOtherProcesses: aBoolean	"If true, reports all processes in the system"	reportOtherProcesses := aBoolean! !!MessageTally class methodsFor: 'spying' stamp: 'ar 2/3/2010 21:15'!spyOnProcess: aProcess forMilliseconds: msecDuration reportOtherProcesses: aBoolean	"Spy on aProcess for a certain amount of time	| p1 p2 |  	p1 := [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.  	p2 := [100000 timesRepeat: [3.14159 printString. Processor yield]] newProcess.	p1 resume.	p2 resume.  	(Delay forMilliseconds: 100) wait.  	MessageTally spyOnProcess: p1 forMilliseconds: 1000 reportOtherProcesses: true	"	| node |	node := self new.	node reportOtherProcesses: aBoolean.	node		spyEvery: self defaultPollPeriod		onProcess: aProcess		forMilliseconds: msecDuration.	self showReport: node.! !!MessageTally class methodsFor: 'spying' stamp: 'ar 2/3/2010 21:16'!spyOn: aBlock reportOtherProcesses: aBoolean	"Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]] reportOtherProcesses: true	"	| node result |	node := self new.	node reportOtherProcesses: aBoolean.	result := node spyEvery: self defaultPollPeriod on: aBlock.	self showReport: node.	^ result! !!MessageTally methodsFor: 'comparing' stamp: 'jmv 9/24/2009 16:11'!sonsOver: threshold	| hereTally last sons |	(receivers == nil or: [receivers size = 0]) ifTrue: [^#()].	hereTally := tally.	sons := receivers select:  "subtract subNode tallies for primitive hits here"		[:son |		hereTally := hereTally - son tally.		son tally > threshold].	hereTally > threshold		ifTrue: [			last := MessageTally new class: class method: method.			last process: process.			last reportOtherProcesses: reportOtherProcesses.			^sons copyWith: (last primitives: hereTally)].	^sons! !!MessageTally class methodsFor: 'spying' stamp: 'ar 2/3/2010 21:13'!spyOn: aBlock	"Spy on aBlock, in the current process. Can include or not statistics on other processes in the report.	[1000 timesRepeat: [		100 timesRepeat: [120 factorial].		(Delay forMilliseconds: 10) wait		]] forkAt: 45 named: '45'.	MessageTally spyOn: [10000 timesRepeat: [1.23 printString]]	"	^self spyOn: aBlock reportOtherProcesses: ShowProcesses! !!MessageTally methodsFor: 'initialize-release' stamp: 'jmv 9/25/2009 08:48'!close	Timer ifNotNil: [ Timer terminate ].	Timer := nil.	class := method := tally := receivers := nil! !!MessageTally methodsFor: 'tallying' stamp: 'jmv 9/24/2009 16:11'!tallyPath: context by: count	| aMethod path |	aMethod := context method.		"Find the correct child (if there)"	receivers do: [ :oldTally | 		oldTally method == aMethod ifTrue: [path := oldTally]].		"Add new child if needed"	path ifNil: [		path := MessageTally new class: context receiver class method: aMethod.		path reportOtherProcesses: reportOtherProcesses.		receivers := receivers copyWith: path].		^ path bumpBy: count! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 1/19/2010 01:53'!mailOut	"Email a compressed version of this changeset to the squeak-dev list, so that it can be shared with everyone.  (You will be able to edit the email before it is sent.)"	| userName message slips |	userName := MailSender userName.	self checkForConversionMethods.	message := Cursor write showWhile: [self buildMessageForMailOutWithUser: userName].	MailSender sendMessage: message.	Preferences suppressCheckForSlips ifTrue: [^ self].	slips := self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?'])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!MessageTally methodsFor: 'printing' stamp: 'jmv 9/24/2009 15:48'!leavesPrintOn: aStream threshold: threshold	| dict |	dict := IdentityDictionary new: 100.	self leavesInto: dict fromSender: nil.	(dict asOrderedCollection			select: [:node | node tally > threshold])		asSortedCollection do: [:node |			node printOn: aStream total: tally totalTime: time tallyExact: false ]! !MessageTally removeSelector: #fullPrintOn:tallyExact:orThreshold:!MessageTally removeSelector: #rootPrintOn:total:totalTime:tallyExact:orThreshold:!MessageTally removeSelector: #leavesPrintOn:tallyExact:orThreshold:!