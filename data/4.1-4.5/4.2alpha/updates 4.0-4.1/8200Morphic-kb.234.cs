"Change Set:		8200Morphic-kb.234Morphic-kb.234: - fix: there was a bug in Morphic-kb.232 concerning the newly introduced behaviour: 'A menu item with a submenu releases its selection only if the mouse doesn't move towards the submenu.'Morphic-nice.229:Handle more crlf casesMorphic-nice.230:Fix selection of last line in case of LF delimitersThis was the awfully hard to find #fixupLastLineIfCRMorphic-nice.231:remove historical #testNewComposeAll and #OLDcomposeLinesFrom:to:delta:into:priorLines:atY:Morphic-kb.232: - subtle usability improvement to MenuMorph.   A menu item with submenu releases its selection only if the mouse doesn't move towards the submenu.Morphic-kb.233: - fix: there was a bug in Morphic-kb.232 concerning the newly introduced behaviour: 'A menu item with a submenu releases its selection only if the mouse doesn't move towards the submenu.'"!StringMorph subclass: #MenuItemMorph	instanceVariableNames: 'isEnabled subMenu isSelected target selector arguments icon lastMousePosition'	classVariableNames: 'SubMenuMarker'	poolDictionaries: ''	category: 'Morphic-Menus'!!TextComposer methodsFor: 'as yet unclassified' stamp: 'nice 11/17/2009 01:24'!composeEachRectangleIn: rectangles	| myLine lastChar |	1 to: rectangles size do: [:i | 		currCharIndex <= theText size ifFalse: [^false].		myLine := scanner 			composeFrom: currCharIndex 			inRectangle: (rectangles at: i)							firstLine: isFirstLine 			leftSide: i=1 			rightSide: i=rectangles size.		lines addLast: myLine.		actualHeight := actualHeight max: myLine lineHeight.  "includes font changes"		currCharIndex := myLine last + 1.		lastChar := theText at: myLine last.		(CharacterSet crlf includes: lastChar) ifTrue: [^#cr].		wantsColumnBreaks ifTrue: [			lastChar = TextComposer characterForColumnBreak ifTrue: [^#columnBreak].		].	].	^false! !!MenuItemMorph methodsFor: 'events' stamp: 'kb 11/17/2009 15:23'!releasesSelection: evt	" Returns a boolean indicating that this menu item is ready to go deselected.	It answers false if the mouse is moving towards its submenu. 	We check this by testing that the current mouse position lays in the triangle of 	the last mouse position and the two corners of the submenu facing our menu item. "	| triangle submenuIsOnTheRightSide |	self hasSubMenu ifFalse: [ 		lastMousePosition := nil.		^true ].	lastMousePosition ifNil: [ 		lastMousePosition := evt position.		^false ].	submenuIsOnTheRightSide := self left < subMenu left.	triangle := {		lastMousePosition.		submenuIsOnTheRightSide 			ifTrue: [ subMenu topLeft ] 			ifFalse: [ subMenu topRight ].		submenuIsOnTheRightSide 			ifTrue: [ subMenu bottomLeft ] 			ifFalse: [ subMenu bottomRight ] }.	lastMousePosition := evt position.	(self triangle: triangle containsPoint: evt position)		ifTrue: [ ^false ]		ifFalse: [ 			lastMousePosition := nil.			^true ]! !!MenuMorph methodsFor: 'events' stamp: 'kb 11/17/2009 15:02'!releasesSelection: evt	" The MenuMorph releases its selection if the selected item releases it. 	Used in #selectItem:event: "	self selectedItem ifNil: [ ^true ].	(self selectedItem containsPoint: evt position) ifTrue: [ ^true ].	^self selectedItem releasesSelection: evt! !!MenuMorph methodsFor: 'events' stamp: 'kb 11/17/2009 15:30'!handleMouseMove: evt	" If the mouse moves over an item not selected, we try to set it as selected.	If this happens depends on that the current selected item wants to release	its selection. "	self selectedItem ifNil: [ ^super handleMouseMove: evt ].	(self selectedItem containsPoint: evt position) ifTrue: [ ^super handleMouseMove: evt ].	self 		selectItem: (			self items 				detect: [ :each | each containsPoint: evt position ] 				ifNone: [ ^super handleMouseMove: evt ])		event: evt.	super handleMouseMove: evt! !!Editor methodsFor: 'private' stamp: 'nice 11/16/2009 15:21'!lines	"Compute lines based on logical line breaks, not optical (which may change due to line wrapping of the editor).	Subclasses using kinds of Paragraphs can instead use the service provided by it.	"	| lines string index lineIndex stringSize |	string := self string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize := string size.	lines := OrderedCollection new: (string size // 15).	index := 0.	lineIndex := 0.	string linesDo:[:line |		lines addLast: (Array			with: (index := index + 1)			with: (lineIndex := lineIndex + 1)			with: (index := index + line size min: stringSize))].	"Special workaround for last line empty."	(string last == Character cr or: [string last == Character lf])	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!MenuItemMorph methodsFor: 'geometry-testing' stamp: 'kb 11/17/2009 13:06'!triangle: points containsPoint: p	" Computes if p is in the triangle defined by points.	p should be a Point, and points should be an array with three Points.	I took the algorithm from the bottom of this page: 		http://www.blackpawn.com/texts/pointinpoly/default.html "	| a b c v0 v1 v2 dot00 dot01 dot02 dot11 dot12 denom invDenom u v |	a := points first.	b := points second.	c := points third.	" Compute vectors "	v0 := c - a.	v1 := b - a.	v2 := p - a.	" Compute dot products "	dot00 := v0 dotProduct: v0.	dot01 := v0 dotProduct: v1.	dot02 := v0 dotProduct: v2.	dot11 := v1 dotProduct: v1.	dot12 := v1 dotProduct: v2.	" Compute barycentric coordinates "	denom := dot00 * dot11 - (dot01 * dot01).	denom = 0 ifTrue: [ ^false ].	invDenom := 1 / denom.	u := (dot11 * dot02 - (dot01 * dot12)) * invDenom.	v := (dot00 * dot12 - (dot01 * dot02)) * invDenom.	" Check if point is in triangle "	^u >= 0 and: [ v >= 0 and: [ u + v <= 1 ] ]! !!MenuItemMorph methodsFor: 'copying' stamp: 'kb 11/17/2009 14:33'!veryDeepInner: deepCopier 	"Copy all of my instance variables. Some need to be not copied  	at all, but shared. Warning!!!! Every instance variable defined in  	this class must be handled. We must also implement  	veryDeepFixupWith:. See DeepCopier class comment."	super veryDeepInner: deepCopier.	isEnabled := isEnabled veryDeepCopyWith: deepCopier.	subMenu := subMenu veryDeepCopyWith: deepCopier.	isSelected := isSelected veryDeepCopyWith: deepCopier.	icon := icon veryDeepCopyWith: deepCopier.	"target := target.		Weakly copied"	"selector := selector.		a Symbol"	arguments := arguments.	lastMousePosition := nil! !!MenuMorph methodsFor: 'control' stamp: 'kb 11/17/2009 11:53'!selectItem: aMenuItem event: anEvent	" Change the selected item, but first ask the currently selected item 	if it want to release it. " 	(self releasesSelection: anEvent) ifFalse: [ ^self ].	selectedItem ifNotNil:[selectedItem deselect: anEvent].	selectedItem := aMenuItem.	selectedItem ifNotNil:[selectedItem select: anEvent].! !!MenuItemMorph methodsFor: 'events' stamp: 'kb 11/17/2009 15:04'!mouseLeaveDragging: evt 	"The mouse left the receiver. Do nothing if we're not in a 'valid menu transition', meaning that the current hand focus must be aimed at the owning menu."	owner ifNil: [^self].	evt hand mouseFocus == owner ifFalse: [^self].	"If we have a submenu, make sure we've got some time to enter it before actually leaving the menu item"	subMenu isNil ifTrue: [ owner selectItem: nil event: evt ]! !!NewParagraph methodsFor: 'private' stamp: 'nice 11/17/2009 00:59'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last crlf |	crlf := CharacterSet crlf.	arrayIndex := lineIndex.	[first := (lines at: arrayIndex) first.	 first > 1 and: [crlf includes: (text string at: first - 1)]] whileTrue: "word wrap"		[arrayIndex := arrayIndex - 1].	last := (lines at: arrayIndex) last.		^(text string copyFrom: first to: last) indentationIfBlank: aBlock.! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'nice 11/17/2009 01:56'!fixupLastLineIfCR"This awful bit is to ensure that if we have scanned all the text and the last character is a CR that there is a null line at the end of lines. Sometimes this was not happening which caused anomalous selections when selecting all the text. This is implemented as a post-composition fixup because I couldn't figure out where to put it in the main logic."	(theText size > 0 and: [CharacterSet crlf includes: theText last]) ifFalse: [^self].	self addNullLineForIndex: theText size + 1.! !NewParagraph removeSelector: #testNewComposeAll!NewParagraph removeSelector: #OLDcomposeLinesFrom:to:delta:into:priorLines:atY:!