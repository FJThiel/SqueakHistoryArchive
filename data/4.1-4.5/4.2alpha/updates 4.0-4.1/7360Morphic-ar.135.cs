"Change Set:		7360Morphic-ar.135Morphic-ar.135:Adds a nice speedup to window activation by removing a bit of code intended as optimization but actually causing significnt slowdowns when opening new windows. Speeds up the overall browser benchmark by 20-25%.Morphic-ar.133:Underscore removal.Morphic-ar.134:Fixes SystemProgressMorph so that it can deal properly with being initialized during use (i.e., FileIn/MC update with progress)."!!UpdatingThreePhaseButtonMorph methodsFor: 'as yet unclassified' stamp: 'sw 3/8/1999 13:50'!getSelector: sel	getSelector := sel! !!SystemProgressMorph methodsFor: 'initialization' stamp: 'jrp 7/6/2005 21:45'!updateColor: aMorph color: aColor intensity: anInteger 	"update the apareance of aMorph"	| fill |	Preferences gradientMenu		ifFalse: [^ self].	fill := GradientFillStyle ramp: {0.0 -> Color white. 1 ->aColor}.	fill radial: false;		origin: aMorph topLeft;		direction: 0 @ aMorph height.	aMorph fillStyle: fill! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:25'!setForm: aForm	self reset.	form := aForm.	port := self portClass toForm: form.! !!SimpleHierarchicalListMorph methodsFor: 'accessing' stamp: 'RAA 7/20/1998 12:09'!sortingSelector: s	sortingSelector := s! !!ThreePhaseButtonMorph class methodsFor: 'instance creation' stamp: 'bf 10/8/1999 15:14'!radioButton	"Answer a button pre-initialized with radiobutton images."	| f |	^self new		onImage: (f := ScriptingSystem formAtKey: 'RadioButtonOn');		pressedImage: (ScriptingSystem formAtKey: 'RadioButtonPressed');		offImage: (ScriptingSystem formAtKey: 'RadioButtonOff');		extent: f extent + (2@0);		yourself! !!PluggableTextMorphWithModel methodsFor: 'contents' stamp: 'sw 10/26/2000 14:37'!newTextContents: stringOrText	"Accept new text contents."	| newText aStack setter myText |	"Just underway; trying to make this work like TextMorph does, but not quite there yet."	newText := stringOrText asText.	(myText := textMorph text) = newText ifTrue: [^ self].  "No substantive change"	(self holdsSeparateDataForEachInstance and: [(aStack := self stack) notNil])		ifTrue:			[setter := self valueOfProperty: #setterSelector.			setter ifNotNil:				[(self valueOfProperty: #cardInstance) perform: setter with: newText]].	self world ifNotNil:		[self world startSteppingSubmorphsOf: self ].! !!HandMorph methodsFor: 'geometry' stamp: 'nk 8/20/2003 17:39'!position: aPoint	"Overridden to align submorph origins to the grid if gridding is on."	| adjustedPosition delta box |	adjustedPosition := aPoint.	temporaryCursor ifNotNil: [adjustedPosition := adjustedPosition + temporaryCursorOffset].	"Copied from Morph to avoid owner layoutChanged"	"Change the position of this morph and and all of its submorphs."	delta := adjustedPosition - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	box := self fullBounds.	(delta dotProduct: delta) > 100 ifTrue:[		"e.g., more than 10 pixels moved"		self invalidRect: box.		self invalidRect: (box translateBy: delta).	] ifFalse:[		self invalidRect: (box merge: (box translateBy: delta)).	].	self privateFullMoveBy: delta.! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 13:14'!vLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	| h |	scroller hasSubmorphs ifFalse:[^0].	h := self vScrollBarHeight.	^ (self vTotalScrollRange - h roundTo: self scrollDeltaHeight) max: 0! !!PolygonMorph methodsFor: 'private' stamp: 'di 11/21/97 21:29'!lineSegments	| lineSegments |	lineSegments := OrderedCollection new.	self lineSegmentsDo: [:p1 :p2 | lineSegments addLast: (Array with: p1 with: p2)].	^ lineSegments! !!Morph methodsFor: 'dropping/grabbing' stamp: 'dgd 9/10/2004 13:42'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"	| aWindow partsBinCase cmd aStack |	(self formerOwner notNil and: [self formerOwner ~~ aMorph])		ifTrue: [self removeHalo].	self formerOwner: nil.	self formerPosition: nil.	cmd := self valueOfProperty: #undoGrabCommand.	cmd ifNotNil:[aMorph rememberCommand: cmd.				self removeProperty: #undoGrabCommand].	(partsBinCase := aMorph isPartsBin) ifFalse:		[self isPartsDonor: false].	(aWindow := aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	(self isInWorld and: [partsBinCase not]) ifTrue:		[self world startSteppingSubmorphsOf: self].	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."	"An object launched by certain parts-launcher mechanisms should end up fully visible..."	(self hasProperty: #beFullyVisibleAfterDrop) ifTrue:		[aMorph == ActiveWorld ifTrue:			[self goHome].		self removeProperty: #beFullyVisibleAfterDrop].	(self holdsSeparateDataForEachInstance and: [(aStack := self stack) notNil])		ifTrue:			[aStack reassessBackgroundShape]! !!BalloonMorph class methodsFor: 'private' stamp: 'wiz 1/8/2005 18:05'!getVertices: bounds	"Construct vertices for a balloon up and to left of anchor"	| corners |	corners := bounds corners atAll: #(1 4 3 2).	^ (Array		with: corners first + (0 - bounds width // 2 @ 0)		with: corners first + (0 - bounds width // 4 @ (bounds height // 2))) , corners! !!HandMorph methodsFor: 'listeners' stamp: 'ar 10/26/2000 01:27'!mouseListeners: anArrayOrNil	mouseListeners := anArrayOrNil! !!TextMorph methodsFor: 'private' stamp: 'di 10/25/97 17:11'!setPredecessor: newPredecessor	predecessor := newPredecessor! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'nk 10/16/2003 14:08'!removeAllMorphs	| oldMorphs myWorld |	myWorld := self world.	(fullBounds notNil or:[myWorld notNil]) ifTrue:[self invalidRect: self fullBounds].	submorphs do: [:m | myWorld ifNotNil: [ m outOfWorld: myWorld ]. m privateOwner: nil].	oldMorphs := submorphs.	submorphs := EmptyArray.	oldMorphs do: [ :m | self removedMorph: m ].	self layoutChanged.! !!TextMorph methodsFor: 'editing' stamp: 'yo 11/7/2002 19:11'!setCompositionWindow	| hand |	hand := self primaryHand.	hand ifNotNil: [hand compositionWindowManager keyboardFocusForAMorph: self].! !!PolygonMorph methodsFor: 'private' stamp: 'nk 3/27/2001 21:23'!transformVerticesFrom: oldOwner to: newOwner	| oldTransform newTransform world newVertices |	world := self world.	oldTransform := oldOwner		ifNil: [ IdentityTransform new ]		ifNotNil: [ oldOwner transformFrom: world ].	newTransform := newOwner		ifNil: [ IdentityTransform new ]		ifNotNil: [ newOwner transformFrom: world ].	newVertices := vertices collect: [ :ea | newTransform globalPointToLocal:		(oldTransform localPointToGlobal: ea) ].	self setVertices: newVertices.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 10/26/2000 14:12'!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	remoteServer ifNotNil:[		self assuredCanvas.		^true].	properDisplay := canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	] ifFalse: [  "this world is inside an MVC window"		(properDisplay and: [canvas clipRect = aWorld viewBox]) ifFalse: [			self canvas:				(Display getCanvas copyOffset: 0@0 clipRect: aWorld viewBox)		]	].	^ true! !!SimpleButtonMorph methodsFor: 'geometry' stamp: '6/7/97 10:53 di'!extent: newExtent	| label |	super extent: newExtent.	submorphs size = 1 ifTrue:		["keep the label centered"		"NOTE: may want to test more that it IS a label..."		label := self firstSubmorph.		label position: self center - (label extent // 2)]! !!Morph methodsFor: 'layout-menu' stamp: 'dgd 8/30/2003 16:51'!addLayoutMenuItems: topMenu hand: aHand	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addUpdating: #hasNoLayoutString action: #changeNoLayout.	aMenu addUpdating: #hasProportionalLayoutString action: #changeProportionalLayout.	aMenu addUpdating: #hasTableLayoutString action: #changeTableLayout.	aMenu addLine.	aMenu add: 'change layout inset...' translated action: #changeLayoutInset:.	aMenu addLine.	self addCellLayoutMenuItems: aMenu hand: aHand.	self addTableLayoutMenuItems: aMenu hand: aHand.	topMenu ifNotNil:[topMenu add: 'layout' translated subMenu: aMenu].	^aMenu! !!FileList2 methodsFor: 'private' stamp: 'LC 1/6/2002 09:03'!setSelectedDirectoryTo: aFileDirectoryWrapper	currentDirectorySelected := aFileDirectoryWrapper.	self directory: aFileDirectoryWrapper withoutListWrapper.	brevityState := #FileList.	"self addPath: path."	self changed: #fileList.	self changed: #contents.	self changed: #currentDirectorySelected.! !!PasteUpMorph methodsFor: 'update cycle' stamp: 'di 7/15/1999 09:51'!startBackgroundProcess	"Start a process to update this world in the background. Return the process created."	| p |	p := [[true] whileTrue: [		self doOneCycleInBackground.		(Delay forMilliseconds: 20) wait]] newProcess.	p resume.	^ p! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'ar 8/31/2004 20:53'!newProjectViewInAWindowFor: aProject	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| window proj |	proj := self on: aProject.	window := (SystemWindow labelled: aProject name) model: aProject.	window		addMorph: proj		frame: (0@0 corner: 1.0@1.0).	proj borderWidth: 0.	^ window! !!PluggableTextMorphWithModel class methodsFor: 'scripting' stamp: 'sw 10/30/2000 11:14'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin"	| proto |	proto := super authoringPrototype.	proto color: (Color r: 0.972 g: 0.972 b: 0.662).	^ proto! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'yo 9/29/2004 10:24'!mouseUp: evt	| c |	self stopStepping.	sourceHand := nil.	deleteOnMouseUp ifTrue: [self delete].	c := self getColorFromKedamaWorldIfPossible: evt cursorPoint.	c ifNotNil: [selectedColor := c].	self updateTargetColor.! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 21:52'!handleBoundsChange: aBlock	| oldBounds newBounds |	oldBounds := bounds.	aBlock value.	newBounds := bounds.	self boundsChangedFrom: oldBounds to: newBounds.! !!TextLine methodsFor: 'private' stamp: 'di 10/23/97 19:57'!lineHeight: height baseline: ascent	bottom := top + height.	baseline := ascent! !!FileList class methodsFor: 'instance creation' stamp: 'sbw 8/29/2001 19:37'!openAsMorph	"Open a morphic view of a FileList on the default directory."	| dir aFileList window upperFraction offset |	dir := FileDirectory default.	aFileList := self new directory: dir.	window := (SystemWindow labelled: dir pathName)				model: aFileList.	upperFraction := 0.3.	offset := 0.	self		addVolumesAndPatternPanesTo: window		at: (0 @ 0 corner: 0.3 @ upperFraction)		plus: offset		forFileList: aFileList.	self		addButtonsAndFileListPanesTo: window		at: (0.3 @ 0 corner: 1.0 @ upperFraction)		plus: offset		forFileList: aFileList.	window		addMorph: (PluggableTextMorph				on: aFileList				text: #contents				accept: #put:				readSelection: #contentsSelection				menu: #fileContentsMenu:shifted:)		frame: (0 @ 0.3 corner: 1 @ 1).	^ window! !!LayoutFrame class methodsFor: 'instance creation' stamp: 'RAA 1/8/2001 21:22'!fractions: fractionsOrNil offsets: offsetsOrNil	| fractions offsets |	fractions := fractionsOrNil ifNil: [0@0 extent: 0@0].	offsets := offsetsOrNil ifNil: [0@0 extent: 0@0].	^self new		topFraction: fractions top offset: offsets top;		leftFraction: fractions left offset: offsets left;		bottomFraction: fractions bottom offset: offsets bottom;		rightFraction: fractions right offset: offsets right! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:27'!oldFileStreamFrom: aDirectory	| sfmResult fileStream |	sfmResult := self oldFileFrom: aDirectory.	sfmResult ifNil: [^nil].	fileStream := sfmResult directory oldFileNamed: sfmResult name.	[fileStream isNil] whileTrue:		[sfmResult := self oldFileFrom: aDirectory.		sfmResult ifNil: [^nil].		fileStream := sfmResult directory oldFileNamed: sfmResult name].	^fileStream! !!UpdatingStringMorph methodsFor: 'accessing' stamp: ''!getSelector: aSymbol	getSelector := aSymbol.! !!TextLine class methodsFor: 'instance creation' stamp: 'di 10/20/97 23:08'!start: startInteger stop: stopInteger internalSpaces: spacesInteger paddingWidth: padWidthInteger	"Answer an instance of me with the arguments as the start, stop points, 	number of spaces in the line, and width of the padding."	| line |	line := self new firstIndex: startInteger lastIndex: stopInteger.	^ line internalSpaces: spacesInteger paddingWidth: padWidthInteger! !!PluggableListMorphByItem methodsFor: 'initialization' stamp: 'ls 8/19/2001 14:52'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list.""NOTE: this is no longer true; list is a real list, and itemList is no longer used.  And this method shouldn't be called, incidentally."self isThisEverCalled .	itemList := arrayOfStrings.	^ super list: arrayOfStrings! !!SystemWindow methodsFor: 'top window' stamp: 'sw 5/20/2001 22:32'!adjustBorderUponActivationWhenLabeless	"Adjust the border upon, um, activation when, um, labelless"	| aWidth |	(aWidth := self valueOfProperty: #borderWidthWhenActive) ifNotNil:		[self acquireBorderWidth: aWidth]! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 11/27/1999 08:51'!bestPositionNear: box inWorld: world	| points b |	points := #(topCenter rightCenter bottomCenter leftCenter).  "possible anchors"	1 to: 4 do:		[:i |  "Try the four obvious anchor points"		b := self bounds align: (self bounds perform: (points at: i))					with: (box perform: (points atWrap: i + 2)).		(world viewBox containsRect: b) ifTrue:			[^ b topLeft"  Yes, it fits"]].	^ 20@20  "when all else fails"! !!HaloMorph methodsFor: 'halos and balloon help' stamp: 'nk 6/12/2004 09:34'!addSimpleHandlesTo: aHaloMorph box: aBox	| aHandle |	simpleMode := true.	target isWorldMorph ifTrue: [^ self addSimpleHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"		self bounds: target renderedMorph worldBoundsForHalo.  "update my size"		self addHandleAt: (((aBox topLeft + aBox leftCenter) // 2) + self simpleFudgeOffset) color: Color paleBuff icon: 'Halo-MoreHandles'		on: #mouseDown send: #addFullHandles to: self.	aHandle := self addGraphicalHandle: #Rotate at: aBox bottomLeft on: #mouseDown send: #startRot:with: to: self.	aHandle on: #mouseMove send: #doRot:with: to: self.	target isFlexMorph		ifTrue: [(self addGraphicalHandle: #Scale at: aBox bottomRight  on: #mouseDown send: #startScale:with: to: self)				on: #mouseMove send: #doScale:with: to: self]		ifFalse: [(self addGraphicalHandle: #Scale at: aBox bottomRight on: #mouseDown send: #startGrow:with: to: self)				on: #mouseMove send: #doGrow:with: to: self].	innerTarget wantsSimpleSketchMorphHandles ifTrue:		[self addSimpleSketchMorphHandlesInBox: aBox].	growingOrRotating := false.	self layoutChanged.	self changed.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 11/4/97 07:46'!defaultTarget: anObject	"Set the default target for adding menu items."	defaultTarget := anObject.! !!SelectionMorph methodsFor: 'halo commands' stamp: 'dgd 9/20/2004 13:41'!alignLeftEdges	"Make the left coordinate of all my elements be the same"	| minLeft |	minLeft := (selectedItems collect: [:itm | itm left]) min.	selectedItems do:		[:itm | itm left: minLeft].	self changed! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label := StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox := self createCollapseBox.			stripes := Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!LayoutCell methodsFor: 'accessing' stamp: 'ls 8/5/2004 16:48'!vSpaceFill: aBool	flags := aBool ifTrue:[self flags bitOr: 2] ifFalse:[self flags bitClear: 2].! !!Morph methodsFor: 'geometry' stamp: 'ar 11/12/2000 22:06'!outerBounds	"Return the 'outer' bounds of the receiver, e.g., the bounds that need to be invalidated when the receiver changes."	| box |	box := self bounds.	self hasDropShadow ifTrue:[box := self expandFullBoundsForDropShadow: box].	self hasRolloverBorder ifTrue:[box := self expandFullBoundsForRolloverBorder: box].	^box! !!MorphicUnknownEvent methodsFor: 'private' stamp: 'ar 10/25/2000 19:59'!setType: evtType argument: arg	type := evtType.	argument := arg.! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!handler: anObject	handler := anObject! !!BorderedMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:53'!borderInitialize	"initialize the receiver state related to border"	borderColor:= self defaultBorderColor.	borderWidth := self defaultBorderWidth! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 12/31/2001 03:26'!contentsOfArea: aRectangle into: aForm	| bb |	self flush.	bb := BitBlt toForm: aForm.	bb sourceForm: form; combinationRule: Form over;		sourceX: (aRectangle left + origin x); sourceY: (aRectangle top + origin y);		width: aRectangle width; height: aRectangle height;		copyBits.	^aForm! !!PolygonMorph methodsFor: 'caching' stamp: 'di 9/4/2000 13:36'!releaseCachedState	super releaseCachedState.	filledForm := nil.	arrowForms := nil.	borderForm := nil.	curveState := nil.	(self hasProperty: #flex) ifTrue:		[self removeProperty: #unflexedVertices;			removeProperty: #flex].! !!TextMorph methodsFor: 'scripting access' stamp: 'sw 10/13/2004 19:57'!insertCharacters: aSource	"Insert the characters from the given source at my current cursor position"	| aLoc |	aLoc := self cursor max: 1.	paragraph replaceFrom: aLoc to: (aLoc - 1) with: aSource asText displaying: true.	self updateFromParagraph  ! !!Morph methodsFor: 'e-toy support' stamp: 'nb 6/17/2003 12:25'!definePath	| points lastPoint aForm offset currentPoint dwell ownerPosition |	points := OrderedCollection new: 70.	lastPoint := nil.	aForm := self imageForm.	offset := aForm extent // 2.	ownerPosition := owner position.	Cursor move show.	Sensor waitButton.	[Sensor anyButtonPressed and: [points size < 100]] whileTrue:		[currentPoint := Sensor cursorPoint.		dwell := 0.		currentPoint = lastPoint			ifTrue:				[dwell := dwell + 1.				((dwell \\ 1000) = 0) ifTrue:					[Beeper beep]]			ifFalse:				[self position: (currentPoint - offset).				self world displayWorld.				(Delay forMilliseconds: 20) wait.				points add: currentPoint.				lastPoint := currentPoint]].	points size > 1		ifFalse:			[self inform: 'no path obtained']		ifTrue:			[points size = 100 ifTrue: [self playSoundNamed: 'croak'].			Transcript cr; show: 'path defined with', points size printString, ' points'.			self renderedMorph setProperty: #pathPoints toValue: 				(points collect: [:p | p - ownerPosition])].	Cursor normal show		! !!Morph methodsFor: 'menus' stamp: 'sw 10/6/2004 12:16'!transferStateToRenderer: aRenderer	"Transfer knownName, actorState, visible, and player info over to aRenderer, which is being imposed above me as a transformation shell"	| current |	(current := self actorStateOrNil) ifNotNil:		[aRenderer actorState: current.		self actorState: nil].	(current := self knownName) ifNotNil:		[aRenderer setNameTo: current.		self setNameTo: nil].	(current := self player) ifNotNil:		[aRenderer player: current.		self player rawCostume: aRenderer.		"NB player is redundantly pointed to in the extension of both the renderer and the rendee; this is regrettable but many years ago occasionally people tried to make that clean but always ran into problems iirc"		"self player: nil"].	aRenderer simplySetVisible: self visible 		! !!TransformMorph methodsFor: 'geometry' stamp: 'nk 4/12/2002 14:02'!localVisibleSubmorphBounds	"Answer, in my coordinate system, the bounds of all my visible submorphs (or nil if no visible submorphs)"	| subBounds |	subBounds := nil.	self submorphsDo: [:m |		(m visible) ifTrue: [			subBounds				ifNil: [subBounds := m fullBounds copy]				ifNotNil: [subBounds := subBounds quickMerge: m fullBounds]]			].	^subBounds! !!Morph methodsFor: 'geometry' stamp: 'sw 7/10/1999 17:27'!previousOwnerPage	"Tell my container to advance to the previous page"	| targ |	targ := self ownerThatIsA: BookMorph.	targ ifNotNil: [targ previousPage]! !!FileList methodsFor: 'volume list and pattern' stamp: 'tpr 11/28/2003 11:44'!deleteDirectory	"Remove the currently selected directory"	| localDirName |	directory entries size = 0 ifFalse:[^self inform:'Directory must be empty'].	localDirName := directory localName.	(self confirm: 'Really delete ' , localDirName , '?') ifFalse: [^ self].	self volumeListIndex: self volumeListIndex-1.	directory deleteDirectory: localDirName.	self updateFileList.! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeBackArrow	arrows := #back.	self computeBounds! !!BalloonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:20'!initialize	"initialize the state of the receiver"	super initialize.	""	self beSmoothCurve.	offsetFromTarget := 0 @ 0! !!MorphicModel class methodsFor: 'prototype access' stamp: 'gm 2/22/2003 19:13'!prototype: aMorph	"Store a copy of the given morph as a prototype to be copied to make new instances."	aMorph ifNil: [prototype := nil. ^ self].	prototype := aMorph veryDeepCopy.	(prototype isMorphicModel) ifTrue: 		[prototype model: nil slotName: nil].! !!ThreePhaseButtonMorph class methodsFor: 'instance creation' stamp: 'bf 10/8/1999 15:23'!checkBox	"Answer a button pre-initialized with checkbox images."	| f |	^self new		onImage: (f := ScriptingSystem formAtKey: 'CheckBoxOn');		pressedImage: (ScriptingSystem formAtKey: 'CheckBoxPressed');		offImage: (ScriptingSystem formAtKey: 'CheckBoxOff');		extent: f extent + (2@0);		yourself! !!Morph methodsFor: 'menus' stamp: 'ar 10/5/2000 17:20'!allMenuWordings	| tempMenu |	tempMenu := self buildHandleMenu: self currentHand.	tempMenu allMorphsDo: [:m | m step].  "Get wordings current"	^ tempMenu allWordings! !!AlphaBlendingCanvas methodsFor: 'initialization' stamp: 'ar 8/8/2001 14:18'!on: aCanvas	myCanvas := aCanvas.	alpha := 1.0.! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/11/2000 16:16'!installAsActiveSubprojectIn: enclosingWorld titled: aString	| opt newWidth |	opt := self optimumExtentFromAuthor.	(opt x > (enclosingWorld width * 0.7) or: 			[opt y > (enclosingWorld height * 0.7)]) ifTrue: [		newWidth := enclosingWorld width // 2.		opt := newWidth @ (opt y * newWidth / opt x) truncated	].	^self 		installAsActiveSubprojectIn: enclosingWorld 		at: (enclosingWorld topLeft + (enclosingWorld extent - opt // 2) extent: opt) 		titled: aString! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 8/31/2004 14:05'!addDismissButtonTo: aRowMorph	"Add the brown dismiss button to the header"	| aButton |	aButton := self tanOButton.	aRowMorph addMorphBack: aButton.	aButton actionSelector: #dismiss;			setBalloonText: 'Remove this scriptfrom the screen(you can open itagain from a Viewer)' translated.	^ aRowMorph! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 10/26/2000 19:26'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	self shadowColor ifNotNil:		[^self fillRectangle: aRectangle color: aFillStyle asColor].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern := aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!TextLine methodsFor: 'updating' stamp: 'di 11/7/97 08:32'!moveBy: delta 	"Move my rectangle by the given delta"	left := left + delta x.	right := right + delta x.	top := top + delta y.	bottom := bottom + delta y.! !!Morph methodsFor: 'drawing' stamp: 'ar 11/8/2000 19:29'!expandFullBoundsForRolloverBorder: aRectangle	| delta |	delta := self valueOfProperty: #rolloverWidth ifAbsent: [10@10].	^aRectangle expandBy: delta.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'mir 3/9/2004 16:27'!withProgressDo: aBlock	| safetyFactor totals trialRect delta stageCompletedString targetOwner |	Smalltalk isMorphic ifFalse: [^aBlock value].	formerProject := Project current.	formerWorld := World.	formerProcess := Processor activeProcess.	targetMorph		ifNil: [targetMorph := ProgressTargetRequestNotification signal].	targetMorph ifNil: [		trialRect := Rectangle center: Sensor cursorPoint extent: 80@80.		delta := trialRect amountToTranslateWithin: formerWorld bounds.		trialRect := trialRect translateBy: delta.		translucentMorph := TranslucentProgessMorph new			opaqueBackgroundColor: Color white;			bounds: trialRect;			openInWorld: formerWorld.	] ifNotNil: [		targetOwner := targetMorph owner.		translucentMorph := TranslucentProgessMorph new			setProperty: #morphicLayerNumber toValue: targetMorph morphicLayerNumber - 0.1;			bounds: targetMorph boundsInWorld;			openInWorld: targetMorph world.	].	stageCompleted := 0.	safetyFactor := 1.1.	"better to guess high than low"	translucentMorph setProperty: #progressStageNumber toValue: 1.	translucentMorph hide.	targetOwner ifNotNil: [targetOwner hide].	totals := self loadingHistoryDataForKey: 'total'.	newRatio := 1.0.	estimate := totals size < 2 ifTrue: [		15000		"be a pessimist"	] ifFalse: [		(totals sum - totals max) / (totals size - 1 max: 1) * safetyFactor.	].	start := Time millisecondClockValue.	self forkProgressWatcher.	[		aBlock 			on: ProgressInitiationException			do: [ :ex | 				ex sendNotificationsTo: [ :min :max :curr |					"ignore this as it is inaccurate"				].			].	] on: ProgressNotification do: [ :note |		translucentMorph show.		targetOwner ifNotNil: [targetOwner show].		note extraParam ifNotNil:[self addProgressDecoration: note extraParam].		stageCompletedString := (note messageText findTokens: ' ') first.		stageCompleted := (stageCompletedString copyUpTo: $:) asNumber.		cumulativeStageTime := Time millisecondClockValue - start max: 1.		prevData := self loadingHistoryDataForKey: stageCompletedString.		prevData isEmpty ifFalse: [			newRatio := (cumulativeStageTime / (prevData average max: 1)) asFloat.		].		self 			loadingHistoryAt: stageCompletedString 			add: cumulativeStageTime.		translucentMorph 			setProperty: #progressStageNumber 			toValue: stageCompleted + 1.		note resume.	].	stageCompleted := 999.	"we may or may not get here"! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'sw 7/30/2001 15:55'!label: aStringOrTextOrMorph font: aFont	"Label this button with the given string or morph."	| r |	self removeAllMorphs.	"nest label in a row for centering"	r := AlignmentMorph newRow		borderWidth: 0;		layoutInset: 0;		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		wrapCentering: #center; cellPositioning: #leftCenter.	aStringOrTextOrMorph isMorph		ifTrue: [			label := aStringOrTextOrMorph.			r addMorph: aStringOrTextOrMorph]		ifFalse: [			label := aStringOrTextOrMorph asString.			r addMorph: (StringMorph contents: label font: aFont)].	self addMorph: r.! !!MenuMorph class methodsFor: 'instance creation' stamp: 'jrp 7/23/2005 12:13'!initialize	"MenuMorph initialize"		Preferences		setParameter: #menuTitleBorderWidth to: 0;		setParameter: #menuTitleColor to: (TranslucentColor r: 0.87 g: 0.8 b: 1 alpha: 0.65);		setParameter: #menuColor to: (Color 			r: (215/255) asFloat 			g: (220/255) asFloat 			b: (232/255) asFloat).	CloseBoxImage := nil! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'dgd 9/20/2003 19:05'!columnPrototype	"Answer a prototypical column"	| sampleMorphs aColumn |	sampleMorphs := #(red yellow green) collect:		[:aColor | Morph new extent: 130 @ 38; color: (Color perform: aColor); setNameTo: aColor asString; yourself].	aColumn := self inAColumn: sampleMorphs.	aColumn setNameTo: 'Column'.	aColumn color: Color veryVeryLightGray.	aColumn cellInset: 4; layoutInset: 6.	aColumn enableDragNDrop.	aColumn setBalloonText: 'Things dropped into here will automatically be organized into a column. Once you have added your own items here, you will want to remove the sample colored rectangles that this started with, and you will want to change this balloon help message to one of your own!!' translated.	^ aColumn! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'wiz 1/16/2006 20:05'!clearTarget	target := nil.! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 9/30/2000 10:07'!trackColorAt: aGlobalPoint 	"Before the mouse comes down in a modal color picker, track the color under the cursor, and show it in the feedback box, but do not make transparency changes"	| selfRelativePoint pickedColor |	selfRelativePoint := (self globalPointToLocal: aGlobalPoint) - self topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue: [^ self].	"pick up color, either inside or outside this world"	pickedColor := Display colorAt: aGlobalPoint.	self updateColor: (pickedColor alpha: originalColor alpha)		feedbackColor: pickedColor! !!TopLeftGripMorph methodsFor: 'drawing' stamp: 'jmv 2/19/2006 14:24'!drawOn: aCanvas	| dotBounds alphaCanvas windowBorderWidth dotBounds2 |	windowBorderWidth := SystemWindow borderWidth.	bounds := self bounds.	alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.		"alphaCanvas		frameRectangle: bounds color: Color blue."	dotBounds := (bounds insetBy: 1).	dotBounds2 := dotBounds right: (dotBounds left + windowBorderWidth).	dotBounds2 := dotBounds2 bottom: (dotBounds2 top + windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.		dotBounds2 := dotBounds left: (dotBounds left + windowBorderWidth).	dotBounds2 := dotBounds2 bottom: (dotBounds2 top + windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 left: (dotBounds2 left + 7).	dotBounds2 := dotBounds2 right: (dotBounds2 right - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor.	dotBounds2 := dotBounds right: (dotBounds left + windowBorderWidth).	dotBounds2 := dotBounds2 top: (dotBounds2 top + windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 top: (dotBounds2 top + 7).	dotBounds2 := dotBounds2 bottom: (dotBounds2 bottom - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor! !!TextFieldMorph class methodsFor: 'scripting' stamp: 'md 11/14/2003 17:32'!authoringPrototype 	"Answer an instance of the receiver that can serve as a prototype for authoring"	| proto |	proto := super authoringPrototype.	proto setProperty: #shared toValue: true.	proto extent: 170 @ 30.	proto color: Color veryLightGray lighter.	proto contents: 'on a clear day you can...'.	^ proto! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'sw 12/10/1999 09:06'!label: aString font: aFont	| oldLabel m |	(oldLabel := self findA: StringMorph)		ifNotNil: [oldLabel delete].	m := StringMorph contents: aString font: (aFont ifNil: [Preferences standardButtonFont]).	self extent: (m width + 6) @ (m height + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/26/2001 23:39'!intersectFrom: startPt with: startDir to: endPt with: endDir	"Compute the intersection of two lines. Return nil if either		* the intersection does not exist, or		* the intersection is 'before' startPt, or		* the intersection is 'after' endPt	"	| det deltaPt alpha beta |	det := (startDir x * endDir y) - (startDir y * endDir x).	det = 0.0 ifTrue:[^nil]. "There's no solution for it"	deltaPt := endPt - startPt.	alpha := (deltaPt x * endDir y) - (deltaPt y * endDir x).	beta := (deltaPt x * startDir y) - (deltaPt y * startDir x).	alpha := alpha / det.	beta := beta / det.	alpha < 0 ifTrue:[^nil].	beta > 1.0 ifTrue:[^nil].	"And compute intersection"	^(startPt x + (alpha * startDir x)) @ (startPt y + (alpha * startDir y))! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:31'!resultBlock: aBlock	^resultBlock := aBlock! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 9/27/2005 20:36'!openMenu	"Build the open window menu for the world."	| menu |	menu := self menu: 'open...'.	menu defaultTarget: ToolSet default.	menu addList: ToolSet menuItems.	menu defaultTarget: self.	self fillIn: menu from: {		nil.		{'file...' . { self . #openFileDirectly} . 'Lets you open a window on a single file'}.		{'transcript (t)' . {self . #openTranscript}. 'A window used to report messages sent to Transcript' }.		"{'inner world' . { WorldWindow . #test1} }."		nil.	}.	self fillIn: menu from: self class registeredOpenCommands.	menu addLine.	self mvcProjectsAllowed ifTrue:		[self fillIn: menu from: { {'mvc project' . {self. #openMVCProject} . 'Creates a new project of the classic "mvc" style'} }].	^ self fillIn: menu from: { 		{'morphic project' . {self. #openMorphicProject} . 'Creates a new morphic project'}.	}.! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'md 2/24/2006 22:41'!doFastWindowReframe: ptName	| newBounds |	"For fast display, only higlight the rectangle during loop"	newBounds := self bounds newRectButtonPressedDo: [:f | 		f 			withSideOrCorner: ptName			setToPoint: (self pointFromWorld: Sensor cursorPoint)			minExtent: self minimumExtent].	self bounds: newBounds.	^newBounds.! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'RAA 5/4/2001 18:09'!addNullLineForIndex: index"This awful bit is to ensure that if we have scanned all the text and the last character is a CR that there is a null line at the end of lines. Sometimes this was not happening which caused anomalous selections when selecting all the text. This is implemented as a post-composition fixup because I couldn't figure out where to put it in the main logic."	| oldLastLine r |	oldLastLine := lines last.	oldLastLine last - oldLastLine first >= 0 ifFalse: [^self].	oldLastLine last = (index - 1) ifFalse: [^self].	r := oldLastLine left @ oldLastLine bottom 				extent: 0@(oldLastLine bottom - oldLastLine top).	"Even though we may be below the bottom of the container,	it is still necessary to compose the last line for consistency..."	self addNullLineWithIndex: index andRectangle: r.! !!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'nk 4/13/2004 15:38'!updateContents	"Update the receiver's contents"	| newString enablement nArgs |	((wordingProvider isNil) or: [wordingSelector isNil]) ifTrue: [^ self].	nArgs := wordingSelector numArgs.	newString := nArgs == 0		ifTrue:			[wordingProvider perform: wordingSelector]		ifFalse:			[(nArgs == 1 and: [wordingArgument notNil])				ifTrue:					[wordingProvider perform: wordingSelector with: wordingArgument]				ifFalse:					[nArgs == arguments size ifTrue:						[wordingProvider perform: wordingSelector withArguments: arguments]]].	newString = (self contentString ifNil: [ contents ])		ifFalse: [self contents: newString.			MenuIcons decorateMenu: owner ].	enablementSelector ifNotNil:		[(enablement := self enablement) == isEnabled 			ifFalse:	[self isEnabled: enablement]]! !!MorphicModel methodsFor: 'compilation' stamp: ''!compilePropagationMethods	| varName |	(self class organization listAtCategoryNamed: 'private - propagation' asSymbol)		do: [:sel | varName := sel allButLast.			model class compilePropagationForVarName: varName slotName: slotName]! !!FileList methodsFor: 'initialization' stamp: 'sw 2/17/2002 05:39'!optionalButtonView	"Answer a view of optional buttons"	| aView bHeight windowWidth offset previousView aButtonView wid services sel allServices |	aView := View new model: self.	bHeight := self optionalButtonHeight.	windowWidth := 120.	aView window: (0 @ 0 extent: windowWidth @ bHeight).	offset := 0.	allServices := self universalButtonServices.	services := allServices copyFrom: 1 to: (allServices size min: 5).	previousView := nil.	services		do: [:service | sel := service selector.		aButtonView := sel asString numArgs = 0			ifTrue: [PluggableButtonView					on: service provider					getState: (service extraSelector == #none							ifFalse: [service extraSelector])					action: sel]			ifFalse: [PluggableButtonView					on: service provider					getState: (service extraSelector == #none							ifFalse: [service extraSelector])					action: sel					getArguments: #fullName					from: self].		service selector = services last selector			ifTrue: [wid := windowWidth - offset]			ifFalse: [aButtonView					borderWidthLeft: 0					right: 1					top: 0					bottom: 0.				wid := windowWidth // services size - 2].		aButtonView label: service buttonLabel asParagraph;			window: (offset @ 0 extent: wid @ bHeight).		offset := offset + wid.		service selector = services first selector			ifTrue: [aView addSubView: aButtonView]			ifFalse: [aView addSubView: aButtonView toRightOf: previousView].		previousView := aButtonView].	^ aView! !!ScrollPane methodsFor: 'event handling' stamp: 'sps 3/9/2004 17:52'!mouseLeave: event	hasFocus := false.	retractableScrollBar ifTrue: [self hideScrollBars].	(owner isSystemWindow) ifTrue: [owner paneTransition: event]! !!ShadowDrawingCanvas methodsFor: 'accessing' stamp: 'ar 8/8/2001 14:14'!shadowColor: aColor	shadowColor := aColor! !!ScrollPane methodsFor: 'menu' stamp: 'sps 3/9/2004 17:47'!retractableOrNot	"Change scroll bar operation"	retractableScrollBar := retractableScrollBar not.	retractableScrollBar		ifTrue: [self removeMorph: scrollBar]		ifFalse: [(submorphs includes: scrollBar) 					ifFalse: 						[self privateAddMorph: scrollBar atIndex: 1.						self privateAddMorph: hScrollBar atIndex: 1]].	self extent: self extent.! !!ScrollBar methodsFor: 'geometry' stamp: 'dew 2/27/1999 18:22'!expandSlider	"Compute the new size of the slider (use the old sliderThickness as a minimum)."	| r |	r := self totalSliderArea.	slider extent: (bounds isWide		ifTrue: [((r width * interval) asInteger max: self sliderThickness) @ slider height]		ifFalse: [slider width @ ((r height * interval) asInteger max: self sliderThickness)])! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'sw 10/30/2000 11:09'!showingMethodPane	"Answer whether the receiver is currently showing the textual method pane"	^ showingMethodPane ifNil: [showingMethodPane := false]! !!StandardScriptingSystem methodsFor: 'form dictionary' stamp: 'di 2/3/2001 20:10'!deletePrivateGraphics: nameList afterStoringToFileNamed: aFileName	"This method is used to strip private graphics from the FormDictionary and store them on a file of the given name"	|  replacement toRemove aReferenceStream keySymbol |	toRemove := Dictionary new.	replacement := FormDictionary at: #Gets.	nameList do:		[:aKey |			keySymbol := aKey asSymbol.			(toRemove at: keySymbol put: (self formAtKey: keySymbol)).			FormDictionary at: keySymbol put: replacement].	aReferenceStream := ReferenceStream fileNamed: aFileName.	aReferenceStream nextPut: toRemove.	aReferenceStream close! !!TransformMorph methodsFor: 'layout' stamp: 'nk 4/12/2002 14:03'!submorphBounds	"Answer, in owner coordinates, the bounds of my visible submorphs, or my bounds"	| box |	box := self localVisibleSubmorphBounds.	^(box ifNotNil: [ transform localBoundsToGlobal: box ] ifNil: [ self bounds ]) truncated.! !!SystemWindow methodsFor: 'open/close' stamp: 'di 10/28/1999 13:15'!delete	| thisWorld sketchEditor aPaintBox |	self mustNotClose ifTrue: [^ self].	model okToChange ifFalse: [^ self].	thisWorld := self world.	sketchEditor := self extantSketchEditor.	self isFlexed		ifTrue: [owner delete]		ifFalse: [super delete].	model windowIsClosing; release.	model := nil.	sketchEditor ifNotNil:		[sketchEditor deleteSelfAndSubordinates.		thisWorld notNil ifTrue:			[(aPaintBox := thisWorld paintBoxOrNil) ifNotNil: [aPaintBox delete]]].			SystemWindow noteTopWindowIn: thisWorld.! !!Morph methodsFor: 'layout' stamp: 'ar 1/1/2002 20:00'!fullBounds	"Return the bounding box of the receiver and all its children. Recompute the layout if necessary."	fullBounds ifNotNil:[^fullBounds].	"Errors at this point can be critical so make sure we catch 'em all right"	[self doLayoutIn: self layoutBounds] on: Error do:[:ex|		"This should do it unless you don't screw up the bounds"		fullBounds := bounds.		ex pass].	^fullBounds! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'ar 11/4/2000 23:21'!setPasswordQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	| pane |	self setQuery: queryString 		initialAnswer: initialAnswer 		answerHeight: answerHeight 		acceptOnCR: acceptBoolean.	pane := self submorphNamed: 'textPane'.	pane font: (StrikeFont passwordFontSize: 12).! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 16:14'!vScrollBarHeight	| h |	h := bounds height - (2 * borderWidth).	(retractableScrollBar not and: [self hIsScrollbarNeeded]) 		ifTrue:[ h := h - self scrollBarThickness. ].		^h! !!UpdatingMenuItemMorph methodsFor: 'wording' stamp: 'sw 11/6/2000 09:55'!wordingArgument: anArgument	"Set the receiver's wordingArgument as indicated"	wordingArgument := anArgument! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!toggleDeleteOnMouseUp	deleteOnMouseUp := deleteOnMouseUp not.! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/2/2000 10:12'!addProjectNameMorphFiller	| m |	self removeAllMorphs.	m := AlignmentMorph newRow color: Color transparent.	self addMorphBack: m.	m		on: #mouseDown send: #editTheName: to: self;		on: #mouseUp send: #yourself to: self.	self updateNamePosition.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/10/2000 14:26'!invokeMetaMenuAt: aPoint event: evt	| menu morphs target |	menu := CustomMenu new.	morphs := self morphsAt: aPoint.	(morphs includes: self) ifFalse:[morphs := morphs copyWith: self].	morphs size = 1 ifTrue:[morphs first invokeMetaMenu: evt].	morphs do: [:m | 		menu add: (m knownName ifNil:[m class name asString]) action: m].	target := menu startUp.	target ifNil:[^self].	target invokeMetaMenu: evt! !!NewParagraph methodsFor: 'access' stamp: 'di 10/23/97 19:33'!textStyle: aTextStyle 	"Set the style by which the receiver should display its text."	textStyle := aTextStyle! !!PluggableTabButtonMorph methodsFor: 'access' stamp: 'KLC 1/22/2004 14:25'!active	active ifNil: [ active := false ].	^ active! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 6/16/1999 11:16'!deleteBackgroundPainting	backgroundMorph		ifNotNil:			[backgroundMorph delete.			backgroundMorph := nil]		ifNil:			[self inform: 'There is presently nobackground paintingto delete.']! !!PasteUpMorph methodsFor: 'Nebraska' stamp: 'ar 10/26/2000 15:19'!transferRemoteServerFrom: aWorld	"Transfer the remote server which was associated with aWorld (if any) to the receiver"	| server |	(aWorld notNil and:[aWorld isMorph and:[aWorld isWorldMorph]]) ifFalse:[^self].	server := aWorld remoteServer.	server ifNotNil:[		self remoteServer: server.		server clients do:[:each| self addRemoteClient: each].		self primaryHand			userInitials: (aWorld primaryHand userInitials)			andPicture: (aWorld primaryHand userPicture).		aWorld primaryHand userInitials: '' andPicture: nil].	aWorld releaseRemoteServer.! !!MouseEvent methodsFor: 'initialize' stamp: 'ar 10/25/2000 22:08'!type: eventType readFrom: aStream	| x y |	type := eventType.	timeStamp := Integer readFrom: aStream.	aStream skip: 1.	x := Integer readFrom: aStream.	aStream skip: 1.	y := Integer readFrom: aStream.	aStream skip: 1.	buttons := Integer readFrom: aStream.	position := x@y.! !!PluggableMultiColumnListMorphByItem methodsFor: 'model access' stamp: 'ls 8/19/2001 14:57'!changeModelSelection: anInteger 	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector		ifNotNil: [item := anInteger = 0						ifFalse: [list first at: anInteger].			model perform: setIndexSelector with: item].	self update: getIndexSelector! !!MorphicModel methodsFor: 'geometry' stamp: ''!recomputeBounds	| bnds |	bnds := submorphs first bounds.	bounds := bnds origin corner: bnds corner. "copy it!!"	fullBounds := nil.	bounds := self fullBounds.! !!HandMorph methodsFor: 'objects from disk' stamp: 'ar 10/5/2000 19:48'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	(refStrm project world hands includes: self) ifTrue: [		^ self].	"owned by the project"	dp := DiskProxy global: #World selector: #primaryHand args: #().	refStrm replace: self with: dp.	^ dp	"Note, when this file is loaded in an MVC project, this will return nil.  The MenuItemMorph that has this in a field will have that item not work.  Maybe warn the user at load time?"! !!Morph methodsFor: 'undo' stamp: 'ar 8/31/2000 23:15'!commandHistory	"Return the command history for the receiver"	| w |	(w := self world) ifNotNil:[^w commandHistory].	(w := self currentWorld) ifNotNil:[^w commandHistory].	^CommandHistory new. "won't really record anything but prevent breaking things"! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/5/2000 16:50'!subclassMorph	"Create a new subclass of this morph's class and make this morph be an instance of it."	| oldClass newClassName newClass newMorph |	oldClass := self class.	newClassName := FillInTheBlank		request: 'Please give this new class a name'		initialAnswer: oldClass name.	newClassName = '' ifTrue: [^ self].	(Smalltalk includesKey: newClassName)		ifTrue: [^ self inform: 'Sorry, there is already a class of that name'].	newClass := oldClass subclass: newClassName asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: oldClass category asString.	newMorph := self as: newClass.	self become: newMorph.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!rubberBandCells: aBool	rubberBandCells := aBool.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/2002 17:55'!decimalPlaces	"Answer the number of decimal places to show."	| places |	(places := self valueOfProperty: #decimalPlaces) ifNotNil: [^ places].	self setProperty: #decimalPlaces toValue: (places := Utilities decimalPlacesForFloatPrecision: self floatPrecision).	^ places! !!TextMorph methodsFor: 'private' stamp: 'di 7/28/2001 10:33'!predecessor: pred successor: succ	"Private -- for use only in morphic duplication"	predecessor := pred.	successor := succ.! !!MenuMorph methodsFor: 'accessing' stamp: 'nk 3/31/2002 15:13'!stayUp: aBoolean	stayUp := aBoolean.	aBoolean ifTrue: [ self removeStayUpBox ].! !!MorphicUnknownEvent methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		type ifNil: [type := #startSound].	source ifNil: [source := varDict at: 'sourceHand'].	argument ifNil: [argument := varDict at: 'sound' ifAbsent: [nil]].	"???"	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!StringMorphAttributeScanner methodsFor: 'scanning' stamp: 'nk 2/26/2004 12:34'!textColor: anObject	"Set the value of textColor"	textColor := anObject! !!Morph methodsFor: 'drawing' stamp: 'sw 6/4/2000 22:02'!boundingBoxOfSubmorphs	| aBox |	aBox := bounds origin extent: self minimumExtent.  "so won't end up with something empty"	submorphs do:		[:m | m visible ifTrue: [aBox := aBox quickMerge: m fullBounds]].	^ aBox! !!Morph methodsFor: 'events-processing' stamp: 'di 12/12/2000 14:39'!handleDropMorph: anEvent	"Handle a dropping morph."	| aMorph localPt |	aMorph := anEvent contents.	"Do a symmetric check if both morphs like each other"	((self wantsDroppedMorph: aMorph event: anEvent)	"I want her"		and: [aMorph wantsToBeDroppedInto: self])		"she wants me"		ifFalse: [aMorph removeProperty: #undoGrabCommand.				^ self].	anEvent wasHandled: true.	"Transform the morph into the receiver's coordinate frame. This is currently incomplete since it only takes the offset into account where it really should take the entire transform."	localPt := (self transformedFrom: anEvent hand world) "full transform down"				globalPointToLocal: aMorph referencePosition.	aMorph referencePosition: localPt.	self acceptDroppingMorph: aMorph event: anEvent.	aMorph justDroppedInto: self event: anEvent.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'ar 1/15/2001 18:36'!pasteRecent	"Paste an item chosen from RecentClippings."	| clipping |	(clipping := Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self handleEdit: [textMorph editor paste]! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!cellSpacing: aSymbol	cellSpacing := aSymbol.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 10/11/1999 08:45'!initForKeystrokes	lastKeystrokeTime := 0.	lastKeystrokes := ''! !!FileList2 methodsFor: 'initialization' stamp: 'mir 2/6/2004 17:25'!limitedSuperSwikiPublishDirectoryList	| dirList localDirName localDir |	dirList := self publishingServers.	ServerDirectory localProjectDirectories do: [ :each |		dirList add: (FileDirectoryWrapper with: each name: each localName model: self)].	"Make sure the following are always shown, but not twice"	localDirName := SecurityManager default untrustedUserDirectory.	localDir := FileDirectory on: localDirName.	((ServerDirectory localProjectDirectories collect: [:each | each pathName]) includes: localDirName)			ifFalse: [dirList add: (FileDirectoryWrapper with: localDir name: localDir localName model: self)].	FileDirectory default pathName = localDirName			ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	^dirList! !!Morph methodsFor: 'structure' stamp: 'dgd 8/28/2004 18:43'!pasteUpMorphHandlingTabAmongFields	"Answer the nearest PasteUpMorph in my owner chain that has the tabAmongFields property, or nil if none"	| aPasteUp |	aPasteUp := self owner.	[aPasteUp notNil] whileTrue:		[aPasteUp tabAmongFields ifTrue:			[^ aPasteUp].		aPasteUp := aPasteUp owner].	^ nil! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeNoArrows	arrows := #none.	self computeBounds! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 7/23/2002 16:19'!findAPreferencesPanel: evt	"Locate a Preferences Panel, open it, and bring it to the front.  Create one if necessary"	| aPanel |	self findAWindowSatisfying:		[:aWindow | aWindow model isKindOf: PreferencesPanel] orMakeOneUsing:			[aPanel := Preferences preferencesControlPanel.			"Note -- we don't really want the openInHand -- but owing to some annoying			difficulty, if we don't, we get the wrong width.  Somebody please clean this up"			^ aPanel openInHand]! !!EditCommand methodsFor: 'accessors' stamp: 'sps 1/5/2002 16:36'!newTextInterval: anInterval	^newText := anInterval! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'ar 12/17/2001 01:59'!composeEachRectangleIn: rectangles	| myLine lastChar |	1 to: rectangles size do: [:i | 		currCharIndex <= theText size ifFalse: [^false].		myLine := scanner 			composeFrom: currCharIndex 			inRectangle: (rectangles at: i)							firstLine: isFirstLine 			leftSide: i=1 			rightSide: i=rectangles size.		lines addLast: myLine.		actualHeight := actualHeight max: myLine lineHeight.  "includes font changes"		currCharIndex := myLine last + 1.		lastChar := theText at: myLine last.		lastChar = Character cr ifTrue: [^#cr].		wantsColumnBreaks ifTrue: [			lastChar = TextComposer characterForColumnBreak ifTrue: [^#columnBreak].		].	].	^false! !!PolygonMorph methodsFor: 'editing' stamp: 'wiz 2/8/2006 18:25'!newVertex: ix event: evt fromHandle: handle	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	"(self hasProperty: #noNewVertices) ifFalse:		[pt := evt cursorPoint.		self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).		evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1)]"	"modified to remove now vestigial test. see PolygonMorph class>>arrowprototype"	pt := evt cursorPoint.	self  insertVertexAt: ix put:  pt .	evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1)! !!TextMorph methodsFor: 'initialization' stamp: 'di 11/17/2001 15:34'!setTextStyle: aTextStyle	textStyle := aTextStyle.	self releaseCachedState; changed! !!PolygonMorph methodsFor: 'attachments' stamp: 'nk 7/3/2003 14:42'!totalLength	"Answer the full length of my segments. Can take a long time if I'm curved."	| length |	length := 0.	self lineSegmentsDo: [ :a :b | length := length + (a dist: b) ].	^length.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 11:31'!targetMorph: aMorph	targetMorph := aMorph! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/8/97 15:31'!compose: t style: ts from: startingIndex in: textContainer	text := t.	textStyle := ts.	firstCharacterIndex := startingIndex.	offsetToEnd := text size - firstCharacterIndex.	container := textContainer.	self composeAll! !!StepMessage methodsFor: 'accessing' stamp: 'ar 10/22/2000 16:56'!stepTime: aNumber	"Set the step time for this message. If nil, the receiver of the message will be asked for its #stepTime."	stepTime := aNumber! !!TextMorph methodsFor: 'accessing' stamp: 'sw 8/10/2004 00:53'!getLastCharacter	"obtain the last character from the receiver if it is empty, return a black dot"	| aString |	^ (aString := text string) size > 0 ifTrue: [aString last asString] ifFalse: ['']! !!HandMorph methodsFor: 'initialization' stamp: 'ar 10/26/2000 14:58'!initialize	super initialize.	self initForEvents.	keyboardFocus := nil.	mouseFocus := nil.	bounds := 0@0 extent: Cursor normal extent.	userInitials := ''.	damageRecorder := DamageRecorder new.	cachedCanvasHasHoles := false.	temporaryCursor := temporaryCursorOffset := nil.	self initForEvents.! !!PolygonMorph methodsFor: 'private' stamp: 'di 10/3/2000 09:02'!arrowBoundsAt: endPoint from: priorPoint 	"Answer a triangle oriented along the line from priorPoint to endPoint."	| d v angle wingBase arrowSpec length width |	v := endPoint - priorPoint.	angle := v degrees.	d := borderWidth max: 1.	arrowSpec := self valueOfProperty: #arrowSpec ifAbsent: [5@4].	length := arrowSpec x abs.  width := arrowSpec y abs.	wingBase := endPoint + (Point r: d * length degrees: angle + 180.0).	arrowSpec x >= 0		ifTrue: [^ {	endPoint.					wingBase + (Point r: d * width degrees: angle + 125.0).					wingBase + (Point r: d * width degrees: angle - 125.0) }]		ifFalse: ["Negative length means concave base."				^ {	endPoint.					wingBase + (Point r: d * width degrees: angle + 125.0).					wingBase.					wingBase + (Point r: d * width degrees: angle - 125.0) }]! !!Morph methodsFor: 'private' stamp: 'md 2/27/2006 08:55'!privateMoveBy: delta 	"Private!! Use 'position:' instead."	| fill |	extension ifNotNil: [extension player				ifNotNil: ["Most cases eliminated fast by above test"					self getPenDown						ifTrue: ["If this is a costume for a player with its 							pen down, draw a line."							self moveWithPenDownBy: delta]]].	bounds := bounds translateBy: delta.	fullBounds ifNotNil: [fullBounds := fullBounds translateBy: delta].	fill := self fillStyle.	fill isOrientedFill ifTrue: [fill origin: fill origin + delta]! !!SystemWindowWithButton methodsFor: 'as yet unclassified' stamp: 'sw 2/15/1999 22:41'!buttonInTitle: aButton	buttonInTitle := aButton.	self addMorphFront: aButton! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:01'!balloonText: aStringOrNil	balloonText := aStringOrNil! !!PluggableListMorphByItem methodsFor: 'model access' stamp: 'ls 8/19/2001 15:58'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item := (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].	self update: getIndexSelector.! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/9/2000 13:50'!viewByIcon	"The receiver has been being viewed in some constrained layout view; now restore it to its normal x-y-layout view"	|  oldSubs |	self showingListView		ifTrue:			[oldSubs := submorphs.			self removeAllMorphs.			self layoutPolicy: nil.			oldSubs do:				[:aSubmorph |					self addMorphBack:  aSubmorph objectRepresented].			self restoreBoundsOfSubmorphs.			self removeProperty: #showingListView]		ifFalse:			[self autoLineLayout == true ifTrue: [self toggleAutoLineLayout]]! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:43'!isSteppingSelector: aSelector	"Return true if the receiver is currently stepping in its world"	| aWorld |	^ (aWorld := self world)		ifNil:		[false]		ifNotNil:	[aWorld isStepping: self selector: aSelector]! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!topFraction: aNumber	topFraction := aNumber! !!ImageMorph methodsFor: 'accessing' stamp: 'ar 12/12/2001 01:11'!borderWidth: bw	| newExtent |	newExtent := 2 * bw + image extent.	bounds extent = newExtent ifFalse:[super extent: newExtent].	super borderWidth: bw! !!SimpleHierarchicalListMorph methodsFor: 'private' stamp: 'RAA 7/30/2000 19:15'!addSubmorphsAfter: parentMorph fromCollection: aCollection allowSorting: sortBoolean	| priorMorph morphList newCollection |	priorMorph := nil.	newCollection := (sortBoolean and: [sortingSelector notNil]) ifTrue: [		(aCollection asSortedCollection: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]) asOrderedCollection	] ifFalse: [		aCollection	].	morphList := OrderedCollection new.	newCollection do: [:item | 		priorMorph := self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: parentMorph indentLevel + 1.		morphList add: priorMorph.	].	scroller addAllMorphs: morphList after: parentMorph.	^morphList	! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:13'!toggleAutomaticViewing	| current |	current := self automaticViewing.	current		ifTrue:			[self removeProperty: #automaticViewing]		ifFalse:			[self setProperty: #automaticViewing toValue: true]! !!MenuMorph methodsFor: 'private' stamp: 'sw 5/1/2002 01:39'!positionAt: aPoint relativeTo: aMenuItem inWorld: aWorld	"Note: items may not be laid out yet (I found them all to be at 0@0),  	so we have to add up heights of items above the selected item."	| i yOffset sub delta |		self fullBounds. "force layout"	i := 0.	yOffset := 0.	[(sub := self submorphs at: (i := i + 1)) == aMenuItem]		whileFalse: [yOffset := yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	"If it doesn't fit, show it to the left, not to the right of the hand."	self right > aWorld worldBounds right		ifTrue:			[self right: aPoint x + 1].	"Make sure that the menu fits in the world."	delta := self bounds amountToTranslateWithin:		(aWorld worldBounds withHeight: ((aWorld worldBounds height - 18) max: (ActiveHand position y) + 1)).	delta = (0 @ 0) ifFalse: [self position: self position + delta]! !!TextMorph methodsFor: 'private' stamp: 'di 10/24/97 11:35'!text: t textStyle: s	"Private -- for use only in morphic duplication"	text := t.	textStyle := s.	paragraph ifNotNil: [paragraph textStyle: s]! !!EllipseMidpointTracer methodsFor: 'computing' stamp: 'ar 6/28/1999 15:35'!stepInY	"Step to the next y value"	inFirstRegion ifTrue:[		"In the upper region we must step until we reach the next y value"		[(aSquared * (y-0.5)) > (bSquared * (x+1))] whileTrue:[			d1 < 0.0				ifTrue:[d1 := d1 + (bSquared * (2*x+3)).						x := x + 1]				ifFalse:[d1 := d1 + (bSquared * (2*x+3)) + (aSquared * (-2*y+2)).						y := y - 1.						^x := x + 1]].		"Stepping into second region"		d2 := (bSquared * (x + 0.5) squared) + (aSquared * (y-1) squared) - (aSquared * bSquared).		inFirstRegion := false.	].	"In the lower region each step is a y-step"	d2 < 0.0		ifTrue:[d2 := d2 + (bSquared * (2*x+2)) + (aSquared * (-2*y+3)).				x := x + 1]		ifFalse:[d2 := d2 + (aSquared * (-2*y+3))].	y := y - 1.	^x! !!TransformMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:39'!initialize	"initialize the state of the receiver"	super initialize.	""		smoothing := 1.	transform := MorphicTransform identity! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nk 1/6/2004 12:39'!grabFloodFromScreen: evt	"Allow the user to plant a flood seed on the Display, and create a new drawing morph from the resulting region. Attach the result to the hand."	| screenForm exterior p1 box |	Cursor crossHair showWhile: [p1 := Sensor waitButton].	box := Display floodFill: Color transparent at: p1.	exterior := ((Display copy: box) makeBWForm: Color transparent) reverse.	self world invalidRect: box; displayWorldSafely.	(box area > (Display boundingBox area // 2))		ifTrue: [^ PopUpMenu notify: 'Sorry, the region was too big'].	(exterior deepCopy reverse anyShapeFill reverse)  "save interior bits"		displayOn: exterior at: 0@0 rule: Form and.	screenForm := Form fromDisplay: box.	screenForm eraseShape: exterior.	screenForm isAllWhite ifFalse:		[evt hand attachMorph: (self drawingClass withForm: screenForm)]! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:10'!stopStepping: aMorph	"Remove the given morph from the step list."	lastStepMessage ifNotNil:[		(lastStepMessage receiver == aMorph) ifTrue:[lastStepMessage := nil]].	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph]).! !!MouseClickState methodsFor: 'event handling' stamp: 'nk 7/26/2004 10:21'!handleEvent: evt from: aHand	"Process the given mouse event to detect a click, double-click, or drag.	Return true if the event should be processed by the sender, false if it shouldn't.	NOTE: This method heavily relies on getting *all* mouse button events."	| localEvt timedOut isDrag |	timedOut := (evt timeStamp - firstClickTime) > dblClickTime.	localEvt := evt transformedBy: (clickClient transformedFrom: aHand owner).	isDrag := (localEvt position - firstClickDown position) r > dragThreshold.	clickState == #firstClickDown ifTrue: [		"Careful here - if we had a slow cycle we may have a timedOut mouseUp event"		(timedOut and:[localEvt isMouseUp not]) ifTrue:[			"timeout before #mouseUp -> keep waiting for drag if requested"			clickState := #firstClickTimedOut.			dragSelector ifNil:[				aHand resetClickState.				self doubleClickTimeout; click "***"].			^true].		localEvt isMouseUp ifTrue:[			(timedOut or:[dblClickSelector isNil]) ifTrue:[				self click.				aHand resetClickState.				^true].			"Otherwise transfer to #firstClickUp"			firstClickUp := evt copy.			clickState := #firstClickUp.			"If timedOut or the client's not interested in dbl clicks get outta here"			self click.			aHand handleEvent: firstClickUp.			^false].		isDrag ifTrue:["drag start"			self doubleClickTimeout. "***"			aHand resetClickState.			dragSelector "If no drag selector send #click instead"				ifNil: [self click]				ifNotNil: [self drag: firstClickDown].			^true].		^false].	clickState == #firstClickTimedOut ifTrue:[		localEvt isMouseUp ifTrue:["neither drag nor double click"			aHand resetClickState.			self doubleClickTimeout; click. "***"			^true].		isDrag ifTrue:["drag start"			aHand resetClickState.			self doubleClickTimeout; drag: firstClickDown. "***"			^true].		^false].	clickState = #firstClickUp ifTrue:[		(timedOut) ifTrue:[			"timed out after mouseUp - signal timeout and pass the event"			aHand resetClickState.			self doubleClickTimeout. "***"			^true].		localEvt isMouseDown ifTrue:["double click"			clickState := #secondClickDown.			^false]].	clickState == #secondClickDown ifTrue: [		timedOut ifTrue:[			"timed out after second mouseDown - pass event after signaling timeout"			aHand resetClickState.			self doubleClickTimeout. "***"			^true].		isDrag ifTrue: ["drag start"			self doubleClickTimeout. "***"			aHand resetClickState.			dragSelector "If no drag selector send #click instead"				ifNil: [self click]				ifNotNil: [self drag: firstClickDown].			^true].		localEvt isMouseUp ifTrue: ["double click"			aHand resetClickState.			self doubleClick.			^false]	].	^true! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 6/12/2001 05:23'!setDirectionFrom: aPoint	| delta degrees |	delta := (self transformFromWorld globalPointToLocal: aPoint) - self referencePosition.	degrees := delta degrees + 90.0.	self forwardDirection: (degrees \\ 360) rounded.! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/24/1998 14:45'!colorTransformBy: aColorTransform	aColorTransform ifNil:[^self].	colorTransform 		ifNil:[colorTransform := aColorTransform]		ifNotNil:[colorTransform := colorTransform composedWithLocal: aColorTransform]! !!FileList class methodsFor: 'instance creation' stamp: 'SD 11/8/2001 21:21'!openEditorOn: aFileStream editString: editString	"Open an editor on the given FileStream."	| fileModel topView fileContentsView |	Smalltalk isMorphic ifTrue: [^ (self openMorphOn: aFileStream editString: editString) openInWorld].	fileModel := FileList new setFileStream: aFileStream.	"closes the stream"	topView := StandardSystemView new.	topView		model: fileModel;		label: aFileStream fullName;		minimumSize: 180@120.	topView borderWidth: 1.	fileContentsView := PluggableTextView on: fileModel 		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 180@120).	topView addSubView: fileContentsView.	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	topView controller open.! !!PluggableTabButtonMorph methodsFor: 'precalculations' stamp: 'KLC 1/23/2004 14:46'!calculateArcLengths	| array radius |	radius := self cornerRadius.	array := Array new: radius.		1 to: radius do: [ :i | | x |		x := i - 0.5.		array at: i		 	put: (radius - ((2 * x * radius) - (x * x)) sqrt) asInteger].			self arcLengths: array! !!Morph methodsFor: 'private' stamp: 'sw 10/25/2000 06:11'!moveWithPenDownBy: delta	"If this is a costume for a player with its pen down, draw a line."	| trailMorph tfm start tfmEnd |	(trailMorph := self trailMorph) ifNotNil:		[tfm := self owner transformFrom: trailMorph.		start :=  self referencePosition.		trailMorph batchPenTrails			ifTrue: [trailMorph notePenDown: true								forPlayer: self player								at: (tfm localPointToGlobal: start)]			ifFalse: [trailMorph drawPenTrailFor: self								from: (tfm localPointToGlobal: start)								to: (tfmEnd := tfm localPointToGlobal: start + delta).					trailMorph noteNewLocation: tfmEnd forPlayer: self player]]! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 4/10/2004 00:59'!phrase: aPhraseTileMorph	"Make the receiver be a Scriptor for a new script whose initial contents is the given phrase."	| aHolder |	firstTileRow := 2.	aHolder := AlignmentMorph newRow.	aHolder beTransparent; layoutInset: 0.	aHolder addMorphBack: aPhraseTileMorph.	self addMorphBack: aHolder.	self install! !!HandMorph methodsFor: 'balloon help' stamp: 'sw 10/15/2002 20:01'!deleteBalloonTarget: aMorph	"Delete any existing balloon help.  This is now done unconditionally, whether or not the morph supplied is the same as the current balloon target"		self balloonHelp: nil"	| h |	h := self balloonHelp ifNil: [^ self].	h balloonOwner == aMorph ifTrue: [self balloonHelp: nil]"! !!Morph methodsFor: 'printing' stamp: 'bf 7/17/2003 12:53'!clipText	"Copy the text in the receiver or in its submorphs to the clipboard"	| content |	"My own text"	content := self userString.	"Or in my submorphs"	content ifNil: [		| list |		list := self allStringsAfter: nil.		list notEmpty ifTrue: [			content := String streamContents: [:stream |				list do: [:each | stream nextPutAll: each; cr]]]].	"Did we find something?"	content		ifNil: [self flash "provide feedback"]		ifNotNil: [Clipboard clipboardText: content].! !!TextMorphForEditView methodsFor: 'initialization' stamp: 'di 9/11/1998 15:43'!initialize	super initialize.	acceptOnCR := false! !!TextMorph methodsFor: 'objects from disk' stamp: 'tk 11/29/2004 16:54'!fixUponLoad: aProject seg: anImageSegment	"We are in an old project that is being loaded from disk.Fix up conventions that have changed."	| substituteFont |	substituteFont := aProject projectParameters at:#substitutedFont ifAbsent: [#none].	(substituteFont ~~ #none and: [self textStyle fontArrayincludes: substituteFont])			ifTrue: [ self fit ].	^ super fixUponLoad: aProject seg: anImageSegment! !!Morph methodsFor: 'private' stamp: 'tk 8/30/1998 09:58'!privateFullBounds: boundsRect	"Private!! Computed automatically."	fullBounds := boundsRect.! !!ComponentLikeModel methodsFor: 'components' stamp: 'di 4/26/1998 10:40'!nameMeIn: aWorld	| stem otherNames i partName className |	className := self class name.	stem := className.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem := stem copyFrom: 1 to: stem size - 5].	stem := stem first asLowercase asString , stem allButFirst.	otherNames := Set newFrom: aWorld allKnownNames.	i := 1.	[otherNames includes: (partName := stem , i printString)]		whileTrue: [i := i + 1].	self setNamePropertyTo: partName! !!HaloMorph methodsFor: 'dropping/grabbing' stamp: 'sw 10/2/2001 22:09'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	| itsOwner |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dragHandle.	positionOffset := dragHandle center - (target point: target position in: owner).	 ((itsOwner := target topRendererOrSelf owner) notNil and:			[itsOwner automaticViewing]) ifTrue:				[target openViewerForArgument]! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:31'!readContentsEUCJP	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: EUCJPTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 5/14/2000 15:50'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	rect := r translateBy: origin.	"draw the border of the rectangle"	borderColor isTransparent ifFalse:[		self setFillColor: borderColor.		(r area > 10000 or: [fillColor isTranslucent]) ifTrue: [			port frameRect: rect borderWidth: borderWidth.		] ifFalse: ["for small rectangles, it's faster to fill the entire outer rectangle					than to compute and fill the border rects"					port fillRect: rect offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse:		[self setFillColor: fillColor.		port fillRect: (rect insetBy: borderWidth) offset: origin].! !!MouseMoveEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:55'!setType: evtType startPoint: evtStart endPoint: evtEnd trail: evtTrail buttons: evtButtons hand: evtHand stamp: stamp	type := evtType.	startPoint := evtStart.	position := evtEnd.	trail := evtTrail.	buttons := evtButtons.	source := evtHand.	wasHandled := false.	timeStamp := stamp.! !!StringMorph methodsFor: 'parts bin' stamp: 'dgd 2/14/2003 21:58'!initializeToStandAlone	super initializeToStandAlone.		font := nil.	emphasis := 0.	hasFocus := false.	self contents: 'String: Shift-click on me to edit'! !!MenuMorph methodsFor: 'construction' stamp: 'sw 11/6/2000 13:39'!addUpdating: wordingSelector enablementSelector: enablementSelector target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  In this variant, the wording of the menu item is obtained by sending the wordingSelector to the target, and the optional enablementSelector determines whether or not the item should be enabled.  Answer the item itself."	| item |	item := UpdatingMenuItemMorph new		target: target;		selector: aSymbol;		wordingProvider: target wordingSelector: wordingSelector;		enablementSelector: enablementSelector;		arguments: argList asArray.	self addMorphBack: item.	^ item! !!PolygonMorph methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		smoothCurve ifNil: [smoothCurve := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PluggableListMorph methodsFor: 'initialization' stamp: 'ls 2/9/2002 01:03'!getListSelector: sel	"Set the receiver's getListSelector as indicated, and trigger a recomputation of the list"	getListSelector := sel.	self changed.	self updateList.! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 3/22/2000 14:28'!isStepping	"Return true if the receiver is currently stepping in its world"	| aWorld |	^ (aWorld := self world)		ifNil:		[false]		ifNotNil:	[aWorld isStepping: self]! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addItem	| string sel |	string := FillInTheBlank request: 'Label for new item?'.	string isEmpty ifTrue: [^ self].	sel := FillInTheBlank request: 'Selector?'.	sel isEmpty ifFalse: [sel := sel asSymbol].	self add: string action: sel.! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/26/2000 00:44'!convertObsolete: anEvent	"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	| type cursorPoint buttons keyValue sourceHand |	type := anEvent type.	cursorPoint := anEvent cursorPoint.	buttons := anEvent buttons.	keyValue := anEvent keyValue.	sourceHand := anEvent hand.	type == #mouseMove ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: cursorPoint			endPoint: cursorPoint			trail: #() 			buttons: buttons 			hand: sourceHand 			stamp: nil].	(type == #mouseDown) | (type == #mouseUp) ifTrue:[			^MouseButtonEvent new				setType: type				position: cursorPoint				which: 0				buttons: buttons				hand: sourceHand				stamp: nil].	(type == #keystroke) | (type == #keyDown) | (type == #keyUp) ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: cursorPoint			keyValue: keyValue			hand: sourceHand			stamp: nil].	^nil! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:35'!computeFramedColors	| base light dark w hw colorArray param |	base := self color asColor.	light := Color white.	dark := Color black.	w := self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w := w asInteger.	w = 1 ifTrue:[^{base mixed: 0.5 with: light. base mixed: 0.5 with: dark}].	colorArray := Array new: w.	hw := w // 2.	"brighten"	0 to: hw-1 do:[:i|		param := 0.5 + (i asFloat / hw * 0.5).		colorArray at: i+1 put: (base mixed: param with: light). "brighten"		colorArray at: w-i put: (base mixed: param with: dark). "darken"	].	w odd ifTrue:[colorArray at: hw+1 put: base].	^colorArray, colorArray! !!BalloonCanvas methodsFor: 'private' stamp: 'nk 5/1/2004 12:54'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	| warp dstRect srcQuad dstOffset center |	(self ifNoTransformWithIn: sourceRect) & false		ifTrue:[^super image: aForm at: aPoint sourceRect: sourceRect rule: rule].	dstRect := (transform localBoundsToGlobal: (aForm boundingBox translateBy: aPoint)).	dstOffset := 0@0. "dstRect origin."	"dstRect := 0@0 corner: dstRect extent."	center := 0@0."transform globalPointToLocal: dstRect origin."	srcQuad := transform globalPointsToLocal: (dstRect innerCorners).	srcQuad := srcQuad collect:[:pt| pt - aPoint].	warp := (WarpBlt current toForm: form)			sourceForm: aForm;			cellSize: 2;  "installs a new colormap if cellSize > 1"			combinationRule: Form over.	warp copyQuad: srcQuad toRect: (dstRect translateBy: dstOffset).	self frameRectangle: (aForm boundingBox translateBy: aPoint) color: Color green.	"... TODO ... create a bitmap fill style from the form and use it for a simple rectangle."! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 22:55'!hasEditingConflicts: aBoolean	hasEditingConflicts := aBoolean! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:31'!defineApplicationView	| r |	r := Rectangle fromUser.	self 		setProperty: #applicationViewBounds 		toValue: ((self transformFromOutermostWorld) globalBoundsToLocal: r) truncated ! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 6/16/2000 13:01'!optionalButtonSpecs: anArray	optionalButtonSpecs := anArray! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'mdr 12/19/2001 10:48'!boundsChangedFrom: oldBounds to: newBounds	oldBounds extent = newBounds extent ifFalse:[		transform := transform composedWithGlobal:			(MatrixTransform2x3 withOffset: oldBounds origin negated).		transform := transform composedWithGlobal:			(MatrixTransform2x3 withScale: newBounds extent / oldBounds extent).		transform := transform composedWithGlobal:			(MatrixTransform2x3 withOffset: newBounds origin).	].	transform offset: transform offset + (newBounds origin - oldBounds origin)! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/2/98 17:43'!shortcutCharacter: aCharacter 	"Set the character to be used as a keyboard shortcut for turning on this switch."	shortcutCharacter := aCharacter.! !!FileList class methodsFor: 'file reader registration' stamp: 'nk 12/7/2002 12:53'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| services suffix |	suffix := self suffixOf: fullName.	services := OrderedCollection new.	self registeredFileReaderClasses do: [:reader |		reader ifNotNil: [services addAll: (reader fileReaderServicesForFile: fullName suffix: suffix)]].	^ services! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 22:03'!newFileFrom: aDirectory	canTypeFileName := true.	^self makeFileMenuFor: aDirectory! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 11/2/2000 17:15'!addExtraSpace: aPoint	extraSpace 		ifNil:[extraSpace := aPoint]		ifNotNil:[extraSpace := extraSpace + aPoint]! !!FileList2 methodsFor: 'initialization' stamp: 'tpr 12/1/2003 17:14'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory := dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode := #date].	volList := Array with: '[]'.	directory ifNotNil: [		volList := volList, directory pathParts.  "Nesting suggestion from RvL"	].	volList := volList withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern.	directoryChangeBlock ifNotNil: [directoryChangeBlock value: directory].! !!TheWorldMenu methodsFor: 'construction' stamp: 'dgd 8/26/2003 21:23'!fillIn: aMenu from: dataForMenu	"A menu constructor utility by RAA.  dataForMenu is a list of items which mean:			nil							Indicates to add a line			first element is symbol		Add updating item with the symbol as the wording selector			second element is a list		second element has the receiver and selector			first element is a string		Add menu item with the string as its wording			second element is a list		second element has the receiver and selector			a third element exists		Use it as the balloon text			a fourth element exists		Use it as the enablement selector (updating case only)"	| item |	dataForMenu do: [ :itemData |		itemData ifNil: [aMenu addLine] ifNotNil:			[item := (itemData first isKindOf: Symbol)				ifTrue: 					[aMenu 						addUpdating: itemData first 						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}]				 ifFalse:					[aMenu 						add: itemData first translated						target: self 						selector: #doMenuItem:with: 						argumentList: {itemData second}].			itemData size >= 3 ifTrue:				[aMenu balloonTextForLastItem: itemData third translated.			itemData size >= 4 ifTrue:				[item enablementSelector: itemData fourth]]]].	^ aMenu! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 11/18/97 14:33'!toggleAutoCenter	autoCenter := autoCenter not.	autoCenter ifTrue: [self moveHandleToCenter].! !!ScrollPane methodsFor: 'access' stamp: 'ar 5/19/1999 18:06'!scroller: aTransformMorph	scroller ifNotNil:[scroller delete].	scroller := aTransformMorph.	self addMorph: scroller.	self resizeScroller.! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!cellSize: aPoint	cellSize := aPoint! !!FormCanvas methodsFor: 'drawing' stamp: 'yo 1/23/2003 17:50'!paragraph3: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner := (port clippedBy: (bounds translateBy: origin)) displayScannerForMulti: para		foreground: (self shadowColor ifNil:[c]) background: Color transparent		ignoreColorChanges: self shadowColor notNil.	para displayOnTest: (self copyClipRect: bounds) using: scanner at: origin+ bounds topLeft.! !!PasteUpMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:31'!initialize"initialize the state of the receiver"	super initialize.""	cursor := 1.	padding := 3.	self enableDragNDrop.	self isWorldMorph		ifTrue: [self setProperty: #automaticPhraseExpansion toValue: true].	self clipSubmorphs: true! !!Morph methodsFor: 'meta-actions' stamp: 'yo 2/12/2005 15:25'!indicateAllSiblings	"Indicate all the receiver and all its siblings by flashing momentarily."	| aPlayer allBoxes |	(aPlayer := self topRendererOrSelf player) belongsToUniClass ifFalse: [^ self "error: 'not uniclass'"].	allBoxes := aPlayer class allInstances		select: [:m | m costume world == ActiveWorld]		thenCollect: [:m | m costume boundsInWorld].	5 timesRepeat:		[Display flashAll: allBoxes andWait: 120]! !!PluggableListMorph methodsFor: 'menu' stamp: 'tk 12/10/2001 20:33'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| aMenu |	aMenu := super getMenu: shiftKeyState.	aMenu ifNotNil: [aMenu commandKeyHandler: self].	^ aMenu! !!HaloMorph methodsFor: 'stepping' stamp: 'nk 6/27/2003 12:32'!step	| newBounds |	target		ifNil: [^ self].	newBounds := target isWorldMorph				ifTrue: [target bounds]				ifFalse: [self localHaloBoundsFor: target renderedMorph].	newBounds = self bounds		ifTrue: [^ self].	newBounds extent = self bounds extent		ifTrue: [^ self position: newBounds origin].	growingOrRotating		ifFalse: [submorphs size > 1				ifTrue: [self addHandles]].	"adjust halo bounds if appropriate"	self bounds: newBounds! !!HandleMorph methodsFor: 'event handling' stamp: 'ar 9/15/2000 23:30'!keyStroke: evt	"Check for cursor keys"	| keyValue |	owner isHandMorph ifFalse:[^self].	keyValue := evt keyValue.	keyValue = 28 ifTrue:[^self position: self position - (1@0)].	keyValue = 29 ifTrue:[^self position: self position + (1@0)].	keyValue = 30 ifTrue:[^self position: self position - (0@1)].	keyValue = 31 ifTrue:[^self position: self position + (0@1)].	"Special case for return"	keyValue = 13 ifTrue:[		"Drop the receiver and be done"	self flag: #arNote. "Probably unnecessary"		owner releaseKeyboardFocus: self.		self delete].! !!Morph methodsFor: 'e-toy support' stamp: 'di 9/7/2000 20:44'!makeGraphPaperGrid: smallGrid background: backColor line: lineColor	| gridForm |	gridForm := self gridFormOrigin: 0@0 grid: smallGrid asPoint background: backColor line: lineColor.	self color: gridForm.	self world ifNotNil: [self world fullRepaintNeeded].	self changed: #newColor.  "propagate to view"! !!HaloMorph methodsFor: 'private' stamp: 'dgd 4/4/2006 16:58'!addNameBeneath: outerRectangle string: aString	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."	| nameMorph namePosition w |	w := self world ifNil:[target world].	nameMorph := NameStringInHalo contents: aString font: Preferences standardHaloLabelFont.	nameMorph wantsYellowButtonMenu: false.	nameMorph color: Color black.	nameMorph useStringFormat; target: innerTarget; putSelector: #tryToRenameTo:.	namePosition := outerRectangle bottomCenter -		((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).	nameMorph position: (namePosition min: w viewBox bottomRight - nameMorph extent y + 2).	nameMorph balloonTextSelector: #objectNameInHalo.	self addMorph: nameMorph.	^ nameMorph! !!SystemWindow class methodsFor: 'initializing' stamp: 'jrp 8/9/2005 19:22'!initialize	CollapseBoxImage := nil.	CloseBoxImage := nil.	ScriptingSystem saveForm: self expandBoxImage atKey: 'expandBox'.	ScriptingSystem saveForm: self menuBoxImage atKey: 'TinyMenu'! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 4/10/2001 18:56'!userScriptObject	"Answer the user-script object associated with the receiver"	| aPlayerScripted topEd |	aPlayerScripted := (topEd := self topEditor) playerScripted.	^ aPlayerScripted class userScriptForPlayer: aPlayerScripted selector: topEd scriptName ! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!target: newTarget	target := newTarget! !!PolygonMorph methodsFor: 'geometry' stamp: 'nk 4/27/2003 15:39'!nextDuplicateVertexIndex	vertices		doWithIndex: [:vert :index | ((index between: 2 and: vertices size - 1)					and: [| epsilon v1 v2 | 						v1 := vertices at: index - 1.						v2 := vertices at: index + 1.						epsilon := ((v1 x - v2 x) abs max: (v1 y - v2 y) abs)									// 32 max: 1.						vert							onLineFrom: v1							to: v2							within: epsilon])				ifTrue: [^ index]].	^ 0! !!Morph methodsFor: 'naming' stamp: 'gm 2/22/2003 13:16'!specialNameInModel	"Return the name for this morph in the underlying model or nil."	"Not an easy problem.  For now, take the first part of the mouseDownSelector symbol in my eventHandler (fillBrushMouseUp:morph: gives 'fillBrush').  5/26/97 tk"	| hh |	(self isMorphicModel) 		ifTrue: [^self slotName]		ifFalse: 			[self eventHandler ifNotNil: 					[self eventHandler mouseDownSelector ifNotNil: 							[hh := self eventHandler mouseDownSelector indexOfSubCollection: 'Mouse'										startingAt: 1.							hh > 0 								ifTrue: [^self eventHandler mouseDownSelector copyFrom: 1 to: hh - 1]].					self eventHandler mouseUpSelector ifNotNil: 							[hh := self eventHandler mouseUpSelector indexOfSubCollection: 'Mouse'										startingAt: 1.							hh > 0 ifTrue: [^self eventHandler mouseUpSelector copyFrom: 1 to: hh - 1]]]].	"	(self eventHandler mouseDownRecipient respondsTo: #nameFor:) ifTrue: [					^ self eventHandler mouseDownRecipient nameFor: self]]].	"	"myModel := self findA: MorphicModel.			myModel ifNotNil: [^ myModel slotName]"	^self world specialNameInModelFor: self! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 2/2/2006 02:39'!dismissViaHalo	"The user has clicked in the delete halo-handle.  This provides a hook in case some concomitant action should be taken, or if the particular morph is not one which should be put in the trash can, for example."	| cmd |	self setProperty: #lastPosition toValue: self positionInWorld.	self dismissMorph.	Preferences preserveTrash ifTrue: [ 		Preferences slideDismissalsToTrash			ifTrue:[self slideToTrash: nil]			ifFalse:[TrashCanMorph moveToTrash: self].	].	cmd := Command new cmdWording: 'dismiss ' translated, self externalName.	cmd undoTarget: ActiveWorld selector: #reintroduceIntoWorld: argument: self.	cmd redoTarget: ActiveWorld selector: #onceAgainDismiss: argument: self.	ActiveWorld rememberCommand: cmd! !!UpdatingStringMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 15:37'!veryDeepFixupWith: deepCopier	"If target field is weakly copied, fix it here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].! !!Morph methodsFor: 'drop shadows' stamp: 'ar 11/12/2000 18:58'!shadowPoint: newPoint	self changed.	self shadowOffset: newPoint - self center // 5.	fullBounds ifNotNil:[fullBounds := self privateFullBounds].	self changed.! !!CollapsedMorph methodsFor: 'collapse/expand' stamp: 'sw 4/9/2001 14:23'!uncollapseToHand	"Hand the uncollapsedMorph to the user, placing it in her hand, after remembering appropriate state for possible future use"	| nakedMorph |	nakedMorph := uncollapsedMorph.	uncollapsedMorph := nil.	nakedMorph setProperty: #collapsedPosition toValue: self position.	mustNotClose := false.  "so the delete will succeed"	self delete.	ActiveHand attachMorph: nakedMorph! !!JoystickMorph methodsFor: 'initialization' stamp: 'bf 9/5/2005 11:23'!initialize	super initialize.	xScale := 0.25.	yScale := 0.25.	radiusScale := 1.0.	lastAngle := 0.0.	autoCenter := true.	self form: ((Form extent: 55@55 depth: 8) fillColor: (Color r: 0.3 g: 0.2 b: 0.2)).	handleMorph := EllipseMorph new.	handleMorph color: Color red; extent: 15@15.	self addMorph: handleMorph.	self moveHandleToCenter.	button1 := false.	button2 := false.! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 1/10/2001 21:43'!dispatchEvent: anEvent with: aMorph	"Dispatch the given event for a morph that has chosen the receiver to dispatch its events. The method implements a shortcut for repeated dispatches of events using the same dispatcher."	anEvent type == lastType ifTrue:[^self perform: lastDispatch with: anEvent with: aMorph].	"Otherwise classify"	lastType := anEvent type.	anEvent isMouse ifTrue:[		anEvent isMouseDown ifTrue:[			lastDispatch := #dispatchMouseDown:with:.			^self dispatchMouseDown: anEvent with: aMorph]].	anEvent type == #dropEvent ifTrue:[		lastDispatch := #dispatchDropEvent:with:.		^self dispatchDropEvent: anEvent with: aMorph].	lastDispatch := #dispatchDefault:with:.	^self dispatchDefault: anEvent with: aMorph! !!HandMorph methodsFor: 'focus handling' stamp: 'yo 11/7/2002 19:11'!newKeyboardFocus: aMorphOrNil	"Make the given morph the new keyboard focus, canceling the previous keyboard focus if any. If the argument is nil, the current keyboard focus is cancelled."	| oldFocus |	oldFocus := self keyboardFocus.	self keyboardFocus: aMorphOrNil.	oldFocus ifNotNil: [oldFocus == aMorphOrNil ifFalse: [oldFocus keyboardFocusChange: false]].	aMorphOrNil ifNotNil: [aMorphOrNil keyboardFocusChange: true. self compositionWindowManager keyboardFocusForAMorph: aMorphOrNil].! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 7/16/1999 13:03'!saveOnURL	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| um pg |	(pg := self saveOnURLbasic) == #cancel ifTrue: [^ self].	um := URLMorph newForURL: pg url.	um setURL: pg url page: pg.	pg isContentsInMemory ifTrue: [pg computeThumbnail].	um isBookmark: true.	um removeAllMorphs.	um color: Color transparent.	self primaryHand attachMorph: um.! !!PasteUpMorph methodsFor: 'world state' stamp: 'tk 8/21/2000 15:36'!paintBox	"Return the painting controls widget (PaintBoxMorph) to be used for painting in this world. If there is not already a PaintBox morph, or if it has been deleted from this world, create a new one."	| newPaintBox refPoint aPalette |	self allMorphsDo: [:m | (m isKindOf: PaintBoxMorph) ifTrue: [^ m]].	refPoint := (aPalette := self standardPalette)		ifNotNil:			[aPalette showNoPalette.			aPalette topRight + (0 @ 12)]		ifNil:			[self topRight].	newPaintBox := PaintBoxMorph new.	newPaintBox position: (refPoint - (newPaintBox width @ 0)). 	self addMorph: newPaintBox.	^ newPaintBox! !!StringMorph methodsFor: 'accessing' stamp: 'di 4/2/1999 16:11'!font: aFont emphasis: emphasisCode	font := aFont.	emphasis := emphasisCode.	self fitContents."in inspector say,	 self font: (TextStyle default fontAt: 2) emphasis: 1"! !!TableLayout methodsFor: 'layout' stamp: 'ar 1/27/2001 14:40'!flushLayoutCache	"Flush any cached information associated with the receiver"	minExtentCache := nil.! !!ColorPickerMorph methodsFor: 'other' stamp: 'ar 12/8/2000 15:32'!putUpFor: aMorph near: aRectangle	"Put the receiver up on the screen.   Note highly variant behavior depending on the setting of the #modalColorPickers preference"	| layerNumber |	aMorph isMorph ifTrue: [		layerNumber := aMorph morphicLayerNumber.		aMorph allOwnersDo:[:m|			layerNumber := layerNumber min: m morphicLayerNumber].		self setProperty: #morphicLayerNumber toValue: layerNumber - 0.1	].	isModal == true "backward compatibility"		ifTrue:			[self pickUpColorFor: aMorph]		ifFalse:			[self addToWorld:				((aMorph notNil and: [aMorph world notNil])					ifTrue:						[aMorph world]					ifFalse:						[self currentWorld])		  		near:					(aRectangle ifNil:						[aMorph ifNil: [100@100 extent: 1@1] ifNotNil: [aMorph fullBoundsInWorld]])]! !!ScrollBar methodsFor: 'other events' stamp: ''!menuButtonMouseDown: event	event hand showTemporaryCursor: nil.	self use: menuSelector orMakeModelSelectorFor: 'MenuButtonPressed:'		in: [:sel | menuSelector := sel.  model perform: sel with: event]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 10/8/2000 15:40'!morphsAt: aPoint unlocked: aBool	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself.  The order is deepest embedding first."	| mList |	mList := WriteStream on: #().	self morphsAt: aPoint unlocked: aBool do:[:m| mList nextPut: m].	^mList contents! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/4/1999 09:42'!borderWidth: anInteger	borderColor ifNil: [borderColor := Color black].	borderWidth := anInteger max: 0.	self changed! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/16/2000 22:32'!fillOval: rect	| centerX centerY nextY yBias xBias outer nextOuterX |	rect area <= 0 ifTrue: [^ self].	height := 1.	yBias := rect height odd ifTrue: [0] ifFalse: [-1].	xBias := rect width odd ifTrue: [1] ifFalse: [0].	centerX := rect center x.	centerY := rect center y.	outer := EllipseMidpointTracer new on: rect.	nextY := rect height // 2.	[nextY > 0] whileTrue:[		nextOuterX := outer stepInY.		width := (nextOuterX bitShift: 1) + xBias.		destX := centerX - nextOuterX.		destY := centerY - nextY.		self copyBits.		destY := centerY + nextY + yBias.		self copyBits.		nextY := nextY - 1.	].	destY := centerY.	height := 1 + yBias.	width := rect width.	destX := rect left.	self copyBits.! !!TextMorph methodsFor: 'private' stamp: 'hpt 4/11/2004 20:35'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].self setProperty: #CreatingParagraph toValue: true.	self setDefaultContentsIfNil.	"...Code here to recreate the paragraph..."	paragraph := (self paragraphClass new textOwner: self owner).	paragraph wantsColumnBreaks: successor notNil.	paragraph		compose: text		style: textStyle copy		from: self startingIndex		in: self container.	wrapFlag ifFalse:		["Was given huge container at first... now adjust"		paragraph adjustRightX].	paragraph focused: (self currentHand keyboardFocus == self).	self fit.self removeProperty: #CreatingParagraph.	^ paragraph! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 3/27/2001 11:52'!nameForUndoWording	"Return wording appropriate to the receiver for use in an undo-related menu item (and perhaps elsewhere)"	| aName |	aName := self knownName ifNil: [self renderedMorph class name].	^ aName truncateTo: 24! !!ScriptEditorMorph methodsFor: 'caching' stamp: 'sw 11/2/2004 16:40'!releaseCachedState	"Release any state that could be recomputed"	super releaseCachedState.	handWithTile := nil.	self hibernate! !!FileList methodsFor: 'initialization' stamp: 'sw 11/30/2002 14:36'!optionalButtonRow	"Answer the button row associated with a file list"	| aRow |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent.	aRow clipSubmorphs: true.	aRow layoutInset: 5@1; cellInset: 6.	self universalButtonServices do:  "just the three sort-by items"			[:service |				aRow addMorphBack: (service buttonToTriggerIn: self).				(service selector  == #sortBySize)					ifTrue:						[aRow addTransparentSpacerOfSize: (4@0)]].	aRow setNameTo: 'buttons'.	aRow setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"	^ aRow! !!Morph methodsFor: 'private' stamp: 'nk 10/11/2003 16:08'!privateAddMorph: aMorph atIndex: index	| oldIndex myWorld itsWorld oldOwner |	((index >= 1) and: [index <= (submorphs size + 1)])		ifFalse: [^ self error: 'index out of range'].	myWorld := self world.	oldOwner := aMorph owner.	(oldOwner == self and: [(oldIndex := submorphs indexOf: aMorph) > 0]) ifTrue:[		"aMorph's position changes within in the submorph chain"		oldIndex < index ifTrue:[			"moving aMorph to back"			submorphs replaceFrom: oldIndex to: index-2 with: submorphs startingAt: oldIndex+1.			submorphs at: index-1 put: aMorph.		] ifFalse:[			"moving aMorph to front"			oldIndex-1 to: index by: -1 do:[:i|				submorphs at: i+1 put: (submorphs at: i)].			submorphs at: index put: aMorph.		].	] ifFalse:[		"adding a new morph"		oldOwner ifNotNil:[			itsWorld := aMorph world.			itsWorld ifNotNil: [self privateInvalidateMorph: aMorph].			(itsWorld == myWorld) ifFalse: [aMorph outOfWorld: itsWorld].			oldOwner privateRemove: aMorph.			oldOwner removedMorph: aMorph.		].		aMorph privateOwner: self.		submorphs := submorphs copyReplaceFrom: index to: index-1 with: (Array with: aMorph).		(itsWorld == myWorld) ifFalse: [aMorph intoWorld: myWorld].	].	myWorld ifNotNil:[self privateInvalidateMorph: aMorph].	self layoutChanged.	oldOwner == self ifFalse: [		self addedMorph: aMorph.		aMorph noteNewOwner: self ].! !!TransformationMorph class methodsFor: 'example' stamp: 'mk 8/14/2005 16:07'!example1	| stringMorph transformationMorph |	stringMorph := 'vertical text' asMorph.	transformationMorph := TransformationMorph new asFlexOf: stringMorph.	transformationMorph angle: Float pi / 2.	transformationMorph position: 5@5.	transformationMorph openInWorld.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'nb 6/17/2003 12:25'!backgroundWorldDisplay	| f |	self flag: #bob.		"really need a better way to do this"			"World displayWorldSafely."	"ugliness to try to track down a possible error"	[World displayWorld] ifError: [ :a :b |		stageCompleted := 999.		f := FileDirectory default fileNamed: 'bob.errors'.		f nextPutAll: a printString,'  ',b printString; cr; cr.		f nextPutAll: 'worlds equal ',(formerWorld == World) printString; cr; cr.		f nextPutAll: thisContext longStack; cr; cr.		f nextPutAll: formerProcess suspendedContext longStack; cr; cr.		f close. Beeper beep.	].! !!MovieMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:05'!scalePoint: newScalePoint	| frame |	newScalePoint ~= scalePoint ifTrue: [		self changed.		scalePoint := newScalePoint.		frame := self currentFrame.		frame ifNotNil: [frame scalePoint: newScalePoint].		self layoutChanged.		self changed].! !!TransformMorph methodsFor: 'private' stamp: 'kfr 8/7/2004 18:48'!privateFullMoveBy: delta	"Private!! Relocate me, but not my subMorphs."	self privateMoveBy: delta.	transform :=  (transform asMorphicTransform) withOffset: (transform offset - delta).! !!Morph methodsFor: 'e-toy support' stamp: 'sw 7/21/1998 21:18'!setStandardTexture	| parms |	parms := self textureParameters.	self makeGraphPaperGrid: parms first		background: parms second		line: parms third! !!StringMorph methodsFor: 'halos and balloon help' stamp: 'sw 6/6/2001 13:34'!boundsForBalloon	"Some morphs have bounds that are way too big.  This is a contorted way of making things work okay in PluggableListMorphs, whose list elements historically have huge widths"	| ownerOwner |	^ ((owner notNil and: [(ownerOwner := owner owner) notNil]) and:			[ownerOwner isKindOf: PluggableListMorph])		ifTrue:			[self boundsInWorld intersect: ownerOwner boundsInWorld]		ifFalse:			[super boundsForBalloon]! !!StringMorphAttributeScanner methodsFor: 'scanning' stamp: 'nk 2/26/2004 12:37'!indentationLevel: anInteger	"Set the value of indent"	indent := anInteger! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/16/1998 01:19'!changeRotationCenter: evt with: rotHandle	| pos |	pos := evt cursorPoint.	rotHandle referencePosition: pos.	self referencePosition: pos.! !!TransformMorph methodsFor: 'accessing' stamp: ''!smoothingOff	smoothing := 1.	self changed! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 3/3/2004 01:17'!putUpPenTrailsSubmenu	"Put up the pen trails menu"	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu title: 'pen trails' translated.	aMenu addStayUpItem.	self addPenTrailsMenuItemsTo: aMenu.	aMenu popUpInWorld: ActiveWorld! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'ar 8/16/2001 11:24'!mouseUp: evt	showSelectionFeedback := false.	borderColor isColor ifFalse:[borderColor := #raised].	allButtons ifNil: [^ self].	allButtons do: [:m |		(m containsPoint: evt cursorPoint) ifTrue: [m performAction]].	allButtons := nil.	self changed.! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:56'!readContentsEUCKR	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: EUCKRTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'di 4/20/1998 18:53'!askBeforeDiscardingEdits: aBoolean	"Set the flag that determines whether the user should be asked before discarding unaccepted edits."	askBeforeDiscardingEdits := aBoolean! !!BalloonMorph class methodsFor: 'private' stamp: 'wiz 1/24/2005 00:32'!getBestLocation: vertices for: morph corner: cornerName	"Try four rel locations of the balloon for greatest unclipped area.   12/99 sma"	| rect maxArea verts rectCorner morphPoint mbc a mp dir bestVerts result usableArea |	"wiz 1/8/2005 Choose rect independantly of vertice order or size. Would be nice it this took into account curveBounds but it does not." 	rect := Rectangle encompassing: vertices.  	maxArea := -1.	verts := vertices.	usableArea := (morph world ifNil: [self currentWorld]) viewBox.	1 to: 4 do: [:i |		dir := #(vertical horizontal) atWrap: i.		verts := verts collect: [:p | p flipBy: dir centerAt: rect center].		rectCorner := #(bottomLeft bottomRight topRight topLeft) at: i.		morphPoint := #(topCenter topCenter bottomCenter bottomCenter) at: i.		a := ((rect			align: (rect perform: rectCorner)			with: (mbc := morph boundsForBalloon perform: morphPoint))				intersect: usableArea) area.		(a > maxArea or: [a = rect area and: [rectCorner = cornerName]]) ifTrue:			[maxArea := a.			bestVerts := verts.			mp := mbc]].	result := bestVerts collect: [:p | p + (mp - bestVerts first)] "Inlined align:with:".	^ result! !!TextLine methodsFor: 'accessing' stamp: ''!internalSpaces: spacesInteger 	"Set the number of spaces in the line to be spacesInteger."	internalSpaces := spacesInteger! !!SimpleButtonMorph methodsFor: 'event handling' stamp: 'wiz 5/18/2006 03:33'!mouseUp: evt	super mouseUp: evt.	oldColor ifNotNil:		["if oldColor nil, it signals that mouse had not gone DOWN		inside me, e.g. because of a cmd-drag; in this case we want		to avoid triggering the action!!"		self color: oldColor.		oldColor := nil.		(self containsPoint: evt cursorPoint) 				ifTrue: [ actWhen == #buttonUp 							ifTrue: [self doButtonAction]  ]				ifFalse: [ self mouseLeave: evt "This is a balk. Note that we have left." ]]		! !!SystemWindow methodsFor: 'menu' stamp: 'RAA 6/12/2000 09:01'!offerWindowMenu	| aMenu |	aMenu := self buildWindowMenu.	model ifNotNil:		[model addModelItemsToWindowMenu: aMenu].	aMenu popUpEvent: self currentEvent in: self world! !!Morph methodsFor: 'WiW support' stamp: 'gk 5/24/2004 15:43'!eToyRejectDropMorph: morphToDrop event: evt	| tm am |	tm := TextMorph new 		beAllFont: ((TextStyle named: Preferences standardEToysFont familyName) fontOfSize: 24);		contents: 'GOT IT!!'.	(am := AlignmentMorph new)		color: Color yellow;		layoutInset: 10;		useRoundedCorners;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		addMorph: tm;		fullBounds;		position: (self bounds center - (am extent // 2));		openInWorld: self world.	SoundService default playSoundNamed: 'yum' ifAbsentReadFrom: 'yum.aif'.	morphToDrop rejectDropMorphEvent: evt.		"send it back where it came from"	am delete! !!UpdatingStringMorph methodsFor: 'copying' stamp: 'tk 9/26/2001 05:09'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared."	super veryDeepInner: deepCopier.	format := format veryDeepCopyWith: deepCopier.	target := target.					"Weakly copied"	lastValue := lastValue veryDeepCopyWith: deepCopier.	getSelector := getSelector.			"Symbol"	putSelector := putSelector.		"Symbol"	floatPrecision := floatPrecision veryDeepCopyWith: deepCopier.	growable := growable veryDeepCopyWith: deepCopier.	stepTime := stepTime veryDeepCopyWith: deepCopier.	autoAcceptOnFocusLoss := autoAcceptOnFocusLoss veryDeepCopyWith: deepCopier.	minimumWidth := minimumWidth veryDeepCopyWith: deepCopier.	maximumWidth := maximumWidth veryDeepCopyWith: deepCopier.! !!PluggableCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 8/25/2000 14:40'!fillRectangle: aRectangle fillStyle: aFillStyle	| pattern |	self shadowColor ifNotNil: [^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	aFillStyle isSolidFill ifTrue:[ ^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern := aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!SystemWindow methodsFor: 'geometry' stamp: 'di 5/22/1998 13:24'!position: newPos	super position: newPos.	isCollapsed		ifTrue: [collapsedFrame := self bounds]		ifFalse: [fullFrame := self bounds].! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!directory: aDirectory	^directory := aDirectory! !!UpdatingStringMorph methodsFor: 'event handling' stamp: 'sw 11/15/2001 10:15'!mouseDown: evt	"The mouse went down over the receiver.  If appropriate, launch a mini-editor so that the user can commence text-editing here"	(owner wantsKeyboardFocusFor: self) ifTrue:		[self userEditsAllowed ifTrue:			[(owner respondsTo: #parseNode)					ifTrue: 	"leave space for editing"						[minimumWidth := (49 max: minimumWidth)].			self launchMiniEditor: evt]]! !!SketchMorph methodsFor: 'menu' stamp: 'sw 1/25/2006 21:41'!editDrawingIn: aPasteUpMorph forBackground: forBackground	"Edit an existing sketch."	| w bnds sketchEditor pal aPaintTab aWorld aPaintBox tfx rotCenter |	self world assureNotPaintingElse: [^self].	w := aPasteUpMorph world.	w prepareToPaint.	w displayWorld.	self visible: false.	bnds := forBackground 				ifTrue: [aPasteUpMorph boundsInWorld]				ifFalse: 					[bnds := self boundsInWorld expandBy: 60 @ 60.					(aPasteUpMorph paintingBoundsAround: bnds center) merge: bnds]. 	sketchEditor := SketchEditorMorph new.	forBackground 		ifTrue: [sketchEditor setProperty: #background toValue: true].	w addMorphFront: sketchEditor.	sketchEditor 		initializeFor: self		inBounds: bnds		pasteUpMorph: aPasteUpMorph.	rotCenter := self rotationCenter.	sketchEditor afterNewPicDo: 			[:aForm :aRect | 			self visible: true.			self form: aForm.			tfx := aPasteUpMorph transformFrom: aPasteUpMorph world.			self topRendererOrSelf position: (tfx globalPointToLocal: aRect origin).			self rotationStyle: sketchEditor rotationStyle.			self forwardDirection: sketchEditor forwardDirection.			(rotCenter notNil and: [(rotCenter = (0.5 @ 0.5)) not]) ifTrue:				[self rotationCenter: rotCenter].			(aPaintTab := (aWorld := self world) paintingFlapTab) 				ifNotNil: [aPaintTab hideFlap]				ifNil: [(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete]].			self presenter drawingJustCompleted: self.			forBackground ifTrue: [self goBehind	"shouldn't be necessary"]]		ifNoBits: 			["If no bits drawn.  Must keep old pic.  Can't have no picture"			self visible: true.			aWorld := self currentWorld.			"sometimes by now I'm no longer in a world myself, but we still need				 to get ahold of the world so that we can deal with the palette"			((pal := aPasteUpMorph standardPalette) notNil and: [pal isInWorld]) 				ifTrue: 					[(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete].					pal viewMorph: self]				ifFalse: 					[(aPaintTab := (aWorld := self world) paintingFlapTab) 						ifNotNil: [aPaintTab hideFlap]						ifNil: [(aPaintBox := aWorld paintBox) ifNotNil: [aPaintBox delete]]]]! !!TransferMorph methodsFor: 'accessing' stamp: 'mir 5/5/2000 14:39'!move	copy := false! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos: aBoolean	wantsMouseOverHalos := aBoolean! !!NewParagraph methodsFor: 'private' stamp: 'di 4/14/98 13:13'!lineIndexForPoint: aPoint	"Answer the index of the line in which to select the character nearest to aPoint."	| i py |	py := aPoint y truncated.	"Find the first line at this y-value"	i := (self fastFindFirstLineSuchThat: [:line | line bottom > py]) min: lines size.	"Now find the first line at this x-value"	[i < lines size and: [(lines at: i+1) top = (lines at: i) top				and: [aPoint x >= (lines at: i+1) left]]]		whileTrue: [i := i + 1].	^ i! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 9/28/1999 11:02'!removeMenuBox	menuBox ifNotNil:		[menuBox delete.		menuBox := nil].! !!SelectionMorph methodsFor: 'undo' stamp: 'di 9/19/2000 21:52'!refineUndoTarget: target selector: selector arguments: arguments in: refineBlock	"Any morph can override this method to refine its undo specification"	selector == #fillStyle: ifTrue:		[refineBlock value: target value: #fillStyleForItems: value: {undoProperties}.		^ undoProperties := nil].	selector == #borderColor: ifTrue:		[refineBlock value: target value: #borderColorForItems: value: {undoProperties}.		^ undoProperties := nil].	selector == #borderWidth: ifTrue:		[refineBlock value: target value: #borderWidthForItems: value: {undoProperties}.		^ undoProperties := nil].	selector == #undoMove:redo:owner:bounds:predecessor: ifTrue:		["This is the biggy.  Need to gather parameters for all selected items"		refineBlock value: target			value: #undoMove:redo:owner:bounds:predecessor:			value: {arguments first.					arguments second.					selectedItems collect: [:m | m owner].					selectedItems collect: [:m | m bounds].					selectedItems collect: [:m | m owner morphPreceding: m]}].	refineBlock value: target value: selector value: arguments! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'sw 1/31/2000 11:01'!responseUponCancel: anObject	responseUponCancel := anObject! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'di 8/30/2000 13:40'!selector: aSymbol	"Set the selector to be associated with the receiver.  Store it in the receiver's command, if appropriate"	selector := aSymbol.	self updateSelectorDisplay! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:15'!doStop: aBoolean	doStop := aBoolean! !!NullEncoder methodsFor: 'initialization' stamp: 'MPW 1/1/1901 00:04'!initWithTarget:aTarget	target := aTarget.	filterSelector := self class filterSelector.	^self.! !!FileList2 methodsFor: 'private' stamp: 'RAA 4/6/2001 12:45'!cancelHit	modalView delete.	directory := fileName := currentDirectorySelected := nil.! !!PolygonMorph methodsFor: 'geometry' stamp: 'nk 2/15/2001 09:09'!arrowsContainPoint: aPoint	"Answer an Array of two Booleans that indicate whether the given point is inside either arrow"	| retval f |	retval := { false . false }.	(super containsPoint: aPoint) ifFalse: [^ retval ].	(closed or: [arrows == #none or: [vertices size < 2]]) ifTrue: [^ retval].	(arrows == #forward or: [arrows == #both]) ifTrue: [	"arrowForms first has end form"		f := self arrowForms first.		retval at: 2 put: ((f pixelValueAt: aPoint - f offset) > 0)	].	(arrows == #back or: [arrows == #both]) ifTrue: [ "arrowForms last has start form"		f := self arrowForms last.		retval at: 1 put: ((f pixelValueAt: aPoint - f offset) > 0)	].	^retval.! !!IconicButton methodsFor: 'initialization' stamp: 'nk 9/7/2004 11:43'!initializeWithThumbnail: aThumbnail withLabel: aLabel andColor: aColor andSend: aSelector to: aReceiver 		"Initialize the receiver to show aThumbnail on its face, giving it the label supplied and arranging for it, when the button goes down on it, to obtain a new morph by sending the supplied selector to the supplied receiver"	| labeledItem nonTranslucent |	nonTranslucent := aColor asNontranslucentColor.	labeledItem := AlignmentMorph newColumn.	labeledItem color: nonTranslucent.	labeledItem borderWidth: 0.	labeledItem		layoutInset: 4@0;		cellPositioning: #center.	labeledItem addMorph: aThumbnail.	labeledItem addMorphBack: (Morph new extent: (4@4)) beTransparent.	labeledItem addMorphBack: (TextMorph new		backgroundColor: nonTranslucent;		contentsAsIs: aLabel;		beAllFont: Preferences standardEToysFont;		centered).	self		beTransparent;		labelGraphic: ((labeledItem imageForm: 32 backgroundColor: nonTranslucent forRectangle: labeledItem fullBounds) replaceColor: nonTranslucent withColor: Color transparent);		borderWidth: 0;		target: aReceiver;		actionSelector: #launchPartVia:label:;		arguments: {aSelector. aLabel};		actWhen: #buttonDown.	self stationarySetup.! !!PolygonMorph methodsFor: 'attachments' stamp: 'nk 7/3/2003 14:43'!midpoint	"Answer the midpoint along my segments"	| middle |	middle := 0.	self lineSegmentsDo: [ :a :b | middle := middle + (a dist: b) ].	middle < 2 ifTrue: [ ^ self center ].	middle := middle / 2.	self lineSegmentsDo: [ :a :b | | dist |		dist := (a dist: b).		middle < dist			ifTrue: [ ^(a + ((b - a) * (middle / dist))) asIntegerPoint ].		middle := middle - dist.	].	self error: 'can''t happen'! !!SelectionMorph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:25'!drawOn: aCanvas	| canvas form1 form2 box |	super drawOn: aCanvas.	box := self bounds.	selectedItems do: [:m | box := box merge: m fullBounds].	box := box expandBy: 1.	canvas := Display defaultCanvasClass extent: box extent depth: 8.	canvas translateBy: box topLeft negated		during: [:tempCanvas | selectedItems do: [:m | tempCanvas fullDrawMorph: m]].	form1 := (Form extent: box extent) copyBits: (0@0 extent: box extent) from: canvas form at: 0@0 colorMap: (Color maskingMap: 8).	form2 := Form extent: box extent.	(0@0) fourNeighbors do: [:d | form1 displayOn: form2 at: d rule: Form under].	form1 displayOn: form2 at: 0@0 rule: Form erase.	aCanvas stencil: form2		at: box topLeft		sourceRect: form2 boundingBox		color: self borderColor! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/14/2000 12:14'!removeAlarm: aSelector	"Remove the given alarm"	| scheduler |	scheduler := self alarmScheduler.	scheduler ifNotNil:[scheduler removeAlarm: aSelector for: self].! !!TextMorph methodsFor: 'submorphs-add/remove' stamp: 'di 11/16/97 16:52'!goBehind	"We need to save the container, as it knows about fill and run-around"	| cont |	container ifNil: [^ super goBehind].	self releaseParagraph.  "Cause recomposition"	cont := container.  "Save the container"	super goBehind.  "This will change owner, nilling the container"	container := cont.  "Restore the container"	self changed! !!MouseEvent methodsFor: 'private' stamp: 'ar 10/10/2000 21:15'!setType: aSymbol	"For quick conversion between event types"	type := aSymbol.! !!TextMorph methodsFor: 'copying' stamp: 'tk 2/20/2001 18:55'!veryDeepFixupWith: deepCopier 	"If target and arguments fields were weakly copied, fix them here.  If 	they were in the tree being copied, fix them up, otherwise point to the 	originals!!"	super veryDeepFixupWith: deepCopier.	"It makes no sense to share pointers to an existing predecessor and successor"	predecessor := deepCopier references at: predecessor ifAbsent: [nil].	successor := deepCopier references at: successor ifAbsent: [nil]! !!CircleMorph methodsFor: 'geometry' stamp: 'nk 7/1/2002 07:01'!bounds: aRectangle	| size |	size := aRectangle width min: aRectangle height.	super bounds: (Rectangle origin: aRectangle origin extent: size @ size).! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/2/2002 21:04'!handUserParameterTile	"Hand the user a parameter, presumably to drop in the script"		| aTileMorph |	aTileMorph := ParameterTile new forScriptEditor: self.	self currentHand attachMorph: aTileMorph! !!HaloMorph methodsFor: 'private' stamp: 'dgd 4/4/2006 16:57'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable.  Keep the relevant command object up to date."	| degrees |	evt hand obtainHalo: self.	degrees := (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees := degrees - angleOffset degrees.	degrees := degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [self setColor: Color lightBlue toHandle: rotHandle]		ifFalse: [self setColor: Color blue toHandle: rotHandle].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	self removeAllHandlesBut: rotHandle.	self showingDirectionHandles ifFalse:		[self showDirectionHandles: true addHandles: false].	self addDirectionHandles.	target rotationDegrees: degrees.	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	(self valueOfProperty: #commandInProgress) ifNotNilDo:		[:cmd | "Update the final rotation"		cmd redoTarget: target renderedMorph selector: #heading: argument: degrees].	self layoutChanged! !!MenuMorph methodsFor: 'control' stamp: 'jrp 7/6/2005 21:23'!updateColor	| fill title |	Preferences gradientMenu		ifFalse: [^ self].	""	fill := GradientFillStyle ramp: {0.0 -> Color white. 1 -> self color}.	""	fill		radial: false;		origin: self topLeft;		direction: 0 @ self height.	""	self fillStyle: fill.	" 	update the title color"	title := self allMorphs				detect: [:each | each hasProperty: #titleString]				ifNone: [^ self].	""	fill := GradientFillStyle ramp: {0.0 -> title color twiceLighter. 1 -> title color twiceDarker}.	""	fill		origin: title topLeft;		direction: title width @ 0.	""	title fillStyle: fill! !!SimpleHierarchicalListMorph methodsFor: 'drawing' stamp: 'sps 12/22/2002 00:03'!drawLinesOn: aCanvas	| lColor |	lColor := self lineColor.	aCanvas 		transformBy: scroller transform		clippingTo: scroller innerBounds		during:[:clippedCanvas |			scroller submorphs do: [ :submorph |				( 					(submorph isExpanded) or: [					(clippedCanvas isVisible: submorph fullBounds) or: [					(submorph nextSibling notNil and: [clippedCanvas isVisible: submorph nextSibling]) 				]]) ifTrue:[					submorph drawLinesOn: clippedCanvas lineColor: lColor.				]			].		]		smoothing: scroller smoothing.! !!Morph methodsFor: 'menus' stamp: 'sw 10/6/2004 11:38'!absorbStateFromRenderer: aRenderer 	"Transfer knownName, actorState, visible, and player info over from aRenderer, which was formerly imposed above me as a transformation shell but is now going away."	| current |	(current := aRenderer actorStateOrNil) ifNotNil:		[self actorState: current.		aRenderer actorState: nil].	(current := aRenderer knownName) ifNotNil:		[self setNameTo: current.		aRenderer setNameTo: nil].	(current := aRenderer player) ifNotNil:		[self player: current.		current rawCostume: self.		aRenderer player: nil].	self visible: aRenderer visible! !!SystemWindow methodsFor: 'top window' stamp: 'sw 5/20/2001 22:32'!adjustBorderUponDeactivationWhenLabeless	"Adjust the border upon deactivation when, labelless"	| aWidth |	(aWidth := self valueOfProperty: #borderWidthWhenInactive) ifNotNil:		[self acquireBorderWidth: aWidth]! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| movies subMenu |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	subMenu := MenuMorph new defaultTarget: self.	frameList size > 1 ifTrue: [		subMenu add: 'repaint' translated action: #editDrawing.		subMenu add: 'set rotation center' translated action: #setRotationCenter.		subMenu add: 'play once' translated action: #playOnce.		subMenu add: 'play loop' translated action: #playLoop.		subMenu add: 'stop playing' translated action: #stopPlaying.		currentFrameIndex > 1 ifTrue: [			subMenu add: 'previous frame' translated action: #previousFrame].		currentFrameIndex < frameList size ifTrue: [			subMenu add: 'next frame' translated action: #nextFrame]].	subMenu add: 'extract this frame' translated action: #extractFrame:.	movies :=		(self world rootMorphsAt: aHandMorph targetPoint)			select: [:m | (m isKindOf: MovieMorph) or:						[m isSketchMorph]].	(movies size > 1) ifTrue:		[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aCustomMenu add: 'movie...' translated subMenu: subMenu! !!CurveMorph class methodsFor: 'instance creation' stamp: 'tk 11/14/2001 17:47'!arrowPrototype	| aa |	aa := PolygonMorph vertices: (Array with: 5@40 with: 5@8 with: 35@8 with: 35@40) 		color: Color black 		borderWidth: 2 		borderColor: Color black.	aa beSmoothCurve; makeOpen; makeForwardArrow.		"is already open"	aa dashedBorder: {10. 10. Color red}.		"A dash spec is a 3- or 5-element array with		{ length of normal border color.		length of alternate border color.		alternate border color}"	aa computeBounds.	^ aa! !!SystemWindow methodsFor: 'initialization' stamp: 'md 2/24/2006 16:06'!setFramesForLabelArea	"an aid to converting old instances, but then I found  	convertAlignment (jesse welton's note)"	| frame windowBorderWidth |	labelArea ifNil: [^ self].		labelArea		layoutPolicy: TableLayout new;		listDirection: #leftToRight;		hResizing: #spaceFill;		layoutInset: 0.	label hResizing: #spaceFill.	labelArea		ifNotNil: [frame := LayoutFrame new.			frame leftFraction: 0;				topFraction: 0;				rightFraction: 1;				topOffset: self labelHeight negated.				windowBorderWidth := self class borderWidth.			frame leftOffset: windowBorderWidth;				rightOffset: windowBorderWidth negated;				topOffset: self labelHeight negated + windowBorderWidth;				bottomOffset: windowBorderWidth negated.			labelArea layoutFrame: frame]! !!FileList methodsFor: 'file menu action' stamp: 'jm 5/3/1998 18:04'!getHex	"Get contents of file again, and display in Hex. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		brevityState := #needToGetBriefHex.		self changed: #contents].! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 7/12/2000 07:44'!lastProjectThumbnail: aForm		lastProjectThumbnail := aForm! !!FileList methodsFor: 'file menu action' stamp: 'dgd 9/21/2003 17:37'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: ('Really delete {1}?' translated format:{fileName})) ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState := #FileList.	self get! !!EditCommand methodsFor: 'selection' stamp: 'sps 7/24/2003 17:03'!undoSelectionInterval"Return an interval to be displayed as a selection after undo, or nil"	| i |	i := (replacedTextInterval first min: self textMorphStringSize).	^i to: i - 1! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:09'!changeLayoutInset: evt	| handle |	handle := HandleMorph new forEachPointDo:[:newPoint |		self layoutInset: (newPoint - evt cursorPoint) asIntegerPoint // 5].	evt hand attachMorph: handle.	handle startStepping.! !!HaloMorph methodsFor: 'accessing' stamp: 'nk 6/12/2004 21:56'!setTarget: aMorph	"Private!! Set the target without adding handles."	target := aMorph topRendererOrSelf.	innerTarget := target renderedMorph.	innerTarget wantsDirectionHandles		ifTrue: [self showDirectionHandles: true addHandles: false].	target hasHalo: true.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'yo 3/15/2005 13:36'!attemptCleanupReporting: whetherToReport	"Try to fix up some bad things that are known to occur in some etoy projects we've seen. If the whetherToReport parameter is true, an informer is presented after the cleanups"	| fixes |	fixes := 0.	ActiveWorld ifNotNil:		[(ActiveWorld submorphs select:			[:m | (m isKindOf: ScriptEditorMorph) and: [m submorphs isEmpty]]) do:				[:m | m delete.  fixes := fixes + 1]].	TransformationMorph allSubInstancesDo:		[:m | (m player notNil and: [m renderedMorph ~~ m])			ifTrue:				[m renderedMorph visible ifFalse:					[m renderedMorph visible: true.  fixes := fixes + 1]]].	(Player class allSubInstances select: [:cl | cl isUniClass]) do:		[:aUniclass |			fixes := fixes + aUniclass cleanseScripts].	self presenter flushPlayerListCache; allExtantPlayers.	whetherToReport ifTrue:		[self inform: ('{1} [or more] repair(s) made' translated format: {fixes printString})]"ActiveWorld attemptCleanupReporting: true.ActiveWorld attemptCleanupReporting: false."! !!EventHandler methodsFor: 'fixups' stamp: 'ar 3/18/2001 17:18'!replaceSendsIn: array1 with: array2	"Replace all the sends that occur in array1 with those in array2. Used for fixing old event handlers in files."	| old index |	1 to: self class instSize do:[:i|		old := self instVarAt: i.		index := array1 identityIndexOf: old.		index > 0 ifTrue:[self instVarAt: i put: (array2 at: index)]].! !!SystemProgressMorph class methodsFor: 'instance creation' stamp: 'laza 4/18/2004 21:16'!label: shortDescription min: minValue max: maxValue	UniqueInstance ifNil: [UniqueInstance := super new].	^UniqueInstance label: (shortDescription contractTo: 100) min: minValue asFloat max: maxValue asFloat! !!ColorPickerMorph class methodsFor: 'class initialization' stamp: 'ar 7/8/2006 20:33'!initialize	"ColorPickerMorph initialize"	ColorChart := ColorPickerMorph colorPaletteForDepth: 16 extent: 190@60.	DragBox :=  (11@0) extent: 9@8.	RevertBox := (ColorChart width - 20)@1 extent: 9@8.	FeedbackBox := (ColorChart width - 10)@1 extent: 9@8.	TransparentBox := DragBox topRight corner: RevertBox bottomLeft.		ColorChart fillBlack: ((DragBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((TransparentBox left)@0 extent: 1@9).		ColorChart fillBlack: ((FeedbackBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((RevertBox left - 1)@0 extent: 1@9).		(Form dotOfSize: 5) displayOn: ColorChart at: DragBox center + (0@1).	self localeChanged.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/31/2004 14:06'!tanOButton	"Answer a button with the old O on a tan background, targeted to self"	| aButton |	aButton := IconicButton new labelGraphic: (ScriptingSystem formAtKey: #TanO).	aButton color: Color transparent; borderWidth: 0; shedSelvedge; actWhen: #buttonUp.	aButton target: self.	^ aButton! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:22'!defaultContents	contents := list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState := #FileList.	^ contents! !!PopUpChoiceMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:44'!initialize"initialize the state of the receiver"	super initialize.""	self contents: 'PopUpChoice of Colors'.	target := Color.	actionSelector := nil.	arguments := EmptyArray.	getItemsSelector := #colorNames.	getItemsArgs := EmptyArray! !!TransformMorph methodsFor: 'geometry' stamp: 'efc 7/24/2003 16:41'!localSubmorphBounds	"Answer, in my coordinate system, the bounds of all my submorphs (or nil if no submorphs). We will cache this value for performance. The value is invalidated upon recieving #layoutChanged."	localBounds ifNil:[		self submorphsDo:[:m |			localBounds ifNil: [localBounds := m fullBounds]						ifNotNil: [localBounds := localBounds quickMerge: m fullBounds]].	].		^ localBounds! !!FileList2 methodsFor: 'own services' stamp: 'yo 7/31/2004 18:08'!removeLinefeeds	"Remove any line feeds by converting to CRs instead.  This is a temporary implementation for 3.6 only... should be removed during 3.7alpha."	| fileContents |	fileContents := ((FileStream readOnlyFileNamed: self fullName) wantsLineEndConversion: true) contentsOfEntireFile.	(FileStream newFileNamed: self fullName) 		nextPutAll: fileContents;		close.! !!JoystickMorph methodsFor: 'menu' stamp: 'sw 8/11/2004 18:15'!toggleRealJoystick	"Toggle whether or not one is using a real joystick"	realJoystickIndex		ifNil:			[realJoystickIndex := self valueOfProperty: #lastRealJoystickIndex ifAbsentPut: [1].			self startStepping]		ifNotNil:			[self stopTrackingJoystick]! !!Slider methodsFor: 'geometry' stamp: 'sw 3/10/2000 13:44'!computeSlider	| r |	r := self roomToMove.	self descending		ifFalse:			[slider position: (bounds isWide				ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]				ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)])]		ifTrue:			[slider position: (bounds isWide				ifTrue:	[r bottomRight - ((r width * value) asInteger @ 0)]				ifFalse:	[r bottomRight - ((0 @ (r height * value) asInteger))])].	slider extent: self sliderExtent! !!TextMorphForEditView methodsFor: 'edit view' stamp: 'di 4/21/1998 13:09'!setEditView: editPane	editView := editPane! !!PolygonMorph methodsFor: 'geometry' stamp: 'nk 4/27/2003 16:15'!intersects: aRectangle 	"Answer whether any of my segments intersects aRectangle, which is in World coordinates."	| rect |	(super intersects: aRectangle) ifFalse: [ ^false ].	rect := self bounds: aRectangle in: self world.	self		lineSegmentsDo: [:p1 :p2 | (rect intersectsLineFrom: p1 to: p2)				ifTrue: [^ true]].	^ false! !!TextMorph methodsFor: 'copying' stamp: 'md 8/15/2005 11:17'!veryDeepInner: deepCopier 	"Copy all of my instance variables. Some need to be not copied at all, but shared.	Warning!!!! Every instance variable defined in this class must be handled.	We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	textStyle := textStyle veryDeepCopyWith: deepCopier.	text := text veryDeepCopyWith: deepCopier.	wrapFlag := wrapFlag veryDeepCopyWith: deepCopier.	paragraph := paragraph veryDeepCopyWith: deepCopier.	editor := editor veryDeepCopyWith: deepCopier.	container := container veryDeepCopyWith: deepCopier.	predecessor := predecessor.	successor := successor.	backgroundColor := backgroundColor veryDeepCopyWith: deepCopier.	margins := margins veryDeepCopyWith: deepCopier.	editHistory := editHistory veryDeepCopyWith: deepCopier.! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jm 5/26/1999 16:23'!stepTime: mSecsPerStep	stepTime := mSecsPerStep truncated.! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 7/9/2005 17:44'!mouseDown: anEvent 	(self class showSplitterHandles not			and: [self bounds containsPoint: anEvent cursorPoint])		ifTrue: [oldColor := self color.			self color: Color black].	^ super mouseDown: anEvent ! !!SketchMorph methodsFor: 'drawing' stamp: 'nk 8/18/2004 19:07'!generateInterpolatedForm	"Draw the given form onto the canvas using the Balloon 3D engine"	| aCanvas extent |	extent := (originalForm extent * scalePoint) asIntegerPoint.	rotatedForm := Form extent: extent asIntegerPoint depth: originalForm depth.	aCanvas := rotatedForm getCanvas.	^self drawInterpolatedImage: originalForm on: aCanvas! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 12/31/2001 02:26'!test1	"FormCanvas test1"	| canvas |	canvas := FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas point: 100@100 color: (Color black).	canvas drawString: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!PasteUpMorph methodsFor: 'scripting' stamp: 'tk 1/31/2001 15:58'!allTileScriptingElements	"Answer a list of all the morphs that pertain to tile-scripting.  A sledge-hammer"	| all morphs |	morphs := IdentitySet new: 400.	self allMorphsAndBookPagesInto: morphs.	all := morphs select: [:s | s isTileScriptingElement]."	self closedViewerFlapTabs do:		[:aTab | all addAll: aTab referent allTileScriptingElements]."	^ all asOrderedCollection! !!Morph methodsFor: 'change reporting' stamp: 'md 4/3/2006 11:52'!invalidRect: aRectangle from: aMorph	| damageRect |	aRectangle hasPositiveExtent ifFalse: [ ^self ].	damageRect := aRectangle.	aMorph == self ifFalse:[		"Clip to receiver's clipping bounds if the damage came from a child"		self clipSubmorphs 			ifTrue:[damageRect := aRectangle intersect: self clippingBounds]].	owner ifNotNil: [owner invalidRect: damageRect from: self].! !!PolygonMorph methodsFor: 'geometry' stamp: 'nk 3/30/2002 12:29'!intersectionsWith: aRectangle	"Answer a Set of points where the given Rectangle intersects with me.	Ignores arrowForms."	| retval |	retval := IdentitySet new: 4.	(self bounds intersects: aRectangle) ifFalse: [^ retval].	self lineSegmentsDo: [ :lp1 :lp2 | | polySeg |		polySeg := LineSegment from: lp1 to: lp2.		aRectangle lineSegmentsDo: [ :rp1 :rp2 | | rectSeg int |			rectSeg := LineSegment from: rp1 to: rp2.			int := polySeg intersectionWith: rectSeg.			int ifNotNil: [ retval add: int ].		].	].	^retval! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 2/17/1999 17:50'!reserveUrl: urlString	"Write a dummy object to the server to hold a name and place for this object."	| dummy ext str |	dummy := PasteUpMorph new.	dummy borderWidth: 2.	dummy setProperty: #initialExtent toValue: (ext := 300@100).	dummy topLeft: 50@50; extent: ext.	"reset when comes in"	str := (TextMorph new) topLeft: dummy topLeft + (10@10); 		extent: dummy width - 15 @ 30.	dummy addMorph: str.	str contents: 'This is a place holder only.  Please \find the original page and choose \"send this page to server"' withCRs.	str extent: dummy width - 15 @ 30.	dummy saveOnURL: urlString.	"Claim that url myself"	self setProperty: #SqueakPage toValue: dummy sqkPage.	(dummy sqkPage) contentsMorph: self; dirty: true.	^ self url! !!HaloMorph methodsFor: 'private' stamp: 'dgd 8/28/2003 15:15'!addGraphicalHandle: formKey at: aPoint on: eventName send: selector to: recipient	"Add the supplied form as a graphical handle centered at the given point, and set it up to respond to the given event by sending the given selector to the given recipient.  Return the handle."	| handle |	handle := self addGraphicalHandleFrom: formKey at: aPoint.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.	^ handle! !!EventHandler methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:45'!convertToCurrentVersion: varDict refStream: smartRefStrm		"20 dec 2000 - only a few (old) conversion exists"	varDict at: 'mouseEnterLadenRecipient' ifPresent: [ :x | mouseEnterDraggingRecipient := x].	varDict at: 'mouseEnterLadenSelector' ifPresent: [ :x | mouseEnterDraggingSelector := x].	varDict at: 'mouseLeaveLadenRecipient' ifPresent: [ :x | mouseLeaveDraggingRecipient := x].	varDict at: 'mouseLeaveLadenSelector' ifPresent: [ :x | mouseLeaveDraggingSelector := x].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!TextMorph methodsFor: 'editing' stamp: 'nk 8/31/2004 15:31'!handleInteraction: interactionBlock fromEvent: evt	"Perform the changes in interactionBlock, noting any change in selection	and possibly a change in the size of the paragraph (ar 9/22/2001 - added for TextPrintIts)"	"Also couple ParagraphEditor to Morphic keyboard events"	| oldEditor oldParagraph oldText |	self editor sensor: (KeyboardBuffer new startingEvent: evt).	oldEditor := editor.	oldParagraph := paragraph.	oldText := oldParagraph text copy.	self selectionChanged.  "Note old selection"		interactionBlock value.	(oldParagraph == paragraph) ifTrue:[		"this will not work if the paragraph changed"		editor := oldEditor.     "since it may have been changed while in block"	].	self selectionChanged.  "Note new selection"	(oldText = paragraph text and: [ oldText runs = paragraph text runs ])		ifFalse:[ self updateFromParagraph ].	self setCompositionWindow.! !!FileDirectoryWrapper methodsFor: 'as yet unclassified' stamp: 'sps 12/5/2002 16:59'!setItem: anObject name: aString model: aModel	item := anObject.	model := aModel.	itemName := aString.	hasContents := nil.! !!Morph methodsFor: 'geometry eToy' stamp: 'tk 7/8/1998 23:47'!wrap	| myBox box newX newY wrapped |	owner ifNil: [^ self].	myBox := self fullBounds.	myBox corner < (50000@50000) ifFalse: [		self inform: 'Who is trying to wrap a hidden object?'. ^ self].	box := owner bounds.	newX := self position x.	newY := self position y.	wrapped := false.	((myBox right < box left) or: [myBox left > box right]) ifTrue: [		newX := box left + ((self position x - box left) \\ box width).		wrapped := true].	((myBox bottom < box top) or: [myBox top > box bottom]) ifTrue: [		newY := box top + ((self position y - box top) \\ box height).		wrapped := true].	self position: newX@newY.	(wrapped and: [owner isPlayfieldLike])		ifTrue: [owner changed].  "redraw all turtle trails if wrapped"! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/2/2000 08:36'!calculateColumnWidthsFrom: arrayOfMorphs 	| maxWidths |	maxWidths := Array new: arrayOfMorphs size - 1.	1		to: maxWidths size		do: [:idx | maxWidths at: idx put: 0].	1		to: maxWidths size		do: [:idx | (arrayOfMorphs at: idx)				do: [:mitem | mitem width							> (maxWidths at: idx)						ifTrue: [maxWidths at: idx put: mitem width]]].	^maxWidths! !!NewHandleMorph methodsFor: 'all' stamp: 'di 5/18/1998 15:27'!followHand: aHand forEachPointDo: block1 lastPointDo: block2	hand := aHand.	pointBlock := block1.	lastPointBlock := block2.	self position: hand lastEvent cursorPoint - (self extent // 2)! !!SketchMorph methodsFor: 'menu' stamp: 'yo 3/15/2005 12:04'!callThisBaseGraphic	"Set my baseGraphic to be the current form"	| aGraphic |	self isInWorld ifFalse: [^ self inform: 'oops, this menu is a for a morph thathas been replaced, probably because a"look like" script was run.  Please dismissthe menu and get a new one!!.  Sorry!!' translated].	((aGraphic := self valueOfProperty: #baseGraphic)				notNil and: [aGraphic ~= originalForm])		ifTrue:			[self setProperty: #baseGraphic toValue: originalForm]		ifFalse:			[self inform: 'this already *was* your baseGraphic' translated]! !!ProjectViewMorph methodsFor: 'submorphs-add/remove' stamp: 'tk 12/9/1999 08:03'!abandon	"Home ViewMorph of project is going away."	project := nil.	super abandon.! !!ComponentLikeModel methodsFor: 'components' stamp: 'di 5/3/1998 20:11'!initPinSpecs	"no-op for default"	pinSpecs := Array new.! !!Morph methodsFor: 'e-toy support' stamp: 'RAA 5/25/2000 09:06'!embedInWindow	| window worldToUse |	worldToUse := self world.		"I'm assuming we are already in a world"	window := (SystemWindow labelled: self defaultLabelForInspector) model: nil.	window bounds: ((self position - ((0@window labelHeight) + window borderWidth))						corner: self bottomRight + window borderWidth).	window addMorph: self frame: (0@0 extent: 1@1).	window updatePaneColors.	worldToUse addMorph: window.	window activate! !!MenuItemMorph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:59'!vResizing	"Default to #shrinkWrap"	| props |	props := self layoutProperties.	^props ifNil:[#shrinkWrap] ifNotNil:[props vResizing].! !!HaloMorph methodsFor: 'handles' stamp: 'RAA 3/15/2001 11:24'!addRecolorHandle: haloSpec	"Add a recolor handle to the receiver, if appropriate"	| recolorHandle |	"since this halo now opens a more general properties panel, allow it in all cases"	"innerTarget canSetColor ifTrue:"	recolorHandle := self addHandle: haloSpec on: #mouseUp send: #doRecolor:with: to: self.	recolorHandle on: #mouseUp send: #doRecolor:with: to: self! !!Slider methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:30'!initialize	"initialize the state of the receiver"	super initialize.	""	value := 0.0.	descending := false.	self initializeSlider! !!HaloMorph methodsFor: 'private' stamp: 'sw 6/17/1999 16:58'!dismiss	"Remove my target from the world."	| w |	self isThisEverCalled. "Seemingly no longer enfranchised"	w := self world.	w ifNotNil: [w stopStepping: target].	self delete.	target dismissViaHalo! !!Morph methodsFor: 'macpal' stamp: 'sw 5/17/2001 17:57'!currentVocabulary	"Answer the receiver's current vocabulary"	| outer |	^ (outer := self ownerThatIsA: StandardViewer orA: ScriptEditorMorph) 			ifNotNil:				[outer currentVocabulary]			ifNil:				[super currentVocabulary]! !!WindowColorSpec methodsFor: 'initialization' stamp: 'sw 2/26/2002 13:39'!classSymbol: sym wording: wrd brightColor: brCol pastelColor: paCol helpMessage: hlpMsg	"Initialize the receiver's instance variables"	classSymbol := sym.	wording := wrd.	brightColor := brCol.	pastelColor := paCol.	helpMessage := hlpMsg! !!SystemWindow methodsFor: 'events' stamp: 'bmk 3/19/2002 02:09'!doFastFrameDrag: grabPoint	"Do fast frame dragging from the given point"	| offset newBounds outerWorldBounds |	outerWorldBounds := self boundsIn: nil.	offset := outerWorldBounds origin - grabPoint.	newBounds := outerWorldBounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: outerWorldBounds extent].	self position: (self globalPointToLocal: newBounds topLeft); comeToFront! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 5/20/2003 15:04'!keyboardNavigationHandler	"Answer the receiver's existing keyboardNavigationHandler, or nil if none."	| aHandler |	aHandler := self valueOfProperty: #keyboardNavigationHandler ifAbsent: [^ nil].	(aHandler hasProperty: #moribund) ifTrue:  "got clobbered in another project"		[self removeProperty: #keyboardNavigationHander.		^ nil].	^ aHandler! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:56'!disableTableLayout	"Layout specific. Disable laying out the receiver in table layout"	| props |	props := self layoutProperties.	^props ifNil:[false] ifNotNil:[props disableTableLayout].! !!HaloMorph methodsFor: 'private' stamp: 'sw 4/27/2000 13:39'!addCircleHandles	| box |	simpleMode := false.	target isWorldMorph ifTrue: [^ self addHandlesForWorldHalos].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target renderedMorph worldBoundsForHalo.  "update my size"	box := self basicBox.	target addHandlesTo: self box: box.	self addName.	growingOrRotating := false.	self layoutChanged.	self changed.! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:10'!width: aNumber	width = aNumber ifTrue:[^self].	width := aNumber truncated max: (width isPoint ifTrue:[0@0] ifFalse:[0]).	self releaseCachedState.! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37'!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX := leftMorph layoutFrame rightFraction.	minY := (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY := (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter := ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !!Morph methodsFor: 'initialization' stamp: 'sw 9/11/1998 11:13'!standardPalette	"Answer a standard palette forced by some level of enclosing presenter, or nil if none"	| pal aPresenter itsOwner |	(aPresenter := self presenter) ifNil: [^ nil].	^ (pal := aPresenter ownStandardPalette)		ifNotNil: [pal]		ifNil:	[(itsOwner := aPresenter associatedMorph owner)					ifNotNil:						[itsOwner standardPalette]					ifNil:						[nil]]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:02'!wrapCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of secondary direction		#bottomRight - center at end of secondary direction		#center - center in the middle of secondary direction		#justified - insert extra space inbetween rows/columns	"	| props |	props := self layoutProperties.	^props ifNil:[#topLeft] ifNotNil:[props wrapCentering].! !!MorphicEvent methodsFor: 'private' stamp: 'ar 10/25/2000 20:53'!setTimeStamp: stamp	timeStamp := stamp.! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'ls 5/15/2001 22:22'!createMorphicListsFrom: arrayOfLists 	| array |	array := Array new: arrayOfLists size.	1 to: arrayOfLists size do: [:arrayIndex |		array at: arrayIndex put: (			(arrayOfLists at: arrayIndex) collect: [:item | item isText						ifTrue: [StringMorph								contents: item								font: self font								emphasis: (item emphasisAt: 1)]						ifFalse: [StringMorph contents: item font: self font]])		].	^array! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction: aNumber offset: anInteger	bottomFraction := aNumber.	bottomOffset := anInteger! !!Morph methodsFor: 'menus' stamp: 'RAA 11/14/2000 13:46'!uncollapseSketch	| uncollapsedVersion w whomToDelete |	(w := self world) ifNil: [^self].	uncollapsedVersion := self valueOfProperty: #uncollapsedMorph.	uncollapsedVersion ifNil: [^self].	whomToDelete := self valueOfProperty: #collapsedMorphCarrier.	uncollapsedVersion setProperty: #collapsedPosition toValue: whomToDelete position.	whomToDelete delete.	w addMorphFront: uncollapsedVersion.! !!Morph methodsFor: 'geometry eToy' stamp: 'RAA 11/8/2000 18:29'!cartesianBoundsTopLeft	"Answer the origin of this morph relative to it's container's cartesian origin. 	NOTE: y DECREASES toward the bottom of the screen"	| w container |	w := self world ifNil: [^ bounds origin].	container := self referencePlayfield ifNil: [w].	^ (bounds left - container cartesianOrigin x) @		(container cartesianOrigin y - bounds top)! !!MovieMorph methodsFor: 'stepping and presenter' stamp: ''!step	playMode = #stop ifTrue: [^ self].	dwellCount > 0 ifTrue: [		dwellCount := dwellCount - 1.		^ self].	currentFrameIndex < frameList size		ifTrue: [^ self setFrame: currentFrameIndex + 1].	playMode = #loop		ifTrue: [self setFrame: 1]		ifFalse: [playMode := #stop].! !!SketchMorph methodsFor: 'caching' stamp: 'di 3/2/98 14:14'!releaseCachedState	"Clear cache of rotated, scaled Form."	super releaseCachedState.	rotatedForm := nil.	originalForm hibernate! !!HandMorph methodsFor: 'double click support' stamp: 'ar 9/18/2000 17:16'!resetClickState	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	mouseClickState := nil.! !!TextMorph methodsFor: 'editing' stamp: 'ar 9/26/2001 22:45'!enterClickableRegion: evt	| index isLink |	evt hand hasSubmorphs ifTrue:[^self].	evt hand temporaryCursor ifNotNil:[^self].	paragraph ifNotNil:[		index := (paragraph characterBlockAtPoint: evt position) stringIndex.		isLink := (paragraph text attributesAt: index forStyle: paragraph textStyle) 					anySatisfy:[:attr| attr mayActOnClick].		isLink ifTrue:[Cursor webLink show] ifFalse:[Cursor normal show].	].! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57'!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles := true.	labelString ifNil: [labelString := 'Untitled Window'].	isCollapsed := false.	activeOnlyOnTop := true.	paneMorphs := Array new.	borderColor := Color lightGray.	borderWidth := 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose := false.	updatablePanes := Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!KeyboardBuffer methodsFor: 'as yet unclassified' stamp: 'di 9/29/97 12:34'!keyboard	eventUsed ifFalse: [eventUsed := true.  ^ event keyCharacter].	^ nil! !!Morph methodsFor: 'dropping/grabbing' stamp: 'dgd 8/26/2003 21:44'!undoGrabCommand	"Return an undo command for grabbing the receiver"	| cmd |	owner ifNil:		[^ nil]. "no owner - no undo"	^ (cmd := Command new)		cmdWording: 'move ' translated, self nameForUndoWording;		undoTarget: self		selector: #undoMove:redo:owner:bounds:predecessor:		arguments: {cmd. false. owner. self bounds. (owner morphPreceding: self)};		yourself! !!MenuItemMorph methodsFor: 'events' stamp: 'RAA 1/18/2001 18:21'!invokeWithEvent: evt	"Perform the action associated with the given menu item."	| selArgCount w |	self isEnabled ifFalse: [^ self].	target class == HandMorph ifTrue: [(self notObsolete) ifFalse: [^ self]].	owner ifNotNil:[self isStayUpItem ifFalse:[		self flag: #workAround. "The tile system invokes menus straightforwardly so the menu might not be in the world."		(w := self world) ifNotNil:[			owner deleteIfPopUp: evt.			"Repair damage before invoking the action for better feedback"			w displayWorldSafely]]].	selector ifNil:[^self].	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		(selArgCount := selector numArgs) = 0			ifTrue:				[target perform: selector]			ifFalse:				[selArgCount = arguments size					ifTrue: [target perform: selector withArguments: arguments]					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]]].! !!DropEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:19'!copyHandlerState: anEvent	"Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."	wasHandled := anEvent wasHandled.! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'ls 7/15/2002 11:16'!mouseDown: event	| oldIndex oldVal row |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	row := self rowAtLocation: event position.	row = 0 ifTrue: [^super mouseDown: event].	model okToChange ifFalse: [^ self].  "No change if model is locked"	"Set meaning for subsequent dragging of selection"	dragOnOrOff := (self listSelectionAt: row) not.	oldIndex := self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal := self listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self changeModelSelection: row]		ifFalse: [self changeModelSelection: 0].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [self listSelectionAt: oldIndex put: oldVal].	self listSelectionAt: row put: dragOnOrOff.	"event hand releaseMouseFocus: aMorph."	"aMorph changed"! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'tk 12/1/2000 15:08'!minimumWidth: aWidth	"Set the minimum width that the receiver can have.  A nonzero value here keeps the receiver from degenerating into something that cannot ever be seen or touched again!!  Obeyed by fitContents."	minimumWidth := aWidth! !!TextMorph methodsFor: 'accessing' stamp: 'sw 8/10/2004 00:56'!setLastCharacter: source	"Set the last character of the receiver as indicated"	| aChar chars |	aChar := source asCharacter.	(chars := self getCharacters) size > 0 		ifFalse:			[self newContents: (String with: aChar)]		ifTrue:			[(chars last = aChar) ifFalse:				[self newContents: (String streamContents:					[:aStream |						aStream nextPutAll: (chars copyFrom: 1 to: (chars size - 1)).						aStream nextPut: aChar])]]! !!FormCanvas methodsFor: 'drawing' stamp: 'di 9/12/2001 21:38'!paragraph: para bounds: bounds color: c	| scanner |	self setPaintColor: c.	scanner := (port clippedBy: (bounds translateBy: origin)) displayScannerFor: para		foreground: (self shadowColor ifNil:[c]) background: Color transparent		ignoreColorChanges: self shadowColor notNil.	para displayOn: (self copyClipRect: bounds) using: scanner at: origin+ bounds topLeft.! !!ScrollPane methodsFor: 'menu' stamp: 'sw 1/13/98 21:27'!scrollBarOnLeft: aBoolean	scrollBarOnLeft := aBoolean.	self extent: self extent! !!Morph methodsFor: 'private' stamp: 'RAA 5/23/2000 11:30'!privateRemoveMorphWithAbsolutelyNoSideEffects: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	"used to delete a morph from an inactive world"	submorphs := submorphs copyWithout: aMorph.! !!MenuMorph class methodsFor: 'images' stamp: 'jrp 7/27/2005 23:11'!closeBoxImage	"Supplied here because we don't necessarily have ComicBold"	^ CloseBoxImage ifNil: [CloseBoxImage := SystemWindow closeBoxImage]! !!MorphicUnknownEvent methodsFor: 'initialize' stamp: 'ar 10/26/2000 01:20'!type: eventType readFrom: aStream	| typeAndArg |	timeStamp := Integer readFrom: aStream.	aStream skip: 1.	typeAndArg := Object readFrom: aStream.	type := typeAndArg first.	argument := typeAndArg last.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!triggerOpeningScripts	"If the receiver has any scripts set to run on opening, run them now"	| aPlayer |	(aPlayer := self player) ifNotNil:		[aPlayer runAllOpeningScripts]! !!HandMorph methodsFor: 'caching' stamp: 'ar 10/26/2000 15:28'!releaseCachedState	| oo ui |	ui := userInitials.	super releaseCachedState.	cacheCanvas := nil.	oo := owner.	self removeAllMorphs.	self initialize.	"nuke everything"	self privateOwner: oo.	self releaseAllFoci.	self userInitials: ui andPicture: (self userPicture).! !!TheWorldMenu methodsFor: 'commands' stamp: 'RAA 5/24/2000 18:13'!saveWorldInFile	"Save the world's submorphs, model, and stepList in a file.  "	| fileName fileStream aClass |	fileName := FillInTheBlank request: 'File name for this morph?'.	fileName isEmpty ifTrue: [^ self].  "abort"	"Save only model, stepList, submorphs in this world"	myWorld submorphsDo: [:m |		m allMorphsDo: [:subM | subM prepareToBeSaved]].	"Amen"	fileStream := FileStream newFileNamed: fileName, '.morph'.	aClass := myWorld model ifNil: [nil] ifNotNil: [myWorld model class].	fileStream fileOutClass: aClass andObject: myWorld.! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 2/15/1999 19:32'!impartPrivatePresenter	presenter ifNil:		[presenter := Presenter new associatedMorph: self.		presenter standardPlayer]! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 10/18/2004 00:05'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := (aDisplayTransform globalBoundsToLocal: innerRect) truncated.	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	warp cellSize: cellSize.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!SystemWindow methodsFor: 'menu' stamp: 'sw 8/7/2000 17:35'!deleteCloseBox	closeBox ifNotNil:		[closeBox delete.		closeBox := nil]! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'wiz 7/13/2005 00:43'!arrowPrototype	"Answer an instance of the receiver that will serve as a prototypical arrow"	| aa |	aa := self new. 	aa vertices: (Array with: 0@0 with: 40@40) 		color: Color black 		borderWidth: 2 		borderColor: Color black.	"aa setProperty: #noNewVertices toValue: true."	"Revert to expected behavior. Remove vestigial code."	aa makeForwardArrow.		"is already open"	aa computeBounds.	^ aa! !!PolygonMorph methodsFor: 'menu' stamp: 'md 12/12/2003 16:22'!customizeArrows: evt	| handle origin aHand |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	handle := HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			self arrowSpec: (newPoint - origin) / 5.0]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor left and rightto change arrow length and style.Move it up and down to change width.Click when done.' hand: evt hand.	handle startStepping! !!TransferMorph methodsFor: 'accessing' stamp: 'sr 4/16/2000 18:53'!passenger: anObject	passenger := anObject! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction: aNumber	rightFraction := aNumber! !!ProjectViewMorph methodsFor: 'objects from disk' stamp: 'RAA 10/27/2000 11:08'!objectForDataStream: refStrm		| copy |	1 = 1 ifTrue: [^self].		"this didn't really work"	copy := self copy lastProjectThumbnail: nil.	"refStrm replace: self with: copy."	^copy! !!FileList2 methodsFor: 'initialization' stamp: 'ar 2/12/2001 16:12'!initialDirectoryList	| dir nameToShow dirList |	dirList := (FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self].	dirList isEmpty ifTrue:[		dirList := Array with: (FileDirectoryWrapper 			with: FileDirectory default 			name: FileDirectory default localName 			model: self)].	dirList := dirList,(		ServerDirectory serverNames collect: [ :n | 			dir := ServerDirectory serverNamed: n.			nameToShow := n.			(dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl		]	).	^dirList! !!TextMorph methodsFor: 'drawing' stamp: 'yo 1/23/2003 18:04'!drawOnTest: aCanvas	"Draw the receiver on a canvas"	| fauxBounds |	self setDefaultContentsIfNil.	super drawOn: aCanvas.  "Border and background if any"	false ifTrue: [self debugDrawLineRectsOn: aCanvas].  "show line rects for debugging"	(self startingIndex > text size)		ifTrue: [self drawNullTextOn: aCanvas].	"Hack here:  The canvas expects bounds to carry the location of the text, but we also need to communicate clipping."	fauxBounds := self bounds topLeft corner: self innerBounds bottomRight.	aCanvas paragraph3: self paragraph bounds: fauxBounds color: color! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!framesToDwell: anInteger	framesToDwell := anInteger.! !!SystemProgressMorph methodsFor: 'labelling' stamp: 'ar 7/18/2009 21:17'!labelAt: progressBlock put: aString	"Change the label for the given progressBlock to aString.	Fixme: I don't know how to map from progressBlock to label.	For now we just use the top-level label since this works just fine."	labels first ifNotNil:[:lbl| lbl contents: aString].! !!PluggableListMorph methodsFor: 'initialization' stamp: 'di 4/10/98 16:20'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect := trueOrFalse.! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 12/31/2001 02:25'!test3	"FormCanvas test3"	| baseCanvas |	baseCanvas := FormCanvas extent: 200@200.	baseCanvas fillColor: Color white.	baseCanvas translateBy: 10@10 during:[:canvas|		canvas shadowColor: (Color black alpha: 0.5).		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas point: 100@100 color: Color black.		canvas drawString: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0.	].! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/12/2004 16:17'!primitiveCopyFileNamed: srcName to: dstName 	"Copied from VMMaker code.	This really ought to be a facility in file system. The major annoyance 	here is that file types and permissions are not handled by current 	Squeak code.	NOTE that this will clobber the destination file!!"	| buffer src dst |	<primitive: 'primitiveFileCopyNamedTo' module:'FileCopyPlugin'> "primitiveExternalCall" 	"If the plugin doesn't do it, go the slow way and lose the filetype info"	"This method may signal FileDoesNotExistException if either the source or 	dest files cannnot be opened; possibly permissions or bad name problems"	[[src := FileStream readOnlyFileNamed: srcName]		on: FileDoesNotExistException		do: [^ self error: ('could not open file ', srcName)].	[dst := FileStream forceNewFileNamed: dstName]		on: FileDoesNotExistException		do: [^ self error: ('could not open file ', dstName)].	buffer := String new: 50000.	[src atEnd]		whileFalse: [dst				nextPutAll: (src nextInto: buffer)]]		ensure: [src				ifNotNil: [src close].			dst				ifNotNil: [dst close]]! !!PluggableListMorph methodsFor: 'events' stamp: 'ls 5/16/2001 22:28'!doubleClick: event	| index |	doubleClickSelector isNil ifTrue: [^super doubleClick: event].	index := self rowAtLocation: event position.	index = 0 ifTrue: [^super doubleClick: event].	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."	^ self model perform: doubleClickSelector! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/27/2000 14:04'!referencePosition: aPosition	"Move the receiver to match its reference position with aPosition"	| newPos intPos |	newPos := self position + (aPosition - self referencePosition).	intPos := newPos asIntegerPoint.	newPos = intPos 		ifTrue:[self position: intPos]		ifFalse:[self position: newPos].! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: ''!expandAll: aMorph	| allChildren |	aMorph toggleExpandedState.	allChildren := OrderedCollection new: 10.	aMorph recursiveAddTo: allChildren.	allChildren do: [:each | 		(each canExpand and: [each isExpanded not])			ifTrue: [self expandAll: each]].! !!ProjectViewMorph methodsFor: 'initialization' stamp: 'RAA 1/26/2001 09:14'!initialize	super initialize.	"currentBorderColor := Color gray."	self addProjectNameMorphFiller.! !!ProgressBarMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:51'!changeProgressColor: evt	| aHand |	aHand := evt ifNotNil: [evt hand] ifNil: [self primaryHand].	self changeColorTarget: self selector: #progressColor: originalColor: self progressColor hand: aHand.! !!SystemWindow methodsFor: 'top window' stamp: 'di 5/14/1998 12:38'!activeOnlyOnTop: trueOrFalse	activeOnlyOnTop := trueOrFalse! !!UserInputEvent methodsFor: 'initialize' stamp: 'ar 9/13/2000 15:54'!resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"	handler := nil.	wasHandled := false.! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 11/12/1998 00:32'!transformBy: aTransform	aTransform ifNil:[^self].	transform 		ifNil:[transform := aTransform]		ifNotNil:[transform := transform composedWithLocal: aTransform]! !!PolygonMorph methodsFor: 'menu' stamp: 'tk 9/2/97 16:04'!removeHandles	"tk 9/2/97 allow it to be called twice (when nil already)"	handles ifNotNil: [		handles do: [:h | h delete].		handles := nil].! !!ThreePhaseButtonMorph methodsFor: 'submorphs-add/remove' stamp: 'tk 6/30/97 10:49'!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed"	actWhen := condition! !!MorphicUnknownEvent methodsFor: 'accessing' stamp: 'ar 10/25/2000 20:04'!argument: arg	argument := arg! !!SystemProgressBarMorph methodsFor: 'accessing' stamp: 'laza 4/9/2004 10:37'!barSize: anInteger	barSize := anInteger.	self changed.! !!SystemWindow class methodsFor: 'top window' stamp: 'gm 2/16/2003 20:55'!noteTopWindowIn: aWorld	| newTop |	"TopWindow must be nil or point to the top window in this project."	TopWindow := nil.	aWorld ifNil: [^ self].	newTop := nil.	aWorld submorphsDo:		[:m | (m isSystemWindow) ifTrue:			[(newTop == nil and: [m activeOnlyOnTop])				ifTrue: [newTop := m].			(m model isKindOf: Project)				ifTrue: ["This really belongs in a special ProjWindow class"						m label ~= m model name ifTrue: [m setLabel: m model name]]]].	newTop == nil ifFalse: [newTop activate]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 10/20/2000 13:12'!submorphAfter	"Return the submorph after (behind) me, or nil"	| ii |	owner ifNil: [^ nil].	^ (ii := owner submorphIndexOf: self) = owner submorphs size 		ifTrue: [nil]		ifFalse: [owner submorphs at: ii+1].	! !!WorldState methodsFor: 'initialization' stamp: 'RAA 1/7/2001 12:33'!stepListSortBlock	| answer |	"Please pardon the hackery below. Since the block provided by this method is retained elsewhere, it is possible that the block argument variables would retain references to objects that were no longer really needed. In one case, this feature resulted in doubling the size of a published project."	^[ :stepMsg1 :stepMsg2 | 		answer := stepMsg1 scheduledTime <= stepMsg2 scheduledTime.		stepMsg1 := stepMsg2 := nil.		answer	]! !!FileList2 methodsFor: 'volume list and pattern' stamp: 'mir 8/24/2001 12:03'!listForPattern: pat	"Make the list be those file names which match the pattern."	| sizePad newList entries |	directory ifNil: [^#()].	entries := (Preferences eToyLoginEnabled		and: [Utilities authorNamePerSe notNil])		ifTrue: [directory matchingEntries: {'submittedBy: ' , Utilities authorName.} ]		ifFalse: [directory entries].	(fileSelectionBlock isKindOf: MessageSend) ifTrue: [		fileSelectionBlock arguments: {entries}.		newList := fileSelectionBlock value.		fileSelectionBlock arguments: #().	] ifFalse: [		newList := entries select: [:entry | fileSelectionBlock value: entry value: pat].	].	newList := newList asSortedCollection: self sortBlock.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	^ newList asArray! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!saveAsWorld	| worldName s |	worldName := FillInTheBlank		request: 'Please give this world a name'		initialAnswer: 'test'.	((self class class includesSelector: worldName asSymbol) and:		[(PopUpMenu confirm: 'OK to overwrite ' , worldName , '?') not])		ifTrue: [^ self].	s := WriteStream on: (String new: 1000).	s	nextPutAll: worldName; cr; tab;		nextPutAll: '"' , self class name , ' ' , worldName, ' open"'; cr; cr; tab;		nextPutAll: '^ '.	self printConstructorOn: s indent: 0.	s cr.	self class class		compile: s contents		classified: 'examples'		notifying: nil.! !!StringMorphAttributeScanner methodsFor: 'scanning' stamp: 'nk 2/26/2004 13:09'!setActualFont: aFont	"Set the value of actualFont, from a TextFontReference"	actualFont := aFont.	aFont textStyle ifNotNilDo: [ :ts | fontNumber := ts fontIndexOf: aFont ]! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'yo 3/16/2005 18:26'!valueFromContents	"Return a new value from the current contents string.""	| expression tilePadMorphOrNil asNumberBlock |	asNumberBlock := [:string | [string asNumber]				on: Error				do: []].	format = #string		ifTrue: [^ contents].	(format = #default			and: [self owner isKindOf: NumericReadoutTile])		ifTrue: [^ asNumberBlock value: contents].	tilePadMorphOrNil := self ownerThatIsA: TilePadMorph.	(tilePadMorphOrNil notNil			and: [tilePadMorphOrNil type = #Number])		ifTrue: [^ asNumberBlock value: contents].	expression := Vocabulary eToyVocabulary translationKeyFor: contents.	expression isNil		ifTrue: [expression := contents].	^ Compiler evaluate: expression"	format = #symbol ifTrue: [^ lastValue].	format = #string ifTrue: [^ contents].	(owner notNil and: [owner isMemberOf: NumericReadoutTile]) ifTrue: [		^ Number readFrom: contents	].	target ifNotNil: [target owner ifNotNil: [		((target owner isMemberOf: TilePadMorph) and: [target owner type = #Number])			ifTrue: [^ Number readFrom: contents]]].	^ Compiler evaluate: contents! !!MorphicModel methodsFor: 'compilation' stamp: ''!propagate: value as: partStoreSelector	model ifNil: [^ self]."	Later we can cache this for more speed as follows...	(partName == cachedPartName and: [slotName == cachedSlotName])		ifFalse: [cachedPartName := partName.				cachedSlotName := slotName.				cachedStoreSelector := (slotName , partStoreSelector) asSymbol].	model perform: cachedStoreSelector with: value]."	model perform: (self slotSelectorFor: partStoreSelector) with: value! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 10/26/2000 11:32'!presentCardAndStackMenu	"Put up a menu holding card/stack-related options."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.			aMenu addStayUpItem.	aMenu addTitle: 'card und stack'.	aMenu add: 'add new card' action: #insertCard.	aMenu add: 'delete this card' action: #deleteCard.	aMenu add: 'go to next card' action: #goToNextCardInStack.	aMenu add: 'go to previous card' action: #goToPreviousCardInStack.	aMenu addLine.	aMenu add: 'show foreground objects' action: #showForegroundObjects.	aMenu add: 'show background objects' action: #showBackgroundObjects.	aMenu add: 'show designations' action: #showDesignationsOfObjects.	aMenu add: 'explain designations'  action: #explainDesignations.	aMenu popUpInWorld: (self world ifNil: [self currentWorld])! !!ColorPickerMorph methodsFor: 'private' stamp: 'ar 7/19/2003 20:40'!argumentsWith: aColor	"Return an argument array appropriate to this action selector"	| nArgs |	nArgs := selector ifNil:[0] ifNotNil:[selector numArgs].	nArgs = 0 ifTrue:[^#()].	nArgs = 1 ifTrue:[^ {aColor}].	nArgs = 2 ifTrue:[^ {aColor. sourceHand}].	nArgs = 3 ifTrue:[^ {aColor. argument. sourceHand}].! !!MovieMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:25'!insertIntoMovie: evt	| movies aTarget |	movies :=		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget := movies first.	(aTarget isSketchMorph) ifTrue:		[aTarget := aTarget replaceSelfWithMovie].	movies first insertFrames: frameList.	self delete.! !!PluggableListMorph methodsFor: 'model access' stamp: 'ls 8/19/2001 14:16'!getList	"Answer the list to be displayed.  Caches the returned list in the 'list' ivar"	getListSelector == nil ifTrue: [^ #()].	list := model perform: getListSelector.	list == nil ifTrue: [^ #()].	list := list collect: [ :item | item asStringOrText ].	^ list! !!StandardScriptingSystem methodsFor: 'help dictionary' stamp: 'sw 6/15/1999 17:03'!initializeHelpStrings	"Initialize the data structure that determines, for the etoy system, help messages for various scripting elements.  The structure is built up by letting every Morph subclass contribute elements simply by implementing method #helpContributions.  Consult implementors of #helpContributions for examples of how this goes."	"ScriptingSystem initializeHelpStrings"	| aDictionary |	aDictionary := IdentityDictionary new.  	"For safety, the new copy is built up in this temp first, so that if an error occurs during the creation of the structure, the old version will remain remain in place"	Morph withAllSubclasses do:		[:aClass | (aClass class selectors includes: #helpContributions)			ifTrue:				[aClass helpContributions do:					[:pair | aDictionary at: pair first put: pair second]]].		HelpStrings := aDictionary! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'tk 6/30/97 10:08'!offImage: aForm	offImage := aForm.	self invalidRect: self bounds.! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'NS 8/1/2000 11:39'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean answerExtent: answerExtent	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| aFillInTheBlankMorph |	aFillInTheBlankMorph := self new		setQuery: queryString		initialAnswer: defaultAnswer		answerExtent: answerExtent		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.	aWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.	^ aFillInTheBlankMorph getUserResponse! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'th 11/18/2002 19:13'!composeAllRectangles: rectangles	| charIndexBeforeLine numberOfLinesBefore reasonForStopping |	actualHeight := defaultLineHeight.	charIndexBeforeLine := currCharIndex.	numberOfLinesBefore := lines size.	reasonForStopping := self composeEachRectangleIn: rectangles.	currentY := currentY + actualHeight.	currentY > theContainer bottom ifTrue: [		"Oops -- the line is really too high to fit -- back out"		currCharIndex := charIndexBeforeLine.		lines size - numberOfLinesBefore timesRepeat: [lines removeLast].		^self	].		"It's OK -- the line still fits."	maxRightX := maxRightX max: scanner rightX.	1 to: rectangles size - 1 do: [ :i |		"Adjust heights across rectangles if necessary"		(lines at: lines size - rectangles size + i)			lineHeight: lines last lineHeight			baseline: lines last baseline	].	isFirstLine := false.	reasonForStopping == #columnBreak ifTrue: [^nil].	currCharIndex > theText size ifTrue: [		^nil		"we are finished composing"	].	! !!HandMorph methodsFor: 'meta-actions' stamp: 'ar 11/6/2000 13:07'!copyToPasteBuffer: aMorph	"Save this morph in the paste buffer. This is mostly useful for copying morphs between projects."	aMorph ifNil:[^PasteBuffer := nil].	Cursor wait showWhile:[		PasteBuffer := aMorph topRendererOrSelf veryDeepCopy.		PasteBuffer privateOwner: nil].! !!FileList methodsFor: 'file list menu' stamp: 'nk 12/7/2002 12:56'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| suffix |	suffix := self class suffixOf: fullName.	^ (self class itemsForFile: fullName) , (self myServicesForFile: fullName suffix: suffix)! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'yo 3/14/2005 13:09'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := FillInTheBlank		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!PluggableTabButtonMorph methodsFor: 'updating' stamp: 'KLC 1/23/2004 17:02'!update: aSelector	self textSelector ifNotNil: [		aSelector = self textSelector			ifTrue: [ | morph |				(aSelector isSymbol and: [model notNil])					ifTrue: [						morph :=							(self model perform: aSelector) asMorph]					ifFalse: [ morph := aSelector value asMorph].				self subMorph: morph]].	self changed! !!Morph methodsFor: 'e-toy support' stamp: 'tk 9/3/1999 11:46'!wrappedInWindow: aSystemWindow	| aWindow |	aWindow := aSystemWindow model: Model new.	aWindow addMorph: self frame: (0@0 extent: 1@1).	aWindow extent: self extent.	^ aWindow! !!ColorPickerMorph methodsFor: 'private' stamp: 'ar 8/25/2001 20:50'!updateColor: aColor feedbackColor: feedbackColor	"Set my selected color to the given color if it is different. Give user feedback. Inform the target of the change if the target and selector are not nil." 	selectedColor = aColor ifTrue: [^ self].  "do nothing if color doesn't change"	self updateAlpha: aColor alpha.	originalForm fill: FeedbackBox fillColor: feedbackColor.	self form: originalForm.	selectedColor := aColor.	updateContinuously ifTrue: [self updateTargetColor].	self locationIndicator center: self topLeft + (self positionOfColor: feedbackColor).! !!ProgressBarMorph methodsFor: 'drawing' stamp: 'sma 3/3/2000 18:54'!drawOn: aCanvas	| width inner |	super drawOn: aCanvas.	inner := self innerBounds.	width := (inner width * lastValue) truncated min: inner width.	aCanvas fillRectangle: (inner origin extent: width @ inner height) color: progressColor.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:01'!rubberBandCells	"Layout specific. This property describes if a parent that is #shrinkWrapped around its children should ignore any #spaceFill children. E.g., when #rubberBandCells is true, the compound layout will always stay at the smallest available size, even though some child may be able to grow."	| props |	props := self layoutProperties.	^props ifNil:[false] ifNotNil:[props rubberBandCells].! !!Morph methodsFor: 'events-accessing' stamp: 'rw 4/25/2002 07:18'!actionMap	"Answer an action map"	| actionMap |	actionMap := self valueOfProperty: #actionMap.	actionMap ifNil:		[actionMap := self createActionMap].	^ actionMap! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 4/23/2001 15:17'!grabMorph: aMorph from: formerOwner	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| grabbed offset targetPoint grabTransform fullTransform |	self releaseMouseFocus. "Break focus"	grabbed := aMorph.	aMorph keepsTransform ifTrue:[		grabTransform := fullTransform := IdentityTransform new.	] ifFalse:[		"Compute the transform to apply to the grabbed morph"		grabTransform := formerOwner 			ifNil:		[IdentityTransform new] 			ifNotNil:	[formerOwner grabTransform].		"Compute the full transform for the grabbed morph"		fullTransform := formerOwner 			ifNil:		[IdentityTransform new] 			ifNotNil:	[formerOwner transformFrom: owner].	].	"targetPoint is point in aMorphs reference frame"	targetPoint := fullTransform globalPointToLocal: self position.	"but current position will be determined by grabTransform, so compute offset"	offset := targetPoint - (grabTransform globalPointToLocal: self position).	"apply the transform that should be used after grabbing"	grabbed := grabbed transformedBy: grabTransform.	grabbed == aMorph 		ifFalse:	[grabbed setProperty: #addedFlexAtGrab toValue: true].	"offset target to compensate for differences in transforms"	grabbed position: grabbed position - offset asIntegerPoint.	"And compute distance from hand's position"	targetOffset := grabbed position - self position.	self addMorphBack: grabbed.	grabbed justGrabbedFrom: formerOwner.! !!SimpleHierarchicalListMorph methodsFor: 'scrolling' stamp: 'sps 3/23/2004 15:51'!hUnadjustedScrollRange"Return the width of the widest item in the list"	| max right stringW count |	max := 0.	count := 0.	scroller submorphsDo: [ :each |		stringW := each font widthOfStringOrText: each contents.		right := (each toggleRectangle right + stringW + 10).		max := max max: right.		"NOTE: need to optimize this method by caching list item morph widths (can init that cache most efficiently in the #list: method before the item widths are reset to 9999).  For now, just punt on really long lists"		((count := count + 1) > 200) ifTrue:[ ^max * 3].	].	^max ! !!Morph methodsFor: 'menus' stamp: 'dgd 8/30/2003 16:44'!addFillStyleMenuItems: aMenu hand: aHand	"Add the items for changing the current fill style of the Morph"	| menu |	self canHaveFillStyles ifFalse:[^aMenu add: 'change color...' translated target: self action: #changeColor].	menu := MenuMorph new defaultTarget: self.	self fillStyle addFillStyleMenuItems: menu hand: aHand from: self.	menu addLine.	menu add: 'solid fill' translated action: #useSolidFill.	menu add: 'gradient fill' translated action: #useGradientFill.	menu add: 'bitmap fill' translated action: #useBitmapFill.	menu add: 'default fill' translated action: #useDefaultFill.	aMenu add: 'fill style' translated subMenu: menu.	"aMenu add: 'change color...' translated action: #changeColor"! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 9/22/1998 12:26'!paintingBoundsAround: aPoint	"Return a rectangle for painting centered on the given point. Both the argument point and the result rectangle are in world coordinates."	| paintExtent maxPaintArea myBnds |	paintExtent := self reasonablePaintingExtent.	maxPaintArea := paintExtent x * paintExtent y.	myBnds := self boundsInWorld.	(myBnds area <= maxPaintArea) ifTrue: [^ myBnds].	^ (aPoint - (paintExtent // 2) extent: paintExtent) intersect: myBnds! !!ComponentLikeModel methodsFor: 'components' stamp: 'di 5/1/1998 16:14'!addPinFromSpec: pinSpec	| pin |	pin := PinMorph new component: self pinSpec: pinSpec.	self addMorph: pin.	pin placeFromSpec.	^ pin! !!PluggableListMorphOfMany methodsFor: 'initialization' stamp: 'tpr 10/4/2001 21:24'!on: anObject list: listSel primarySelection: getSelectionSel changePrimarySelection: setSelectionSel listSelection: getListSel changeListSelection: setListSel menu: getMenuSel keystroke: keyActionSel	"setup a whole load of pluggability options"	getSelectionListSelector := getListSel.	setSelectionListSelector := setListSel.	super on: anObject list: listSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 5/4/1998 16:52'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model := anObject.! !!FileList methodsFor: 'initialization' stamp: 'BG 12/13/2002 15:32'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory := dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode := #date].	volList := ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	volListIndex := volList size.	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval := sel! !!PolygonMorph methodsFor: 'dashes' stamp: 'nk 4/5/2001 16:02'!removeVertex: aVert	"Make sure that I am not left with less than two vertices"	| newVertices |	vertices size < 2 ifTrue: [ ^self ].	newVertices := vertices copyWithout: aVert.	newVertices size caseOf: {		[1] -> [ newVertices := { newVertices first . newVertices first } ].		[0] -> [ newVertices := { aVert . aVert } ]	} otherwise: [].	self setVertices: newVertices ! !!ScrollPane methodsFor: 'event handling' stamp: 'sps 3/9/2004 17:51'!mouseEnter: event	hasFocus := true.	(owner isSystemWindow) ifTrue: [owner paneTransition: event].	retractableScrollBar ifTrue:[ self hideOrShowScrollBars ].! !!TextMorphEditor methodsFor: 'attributes' stamp: 'th 9/19/2002 18:30'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply curFont menuList |true ifTrue:[^self changeTextFont].	self flag: #arNote. "Move this up once we get rid of MVC"	curFont := (paragraph text fontAt: self startIndex withStyle: paragraph textStyle) fontNameWithPointSize.	aList := paragraph textStyle fontNamesWithPointSizes.	menuList := aList collect:[:fntName|		fntName = curFont ifTrue:['<on>',fntName] ifFalse:['<off>',fntName]].	reply := (SelectionMenu labelList: menuList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!TextMorph methodsFor: 'scripting access' stamp: 'sw 2/18/2003 02:46'!insertContentsOf: aPlayer	"Insert the characters from the given player at my current cursor position"	| aLoc |	aLoc := self cursor.	paragraph replaceFrom: aLoc to: (aLoc - 1) with: aPlayer getStringContents displaying: true.	self updateFromParagraph  ! !!TransformMorph methodsFor: 'accessing' stamp: ''!smoothing: cellSize	smoothing := cellSize.	self changed! !!TextMorph methodsFor: 'multi level undo' stamp: 'sps 7/24/2003 22:57'!editHistory	editHistory ifNil: [ editHistory := TextMorphCommandHistory new].	^editHistory! !!MenuMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!addTitle	| string |	string := FillInTheBlank request: 'Title for this menu?'.	string isEmpty ifTrue: [^ self].	self addTitle: string.! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:55'!privateMoveBy: delta	super privateMoveBy: delta.	transform := nil.! !!Morph methodsFor: 'menus' stamp: 'dgd 4/3/2006 14:09'!helpButton	"Answer a button whose action would be to put up help concerning the receiver"	| aButton |	aButton := SimpleButtonMorph new.	aButton		target: self;		color: ColorTheme current helpColor;		borderColor: ColorTheme current helpColor muchDarker;		borderWidth: 1;		label: '?' translated font: Preferences standardButtonFont;		actionSelector: #presentHelp;		setBalloonText: 'click here for help' translated.	^ aButton! !!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 00:50'!initialize 	"Refer to the comment in View|initialize."	super initialize.	self borderWidth: 5.	self noLabel.	modalBorder := true.! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'tak 12/22/2004 12:59'!buttonRowForEditor	"Answer a row of buttons that comprise the header at the top of the Scriptor"	| aRow aString buttonFont aStatusMorph aButton aColumn aTile |	buttonFont := Preferences standardButtonFont.	aRow := AlignmentMorph newRow color: Color transparent; layoutInset: 0.	aRow hResizing: #shrinkWrap.	aRow vResizing: #shrinkWrap.	self hasParameter ifFalse:		[aRow addMorphFront:			(SimpleButtonMorph new				label: '!!' font: Preferences standardEToysFont;				target: self;				color: Color yellow;				borderWidth: 0;				actWhen: #whilePressed;				actionSelector: #tryMe;				balloonTextSelector: #tryMe).		aRow addTransparentSpacerOfSize: 6@10].	self addDismissButtonTo: aRow.	aRow addTransparentSpacerOfSize: 6@1.	aColumn := AlignmentMorph newColumn beTransparent.	aColumn addTransparentSpacerOfSize: 0@4.	aButton := UpdatingThreePhaseButtonMorph checkBox.	aButton		target: self;		actionSelector: #toggleWhetherShowingTiles;		getSelector: #showingMethodPane.	aButton setBalloonText: 'toggle between showing tiles and showing textual code' translated.	aColumn addMorphBack: aButton.	aRow addMorphBack: aColumn.	aRow addTransparentSpacerOfSize: 6@10.	aString := playerScripted externalName.	aRow addMorphBack:		(aButton := SimpleButtonMorph new useSquareCorners label: aString font: buttonFont; target: self; setNameTo: 'title').	aButton actWhen: #buttonDown; actionSelector: #offerScriptorMenu.	aButton		on: #mouseEnter send: #menuButtonMouseEnter: to: aButton;		on: #mouseLeave send: #menuButtonMouseLeave: to: aButton.	aButton borderColor: (Color fromRgbTriplet: #(0.065 0.258 1.0)).	aButton color: ScriptingSystem uniformTileInteriorColor.	aButton balloonTextSelector: #offerScriptorMenu.	aRow addTransparentSpacerOfSize: 4@1.	aButton := (Preferences universalTiles ifTrue: [SyntaxUpdatingStringMorph] 					ifFalse: [UpdatingStringMorph]) new.	aButton useStringFormat;		target:  self;		getSelector: #scriptTitle;		setNameTo: 'script name';		font: ScriptingSystem fontForNameEditingInScriptor;		putSelector: #setScriptNameTo:;		setProperty: #okToTextEdit toValue: true;		step;		yourself.	aRow addMorphBack: aButton.	aButton setBalloonText: 'Click here to edit the name of the script.' translated.	aRow addTransparentSpacerOfSize: 6@0.	self hasParameter		ifTrue:			[aTile := TypeListTile new choices: Vocabulary typeChoices dataType: nil.			aTile addArrows.			aTile setLiteral: #Number.	"(aButton := SimpleButtonMorph new useSquareCorners label: 'parameter' translated font: buttonFont; target: self; setNameTo: 'parameter').			aButton actWhen: #buttonDown; actionSelector: #handUserParameterTile."			aRow addMorphBack: aTile.			aTile borderColor: Color red.			aTile color: ScriptingSystem uniformTileInteriorColor.			aTile setBalloonText: 'Drag from here to get a parameter tile' translated]		ifFalse:			[aRow addMorphBack: (aStatusMorph := self scriptInstantiation statusControlMorph)].	aRow addTransparentSpacerOfSize: 6@1.	aRow addMorphBack:		(IconicButton new borderWidth: 0;			labelGraphic: (ScriptingSystem formAtKey: 'AddTest'); color: Color transparent; 			actWhen: #buttonDown;			target: self;			actionSelector: #addYesNoToHand;			shedSelvedge;			balloonTextSelector: #addYesNoToHand).	aRow addTransparentSpacerOfSize: 12@10.	self addDestroyButtonTo: aRow.	(playerScripted existingScriptInstantiationForSelector: scriptName)		ifNotNilDo:			[:inst | inst updateStatusMorph: aStatusMorph].	^ aRow! !!EditCommand methodsFor: 'initialization' stamp: 'sps 7/24/2003 17:01'!textMorph: tmreplacedText: rText replacedTextInterval: rIntervalnewText: nText newTextInterval: nInterval	textMorph := tm.	replacedText := rText.	replacedTextInterval := rInterval.	newText := nText.	newTextInterval := nInterval.! !!FillInTheBlankMorph methodsFor: 'accessing' stamp: 'jm 5/4/1998 14:22'!response: aText	"Sent when text pane accepts."	response := aText asString.	done := true.	^ true! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint	scalePoint ifNil: [scalePoint := 1.0@1.0].	^ scalePoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 7/20/2001 22:51'!minimumExtent	| minExt |	textStyle ifNil: [^ 9@16].	borderWidth ifNil: [^ 9@16].	minExt := (9@(textStyle lineGrid+2)) + (borderWidth*2).	margins ifNil: [^ minExt].	^ ((0@0 extent: minExt) expandBy: margins) extent! !!ScriptEditorMorph methodsFor: 'other' stamp: 'yo 1/14/2004 10:50'!hasScriptReferencing: aSlotName ofPlayer: aPlayer	"Answer whether the receiver has any tiles in it which reference the given slot of the given player.  By doing a text search on the decompiled method, this is able to work both with text and with tiles.  The approach is still not perfect, because we can't really know until run-time whom the getters and setters are sent to.  But practically speaking, this is all presumably a positive."	| stringToSearch |	"(aPlayer isKindOf: playerScripted class) ifFalse: [^ false]."	stringToSearch := (playerScripted class compiledMethodAt: scriptName) decompileString.	{Utilities getterSelectorFor: aSlotName. Utilities setterSelectorFor: aSlotName} do:		[:searchee |			(stringToSearch findString: searchee startingAt: 1) = 0				ifFalse:					[^ true]]. 	^ false! !!Morph methodsFor: 'private' stamp: 'di 10/18/2004 21:49'!privateRemove: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	submorphs := submorphs copyWithout: aMorph.	self layoutChanged.! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'tk 6/30/97 11:01'!state: newState	"Change the image and invalidate the rect."	newState == state ifTrue: [^ self].	state := newState.	self invalidRect: bounds.	"All three images must be the same size"! !!Morph methodsFor: 'visual properties' stamp: 'nk 2/27/2003 11:48'!useGradientFill	"Make receiver use a solid fill style (e.g., a simple color)"	| fill color1 color2 |	self fillStyle isGradientFill ifTrue:[^self]. "Already done"	color1 := self color asColor.	color2 := color1 negated.	fill := GradientFillStyle ramp: {0.0 -> color1. 1.0 -> color2}.	fill origin: self topLeft.	fill direction: 0 @ self bounds extent y.	fill normal: self bounds extent x @ 0.	fill radial: false.	self fillStyle: fill! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'ar 9/4/2001 13:26'!initialize	"Initialize the receiver.  Obey the modalColorPickers preference when deciding how to configure myself.  This is not quite satisfactory -- we'd like to have explicit calls tell us things like whether whether to be modal, whether to allow transparency, but for the moment, in grand Morphic fashion, this is rather inflexibly all housed right here"	super initialize.	self clipSubmorphs: true.	self buildChartForm.		selectedColor := Color white.	sourceHand := nil.	deleteOnMouseUp := false.	clickedTranslucency := false.	updateContinuously := true.	selector := nil.	target := nil! !!MorphExtension methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 12:45'!comeFullyUpOnReload: smartRefStream	"inst vars have default booplean values."	locked ifNil: [locked := false].	visible ifNil: [visible := true].	sticky ifNil: [sticky := false].	isPartsDonor ifNil: [isPartsDonor := false].	^ self! !!AlphaBlendingCanvas methodsFor: 'accessing' stamp: 'ar 8/8/2001 14:24'!alpha: newAlpha	alpha := newAlpha.! !!TextMorphEditor methodsFor: 'multi level undo' stamp: 'sps 7/24/2003 18:52'!multiRedoWithCount: count	| command i lastCommand newSelection saveSelection history |	count > 0 ifFalse:[ ^self ].	history := self editHistory.	(command := history nextCommand) isNil			ifTrue:[ ^self multiUndoError: 'Nothing to redo'].	saveSelection := self selectionInterval.	self deselect.	i := 0.	[i < count] whileTrue: 		[		history redo.		lastCommand := command.		((i := i + 1) < count) ifTrue:			[			(command := history nextCommand) ifNil:[				self multiUndoError: ('Only ', (i - 1) asString, ' commands to redo.').				i := count.]]].	(newSelection := lastCommand redoSelectionInterval) isNil			ifTrue:[ self selectInterval: saveSelection]			ifFalse:[ self selectInterval: newSelection].! !!PolygonMorph methodsFor: 'geometry' stamp: 'edc 3/20/2002 14:24'!flipHAroundX: centerX	"Flip me horizontally around the center.  If centerX is nil, compute my center of gravity."	| cent |	cent := centerX 		ifNil: [bounds center x			"cent := 0.			vertices do: [:each | cent := cent + each x].			cent asFloat / vertices size"]		"average is the center"		ifNotNil: [centerX].	self setVertices: (vertices collect: [:vv |			((vv x - cent) * -1 + cent) @ vv y]) reversed.! !!KeyboardBuffer methodsFor: 'as yet unclassified' stamp: ''!startingEvent: evt	event := evt.	eventUsed := false! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'ar 11/9/2000 21:21'!label: aStringOrTextOrMorph	"Label this button with the given string or morph."	| r |	self removeAllMorphs.	"nest label in a row for centering"	r := AlignmentMorph newRow		borderWidth: 0;		layoutInset: 0;		color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		wrapCentering: #center; cellPositioning: #leftCenter.	aStringOrTextOrMorph isMorph		ifTrue: [			label := aStringOrTextOrMorph.			r addMorph: aStringOrTextOrMorph]		ifFalse: [			label := aStringOrTextOrMorph asString.			r addMorph: (StringMorph contents: label)].	self addMorph: r.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 5/26/2004 00:01'!decimalPlaces: aNumber	"Set the receiver's number of decimal places to be shown.  If my target is a morph or a player, tell it about the change, in case it wants to remember it."	| constrained |	self setProperty: #decimalPlaces toValue: (constrained := aNumber min: 11).	self pvtFloatPrecision: (Utilities floatPrecisionForDecimalPlaces: constrained).	(target isKindOf: Morph orOf: Player) ifTrue:		[target noteDecimalPlaces: constrained forGetter: getSelector]! !!SketchMorph methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:49'!convertToCurrentVersion: varDict refStream: smartRefStrm		scalePoint ifNil: [scalePoint := 1.0@1.0].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 2/20/2001 00:34'!tileRows	"If using classic tiles, return a collection of arrays of Tiles in which each array is one line of tiles.  (John Maloney's original design and code)."	| rows r |	rows := OrderedCollection new.	Preferences universalTiles ifTrue: [^ rows].	firstTileRow to: submorphs size do: [:i |		r := submorphs at: i.		r submorphCount > 0 ifTrue: [rows addLast: r submorphs]].	^ rows! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:01'!reverseTableCells	"Layout specific. This property describes if the cells should be treated in reverse order of submorphs."	| props |	props := self layoutProperties.	^props ifNil:[false] ifNotNil:[props reverseTableCells].! !!Morph methodsFor: 'object fileIn' stamp: 'dgd 2/22/2003 14:30'!convertAugust1998: varDict using: smartRefStrm 	"These variables are automatically stored into the new instance 	('bounds' 'owner' 'submorphs' 'fullBounds' 'color' ). 	This method is for additional changes. Use statements like (foo := 	varDict at: 'foo')."	"Be sure to to fill in ('extension' ) and deal with the information 	in ('eventHandler' 'properties' 'costumee' )"	"This method moves all property variables as well as 	eventHandler, and costumee into a morphicExtension."	"Move refs to eventhandler and costumee into extension"	| propVal |	(varDict at: 'eventHandler') isNil 		ifFalse: [self eventHandler: (varDict at: 'eventHandler')].	(varDict at: 'costumee') isNil 		ifFalse: [self player: (varDict at: 'costumee')].	(varDict at: 'properties') isNil 		ifFalse: 			[(varDict at: 'properties') keys do: 					[:key | 					"Move property extensions into extension"					propVal := (varDict at: 'properties') at: key.					propVal ifNotNil: 							[key == #possessive 								ifTrue: [propVal == true ifTrue: [self bePossessive]]								ifFalse: 									[key ifNotNil: [self assureExtension convertProperty: key toValue: propVal]]]]]! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/19/2000 01:10'!openLabel: aString	"Open a view of an instance of me."	"StandardFileDialog new open"	| topView volListView templateView fileListView fileStringView leftButtonView middleButtonView rightButtonView |		self directory: directory.	topView := (PluggableFileListView new)		model: self.	volListView := PluggableListView on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView := PluggableTextView on: self		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	fileListView := PluggableListView on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@60).	topView addSubView: fileListView toRightOf: volListView.	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	"fileStringView := PluggableTextView on: self		text: #fileString		accept: #fileString:.	fileStringView askBeforeDiscardingEdits: false.	fileStringView window: (0@0 extent: 200@15).	topView addSubView: fileStringView below: templateView."	fileStringView := templateView.	leftButtonView := PluggableButtonView 		on: self		getState: nil		action: #leftButtonPressed.	leftButtonView		label: 'Cancel';		backgroundColor: Color red;		borderWidth: 3;		window: (0@0 extent: 50@15).	middleButtonView := PluggableButtonView		on: self		getState: nil		action: nil.	middleButtonView		label: prompt;		window: (0@0 extent: 100@15);		borderWidth: 1;		controller: NoController new.	rightButtonView := PluggableButtonView		on: self		getState: nil		action: #rightButtonPressed.	rightButtonView		label: 'Accept';		backgroundColor: (self canAccept ifTrue: [Color green] ifFalse: [Color lightYellow]);		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]);		window: (0@0 extent: 50@15).	self canAccept ifFalse: [rightButtonView controller: NoController new].	topView acceptButtonView: rightButtonView.	topView		addSubView: leftButtonView below: fileStringView;		addSubView: middleButtonView toRightOf: leftButtonView;		addSubView: rightButtonView toRightOf: middleButtonView.	self changed: #getSelectionSel.	topView doModalDialog.		^self result! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'sw 12/7/1999 18:11'!label: aString	| oldLabel m |	(oldLabel := self findA: StringMorph)		ifNotNil: [oldLabel delete].	m := StringMorph contents: aString font: TextStyle defaultFont.	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock! !!TextMorphEditor methodsFor: 'attributes' stamp: 'nk 9/1/2004 14:55'!changeTextFont	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.	If there is no selection, or the selection is empty, apply it to the whole morph."	| curFont newFont attr startIndex stopIndex |	startIndex := self startIndex.	stopIndex := self stopIndex-1 min: paragraph text size.	curFont := (paragraph text fontAt: startIndex withStyle: paragraph textStyle).	newFont := StrikeFont fromUser: curFont allowKeyboard: false.	newFont ifNil:[^self].	attr := TextFontReference toFont: newFont.	stopIndex >= startIndex		ifTrue: [ paragraph text addAttribute: attr from: startIndex to: stopIndex ]		ifFalse: [ paragraph text addAttribute: attr from: 1 to: paragraph text size. ].	paragraph composeAll.	self recomputeInterval.! !!TheWorldMenu methodsFor: 'commands' stamp: 'dgd 9/6/2003 18:17'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result oldDepth allDepths allLabels menu hasBoth |	oldDepth := Display nativeDepth.	allDepths := #(1 -1 2 -2 4 -4 8 -8 16 -16 32 -32) select: [:d | Display supportsDisplayDepth: d].	hasBoth := (allDepths anySatisfy:[:d| d > 0]) and:[allDepths anySatisfy:[:d| d < 0]].	allLabels := allDepths collect:[:d|		String streamContents:[:s|			s nextPutAll: (d = oldDepth ifTrue:['<on>'] ifFalse:['<off>']).			s print: d abs.			hasBoth ifTrue:[s nextPutAll: (d > 0 ifTrue:['  (big endian)'] ifFalse:['  (little endian)'])].		]].	menu := SelectionMenu labels: allLabels selections: allDepths.	result := menu startUpWithCaption: 'Choose a display depth' translated.	result ifNotNil: [Display newDepth: result].	oldDepth := oldDepth abs.	(Smalltalk isMorphic and: [(Display depth < 4) ~= (oldDepth < 4)])		ifTrue:			["Repaint windows since they look better all white in depth < 4"			(SystemWindow windowsIn: myWorld satisfying: [:w | true]) do:				[:w |				oldDepth < 4					ifTrue: [w restoreDefaultPaneColor]					ifFalse: [w updatePaneColors]]]! !!EditCommand methodsFor: 'accessors' stamp: 'sps 1/5/2002 16:36'!replacedTextInterval: anInterval	^replacedTextInterval := anInterval! !!ProportionalLayout methodsFor: 'layout' stamp: 'ar 2/5/2002 20:05'!minExtentOf: aMorph in: newBounds	"Return the minimal size aMorph's children would require given the new bounds"	| min extent frame |	min := 0@0.	aMorph submorphsDo:[:m|		"Map the minimal size of the child through the layout frame.		Note: This is done here and not in the child because its specific		for proportional layouts. Perhaps we'll generalize this for table		layouts but I'm not sure how and when."		extent := m minExtent.		frame := m layoutFrame.		frame ifNotNil:[extent := frame minExtentFrom: extent].		min := min max: extent].	^min! !!ModalSystemWindowView methodsFor: 'initialize-release' stamp: 'acg 2/18/2000 20:41'!borderWidth: anObject	modalBorder := false.	^super borderWidth: anObject! !!Morph methodsFor: 'thumbnail' stamp: 'tk 3/28/2000 21:55'!updateThumbnailUrlInBook: bookUrl	"If I have a cached thumbnail, then update it's urls."	| cachedThumbnail |	(cachedThumbnail := self valueOfProperty: #cachedThumbnail) ifNotNil:		[(cachedThumbnail respondsTo: #computeThumbnail) 			ifTrue: [cachedThumbnail pageMorph: self url inBook: bookUrl]			ifFalse: [self removeProperty: #computeThumbnail]].			"Test and removal are because the thumbnail is being replaced 			by another Morph.  We don't know why.  Need to fix that at 			the source."! !!PluggableFileListView methodsFor: 'as yet unclassified' stamp: 'acg 2/9/2000 08:57'!acceptButtonView: aView	^acceptButtonView := aView! !!PluggableListMorph methodsFor: 'events' stamp: 'ls 10/14/2001 13:08'!handleBasicKeys: aBoolean	"set whether the list morph should handle basic keys like arrow keys, or whether everything should be passed to the model"	handlesBasicKeys := aBoolean! !!GrafPort methodsFor: 'private' stamp: 'yo 1/8/2005 09:11'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	super installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor.	alpha := foregroundColor privateAlpha.	"dynamically switch between blend modes to support translucent text"	"To handle the transition from TTCFont to StrikeFont, rule 34 must be taken into account."	alpha = 255 ifTrue:[		combinationRule = 30 ifTrue: [combinationRule := Form over].		combinationRule = 31 ifTrue: [combinationRule := Form paint].		combinationRule = 34 ifTrue: [combinationRule := Form paint].	] ifFalse:[		combinationRule = Form over ifTrue: [combinationRule := 30].		combinationRule = Form paint ifTrue: [combinationRule := 31].		combinationRule = 34 ifTrue: [combinationRule := 31].	].	lastFont := aStrikeFont.	lastFontForegroundColor := foregroundColor.	lastFontBackgroundColor := backgroundColor.! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 10/18/2001 03:56'!fromHand: hand	"Let the user draw a polygon, clicking at each vertex, and ending		by clicking within 5 of the first point..."	| p1 poly oldVerts pN opposite |	Cursor crossHair showWhile:		[[Sensor anyButtonPressed] whileFalse:			[self currentWorld displayWorldSafely; runStepMethods].		p1 := Sensor cursorPoint].	opposite := (Display colorAt: p1) negated.	opposite = Color transparent ifTrue: [opposite := Color red].	(poly := LineMorph from: p1 to: p1 color: opposite width: 2) openInWorld.	oldVerts := {p1}.	self currentWorld displayWorldSafely; runStepMethods.	[true] whileTrue:		[[Sensor anyButtonPressed] whileTrue:			[pN := Sensor cursorPoint.			poly setVertices: (oldVerts copyWith: pN).			self currentWorld displayWorldSafely; runStepMethods].		(oldVerts size > 1 and: [(pN dist: p1) < 5]) ifTrue:			[hand position: Sensor cursorPoint.  "Done -- update hand pos"			^ (poly setVertices: (poly vertices copyWith: p1)) delete].		oldVerts := poly vertices.		[Sensor anyButtonPressed] whileFalse:			[pN := Sensor cursorPoint.			poly setVertices: (oldVerts copyWith: pN).			self currentWorld displayWorldSafely; runStepMethods]].! !!TextFieldMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:54'!initialize	"initialize the state of the receiver"	| tm |	super initialize.	""		self addMorph: (tm := TextMorph new).	tm fillingOnOff! !!PolygonMorph methodsFor: 'dropping/grabbing' stamp: 'di 9/8/2000 09:56'!justDroppedInto: newOwner event: evt	| delta |	(newOwner isKindOf: PasteUpMorph) ifTrue:		["Compensate for border width so that gridded drop			is consistent with gridded drag of handles."		delta := borderWidth+1//2.		self position: (newOwner gridPoint: self position + delta) - delta].	^ super justDroppedInto: newOwner event: evt! !!TextMorph methodsFor: 'accessing' stamp: 'di 4/14/98 08:33'!contents: stringOrText wrappedTo: width	"Accept new text contents.  Lay it out, wrapping to width.	Then fit my height to the result."	self newContents: ''.	wrapFlag := true.	super extent: width truncated@self height.	self newContents: stringOrText! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/8/2000 09:44'!beSmoothCurve	smoothCurve == true ifFalse:		[smoothCurve := true.		self computeBounds]! !!FileList2 methodsFor: 'initialization' stamp: 'ar 10/10/2000 16:00'!dirSelectionBlock: aBlock	dirSelectionBlock := aBlock! !!Morph methodsFor: 'drop shadows' stamp: 'ar 10/26/2000 18:58'!setShadowOffset: evt	| handle |	handle := HandleMorph new forEachPointDo:		[:newPoint | self shadowPoint: newPoint].	evt hand attachMorph: handle.	handle startStepping.! !!Morph methodsFor: 'initialization' stamp: 'RAA 5/25/2000 08:12'!openInWindowLabeled: aString inWorld: aWorld	| window extent |	window := (SystemWindow labelled: aString) model: nil.	window 		" guess at initial extent"		bounds:  (RealEstateAgent initialFrameFor: window initialExtent: self fullBounds extent world: aWorld);		addMorph: self frame: (0@0 extent: 1@1);		updatePaneColors.	" calculate extent after adding in case any size related attributes were changed.  Use	fullBounds in order to trigger re-layout of layout morphs"	extent := self fullBounds extent + 			(window borderWidth@window labelHeight) + window borderWidth.	window extent: extent.	aWorld addMorph: window.	window activate.	aWorld startSteppingSubmorphsOf: window.	^window! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/13/2000 15:33'!beAccepted	^accepted := true! !!TextMorph methodsFor: 'scripting access' stamp: 'dgd 2/21/2003 22:31'!setAllButFirstCharacter: source 	"Set all but the first char of the receiver to the source"	| aChar chars |	aChar := source asCharacter.	(chars := self getCharacters) isEmpty		ifTrue: [self newContents: '' , source asString]		ifFalse: [chars first = aChar				ifFalse: [""					self						newContents: (String								streamContents: [:aStream | 									aStream nextPut: chars first.									aStream nextPutAll: source])]] ! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'ar 6/12/2001 05:23'!setDirectionFrom: aPoint	| delta degrees inner |	inner := self renderedMorph.	inner == self ifTrue:[^self].	delta := (inner transformFromWorld globalPointToLocal: aPoint) - inner referencePosition.	degrees := delta degrees + 90.0.	self forwardDirection: (degrees \\ 360) rounded.! !!SystemWindow class methodsFor: 'initializing' stamp: 'jrp 7/30/2005 22:51'!closeBoxImage	"Supplied here because we don't necessarily have ComicBold"	^ CloseBoxImage ifNil: [CloseBoxImage := (Form	extent: 10@10	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 3326099520 3330310272 0 0 0 0 0 0 0 0 4144038145 3326099520 3330310272 0 0 0 4144038145 3326099520 0 0 0 4227924225 3326099520 3330310272 0 4144038145 3326099520 3330310272 0 0 0 0 4144038145 3326099520 4144038145 3326099520 3330310272 3336494814 0 0 0 0 0 4227924225 3326099520 3330310272 3336494814 0 0 0 0 0 4144038145 3326099520 4144038145 3326099520 3330310272 3336494814 0 0 0 4144038145 3326099520 3330310272 3336494814 4144038145 3326099520 3330310272 0 0 4144038145 3326099520 3330310272 3336494814 0 0 4144038145 3326099520 0 0 0 3330310272 3336494814 0 0 0 0 0 0)	offset: 0@0)]! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'KLC 4/11/2004 10:56'!invokeAt: aPoint in: aWorld allowKeyboard: aBoolean	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| w originalFocusHolder |	self flag: #bob.		"is <aPoint> global or local?"	self flag: #arNote.	"<aPoint> is local to aWorld"	originalFocusHolder := aWorld primaryHand keyboardFocus.	self popUpAt: aPoint forHand: aWorld primaryHand in: aWorld allowKeyboard: aBoolean.	done := false.	w := aWorld outermostWorldMorph. "containing hand"	[self isInWorld & done not] whileTrue: [w doOneSubCycle].	self delete.	originalFocusHolder ifNotNil: [aWorld primaryHand newKeyboardFocus: originalFocusHolder].	^ mvcSelection! !!TextMorph methodsFor: 'accessing' stamp: 'nk 10/16/2003 16:42'!font: aFont	| newTextStyle |	newTextStyle := aFont textStyle copy ifNil: [ TextStyle fontArray: { aFont } ].	textStyle := newTextStyle.	text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOf: aFont)).	paragraph ifNotNil: [paragraph textStyle: newTextStyle]! !!NewParagraph methodsFor: 'private' stamp: 'di 4/14/98 13:17'!fastFindFirstLineSuchThat: lineBlock	"Perform a binary search of the lines array and return the index	of the first element for which lineBlock evaluates as true.	This assumes the condition is one that goes from false to true for	increasing line numbers (as, eg, yval > somey or start char > somex).	If lineBlock is not true for any element, return size+1."	| index low high |	low := 1.	high := lines size.	[index := high + low // 2.	low > high]		whileFalse: 			[(lineBlock value: (lines at: index))				ifTrue: [high := index - 1]				ifFalse: [low := index + 1]].	^ low! !!Morph methodsFor: 'layout' stamp: 'ar 8/6/2001 09:55'!layoutInBounds: cellBounds	"Layout specific. Apply the given bounds to the receiver after being layed out in its owner."	| box aSymbol delta |	fullBounds ifNil:["We are getting new bounds here but we haven't computed the receiver's layout yet. Although the receiver has reported its minimal size before the actual size it has may differ from what would be after the layout. Normally, this isn't a real problem, but if we have #shrinkWrap constraints then the receiver's bounds may be larger than the cellBounds. THAT is a problem because the centering may not work correctly if the receiver shrinks after the owner layout has been computed. To avoid this problem, we compute the receiver's layout now. Note that the layout computation is based on the new cell bounds rather than the receiver's current bounds."		cellBounds origin = self bounds origin ifFalse:[			box := self outerBounds.			delta := cellBounds origin - self bounds origin.			self invalidRect: (box merge: (box translateBy: delta)).			self privateFullMoveBy: delta]. "sigh..."		box := cellBounds origin extent: "adjust for #rigid receiver"			(self hResizing == #rigid ifTrue:[self bounds extent x] ifFalse:[cellBounds extent x]) @			(self vResizing == #rigid ifTrue:[self bounds extent y] ifFalse:[cellBounds extent y]).		"Compute inset of layout bounds"		box := box origin - (self bounds origin - self layoutBounds origin) corner:					box corner - (self bounds corner - self layoutBounds corner).		"And do the layout within the new bounds"		self layoutBounds: box.		self doLayoutIn: box].	cellBounds = self fullBounds ifTrue:[^self]. "already up to date"	cellBounds extent = self fullBounds extent "nice fit"		ifTrue:[^self position: cellBounds origin].	box := bounds.	"match #spaceFill constraints"	self hResizing == #spaceFill 		ifTrue:[box := box origin extent: cellBounds width @ box height].	self vResizing == #spaceFill		ifTrue:[box := box origin extent: box width @ cellBounds height].	"align accordingly"	aSymbol := (owner ifNil:[self]) cellPositioning.	box := box align: (box perform: aSymbol) with: (cellBounds perform: aSymbol).	"and install new bounds"	self bounds: box.! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 7/6/1999 13:36'!toggleOriginAtCenter	| hasIt |	hasIt := self hasProperty: #originAtCenter.	hasIt		ifTrue:			[self removeProperty: #originAtCenter]		ifFalse:			[self setProperty: #originAtCenter toValue: true]! !!Morph methodsFor: 'debug and other' stamp: 'nk 6/14/2004 16:14'!buildDebugMenu: aHand	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu aPlayer |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' translated action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' translated action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' translated action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' translated action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' translated action: #inspect].	self isMorphicModel ifTrue:		[aMenu add: 'inspect model' translated target: self model action: #inspect].	(aPlayer := self player) ifNotNil:		[aMenu add: 'inspect player' translated target: aPlayer action: #inspect].     aMenu add: 'explore morph' translated target: self selector: #explore.	aMenu addLine.	aPlayer ifNotNil:		[ aMenu add: 'viewer for Player' translated target: self player action: #beViewed.	aMenu balloonTextForLastItem: 'Opens a viewer on my Player -- this is the same thing you get if you click on the cyan "View" halo handle' translated ].	aMenu add: 'viewer for Morph' translated target: self action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'Opens a Viewer on this Morph, rather than on its Player' translated.	aMenu addLine.	aPlayer ifNotNil:		[aPlayer class isUniClass ifTrue: [			aMenu add: 'browse player class' translated target: aPlayer action: #browseHierarchy]].	aMenu add: 'browse morph class' translated target: self selector: #browseHierarchy.	(self isMorphicModel)		ifTrue: [aMenu				add: 'browse model class'				target: self model				selector: #browseHierarchy].	aMenu addLine.	aPlayer ifNotNil:		[aMenu add: 'player protocol (tiles)' translated target: aPlayer action: #openInstanceBrowserWithTiles			"#browseProtocolForPlayer"].	aMenu add: 'morph protocol (text)' translated target: self selector: #haveFullProtocolBrowsed.	aMenu add: 'morph protocol (tiles)' translated target: self selector: #openInstanceBrowserWithTiles.	aMenu addLine.	self addViewingItemsTo: aMenu.	aMenu 		add: 'make own subclass' translated action: #subclassMorph;		add: 'internal name ' translated action: #choosePartName;		add: 'save morph in file' translated  action: #saveOnFile;		addLine;		add: 'call #tempCommand' translated action: #tempCommand;		add: 'define #tempCommand' translated action: #defineTempCommand;		addLine;		add: 'control-menu...' translated target: self selector: #invokeMetaMenu:;		add: 'edit balloon help' translated action: #editBalloonHelpText.	^ aMenu! !!FileList2 methodsFor: 'private' stamp: 'md 10/22/2003 15:27'!okHit	ok := true.	currentDirectorySelected		ifNil: [Beeper beep]		ifNotNil: [modalView delete]! !!ScriptEditorMorph methodsFor: 'access' stamp: 'sw 11/3/1998 17:20'!myMorph	"Answer the morph that serves as the costume of my associated player.  If for some reason I have no associated player, answer nil"	| aPlayer |	^ (aPlayer := self playerScripted) ifNotNil: [aPlayer costume]! !!TextLine methodsFor: 'accessing' stamp: 'hmm 2/9/2001 11:58'!leftMargin: lm	left := lm! !!TTSampleStringMorph methodsFor: 'initialize' stamp: 'sma 1/1/2000 18:08'!initializeString	| xStart char glyph |	(font isNil or: [string isNil]) ifTrue: [^ self].	xStart := 0.	ttBounds := 0@0 corner: 0@0.	1 to: string size do:		[:i |		char := string at: i.		glyph := font at: char.		ttBounds := ttBounds quickMerge: (glyph bounds translateBy: xStart@0).		xStart := xStart + glyph advanceWidth.	].	self extent: ttBounds extent // 40.	borderWidth := ttBounds height // 40! !!Morph methodsFor: 'card in a stack' stamp: 'tk 11/2/2001 13:53'!stack	"Answer the nearest containing Stack, or, if none, a stack in the current project, and if still none, nil.  The extra messiness is because uninstalled backgrounds don't have an owner pointers to their stack."	| aStack bkgnd |	bkgnd := self orOwnerSuchThat: [:oo | oo hasProperty: #myStack].	bkgnd ifNotNil: [^ bkgnd valueOfProperty: #myStack].	"fallbacks"	(aStack := self ownerThatIsA: StackMorph) ifNotNil: [^ aStack].	^ Project current currentStack! !!PluggableTabButtonMorph methodsFor: 'access' stamp: 'KLC 1/22/2004 14:39'!model: anObject	model := anObject! !!Morph methodsFor: 'player' stamp: 'sw 8/10/2000 00:06'!assureExternalName	| aName |	^ (aName := self knownName) ifNil:		[self setNameTo: (aName := self externalName).		^ aName]! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:10'!stopStepping: aMorph selector: aSelector	"Remove the given morph from the step list."	lastStepMessage ifNotNil:[		(lastStepMessage receiver == aMorph and:[lastStepMessage selector == aSelector])			ifTrue:[lastStepMessage := nil]].	stepList removeAll: (stepList select:[:stepMsg| stepMsg receiver == aMorph and:[stepMsg selector == aSelector]]).! !!AbstractResizerMorph methodsFor: 'as yet unclassified' stamp: 'jrp 7/30/2005 21:30'!setInverseColors	handleColor := Color lightGray.	dotColor := Color white! !!StringMorph methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:45'!measureContents	| f |	f := self fontToUse.	^(((f widthOfString: contents) max: self minimumWidth)  @ f height).! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'di 4/10/98 16:20'!autoDeselect: trueOrFalse	"Enable/disable autoDeselect (see class comment)"	autoDeselect := trueOrFalse.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 3/17/2001 23:57'!checkCurrentHandForObjectToPaste	| response |	self primaryHand pasteBuffer ifNil: [^self].	response := (PopUpMenu labels: 'Delete\Keep' withCRs)		startUpWithCaption: 'Hand is holding a Morph in its paste buffer:\' withCRs,			self primaryHand pasteBuffer printString.	response = 1 ifTrue: [self primaryHand pasteBuffer: nil].! !!FileList methodsFor: 'private' stamp: 'ka 6/23/2002 15:55'!readContentsUTF8	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: UTF8TextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!MorphicAlarm methodsFor: 'accessing' stamp: 'ar 9/11/2000 16:45'!scheduledTime: msecs	"Set the time (in milliseconds) that the receiver is scheduled to be executed"	scheduledTime := msecs! !!SystemWindow methodsFor: 'top window' stamp: 'ar 7/21/2009 19:37'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColorToUse.	model modelSleep.	"Control boxes remain active, except in novice mode"	self submorphsDo: [:m |		m == labelArea ifFalse:			[m lock]].	labelArea ifNotNil:		[labelArea submorphsDo: [:m |			(m == closeBox or: [m == collapseBox])				ifTrue:					[Preferences noviceMode ifTrue: [m lock]]				ifFalse:					[m lock]]]		ifNil: "i.e. label area is nil, so we're titleless"			[self adjustBorderUponDeactivationWhenLabeless].! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'RAA 8/15/2000 16:27'!doButtonAction: evt	| moreArgs |	"Perform the action of this button. Subclasses may override this method. The default behavior is to send the button's actionSelector to its target object with its arguments."	target ifNil: [^self].	actionSelector ifNil: [^self].	Cursor normal showWhile: [		moreArgs := actionSelector numArgs > arguments size ifTrue: [			arguments copyWith: evt		] ifFalse: [			arguments		].		target perform: actionSelector withArguments: moreArgs	]! !!MatrixTransformMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:38'!initialize"initialize the state of the receiver"	super initialize.""	transform := MatrixTransform2x3 identity! !!TextMorphEditor methodsFor: 'multi level undo' stamp: 'sps 2/5/2004 13:26'!closeTypeIn	| begin stop rInterval nInterval newText |	(UndoMessage sends: #noUndoer) ifFalse:[^super closeTypeIn].	Preferences multipleTextUndo ifTrue: 		[		beginTypeInBlock == nil ifFalse:			[				begin := self startOfTyping.				stop := self stopIndex.				rInterval := (begin "+ UndoMessage argument" 																to: begin + UndoSelection size - 1).				nInterval := begin to: stop - 1.				(nInterval = rInterval) ifTrue:[ ^super closeTypeIn ].				newText := nInterval size > 0										ifTrue: [ paragraph text 																copyFrom: nInterval first 																to: nInterval last ]										ifFalse: [ self nullText ].				self addEditCommand: 				 	(EditCommand							textMorph: morph							replacedText: UndoSelection copy							replacedTextInterval: rInterval							newText: newText 							newTextInterval: nInterval)			].		].		"Call the super regardless, just to keep the standard undo machine happy"	^super closeTypeIn! !!PluggableTabButtonMorph methodsFor: 'access' stamp: 'KLC 1/22/2004 14:39'!textSelector: aSymbol	textSelector := aSymbol! !!Morph methodsFor: 'copying' stamp: 'md 2/27/2006 08:47'!veryDeepInner: deepCopier 	"The inner loop, so it can be overridden when a field should not  	be traced."	"super veryDeepInner: deepCopier.	know Object has no inst vars"	bounds := bounds clone.	"Points are shared with original"	"owner := owner.	special, see veryDeepFixupWith:"	submorphs := submorphs veryDeepCopyWith: deepCopier.	"each submorph's fixup will install me as the owner"	"fullBounds := fullBounds.	fullBounds is shared with original!!"	color := color veryDeepCopyWith: deepCopier.	"color, if simple, will return self. may be complex"	extension := (extension veryDeepCopyWith: deepCopier)! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 01:20'!dispatchDefault: anEvent with: aMorph	"Dispatch the given event. The event will be passed to the front-most visible submorph that contains the position wrt. to the event."	| localEvt index child morphs inside |	"See if we're fully outside aMorphs bounds"	(aMorph fullBounds containsPoint: anEvent position) ifFalse:[^#rejected]. "outside"	"Traverse children"	index := 1.	morphs := aMorph submorphs.	inside := false.	[index <= morphs size] whileTrue:[		child := morphs at: index.		localEvt := anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			"Not rejected. The event was in some submorph of the receiver"			inside := true.			localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].			index := morphs size. "break"		].		index := index + 1.	].	"Check for being inside the receiver"	inside ifFalse:[inside := aMorph containsPoint: anEvent position event: anEvent].	inside ifTrue:[^aMorph handleEvent: anEvent].	^#rejected! !!MVCMenuMorph methodsFor: 'private' stamp: 'ar 9/18/2000 12:16'!selectMVCItem: item	"Called by the MenuItemMorph that the user selects.	Record the selection and set the done flag to end this interaction."	mvcSelection := item.	done := true.! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/9/2000 12:48'!autoLineLayout	| layout |	layout := self layoutPolicy ifNil:[^false].	layout isTableLayout ifFalse:[^false].	self listDirection == #leftToRight ifFalse:[^false].	self wrapDirection == #topToBottom ifFalse:[^false].	^true! !!TextMorph methodsFor: 'geometry' stamp: 'nk 7/11/2004 20:07'!extent: aPoint 	| newExtent priorEditor |	bounds extent = aPoint ifTrue: [^ self].	priorEditor := editor.	self isAutoFit		ifTrue: [wrapFlag ifFalse: [^ self].  "full autofit can't change"				newExtent := aPoint truncated max: self minimumExtent.				newExtent x = self extent x ifTrue: [^ self].  "No change of wrap width"				self releaseParagraphReally.  "invalidate the paragraph cache"				super extent: newExtent.				priorEditor					ifNil: [self fit]  "since the width has changed..."					ifNotNil: [self installEditorToReplace: priorEditor]]		ifFalse: [super extent: (aPoint truncated max: self minimumExtent).				wrapFlag ifFalse: [^ self].  "no effect on composition"				self composeToBounds]! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 10:49'!drawOn: aCanvas	| origin extent offset |	(font isNil) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	origin := self position asIntegerPoint.	extent := self extent asIntegerPoint.	0 to: 16 do:[:i|		offset := (extent x * i // 16) @ (extent y * i // 16).		aCanvas line: origin x @ (origin y + offset y) 				to: (origin x + extent x) @ (origin y + offset y)				width: borderWidth color: borderColor.		aCanvas line: (origin x + offset x) @ origin y 				to: (origin x + offset x) @ (origin y + extent y)				width: borderWidth color: borderColor.	].	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		balloonCanvas transformBy: self transform.		balloonCanvas aaLevel: self smoothing.		self drawCharactersOn: balloonCanvas.	].! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/8/2000 10:36'!setVertices: newVertices	vertices := newVertices.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!PluggableFileList methodsFor: 'file list menu' stamp: 'sma 11/11/2000 18:14'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles |	entries := directory entries select: fileFilterBlock.	sizePad := (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := (SortedCollection new: 30) sortBlock: self sortBlock.	allFiles := pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [entry isDirectory or: [pat match: entry first]]) ifTrue:			[newList add: entry]].	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	newFiles := OrderedCollection new.	^ newList asArray.! !!UpdatingSimpleButtonMorph methodsFor: 'stepping and presenter' stamp: 'sw 10/30/2000 08:56'!step	"If appropriate update the receiver's label"	| newString |	super step.	wordingProvider ifNotNil:		[newString := wordingProvider perform: wordingSelector.		newString = self label ifFalse: [self labelString: newString; changed]]! !!PluggableButtonMorph methodsFor: 'arguments' stamp: 'sw 2/17/2002 05:29'!argumentsProvider: anObject argumentsSelector: aSelector	"Set the argument provider and selector"	argumentsProvider := anObject.	argumentsSelector := aSelector! !!BorderedMorph methodsFor: 'geometry' stamp: 'sw 5/18/2001 22:52'!acquireBorderWidth: aBorderWidth	"Gracefully acquire the new border width, keeping the interior area intact and not seeming to shift"	| delta |	(delta := aBorderWidth- self borderWidth) == 0 ifTrue: [^ self].	self bounds: ((self bounds origin - (delta @ delta)) corner: (self bounds corner + (delta @ delta))).	self borderWidth: aBorderWidth.	self layoutChanged! !!PluggableListMorph methodsFor: 'events' stamp: 'ls 10/14/2001 13:28'!mouseDown: evt	| selectors row |	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	row := self rowAtLocation: evt position.	row = 0  ifTrue: [^super mouseDown: evt].	"self dragEnabled ifTrue: [aMorph highlightForMouseDown]."	selectors := Array 		with: #click:		with: (doubleClickSelector ifNotNil:[#doubleClick:])		with: nil		with: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil]).	evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10 "pixels".! !!Morph methodsFor: 'menus' stamp: 'sw 11/22/1999 12:14'!menuItemBefore: menuString	| allWordings |	allWordings := self allMenuWordings.	^ allWordings atWrap: ((allWordings indexOf: menuString) - 1)! !!LayoutCell methodsFor: 'collection' stamp: 'ar 10/28/2000 21:27'!inject: thisValue into: binaryBlock 	"Accumulate a running value associated with evaluating the argument, 	binaryBlock, with the current value of the argument, thisValue, and the 	receiver as block arguments. For instance, to sum the numeric elements 	of a collection, aCollection inject: 0 into: [:subTotal :next | subTotal + 	next]."	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue! !!OrientedFillStyle methodsFor: '*Morphic-Balloon' stamp: 'ar 6/18/1999 07:28'!changeOriginIn: aMorph event: evt	"Interactively change the origin of the receiver"	| handle |	handle := HandleMorph new forEachPointDo:[:pt|		self origin: pt.		aMorph changed].	evt hand attachMorph: handle.	handle startStepping.! !!MenuMorph methodsFor: 'construction' stamp: 'hg 8/3/2000 15:22'!add: aString target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument."	| item |	item := MenuItemMorph new		contents: aString;		target: target;		selector: aSymbol;		arguments: argList asArray.	self addMorphBack: item.! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'tk 6/30/97 10:50'!target: anObject	target := anObject! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/13/2002 17:58'!pvtFloatPrecision: aNumber	"Private - Set the floatPrecision instance variable to the given number"	floatPrecision := aNumber! !!TTSampleFontMorph methodsFor: 'connectors' stamp: 'nk 8/17/2003 12:12'!selectGlyph	| retval done |	"Modal glyph selector"	done := false.	self on: #mouseDown send: #selectGlyphBlock:event:from: to: self withValue: [ :glyph | retval := glyph. done := true. ].	self on: #keyStroke send: #value to: [ done := true ].	[ done ] whileFalse: [ self world doOneCycle ].	self on: #mouseDown send: nil to: nil.	self on: #keyStroke send: nil to: nil.	^retval! !!PasteUpMorph methodsFor: 'project' stamp: 'tk 3/27/2000 20:38'!releaseSqueakPages	| uu |	"If this world has a book with SqueakPages, then clear the SqueakPageCache"	submorphs do: [:sub | (sub isKindOf: BookMorph) ifTrue: [		uu := sub valueOfProperty: #url ifAbsent: [nil].		uu ifNotNil: [(SqueakPageCache pageCache includesKey: uu) ifTrue: [				SqueakPageCache initialize]]]].	"wipe the cache"! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'ar 3/17/2001 17:39'!toggleExpandedState: aMorph event: event	| oldState |	"self setSelectedMorph: aMorph."	event yellowButtonPressed ifTrue: [		oldState := aMorph isExpanded.		scroller submorphs copy do: [ :each |			(each canExpand and: [each isExpanded = oldState]) ifTrue: [				each toggleExpandedState.			].		].	] ifFalse: [		aMorph toggleExpandedState.	].	self adjustSubmorphPositions.	! !!PasteUpMorph methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:48'!convertToCurrentVersion: varDict refStream: smartRefStrm		"transition from project to worldState (8/16/1999)"	worldState ifNil: [varDict at: 'project' ifPresent: [ :x | worldState := x]].	"elimination of specific gradient stuff (5/6/2000)"	varDict at: 'fillColor2' ifPresent: [ :color2 |		(color isColor and: [color2 isColor and: [color ~= color2]]) ifTrue: [			self useGradientFill.			self fillStyle				colorRamp: {0.0 -> color. 1.0 -> color2};				radial: false;				origin: self position;				direction: ((varDict at: 'gradientDirection') == #vertical 					ifTrue:[0@self height] 					ifFalse:[self width@0]).		]	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ColorPickerMorph methodsFor: 'private' stamp: 'di 9/28/2000 11:10'!updateAlpha: alpha	| sliderRect |	sliderRect := (TransparentBox left + 10)@1 corner: (TransparentBox right - 9)@9.	originalForm fill: (sliderRect withRight: sliderRect left + (alpha*sliderRect width))				fillColor: Color lightGray.	originalForm fillWhite: (sliderRect withLeft: sliderRect left + (alpha*sliderRect width)).	originalForm fill: ((TransparentBox right - 9)@1 extent: 8@8)				fillColor: (alpha < 1.0 ifTrue: [Color white] ifFalse: [Color lightGray]).	TransText displayOn: originalForm at: 62@1 rule: Form paint.! !!SystemProgressMorph methodsFor: 'private' stamp: 'laza 7/29/2004 10:30'!label: shortDescription min: minValue max: maxValue	| slot range newBarSize barSize lastRefresh |	((range := maxValue - minValue) <= 0 or: [(slot := self nextSlotFor: shortDescription) = 0])		ifTrue: [^[:barVal| 0 ]].	self openInWorld.	self align: self fullBounds center with: Display boundingBox center.	barSize := -1. "Enforces a inital draw of the morph"	lastRefresh := 0.	^[:barVal | 		(barVal between: minValue and: maxValue) ifTrue: [			newBarSize := (barVal - minValue / range * BarWidth) truncated.			newBarSize = barSize ifFalse: [				barSize := newBarSize.				(bars at: slot) barSize: barSize.				Time primMillisecondClock - lastRefresh > 25 ifTrue: [					self currentWorld displayWorld.					lastRefresh := Time primMillisecondClock]]].		slot]! !!Morph methodsFor: 'testing' stamp: 'ar 12/3/2001 12:33'!shouldDropOnMouseUp	| former |	former := self formerPosition ifNil:[^false].	^(former dist: self position) > 10! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/12/2001 22:47'!makeSiblingsLookLikeMe: evt	"Make all my siblings wear the same costume that I am wearing."	| aPlayer |	(aPlayer := self topRendererOrSelf player) belongsToUniClass ifFalse: [self error: 'not uniclass'].	aPlayer class allInstancesDo:		[:anInstance | anInstance == aPlayer ifFalse:			[anInstance wearCostumeOf: aPlayer]]! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 7/20/2002 14:34'!renameScriptTo: newSelector	"Rename the receiver's script so that it bears a new selector"	| aMethodNodeMorph methodMorph methodSource pos newMethodSource |	scriptName := newSelector.	self updateHeader.	Preferences universalTiles		ifFalse:  "classic tiles"			[self showingMethodPane				ifTrue:					["textually coded -- need to change selector"					methodMorph := self findA: MethodMorph.					methodSource := methodMorph text string.					pos := methodSource indexOf: Character cr ifAbsent: [self error: 'no cr'].					newMethodSource := newSelector.					newSelector numArgs > 0 ifTrue: [newMethodSource := newMethodSource, ' t1'].  "for the parameter"					newMethodSource := newMethodSource, (methodSource copyFrom: pos to: methodSource size).					methodMorph editString: newMethodSource.					methodMorph model changeMethodSelectorTo: newSelector.					playerScripted class compile: newMethodSource classified: 'scripts'.					methodMorph accept]				ifFalse:					[self install]]		ifTrue:  "universal tiles..."			[(aMethodNodeMorph := self methodNodeMorph) ifNotNil:				[aMethodNodeMorph acceptInCategory: 'scripts']]! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:13'!dispatchDropEvent: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. The dispatch is similar to the default dispatch with one difference: Morphs are given the chance to reject an entire drop operation. If the operation is rejected, no drop will be executed."	| inside index morphs child localEvt |	"Try to get out quickly"	(aMorph fullBounds containsPoint: anEvent cursorPoint)		ifFalse:[^#rejected].	"Give aMorph a chance to repel the dropping morph"	aMorph rejectDropEvent: anEvent.	anEvent wasHandled ifTrue:[^self].	"Go looking if any of our submorphs wants it"	index := 1.	inside := false.	morphs := aMorph submorphs.	[index <= morphs size] whileTrue:[		child := morphs at: index.		localEvt := anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			localEvt wasHandled ifTrue:[^anEvent wasHandled: true]. "done"			inside := true.			index := morphs size]. "break"		index := index + 1.	].	inside ifFalse:[inside := aMorph containsPoint: anEvent cursorPoint event: anEvent].	inside ifTrue:[^aMorph handleEvent: anEvent].	^#rejected! !!TransformMorph methodsFor: 'accessing' stamp: ''!setOffset: newOffset angle: newAngle scale: newScale	transform := MorphicTransform offset: newOffset angle: newAngle scale: newScale.	self changed! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'tk 6/30/97 10:08'!onImage: aForm	image := aForm.	self invalidRect: self bounds.! !!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/2/98 00:05'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!MenuItemMorph methodsFor: 'private' stamp: 'hg 8/3/2000 15:21'!deselectItem	| item |	self isSelected: false.	subMenu ifNotNil: [subMenu deleteIfPopUp].	(owner isKindOf: MenuMorph) ifTrue:		[item := owner popUpOwner.		(item isKindOf: MenuItemMorph) ifTrue: [item deselectItem]].! !!ScrollPane methodsFor: 'initialization' stamp: 'sps 4/3/2005 15:21'!initialize		"initialize the state of the receiver"	super initialize.	""	self initializePreferences.	hasFocus := false.	self initializeScrollBars.	""	self extent: self defaultExtent.	self hideOrShowScrollBars.! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topOffset: anInteger	topOffset := anInteger! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:56'!assureLayoutProperties	| props |	props := self layoutProperties.	props == self ifTrue:[props := nil].	props ifNil:[		props := LayoutProperties new initializeFrom: self.		self layoutProperties: props].	^props! !!LayoutFrame methodsFor: 'layout' stamp: 'ar 2/5/2002 20:05'!minExtentFrom: minExtent	"Return the minimal extent the given bounds can be represented in"	| widthFraction heightFraction width height |	widthFraction := 1.0.	leftFraction ifNotNil:[widthFraction := widthFraction + leftFraction].	rightFraction ifNotNil:[widthFraction := widthFraction + rightFraction].	heightFraction := 1.0.	topFraction ifNotNil:[heightFraction := heightFraction + topFraction].	bottomFraction ifNotNil:[heightFraction := heightFraction + bottomFraction].	width := minExtent x * widthFraction.	height := minExtent y * heightFraction.	leftOffset ifNotNil:[width := width + leftOffset].	rightOffset ifNotNil:[width := width + rightOffset].	topOffset ifNotNil:[height := height + topOffset].	bottomOffset ifNotNil:[height := height + bottomOffset].	^width truncated @ height truncated! !!ComplexBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:22'!style: newStyle	style == newStyle ifTrue:[^self].	style := newStyle.	self releaseCachedState.! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 2/6/2001 22:07'!scriptEdited	| anEditor |	(anEditor := self topEditor) ifNotNil: [anEditor recompileScript]! !!PluggableListMorph methodsFor: 'initialization' stamp: 'ls 5/15/2001 22:31'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel 	self model: anObject.	getListSelector := getListSel.	getIndexSelector := getSelectionSel.	setIndexSelector := setSelectionSel.	getMenuSelector := getMenuSel.	keystrokeActionSelector := keyActionSel.	autoDeselect := true.	self borderWidth: 1.	self updateList.	self selectionIndex: self getCurrentSelectionIndex.	self initForKeystrokes! !!PluggableTextMorph methodsFor: 'event handling' stamp: 'sw 12/4/2001 12:42'!mouseLeave: event	"The mouse has left the area of the receiver"	textMorph ifNotNil: [selectionInterval := textMorph editor selectionInterval].	super mouseLeave: event.	Preferences mouseOverForKeyboardFocus ifTrue:		[event hand releaseKeyboardFocus: textMorph]! !!TransformationMorph methodsFor: 'menu' stamp: 'RJT 5/31/2006 13:05'!removeFlexShell	"Remove the shell used to make a morph rotatable and scalable."	| oldHalo unflexed pensDown player myWorld refPos aPosition |	refPos := self referencePosition.	myWorld := self world.	oldHalo := self halo.	submorphs isEmpty ifTrue: [^ self delete].	aPosition := (owner submorphIndexOf: self) ifNil: [1].	unflexed := self firstSubmorph.	pensDown := OrderedCollection new.	self allMorphsDo:  "Note any pens down -- must not be down during the move"		[:m | ((player := m player) notNil and: [player getPenDown]) ifTrue:			[m == player costume ifTrue:				[pensDown add: player.				player setPenDown: false]]].	self submorphs do: [:m |		m position: self center - (m extent // 2).		owner addMorph: m asElementNumber: aPosition].	unflexed absorbStateFromRenderer: self.	pensDown do: [:p | p setPenDown: true].	oldHalo ifNotNil: [oldHalo setTarget: unflexed].	myWorld ifNotNil: [myWorld startSteppingSubmorphsOf: unflexed].	self delete.	unflexed referencePosition: refPos.	^ unflexed! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 11/3/2004 19:56'!morphicViewProjectSaverFor: aProject"(FileList2 morphicViewProjectSaverFor: Project current) openInWorld"	| window aFileList buttons treePane pane2 textColor1 option treeExtent buttonData buttonRow |	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	aFileList := self new directory: ServerDirectory projectDefaultDirectory.	aFileList dirSelectionBlock: self hideSqueakletDirectoryBlock.	window := AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	aFileList modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: ColorTheme current dialogBorderWidth;		borderColor: ColorTheme current dialogBorderColor;		useRoundedCorners.	buttonData := Preferences enableLocalSave				ifTrue: [{							{'Save'. #okHit. 'Save in the place specified below, and in the Squeaklets folder on your local disk'. ColorTheme current okColor}.							{'Save on local disk only'. #saveLocalOnlyHit. 'saves in the Squeaklets folder'. ColorTheme current okColor}.							{'Cancel'. #cancelHit. 'return without saving'. ColorTheme current cancelColor}						}]				ifFalse: [{							{'Save'. #okHit. 'Save in the place specified below, and in the Squeaklets folder on your local disk'. ColorTheme current okColor}.							{'Cancel'. #cancelHit. 'return without saving'. ColorTheme current cancelColor}						}].	buttons := buttonData collect: [ :each |		(self blueButtonText: each first textColor: textColor1 color: each fourth inWindow: window)			setBalloonText: each third translated;			hResizing: #shrinkWrap;			on: #mouseUp send: each second to: aFileList	].	option := aProject world 		valueOfProperty: #SuperSwikiPublishOptions 		ifAbsent: [#initialDirectoryList].	aProject world removeProperty: #SuperSwikiPublishOptions.	treeExtent := World height < 500						ifTrue: [ 350@150 ]						ifFalse: [ 350@300 ].	(treePane := aFileList morphicDirectoryTreePaneFiltered: option) 		extent: treeExtent; 		retractable: false;		borderWidth: 0.	window		addARowCentered: {			window fancyText: 'Publish This Project' translated font: Preferences standardEToysTitleFont color: textColor1		}.	buttonRow := OrderedCollection new.	buttons do: [:button | buttonRow add: button] separatedBy: [buttonRow add: ((Morph new extent: 30@5) color: Color transparent)]."	addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second.			(Morph new extent: 30@5) color: Color transparent. 			buttons third		};"	window		addARowCentered: buttonRow;		addARowCentered: { (window inAColumn: {(ProjectViewMorph on: aProject) lock}) layoutInset: 4};		addARowCentered: {			window fancyText: 'Please select a folder' translated font: Preferences standardEToysFont color: textColor1		};		addARow: {			(				window inAColumn: {					(pane2 := window inARow: {window inAColumn: {treePane}}) 						useRoundedCorners;						layoutInset: 0;						borderWidth: ColorTheme current dialogPaneBorderWidth;						borderColor: ColorTheme current dialogPaneBorderColor				}			) layoutInset: 10		}.	window fullBounds.	window fillWithRamp: ColorTheme current dialogRampOrColor oriented: 0.65.	pane2 fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35)."	buttons do: [ :each |		each fillWithRamp: ColorTheme current dialogButtonsRampOrColor oriented: (0.75 @ 0).	]."	window setProperty: #morphicLayerNumber toValue: 11.	aFileList postOpen.	window adoptPaneColor: (Color r: 0.548 g: 0.677 b: 1.0).	^ window ! !!EditCommand methodsFor: 'accessors' stamp: 'sps 1/5/2002 16:36'!newText: aText	^newText := aText! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:55'!cellSpacing	"Layout specific. This property describes how the cell size for each element in a list should be computed.		#globalRect - globally equal rectangular cells		#globalSquare - globally equal square cells		#localRect - locally (e.g., per row/column) equal rectangular cells		#localSquare - locally (e.g., per row/column) equal square cells		#none - cells are sized based on available row/column constraints	"	| props |	props := self layoutProperties.	^props ifNil:[#none] ifNotNil:[props cellSpacing].! !!ColorMappingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:22'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	| oldCanvas |	oldCanvas := myCanvas.	myCanvas translateTo: newOrigin clippingTo: aRectangle during:[:newCanvas|		myCanvas := newCanvas.		aBlock value: self].	myCanvas := oldCanvas.! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 1/2/2005 01:06'!potentialEmbeddingTargets	"Return the potential targets for embedding the receiver"	| oneUp topRend |	(oneUp := (topRend := self topRendererOrSelf) owner) ifNil:[^#()].	^ (oneUp morphsAt: topRend referencePosition behind: topRend unlocked: true) select:		[:m | m  isFlexMorph not]! !!Morph methodsFor: 'copying' stamp: 'tk 2/3/2001 14:29'!veryDeepFixupWith: deepCopier	"If some fields were weakly copied, fix new copy here."	"super veryDeepFixupWith: deepCopier.	Object has no fixups, so don't call it"	"If my owner is being duplicated too, then store his duplicate.	 If I am owned outside the duplicated tree, then I am no longer owned!!"	owner := deepCopier references at: owner ifAbsent: [nil].! !!NewParagraph methodsFor: 'composition' stamp: 'RAA 5/6/2001 15:09'!testNewComposeAll	| newResult |	self 		OLDcomposeLinesFrom: firstCharacterIndex 		to: text size 		delta: 0		into: OrderedCollection new 		priorLines: Array new 		atY: container top.	newResult := TextComposer new		composeLinesFrom: firstCharacterIndex 		to: text size 		delta: 0		into: OrderedCollection new 		priorLines: Array new 		atY: container top		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: false.	newResult first with: lines do: [ :e1 :e2 |		e1 longPrintString = e2 longPrintString ifFalse: [self halt].	].	newResult second = maxRightX ifFalse: [self halt].	^{newResult. {lines. maxRightX}}! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:57'!externalName: aString 	"change the receiver's externalName"	externalName := aString! !!BorderedMorph methodsFor: 'accessing' stamp: 'ar 8/17/2001 16:52'!borderColor: colorOrSymbolOrNil	self doesBevels ifFalse:[		colorOrSymbolOrNil isColor ifFalse:[^self]].	borderColor = colorOrSymbolOrNil ifFalse: [		borderColor := colorOrSymbolOrNil.		self changed].! !!HaloMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 17:37'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].innerTarget := deepCopier references at: innerTarget ifAbsent: [innerTarget].! !!FormCanvas methodsFor: 'drawing-images' stamp: 'ar 12/30/2001 16:36'!warpImage: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."	| tfm |	tfm := (MatrixTransform2x3 withOffset: origin) composedWithLocal: aTransform.	^self privateWarp: aForm transform: tfm at: extraOffset sourceRect: sourceRect cellSize: cellSize! !!Morph methodsFor: 'scripting' stamp: 'ar 1/25/2001 12:50'!asEmptyPermanentScriptor	"Answer a new empty permanent scriptor derived from info deftly secreted in the receiver.  Good grief"	| aScriptor aPlayer |	aPlayer := self valueOfProperty: #newPermanentPlayer.	aPlayer assureUniClass.	aScriptor :=  aPlayer newScriptorAround: nil.	aScriptor position: (self world primaryHand position - (10 @ 10)).	aPlayer updateAllViewersAndForceToShow: #scripts.	^ aScriptor! !!HaloMorph methodsFor: 'private' stamp: 'dgd 4/4/2006 16:56'!addDirectionHandles	| centerHandle d w directionShaft patch patchColor crossHairColor |	self showingDirectionHandles ifFalse: [^ self].	directionArrowAnchor := (target point: target referencePosition in: self world) rounded.	patch := target imageFormForRectangle: (Rectangle center: directionArrowAnchor extent: 3@3).	patchColor := patch colorAt: 1@1.	(directionShaft := LineMorph newSticky makeForwardArrow)		borderWidth: 2; borderColor: (Color green orColorUnlike: patchColor).	self positionDirectionShaft: directionShaft.	self addMorphFront: directionShaft.	directionShaft setCenteredBalloonText: 'Set forward direction' translated;		on: #mouseDown send: #doDirection:with: to: self;		on: #mouseMove send: #trackDirectionArrow:with: to: self;		on: #mouseUp send: #setDirection:with: to: self.	d := 15.  "diameter"  w := 3.  "borderWidth"	crossHairColor := Color red orColorUnlike: patchColor.	(centerHandle := EllipseMorph newBounds: (0@0 extent: d@d) color: Color transparent)			borderWidth: w; borderColor: (Color blue orColorUnlike: patchColor);			addMorph: (LineMorph from: (d//2)@w to: (d//2)@(d-w-1) color: crossHairColor width: 1) lock;			addMorph: (LineMorph from: w@(d//2) to: (d-w-1)@(d//2) color: crossHairColor width: 1) lock;			align: centerHandle bounds center with: directionArrowAnchor.	centerHandle wantsYellowButtonMenu: false.	self addMorph: centerHandle.	centerHandle setCenteredBalloonText: 'Rotation center (hold down the shift key and drag from here to change it)' translated;			on: #mouseDown send: #prepareToTrackCenterOfRotation:with: to: self;			on: #mouseMove send: #trackCenterOfRotation:with: to: self;			on: #mouseUp send: #setCenterOfRotation:with: to: self! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:41'!altSpecialCursor3: aColor	| f box |	"a bulls-eye pattern in this color"	f := Form extent: 32@32 depth: 32.	f offset: (f extent // 2) negated.	box := f boundingBox.	[ box width > 0] whileTrue: [		f fill: box rule: Form over fillColor: aColor.		f fill: (box insetBy: 2) rule: Form over fillColor: Color transparent.		box := box insetBy: 4.	].	^f! !!PolygonMorph methodsFor: 'drawing' stamp: 'wiz 2/23/2006 19:19'!drawArrowsOn: aCanvas 	"Answer (possibly modified) endpoints for border drawing"	"ArrowForms are computed only upon demand"	| array |	self hasArrows		ifFalse: [^ #() ].	"Nothing to do"	array := Array with: vertices first with: vertices last.	"Prevent crashes for #raised or #inset borders"	borderColor isColor		ifFalse: [ ^array ].	(arrows == #forward or: [arrows == #both])		ifTrue: [ array at: 2 put: (self				drawArrowOn: aCanvas				at: vertices last				from: self nextToLastPoint) ].	(arrows == #back or: [arrows == #both])		ifTrue: [ array at: 1 put: (self				drawArrowOn: aCanvas				at: vertices first				from: self nextToFirstPoint) ].	^array! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 5/10/1998 22:07'!inspectIt	| result |	self handleEdit:		[result := textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [result inspect]]! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 3/21/2006 23:11'!mouseMove: anEvent 	anEvent hand temporaryCursor		ifNil: [^ self].	self class fastSplitterResize		ifFalse:  [self updateFromEvent: anEvent]		ifTrue: [traceMorph				ifNil: [traceMorph := Morph newBounds: self bounds.					traceMorph borderColor: Color lightGray.					traceMorph borderWidth: 1.					self owner addMorph: traceMorph].			splitsTopAndBottom				ifTrue: [traceMorph position: traceMorph position x @ (self normalizedY: anEvent cursorPoint y)]				ifFalse: [traceMorph position: (self normalizedX: anEvent cursorPoint x) @ traceMorph position y]]! !!PluggableListMorphOfMany methodsFor: 'initialization' stamp: 'ar 3/17/2001 17:07'!list: listOfStrings	scroller removeAllMorphs.	list := listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	super list: listOfStrings.	"At this point first morph is sensitized, and all morphs share same handler."	scroller firstSubmorph on: #mouseEnterDragging						send: #mouseEnterDragging:onItem:						to: self.	scroller firstSubmorph on: #mouseUp						send: #mouseUp:onItem:						to: self.	"This should add this behavior to the shared event handler thus affecting all items"! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 12/12/2001 10:49'!nominalForm: aForm	"Ascribe the blank nominal form"	originalForm := aForm.	self rotationCenter: 0.5@0.5.	self layoutChanged! !!PluggableButtonMorph methodsFor: 'initialize-release' stamp: 'jrp 7/28/2005 22:42'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom.	self hResizing: #shrinkWrap.	"<--so naked buttons work right"	self vResizing: #shrinkWrap.	self wrapCentering: #center;		 cellPositioning: #topCenter.	self borderStyle: BorderStyle thinGray.	model := nil.	label := nil.	getStateSelector := nil.	actionSelector := nil.	getLabelSelector := nil.	getMenuSelector := nil.	shortcutCharacter := nil.	askBeforeChanging := false.	triggerOnMouseDown := false.	onColor := self color darker.	offColor := self color.	feedbackColor := Color red.	showSelectionFeedback := false.	allButtons := nil.	argumentsProvider := nil.	argumentsSelector := nil.	self extent: 20 @ 15! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/4/2000 16:27'!addHandlesForWorldHalos	"Add handles for world halos, like the man said"	| box w |	w := self world ifNil:[target world].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target bounds.	box := w bounds insetBy: 9.	target addWorldHandlesTo: self box: box.	Preferences uniqueNamesInHalos ifTrue:		[innerTarget assureExternalName].	self addNameBeneath: (box insetBy: (0@0 corner: 0@10)) string: innerTarget externalName.	growingOrRotating := false.	self layoutChanged.	self changed.! !!HandMorph methodsFor: 'geometry' stamp: 'ar 12/30/2001 20:44'!userInitials: aString andPicture: aForm	| cb pictRect initRect f |	userInitials := aString.	pictRect := initRect := cb := self cursorBounds.	userInitials isEmpty ifFalse: [		f := TextStyle defaultFont.		initRect := cb topRight + (0@4) extent: (f widthOfString: userInitials)@(f height).	].	self userPicture: aForm.	aForm ifNotNil: [		pictRect := (self cursorBounds topRight + (0@24)) extent: aForm extent.	].	self bounds: ((cb merge: initRect) merge: pictRect).! !!TextMorph methodsFor: 'events-processing' stamp: 'sw 3/1/2001 17:16'!handleKeystroke: anEvent	"System level event handling."	| pasteUp |	anEvent wasHandled ifTrue:[^self].	(self handlesKeyboard: anEvent) ifFalse:	[^ self].	anEvent wasHandled: true.	anEvent keyCharacter = Character tab ifTrue:		["Allow passing through text morph inside pasteups"		(self wouldAcceptKeyboardFocusUponTab and:				[(pasteUp := self pasteUpMorphHandlingTabAmongFields) notNil])			ifTrue:[^ pasteUp tabHitWithEvent: anEvent]].	self keyStroke: anEvent! !!TextMorph methodsFor: 'linked frames' stamp: 'di 7/28/2001 10:35'!addSuccessor: evt	| newMorph |	newMorph := self copy predecessor: self successor: successor.	newMorph extent: self width @ 100.	successor ifNotNil: [successor setPredecessor: newMorph].	self setSuccessor: newMorph.	successor recomposeChain.	evt hand attachMorph: newMorph! !!SimpleHierarchicalListMorph class methodsFor: 'instance creation' stamp: 'nk 3/8/2004 10:06'!notExpandedForm	notExpandedForm ifNotNil: [ notExpandedForm depth ~= Display depth ifTrue: [ notExpandedForm := nil ]].	^notExpandedForm ifNil: [notExpandedForm := 			(Form				extent: 10@9				depth: 8				fromArray: #( 4294967041 4294967295 4294901760 4294967041 33554431 4294901760 4294967041 1224867839 4294901760 4294967041 1229521407 4294901760 4294967041 1229539585 4294901760 4294967041 1229521407 4294901760 4294967041 1224867839 4294901760 4294967041 33554431 4294901760 4294967041 4294967295 4294901760)				offset: 0@0)					asFormOfDepth: Display depth;					replaceColor: Color white withColor: Color transparent;					yourself	].! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 16:23'!adjustWakeupTimes: now	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| deltaTime |	deltaTime := now - lastStepTime.	stepList do:[:entry| entry scheduledTime: entry scheduledTime + deltaTime].	lastStepTime := now.! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/12/2000 22:37'!sortSubmorphsBy: sortOrderSymbol	"Sort the receiver's submorphs by the criterion indicated in the provided symbol"	self invalidRect: self fullBounds.	submorphs := submorphs sortBy:[:a :b | (a perform: sortOrderSymbol) <= (b perform: sortOrderSymbol)].	self layoutChanged.! !!Morph methodsFor: 'menus' stamp: 'ar 10/25/2000 23:17'!doMenuItem: menuString	| aMenu anItem aNominalEvent aHand |	aMenu := self buildHandleMenu: (aHand := self currentHand).	aMenu allMorphsDo: [:m | m step].  "Get wordings current"	anItem := aMenu itemWithWording: menuString.	anItem ifNil:		[^ self player scriptingError: 'Menu item not found: ', menuString].	aNominalEvent :=  MouseButtonEvent new		setType: #mouseDown		position: anItem bounds center		which: 4 "red"		buttons: 4 "red"		hand: aHand		stamp: nil.	anItem invokeWithEvent: aNominalEvent! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 23:10'!layoutBounds	"Return the bounds for laying out children of the receiver"	| inset box |	inset := self layoutInset.	box := self innerBounds.	inset isZero ifTrue:[^box].	^box insetBy: inset.! !!Morph methodsFor: 'translation' stamp: 'yo 1/27/2005 23:33'!isTurtleRow	| aCollection selectorCollection |	aCollection := Set new.	selectorCollection := Set new.	self accumlatePlayersInto: aCollection andSelectorsInto: selectorCollection.	#(turtleCount: turtleCount grouped: grouped) do: [:sel |		(selectorCollection includes: sel) ifTrue: [^ false].	].	aCollection do: [:e |		(e isKindOf: KedamaExamplerPlayer) ifTrue: [^ true].	].	^ false.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: ''!putSelector: aSymbol	putSelector := aSymbol.! !!TextMorphForEditView methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:50'!convertToCurrentVersion: varDict refStream: smartRefStrm		acceptOnCR ifNil: [acceptOnCR := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!ProjectViewMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/2/2000 09:56'!addProjectNameMorph	| m |	self removeAllMorphs.	m := UpdatingStringMorph contents: self safeProjectName font: self fontForName.	m target: self; getSelector: #safeProjectName; putSelector: #safeProjectName:.	m useStringFormat; fitContents.	self addMorphBack: m.	self updateNamePosition.	^m! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/24/2002 16:18'!innerBounds	| inner |	inner := super innerBounds.	retractableScrollBar | (submorphs includes: scrollBar) not ifFalse:[		inner := (scrollBarOnLeft					ifTrue: [scrollBar right @ inner top corner: inner bottomRight]					ifFalse: [inner topLeft corner: scrollBar left @ inner bottom])	].	(retractableScrollBar | self hIsScrollbarShowing not)		ifTrue: [^ inner]		ifFalse: [^ inner topLeft corner: (inner bottomRight - (0@self scrollBarThickness))].! !!TextFieldMorph methodsFor: 'just like textMorph' stamp: 'ar 4/10/2005 18:54'!contents: textOrString	"talk to my text"	| tm newText atts |	(tm := self findA: TextMorph) ifNil: [^ nil].	textOrString isString ifTrue: [		tm contents ifNotNil: ["Keep previous properties of the field"			newText := textOrString asText.			atts := tm contents attributesAt: 1.			atts do: [:each | newText addAttribute: each].			^ tm contents: newText]].	^ tm contents: textOrString! !!HaloMorph methodsFor: 'private' stamp: 'sw 10/27/2002 09:27'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	self world displayWorld.	evt shiftPressed ifTrue: 		[self delete.		^ innerTarget inspectInMorphic: evt].	menu := innerTarget buildDebugMenu: evt hand.	menu addTitle: (innerTarget externalName truncateWithElipsisTo: 40).	menu popUpEvent: evt in: self world! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 7/10/2005 02:53'!makeVectorUseConformToPreference	"Make certain that the use of vectors in this project conforms to the current preference setting."	| prefValue currentValue |	prefValue := Preferences useVectorVocabulary.	currentValue := self currentlyUsingVectorVocabulary.	prefValue ~~ currentValue ifTrue:		[currentValue			ifTrue:				[self abandonVocabularyPreference]			ifFalse:				[self installVectorVocabulary]]! !!TableLayout methodsFor: 'layout' stamp: 'ar 12/18/2000 13:45'!computeCellSizes: aMorph in: newBounds horizontal: aBool	"Step 1: Compute the minimum extent for all the children of aMorph"	| cells cell size block maxCell minSize maxSize |	cells := WriteStream on: (Array new: aMorph submorphCount).	minSize := properties minCellSize asPoint.	maxSize := properties maxCellSize asPoint.	aBool ifTrue:[		minSize := minSize transposed.		maxSize := maxSize transposed].	maxCell := 0@0.	block := [:m|		m disableTableLayout ifFalse:[			size := m minExtent asIntegerPoint.			cell := LayoutCell new target: m.			aBool ifTrue:[				cell hSpaceFill: m hResizing == #spaceFill.				cell vSpaceFill: m vResizing == #spaceFill.			] ifFalse:[				cell hSpaceFill: m vResizing == #spaceFill.				cell vSpaceFill: m hResizing == #spaceFill.				size := size transposed.			].			size := (size min: maxSize) max: minSize.			cell cellSize: size.			maxCell := maxCell max: size.			cells nextPut: cell]].	properties reverseTableCells		ifTrue:[aMorph submorphsReverseDo: block]		ifFalse:[aMorph submorphsDo: block].	^maxCell -> cells contents! !!Morph methodsFor: 'menus' stamp: 'sw 4/12/2005 23:12'!addPlayerItemsTo: aMenu	"Add player-related items to the menu if appropriate"	| aPlayer subMenu |	self couldMakeSibling ifFalse: [^ self].	aPlayer := self topRendererOrSelf player.	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'make a sibling instance' translated target: self action: #makeNewPlayerInstance:.	subMenu balloonTextForLastItem: 'Makes another morph whose player is of the same class as this one.  Both siblings will share the same scripts' translated.	subMenu add: 'make multiple siblings...' translated target: self action: #makeMultipleSiblings:.	subMenu balloonTextForLastItem: 'Make any number of sibling instances all at once' translated.	(aPlayer belongsToUniClass and: [aPlayer class instanceCount > 1]) ifTrue:		[subMenu addLine.		subMenu add: 'make all siblings look like me' translated target: self action: #makeSiblingsLookLikeMe:.		subMenu balloonTextForLastItem: 'make all my sibling instances look like me.' translated.		subMenu add: 'bring all siblings to my location' translated target: self action: #bringAllSiblingsToMe:.		subMenu balloonTextForLastItem: 'find all sibling instances and bring them to me' translated.		subMenu add: 'apply status to all siblngs' translated target: self action: #applyStatusToAllSiblings:.		subMenu balloonTextForLastItem: 'apply the current status of all of my scripts to the scripts of all my siblings' translated].		subMenu add: 'indicate all siblings' translated target: self action: #indicateAllSiblings.		subMenu balloonTextForLastItem: 'momentarily show, by flashing , all of my visible siblings.'.		aMenu add: 'siblings...' translated subMenu: subMenu! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:57'!hResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	| props |	props := self layoutProperties.	^props ifNil:[#rigid] ifNotNil:[props hResizing].! !!MorphicModel class methodsFor: 'subclass creation' stamp: ''!newSubclass	| i className |	i := 1.	[className := (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i := i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Morphic-Models'! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 11/9/2000 20:43'!addNewRow	| row |	row := AlignmentMorph newRow		vResizing: #spaceFill;		layoutInset: 0;		borderWidth: 0;		extent: (bounds width)@(TileMorph defaultH);		color: Color transparent.	self addMorphBack: row.	^ row! !!PolygonMorph methodsFor: 'private' stamp: 'md 12/12/2003 16:22'!privateMoveBy: delta	super privateMoveBy: delta.	vertices := vertices collect: [:p | p + delta].	self arrowForms do: [:f | f offset: f offset + delta].	curveState := nil.  "Force recomputation"	(self valueOfProperty: #referencePosition) ifNotNilDo:		[:oldPos | self setProperty: #referencePosition toValue: oldPos + delta]! !!CircleMorph methodsFor: 'geometry eToy' stamp: 'nk 7/1/2002 11:16'!rotationCenter	"Return the rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	| refPos |	refPos := self referencePosition.	^ (refPos - self bounds origin) / self bounds extent asFloatPoint! !!GradientFillStyle methodsFor: '*Morphic-Balloon' stamp: 'nk 7/18/2003 16:35'!lastColor: aColor forMorph: aMorph hand: aHand	colorRamp last value: aColor.	isTranslucent := nil.	pixelRamp := nil.	aMorph changed.! !!TextContainer methodsFor: 'access' stamp: 'di 11/13/97 14:45'!fillsOwner: aBoolean	fillsOwner := aBoolean.	self releaseCachedState! !!Morph methodsFor: 'meta-actions' stamp: 'dgd 11/15/2003 19:29'!buildMetaMenu: evt	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	menu := MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' translated action: #grabMorph:.	menu add: 'copy to paste buffer' translated action: #copyToPasteBuffer:.	self maybeAddCollapseItemTo: menu.	menu add: 'delete' translated action: #dismissMorph:.	menu addLine.	menu add: 'copy text' translated action: #clipText.	menu add: 'copy Postscript' translated action: #clipPostscript.	menu add: 'print Postscript to file...' translated action: #printPSToFile.	menu addLine.	menu add: 'go behind' translated action: #goBehind.	menu add: 'add halo' translated action: #addHalo:.	menu add: 'duplicate' translated action: #maybeDuplicateMorph:.	self addEmbeddingMenuItemsTo: menu hand: evt hand.	menu add: 'resize' translated action: #resizeMorph:.	"Give the argument control over what should be done about fill styles"	self addFillStyleMenuItems: menu hand: evt hand.	self addDropShadowMenuItems: menu hand: evt hand.	self addLayoutMenuItems: menu hand: evt hand.	menu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().	menu addLine.	(self morphsAt: evt position) size > 1 ifTrue:		[menu add: 'submorphs...' translated			target: self			selector: #invokeMetaMenuAt:event:			argument: evt position].	menu addLine.	menu add: 'inspect' translated selector: #inspectAt:event: argument: evt position.	menu add: 'explore' translated action: #explore.	menu add: 'browse hierarchy' translated action: #browseHierarchy.	menu add: 'make own subclass' translated action: #subclassMorph.	menu addLine.	menu add: 'set variable name...' translated action: #choosePartName.	(self isMorphicModel) ifTrue:		[menu add: 'save morph as prototype' translated action: #saveAsPrototype.		(self ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' translated action: #beThisWorldsModel]].	menu add: 'save morph in file' translated action: #saveOnFile.	(self hasProperty: #resourceFilePath)		ifTrue: [((self valueOfProperty: #resourceFilePath) endsWith: '.morph')				ifTrue: [menu add: 'save as resource' translated action: #saveAsResource].				menu add: 'update from resource' translated action: #updateFromResource]		ifFalse: [menu add: 'attach to resource' translated action: #attachToResource].	menu add: 'show actions' translated action: #showActions.	menu addLine.	self addDebuggingItemsTo: menu hand: evt hand.	self addCustomMenuItems: menu hand: evt hand.	^ menu! !!FileList2 class methodsFor: 'blue ui' stamp: 'nk 7/16/2003 17:13'!enableTypeButtons: typeButtons info: fileTypeInfo forDir: aDirectory	| foundSuffixes fileSuffixes firstEnabled enableIt |	firstEnabled := nil.	foundSuffixes := (aDirectory ifNil: [ #()] ifNotNil: [ aDirectory fileNames]) collect: [ :each | (each findTokens: '.') last asLowercase].	foundSuffixes := foundSuffixes asSet.	fileTypeInfo with: typeButtons do: [ :info :button |		fileSuffixes := info second.		enableIt := fileSuffixes anySatisfy: [ :patt | foundSuffixes includes: patt].		button 			setProperty: #enabled 			toValue: enableIt.		enableIt ifTrue: [firstEnabled ifNil: [firstEnabled := button]].	].	firstEnabled ifNotNil: [^firstEnabled mouseUp: nil].	typeButtons do: [ :each | each color: Color gray].! !!HaloMorph methodsFor: 'copying' stamp: 'st 9/14/2004 13:03'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	"target := target.		Weakly copied"	"innerTarget := innerTarget.		Weakly copied"	positionOffset := positionOffset veryDeepCopyWith: deepCopier.	angleOffset := angleOffset veryDeepCopyWith: deepCopier.	growingOrRotating := growingOrRotating veryDeepCopyWith: deepCopier.	directionArrowAnchor := directionArrowAnchor.	simpleMode := simpleMode.	haloBox := haloBox.	originalExtent := originalExtent! !!BalloonMorph methodsFor: 'initialization' stamp: 'ar 10/4/2000 10:13'!popUpFor: aMorph hand: aHand	"Pop up the receiver as balloon help for the given hand"	balloonOwner := aMorph.	self popUpForHand: aHand.! !!HandMorph methodsFor: 'halo handling' stamp: 'ar 10/4/2000 13:40'!halo: newHalo	"Set halo associated with this hand"	| oldHalo |	oldHalo := self halo.	(oldHalo isNil or:[oldHalo == newHalo]) ifFalse:[oldHalo delete].	newHalo		ifNil:[self removeProperty: #halo]		ifNotNil:[self setProperty: #halo toValue: newHalo]! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:40'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	| tempCanvas |	tempCanvas := self copyOrigin: newOrigin clipRect: aRectangle.	aBlock value: tempCanvas.	foundMorph := tempCanvas foundMorph.! !!Slider methodsFor: 'initialization' stamp: 'jrp 8/3/2005 10:13'!initializeSlider	slider := RectangleMorph newBounds: self totalSliderArea color: self thumbColor.	sliderShadow := RectangleMorph newBounds: self totalSliderArea						color: self pagingArea color.	slider on: #mouseMove send: #scrollAbsolute: to: self.	slider on: #mouseDown send: #mouseDownInSlider: to: self.	slider on: #mouseUp send: #mouseUpInSlider: to: self.	slider setBorderWidth: 1 borderColor: Color lightGray..	sliderShadow setBorderWidth: 1 borderColor: #inset.	"(the shadow must have the pagingArea as its owner to highlight properly)"	self pagingArea addMorph: sliderShadow.	sliderShadow hide.	self addMorph: slider.	self computeSlider.! !!FileList2 class methodsFor: 'morphic ui' stamp: 'dgd 4/3/2006 14:04'!update: actionRow in: window fileTypeRow: fileTypeRow morphUp: morph	| fileTypeInfo info2 buttons textColor1 fileSuffixes fileActions aFileList fileTypeString |	(morph notNil and:[(morph valueOfProperty: #enabled) not]) ifTrue: [^self].	fileTypeRow submorphsDo: [ :sub |		sub color: (			sub == morph 				ifTrue: [Color white] 				ifFalse: [(sub valueOfProperty: #enabled) 							ifTrue: [Color transparent] ifFalse: [Color gray]]		).	].	fileTypeString := morph isNil ifTrue:['xxxx'] ifFalse:[morph valueOfProperty: #buttonText].	aFileList := window valueOfProperty: #FileList.	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	actionRow removeAllMorphs.	fileTypeInfo := self endingSpecs.	info2 := fileTypeInfo detect: [ :each | each first = fileTypeString] ifNone: [ nil ].	info2 isNil		ifTrue:[			buttons := OrderedCollection new		]		ifFalse:[			fileSuffixes := info2 second.			fileActions := info2 third.			buttons := fileActions collect: [ :each | aFileList blueButtonForService: each textColor: textColor1 inWindow: window ].			buttons do: [ :each |				each fillWithRamp: ColorTheme current okColor oriented: (0.75 @ 0).			].		].	buttons addLast: (self								blueButtonText: 'Cancel'								textColor: textColor1								color: ColorTheme current cancelColor								inWindow: window								balloonText: 'Cancel this search' selector: #cancelHit recipient: aFileList).	buttons do: [ :each | actionRow addMorphBack: each].	window fullBounds.	fileSuffixes isNil ifFalse:[		aFileList fileSelectionBlock: (			self selectionBlockForSuffixes: (fileSuffixes collect: [ :each | '*.',each])		).	].	aFileList updateFileList.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!reverseTableCells: aBool	reverseTableCells := aBool! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'kfr 6/8/2000 22:38'!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph notNil ifTrue:		["the current selection gets munged by resetting the extent, so store it"		tempSelection := self selectionInterval.				"don't reset it if it's not active"		tempSelection = (Interval from: 1 to: 0) 						ifTrue: [retractableScrollBar							ifTrue:[ ^ self]].		self extent: self extent.		self setSelection: tempSelection]! !!ComponentLikeModel methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:03'!justDroppedInto: aMorph event: anEvent	| theModel |	theModel := aMorph modelOrNil.	((aMorph isKindOf: ComponentLayout) 		and: [theModel isKindOf: Component]) ifFalse:		["Disconnect prior to removal by move"		(theModel isKindOf: Component) ifTrue: [self unwire.  model := nil].		^ super justDroppedInto: aMorph event: anEvent].	theModel == model ifTrue: [^ self  "Presumably just a move"].	self initComponentIn: aMorph.	super justDroppedInto: aMorph event: anEvent! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'dgd 9/20/2003 19:05'!rowPrototype	"Answer a prototypical row"	| sampleMorphs aRow |	sampleMorphs := (1 to: (2 + 3 atRandom)) collect:		[:integer | EllipseMorph new extent: ((60 + (20 atRandom)) @ (80 + ((20 atRandom)))); color: Color random; setNameTo: ('egg',  integer asString); yourself].	aRow := self inARow: sampleMorphs.	aRow setNameTo: 'Row'.	aRow enableDragNDrop.	aRow cellInset: 6.	aRow layoutInset: 8.	aRow setBalloonText: 'Things dropped into here will automatically be organized into a row. Once you have added your own items here, you will want to remove the sample colored eggs that this started with, and you will want to change this balloon help message to one of your own!!' translated.	aRow color: Color veryVeryLightGray.	^ aRow			"AlignmentMorph rowPrototype openInHand"! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'yo 2/23/2005 17:17'!initializeForPropertiesPanel	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	isModal := false.	self removeAllMorphs.	self setProperty: #noDraggingThisPicker toValue: true.	self addMorph: ((Morph newBounds: (RevertBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'restore original color' translated).	self addMorph: ((Morph newBounds: (FeedbackBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'shows selected color' translated).	self addMorph: ((Morph newBounds: (TransparentBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'adjust translucency' translated).	self buildChartForm.		selectedColor ifNil: [selectedColor := Color white].	sourceHand := nil.	deleteOnMouseUp := false.	updateContinuously := true.! !!TransformationMorph methodsFor: 'geometry' stamp: 'ar 11/21/2000 17:00'!computeBounds	self hasSubmorphs ifTrue:		[bounds := (transform localBoundsToGlobal:					(Rectangle merging:						(self submorphs collect: [:m | m fullBounds]))) truncated				expandBy: 1].	fullBounds := bounds.! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 12/30/1998 10:54'!initialize	aaLevel := 1.	deferred := false.! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 2/9/1999 05:52'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw a beveled or raised rectangle"	| bw |	"Note: The optimization test below should actually read:		self ifNoTransformWithIn: (r insetBy: borderWidth // 2)	but since borderWidth is assumed to be very small related to r we don't check it."	(self ifNoTransformWithIn: r)		ifTrue:[^super frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor].	"Fill rectangle and draw top and left border"	bw := borderWidth // 2.	self drawRectangle: (r insetBy: bw)		color: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now draw bottom right border."	self drawPolygon: (Array with: r topRight + (bw negated@bw) 							with: r bottomRight - bw asPoint							with: r bottomLeft + (bw@bw negated))		color: nil		borderWidth: borderWidth		borderColor: bottomRightColor.! !!TextFieldMorph methodsFor: 'just like textMorph' stamp: 'ar 12/27/2001 00:03'!prepend: stringOrText	"add to my text"	| tm |	(tm := self findA: TextMorph) ifNil: [^ nil].	tm contents prepend: stringOrText.	tm releaseParagraph; paragraph.	! !!ScrollBar methodsFor: 'initialize' stamp: 'dew 3/4/2002 01:11'!initialize	super initialize.	scrollDelta := 0.02.	pageDelta := 0.2.	self roundedScrollbarLook ifTrue:[		self borderStyle: ((BorderStyle complexFramed width: 2) "baseColor: Color gray")].! !!HaloMorph methodsFor: 'handles' stamp: 'sw 11/27/2001 11:18'!addDismissHandle: handleSpec	"Add the dismiss handle according to the spec, unless selectiveHalos is on and my target resists dismissal"	| dismissHandle |	(target okayToAddDismissHandle or: [Preferences selectiveHalos not]) ifTrue:		[dismissHandle := self addHandle: handleSpec			on: #mouseDown send: #mouseDownInDimissHandle:with: to: self.		dismissHandle on: #mouseUp send: #maybeDismiss:with: to: self.		dismissHandle on: #mouseDown send: #setDismissColor:with: to: self.		dismissHandle on: #mouseMove send: #setDismissColor:with: to: self]! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/8/2001 14:33'!setCenterOfRotation: evt with: rotationHandle	| localPt |	evt hand obtainHalo: self.	evt hand showTemporaryCursor: nil.	(rotationHandle hasProperty: #dragByCenterOfRotation) ifFalse:[		localPt := innerTarget transformFromWorld globalPointToLocal: rotationHandle center.		innerTarget setRotationCenterFrom: localPt.	].	rotationHandle removeProperty: #dragByCenterOfRotation.	self endInteraction! !!Morph methodsFor: 'scripting' stamp: 'sw 10/18/2000 10:32'!viewAfreshIn: aPasteUp showingScript: aScriptName at: aPosition	"Obtain a smartly updated ScriptEditor for the given script name and zap it into place at aPosition"	| anEditor |	self player updateAllViewersAndForceToShow: #scripts.	anEditor := self player scriptEditorFor: aScriptName.	aPasteUp ifNotNil: [aPasteUp addMorph: anEditor].	anEditor position: aPosition.	anEditor currentWorld startSteppingSubmorphsOf: anEditor! !!Morph methodsFor: 'card in a stack' stamp: 'sw 10/23/2000 14:38'!stackDo: aBlock	"If the receiver has a stack, evaluate aBlock on its behalf"	| aStack |	(aStack := self ownerThatIsA: StackMorph) ifNotNil:		[^ aBlock value: aStack]! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/29/2000 17:30'!addText: aString	| t |	t := TextMorph new 		beAllFont: (TextStyle default fontOfSize: 26);		contents: aString.	self extent: t extent * 3.	innerArea := Morph new 		color: Color white; 		extent: self extent - (16@16);		position: self position + (8@8);		lock.	self addMorph: innerArea. 	self addMorph: (t position: self position + t extent; lock).! !!StringMorphAttributeScanner methodsFor: 'scanning' stamp: 'nk 2/26/2004 13:10'!setFont: fontNum	"Set the value of font"	fontNumber := fontNum! !!SystemProgressMorph class methodsFor: 'instance creation' stamp: 'laza 4/9/2004 10:35'!reset	"SystemProgressMorph reset"	UniqueInstance ifNotNil: [UniqueInstance delete].	UniqueInstance := nil.! !!TextMorphEditor methodsFor: 'accessing' stamp: 'tk 1/13/1999 07:53'!morph: aMorph	"Install a link back to the morph being edited (esp for text links)"	morph := aMorph ! !!HaloMorph methodsFor: 'private' stamp: 'sw 2/2/2006 02:46'!startGrow: evt with: growHandle	"Initialize resizing of my target.  Launch a command representing it, to support Undo"	| botRt |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: growHandle.	botRt := target point: target bottomRight in: owner.	positionOffset := (self world viewBox containsPoint: botRt)		ifTrue: [evt cursorPoint - botRt]		ifFalse: [0@0].	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: ('resize ' translated, target nameForUndoWording);			undoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: target extent).	originalExtent := target extent! !!HandMorph methodsFor: 'listeners' stamp: 'ar 10/26/2000 01:27'!eventListeners: anArrayOrNil	eventListeners := anArrayOrNil! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'kfr 1/24/2006 21:23'!addYesNoToHand	"Place a test/yes/no complex in the hand of the beloved user"	| ms messageNodeMorph aMorph |	Preferences universalTiles		ifTrue:			[ms := MessageSend receiver: true selector: #ifTrue:ifFalse:						arguments: {['do nothing']. ['do nothing']}.			messageNodeMorph := ms asTilesIn: playerScripted class globalNames: true.			self primaryHand attachMorph: messageNodeMorph]		ifFalse:			[aMorph := CompoundTileMorph new.			ActiveHand attachMorph: aMorph.			aMorph setNamePropertyTo: 'TestTile' translated.			aMorph position: ActiveHand position.			aMorph formerPosition: ActiveHand position.			self startSteppingSelector: #trackDropZones.]! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:48'!locked: aBoolean 	"change the receiver's locked property"	locked := aBoolean! !!ProjectViewMorph methodsFor: 'caching' stamp: 'RAA 10/27/2000 10:55'!releaseCachedState	"see if we can reduce size of published file, but there may be problems"	super releaseCachedState.	lastProjectThumbnail := image.! !!Morph methodsFor: 'meta-actions' stamp: 'ar 11/4/2000 17:56'!duplicateMorph: evt	"Make and return a duplicate of the receiver's argument"	| dup |	dup := self duplicate.	evt hand grabMorph: dup from: owner. "duplicate was ownerless so use #grabMorph:from: here"	^dup! !!HandMorph methodsFor: 'initialization' stamp: 'ar 3/3/2001 15:27'!resourceJustLoaded	"In case resource relates to me"	cacheCanvas := nil.! !!ComponentLikeModel methodsFor: 'components' stamp: 'di 5/5/1998 00:57'!initComponentIn: aLayout	model := aLayout model.	self nameMeIn: aLayout.	self color: Color lightCyan.	self initPinSpecs.	self initFromPinSpecs.	self showPins.	model addDependent: self! !!SketchMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:53'!erasePixelsOfColor: evt	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	| c r |	self changeColorTarget: self selector: #rememberedColor: originalColor: nil hand: evt hand.   "color to erase"	c := self rememberedColor ifNil: [Color red].	originalForm mapColor: c to: Color transparent.	r := originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: r).! !!HandMorph methodsFor: 'events-processing' stamp: 'nk 7/20/2003 10:02'!handleEvent: anEvent	| evt ofs |	owner ifNil:[^self].	evt := anEvent.	EventStats ifNil:[EventStats := IdentityDictionary new].	EventStats at: #count put: (EventStats at: #count ifAbsent:[0]) + 1.	EventStats at: evt type put: (EventStats at: evt type ifAbsent:[0]) + 1.	evt isMouseOver ifTrue:[^self sendMouseEvent: evt].ShowEvents == true ifTrue:[	Display fill: (0@0 extent: 250@120) rule: Form over fillColor: Color white.	ofs := (owner hands indexOf: self) - 1 * 60.	evt printString displayAt: (0@ofs) + (evt isKeyboard ifTrue:[0@30] ifFalse:[0@0]).	self keyboardFocus printString displayAt: (0@ofs)+(0@45).].	"Notify listeners"	self sendListenEvent: evt to: self eventListeners.	evt isKeyboard ifTrue:[		self sendListenEvent: evt to: self keyboardListeners.		self sendKeyboardEvent: evt.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isDropEvent ifTrue:[		self sendEvent: evt focus: nil.		^self mouseOverHandler processMouseOver: lastMouseEvent].	evt isMouse ifTrue:[		self sendListenEvent: evt to: self mouseListeners.		lastMouseEvent := evt].	"Check for pending drag or double click operations."	mouseClickState ifNotNil:[		(mouseClickState handleEvent: evt from: self) ifFalse:[			"Possibly dispatched #click: or something and will not re-establish otherwise"			^self mouseOverHandler processMouseOver: lastMouseEvent]].	evt isMove ifTrue:[		self position: evt position.		self sendMouseEvent: evt.	] ifFalse:[		"Issue a synthetic move event if we're not at the position of the event"		(evt position = self position) ifFalse:[self moveToEvent: evt].		"Drop submorphs on button events"		(self hasSubmorphs) 			ifTrue:[self dropMorphs: evt]			ifFalse:[self sendMouseEvent: evt].	].	ShowEvents == true ifTrue:[self mouseFocus printString displayAt: (0@ofs) + (0@15)].	self mouseOverHandler processMouseOver: lastMouseEvent.! !!PluggableListMorph methodsFor: 'accessing' stamp: 'ar 3/17/2001 15:32'!itemFromPoint: aPoint	"Return the list element (morph) at the given point or nil if outside"	| ptY |	scroller hasSubmorphs ifFalse:[^nil].	(scroller fullBounds containsPoint: aPoint) ifFalse:[^nil].	ptY := (scroller firstSubmorph point: aPoint from: self) y.	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"	scroller firstSubmorph top > ptY ifTrue:[^nil].	scroller lastSubmorph bottom < ptY ifTrue:[^nil].	"now use binary search"	^scroller 		findSubmorphBinary:[:item|			(item top <= ptY and:[item bottom >= ptY])				ifTrue:[0] "found"				ifFalse:[ (item top + item bottom // 2) > ptY ifTrue:[-1] ifFalse:[1]]]! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37'!topFraction: aNumber offset: anInteger	topFraction := aNumber.	topOffset := anInteger! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 11/27/1999 09:12'!addToWorld: world near: box	| goodLocation |	goodLocation := self bestPositionNear: box inWorld: world.	world allMorphsDo:		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:			[(p selector == selector and: [p argument == argument])				ifTrue: [^ p comeToFront  "uncover existing picker"]				ifFalse: ["place second picker relative to first"						goodLocation := self bestPositionNear: p bounds inWorld: world]]]].	self position: goodLocation.	world addMorphFront: self.	self changed! !!TheWorldMenu methodsFor: 'construction' stamp: 'rr 3/10/2006 16:41'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu := MenuMorph new defaultTarget: self.	menu commandKeyHandler: self.	self colorForDebugging: menu.	menu addStayUpItem.	ServiceGui worldMenu: menu.	ServiceGui onlyServices		ifTrue: [^ menu].	self fillIn: menu from: {{'previous project'. {#myWorld. #goBack}. 'return to the most-recently-visited project'}. {'jump to project...'. {#myWorld. #jumpToProject}. 'put up a list of all projects, letting me choose one to go to'}. {'save project on file...'. {#myWorld. #saveOnFile}. 'save this project on a file'}. {'load project from file...'. {self. #loadProject}. 'load a project from a file'}. nil}.	myWorld addUndoItemsTo: menu.	self fillIn: menu from: {{'restore display (r)'. {World. #restoreMorphicDisplay}. 'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.'}. nil}.	Preferences simpleMenus		ifFalse: [self fillIn: menu from: {{'open...'. {self. #openWindow}}. {'windows...'. {self. #windowsDo}}. {'changes...'. {self. #changesDo}}}].	self fillIn: menu from: {{'help...'. {self. #helpDo}. 'puts up a menu of useful items for updating the system, determining what version you are running, and much else'}. {'appearance...'. {self. #appearanceDo}. 'put up a menu offering many controls over appearance.'}}.	Preferences simpleMenus		ifFalse: [self fillIn: menu from: {{'do...'. {Utilities. #offerCommonRequests}. 'put up an editible list of convenient expressions, and evaluate the one selected.'}}].	self fillIn: menu from: {nil. {'objects (o)'. {#myWorld. #activateObjectsTool}. 'A tool for finding and obtaining many kinds of objects'}. {'new morph...'. {self. #newMorph}. 'Offers a variety of ways to create new objects'}. nil. {'authoring tools...'. {self. #scriptingDo}. 'A menu of choices useful for authoring'}. {'playfield options...'. {self. #playfieldDo}. 'A menu of options pertaining to this object as viewed as a playfield'}. {'flaps...'. {self. #flapsDo}. 'A menu relating to use of flaps.  For best results, use "keep this menu up"'}. {'projects...'. {self. #projectDo}. 'A menu of commands relating to use of projects'}}.	Preferences simpleMenus		ifFalse: [self fillIn: menu from: {{'print PS to file...'. {self. #printWorldOnFile}. 'write the world into a postscript file'}. {'debug...'. {self. #debugDo}. 'a menu of debugging items'}}].	self fillIn: menu from: {nil. {'save'. {SmalltalkImage current. #saveSession}. 'save the current version of the image on disk'}. {'save as...'. {SmalltalkImage current. #saveAs}. 'save the current version of the image on disk under a new name.'}. {'save as new version'. {SmalltalkImage current. #saveAsNewVersion}. 'give the current image a new version-stamped name and save it under that name on disk.'}. {'save and quit'. {self. #saveAndQuit}. 'save the current image on disk, and quit out of Squeak.'}. {'quit'. {self. #quitSession}. 'quit out of Squeak.'}}.	^ menu! !!PluggableTabButtonMorph methodsFor: 'drawing' stamp: 'KLC 2/2/2004 15:07'!drawTabOn: aCanvas	| top myColor cornerRadius myArcLengths myBounds |	cornerRadius := self cornerRadius.	myBounds := self bounds.	self active		ifTrue: [ top := myBounds top.			myColor := self color ]		ifFalse: [ top := myBounds top + self topInactiveGap.			myColor := self color whiter whiter ].	aCanvas fillRectangle:		((myBounds left + cornerRadius)				@ (top + cornerRadius)			corner: (myBounds right - cornerRadius)						@ self bottom)		color: myColor.	aCanvas fillRectangle:		((myBounds left + (cornerRadius * 2)) @ top			corner: (myBounds right - (cornerRadius * 2))				@ (top + cornerRadius))		color: myColor.	aCanvas fillOval:		((myBounds left + self cornerRadius) @ top			corner: (myBounds left + (self cornerRadius * 3))				@ (top + (self cornerRadius * 2)))		color: myColor.	aCanvas fillOval:		((myBounds right - (self cornerRadius * 3)) @ top			corner: (myBounds right - self cornerRadius)				@ (top + (self cornerRadius * 2)))		color: myColor.	myArcLengths := self arcLengths.	1 to: myArcLengths size do: [ :i | | length |		length := myArcLengths at: i.		aCanvas line: (myBounds left + cornerRadius - i) @ (myBounds bottom - 1 )			to: (myBounds left + cornerRadius - i) @ (myBounds bottom - length - 1)			color: myColor.		aCanvas line: (myBounds right - cornerRadius + i - 1) @ (myBounds bottom - 1)			to: (myBounds right - cornerRadius + i - 1) @ (myBounds bottom - length - 1)			color: myColor]	! !!TextMorph methodsFor: 'private' stamp: 'di 7/28/2001 10:34'!text: t textStyle: s wrap: wrap color: c	predecessor: pred successor: succ	"Private -- for use only in morphic duplication"	text := t.	textStyle := s.	wrapFlag := wrap.	color := c.	paragraph := editor := container := nil.	self predecessor: pred successor: succ! !!PluggableMessageCategoryListMorph methodsFor: 'updating' stamp: 'ls 8/19/2001 14:26'!verifyContents		| newList existingSelection anIndex newRawList |	(model editSelection == #editComment) ifTrue: [^ self].	model classListIndex = 0 ifTrue: [^ self].	newRawList := model perform: getRawListSelector.	newRawList == priorRawList ifTrue: [^ self].  "The usual case; very fast"	priorRawList := newRawList.	newList := (Array with: ClassOrganizer allCategory), priorRawList.	list = newList ifTrue: [^ self].	self flash.  "could get annoying, but hell"	existingSelection := self selection.	self updateList.	(anIndex := newList indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifNil:			[self changeModelSelection: 0]! !!ScrollBar methodsFor: 'initialize' stamp: 'jrp 8/3/2005 09:55'!initializeDownButton	"initialize the receiver's downButton"	downButton := RectangleMorph 				newBounds: (self innerBounds bottomRight - self buttonExtent 						extent: self buttonExtent)				color: self thumbColor.	downButton 		on: #mouseDown		send: #scrollDownInit		to: self.	downButton 		on: #mouseUp		send: #finishedScrolling		to: self.	self updateDownButtonImage.	self roundedScrollbarLook 		ifTrue: 			[downButton color: Color veryLightGray.			downButton borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [downButton setBorderWidth: 1 borderColor: Color lightGray].	self addMorph: downButton! !!TextMorph methodsFor: 'multi level undo' stamp: 'sps 7/24/2003 16:49'!editHistory: aTextMorphCommandHistory	^editHistory := aTextMorphCommandHistory ! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 7/8/2005 21:42'!mouseUp: anEvent 	(self bounds containsPoint: anEvent cursorPoint)		ifFalse: [anEvent hand showTemporaryCursor: nil].	self class fastSplitterResize		ifTrue: [self updateFromEvent: anEvent].	traceMorph ifNotNil: [traceMorph delete. traceMorph := nil].	self color: self getOldColor! !!SimpleButtonMorph methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 15:49'!objectForDataStream: refStrm	"I am about to be written on an object file.  If I send a message to a BookMorph, it would be bad to write that object out.  Create and write out a URLMorph instead."	| bb thatPage um stem ind sqPg |	(actionSelector == #goToPageMorph:fromBookmark:) | 		(actionSelector == #goToPageMorph:) ifFalse: [			^ super objectForDataStream: refStrm].	"normal case"	target url ifNil: ["Later force target book to get a url."		bb := SimpleButtonMorph new.	"write out a dummy"		bb label: self label.		bb bounds: bounds.		refStrm replace: self with: bb.		^ bb].	(thatPage := arguments first) url ifNil: [			"Need to assign a url to a page that will be written later.			It might have bookmarks too.  Don't want to recurse deeply.  			Have that page write out a dummy morph to save its url on the server."		stem := target getStemUrl.	"know it has one"		ind := target pages identityIndexOf: thatPage.		thatPage reserveUrl: stem,(ind printString),'.sp'].	um := URLMorph newForURL: thatPage url.	sqPg := thatPage sqkPage clone.	sqPg contentsMorph: nil.	um setURL: thatPage url page: sqPg.	(SqueakPage stemUrl: target url) = (SqueakPage stemUrl: thatPage url) 		ifTrue: [um book: true]		ifFalse: [um book: target url].  	"remember which book"	um privateOwner: owner.	um bounds: bounds.	um isBookmark: true; label: self label.	um borderWidth: borderWidth; borderColor: borderColor.	um color: color.	refStrm replace: self with: um.	^ um! !!FileList2 methodsFor: 'initialization' stamp: 'mir 2/6/2004 17:25'!limitedSuperSwikiDirectoryList	| dir nameToShow dirList localDirName localDir |	dirList := OrderedCollection new.	ServerDirectory serverNames do: [ :n | 		dir := ServerDirectory serverNamed: n.		dir isProjectSwiki ifTrue: [			nameToShow := n.			dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl)		].	].	ServerDirectory localProjectDirectories do: [ :each |		dirList add: (FileDirectoryWrapper with: each name: each localName model: self)	].	"Make sure the following are always shown, but not twice"	localDirName := SecurityManager default untrustedUserDirectory.	localDir := FileDirectory on: localDirName.	((ServerDirectory localProjectDirectories collect: [:each | each pathName]) includes: localDirName)			ifFalse: [dirList add: (FileDirectoryWrapper with: localDir name: localDir localName model: self)].	FileDirectory default pathName = localDirName			ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	(dirList anySatisfy: [:each | each withoutListWrapper acceptsUploads])		ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	^dirList! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 21:30'!extraSpace: aPoint	extraSpace := aPoint! !!ScrollPane methodsFor: 'menu' stamp: 'di 11/14/97 09:09'!leftOrRight  "Change scroll bar location"	scrollBarOnLeft := scrollBarOnLeft not.	self extent: self extent! !!SystemWindow methodsFor: 'menu' stamp: 'nb 6/17/2003 12:25'!takeOutOfWindow	"Take the receiver's pane morph out the window and place it, naked, where once the window was"	| aMorph |	paneMorphs size == 1 ifFalse: [^ Beeper beep].	aMorph := paneMorphs first.	owner addMorphFront: aMorph.	self delete! !!Morph methodsFor: 'drawing' stamp: 'sw 10/10/1999 23:25'!refreshWorld	| aWorld |	(aWorld := self world) ifNotNil: [aWorld displayWorldSafely]! !!NewParagraph methodsFor: 'selection' stamp: 'di 12/2/97 19:57'!selectionStart: startBlock selectionStop: stopBlock	selectionStart := startBlock.	selectionStop := stopBlock.! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/13/2000 17:57'!cellInset: aNumber	cellInset := aNumber! !!ScrollBar methodsFor: 'geometry' stamp: 'hpt 4/3/2003 19:18'!totalSliderArea	| upperBoundsButton |	upperBoundsButton := menuButton ifNil: [upButton].	bounds isWide		ifTrue: [			upButton right > upperBoundsButton right				ifTrue: [upperBoundsButton := upButton].			^upperBoundsButton bounds topRight corner: downButton bounds bottomLeft]		ifFalse:[			upButton bottom > upperBoundsButton bottom				ifTrue: [upperBoundsButton := upButton].			^upperBoundsButton bounds bottomLeft corner: downButton bounds topRight].! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 1/27/2001 14:44'!removeEmptyRows	submorphs copy do: [:m |		(m isAlignmentMorph and: [m submorphCount = 0])			ifTrue: [m delete]].self flag: #arNote. "code below lead to large and unnecessary recomputations of layouts; without it things just fly""	self fullBounds.	self layoutChanged."	self flag: #noteToJohn.  "Screws up when we have nested IFs.  got broken in 11/97 when you made some emergency fixes for some other reason, and has never worked since...  Would be nice to have a more robust reaction to this!!""	self removeEmptyLayoutMorphs.	spacer := LayoutMorph new extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: self indexForLeadingSpacer.	spacer := LayoutMorph new  extent: 10@12.	spacer vResizing: #rigid.	self privateAddMorph: spacer atIndex: (submorphs size + 1).	self fullBounds; layoutChanged."! !!Morph methodsFor: 'card in a stack' stamp: 'nb 6/17/2003 12:25'!newCard	"Create a new card for the receiver and return it"	| aNewInstance |	self isStackBackground ifFalse: [^ Beeper beep].  "bulletproof against deconstruction"	aNewInstance := self player class baseUniclass new.	^ aNewInstance! !!FileList methodsFor: 'volume list and pattern' stamp: 'sma 11/11/2000 18:06'!listForPattern: pat	"Make the list be those file names which match the pattern."	| sizePad newList |	newList := (self entriesMatching: pat) asSortedCollection: self sortBlock.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray! !!FormCanvas methodsFor: 'private' stamp: 'tpr 9/15/2004 10:28'!setClearColor: aColor	"Install a new clear color - e.g., a color is used for clearing the background"	| clearColor |	clearColor := aColor ifNil:[Color transparent].	clearColor isColor ifFalse:[		(clearColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: clearColor; combinationRule: Form over].	"Okay, so clearColor really *is* a color"	port sourceForm: nil.	port combinationRule: Form over.	port fillPattern: clearColor.	self depth = 8 ifTrue:[		"Use a stipple pattern"		port fillColor: (form balancedPatternFor: clearColor)].! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 16:37'!layoutInset: aNumber	layoutInset := aNumber! !!PasteUpMorph class methodsFor: 'project' stamp: 'RAA 5/25/2000 15:26'!disableDeferredUpdates	^DisableDeferredUpdates ifNil: [DisableDeferredUpdates := false]! !!BorderStyle class methodsFor: 'instance creation' stamp: 'yo 7/2/2004 17:21'!borderStyleForSymbol: sym	"Answer a border style corresponding to the given symbol"	| aSymbol |	aSymbol := sym == #none ifTrue: [#simple] ifFalse: [sym].	^ self perform: aSymbol"	| aSymbol selector |	aSymbol := sym == #none ifTrue: [#simple] ifFalse: [sym].	selector := Vocabulary eToyVocabulary translationKeyFor: aSymbol.	selector isNil ifTrue: [selector := aSymbol].	^ self perform: selector"! !!ObjectExplorerWrapper methodsFor: 'monitoring' stamp: 'nk 7/12/2003 18:28'!refresh	"hack to refresh item given an object and a string that is either an index or an instance variable name."	[ | index |		(model class allInstVarNames includes: itemName)			ifTrue: [ item := model instVarNamed: itemName ]			ifFalse: [ index := itemName asNumber.				(index between: 1 and: model basicSize) ifTrue: [ item := model basicAt: index]]	] on: Error do: [ :ex | item := nil ]! !!StringMorphEditor methodsFor: 'event handling' stamp: 'nk 1/23/2004 13:18'!keyboardFocusChange: aBoolean	| hadFocus |	owner ifNil: [ ^self ].	hadFocus := owner hasFocus.	super keyboardFocusChange: aBoolean.	aBoolean ifFalse:		[hadFocus ifTrue:			[owner lostFocusWithoutAccepting; doneWithEdits].		^ self delete]! !!TextMorphEditor methodsFor: 'attributes' stamp: 'KR 12/5/2005 00:57'!changeEmphasisOrAlignment	| aList reply  code align menuList startIndex alignSymbol |	self flag: #arNote. "Move this up once we get rid of MVC"	startIndex := self startIndex.	aList := #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).		align := paragraph text alignmentAt: startIndex 		ifAbsent:[paragraph textStyle alignment].	alignSymbol := TextAlignment alignmentSymbol: align.	code := paragraph text emphasisAt: startIndex.	menuList := WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal' translated.	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue:['<on>', emph asString translated]			ifFalse:['<off>',emph asString translated]]).	((paragraph text attributesAt: startIndex forStyle: paragraph textStyle)		anySatisfy:[:attr| attr isKern and:[attr kern < 0]]) 			ifTrue:[menuList nextPut:'<on>', 'narrow' translated]			ifFalse:[menuList nextPut:'<off>', 'narrow' translated].	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collect:[:type|		type == alignSymbol			ifTrue:['<on>',type asString translated]			ifFalse:['<off>',type asString translated]]).	aList := #(normal bold italic underlined struckOut narrow leftFlush centered rightFlush justified).	reply := (SelectionMenu labelList: menuList contents lines: #(1 6) selections: aList) startUpWithoutKeyboard.	reply notNil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[self setAlignment: reply.				paragraph composeAll.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!Morph methodsFor: 'objects from disk' stamp: 'tk 7/11/1998 18:53'!storeDataOn: aDataStream	"Let all Morphs be written out.  All owners are weak references.  They only go out if the owner is in the tree being written."	| cntInstVars cntIndexedVars ti localInstVars |	"block my owner unless he is written out by someone else"	cntInstVars := self class instSize.	cntIndexedVars := self basicSize.	localInstVars := Morph instVarNames.	ti := 2.  	((localInstVars at: ti) = 'owner') & (Morph superclass == Object) ifFalse:			[self error: 'this method is out of date'].	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: ti-1 do:		[:i | aDataStream nextPut: (self instVarAt: i)].	aDataStream nextPutWeak: owner.	"owner only written if in our tree"	ti+1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/11/2002 14:44'!format	"Answer the receiver's format: #default or #string"	^ format ifNil: [format := #default]! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 4/3/2006 14:02'!endingSpecs	"Answer a collection of specs to build the selective 'find anything' tool called by the Navigator. This version uses the services registry to do so."	"FileList2 morphicViewGeneralLoaderInWorld: World"	| categories services specs rejects |	rejects := #(addFileToNewZip: compressFile: openInZipViewer: extractAllFrom: openOn:).	categories := #(		('Art' ('bmp' 'gif' 'jpg' 'jpeg' 'form' 'png' 'pcx' 'xbm' 'xpm' 'ppm' 'pbm'))		('Morphs' ('morph' 'morphs' 'sp'))		('Projects' ('extseg' 'project' 'pr'))		('MIDI' ('mid' 'midi'))		('Music' ('mp3'))		('Movies' ('movie' 'mpg' 'mpeg' 'qt' 'mov'))		('Flash' ('swf'))	).		"('Books' ('bo'))"		"('Code' ('st' 'cs'))"		"('TrueType' ('ttf'))"		"('3ds' ('3ds'))"		"('Tape' ('tape'))"		"('Wonderland' ('wrl'))"		"('HTML' ('htm' 'html'))"	categories first at: 2 put: ImageReadWriter allTypicalFileExtensions.	specs := OrderedCollection new.	categories do: [ :cat | | catSpecs catServices okExtensions |		services := Dictionary new.		catSpecs := Array new: 3.		catServices := OrderedCollection new.		okExtensions := Set new.		cat second do: [ :ext | (FileList itemsForFile: 'fred.',ext) do: [ :i |			(rejects includes: i selector) ifFalse: [				okExtensions add: ext.				services at: i label put: i ]]].		services do: [ :svc | catServices add: svc ].		services isEmpty ifFalse: [ 			catSpecs at: 1 put: cat first;				at: 2 put: okExtensions;				at: 3 put: catServices.			specs add: catSpecs ]	].	^specs! !!KeyboardEvent methodsFor: 'initialize' stamp: 'ar 10/25/2000 22:08'!type: eventType readFrom: aStream	type := eventType.	timeStamp := Integer readFrom: aStream.	aStream skip: 1.	buttons := Integer readFrom: aStream.	aStream skip: 1.	keyValue := Integer readFrom: aStream.! !!Morph methodsFor: 'private' stamp: 'nk 10/11/2003 16:08'!privateAddAllMorphs: aCollection atIndex: index	"Private. Add aCollection of morphs to the receiver"	| myWorld itsWorld otherSubmorphs |	myWorld := self world.	otherSubmorphs := submorphs copyWithoutAll: aCollection.	(index between: 0 and: otherSubmorphs size)		ifFalse: [^ self error: 'index out of range'].	index = 0		ifTrue:[	submorphs := aCollection asArray, otherSubmorphs]		ifFalse:[	index = otherSubmorphs size			ifTrue:[	submorphs := otherSubmorphs, aCollection]			ifFalse:[	submorphs := otherSubmorphs copyReplaceFrom: index + 1 to: index with: aCollection ]].	aCollection do: [:m | | itsOwner |		itsOwner := m owner.		itsOwner ifNotNil: [			itsWorld := m world.			(itsWorld == myWorld) ifFalse: [				itsWorld ifNotNil: [self privateInvalidateMorph: m].				m outOfWorld: itsWorld].			(itsOwner ~~ self) ifTrue: [				m owner privateRemove: m.				m owner removedMorph: m ]].		m privateOwner: self.		myWorld ifNotNil: [self privateInvalidateMorph: m].		(myWorld == itsWorld) ifFalse: [m intoWorld: myWorld].		itsOwner == self ifFalse: [			self addedMorph: m.			m noteNewOwner: self ].	].	self layoutChanged.! !!PolygonMorph methodsFor: 'menu' stamp: 'yo 3/14/2005 12:54'!specifyDashedLine	| executableSpec newSpec |	executableSpec := FillInTheBlank		request:'Enter a dash specification as{ major dash length. minor dash length. minor dash color }The major dash will have the normal border color.A blank response will remove the dash specification.[Note: You may give 5 items as, eg, {10. 5. Color white. 0. 3}where the 4th ityem is zero, and the 5th is the number of pixelsby which the dashes will move in each step of animation]' translated		initialAnswer: '{ 10. 5. Color red }'.	executableSpec isEmpty ifTrue:		[^ self stopStepping; dashedBorder: nil].	newSpec := [Compiler evaluate: executableSpec] ifError:		[^ self stopStepping; dashedBorder: nil].	newSpec first isNumber & newSpec second isNumber & newSpec third isColor ifFalse:		[^ self stopStepping; dashedBorder: nil].	newSpec size = 3 ifTrue:		[^ self stopStepping; dashedBorder: newSpec].	(newSpec size = 5 and: [newSpec fourth isNumber & newSpec fifth isNumber]) ifTrue:		[^ self dashedBorder: newSpec; startStepping].! !!LayoutProperties methodsFor: 'initialize' stamp: 'ar 11/14/2000 17:53'!initialize	hResizing := vResizing := #rigid.	disableLayout := false.! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'RAA 8/1/1998 00:19'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self model: anObject.	getListSelector := getListSel.	getSelectionSelector := getSelectionSel.	setSelectionSelector := setSelectionSel.	getMenuSelector := getMenuSel.	keystrokeActionSelector := keyActionSel.	autoDeselect := true.	self borderWidth: 1.	self list: self getList.! !!PolygonMorph methodsFor: 'drawing' stamp: 'ar 11/26/2001 23:15'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight 	line segments."	| array |	vertices size < 1		ifTrue: [self error: 'a polygon must have at least one point'].	closed ifTrue:		[aCanvas drawPolygon: self getVertices fillStyle: self fillStyle.		aCanvas isShadowDrawing ifTrue: [^ self]].	array := self drawArrowsOn: aCanvas.	self drawClippedBorderOn: aCanvas usingEnds: array.! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'ar 11/8/2000 15:50'!autoScrollView: evt	"This is kind of a hack because the PluggableTextMorph expects me to first expand the selection before auto scrolling will work."	| localEvt |	localEvt := evt transformedBy: (self transformedFrom: editView).	super mouseMove: localEvt.	editView scrollSelectionIntoView: localEvt.! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:51'!disableTableLayout: aBool	disableLayout := aBool! !!CornerGripMorph methodsFor: 'as yet unclassified' stamp: 'bvs 3/24/2004 14:38'!target: aMorph	target := aMorph! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'RAA 5/4/2001 11:33'!checkIfReadyToSlide	"Check whether we are now in sync with previously composed lines"	(possibleSlide and: [currCharIndex > stopCharIndex]) ifFalse: [^self].	[prevIndex < prevLines size		and: [(prevLines at: prevIndex) first < (currCharIndex - deltaCharIndex)]]			whileTrue: [prevIndex := prevIndex + 1].	(prevLines at: prevIndex) first = (currCharIndex - deltaCharIndex) ifTrue: [		"Yes -- next line will have same start as prior line."		prevIndex := prevIndex - 1.		possibleSlide := false.		nowSliding := true	] ifFalse: [		prevIndex = prevLines size ifTrue: [			"Weve reached the end of prevLines, so no use to keep looking for lines to slide."			possibleSlide := false		]	]! !!TextMorph methodsFor: 'visual properties' stamp: 'di 6/22/2001 09:52'!fillStyle: aFillStyle	"Set the current fillStyle of the receiver."	self setProperty: #fillStyle toValue: aFillStyle.	"Workaround for Morphs not yet converted"	backgroundColor := aFillStyle asColor.	self changed.! !!SelectionMorph methodsFor: 'halo commands' stamp: 'dgd 9/20/2004 13:41'!alignRightEdges	"Make the right coordinate of all my elements be the same"	| maxRight |	maxRight := (selectedItems collect: [:itm | itm right]) max.	selectedItems do:		[:itm | itm right: maxRight].	self changed! !!SystemWindow methodsFor: 'initialization' stamp: 'jrp 7/23/2005 21:26'!addPaneVSplitters	| remaining targetX sameX |	remaining := paneMorphs copy reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[targetX := remaining first layoutFrame rightFraction.		sameX := paneMorphs select: [:each | each layoutFrame rightFraction = targetX].		self addPaneVSplitterBetween: remaining first and: sameX.		remaining := remaining copyWithoutAll: sameX]! !!WorldState class methodsFor: 'class initialization' stamp: 'RAA 7/15/2000 12:58'!deferredUIMessages	^DeferredUIMessages ifNil: [DeferredUIMessages := SharedQueue new].! !!StringMorph methodsFor: 'objects from disk' stamp: 'tk 11/29/2004 16:52'!fixUponLoad: aProject seg: anImageSegment	"We are in an old project that is being loaded from disk.Fix up conventions that have changed."	| substituteFont |	substituteFont := aProject projectParameters at:#substitutedFont ifAbsent: [#none].	(substituteFont ~~ #none and: [self font == substituteFont])			ifTrue: [ self fitContents ].	^ super fixUponLoad: aProject seg: anImageSegment! !!TransformMorph methodsFor: 'accessing' stamp: 'ar 1/30/2001 23:20'!angle: newAngle	self changed.	transform := transform withAngle: newAngle.	self layoutChanged.	self changed! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 11/13/1998 09:56'!updateSubmorphThumbnails	| thumbsUp itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails |	thumbsUp := self alwaysShowThumbnail.	heightForThumbnails := self heightForThumbnails.	maxHeightToAvoidThumbnailing := self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails := self maximumThumbnailWidth.	self submorphs do:		[:aMorph | thumbsUp			ifTrue:				[itsThumbnail := aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.				(aMorph == itsThumbnail)					ifFalse:						[self replaceSubmorph: aMorph by: itsThumbnail]]			ifFalse:				[(aMorph isKindOf: MorphThumbnail)					ifTrue:						[self replaceSubmorph: aMorph by: aMorph morphRepresented]]]! !!PluggableMultiColumnListMorph methodsFor: 'model access' stamp: 'ls 7/12/2001 23:24'!getList	"fetch and answer the lists to be displayed"	getListSelector == nil ifTrue: [^ #()].	list := model perform: getListSelector.	list == nil ifTrue: [^ #()].	list := list collect: [ :column | column collect: [ :item | item asStringOrText ] ].	^ list! !!PluggableListMorph methodsFor: 'initialization' stamp: 'sw 1/12/2000 16:22'!doubleClickSelector: aSymbol	doubleClickSelector := aSymbol! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 3/10/2004 13:17'!hLeftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	| w |	scroller hasSubmorphs ifFalse:[^0].	w :=  bounds width.	self vIsScrollbarShowing ifTrue:[ w := w - self scrollBarThickness ].	^ (self hTotalScrollRange - w roundTo: self scrollDeltaHeight) max: 0! !!NewParagraph methodsFor: 'private' stamp: 'di 5/21/1998 21:47'!textStyle: ts lines: l text: t	"Private -- just a service for deepCopy"	textStyle := ts.	lines := l.	text := t.! !!Morph methodsFor: 'testing' stamp: 'sw 10/24/2004 15:28'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self isPartsDonor ifTrue: [^ false].	(self == self topRendererOrSelf) ifTrue: [self player wantsSteps ifTrue: [^ true]].	c := self class.	[c includesSelector: #step] whileFalse: [c := c superclass].	^ c ~= Morph! !!ProjectViewMorph methodsFor: 'events' stamp: 'yo 8/1/2005 21:00'!showMenuForProjectView	| menu selection |	(menu := CustomMenu new)		add: 'enter this project' translated		action: [^ self enter];				add: 'ENTER ACTIVE' translated		action: [self setProperty: #wasOpenedAsSubproject toValue: true.			^ self enterAsActiveSubproject];				add: 'PUBLISH (also saves a local copy)' translated		action: [^ project storeOnServerShowProgressOn: self forgetURL: false];				add: 'PUBLISH to a different server' translated		action: [project forgetExistingURL.			^ project storeOnServerShowProgressOn: self forgetURL: true];				add: 'see if server version is more recent' translated		action: [^ self checkForNewerVersionAndLoad];		addLine;		add: 'expunge this project' translated		action: [^ self expungeProject].	selection := menu build startUpCenteredWithCaption: ('Project Named \"{1}"' translated withCRs format: {project name}).	selection		ifNil: [^ self].	selection value! !!SystemWindow class methodsFor: 'initializing' stamp: 'jrp 7/31/2005 13:21'!collapseBoxImage	"Supplied here because we don't necessarily have ComicBold"	^ CollapseBoxImage ifNil: [ CollapseBoxImage := (Form	extent: 10@10	depth: 32	fromArray: #( 0 0 4127260929 4127260929 4127260929 4127260929 4127260929 0 0 0 0 3875602689 3212869760 3212869760 3212869760 3212869760 3212869760 4227924225 0 0 4127260929 3212869760 3212869760 0 0 0 0 3212869760 4127260929 0 4127260929 3212869760 0 0 0 0 0 0 4127260929 3212869760 4127260929 3212869760 0 0 0 0 0 0 4127260929 3212869760 4127260929 3212869760 0 0 0 0 0 0 4127260929 3212869760 4128708375 3212869760 0 0 0 0 0 0 4127260929 3212869760 0 4127260929 3212869760 0 0 0 0 4127260929 3208659008 3212869760 0 3208659008 4127260929 4127260929 4127260929 4127260929 4127260929 3208659008 3212869760 0 0 0 3212869760 3212869760 3212869760 3212869760 3212869760 3212869760 0 0)	offset: 0@0)]! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 14:44'!frameRect: rect borderWidth: borderWidth	sourceX := 0.	sourceY := 0.	(rect areasOutside: (rect insetBy: borderWidth)) do:		[:edgeStrip | self destRect: edgeStrip; copyBits].! !!EllipseMorph methodsFor: 'geometry testing' stamp: 'di 11/14/97 13:50'!containsPoint: aPoint	| radius other delta xOverY |	(bounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	(bounds width = 1 or: [bounds height = 1])		ifTrue: [^ true].  "Degenerate case -- code below fails by a bit"	radius := bounds height asFloat / 2.	other := bounds width asFloat / 2.	delta := aPoint - bounds topLeft - (other@radius).	xOverY := bounds width asFloat / bounds height asFloat.	^ (delta x asFloat / xOverY) squared + delta y squared <= radius squared! !!NewParagraph methodsFor: 'fonts-display' stamp: 'nk 3/20/2004 11:13'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| visibleRectangle offset leftInRun line |	visibleRectangle := aCanvas clipRect.	offset := (somePosition - positionWhenComposed) truncated.	leftInRun := 0.	(self lineIndexForPoint: visibleRectangle topLeft)		to: (self lineIndexForPoint: visibleRectangle bottomRight)		do: [:i | line := lines at: i.			self displaySelectionInLine: line on: aCanvas.			line first <= line last ifTrue:				[leftInRun := displayScanner displayLine: line								offset: offset leftInRun: leftInRun]].! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 2/9/1999 06:29'!ifNoTransformWithIn: box	"Return true if the current transformation does not affect the given bounding box"	| delta |	"false ifFalse:[^false]."	transform isNil ifTrue:[^true].	delta := (transform localPointToGlobal: box origin) - box origin.	^(transform localPointToGlobal: box corner) - box corner = delta! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:36'!openToEdits	"Enable this morph's ability to add and remove morphs via drag-n-drop."	open := true! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!wrapDirection: aSymbol	wrapDirection := aSymbol! !!Morph methodsFor: 'card in a stack' stamp: 'dgd 8/28/2004 19:15'!tabHitWithEvent: anEvent	"The tab key was hit.  The keyboard focus has referred this event to me, though this perhaps seems rather backwards.  Anyway, the assumption is that I have the property #tabAmongFields, so now the task is to tab to the next field."	| currentFocus fieldList anIndex itemToHighlight variableBearingMorphs otherAmenableMorphs |	currentFocus := anEvent hand keyboardFocus.	fieldList := self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	fieldList isEmpty ifTrue:[^ self].	variableBearingMorphs := self player isNil										ifTrue:[#()]										ifFalse:[self player class variableDocks collect: [:vd | vd definingMorph] thenSelect: [:m | m isInWorld]].	otherAmenableMorphs := (self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]])			copyWithoutAll: variableBearingMorphs.	fieldList := variableBearingMorphs, otherAmenableMorphs.	anIndex := fieldList indexOf: currentFocus ifAbsent: [nil].	itemToHighlight := fieldList atWrap: 		(anIndex ifNotNil: [anEvent shiftPressed ifTrue: [anIndex - 1] ifFalse: [anIndex + 1]]				ifNil: [1]).	anEvent hand newKeyboardFocus: itemToHighlight. self flag: #arNote. "really???"	itemToHighlight editor selectAll.	itemToHighlight invalidRect: itemToHighlight bounds ! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'jrp 7/28/2005 20:37'!initializeAllButLabel	super initialize.	self borderWidth: 1.	self color: (Color r: 0.4 g: 0.8 b: 0.6).	self borderColor: self color darker.	self borderStyle: BorderStyle thinGray.	target := nil.	actionSelector := #flash.	arguments := EmptyArray.	actWhen := #buttonUp! !!ScriptEditorMorph methodsFor: 'textually-coded scripts' stamp: 'tk 11/14/2000 13:54'!showingMethodPane: val	"Whether the receiver will show the textual method pane"	showingMethodPane := val! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'raa 2/8/2001 10:40'!ensureImageReady	self isTheRealProjectPresent ifFalse: [^self].	project thumbnail ifNil: [		image fill: image boundingBox rule: Form over 			fillColor: project defaultBackgroundColor.		^self	].	project thumbnail ~~ lastProjectThumbnail ifTrue: ["scale thumbnail to fit my bounds"		lastProjectThumbnail := project thumbnail.		self updateImageFrom: lastProjectThumbnail.		project thumbnail ifNotNil: [project thumbnail hibernate].		image borderWidth: 1	].! !!PluggableListMorphOfMany methodsFor: 'event handling' stamp: 'ar 3/17/2001 16:23'!mouseUp: event	dragOnOrOff := nil.  "So improperly started drags will have not effect"! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFileSelectorForSuffixes: aList directory: aDirectory	| window aFileList |	window := self morphicViewFileSelectorForSuffixes: aList directory: aDirectory.	aFileList := window valueOfProperty: #fileListModel.	window openCenteredInWorld.	self modalLoopOn: window.	^aFileList getSelectedFile! !!BorderedMorph methodsFor: 'menu' stamp: 'dgd 9/18/2004 19:16'!addBorderStyleMenuItems: aMenu hand: aHandMorph	"Add border-style menu items"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	"subMenu addTitle: 'border' translated."	subMenu addStayUpItemSpecial.	subMenu addList: 		{{'border color...' translated. #changeBorderColor:}.		{'border width...' translated. #changeBorderWidth:}}.	subMenu addLine.	BorderStyle borderStyleChoices do:		[:sym | (self borderStyleForSymbol: sym)			ifNotNil:				[subMenu add: sym translated target: self selector: #setBorderStyle: argument: sym]].	aMenu add: 'border style' translated subMenu: subMenu! !!TTSampleStringMorph methodsFor: 'parts bin' stamp: 'tk 12/10/2001 17:36'!initializeToStandAlone	"Make me into an example"	| dd |	dd := TTFontDescription default.	dd ifNil: [^ RectangleMorph initializeToStandAlone].	"not available"	super initializeToStandAlone.	self font: dd; color: (TranslucentColor r: 1.0 g: 0.097 b: 1.0 alpha: 0.6).	self string: 'TrueType fonts are beautiful'.! !!AlignmentMorph methodsFor: 'objects from disk' stamp: 'tk 11/26/2004 05:51'!convertToCurrentVersion: varDict refStream: smartRefStrm	| newish |	newish := super convertToCurrentVersion: varDict refStream:smartRefStrm.	"major change - much of AlignmentMorph is now implementedmore generally in Morph"	varDict at: 'hResizing' ifPresent: [ :x |		^ newish convertOldAlignmentsNov2000: varDict using:smartRefStrm].	^ newish! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:47'!listSpacing: aSymbol	listSpacing := aSymbol! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/28/2003 01:07'!displayWorldSafely: aWorld	"Update this world's display and keep track of errors during draw methods."	[aWorld displayWorld] ifError: [:err :rcvr |		"Handle a drawing error"		| errCtx errMorph |		errCtx := thisContext.		[			errCtx := errCtx sender.			"Search the sender chain to find the morph causing the problem"			[errCtx notNil and:[(errCtx receiver isMorph) not]] 				whileTrue:[errCtx := errCtx sender].			"If we're at the root of the context chain then we have a fatal drawing problem"			errCtx ifNil:[^self handleFatalDrawingError: err].			errMorph := errCtx receiver.			"If the morph causing the problem has already the #drawError flag set,			then search for the next morph above in the caller chain."			errMorph hasProperty: #errorOnDraw		] whileTrue.		errMorph setProperty: #errorOnDraw toValue: true.		"Install the old error handler, so we can re-raise the error"		rcvr error: err.	].! !!SystemWindow methodsFor: 'initialization' stamp: 'jrp 7/23/2005 21:34'!addPaneHSplitters	| remaining targetY sameY |	remaining := paneMorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty] whileTrue:		[targetY := remaining first layoutFrame bottomFraction.		sameY := paneMorphs select: [:each | each layoutFrame bottomFraction = targetY].		self addPaneHSplitterBetween: remaining first and: sameY.		remaining := remaining copyWithoutAll: sameY]! !!PluggableListMorph methodsFor: 'scroll cache' stamp: 'sps 4/3/2005 15:29'!deriveHScrollRange	|  unadjustedRange totalRange |	(list isNil or: [list isEmpty]) 		ifTrue:[hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0 ]		ifFalse:[ 			unadjustedRange := self listMorph hUnadjustedScrollRange.			totalRange := unadjustedRange + self hExtraScrollRange + self hMargin.			hScrollRangeCache := Array 										with: totalRange 										with: unadjustedRange 										with: list size 										with: list first 										with: list last .		].! !!PasteUpMorph methodsFor: 'private' stamp: 'nk 7/8/2003 09:18'!privateRemoveMorph: aMorph	backgroundMorph == aMorph ifTrue: [ backgroundMorph := nil ].	^super privateRemoveMorph: aMorph.! !!TextMorph methodsFor: 'editing' stamp: 'fbs 1/7/2005 15:42'!preferredKeyboardPosition	| default rects |	default  := (self bounds: self bounds in: World) topLeft.	paragraph ifNil: [^ default].	rects := paragraph selectionRects.	rects size = 0 ifTrue: [^ default].	^ rects first topLeft.	"^ (self bounds: self bounds in: World) topLeft."! !!StringMorph methodsFor: 'font' stamp: 'efc 2/22/2003 21:35'!emphasis: aNumber	"Set the receiver's emphasis as indicated. aNumber is a bitmask with the following format:	bit	attribute	1	bold	2	italic	4	underlined	8	narrow	16	struckOut"	"examples: 0 -> plain.  	1 -> bold.  2 -> italic.  3 -> bold italic.  4 -> underlined  	5 -> bold underlined.  6 -> italic underlined.   7 -> bold italic underlined   	etc..."	emphasis := aNumber.	^ self font: font emphasis: emphasis! !!NewParagraph methodsFor: 'private' stamp: 'edc 6/18/2004 09:10'!moveBy: delta	lines do: [:line | line moveBy: delta].	positionWhenComposed ifNotNil:[	positionWhenComposed := positionWhenComposed + delta].	container := container translateBy: delta! !!BalloonMorph class methodsFor: 'utility' stamp: 'sw 1/31/2000 15:40'!setBalloonFontTo: aFont	aFont ifNotNil: [BalloonFont := aFont]! !!DamageRecorder methodsFor: 'initialization' stamp: 'sma 6/5/2000 11:55'!reset	"Clear the damage list."	invalidRects := OrderedCollection new: 15.	totalRepaint := false! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'dgd 9/6/2003 18:04'!presentViewMenu	"Answer an auxiliary menu with options specific to viewing playfields -- this is put up from the provisional 'view' halo handle, on pasteup morphs only."	| aMenu isWorld |	isWorld := self isWorldMorph.	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	self addViewingItemsTo: aMenu.	#(	"(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')"		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(resizeToFitString		toggleResizeToFit			'whether I should automatically strive exactly to fit my contents')		(behaveLikeAHolderString	toggleBehaveLikeAHolder			'whether auto-line-layout, resize-to-fit, and indicate-cursor should be set to true; useful for animation control, etc.')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')		(fenceEnabledString	toggleFenceEnabled			'whether moving objects should stop at the edge of their container')		(autoViewingString		toggleAutomaticViewing			'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.')		(griddingString			griddingOnOff			'whether gridding should be used in my interior')		(gridVisibleString		gridVisibleOnOff			'whether the grid should be shown when gridding is on')	) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail toggleAutomaticViewing ) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third translated]]. 	aMenu addLine.	aMenu add: 'round up strays' translated action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.' translated.	aMenu add: 'shuffle contents' translated action: #shuffleSubmorphs.	aMenu balloonTextForLastItem: 'Rearranges my contents in random order' translated.	aMenu add: 'set grid spacing...' translated action: #setGridSpec.	aMenu balloonTextForLastItem: 'Set the spacing to be used when gridding is on' translated.	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' translated action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them' translated].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' translated action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.' translated].	aMenu addLine.	self addPenTrailsMenuItemsTo: aMenu.	aMenu addLine.	aMenu add: 'use standard texture' translated action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.' translated.	aMenu add: 'make graph paper...' translated action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.' translated.	aMenu addTitle: ('viewing options for "{1}"' translated format: {self externalName}).	aMenu popUpForHand: self activeHand in: self world! !!PasteUpMorph class methodsFor: 'project' stamp: 'RAA 5/26/2000 10:07'!newWorldTesting	| world ex |	ex := 500@500.	world := PasteUpMorph newWorldForProject: nil.	world extent: ex; color: Color orange.	world openInWorld.	world viewBox: (0@0 extent: ex).	BouncingAtomsMorph new openInWorld: world."-----	| world window |	world := PasteUpMorph newWorldForProject: nil.	world extent: 300@300; color: Color orange.	world viewBox: (0@0 extent: 300@300).	window := (SystemWindow labelled: 'the new world') model: world.	window color: Color orange.	window addMorph: world frame: (0@0 extent: 1.0@1.0).	window openInWorld.---"! !!PolygonMorph methodsFor: 'editing' stamp: 'ar 3/17/2001 14:30'!dragVertex: ix event: evt fromHandle: handle	| p |	p := self isCurve		ifTrue: [evt cursorPoint]		ifFalse: [self griddedPoint: evt cursorPoint].	handle position: p - (handle extent//2).	self verticesAt: ix put: p.! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'jcg 9/21/2001 13:23'!mouseDown: evt	| aMorph selectors |	aMorph := self itemFromPoint: evt position.	(aMorph notNil and:[aMorph inToggleArea: (aMorph point: evt position from: self)])		ifTrue:[^self toggleExpandedState: aMorph event: evt]. 	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	aMorph ifNil:[^super mouseDown: evt].	aMorph highlightForMouseDown.	selectors := Array 		with: #click:		with: nil		with: nil		with: (self dragEnabled ifTrue:[#startDrag:] ifFalse:[nil]).	evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10 "pixels".! !!NewHandleMorph methodsFor: 'all' stamp: 'ar 8/16/2001 15:48'!followHand: aHand forEachPointDo: block1 lastPointDo: block2 withCursor: aCursor	hand := aHand.	hand showTemporaryCursor: aCursor "hotSpotOffset: aCursor offset negated".	borderWidth := 0.	color := Color transparent.	pointBlock := block1.	lastPointBlock := block2.	self position: hand lastEvent cursorPoint - (self extent // 2)! !!PluggableListMorph methodsFor: 'initialization' stamp: 'ls 2/5/2004 16:29'!list: listOfStrings  	"lex doesn't think this is used any longer, but is not yet brave enough to remove it.  It should be removed eventually"			"Set the receiver's list as specified"	| morphList h loc index converter item aSelector textColor font |	scroller removeAllMorphs.	list := listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [self setScrollDeltas.  ^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	font ifNil: [font := Preferences standardListFont].	converter := self valueOfProperty: #itemConversionMethod.	converter ifNil: [converter := #asStringOrText].	textColor := self valueOfProperty: #textColor.	morphList := list collect: [:each | | stringMorph |		item := each.		item := item perform: converter.		stringMorph := item isText			ifTrue: [StringMorph contents: item font: font emphasis: (item emphasisAt: 1)]			ifFalse: [StringMorph contents: item font: font].		textColor ifNotNil: [ stringMorph color: textColor ].		stringMorph	].		(aSelector := self valueOfProperty: #balloonTextSelectorForSubMorphs)		ifNotNil:			[morphList do: [:m | m balloonTextSelector: aSelector]].	self highlightSelector ifNotNil:		[model perform: self highlightSelector with: list with: morphList].	"Lay items out vertically and install them in the scroller"	h := morphList first height "self listItemHeight".	loc := 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc := loc + (0@h)].	scroller addAllMorphs: morphList.	index := self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > morphList size]) ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:20'!changeTableLayout	| layout |	((layout := self layoutPolicy) notNil and:[layout isTableLayout])		ifTrue:[^self]. "already table layout"	self layoutPolicy: TableLayout new.	self layoutChanged.! !!HandMorph methodsFor: 'halo handling' stamp: 'ar 10/24/2000 18:40'!obtainHalo: aHalo	"Used for transfering halos between hands"	| formerOwner |	self halo == aHalo ifTrue:[^self].	"Find former owner"	formerOwner := self world hands detect:[:h| h halo == aHalo] ifNone:[nil].	formerOwner ifNotNil:[formerOwner releaseHalo: aHalo].	self halo: aHalo! !!Morph methodsFor: 'geometry' stamp: 'laza 3/25/2004 21:31'!extent: aPoint	bounds extent = aPoint ifTrue: [^ self].	self changed.	bounds := (bounds topLeft extent: aPoint) rounded.	self layoutChanged.	self changed.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 4/30/1998 13:46'!revertScriptVersion	| aUserScript |	aUserScript := playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript revertScriptVersionFrom: self! !!Morph methodsFor: 'copying' stamp: 'md 2/27/2006 08:53'!updateReferencesUsing: aDictionary 	"Update intra-morph references within a composite morph that 	has been copied. For example, if a button refers to morph X in 	the orginal 	composite then the copy of that button in the new composite 	should refer to 	the copy of X in new composite, not the original X. This default 	implementation updates the contents of any morph-bearing slot. 	It may be 	overridden to avoid this behavior if so desired."	| old |	Morph instSize + 1		to: self class instSize		do: [:i | 			old := self instVarAt: i.			old isMorph				ifTrue: [self						instVarAt: i						put: (aDictionary								at: old								ifAbsent: [old])]].	extension ifNotNil: [extension updateReferencesUsing: aDictionary]! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:33'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation just adds the given morph to the receiver."	| layout |	layout := self layoutPolicy.	layout ifNil:[^self addMorph: aMorph].	self privateAddMorph: aMorph 		atIndex: (layout indexForInserting: aMorph at: evt position in: self).! !!TextMorphForEditView methodsFor: 'accept/cancel' stamp: 'di 9/11/1998 15:42'!acceptOnCR: trueOrFalse	acceptOnCR := trueOrFalse! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'RAA 6/21/1999 10:49'!setItem: anObject name: aString model: aModel	item := anObject.	model := aModel.	itemName := aString.! !!FormCanvas methodsFor: 'other' stamp: 'ar 5/28/2000 12:09'!showAt: pt invalidRects: updateRects	| blt |	blt := (BitBlt current toForm: Display)		sourceForm: form;		combinationRule: Form over.	updateRects do:		[:rect |		blt sourceRect: rect;			destOrigin: rect topLeft + pt;			copyBits]! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint: aPoint	scalePoint := aPoint.	self layoutChanged.! !!SimpleButtonDelayedMenuMorph methodsFor: 'event handling' stamp: 'nk 1/11/2004 12:35'!mouseDown: evt	didMenu := nil.	super mouseDown: evt.! !!TranslucentProgessMorph methodsFor: 'drawing' stamp: 'nk 7/12/2003 08:59'!drawOn: aCanvas	| revealPercentage revealingStyle revealingColor revealingBounds revealToggle x baseColor revealTimes secondsRemaining stringToDraw where fontToUse innerBounds |		innerBounds := bounds.	opaqueBackgroundColor ifNotNil: [		aCanvas 			frameAndFillRectangle: bounds			fillColor: opaqueBackgroundColor			borderWidth: 8			borderColor: Color blue.		innerBounds := innerBounds insetBy: 8.	].	revealTimes := (self valueOfProperty: #revealTimes) ifNil: [^self].	revealPercentage := (revealTimes first / revealTimes second) asFloat.	revealingStyle := self revealingStyle.	x := self valueOfProperty: #progressStageNumber ifAbsent: [1].	baseColor := Color perform: (#(red blue green magenta cyan yellow) atPin: x).	revealingColor := baseColor alpha: 0.2.	revealingStyle = 3 ifTrue: [	"wrap and change color"		revealPercentage > 1.0 ifTrue: [			revealingColor := baseColor alpha: (0.2 + (revealingStyle / 10) min: 0.5).		].		revealPercentage := revealPercentage fractionPart.	].	revealingStyle = 2 ifTrue: [	"peg at 75 and blink"		revealPercentage > 0.75 ifTrue: [			revealToggle := self valueOfProperty: #revealToggle ifAbsent: [true].			self setProperty: #revealToggle toValue: revealToggle not.			revealToggle ifTrue: [revealingColor := baseColor alpha: 0.8.].		].		revealPercentage := revealPercentage min: 0.75.	].	revealingBounds := innerBounds withLeft: innerBounds left + (innerBounds width * revealPercentage) truncated.	aCanvas 		fillRectangle: revealingBounds		color: revealingColor.	secondsRemaining := (revealTimes second - revealTimes first / 1000) rounded.	secondsRemaining > 0 ifTrue: [		fontToUse := StrikeFont familyName: Preferences standardEToysFont familyName size: 24.		stringToDraw := secondsRemaining printString.		where := innerBounds corner - ((fontToUse widthOfString: stringToDraw) @ fontToUse height).		aCanvas 			drawString: stringToDraw 			in: (where corner: innerBounds corner)			font: fontToUse			color: Color black.		aCanvas			drawString: stringToDraw 			in: (where - (1@1) corner: innerBounds corner)			font: fontToUse			color: Color white.	]. ! !!SketchMorph methodsFor: 'drawing' stamp: 'ar 7/28/2005 16:51'!drawInterpolatedImage: aForm on: aCanvas	"Draw the given form onto the canvas using the Balloon 3D engine"	| engine |	engine := Smalltalk at: #B3DRenderEngine 		ifPresent:[:b3d | b3d defaultForPlatformOn: aCanvas form].	engine == nil ifTrue:[		self useInterpolation: false.		^self generateRotatedForm].	"Setup the engine"	engine viewport: aCanvas form boundingBox.	"Install the material to be used (using a plain white emission color)"	engine material: ((Smalltalk at: #B3DMaterial) new emission: Color white).	"Install the texture"	engine texture: aForm.	"Draw the mesh"	engine render: ((Smalltalk at: #B3DIndexedQuadMesh) new plainTextureRect).	"and finish"	engine finish.! !!ScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector := aSelector! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!target: anObject	target := anObject.! !!SystemWindowWithButton methodsFor: 'label' stamp: 'sw 9/29/1999 07:27'!setLabelWidgetAllowance	^ labelWidgetAllowance := 115! !!Morph methodsFor: 'geometry' stamp: 'sw 6/4/2000 21:59'!minimumExtent	| ext |	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least.  copied up from SystemWindow 6/00"	(ext := self valueOfProperty: #minimumExtent)		ifNotNil:			[^ ext].	^ 100 @ 80! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 12/18/2000 01:16'!assureNotPaintingEvent: evt	"If painting is already underway	in the receiver, put up an informer to that effect and evalute aBlock"	| editor |	(editor := self sketchEditorOrNil) ifNotNil:[		editor save: evt.		Cursor normal show.	].! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'ar 7/8/2001 17:05'!forkProgressWatcher	| killTarget |	[		[stageCompleted < 999 and: 				[formerProject == Project current and: 				[formerWorld == World and: 				[translucentMorph world notNil and:				[formerProcess suspendedContext notNil and: 				[Project uiProcess == formerProcess]]]]]] whileTrue: [			translucentMorph setProperty: #revealTimes toValue: 					{(Time millisecondClockValue - start max: 1). (estimate * newRatio max: 1)}.			translucentMorph changed.			translucentMorph owner addMorphInLayer: translucentMorph.			(Time millisecondClockValue - WorldState lastCycleTime) abs > 500 ifTrue: [				self backgroundWorldDisplay			].			(Delay forMilliseconds: 100) wait.		].		translucentMorph removeProperty: #revealTimes.		self loadingHistoryAt: 'total' add: (Time millisecondClockValue - start max: 1).		killTarget := targetMorph ifNotNil: [			targetMorph valueOfProperty: #deleteOnProgressCompletion		].		formerWorld == World ifTrue: [			translucentMorph delete.			killTarget ifNotNil: [killTarget delete].		] ifFalse: [			translucentMorph privateDeleteWithAbsolutelyNoSideEffects.			killTarget ifNotNil: [killTarget privateDeleteWithAbsolutelyNoSideEffects].		].	] forkAt: Processor lowIOPriority.! !!Morph methodsFor: 'printing' stamp: ''!printConstructorOn: aStream indent: level nodeDict: nodeDict	| nodeString |	(nodeString := nodeDict at: self ifAbsent: [nil])		ifNotNil: [^ aStream nextPutAll: nodeString].	submorphs isEmpty ifFalse: [aStream nextPutAll: '('].	aStream nextPutAll: '('.	self fullPrintOn: aStream.	aStream nextPutAll: ')'.	submorphs isEmpty ifTrue: [^ self].	submorphs size <= 4	ifTrue:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: (Array'.		1 to: submorphs size do:			[:i | aStream crtab: level+1; nextPutAll: 'with: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict].		aStream nextPutAll: '))']	ifFalse:		[aStream crtab: level+1;			nextPutAll: 'addAllMorphs: ((Array new: ', submorphs size printString, ')'.		1 to: submorphs size do:			[:i |			aStream crtab: level+1; nextPutAll: 'at: ', i printString, ' put: '.			(submorphs at: i) printConstructorOn: aStream indent: level+1 nodeDict: nodeDict.			aStream nextPutAll: ';'].		aStream crtab: level+1; nextPutAll: 'yourself))']! !!StandardFileMenuResult methodsFor: 'private' stamp: 'acg 4/15/1999 08:42'!directory: aDirectory name: aString	directory := aDirectory.	name := aString.	^self! !!ScriptEditorMorph methodsFor: 'other' stamp: 'di 2/19/2001 10:12'!recreateScript	| aUserScript |	aUserScript := playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript recreateScriptFrom: self! !!FormCanvas methodsFor: 'private' stamp: 'ar 6/22/1999 14:06'!setOrigin: aPoint clipRect: aRectangle	origin := aPoint.	clipRect := aRectangle.	port clipRect: aRectangle.! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'sw 6/11/1999 18:40'!labelString: aString	| existingLabel |	(existingLabel := self findA: StringMorph)		ifNil:			[self label: aString]		ifNotNil:			[existingLabel contents: aString.			self fitContents]! !!Morph methodsFor: 'accessing' stamp: 'sw 3/6/1999 02:09'!regularColor		| val |	^ (val := self valueOfProperty: #regularColor)		ifNotNil:			[val ifNil: [self error: 'nil regularColor']]		ifNil:			[owner ifNil: [self color] ifNotNil: [owner regularColor]]! !!ComplexBorder methodsFor: 'private' stamp: 'ar 9/4/2001 19:51'!fillStyleForDirection: direction	"Fill the given form describing the receiver's look at a particular direction"	| index fill dir |	index := direction degrees truncated // 10 + 1.	lineStyles ifNotNil:[		fill := lineStyles at: index.		fill ifNotNil:[^fill].	].	dir := Point r: 1.0 degrees: index - 1 * 10 + 5.	fill := GradientFillStyle colors: (self colorsForDirection: dir).	fill direction: 0 @ width asPoint y; radial: false.	fill origin: ((width asPoint x // 2) @ (width asPoint y // 2)) negated.	fill pixelRamp: (fill computePixelRampOfSize: 16).	fill isTranslucent. "precompute"	lineStyles ifNil:[lineStyles := Array new: 37].	lineStyles at: index put: fill.	^fill! !!PluggableFileList methodsFor: 'file list menu' stamp: 'asm 8/25/2003 18:37'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 services |	firstItems := self itemsForFile: self fullName asLowercase.	secondItems := self itemsForAnyFile.	thirdItems := self itemsForNoFile.	n1 := firstItems size.	n2 := n1 + secondItems size.	n3 := n2 + thirdItems size.	services := firstItems, secondItems, thirdItems, 			(OrderedCollection with: (SimpleServiceEntry provider: self label: 'more...' selector: #offerAllFileOptions)).	^ aMenu 		addServices2: services 		for: self		extraLines: (Array with: n1 with: n2 with: n3)! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeForwardArrow	arrows := #forward.	self computeBounds! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 4/1/98 16:38'!clearTurtleTrails	turtleTrailsForm := nil.	turtlePen := nil.	self changed.! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:24'!getFile	| result |	result := self getFilePathName.	^result ifNotNil: [FileStream oldFileNamed: result]! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 07:33'!fileFilterBlock: aBlock	^fileFilterBlock := aBlock! !!TextMorph class methodsFor: 'scripting' stamp: 'yo 7/2/2004 21:27'!authoringPrototype	| t |	t := super authoringPrototype.	t contents: 'abc' translated asText.	t wrapFlag: true. "Strangeness here in order to avoid two offset copies of the default contents when operating in an mvc project before cursor enters the morphic window"	t paragraph.	^ t! !!SystemWindow methodsFor: 'initialization' stamp: 'bvs 3/16/2004 13:20'!gradientWithColor: aColor	| ramp |	ramp := {0.0 -> Color white. 1.0 -> aColor}.	^ (GradientFillStyle ramp: ramp)		radial: true;		origin: self bounds origin;		direction: 0 @ 223;		normal: 223 @ 0.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/16/2000 22:26'!frameOval: rect borderWidth: borderWidth	| centerX centerY nextY yBias xBias wp outer inner nextOuterX nextInnerX fillAlpha |	rect area <= 0 ifTrue: [^ self].	height := 1.	wp := borderWidth asPoint.	yBias := rect height odd ifTrue: [0] ifFalse: [-1].	xBias := rect width odd ifTrue: [1] ifFalse: [0].	centerX := rect center x.	centerY := rect center y.	outer := EllipseMidpointTracer new on: rect.	inner := EllipseMidpointTracer new on: (rect insetBy: wp).	nextY := rect height // 2.	1 to: (wp y min: nextY) do:[:i|		nextOuterX := outer stepInY.		width := (nextOuterX bitShift: 1) + xBias.		destX := centerX - nextOuterX.		destY := centerY - nextY.		self copyBits.		destY := centerY + nextY + yBias.		self copyBits.		nextY := nextY - 1.	].	[nextY > 0] whileTrue:[		nextOuterX := outer stepInY.		nextInnerX := inner stepInY.		destX := centerX - nextOuterX.		destY := centerY - nextY.		width := nextOuterX - nextInnerX.		self copyBits.		destX := centerX + nextInnerX + xBias.		self copyBits.		destX := centerX - nextOuterX.		destY := centerY + nextY + yBias.		self copyBits.		destX := centerX + nextInnerX + xBias.		self copyBits.		nextY := nextY - 1.	].	destY := centerY.	height := 1 + yBias.	width := wp x.	destX := rect left.	self copyBits.	destX := rect right - wp x.	self copyBits.! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/27/2002 01:30'!hResizeScrollBar	| topLeft h border |"TEMPORARY: IF OLD SCROLLPANES LYING AROUND THAT DON'T HAVE A hScrollBar, INIT THEM"	hScrollBar ifNil: [ self hInitScrollBarTEMPORARY].		(self valueOfProperty: #noHScrollBarPlease ifAbsent: [false]) ifTrue: [^self].	bounds ifNil: [ self fullBounds ].		h := self scrollBarThickness.	border := borderWidth.		topLeft := retractableScrollBar				ifTrue: [bounds bottomLeft + (border @ border negated)]				ifFalse: [bounds bottomLeft + (border @ (h + border) negated)].	hScrollBar bounds: (topLeft extent: self hScrollBarWidth@ h)! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 3/21/2006 23:03'!splitterLeft	| splitters |	splitters := ((self siblingSplitters select: [:each | each x < self x]) asSortedCollection: [:a :b | a x > b x]).		^ splitters ifEmpty: nil ifNotEmpty: [splitters first]! !!PasteUpMorph methodsFor: 'name' stamp: 'sw 6/17/2004 01:46'!unusedMorphNameLike: stem	"Answer a suitable name for a morph in this world, based on the stem provided"	| names |	names := self allKnownNames.	^ Utilities keyLike: stem asString satisfying:		[:aName | (names includes: aName) not]! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'ar 3/17/2001 17:25'!itemFromPoint: aPoint	"Return the list element (morph) at the given point or nil if outside"	| ptY |	scroller hasSubmorphs ifFalse:[^nil].	(scroller fullBounds containsPoint: aPoint) ifFalse:[^nil].	ptY := (scroller firstSubmorph point: aPoint from: self) y.	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"	scroller firstSubmorph top > ptY ifTrue:[^nil].	scroller lastSubmorph bottom < ptY ifTrue:[^nil].	"now use binary search"	^scroller 		findSubmorphBinary:[:item|			(item top <= ptY and:[item bottom >= ptY])				ifTrue:[0] "found"				ifFalse:[ (item top + item bottom // 2) > ptY ifTrue:[-1] ifFalse:[1]]]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 3/13/2003 12:19'!dispatchCommandKeyInWorld: aChar event: evt	"Dispatch the desktop command key if possible.  Answer whether handled"	| aMessageSend |	aMessageSend := self commandKeySelectors at: aChar ifAbsent: [^ false].	aMessageSend selector numArgs = 0		ifTrue:			[aMessageSend value]		ifFalse:			[aMessageSend valueWithArguments: (Array with: evt)].	^ true! !!TransformMorph methodsFor: 'accessing' stamp: ''!smoothingOn	smoothing := 2.	self changed! !!ScrollPane methodsFor: 'event handling' stamp: 'ar 9/18/2000 22:11'!handlesMouseOver: evt	"Could just ^ true, but this ensures that scroll bars won't flop out	if you mouse-over appendages such as connecting pins."	self flag: #arNote. "I have no idea how the code below could've ever worked. If the receiver does not handle mouse over events then it should not receive any #mouseLeave if the mouse leaves the receiver for real. This is because 'evt cursorPoint' describes the *end* point of the movement and considering that the code would return false if the move ends outside the receiver the scroll bars should never pop back in again. Which is exactly what happens with the new event logic if you don't just ^true. I'm leaving the code in for reference - perhaps somebody can make sense from it; I sure cannot."	^true"	| cp |	cp := evt cursorPoint.	(bounds containsPoint: cp)		ifTrue: [^ true]					ifFalse: [self submorphsDo:					[:m | (m containsPoint: cp) ifTrue:							[m == scrollBar								ifTrue: [^ true]								ifFalse: [^ false]]].				^ false]"! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'tk 7/1/97 08:39'!arguments: aCollection	arguments := aCollection asArray copy.! !!ScrollBar methodsFor: 'initialize' stamp: 'jrp 8/3/2005 09:57'!initializeUpButton"initialize the receiver's upButton"	upButton := self roundedScrollbarLook		ifTrue: [RectangleMorph						newBounds: (self innerBounds topLeft extent: self buttonExtent)]		ifFalse: [RectangleMorph						newBounds: ((menuButton								ifNil: [self innerBounds topLeft]								ifNotNil: [bounds isWide										ifTrue: [menuButton bounds topRight]										ifFalse: [menuButton bounds bottomLeft]])								extent: self buttonExtent)].	upButton color: self thumbColor.	upButton		on: #mouseDown		send: #scrollUpInit		to: self.	upButton		on: #mouseUp		send: #finishedScrolling		to: self.	self updateUpButtonImage.	self roundedScrollbarLook		ifTrue: [upButton color: Color veryLightGray.			upButton				borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [upButton setBorderWidth: 1 borderColor: Color lightGray].	self addMorph: upButton! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 12/14/2001 17:42'!trackDropZones	"The fundamental heart of script-editor layout, by Dan Ingalls in fall 1997, though many hands have touched it since."	| hand insertion i space1 d space2 insHt nxtHt prevBot ht2 c1 c2 ii where |	hand := handWithTile ifNil: [self primaryHand].	((self hasOwner: hand) not and: [hand submorphCount > 0])		ifTrue:			[insertion := hand firstSubmorph renderedMorph.			insHt := insertion fullBounds height.			self removeSpaces.			where := self globalPointToLocal: hand position"insertion fullBounds topLeft".			i := (ii := self indexOfMorphAbove: where) min: submorphs size-1.			prevBot := i <= 0 ifTrue: [(self innerBounds) top]							ifFalse: [(self submorphs at: i) bottom].			nxtHt := (submorphs isEmpty				ifTrue: [insertion]				ifFalse: [self submorphs at: i+1]) height.			d := ii > i ifTrue: [nxtHt "for consistent behavior at bottom"]					ifFalse: [0 max: (where y - prevBot min: nxtHt)].			"Top and bottom spacer heights cause continuous motion..."			c1 := Color green.  c2 := Color transparent.			ht2 := d*insHt//nxtHt.			space1 := Morph newBounds: (0@0 extent: 30@(insHt-ht2))                                        color: ((insHt-ht2) > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space1 atIndex: (i+1 max: 1).			space2 := Morph newBounds: (0@0 extent: 30@ht2)                                        color: (ht2 > (insHt//2+1) ifTrue: [c1] ifFalse: [c2]).			self privateAddMorph: space2 atIndex: (i+3 min: submorphs size+1)]		ifFalse:			[self stopSteppingSelector: #trackDropZones.			self removeSpaces]! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/2/2000 08:37'!calculateColumnOffsetsFrom: maxWidths	| offsets previous current |	offsets := Array new: maxWidths size.	1		to: offsets size		do: [:indx | offsets at: indx put: (maxWidths at: indx)					+ 10].	2		to: offsets size		do: [:indx | 			previous := offsets at: indx - 1.			current := offsets at: indx.			current := previous + current.			offsets at: indx put: current].	^offsets! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:49'!cellPositioning: aSymbol	cellPositioning := aSymbol! !!Morph methodsFor: 'WiW support' stamp: 'RAA 2/16/2001 13:57'!addMorphInFrontOfLayer: aMorph	| targetLayer layerHere |	targetLayer := aMorph morphicLayerNumberWithin: self.	submorphs do: [ :each |		each == aMorph ifTrue: [^self].		layerHere := each morphicLayerNumberWithin: self.		"the <= is the difference - it insures we go to the front of our layer"		targetLayer <= layerHere ifTrue: [			^self addMorph: aMorph inFrontOf: each		].	].	self addMorphBack: aMorph.! !!Morph methodsFor: 'layout' stamp: 'ar 1/27/2001 14:41'!layoutChanged	| layout |	fullBounds ifNil:[^self]. "layout will be recomputed so don't bother"	fullBounds := nil.	layout := self layoutPolicy.	layout ifNotNil:[layout flushLayoutCache].	owner ifNotNil: [owner layoutChanged].	"note: does not send #ownerChanged here - we'll do this when computing the new layout"! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jrp 7/27/2005 22:44'!collapseOrExpand	"Collapse or expand the window, depending on existing state"	| cf |	isCollapsed		ifTrue: 			["Expand -- restore panes to morphics structure"			isCollapsed := false.			self activate.  "Bring to frint first"			Preferences collapseWindowsInPlace				ifTrue: 					[fullFrame := fullFrame align: fullFrame topLeft with: self getBoundsWithFlex topLeft]				ifFalse:					[collapsedFrame := self getBoundsWithFlex].			collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse this window'].			self setBoundsWithFlex: fullFrame.			paneMorphs reverseDo: 					[:m |  self addMorph: m unlock.					self world startSteppingSubmorphsOf: m].			self addPaneSplitters]		ifFalse: 			["Collapse -- remove panes from morphics structure"			isCollapsed := true.			fullFrame := self getBoundsWithFlex.			"First save latest fullFrame"			paneMorphs do: [:m | m delete; releaseCachedState].			self removePaneSplitters.			self removeCornerGrips.			model modelSleep.			cf := self getCollapsedFrame.			(collapsedFrame isNil and: [Preferences collapseWindowsInPlace not]) ifTrue:				[collapsedFrame := cf].			self setBoundsWithFlex: cf.			collapseBox ifNotNil: [collapseBox setBalloonText: 'expand this window'].			expandBox ifNotNil: [expandBox setBalloonText: 'expand to full screen']].	self layoutChanged! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 16:03'!loadFromURL: urlString	"Fetch the file, unarchive, unzip, and use as my font."	| rawStrm |	rawStrm := HTTPSocket httpGet: urlString. 	"Later use an HttpURL?"	self font: (TTFontReader readFrom: rawStrm asUnZippedStream).! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'jcg 11/5/2000 22:25'!correctSelectionWithString: aString	| result newPosition |	"I can't tell if this is a hack or if it's the right thing to do."	self setSelection: selectionInterval. 	result := self correctFrom: selectionInterval first to: selectionInterval last with: aString.	newPosition := selectionInterval first + aString size.	self setSelection: (newPosition to: newPosition - 1).	^ result! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:10'!color: aColor	color = aColor ifTrue:[^self].	color := aColor.	self releaseCachedState.! !!Morph methodsFor: 'private' stamp: 'jm 5/29/1998 21:28'!privateColor: aColor	color := aColor.! !!StringMorphAttributeScanner methodsFor: 'string morph' stamp: 'nk 2/26/2004 13:09'!initializeFromStringMorph: aStringMorph	| style |	actualFont := aStringMorph font ifNil: [ TextStyle defaultFont ].	style := actualFont textStyle.	emphasis := actualFont emphasis.	fontNumber := (style fontIndexOf: actualFont) ifNil: [ 1 ].	textColor := aStringMorph color.! !!PluggableListMorph methodsFor: 'scroll cache' stamp: 'sps 4/3/2005 15:29'!resetHScrollRange	hScrollRangeCache := nil.	self deriveHScrollRange.! !!MorphExtension methodsFor: 'initialization' stamp: 'di 8/16/1998 12:02'!initialize	"Init all booleans to default values"	locked := false.	visible := true.	sticky := false.	isPartsDonor := false.! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 9/25/2000 15:38'!indicateColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	self pickColorAt: (pt := Sensor cursorPoint).	isModal ifTrue:		[self activeHand position: pt.		self world displayWorldSafely; runStepMethods].	^ selectedColor	! !!Morph methodsFor: 'geometry eToy' stamp: 'nk 7/7/2003 17:18'!color: sensitiveColor sees: soughtColor 	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor."	"Make a mask with black where sensitiveColor is, white elsewhere"	| myImage sensitivePixelMask map patchBelowMe tfm morphAsFlexed i1 pasteUp |	pasteUp := self world ifNil: [ ^false ].	tfm := self transformFrom: pasteUp.	morphAsFlexed := tfm isIdentity 				ifTrue: [self]				ifFalse: [TransformationMorph new flexing: self clone byTransformation: tfm].	myImage := morphAsFlexed imageForm offset: 0 @ 0.	sensitivePixelMask := Form extent: myImage extent depth: 1.	"ensure at most a 16-bit map"	map := Bitmap new: (1 bitShift: (myImage depth - 1 min: 15)).	map at: (i1 := sensitiveColor indexInMap: map) put: 1.	sensitivePixelMask 		copyBits: sensitivePixelMask boundingBox		from: myImage form		at: 0 @ 0		colorMap: map.	"get an image of the world below me"	patchBelowMe := pasteUp 				patchAt: morphAsFlexed fullBounds				without: self				andNothingAbove: false.	"sensitivePixelMask displayAt: 0@0.patchBelowMe displayAt: 100@0."	"intersect world pixels of the color we're looking for with the sensitive pixels"	map at: i1 put: 0.	"clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelMask 		copyBits: patchBelowMe boundingBox		from: patchBelowMe		at: 0 @ 0		clippingBox: patchBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	"sensitivePixelMask displayAt: 200@0."	^(sensitivePixelMask tallyPixelValues second) > 0! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'RAA 6/12/2000 09:02'!yellowButtonActivity: shiftKeyState	| menu |	(menu := self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu popUpEvent: self activeHand lastEvent in: self world]! !!PasteUpMorph methodsFor: 'gridding' stamp: 'kfr 9/4/2004 15:44'!setGridSpec	"Gridding rectangle provides origin and modulus"	| response result |	response := FillInTheBlank			request: 'New grid origin (usually 0@0):' translated			initialAnswer: self gridOrigin printString.	response isEmpty ifTrue: [^ self].	result := [Compiler evaluate: response] ifError: [^ self].	(result isPoint and: [(result >= (0@0))])		ifTrue: [self gridOrigin: result]		ifFalse: [self inform: ('Must be a Point with coordinates (for example 10@10)' translated )].	response := FillInTheBlank			request: 'New grid spacing:' translated			initialAnswer: self gridModulus printString.	response isEmpty ifTrue: [^ self].	result := [Compiler evaluate: response] ifError: [^ self].	(result isPoint and: [(result > (0@0)) ])		ifTrue: [self gridModulus: result]		ifFalse: [self inform: ('Must be a Point with coordinates (for example 10@10)' translated )].! !!SystemWindow methodsFor: 'label' stamp: 'jrp 8/6/2005 23:49'!labelHeight	"Answer the height for the window label.  The standard behavior is at bottom; a hook is provided so that models can stipulate other heights, in support of various less-window-looking demos."	| aHeight |	(model notNil and: [model respondsTo: #desiredWindowLabelHeightIn:]) ifTrue:		[(aHeight := model desiredWindowLabelHeightIn: self) ifNotNil: [^ aHeight]].	^ label ifNil: [0] ifNotNil:		 [(label height + (self class borderWidth * 2)) max:			(collapseBox ifNotNil: [collapseBox height] ifNil: [10])]! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 8/31/2000 11:18'!setIndexInOwner: anInteger	"Answer which position the receiver holds in its owner's hierarchy"	"There is some concern about submorphs that aren't really to be counted, such as a background morph of a playfield."	| container topRenderer indexToUse |	container := (topRenderer := self topRendererOrSelf) owner.	indexToUse := (anInteger min: container submorphCount) max: 1.	container addMorph: topRenderer asElementNumber: indexToUse! !!SelectionMorph methodsFor: 'halos and balloon help' stamp: 'di 8/31/2000 22:29'!addHandlesTo: aHaloMorph box: box	| onlyThese |	aHaloMorph haloBox: box.	onlyThese := #(addDismissHandle: addMenuHandle: addGrabHandle: addDragHandle: addDupHandle: addHelpHandle: addGrowHandle: addFontSizeHandle: addFontStyleHandle: addFontEmphHandle: addRecolorHandle:).	Preferences haloSpecifications do:		[:aSpec | (onlyThese includes: aSpec addHandleSelector) ifTrue:				[aHaloMorph perform: aSpec addHandleSelector with: aSpec]].	aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: box! !!Morph methodsFor: 'menus' stamp: 'dgd 10/17/2003 22:51'!adhereToEdge	| menu |	menu := MenuMorph new defaultTarget: self.	#(top right bottom left - center - topLeft topRight bottomRight bottomLeft - none)		do: [:each |			each == #-				ifTrue: [menu addLine]				ifFalse: [menu add: each asString translated selector: #setToAdhereToEdge: argument: each]].	menu popUpEvent: self currentEvent in: self world! !!MatrixTransformMorph methodsFor: 'geometry eToy' stamp: 'ar 6/12/2001 05:11'!rotationCenter	| pt |	pt := self transform localPointToGlobal: super rotationCenter.	^pt - bounds origin / bounds extent asFloatPoint! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!leftOffset: anInteger	leftOffset := anInteger! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 9/27/2005 20:13'!changesMenu        "Build the changes menu for the world."        | menu |        menu := self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { ChangeSet current . #verboseFileOut}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSet . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { self  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.                { 'find recent submissions (R)' . { #myWorld . #openRecentSubmissionsBrowser:}.                                'Make an open recent-submissions browser be the front-window, expanding a collapsed one or creating a new one if necessary.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted, latest first.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions at the top of the browser.'}.			nil.                { 'recently logged changes...' . { self . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        self projectForMyWorld isIsolated ifTrue: [                self fillIn: menu from: {                         { 'propagate changes upward' . {self. #propagateChanges}.                                'The changes made in this isolated project will propagate to projects up to the next isolation layer.'}.                }.        ] ifFalse: [                self fillIn: menu from: {                         { 'isolate changes of this project' . {self. #beIsolated}.                                'Isolate this project and its subprojects from the rest of the system.  Changes to methods here will be revoked when you leave this project.'}.                }.        ].        ^ menu! !!WorldState methodsFor: 'update cycle' stamp: 'ar 4/25/2001 17:01'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	canvas roundCornersOf: aWorld during:[		worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage := worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 11/8/2000 22:37'!toggleIndicateCursor	indicateCursor := self indicateCursor not.	self changed.! !!TextAnchor methodsFor: 'accessing' stamp: 'di 11/10/97 10:47'!anchoredMorph: aMorph 	anchoredMorph := aMorph! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/29/2001 17:11'!makeSiblings: count	"Make multiple sibling, and return the list"	| aPosition anInstance listOfNewborns |	aPosition := self position.	listOfNewborns := (1 to: count asInteger) asArray collect: 		[:anIndex |			anInstance := self usableSiblingInstance.			owner addMorphFront: anInstance.			aPosition := aPosition + (10@10).			anInstance position: aPosition.			anInstance].	self currentWorld startSteppingSubmorphsOf: self topRendererOrSelf owner.	^ listOfNewborns! !!MouseEvent methodsFor: 'private' stamp: 'ar 9/15/2000 22:53'!setType: evtType position: evtPos buttons: evtButtons hand: evtHand	type := evtType.	position := evtPos.	buttons := evtButtons.	source := evtHand.	wasHandled := false.! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'bf 4/14/1999 12:39'!keyStroke: evt	| view |	(editView scrollByKeyboard: evt) ifTrue: [^self].	self editor model: editView model.  "For evaluateSelection"	view := editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!TextFieldMorph methodsFor: 'just like textMorph' stamp: 'tk 9/4/2000 16:28'!fit	"tell my text to recompute its looks"	| tm |	(tm := self findA: TextMorph) ifNil: [^ nil].	tm releaseParagraph; paragraph.! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/4/97 14:29'!submorphsInFrontOf: aMorph do: aBlock	| behind |	behind := false.	submorphs do:		[:m | m == aMorph ifTrue: [behind := true]						ifFalse: [behind ifFalse: [aBlock value: m]]].! !!ProjectViewMorph methodsFor: 'events' stamp: 'raa 11/2/2000 10:29'!seeIfNameChanged	| nameBefore nameNow |	nameBefore := self valueOfProperty: #SafeProjectName ifAbsent: ['???'].	nameNow := self safeProjectName.	(submorphs notEmpty and: [nameBefore = nameNow]) ifTrue: [^self].	self addProjectNameMorphFiller.! !!Morph methodsFor: 'geometry' stamp: 'tk 7/14/2001 11:11'!setConstrainedPosition: aPoint hangOut: partiallyOutside	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds.  Let me go within two pixels of completely outside if partiallyOutside is true."	| trialRect delta boundingMorph bRect |	owner ifNil:[^self].	trialRect := aPoint extent: self bounds extent.	boundingMorph := self topRendererOrSelf owner.	delta := boundingMorph			ifNil:    [0@0]			ifNotNil: [				bRect := partiallyOutside 					ifTrue: [boundingMorph bounds insetBy: 								self extent negated + boundingMorph borderWidth + (2@2)]					ifFalse: [boundingMorph bounds].				trialRect amountToTranslateWithin: bRect].	self position: aPoint + delta.	self layoutChanged  "So that, eg, surrounding text will readjust"! !!HaloMorph methodsFor: 'private' stamp: 'tk 7/14/2001 11:04'!doDrag: evt with: dragHandle	| thePoint |	evt hand obtainHalo: self.	thePoint := target point: evt position - positionOffset from: owner.	target setConstrainedPosition:(target griddedPoint: thePoint) hangOut: true.! !!FileList2 class methodsFor: 'morphic ui' stamp: 'sw 2/22/2002 02:02'!morphicViewProjectLoader	| dir aFileList window midLine fixedSize |	dir := FileDirectory default.	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList servicesForProjectLoader.	aFileList fileSelectionBlock: self projectOnlySelectionBlock.	window := (SystemWindow labelled: dir pathName) model: aFileList.	fixedSize := 25.	midLine := 0.4.	self addFullPanesTo: window from: {		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0. 0@0 corner: 0@fixedSize}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1. 0@fixedSize corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1. 0@fixedSize corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!MenuMorph methodsFor: 'keyboard control' stamp: 'laza 5/6/2004 13:59'!keyStroke: evt 	| matchString char asc selectable help |	help := BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.	(self rootMenu hasProperty: #hasUsedKeyboard) 		ifFalse: 			[self rootMenu setProperty: #hasUsedKeyboard toValue: true.			self changed].	(evt commandKeyPressed and: [self commandKeyHandler notNil]) 		ifTrue: 			[self commandKeyHandler commandKeyTypedIntoMenu: evt.			^self deleteIfPopUp: evt].	char := evt keyCharacter.	asc := char asciiValue.	char = Character cr 		ifTrue: 			[selectedItem ifNotNil: 					[selectedItem hasSubMenu 						ifTrue: 							[evt hand newMouseFocus: selectedItem subMenu.							^evt hand newKeyboardFocus: selectedItem subMenu]						ifFalse: 							["self delete."							^selectedItem invokeWithEvent: evt]].			(selectable := self items) size = 1 				ifTrue: [^selectable first invokeWithEvent: evt].			^self].	asc = 27 		ifTrue: 			["escape key"			self valueOfProperty: #matchString				ifPresentDo: 					[:str | 					str isEmpty 						ifFalse: 							["If filtered, first ESC removes filter"							self setProperty: #matchString toValue: String new.							self selectItem: nil event: evt.							^self displayFiltered: evt]].			"If a stand-alone menu, just delete it"			popUpOwner ifNil: [^self delete].			"If a sub-menu, then deselect, and return focus to outer menu"			self selectItem: nil event: evt.			evt hand newMouseFocus: popUpOwner owner.			^evt hand newKeyboardFocus: popUpOwner owner].	(asc = 28 or: [asc = 29]) 		ifTrue: 			["left or right arrow key"			(selectedItem notNil and: [selectedItem hasSubMenu]) 				ifTrue: 					[evt hand newMouseFocus: selectedItem subMenu.					selectedItem subMenu moveSelectionDown: 1 event: evt.					^evt hand newKeyboardFocus: selectedItem subMenu]].	asc = 30 ifTrue: [^self moveSelectionDown: -1 event: evt].	"up arrow key"	asc = 31 ifTrue: [^self moveSelectionDown: 1 event: evt].	"down arrow key"	asc = 11 ifTrue: [^self moveSelectionDown: -5 event: evt].	"page up key"	asc = 12 ifTrue: [^self moveSelectionDown: 5 event: evt].	"page down key"	matchString := self valueOfProperty: #matchString ifAbsentPut: [String new].	matchString := char = Character backspace 				ifTrue: 					[matchString isEmpty ifTrue: [matchString] ifFalse: [matchString allButLast]]				ifFalse: [matchString copyWith: evt keyCharacter].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt.	help := BalloonMorph string: 'Enter text to\narrow selection down\to matching items ' withCRs for: self corner: #topLeft.	help popUpForHand: self activeHand.! !!Morph class methodsFor: 'misc' stamp: 'sw 8/4/1998 16:51'!morphsUnknownToTheirOwners	"Return a list of all morphs (other than HandMorphs) whose owners do not contain them in their submorph lists"	"Morph morphsUnknownToTheirOwners"	| problemMorphs itsOwner |	problemMorphs := OrderedCollection new.	self allSubInstances do:		[:m | (m isHandMorph not and: [((itsOwner := m owner) ~~ nil and: [(itsOwner submorphs includes: m) not])])			ifTrue:				[problemMorphs add: m]].	^ problemMorphs! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/7/2000 20:53'!embedInto: evt	"Embed the receiver into some other morph"	|  menu target |	menu := CustomMenu new.	self potentialEmbeddingTargets  do: [:m | 		menu add: (m knownName ifNil:[m class name asString]) action: m].	target := menu startUpWithCaption: ('Place ', self externalName, ' in...').	target ifNil:[^self].	target addMorphFront: self fromWorldPosition: self positionInWorld.! !!TextMorph methodsFor: 'accessing' stamp: 'BJP 12/1/2003 00:19'!newContents: stringOrText 	"Accept new text contents."	| newText embeddedMorphs |	"If my text is all the same font, use the font for my new contents"	newText := stringOrText isString ifTrue: [ | textSize |		(text notNil		  and: [ (textSize := text size) > 0		    and: [ (text runLengthFor: 1) = textSize ]]) ifTrue: [ | attribs |			attribs := text attributesAt: 1 forStyle: textStyle.			Text string: stringOrText copy attributes: attribs.		]		ifFalse: [ Text fromString: stringOrText copy ]	]	ifFalse: [ stringOrText copy asText.	"should be veryDeepCopy?" ].	(text = newText and: [text runs = newText runs]) ifTrue: [^ self].	"No substantive change"	text ifNotNil: [(embeddedMorphs := text embeddedMorphs)			ifNotNil: 				[self removeAllMorphsIn: embeddedMorphs.				embeddedMorphs do: [:m | m delete]]].	text := newText.	"add all morphs off the visible region; they'll be moved into the right 	place when they become visible. (this can make the scrollable area too 	large, though)"	newText embeddedMorphs do: 		[:m | 		self addMorph: m.		m position: -1000 @ 0].	self releaseParagraph.	"update the paragraph cache"	self paragraph.	"re-instantiate to set bounds"	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/5/2000 20:00'!aboutToBeGrabbedBy: aHand	"The receiver is being grabbed by a hand.	Perform necessary adjustments (if any) and return the actual morph	that should be added to the hand."	| extentToHandToHand cmd |	self formerOwner: owner.	self formerPosition: self position.	cmd := self undoGrabCommand.	cmd ifNotNil:[self setProperty: #undoGrabCommand toValue: cmd].	(extentToHandToHand := self valueOfProperty: #expandedExtent)			ifNotNil:				[self removeProperty: #expandedExtent.				self extent: extentToHandToHand].	^self "Grab me"! !!PluggableFileList methodsFor: 'file string' stamp: 'acg 2/19/2000 01:02'!fileString: aString	"| textName index ending |	textName := aString asString.	(FileDirectory default fileExists: textName) ifTrue:		[self directory: (FileDirectory forFileName: textName).		 index := list indexOf: (FileDirectory localNameFor: textName).		 index = 0 ifTrue: 			[ending := ') ', (FileDirectory localNameFor: textName).		  	 index := list findFirst: [:line | line endsWith: ending]].		 self fileListIndex: index].	(FileDirectory default directoryExists: textName) ifTrue:		[self directory: (FileDirectory on: textName)]."	self changed: #fileString.	self changed: #contents.	^true! !!FileList methodsFor: 'file menu action' stamp: 'jm 5/3/1998 18:03'!get	"Get contents of file again, it may have changed. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		self okToChange ifFalse: [^ nil].		brevityState == #briefHex			ifTrue: [brevityState := #needToGetFullHex]			ifFalse: [brevityState := #needToGetFull].		self changed: #contents].! !!MouseMoveEvent methodsFor: 'transforming' stamp: 'ar 9/15/2000 22:52'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position :=  aMorphicTransform globalPointToLocal: position.	startPoint :=  aMorphicTransform globalPointToLocal: startPoint.! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 17:58'!structureString	"Return a string that showing this morph and all its submorphs in an indented list that reflects its structure."	| s |	s := WriteStream on: (String new: 1000).	self printStructureOn: s indent: 0.	^ s contents! !!PasteUpMorph methodsFor: 'accessing' stamp: 'ar 6/30/2001 13:21'!assureFlapWidth: requestedWidth	| tab |	self width: requestedWidth.	tab := self flapTab ifNil:[^self].	tab flapShowing ifTrue:[tab hideFlap; showFlap].! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 12/30/2004 02:53'!addHandlesTo: aHaloMorph box: box	"Add halo handles to the halo.  Apply the halo filter if appropriate"	| wantsIt aSelector |	aHaloMorph haloBox: box.	Preferences haloSpecifications  do:		[:aSpec | 			aSelector :=  aSpec addHandleSelector.			wantsIt := Preferences selectiveHalos				ifTrue:					[self wantsHaloHandleWithSelector: aSelector inHalo: aHaloMorph]				ifFalse:					[true].			wantsIt ifTrue:				[(#(addMakeSiblingHandle: addDupHandle:) includes: aSelector) ifTrue:					[wantsIt := self preferredDuplicationHandleSelector = aSelector].			wantsIt ifTrue:				[aHaloMorph perform: aSelector with: aSpec]]].	aHaloMorph innerTarget addOptionalHandlesTo: aHaloMorph box: box! !!PasteUpMorph methodsFor: 'initialization' stamp: 'mir 10/29/2003 13:05'!becomeActiveDuring: aBlock	"Make the receiver the ActiveWorld during the evaluation of aBlock.	Note that this method does deliberately *not* use #ensure: to prevent	re-installation of the world on project switches."	| priorWorld priorHand priorEvent |	priorWorld := ActiveWorld.	priorHand := ActiveHand.	priorEvent := ActiveEvent.	ActiveWorld := self.	ActiveHand := self hands first. "default"	ActiveEvent := nil. "not in event cycle"	[aBlock value]		on: Error		do: [:ex | 			ActiveWorld := priorWorld.			ActiveEvent := priorEvent.			ActiveHand := priorHand.			ex pass]! !!FileList methodsFor: 'server list' stamp: 'di 1/29/2002 21:45'!putUpdate: fullFileName	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names := ServerDirectory groupNames asSortedArray.	choice := (SelectionMenu labelList: names selections: names) startUp.	choice == nil ifTrue: [^ self].	(ServerDirectory serverInGroupNamed: choice) putUpdate: 				(directory oldFileNamed: fullFileName).	self volumeListIndex: volListIndex.! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 10:00'!historyCategory: aKey	History ifNil: [History := Dictionary new].	specificHistory := History		at: aKey		ifAbsentPut: [Dictionary new].	^specificHistory! !!HaloMorph methodsFor: 'private' stamp: 'di 9/26/2000 15:12'!positionDirectionShaft: shaft	"Position the shaft."	| alphaRadians unitVector |	"Pretty crude and slow approach at present, but a stake in the ground"	alphaRadians := target heading degreesToRadians.	unitVector := alphaRadians sin  @ alphaRadians cos negated.	shaft setVertices: {unitVector * 6 + directionArrowAnchor.  "6 = radius of deadeye circle"					unitVector * self directionArrowLength + directionArrowAnchor}! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:04'!setRotationStyle	| selections labels sel reply |	selections := #(normal leftRight upDown none).	labels := #('rotate smoothly' 'left-right flip only' 'top-down flip only' 'don''t rotate').	sel := labels at: (selections indexOf: self rotationStyle ifAbsent:[1]).	labels := labels collect:[:lbl| sel = lbl ifTrue:['<on>', lbl translated] ifFalse:['<off>', lbl translated]].	reply := (SelectionMenu labelList: labels selections: selections) startUp.	reply ifNotNil: [self rotationStyle: reply].! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 12/31/1998 17:54'!setTimeStamp	timeStamp := Date today mmddyyyy, ' ', (Time now print24 copyFrom: 1 to: 8).	^ timeStamp! !!FileList class methodsFor: 'file reader registration' stamp: 'nk 6/12/2004 11:42'!itemsForDirectory: aFileDirectory	"Answer a list of services appropriate when no file is selected."	| services |	services := OrderedCollection new.	self registeredFileReaderClasses do: [:reader |		reader ifNotNil: [services addAll: (reader fileReaderServicesForDirectory: aFileDirectory) ]].	^ services! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'sbw 12/2/2000 08:38'!layoutMorphicLists: arrayOfMorphs 	| maxWidths offsets locs h |	maxWidths := self calculateColumnWidthsFrom: arrayOfMorphs.	offsets := self calculateColumnOffsetsFrom: maxWidths.	locs := Array new: arrayOfMorphs size.	locs at: 1 put: 0 @ 0.	2		to: locs size		do: [:indx | locs at: indx put: (offsets at: indx - 1)					@ 0].	h := arrayOfMorphs first first height.	1		to: arrayOfMorphs size		do: [:indx | (arrayOfMorphs at: indx)				do: [:morphItem | 					morphItem						bounds: ((locs at: indx)								extent: 9999 @ h).					locs at: indx put: (locs at: indx)							+ (0 @ h)]]! !!FormCanvas methodsFor: 'drawing-text' stamp: 'ar 2/5/2002 19:03'!drawString: aString from: firstIndex to: lastIndex in: bounds font: fontOrNil color: c	| font portRect |	port colorMap: nil.	portRect := port clipRect.	port clipByX1: bounds left + origin x 		y1: bounds top + origin y 		x2: bounds right + origin x 		y2: bounds bottom + origin y.	font := fontOrNil ifNil: [TextStyle defaultFont].	port combinationRule: Form paint.	font installOn: port		foregroundColor: (self shadowColor ifNil:[c]) 		backgroundColor: Color transparent.	font displayString: aString asString on: port 		from: firstIndex to: lastIndex at: (bounds topLeft + origin) kern: 0.	port clipRect: portRect.! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 3/21/2006 23:01'!splitterBelow	| splitters |	splitters := ((self siblingSplitters select: [:each | each y < self y]) asSortedCollection: [:a :b | a y > b y]).		^ splitters ifEmpty: nil ifNotEmpty: [splitters first]! !!NewParagraph methodsFor: 'composition' stamp: 'yo 12/17/2002 14:48'!testNewComposeAll2	| newResult |	newResult := TextComposer new		composeLinesFrom: firstCharacterIndex 		to: text size 		delta: 0		into: OrderedCollection new 		priorLines: Array new 		atY: container top		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: false.	^{newResult. {lines. maxRightX}}! !!NewHandleMorph methodsFor: 'stepping and presenter' stamp: 'RAA 4/19/2001 11:37'!step	| eventSource |	eventSource := self sensorMode ifTrue: [		Sensor	] ifFalse: [		hand lastEvent	].	eventSource anyButtonPressed		ifTrue: [waitingForClickInside := false.				self position: eventSource cursorPoint - (self extent // 2).				pointBlock value: self center]		ifFalse: [waitingForClickInside					ifTrue: [(self containsPoint: eventSource cursorPoint)								ifFalse: ["mouse wandered out before clicked"										^ self delete]]					ifFalse: [lastPointBlock value: self center.							^ self delete]]! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 00:26'!shadowColor: aColor	shadowColor := aColor! !!FormCanvas methodsFor: 'initialization' stamp: 'ar 2/17/2000 00:21'!reset	origin := 0@0.							"origin of the top-left corner of this cavas"	clipRect := (0@0 corner: 10000@10000).		"default clipping rectangle"	self shadowColor: nil.! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'th 9/20/2002 11:26'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY rect deltaX |	lineHeight := paragraph textStyle lineGrid.	rect := morph owner bounds.	deltaY := self stopBlock top - rect top.	deltaY ~= 0 ifTrue: [		deltaX := 0.		deltaY := (deltaY abs + lineHeight - 1 truncateTo: lineHeight) negated.		morph editView scrollBy: deltaX@deltaY]! !!SimpleHierarchicalListMorph class methodsFor: 'instance creation' stamp: 'nk 3/8/2004 10:05'!expandedForm	expandedForm ifNotNil: [ expandedForm depth ~= Display depth ifTrue: [ expandedForm := nil ]].	^expandedForm ifNil: [expandedForm := 			(Form				extent: 10@9				depth: 8				fromArray: #( 4294967295 4294967295 4294901760 4294967295 4294967295 4294901760 4278255873 16843009 16842752 4294902089 1229539657 33488896 4294967041 1229539585 4294901760 4294967295 21561855 4294901760 4294967295 4278321151 4294901760 4294967295 4294967295 4294901760 4294967295 4294967295 4294901760)				offset: 0@0)					asFormOfDepth: Display depth;					replaceColor: Color white withColor: Color transparent;					yourself	].! !!PasteUpMorph methodsFor: 'options' stamp: 'panda 4/25/2000 15:42'!setPartsBinStatusTo: aBoolean	isPartsBin := aBoolean.	aBoolean ifFalse: [self enableDragNDrop].		"but note that we no longer reset openToDragNDrop to false upon making it a parts bin again"	isPartsBin		ifTrue:			[submorphs do:				[:m | m isPartsDonor: true.					m stopStepping.					m suspendEventHandler]]		ifFalse:			[submorphs do:				[:m | m isPartsDonor: false.					m restoreSuspendedEventHandler].			self world ifNotNil: [self world startSteppingSubmorphsOf: self]]! !!TTSampleFontMorph methodsFor: 'copying' stamp: 'sma 2/26/2000 19:18'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all,	but shared. Warning!!!! Every instance variable defined in this class	must be handled.  We must also implement veryDeepFixupWith:.	See DeepCopier class comment."	super veryDeepInner: deepCopier.	"font := font"	transform := transform veryDeepCopyWith: deepCopier.	smoothing := smoothing veryDeepCopyWith: deepCopier! !!PolygonMorph methodsFor: 'private' stamp: 'wiz 2/12/2006 00:04'!computeBounds	| oldBounds delta excludeHandles |	vertices ifNil: [^ self].	self changed.	oldBounds := bounds.	self releaseCachedState.	bounds := self curveBounds expanded.	self arrowForms do:		[:f | bounds := bounds merge: (f offset extent: f extent)].	handles ifNotNil: [self updateHandles].	"since we are directly updating bounds, see if any ordinary submorphs exist and move them accordingly"	(oldBounds notNil and: [(delta := bounds origin - oldBounds origin) ~= (0@0)]) ifTrue: [		excludeHandles := IdentitySet new.		handles ifNotNil: [excludeHandles addAll: handles].		self submorphsDo: [ :each |			(excludeHandles includes: each) ifFalse: [				each position: each position + delta			].		].	].	self layoutChanged.	self changed.! !!SketchMorph methodsFor: 'menus' stamp: 'RAA 11/14/2000 13:44'!collapse		| priorPosition w collapsedVersion a |	(w := self world) ifNil: [^self].	collapsedVersion := (self imageForm scaledToSize: 50@50) asMorph.	collapsedVersion setProperty: #uncollapsedMorph toValue: self.	collapsedVersion on: #mouseUp send: #uncollapseSketch to: collapsedVersion.	collapsedVersion setBalloonText: 'A collapsed version of ',self name.				self delete.	w addMorphFront: (		a := AlignmentMorph newRow			hResizing: #shrinkWrap;			vResizing: #shrinkWrap;			borderWidth: 4;			borderColor: Color white;			addMorph: collapsedVersion	).	collapsedVersion setProperty: #collapsedMorphCarrier toValue: a.	(priorPosition := self valueOfProperty: #collapsedPosition ifAbsent: [nil])	ifNotNil:		[a position: priorPosition].! !!WorldState methodsFor: 'hands' stamp: 'ar 1/22/2001 14:26'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(hands includes: aHandMorph) ifFalse: [^self].	hands := hands copyWithout: aHandMorph.	ActiveHand == aHandMorph ifTrue: [ActiveHand := nil].! !!GrafPort methodsFor: 'private' stamp: 'yo 1/8/2005 09:12'!installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor	super installTTCFont: aTTCFont foregroundColor: foregroundColor backgroundColor: backgroundColor.	lastFont := aTTCFont.	lastFontForegroundColor := foregroundColor.	lastFontBackgroundColor := backgroundColor.! !!SimpleHierarchicalListMorph methodsFor: 'private' stamp: 'RAA 6/21/1999 11:25'!adjustSubmorphPositions	| p h |	p := 0@0.	scroller submorphsDo: [ :each |		h := each height.		each privateBounds: (p extent: 9999@h).		p := p + (0@h)	].	self 		changed;		layoutChanged;		setScrollDeltas.! !!ThreePhaseButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:02'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].arguments := arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!Morph methodsFor: 'geometry' stamp: 'ar 9/15/2000 14:21'!griddedPoint: ungriddedPoint	| griddingContext |	self flag: #arNote. "Used by event handling - should transform to pasteUp for gridding"	(griddingContext := self pasteUpMorph) ifNil: [^ ungriddedPoint].	^ griddingContext gridPoint: ungriddedPoint! !!DropEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 18:44'!wasHandled: aBool	wasHandled := aBool.! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 10/24/2004 17:41'!updateToPlayer: newPlayer 	"Make certain that the script name and the names of actors within are up to date"	playerScripted ifNil: 		["likely a naked test/yes/no fragment!!"		^ self].	newPlayer == playerScripted ifTrue: [^ self].	"Already points to him"	self allMorphs do:  [:m | 		(m isKindOf: TileMorph)  ifTrue: 			[m retargetFrom: playerScripted to: newPlayer.			m bringUpToDate]].	playerScripted := newPlayer.	self replaceRow1! !!PasteUpMorph methodsFor: 'scripting' stamp: 'tk 6/14/1998 15:18'!scriptorForTextualScript: aSelector ofPlayer: aPlayer	| aScriptor |	self world ifNil: [^ nil].	aScriptor := ScriptEditorMorph new setMorph: aPlayer costume scriptName: aSelector.	aScriptor position: (self primaryHand position - (10 @ 10)).	^ aScriptor! !!TextLine methodsFor: 'private' stamp: ''!internalSpaces: spacesInteger paddingWidth: padWidthInteger	internalSpaces := spacesInteger.	paddingWidth := padWidthInteger! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/7/2000 23:36'!basicBoxForSimpleHalos	| w |	w := self world ifNil:[target outermostWorldMorph].	^ (target topRendererOrSelf worldBoundsForHalo expandBy: self handleAllowanceForIconicHalos)			intersect: (w bounds insetBy: 8@8)! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/10/2000 19:03'!addHalo: evt	| halo prospectiveHaloClass |	prospectiveHaloClass := Smalltalk at: self haloClass ifAbsent: [HaloMorph].	halo := prospectiveHaloClass new bounds: self worldBoundsForHalo.	halo popUpFor: self event: evt.	^halo! !!SystemProgressMorph methodsFor: 'private' stamp: 'laza 4/9/2004 10:23'!nextSlotFor: shortDescription	| bar slots label |	lock critical: [		slots := bars size.		activeSlots = slots ifTrue: [^0].		activeSlots := activeSlots + 1.		1 to: slots do: [:index |			bar := (bars at: index).			bar ifNil: [				bar := bars at: index put: (SystemProgressBarMorph new extent: BarWidth@BarHeight).				label := labels at: index put: (StringMorph contents: shortDescription font: font).				self					addMorphBack: label;					addMorphBack: bar.				^index].			bar owner ifNil: [				bar := bars at: index.				label := labels at: index.				self					addMorphBack: (label contents: shortDescription);					addMorphBack: (bar barSize: 0).				^index]]]		! !!UpdatingStringMorph methodsFor: 'events-processing' stamp: 'sw 11/15/2001 18:17'!handlerForMouseDown: evt	"Answer an object to field the mouseDown event provided, or nil if none"	| aHandler |	aHandler := super handlerForMouseDown: evt.	aHandler == self ifTrue:	[^ self]. "I would get it anyways"	"Note: This is a hack to allow value editing in viewers"	((owner wantsKeyboardFocusFor: self) and:		[self userEditsAllowed]) ifTrue: [^ self].	^ aHandler! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/26/1999 23:32'!embeddedInMorphicWindowLabeled: labelString	| window |	window := (SystemWindow labelled: labelString) model: nil.	window setStripeColorsFrom: nil defaultBackgroundColor.	window addMorph: self frame: (0@0 extent: 1@1).	^ window! !!UpdatingSimpleButtonMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/11/1999 18:30'!wordingSelector: aSelector	wordingSelector := aSelector.	wordingProvider ifNil: [wordingProvider := target]! !!Morph methodsFor: 'initialization' stamp: 'sw 6/26/2001 10:56'!inATwoWayScrollPane	"Answer a two-way scroll pane that allows the user to scroll the receiver in either direction.  It will have permanent scroll bars unless you take some special action."	| widget |	widget := TwoWayScrollPane new.	widget extent: ((self width min: 300 max: 100) @ (self height min: 150 max: 100));		borderWidth: 0.	widget scroller addMorph: self.	widget setScrollDeltas.	widget color: self color darker darker.	^ widget! !!BalloonCanvas methodsFor: 'TODO' stamp: 'ar 2/9/1999 05:46'!line: point1 to: point2 brushForm: brush	"Who's gonna use this?"	| pt1 pt2 |	self flush. "Sorry, but necessary..."	transform 		ifNil:[pt1 := point1. pt2 := point2]		ifNotNil:[pt1 := transform localPointToGlobal: point1.				pt2 := transform localPointToGlobal: point2].	^super line: pt1 to: pt2 brushForm: brush! !!Morph methodsFor: 'meta-actions' stamp: 'mir 3/17/2006 18:02'!dismissMorph	"This is called from an explicit halo destroy/delete action."	| w |	w := self world ifNil:[^self].	w abandonAllHalos; stopStepping: self.	self delete! !!SketchMorph methodsFor: 'e-toy support' stamp: 'jm 7/24/97 15:06'!rotationStyle: aSymbol	"Set my rotation style to #normal, #leftRight, #upDown, or #none. Styles mean:		#normal		-- continuous 360 degree rotation		#leftRight		-- quantize angle to left or right facing		#upDown		-- quantize angle to up or down facing		#none			-- do not rotate"	rotationStyle := aSymbol.	self layoutChanged.! !!TextMorph methodsFor: 'menu' stamp: 'sw 1/31/2006 05:33'!changeMargins: evt	| handle origin aHand oldMargin newMargin |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	oldMargin := margins.	handle := HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newMargin := (newPoint - origin max: 0@0) // 5.			self margins: newMargin]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].			self rememberCommand:				(Command new cmdWording: ('margin change for ' translated,self nameForUndoWording);					undoTarget: self selector: #margins: argument: oldMargin;					redoTarget: self selector: #margins: argument: newMargin;					yourself)].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor down and to the rightto increase margin inset.Click when done.' hand: evt hand.	handle startStepping! !!TransferMorph methodsFor: 'private' stamp: 'sr 6/6/2000 07:19'!animationForMoveSuccess: success 	| start stop slideForm |	success		ifTrue: [^ self]		ifFalse: 			[start := self fullBounds origin.			stop := self source bounds origin].	start = stop ifTrue: [^ self].	slideForm := self imageFormForRectangle: ((self fullBounds origin corner: self fullBounds corner + self activeHand shadowOffset)					merge: self activeHand bounds).	slideForm offset: 0 @ 0.	slideForm		slideWithFirstFrom: start		to: stop		nSteps: 12		delay: 20! !!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 3/30/1999 18:27'!setItem: anObject	item := anObject! !!FileList methodsFor: 'private' stamp: 'nk 12/10/2002 07:57'!updateFileList	"Update my files list with file names in the current directory  	that match the pattern.	The pattern string may have embedded newlines or semicolons; these separate different patterns."	| patterns |	patterns := OrderedCollection new.	Cursor wait showWhile: [	(pattern findTokens: (String with: Character cr with: Character lf with: $;))		do: [ :each |			(each includes: $*) | (each includes: $#)					ifTrue: [ patterns add: each]					ifFalse: [each isEmpty										ifTrue: [ patterns add: '*']										ifFalse: [ patterns add: '*' , each , '*']]].	list := self listForPatterns: patterns.	listIndex := 0.	volListIndex := volList size.	fileName := nil.	contents := ''.	self changed: #volumeListIndex.	self changed: #fileList.	self updateButtonRow]! !!SystemWindow methodsFor: 'panes' stamp: 'RAA 1/8/2001 20:37'!addMorph: aMorph frame: relFrame	| frame |	frame := LayoutFrame new.	frame 		leftFraction: relFrame left; 		rightFraction: relFrame right; 		topFraction: relFrame top; 		bottomFraction: relFrame bottom.	self addMorph: aMorph fullFrame: frame.! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'bolot 5/18/2000 13:53'!requestPassword: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| aFillInTheBlankMorph |	aFillInTheBlankMorph := self new		setPasswordQuery: queryString		initialAnswer: defaultAnswer		answerHeight: 50		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.	aWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.	^ aFillInTheBlankMorph getUserResponse! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 5/1/2005 00:33'!resumeScriptsPausedByPainting	"If there were any scripts running when painting was initiated, resume them now"	| aList |	(aList := self valueOfProperty: #scriptsToResume) isEmptyOrNil ifFalse:		[aList do:			[:aScriptInstantiation |				aScriptInstantiation player costume isInWorld ifTrue:					[aScriptInstantiation startRunningIfPaused]]].	self removeProperty: #scriptsToResume! !!SelectionMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/10/2000 15:02'!aboutToBeGrabbedBy: aHand	slippage := 0@0.	^ super aboutToBeGrabbedBy: aHand! !!PluggableTextMorphWithModel methodsFor: 'contents' stamp: 'mjg 12/3/1999 11:59'!setMyText: someText	myContents := someText.	^true.! !!MouseMoveEvent methodsFor: 'transforming' stamp: 'ar 9/15/2000 22:52'!translateBy: delta	"add delta to cursorPoint, and return the new event"	position := position + delta.	startPoint := startPoint + delta.! !!ColorPatchCanvas methodsFor: 'private' stamp: 'ar 6/22/1999 16:18'!setForm: aForm	"Initialize the receiver to act just as a FormCanvas"	super setForm: aForm.	stopMorph := nil.	doStop := false.	foundMorph := false.! !!EventHandler methodsFor: 'access' stamp: ''!methodRefList	"Return a MethodReference for each message I can send. tk 9/13/97, raa 	5/29/01 "	| list adder |	list := SortedCollection new.	adder := [:recip :sel | recip				ifNotNil: [list						add: (MethodReference new								setStandardClass: (recip class whichClassIncludesSelector: sel)								methodSymbol: sel)]].	adder value: mouseDownRecipient value: mouseDownSelector.	adder value: mouseMoveRecipient value: mouseMoveSelector.	adder value: mouseStillDownRecipient value: mouseStillDownSelector.	adder value: mouseUpRecipient value: mouseUpSelector.	adder value: mouseEnterRecipient value: mouseEnterSelector.	adder value: mouseLeaveRecipient value: mouseLeaveSelector.	adder value: mouseEnterDraggingRecipient value: mouseEnterDraggingSelector.	adder value: mouseLeaveDraggingRecipient value: mouseLeaveDraggingSelector.	adder value: doubleClickRecipient value: doubleClickSelector.	adder value: keyStrokeRecipient value: keyStrokeSelector.	^ list! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 11/2/2004 16:41'!dismiss	"Dismiss the scriptor, usually nondestructively"	owner ifNil: [^ self].	scriptName ifNil: [^ self delete].  "ad hoc fixup for bkwrd compat"	(playerScripted isExpendableScript: scriptName) ifTrue: [playerScripted removeScript: scriptName  fromWorld: self world].	handWithTile := nil.	self delete! !!JoystickMorph methodsFor: 'menu' stamp: 'yo 3/14/2005 13:11'!setYRange	| range |	range := FillInTheBlank		request:'Type the maximum value for the Y axis'  translated		initialAnswer: ((yScale * (self width - handleMorph width) / 2.0) roundTo: 0.01) printString.	range isEmpty ifFalse: [		yScale := (2.0 * range asNumber asFloat) / (self width - handleMorph width)].! !!ThreePhaseButtonMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:01'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier.offImage := offImage veryDeepCopyWith: deepCopier.pressedImage := pressedImage veryDeepCopyWith: deepCopier.state := state veryDeepCopyWith: deepCopier."target := target.		Weakly copied""actionSelector := actionSelector.		Symbol""arguments := arguments.		Weakly copied"actWhen := actWhen.		"Symbol"! !!ScrollBar methodsFor: 'access' stamp: ''!scrollDelta: d1 pageDelta: d2	"Supply optional increments for better scrolling of, eg, text"	scrollDelta := d1.	pageDelta := d2.! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:34'!adjustLayoutBounds	"Adjust the receivers bounds depending on the resizing strategy imposed"	| hFit vFit box myExtent extent |	hFit := self hResizing.	vFit := self vResizing.	(hFit == #shrinkWrap or:[vFit == #shrinkWrap]) ifFalse:[^self]. "not needed"	box := self layoutBounds.	myExtent := box extent.	extent := self submorphBounds corner - box origin.	hFit == #shrinkWrap ifTrue:[myExtent := extent x @ myExtent y].	vFit == #shrinkWrap ifTrue:[myExtent := myExtent x @ extent y].	"Make sure we don't get smaller than minWidth/minHeight"	myExtent x < self minWidth ifTrue:[		myExtent := (myExtent x max: 			(self minWidth - self bounds width + self layoutBounds width)) @ myExtent y].	myExtent y < self minHeight ifTrue:[		myExtent := myExtent x @ (myExtent y max:			(self minHeight - self bounds height + self layoutBounds height))].	self layoutBounds: (box origin extent: myExtent).! !!BorderedMorph methodsFor: 'geometry' stamp: 'nk 4/5/2001 14:24'!closestPointTo: aPoint	"account for round corners. Still has a couple of glitches at upper left and right corners"	| pt |	pt := self bounds pointNearestTo: aPoint.	self wantsRoundedCorners ifFalse: [ ^pt ].	self bounds corners with: (self bounds insetBy: 6) corners do: [ :out :in |		(pt - out) abs < (6@6)			ifTrue: [ ^(in + (Point r: 5.0 degrees: (pt - in) degrees)) asIntegerPoint ].	].	^pt.! !!ImageMorph methodsFor: 'accessing' stamp: 'ar 12/12/2001 01:08'!borderStyle: newStyle	| newExtent |	newExtent := 2 * newStyle width + image extent.	bounds extent = newExtent ifFalse:[super extent: newExtent].	super borderStyle: newStyle.! !!PasteUpMorph methodsFor: 'viewing' stamp: 'ar 11/9/2000 13:49'!imposeListViewSortingBy: sortOrderSymbol retrieving: fieldListSelectors	"Establish a list view of the receiver's contents, sorting the contents by the criterion represented by sortOrderSymbol, and displaying readouts as indicated by the list of field selectors."	| rep |	self setProperty: #sortOrder toValue: sortOrderSymbol.	self setProperty: #fieldListSelectors toValue: fieldListSelectors.	self showingListView ifFalse:		[self autoLineLayout ifFalse: [self saveBoundsOfSubmorphs].		self setProperty: #showingListView toValue: true.		self layoutPolicy: TableLayout new.		self layoutInset: 2; cellInset: 2.		self listDirection: #topToBottom.		self wrapDirection: #none].	self submorphs "important that it be a copy" do:		[:aMorph | 			rep := aMorph listViewLineForFieldList: fieldListSelectors.			rep hResizing: #spaceFill.			self replaceSubmorph: aMorph by: rep].	self sortSubmorphsBy: (self valueOfProperty: #sortOrder).! !!ThreePhaseButtonMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:16'!mouseDown: evt	| now dt |	self state: #pressed.	actWhen == #buttonDown		ifTrue:			[self doButtonAction]		ifFalse:			[now := Time millisecondClockValue.			super mouseDown: evt.			"Allow on:send:to: to set the response to events other than actWhen"			dt := Time millisecondClockValue - now max: 0.  "Time it took to do"			dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait]].	self mouseStillDown: evt.! !!PluggableListMorph methodsFor: 'drag and drop' stamp: 'ls 6/23/2001 00:01'!resetPotentialDropRow	potentialDropRow ifNotNil: [	potentialDropRow ~= 0 ifTrue: [		potentialDropRow := 0.		self changed. ] ]! !!TTSampleFontMorph methodsFor: 'copying' stamp: 'sma 2/26/2000 19:20'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here. If they were in the 	tree being copied, fix them up, otherwise point to the originals!!!!"	super veryDeepFixupWith: deepCopier.	font := deepCopier references at: font ifAbsent: [font]! !!SketchMorph methodsFor: 'pen support' stamp: 'jm 4/22/1998 09:08'!revealPenStrokes	"This message must be sent after a sequence of pen strokes to make the resulting changes visible."	rotatedForm := nil.	self changed.! !!EventHandler methodsFor: 'access' stamp: 'ar 10/25/2000 17:33'!allRecipients	"Answer a list, without duplication, of all the objects serving as recipients to any of the events I handle.  Intended for debugging/documentation use only"	| aList |	aList := OrderedCollection with: mouseDownRecipient with: mouseStillDownRecipient with: mouseUpRecipient with: mouseEnterRecipient with: mouseLeaveRecipient.	aList addAll: (OrderedCollection with:  mouseEnterDraggingRecipient with: mouseLeaveDraggingRecipient with: doubleClickRecipient with: keyStrokeRecipient).	aList add: mouseMoveRecipient.	^ (aList copyWithout: nil) asSet asArray! !!NewParagraph methodsFor: 'composition' stamp: 'yo 1/3/2003 12:17'!multiComposeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult |	newResult := MultiTextComposer new		multiComposeLinesFrom: start 		to: stop 		delta: delta 		into: lineColl 		priorLines: priorLines		atY: startingY		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: wantsColumnBreaks == true.	lines := newResult first asArray.	maxRightX := newResult second.	"maxRightX printString displayAt: 0@0."	^maxRightX! !!ComplexBorder methodsFor: 'private' stamp: 'ar 11/26/2001 15:00'!computeColors	width = 0 ifTrue:[^colors := #()].	style == #complexFramed ifTrue:[^self computeFramedColors].	style == #complexAltFramed ifTrue:[^self computeAltFramedColors].	style == #complexRaised ifTrue:[^self computeRaisedColors].	style == #complexAltRaised ifTrue:[^self computeAltRaisedColors].	style == #complexInset ifTrue:[^self computeInsetColors].	style == #complexAltInset ifTrue:[^self computeAltInsetColors].	self error:'Unknown border style: ', style printString.! !!Morph methodsFor: 'fileIn/out' stamp: 'di 11/18/1999 08:52'!saveAsResource	| pathName |	(self hasProperty: #resourceFilePath) ifFalse: [^ self].	pathName := self valueOfProperty: #resourceFilePath.	(pathName asLowercase endsWith: '.morph') ifFalse:		[^ self error: 'Can only update morphic resources'].	(FileStream newFileNamed: pathName) fileOutClass: nil andObject: self.! !!WorldState methodsFor: 'stepping' stamp: 'ar 10/22/2000 15:22'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now := Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes: now].  "clock slipped"! !!HandMorph methodsFor: 'layout' stamp: 'jm 2/20/98 18:55'!fullBounds	"Extend my bounds by the shadow offset when carrying morphs."	| bnds |	bnds := super fullBounds.	submorphs isEmpty		ifTrue: [^ bnds ]		ifFalse: [^ bnds topLeft corner: bnds bottomRight + self shadowOffset].! !!TheWorldMenu methodsFor: 'mechanics' stamp: 'dgd 8/26/2003 21:05'!menu: titleString	"Create a menu with the given title, ready for filling"	| menu |	(menu := MenuMorph entitled: titleString translated) 		defaultTarget: self; 		addStayUpItem;		commandKeyHandler: self.	self colorForDebugging: menu.	^ menu! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!listCentering: aSymbol	listCentering := aSymbol! !!Morph methodsFor: 'meta-actions' stamp: 'wiz 7/17/2004 23:27'!targetWith: evt	"Some other morph become target of the receiver"	|  menu newTarget |	menu := CustomMenu new.	self potentialTargets  do: [:m | 		menu add: (m knownName ifNil:[m class name asString]) action: m].	newTarget := menu startUpWithCaption: ( self externalName, ' targets...').	newTarget ifNil:[^self].	self target: newTarget.! !!MorphExtension methodsFor: 'accessing' stamp: 'di 8/10/1998 12:55'!visible: newValue	visible := newValue! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/26/2000 00:49'!readFrom: aStream	"Read a MorphicEvent from the given stream."	| typeString c |	typeString := String streamContents:		[:s |   [(c := aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove' ifTrue:[^MouseMoveEvent type: #mouseMove readFrom: aStream].	typeString = 'mouseDown' ifTrue:[^MouseButtonEvent type: #mouseDown readFrom: aStream].	typeString = 'mouseUp' ifTrue:[^MouseButtonEvent type: #mouseUp readFrom: aStream].	typeString = 'keystroke' ifTrue:[^KeyboardEvent type: #keystroke readFrom: aStream].	typeString = 'keyDown' ifTrue:[^KeyboardEvent type: #keyDown readFrom: aStream].	typeString = 'keyUp' ifTrue:[^KeyboardEvent type: #keyUp readFrom: aStream].	typeString = 'mouseOver' ifTrue:[^MouseEvent type: #mouseOver readFrom: aStream].	typeString = 'mouseEnter' ifTrue:[^MouseEvent type: #mouseEnter readFrom: aStream].	typeString = 'mouseLeave' ifTrue:[^MouseEvent type: #mouseLeave readFrom: aStream].	typeString = 'unknown' ifTrue:[^MorphicUnknownEvent type: #unknown readFrom: aStream].	^nil! !!TransferMorph methodsFor: 'accessing' stamp: 'panda 4/25/2000 16:14'!dropNotifyRecipient: anObject	dropNotifyRecipient := anObject! !!PluggableMultiColumnListMorphByItem methodsFor: 'model access' stamp: 'ls 8/19/2001 15:11'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector == nil		ifTrue: [^ 0].	item := model perform: getIndexSelector.	^ list first		findFirst: [:x | x  = item]! !!AbstractResizerMorph methodsFor: 'as yet unclassified' stamp: 'jrp 7/29/2005 13:25'!setDefaultColors	handleColor := Color lightGray lighter lighter.	dotColor := Color gray lighter! !!Morph methodsFor: 'thumbnail' stamp: 'tk 3/28/2000 11:08'!updateThumbnailUrl	"If I have a cached thumbnail, then update it's urls."	| cachedThumbnail |	(cachedThumbnail := self valueOfProperty: #cachedThumbnail) ifNotNil:		[(cachedThumbnail respondsTo: #computeThumbnail) 			ifTrue: [cachedThumbnail pageMorph: self url inBook: owner url]			ifFalse: [self removeProperty: #computeThumbnail]].			"Test and removal are because the thumbnail is being replaced 			by another Morph.  We don't know why.  Need to fix that at 			the source."! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 2/19/2001 06:57'!projectOnlySelectionMethod: incomingEntries	| versionsAccepted basicInfoTuple basicName basicVersion |	"this shows only the latest version of each project"	versionsAccepted := Dictionary new.	incomingEntries do: [ :entry |		entry isDirectory ifFalse: [			(#('*.pr' '*.pr.gz' '*.project') anySatisfy: [ :each | each match: entry name]) ifTrue: [				basicInfoTuple := Project parseProjectFileName: entry name.				basicName := basicInfoTuple first.				basicVersion := basicInfoTuple second.				((versionsAccepted includesKey: basicName) and: 						[(versionsAccepted at: basicName) first > basicVersion]) ifFalse: [					versionsAccepted at: basicName put: {basicVersion. entry}				].			]		]	].	^versionsAccepted asArray collect: [ :each | each second]! !!TransformMorph methodsFor: 'layout' stamp: 'di 11/20/2000 11:54'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	"It might be better to override doLayoutIn:, and remove this method"	fullBounds ifNotNil:[^ fullBounds].	fullBounds := bounds.	submorphs do: [:m| m ownerChanged].	^ fullBounds! !!HandMorph methodsFor: 'updating' stamp: 'jm 2/20/98 19:54'!changed	hasChanged := true.! !!Morph methodsFor: 'halos and balloon help' stamp: 'em 3/24/2005 10:02'!editBalloonHelpContent: aString	| reply |	reply := FillInTheBlank		multiLineRequest: 'Edit the balloon help text for ' translated, self externalName		centerAt: Sensor cursorPoint		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])		answerHeight: 200.	reply ifNil: [^ self].  "User cancelled out of the dialog"	(reply isEmpty or: [reply asString = self noHelpString])		ifTrue: [self setBalloonText: nil]		ifFalse: [self setBalloonText: reply]! !!Morph methodsFor: 'structure' stamp: 'sw 8/29/2000 14:55'!morphPreceding: aSubmorph	"Answer the morph immediately preceding aSubmorph, or nil if none"	| anIndex |	anIndex := submorphs indexOf: aSubmorph ifAbsent: [^ nil].	^ anIndex > 1		ifTrue:			[submorphs at: (anIndex - 1)]		ifFalse:			[nil]! !!MenuMorph methodsFor: 'construction' stamp: 'sw 8/28/2000 18:01'!addWithLabel: aLabel enablementSelector: enablementSelector target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  In this variant, the wording of the menu item is constant, and the optional enablementSelector determines whether or not the item should be enabled."	| item |	item := UpdatingMenuItemMorph new		target: target;		selector: aSymbol;		contents: aLabel;		wordingProvider: target wordingSelector: nil;		enablementSelector: enablementSelector;		arguments: argList asArray.	self addMorphBack: item.! !!MorphExtension methodsFor: 'other' stamp: 'md 2/27/2006 08:39'!inspectElement	"Create and schedule an Inspector on the otherProperties and the 	named properties."	| key obj |	key := (SelectionMenu selections: self sortedPropertyNames)				startUpWithCaption: 'Inspect which property?'.	key		ifNil: [^ self].	obj := otherProperties				at: key				ifAbsent: ['nOT a vALuE'].	obj = 'nOT a vALuE'		ifTrue: [(self perform: key) inspect			"named properties"]		ifFalse: [obj inspect]! !!TTSampleStringMorph methodsFor: 'drawing' stamp: 'ar 12/30/1998 10:51'!drawOn: aCanvas	| xStart glyph |	(font isNil or:[string isNil or:[string isEmpty]]) 		ifTrue:[^aCanvas frameRectangle: bounds color: Color black].	xStart := 0.	aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|		balloonCanvas transformBy: self transform.		balloonCanvas aaLevel: self smoothing.		string do:[:char|			glyph := font at: char.			balloonCanvas preserveStateDuring:[:subCanvas|				subCanvas transformBy: (MatrixTransform2x3 withOffset: xStart@0).				subCanvas 					drawGeneralBezierShape: glyph contours					color: color 					borderWidth: borderWidth 					borderColor: borderColor].			xStart := xStart + glyph advanceWidth.		].	].! !!UserInputEvent methodsFor: 'initialize' stamp: 'ar 9/13/2000 15:54'!copyHandlerState: anEvent	"Copy the handler state from anEvent. Used for quickly transferring handler information between transformed events."	handler := anEvent handler.	wasHandled := anEvent wasHandled.! !!FileList methodsFor: 'private' stamp: 'sma 11/11/2000 17:00'!entriesMatching: patternString	"Answer a list of directory entries which match the patternString.	The patternString may consist of multiple patterns separated by ';'.	Each pattern can include a '*' or '#' as wildcards - see String>>match:"	| entries patterns |	entries := directory entries.	patterns := patternString findTokens: ';'.	(patterns anySatisfy: [:each | each = '*'])		ifTrue: [^ entries].	^ entries select: [:entry | 		entry isDirectory or: [patterns anySatisfy: [:each | each match: entry first]]]! !!Morph methodsFor: 'drop shadows' stamp: 'ar 11/12/2000 18:57'!removeDropShadow	self hasDropShadow ifFalse:[^self].	self changed.	self hasDropShadow: false.	fullBounds ifNotNil:[fullBounds := self privateFullBounds].	self changed.! !!TextContainer methodsFor: 'private' stamp: 'ar 10/26/2000 20:04'!bounds	| bounds theText |	self fillsOwner ifFalse: [^ textMorph textBounds].	theText := textMorph.	bounds := theText owner innerBounds.	bounds := bounds insetBy: (textMorph valueOfProperty: #margins ifAbsent: [1@1]).	theText owner submorphsBehind: theText do:		[:m | bounds := bounds merge: m fullBounds].	^ bounds! !!TextMorph class methodsFor: 'class initialization' stamp: 'nk 11/9/2003 09:58'!initialize	"TextMorph initialize"		"Initialize constants shared by classes associated with text display."	CaretForm := (ColorForm extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -2@0)					colors: (Array with: Color transparent with: Preferences textHighlightColor).	self registerInFlapsRegistry.! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'RAA 3/31/1999 12:15'!selectionOneOf: aListOfItems	"Set the selection to the first item in the list which is represented by one of my submorphs"	| index |	aListOfItems do: [ :item |		index := scroller submorphs findFirst: [:m | 			m withoutListWrapper = item withoutListWrapper		].		index > 0 ifTrue: [^self selectionIndex: index].	].	self selectionIndex: 0.! !!MenuMorph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 14:23'!justDroppedInto: aMorph event: evt	| halo |	super justDroppedInto: aMorph event: evt.	halo := evt hand halo.	(halo notNil and:[halo target hasOwner: self]) ifTrue:[		"Grabbed single menu item"		self addHalo: evt.	].	stayUp ifFalse:[evt hand newMouseFocus: self].! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'ar 12/30/2001 20:48'!fitContents	| newExtent f |	f := self fontToUse.	newExtent := (((f widthOfString: contents) max: self minimumWidth) min: self maximumWidth)  @ f height.	(self extent = newExtent) ifFalse:		[self extent: newExtent.		self changed]! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:28'!newFileStreamFrom: aDirectory	| sfmResult fileStream |	sfmResult := self newFileFrom: aDirectory.	sfmResult ifNil: [^nil].	fileStream := sfmResult directory newFileNamed: sfmResult name.	[fileStream isNil] whileTrue:		[sfmResult := self newFileFrom: aDirectory.		sfmResult ifNil: [^nil].		fileStream := sfmResult directory newFileNamed: sfmResult name].	^fileStream! !!MouseOverHandler methodsFor: 'initialize-release' stamp: 'ar 9/28/2000 17:08'!initialize	mouseOverMorphs := #().! !!TextFieldMorph methodsFor: 'just like textMorph' stamp: 'tk 9/6/2000 11:03'!append: stringOrText	"add to my text"	| tm |	(tm := self findA: TextMorph) ifNil: [^ nil].	tm contents append: stringOrText.	tm releaseParagraph; paragraph.	! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:59'!trackRealJoystick	| s |	s := FillInTheBlank		request: 'Number of joystick to track?'		initialAnswer: '1'.	s isEmpty ifTrue: [^ self].	realJoystickIndex := Number readFromString: s.	self startStepping.! !!PluggableListMorph methodsFor: 'events' stamp: 'ls 6/22/2001 23:58'!mouseEnterDragging: evt	(evt hand hasSubmorphs and:[self dropEnabled]) ifFalse: ["no d&d"		^super mouseEnterDragging: evt].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt )		ifTrue:[			potentialDropRow := self rowAtLocation: evt position.			evt hand newMouseFocus: self.			self changed.			"above is ugly but necessary for now"		].! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 11:50'!hScrollBarValue: scrollValue	| x |	self hIsScrollbarShowing ifFalse: 		[^scroller offset: (0 - self hMargin)@scroller offset y].	((x := self hLeftoverScrollRange * scrollValue) <= 0)		ifTrue:[x := 0 - self hMargin].	scroller offset: (x@scroller offset y)! !!SimpleButtonMorph methodsFor: 'accessing' stamp: ''!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!BalloonMorph methodsFor: 'private' stamp: 'sma 12/23/1999 14:06'!setTarget: aMorph	(target := aMorph) ifNotNil: [offsetFromTarget := self position - target position]! !!PluggableMultiColumnListMorph methodsFor: 'accessing' stamp: 'nk 4/5/2001 23:18'!itemFromPoint: aPoint	"Return the list element (morph) at the given point or nil if outside"	| ptY |	scroller hasSubmorphs ifFalse:[^nil].	(scroller fullBounds containsPoint: aPoint) ifFalse:[^nil].	ptY := (scroller firstSubmorph point: aPoint from: self) y.	"note: following assumes that submorphs are vertical, non-overlapping, and ordered"	scroller firstSubmorph top > ptY ifTrue:[^nil].	scroller lastSubmorph bottom < ptY ifTrue:[^nil].	"now use binary search"	^scroller submorphThat: [ :item | item top <= ptY and:[item bottom >= ptY] ] ifNone: [].! !!SelectionMorph methodsFor: 'halo commands' stamp: 'dgd 9/20/2004 13:41'!alignCentersVertically	"Make every morph in the selection have the same horizontal center as the topmost item."	| minTop topMost |	selectedItems size > 1 ifFalse: [^ self].	minTop := (selectedItems collect: [:itm | itm top]) min.	topMost := selectedItems detect: [:m | m top = minTop].	selectedItems do:		[:itm | itm center: (topMost center x @ itm center y)].	self changed! !!TransformMorph methodsFor: 'accessing' stamp: 'jm 4/17/1998 05:23'!scale: newScale	self changed.	transform := transform withScale: newScale.	self layoutChanged.	self changed.! !!ColorMappingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:22'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	| oldCanvas |	oldCanvas := myCanvas.	myCanvas translateBy: delta during:[:newCanvas|		myCanvas := newCanvas.		aBlock value: self].	myCanvas := oldCanvas.! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomOffset: anInteger	bottomOffset := anInteger! !!PolygonMorph methodsFor: 'halo control' stamp: 'di 9/24/2000 09:42'!rotationDegrees: degrees 	| flex center |	(center := self valueOfProperty: #referencePosition) ifNil:		[self setProperty: #referencePosition toValue: (center := self bounds center)].	flex := (MorphicTransform offset: center negated)			withAngle: (degrees - self forwardDirection) degreesToRadians.	self setVertices: (vertices collect: [:v | (flex transform: v) - flex offset]).	self forwardDirection: degrees.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'nk 10/16/2003 14:02'!removeAllMorphsIn: aCollection	"greatly speeds up the removal of *lots* of submorphs"	| set myWorld |	set := IdentitySet new: aCollection size * 4 // 3.	aCollection do: [:each | each owner == self ifTrue: [ set add: each]].	myWorld := self world.	(fullBounds notNil or:[myWorld notNil]) ifTrue:[self invalidRect: self fullBounds].	set do: [:m | myWorld ifNotNil: [ m outOfWorld: myWorld ]. m privateOwner: nil].	submorphs := submorphs reject: [ :each | set includes: each].	set do: [ :m | self removedMorph: m ].	self layoutChanged.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 8/8/2001 14:26'!image: aForm at: aPoint sourceRect: sourceRect rule: rule alpha: sourceAlpha	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm := aForm.	combinationRule := rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBitsTranslucent: (alpha := (sourceAlpha * 255) truncated min: 255 max: 0).! !!PasteUpMorph methodsFor: 'world state' stamp: 'sw 7/10/2005 03:55'!abandonVocabularyPreference	"Remove any memory of a preferred vocabulary in the project"	| standardViewers aVocabulary |	self removeProperty: #currentVocabularySymbol.	standardViewers := (self submorphsSatisfying: [:m | m isKindOf: ViewerFlapTab]) collect:		[:m | m referent firstSubmorph].	aVocabulary := Vocabulary vocabularyNamed: #eToy.	standardViewers do:		[:m | ((m valueOfProperty: #currentVocabularySymbol ifAbsent: [nil]) == #Vector) ifTrue:			[m switchToVocabulary: aVocabulary]]"ActiveWorld abandonVocabularyPreference"! !!TransformationMorph methodsFor: 'initialization' stamp: 'di 9/30/1998 23:12'!flexing: aMorph byTransformation: tfm	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	(aMorph isKindOf: TransformationMorph)		ifTrue: [aMorph submorphsDo: [:m | self addMorph: m clone]]		ifFalse: [self addMorph: aMorph].	transform := tfm.	self chooseSmoothing.	self layoutChanged.! !!Morph methodsFor: 'e-toy support' stamp: 'RAA 2/5/2001 15:35'!wrappedInWindowWithTitle: aTitle	| aWindow w2 |	aWindow := (SystemWindow labelled: aTitle) model: Model new.	aWindow addMorph: self frame: (0@0 extent: 1@1).	w2 := aWindow borderWidth * 2.	w2 := 3.		"oh, well"	aWindow extent: self fullBounds extent + (0 @ aWindow labelHeight) + (w2 @ w2).	^ aWindow! !!UpdatingStringMorph methodsFor: 'formats' stamp: ''!useStringFormat	format := #string.! !!SketchMorph methodsFor: 'menu' stamp: 'wiz 12/4/2006 00:32'!insertIntoMovie: evt	| movies aTarget |	movies :=		(self world rootMorphsAt: evt hand targetPoint)			select: [:m | ((m isKindOf: MovieMorph) or:						 [m isSketchMorph]) and: [m ~= self]].	movies isEmpty ifTrue: [^ self].	aTarget := movies first.	(aTarget isSketchMorph) ifTrue: [		aTarget := aTarget replaceSelfWithMovie].	aTarget insertFrames: (Array with: self).	self delete.! !!MorphicModel methodsFor: 'initialization' stamp: 'jm 8/20/1998 09:08'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model := anObject.! !!Morph methodsFor: 'menus' stamp: 'dgd 11/15/2003 19:25'!addCopyItemsTo: aMenu	"Add copy-like items to the halo menu"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'copy to paste buffer' translated action: #copyToPasteBuffer:.	subMenu add: 'copy text' translated action: #clipText.	subMenu add: 'copy Postscript' translated action: #clipPostscript.	subMenu add: 'print Postscript to file...' translated target: self selector: #printPSToFile.	aMenu add: 'copy & print...' translated subMenu: subMenu! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 9/9/2000 11:41'!shapeFromPen: penBlock color: c borderWidth: bw borderColor: bc	"World addMorph: (PolygonMorph		shapeFromPen: [:p | p hilbert: 4 side: 5. p go: 5.						p hilbert: 4 side: 5. p go: 5]		color: Color red borderWidth: 1 borderColor: Color black)"	| pen |	penBlock value: (pen := PenPointRecorder new).	^ (self vertices: pen points asArray color: c borderWidth: bw borderColor: bc)		quickFill: false! !!StringMorph methodsFor: 'menu' stamp: 'ar 1/5/2002 21:45'!changeFont	| newFont |	newFont := StrikeFont fromUser: self fontToUse.	newFont ifNotNil:[self font: newFont].! !!PasteUpMorph methodsFor: 'world state' stamp: 'nk 7/7/2003 11:15'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen	without stopMorph, and possibly without anything above it."	| c |	c := ColorPatchCanvas		extent: patchRect extent		depth: Display depth		origin: patchRect topLeft negated		clipRect: (0@0 extent: patchRect extent).	c stopMorph: stopMorph.	c doStop: stopThere.	(self bounds containsRect: patchRect) ifFalse:		["Need to fill area outside bounds with black."		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse:		["Nothing within bounds to show."		^ c form].	self fullDrawOn: c.	stopThere ifFalse: [ self world handsReverseDo: [:h | h drawSubmorphsOn: c]].	^c form! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:03'!wrapDirection	"Layout specific. This property describes the direction along which a list-like layout should be wrapped. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop		#none	indicating in which direction wrapping should occur. This direction must be orthogonal to the list direction, that is if listDirection is #leftToRight or #rightToLeft then wrapDirection must be #topToBottom or #bottomToTop and vice versa."	| props |	props := self layoutProperties.	^props ifNil:[#none] ifNotNil:[props wrapDirection].! !!Morph methodsFor: 'player' stamp: 'sw 2/19/1999 09:06'!assuredPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer := self player) ifNil:		[self assureExternalName.  "a default may be given if not named yet"		self player: (aPlayer := self newPlayerInstance).  			"Different morphs may demand different player types"		aPlayer costume: self.		self presenter ifNotNil: [self presenter flushPlayerListCache]].	^ aPlayer! !!BalloonMorph methodsFor: 'initialization' stamp: 'RAA 7/1/2001 18:48'!popUpForHand: aHand	"Pop up the receiver as balloon help for the given hand"	| worldBounds |	self lock.	self fullBounds. "force layout"	self setProperty: #morphicLayerNumber toValue: self morphicLayerNumber.	aHand world addMorphFront: self.	"So that if the translation below makes it overlap the receiver, it won't	interfere with the rootMorphsAt: logic and hence cause flashing.  Without	this, flashing happens, believe me!!"	((worldBounds := aHand world bounds) containsRect: self bounds) ifFalse:		[self bounds: (self bounds translatedToBeWithin: worldBounds)].	aHand balloonHelp: self.! !!SimpleHierarchicalListMorph methodsFor: 'initialization' stamp: 'ar 3/17/2001 17:39'!list: aCollection	| wereExpanded morphList |	wereExpanded := self currentlyExpanded.	scroller removeAllMorphs.	(aCollection isNil or: [aCollection isEmpty]) ifTrue: [^ self selectedMorph: nil].	morphList := OrderedCollection new.	self 		addMorphsTo: morphList		from: aCollection 		allowSorting: false		withExpandedItems: wereExpanded		atLevel: 0.	self insertNewMorphs: morphList.! !!TextLine methodsFor: 'accessing' stamp: 'di 10/20/97 23:27'!stop: stopInteger 	"Set the stopping point in the string of the line to be stopInteger."	lastIndex := stopInteger! !!Morph methodsFor: 'accessing' stamp: 'sw 11/26/2001 16:16'!setBorderStyle: aSymbol	"Set the border style of my costume"	| aStyle |	aStyle := self borderStyleForSymbol: aSymbol.	aStyle ifNil: [^ self].	(self canDrawBorder: aStyle)		ifTrue:			[self borderStyle: aStyle]! !!StringMorph methodsFor: 'printing' stamp: 'efc 2/22/2003 21:35'!font: aFont 	"Set the font my text will use. The emphasis remains unchanged."	font := aFont.	^ self font: font emphasis: emphasis! !!TextMorphCommandHistory methodsFor: 'command exec' stamp: 'sps 7/24/2003 16:42'!removeUndoneCommands"Remove all of the commands at the end of history until the first one that is not marked #undone"	history reversed do: [ :command |		(command phase == #done) ifTrue:[			lastCommand := command.			^self		]ifFalse:[			history remove: command.		].	].		"If there were no #done commands on the stack, then get rid of lastCommand"	lastCommand := nil.! !!IconicButton methodsFor: 'as yet unclassified' stamp: 'di 2/17/2000 20:30'!labelGraphic: aForm	| oldLabel graphicalMorph |	(oldLabel := self findA: SketchMorph)		ifNotNil: [oldLabel delete].	graphicalMorph := SketchMorph withForm: aForm.	self extent: graphicalMorph extent + (borderWidth + 6).	graphicalMorph position: self center - (graphicalMorph extent // 2).	self addMorph: graphicalMorph.	graphicalMorph lock! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:55'!deferred: aBoolean	deferred == aBoolean ifTrue:[^self].	self flush. "Force pending prims on screen"	deferred := aBoolean.	engine ifNotNil:[engine deferred: aBoolean].! !!Morph methodsFor: 'testing' stamp: 'RAA 10/20/2000 14:47'!completeModificationHash"World completeModificationHash"	| resultSize result here i |	resultSize := 10.	result := ByteArray new: resultSize.	self allMorphsDo: [ :each | 		here := each modificationHash.		here withIndexDo: [ :ch :index |			i := index \\ resultSize + 1.			result at: i put: ((result at: i) bitXor: ch asciiValue)		].	].	^result! !!MorphicEvent methodsFor: 'objects from disk' stamp: 'RAA 12/21/2000 11:35'!convertToCurrentVersion: varDict refStream: smartRefStrm		| answer |	"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	varDict at: 'cursorPoint' ifPresent: [ :x | 		answer := self convertOctober2000: varDict using: smartRefStrm.		varDict removeKey: 'cursorPoint'.	"avoid doing this again"		^answer	].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 3/24/2001 23:58'!makeNewDrawingWithin	"Start a painting session in my interior which will result in a new SketchMorph being created as one of my submorphs"	| evt |	evt := MouseEvent new setType: nil position: self center buttons: 0 hand: self world activeHand.	self makeNewDrawing: evt! !!DoCommandOnceMorph methodsFor: 'as yet unclassified' stamp: 'RAA 7/7/2000 11:49'!actionBlock: aBlock	actionBlock := aBlock! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/14/2000 12:15'!addAlarm: aSelector withArguments: args at: scheduledTime	"Add an alarm (that is an action to be executed once) with the given set of parameters"	| scheduler |	scheduler := self alarmScheduler.	scheduler ifNotNil:[scheduler addAlarm: aSelector withArguments: args for: self at: scheduledTime].! !!Morph methodsFor: 'private' stamp: ''!privateBounds: boundsRect	"Private!! Use position: and/or extent: instead."	fullBounds := nil.	bounds := boundsRect.! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:35'!modalFileSelector	| window |	window := self morphicViewFileSelector.	window openCenteredInWorld.	self modalLoopOn: window.	^(window valueOfProperty: #fileListModel) getSelectedFile! !!Morph methodsFor: 'submorphs-accessing' stamp: ''!allMorphs	"Return a collection containing all morphs in this composite morph (including the receiver)."	| all |	all := OrderedCollection new: 100.	self allMorphsDo: [: m | all add: m].	^ all! !!TheWorldMainDockingBar methodsFor: 'menu actions' stamp: 'dgd 9/9/2004 18:15'!publishStyle: aSymbol forgetURL: aBoolean withRename: renameBoolean	| w primaryServer rename |	w := self world ifNil: [^Beeper beep].	w setProperty: #SuperSwikiPublishOptions toValue: aSymbol.	primaryServer := w project primaryServerIfNil: [nil].	rename := ((primaryServer notNil		and: [primaryServer acceptsUploads]) not)		or: [renameBoolean].	w setProperty: #SuperSwikiRename toValue: rename.	w project 		storeOnServerShowProgressOn: self 		forgetURL: aBoolean | rename.! !!WorldState methodsFor: 'alarms' stamp: 'ar 9/11/2000 17:11'!adjustAlarmTimes: nowTime	"Adjust the alarm times after some clock weirdness (such as roll-over, image-startup etc)"	| deltaTime |	deltaTime := nowTime - lastAlarmTime.	self alarms do:[:alarm| alarm scheduledTime: alarm scheduledTime + deltaTime].! !!FileList class methodsFor: 'instance creation' stamp: 'sw 1/25/2001 08:45'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView underPane pHeight |	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	dir := FileDirectory default.	aFileList := self new directory: dir.	topView := StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView := PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView := PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	aFileList wantsOptionalButtons		ifTrue:			[underPane := aFileList optionalButtonView.			underPane isNil				ifTrue: [pHeight := 60]				ifFalse: [					topView addSubView: underPane toRightOf: volListView.					pHeight := 60 - aFileList optionalButtonHeight]]		ifFalse:			[underPane := nil.			pHeight := 60].	fileListView := PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@pHeight).	underPane isNil		ifTrue: [topView addSubView: fileListView toRightOf: volListView]		ifFalse: [topView addSubView: fileListView below: underPane].	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	fileContentsView := PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 8/13/2003 11:39'!dropMorph: aMorph event: anEvent	"Drop the given morph which was carried by the hand"	| event dropped |	(anEvent isMouseUp and:[aMorph shouldDropOnMouseUp not]) ifTrue:[^self].	"Note: For robustness in drag and drop handling we remove the morph BEFORE we drop him, but we keep his owner set to the hand. This prevents system lockups when there is a problem in drop handling (for example if there's an error in #wantsToBeDroppedInto:). THIS TECHNIQUE IS NOT RECOMMENDED FOR CASUAL USE."	self privateRemove: aMorph.	aMorph privateOwner: self.	dropped := aMorph.	(dropped hasProperty: #addedFlexAtGrab) 		ifTrue:[dropped := aMorph removeFlexShell].	event := DropEvent new setPosition: self position contents: dropped hand: self.	self sendEvent: event focus: nil.	event wasHandled ifFalse:[aMorph rejectDropMorphEvent: event].	aMorph owner == self ifTrue:[aMorph delete].	self mouseOverHandler processMouseOver: anEvent.! !!TheWorldMenu methodsFor: 'commands' stamp: 'RAA 5/25/2000 07:42'!newMorphOfClass: morphClass event: evt	"Attach a new morph of the given class to the invoking hand."	| m |	m := morphClass new.	m installModelIn: myWorld.  "a chance to install model pointers"	m wantsToBeOpenedInWorld		ifTrue:[myWorld addMorph: m]		ifFalse:[evt hand attachMorph: m].	myWorld startSteppingSubmorphsOf: m.! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 2/13/2001 21:07'!ensuredEngine	engine ifNil:[		engine := BalloonEngine new.		"engine := BalloonDebugEngine new"		engine aaLevel: aaLevel.		engine bitBlt: port.		engine destOffset: origin.		engine clipRect: clipRect.		engine deferred: deferred.		engine].	engine colorTransform: colorTransform.	engine edgeTransform: transform.	^engine! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 9/8/2000 16:41'!numberAtCursor	"Answer the number represented by the object at my current cursor position"	| chosenMorph |	submorphs isEmpty ifTrue: [^ 0].	chosenMorph := submorphs at: ((cursor truncated max: 1) min: submorphs size).	^ chosenMorph getNumericValue! !!SelectionMorph methodsFor: 'visual properties' stamp: 'di 9/19/2000 21:53'!fillStyle: aColor	undoProperties ifNil: [undoProperties := selectedItems collect: [:m | m fillStyle]].	selectedItems do: [:m | m fillStyle: aColor]! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 9/9/1998 13:15'!originalForm: aForm	originalForm := aForm! !!SelectionMorph methodsFor: 'halo commands' stamp: 'sw 4/19/2005 18:14'!duplicate	"Make a duplicate of the receiver and havbe the hand grab it"	selectedItems := self duplicateMorphCollection: selectedItems.	selectedItems reverseDo: [:m | (owner ifNil: [ActiveWorld]) addMorph: m].	dupLoc := self position.	ActiveHand grabMorph: self.	ActiveWorld presenter flushPlayerListCache! !!PolygonMorph methodsFor: 'smoothing' stamp: 'nk 4/23/2002 15:48'!straightLineSegmentsDo: endPointsBlock	"Emit a sequence of segment endpoints into endPointsBlock.	Work the same way regardless of whether I'm curved."	| beginPoint |	beginPoint := nil.		vertices do:			[:vert | beginPoint ifNotNil:				[endPointsBlock value: beginPoint								value: vert].			beginPoint := vert].		(closed or: [vertices size = 1])			ifTrue: [endPointsBlock value: beginPoint									value: vertices first].! !!TextContainer class methodsFor: 'class initialization' stamp: 'di 11/16/97 09:25'!initialize    "TextContainer initialize"	OuterMargin := 2! !!TextMorphEditor methodsFor: 'editing keys' stamp: 'tk 5/7/2001 09:10'!chooseColor	| attribute |	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"	ColorPickerMorph new		choseModalityFromPreference;		sourceHand: morph activeHand;		target: (attribute := TextColor color: Color black "default");		selector: #color:;		originalColor: Color black;		putUpFor: morph near: morph fullBoundsInWorld.	^ attribute! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'sw 9/29/1999 07:37'!adjustBookControls	| inner |	proceedButton ifNil: [^ self].	proceedButton align: proceedButton topLeft with: (inner := self innerBounds) topLeft + (35@-4).	debugButton align: debugButton topRight with: inner topRight - (16@4).! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'md 10/20/2004 15:32'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel getRawListSelector: getRawSel	self model: anObject.	getListSelector := getListSel.	getIndexSelector := getSelectionSel.	setIndexSelector := setSelectionSel.	getMenuSelector := getMenuSel.	keystrokeActionSelector := keyActionSel.	autoDeselect := true.	self borderWidth: 1.	getRawListSelector := getRawSel.	self updateList.	self selectionIndex: self getCurrentSelectionIndex.	self initForKeystrokes! !!HaloMorph methodsFor: 'event handling' stamp: 'tk 7/14/2001 11:04'!mouseMove: evt	"Drag our target around"	| thePoint |	thePoint := target point: (evt position - positionOffset) from: owner.	target setConstrainedPosition: thePoint hangOut: true.! !!ScriptEditorMorph class methodsFor: 'instance creation' stamp: 'tk 1/31/2001 09:48'!writingUniversalTiles: boolean	WritingUniversalTiles := boolean! !!Morph methodsFor: 'WiW support' stamp: 'RAA 7/16/2000 13:54'!randomBoundsFor: aMorph	| trialRect |	trialRect := (		self topLeft + 			((self width * (15 + 75 atRandom/100)) rounded @			(self height * (15 + 75 atRandom/100)) rounded)	) extent: aMorph extent.	^trialRect translateBy: (trialRect amountToTranslateWithin: self bounds)! !!TextMorph methodsFor: 'scripting access' stamp: 'sw 9/15/2000 06:14'!getAllButFirstCharacter	"Obtain all but the first character from the receiver; if that would be empty, return a black dot"	| aString |	^ (aString := text string) size > 1 ifTrue: [aString copyFrom: 2 to: aString size] ifFalse: ['']! !!Morph methodsFor: 'private' stamp: ''!privateSubmorphs: aCollection	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	submorphs := aCollection.! !!PasteUpMorph methodsFor: 'painting' stamp: 'sw 10/17/2000 11:56'!backgroundSketch: aSketchMorphOrNil	"Set the receiver's background graphic as indicated.  If nil is supplied, remove any existing background graphic.  In any case, delete any preexisting background graphic."	backgroundMorph ifNotNil: [backgroundMorph delete].  "replacing old background"	aSketchMorphOrNil ifNil: [backgroundMorph := nil.  ^ self].	backgroundMorph := StickySketchMorph new form: aSketchMorphOrNil form.	backgroundMorph position: aSketchMorphOrNil position.	self addMorphBack: backgroundMorph.	aSketchMorphOrNil delete.	backgroundMorph lock.	backgroundMorph setProperty: #shared toValue: true.	^ backgroundMorph! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:39'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	| tempCanvas |	tempCanvas := self copyOffset: delta.	aBlock value: tempCanvas.	foundMorph := tempCanvas foundMorph.! !!HaloMorph methodsFor: 'handles' stamp: 'ar 1/30/2001 23:32'!positionIn: aBox horizontalPlacement: horiz verticalPlacement: vert	| xCoord yCoord |	horiz == #left		ifTrue:	[xCoord := aBox left].	horiz == #leftCenter		ifTrue:	[xCoord := aBox left + (aBox width // 4)].	horiz == #center		ifTrue:	[xCoord := (aBox left + aBox right) // 2].	horiz == #rightCenter		ifTrue:	[xCoord := aBox left + ((3 * aBox width) // 4)].	horiz == #right		ifTrue:	[xCoord := aBox right].	vert == #top		ifTrue:	[yCoord := aBox top].	vert == #topCenter		ifTrue:	[yCoord := aBox top + (aBox height // 4)].	vert == #center		ifTrue:	[yCoord := (aBox top + aBox bottom) // 2].	vert == #bottomCenter		ifTrue:	[yCoord := aBox top + ((3 * aBox height) // 4)].	vert == #bottom		ifTrue:	[yCoord := aBox bottom].	^ xCoord asInteger @ yCoord asInteger! !!PasteUpMorph methodsFor: 'flaps' stamp: 'sw 5/5/2001 00:27'!deleteGlobalFlapArtifacts	"Delete all flap-related detritus from the world"	| localFlaps |	localFlaps := self localFlapTabs collect: [:m | m referent].	self submorphs do:		[:m | 			((m isFlapTab) and: [m isGlobalFlap]) ifTrue: [m delete].			m isFlap ifTrue:[(localFlaps includes: m) ifFalse: [m delete]]]"ActiveWorld deleteGlobalFlapArtifacts"! !!TheWorldMenu methodsFor: 'action' stamp: 'ar 3/17/2001 23:46'!doMenuItem: aCollection with: event	| realTarget selector nArgs |	selector := aCollection second.	nArgs := selector numArgs.	realTarget := aCollection first.	realTarget == #myWorld ifTrue: [realTarget := myWorld].	realTarget == #myHand ifTrue: [realTarget := myHand].	realTarget == #myProject ifTrue: [realTarget := self projectForMyWorld].	^nArgs = 0 		ifTrue:[realTarget perform: selector]		ifFalse:[realTarget perform: selector with: event].! !!ComplexBorder methodsFor: 'private' stamp: 'ar 8/25/2001 16:16'!computeAltFramedColors	| base light dark w hw colorArray param |	base := self color asColor.	light := Color white.	dark := Color black.	w := self width isPoint ifTrue:[self width x max: self width y] ifFalse:[self width].	w := w asInteger.	w = 1 ifTrue:[^{base mixed: 0.5 with: light. base mixed: 0.5 with: dark}].	colorArray := Array new: w.	hw := w // 2.	"brighten"	0 to: hw-1 do:[:i|		param := 0.5 + (i asFloat / hw * 0.5).		colorArray at: i+1 put: (base mixed: param with: dark). "brighten"		colorArray at: w-i put: (base mixed: param with: light). "darken"	].	w odd ifTrue:[colorArray at: hw+1 put: base].	^colorArray, colorArray! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:28'!prompt: aString	 prompt := aString! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/1/98 16:59'!indicateCursor: aBoolean	indicateCursor := aBoolean! !!WorldState class methodsFor: 'class initialization' stamp: 'RAA 7/15/2000 12:56'!initialize	"WorldState initialize"	MinCycleLapse := 20.		"allows 50 frames per second..."	DisableDeferredUpdates := false.	DeferredUIMessages := SharedQueue new.! !!Morph methodsFor: 'menus' stamp: 'sw 4/12/2005 23:13'!addHaloActionsTo: aMenu	"Add items to aMenu representing actions requestable via halo"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu addTitle: self externalName.	subMenu addStayUpItemSpecial.	subMenu addLine.	subMenu add: 'delete' translated action: #dismissViaHalo.	subMenu balloonTextForLastItem: 'Delete this object -- warning -- can be destructive!!' translated.	self maybeAddCollapseItemTo: subMenu.	subMenu add: 'grab' translated action: #openInHand.	subMenu balloonTextForLastItem: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' translated.	subMenu addLine.	subMenu add: 'resize' translated action: #resizeFromMenu.	subMenu balloonTextForLastItem: 'Change the size of this object' translated.	subMenu add: 'duplicate' translated action: #maybeDuplicateMorph.	subMenu balloonTextForLastItem: 'Hand me a copy of this object' translated.	"Note that this allows access to the non-instancing duplicate even when this is a uniclass instance"	self couldMakeSibling ifTrue:		[subMenu add: 'make a sibling' translated action: #handUserASibling.		subMenu balloonTextForLastItem: 'Make a new sibling of this object and hand it to me' translated].	subMenu addLine.	subMenu add: 'property sheet' translated target: self renderedMorph action: #openAPropertySheet.	subMenu balloonTextForLastItem: 'Open a property sheet for me. Allows changing lots of stuff at once.' translated.	subMenu add: 'set color' translated target: self renderedMorph action: #changeColor.	subMenu balloonTextForLastItem: 'Change the color of this object' translated.	subMenu add: 'viewer' translated target: self action: #beViewed.	subMenu balloonTextForLastItem: 'Open a Viewer that will allow everything about this object to be seen and controlled.' translated.	subMenu add: 'tile browser' translated target: self action: #openInstanceBrowserWithTiles.	subMenu balloonTextForLastItem: 'Open a tool that will facilitate tile scripting of this object.' translated.	subMenu add: 'hand me a tile' translated target: self action: #tearOffTile.	subMenu balloonTextForLastItem: 'Hand me a tile represting this object' translated.	subMenu addLine.	subMenu add: 'inspect' translated target: self action: #inspect.	subMenu balloonTextForLastItem: 'Open an Inspector on this object' translated.	aMenu add: 'halo actions...' translated subMenu: subMenu! !!Morph methodsFor: 'visual properties' stamp: 'ar 6/18/1999 07:05'!fillStyle: aFillStyle	"Set the current fillStyle of the receiver."	self setProperty: #fillStyle toValue: aFillStyle.	"Workaround for Morphs not yet converted"	color := aFillStyle asColor.	self changed.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!arguments: aCollection	arguments := aCollection.! !!Morph methodsFor: 'fileIn/out' stamp: 'tak 2/10/2006 02:24'!prepareToBeSaved	"Prepare this morph to be saved to disk. Subclasses should nil out any instance variables that holds state that should not be saved, such as cached Forms. Note that this operation may take more drastic measures than releaseCachedState; for example, it might discard the transcript of an interactive chat session."	self releaseCachedState.	self formerOwner: nil.	self formerPosition: nil.	self removeProperty: #undoGrabCommand.	fullBounds := nil! !!MorphExtension methodsFor: 'accessing' stamp: 'di 8/10/1998 12:56'!eventHandler: newValue	eventHandler := newValue! !!FileList methodsFor: 'file list menu' stamp: 'nk 11/16/2002 13:00'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 services |	firstItems := self itemsForFile: self fullName.	secondItems := self itemsForAnyFile.	thirdItems := self itemsForNoFile.	n1 := firstItems size.	n2 := n1 + secondItems size.	n3 := n2 + thirdItems size.	services := firstItems, secondItems, thirdItems, self serviceAllFileOptions.	services do: [ :svc | svc addDependent: self ].	^ aMenu 		addServices2: services 		for: self		extraLines: (Array with: n1 with: n2 with: n3)! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 2/15/2001 20:04'!showSourceInScriptor	"Remove tile panes, if any, and show textual source instead"	| aCodePane |	self isTextuallyCoded ifFalse: [self becomeTextuallyCoded].		"Mostly to fix up grandfathered ScriptEditors"	self removeAllButFirstSubmorph.	aCodePane := MethodHolder 		isolatedCodePaneForClass: playerScripted class 		selector: scriptName.	aCodePane		hResizing: #spaceFill;		vResizing: #spaceFill;		minHeight: 100.	self 		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self addMorphBack: aCodePane.	self fullBounds.	self 		listDirection: #topToBottom;		hResizing: #rigid;		vResizing: #rigid;		rubberBandCells: true;		minWidth: self width.	showingMethodPane := true.	self currentWorld startSteppingSubmorphsOf: self! !!Morph methodsFor: 'copying' stamp: 'sw 4/19/2005 17:02'!duplicate	"Make and return a duplicate of the receiver"	| newMorph aName w aPlayer topRend |	((topRend := self topRendererOrSelf) ~~ self) ifTrue: [^ topRend duplicate].	self okayToDuplicate ifFalse: [^ self].	aName := (w := self world) ifNotNil:		[w nameForCopyIfAlreadyNamed: self].	newMorph := self veryDeepCopy.	aName ifNotNil: [newMorph setNameTo: aName].	newMorph arrangeToStartStepping.	newMorph privateOwner: nil. "no longer in world"	newMorph isPartsDonor: false. "no longer parts donor"	(aPlayer := newMorph player) belongsToUniClass ifTrue:		[aPlayer class bringScriptsUpToDate].	aPlayer ifNotNil: [ActiveWorld presenter flushPlayerListCache].	^ newMorph! !!WorldState methodsFor: 'stepping' stamp: 'ar 2/23/2001 21:14'!cleanseStepListForWorld: aWorld	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."	| deletions morphToStep |	deletions := nil.	stepList do: [:entry |		morphToStep := entry receiver.		morphToStep world == aWorld ifFalse:[			deletions ifNil: [deletions := OrderedCollection new].			deletions addLast: entry]].	deletions ifNotNil:[		deletions do: [:entry|			self stopStepping: entry receiver]].	self alarms copy do:[:entry|		morphToStep := entry receiver.		(morphToStep isMorph and:[morphToStep world == aWorld]) 			ifFalse:[self removeAlarm: entry selector for: entry receiver]].! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFolderSelectorForProjectLoad	| window fileModel w |	window := self morphicViewProjectLoader2InWorld: self currentWorld reallyLoad: false.	fileModel := window valueOfProperty: #FileList.	w := self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	window openInWorld: w.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!ProgressBarMorph methodsFor: 'accessing' stamp: 'sma 3/3/2000 18:53'!value: aModel	value ifNotNil: [value removeDependent: self].	value := aModel.	value ifNotNil: [value addDependent: self]! !!TextContainer methodsFor: 'container protocol' stamp: 'di 11/16/97 09:33'!top	"Note we should really check for contiguous pixels here"	| outerWidth |	outerWidth := minWidth + (2*OuterMargin).	^ (self vertProfile findFirst: [:count | count >= outerWidth]) - 1		+ shadowForm offset y! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 12/19/2000 19:23'!endDrawing: evt	"If painting is already underway	in the receiver, finish and save it."	| editor |	(editor := self sketchEditorOrNil) ifNotNil:[		editor save: evt.		Cursor normal show.	].! !!PluggableListMorphByItem methodsFor: 'model access' stamp: 'ls 8/19/2001 14:51'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector == nil ifTrue: [^ 0].	item := model perform: getIndexSelector.	^ list findFirst: [ :x | x = item]! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 5/29/1999 08:59'!transformBy: aDisplayTransform during: aBlock	| myTransform result |	myTransform := transform.	self transformBy: aDisplayTransform.	result := aBlock value: self.	transform := myTransform.	^result! !!TableLayoutProperties methodsFor: 'initialize' stamp: 'ar 11/14/2000 17:45'!initialize	super initialize.	cellSpacing := listSpacing := wrapDirection := #none.	cellPositioning := #center.	listCentering := wrapCentering := #topLeft.	listDirection := #topToBottom.	reverseTableCells := rubberBandCells := false.	layoutInset := cellInset := minCellSize := 0.	maxCellSize := 1073741823. "SmallInteger maxVal"! !!PluggableMultiColumnListMorph methodsFor: 'initialization' stamp: 'ls 5/17/2001 21:16'!list: arrayOfLists 	| listOfStrings |	lists := arrayOfLists.	scroller removeAllMorphs.	listOfStrings := arrayOfLists == nil				ifTrue: [Array new]				ifFalse: [					arrayOfLists isEmpty ifFalse: [					arrayOfLists at: 1]].	list := listOfStrings				ifNil: [Array new].	self listMorph listChanged..	self setScrollDeltas.	scrollBar setValue: 0.0! !!Morph class methodsFor: 'testing' stamp: 'yo 3/17/2005 09:07'!allSketchMorphForms	"Answer a Set of forms of SketchMorph (sub) instances, except those 	used as button images, ones being edited, and those with 0 extent."	| reasonableForms form |	reasonableForms := Set new.	Morph allSketchMorphClasses do:		[:cls | cls allInstances do:			[:m | (m owner isKindOf: SketchEditorMorph orOf: IconicButton)				ifFalse:					[form := m form.					((form width > 0) and: [form height > 0]) ifTrue: [reasonableForms add: form]]]].	^ reasonableForms! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'nk 2/14/2004 18:19'!initialize	"initialize the state of the receiver"	super initialize.	hasUnacceptedEdits := false.	hasEditingConflicts := false.	askBeforeDiscardingEdits := true.! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'sw 2/15/98 03:49'!recolor: c	self color: c.	oldColor := c! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/28/2000 12:10'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt := (BitBlt current toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: self viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect := r translateBy: self viewBox origin.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!UpdatingStringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:44'!initialize	"Initialie the receiver to have default values in its instance 	variables "	super initialize.""	format := #default.	"formats: #string, #default"	target := getSelector := putSelector := nil.	floatPrecision := 1.	growable := true.	stepTime := 50.	autoAcceptOnFocusLoss := true.	minimumWidth := 8.	maximumWidth := 300! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:50'!exportAsBMP	| fName |	fName := FillInTheBlank request:'Please enter the name' translated initialAnswer: self externalName,'.bmp'.	fName isEmpty ifTrue:[^self].	self imageForm writeBMPfileNamed: fName.! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 9/8/2000 16:35'!getIndexInOwner	"Answer which position the receiver holds in its owner's hierarchy"	"NB: There is some concern about submorphs that aren't really to be counted, such as a background morph of a playfield."	| container topRenderer |	container := (topRenderer := self topRendererOrSelf) owner.	^ container submorphIndexOf: topRenderer.! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:57'!assureTableProperties	| props |	props := self layoutProperties.	props == self ifTrue:[props := nil].	props ifNil:[		props := TableLayoutProperties new initializeFrom: self.		self layoutProperties: props].	props includesTableProperties 		ifFalse:[self layoutProperties: (props := props asTableLayoutProperties)].	^props! !!EditCommand methodsFor: 'accessors' stamp: 'sps 1/5/2002 16:37'!replacedText: aText	^replacedText := aText! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'rhi 12/6/2001 11:06'!exploreIt	| result |	self handleEdit: [		result := textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [result explore]].! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'ar 9/18/2000 12:16'!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j emphasis |	menu := self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString := aPopupMenu labelString.	items := labelString asString findTokens: String cr.	labelString isText ifTrue:		["Pass along text emphasis if present"		j := 1.		items := items collect:			[:item | j := labelString asString findString: item startingAt: j.			emphasis := TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines := aPopupMenu lineArray.	lines ifNil: [lines := #()].	menu cancelValue: 0.	menu defaultTarget: menu.	selections := (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) selector: #selectMVCItem: argument: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction: aNumber offset: anInteger	leftFraction := aNumber.	leftOffset := anInteger! !!MenuMorph methodsFor: 'modal control' stamp: 'sw 2/3/2002 14:26'!invokeModal	"Invoke this menu and don't return until the user has chosen a value.	See example below on how to use modal menu morphs."	^ self invokeModal: Preferences menuKeyboardControl	"Example:	| menu sub entry |	menu := MenuMorph new.	1 to: 3 do: [:i |		entry := 'Line', i printString.		sub := MenuMorph new.		menu add: entry subMenu: sub.		#('Item A' 'Item B' 'Item C')  do:[:subEntry|			sub add: subEntry target: menu 				selector: #modalSelection: argument: {entry. subEntry}]].	menu invokeModal."! !!ColorMappingCanvas methodsFor: 'initialization' stamp: 'ar 8/8/2001 14:14'!on: aCanvas	myCanvas := aCanvas.! !!NewParagraph methodsFor: 'private' stamp: 'di 10/21/97 21:36'!positionWhenComposed: pos	positionWhenComposed := pos! !!MorphicModel methodsFor: 'compilation' stamp: 'tk 4/18/97'!compileAccessForSlot: aSlotName	"Write the method to get at this inst var.  "	"Instead call the right thing to make this happen?"	| s  |	s := WriteStream on: (String new: 2000).	s nextPutAll: aSlotName; cr; tab; nextPutAll: '^', aSlotName.	self class		compile: s contents		classified: 'public access'		notifying: nil.! !!SystemWindow methodsFor: 'menu' stamp: 'md 2/24/2006 15:37'!setWindowColor: incomingColor	| existingColor aColor |	incomingColor ifNil: [^ self].  "it happens"	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor 		or: [aColor = Color black]) ifTrue: [^ self].	existingColor := self paneColorToUse.	existingColor ifNil: [^ Beeper beep].	self paneColor: aColor.	self setStripeColorsFrom: aColor.	self changed.! !!HaloMorph methodsFor: 'stepping' stamp: 'ar 8/8/2001 15:44'!fadeInInitially	| max |	max := self isMagicHalo ifTrue:[0.3] ifFalse:[1.0].	self magicAlpha >= max ifTrue:[self stopSteppingSelector: #fadeInInitially].	self magicAlpha: ((self magicAlpha + (max * 0.1)) min: max)! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'kfr 11/14/2004 13:20'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval := textMorph editor selectionInterval.	selRects := textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest := selRects first merge: selRects last.	transform := scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere := transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest := selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest := selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect := transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta := selRect amountToTranslateWithin: self innerBounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!TheWorldMenu class methodsFor: 'open-menu registry' stamp: 'nk 6/29/2003 13:55'!registry	"Answer the registry of dynamic open commands"		^OpenMenuRegistry ifNil: [OpenMenuRegistry := OrderedCollection new].! !!SystemWindow methodsFor: 'geometry' stamp: 'ar 10/5/2000 20:05'!justDroppedInto: aMorph event: anEvent	isCollapsed		ifTrue: [self position: ((self position max: 0@0) grid: 8@8).				collapsedFrame := self bounds]		ifFalse: [fullFrame := self bounds.				TopWindow ~~ self ifTrue: [self activate]].	^super justDroppedInto: aMorph event: anEvent! !!MenuMorph methodsFor: 'modal control' stamp: 'KLC 4/11/2004 09:06'!invokeModalAt: aPoint in: aWorld allowKeyboard: aBoolean	"Invoke this menu and don't return until the user has chosen a value.	See senders of this method for finding out how to use modal menu morphs."	| w originalFocusHolder |	originalFocusHolder := aWorld primaryHand keyboardFocus.	self popUpAt: aPoint forHand: aWorld primaryHand in: aWorld allowKeyboard: aBoolean.	self isModalInvokationDone: false.	w := aWorld outermostWorldMorph. "containing hand"	[self isInWorld & self isModalInvokationDone not] whileTrue: [w doOneSubCycle].	self delete.	originalFocusHolder ifNotNil: [aWorld primaryHand newKeyboardFocus: originalFocusHolder].	^ self modalSelection! !!Morph methodsFor: 'meta-actions' stamp: 'yo 3/15/2005 14:45'!blueButtonDown: anEvent	"Special gestures (cmd-mouse on the Macintosh; Alt-mouse on Windows and Unix) allow a mouse-sensitive morph to be moved or bring up a halo for the morph."	| h tfm doNotDrag |	h := anEvent hand halo.	"Prevent wrap around halo transfers originating from throwing the event back in"	doNotDrag := false.	h ifNotNil:[		(h innerTarget == self) ifTrue:[doNotDrag := true].		(h innerTarget hasOwner: self) ifTrue:[doNotDrag := true].		(self hasOwner: h target) ifTrue:[doNotDrag := true]].	tfm := (self transformedFrom: nil) inverseTransformation.	"cmd-drag on flexed morphs works better this way"	h := self addHalo: (anEvent transformedBy: tfm).	h ifNil: [^ self].	doNotDrag ifTrue:[^self].	"Initiate drag transition if requested"	anEvent hand 		waitForClicksOrDrag: h		event: (anEvent transformedBy: tfm)		selectors: { nil. nil. nil. #dragTarget:. }		threshold: 5.	"Pass focus explicitly here"	anEvent hand newMouseFocus: h.! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'sw 11/5/2001 15:11'!inARow: aCollectionOfMorphs	"Answer a row-oriented AlignmentMorph holding the given collection"	| aRow |	aRow := self newRow		color: Color transparent;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 1;		borderColor: Color black;		borderWidth: 1;		wrapCentering: #center;		cellPositioning: #topCenter.	aCollectionOfMorphs do: [ :each | aRow addMorphBack: each].	^ aRow! !!FormCanvas methodsFor: 'private' stamp: 'yo 6/18/2004 15:11'!privateWarp: aForm transform: aTransform at: extraOffset sourceRect: sourceRect cellSize: cellSize	"Warp the given using the appropriate transform and offset."	| globalRect sourceQuad warp tfm |	tfm := aTransform.	globalRect := tfm localBoundsToGlobal: sourceRect.	sourceQuad := (tfm sourceQuadFor: globalRect) collect:[:p| p - sourceRect topLeft].	extraOffset ifNotNil:[globalRect := globalRect translateBy: extraOffset].     warp := (WarpBlt current toForm: port destForm)                combinationRule: Form paint;                sourceQuad: sourceQuad destRect: (globalRect origin corner: globalRect corner+(1@1));                clipRect: port clipRect.	warp cellSize: cellSize.	warp sourceForm: aForm.	warp warpBits! !!HaloMorph methodsFor: 'meta-actions' stamp: 'jcg 9/21/2001 13:18'!blueButtonDown: event	"Transfer the halo to the next likely recipient"	target ifNil:[^self delete].	event hand obtainHalo: self.	positionOffset := event position - (target point: target position in: owner).	self isMagicHalo ifTrue:[		self isMagicHalo: false.		^self magicAlpha: 1.0].	"wait for drags or transfer"	event hand 		waitForClicksOrDrag: self 		event: event		selectors: { #transferHalo:. nil. nil. #dragTarget:. }		threshold: 5.! !!SimpleHierarchicalListMorph methodsFor: 'event handling' stamp: 'ar 3/17/2001 17:26'!mouseEnterDragging: evt	| aMorph |	(evt hand hasSubmorphs and:[self dropEnabled]) ifFalse: ["no d&d"		^super mouseEnterDragging: evt].	(self wantsDroppedMorph: evt hand firstSubmorph event: evt )		ifTrue:[			aMorph := self itemFromPoint: evt position.			aMorph ifNotNil:[self potentialDropMorph: aMorph].			evt hand newMouseFocus: self.			"above is ugly but necessary for now"		].! !!PasteUpMorph methodsFor: 'accessing' stamp: 'tk 7/17/2001 16:07'!flapTab	| ww |	self isFlap ifFalse:[^nil].	ww := self world ifNil: [World].	^ww flapTabs detect:[:any| any referent == self] ifNone:[nil]! !!PolygonMorph methodsFor: 'menu' stamp: '6/9/97 21:32 di'!makeBothArrows	arrows := #both.	self computeBounds! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!extent: extentPoint	super extent: extentPoint.	transform := nil.! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'di 9/28/2000 12:05'!buildChartForm	| chartForm |	chartForm := ColorChart deepCopy asFormOfDepth: Display depth.	chartForm fill: ((TransparentBox left + 9)@0 extent: 1@9) fillColor: Color lightGray.	chartForm fill: ((TransparentBox right - 10)@0 extent: 1@9) fillColor: Color lightGray.	TransText displayOn: chartForm at: 62@0.	Display depth = 32 ifTrue:		["Set opaque bits for 32-bit display"		chartForm fill: chartForm boundingBox rule: Form under				fillColor: (Color r: 0.0 g: 0.0 b: 0.0 alpha: 1.0)].	chartForm borderWidth: 1.	self form: chartForm.	selectedColor ifNotNil: [self updateAlpha: selectedColor alpha].	self updateSelectorDisplay.! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:58'!viewBox: x	viewBox := x! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:33'!modalFolderSelector: aDir	| window fileModel |	window := self morphicViewFolderSelector: aDir.	fileModel := window model.	window openInWorld: self currentWorld extent: 300@400.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!TextMorphCommandHistory methodsFor: 'command exec' stamp: 'sps 7/23/2003 18:58'!rememberCommand: aCommand	"Make the supplied command be the 'LastCommand', and mark it 'done'"	"Before adding the new command, remove any commands after the last #done 	command, and make that last #done command be lastCommand."	self removeUndoneCommands.	aCommand phase: #done.			"If we are building a compound command, just add the new command to that"	history addLast: aCommand.	lastCommand := aCommand."Debug dShow: ('Remember: ', commandToUse asString)."! !!FormCanvas methodsFor: 'private' stamp: 'ar 5/25/2000 17:25'!resetGrafPort	"Private!! Create a new grafPort for a new copy."	port := self portClass toForm: form.	port clipRect: clipRect.! !!JoystickMorph methodsFor: 'stepping and presenter' stamp: 'bf 9/5/2005 11:19'!step	"Track the real joystick whose index is realJoystickIndex."	"Details:	  a. if realJoystickIndex is nil we're not tracking a joystick	  b. [-joyMax..joyMax] is nominal range of joystick in both X and Y	  c. [-threshold..threshold] is considered 0 to compensate for poor joystick centering"	| threshold joyMax joyPt joyBtn m mCenter r scaledPt  |	super step.  "Run ticking user-written scripts if any"	realJoystickIndex ifNil: [^ self].	threshold := 30.	joyMax := 350.	joyPt := Sensor joystickXY: realJoystickIndex.	joyBtn := Sensor joystickButtons: realJoystickIndex.	button1 := (joyBtn bitAnd: 1) > 0.	button2 := (joyBtn bitAnd: 2) > 0.		joyPt x abs < threshold ifTrue: [joyPt := 0@joyPt y].	joyPt y abs < threshold ifTrue: [joyPt := joyPt x@0].	lastRealJoystickValue = joyPt ifTrue: [^ self].	lastRealJoystickValue := joyPt.	m := handleMorph.	mCenter := m center.	r := m owner innerBounds insetBy:		((mCenter - m fullBounds origin) corner: (m fullBounds corner - mCenter)).	scaledPt := r center + ((r extent * joyPt) / (joyMax * 2)) truncated.	m position: (scaledPt adhereTo: r) - (m extent // 2).! !!ScrollBar methodsFor: 'initialize' stamp: 'RAA 7/28/2000 10:12'!upArrow8Bit	"convert to 8-bit and convert white to transparent to avoid gratuitous conversion every time we put one in an ImageMorph"	^UpArrow8Bit ifNil: [		UpArrow8Bit := (ColorForm mappingWhiteToTransparentFrom: UpArrow) asFormOfDepth: 8	]! !!FlattenEncoder methodsFor: 'writing' stamp: 'MPW 1/4/1901 08:25'!writeCollectionContents:aCollection separator:separator iterationMessage:op	| first |	first := true.	aCollection perform:op with: [ :each |  first ifFalse:[ self writeObject:separator ]. self write:each. first:=false.].! !!HaloMorph methodsFor: 'private' stamp: 'dgd 9/29/2004 19:56'!setDismissColor: evt with: dismissHandle	"Called on mouseStillDown in the dismiss handle; set the color appropriately."	| colorToUse |	evt hand obtainHalo: self.	colorToUse :=  (dismissHandle containsPoint: evt cursorPoint)		ifFalse:			[Color red muchLighter]		ifTrue:			[Color lightGray].	self setColor: colorToUse toHandle: dismissHandle.! !!FileList methodsFor: 'private' stamp: 'sw 11/30/2002 16:34'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name := self fileNameFromFormattedItem: (list at: listIndex)].	sortMode := newMode.	self pattern: pattern.	name ifNotNil: [		fileName := name.		listIndex := list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents].	self updateButtonRow! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 10/22/2000 16:36'!startStepping: aSelector at: scheduledTime arguments: args stepTime: stepTime	"Start stepping the receiver"	| w |	w := self world.	w ifNotNil: [		w startStepping: self at: scheduledTime selector: aSelector arguments: args stepTime: stepTime.		self changed].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:58'!listCentering	"Layout specific. This property describes how the rows/columns in a list-like layout should be centered.		#topLeft - center at start of primary direction		#bottomRight - center at end of primary direction		#center - center in the middle of primary direction		#justified - insert extra space inbetween rows/columns	"	| props |	props := self layoutProperties.	^props ifNil:[#topLeft] ifNotNil:[props listCentering].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectBottom: rect height: h	destX := rect left + 1.	destY := rect bottom - 1.	width := rect width - 2.	height := 1.	1 to: h do: [:i |		self copyBits.		destX := destX + 1.		destY := destY - 1.		width := width - 2].! !!MovieMorph methodsFor: 'menu' stamp: ''!stopPlaying	playMode := #stop.	self setFrame: 1.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'ar 10/8/2000 23:42'!attachMorph: m	"Position the center of the given morph under this hand, then grab it.	This method is used to grab far away or newly created morphs."	| delta |	self releaseMouseFocus. "Break focus"	delta := m bounds extent // 2.	m position: (self position - delta).	m formerPosition: m position.	targetOffset := m position - self position.	self addMorphBack: m.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/24/2000 14:09'!disconnectRemoteUser	"Prompt for the initials of the remote user, then remove the remote hand with those initials, breaking its connection."	"select hand to remove"	| initials handToRemove |	initials := FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	initials isEmpty ifTrue: [^ self].  "abort"	handToRemove := nil.	self handsDo: [:h |		h userInitials = initials ifTrue: [handToRemove := h]].	handToRemove ifNil: [^ self].  "no hand with those initials"	handToRemove withdrawFromWorld.! !!HandMorph methodsFor: 'paste buffer' stamp: 'dgd 9/19/2004 13:49'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.' translated].	self attachMorph: (aPastee := self objectToPaste).	aPastee align: aPastee center with: self position.	aPastee player ifNotNil: [aPastee player startRunning]! !!TextMorph class methodsFor: 'parts bin' stamp: 'sw 6/13/2001 21:58'!exampleBackgroundLabel	"Answer a background label for a parts bin"	| aTextMorph |	aTextMorph := self authoringPrototype.	aTextMorph contents: 'backgroundlabel' asText.  	aTextMorph beAllFont: (StrikeFont familyName: #NewYork size: 18).	aTextMorph color: Color brown.	aTextMorph setProperty: #shared toValue: true.	^ aTextMorph! !!MorphicModel methodsFor: 'compilation' stamp: ''!addPartNameLike: className withValue: aMorph	| otherNames i default partName stem |	stem := className first asLowercase asString , className allButFirst.	otherNames := self class allInstVarNames.	i := 1.	[otherNames includes: (default := stem, i printString)]		whileTrue: [i := i + 1].	partName := FillInTheBlank		request: 'Please give this part a name'		initialAnswer: default.	(otherNames includes: partName)		ifTrue: [self inform: 'Sorry, that name is already used'. ^ nil].	self class addInstVarName: partName.	self instVarAt: self class instSize put: aMorph.  "Assumes added as last field"	^ partName! !!ScrollBar methodsFor: 'access' stamp: 'dew 2/21/1999 03:08'!interval: d	"Supply an optional floating fraction so slider can expand to indicate range"	interval := d min: 1.0.	self expandSlider.	self computeSlider.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawGeneralPolygon: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general polygon (e.g., a polygon that can contain holes)"	| fillC borderC |	fillC := self shadowColor ifNil:[c].	borderC := self shadowColor ifNil:[borderColor].	self ensuredEngine		drawGeneralPolygon: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm := aForm.	combinationRule := rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!Morph methodsFor: 'menus' stamp: 'nk 2/15/2004 08:19'!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	self mustBeBackmost ifFalse:		[aMenu add: 'send to back' translated action: #goBehind.		aMenu add: 'bring to front' translated action: #comeToFront.		self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.		aMenu addLine].	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addBorderStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	owner isTextMorph ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addStackItemsTo: aMenu.	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu			add: ('unlock "{1}"' translated format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!ImageMorph methodsFor: 'drawing' stamp: 'dgd 9/7/2004 17:24'!drawOn: aCanvas	| style |	(style := self borderStyle) ifNotNil:[		style frameRectangle: bounds on: aCanvas.	].	self isOpaque		ifTrue:[aCanvas drawImage: image at: self innerBounds origin]		ifFalse:[aCanvas translucentImage: image at: self innerBounds origin]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'di 10/18/2001 03:33'!grabDrawingFromScreen: evt	"Allow the user to specify a rectangular area of the Display, capture the pixels from that area, and use them to create a new drawing morph. Attach the result to the hand."	| m |	m := self drawingClass new form: Form fromUser.	evt hand position: Sensor cursorPoint.  "update hand pos after Sensor loop in fromUser"	evt hand attachMorph: m.! !!TextMorph methodsFor: 'linked frames' stamp: 'di 7/28/2001 10:34'!addPredecessor: evt	| newMorph |	newMorph := self copy predecessor: predecessor successor: self.	newMorph extent: self width @ 100.	predecessor ifNotNil: [predecessor setSuccessor: newMorph].	self setPredecessor: newMorph.	predecessor recomposeChain.	evt hand attachMorph: newMorph! !!MorphicEvent methodsFor: 'private' stamp: 'ar 10/25/2000 21:26'!setHand: aHand	source := aHand! !!SketchMorph methodsFor: 'other' stamp: 'jm 7/24/97 15:06'!replaceSelfWithMovie	"Replace this SketchMorph in its owner with a MovieMorph containing this sketch as its only frame. This allows a SketchMorph to be turned into a MovieMorph by just insering additional frames."	| o movie |	self changed.	o := self owner.	movie := MovieMorph new position: self referencePosition.	movie insertFrames: (Array with: self).	o ifNil: [^ movie].	o addMorphFront: movie.	^ movie! !!PluggableListMorph methodsFor: 'selection' stamp: 'sw 10/30/2000 11:16'!setGetListSelector: sel	"Set the the receiver's getListSelector as indicated.  For access via scripting"	getListSelector := sel! !!SelectionMorph methodsFor: 'halo commands' stamp: 'dgd 9/20/2004 13:41'!alignCentersHorizontally	"Make every morph in the selection have the same vertical center as the topmost item."	| minLeft leftMost |	selectedItems size > 1 ifFalse: [^ self].	minLeft := (selectedItems collect: [:itm | itm left]) min.	leftMost := selectedItems detect: [:m | m left = minLeft].	selectedItems do:		[:itm | itm center: (itm center x @ leftMost center y)].	self changed! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/3/2000 17:05'!mouseDownOnHelpHandle: anEvent	"The mouse went down in the show-balloon handle"		| str |	anEvent shiftPressed ifTrue: [^ self editBalloonHelpText].	str := self balloonText.	str ifNil: [str := self noHelpString].	self showBalloon: str hand: anEvent hand.! !!HaloSpec methodsFor: 'as yet unclassified' stamp: 'sw 1/25/2000 19:54'!horizontalPlacement: hp verticalPlacement: vp color: col iconSymbol: is addHandleSelector: sel	horizontalPlacement := hp.	verticalPlacement := vp.	color:= col.	iconSymbol := is asSymbol.	addHandleSelector := sel! !!MovieMorph methodsFor: 'private' stamp: ''!insertFrames: newFrames	"Insert the given collection of frames into this movie just after the currentrame."	frameList isEmpty ifTrue: [		frameList := newFrames asArray copy.		self setFrame: 1.		^ self].	frameList :=		frameList			copyReplaceFrom: currentFrameIndex + 1  "insert before"			to: currentFrameIndex			with: newFrames.! !!TransformationMorph methodsFor: 'geometry' stamp: 'ar 4/18/2000 16:21'!extent: newExtent	| scaleFactor |	self adjustAfter:		[scaleFactor := (self scale * newExtent r / self fullBounds extent r) max: 0.1.		self scale: (scaleFactor detentBy: 0.1 atMultiplesOf: 1.0 snap: false)]! !!FileList2 class methodsFor: 'morphic ui' stamp: 'RAA 1/8/2001 21:39'!morphicViewNoFile	| dir aFileList window midLine fixedSize |	dir := FileDirectory default.	aFileList := self new directory: dir.	window := (SystemWindow labelled: dir pathName) model: aFileList.	fixedSize := 25.	midLine := 0.4.	self addFullPanesTo: window from: {		{aFileList morphicPatternPane. 0@0 corner: 0.3@0. 0@0 corner: 0@fixedSize}.		{aFileList optionalButtonRow. 0.3 @ 0 corner: 1@0. 0@0 corner: 0@fixedSize}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1. 0@fixedSize corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1. 0@fixedSize corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!MorphicModel methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:47'!initialize	"initialize the state of the receiver"	super initialize.""	open := false! !!NewParagraph methodsFor: 'private' stamp: 'di 11/8/97 15:47'!adjustLineIndicesBy: delta	firstCharacterIndex := firstCharacterIndex + delta.	lines do: [:line | line slide: delta].! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 22:03'!oldFileFrom: aDirectory	canTypeFileName := false.	^self makeFileMenuFor: aDirectory! !!StringMorph methodsFor: 'accessing' stamp: ''!contentsClipped: aString	"Change my text, but do not change my size as a result"	contents = aString ifTrue: [^ self].  "No substantive change"	contents := aString.	self changed! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 7/5/2005 21:46'!initialize	super initialize.		self hResizing: #spaceFill.	self vResizing: #spaceFill.	splitsTopAndBottom := false.		leftOrTop := OrderedCollection new.	rightOrBottom := OrderedCollection new! !!TextMorph methodsFor: 'initialization' stamp: 'di 7/27/2001 11:56'!initialize	super initialize.	borderWidth := 0.	textStyle := TextStyle default copy.	wrapFlag := true.! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 10/30/2000 16:33'!allClassVarNamesInSystem	"Compute and answer a set of all the class variable names known to the sytem from any class"	| aList |	aList := OrderedCollection new.	Object withAllSubclasses do:		[:c | aList addAll: c allClassVarNames].	^ aList asSet	"ScriptingSystem allClassVarNamesInSystem"! !!ComplexProgressIndicator methodsFor: 'as yet unclassified' stamp: 'RAA 5/23/2000 10:02'!loadingHistoryDataForKey: anObject	| answer |	answer := specificHistory 		at: anObject		ifAbsentPut: [OrderedCollection new].	answer size > 50 ifTrue: [		answer := answer copyFrom: 25 to: answer size.		specificHistory at: anObject put: answer.	].	^answer! !!PasteUpMorph methodsFor: 'events-processing' stamp: 'ar 4/5/2001 21:42'!processEvent: anEvent using: defaultDispatcher	"Reimplemented to install the receiver as the new ActiveWorld if it is one"	| priorWorld result |	self isWorldMorph ifFalse:[^super processEvent: anEvent using: defaultDispatcher].	priorWorld := ActiveWorld.	ActiveWorld := self.	result := super processEvent: anEvent using: defaultDispatcher.	ActiveWorld := priorWorld.	^result! !!WorldState class methodsFor: 'as yet unclassified' stamp: 'RAA 8/14/2000 16:40'!canSurrenderToOS: aBoolean	CanSurrenderToOS := aBoolean! !!ThreePhaseButtonMorph methodsFor: 'geometry' stamp: 'tk 7/1/97 09:14'!extent: aPoint	"Do it normally"		self changed.	bounds := bounds topLeft extent: aPoint.	self layoutChanged.	self changed.! !!DoCommandOnceMorph methodsFor: 'stepping and presenter' stamp: 'RAA 7/29/2000 17:30'!step	| goForIt |	actionBlock ifNil: [^self stopStepping].	goForIt := actionBlock.	actionBlock := nil.	[		goForIt value.	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: innerArea].		"in case a save/load progress display needs a home"! !!PasteUpMorph methodsFor: 'world state' stamp: 'dgd 9/5/2004 16:19'!initForProject: aWorldState	worldState := aWorldState.	bounds := Display boundingBox.	self color: Preferences defaultWorldColor.	self addHand: HandMorph new.	self setProperty: #automaticPhraseExpansion toValue: true.	self setProperty: #optimumExtentFromAuthor toValue: Display extent.	self wantsMouseOverHalos: Preferences mouseOverHalos.	self borderWidth: 0.	model := nil.! !!TextMorph class methodsFor: 'parts bin' stamp: 'nk 9/2/2004 16:03'!borderedPrototype	| t |	t := self authoringPrototype.	t fontName: 'BitstreamVeraSans' pointSize: 24.	t autoFit: false; extent: 250@100.	t borderWidth: 1; margins: 4@0."Strangeness here in order to avoid two offset copies of the default contents when operating in an mvc project before cursor enters the morphic window"	t paragraph.	^ t! !!TheWorldMenu methodsFor: 'mechanics' stamp: 'RAA 5/24/2000 19:02'!world: aWorld project: aProject hand: aHand	myWorld := aWorld.	myProject := aProject.	myHand := aHand.! !!PasteUpMorph methodsFor: 'scripting' stamp: 'RAA 1/8/2001 15:17'!hideAllPlayers	| a |	a := OrderedCollection new.	self allMorphsDo: [ :x | 		(x isKindOf: ViewerFlapTab) ifTrue: [a add: x]	].	a do: [ :each | each delete].! !!WorldState methodsFor: 'update cycle' stamp: 'ar 1/22/2001 14:26'!doOneSubCycleFor: aWorld	"Like doOneCycle, but preserves activeHand."	| currentHand |	currentHand := ActiveHand.	self doOneCycleFor: aWorld.	ActiveHand := currentHand! !!ScrollPane methodsFor: 'scrolling' stamp: 'kfr 11/14/2004 10:29'!scrollToShow: aRectangle	"scroll to include as much of aRectangle as possible, where aRectangle is in the scroller's local space"	| range |	((aRectangle top - scroller offset y) >= 0 and: [		(aRectangle bottom - scroller offset y) <= (self innerBounds height) ])		ifTrue:[ "already visible"^self ].	range := self vLeftoverScrollRange.	scrollBar value: (range > 0		ifTrue: [((aRectangle top) / self vLeftoverScrollRange)							truncateTo: scrollBar scrollDelta]		ifFalse: [0]).	scroller offset: -3 @ (range * scrollBar value).! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 4/3/2006 14:03'!morphicViewProjectLoader2InWorld: aWorld reallyLoad: aBoolean dirFilterType: aSymbol	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b treeExtent filesExtent |	window := AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	aFileList := self new directory: FileDirectory default.	aFileList 		optionalButtonSpecs: aFileList servicesForProjectLoader;		fileSelectionBlock: (			aSymbol == #limitedSuperSwikiDirectoryList ifTrue: [				MessageSend receiver: self selector: #projectOnlySelectionMethod:			] ifFalse: [				self projectOnlySelectionBlock			]		);		"dirSelectionBlock: self hideSqueakletDirectoryBlock;"		modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: ColorTheme current dialogBorderWidth;		borderColor: ColorTheme current dialogBorderColor;		useRoundedCorners.	buttons := {{'OK'. ColorTheme current okColor}. {'Cancel'. ColorTheme current cancelColor}} collect: [ :each |		self blueButtonText: each first textColor: textColor1 color: each second inWindow: window	].	aWorld width < 800 ifTrue: [		treeExtent := 150@300.		filesExtent := 350@300.	] ifFalse: [		treeExtent := 250@300.		filesExtent := 350@300.	].	(treePane := aFileList morphicDirectoryTreePaneFiltered: aSymbol)		extent: treeExtent; 		retractable: false;		borderWidth: 0.	fileListPane := aFileList morphicFileListPane 		extent: filesExtent; 		retractable: false;		borderWidth: 0.	window		addARow: {			window fancyText: 'Load A Project' translated font: Preferences standardEToysTitleFont color: textColor1		};		addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second		};		addARow: {			window fancyText: 'Please select a project' translated  font: Preferences standardEToysFont color: textColor1		};		addARow: {				(window inAColumn: {(pane2a := window inARow: {window inAColumn: {treePane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.				(window inAColumn: {(pane2b := window inARow: {window inAColumn: {fileListPane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.		}.	window fullBounds.	window fillWithRamp: ColorTheme current dialogRampOrColor oriented: 0.65.	pane2a fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35).	pane2b fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35)."	buttons do: [ :each |		each fillWithRamp: ColorTheme current dialogButtonsRampOrColor oriented: (0.75 @ 0).	]."	buttons first 		on: #mouseUp 		send: (aBoolean ifTrue: [#okHitForProjectLoader] ifFalse: [#okHit])		to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	window adoptPaneColor: (Color r: 0.548 g: 0.677 b: 1.0).	window becomeModal.	^ window openInWorld: aWorld.! !!NewParagraph methodsFor: 'selection' stamp: 'ls 11/2/2001 23:10'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 := characterBlock1.  cb2 := characterBlock2]		ifFalse: [cb2 := characterBlock1.  cb1 := characterBlock2].	cb1 = cb2 ifTrue:		[w := self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 := self lineIndexForCharacter: cb1 stringIndex.	line2 := self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects := OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	line1+1 to: line2-1 do: [ :i |		| line |		line := lines at: i.		(line left = rects last left and: [ line right = rects last right ])			ifTrue: [ "new line has same margins as old one -- merge them, so that the caller gets as few rectangles as possible"					| lastRect |					lastRect := rects removeLast.					rects add: (lastRect bottom: line bottom) ]			ifFalse: [ "differing margins; cannot merge"					rects add: line rectangle ] ].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/27/2001 13:10'!wrapFlag: aBoolean	"Change whether contents are wrapped to the container."	aBoolean == wrapFlag ifTrue: [^ self].	wrapFlag := aBoolean.	self composeToBounds! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'ar 6/25/1999 11:33'!argument: anObject	argument := anObject! !!WorldState methodsFor: 'alarms' stamp: 'RAA 1/7/2001 12:33'!alarmSortBlock	| answer |	"Please pardon the hackery below. Since the block provided by this method is retained elsewhere, it is possible that the block argument variables would retain references to objects that were no longer really needed. In one case, this feature resulted in doubling the size of a published project."	^[ :alarm1 :alarm2 | 		answer := alarm1 scheduledTime < alarm2 scheduledTime.		alarm1 := alarm2 := nil.		answer	]! !!FileList methodsFor: 'file list menu' stamp: 'em 3/29/2005 12:25'!fullFileListMenu: aMenu shifted: aBoolean	"Fill the menu with all possible items for the file list pane, regardless of selection."	| lastProvider |	aMenu title: 'all possible file operations' translated.	Smalltalk isMorphic ifTrue: [aMenu addStayUpItemSpecial].	lastProvider := nil.	(self itemsForFile: 'a.*') do: [ :svc |		(lastProvider notNil and: [svc provider ~~ lastProvider])			ifTrue: [ aMenu addLine ].		svc addServiceFor: self toMenu: aMenu.		Smalltalk isMorphic ifTrue: [aMenu submorphs last setBalloonText: svc description].		lastProvider := svc provider.		svc addDependent: self.	].	^aMenu! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!updateContinuously: aBoolean	updateContinuously := aBoolean.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'ar 3/17/2001 20:16'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target := target adaptedToWorld: aWorld.! !!Morph methodsFor: 'naming' stamp: 'dgd 8/30/2003 15:52'!innocuousName	"Choose an innocuous name for the receiver -- one that does not end in the word Morph"	| className allKnownNames |	className := self defaultNameStemForInstances.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className := className copyFrom: 1 to: className size - 5].	className := className asString translated.	allKnownNames := self world ifNil: [OrderedCollection new] ifNotNil: [self world allKnownNames].	^ Utilities keyLike: className asString satisfying:		[:aName | (allKnownNames includes: aName) not]! !!SystemProgressMorph methodsFor: 'private' stamp: 'laza 5/28/2004 06:03'!freeSlot: number	number > 0 ifTrue: [		lock critical: [			(bars at: number) delete.			(labels at: number) delete.			activeSlots := activeSlots - 1.			activeSlots = 0				ifTrue: [self delete]				ifFalse: [self align: self fullBounds center with: Display boundingBox center]]]! !!Slider methodsFor: 'model access' stamp: ''!setValue: newValue	"Called internally for propagation to model"	self value: newValue.	self use: setValueSelector orMakeModelSelectorFor: 'Value:'		in: [:sel | setValueSelector := sel.  model perform: sel with: value]! !!TransferMorphLineAnimation methodsFor: 'initialization' stamp: 'di 9/9/2000 09:59'!initPolygon	polygon := (LineMorph from: self transferMorph source bounds center				to: self transferMorph bounds center				color: Color black width: 2)			dashedBorder: {10. 10. Color white}.	self addMorph: polygon! !!PolygonMorph methodsFor: 'geometry eToy' stamp: 'di 9/24/2000 09:31'!rotationCenter: aPointOrNil	"Set the new rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	| box |	aPointOrNil isNil		ifTrue: [self removeProperty: #referencePosition]		ifFalse: [box := self bounds.				self setProperty: #referencePosition					toValue: box origin + (aPointOrNil * box extent)]! !!SystemWindow methodsFor: 'panes' stamp: 'md 2/24/2006 15:46'!replacePane: oldPane with: newPane	"Make newPane exactly occupy the position and extent of oldPane"	| aLayoutFrame hadDep |	hadDep := model dependents includes: oldPane.	oldPane owner replaceSubmorph: oldPane by: newPane.	newPane		position: oldPane position;		extent: oldPane extent.	aLayoutFrame := oldPane layoutFrame.	paneMorphs := paneMorphs collect:		[:each |		each == oldPane ifTrue: [newPane] ifFalse: [each]].	aLayoutFrame ifNotNil: [newPane layoutFrame: aLayoutFrame].	newPane color: Color transparent.	hadDep ifTrue: [model removeDependent: oldPane. model addDependent: newPane].	self changed! !!TTSampleFontMorph methodsFor: 'private' stamp: 'ar 11/15/1998 22:48'!computeTransform	| fullExtent scale |	fullExtent := font bounds extent * 16.	scale := self extent asFloatPoint / fullExtent asFloatPoint.	transform := MatrixTransform2x3 withScale: scale.	transform := transform composedWithGlobal: (MatrixTransform2x3 withOffset: self position).	^transform! !!SystemWindow methodsFor: 'top window' stamp: 'sw 5/18/2001 23:20'!activate	"Bring me to the front and make me able to respond to mouse and keyboard"	| oldTop outerMorph sketchEditor pal |	outerMorph := self topRendererOrSelf.	outerMorph owner ifNil: [^ self "avoid spurious activate when drop in trash"].	oldTop := TopWindow.	TopWindow := self.	oldTop ifNotNil: [oldTop passivate].	outerMorph owner firstSubmorph == outerMorph		ifFalse: ["Bring me (with any flex) to the top if not already"				outerMorph owner addMorphFront: outerMorph].	self submorphsDo: [:m | m unlock].	labelArea ifNotNil:		[labelArea submorphsDo: [:m | m unlock].		self setStripeColorsFrom: self paneColorToUse].	self isCollapsed ifFalse:		[model modelWakeUpIn: self.		self positionSubmorphs.		labelArea ifNil: [self adjustBorderUponActivationWhenLabeless]].	(sketchEditor := self extantSketchEditor) ifNotNil:		[sketchEditor comeToFront.		(pal := self world findA: PaintBoxMorph) ifNotNil:			[pal comeToFront]].! !!HandMorph methodsFor: 'change reporting' stamp: 'ar 12/30/2001 17:32'!invalidRect: damageRect from: aMorph	"Note that a change has occurred and record the given damage rectangle relative to the origin this hand's cache."	hasChanged := true.	aMorph == self ifTrue:[^self].	damageRecorder recordInvalidRect: damageRect.! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 00:31'!font: aTTFontDescription	| morph |	font := aTTFontDescription.	morph := (TTSampleStringMorph font: font).	morph extent: morph extent * 2.	morph color: Color magenta.	self addMorphCentered: morph.	morph position: morph position x @ (self bounds bottom + 10).	self privateFullMoveBy: self fullBounds origin negated.! !!Morph methodsFor: 'private' stamp: ''!privateOwner: aMorph	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	owner := aMorph.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'sge 3/12/2004 05:51'!setLabel	| newLabel |	newLabel := FillInTheBlank		request: 'Please enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self labelString: newLabel].! !!StringMorph methodsFor: 'menu' stamp: 'yo 3/14/2005 13:03'!changeEmphasis	| reply aList |	aList := #(normal bold italic narrow underlined struckOut).	reply := (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ifNotNil:[		self emphasis: (TextEmphasis perform: reply) emphasisCode.	].! !!TransformMorph methodsFor: 'accessing' stamp: ''!offset: newOffset	transform := transform withOffset: newOffset - self innerBounds topLeft.	self changed! !!PasteUpMorph methodsFor: 'flaps' stamp: 'sw 4/17/2001 11:22'!localFlapTabs	"Answer a list of local flap tabs in the current project"	| globalList aList aFlapTab |	globalList := Flaps globalFlapTabsIfAny.	aList := OrderedCollection new.	submorphs do:		[:m | ((m isFlapTab) and: [(globalList includes: m) not])			ifTrue:				[aList add: m]			ifFalse:				[((m isFlap) and:					[(aFlapTab := m submorphs detect: [:n | n isFlapTab] ifNone: [nil]) notNil])						ifTrue:							[aList add: aFlapTab]]].	^ aList! !!PasteUpMorph methodsFor: 'scripting' stamp: 'RAA 1/8/2001 15:24'!showAllPlayers	| a |	a := OrderedCollection new.	self allMorphsDo: [ :x | 		(x player notNil and: [x player hasUserDefinedScripts]) ifTrue: [a add: x]	].	a do: [ :each | each openViewerForArgument].! !!SystemWindow methodsFor: 'geometry' stamp: 'JW 2/1/2001 13:15'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	| layoutBounds box frame left right top bottom |	layoutBounds := self layoutBounds.	paneMorphs do:[:m|		frame := m layoutFrame.		box := m bounds.		frame ifNotNil:[			left := box left - layoutBounds left - (frame leftOffset ifNil:[0]).			right := box right - layoutBounds left - (frame rightOffset ifNil:[0]).			top := box top - layoutBounds top - (frame topOffset ifNil:[0]).			bottom := box bottom - layoutBounds top - (frame bottomOffset ifNil:[0]).			frame leftFraction: (left / layoutBounds width asFloat).			frame rightFraction: (right / layoutBounds width asFloat).			frame topFraction: (top / layoutBounds height asFloat).			frame bottomFraction: (bottom / layoutBounds height asFloat).		].	].! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 16:57'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.playerScripted := deepCopier references at: playerScripted ifAbsent: [playerScripted].! !!Morph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:00'!basicInitialize	"Do basic generic initialization of the instance variables:  	Set up the receiver, created by a #basicNew and now ready to  	be initialized, by placing initial values in the instance variables  	as appropriate"owner := nil.	submorphs := EmptyArray.	bounds := self defaultBounds.		color := self defaultColor! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:52'!vResizing: aSymbol	vResizing := aSymbol! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 12/12/2001 11:36'!makeNewDrawing: evt at: aPoint	"make a new drawing, triggered by the given event, with the painting area centered around the given point"	| w newSketch newPlayer sketchEditor aPaintBox aPalette tfx whereToPresent rect ownerBeforeHack aPaintTab aWorld |	w := self world.	w assureNotPaintingElse: [^ self].	rect := self paintingBoundsAround: aPoint.	aPalette := self standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w prepareToPaint.	newSketch := self drawingClass new player: (newPlayer := UnscriptedPlayer newUserInstance).	newPlayer costume: newSketch.	newSketch nominalForm: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor := SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: self.	sketchEditor		afterNewPicDo: [:aForm :aRect |			whereToPresent := self presenter.			newSketch form: aForm.			tfx := self transformFrom: w.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch forwardDirection: sketchEditor forwardDirection.			ownerBeforeHack := newSketch owner.	"about to break the invariant!!!!"			newSketch privateOwner: self. "temp for halo access"			newPlayer setHeading: sketchEditor forwardDirection.			(aPaintTab := (aWorld := self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox := aWorld paintBox) ifNotNil:[aPaintBox delete]].			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			newSketch privateOwner: ownerBeforeHack. "probably nil, but let's be certain"			self addMorphFront: newPlayer costume.			w startSteppingSubmorphsOf: newSketch.			whereToPresent drawingJustCompleted: newSketch]		 ifNoBits:[			(aPaintTab := (aWorld := self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox := aWorld paintBox) ifNotNil:[aPaintBox delete]].			aPalette ifNotNil: [aPalette showNoPalette].]! !!Morph methodsFor: 'meta-actions' stamp: 'st 9/14/2004 12:30'!resizeMorph: evt	| handle |	handle := HandleMorph new forEachPointDo: [:newPoint | 		self extent: (self griddedPoint: newPoint) - self bounds topLeft].	evt hand attachMorph: handle.	handle startStepping.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'tk 3/11/2002 16:11'!insertUniversalTilesForClass: aClass selector: aSelector	"Add a submorph which holds the universal-tiles script for the given class and selector"	| source tree syn widget header |	source := aClass sourceCodeAt: aSelector ifAbsent: [		Transcript cr; show: aClass name, 'could not find selector ', aSelector.		^ self delete].    	tree := Compiler new 		parse: source 		in: aClass 		notifying: nil.	(syn := tree asMorphicSyntaxUsing: SyntaxMorph)		parsedInClass: aClass.	aSelector numArgs = 0 ifTrue: [		"remove method header line"		(header := syn findA: SelectorNode) ifNotNil: [header delete]].	syn removeReturnNode.		"if ^ self at end, remove it"	widget := syn inAScrollPane.	widget hResizing: #spaceFill;		vResizing: #spaceFill;		color: Color transparent;		setProperty: #hideUnneededScrollbars toValue: true.	self addMorphBack: widget.	(self hasProperty: #autoFitContents) ifFalse:		[self valueOfProperty: #sizeAtHibernate ifPresentDo:			[:oldExtent | self extent: oldExtent]].	syn finalAppearanceTweaks.! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'RAA 8/14/2000 14:22'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw the rectangle using the given attributes.	Note: This is a *very* simple implementation"	| bw pt |	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: bottomRightColor.	bottomRightColor = topLeftColor ifFalse: [		bw := borderWidth asPoint.		pt := r topLeft + (bw // 2).		self line: pt to: pt + ((r extent x - bw x)@0) width: borderWidth color: topLeftColor.		self line: pt to: pt + (0@(r extent y - bw y)) width: borderWidth color: topLeftColor.	].! !!PolygonMorph methodsFor: 'attachments' stamp: 'nk 5/31/2003 10:56'!endShapeWidth: aWidth	| originalWidth originalVertices transform |	originalWidth := self valueOfProperty: #originalWidth ifAbsentPut: [ self borderWidth isZero ifFalse: [ self borderWidth ] ifTrue: [ 2 ] ].	self borderWidth: aWidth.	originalVertices := self valueOfProperty: #originalVertices ifAbsentPut: [		self vertices collect: [ :ea | (ea - (self referencePosition)) rotateBy: self heading degreesToRadians about: 0@0 ]	].	transform := MorphicTransform offset: 0@0 angle: self heading degreesToRadians scale: originalWidth / aWidth.	self setVertices: (originalVertices collect: [ :ea |		((transform transform: ea) + self referencePosition) asIntegerPoint	]).	self computeBounds.! !!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/2/98 00:05'!target: anObject	target := anObject! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 10/8/2000 15:37'!morphsAt: aPoint unlocked: aBool do: aBlock	"Evaluate aBlock with all the morphs starting at the receiver which appear at aPoint. If aBool is true take only visible, unlocked morphs into account."	| tfm |	(self fullBounds containsPoint: aPoint) ifFalse:[^self].	(aBool and:[self isLocked or:[self visible not]]) ifTrue:[^self].	self submorphsDo:[:m|		tfm := m transformedFrom: self.		m morphsAt: (tfm globalPointToLocal: aPoint) unlocked: aBool do: aBlock].	(self containsPoint: aPoint) ifTrue:[aBlock value: self].! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'RAA 8/31/1999 08:36'!selection: item	"Called from outside to request setting a new selection.	Assumes scroller submorphs is exactly our list.	Note: MAY NOT work right if list includes repeated items"	| i |	item ifNil: [^self selectionIndex: 0].	i := scroller submorphs findFirst: [:m | m complexContents == item].	i > 0 ifTrue: [^self selectionIndex: i].	i := scroller submorphs findFirst: [:m | m withoutListWrapper = item withoutListWrapper].	self selectionIndex: i! !!MenuMorph methodsFor: 'menu' stamp: 'ar 9/18/2000 11:47'!detachSubMenu: evt	| possibleTargets item subMenu index |	possibleTargets := self items select:[:any| any hasSubMenu].	possibleTargets size > 0 ifTrue:[		index := PopUpMenu 				withCaption:'Which menu?' 				chooseFrom: (possibleTargets collect:[:t| t contents asString]).		index = 0 ifTrue:[^self]].	item := possibleTargets at: index.	subMenu := item subMenu.	subMenu ifNotNil: [		item subMenu: nil.		item delete.		subMenu stayUp: true.		subMenu popUpOwner: nil.		subMenu addTitle: item contents.		evt hand attachMorph: subMenu].! !!MenuMorph methodsFor: 'control' stamp: 'ar 3/18/2001 00:33'!popUpForHand: hand in: aWorld	| p |	"Present this menu under control of the given hand."	p := hand position truncated.	^self popUpAt: p forHand: hand in: aWorld! !!PasteUpMorph methodsFor: 'pen' stamp: 'nk 7/7/2003 11:17'!createOrResizeTrailsForm	"If necessary, create a new turtleTrailsForm or resize the existing one to fill my bounds.	On return, turtleTrailsForm exists and is the correct size.	Use the Display depth so that color comparisons (#color:sees: and #touchesColor:) will work right."	| newForm |	(turtleTrailsForm isNil or: [ turtleTrailsForm extent ~= self extent ]) ifTrue:		["resize TrailsForm if my size has changed"		newForm := Form extent: self extent depth: Display depth.		turtleTrailsForm ifNotNil: [			newForm copy: self bounds from: turtleTrailsForm					to: 0@0 rule: Form paint ].		turtleTrailsForm := newForm.		turtlePen := nil].	"Recreate Pen for this form"	turtlePen ifNil: [turtlePen := Pen newOnForm: turtleTrailsForm].! !!ColorPickerMorph class methodsFor: 'class initialization' stamp: 'ar 7/8/2006 20:32'!colorPaletteForDepth: depth extent: chartExtent	"Display a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorPaletteForDepth: 16 extent: 190@60) display"	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |	palette := Form extent: chartExtent depth: depth.	transCaption := "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt := transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth := 10.	startHue := 338.0.	vSteps := palette height - transHt // 2.	hSteps := palette width - grayWidth.	x := 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue := Color h: h asFloat s: 1.0 v: 1.0.		y := transHt+1.		0 to: vSteps do: [:n | 			c := basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		1 to: vSteps do: [:n | 			c := Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			palette fill: (x@y extent: 1@1) fillColor: c.			y := y + 1].		x := x + 1].	y := transHt + 1.	1 to: vSteps * 2 do: [:n | 		c := Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		palette fill: (x@y extent: 10@1) fillColor: c.		y := y + 1].	^ palette! !!ScriptEditorMorph methodsFor: 'other' stamp: 'sw 10/20/2004 23:09'!methodString	"Answer the source-code string for the receiver.  This is for use by classic tiles, but is also used in universal tiles to formulate an initial method declaration for a nascent user-defined script; in universalTiles mode, the codeString (at present anyway) is empty -- the actual code derives from the SyntaxMorph in that case"	| k methodNode string |	playerScripted class compileSilently: (string := String streamContents:		[:aStream |			aStream nextPutAll: scriptName.			scriptName endsWithAColon ifTrue:				[aStream nextPutAll: ' parameter'].			aStream cr; cr; tab.			aStream nextPutAll: self codeString.	]) classified: 'temporary'.	k := KedamaVectorizer new initialize.	(k includesTurtlePlayer: (playerScripted class decompile: scriptName) for: playerScripted) ifFalse: [^ string].	methodNode := k vectorize: (playerScripted class decompile: scriptName) 	object: playerScripted.	^ methodNode decompileString.! !!HandMorph methodsFor: 'listeners' stamp: 'ar 10/26/2000 01:27'!keyboardListeners: anArrayOrNil	keyboardListeners := anArrayOrNil! !!MenuItemMorph methodsFor: 'copying' stamp: 'sw 9/25/2002 03:24'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"	super veryDeepFixupWith: deepCopier.	target := deepCopier references at: target ifAbsent: [target].	arguments notNil ifTrue:	[arguments := arguments collect: [:each |		deepCopier references at: each ifAbsent: [each]]]! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/6/2000 00:09'!releaseAllFoci	mouseFocus := nil.	keyboardFocus := nil.! !!Morph methodsFor: 'geometry eToy' stamp: 'ar 9/22/2000 20:12'!referencePosition	"Return the current reference position of the receiver"	| box |	box := self bounds.	^box origin + (self rotationCenter * box extent).! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'dgd 9/1/2003 14:00'!chooseFrequency	| currentFrequency aMenu |	currentFrequency := self scriptInstantiation frequency.	currentFrequency = 0 ifTrue: [currentFrequency := 1].	aMenu := MenuMorph new defaultTarget: self.	#(1 2 5 10 25 50 100 1000 5000 10000) do:		[:i | aMenu add: i printString selector: #setFrequencyTo: argument: i].		aMenu add: 'other...' translated action: #typeInFrequency.	aMenu addTitle: ('Choose frequency (current: {1})' translated format: {currentFrequency}).	aMenu  popUpEvent: self currentEvent in: self world! !!Morph methodsFor: 'fileIn/out' stamp: 'yo 7/2/2004 13:14'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream ok |	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := FillInTheBlank request: 'File name? (".morph" will be added to end)' translated 			initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^ Beeper beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.morph'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName,'.morph'].	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!WorldState methodsFor: 'alarms' stamp: 'ar 10/22/2000 16:55'!triggerAlarmsBefore: nowTime	"Trigger all pending alarms that are to be executed before nowTime."	| pending |	lastAlarmTime ifNil:[lastAlarmTime := nowTime].	(nowTime < lastAlarmTime or:[nowTime - lastAlarmTime > 10000])		ifTrue:[self adjustAlarmTimes: nowTime].	pending := self alarms.	[pending isEmpty not and:[pending first scheduledTime < nowTime]]		whileTrue:[pending removeFirst value: nowTime].	lastAlarmTime := nowTime.! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'sw 11/2/2001 04:45'!inAColumn: aCollectionOfMorphs	"Answer a columnar AlignmentMorph holding the given collection"	| col |	col := self newColumn		color: Color transparent;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		layoutInset: 1;		borderColor: Color black;		borderWidth: 1;		wrapCentering: #center;		cellPositioning: #topCenter.	aCollectionOfMorphs do: [:each | col addMorphBack: each].	^ col! !!FormCanvas methodsFor: 'drawing-text' stamp: 'ar 2/5/2002 19:03'!drawString: aString from: firstIndex to: lastIndex at: aPoint font: fontOrNil color: c	| font |	port colorMap: nil.	font := fontOrNil ifNil: [TextStyle defaultFont].	port combinationRule: Form paint.	font installOn: port		foregroundColor: (self shadowColor ifNil:[c]) 		backgroundColor: Color transparent.	font displayString: aString on: port 		from: firstIndex to: lastIndex at: (origin + aPoint) kern: 0.! !!FileList2 methodsFor: 'private' stamp: 'TN 4/13/2005 18:32'!okHitForProjectLoader	| areaOfProgress |	fileName ifNil: [^ self].	ok := true.	areaOfProgress := modalView firstSubmorph.	[		areaOfProgress setProperty: #deleteOnProgressCompletion toValue: modalView.		self openProjectFromFile.		modalView delete.	"probably won't get here"	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: areaOfProgress].! !!WorldState methodsFor: 'update cycle' stamp: 'md 3/19/2006 22:16'!doOneCycleNowFor: aWorld	"Immediately do one cycle of the interaction loop.	This should not be called directly, but only via doOneCycleFor:"	| capturingGesture |	DisplayScreen checkForNewScreenSize.	capturingGesture := false.	"self flag: #bob.	"	"need to consider remote hands in lower worlds"	"process user input events"	LastCycleTime := Time millisecondClockValue.	self handsDo: [:h |		ActiveHand := h.		h processEvents.		capturingGesture := capturingGesture or: [ h isCapturingGesturePoints ].		ActiveHand := nil	].	"the default is the primary hand"	ActiveHand := self hands first.	"The gesture recognizer needs enough points to be accurate.	Therefore morph stepping is disabled while capturing points for the recognizer"	capturingGesture ifFalse: 		[aWorld runStepMethods.		"there are currently some variations here"		self displayWorldSafely: aWorld].! !!WorldState methodsFor: 'initialization' stamp: 'RAA 1/5/2001 10:47'!initialize	hands := Array new.	damageRecorder:= DamageRecorder new.	stepList := Heap sortBlock: self stepListSortBlock.	lastStepTime := 0.	lastAlarmTime := 0.! !!LayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:51'!hResizing: aSymbol	hResizing := aSymbol! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 23:06'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse:		[hasUnacceptedEdits := aBoolean.		self changed].	aBoolean ifFalse: [hasEditingConflicts := false]! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34'!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining := submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target := remaining first.		targetX := target layoutFrame rightFraction.		sameX := submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY := (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY := (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter := ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining := remaining copyWithoutAll: sameX].	remaining := submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target := remaining first.			targetY := target layoutFrame bottomFraction.			sameY := submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX := (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX := (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter := ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining := remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!MenuMorph class methodsFor: 'example' stamp: 'jm 11/4/97 07:46'!example	"MenuMorph example"	| menu |	menu := MenuMorph new.	menu addStayUpItem.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu! !!HandMorph methodsFor: 'balloon help' stamp: 'ar 10/3/2000 16:51'!balloonHelp: aBalloonMorph	"Return the balloon morph associated with this hand"	| oldHelp |	oldHelp := self balloonHelp.	oldHelp ifNotNil:[oldHelp delete].	aBalloonMorph		ifNil:[self removeProperty: #balloonHelpMorph]		ifNotNil:[self setProperty: #balloonHelpMorph toValue: aBalloonMorph]! !!ScriptEditorMorph methodsFor: 'copying' stamp: 'yo 3/11/2005 22:18'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."	super veryDeepInner: deepCopier.	scriptName := scriptName veryDeepCopyWith: deepCopier.	firstTileRow := firstTileRow veryDeepCopyWith: deepCopier.	timeStamp := timeStamp veryDeepCopyWith: deepCopier.	playerScripted := playerScripted.		"Weakly copied"	handWithTile := nil.  "Just a cache"	showingMethodPane := showingMethodPane.	"boolean"	threadPolygon := nil. "Just a cache".! !!PolygonMorph methodsFor: 'menu' stamp: 'di 8/20/2000 14:27'!makeOpen	closed := false.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!TextMorph methodsFor: 'accessing' stamp: 'kfr 9/21/2003 21:47'!getFirstCharacter	"obtain the first character from the receiver if it is empty, return a  	black dot"	| aString |	^ (aString := text string) isEmpty		ifTrue: ['']		ifFalse: [aString first asString] ! !!MorphicEventDispatcher methodsFor: 'dispatching' stamp: 'ar 10/10/2000 21:14'!dispatchMouseDown: anEvent with: aMorph	"Find the appropriate receiver for the event and let it handle it. Default rules:	* The top-most chain of visible, unlocked morphs containing the event position will get a chance to handle the event.	* When travelling down the hierarchy a prospective handler for the event is installed. This prospective handler can be used by submorphs wishing to handle the mouse down for negotiating who the receiver is.	* When travelling up, the prospective handler is always executed. The handler needs to check if the event was handled before as well as checking if somebody else's handler has been installed.	* If another handler has been installed but the event was not handled it means that somebody up in the hierarchy wants to handle the event."	| globalPt localEvt index child morphs handler inside lastHandler |	"Try to get out quickly"	globalPt := anEvent cursorPoint.	(aMorph fullBounds containsPoint: globalPt) ifFalse:[^#rejected].	"Install the prospective handler for the receiver"	lastHandler := anEvent handler. "in case the mouse wasn't even in the receiver"	handler := aMorph handlerForMouseDown: anEvent.	handler ifNotNil:[anEvent handler: handler].	"Now give our submorphs a chance to handle the event"	index := 1.	morphs := aMorph submorphs.	[index <= morphs size] whileTrue:[		child := morphs at: index.		localEvt := anEvent transformedBy: (child transformedFrom: aMorph).		(child processEvent: localEvt using: self) == #rejected ifFalse:[			"Some child did contain the point so we're part of the top-most chain."			inside := false.			localEvt wasHandled ifTrue:[anEvent copyHandlerState: localEvt].			index := morphs size].		index := index + 1.	].	(inside == false or:[aMorph containsPoint: anEvent cursorPoint event: anEvent]) ifTrue:[		"Receiver is in the top-most unlocked, visible chain."		handler ifNotNil:[handler handleEvent: anEvent].		"Note: Re-installing the handler is not really necessary but good style."		anEvent handler: lastHandler.		^self	].	"Mouse was not on receiver nor any of its children"	anEvent handler: lastHandler.	^#rejected! !!ProjectViewMorph methodsFor: 'stepping and presenter' stamp: 'raa 11/2/2000 10:20'!step	| cmd |	"Check for a command that could not be executed in my subproject.  Once it is done, remove the trigger.  If this is too slow, make armsLengthCmd an inst var."	self seeIfNameChanged.	cmd := self valueOfProperty: #armsLengthCmd.	cmd ifNil: [^ super step].	self removeProperty: #armsLengthCmd.	project perform: cmd.	project enter.! !!TableLayout methodsFor: 'layout' stamp: 'ar 10/31/2000 22:50'!computeGlobalCellArrangement: cells in: newBounds horizontal: aBool wrap: wrap spacing: spacing	"Compute number of cells we can put in each row/column. The returned array contains a list of all the cells we can put into the row/column at each level.	Note: The arrangement is so that the 'x' value of each cell advances along the list direction and the 'y' value along the wrap direction. The returned arrangement has an extra cell at the start describing the width and height of the row."	| output maxExtent n cell first last hFill vFill |	output := (WriteStream on: Array new).	first := last := nil.	maxExtent := cells inject: 0@0 into:[:size :c| size max: c cellSize "e.g., minSize"].	spacing == #globalSquare ifTrue:[maxExtent := (maxExtent x max: maxExtent y) asPoint].	n := (wrap // maxExtent x) max: 1.	hFill := vFill := false.	1 to: cells size do:[:i|		cell := cells at: i.		hFill := hFill or:[cell hSpaceFill].		vFill := vFill or:[cell vSpaceFill].		cell cellSize: maxExtent.		first ifNil:[first := last := cell] ifNotNil:[last nextCell: cell. last := cell].		(i \\ n) = 0 ifTrue:[			last := LayoutCell new.			last cellSize: (maxExtent x * n) @ (maxExtent y).			last hSpaceFill: hFill.			last vSpaceFill: vFill.			hFill := vFill := false.			last nextCell: first.			output nextPut: last.			first := nil]].	first ifNotNil:[		last := LayoutCell new.		last cellSize: (maxExtent x * n) @ (maxExtent y). self flag: #arNote."@@@: n is not correct!!"		last nextCell: first.		output nextPut: last].	^output contents! !!ScriptEditorMorph methodsFor: 'private' stamp: 'sw 2/13/98 15:44'!rowInsertionIndexFor: aPoint	"Return the row into which the given morph should be inserted."	| m |	firstTileRow to: submorphs size do: [:i |		m := submorphs at: i.		((m top <= aPoint y) and: [m bottom >= aPoint y]) ifTrue:			[(aPoint y > m center y)				ifTrue: [^ i]				ifFalse: [^ (i - 1) max: firstTileRow]]].	^ firstTileRow > submorphs size		ifTrue:			[submorphs size]		ifFalse:			[(submorphs at: firstTileRow) top > aPoint y 				ifTrue: [firstTileRow - 1]				ifFalse: [submorphs size]]! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'DSM 10/15/1999 15:18'!drawGeneralBezier3Shape: contours color: c borderWidth: borderWidthborderColor: borderColor	| b2 |	b2 := contours collect: [:b3 | Bezier3SegmentconvertBezier3ToBezier2: b3 ].	self drawGeneralBezierShape: b2 color: c borderWidth: borderWidthborderColor: borderColor! !!HandMorph methodsFor: 'paste buffer' stamp: 'ar 10/5/2000 19:11'!pasteBuffer: aMorphOrNil	"Set the contents of the paste buffer."	PasteBuffer := aMorphOrNil.! !!FileList2 class methodsFor: 'morphic ui' stamp: 'miki 8/14/2005 21:21'!morphicViewFileSelectorForSuffixes: aList directory: dir	"Answer a morphic file-selector tool for the given suffix list and the given directory."	| aFileList window fixedSize midLine gap |	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList okayAndCancelServices.	aList ifNotNil:		[aFileList fileSelectionBlock: [:entry :myPattern |			entry isDirectory				ifTrue:					[false]				ifFalse:					[aList includes: (FileDirectory extensionFor: entry name asLowercase)]] fixTemps].	window := BorderedMorph new		layoutPolicy: ProportionalLayout new;		color: Color lightBlue;		borderColor: Color blue;		borderWidth: 4;		layoutInset: 4;		extent: 600@400;		useRoundedCorners.	window setProperty: #fileListModel toValue: aFileList.	aFileList modalView: window.	midLine := 0.4.	fixedSize := 25.	gap := 5.	self addFullPanesTo: window from: {		{self textRow: 'Please select a file'. 0 @ 0 corner: 1 @ 0. 0@0 corner: 0@fixedSize}.		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0. 0@fixedSize corner: 0@(fixedSize * 2)}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1. 					gap @(fixedSize * 2) corner: gap negated@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1. 					gap@(fixedSize * 2) corner: gap negated@0}.	}.	aFileList postOpen.	^ window ! !!PolygonMorph methodsFor: 'menu' stamp: 'di 9/7/2000 15:43'!toggleSmoothing	smoothCurve := smoothCurve not.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!ComponentLikeModel methodsFor: 'components' stamp: 'di 5/3/1998 09:26'!renameMe	| otherNames newName |	otherNames := Set newFrom: self pasteUpMorph allKnownNames.	newName := FillInTheBlank request: 'Please give this new a name'						initialAnswer: self knownName.	newName isEmpty ifTrue: [^ nil].	(otherNames includes: newName) ifTrue:			[self inform: 'Sorry, that name is already used'. ^ nil].	self setNamePropertyTo: newName! !!BalloonMorph class methodsFor: 'private' stamp: 'sd 12/5/2001 20:28'!getTextMorph: aStringOrMorph for: balloonOwner	"Construct text morph."	| m text |	aStringOrMorph isMorph		ifTrue: [m := aStringOrMorph]		ifFalse: [BalloonFont				ifNil: [text := aStringOrMorph]				ifNotNil: [text := Text								string: aStringOrMorph								attribute: (TextFontReference toFont: balloonOwner balloonFont)].			m := (TextMorph new contents: text) centered].	m setToAdhereToEdge: #adjustedCenter.	^ m! !!SystemProgressMorph class methodsFor: 'class initialization' stamp: 'ar 7/18/2009 21:26'!initialize	"SystemProgressMorph initialize; reset"	BarHeight := 16.	BarWidth := 200.! !!SimpleButtonDelayedMenuMorph methodsFor: 'event handling' stamp: 'RAA 7/5/2000 16:50'!mouseUp: evt	didMenu == true ifFalse: [^super mouseUp: evt].	oldColor ifNotNil: [		self color: oldColor.		oldColor := nil	].! !!MenuItemMorph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 17:58'!hResizing	"Default to #spaceFill"	| props |	props := self layoutProperties.	^props ifNil:[#spaceFill] ifNotNil:[props hResizing].! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 2/5/2001 16:59'!replaceTallSubmorphsByThumbnails	"Any submorphs that seem to tall get replaced by thumbnails; their balloon text is copied over to the thumbnail"	|  itsThumbnail heightForThumbnails maxHeightToAvoidThumbnailing maxWidthForThumbnails existingHelp |	heightForThumbnails := self heightForThumbnails.	maxHeightToAvoidThumbnailing := self maxHeightToAvoidThumbnailing.	maxWidthForThumbnails := self maximumThumbnailWidth.	self submorphs do:		[:aMorph |			itsThumbnail := aMorph representativeNoTallerThan: maxHeightToAvoidThumbnailing norWiderThan: maxWidthForThumbnails thumbnailHeight: heightForThumbnails.			(aMorph == itsThumbnail)				ifFalse:					[existingHelp := aMorph balloonText.					self replaceSubmorph: aMorph by: itsThumbnail.					existingHelp ifNotNil:						[itsThumbnail setBalloonText: existingHelp]]]! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'RAA 5/7/2001 10:11'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	defaultLineHeight := theTextStyle lineGrid.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!WorldState methodsFor: 'update cycle' stamp: 'ls 7/10/2003 21:32'!interCyclePause: milliSecs	"delay enough that the previous cycle plus the amount of delay will equal milliSecs.  If the cycle is already expensive, then no delay occurs.  However, if the system is idly waiting for interaction from the user, the method will delay for a proportionally long time and cause the overall CPU usage of Squeak to be low."	| currentTime wait |	(lastCycleTime notNil and: [CanSurrenderToOS ~~ false]) ifTrue: [ 		 currentTime := Time millisecondClockValue.		  wait := lastCycleTime + milliSecs - currentTime.		  (wait > 0 and: [ wait <= milliSecs ] )		ifTrue: [			(Delay forMilliseconds: wait) wait ]. 	].	lastCycleTime :=  Time millisecondClockValue.	CanSurrenderToOS := true.! !!PasteUpMorph methodsFor: 'macpal' stamp: 'sw 6/4/2001 19:38'!currentVocabulary	"Answer the default Vocabulary object to be applied when scripting"	| aSym aVocab |	aSym := self valueOfProperty: #currentVocabularySymbol.	aSym ifNil:		[aVocab := self valueOfProperty: #currentVocabulary.		aVocab ifNotNil:			[aSym := aVocab vocabularyName.			self setProperty: #currentVocabularySymbol toValue: aSym.			self removeProperty: #currentVocabulary]].	^ aSym		ifNotNil:			[Vocabulary vocabularyNamed: aSym]		ifNil:			[Vocabulary fullVocabulary]! !!EllipseMidpointTracer methodsFor: 'initialize' stamp: 'ar 6/28/1999 15:33'!on: aRectangle	rect := aRectangle.	a := rect width // 2.	b := rect height // 2.	x := 0.	y := b.	aSquared := a * a.	bSquared := b * b.	d1 := bSquared - (aSquared * b) + (0.25 * aSquared).	d2 := nil.	inFirstRegion := true.! !!WorldState methodsFor: 'undo support' stamp: 'RAA 9/21/2000 20:05'!clearCommandHistory	"useful prior to project saves"	commandHistory := nil! !!Morph methodsFor: 'layout-menu' stamp: 'dgd 8/30/2003 16:57'!addCellLayoutMenuItems: aMenu hand: aHand	"Cell (e.g., child) related items"	| menu sub |	menu := MenuMorph new defaultTarget: self.		menu addUpdating: #hasDisableTableLayoutString action: #changeDisableTableLayout.		menu addLine.		sub := MenuMorph new defaultTarget: self.		#(rigid shrinkWrap spaceFill) do:[:sym|			sub addUpdating: #hResizingString: target: self selector: #hResizing: argumentList: (Array with: sym)].		menu add:'horizontal resizing' translated subMenu: sub.		sub := MenuMorph new defaultTarget: self.		#(rigid shrinkWrap spaceFill) do:[:sym|			sub addUpdating: #vResizingString: target: self selector: #vResizing: argumentList: (Array with: sym)].		menu add:'vertical resizing' translated subMenu: sub.	aMenu ifNotNil:[aMenu add: 'child layout' translated subMenu: menu].	^menu! !!CollapsedMorph methodsFor: 'resize/collapse' stamp: 'sw 9/1/2000 11:07'!collapseOrExpand	"Toggle the expand/collapsd state of the receiver.  If expanding, copy the window title back to the name of the expanded morph"	| aWorld |	isCollapsed		ifTrue: 			[uncollapsedMorph setProperty: #collapsedPosition toValue: self position.			labelString ifNotNil: [uncollapsedMorph setNameTo: labelString].			mustNotClose := false.	"We're not closing but expanding"			self delete.			(aWorld := self currentWorld) addMorphFront: uncollapsedMorph.			aWorld startSteppingSubmorphsOf: uncollapsedMorph]		ifFalse:			[super collapseOrExpand]! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:38'!foundMorph: aBoolean	foundMorph := aBoolean! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 3/21/2006 23:01'!splitterAbove	| splitters |	splitters := ((self siblingSplitters select: [:each | each y > self y]) asSortedCollection: [:a :b | a y < b y]).		^ splitters ifEmpty: nil ifNotEmpty: [splitters first]! !!ColorMappingCanvas methodsFor: 'drawing-support' stamp: 'di 10/16/1999 16:01'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Transform the receiver by the given display transformation during the execution of aBlock. The given clip rectangle defines the *global* (e.g., outer) rectangle against which the receiver should clip (which would be equivalent to 'self clipRect: aClipRect; transformBy: aDisplayTransform')."	| oldCanvas |	oldCanvas := myCanvas.	myCanvas transformBy: aDisplayTransform		clippingTo: aClipRect		during: [:newCanvas |				myCanvas := newCanvas.				aBlock value: self]		smoothing: cellSize.	myCanvas := oldCanvas.! !!EventHandler methodsFor: 'copying' stamp: 'tk 1/22/2001 17:43'!veryDeepFixupWith: deepCopier	| old |	"ALL inst vars were weakly copied.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.1 to: self class instSize do:	[:ii | old := self instVarAt: ii.	self instVarAt: ii put: (deepCopier references at: old ifAbsent: [old])].! !!FillInTheBlankMorph methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 17:59'!convertToCurrentVersion: varDict refStream: smartRefStrm		varDict at: 'responseUponCancel' ifAbsent: [responseUponCancel := ''].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!Morph methodsFor: 'events-accessing' stamp: 'rw 4/25/2002 07:17'!updateableActionMap	"Answer an updateable action map, saving it in my #actionMap property"		| actionMap |	actionMap := self valueOfProperty: #actionMap.	actionMap ifNil:		[actionMap := self createActionMap.		self setProperty: #actionMap toValue: actionMap].	^ actionMap! !!SystemWindow methodsFor: 'panes' stamp: 'sw 1/14/1999 10:52'!holdsTranscript	"ugh"	| plug |	^ paneMorphs size == 1 and: [((plug := paneMorphs first) isKindOf: PluggableTextMorph) and: [plug model isKindOf: TranscriptStream]]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'dgd 8/30/2003 21:18'!addScalingMenuItems: menu hand: aHandMorph	| subMenu |	(subMenu := MenuMorph new)		defaultTarget: self;		add: 'show application view' translated action: #showApplicationView;		add: 'show factory view' translated action: #showFactoryView;		add: 'show whole world view' translated action: #showFullView;		add: 'expand' translated action: #showExpandedView;		add: 'reduce' translated action: #showReducedView;		addLine;		add: 'define application view' translated action: #defineApplicationView;		add: 'define factory view' translated action: #defineFactoryView.	menu		add: 'world scale and clip...' translated		subMenu: subMenu! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:08'!changeCellInset: evt	| handle |	handle := HandleMorph new forEachPointDo:[:newPoint |		self cellInset: (newPoint - evt cursorPoint) asIntegerPoint // 5].	evt hand attachMorph: handle.	handle startStepping.! !!SystemWindow class methodsFor: 'top window' stamp: 'gm 2/16/2003 20:55'!windowsIn: aWorld satisfying: windowBlock	| windows s |	windows := OrderedCollection new.	aWorld ifNil: [^windows].	"opening MVC in Morphic - WOW!!"	aWorld submorphs do:		[:m |		((m isSystemWindow) and: [windowBlock value: m])			ifTrue: [windows addLast: m]			ifFalse: [((m isKindOf: TransformationMorph) and: [m submorphs size = 1])					ifTrue: [s := m firstSubmorph.							((s isSystemWindow) and: [windowBlock value: s])								ifTrue: [windows addLast: s]]]].	^ windows! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/3/2000 17:06'!showBalloon: msgString	"Pop up a balloon containing the given string,	first removing any existing BalloonMorphs in the world."	| w |	self showBalloon: msgString hand: ((w := self world) ifNotNil:[w activeHand]).! !!Canvas methodsFor: 'drawing' stamp: 'sr 4/27/2000 03:31'!line: pt1 to: pt2 width: w1 color: c1 stepWidth: s1 secondWidth: w2 secondColor: c2 secondStepWidth: s2 	"Draw a line using the given width, colors and steps; both steps can  	have different stepWidths (firstStep, secondStep), draw widths and  	colors."	| bigSteps offsetPoint dist p1p2Vec deltaBig delta1 delta2 lastPoint bigStep |	s1 = 0 & (s2 = 0) ifTrue: [^ self].	dist := pt1 dist: pt2.	dist = 0 ifTrue: [^ self].	bigStep := s1 + s2.	bigSteps := dist / bigStep.	p1p2Vec := pt2 - pt1.	deltaBig := p1p2Vec / bigSteps.	delta1 := deltaBig * (s1 / bigStep).	delta2 := deltaBig * (s2 / bigStep).	dist <= s1		ifTrue: 			[self				line: pt1 rounded				to: pt2 rounded				width: w1				color: c1.			^ self].	0 to: bigSteps truncated - 1 do: 		[:bigStepIx | 		self			line: (pt1 + (offsetPoint := deltaBig * bigStepIx)) rounded			to: (pt1 + (offsetPoint := offsetPoint + delta1)) rounded			width: w1			color: c1.		self			line: (pt1 + offsetPoint) rounded			to: (pt1 + (offsetPoint + delta2)) rounded			width: w2			color: c2].	"if there was no loop, offsetPoint is nil"	lastPoint := pt1 + ((offsetPoint ifNil: [0 @ 0])					+ delta2).	(lastPoint dist: pt2)		<= s1		ifTrue: [self				line: lastPoint rounded				to: pt2 rounded				width: w1				color: c1]		ifFalse: 			[self				line: lastPoint rounded				to: (lastPoint + delta1) rounded				width: w1				color: c1.			self				line: (lastPoint + delta1) rounded				to: pt2				width: w1				color: c2]! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'BG 8/27/2003 22:58'!openAsMorphLabel: aString inWorld: aWorld	"Open a view of an instance of me."	"PluggableFileList new openAsMorphLabel: 'foo' inWorld: World"	| windowMorph volListMorph templateMorph fileListMorph leftButtonMorph middleButtonMorph rightButtonMorph |		self directory: directory.	windowMorph := (SystemWindow labelled: aString) model: self.	volListMorph := PluggableListMorph on: self		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListMorph autoDeselect: false.	windowMorph addMorph: volListMorph frame: (0@0 corner: 0.4@0.5625).	templateMorph := PluggableTextMorph on: self		text: #pattern		accept: #pattern:.	templateMorph askBeforeDiscardingEdits: false.	windowMorph addMorph: templateMorph frame: (0@0.5625 corner: 0.4@0.75).	fileListMorph := PluggableListMorph on: self		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	windowMorph addMorph: fileListMorph frame: (0.4@0 corner: 1.0@0.75).	leftButtonMorph := PluggableButtonMorph 		on: self		getState: #leftButtonState		action: #leftButtonPressed.	leftButtonMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		label: 'Cancel';		onColor: Color red offColor: Color red;		feedbackColor: Color orange;		borderWidth: 3.	middleButtonMorph := PluggableButtonMorph		on: self		getState: nil		action: nil.	middleButtonMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		label: prompt;		onColor: Color lightYellow offColor: Color lightYellow;		feedbackColor: Color lightYellow;		borderWidth: 1.	rightButtonMorph := PluggableButtonMorph		on: self		getState: #rightButtonState		action: #rightButtonPressed.	rightButtonMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		label: 'Accept';		onColor: Color green offColor: Color lightYellow;		feedbackColor: Color black;		borderWidth: (self canAccept ifTrue: [3] ifFalse: [1]).	"self canAccept ifFalse: [rightButtonMorph controller: NoController new]."	windowMorph		addMorph: leftButtonMorph frame: (0@0.75 corner: 0.25@1.0);		addMorph: middleButtonMorph frame: (0.25@0.75 corner: 0.75@1.0);		addMorph: rightButtonMorph frame: (0.75@0.75 corner: 1.0@1.0).	self changed: #getSelectionSel.    windowMorph openInWorld: aWorld.    [windowMorph model notNil]       whileTrue: [aWorld doOneCycle].    ^self result! !!HaloMorph methodsFor: 'private' stamp: 'dgd 9/18/2004 18:23'!addGraphicalHandleFrom: formKey at: aPoint	"Add the supplied form as a graphical handle centered at the given point.  Return the handle."	| handle aForm |	aForm := (ScriptingSystem formAtKey: formKey) ifNil: [ScriptingSystem formAtKey: #SolidMenu].	handle := ImageMorph new image: aForm; bounds: (Rectangle center: aPoint extent: aForm extent).	handle wantsYellowButtonMenu: false.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	^ handle! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 10/25/1999 23:34'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition w |	oldMorph stopStepping.	itsPosition := oldMorph referencePositionInWorld.	index := submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph referencePositionInWorld: itsPosition.	(w := newMorph world) ifNotNil:		[w startSteppingSubmorphsOf: newMorph]! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 9/24/2000 08:44'!extent: newExtent 	"Not really advisable, but we can preserve most of the geometry if we don't	shrink things too small."	| safeExtent center |	center := self referencePosition.	safeExtent := newExtent max: 20@20.	self setVertices: (vertices collect:		[:p | p - center * (safeExtent asFloatPoint / (bounds extent max: 1@1)) + center])! !!Morph methodsFor: 'fileIn/out' stamp: 'tk 11/20/1998 11:47'!saveOnURL: suggestedUrlString	"Save myself on a SmartReferenceStream file.  If I don't already have a url, use the suggested one.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg := self valueOfProperty: #SqueakPage) ifNil: [pg := SqueakPage new]		ifNotNil: [pg contentsMorph ~~ self ifTrue: [				self inform: 'morph''s SqueakPage property is out of date'.				pg := SqueakPage new]].	(url := pg url) ifNil: [url := pg urlNoOverwrite: suggestedUrlString].	stamp := Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol := pg policy) ifNil: [pol := #neverWrite].	pg policy: #now; dirty: true.  pg write.	"force the write"	pg policy: pol.	^ pg! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:42'!sendEvent: anEvent focus: focusHolder clear: aBlock	"Send the event to the morph currently holding the focus, or if none to the owner of the hand."	| result |	focusHolder ifNotNil:[^self sendFocusEvent: anEvent to: focusHolder clear: aBlock].	ActiveEvent := anEvent.	result := owner processEvent: anEvent.	ActiveEvent := nil.	^result! !!FileList methodsFor: 'private' stamp: 'yo 3/14/2005 13:55'!readContentsAsEncoding: encodingName	| f writeStream converter c |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	converter := TextConverter defaultConverterClassForEncoding: encodingName.	converter ifNil: [^ 'This encoding is not supported'].	f converter: converter new.	f wantsLineEndConversion: true.	[f atEnd or: [(c := f next) isNil]]		whileFalse: [writeStream nextPut: c].	f close.	^ writeStream contents! !!TransferMorph class methodsFor: 'class initialization' stamp: 'mir 5/5/2000 14:49'!initIcons	"TransferMorph initIcons"	CopyPlusIcon := Form		extent: 16@16		depth: 8		fromArray: #( 0 0 65535 0 0 0 16768220 4278190080 0 0 16768220 4278190080 0 255 4294958300 4294967040 0 65500 3705461980 3705462015 0 65500 3705461980 3705462015 0 255 4294958300 4294967295 0 0 16768220 4278190080 0 0 16768220 4278190080 0 0 65535 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)		offset: 0@0! !!ColorPickerMorph methodsFor: 'private' stamp: 'ar 9/4/2001 13:27'!positionOfColor: aColor	"Compute the position of the given color in the color chart form"	| rgbRect x y h s v |	rgbRect := (0@0 extent: originalForm boundingBox extent) insetBy: (1@10 corner: 11@1).	h := aColor hue.	s := aColor saturation.	v := aColor brightness.	h = 0.0 ifTrue:["gray"		^(rgbRect right + 6) @ (rgbRect height * (1.0 - v) + rgbRect top)].	x := (h + 22 \\ 360 / 360.0 * rgbRect width) rounded.	y := 0.5.	s < 1.0 ifTrue:[y := y - (1.0 - s * 0.5)].	v < 1.0 ifTrue:[y := y + (1.0 - v * 0.5)].	y := (y * rgbRect height) rounded.	^x@y + (1@10)! !!MenuItemMorph methodsFor: 'grabbing' stamp: 'spfa 3/13/2004 18:32'!duplicateMorph: evt	"Make and return a duplicate of the receiver's argument"	| dup menu |	dup := self duplicate isSelected: false.	menu := MenuMorph new defaultTarget: nil.	menu addMorphFront: dup.	menu bounds: self bounds.	menu stayUp: true.	evt hand grabMorph: menu from: owner. "duplicate was ownerless so use #grabMorph:from: here"	^menu! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeListDirection: aSymbol	| listDir wrapDir |	self listDirection: aSymbol.	(self wrapDirection == #none) ifTrue:[^self].	"otherwise automatically keep a valid table layout"	listDir := self listDirection.	wrapDir := self wrapDirection.	(listDir == #leftToRight or:[listDir == #rightToLeft]) ifTrue:[		wrapDir == #leftToRight ifTrue:[^self wrapDirection: #topToBottom].		wrapDir == #rightToLeft ifTrue:[^self wrapDirection: #bottomToTop].	] ifFalse:[		wrapDir == #topToBottom ifTrue:[^self wrapDirection: #leftToRight].		wrapDir == #bottomToTop ifTrue:[^self wrapDirection: #rightToLeft].	].! !!Morph class methodsFor: 'class initialization' stamp: 'hg 8/3/2000 16:43'!initialize	"Morph initialize"	"this empty array object is shared by all morphs with no submorphs:"	EmptyArray := Array new.	FileList registerFileReader: self! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!bottomFraction: aNumber	bottomFraction := aNumber! !!MenuMorph methodsFor: 'control' stamp: 'ar 9/18/2000 12:16'!selectItem: aMenuItem event: anEvent	selectedItem ifNotNil:[selectedItem deselect: anEvent].	selectedItem := aMenuItem.	selectedItem ifNotNil:[selectedItem select: anEvent].! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:50'!exportAsGIF	| fName |	fName := FillInTheBlank request:'Please enter the name' translated initialAnswer: self externalName,'.gif'.	fName isEmpty ifTrue:[^self].	GIFReadWriter putForm: self imageForm onFileNamed: fName.! !!FormCanvas methodsFor: 'private' stamp: 'tpr 9/15/2004 10:28'!setFillColor: aColor	"Install a new color used for filling."	| screen patternWord fillColor |	fillColor := self shadowColor ifNil:[aColor].	fillColor ifNil:[fillColor := Color transparent].	fillColor isColor ifFalse:[		(fillColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: fillColor; combinationRule: Form over].	"Okay, so fillColor really *is* a color"	port sourceForm: nil.	fillColor isTranslucent ifFalse:[		port combinationRule: Form over.		port fillPattern: fillColor.		self depth = 8 ifTrue:[			"In 8 bit depth it's usually a good idea to use a stipple pattern"			port fillColor: (form balancedPatternFor: fillColor)].		^self].	"fillColor is some translucent color"	self depth > 8 ifTrue:[		"BitBlt setup for alpha masked transfer"		port fillPattern: fillColor.		self depth = 16			ifTrue:[port alphaBits: fillColor privateAlpha; combinationRule: 30]			ifFalse:[port combinationRule: Form blend].		^self].	"Can't represent actual transparency -- use stipple pattern"	screen := Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord := form pixelWordFor: fillColor.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint.! !!PolygonMorph methodsFor: 'initialization' stamp: 'di 9/8/2000 09:45'!beStraightSegments	smoothCurve == false ifFalse:		[smoothCurve := false.		self computeBounds]! !!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/2/98 00:32'!getItemsSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ getItemsSelector := nil].	getItemsSelector := aSymbolOrString asSymbol.! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'ar 3/17/2001 17:39'!expandAll: aMorph except: aBlock	| allChildren |	(aBlock value: aMorph complexContents)		ifFalse: [^self].	aMorph toggleExpandedState.	allChildren := OrderedCollection new: 10.	aMorph recursiveAddTo: allChildren.	allChildren do: [:each | 		(each canExpand			and: [each isExpanded not])			ifTrue: [self expandAll: each except: aBlock]].! !!Morph methodsFor: 'structure' stamp: 'di 11/13/2000 00:50'!outermostMorphThat: conditionBlock	"Return the outermost containing morph for which aBlock is true, or nil if none"	| outermost |	self allOwnersDo: [:m | (conditionBlock value: m) ifTrue: [outermost := m]].	^ outermost! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightOffset: anInteger	rightOffset := anInteger! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 5/17/2000 21:20'!fillRect: rect offset: aPoint	"The offset is really just for stupid InfiniteForms."	| fc |	fillPattern class == InfiniteForm ifTrue:[		fc := halftoneForm.		self fillColor: nil.		fillPattern displayOnPort: ((self clippedBy: rect) colorMap: nil) at: aPoint.		halftoneForm := fc.		^self].	destX := rect left.	destY := rect top.	sourceX := 0.	sourceY := 0.	width := rect width.	height := rect height.	self copyBits.! !!HandMorph methodsFor: 'double click support' stamp: 'nk 7/26/2004 10:32'!waitForClicksOrDrag: aMorph event: evt selectors: clickAndDragSelectors threshold: threshold	"Wait for mouse button and movement events, informing aMorph about events interesting to it via callbacks.	This message is typically sent to the Hand by aMorph when it first receives a mouse-down event.	The callback methods, named in clickAndDragSelectors and passed a copy of evt, are:		1 	(click) sent when the mouse button goes up within doubleClickTime.		2	(doubleClick) sent when the mouse goes up, down, and up again all within DoubleClickTime.		3	(doubleClickTimeout) sent when the mouse does not have a doubleClick within DoubleClickTime.		4	(startDrag) sent when the mouse moves more than threshold pixels from evt's position within DoubleClickTime.	Note that mouseMove: and mouseUp: events are not sent to aMorph until it becomes the mouse focus,	which is typically done by aMorph in its click:, doubleClick:, or drag: methods."		mouseClickState := 		MouseClickState new			client: aMorph 			click: clickAndDragSelectors first 			dblClick: clickAndDragSelectors second 			dblClickTime: DoubleClickTime 			dblClickTimeout: clickAndDragSelectors third			drag: clickAndDragSelectors fourth 			threshold: threshold 			event: evt.! !!Morph methodsFor: 'geometry' stamp: 'sw 7/10/1999 17:26'!nextOwnerPage	"Tell my container to advance to the next page"	| targ |	targ := self ownerThatIsA: BookMorph.	targ ifNotNil: [targ nextPage]! !!FileList class methodsFor: 'instance creation' stamp: 'di 10/18/1999 22:34'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel := FileList new setFileStream: aFileStream.	"closes the stream"	window := (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView := PluggableTextMorph on: fileModel 			text: #contents accept: #put:			readSelection: #contentsSelection 			menu: #fileContentsMenu:shifted:)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	^ window! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 11/2/2000 10:11'!updateNamePosition	| nameMorph shadowMorph nameFillerMorph |	(nameMorph := self findA: UpdatingStringMorph) ifNotNil: [		nameMorph position:			(self left + (self width - nameMorph width // 2)) @			(self bottom - nameMorph height - 2).	].	(nameFillerMorph := self findA: AlignmentMorph) ifNotNil: [		nameFillerMorph			position: self bottomLeft - (0@20);			extent: self width@20.	].	(shadowMorph := self findA: ImageMorph) ifNotNil: [		shadowMorph delete	"no longer used"	].! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 1/19/2000 11:48'!setFontSize	| sizes reply family |	family := font ifNil: [TextStyle default] ifNotNil: [font textStyle].	family ifNil: [family := TextStyle default].  "safety net -- this line SHOULD be unnecessary now"	sizes := 	family fontNamesWithPointSizes.	reply := (SelectionMenu labelList: sizes selections: sizes) startUp.	reply ifNotNil:		[self font: (family fontAt: (sizes indexOf: reply))]! !!Morph methodsFor: 'geometry' stamp: 'ar 12/14/2000 13:48'!bounds: newBounds	| oldExtent newExtent |	oldExtent := self extent.	newExtent := newBounds extent.	(oldExtent dotProduct: oldExtent) <= (newExtent dotProduct: newExtent) ifTrue:[		"We're growing. First move then resize."		self position: newBounds topLeft; extent: newExtent.	] ifFalse:[		"We're shrinking. First resize then move."		self extent: newExtent; position: newBounds topLeft.	].! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/10/2000 07:58'!rightButtonPressed	(canAcceptBlock value: directory value: fileName) ifFalse: [^nil].	(validateBlock value: directory value: fileName value: newFiles) ifFalse: [^nil].	accepted := true.	self changed: #close! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 2/17/2000 00:15'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		subCanvas := self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect.		aBlock value: subCanvas.		foundMorph := subCanvas foundMorph.		^self	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := aDisplayTransform globalBoundsToLocal:					(self clipRect intersect: innerRect).	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	warp cellSize: cellSize.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := ColorPatchCanvas extent: patchRect extent depth: self depth.		subCanvas stopMorph: stopMorph.		subCanvas foundMorph: foundMorph.		subCanvas doStop: doStop.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		i = 2 ifTrue:[foundMorph := subCanvas foundMorph].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!BottomLeftGripMorph methodsFor: 'drawing' stamp: 'jmv 2/19/2006 14:23'!drawOn: aCanvas	| dotBounds alphaCanvas windowBorderWidth dotBounds2 |	windowBorderWidth := SystemWindow borderWidth.	bounds := self bounds.	alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.		"alphaCanvas		frameRectangle: bounds color: Color blue."	dotBounds := (bounds insetBy: 1).	dotBounds2 := dotBounds right: (dotBounds left + windowBorderWidth).	dotBounds2 := dotBounds2 top: (dotBounds2 bottom - windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.		dotBounds2 := dotBounds left: (dotBounds left + windowBorderWidth).	dotBounds2 := dotBounds2 top: (dotBounds2 bottom - windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 left: (dotBounds2 left + 7).	dotBounds2 := dotBounds2 right: (dotBounds2 right - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor.	dotBounds2 := dotBounds right: (dotBounds left + windowBorderWidth).	dotBounds2 := dotBounds2 bottom: (dotBounds2 bottom - windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 top: (dotBounds2 top + 7).	dotBounds2 := dotBounds2 bottom: (dotBounds2 bottom - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor! !!PasteUpMorph methodsFor: 'flaps' stamp: 'sw 2/15/1999 20:37'!accommodateFlap: aFlapTab	"Shift submorphs over, if appropriate"	| offset |	aFlapTab slidesOtherObjects ifTrue:		[offset := self offsetForAccommodating: aFlapTab referent extent onEdge: aFlapTab edgeToAdhereTo.		self shiftSubmorphsBy: offset]! !!Morph methodsFor: 'thumbnail' stamp: 'ar 11/9/2000 20:42'!readoutForField: fieldSym	"Provide a readout that will show the value of the slot/pseudoslot of the receiver generated by sending fieldSym to the receiver"	| aContainer |	"still need to get this right"	aContainer := AlignmentMorph newColumn.	aContainer layoutInset: 0; hResizing: #rigid; vResizing: #shrinkWrap.	aContainer addMorphBack: (StringMorph new contents: (self perform: fieldSym) asString).	^ aContainer! !!MorphExtension methodsFor: 'accessing' stamp: 'di 8/10/1998 12:55'!balloonText: newValue	balloonText := newValue! !!TransferMorph methodsFor: 'accessing' stamp: 'panda 4/25/2000 16:31'!draggedMorph: aMorph	draggedMorph := aMorph! !!PasteUpMorph methodsFor: 'world menu' stamp: 'mir 11/14/2002 17:37'!connectRemoteUserWithName: nameStringOrNil picture: aFormOrNil andIPAddress: aStringOrNil	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials := nameStringOrNil.	initials isEmptyOrNil ifTrue: [		initials := FillInTheBlank request: 'Enter initials for remote user''s cursor?'.	].	initials isEmpty ifTrue: [^ self].  "abort"	addr := 0.	aStringOrNil isEmptyOrNil ifFalse: [		addr := NetNameResolver addressForName: aStringOrNil timeout: 30	].	addr = 0 ifTrue: [		addr := NetNameResolver promptUserForHostAddress.	].	addr = 0 ifTrue: [^ self].  "abort"	RemoteHandMorph ensureNetworkConnected.	h := RemoteHandMorph new userInitials: initials andPicture: aFormOrNil.	self addHand: h.	h changed.	h startListening.	h startTransmittingEventsTo: addr.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:46'!showReducedView	| r |	r := Display extent // 4 extent: Display extent // 2.	owner	"the transform"		owner	"the green border"			bounds: r! !!TextFieldMorph methodsFor: 'just like textMorph' stamp: 'tk 8/30/2000 14:24'!fontName: fontName size: fontSize	| tm |	"talk to my text"	(tm := self findA: TextMorph) ifNil: [^ nil].	^ tm fontName: fontName size: fontSize! !!Morph methodsFor: 'menus' stamp: 'ar 9/22/2000 20:15'!setRotationCenter	| p |	self world displayWorld.	Cursor crossHair showWhile:		[p := Sensor waitButton].	Sensor waitNoButton.	self setRotationCenterFrom: (self transformFromWorld globalPointToLocal: p).! !!Morph methodsFor: 'layout-menu' stamp: 'ar 10/31/2000 19:19'!changeProportionalLayout	| layout |	((layout := self layoutPolicy) notNil and:[layout isProportionalLayout])		ifTrue:[^self]. "already proportional layout"	self layoutPolicy: ProportionalLayout new.	self layoutChanged.! !!PluggableListMorph methodsFor: 'model access' stamp: 'sw 12/9/2001 18:54'!specialKeyPressed: asciiValue	"A special key with the given ascii-value was pressed; dispatch it"	| oldSelection nextSelection max howManyItemsShowing |	asciiValue = 27 ifTrue: 		[" escape key"		^ ActiveEvent shiftPressed			ifTrue:				[ActiveWorld putUpWorldMenuFromEscapeKey]			ifFalse:				[self yellowButtonActivity: false]].	max := self maximumSelection.	max > 0 ifFalse: [^ self].	nextSelection := oldSelection := self getCurrentSelectionIndex.	asciiValue = 31 ifTrue: 		[" down arrow"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].	asciiValue = 30 ifTrue: 		[" up arrow"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].	asciiValue = 1 ifTrue:		[" home"		nextSelection := 1].	asciiValue = 4 ifTrue:		[" end"		nextSelection := max].	howManyItemsShowing := self numSelectionsInView.	asciiValue = 11 ifTrue:		[" page up"		nextSelection := 1 max: oldSelection - howManyItemsShowing].	asciiValue = 12 ifTrue:		[" page down"		nextSelection := oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection = nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!Morph methodsFor: 'naming' stamp: 'fc 4/27/2004 21:58'!choosePartName	"Pick an unused name for this morph."	| className |	self world ifNil: [^nil].	(self world model isKindOf: Component) ifTrue:		[self knownName ifNil: [^ self nameMeIn: self world]					ifNotNil: [^ self renameMe]].	className := self class name.	(className size > 5 and: [className endsWith: 'Morph'])		ifTrue: [className := className copyFrom: 1 to: className size - 5].	^ self world model addPartNameLike: className withValue: self! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 1/29/98 18:37'!scriptee	| editor |	playerScripted ifNotNil: [^ playerScripted].	(editor := self topEditor) == self ifTrue: [self error: 'unattached script editor'. ^ nil].	^ editor scriptee! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw the oval defined by the given rectangle"	| fillC borderC |	fillC := self shadowColor ifNil:[c].	borderC := self shadowColor ifNil:[borderColor].	self ensuredEngine		drawOval: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!Morph methodsFor: 'geometry' stamp: 'sw 2/16/1999 22:05'!shiftSubmorphsOtherThan: listNotToShift by: delta	| rejectList |	rejectList := listNotToShift ifNil: [OrderedCollection new].	(submorphs copyWithoutAll: rejectList) do:		[:m | m position: (m position + delta)]! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!addMorph: aMorph centeredNear: aPoint	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."	| trialRect delta |	trialRect := Rectangle center: aPoint extent: aMorph fullBounds extent.	delta := trialRect amountToTranslateWithin: bounds.	aMorph position: trialRect origin + delta.	self addMorph: aMorph.! !!Morph methodsFor: 'structure' stamp: 'ar 3/18/2001 00:12'!outermostWorldMorph	| outer |	World ifNotNil:[^World].	self flag: #arNote. "stuff below is really only for MVC"	outer := self outermostMorphThat: [ :x | x isWorldMorph].	outer ifNotNil: [^outer].	self isWorldMorph ifTrue: [^self].	^nil! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 6/26/1998 07:47'!toggleGrowability	growable := self growable not.	self updateContentsFrom: self readFromTarget.	growable ifTrue: [self fitContents]! !!ColorPickerMorph methodsFor: 'menu' stamp: 'yo 9/29/2004 10:38'!pickUpColorFor: aMorph	"Show the eyedropper cursor, and modally track the mouse through a mouse-down and mouse-up cycle"      | aHand localPt c |	aHand := aMorph ifNil: [self activeHand] ifNotNil: [aMorph activeHand].	aHand ifNil: [aHand := self currentHand].	self addToWorld: aHand world near: (aMorph ifNil: [aHand world]) fullBounds.	self owner ifNil: [^ self].	aHand showTemporaryCursor: (ScriptingSystem formAtKey: #Eyedropper) 			hotSpotOffset: 6 negated @ 4 negated.    "<<<< the form was changed a bit??"	self updateContinuously: false.	[Sensor anyButtonPressed]		whileFalse: 			 [self trackColorUnderMouse].	self deleteAllBalloons.	localPt := Sensor cursorPoint - self topLeft.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt) ifTrue:			["Click or drag the drag-dot means to anchor as a modeless picker"			^ self anchorAndRunModeless: aHand].	].	(clickedTranslucency := TransparentBox containsPoint: localPt)		ifTrue: [selectedColor := originalColor].	self updateContinuously: true.	[Sensor anyButtonPressed]		whileTrue:			 [self updateTargetColorWith: self indicateColorUnderMouse].	c := self getColorFromKedamaWorldIfPossible: Sensor cursorPoint.	c ifNotNil: [selectedColor := c].	aHand newMouseFocus: nil;		showTemporaryCursor: nil;		flushEvents.	self delete.		  ! !!SystemWindow methodsFor: 'menu' stamp: 'dgd 8/30/2003 16:40'!buildWindowMenu	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu add: 'change title...' translated action: #relabel.	aMenu addLine.	aMenu add: 'send to back' translated action: #sendToBack.	aMenu add: 'make next-to-topmost' translated action: #makeSecondTopmost.	aMenu addLine.	self mustNotClose		ifFalse:			[aMenu add: 'make unclosable' translated action: #makeUnclosable]		ifTrue:			[aMenu add: 'make closable' translated action: #makeClosable].	aMenu		add: (self isSticky ifTrue: ['make draggable'] ifFalse: ['make undraggable']) translated 		action: #toggleStickiness.	aMenu addLine.	aMenu add: 'full screen' translated action: #fullScreen.	self isCollapsed ifFalse: [aMenu add: 'window color...' translated action: #setWindowColor].	^aMenu! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:51'!exportAsPNG	| fName |	fName := FillInTheBlank request:'Please enter the name' translated initialAnswer: self externalName,'.png'.	fName isEmpty ifTrue:[^self].	PNGReadWriter putForm: self imageForm onFileNamed: fName.! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'ar 11/14/1998 23:53'!string: aString	string := aString.	self initializeString.! !!FileList methodsFor: 'volume list and pattern' stamp: 'sw 3/6/1999 11:39'!veryDeepFixupWith: deepCopier	super veryDeepFixupWith: deepCopier.	volListIndex := 1.	self directory: FileDirectory default.	self updateFileList! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 11/1/2000 22:49'!drawOn: aCanvas	| font projectName nameForm rectForName |	self ensureImageReady.	super drawOn: aCanvas.	self isEditingName ifTrue: [^self].	font := self fontForName.	projectName := self safeProjectName.	nameForm := (StringMorph contents: projectName font: font) imageForm.	nameForm := nameForm scaledToSize: (self extent - (4@2) min: nameForm extent).	rectForName := self bottomLeft + 			(self width - nameForm width // 2 @ (nameForm height + 2) negated)				extent: nameForm extent.	rectForName topLeft eightNeighbors do: [ :pt |		aCanvas			stencil: nameForm 			at: pt			color: self colorAroundName.	].	aCanvas		stencil: nameForm 		at: rectForName topLeft 		color: Color black.	! !!HaloMorph methodsFor: 'private' stamp: 'dgd 4/4/2006 16:53'!doScale: evt with: scaleHandle	"Update the scale of my target if it is scalable."	| newHandlePos colorToUse |	evt hand obtainHalo: self.	newHandlePos := evt cursorPoint - (scaleHandle extent // 2).	target scaleToMatch: newHandlePos.	colorToUse := target scale = 1.0						ifTrue: [Color yellow]						ifFalse: [Color orange].	self setColor: colorToUse toHandle: scaleHandle.	scaleHandle		submorphsDo: [:m | m color: colorToUse makeForegroundColor].	scaleHandle position: newHandlePos.	self layoutChanged.	(self valueOfProperty: #commandInProgress) ifNotNilDo:[:cmd |		"Update the final extent"		cmd redoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: target extent	].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 10/11/2000 18:24'!separateDragAndDrop	"Conversion only. Separate the old #dragNDropEnabled into #dragEnabled and #dropEnabled and remove the old property."	| dnd |	(self hasProperty: #dragNDropEnabled) ifFalse:[^self].	dnd := (self valueOfProperty: #dragNDropEnabled) == true.	self dragEnabled: dnd.	self dropEnabled: dnd.	self removeProperty: #dragNDropEnabled.! !!SketchMorph methodsFor: 'geometry' stamp: 'nk 6/21/2003 14:00'!firstIntersectionWithLineFrom: start to: end	| intersections last |	intersections := self fullBounds extrapolatedIntersectionsWithLineFrom: start to: end.	intersections size = 1 ifTrue: [ ^intersections anyOne ].	intersections isEmpty ifTrue: [ ^nil ].	intersections := intersections asSortedCollection: [ :a :b | (start dist: a) < (start dist: b) ].	last := intersections first rounded.	last pointsTo: intersections last rounded do: [ :pt |		(self rotatedForm isTransparentAt: (pt - bounds origin)) ifFalse: [ ^last ].		last := pt.	].	^intersections first rounded! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 5/24/2000 15:10'!notePenDown: penDown forPlayer: player at: location	"Note that a morph has just moved with its pen down, begining at startPoint.	Only used in conjunction with Preferences batchPenTrails."	| startLoc |	lastTurtlePositions ifNil: [lastTurtlePositions := IdentityDictionary new].	penDown		ifTrue: ["Putting the Pen down -- record current location"				(lastTurtlePositions includesKey: player) ifFalse:					[lastTurtlePositions at: player put: location]]		ifFalse: ["Picking the Pen up -- draw to current location and remove"				(startLoc := lastTurtlePositions at: player ifAbsent: [nil]) ifNotNil:					[self drawPenTrailFor: player costume							from: startLoc to: location].				lastTurtlePositions removeKey: player ifAbsent: []]! !!PluggableTextMorph methodsFor: 'model access' stamp: 'wod 5/26/1998 17:03'!setSelection: sel	selectionInterval := sel.	textMorph editor selectFrom: sel first to: sel last.	self scrollSelectionIntoView ifFalse: [scroller changed].! !!TextLine methodsFor: 'scanning' stamp: ''!justifiedPadFor: spaceIndex 	"Compute the width of pad for a given space in a line of justified text."	| pad |	internalSpaces = 0 ifTrue: [^0].	pad := paddingWidth // internalSpaces.	spaceIndex <= (paddingWidth \\ internalSpaces)		ifTrue: [^pad + 1]		ifFalse: [^pad]! !!SystemWindow methodsFor: 'drawing' stamp: 'di 8/16/1998 01:14'!areasRemainingToFill: aRectangle	| areas |	(areas := super areasRemainingToFill: aRectangle) isEmpty		ifTrue: [^ areas "good news -- complete occlusion"].	"Check for special case that this is scrollbar damage"	((bounds topLeft - (14@0) corner: bounds bottomRight) containsRect: aRectangle) ifTrue:		[paneMorphs do: [:p | ((p isKindOf: ScrollPane) and: [p scrollBarFills: aRectangle])							ifTrue: [^ Array new]]].	^ areas! !!TransferMorph methodsFor: 'initialization' stamp: 'nk 6/16/2003 16:50'!initialize	"initialize the state of the receiver"	super initialize.	self layoutPolicy: TableLayout new.	self listDirection: #leftToRight;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		layoutInset: 3;		wrapCentering: #center;		cellPositioning: #leftCenter.	accepted := false.	copy := false.	self on: #keyStroke send: #keyStroke: to: self! !!ComplexProgressIndicator class methodsFor: 'as yet unclassified' stamp: 'nb 6/17/2003 12:25'!historyReport"ComplexProgressIndicator historyReport"	| answer data |	History ifNil: [^Beeper beep].	answer := String streamContents: [ :strm |		(History keys asSortedCollection: [ :a :b | a asString <= b asString]) do: [ :k |			strm nextPutAll: k printString; cr.			data := History at: k.			(data keys asSortedCollection: [ :a :b | a asString <= b asString]) do: [ :dataKey |				strm tab; nextPutAll: dataKey printString,'  ',					(data at: dataKey) asArray printString; cr.			].			strm cr.		].	].	StringHolder new		contents: answer contents;		openLabel: 'Progress History'! !!ProgressBarMorph methodsFor: 'menu' stamp: 'sma 3/3/2000 19:27'!changeProgressValue: evt	| answer |	answer := FillInTheBlank		request: 'Enter new value (0 - 1.0)'		initialAnswer: self value contents asString.	answer isEmptyOrNil ifTrue: [^ self].	self value contents: answer asNumber! !!MatrixTransformMorph methodsFor: 'layout' stamp: 'ar 11/15/1998 21:52'!fullBounds	| subBounds |	fullBounds ifNil:[		fullBounds := self bounds.		submorphs do:[:m|			subBounds := (self transform localBoundsToGlobal: m fullBounds).			fullBounds := fullBounds quickMerge: subBounds.		].	].	^fullBounds! !!HaloMorph methodsFor: 'private' stamp: 'sw 2/2/2006 02:48'!doGrow: evt with: growHandle	"Called while the mouse is down in the grow handle"	| newExtent extentToUse scale |	evt hand obtainHalo: self.	newExtent := (target pointFromWorld: (target griddedPoint: evt cursorPoint - positionOffset))								- target topLeft.	evt shiftPressed ifTrue: [		scale := (newExtent x / (originalExtent x max: 1)) min:					(newExtent y / (originalExtent y max: 1)).		newExtent := (originalExtent x * scale) asInteger @ (originalExtent y * scale) asInteger	].	(newExtent x < 1 or: [newExtent y < 1 ]) ifTrue: [^ self].	target renderedMorph setExtentFromHalo: (extentToUse := newExtent).	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.	(self valueOfProperty: #commandInProgress) ifNotNilDo:  		[:cmd | "Update the final extent"			cmd redoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: extentToUse]! !!FileList2 class methodsFor: 'morphic ui' stamp: 'bkv 11/12/2002 16:55'!morphicViewFolderSelector: aDir	"Answer a tool that allows the user to select a folder"	| aFileList window fixedSize |	aFileList := self new directory: aDir.	aFileList optionalButtonSpecs: aFileList servicesForFolderSelector.	window := (SystemWindow labelled: aDir pathName) model: aFileList.	aFileList modalView: window.	fixedSize := 25.	self addFullPanesTo: window from: {		{self textRow: 'Please select a folder'. 0 @ 0 corner: 1 @ 0. 				0@0 corner: 0@fixedSize}.		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0. 				0@fixedSize corner: 0@(fixedSize * 2)}.		{aFileList morphicDirectoryTreePane. 0@0 corner: 1@1.				0@(fixedSize * 2) corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!PasteUpMorph methodsFor: 'misc' stamp: 'di 12/23/1998 14:44'!cachedOrNewThumbnailFrom: newThumbnail	"If I have a cached thumbnail, and it is of the desired extent, then ruturn it.	Otherwise produce one in newThumbnail and return it (after caching).	This code parallels what happens in page: to match resultant extent."	| cachedThumbnail scale ext |	scale := newThumbnail height / self fullBounds height.	ext := (self fullBounds extent * scale) truncated.	(cachedThumbnail := self valueOfProperty: #cachedThumbnail) ifNotNil:		[cachedThumbnail extent = ext ifTrue: [^ cachedThumbnail]].	self setProperty: #cachedThumbnail toValue: (newThumbnail page: self).	^ newThumbnail! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 11/2/2000 10:06'!on: aProject	project := aProject.	self addProjectNameMorphFiller.	lastProjectThumbnail := nil.	project thumbnail		ifNil: [self extent: 100@80]		"more like screen dimensions?"		ifNotNil: [self extent: project thumbnail extent].! !!TextLine methodsFor: 'updating' stamp: 'di 4/28/1999 11:12'!slideIndexBy: delta andMoveTopTo: newTop	"Relocate my character indices and y-values.	Used to slide constant text up or down in the wake of a text replacement."	firstIndex := firstIndex + delta.	lastIndex := lastIndex + delta.	bottom := bottom + (newTop - top).	top := newTop.! !!StringMorph methodsFor: 'editing' stamp: 'sw 9/8/1999 17:04'!acceptValue: aValue	| val |	self contents: (val := aValue asString).	^ val! !!TextLine methodsFor: 'private' stamp: 'di 10/20/97 23:08'!firstIndex: firstInteger lastIndex: lastInteger	firstIndex := firstInteger.	lastIndex := lastInteger! !!Morph methodsFor: 'naming' stamp: 'sw 10/27/2000 17:47'!tryToRenameTo: aName	"A new name has been submited; make sure it's appropriate, and react accordingly.  This circumlocution provides the hook by which the simple renaming of a field can result in a change to variable names in a stack, etc.  There are some problems to worry about here."	| aStack |	(self holdsSeparateDataForEachInstance and: [(aStack := self stack) notNil])		ifTrue:			[self topRendererOrSelf setNameTo: aName.			aStack reassessBackgroundShape]		ifFalse:			[self renameTo: aName]! !!ProgressBarMorph methodsFor: 'accessing' stamp: 'sma 3/3/2000 18:52'!progressColor: aColor	progressColor = aColor		ifFalse:			[progressColor := aColor.			self changed]! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ar 11/11/1998 19:39'!point: pt color: c	"Is there any use for this?"	| myPt |	transform 		ifNil:[myPt := pt]		ifNotNil:[myPt := transform localPointToGlobal: pt].	^super point: myPt color: c! !!MenuMorph methodsFor: 'construction' stamp: 'sw 11/6/2000 13:43'!addUpdating: wordingSelector target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  In this variant, the wording of the menu item is obtained by sending the wordingSelector to the target,  Answer the item added."	| item |	item := UpdatingMenuItemMorph new		target: target;		selector: aSymbol;		wordingProvider: target wordingSelector: wordingSelector;		arguments: argList asArray.	self addMorphBack: item.	^ item! !!Morph methodsFor: 'text-anchor' stamp: 'ar 12/17/2001 12:45'!addTextAnchorMenuItems: topMenu hand: aHand	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addUpdating: #hasInlineAnchorString action: #changeInlineAnchor.	aMenu addUpdating: #hasParagraphAnchorString action: #changeParagraphAnchor.	aMenu addUpdating: #hasDocumentAnchorString action: #changeDocumentAnchor.	topMenu ifNotNil:[topMenu add: 'text anchor' subMenu: aMenu].	^aMenu! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/16/2000 22:07'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w := h := borderWidth]			ifFalse: [w := borderWidth x.   h := borderWidth y].		rect := r translateBy: origin.		self setFillColor: bottomRightColor.		port 			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!PluggableTabButtonMorph methodsFor: 'access' stamp: 'KLC 1/22/2004 14:26'!active: aBoolean	active := aBoolean.	self changed.! !!Morph methodsFor: 'card in a stack' stamp: 'sw 11/8/2002 15:16'!installAsCurrent: anInstance	"Install anInstance as the one currently viewed in the receiver.  Dock up all the morphs in the receiver which contain data rooted in the player instance to the instance data.  Run any 'opening' scripts that pertain."	| fieldList itsFocus |	self player == anInstance ifTrue: [^ self].	fieldList := self allMorphs select:		[:aMorph | (aMorph wouldAcceptKeyboardFocusUponTab) and: [aMorph isLocked not]].	self currentWorld hands do:		[:aHand | (itsFocus := aHand keyboardFocus) notNil ifTrue:			[(fieldList includes: itsFocus) ifTrue: [aHand newKeyboardFocus: nil]]].	self player uninstallFrom: self.  "out with the old"	anInstance installPrivateMorphsInto: self.	self changed.	anInstance costume: self.	self player: anInstance.	self player class variableDocks do:		[:aVariableDock | aVariableDock dockMorphUpToInstance: anInstance].	self currentWorld startSteppingSubmorphsOf: self! !!TextMorphEditor methodsFor: 'events' stamp: 'th 9/18/2002 11:15'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval := self selectionInterval.	clickPoint := evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [		pivotBlock := paragraph characterBlockAtPoint: clickPoint.		self markBlock: pivotBlock.		self pointBlock: pivotBlock.		evt hand releaseKeyboardFocus: self.		^ self].	evt shiftPressed		ifFalse:			[self closeTypeIn.			pivotBlock := paragraph characterBlockAtPoint: clickPoint.			self markBlock: pivotBlock.			self pointBlock: pivotBlock.]		ifTrue:			[self closeTypeIn.			self mouseMove: evt].	self storeSelectionInParagraph! !!ScriptEditorMorph methodsFor: 'dropping/grabbing' stamp: 'ar 12/14/2001 17:41'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add tiles and program fragments just by dropping them on this morph."	| i slideMorph p1 p2 |	self prepareToUndoDropOf: aMorph.	"Find where it will go, and prepare to animate the move..."	i := self rowInsertionIndexFor: aMorph fullBounds center.	slideMorph := aMorph imageForm offset: 0@0.	p1 := aMorph screenRectangle topLeft.	aMorph delete.	self stopSteppingSelector: #trackDropZones.	self world displayWorld.  "Clear old image prior to animation"	(aMorph isKindOf: PhraseTileMorph) ifTrue:		[aMorph justGrabbedFromViewer: false].	aMorph tileRows do: [:tileList |		self insertTileRow: (Array with:				(tileList first rowOfRightTypeFor: owner forActor: aMorph associatedPlayer))			after: i.		i := i + 1].	self removeSpaces.	self enforceTileColorPolicy.	self layoutChanged.	self fullBounds. "force layout"	"Now animate the move, before next Morphic update.		NOTE: This probably should use ZoomMorph instead"	p2 := (self submorphs atPin: (i-1 max: firstTileRow)) screenRectangle topLeft.	slideMorph slideFrom: p1 to: p2 nSteps: 5 delay: 50 andStay: true.	self playSoundNamed: 'scritch'.	self topEditor install  "Keep me for editing, a copy goes into lastAcceptedScript"! !!TheWorldMenu methodsFor: 'commands' stamp: 'RAA 6/15/2000 10:17'!projectForMyWorld        ^myProject ifNil: [myProject := myWorld project]! !!PolygonMorph methodsFor: 'geometry' stamp: 'nk 4/18/2002 16:58'!reduceVertices	"Reduces the vertices size, when 3 vertices are on the same line with a 	little epsilon. Based on code by Steffen Mueller"	| dup |	[ (dup := self nextDuplicateVertexIndex) > 0 ] whileTrue: [		self setVertices: (vertices copyWithoutIndex: dup)	].	^vertices size.! !!ScriptEditorMorph methodsFor: 'private' stamp: 'ar 11/9/2000 20:43'!insertTileRow: tileList after: index	"Return a row to be used to insert an entire row of tiles."	| row |	row := AlignmentMorph newRow		vResizing: #spaceFill;		layoutInset: 0;		extent: (bounds width)@(TileMorph defaultH);		color: Color transparent.	row addAllMorphs: tileList.	self privateAddMorph: row atIndex: index + 1.! !!TheWorldMenu methodsFor: 'commands' stamp: 'dgd 10/8/2003 20:11'!worldMenuHelp	| aList aMenu cnts explanation |	"self currentWorld primaryHand worldMenuHelp"	aList := OrderedCollection new.	#(helpMenu changesMenu openMenu debugMenu projectMenu scriptingMenu windowsMenu playfieldMenu appearanceMenu flapsMenu) 		with:	#('help' 'changes' 'open' 'debug' 'projects' 'authoring tools' 'windows' 'playfield options' 'appearance' 'flaps') do:		[:sel :title | aMenu := self perform: sel.			aMenu items do:				[:it | (((cnts := it contents) = 'keep this menu up') or: [cnts isEmpty])					ifFalse: [aList add: (cnts, ' - ', title translated)]]].	aList := aList asSortedCollection: [:a :b | a asLowercase < b asLowercase].	explanation := String streamContents: [:aStream | aList do:		[:anItem | aStream nextPutAll: anItem; cr]].	(StringHolder new contents: explanation)		openLabel: 'Where in the world menu is...' translated! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:59'!maxCellSize	"Layout specific. This property specifies the maximum size of a table cell."	| props |	props := self layoutProperties.	^props ifNil:[SmallInteger maxVal] ifNotNil:[props maxCellSize].! !!Morph methodsFor: 'e-toy support' stamp: 'nb 6/17/2003 12:25'!followPath	| pathPoints offset |	(pathPoints := self renderedMorph valueOfProperty: #pathPoints) ifNil: [^ Beeper beep].	offset := owner position - (self extent // 2).	pathPoints do:		[:aPoint |			self position: aPoint + offset.			self world displayWorld.			(Delay forMilliseconds: 20) wait]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'yo 6/9/2004 07:09'!readFromTarget	"Update my readout from my target"	| v ret |	(target isNil or: [getSelector isNil]) ifTrue: [^contents].	ret := self checkTarget.	ret ifFalse: [^ '0'].	v := target perform: getSelector.	"scriptPerformer"	(v isKindOf: Text) ifTrue: [v := v asString].	^self acceptValueFromTarget: v! !!PluggableListMorph methodsFor: 'scroll cache' stamp: 'sps 4/3/2005 15:29'!resetHScrollRangeIfNecessary	hScrollRangeCache ifNil: [ ^self deriveHScrollRange ].	(list isNil or: [list isEmpty]) 		ifTrue:[^hScrollRangeCache := Array with: 0 with: 0 with: 0 with: 0 with: 0]."Make a guess as to whether the scroll ranges need updating based on whether the size, first item, or last item of the list has changed"	(		(hScrollRangeCache third == list size) and: [		(hScrollRangeCache fourth == list first) and: [		(hScrollRangeCache fifth == list last)	]])		ifFalse:[self deriveHScrollRange].! !!SelectionMorph methodsFor: 'geometry' stamp: 'jcg 2/14/2001 08:58'!bounds: newBounds	"Make sure position: gets called before extent:; Andreas' optimization for growing/shrinking in ChangeSet 3119 screwed up selection of morphs from underlying pasteup."	selectedItems := OrderedCollection new.  "Avoid repostioning items during super position:"	self position: newBounds topLeft; extent: newBounds extent! !!SimpleHierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'ar 10/14/2003 23:39'!setSelectionIndex: idx	"Called internally to select the index-th item."	| theMorph index |	idx ifNil: [^ self].	index := idx min: scroller submorphs size max: 0.	theMorph := index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index].	self setSelectedMorph: theMorph.! !!TextMorphEditor methodsFor: 'accessing' stamp: 'tk 12/18/2001 10:25'!setSearch: aString	| bk |	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	(bk := morph ownerThatIsA: BookMorph) ifNotNil: [		bk setProperty: #tempSearchKey 			toValue: (aString findTokens: Character separators)].	FindText string = aString		ifFalse: [FindText := ChangeText := aString asText]! !!ScrollBar methodsFor: 'initialize' stamp: 'wiz 12/22/2007 23:01'!initializeMenuButton"initialize the receiver's menuButton"	"Preferences disable: #scrollBarsWithoutMenuButton"	"Preferences enable: #scrollBarsWithoutMenuButton"	(Preferences valueOfFlag: #scrollBarsWithoutMenuButton)		ifTrue: [menuButton := nil .^ self].	menuButton := self roundedScrollbarLook		ifTrue: [RectangleMorph					newBounds: ((bounds isWide							ifTrue: [upButton bounds topRight]							ifFalse: [upButton bounds bottomLeft])							extent: self buttonExtent)]		ifFalse: [RectangleMorph					newBounds: (self innerBounds topLeft extent: self buttonExtent)					color: self thumbColor].	menuButton		on: #mouseEnter		send: #menuButtonMouseEnter:		to: self.	menuButton		on: #mouseDown		send: #menuButtonMouseDown:		to: self.	menuButton		on: #mouseLeave		send: #menuButtonMouseLeave:		to: self.	"menuButton 	addMorphCentered: (RectangleMorph 	newBounds: (0 @ 0 extent: 4 @ 2) 	color: Color black)."	self updateMenuButtonImage.	self roundedScrollbarLook		ifTrue: [menuButton color: Color veryLightGray.			menuButton				borderStyle: (BorderStyle complexRaised width: 3)]		ifFalse: [menuButton setBorderWidth: 1 borderColor: Color lightGray].	self addMorph: menuButton! !!KeyboardEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:54'!setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp	type := aSymbol.	buttons := anInteger.	position := pos.	keyValue := aValue.	source := aHand.	wasHandled := false.	timeStamp := stamp.! !!PasteUpMorph methodsFor: 'cursor' stamp: 'sw 5/12/1998 10:55'!rectifyCursor	cursor := ((cursor truncated max: 1) min: submorphs size)! !!Morph methodsFor: 'e-toy support' stamp: 'sw 9/11/2004 16:23'!referencePlayfield	"Answer the PasteUpMorph to be used for cartesian-coordinate reference"	| former |	owner ifNotNil:		[(self topRendererOrSelf owner isHandMorph and: [(former := self formerOwner) notNil])			ifTrue:				[former := former renderedMorph.				^ former isPlayfieldLike 					ifTrue: [former]					ifFalse: [former referencePlayfield]]].	self allOwnersDo: [:o | o isPlayfieldLike ifTrue: [^ o]].	^ ActiveWorld! !!HaloMorph methodsFor: 'private' stamp: 'ar 10/7/2000 23:36'!basicBox	| aBox minSide anExtent w |	minSide := 4 * self handleSize.	anExtent := ((self width + self handleSize + 8) max: minSide) @				((self height + self handleSize + 8) max: minSide).	aBox := Rectangle center: self center extent: anExtent.	w := self world ifNil:[target outermostWorldMorph].	^ w		ifNil:			[aBox]		ifNotNil:			[aBox intersect: (w viewBox insetBy: 8@8)]! !!SketchMorph methodsFor: 'initialization' stamp: 'ar 9/22/2000 20:38'!initializeWith: aForm	super initialize.	originalForm := aForm.	self rotationCenter: 0.5@0.5.		"relative to the top-left corner of the Form"	rotationStyle := #normal.		"styles: #normal, #leftRight, #upDown, or #none"	scalePoint := 1.0@1.0.	framesToDwell := 1.	rotatedForm := originalForm.	"cached rotation of originalForm"	self extent: originalForm extent.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/9/2000 16:48'!listViewLineForFieldList: aFieldList	"Answer a ListLineView object which describes the receiver"	| aLine |	aLine := ListViewLine new objectRepresented: self.	aFieldList do:		[:fieldSym | aLine addMorphBack: (self readoutForField: fieldSym).		aLine addTransparentSpacerOfSize: (7 @ 0)].	^ aLine! !!MenuMorph methodsFor: 'construction' stamp: 'ar 12/16/2001 16:53'!add: aString subMenu: aMenuMorph target: target selector: aSymbol argumentList: argList	"Append the given submenu with the given label."	| item |	item := MenuItemMorph new.	item 		contents: aString;		target: target;		selector: aSymbol;		arguments: argList asArray;		subMenu: aMenuMorph.	self addMorphBack: item.	^item! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 3/21/2006 23:03'!splitterRight	| splitters |	splitters := ((self siblingSplitters select: [:each | each x > self x]) asSortedCollection: [:a :b | a x < b x]).		^ splitters ifEmpty: nil ifNotEmpty: [splitters first]! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/20/2001 22:44'!margins: newMargins	"newMargins can be a number, point or rectangle, as allowed by, eg, insetBy:."	margins := newMargins.	self composeToBounds! !!Morph methodsFor: 'structure' stamp: 'RAA 6/13/2000 15:01'!primaryHand        | outer |        outer := self outermostWorldMorph ifNil: [^ nil].        ^ outer activeHand ifNil: [outer firstHand]! !!NewParagraph methodsFor: 'editing' stamp: 'mk 5/28/2005 11:15'!clickAt: clickPoint for: model controller: editor	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action target range boxes box |	action := false.	startBlock := self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[(target := model) ifNil: [target := editor morph].				range := text rangeOf: att startingAt: startBlock stringIndex.				boxes := self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last+1).				box := boxes detect: [:each | each containsPoint: clickPoint] ifNone: [nil].				box ifNotNil:					[ box := (editor transformFrom: nil) invertBoundsRect: box.					editor morph allOwnersDo: [ :m | box := box intersect: (m boundsInWorld) ].					Utilities awaitMouseUpIn: box						repeating: []						ifSucceed: [(att actOnClickFor: target in: self at: clickPoint editor: editor) ifTrue: [action := true]].					Cursor currentCursor == Cursor webLink ifTrue:[Cursor normal show].				]]].	^ action! !!MenuItemMorph methodsFor: 'private' stamp: 'ar 9/17/2000 18:36'!offImage	"Return the form to be used for indicating an '<off>' marker"	| form |	form := Form extent: (self fontToUse ascent-2) asPoint depth: 16.	(form getCanvas)		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.9) 			borderWidth: 1 borderColor: Color black.	^form! !!Morph methodsFor: 'copying' stamp: 'nk 3/12/2001 17:07'!duplicateMorphCollection: aCollection	"Make and return a duplicate of the receiver"	| newCollection names |	names := aCollection collect: [ :ea | | newMorph w |		(w := ea world) ifNotNil:			[w nameForCopyIfAlreadyNamed: ea].	].	newCollection := aCollection veryDeepCopy.	newCollection with: names do: [ :newMorph :name |		name ifNotNil: [ newMorph setNameTo: name ].		newMorph arrangeToStartStepping.		newMorph privateOwner: nil. "no longer in world"		newMorph isPartsDonor: false. "no longer parts donor"	].	^newCollection! !!UserInputEvent methodsFor: 'printing' stamp: 'ar 10/7/2000 21:56'!modifierString	"Return a string identifying the currently pressed modifiers"	| string |	string := ''.	self commandKeyPressed ifTrue:[string := string,'CMD '].	self shiftPressed ifTrue:[string := string,'SHIFT '].	self controlKeyPressed ifTrue:[string := string,'CTRL '].	^string! !!GradientFillStyle methodsFor: '*Morphic-Balloon' stamp: 'nk 7/18/2003 16:35'!firstColor: aColor forMorph: aMorph hand: aHand	colorRamp first value: aColor.	isTranslucent := nil.	pixelRamp := nil.	aMorph changed.! !!ScrollBar methodsFor: 'scrolling' stamp: 'RAA 12/29/2000 11:56'!setNextDirectionFromEvent: event	nextPageDirection := bounds isWide ifTrue: [		event cursorPoint x >= slider center x	]	ifFalse: [		event cursorPoint y >= slider center y	]! !!Morph methodsFor: 'accessing' stamp: 'nk 4/14/2004 17:48'!borderWidth: aNumber	| style |	style := self borderStyle.	style width = aNumber ifTrue: [ ^self ].	style style = #none		ifTrue: [ self borderStyle: (SimpleBorder width: aNumber color: Color transparent) ]		ifFalse: [ style width: aNumber. self changed ].! !!NewParagraph methodsFor: 'composition' stamp: 'RAA 2/25/2001 15:02'!fixLastWithHeight: lineHeightGuess"This awful bit is to ensure that if we have scanned all the text and the last character is a CR that there is a null line at the end of lines. Sometimes this was not happening which caused anomalous selections when selecting all the text. This is implemented as a post-composition fixup because I coul;dn't figure out where to put it in the main logic."	| oldLastLine newRectangle line |	(text size > 1 and: [text last = Character cr]) ifFalse: [^self].	oldLastLine := lines last.	oldLastLine last - oldLastLine first >= 0 ifFalse: [^self].	oldLastLine last = text size ifFalse: [^self].	newRectangle := oldLastLine left @ oldLastLine bottom 				extent: 0@(oldLastLine bottom - oldLastLine top).	"Even though we may be below the bottom of the container,	it is still necessary to compose the last line for consistency..."	line := TextLine start: text size+1 stop: text size internalSpaces: 0 paddingWidth: 0.	line rectangle: newRectangle.	line lineHeight: lineHeightGuess baseline: textStyle baseline.	lines := lines, (Array with: line).! !!NewParagraph methodsFor: 'selection' stamp: 'ar 4/12/2005 19:53'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line := lines at: (self lineIndexForCharacter: index).	^ ((text string isWideString) ifTrue: [		MultiCharacterBlockScanner new text: text textStyle: textStyle	] ifFalse: [		CharacterBlockScanner new text: text textStyle: textStyle	])		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'nk 1/11/2004 15:29'!doneWithEdits	"If in a SyntaxMorph, shrink min width after editing"	| editor |	super doneWithEdits.	(owner respondsTo: #parseNode) ifTrue: [minimumWidth := 8].	editor := (submorphs detect: [ :sm | sm isKindOf: StringMorphEditor ] ifNone: [ ^self ]).	editor delete.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/7/98 19:16'!triggerOnMouseDown: aBoolean	"If this preference is turned on, then trigger my action immediately when the mouse goes down."	triggerOnMouseDown := aBoolean.! !!MatrixTransformMorph methodsFor: 'geometry eToy' stamp: 'ar 6/12/2001 05:50'!setDirectionFrom: aPoint	| delta degrees |	delta := (self transformFromWorld globalPointToLocal: aPoint) - super rotationCenter.	degrees := delta degrees + 90.0.	self forwardDirection: (degrees \\ 360) rounded.! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/21/2001 10:35'!textColor: aColor	color = aColor ifTrue: [^ self].	color := aColor.	self changed.! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 18:03'!printPSToFileNamed: aString 	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag psCanvasType psExtension |	fileName := aString asFileName.	psCanvasType := PostscriptCanvas defaultCanvasType.	psExtension := psCanvasType defaultExtension.	fileName := FillInTheBlank request: (String streamContents: [ :s |		s nextPutAll: ('File name? ("{1}" will be added to end)' translated format: {psExtension})])			initialAnswer: fileName.	fileName isEmpty		ifTrue: [^ Beeper beep].	(fileName endsWith: psExtension)		ifFalse: [fileName := fileName , psExtension].	rotateFlag := ((PopUpMenu labels: 'portrait (tall)landscape (wide)' translated)				startUpWithCaption: 'Choose orientation...' translated)				= 2.	((FileStream newFileNamed: fileName asFileName) converter: TextConverter defaultSystemConverter)		nextPutAll: (psCanvasType morphAsPostscript: self rotated: rotateFlag);		 close! !!HandMorph methodsFor: 'multilingual' stamp: 'yo 9/26/2003 22:11'!clearKeyboardInterpreter	keyboardInterpreter := nil.! !!Morph methodsFor: 'layout' stamp: 'ar 11/2/2000 17:42'!submorphBounds	"Private. Compute the actual full bounds of the receiver"	| box subBox |	submorphs do: [:m | 		(m visible) ifTrue: [			subBox := m fullBounds.			box 				ifNil:[box := subBox copy]				ifNotNil:[box := box quickMerge: subBox]]].	box ifNil:[^self bounds]. "e.g., having submorphs but not visible"	^ box origin asIntegerPoint corner: box corner asIntegerPoint! !!TextMorph class methodsFor: 'parts bin' stamp: 'nk 7/12/2003 08:59'!fancyPrototype	| t |	t := self authoringPrototype.	t autoFit: false; extent: 150@75.	t borderWidth: 2; margins: 4@0; useRoundedCorners.	"Why not rounded?"	"fancy font, shadow, rounded"	t fontName: Preferences standardEToysFont familyName size: 18; textColor: Color blue; backgroundColor: Color lightBrown.	t addDropShadow."Strangeness here in order to avoid two offset copies of the default contents when operating in an mvc project before cursor enters the morphic window"	t paragraph.	^ t! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!triggerClosingScripts	"If the receiver has any scripts set to run on closing, run them now"	| aPlayer |	(aPlayer := self player) ifNotNil:		[aPlayer runAllClosingScripts]! !!SystemProgressMorph methodsFor: 'initialization' stamp: 'laza 4/20/2004 10:40'!initialize	super initialize.	activeSlots := 0.	bars := Array new: 10.	labels := Array new: 10.	font := Preferences windowTitleFont.	lock := Semaphore forMutualExclusion.	self setDefaultParameters;		setProperty: #morphicLayerNumber toValue: self morphicLayerNumber;		layoutPolicy: TableLayout new;		listDirection: #topToBottom;		cellPositioning: #topCenter;		cellInset: 5;		listCentering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		layoutInset:4@4.! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'di 5/25/2001 01:40'!fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	"draw the border of the oval"	rect := (r translateBy: origin) truncated.	(borderWidth = 0 or: [borderColor isTransparent]) ifFalse:[		self setFillColor: borderColor.		(r area > 10000 or: [fillColor isTranslucent]) 			ifTrue: [port frameOval: rect borderWidth: borderWidth]			ifFalse: [port fillOval: rect]]. "faster this way"	"fill the inside"	fillColor isTransparent ifFalse:		[self setFillColor: fillColor.		port fillOval: (rect insetBy: borderWidth)].! !!PasteUpMorph methodsFor: 'model' stamp: 'sw 4/1/98 21:17'!setModel: aModelMorph	"Set the model for this world. Methods for sensitized morphs will be compiled into the class for this model."	model := aModelMorph! !!SystemWindow methodsFor: 'panes' stamp: 'md 2/24/2006 15:58'!addMorph: aMorph fullFrame: aLayoutFrame	| left right bottom top windowBorderWidth |	windowBorderWidth := self class borderWidth.	left := aLayoutFrame leftOffset ifNil: [0].	right := aLayoutFrame rightOffset ifNil: [0].	bottom := aLayoutFrame bottomOffset ifNil: [0].	top := aLayoutFrame topOffset ifNil: [0].		aLayoutFrame rightFraction = 1 ifTrue: [aLayoutFrame rightOffset: right - windowBorderWidth].	aLayoutFrame leftFraction = 0		ifTrue: [aLayoutFrame leftOffset: left + windowBorderWidth]		ifFalse: [aLayoutFrame leftOffset: left + ProportionalSplitterMorph splitterWidth].	aLayoutFrame bottomFraction = 1 ifTrue: [aLayoutFrame bottomOffset: bottom - windowBorderWidth].	aLayoutFrame topFraction = 0		ifTrue: [aLayoutFrame topOffset: top]		ifFalse: [aLayoutFrame topOffset: top + ProportionalSplitterMorph splitterWidth].		(aMorph class name = #BrowserCommentTextMorph) ifTrue:		[aLayoutFrame rightOffset: windowBorderWidth negated.		aLayoutFrame leftOffset: windowBorderWidth.		aLayoutFrame bottomOffset: windowBorderWidth negated.		aLayoutFrame topOffset: (windowBorderWidth negated) + 4].		super addMorph: aMorph fullFrame: aLayoutFrame.	paneMorphs := paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	aMorph adoptPaneColor: self paneColor.	aMorph borderWidth: 1; borderColor: Color lightGray; color: Color white.	Preferences scrollBarsOnRight	"reorder panes so flop-out right-side scrollbar is visible"		ifTrue: [self addMorphBack: aMorph].			self addPaneSplitters! !!BalloonMorph class methodsFor: 'utility' stamp: 'sma 11/11/2000 14:59'!setBalloonColorTo: aColor 	aColor ifNotNil: [BalloonColor := aColor]! !!PasteUpMorph methodsFor: 'painting' stamp: 'bf 10/2/2002 17:07'!backgroundSketch	backgroundMorph ifNil: [^ nil].	backgroundMorph owner == self ifFalse:		[backgroundMorph := nil].	"has been deleted"	^ backgroundMorph! !!WorldState methodsFor: 'alarms' stamp: 'RAA 1/5/2001 10:46'!alarms	^alarms ifNil: [alarms := Heap sortBlock: self alarmSortBlock]! !!StringMorphEditor methodsFor: 'event handling' stamp: 'nk 6/12/2004 22:07'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor newSel |	(((char := evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner doneWithEdits; acceptContents.	self flag: #arNote. "Probably unnecessary"						evt hand releaseKeyboardFocus.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand releaseKeyboardFocus.		^ self delete].	super keyStroke: evt.	owner interimContents: self contents asString.	newSel := self editor selectionInterval.	priorEditor := self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	self editor selectFrom: newSel first to: newSel last.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'dgd 8/30/2003 20:42'!buildDebugMenu: aHandMorph	| aMenu |	aMenu := super buildDebugMenu: aHandMorph.	aMenu add:  'abandon costume history' translated target: self action: #abandonCostumeHistory.	^ aMenu! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 5/4/1998 16:29'!onColor: colorWhenOn offColor: colorWhenOff	"Set the fill colors to be used when this button is on/off."	onColor := colorWhenOn.	offColor := colorWhenOff.	self update: nil.! !!DropEvent methodsFor: 'transforming' stamp: 'ar 10/7/2000 18:28'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position :=  aMorphicTransform globalPointToLocal: position.! !!InsetBorder methodsFor: 'accessing' stamp: 'ar 11/26/2001 15:23'!colorsAtCorners	| c c14 c23 |	c := self color.	c14 := c lighter. c23 := c darker.	^Array with: c23 with: c14 with: c14 with: c23.! !!ProjectViewMorph methodsFor: 'events' stamp: 'RAA 11/2/2000 10:06'!project: aProject	project := aProject.	self addProjectNameMorphFiller.! !!Morph methodsFor: 'accessing' stamp: 'sw 8/11/1998 16:46'!actorState	"This method instantiates actorState as a side-effect.	For simple queries, use actorStateOrNil"	| state |	state := self actorStateOrNil.	state ifNil:		[state := ActorState new initializeFor: self assuredPlayer.		self actorState: state].	^ state! !!SelectionMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:23'!initialize	"initialize the state of the receiver"	super initialize.	""		selectedItems := OrderedCollection new.	itemsAlreadySelected := OrderedCollection new.	slippage := 0 @ 0! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!setItem: anObject name: aString model: aModel parent: itemParent	parent := itemParent.	self setItem: anObject name: aString model: aModel! !!TextLine methodsFor: 'updating' stamp: 'di 10/20/97 23:25'!slide: delta 	"Change the starting and stopping points of the line by delta."	firstIndex := firstIndex + delta.	lastIndex := lastIndex + delta! !!PasteUpMorph methodsFor: 'options' stamp: 'dgd 9/6/2003 18:05'!setThumbnailHeight	|  reply |	(self hasProperty: #alwaysShowThumbnail) ifFalse:		[^ self inform: 'setting the thumbnail height is onlyapplicable when you are currentlyshowing thumbnails.' translated].	reply := FillInTheBlank		request: 'New height for thumbnails? ' translated		initialAnswer: self heightForThumbnails printString.	reply isEmpty ifTrue: [^ self].	reply := reply asNumber.	(reply > 0 and: [reply <= 150]) ifFalse:		[^ self inform: 'Please be reasonable!!' translated].	self setProperty: #heightForThumbnails toValue: reply.	self updateSubmorphThumbnails! !!FillInTheBlankMorph methodsFor: 'menu' stamp: 'sw 1/31/2000 11:11'!cancel	"Sent by the cancel button."	response := responseUponCancel.	done := true.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 9/1/2003 14:47'!extent: x	| newExtent tw menu |	newExtent := x max: self minWidth@self minHeight.	(tw := self findA: TwoWayScrollPane) ifNil:		["This was the old behavior"		^ super extent: newExtent].	(self hasProperty: #autoFitContents) ifTrue: [		menu := MenuMorph new defaultTarget: self.		menu addUpdating: #autoFitString target: self action: #autoFitOnOff.		menu addTitle: 'To resize the script, uncheck the box below' translated.		menu popUpEvent: nil in: self world	.		^ self].	"Allow the user to resize to any size"	tw extent: ((newExtent x max: self firstSubmorph width)				@ (newExtent y - self firstSubmorph height)) - (borderWidth*2) + (-4@-4).  "inset?"	^ super extent: newExtent! !!PasteUpMorph class methodsFor: 'project' stamp: 'di 7/15/1999 09:51'!MinCycleLapse: milliseconds	"set the minimum amount of time that may transpire between two calls to doOneCycle"	MinCycleLapse := milliseconds ifNotNil: [ milliseconds rounded ].! !!FormCanvas class methodsFor: 'testing' stamp: 'ar 12/31/2001 02:26'!test2	"FormCanvas test2"	| baseCanvas p |	baseCanvas := FormCanvas extent: 200@200.	p := Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		baseCanvas translateBy: (Sensor cursorPoint - p) during:[:canvas|			canvas fillColor: Color white.			canvas line: 10@10 to: 50@30 width: 1 color: Color red.			canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.			canvas point: 100@100 color: Color black.			canvas drawString: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.			canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.			canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.			canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.			canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.			canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.			canvas showAt: 0@0]].! !!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/2/98 00:05'!arguments: aCollection	arguments := aCollection asArray copy.! !!PolygonMorph methodsFor: 'private' stamp: 'ar 5/25/2000 18:04'!borderForm	"A form must be created for drawing the border whenever the borderColor is translucent."	| borderCanvas |	borderForm ifNotNil: [^ borderForm].	borderCanvas := (Display defaultCanvasClass extent: bounds extent depth: 1)		shadowColor: Color black.	borderCanvas translateBy: bounds topLeft negated		during:[:tempCanvas| self drawBorderOn: tempCanvas].	borderForm := borderCanvas form.	self arrowForms do:		[:f |  "Eliminate overlap between line and arrowheads if transparent."		borderForm copy: f boundingBox from: f to: f offset - self position rule: Form erase].	^ borderForm! !!HaloMorph methodsFor: 'events' stamp: 'tk 7/14/2001 11:04'!dragTarget: event	"Begin dragging the target"	| thePoint |	thePoint := target point: event position - positionOffset from: owner.	target setConstrainedPosition: thePoint hangOut: true.	event hand newMouseFocus: self.! !!PasteUpMorph methodsFor: 'event handling' stamp: 'dgd 9/27/2004 13:56'!mouseDown: evt	"Handle a mouse down event."	| grabbedMorph handHadHalos |	(Preferences generalizedYellowButtonMenu			and: [evt yellowButtonPressed])		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	grabbedMorph := self morphToGrab: evt.	grabbedMorph ifNotNil:[		grabbedMorph isSticky ifTrue:[^self].		self isPartsBin ifFalse:[^evt hand grabMorph: grabbedMorph].		grabbedMorph := grabbedMorph partRepresented duplicate.		grabbedMorph restoreSuspendedEventHandler.		(grabbedMorph fullBounds containsPoint: evt position) 			ifFalse:[grabbedMorph position: evt position].		"Note: grabbedMorph is ownerless after duplicate so use #grabMorph:from: instead"		^ evt hand grabMorph: grabbedMorph from: self].	(super handlesMouseDown: evt)		ifTrue:[^super mouseDown: evt].	handHadHalos := evt hand halo notNil.	evt hand removeHalo. "shake off halos"	evt hand releaseKeyboardFocus. "shake of keyboard foci"	self submorphs		select:[:each | each hasProperty: #morphHierarchy]		thenDo:[:each | each delete].	Preferences noviceMode		ifTrue:[			self submorphs				select:[:each | (each isKindOf: MenuMorph) and:[each stayUp not]]				thenDo:[:each | each delete].		].	(evt shiftPressed not			and:[ self isWorldMorph not ]			and:[ self wantsEasySelection not ])	ifTrue:[		"explicitly ignore the event if we're not the world and we'll not select,		so that we could be picked up if need be"		evt wasHandled: false.		^ self.	].	( evt shiftPressed or: [ self wantsEasySelection ] ) ifTrue:[		"We'll select on drag, let's decide what to do on click"		| clickSelector |		clickSelector := nil.		evt shiftPressed ifTrue:[			clickSelector := #findWindow:.		]		ifFalse:[			self isWorldMorph ifTrue:[				clickSelector := handHadHalos										ifTrue: [ #delayedInvokeWorldMenu: ]										ifFalse: [ #invokeWorldMenu: ]			]		].		evt hand 				waitForClicksOrDrag: self 				event: evt 				selectors: { clickSelector. nil. nil. #dragThroughOnDesktop: }				threshold: 5.	]	ifFalse:[		"We wont select, just bring world menu if I'm the world"		self isWorldMorph ifTrue:[			handHadHalos				ifTrue: [ self delayedInvokeWorldMenu: evt ]				ifFalse: [ self invokeWorldMenu: evt ]		]	].! !!StringMorphAttributeScanner methodsFor: 'scanning' stamp: 'nk 2/26/2004 12:39'!setAlignment: aSymbol	"Set the value of alignment"	alignment := aSymbol! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 3/23/2004 23:25'!vSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta |	scroller hasSubmorphs ifFalse:[scrollBar interval: 1.0. ^self].		delta := self scrollDeltaHeight.	range := self vLeftoverScrollRange.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	scrollBar scrollDelta: (delta / range) asFloat 			pageDelta: ((self innerBounds height - delta) / range) asFloat.	scrollBar interval: ((self innerBounds height) / self vTotalScrollRange) asFloat.	scrollBar setValue: (scroller offset y / range min: 1.0) asFloat.! !!SimpleButtonMorph methodsFor: 'submorphs-add/remove' stamp: 'nk 6/13/2004 13:46'!actWhen: condition	"Accepts symbols:  #buttonDown, #buttonUp, and #whilePressed, #startDrag"	actWhen := condition.	actWhen == #startDrag		ifFalse: [self on: #startDrag send: nil to: nil ]		ifTrue:[self on: #startDrag send: #doButtonAction to: self].! !!MenuItemMorph methodsFor: 'grabbing' stamp: 'spfa 3/13/2004 18:34'!aboutToBeGrabbedBy: aHand	"Don't allow the receiver to act outside a Menu"	| menu box |	(owner notNil and:[owner submorphs size = 1]) ifTrue:[		"I am a lonely menuitem already; just grab my owner"		owner stayUp: true.		^owner 	aboutToBeGrabbedBy: aHand].	box := self bounds.	menu := MenuMorph new defaultTarget: nil.	menu addMorphFront: self.	menu bounds: box.	menu stayUp: true.	self isSelected: false.	^menu! !!TextContainer methodsFor: 'access' stamp: 'di 11/16/97 09:39'!releaseCachedState	shadowForm := nil.	vertProfile := nil.	rectangleCache := Dictionary new.! !!Morph methodsFor: 'private' stamp: 'RAA 5/23/2000 11:31'!privateDeleteWithAbsolutelyNoSideEffects	"Private!! Should only be used by methods that maintain the ower/submorph invariant."	"used to delete a morph from an inactive world"	owner ifNil: [^self].	owner privateRemoveMorphWithAbsolutelyNoSideEffects: self.	owner := nil.! !!ProgressBarMorph methodsFor: 'updating' stamp: 'sma 3/3/2000 18:51'!update: aSymbol 	aSymbol == #contents		ifTrue: 			[lastValue := value contents.			self changed]! !!SimpleHierarchicalListMorph methodsFor: 'accessing' stamp: 'sps 12/28/2002 02:27'!lineColor: aColor	^lineColor := aColor! !!Morph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 17:30'!initialize	"initialize the state of the receiver"owner := nil.	submorphs := EmptyArray.	bounds := self defaultBounds.		color := self defaultColor! !!Slider methodsFor: 'access' stamp: 'sw 3/12/2000 11:57'!descending: aBoolean	descending := aBoolean.	self value: value! !!SelectionMorph methodsFor: 'accessing' stamp: 'di 9/19/2000 18:25'!borderWidth: aWidth	| bordered |	bordered := selectedItems select: [:m | m isKindOf: BorderedMorph].	undoProperties ifNil: [undoProperties := bordered collect: [:m | m borderWidth]].	bordered do: [:m | m borderWidth: aWidth]! !!Morph methodsFor: 'drawing' stamp: 'nk 9/1/2004 15:08'!imageForm: depth backgroundColor: aColor forRectangle: rect	| canvas |	canvas := Display defaultCanvasClass extent: rect extent depth: depth.	canvas translateBy: rect topLeft negated		during:[:tempCanvas| 			tempCanvas fillRectangle: rect color: aColor.			tempCanvas fullDrawMorph: self].	^ canvas form offset: rect topLeft! !!ScriptEditorMorph methodsFor: 'menu' stamp: 'tk 8/22/2001 10:49'!autoFitOnOff	"Toggle between auto fit to size of code and manual resize with scrolling"	| tw |	(tw := self findA: TwoWayScrollPane) ifNil: [^ self].	(self hasProperty: #autoFitContents)		ifTrue: [self removeProperty: #autoFitContents.			self hResizing: #rigid; vResizing: #rigid]		ifFalse: [self setProperty: #autoFitContents toValue: true.			self hResizing: #shrinkWrap; vResizing: #shrinkWrap].	tw layoutChanged! !!Morph methodsFor: 'naming' stamp: 'sw 1/29/2001 02:49'!updateAllScriptingElements	"A sledge-hammer sweep from the world down to make sure that all live scripting elements are up to date.  Presently in eclipse, not sent at the moment."	| aPasteUp |	(aPasteUp := self topPasteUp) ifNotNil:		[aPasteUp allTileScriptingElements do: [:m | m bringUpToDate]]! !!PluggableListMorph methodsFor: 'updating' stamp: 'ls 6/22/2001 23:56'!updateList	| index |	"the list has changed -- update from the model"	self listMorph listChanged.	self setScrollDeltas.	scrollBar setValue: 0.0.	index := self getCurrentSelectionIndex.	self resetPotentialDropRow.	self selectionIndex: index.! !!ScrollBar methodsFor: 'stepping and presenter' stamp: 'ar 10/7/2000 15:02'!step	| action |	action := self scrollBarAction.	action ifNotNil:[self perform: action].! !!HaloMorph methodsFor: 'drawing' stamp: 'ar 8/8/2001 15:13'!drawSubmorphsOn: aCanvas	| alpha |	((alpha := self magicAlpha) = 1.0)		ifTrue:[^super drawSubmorphsOn: aCanvas].	^super drawSubmorphsOn: (aCanvas asAlphaBlendingCanvas: alpha)! !!Slider methodsFor: 'scrolling' stamp: 'sw 3/10/2000 13:37'!scrollAbsolute: event	| r p |	r := self roomToMove.	bounds isWide		ifTrue: [r width = 0 ifTrue: [^ self]]		ifFalse: [r height = 0 ifTrue: [^ self]].	p := event targetPoint adhereTo: r.	self descending		ifFalse:			[self setValue: (bounds isWide 				ifTrue: [(p x - r left) asFloat / r width]				ifFalse: [(p y - r top) asFloat / r height])]		ifTrue:			[self setValue: (bounds isWide				ifTrue: [(r right - p x) asFloat / r width]				ifFalse:	[(r bottom - p y) asFloat / r height])]! !!HandMorph methodsFor: 'private events' stamp: 'yo 7/25/2003 16:56'!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type pressType stamp char |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	modifiers := evtBuf fifth.	buttons := modifiers bitShift: 3.	char := self keyboardInterpreter nextCharFrom: Sensor firstEvt: evtBuf.	^ KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: char asciiValue		hand: self		stamp: stamp.! !!WorldState methodsFor: 'hands' stamp: 'ar 10/26/2000 14:51'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	hands := (hands copyWithout: aHandMorph) copyWith: aHandMorph.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 4/12/2005 23:07'!handUserASibling	"Make and hand the user a sibling instance.  Force the creation of a uniclass at this point if one does not already exist for the receiver."	| topRend |	topRend := self topRendererOrSelf.	topRend couldMakeSibling ifFalse: [^ Beeper beep].	topRend assuredPlayer assureUniClass.	(topRend makeSiblings: 1) first openInHand! !!TransformationMorph methodsFor: 'geometry eToy' stamp: 'sw 3/28/2001 14:24'!referencePosition	"Answer the  receiver's reference position, bullet-proofed against infinite recursion in the unlikely but occasionally-seen case that I am my own renderee"	| rendered |	^ (rendered := self renderedMorph) == self		ifTrue:			[super referencePosition]		ifFalse:			[transform localPointToGlobal: rendered referencePosition]! !!TextMorph methodsFor: 'private' stamp: 'ar 8/10/2003 18:12'!removedMorph: aMorph	| range |	range := text find: (TextAnchor new anchoredMorph: aMorph).	range ifNotNil:		[self paragraph replaceFrom: range first to: range last				with: Text new displaying: false.		self fit].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	super removedMorph: aMorph.! !!HaloMorph methodsFor: 'stepping' stamp: 'nk 6/27/2003 12:28'!localHaloBoundsFor: aMorph	"aMorph may be in the hand and perhaps not in our world"	| r |	r := aMorph worldBoundsForHalo truncated.	aMorph world = self world ifFalse: [^r].	^((self transformFromOutermostWorld) globalBoundsToLocal: r) truncated! !!ModalSystemWindowView methodsFor: 'modal dialog' stamp: 'BG 12/13/2002 11:33'!doModalDialog	| savedArea |	self resizeInitially.	self resizeTo: 		((self windowBox)			align: self windowBox center			with: Display boundingBox aboveCenter).	savedArea := Form fromDisplay: self windowBox.	self displayEmphasized.	self controller startUp.	self release.	savedArea displayOn: Display at: self windowOrigin.! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 11/2/1998 15:57'!handleEdit: editBlock	| result |	textMorph editor selectFrom: selectionInterval first to: selectionInterval last;						model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result := editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PolygonMorph methodsFor: 'private' stamp: 'di 9/7/2000 13:30'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm := nil].	filledForm ifNotNil: [^ filledForm].	filledForm := Form extent: bounds extent+2.	"Draw the border..."	bb := (BitBlt current toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin := bounds topLeft asIntegerPoint-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 asIntegerPoint-origin										to: p2 asIntegerPoint-origin].	"Fill it in..."	filledForm convexShapeFill: Color black.	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue:		["If border is stored as a form, then erase any overlap now."		filledForm copy: self borderForm boundingBox from: self borderForm			to: 1@1 rule: Form erase].	^ filledForm! !!ProgressMorph methodsFor: 'initialization' stamp: 'sma 3/3/2000 19:13'!initLabelMorph	^ labelMorph := StringMorph contents: '' font: (self fontOfPointSize: 14)! !!TheWorldMenu methodsFor: 'action' stamp: 'dao 10/1/2004 13:37'!projectThumbnail	"Offer the user a menu of project names. Attach to the hand a thumbnail of the project the user selects."	| menu projName pr |	menu := CustomMenu new.	menu 		add: (Project current name, ' (current)') 		action: Project current name.	menu addLine.	Project allNames do: [:n | menu add: n action: n].	projName := menu startUpWithCaption: 'Select a project'.	projName ifNotNil:		[(pr := Project named: projName) 			ifNotNil: [myHand attachMorph: (ProjectViewMorph on: pr)]			ifNil: [self inform: 'can''t seem to find that project']].! !!ScrollPane methodsFor: 'menu' stamp: 'sw 9/23/1998 08:47'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu := MenuMorph new defaultTarget: model.	aTitle := getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 ifTrue:		[aMenu := model perform: getMenuSelector with: menu.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	getMenuSelector numArgs = 2 ifTrue:		[aMenu := model perform: getMenuSelector with: menu with: shiftKeyState.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollPane methodsFor: 'initialization' stamp: 'sps 4/4/2004 12:18'!initializeScrollBars"initialize the receiver's scrollBar"	(scrollBar := ScrollBar new model: self slotName: 'vScrollBar')			borderWidth: 1; 			borderColor: Color black.	(hScrollBar := ScrollBar new model: self slotName: 'hScrollBar')			borderWidth: 1; 			borderColor: Color black.	""	scroller := TransformMorph new color: Color transparent.	scroller offset: -3 @ 0.	self addMorph: scroller.	""	scrollBar initializeEmbedded: retractableScrollBar not.	hScrollBar initializeEmbedded: retractableScrollBar not.	retractableScrollBar ifFalse: 			[self 				addMorph: scrollBar;				addMorph: hScrollBar].	Preferences alwaysShowVScrollbar ifTrue:		[ self alwaysShowVScrollBar: true ].			Preferences alwaysHideHScrollbar		ifTrue:[self hideHScrollBarIndefinitely: true ]		ifFalse:			[Preferences alwaysShowHScrollbar ifTrue:				[ self alwaysShowHScrollBar: true ]].! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:24'!put: aText	"Private - put the supplied text onto the file"	| ff type |	brevityState == #fullFile ifTrue:		[ff := directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents := aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[self inform: 'No fileName is selected' translated.		^ false  "failed"].	type := 'These'.	brevityState = #briefFile ifTrue: [type := 'Abbreviated'].	brevityState = #briefHex ifTrue: [type := 'Abbreviated'].	brevityState = #fullHex ifTrue: [type := 'Hexadecimal'].	brevityState = #FileList ifTrue: [type := 'Directory'].	self inform: ('{1} contents cannotmeaningfully be saved at present.' translated format:{type translated}).	^ false  "failed"! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 10/24/2000 14:40'!reportLocalAddress	"Report the local host address of this computer."	| addrString m s |	Socket initializeNetwork.	addrString := NetNameResolver localAddressString.	m := RectangleMorph new		color: (Color r: 0.6 g: 0.8 b: 0.6);		extent: 118@36;		borderWidth: 1.	s := StringMorph contents: 'Local Host Address:'.	s position: m position + (5@4).	m addMorph: s.	s := StringMorph contents: addrString.	s position: m position + (5@19).	m addMorph: s.	self primaryHand attachMorph: m.! !!SelectionMorph methodsFor: 'halo commands' stamp: 'dgd 9/20/2004 13:40'!alignBottomEdges	"Make the bottom coordinate of all my elements be the same"	| maxBottom |	maxBottom := (selectedItems collect: [:itm | itm bottom]) max.	selectedItems do:		[:itm | itm bottom: maxBottom].	self changed! !!HandMorph methodsFor: 'initialization' stamp: 'tk 8/9/2001 16:55'!initForEvents	mouseOverHandler := nil.	lastMouseEvent := MouseEvent new setType: #mouseMove position: 0@0 buttons: 0 hand: self.	lastEventBuffer := {1. 0. 0. 0. 0. 0. nil. nil}.	self resetClickState.! !!StringMorph methodsFor: 'editing' stamp: 'nk 2/24/2005 20:11'!launchMiniEditor: evt	| textMorph |	hasFocus := true.  "Really only means edit in progress for this morph"	textMorph := StringMorphEditor new contentsAsIs: contents.	textMorph beAllFont: self fontToUse.	textMorph bounds: (self bounds expandBy: 0@2).	self addMorphFront: textMorph.	evt hand newKeyboardFocus: textMorph.	textMorph editor selectFrom: 1 to: textMorph paragraph text string size! !!HandMorph methodsFor: 'private events' stamp: 'ar 3/18/2001 01:42'!sendFocusEvent: anEvent to: focusHolder clear: aBlock	"Send the event to the morph currently holding the focus"	| result w |	w := focusHolder world ifNil:[^ aBlock value].	w becomeActiveDuring:[		ActiveHand := self.		ActiveEvent := anEvent.		result := focusHolder handleFocusEvent: 			(anEvent transformedBy: (focusHolder transformedFrom: self)).	].	^result! !!PolygonMorph methodsFor: 'geometry' stamp: 'nk 3/11/2001 19:08'!closestSegmentTo: aPoint	"Answer the starting index of my (big) segment nearest to aPoint"	| curvePoint closestPoint dist minDist vertexIndex closestVertexIndex |	vertexIndex := 0.	closestVertexIndex := 0.	closestPoint := minDist := nil.	self lineSegmentsDo:		[:p1 :p2 | 		(p1 = (self vertices at: vertexIndex + 1))			ifTrue: [ vertexIndex := vertexIndex + 1 ].		curvePoint := aPoint nearestPointOnLineFrom: p1 to: p2.		dist := curvePoint dist: aPoint.		(closestPoint == nil or: [dist < minDist])			ifTrue: [closestPoint := curvePoint.					minDist := dist.					closestVertexIndex := vertexIndex. ]].	^ closestVertexIndex! !!TextFieldMorph methodsFor: 'just like textMorph' stamp: 'tk 9/6/2000 12:33'!lineCount	| tm |	"how many lines in my text"	(tm := self findA: TextMorph) ifNil: [^ nil].	^ tm contents string lineCount! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeMinCellSize: evt	| handle |	handle := HandleMorph new forEachPointDo:[:newPoint |		self minCellSize: (newPoint - evt cursorPoint) asIntegerPoint].	evt hand attachMorph: handle.	handle startStepping.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sd 11/13/2003 21:25'!findWindow: evt	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."	| menu expanded collapsed nakedMorphs |	menu := MenuMorph new.	expanded := SystemWindow windowsIn: self satisfying: [:w | w isCollapsed not].	collapsed := SystemWindow windowsIn: self satisfying: [:w | w isCollapsed].	nakedMorphs := self submorphsSatisfying:		[:m | (m isSystemWindow not and: [(m isKindOf: StickySketchMorph) not]) and:			[(m isFlapTab) not]].	(expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty)) ifTrue: [^ Beeper beep].	(expanded asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do:		[:w | menu add: w label target: w action: #activateAndForceLabelToShow.			w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	(expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty)) ifFalse: [menu addLine].	(collapsed asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do: 		[:w | menu add: w label target: w action: #collapseOrExpand.		w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asSortedCollection: [:w1 :w2 | w1 nameForFindWindowFeature caseInsensitiveLessOrEqual: w2 nameForFindWindowFeature]) do:		[:w | menu add: w nameForFindWindowFeature target: w action: #comeToFrontAndAddHalo].	menu addTitle: 'find window' translated.		menu popUpEvent: evt in: self.! !!PasteUpMorph methodsFor: 'event handling' stamp: 'mir 1/10/2002 17:35'!dropFiles: anEvent	"Handle a number of dropped files from the OS.	TODO:		- use a more general mechanism for figuring out what to do with the file (perhaps even offering a choice from a menu)		- remember the resource location or (when in browser) even the actual file handle	"	| numFiles stream handler |	numFiles := anEvent contents.	1 to: numFiles do: [:i |		stream := FileStream requestDropStream: i.		handler := ExternalDropHandler lookupExternalDropHandler: stream.		[handler ifNotNil: [handler handle: stream in: self dropEvent: anEvent]]			ensure: [stream close]].! !!PolygonMorph methodsFor: 'menu' stamp: 'di 8/20/2000 14:27'!makeClosed	closed := true.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!SimpleHierarchicalListMorph methodsFor: 'events' stamp: 'ar 3/17/2001 17:39'!expand: aMorph to: level	| allChildren |	aMorph toggleExpandedState.	allChildren := OrderedCollection new: 10.	aMorph recursiveAddTo: allChildren.	allChildren do: [:each | 		((each canExpand			and: [each isExpanded not])			and: [level > 0])			ifTrue: [self expand: each to: level-1]].! !!MorphicAlarm methodsFor: 'evaluating' stamp: 'ar 10/22/2000 17:36'!value: anArgument	| nArgs |	numArgs ifNil:[numArgs := selector numArgs].	nArgs := arguments ifNil:[0] ifNotNil:[arguments size].	nArgs = numArgs ifTrue:[		"Ignore extra argument"		^self value].	^arguments isNil		ifTrue: [receiver perform: selector with: anArgument]		ifFalse: [receiver perform: selector withArguments: (arguments copyWith: anArgument)]! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:11'!reduceColorPalette: evt	"Let the user ask for a reduced number of colors in this sketch"	| str nColors |	str := FillInTheBlank		request: 'Please enter a number greater than one.(note: this cannot be undone, so answer zeroto abort if you need to make a backup first)' translated		initialAnswer: '256'.	nColors := Integer readFrom: (ReadStream on: str).	(nColors between: 2 and: 256) ifFalse: [^ self].	originalForm := originalForm copyWithColorsReducedTo: nColors.	rotatedForm := nil.	self changed! !!PluggableListMorph methodsFor: 'updating' stamp: 'ls 8/19/2001 14:36'!verifyContents	"Verify the contents of the receiver, reconstituting if necessary.  Called whenever window is reactivated, to react to possible structural changes.  Also called periodically in morphic if the smartUpdating preference is true"	| newList existingSelection anIndex oldList |	oldList := list ifNil: [ #() ].	newList := self getList.	((oldList == newList) "fastest" or: [oldList = newList]) ifTrue: [^ self].	self flash.  "list has changed beneath us; give the user a little visual feedback that the contents of the pane are being updated."	existingSelection := self selectionIndex > 0 ifTrue: [ oldList at: self selectionIndex ] ifFalse: [ nil ].	self updateList.	(existingSelection notNil and: [(anIndex := list indexOf: existingSelection asStringOrText ifAbsent: [nil]) notNil])		ifTrue:			[model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifFalse:			[self changeModelSelection: 0]! !!BorderedMorph methodsFor: 'menu' stamp: 'em 3/24/2005 14:36'!changeBorderWidth: evt	| handle origin aHand newWidth oldWidth |	aHand := evt ifNil: [self primaryHand] ifNotNil: [evt hand].	origin := aHand position.	oldWidth := borderWidth.	handle := HandleMorph new		forEachPointDo:			[:newPoint | handle removeAllMorphs.			handle addMorph:				(LineMorph from: origin to: newPoint color: Color black width: 1).			newWidth := (newPoint - origin) r asInteger // 5.			self borderWidth: newWidth]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].			self rememberCommand:				(Command new cmdWording: 'border change' translated;					undoTarget: self selector: #borderWidth: argument: oldWidth;					redoTarget: self selector: #borderWidth: argument: newWidth)].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase border width.Click when done.' translated hand: evt hand.	handle startStepping! !!HaloMorph methodsFor: 'private' stamp: 'sw 2/2/2006 01:31'!startRot: evt with: rotHandle	"Initialize rotation of my target if it is rotatable.  Launch a command object to represent the action"	self obtainHaloForEvent: evt andRemoveAllHandlesBut: rotHandle.	target isFlexMorph ifFalse: 		[target isInWorld ifFalse: [self setTarget: target player costume].		target addFlexShellIfNecessary].	growingOrRotating := true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset := evt cursorPoint - (target pointInWorld: target referencePosition).	angleOffset := Point			r: angleOffset r			degrees: angleOffset degrees - target rotationDegrees.	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: ('rotate ' translated, target nameForUndoWording);			undoTarget: target renderedMorph selector: #heading: argument: target rotationDegrees)! !!CollapsedMorph methodsFor: 'collapse/expand' stamp: 'sw 5/9/2000 00:18'!beReplacementFor: aMorph	| itsWorld priorPosition |	(itsWorld := aMorph world) ifNil: [^self].	uncollapsedMorph := aMorph.				self setLabel: aMorph externalName.	aMorph delete.	itsWorld addMorphFront: self.	self collapseOrExpand.	(priorPosition := aMorph valueOfProperty: #collapsedPosition ifAbsent: [nil])	ifNotNil:		[self position: priorPosition].! !!MenuMorph methodsFor: 'copying' stamp: 'dgd 9/1/2004 17:54'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."defaultTarget := defaultTarget.		Weakly copied"selectedItem := selectedItem veryDeepCopyWith: deepCopier.stayUp := stayUp veryDeepCopyWith: deepCopier.popUpOwner := popUpOwner.		"Weakly copied"activeSubMenu := activeSubMenu. "Weakly copied"activatorDockingBar := activatorDockingBar.  "Weakly copied"! !!ScriptEditorMorph methodsFor: 'customevents-buttons' stamp: 'nk 4/23/2004 07:28'!actuallyDestroyScript	"Carry out the actual destruction of the associated script."	| aHandler itsCostume |	self delete.	playerScripted class removeScriptNamed: scriptName.	playerScripted actorState instantiatedUserScriptsDictionary removeKey: scriptName ifAbsent: [].		"not quite enough yet in the multiple-instance case..."	itsCostume := playerScripted costume.	(aHandler := itsCostume renderedMorph eventHandler) ifNotNil:		[aHandler forgetDispatchesTo: scriptName].	itsCostume removeActionsSatisfying: [ :act | act receiver == playerScripted and: [ act selector == scriptName ]].	itsCostume currentWorld removeActionsSatisfying: [ :act | act receiver == playerScripted and: [ act selector == scriptName ]].	playerScripted updateAllViewersAndForceToShow: ScriptingSystem nameForScriptsCategory! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'md 12/12/2003 16:21'!toggleAnnotationPaneSize	| handle origin aHand siblings newHeight lf prevBottom m ht |	self flag: #bob.		"CRUDE HACK to enable changing the size of the annotations pane"	owner ifNil: [^self].	siblings := owner submorphs.	siblings size > 3 ifTrue: [^self].	siblings size < 2 ifTrue: [^self].	aHand := self primaryHand.	origin := aHand position.	handle := HandleMorph new		forEachPointDo: [:newPoint |			handle removeAllMorphs.			newHeight := (newPoint - origin) y asInteger min: owner height - 50 max: 16.			lf := siblings last layoutFrame.			lf bottomOffset: newHeight.			prevBottom := newHeight.			siblings size - 1 to: 1 by: -1 do: [ :index |				m := siblings at: index.				lf := m layoutFrame.				ht := lf bottomOffset - lf topOffset.				lf topOffset: prevBottom.				lf bottomOffset = 0 ifFalse: [					lf bottomOffset: (prevBottom + ht).				].				prevBottom := prevBottom + ht.			].			owner layoutChanged.		]		lastPointDo:			[:newPoint | handle deleteBalloon.			self halo ifNotNilDo: [:halo | halo addHandles].		].	aHand attachMorph: handle.	handle setProperty: #helpAtCenter toValue: true.	handle showBalloon:'Move cursor farther fromthis point to increase pane.Click when done.' hand: aHand.	handle startStepping! !!ColorMappingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:19'!preserveStateDuring: aBlock	"Preserve the full canvas state during the execution of aBlock"	| oldCanvas |	oldCanvas := myCanvas.	myCanvas preserveStateDuring:[:newCanvas|		myCanvas := newCanvas.		aBlock value: self].	myCanvas := oldCanvas.! !!ShadowDrawingCanvas methodsFor: 'initialization' stamp: 'ar 8/8/2001 14:14'!on: aCanvas	myCanvas := aCanvas.	shadowColor := Color black.! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36'!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY := topMorph layoutFrame bottomFraction.	minX := (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX := (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter := ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!TransformMorph methodsFor: 'accessing' stamp: 'ar 5/19/1999 18:04'!transform: aTransform	transform := aTransform.! !!TextMorphEditor methodsFor: 'multi level undo' stamp: 'sps 7/24/2003 18:53'!multiUndoWithCount: count	| command i lastCommand saveSelection newSelection history |	count > 0 ifFalse:[ ^self ].	history := self editHistory.	(command := history commandToUndo) 		ifNil:[ ^self multiUndoError: 'Nothing to undo'].			saveSelection := self selectionInterval.	self deselect.	i := 0.	[i < count] whileTrue: 		[history undo.		lastCommand := command.		((i := i + 1) < count) ifTrue:			[(command := history commandToUndo) ifNil:[				self multiUndoError: ('Only ', (i - 1) asString, ' commands to undo.').				i := count. ]]].	(newSelection := lastCommand undoSelectionInterval) isNil			ifTrue:[ self selectInterval: saveSelection]			ifFalse:[ self selectInterval: newSelection].! !!PasteUpMorph methodsFor: 'project state' stamp: 'sw 9/5/2000 09:59'!steppingMorphsNotInWorld	| all |	all := self allMorphs.	^ self listOfSteppingMorphs select: [:m | (all includes: m) not]	"self currentWorld steppingMorphsNotInWorld do: [:m | m delete]"! !!SelectionMorph methodsFor: 'halo commands' stamp: 'md 11/14/2003 17:18'!doDup: evt fromHalo: halo handle: dupHandle	selectedItems := self duplicateMorphCollection: selectedItems.	selectedItems do: [:m | self owner addMorph: m].	dupDelta isNil		ifTrue: ["First duplicate operation -- note starting location"				dupLoc := self position.				evt hand grabMorph: self.				halo removeAllHandlesBut: dupHandle]		ifFalse: ["Subsequent duplicate does not grab, but only moves me and my morphs"				dupLoc := nil.				self position: self position + dupDelta]! !!StringMorph methodsFor: 'accessing' stamp: 'ar 12/12/2001 02:44'!fitContents	| newBounds boundsChanged |	newBounds := self measureContents.	boundsChanged := bounds extent ~= newBounds.	self extent: newBounds.		"default short-circuits if bounds not changed"	boundsChanged ifFalse: [self changed]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 8/16/2000 17:42'!nameForCopyIfAlreadyNamed: aMorph	"Answer a name to set for a copy of aMorph if aMorph itself is named, else nil"	| aName usedNames |	^ (aName := aMorph knownName) ifNotNil:		[usedNames := self allKnownNames.		Utilities keyLike: aName satisfying: [:f | (usedNames includes: f) not]]! !!ScriptEditorMorph methodsFor: 'tiles from method' stamp: 'sw 2/20/2001 02:03'!fromExistingMethod: aSelector forPlayer: aPlayer 	"Create tiles for this method.  "	self initialize.	playerScripted := aPlayer.	self setMorph: aPlayer costume scriptName: aSelector.	self insertUniversalTiles! !!SelectionMorph methodsFor: 'private' stamp: 'nk 8/14/2003 08:12'!privateFullMoveBy: delta	| griddedDelta griddingMorph |	selectedItems isEmpty ifTrue: [^ super privateFullMoveBy: delta].	griddingMorph := self pasteUpMorph.	griddingMorph ifNil: [^ super privateFullMoveBy: delta].	griddedDelta := (griddingMorph gridPoint: self position + delta + slippage) -					(griddingMorph gridPoint: self position).	slippage := slippage + (delta - griddedDelta).  "keep track of how we lag the true movement."	griddedDelta = (0@0) ifTrue: [^ self].	super privateFullMoveBy: griddedDelta.	selectedItems do:		[:m | m position: (m position + griddedDelta) ]! !!TransformationMorph methodsFor: 'naming' stamp: 'sw 5/13/1998 10:32'!innocuousName	| r |	^ (r := self renderedMorph) == self		ifTrue: [super innocuousName] ifFalse: [r innocuousName]! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:08'!recolorPixelsOfColor: evt	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| c d newForm map newC |	self inform: 'choose the color you want to replace' translated.	self changeColorTarget: self selector: #rememberedColor: originalColor: nil hand: evt hand.   "color to replace"	c := self rememberedColor ifNil: [Color red].	self inform: 'now choose the color you want to replace it with' translated.	self changeColorTarget: self selector:  #rememberedColor: originalColor: c hand: evt hand.  "new color"	newC := self rememberedColor ifNil: [Color blue].	d := originalForm depth.	newForm := Form extent: originalForm extent depth: d.	map := (Color cachedColormapFrom: d to: d) copy.	map at: (c indexInMap: map) put: (newC pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!TheWorldMenu methodsFor: 'construction' stamp: 'sw 10/5/2002 00:45'!appearanceMenu	"Build the appearance menu for the world."	| screenCtrl |	screenCtrl := ScreenController new.	^self fillIn: (self menu: 'appearance...') from: {		{'preferences...' . { Preferences . #openFactoredPanel} . 'Opens a "Preferences Panel" which allows you to alter many settings' } .		{'choose theme...' . { Preferences . #offerThemesMenu} . 'Presents you with a menu of themes; each item''s balloon-help will tell you about the theme.  If you choose a theme, many different preferences that come along with that theme are set at the same time; you can subsequently change any settings by using a Preferences Panel'} .		nil .		{'window colors...' . { Preferences . #windowSpecificationPanel} . 'Lets you specify colors for standard system windows.'}.		{'system fonts...' . { self . #standardFontDo} . 'Choose the standard fonts to use for code, lists, menus, window titles, etc.'}.		{'text highlight color...' . { Preferences . #chooseTextHighlightColor} . 'Choose which color should be used for text highlighting in Morphic.'}.		{'insertion point color...' . { Preferences . #chooseInsertionPointColor} . 'Choose which color to use for the text insertion point in Morphic.'}.		{'keyboard focus color' . { Preferences . #chooseKeyboardFocusColor} . 'Choose which color to use for highlighting which pane has the keyboard focus'}.		nil.		{#menuColorString . { Preferences . #toggleMenuColorPolicy} . 'Governs whether menu colors should be derived from the desktop color.'}.		{#roundedCornersString . { Preferences . #toggleRoundedCorners} . 'Governs whether morphic windows and menus should have rounded corners.'}.		nil.		{'full screen on' . { screenCtrl . #fullScreenOn} . 'puts you in full-screen mode, if not already there.'}.		{'full screen off' . { screenCtrl . #fullScreenOff} . 'if in full-screen mode, takes you out of it.'}.		nil.		{'set display depth...' . {self. #setDisplayDepth} . 'choose how many bits per pixel.'}.		{'set desktop color...' . {self. #changeBackgroundColor} . 'choose a uniform color to use as desktop background.'}.		{'set gradient color...' . {self. #setGradientColor} . 'choose second color to use as gradient for desktop background.'}.		{'use texture background' . { #myWorld . #setStandardTexture} . 'apply a graph-paper-like texture background to the desktop.'}.		nil.		{'clear turtle trails from desktop' . { #myWorld . #clearTurtleTrails} . 'remove any pigment laid down on the desktop by objects moving with their pens down.'}.		{'pen-trail arrowhead size...' . { Preferences. #setArrowheads} . 'choose the shape to be used in arrowheads on pen trails.'}.	}! !!EventHandler methodsFor: 'events' stamp: 'ar 3/17/2001 14:34'!send: selector to: recipient withEvent: event fromMorph: sourceMorph	| arity |	recipient ifNil: [^ self].	arity := selector numArgs.	arity = 0 ifTrue:		[^ recipient perform: selector].	arity = 1 ifTrue:		[^ recipient perform: selector with: event].	arity = 2 ifTrue:		[^ recipient perform: selector with: event with: sourceMorph].	arity = 3 ifTrue:		[^ recipient perform: selector with: valueParameter with: event with: sourceMorph].	self error: 'Event handling selectors must be Symbols and take 0-3 arguments'! !!PasteUpMorph methodsFor: 'misc' stamp: 'ka 4/10/2005 00:43'!viewerFlapTabFor: anObject	"Open up a Viewer on aMorph in its own flap, creating it if necessary"	| bottomMost aPlayer aFlapTab tempFlapTab |	bottomMost := self top.	aPlayer := anObject isMorph ifTrue: [anObject assuredPlayer] ifFalse: [anObject objectRepresented].	self flapTabs do:		[:aTab | ((aTab isKindOf: ViewerFlapTab) or: [aTab hasProperty: #paintingFlap])			ifTrue:				[bottomMost := aTab bottom max: bottomMost.				((aTab isKindOf: ViewerFlapTab) and: [aTab scriptedPlayer == aPlayer])					ifTrue:						[^ aTab]]].	"Not found; make a new one"	tempFlapTab := Flaps newFlapTitled: anObject nameForViewer onEdge: #right inPasteUp: self.	tempFlapTab arrangeToPopOutOnDragOver: false;		arrangeToPopOutOnMouseOver: false. 	"For some reason those event handlers were causing trouble, as reported by ar 11/22/2001, after di's flapsOnBottom update."	aFlapTab := tempFlapTab as: ViewerFlapTab.	aFlapTab initializeFor: aPlayer topAt: bottomMost + 2.	aFlapTab referent color: (Color green muchLighter alpha: 0.5).	aFlapTab referent borderWidth: 0.	aFlapTab referent setProperty: #automaticPhraseExpansion toValue: true.	Preferences compactViewerFlaps 		ifTrue:	[aFlapTab makeFlapCompact: true].	self addMorphFront: aFlapTab.	aFlapTab adaptToWorld: self.	aFlapTab setProperty: #isEToysFlap toValue: true.	^ aFlapTab! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 3/3/2005 02:53'!stringForNumericValue: aValue	"Answer a suitably-formatted string representing the value."	| barePrintString |	((barePrintString := aValue printString) includes: $e)  ifTrue: [^ barePrintString].	^ aValue printShowingDecimalPlaces: self decimalPlaces! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!sourceHand: aHand	sourceHand := aHand.! !!TextFieldMorph methodsFor: 'just like textMorph' stamp: 'tk 8/30/2000 14:22'!contents	| tm |	"talk to my text"	(tm := self findA: TextMorph) ifNil: [^ nil].	^ tm contents! !!TheWorldMenu methodsFor: 'construction' stamp: 'md 2/22/2006 21:24'!newMorph	"The user requested 'new morph' from the world menu.  Put up a menu that allows many ways of obtaining new morphs."	| menu |	menu := self menu: 'Add a new morph'.	menu 		add: 'from paste buffer' translated target: myHand action: #pasteMorph;		add: 'from alphabetical list' translated subMenu: self alphabeticalMorphMenu;		add: 'from a file...' translated target: self action: #readMorphFromAFile.	menu addLine.	menu add: 'grab rectangle from screen' translated target: myWorld action: #grabDrawingFromScreen:;		add: 'grab with lasso from screen' translated target: myWorld action: #grabLassoFromScreen:;		add: 'grab rubber band from screen' translated target: myWorld action: #grabRubberBandFromScreen:;		add: 'grab flood area from screen' translated target: myWorld action: #grabFloodFromScreen:.	menu addLine.	menu add: 'make new drawing' translated target: myWorld action: #newDrawingFromMenu:;		add: 'make link to project...' translated target: self action: #projectThumbnail.	self doPopUp: menu.! !!MorphicModel methodsFor: 'compilation' stamp: ''!nameFor: aMorph	"Return the name of the slot containing the given morph or nil if that morph has not been named."	| allNames start |	allNames := self class allInstVarNames.	start := MorphicModel allInstVarNames size + 1.	start to: allNames size do: [:i |		(self instVarAt: i) == aMorph ifTrue: [^ allNames at: i]].	^ nil! !!HandMorph methodsFor: 'focus handling' stamp: 'ar 10/26/2000 01:30'!keyboardFocus: aMorphOrNil	keyboardFocus := aMorphOrNil! !!MenuMorph methodsFor: 'keyboard control' stamp: 'cmm 3/26/2003 22:52'!displayFiltered: evt	| matchStr allItems isMatch matches feedbackMorph |	matchStr := self valueOfProperty: #matchString.	allItems := self submorphs select: [:m | m isKindOf: MenuItemMorph].	matches :=  allItems select: [:m | 		isMatch := 			matchStr isEmpty or: [				m contents includesSubstring: matchStr caseSensitive: false].		m isEnabled: isMatch.		isMatch].	feedbackMorph := self valueOfProperty: #feedbackMorph.	feedbackMorph ifNil: [		feedbackMorph := 			TextMorph new 				autoFit: true;				color: Color darkGray.		self			addLine;			addMorphBack: feedbackMorph lock.		self setProperty: #feedbackMorph toValue: feedbackMorph.		self fullBounds.  "Lay out for submorph adjacency"].	feedbackMorph contents: '<', matchStr, '>'.	matchStr isEmpty ifTrue: [		feedbackMorph delete.		self submorphs last delete.		self removeProperty: #feedbackMorph].	matches size >= 1 ifTrue: [		self selectItem: matches first event: evt]! !!TransferMorph methodsFor: 'accessing' stamp: 'panda 4/28/2000 16:11'!dragTransferType: aSymbol	transferType := aSymbol! !!TextLine methodsFor: 'accessing' stamp: 'di 11/26/97 16:18'!setRight: x	right := x! !!JoystickMorph methodsFor: 'menu' stamp: 'yo 3/14/2005 13:11'!setXRange	| range |	range := FillInTheBlank		request:'Type the maximum value for the X axis' translated		initialAnswer: ((xScale * (self width - handleMorph width) / 2.0) roundTo: 0.01) printString.	range isEmpty ifFalse: [		xScale := (2.0 * range asNumber asFloat) / (self width - handleMorph width)].! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 3/3/2004 01:15'!addPenTrailsMenuItemsTo: aMenu	"Add items relating to pen trails to aMenu"	| oldTarget |	oldTarget := aMenu defaultTarget.	aMenu defaultTarget: self.	aMenu add: 'clear pen trails' translated action: #clearTurtleTrails.	aMenu addLine.	aMenu add: 'all pens up' translated action: #liftAllPens.	aMenu add: 'all pens down' translated action: #lowerAllPens.	aMenu addLine.	aMenu add: 'all pens show lines' translated action: #linesForAllPens.	aMenu add: 'all pens show arrowheads' translated action: #arrowsForAllPens.	aMenu add: 'all pens show arrows' translated action: #linesAndArrowsForAllPens.	aMenu add: 'all pens show dots' translated action: #dotsForAllPens.	aMenu defaultTarget: oldTarget! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFileSelectorForSuffixes: aList	| window aFileList |	window := self morphicViewFileSelectorForSuffixes: aList.	aFileList := window valueOfProperty: #fileListModel.	window openCenteredInWorld.	self modalLoopOn: window.	^aFileList getSelectedFile! !!TopRightGripMorph methodsFor: 'drawing' stamp: 'jmv 2/19/2006 14:24'!drawOn: aCanvas	| dotBounds alphaCanvas windowBorderWidth dotBounds2 |	windowBorderWidth := SystemWindow borderWidth.	bounds := self bounds.	alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.		"alphaCanvas		frameRectangle: bounds color: Color blue."	dotBounds := (bounds insetBy: 1).	dotBounds2 := dotBounds left: (dotBounds right - windowBorderWidth).	dotBounds2 := dotBounds2 bottom: (dotBounds2 top + windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.		dotBounds2 := dotBounds right: (dotBounds right - windowBorderWidth).	dotBounds2 := dotBounds2 bottom: (dotBounds2 top + windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 left: (dotBounds2 left + 7).	dotBounds2 := dotBounds2 right: (dotBounds2 right - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor.	dotBounds2 := dotBounds left: (dotBounds right - windowBorderWidth).	dotBounds2 := dotBounds2 top: (dotBounds2 top + windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 top: (dotBounds2 top + 7).	dotBounds2 := dotBounds2 bottom: (dotBounds2 bottom - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor! !!SimpleHierarchicalListMorph methodsFor: 'accessing' stamp: 'nk 3/8/2004 09:55'!lineColor	"Answer a good color to use for drawing the lines that connect members of the hierarchy view.	Used the cached color, or derive it if necessary by finding the first owner (up to my root) that is not transparent, then picking a contrasting color.	Fall back to veryLightGray if all my owners are transparent."	| coloredOwner targetLuminance ownerColor darken |	lineColor ifNotNil: [ ^lineColor ].	coloredOwner := self firstOwnerSuchThat: [ :o | o isWorldOrHandMorph not and: [ o color isTransparent not ]].	coloredOwner ifNil: [ ^Color veryLightGray ].	ownerColor := coloredOwner color.	darken := ownerColor luminance > 0.5.	targetLuminance := ownerColor luminance + (darken ifTrue: [ -0.2 ] ifFalse: [ 0.2 ]).	^darken		ifTrue: [ ownerColor atMostAsLuminentAs: targetLuminance ]		ifFalse: [ ownerColor atLeastAsLuminentAs: targetLuminance ]	! !!SketchMorph methodsFor: 'layout' stamp: 'ar 9/22/2000 14:00'!layoutChanged	"Update rotatedForm and compute new bounds."	self changed.	self generateRotatedForm.	bounds := bounds origin extent: rotatedForm extent.	super layoutChanged.	self changed.! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jrp 7/6/2005 21:44'!updateColor: aMorph color: aColor intensity: anInteger 	"update the apareance of aMorph"	| fill |	Preferences gradientMenu		ifFalse: [^ self].	fill := GradientFillStyle ramp: {0.0 -> Color white. 1 -> aColor}.	fill radial: false;		origin: aMorph topLeft;		direction: 0 @ aMorph height.	aMorph fillStyle: fill! !!UserInputEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:54'!wasHandled: aBool	wasHandled := aBool.! !!Morph methodsFor: 'rotate scale and flex' stamp: 'sw 3/30/2005 03:44'!addFlexShell	"Wrap a rotating and scaling shell around this morph."	| oldHalo flexMorph myWorld anIndex |	myWorld := self world.	oldHalo := self halo.	anIndex := self owner submorphIndexOf: self.	self owner addMorph: (flexMorph := self newTransformationMorph asFlexOf: self)		asElementNumber: anIndex.	self transferStateToRenderer: flexMorph.	oldHalo ifNotNil: [oldHalo setTarget: flexMorph].	myWorld ifNotNil: [myWorld startSteppingSubmorphsOf: flexMorph].	^ flexMorph! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:55'!readContentsCNGB	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: CNGBTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!EventHandler methodsFor: 'access' stamp: ''!messageList	"Return a list of 'Class selector' for each message I can send. tk 	9/13/97"	| list |	self flag: #mref.	"is this still needed? I replaced the one use that I could spot with 	#methodRefList "	list := SortedCollection new.	mouseDownRecipient		ifNotNil: [list add: (mouseDownRecipient class whichClassIncludesSelector: mouseDownSelector) name , ' ' , mouseDownSelector].	mouseMoveRecipient		ifNotNil: [list add: (mouseMoveRecipient class whichClassIncludesSelector: mouseMoveSelector) name , ' ' , mouseMoveSelector].	mouseStillDownRecipient		ifNotNil: [list add: (mouseStillDownRecipient class whichClassIncludesSelector: mouseStillDownSelector) name , ' ' , mouseStillDownSelector].	mouseUpRecipient		ifNotNil: [list add: (mouseUpRecipient class whichClassIncludesSelector: mouseUpSelector) name , ' ' , mouseUpSelector].	mouseEnterRecipient		ifNotNil: [list add: (mouseEnterRecipient class whichClassIncludesSelector: mouseEnterSelector) name , ' ' , mouseEnterSelector].	mouseLeaveRecipient		ifNotNil: [list add: (mouseLeaveRecipient class whichClassIncludesSelector: mouseLeaveSelector) name , ' ' , mouseLeaveSelector].	mouseEnterDraggingRecipient		ifNotNil: [list add: (mouseEnterDraggingRecipient class whichClassIncludesSelector: mouseEnterDraggingSelector) name , ' ' , mouseEnterDraggingSelector].	mouseLeaveDraggingRecipient		ifNotNil: [list add: (mouseLeaveDraggingRecipient class whichClassIncludesSelector: mouseLeaveDraggingSelector) name , ' ' , mouseLeaveDraggingSelector].	doubleClickRecipient		ifNotNil: [list add: (doubleClickRecipient class whichClassIncludesSelector: doubleClickSelector) name , ' ' , doubleClickSelector].	keyStrokeRecipient		ifNotNil: [list add: (keyStrokeRecipient class whichClassIncludesSelector: keyStrokeSelector) name , ' ' , keyStrokeSelector].	^ list! !!LayoutCell methodsFor: 'accessing' stamp: 'ls 8/5/2004 16:48'!hSpaceFill: aBool	flags := aBool ifTrue:[self flags bitOr: 1] ifFalse:[self flags bitClear: 1].! !!NewParagraph methodsFor: 'access' stamp: 'RAA 5/6/2001 15:03'!wantsColumnBreaks: aBoolean	wantsColumnBreaks := aBoolean! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/9/2000 01:05'!leftButtonPressed	accepted := false.	self changed: #close.! !!HaloMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:29'!initialize	"initialize the state of the receiver"	super initialize.	""	growingOrRotating := false.	simpleMode := Preferences simpleHalosInForce ! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:42'!preserveStateDuring: aBlock	"Preserve the full canvas state during the execution of aBlock.	Note: This does *not* include the state in the receiver (e.g., foundMorph)."	| tempCanvas |	tempCanvas := self copy.	aBlock value: tempCanvas.	foundMorph := tempCanvas foundMorph.! !!MenuMorph methodsFor: 'copying' stamp: 'ar 9/18/2000 09:34'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals."super veryDeepFixupWith: deepCopier.defaultTarget := deepCopier references at: defaultTarget ifAbsent: [defaultTarget].popUpOwner := deepCopier references at: popUpOwner ifAbsent: [popUpOwner].activeSubMenu := deepCopier references at: activeSubMenu ifAbsent:[activeSubMenu].! !!PopUpChoiceMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 09:43'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied""actionSelector := actionSelector.		a Symbol""arguments := arguments.		All weakly copied""getItemsSelector := getItemsSelector.		a Symbol""getItemsArgs := getItemsArgs.		All weakly copied""choiceSelector := choiceSelector.		a Symbol"choiceArgs := choiceArgs.		"All weakly copied"     ! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36'!rightFraction: aNumber offset: anInteger	rightFraction := aNumber.	rightOffset := anInteger! !!ScriptEditorMorph methodsFor: 'save & revert' stamp: 'RAA 1/16/2001 01:34'!revertToTileVersion	"The receiver, currently showing textual code,  is asked to revert to the last-saved tile version"	| aUserScript |	self 		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	aUserScript := playerScripted class userScriptForPlayer: playerScripted selector: scriptName.	aUserScript revertToLastSavedTileVersionFor: self.	self currentWorld startSteppingSubmorphsOf: self! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 8/7/2000 12:09'!repairEmbeddedWorlds	| transform eWorld toDoList |	toDoList := OrderedCollection new.	self allMorphsDo: [ :each |		(each isKindOf: EmbeddedWorldBorderMorph) ifTrue: [			transform := each submorphs at: 1 ifAbsent: [nil].			transform ifNotNil: [				eWorld := transform submorphs at: 1 ifAbsent: [nil].				eWorld ifNotNil: [					toDoList add: {transform. eWorld}.				].			].			"Smalltalk at: #Q put: {self. each. transform. eWorld}."		].	].	toDoList do: [ :each |		each first addMorph: each second.	].! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 11:09'!scrollBy: delta	"Move the contents in the direction delta."	| newYoffset r newXoffset |		"Set the offset on the scroller"	newYoffset := scroller offset y - delta y max: 0.	newXoffset := scroller offset x - delta x max: -3.		scroller offset: newXoffset@ newYoffset.	"Update the scrollBars"	(r := self vLeftoverScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r].	(r := self hLeftoverScrollRange) = 0		ifTrue: [hScrollBar value: -3.0]		ifFalse: [hScrollBar value: newXoffset asFloat / r]! !!Morph methodsFor: 'halos and balloon help' stamp: 'dgd 9/10/2004 13:59'!transferHalo: event from: formerHaloOwner	"Progressively transfer the halo to the next likely recipient"	| localEvt w target |	self flag: #workAround. "For halo's distinction between 'target' and 'innerTarget' we need to bypass any renderers."	(formerHaloOwner == self and:[self isRenderer and:[self wantsHaloFromClick not]]) ifTrue:[		event shiftPressed ifTrue:[			target := owner.			localEvt := event transformedBy: (self transformedFrom: owner).		] ifFalse:[			target := self renderedMorph.			localEvt := event transformedBy: (target transformedFrom: self).		].		^target transferHalo: localEvt from: target]."	formerHaloOwner == self ifTrue:[^ self removeHalo]."	"Never transfer halo to top-most world"	(self isWorldMorph and:[owner isNil]) ifFalse:[		(self wantsHaloFromClick and:[formerHaloOwner ~~ self]) 			ifTrue:[^self addHalo: event from: formerHaloOwner]].	event shiftPressed ifTrue:[		"Pass it outwards"		owner ifNotNil:[^owner transferHalo: event from: formerHaloOwner].		"We're at the top level; throw the event back in to find recipient"		formerHaloOwner removeHalo.		^self processEvent: event copy resetHandlerFields.	].	self submorphsDo:[:m|		localEvt := event transformedBy: (m transformedFrom: self).		(m fullContainsPoint: localEvt position) 			ifTrue:[^m transferHalo: event from: formerHaloOwner].	].	"We're at the bottom most level; throw the event back up to the root to find recipient"	formerHaloOwner removeHalo.	Preferences maintainHalos ifFalse:[		(w := self world) ifNil: [ ^self ].		localEvt := event transformedBy: (self transformedFrom: w) inverseTransformation.		^w processEvent: localEvt resetHandlerFields.	].! !!PolygonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:09'!vertices: verts color: aColor borderWidth: borderWidthInteger borderColor: anotherColor 	super initialize.""	vertices := verts.	color := aColor.	borderWidth := borderWidthInteger.	borderColor := anotherColor.	closed := vertices size > 2.	arrows := #none.	self computeBounds! !!ColorMappingCanvas methodsFor: 'other' stamp: 'ar 6/22/1999 18:21'!translateBy: delta clippingTo: aRectangle during: aBlock	"Set a translation and clipping rectangle only during the execution of aBlock."	| oldCanvas |	oldCanvas := myCanvas.	myCanvas translateBy: delta clippingTo: aRectangle during:[:newCanvas|		myCanvas := newCanvas.		aBlock value: self].	myCanvas := oldCanvas.! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 9/2/2004 18:45'!addDestroyButtonTo: aRowMorph 	"Add the destroiy button at the end of the header provided"	| aButton |	aButton := self pinkXButton.	aRowMorph addMorphBack: aButton.	aButton actionSelector: #destroyScript;			 setBalloonText: 'Destroy this script(CAUTION!!!!)' translated.	^ aRowMorph! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'sw 4/24/2001 12:00'!newMVCProject	"Create an instance of me on a new MVC project (in a SystemWindow)."	| proj window |	proj := Project new.	window := (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ThreePhaseButtonMorph class methodsFor: 'class initialization' stamp: 'ar 5/25/2000 18:01'!initialize	"ThreePhaseButtonMorph initialize"	| extent inset |	extent := 12@12.	inset := 3.	#('CheckBoxOff' 'CheckBoxOn' 'CheckBoxPressed') do: [:button |		| f r |		f := ColorForm extent: extent depth: 1.		f colors: {Color transparent. Color black}.		f borderWidth: 1.		r := f boundingBox insetBy: inset.		button = 'CheckBoxPressed' ifTrue: [f border: r width: 1].		button = 'CheckBoxOn' ifTrue: [f fillBlack: r].		ScriptingSystem saveForm: f atKey: button].	#('RadioButtonOff' 'RadioButtonOn' 'RadioButtonPressed') do: [:button |		| f r c |		f := ColorForm extent: extent depth: 1.		f colors: {Color transparent. Color black}.		r := f boundingBox.		c := f getCanvas.		c frameOval: r color: Color black.		r := r insetBy: inset.		button = 'RadioButtonPressed' ifTrue:			[c frameOval: r color: Color black].		button = 'RadioButtonOn' ifTrue:			[c fillOval: r color: Color black].		ScriptingSystem saveForm: f atKey: button]! !!PluggableButtonMorph class methodsFor: 'example' stamp: 'RAA 1/17/2001 14:32'!example	"PluggableButtonMorph example openInWorld"	| s1 s2 s3 b1 b2 b3 row |	s1 := Switch new.	s2 := Switch new turnOn.	s3 := Switch new.	s2 onAction: [s3 turnOff].	s3 onAction: [s2 turnOff].	b1 := (PluggableButtonMorph on: s1 getState: #isOn action: #switch) label: 'S1'.	b2 := (PluggableButtonMorph on: s2 getState: #isOn action: #turnOn) label: 'S2'.	b3 := (PluggableButtonMorph on: s3 getState: #isOn action: #turnOn) label: 'S3'.	b1		hResizing: #spaceFill;		vResizing: #spaceFill.	b2		hResizing: #spaceFill;		vResizing: #spaceFill.	b3		hResizing: #spaceFill;		vResizing: #spaceFill.	row := AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		addAllMorphs: (Array with: b1 with: b2 with: b3);		extent: 120@35.	^ row! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 4/7/98 19:17'!askBeforeChanging: aBoolean	"If this preference is turned on, then give the model an opportunity to ask the user before accepting a change that might cause unaccepted edits to be lost."	askBeforeChanging := aBoolean.! !!MenuItemMorph methodsFor: 'private' stamp: 'ar 9/19/2000 09:34'!onImage	"Return the form to be used for indicating an '<off>' marker"	| form |	form := Form extent: (self fontToUse ascent-2) asPoint depth: 16.	(form getCanvas)		frameAndFillRectangle: form boundingBox fillColor: (Color gray: 0.8) 			borderWidth: 1 borderColor: Color black;		fillRectangle: (form boundingBox insetBy: 2) fillStyle: Color black.	^form! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 12/13/2001 12:10'!form: aForm	"Set the receiver's form"	| oldForm topRenderer |	oldForm := originalForm.	(self hasProperty: #baseGraphic) ifFalse: [self setProperty: #baseGraphic toValue: aForm].	originalForm := aForm.	self rotationCenter: 0.5@0.5.	self layoutChanged.	topRenderer := self topRendererOrSelf.	oldForm ifNotNil: [topRenderer position: topRenderer position + (oldForm extent - aForm extent // 2)].! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 3/21/2006 23:19'!updateFromEvent: anEvent 	| delta firstRight firstBottom secondLeft secondTop selfTop selfBottom selfLeft selfRight |	delta := splitsTopAndBottom				ifTrue: [0 @ ((self normalizedY: anEvent cursorPoint y) - lastMouse y)]				ifFalse: [(self normalizedX: anEvent cursorPoint x) - lastMouse x @ 0].					splitsTopAndBottom		ifTrue: [lastMouse := lastMouse x @ (self normalizedY: anEvent cursorPoint y)]		ifFalse: [lastMouse := (self normalizedX: anEvent cursorPoint x) @ lastMouse y].	leftOrTop				do: [:each | 					firstRight := each layoutFrame rightOffset								ifNil: [0].					firstBottom := each layoutFrame bottomOffset								ifNil: [0].					each layoutFrame rightOffset: firstRight + delta x.					each layoutFrame bottomOffset: firstBottom + delta y].			rightOrBottom				do: [:each | 					secondLeft := each layoutFrame leftOffset								ifNil: [0].					secondTop := each layoutFrame topOffset								ifNil: [0].					each layoutFrame leftOffset: secondLeft + delta x.					each layoutFrame topOffset: secondTop + delta y].	selfTop := self layoutFrame topOffset				ifNil: [0].	selfBottom := self layoutFrame bottomOffset				ifNil: [0].	selfLeft := self layoutFrame leftOffset				ifNil: [0].	selfRight := self layoutFrame rightOffset				ifNil: [0].	self layoutFrame topOffset: selfTop + delta y.	self layoutFrame bottomOffset: selfBottom + delta y.	self layoutFrame leftOffset: selfLeft + delta x.	self layoutFrame rightOffset: selfRight + delta x.	self owner layoutChanged! !!MenuMorph class methodsFor: 'images' stamp: 'nk 8/1/2002 17:03'!pushPinImage	"Answer the push-pin image, creating and caching it at this time if it is absent"	^ PushPinImage ifNil: [PushPinImage := ((ColorForm	extent: 13@14	depth: 8	fromArray: #( 4294967295 4278387717 101187583 4278190080 4294967295 4278914061 235868177 4278190080 4294967295 303240213 370612249 4278190080 4294967295 454827294 522199330 587202560 4280624679 673786411 741158447 805306368 825373492 892745528 960117564 1023410176 1044332609 1111704645 1179076681 1241513984 1263291726 1330663762 1398035764 1442840576 1465407834 1532779870 1600151906 1660944384 1684366951 1751738987 1819148287 4278190080 4285559154 1937012086 2004418559 4278190080 2038070140 2101902975 2150891519 4278190080 2172814212 2240186248 327811071 4278190080 2324430732 2374930320 2449473535 4278190080)	offset: 0@0)	colorsFromArray: #(#(1.0 1.0 1.0) #(0.995 0.995 0.995) #(0.987 0.987 0.987) #(0.667 0.662 0.667) #(0.149 0.149 0.145) #(0.254 0.262 0.262) #(0.215 0.262 0.285) #(0.478 0.482 0.482) #(0.921 0.921 0.929) #(0.987 0.991 0.983) #(0.956 0.956 0.956) #(0.102 0.102 0.102) #(0.69 0.717 0.717) #(0.293 0.694 0.89) #(0.027 0.58 0.87) #(0.023 0.293 0.443) #(0.18 0.184 0.199) #(0.874 0.878 0.874) #(0.858 0.858 0.858) #(0.02 0.02 0.02) #(0.811 0.858 0.882) #(0.012 0.595 0.893) #(0.0 0.595 0.893) #(0.008 0.591 0.886) #(0.02 0.242 0.369) #(0.207 0.199 0.199) #(0.948 0.948 0.948) #(0.886 0.886 0.886) #(0.035 0.031 0.027) #(0.698 0.71 0.717) #(0.141 0.638 0.886) #(0.004 0.595 0.897) #(0.008 0.587 0.89) #(0.023 0.533 0.796) #(0.016 0.039 0.063) #(0.568 0.568 0.568) #(0.983 0.983 0.983) #(0.925 0.925 0.925) #(0.694 0.694 0.694) #(0.807 0.807 0.807) #(0.63 0.63 0.63) #(0.035 0.043 0.039) #(0.345 0.349 0.333) #(0.533 0.804 0.929) #(0.004 0.595 0.893) #(0.008 0.591 0.893) #(0.012 0.595 0.905) #(0.031 0.164 0.246) #(0.188 0.196 0.192) #(0.893 0.893 0.893) #(0.192 0.192 0.192) #(0.207 0.207 0.207) #(0.012 0.012 0.012) #(0.023 0.012 0.02) #(0.016 0.086 0.129) #(0.031 0.043 0.055) #(0.427 0.595 0.702) #(0.031 0.599 0.893) #(0.008 0.587 0.897) #(0.02 0.587 0.897) #(0.016 0.254 0.365) #(0.027 0.031 0.027) #(0.466 0.466 0.466) #(0.361 0.361 0.361) #(0.341 0.341 0.341) #(0.035 0.027 0.023) #(0.408 0.423 0.427) #(0.102 0.591 0.847) #(0.027 0.529 0.804) #(0.016 0.584 0.866) #(0.016 0.587 0.878) #(0.023 0.568 0.85) #(0.023 0.58 0.862) #(0.023 0.129 0.192) #(0.063 0.063 0.063) #(0.317 0.317 0.313) #(0.423 0.419 0.415) #(0.714 0.725 0.714) #(0.714 0.714 0.71) #(0.979 0.976 0.968) #(0.239 0.674 0.905) #(0.016 0.595 0.89) #(0.023 0.564 0.862) #(0.031 0.145 0.219) #(0.02 0.027 0.047) #(0.012 0.039 0.059) #(0.431 0.431 0.431) #(0.458 0.458 0.466) #(0.133 0.199 0.231) #(0.505 0.792 0.933) #(0.741 0.886 0.956) #(0.474 0.776 0.925) #(0.035 0.587 0.882) #(0.023 0.556 0.843) #(0.027 0.188 0.278) #(0.043 0.035 0.051) #(0.435 0.439 0.435) #(0.357 0.357 0.357) #(0.619 0.619 0.619) #(0.952 0.952 0.952) #(0.792 0.8 0.804) #(0.008 0.02 0.027) #(0.023 0.478 0.725) #(0.016 0.587 0.893) #(0.023 0.595 0.89) #(0.023 0.466 0.706) #(0.016 0.094 0.141) #(0.008 0.008 0.012) #(0.02 0.012 0.012) #(0.638 0.638 0.642) #(0.991 0.991 0.991) #(0.976 0.976 0.976) #(0.168 0.164 0.164) #(0.016 0.18 0.25) #(0.008 0.58 0.874) #(0.016 0.591 0.87) #(0.031 0.156 0.239) #(0.02 0.008 0.016) #(0.012 0.012 0.02) #(0.008 0.008 0.008) #(0.258 0.258 0.258) #(0.866 0.866 0.866) #(0.051 0.047 0.047) #(0.023 0.016 0.027) #(0.027 0.258 0.388) #(0.016 0.564 0.858) #(0.016 0.435 0.654) #(0.023 0.18 0.258) #(0.016 0.016 0.016) #(0.4 0.4 0.4) #(0.039 0.039 0.039) #(0.325 0.325 0.321) #(0.035 0.031 0.039) #(0.02 0.09 0.133) #(0.031 0.188 0.289) #(0.023 0.137 0.188) #(0.016 0.027 0.043) #(0.576 0.576 0.576) #(0.16 0.16 0.16) #(0.733 0.733 0.733) #(0.753 0.749 0.749) #(0.365 0.365 0.376) #(0.117 0.113 0.121) #(0.074 0.066 0.066) #(0.203 0.203 0.219) #(0.603 0.603 0.603) #(0.979 0.979 0.979) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #(1.0 1.0 1.0) #( )  )) ]! !!BottomRightGripMorph methodsFor: 'drawing' stamp: 'jmv 2/19/2006 14:23'!drawOn: aCanvas	| dotBounds alphaCanvas windowBorderWidth dotBounds2 |	windowBorderWidth := SystemWindow borderWidth.	bounds := self bounds.	alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.		"alphaCanvas		frameRectangle: bounds color: Color blue."	dotBounds := (bounds insetBy: 1).	dotBounds2 := dotBounds left: (dotBounds right - windowBorderWidth).	dotBounds2 := dotBounds2 top: (dotBounds2 bottom - windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.		dotBounds2 := dotBounds right: (dotBounds right - windowBorderWidth).	dotBounds2 := dotBounds2 top: (dotBounds2 bottom - windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 left: (dotBounds2 left + 7).	dotBounds2 := dotBounds2 right: (dotBounds2 right - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor.	dotBounds2 := dotBounds left: (dotBounds right - windowBorderWidth).	dotBounds2 := dotBounds2 bottom: (dotBounds2 bottom - windowBorderWidth).	alphaCanvas		fillRectangle: dotBounds2		color: self handleColor.	dotBounds2 := dotBounds2 top: (dotBounds2 top + 7).	dotBounds2 := dotBounds2 bottom: (dotBounds2 bottom - 7).	alphaCanvas		fillRectangle: dotBounds2		color: self dotColor! !!TTSampleStringMorph methodsFor: 'private' stamp: 'ar 11/14/1998 22:04'!computeTransform	| cy |	cy := bounds origin y + bounds corner y * 0.5.	transform := MatrixTransform2x3 			transformFromLocal: (ttBounds insetBy: borderWidth negated)			toGlobal: bounds.	transform := transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy negated).	transform := transform composedWithGlobal:(MatrixTransform2x3 withScale: 1.0@-1.0).	transform := transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0@cy).	^transform! !!TextContainer methodsFor: 'private' stamp: 'ar 10/26/2000 20:05'!computeShadow	| canvas back bounds theText |	bounds := self bounds.	theText := textMorph.	canvas := (Display defaultCanvasClass extent: bounds extent depth: 1)			shadowColor: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas|		self fillsOwner			ifTrue: [tempCanvas fullDrawMorph: (theText owner copyWithoutSubmorph: theText)]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back := tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [tempCanvas fullDrawMorph: m]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm := canvas form offset: bounds topLeft.	vertProfile := shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache := Dictionary new.	^ shadowForm! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'RAA 6/26/2000 11:29'!defineFactoryView	| r |	r := Rectangle fromUser.	self 		setProperty: #factoryViewBounds 		toValue: ((self transformFromOutermostWorld) globalBoundsToLocal: r) truncated ! !!TTSampleStringMorph methodsFor: 'accessing' stamp: 'tk 12/10/2001 16:21'!font: aTTFontDescription	font := aTTFontDescription.	string ifNil: [self string: aTTFontDescription fullName]		ifNotNil: [self initializeString].! !!MenuItemMorph methodsFor: 'accessing' stamp: 'hg 12/8/2001 13:22'!isEnabled: aBoolean	isEnabled = aBoolean ifTrue: [^ self].	isEnabled := aBoolean.	self color: (aBoolean ifTrue: [Color black] ifFalse: [Color lightGray]).! !!Morph methodsFor: 'meta-actions' stamp: 'ar 10/10/2000 14:09'!inspectAt: aPoint event: evt	| menu morphs target |	menu := CustomMenu new.	morphs := self morphsAt: aPoint.	(morphs includes: self) ifFalse:[morphs := morphs copyWith: self].	morphs do: [:m | 		menu add: (m knownName ifNil:[m class name asString]) action: m].	target := menu startUpWithCaption: ('inspect whom?(deepest at top)').	target ifNil:[^self].	target inspectInMorphic: evt! !!Morph methodsFor: 'layout' stamp: 'ar 11/12/2000 17:35'!layoutProportionallyIn: newBounds	"Layout specific. Apply the given bounds to the receiver."	| box frame |	frame := self layoutFrame ifNil:[^self].	"before applying the proportional values make sure the receiver's layout is computed"	self fullBounds. "sigh..."	"compute the cell size the receiver has given its layout frame"	box := frame layout: self bounds in: newBounds.	(box = self bounds) ifTrue:[^self]. "no change"	^self layoutInBounds: box.! !!TextMorph methodsFor: 'accessing' stamp: 'dgd 2/21/2003 22:32'!setFirstCharacter: source 	"Set the first character of the receiver as indicated"	| aChar chars |	aChar := source asCharacter.	(chars := self getCharacters) isEmpty		ifTrue: [self				newContents: (String with: aChar)]		ifFalse: [chars first = aChar				ifFalse: [self						newContents: (String								streamContents: [:aStream | 									aStream nextPut: aChar.									aStream										nextPutAll: (chars copyFrom: 2 to: chars size)])]] ! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'dgd 9/10/2004 13:45'!acceptDroppingMorph: dropped event: evt	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"	| mm tfm aMorph |	aMorph := self morphToDropFrom: dropped.	self isWorldMorph		ifTrue:["Add the given morph to this world and start stepping it if it wants to be."				self addMorphFront: aMorph.				(aMorph fullBounds intersects: self viewBox) ifFalse:					[Beeper beep.  aMorph position: self bounds center]]		ifFalse:[super acceptDroppingMorph: aMorph event: evt].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	aMorph allMorphsDo:  "Establish any penDown morphs in new world"		[:m | m player ifNotNil:			[m player getPenDown ifTrue:				[((mm := m player costume) notNil and: [(tfm := mm owner transformFrom: self) notNil])					ifTrue: [self noteNewLocation: (tfm localPointToGlobal: mm referencePosition)									forPlayer: m player]]]].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph stopSteppingSelfAndSubmorphs.			aMorph suspendEventHandler]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph].	self presenter morph: aMorph droppedIntoPasteUpMorph: self.	self showingListView ifTrue:		[self sortSubmorphsBy: (self valueOfProperty: #sortOrder).		self currentWorld abandonAllHalos].	self bringTopmostsToFront.! !!SimpleButtonMorph methodsFor: 'accessing' stamp: ''!target: anObject	target := anObject! !!StringMorphAttributeScanner methodsFor: 'scanning' stamp: 'nk 2/26/2004 12:40'!addEmphasis: anInteger	"Set the value of emphasis"	emphasis := emphasis bitOr: anInteger! !!SketchMorph methodsFor: 'geometry' stamp: 'nk 1/10/2004 14:51'!extent: newExtent	"Change my scale to fit myself into the given extent.	Avoid extents where X or Y is zero."	(newExtent y = 0 or: [ newExtent x = 0 ]) ifTrue: [ ^self ].	self extent = newExtent ifTrue:[^self].	scalePoint := newExtent asFloatPoint / (originalForm extent max: 1@1).	self layoutChanged.! !!TransferMorph methodsFor: 'accessing' stamp: 'sr 4/16/2000 18:53'!source: anObject	source := anObject! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'sw 12/15/2004 20:37'!restoreScriptName: aScriptName	"For fixup only..."	scriptName := aScriptName! !!SystemWindow methodsFor: 'menu' stamp: 'dao 10/1/2004 12:57'!fullScreen	"Zoom Window to Full World size with possible DeskMargins"		"SystemWindow fullScreen"		| left right possibleBounds |	left := right := 0.	self paneMorphs		do: [:pane | ((pane isKindOf: ScrollPane)					and: [pane retractableScrollBar])				ifTrue: [pane scrollBarOnLeft						ifTrue: [left := left max: pane scrollBarThickness]						ifFalse: [right := right max: pane scrollBarThickness]]].	possibleBounds := (RealEstateAgent maximumUsableAreaInWorld: self world)				insetBy: (left @ 0 corner: right @ 0).	((Flaps sharedFlapsAllowed				and: [Project current flapsSuppressed not])			or: [Preferences fullScreenLeavesDeskMargins])		ifTrue: [possibleBounds := possibleBounds insetBy: 22].	self bounds: possibleBounds! !!TheWorldMenu methodsFor: 'commands' stamp: 'dgd 9/21/2003 13:17'!loadProject	| stdFileMenuResult |	"Put up a Menu and let the user choose a '.project' file to load.  Create a thumbnail and jump into the project."	Project canWeLoadAProjectNow ifFalse: [^ self].	stdFileMenuResult := ((StandardFileMenu new) pattern: '*.pr'; 		oldFileFrom: FileDirectory default ) 			startUpWithCaption: 'Select a File:' translated.	stdFileMenuResult ifNil: [^ nil].	ProjectLoading 		openFromDirectory: stdFileMenuResult directory 		andFileName: stdFileMenuResult name! !!FileList2 methodsFor: 'volume list and pattern' stamp: 'nk 2/20/2001 12:09'!listForPatterns: anArray	"Make the list be those file names which match the patterns."	| sizePad newList |	directory ifNil: [^#()].	(fileSelectionBlock isKindOf: MessageSend) ifTrue: [		fileSelectionBlock arguments: {directory entries}.		newList := fileSelectionBlock value.		fileSelectionBlock arguments: #().	] ifFalse: [		newList := Set new.		anArray do: [ :pat |			newList addAll: (directory entries select: [:entry | fileSelectionBlock value: entry value: pat]) ].	].	newList := newList asSortedCollection: self sortBlock.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	^ newList asArray! !!NullEncoder methodsFor: 'writing' stamp: 'mpw 8/13/1999 10:54'!write:anObject	filterSelector  ifNil:[filterSelector:=self class filterSelector].	anObject ifNotNil: [anObject perform:filterSelector with:self].! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'dgd 2/16/2003 21:20'!privateOtherProperties: anIndentityDictionary 	"private - change the receiver's otherProperties"	otherProperties := anIndentityDictionary ! !!TheWorldMenu class methodsFor: 'open-menu registry' stamp: 'sw 11/11/2002 00:27'!openPackageLoader	"If this method is reached, it means that SMLoader has not yet been loaded; after SqueakMap has come into the image, a different receiver/selector will have been installed under 'Package Loader'; if this method is reached when theoretically SqueakMap is already loaded, presumably this is a grandfathered menu item in a still-up menu, so get the message on to its appropriate recipient."	| loaderClass |	((loaderClass := Smalltalk at: #SMLoader ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[^ loaderClass open].	(self confirm: 'This requires that you first install "SqueakMap" into your image.SqueakMap is a new architecture for finding, installing, andpublishing packages in Squeak.Would you like to install SqueakMap now?' )		ifTrue:			[self loadSqueakMap]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'dgd 4/3/2006 14:12'!slideToTrash: evt	"Perhaps slide the receiver across the screen to a trash can and make it disappear into it.  In any case, remove the receiver from the screen."	| aForm trash startPoint endPoint morphToSlide |	((self renderedMorph == Utilities scrapsBook) or: [self renderedMorph isKindOf: TrashCanMorph]) ifTrue:		[self dismissMorph.  ^ self].	Preferences slideDismissalsToTrash ifTrue:		[morphToSlide := self representativeNoTallerThan: 200 norWiderThan: 200 thumbnailHeight: 100.		aForm := morphToSlide imageForm offset: (0@0).		trash := ActiveWorld			findDeepSubmorphThat:				[:aMorph | (aMorph isKindOf: TrashCanMorph) and:					[aMorph topRendererOrSelf owner == ActiveWorld]]			ifAbsent:				[trash := TrashCanMorph new.				trash bottomLeft: ActiveWorld bottomLeft - (-10@10).				trash openInWorld.				trash].		endPoint := trash fullBoundsInWorld center.		startPoint := self topRendererOrSelf fullBoundsInWorld center - (aForm extent // 2)].	self dismissMorph.	ActiveWorld displayWorld.	Preferences slideDismissalsToTrash ifTrue:		[aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15].	Utilities addToTrash: self! !!PasteUpMorph methodsFor: 'pen' stamp: 'di 5/24/2000 15:13'!noteNewLocation: location forPlayer: player	"Note that a morph has just moved with its pen down, begining at startPoint.	Only used in conjunction with Preferences batchPenTrails."	lastTurtlePositions ifNil: [lastTurtlePositions := IdentityDictionary new].	lastTurtlePositions at: player put: location! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 5/14/2001 23:34'!line: pt1 to: pt2 brushForm: brush	| offset |	offset := origin.	self setPaintColor: Color black.	port sourceForm: brush; fillColor: nil;		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededFor: form);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!Morph methodsFor: 'player' stamp: 'tk 10/30/2001 12:13'!assuredCardPlayer	"Answer the receiver's player, creating a new one if none currently exists"	| aPlayer |	(aPlayer := self player) ifNotNil: [		(aPlayer isKindOf: CardPlayer) 				ifTrue: [^ aPlayer]				ifFalse: [self error: 'Must convert to a CardPlayer']					"later convert using as: and remove the error"].	self assureExternalName.  "a default may be given if not named yet"	self player: (aPlayer := UnscriptedCardPlayer newUserInstance).		"Force it to be a CardPlayer.  Morph class no longer dictates what kind of player"	aPlayer costume: self.	self presenter ifNotNil: [self presenter flushPlayerListCache].	^ aPlayer! !!Morph methodsFor: 'menu' stamp: 'nk 3/10/2004 19:51'!outermostOwnerWithYellowButtonMenu	"Answer me or my outermost owner that is willing to contribute menu items to a context menu.	Don't include the world."	| outermost |	outermost := self outermostMorphThat: [ :ea |		ea isWorldMorph not and: [ ea hasYellowButtonMenu ]].	^outermost ifNil: [ self hasYellowButtonMenu ifTrue: [ self ] ifFalse: []] ! !!TextMorph methodsFor: 'objects from disk' stamp: 'di 7/30/2001 14:19'!convertToCurrentVersion: varDict refStream: smartRefStrm		borderWidth ifNil:		[borderWidth := 0.		self removeProperty: #fillStyle].	^ super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!PopUpChoiceMorph methodsFor: 'copying' stamp: 'di 3/24/1999 09:57'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].arguments := arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].getItemsArgs := getItemsArgs collect: [:each |	deepCopier references at: each ifAbsent: [each]].choiceArgs ifNotNil: [choiceArgs := choiceArgs collect: [:each |	deepCopier references at: each ifAbsent: [each]]].! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 3/13/2003 13:52'!commandKeySelectors	"Answer my command-key table"	| aDict |	aDict := self valueOfProperty: #commandKeySelectors ifAbsentPut: [self initializeDesktopCommandKeySelectors].	^ aDict! !!BalloonCanvas methodsFor: 'initialize' stamp: 'ar 11/11/1998 20:25'!resetEngine	engine := nil.! !!FileList methodsFor: 'private' stamp: 'mu 8/22/2003 01:46'!selectEncoding	| aMenu encodingItems |	aMenu := CustomMenu new.	encodingItems := OrderedCollection new.	TextConverter allSubclasses do: [:each | | names |		names := each encodingNames.		names notEmpty ifTrue: [ | label |			label := '' writeStream.			names do: [:eachName | label nextPutAll: eachName ] separatedBy: [ label nextPutAll: ', '].			encodingItems add: {label contents. names first asSymbol}.		].	].	aMenu addList: encodingItems.	brevityState := aMenu startUp.	brevityState ifNil: [brevityState := #needToGetBrief].! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 10/30/2000 11:16'!tileForIt	"Return a tile referring to the object resulting form evaluating my current selection.  Not currently threaded in, but useful in earlier demos and possibly still of value."	| result |	self handleEdit:		[result := textMorph editor evaluateSelection.		((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [self flash]			ifFalse: [self currentHand attachMorph: result tileToRefer]]! !!ColorPatchCanvas methodsFor: 'other' stamp: 'ar 6/22/1999 16:39'!translateBy: delta clippingTo: aRectangle during: aBlock	"Set a translation and clipping rectangle only during the execution of aBlock."	| tempCanvas |	tempCanvas := self copyOffset: delta clipRect: aRectangle.	aBlock value: tempCanvas.	foundMorph := tempCanvas foundMorph.! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 00:32'!advance: anInteger containingDirectoriesFrom: aDirectory	| theDirectory |	theDirectory := aDirectory.	1 to: anInteger do: [:i | theDirectory := theDirectory containingDirectory].	^theDirectory! !!CircleMorph methodsFor: 'rotate scale and flex' stamp: 'nk 7/1/2002 15:52'!rotationDegrees: degrees	| ref newPos flex origAngle origCenter |	ref := self referencePosition.	origAngle := self valueOfProperty: #originalAngle ifAbsentPut: [ self heading ].	origCenter := self valueOfProperty: #originalCenter ifAbsentPut: [ self center ].	flex := (MorphicTransform offset: ref negated)			withAngle: (degrees - origAngle) degreesToRadians.	newPos := (flex transform: origCenter) - flex offset.	self position: (self position + newPos - self center) asIntegerPoint.	self setProperty: #referencePosition toValue: ref.	self setProperty: #originalAngle toValue: origAngle.	self setProperty: #originalCenter toValue: origCenter.	self forwardDirection: degrees.	self changed.! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'acg 9/28/1999 23:34'!startUpWithCaption: aString at: location	|result|	result := super startUpWithCaption: aString at: location.	result ifNil: [^nil].	result isDirectory ifTrue:		[self makeFileMenuFor: result directory.		 self computeForm.		 ^self startUpWithCaption: aString at: location].	result isCommand ifTrue: 		[result := self getTypedFileName: result.		result ifNil: [^nil]].	canTypeFileName ifTrue: [^self confirmExistingFiles: result].	^result	! !!TextMorph methodsFor: 'private' stamp: 'di 7/20/2001 22:18'!compositionRectangle	| compRect |	compRect := self innerBounds.	margins ifNotNil: [compRect := compRect insetBy: margins].	compRect width < 9 ifTrue: [compRect := compRect withWidth: 9].	compRect height < 16 ifTrue: [compRect := compRect withHeight: 16].	^ compRect! !!TheWorldMenu methodsFor: 'construction' stamp: 'md 1/21/2006 10:51'!debugMenu        | menu |        menu := self menu: 'debug...'.        self fillIn: menu from: {                 { 'inspect world' . { #myWorld . #inspect } }.                { 'explore world' . { #myWorld . #explore } }.                { 'inspect model' . { self . #inspectWorldModel } }.                        " { 'talk to world...' . { self . #typeInMessageToWorld } }."                { 'start MessageTally' . { self . #startMessageTally } }.                { 'start/browse MessageTally' . { self . #startThenBrowseMessageTally } }.                { 'open process browser' . { self . #openProcessBrowser } }.                nil.                        "(self hasProperty: #errorOnDraw) ifTrue:  Later make this come up only when needed."                { 'start drawing again' . { #myWorld . #resumeAfterDrawError } }.                { 'start stepping again' . { #myWorld . #resumeAfterStepError } }.                nil.                { 'call #tempCommand' . { #myWorld . #tempCommand } }.                { 'define #tempCommand' . { #myWorld . #defineTempCommand } }.        }.	self haltOnceEnabled		ifTrue: [menu				add: 'disable halt/inspect once' translated				target: menu				action: #clearHaltOnce]		ifFalse: [menu				add: 'enable halt/inspect once' translated				target: menu				action: #setHaltOnce].	^menu	! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:51'!balloonTextSelector: aSymbol 	"change the receiver's balloonTextSelector"	balloonTextSelector := aSymbol! !!MorphicModel methodsFor: 'compilation' stamp: ''!use: cachedSelector orMakeModelSelectorFor: selectorBody in: selectorBlock	| selector |	model ifNil: [^ nil].	cachedSelector ifNil:			["Make up selector from slotname if any"			selector := (slotName ifNil: [selectorBody]								ifNotNil: [slotName , selectorBody]) asSymbol.			(model class canUnderstand: selector) ifFalse:				[(self confirm: 'Shall I compile a null response for'							, Character cr asString							, model class name , '>>' , selector)						ifFalse: [self halt].				model class compile: (String streamContents:								[:s | selector keywords doWithIndex:										[:k :i | s nextPutAll: k , ' arg' , i printString].								s cr; nextPutAll: '"Automatically generated null response."'.								s cr; nextPutAll: '"Add code below for appropriate behavior..."'.])							classified: 'input events'							notifying: nil]]		ifNotNil:			[selector := cachedSelector].	^ selectorBlock value: selector! !!TransformationMorph methodsFor: 'private' stamp: 'di 9/30/1998 22:49'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos := self referencePosition.	changeBlock value.	self chooseSmoothing.	self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)].	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!MatrixTransformMorph methodsFor: 'geometry' stamp: 'ar 6/12/2001 06:18'!computeBounds	| subBounds box |	(submorphs isNil or:[submorphs isEmpty]) ifTrue:[^self].	box := nil.	submorphs do:[:m|		subBounds := self transform localBoundsToGlobal: m bounds.		box 			ifNil:[box := subBounds]			ifNotNil:[box := box quickMerge: subBounds].	].	box ifNil:[box := 0@0 corner: 20@20].	fullBounds := bounds := box! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 9/9/2000 17:31'!morphsInFrontOverlapping: aRectangle	"Return all top-level morphs in front of someMorph that overlap with the given rectangle."	| morphList |	morphList := WriteStream on: Array new.	self morphsInFrontOf: nil overlapping: aRectangle do:[:m | morphList nextPut: m].	^morphList contents! !!SystemWindow methodsFor: 'label' stamp: 'dew 8/3/2004 01:12'!setLabel: aString	| frame |	labelString := aString.	label ifNil: [^ self].	label contents: aString.	self labelWidgetAllowance.  "Sets it if not already"	self isCollapsed		ifTrue: [self extent: (label width + labelWidgetAllowance) @ (self labelHeight + 2)]		ifFalse: [label fitContents; setWidth: (label width min: bounds width - labelWidgetAllowance).				label align: label bounds topCenter with: bounds topCenter + (0@borderWidth).				collapsedFrame ifNotNil:					[collapsedFrame := collapsedFrame withWidth: label width + labelWidgetAllowance]].	frame := LayoutFrame new.	frame leftFraction: 0.5;		 topFraction: 0.5;		 leftOffset: label width negated // 2;		 topOffset: label height negated // 2.	label layoutFrame: frame.! !!EditCommand methodsFor: 'accessors' stamp: 'sps 7/24/2003 13:40'!phase: aSymbol	^phase := aSymbol! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'ar 10/25/2000 21:58'!readFromObsolete: aStream	"Read one of those old and now obsolete events from the stream"	| type x y buttons keyValue typeString c |	typeString := String streamContents:		[:s |   [(c := aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove'		ifTrue: [type := #mouseMove  "fast treatment of common case"]		ifFalse: [type := typeString asSymbol].	x := Integer readFrom: aStream.	aStream skip: 1.	y := Integer readFrom: aStream.	aStream skip: 1.	buttons := Integer readFrom: aStream.	aStream skip: 1.	keyValue := Integer readFrom: aStream.	typeString = 'mouseMove' ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: x@y 			endPoint: x@y 			trail: #() 			buttons: buttons 			hand: nil 			stamp: nil].	(typeString = 'mouseDown') | (typeString = 'mouseUp') ifTrue:[			^MouseButtonEvent new				setType: type				position: x@y				which: 0				buttons: buttons				hand: nil				stamp: nil].	(typeString = 'keystroke') | (typeString = 'keyDown') | (typeString = 'keyUp') ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: x@y			keyValue: keyValue			hand: nil			stamp: nil].	^nil! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 9/19/2000 22:17'!dragThroughOnDesktop: evt	"Draw out a selection rectangle"	| selection |	selection := SelectionMorph newBounds: (evt cursorPoint extent: 8@8).	self addMorph: selection.	^ selection extendByHand: evt hand! !!LayoutFrame methodsFor: 'layout' stamp: 'JW 2/1/2001 13:04'!layout: oldBounds in: newBounds	"Return the proportional rectangle insetting the given bounds"	| left right top bottom |	leftFraction ifNotNil:[		left := newBounds left + (newBounds width * leftFraction).		leftOffset ifNotNil:[left := left + leftOffset]].	rightFraction ifNotNil:[		right := newBounds right - (newBounds width * (1.0 - rightFraction)).		rightOffset ifNotNil:[right := right + rightOffset]].	topFraction ifNotNil:[		top := newBounds top + (newBounds height * topFraction).		topOffset ifNotNil:[top := top + topOffset]].	bottomFraction ifNotNil:[		bottom := newBounds bottom - (newBounds height * (1.0 - bottomFraction)).		bottomOffset ifNotNil:[bottom := bottom + bottomOffset]].	left ifNil:[ right 			ifNil:[left := oldBounds left. right := oldBounds right]			ifNotNil:[left := right - oldBounds width]].	right ifNil:[right := left + oldBounds width].	top ifNil:[ bottom 			ifNil:[top := oldBounds top. bottom := oldBounds bottom]			ifNotNil:[top := bottom - oldBounds height]].	bottom ifNil:[bottom := top + oldBounds height].	^(left rounded @ top rounded) corner: (right rounded @ bottom rounded)! !!PasteUpMorph class methodsFor: 'project' stamp: 'di 7/15/1999 09:51'!disableDeferredUpdates: aBoolean	"If the argument is true, disable deferred screen updating."	"Details: When deferred updating is used, Morphic performs double-buffered screen updates by telling the VM to de-couple the Display from the hardware display buffer, drawing directly into the Display, and then forcing the changed regions of the Display to be copied to the screen. This saves both time (an extra BitBlt is avoided) and space (an extra display buffer is avoided). However, on platforms on which the Display points directly to the hardware screen buffer, deferred updating can't be used (you'd see ugly flashing as the layers of the drawing were assembled). In this case, the drawing is composited into an offscreen FormCanvas  and then copied to the hardware display buffer."	DisableDeferredUpdates := aBoolean.! !!TTSampleFontMorph methodsFor: 'connectors' stamp: 'nk 8/17/2003 11:34'!fontWithoutString: aTTFontDescription	font := aTTFontDescription.! !!TransformationMorph methodsFor: 'submorphs-add/remove' stamp: 'di 11/18/1999 15:44'!replaceSubmorph: oldMorph by: newMorph	| t b |	t := transform.	b := bounds.	super replaceSubmorph: oldMorph by: newMorph.	transform := t.	bounds := b.	self layoutChanged! !!FileList methodsFor: 'file list menu' stamp: 'yo 11/14/2002 15:04'!openMorphFromFile	"Reconstitute a Morph from the selected file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	aFileStream := (MultiByteBinaryOrTextStream with: ((FileStream readOnlyFileNamed: self fullName) binary contentsOfEntireFile)) binary reset.	morphOrList := aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList := morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [^ self errorMustBeMorph].			morphOrList openInWorld]! !!TextMorph methodsFor: 'accessing' stamp: 'tk 8/31/2000 14:59'!contentsAsIs: stringOrText	"Accept new text contents with line breaks only as in the text.	Fit my width and height to the result."	wrapFlag := false.	container ifNotNil: [container fillsOwner ifTrue: [wrapFlag := true]].	self newContents: stringOrText! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/11/2000 15:09'!optimumExtentFromAuthor	| opt |	^self 		valueOfProperty: #optimumExtentFromAuthor 		ifAbsent: [			opt := bounds extent.			self setProperty: #optimumExtentFromAuthor toValue: opt.			^opt		]! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'ar 12/14/2001 17:41'!mouseLeave: evt	owner ifNil: [^ self].	"left by being removed, not by mouse movement"	(self hasProperty: #justPickedUpPhrase) ifTrue:[		self removeProperty: #justPickedUpPhrase.		^self].	self stopSteppingSelector: #trackDropZones.	handWithTile := nil.	self removeSpaces.! !!PasteUpMorph methodsFor: 'painting' stamp: 'ar 6/2/2001 16:55'!paintBackground	| pic rect |	self world prepareToPaint.	pic := self backgroundSketch.	pic ifNotNil: [pic editDrawingIn: self forBackground: true]		"need to resubmit it? (tck comment)"		ifNil: [rect := self bounds.			pic := self world drawingClass new form: 				(Form extent: rect extent depth: Display depth).			pic bounds: rect.			"self world addMorphBack: pic.  done below"			pic := self backgroundSketch: pic.	"returns a different guy"			pic ifNotNil: [pic editDrawingIn: self forBackground: true]]! !!MorphicModel methodsFor: 'menu' stamp: 'di 6/20/97 15:36'!closeToEdits	"Disable this morph's ability to add and remove morphs via drag-n-drop."	open := false! !!Morph methodsFor: 'menus' stamp: 'sw 11/22/1999 12:13'!menuItemAfter: menuString	| allWordings |	allWordings := self allMenuWordings.	^ allWordings atWrap: ((allWordings indexOf: menuString) + 1)! !!FileList2 methodsFor: 'own services' stamp: 'sd 5/11/2003 22:15'!importImage	"Import the given image file and store the resulting Form in the default Imports"	| fname image |	fname := fileName sansPeriodSuffix.	image := Form fromFileNamed: self fullName.	Imports default importImage: image named: fname.! !!ImageMorph methodsFor: 'menu commands' stamp: 'di 9/15/1998 09:58'!readFromFile	| fileName |	fileName := FillInTheBlank		request: 'Please enter the image file name'		initialAnswer: 'fileName'.	fileName isEmpty ifTrue: [^ self].	self image: (Form fromFileNamed: fileName).! !!Morph methodsFor: 'menus' stamp: 'sw 3/2/2004 22:11'!addMiscExtrasTo: aMenu	"Add a submenu of miscellaneous extra items to the menu."	| realOwner realMorph subMenu |	subMenu := MenuMorph new defaultTarget: self.	(self isWorldMorph not and: [(self renderedMorph isSystemWindow) not])		ifTrue: [subMenu add: 'put in a window' translated action: #embedInWindow].	self isWorldMorph ifFalse:		[subMenu add: 'adhere to edge...' translated action: #adhereToEdge.		subMenu addLine].	realOwner := (realMorph := self topRendererOrSelf) owner.	(realOwner isKindOf: TextPlusPasteUpMorph) ifTrue:		[subMenu add: 'GeeMail stuff...' translated subMenu: (realOwner textPlusMenuFor: realMorph)].	subMenu		add: 'add mouse up action' translated action: #addMouseUpAction;		add: 'remove mouse up action' translated action: #removeMouseUpAction;		add: 'hand me tiles to fire this button' translated action: #handMeTilesToFire.	subMenu addLine.	subMenu add: 'arrowheads on pen trails...' translated action: #setArrowheads.	subMenu addLine.	subMenu defaultTarget: self topRendererOrSelf.	subMenu add: 'draw new path' translated action: #definePath.	subMenu add: 'follow existing path' translated action: #followPath.	subMenu add: 'delete existing path' translated action: #deletePath.	subMenu addLine.	self addGestureMenuItems: subMenu hand: ActiveHand.	aMenu add: 'extras...' translated subMenu: subMenu! !!TTSampleFontMorph methodsFor: 'menu' stamp: 'sma 1/1/2000 17:51'!nextSmoothingLevel	smoothing = 1		ifTrue: [smoothing := 2]		ifFalse: [smoothing = 2			ifTrue: [smoothing := 4]			ifFalse: [smoothing = 4				ifTrue: [smoothing := 1]]].	self changed! !!PluggableListMorph methodsFor: 'initialization' stamp: 'sw 1/18/2001 13:08'!keystrokeActionSelector: keyActionSel	"Set the keystroke action selector as specified"	keystrokeActionSelector := keyActionSel! !!PluggableButtonMorph methodsFor: 'events' stamp: 'ar 8/16/2001 11:24'!updateFeedbackForEvt: evt	| newState |	newState := self containsPoint: evt cursorPoint.	newState = showSelectionFeedback ifFalse: [		borderColor isColor			ifTrue:[showSelectionFeedback := newState]			ifFalse:[borderColor := newState ifTrue:[#inset] ifFalse:[#raised]].		self changed].! !!SimpleHierarchicalListMorph methodsFor: 'private' stamp: 'RAA 7/30/2000 19:49'!addMorphsTo: morphList from: aCollection allowSorting: sortBoolean withExpandedItems: expandedItems atLevel: newIndent	| priorMorph newCollection firstAddition |	priorMorph := nil.	newCollection := (sortBoolean and: [sortingSelector notNil]) ifTrue: [		(aCollection asSortedCollection: [ :a :b | 			(a perform: sortingSelector) <= (b perform: sortingSelector)]) asOrderedCollection	] ifFalse: [		aCollection	].	firstAddition := nil.	newCollection do: [:item | 		priorMorph := self indentingItemClass basicNew 			initWithContents: item 			prior: priorMorph 			forList: self			indentLevel: newIndent.		firstAddition ifNil: [firstAddition := priorMorph].		morphList add: priorMorph.		((item hasEquivalentIn: expandedItems) or: [priorMorph isExpanded]) ifTrue: [			priorMorph isExpanded: true.			priorMorph 				addChildrenForList: self 				addingTo: morphList				withExpandedItems: expandedItems.		].	].	^firstAddition	! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawRectangle: r color: c borderWidth: borderWidth borderColor: borderColor	"Draw a rectangle"	| fillC borderC |	fillC := self shadowColor ifNil:[c].	borderC := self shadowColor ifNil:[borderColor].	self ensuredEngine		drawRectangle: r		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!RectangleMorph class methodsFor: 'parts bin' stamp: 'tk 11/14/2001 20:09'!gradientPrototype	| rr |	rr := self authoringPrototype.	rr useGradientFill; borderWidth: 0.	^ rr! !!TTSampleFontMorph methodsFor: 'geometry' stamp: 'ar 11/14/1998 22:53'!position: pos	super position: pos.	transform := nil.! !!PluggableTabButtonMorph methodsFor: 'private - access' stamp: 'KLC 1/23/2004 14:37'!arcLengths: anArrayOfIntegers	arcLengths := anArrayOfIntegers! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 8/8/2001 17:31'!addMagicHaloFor: aHand	| halo prospectiveHaloClass |	aHand halo ifNotNil:[		aHand halo target == self ifTrue:[^self].		aHand halo isMagicHalo ifFalse:[^self]].	prospectiveHaloClass := Smalltalk at: self haloClass ifAbsent: [HaloMorph].	halo := prospectiveHaloClass new bounds: self worldBoundsForHalo.	halo popUpMagicallyFor: self hand: aHand.! !!SelectionMorph methodsFor: 'halo commands' stamp: 'dgd 9/20/2004 13:50'!alignTopEdges	"Make the top coordinate of all my elements be the same"	| minTop |	minTop := (selectedItems collect: [:itm | itm top]) min.	selectedItems do:		[:itm | itm top: minTop].	self changed! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/10/2001 16:03'!loadFromURL	"Allow the user to change the text in a crude way"	| url |	url := FillInTheBlankMorph request: ' Type in the url for a TrueType font on the web. '				 initialAnswer: 'http://www.fontguy.com/download.asp?fontid=1494'.	url isEmpty ifTrue: [^ self].	self loadFromURL: url.! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:24'!drawGeneralBezierShape: contours color: c borderWidth: borderWidth borderColor: borderColor	"Draw a general boundary shape (e.g., possibly containing holes)"	| fillC borderC |	fillC := self shadowColor ifNil:[c].	borderC := self shadowColor ifNil:[borderColor].	self ensuredEngine		drawGeneralBezierShape: contours		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!FileList methodsFor: 'private' stamp: 'yo 7/6/2004 20:52'!defaultEncoderFor: aFileName	"This method just illustrates the stupidest possible implementation of encoder selection."	| l |	l := aFileName asLowercase."	((l endsWith: FileStream multiCs) or: [		l endsWith: FileStream multiSt]) ifTrue: [		^ UTF8TextConverter new.	]."	((l endsWith: FileStream cs) or: [		l endsWith: FileStream st]) ifTrue: [		^ MacRomanTextConverter new.	].	^ Latin1TextConverter new.	! !!TransformMorph methodsFor: 'geometry' stamp: 'efc 7/24/2003 16:43'!layoutChanged	"A submorph could have moved, thus changing my localBounds. Invalidate the cache."	localBounds := nil.	^super layoutChanged! !!NewParagraph methodsFor: 'composition' stamp: 'RAA 5/7/2001 10:58'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| newResult |	newResult := TextComposer new		composeLinesFrom: start 		to: stop 		delta: delta 		into: lineColl 		priorLines: priorLines		atY: startingY		textStyle: textStyle 		text: text 		container: container		wantsColumnBreaks: wantsColumnBreaks == true.	lines := newResult first asArray.	maxRightX := newResult second.	^maxRightX! !!SketchMorph methodsFor: 'drawing' stamp: 'RAA 12/17/2000 12:53'!canBeEnlargedWithB3D	| answer |	^self 		valueOfProperty: #canBeEnlargedWithB3D		ifAbsent: [			answer := self rotatedForm colorsUsed allSatisfy: [ :c | c isTranslucent not].			self setProperty: #canBeEnlargedWithB3D toValue: answer.			answer		]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'tk 7/13/2000 20:07'!printIt	| result oldEditor |	textMorph editor selectFrom: selectionInterval first to: selectionInterval last;						model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result := (oldEditor := textMorph editor) evaluateSelection].	((result isKindOf: FakeClassPool) or: [result == #failedDoit]) ifTrue: [^self flash].	selectionInterval := oldEditor selectionInterval.	textMorph installEditorToReplace: oldEditor.	textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	selectionInterval := oldEditor selectionInterval.		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.	self scrollSelectionIntoView.! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:07'!alphaBits: a	alpha := a! !!FileList2 methodsFor: 'private' stamp: 'LC 1/6/2002 07:12'!saveLocalOnlyHit	ok := true.	modalView delete.	directory := fileName := nil.	currentDirectorySelected := #localOnly.! !!Morph methodsFor: 'drawing' stamp: 'RAA 1/6/2001 22:12'!expandFullBoundsForDropShadow: aRectangle	"Return an expanded rectangle for an eventual drop shadow"	| delta box |	box := aRectangle.	delta := self shadowOffset.	box := delta x >= 0 		ifTrue:[box right: aRectangle right + delta x]		ifFalse:[box left: aRectangle left + delta x].	box := delta y >= 0		ifTrue:[box bottom: aRectangle bottom + delta y]		ifFalse:[box top: aRectangle top + delta y].	^box! !!TextMorph methodsFor: 'accessing' stamp: 'sw 5/22/2003 02:39'!cursor	"Answer the receiver's logical cursor position"	| loc |	loc := self valueOfProperty: #textCursorLocation  ifAbsentPut: [1].	loc := loc min: text string size.	^ loc rounded	! !!TTSampleStringMorph methodsFor: 'menus' stamp: 'tk 12/7/2001 11:24'!edit	"Allow the user to change the text in a crude way"	| str |	str := FillInTheBlankMorph request: 'Type in new text for this TrueType displayer.'				 initialAnswer: 'some text'.	str isEmpty ifTrue: [^ self].	self string: str.! !!SimpleButtonDelayedMenuMorph methodsFor: 'event handling' stamp: 'ar 10/25/2000 18:08'!mouseStillDown: evt	(mouseDownTime isNil or: [(Time millisecondClockValue - mouseDownTime) abs < 1000]) ifTrue: [		^super mouseStillDown: evt	].	didMenu ifNotNil: [^super mouseStillDown: evt].	self color: oldColor.		"in case menu never returns"	didMenu := target showMenuFor: actionSelector event: evt.! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/10/2000 08:02'!validateBlock: aBlock	^validateBlock := aBlock! !!Morph methodsFor: 'e-toy support' stamp: 'dgd 9/6/2003 18:10'!makeGraphPaper	| smallGrid backColor lineColor |	smallGrid := Compiler evaluate: (FillInTheBlank request: 'Enter grid size' translated initialAnswer: '16').	smallGrid ifNil: [^ self].	Utilities informUser: 'Choose a background color' translated during: [backColor := Color fromUser].	Utilities informUser: 'Choose a line color' translated during: [lineColor := Color fromUser].	self makeGraphPaperGrid: smallGrid background: backColor line: lineColor.! !!BorderStyle class methodsFor: 'instance creation' stamp: 'ar 8/25/2001 17:26'!default	^Default ifNil:[Default := self new]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:00'!minCellSize	"Layout specific. This property specifies the minimal size of a table cell."	| props |	props := self layoutProperties.	^props ifNil:[0] ifNotNil:[props minCellSize].! !!HandMorph class methodsFor: 'accessing' stamp: ''!doubleClickTime: milliseconds	DoubleClickTime := milliseconds.! !!MorphExtension methodsFor: 'object fileIn' stamp: 'dgd 2/16/2003 21:06'!convertProperty: aSymbol toValue: anObject 	"These special cases move old properties into named fields of the 	extension"	aSymbol == #locked		ifTrue: [^ locked := anObject].	aSymbol == #visible		ifTrue: [^ visible := anObject].	aSymbol == #sticky		ifTrue: [^ sticky := anObject].	aSymbol == #balloonText		ifTrue: [^ balloonText := anObject].	aSymbol == #balloonTextSelector		ifTrue: [^ balloonTextSelector := anObject].	aSymbol == #actorState		ifTrue: [^ actorState := anObject].	aSymbol == #player		ifTrue: [^ player := anObject].	aSymbol == #name		ifTrue: [^ externalName := anObject].	"*renamed*"	aSymbol == #partsDonor		ifTrue: [^ isPartsDonor := anObject].	"*renamed*"	self assureOtherProperties at: aSymbol put: anObject! !!TextMorphEditor methodsFor: 'multi level undo' stamp: 'sps 7/24/2003 13:45'!noUndoReplace: anInterval with: aText"This is the zap that multilevel undo uses to do edits. This method bypasses any undo/redo plumbing (in contrast to zapSelection:).  This method is called by an EditCommand (which wants to carry out its paragraph surgery without adding another command to the editHistory)"	| start stop |	self deselect.	start := (anInterval first max: 1).	stop := (anInterval last min: paragraph text size).	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere := (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]]."Debug dShow: ('zap start->stop: ', (start to: stop) asString)."	paragraph 		replaceFrom: start 		to: stop 		with: aText 		displaying: false.  	UndoMessage sends: #noUndoer . "Keep the normal undo machine happy"	self userHasEdited  " -- note text now dirty"! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'bvs 3/24/2004 16:39'!beSplitsTopAndBottom	splitsTopAndBottom := true.	! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 10:07'!popUpOwner: aMenuItemMorph	"Set the current pop-up owner"	popUpOwner := aMenuItemMorph.! !!ProgressBarMorph methodsFor: 'initialization' stamp: 'sma 3/3/2000 18:55'!initialize	super initialize.	progressColor := Color green.	self value: (ValueHolder new contents: 0.0).	lastValue := 0.0! !!MorphicModel methodsFor: 'debug and other' stamp: '6/7/97 10:43 di'!installModelIn: aWorld	self wantsSlot ifFalse: [^ self].  "No real need to install"	slotName := aWorld model addPartNameLike: self class name withValue: self.	slotName ifNil: [^ self].  "user chose bad slot name"	self model: aWorld model slotName: slotName.	self compilePropagationMethods.	aWorld model compileAccessForSlot: slotName.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!subMenu: aMenuMorph	subMenu := aMenuMorph.	self changed.! !!NewParagraph methodsFor: 'copying' stamp: 'di 5/21/1998 21:45'!deepCopy	"Don't want to copy the container (etc) or fonts in the TextStyle."	| new |	new := self copy.	new textStyle: textStyle copy		lines: lines copy		text: text deepCopy.	^ new! !!SimpleHierarchicalListMorph methodsFor: 'accessing' stamp: 'RAA 7/18/1998 23:18'!columns: anArray	columns := anArray! !!MorphicModel class methodsFor: 'housekeeping' stamp: 'jm 7/30/97 16:40'!removeUninstantiatedModels	"With the user's permission, remove the classes of any models that have neither instances nor subclasses."	"MorphicModel removeUninstantiatedModels"	| candidatesForRemoval ok |	Smalltalk garbageCollect.	candidatesForRemoval :=		MorphicModel subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c |		ok := self confirm: 'Are you certain that youwant to delete the class ', c name, '?'.		ok ifTrue: [c removeFromSystem]].! !!HandMorph class methodsFor: 'utilities' stamp: 'ar 9/17/2000 17:02'!newEventRules: aBool	NewEventRules := aBool.! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/8/2000 15:37'!potentialDropMorph: aMorph	potentialDropMorph := aMorph.	aMorph highlightForDrop! !!Morph methodsFor: 'layout-menu' stamp: 'ar 11/13/2000 19:10'!changeMaxCellSize: evt	| handle |	handle := HandleMorph new forEachPointDo:[:newPoint |		self maxCellSize: (newPoint - evt cursorPoint) asIntegerPoint].	evt hand attachMorph: handle.	handle startStepping.! !!HaloMorph methodsFor: 'private' stamp: 'sw 2/2/2006 00:28'!startScale: evt with: scaleHandle	"Initialize scaling of my target."	self obtainHaloForEvent: evt andRemoveAllHandlesBut: scaleHandle.	target isFlexMorph ifFalse: [target addFlexShellIfNecessary].	growingOrRotating := true.	positionOffset := 0@0.	self setProperty: #commandInProgress toValue:		(Command new			cmdWording: ('resize ' translated, target nameForUndoWording);			undoTarget: target renderedMorph selector: #setFlexExtentFromHalo: argument: target extent).	originalExtent := target extent! !!Morph methodsFor: 'e-toy support' stamp: 'kfr 9/4/2004 15:22'!gridFormOrigin: origin grid: smallGrid background: backColor line: lineColor	| bigGrid gridForm gridOrigin |	gridOrigin := origin \\ smallGrid.	bigGrid := (smallGrid asPoint x) @ (smallGrid asPoint y).	gridForm := Form extent: bigGrid depth: Display depth.	backColor ifNotNil: [gridForm fillWithColor: backColor].	gridOrigin x to: gridForm width by: smallGrid x do:		[:x | gridForm fill: (x@0 extent: 1@gridForm height) fillColor: lineColor].	gridOrigin y to: gridForm height by: smallGrid y do:		[:y | gridForm fill: (0@y extent: gridForm width@1) fillColor: lineColor].	^ InfiniteForm with: gridForm! !!BitmapFillStyle methodsFor: '*Morphic-Balloon' stamp: 'wiz 8/30/2003 16:54'!grabNewGraphicIn: aMorph event: evt 	"Used by any morph that can be represented by a graphic"	| fill |	fill := Form fromUser.	fill boundingBox area = 0		ifTrue: [^ self].	self form: fill.	self direction: fill width @ 0.	self normal: 0 @ fill height.	aMorph changed! !!StringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:42'!initialize"initialize the state of the receiver"	super initialize.""	font := nil.	emphasis := 0.	hasFocus := false! !!StringMorph class methodsFor: 'testing' stamp: 'di 5/6/1998 21:08'!test2	"Return a morph with lots of strings for testing display speed."	| c r |	c := AlignmentMorph newColumn.	SystemOrganization categories reverseDo:		[:cat | c addMorph: (StringMorph new contents: cat)].	r := RectangleMorph new extent: c fullBounds extent.	c submorphsDo: [:m | r addMorph: m].	^ r! !!Morph methodsFor: 'halos and balloon help' stamp: 'bf 11/1/2000 15:58'!showBalloon: msgString hand: aHand	"Pop up a balloon containing the given string,	first removing any existing BalloonMorphs in the world."	| w balloon h |	(w := self world) ifNil: [^ self].	h := aHand.	h ifNil:[		h := w activeHand].	balloon := BalloonMorph string: msgString for: self balloonHelpAligner.	balloon popUpFor: self hand: h.! !!PluggableListMorph methodsFor: 'menus' stamp: 'dao 6/6/2006 15:58'!copyListToClipboard	"Copy my items to the clipboard as a multi-line string"	| stream |	stream := WriteStream on: (String new: self getList size * 40).	list do: [:ea | stream nextPutAll: ea asString] separatedBy: [stream nextPut: Character cr].	Clipboard clipboardText: stream contents! !!TransformationMorph methodsFor: 'testing' stamp: 'mdr 10/3/2000 11:28'!stepTime	"Answer the stepTime of my rendered morph if posible"	| rendered |	rendered := self renderedMorph.	rendered = self ifTrue: [^super stepTime].	"Hack to avoid infinite recursion"	^rendered stepTime.	! !!MorphicEvent methodsFor: 'accessing' stamp: 'ar 9/13/2000 15:29'!timeStamp	"Return the millisecond clock value at which the event was generated"	^timeStamp ifNil:[timeStamp := Time millisecondClockValue]! !!ProjectViewMorph methodsFor: 'copying' stamp: 'tk 1/8/1999 08:56'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.project := deepCopier references at: project ifAbsent: [project].lastProjectThumbnail := deepCopier references at: lastProjectThumbnail 				ifAbsent: [lastProjectThumbnail].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:59'!listSpacing	"Layout specific. This property describes how the heights for different rows in a table layout should be handled.		#equal - all rows have the same height		#none - all rows may have different heights	"	| props |	props := self layoutProperties.	^props ifNil:[#none] ifNotNil:[props listSpacing].! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/3/1998 19:01'!pattern: textOrStringOrNil	textOrStringOrNil		ifNil: [pattern := '*']		ifNotNil: [pattern := textOrStringOrNil asString].	self updateFileList.	^ true! !!MouseClickState methodsFor: 'initialize' stamp: 'jcg 9/21/2001 13:08'!client: aMorph click: aClickSelector dblClick: aDblClickSelector dblClickTime: timeOut dblClickTimeout: aDblClickTimeoutSelector drag: aDragSelector threshold: aNumber event: firstClickEvent	clickClient := aMorph.	clickSelector := aClickSelector.	dblClickSelector := aDblClickSelector.	dblClickTime := timeOut.	dblClickTimeoutSelector := aDblClickTimeoutSelector.	dragSelector := aDragSelector.	dragThreshold := aNumber.	firstClickDown := firstClickEvent.	firstClickTime := firstClickEvent timeStamp.	clickState := #firstClickDown.! !!Morph methodsFor: 'debug and other' stamp: 'RAA 7/7/2000 16:41'!altSpecialCursor2	| f |	"a blue box with transparent center"	f := Form extent: 32@32 depth: 32.	f offset: (f extent // 2) negated.	f fill: f boundingBox rule: Form over fillColor: (Color blue alpha: 0.5).	f fill: (f boundingBox insetBy: 4) rule: Form over fillColor: Color transparent.	^f! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 6/19/2000 07:44'!beWorldForProject: aProject	self privateOwner: nil.	worldState := WorldState new.	self addHand: HandMorph new.	self setProperty: #automaticPhraseExpansion toValue: true.	self setProperty: #optimumExtentFromAuthor toValue: Display extent.	self startSteppingSubmorphsOf: self! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/2/1998 11:31'!positionNear: aPoint forExtent: anExtent adjustmentSuggestion: adjustmentPoint	"Compute a plausible positioning for adding a subpart of size anExtent, somewhere near aPoint, using adjustmentPoint as the unit of adjustment"	| adjustedPosition |	adjustedPosition := aPoint.	[((self morphsAt: (adjustedPosition + (anExtent // 2))) size > 1) and:  "that 1 is self here"		[bounds containsPoint: adjustedPosition]]	whileTrue:		[adjustedPosition := adjustedPosition + adjustmentPoint].	^ adjustedPosition! !!MouseMoveEvent methodsFor: 'initialize' stamp: 'ar 10/24/2000 16:31'!type: eventType readFrom: aStream	| x y |	super type: eventType readFrom: aStream.	aStream skip: 1.	x := Integer readFrom: aStream.	aStream skip: 1.	y := Integer readFrom: aStream.	startPoint := x@y.! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'ar 11/15/1998 21:56'!rotationDegrees: degrees	| last delta |	last := self lastRotationDegrees.	delta := degrees - last.	self rotateBy: delta.	self lastRotationDegrees: degrees.! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'nk 4/6/2002 22:33'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title w |	Smalltalk isMorphic ifFalse: [^ self].	title := self allMorphs detect: [ :ea | ea hasProperty: #titleString ].	title := title submorphs first.	self visible: false.	w := ActiveWorld.	aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		title contents: string.		self setConstrainedPosition: Sensor cursorPoint hangOut: false.		self changed.		w displayWorld		 "show myself"	]. 	self delete.	w displayWorld! !!PolygonMorph methodsFor: 'menu' stamp: 'sw 9/24/2002 19:23'!arrowLength: aLength	"Assumes that I have exactly two vertices"	| theta horizontalOffset verticalOffset newTip delta |	delta := vertices second - vertices first.	theta := delta theta.	horizontalOffset := aLength * (theta cos).	verticalOffset := aLength * (theta sin).	newTip := vertices first + (horizontalOffset @ verticalOffset).	self verticesAt: 2 put: newTip! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 8/17/2000 13:22'!directoryChangeBlock: aBlockOrNil	directoryChangeBlock := aBlockOrNil.! !!PluggableTextMorph methodsFor: 'model access' stamp: 'tween 8/29/2004 20:43'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph := self textMorphClass new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!SketchMorph methodsFor: 'drawing' stamp: 'RAA 12/17/2000 14:24'!drawHighResolutionOn: aCanvas in: aRectangle	| r finalClipRect scale sourceOrigin sourceExtent sourceRect biggerSource biggerDestExtent interForm offsetInBigger |	r := aRectangle translateBy: aCanvas origin.	finalClipRect := r intersect: (aCanvas clipRect translateBy: aCanvas origin).	self canBeEnlargedWithB3D ifTrue: [		(WarpBlt toForm: aCanvas form)			clipRect: finalClipRect;			sourceForm: originalForm;			cellSize: 2;  "installs a colormap"			combinationRule: Form paint;			copyQuad: originalForm boundingBox innerCorners 			toRect: r.		^self	].	scale := aRectangle extent / originalForm extent.	sourceOrigin := originalForm offset + (aCanvas clipRect origin - aRectangle origin / scale).	sourceExtent := aCanvas clipRect extent / scale.	sourceRect := sourceOrigin rounded extent: sourceExtent rounded.	biggerSource := sourceRect expandBy: 1.	biggerDestExtent := (biggerSource extent * scale) rounded.	offsetInBigger := (sourceOrigin - biggerSource origin * scale) rounded.	interForm := Form extent: biggerDestExtent depth: aCanvas depth.	(originalForm copy: biggerSource)		displayInterpolatedIn: interForm boundingBox		on: interForm.	aCanvas 		drawImage: interForm 		at: aCanvas clipRect origin 		sourceRect: (offsetInBigger extent: aCanvas clipRect extent).! !!MenuMorph methodsFor: 'keyboard control' stamp: 'di 12/10/2001 22:52'!moveSelectionDown: direction event: evt	"Move the current selection up or down by one, presumably under keyboard control.	direction = +/-1"	| index m |	index := (submorphs indexOf: selectedItem ifAbsent: [1-direction]) + direction.	submorphs do: "Ensure finite"		[:unused | m := submorphs atWrap: index.		((m isKindOf: MenuItemMorph) and: [m isEnabled]) ifTrue:			[^ self selectItem: m event: evt].		"Keep looking for an enabled item"		index := index + direction sign].	^ self selectItem: nil event: evt! !!MovieMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:47'!initialize	"initialize the state of the receiver"	super initialize.	""		playMode := #stop.	"#stop, #playOnce, or #loop"	msecsPerFrame := 200.	rotationDegrees := 0.	scalePoint := 1.0 @ 1.0.	frameList := EmptyArray.	currentFrameIndex := 1.	dwellCount := 0! !!ScrollPane methodsFor: 'scrolling' stamp: 'sps 3/10/2004 12:07'!hideOrShowScrollBars	| wasHShowing wasVShowing |	wasVShowing := self vIsScrollbarShowing.	wasHShowing := self hIsScrollbarShowing.	self 		vHideOrShowScrollBar; 		hHideOrShowScrollBar; 		resizeScrollBars.	(wasVShowing and: [self vIsScrollbarShowing not]) ifTrue:		["Make sure the delta is 0"		(scroller offset y == 0) 				ifFalse:[ scroller offset: (scroller offset x@0) ]].				(wasHShowing and: [self hIsScrollbarShowing not]) ifTrue:		[(scroller offset x <= 0)				ifFalse:[ scroller offset: (self hMargin negated@scroller offset y)]].! !!AbstractResizerMorph methodsFor: 'as yet unclassified' stamp: 'jrp 7/5/2005 21:42'!mouseDown: anEvent	lastMouse := anEvent cursorPoint! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/19/2001 18:10'!bringAllSiblingsToMe: evt	"bring all siblings of the receiver's player found in the same container to the receiver's location."	| aPlayer aPosition aContainer |	(aPlayer := self topRendererOrSelf player) belongsToUniClass ifFalse: [self error: 'not uniclass'].	aPosition := self topRendererOrSelf position.	aContainer := self topRendererOrSelf owner.	(aPlayer class allInstances copyWithout: aPlayer) do:		[:each |			(aContainer submorphs includes: each costume) ifTrue:				[each costume  position: aPosition]]! !!SystemWindow methodsFor: 'menu' stamp: 'sw 8/7/2000 17:35'!makeUnclosable	mustNotClose := true.	self deleteCloseBox! !!TextMorph methodsFor: 'event handling' stamp: 'Tsutomu Hiroshima 11/17/2003 08:49'!keyStroke: evt	"Handle a keystroke event."	| action |	evt keyValue = 13 ifTrue:["CR - check for special action"		action := self crAction.		action ifNotNil:[			"Note: Code below assumes that this was some			input field reacting on CR. Break the keyboard			focus so that the receiver can be safely deleted."			evt hand newKeyboardFocus: nil.			^action value]].	self handleInteraction: [editor readKeyboard] fromEvent: evt.	"self updateFromParagraph."	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!PasteUpMorph methodsFor: 'world state' stamp: 'RAA 5/24/2000 10:38'!pauseEventRecorder	"Suspend any event recorder, and return it if found"	| er |	worldState handsDo: [:h | (er := h pauseEventRecorderIn: self) ifNotNil: [^ er]].	^ nil! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/18/2000 15:19'!nonCachingFullDrawOn: aCanvas	| shadowForm |	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		"Note: We use a shadow form here to prevent drawing		overlapping morphs multiple times using the transparent		shadow color."		shadowForm := self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."		shadowCanvas paintImage: shadowForm at: shadowForm offset.  "draw shadows"	].	"draw morphs in front of shadows"	self drawSubmorphsOn: aCanvas.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!Morph methodsFor: 'e-toy support' stamp: 'tk 10/19/1999 07:16'!updateCachedThumbnail	"If I have a cached thumbnail, then update it.  Copied up from Dan's original version in PasteUpMorph so it can be used by all morphs."	| cachedThumbnail |	(cachedThumbnail := self valueOfProperty: #cachedThumbnail) ifNotNil:		[(cachedThumbnail respondsTo: #computeThumbnail) 			ifTrue: [cachedThumbnail computeThumbnail]			ifFalse: [self removeProperty: #computeThumbnail]].		"Test and removal are because the thumbnail is being replaced by another Morph.  We don't know why.  Need to fix that at the source."! !!UpdatingMenuItemMorph methodsFor: 'wording' stamp: 'sw 6/11/1999 15:12'!wordingProvider: aProvider wordingSelector: aSelector	wordingProvider := aProvider.	wordingSelector := aSelector! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 5/26/1999 16:22'!growable: aBoolean	growable := aBoolean.! !!FileList methodsFor: 'private' stamp: 'rhi 9/8/2001 02:17'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| from to |	self sortingByName		ifTrue: [			from := item lastIndexOf: $( ifAbsent: [0].			to := item lastIndexOf: $) ifAbsent: [0]]		ifFalse: [			from := item indexOf: $( ifAbsent: [0].			to := item indexOf: $) ifAbsent: [0]].	^ (from * to = 0		ifTrue: [item]		ifFalse: [item copyReplaceFrom: from to: to with: '']) withBlanksTrimmed! !!TranslucentProgessMorph methodsFor: 'as yet unclassified' stamp: 'RAA 6/29/2000 11:35'!opaqueBackgroundColor: aColor	opaqueBackgroundColor := aColor! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 4/23/1998 16:49'!isPartsBin: aBoolean	isPartsBin := aBoolean! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/19/2003 10:08'!wantsDroppedMorph: aTransferMorph event: evt inMorph: dest	| retval |	retval := (aTransferMorph isKindOf: TransferMorph)		and: [ aTransferMorph dragTransferType == #file ]		and: [ self isDirectoryList: dest ].	"retval ifFalse: [ Transcript nextPutAll: 'drop not wanted'; cr ]."	^retval! !!ThreePhaseButtonMorph methodsFor: 'initialization' stamp: 'tk 7/1/97 08:34'!initialize	super initialize.	state := #off.	target := nil.	actionSelector := #flash.	arguments := EmptyArray.	actWhen := #buttonUp.	"self on: #mouseStillDown send: #dragIfAuthoring: to: self."		"real move should include a call on dragIfAuthoring: "! !!SketchMorph methodsFor: 'menus' stamp: 'nk 3/27/2001 17:57'!changePixelsOfColor: c toColor: newColor	| r |	originalForm mapColor: c to: newColor.	r := originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: r).! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:54'!cellPositioning	"Layout specific. This property describes how the receiver should be layed out in its owner when the bounds of the cell assigned to the receiver do not exactly match its bounds. Possible values are:		#topLeft, #topRight, #bottomLeft, #bottomRight, #topCenter, #leftCenter, #rightCenter, #bottomCenter, #center 	which align the receiver's bounds with the cell at the given point."	| props |	props := self layoutProperties.	^props ifNil:[#center] ifNotNil:[props cellPositioning].! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:59'!listDirection	"Layout specific. This property describes the direction in which a list-like layout should be applied. Possible values are:		#leftToRight		#rightToLeft		#topToBottom		#bottomToTop	indicating the direction in which any layout should take place"	| props |	props := self layoutProperties.	^props ifNil:[#topToBottom] ifNotNil:[props listDirection].! !!MenuMorph methodsFor: 'accessing' stamp: 'ar 9/18/2000 11:22'!itemWithWording: wording	"If any of the receiver's items or submenu items have the given wording (case-blind comparison done), then return it, else return nil."	| found |	self items do:[:anItem |		found := anItem itemWithWording: wording.		found ifNotNil:[^found]].	^ nil! !!TextContainer methodsFor: 'access' stamp: 'di 11/13/97 14:45'!avoidsOcclusions: aBoolean	avoidsOcclusions := aBoolean.	self releaseCachedState! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 12/15/2000 00:00'!stopStepping	"Stop getting sent the 'step' message."	| w |	w := self world.	w ifNotNil: [w stopStepping: self].! !!Morph methodsFor: 'e-toy support' stamp: 'dgd 10/8/2003 19:30'!unlockOneSubpart	| unlockables aMenu reply |	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size <= 1 ifTrue: [^ self unlockContents].	aMenu := SelectionMenu labelList: (unlockables collect: [:m | m externalName]) selections: unlockables.	reply := aMenu startUpWithCaption: 'Who should be be unlocked?' translated.	reply isNil ifTrue: [^ self].	reply unlock! !!HandMorph class methodsFor: 'utilities' stamp: 'nk 7/20/2003 10:03'!showEvents: aBool	"HandMorph showEvents: true"	"HandMorph showEvents: false"	ShowEvents := aBool.	aBool ifFalse: [ ActiveWorld invalidRect: (0@0 extent: 250@120) ].! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 2/13/98 16:35'!setMorph: anActorMorph scriptName: aString	"Create a script editor for editing a named script."	self setMorph: anActorMorph.	scriptName := aString.	self addMorphFront: self buttonRowForEditor.	self updateStatus.	firstTileRow := 2! !!ScriptEditorMorph methodsFor: 'frequency' stamp: 'yo 2/14/2005 13:51'!typeInFrequency	| reply aNumber |	reply := FillInTheBlank request: 'Number of firings per tick: ' translated initialAnswer: self scriptInstantiation frequency printString.	reply ifNotNil:		[aNumber := reply asNumber.		aNumber > 0 ifTrue:			[self setFrequencyTo: aNumber]]! !!Morph methodsFor: 'macpal' stamp: 'sw 10/10/1999 10:23'!flash	| c w |	c := self color.	self color: Color black.	(w := self world) ifNotNil: [w displayWorldSafely].	self color: c! !!ScriptEditorMorph methodsFor: 'other' stamp: 'dgd 9/1/2003 14:54'!offerScriptorMenu	"Put up a menu in response to the user's clicking in the menu-request area of the scriptor's heaer"	| aMenu  count |	self modernize.	ActiveHand showTemporaryCursor: nil.	aMenu := MenuMorph new defaultTarget: self.	aMenu addTitle: scriptName asString.	Preferences universalTiles ifFalse:		[count := self savedTileVersionsCount.		self showingMethodPane			ifFalse:				"currently showing tiles"				[aMenu add: 'show code textually' translated action: #showSourceInScriptor.				count > 0 ifTrue: 					[aMenu add: 'revert to tile version...' translated action:	 #revertScriptVersion].				aMenu add: 'save this version' translated	action: #saveScriptVersion]			ifTrue:				"current showing textual source"				[count >= 1 ifTrue:					[aMenu add: 'revert to tile version' translated action: #revertToTileVersion]]].	aMenu addList: {		#-.		{'destroy this script' translated.					#destroyScript}.		{'rename this script' translated.					#renameScript}.		}.	self hasParameter ifFalse:		[aMenu addList: {{'button to fire this script' translated.			#tearOfButtonToFireScript}}].	aMenu addList: {		{'edit balloon help for this script' translated.		#editMethodDescription}.		#-.		{'explain status alternatives' translated. 			#explainStatusAlternatives}.		#-.		{'hand me a tile for self' translated.					#handUserTileForSelf}.		{'hand me a "random number" tile' translated.		#handUserRandomTile}.		{'hand me a "button down?" tile' translated.		#handUserButtonDownTile}.		{'hand me a "button up?" tile' translated.			#handUserButtonUpTile}.		}.	aMenu addList: (self hasParameter		ifTrue: [{			#-.			{'remove parameter' translated.					#ceaseHavingAParameter}}]		ifFalse: [{			{'fires per tick...' translated.						#chooseFrequency}.			#-.			{'add parameter' translated.						#addParameter}}]).	aMenu popUpInWorld: self currentWorld.! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'jrp 10/4/2004 16:06'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w := self world.	w ifNil: [^ response].		(ProvideAnswerNotification signal:		(self submorphOfClass: TextMorph) userString) ifNotNilDo:		[:answer |		self delete.		w doOneCycle.		^ response := (answer == #default) ifTrue: [response] ifFalse: [answer]].	done := false.	w activeHand newKeyboardFocus: textPane.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^ response! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 17:51'!exportAsJPEG	"Export the receiver's image as a JPEG"	| fName |	fName := FillInTheBlank request: 'Please enter the name' translated initialAnswer: self externalName,'.jpeg'.	fName isEmpty ifTrue: [^ self].	self imageForm writeJPEGfileNamed: fName! !!NewParagraph methodsFor: 'selection' stamp: 'ar 4/12/2005 19:53'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line := lines at: (self lineIndexForPoint: aPoint).	^ ((text string isWideString) ifTrue: [		MultiCharacterBlockScanner new text: text textStyle: textStyle	] ifFalse: [CharacterBlockScanner new text: text textStyle: textStyle])		characterBlockAtPoint: aPoint index: nil		in: line! !!BorderedMorph methodsFor: 'geometry' stamp: 'nk 4/5/2001 14:23'!intersectionWithLineSegmentFromCenterTo: aPoint	"account for round corners. Still has a couple of glitches at upper left and right corners"	| pt |	pt := super intersectionWithLineSegmentFromCenterTo: aPoint.	self wantsRoundedCorners ifFalse: [ ^pt ].	self bounds corners with: (self bounds insetBy: 6) corners do: [ :out :in |		(pt - out) abs < (6@6)			ifTrue: [ ^(in + (Point r: 5.0 degrees: (pt - in) degrees)) asIntegerPoint ].	].	^pt.! !!ColorPatchCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 16:14'!stopMorph: aMorph	stopMorph := aMorph! !!Slider methodsFor: 'access' stamp: 'sw 3/7/2000 15:39'!sliderColor: newColor	sliderColor := newColor.	slider ifNotNil: [slider color: sliderColor]! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 11/1/2000 22:45'!isEditingName	| nameMorph |	nameMorph := self findA: UpdatingStringMorph.	nameMorph ifNil: [^false].	^nameMorph hasFocus! !!TransferMorph methodsFor: 'private' stamp: 'nk 6/16/2003 16:34'!updateCopyIcon	| copyIcon |	copyIcon := self submorphWithProperty: #tmCopyIcon.	(self shouldCopy and: [ copyIcon isNil ]) ifTrue: [		^self addMorphFront: ((ImageMorph new image: CopyPlusIcon) setProperty: #tmCopyIcon toValue: true)	].	(self shouldCopy not and: [ copyIcon notNil ]) ifTrue: [		copyIcon delete	]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/21/1998 16:12'!paneWithLongestSide: sideBlock near: aPoint 	| thePane theSide theLen box |	theLen := 0.	paneMorphs do:		[:pane | box := pane bounds.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[thePane := pane.				theSide := side.				theLen := len]]].	sideBlock value: theSide.	^ thePane! !!Morph methodsFor: 'initialization' stamp: 'fbs 1/5/2005 09:17'!inAScrollPane	"Answer a scroll pane that allows the user to scroll the receiver in either direction.  It will have permanent scroll bars unless you take some special action."	| widget |	widget := ScrollPane new.	widget extent: ((self width min: 300 max: 100) @ (self height min: 150 max: 100));		borderWidth: 0.	widget scroller addMorph: self.	widget setScrollDeltas.	widget color: self color darker darker.	^ widget! !!PluggableTabButtonMorph methodsFor: 'private - access' stamp: 'KLC 1/23/2004 16:40'!subMorph: aMorph	subMorph := aMorph! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 8/12/2001 17:47'!activateObjectsTool	"Offer the user a parts bin of morphs -- if one already exists, bring it to the front and flash its border beckoningly; if none exists yet, create a new one and place it in the center of the screen"	| anObjectTool |	submorphs do:		[:aMorph | (aMorph renderedMorph isKindOf: ObjectsTool)			ifTrue:				[aMorph comeToFront.				aMorph flash.				^ self]].	"None found, so create one"	anObjectTool := ObjectsTool newStandAlone.	self addMorphFront: anObjectTool.	anObjectTool fullBounds.	anObjectTool center: self center	"ActiveWorld activateObjectsTool"! !!ComplexBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:13'!colors	^colors ifNil:[colors := self computeColors].! !!PluggableMessageCategoryListMorph methodsFor: 'model access' stamp: 'ls 8/19/2001 15:35'!getList	"Differs from the generic in that here we obtain and cache the raw list, then cons it together with the special '-- all --' item to produce the list to be used in the browser.  This special handling is done in order to avoid excessive and unnecessary reformulation of the list in the step method"	getRawListSelector == nil ifTrue: ["should not happen!!" priorRawList := nil.  ^ #()].	model classListIndex = 0 ifTrue: [^ priorRawList := list := Array new].	priorRawList := model perform: getRawListSelector.	list := (Array with: ClassOrganizer allCategory), priorRawList.	^list! !!TextMorph methodsFor: 'private' stamp: 'tween 8/29/2004 20:34'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray := priorEditor stateArray].	editor := self editorClass new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !!Morph methodsFor: 'geometry' stamp: 'dgd 9/10/2004 12:37'!worldBoundsForHalo	"Answer the rectangle to be used as the inner dimension of my halos.	Allow for showing either bounds or fullBounds, and compensate for the optional bounds rectangle."	| r |	r := (Preferences haloEnclosesFullBounds)		ifFalse: [ self boundsIn: nil ]		ifTrue: [ self fullBoundsInWorld ].	Preferences showBoundsInHalo ifTrue: [ ^r outsetBy: 2 ].	^r! !!TextMorph methodsFor: 'private' stamp: 'RAA 12/5/2001 11:20'!releaseParagraphReally	"a slight kludge so subclasses can have a bit more control over whether the paragraph really 	gets released. important for GeeMail since the selection needs to be accessible even if the 	hand is outside me"	"Paragraph instantiation is lazy -- it will be created only when needed"	self releaseEditor.	paragraph ifNotNil:		[paragraph := nil].	container ifNotNil:		[container releaseCachedState]! !!Morph methodsFor: 'menus' stamp: 'yo 2/17/2005 16:58'!setArrowheads	"Let the user edit the size of arrowheads for this object"	| aParameter result  |	aParameter := self renderedMorph valueOfProperty:  #arrowSpec ifAbsent:		[Preferences parameterAt: #arrowSpec ifAbsent: [5 @ 4]].	result := Morph obtainArrowheadFor: 'Head size for arrowheads: ' translated defaultValue: aParameter asString.	result ifNotNil:			[self renderedMorph  setProperty: #arrowSpec toValue: result]		ifNil:			[Beeper beep]! !!HaloMorph methodsFor: 'private' stamp: 'ar 11/29/2001 20:01'!doMenu: evt with: menuHandle	"Ask hand to invoke the halo menu for my inner target."	| menu |	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	self world displayWorld.	menu := innerTarget buildHandleMenu: evt hand.	innerTarget addTitleForHaloMenu: menu.	menu popUpEvent: evt in: self world.! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 10/18/2001 04:42'!fromHandFreehand: hand	"Let the user draw a polygon, holding the mouse down, and ending		by clicking within 5 of the first point..."	| p1 poly pN opposite |	Cursor crossHair showWhile:		[[Sensor anyButtonPressed] whileFalse:			[self currentWorld displayWorldSafely; runStepMethods].		p1 := Sensor cursorPoint].	opposite := (Display colorAt: p1) negated.	opposite = Color transparent ifTrue: [opposite := Color red].	(poly := LineMorph from: p1 to: p1 color: opposite width: 2) openInWorld.	self currentWorld displayWorldSafely; runStepMethods.	[Sensor anyButtonPressed] whileTrue:			[pN := Sensor cursorPoint.			(pN dist: poly vertices last) > 3 ifTrue:				[poly setVertices: (poly vertices copyWith: pN).				self currentWorld displayWorldSafely; runStepMethods]].	hand position: Sensor cursorPoint.  "Done -- update hand pos"	^ (poly setVertices: (poly vertices copyWith: p1)) delete! !!TTSampleFontMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 18:43'!initialize	"initialize the state of the receiver"	super initialize.	smoothing := 4.	self extent: 300 @ 300! !!PasteUpMorph methodsFor: 'world menu' stamp: 'dgd 8/31/2004 16:25'!putUpWorldMenu: evt	"Put up a menu in response to a click on the desktop, triggered by evt."	| menu |	self bringTopmostsToFront.	evt isMouse ifTrue:		[evt yellowButtonPressed			ifTrue: [^ self yellowButtonClickOnDesktopWithEvent: evt].		evt shiftPressed ifTrue:[^ self findWindow: evt]].	"put up screen menu"	menu := self buildWorldMenu: evt.	menu addTitle: Preferences desktopMenuTitle translated.	menu popUpEvent: evt in: self.	^ menu! !!MenuItemMorph class methodsFor: 'class initialization' stamp: 'jm 11/16/97 09:17'!initialize	"MenuItemMorph initialize"	| f |	f := Form		extent: 5@9		fromArray: #(2147483648 3221225472 3758096384 4026531840 4160749568 4026531840 3758096384 3221225472 2147483648)		offset: 0@0.	SubMenuMarker := ColorForm mappingWhiteToTransparentFrom: f.! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 8/26/2001 19:01'!frameRectangle: aRectangle on: aCanvas	"Note: This uses BitBlt since it's roughly a factor of two faster for rectangles"	| w h r |	self colors ifNil:[^super frameRectangle: aRectangle on: aCanvas].	w := self width.	w isPoint ifTrue:[h := w y. w := w x] ifFalse:[h := w].	1 to: h do:[:i| "top/bottom"		r := (aRectangle topLeft + (i-1)) extent: (aRectangle width - (i-1*2))@1. "top"		aCanvas fillRectangle: r color: (colors at: i).		r := (aRectangle bottomLeft + (i @ (0-i))) extent: (aRectangle width - (i-1*2) - 1)@1. "bottom"		aCanvas fillRectangle: r color: (colors at: colors size - i + 1).	].	1 to: w do:[:i| "left/right"		r := (aRectangle topLeft + (i-1)) extent: 1@(aRectangle height - (i-1*2)). "left"		aCanvas fillRectangle: r color: (colors at: i).		r := aRectangle topRight + ((0-i)@i) extent: 1@(aRectangle height - (i-1*2) - 1). "right"		aCanvas fillRectangle: r color: (colors at: colors size - i + 1).	].! !!Morph methodsFor: 'submorphs-accessing' stamp: 'di 11/4/97 14:30'!submorphsBehind: aMorph do: aBlock	| behind |	behind := false.	submorphs do:		[:m | m == aMorph ifTrue: [behind := true]						ifFalse: [behind ifTrue: [aBlock value: m]]].! !!PluggableTextMorph methodsFor: 'scroll bar events' stamp: 'rr 3/10/2004 09:30'!scrollBarMenuButtonPressed: event	"The menu button in the scrollbar was pressed; put up the menu"	| menu |	(menu := self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu invokeModal]! !!Morph methodsFor: 'stepping and presenter' stamp: 'ar 12/15/2000 00:00'!stopSteppingSelector: aSelector	"Stop getting sent the given message."	| w |	w := self world.	w ifNotNil: [w stopStepping: self selector: aSelector].! !!FileList2 methodsFor: 'own services' stamp: 'nk 1/6/2004 12:36'!openImageInWindow	"Handle five file formats: GIF, JPG, PNG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image myStream |	myStream := (directory readOnlyFileNamed: fileName) binary.	image := Form fromBinaryStream: myStream.	myStream close.	Smalltalk isMorphic		ifTrue: [(World drawingClass withForm: image) openInWorld]		ifFalse: [FormView open: image named: fileName]! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'ar 8/25/2001 20:44'!locationIndicator	| loc |	^self valueOfProperty: #locationIndicator ifAbsent:[		loc := EllipseMorph new.		loc color: Color transparent; 			borderWidth: 1; 			borderColor: Color red; 			extent: 6@6.		self setProperty: #locationIndicator toValue: loc.		self addMorphFront: loc.		loc]! !!Morph methodsFor: 'accessing' stamp: 'sw 11/26/2001 16:18'!borderStyleForSymbol: aStyleSymbol	"Answer a suitable BorderStyle for me of the type represented by a given symbol"	| aStyle existing |	aStyle := BorderStyle borderStyleForSymbol: aStyleSymbol asSymbol.	aStyle ifNil: [self error: 'bad style'].	existing := self borderStyle.	aStyle width: existing width;		baseColor: existing baseColor.	^ (self canDrawBorder: aStyle)		ifTrue:			[aStyle]		ifFalse:			[nil]! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectRight: rect width: w	width := 1.	height := rect height - 1.	destX := rect right - 1.	destY := rect top + 1.	1 to: w do: [:i |		self copyBits.		destX := destX - 1.		destY := destY + 1.		height := height - 2].! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'nk 4/28/2004 10:26'!selectionIndex: idx	"Called internally to select the index-th item."	| theMorph range index |	idx ifNil: [^ self].	index := idx min: scroller submorphs size max: 0.	(theMorph := index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index])		ifNotNil:		[((theMorph bounds top - scroller offset y) >= 0			and: [(theMorph bounds bottom - scroller offset y) <= bounds height]) ifFalse:			["Scroll into view -- should be elsewhere"			range := self vTotalScrollRange.			scrollBar value: (range > 0				ifTrue: [((index-1 * theMorph height) / self vTotalScrollRange)									truncateTo: scrollBar scrollDelta]				ifFalse: [0]).			scroller offset: -3 @ (range * scrollBar value)]].	self selectedMorph: theMorph! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'tak 3/17/2005 18:27'!playfieldOptionsMenu	"Answer an auxiliary menu with options specific to playfields -- too many to be housed in the main menu"	| aMenu isWorld |	isWorld := self isWorldMorph.	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu add: 'save on file...' translated action: #saveOnFile.	Preferences eToyFriendly ifFalse: [		aMenu add: 'save as SqueakPage at url...' translated action: #saveOnURL.		aMenu add: 'update all from resources' translated action: #updateAllFromResources].	aMenu add: 'round up strays' translated action: #roundUpStrays.	aMenu balloonTextForLastItem:  'Bring back all objects whose current coordinates keep them from being visible, so that at least a portion of each of my interior objects can be seen.' translated.	aMenu add: 'show all players' translated action: #showAllPlayers.	aMenu balloonTextForLastItem:  'Make visible the viewers for all players which have user-written scripts in this playfield.' translated.	aMenu add: 'hide all players' translated action: #hideAllPlayers.	aMenu balloonTextForLastItem:  'Make invisible the viewers for all players in this playfield. This will save space before you publish this project' translated.	aMenu addLine.	aMenu add: 'shuffle contents' translated action: #shuffleSubmorphs.	aMenu balloonTextForLastItem: 'Rearranges my contents in random order' translated.	self griddingOn		ifTrue: [aMenu add: 'turn gridding off' translated action: #griddingOnOff.				aMenu add: (self gridVisible ifTrue: ['hide'] ifFalse: ['show']) translated, ' grid' translated						action: #gridVisibleOnOff.				aMenu add: 'set grid spacing...' translated action: #setGridSpec]		ifFalse: [aMenu add: 'turn gridding on' translated action: #griddingOnOff].	aMenu addLine.	#(	(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')		(autoExpansionString	toggleAutomaticPhraseExpansion			'whether tile phrases, dropped on me, should automatically sprout Scriptors around them')		(originAtCenterString	toggleOriginAtCenter			'whether the cartesian origin of the playfield should be at its lower-left corner or at the center of the playfield')		(showThumbnailString	toggleAlwaysShowThumbnail			'whether large objects should be represented by thumbnail miniatures of themselves')		(fenceEnabledString	toggleFenceEnabled			'whether moving objects should stop at the edge of their container')		(batchPenTrailsString	toggleBatchPenTrails 			'if true, detailed movement of pens between display updates is ignored.  Thus multiple line segments drawn within a script may not be seen individually.')	) do:			[:triplet |				(isWorld and: [#(toggleAutoLineLayout toggleIndicateCursor toggleIsPartsBin toggleAlwaysShowThumbnail) includes: triplet second]) ifFalse:					[aMenu addUpdating: triplet first action: triplet second.					aMenu balloonTextForLastItem: triplet third translated]]. 	aMenu addUpdating: #autoViewingString action: #toggleAutomaticViewing.	aMenu balloonTextForLastItem:  'governs whether, when an object is touched inside me, a viewer should automatically be launched for it.' translated.	((isWorld not or: [self backgroundSketch notNil]) or: [presenter isNil])		ifTrue:			[aMenu addLine].	isWorld ifFalse:		[aMenu add: 'set thumbnail height...' translated action: #setThumbnailHeight.		aMenu balloonTextForLastItem: 'if currently showing thumbnails governs the standard height for them' translated.		aMenu add: 'behave like a Holder' translated action: #becomeLikeAHolder.		aMenu balloonTextForLastItem: 'Set properties to make this object nicely set up to hold frames of a scripted animation.' translated].	self backgroundSketch ifNotNil:		[aMenu add: 'delete background painting' translated action: #deleteBackgroundPainting.		aMenu balloonTextForLastItem: 'delete the graphic that forms the background for this me.' translated].	presenter ifNil:		[aMenu add: 'make detachable' translated action: #makeDetachable.		aMenu balloonTextForLastItem: 'Allow this area to be separately governed by its own controls.' translated].	aMenu addLine.	aMenu add: 'use standard texture' translated action: #setStandardTexture.	aMenu balloonTextForLastItem: 'use a pale yellow-and-blue background texture here.' translated.	aMenu add: 'make graph paper...' translated action: #makeGraphPaper.	aMenu balloonTextForLastItem: 'Design your own graph paper and use it as the background texture here.' translated.	aMenu addTitle: 'playfield options...' translated.	^ aMenu! !!LayoutCell methodsFor: 'accessing' stamp: 'ar 10/28/2000 18:12'!nextCell: aCell	nextCell := aCell! !!Morph methodsFor: 'menus' stamp: 'sw 8/30/1998 09:42'!snapToEdgeIfAppropriate	| edgeSymbol oldBounds aWorld |	(edgeSymbol := self valueOfProperty: #edgeToAdhereTo) ifNotNil:		[oldBounds := bounds.		self adhereToEdge: edgeSymbol.		bounds ~= oldBounds ifTrue: [(aWorld := self world) ifNotNil: [aWorld viewBox ifNotNil:			[aWorld displayWorld]]]]! !!CircleMorph methodsFor: 'geometry eToy' stamp: 'nk 7/1/2002 13:48'!rotationCenter: aPointOrNil	"Set the new rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	| newRef box |	aPointOrNil isNil		ifTrue: [self removeProperty: #referencePosition.			self removeProperty: #originalCenter.			self removeProperty: #originalAngle. ]		ifFalse: [ box := self bounds.				newRef := box origin + (aPointOrNil * box extent).				self setRotationCenterFrom: newRef ].! !!PasteUpMorph methodsFor: 'viewing' stamp: 'sw 7/20/2002 12:52'!scriptSelectorToTriggerFor: aButtonMorph	"Answer a new selector which will bear the code for aButtonMorph in the receiver"	| buttonName selectorName |	buttonName := aButtonMorph externalName.	selectorName := self assuredPlayer acceptableScriptNameFrom: buttonName  forScriptCurrentlyNamed: nil.	buttonName ~= selectorName ifTrue:		[aButtonMorph setNameTo: selectorName].	^ selectorName! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/13/2000 17:57'!minCellSize: aNumber	minCellSize := aNumber.! !!ColorMappingCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 18:19'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	| oldCanvas |	oldCanvas := myCanvas.	myCanvas clipBy: aRectangle during:[:newCanvas|		myCanvas := newCanvas.		aBlock value: self].	myCanvas := oldCanvas! !!EllipseMorph methodsFor: 'geometry' stamp: 'nk 2/13/2001 18:16'!intersectionWithLineSegmentFromCenterTo: aPoint 	| dx aSquared bSquared m mSquared xSquared x y dy |	(self containsPoint: aPoint)		ifTrue: [ ^aPoint ].	dx := aPoint x - self center x.	dy := aPoint y - self center y.	dx = 0		ifTrue: [ ^self bounds pointNearestTo: aPoint ].	m := dy / dx.	mSquared := m squared.	aSquared := (self bounds width / 2) squared.	bSquared := (self bounds height / 2) squared.	xSquared := 1 / ((1 / aSquared) + (mSquared / bSquared)).	x := xSquared sqrt.	dx < 0 ifTrue: [ x := x negated ].	y := m * x.	^ self center + (x @ y) asIntegerPoint.! !!BorderStyle methodsFor: 'accessing' stamp: 'ar 8/25/2001 16:07'!dotOfSize: diameter forDirection: aDirection	| form |	form := Form extent: diameter@diameter depth: Display depth.	form getCanvas fillOval: form boundingBox color: self color.	^form! !!MorphicUnknownEvent methodsFor: 'private' stamp: 'ar 10/25/2000 19:58'!setType: evtType argument: arg hand: evtHand stamp: stamp	type := evtType.	argument := arg.	source := evtHand.	timeStamp := stamp.! !!TextMorphEditor methodsFor: 'events' stamp: 'th 9/19/2002 18:29'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(self hasCaret 		and: [oldInterval = self selectionInterval])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval := oldInterval].	self storeSelectionInParagraph! !!UpdatingStringMorph methodsFor: 'formats' stamp: ''!useDefaultFormat	"Use the object's own printString format."	format := #default.! !!MatrixTransformMorph methodsFor: 'accessing' stamp: 'ar 11/15/1998 21:51'!transform: aMatrixTransform	transform := aMatrixTransform.	self computeBounds.! !!RaisedBorder methodsFor: 'accessing' stamp: 'ar 11/26/2001 15:23'!colorsAtCorners	| c c14 c23 |	c := self color.	c14 := c lighter. c23 := c darker.	^Array with: c14 with: c23 with: c23 with: c14! !!SystemWindow class methodsFor: 'top window' stamp: 'RAA 7/7/2000 09:34'!clearTopWindow	TopWindow := nil.	"if leaving morphic to export from mvc, this ref could cause problems"! !!FileList2 class methodsFor: 'utility' stamp: 'RAA 1/8/2001 21:23'!addFullPanesTo: window from: aCollection	| frame |	aCollection do: [ :each |		frame := LayoutFrame 			fractions: each second 			offsets: each third.		window addMorph: each first fullFrame: frame.	]! !!MorphicEvent methodsFor: 'object fileIn' stamp: 'RAA 12/20/2000 16:05'!convertOctober2000: varDict using: smartRefStrm	"ar 10/25/2000: This method is used to convert OLD MorphicEvents into new ones."	"These are going away #('type' 'cursorPoint' 'buttons' 'keyValue' 'sourceHand').  Possibly store their info in another variable?"	| type cursorPoint buttons keyValue sourceHand |	type := varDict at: 'type'.	cursorPoint := varDict at: 'cursorPoint'.	buttons := varDict at: 'buttons'.	keyValue := varDict at: 'keyValue'.	sourceHand := varDict at: 'sourceHand'.	type == #mouseMove ifTrue:[		^MouseMoveEvent new			setType: #mouseMove 			startPoint: cursorPoint			endPoint: cursorPoint			trail: #() 			buttons: buttons 			hand: sourceHand 			stamp: nil].	(type == #mouseDown) | (type == #mouseUp) ifTrue:[			^MouseButtonEvent new				setType: type				position: cursorPoint				which: 0				buttons: buttons				hand: sourceHand				stamp: nil].	(type == #keystroke) | (type == #keyDown) | (type == #keyUp) ifTrue:[		^KeyboardEvent new			setType: type			buttons: buttons			position: cursorPoint			keyValue: keyValue			hand: sourceHand			stamp: nil].	"All others will be handled there"	^MorphicUnknownEvent new! !!MorphExtension methodsFor: 'accessing' stamp: 'dgd 2/16/2003 21:47'!sticky: aBoolean 	"change the receiver's sticky property"	sticky := aBoolean! !!FileList2 methodsFor: 'initialization' stamp: 'mir 11/15/2001 18:16'!publishingServers	| dir nameToShow dirList |	dirList := OrderedCollection new.	ServerDirectory serverNames do: [ :n | 		dir := ServerDirectory serverNamed: n.		(dir isProjectSwiki and: [dir acceptsUploads])			 ifTrue: [				nameToShow := n.				dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)					balloonText: dir realUrl)]].	^dirList! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:46'!listDirection: aSymbol	listDirection := aSymbol.! !!PasteUpMorph methodsFor: 'flaps' stamp: 'sw 2/15/1999 20:36'!removeAccommodationForFlap: aFlapTab	"Shift submorphs over, if appropriate"	| offset |	aFlapTab slidesOtherObjects ifTrue:		[offset := self offsetForAccommodating: aFlapTab referent extent onEdge: aFlapTab edgeToAdhereTo.		self shiftSubmorphsBy: offset negated]! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'RAA 2/19/2001 13:17'!mouseDown: evt	| localPt |	localPt := evt cursorPoint - self topLeft.	self deleteAllBalloons.	clickedTranslucency := TransparentBox containsPoint: localPt.	self inhibitDragging ifFalse: [		(DragBox containsPoint: localPt)			ifTrue: [^ evt hand grabMorph: self].	].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	self inhibitDragging ifFalse: [self comeToFront].	sourceHand := evt hand.	self startStepping.! !!FileList2 methodsFor: 'initialize-release' stamp: 'ar 10/10/2000 15:57'!initialize	showDirsInFileList := false.	fileSelectionBlock := [ :entry :myPattern |		entry isDirectory ifTrue: [			showDirsInFileList		] ifFalse: [			myPattern = '*' or: [myPattern match: entry name]		]	] fixTemps.	dirSelectionBlock := [ :dirName | true].! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'yo 2/23/2005 17:13'!initializeModal: beModal	"Initialize the receiver.  If beModal is true, it will be a modal color picker, else not"	isModal := beModal.	self removeAllMorphs.	isModal ifFalse:		[theSelectorDisplayMorph := AlignmentMorph newRow			color: Color white;			borderWidth: 1;			borderColor: Color red;			hResizing: #shrinkWrap;			vResizing: #shrinkWrap;			addMorph: (StringMorph contents: 'theSelector' translated).		self addMorph: theSelectorDisplayMorph.		self addMorph: (SimpleButtonMorph new borderWidth: 0;			label: 'x' font: nil; color: Color transparent;			actionSelector: #delete; target: self; useSquareCorners;			position: self topLeft - (0@3); extent: 10@12;			setCenteredBalloonText: 'dismiss color picker' translated)].	self addMorph: ((Morph newBounds: (DragBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'put me somewhere' translated).	self addMorph: ((Morph newBounds: (RevertBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'restore original color' translated).	self addMorph: ((Morph newBounds: (FeedbackBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'shows selected color' translated).	self addMorph: ((Morph newBounds: (TransparentBox translateBy: self topLeft))			color: Color transparent; setCenteredBalloonText: 'adjust translucency' translated).	self buildChartForm.		selectedColor ifNil: [selectedColor := Color white].	sourceHand := nil.	deleteOnMouseUp := false.	updateContinuously := true.! !!ScriptEditorMorph methodsFor: 'caching' stamp: 'sw 11/2/2004 17:00'!resetHandWithTile	"Set the handWithTile back to nil, in case it somehow got to be nonnil"	handWithTile := nil! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:09'!fillPattern: anObject	fillPattern := anObject.	self fillColor: anObject.! !!PolygonMorph methodsFor: 'geometry' stamp: 'sw 9/14/97 18:22'!flipVAroundY: centerY	"Flip me vertically around the center.  If centerY is nil, compute my center of gravity."	| cent |	cent := centerY 		ifNil: [bounds center y			"cent := 0.			vertices do: [:each | cent := cent + each y].			cent asFloat / vertices size"]		"average is the center"		ifNotNil: [centerY].	self setVertices: (vertices collect: [:vv |			vv x @ ((vv y - cent) * -1 + cent)]) reversed.! !!MorphicModel class methodsFor: 'compilation' stamp: 'sw 5/23/2001 13:51'!chooseNewName	"Choose a new name for the receiver, persisting until an acceptable name is provided or until the existing name is resubmitted"	| oldName newName |	oldName := self name.		[newName := (FillInTheBlank request: 'Please give this Model a name'					initialAnswer: oldName) asSymbol.		newName = oldName ifTrue: [^ self].		Smalltalk includesKey: newName]		whileTrue:		[self inform: 'Sorry, that name is already in use.'].	self rename: newName.! !!SystemWindow methodsFor: 'label' stamp: 'bvs 4/2/2004 16:55'!getRawLabel	| contentsFit |	contentsFit := label duplicate fitContents.	contentsFit extent: (label extent x min: contentsFit extent x) @ contentsFit extent y.		^ contentsFit! !!SelectionMorph methodsFor: 'accessing' stamp: 'nk 9/4/2004 17:33'!borderColor: aColor	| bordered |	bordered := selectedItems.	undoProperties ifNil: [undoProperties := bordered collect: [:m | m borderColor]].	bordered do: [:m | m borderColor: aColor]! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:30'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last cr |	cr := Character cr.	arrayIndex := lineIndex.	[first := (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex := arrayIndex - 1].	last := (lines at: arrayIndex) last.		^(text string copyFrom: first to: last) indentationIfBlank: aBlock.! !!PluggableButtonMorph methodsFor: 'arguments' stamp: 'sw 2/17/2002 01:03'!arguments: args	"If the receiver takes argument(s) that are static, they can be filled by calling this.  If its argument(s) are to be dynamically determined, then use an argumentProvider and argumentSelector instead"	arguments := args! !!MovieMorph methodsFor: 'menu' stamp: ''!extractFrame: evt	| f |	f := self currentFrame.	f ifNil: [^ self].	frameList := frameList copyWithout: f.	frameList isEmpty		ifTrue: [self position: f position]		ifFalse: [self setFrame: currentFrameIndex].	evt hand attachMorph: f.! !!KeyboardBuffer methodsFor: 'as yet unclassified' stamp: 'di 9/29/97 12:34'!flushKeyboard	eventUsed ifFalse: [^ eventUsed := true].! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'yo 3/16/2005 21:00'!setActWhen	| selections |	selections := #(buttonDown buttonUp whilePressed startDrag).	actWhen := (SelectionMenu 				labels: (selections collect: [:t | t translated]) selections: selections) 					startUpWithCaption: 'Choose one of the following conditions' translated! !!SimpleButtonMorph methodsFor: 'accessing' stamp: ''!arguments: aCollection	arguments := aCollection asArray copy.! !!PasteUpMorph methodsFor: 'flaps' stamp: 'dao 10/1/2004 12:56'!addGlobalFlaps 	"Must make global flaps adapt to world.  Do this even if not shown, so the old world will not be pointed at by the flaps."	| use thisWorld |	use := Flaps sharedFlapsAllowed.	Project current flapsSuppressed ifTrue: [use := false].	"Smalltalk isMorphic ifFalse: [use := false]."	thisWorld := use 		ifTrue: [self]		ifFalse: [PasteUpMorph new initForProject:  "fake to be flap owner"						WorldState new;					bounds: (0@0 extent: 4000@4000);					viewBox: (0@0 extent: 4000@4000)].		Flaps globalFlapTabsIfAny do: [:aFlapTab |		(Project current isFlapEnabled: aFlapTab) ifTrue:			[(aFlapTab world == thisWorld) ifFalse:				[thisWorld addMorphFront: aFlapTab.				aFlapTab adaptToWorld: thisWorld].	"always do"			use ifTrue:				[aFlapTab spanWorld.				aFlapTab adjustPositionAfterHidingFlap.				aFlapTab flapShowing ifTrue: [aFlapTab showFlap]]]]! !!Morph methodsFor: 'menus' stamp: 'dgd 8/30/2003 20:15'!maybeAddCollapseItemTo: aMenu	"If appropriate, add a collapse item to the given menu"	| anOwner |	(anOwner := self topRendererOrSelf owner) ifNotNil:			[anOwner isWorldMorph ifTrue:				[aMenu add: 'collapse' translated target: self action: #collapse]]! !!UpdatingThreePhaseButtonMorph methodsFor: 'stepping and presenter' stamp: 'tk 7/14/2000 15:27'!step	| newBoolean |	super step.	state == #pressed ifTrue: [^ self].	newBoolean := target perform: getSelector.	newBoolean == self isOn		ifFalse:			[self state: (newBoolean == true ifTrue: [#on] ifFalse: [#off])]! !!FormCanvas methodsFor: 'private' stamp: 'tpr 9/15/2004 10:28'!setPaintColor: aColor	"Install a new color used for filling."	| paintColor screen patternWord |	paintColor := self shadowColor ifNil:[aColor].	paintColor ifNil:[paintColor := Color transparent].	paintColor isColor ifFalse:[		(paintColor isKindOf: InfiniteForm) ifFalse:[^self error:'Cannot install color'].		^port fillPattern: paintColor; combinationRule: Form paint].	"Okay, so paintColor really *is* a color"	port sourceForm: nil.	(paintColor isTranslucent) ifFalse:[		port fillPattern: paintColor.		port combinationRule: Form paint.		self depth = 8 ifTrue:[			port fillColor: (form balancedPatternFor: paintColor)].		^self].	"paintColor is translucent color"	self depth > 8 ifTrue:[		"BitBlt setup for alpha mapped transfer"		port fillPattern: paintColor.		self depth = 16			ifTrue:[port alphaBits: paintColor privateAlpha; combinationRule: 31]			ifFalse:[port combinationRule: Form blend].		^self].	"Can't represent actual transparency -- use stipple pattern"	screen := Color translucentMaskFor: paintColor alpha depth: self depth.	patternWord := form pixelWordFor: paintColor.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint! !!BalloonCanvas methodsFor: 'drawing-polygons' stamp: 'ar 2/17/2000 00:25'!drawPolygon: vertices fillStyle: aFillStyle borderWidth: borderWidth borderColor: borderColor	"Draw a simple polygon defined by the list of vertices."	| fillC borderC |	fillC := self shadowColor ifNil:[aFillStyle].	borderC := self shadowColor ifNil:[borderColor].	self ensuredEngine		drawPolygon: (vertices copyWith: vertices first)		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!HandleMorph methodsFor: 'initialize' stamp: 'di 11/3/97 16:34'!forEachPointDo: aBlock	pointBlock := aBlock! !!CollapsedMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 16:41'!buildWindowMenu	"Answer the menu to be put up in response to the user's clicking on the window-menu control in the window title.  Specialized for CollapsedMorphs."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu add: 'change name...' translated action: #relabel.	aMenu addLine.	aMenu add: 'send to back' translated action: #sendToBack.	aMenu add: 'make next-to-topmost' translated action: #makeSecondTopmost.	aMenu addLine.	self mustNotClose		ifFalse:			[aMenu add: 'make unclosable' translated action: #makeUnclosable]		ifTrue:			[aMenu add: 'make closable' translated action: #makeClosable].	aMenu		add: (self isSticky ifTrue: ['make draggable'] ifFalse: ['make undraggable']) translated 		action: #toggleStickiness.	^aMenu! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:24'!stopTrackingJoystick	realJoystickIndex := nil.	self stopStepping.! !!Morph methodsFor: 'card in a stack' stamp: 'yo 2/17/2005 17:47'!insertAsStackBackground	"I am not yet in a stack.  Find a Stack that my reference point (center) overlaps, and insert me as a new background."	| aMorph |	self isStackBackground ifTrue: [^ Beeper beep].			"already in a stack.  Must clear flags when remove.""	self potentialEmbeddingTargets do: [:mm |   No, force user to choose a stack.  		(mm respondsTo: #insertAsBackground:resize:) ifTrue: [			^ mm insertAsBackground: self resize: false]]."	"None found, ask user"	self inform: 'Please click on a Stack' translated.	Sensor waitNoButton.	aMorph := self world chooseClickTarget.	aMorph ifNil: [^ self].	(aMorph ownerThatIsA: StackMorph) insertAsBackground: self resize: false.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: ''!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector := aSymbol.! !!FileList methodsFor: 'file list' stamp: 'sw 2/17/2002 02:32'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.	self updateButtonRow! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:46'!selector: aSymbol	selector := aSymbol.! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:52'!canAcceptBlock: aBlock	^canAcceptBlock := aBlock! !!ColorPatchCanvas methodsFor: 'drawing-support' stamp: 'ar 6/22/1999 16:34'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	| tempCanvas |	tempCanvas := (self copyClipRect: aRectangle).	aBlock value: tempCanvas.	foundMorph := tempCanvas foundMorph.! !!PluggableTabButtonMorph methodsFor: 'drawing' stamp: 'KLC 9/17/2004 11:24'!drawSubMorphOn: aCanvas	| morphBounds |	morphBounds := self bounds insetBy: (self cornerRadius + 3) @ (self topInactiveGap // 2 + 2).	morphBounds := morphBounds translateBy: 0@(self topInactiveGap // 2 + 1).	self active ifTrue: [		morphBounds := morphBounds translateBy: 0@((self topInactiveGap // 2 + 1) negated)].	self subMorph bounds height < (morphBounds height)		ifTrue: [			morphBounds := morphBounds				insetBy: 0@((morphBounds height - self subMorph bounds height) // 2)].	self subMorph bounds width < (morphBounds width)		ifTrue: [			morphBounds := morphBounds				insetBy: ((morphBounds width - self subMorph bounds width) // 2)@0].	self subMorph bounds: morphBounds.				aCanvas drawMorph: self subMorph! !!MovieMorph methodsFor: 'menu' stamp: ''!playOnce	self setFrame: 1.	playMode := #playOnce.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'yo 3/16/2005 20:54'!setActionSelector	| newSel |	newSel := FillInTheBlank		request:'Please type the selector to be sent tothe target when this button is pressed' translated		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!Morph methodsFor: 'accessing' stamp: 'sw 6/20/2001 15:45'!methodCommentAsBalloonHelp	"Given that I am a morph that is associated with an object and a method, answer a suitable method comment relating to that object & method if possible"	| inherentSelector actual |	(inherentSelector := self valueOfProperty: #inherentSelector)		ifNotNil:			[(actual := (self ownerThatIsA: PhraseTileMorph orA: SyntaxMorph) actualObject) ifNotNil:				[^ actual class precodeCommentOrInheritedCommentFor: inherentSelector]].	^ nil! !!TextLine methodsFor: 'scanning' stamp: ''!justifiedTabDeltaFor: spaceIndex 	"Compute the delta for a tab in a line of justified text, so tab falls 	somewhere plausible when line is justified."	| pad extraPad |	internalSpaces = 0 ifTrue: [^0].	pad := paddingWidth // internalSpaces.	extraPad := paddingWidth \\ internalSpaces.	spaceIndex <= extraPad		ifTrue: [^spaceIndex * (pad + 1)]		ifFalse: [^extraPad * (pad + 1) + (spaceIndex - extraPad * pad)]! !!SelectionMorph methodsFor: 'private' stamp: 'di 8/31/2000 22:12'!selectSubmorphsOf: aMorph	| newItems removals |	newItems := aMorph submorphs select:		[:m | (bounds containsRect: m fullBounds) 					and: [m~~self					and: [(m isKindOf: HaloMorph) not]]].	otherSelection ifNil: [^ selectedItems := newItems].	removals := newItems intersection: itemsAlreadySelected.	otherSelection setSelectedItems: (itemsAlreadySelected copyWithoutAll: removals).	selectedItems := (newItems copyWithoutAll: removals).! !!Morph methodsFor: 'accessing' stamp: 'tk 2/17/1999 11:45'!url	"If I have been assigned a url, return it.  For PasteUpMorphs mostly."	| sq |	(sq := self sqkPage) ifNotNil: [^ sq url].	^ self valueOfProperty: #url		! !!Morph methodsFor: 'submorphs-accessing' stamp: 'tk 10/20/2000 13:13'!submorphBefore	"Return the submorph after (behind) me, or nil"	| ii |	owner ifNil: [^ nil].	^ (ii := owner submorphIndexOf: self) = 1 		ifTrue: [nil]		ifFalse: [owner submorphs at: ii-1].	! !!BalloonCanvas methodsFor: 'balloon drawing' stamp: 'ar 2/17/2000 00:25'!drawBezierShape: vertices color: c borderWidth: borderWidth borderColor: borderColor	"Draw a boundary shape that is defined by a list of vertices.	Each three subsequent vertices define a quadratic bezier segment.	For lines, the control point should be set to either the start or the end	of the bezier curve."	| fillC borderC |	fillC := self shadowColor ifNil:[c].	borderC := self shadowColor ifNil:[borderColor].	self ensuredEngine		drawBezierShape: vertices		fill: fillC		borderWidth: borderWidth		borderColor: borderC		transform: transform.! !!FileList methodsFor: 'private' stamp: 'nk 2/20/2001 12:36'!listForPatterns: anArray	"Make the list be those file names which match the pattern."	| sizePad newList |	newList := Set new.	anArray do: [ :pat | newList addAll: (self entriesMatching: pat) ].	newList := (SortedCollection sortBlock: self sortBlock) addAll: newList; yourself.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray! !!SketchMorph methodsFor: 'accessing' stamp: 'sw 10/24/2000 05:55'!setNewFormFrom: formOrNil	"Set the receiver's form as indicated.   If nil is provided, then a default form will be used, possibly retrieved from the receiver's defaultValue property"	| defaultImage |	formOrNil ifNotNil: [^ self form: formOrNil].	defaultImage := self defaultValueOrNil ifNil: [ScriptingSystem squeakyMouseForm].	self form: defaultImage! !!PluggableTabButtonMorph class methodsFor: 'instance creation' stamp: 'KLC 1/22/2004 14:46'!on: anObject label: getTextSelector	| instance |	instance := super new.	instance model: anObject.	instance textSelector: getTextSelector.	^ instance ! !!UpdatingMenuMorph methodsFor: 'initialization' stamp: 'sw 4/23/2001 11:02'!updater: anObject updateSelector: aSelector	"Set the receiver's updater and updateSelector"	updater := anObject.	updateSelector := aSelector! !!TheWorldMainDockingBar methodsFor: 'menu actions' stamp: 'dgd 10/7/2004 14:51'!setWorldColor| world |world := self world.	world		changeColorTarget: world		selector: #color:		originalColor: world color		hand: world activeHand! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/10/1999 09:59'!minimumWidth	"Answer the minimum width that the receiver can have.  A nonzero value here keeps the receiver from degenerating into something that cannot ever be seen or touched again!!  Obeyed by fitContents."	^ minimumWidth ifNil: [minimumWidth := 8]! !!MenuItemMorph methodsFor: 'selecting' stamp: 'ar 9/18/2000 11:09'!isSelected: aBoolean	isSelected := aBoolean.	self changed.! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 3/23/2004 23:23'!hSetScrollDelta	"Set the ScrollBar deltas, value and interval, based on the current scroll pane size, offset and range."	| range delta |	scroller hasSubmorphs ifFalse:[scrollBar interval: 1.0. ^self].		delta := self scrollDeltaWidth.	range := self hLeftoverScrollRange.	range = 0 ifTrue: [ hScrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0; setValue: 0. ^self].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	hScrollBar 			scrollDelta: (delta / range) asFloat 			pageDelta: ((self innerBounds width - delta) / range) asFloat.	hScrollBar interval: ((self innerBounds width) / self hTotalScrollRange) asFloat.	hScrollBar setValue: ((scroller offset x / range) min: 1.0) asFloat.! !!NameStringInHalo methodsFor: 'as yet unclassified' stamp: 'di 11/25/1999 23:40'!placeContents	| namePosition |	(owner notNil and: [owner isInWorld]) ifTrue:		[namePosition := owner basicBox bottomCenter -			((self width // 2) @ (owner handleSize negated // 2 - 1)).		namePosition := namePosition min: self world viewBox bottomRight - self extent y + 2.		self bounds: (namePosition extent: self extent)]! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'tk 6/30/97 10:09'!pressedImage: aForm	pressedImage := aForm.	self invalidRect: self bounds.! !!HandMorph methodsFor: 'multilingual' stamp: 'yo 7/28/2004 21:35'!keyboardInterpreter	^keyboardInterpreter ifNil: [keyboardInterpreter := LanguageEnvironment currentPlatform class defaultInputInterpreter]! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'ar 9/26/2001 22:28'!mouseMove: evt	| editEvt |	super mouseMove: evt.	evt redButtonPressed ifFalse: [^ self].	editEvt := evt transformedBy: (self transformedFrom: editView) inverseTransformation.	(editEvt position y between: editView top and: editView bottom) ifFalse:[		"Start auto-scrolling"		self startStepping: #autoScrollView:			at: Time millisecondClockValue			arguments: (Array with: editEvt)			stepTime: 100. "fast enough"	] ifTrue:[		self stopSteppingSelector: #autoScrollView:.	].! !!ColorPickerMorph methodsFor: 'menu' stamp: 'jm 11/4/97 07:46'!toggleUpdateContinuously	updateContinuously := updateContinuously not.! !!TextMorph methodsFor: 'anchors' stamp: 'ar 8/10/2003 18:19'!anchorMorph: aMorph at: aPoint type: anchorType	| relPt index newText block |	aMorph owner == self ifTrue:[self removeMorph: aMorph].	aMorph textAnchorType: nil.	aMorph relativeTextAnchorPosition: nil.	self addMorphFront: aMorph.	aMorph textAnchorType: anchorType.	aMorph relativeTextAnchorPosition: nil.	anchorType == #document ifTrue:[^self].	relPt := self transformFromWorld globalPointToLocal: aPoint.	index := (self paragraph characterBlockAtPoint: relPt) stringIndex.	newText := Text string: (String value: 1) attribute: (TextAnchor new anchoredMorph: aMorph).	anchorType == #inline ifTrue:[		self paragraph replaceFrom: index to: index-1 with: newText displaying: false.	] ifFalse:[		index := index min: paragraph text size.		index := paragraph text string lastIndexOf: Character cr startingAt: index ifAbsent:[0].		block := paragraph characterBlockForIndex: index+1.		aMorph relativeTextAnchorPosition: (relPt x - bounds left) @ (relPt y - block top ).		self paragraph replaceFrom: index+1 to: index with: newText displaying: false.	].	self fit.! !!Morph methodsFor: 'geometry' stamp: 'nk 5/19/2003 20:39'!overlapsShadowForm: itsShadow bounds: itsBounds	"Answer true if itsShadow and my shadow overlap at all"	| andForm overlapExtent |	overlapExtent := (itsBounds intersect: self fullBounds) extent.	overlapExtent > (0 @ 0)		ifFalse: [^ false].	andForm := self shadowForm.	overlapExtent ~= self fullBounds extent		ifTrue: [andForm := andForm						contentsOfArea: (0 @ 0 extent: overlapExtent)].	andForm := andForm				copyBits: (self fullBounds translateBy: itsShadow offset negated)				from: itsShadow				at: 0 @ 0				clippingBox: (0 @ 0 extent: overlapExtent)				rule: Form and				fillColor: nil.	^ andForm bits		anySatisfy: [:w | w ~= 0]! !!TextMorphEditor methodsFor: 'menu messages' stamp: 'sps 2/5/2004 13:16'!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop rText rInterval isInTypeRun |	self deselect.	start := self startIndex.	stop := self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere := (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[		"===Support for multilevel undo start ==="		rText := (paragraph text copyFrom: start to: (stop - 1)).		rInterval := start to: (stop - 1).		isInTypeRun := self isInTypeRun.		"===Support for multilevel undo end ==="				paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval := otherInterval := self selectionInterval.		"===Support for multilevel undo start ==="		 (Preferences multipleTextUndo and: [isInTypeRun not])ifTrue:				[ self addEditCommand: 							(EditCommand									textMorph: morph									replacedText: rText									replacedTextInterval: rInterval									newText: aText 									newTextInterval: super selectionInterval)].		"===Support for multilevel undo end ==="].	self userHasEdited  " -- note text now dirty"! !!ColorPatchCanvas methodsFor: 'initialization' stamp: 'ar 6/22/1999 16:18'!reset	"Initialize the receiver to act just as a FormCanvas"	super reset.	foundMorph := false.	doStop := false.	stopMorph := nil.! !!TTSampleFontMorph methodsFor: 'connectors' stamp: 'nk 8/17/2003 11:54'!glyphIndexAt: position	| offset |	offset := (position adhereTo: (bounds insetBy: 1)) - bounds origin.	offset := (offset asFloatPoint / bounds extent) * 16.	offset := offset truncated.	^offset y * 16 + offset x! !!StringMorphAttributeScanner methodsFor: 'scanning' stamp: 'nk 2/26/2004 12:41'!addKern: kernDelta	"Set the current kern amount."	kern := kern + kernDelta! !!SystemWindow methodsFor: 'initialization' stamp: 'jrp 7/23/2005 12:07'!createBox	"create a button with default to be used in the label area"	"Transcript show: self paneColor asString;  	cr."	| box |	box := IconicButton new.	box color: Color transparent;		 target: self;		 useSquareCorners;		 borderWidth: 0.	^ box! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 11/26/2001 15:10'!drawPolyPatchFrom: startPoint to: stopPoint on: aCanvas usingEnds: endsArray	| cos sin tfm fill dir fsOrigin fsDirection points x y |	dir := (stopPoint - startPoint) normalized.	"Compute the rotational transform from (0@0) -> (1@0) to startPoint -> stopPoint"	cos := dir dotProduct: (1@0).	sin := dir crossProduct: (1@0).	"Now get the fill style appropriate for the given direction"	fill := self fillStyleForDirection: dir.false ifTrue:[	"Transform the fill appropriately"	fill := fill clone.	"Note: Code below is inlined from tfm transformPoint:/transformDirection:"	x := fill origin x. y := fill origin y.	fsOrigin := ((x * cos) + (y * sin) + startPoint x) @					((y * cos) - (x * sin) + startPoint y).	x := fill direction x. y := fill direction y.	fsDirection := ((x * cos) + (y * sin)) @ ((y * cos) - (x * sin)).	fill origin: fsOrigin; 		direction: fsDirection rounded; "NOTE: This is a bug in the balloon engine!!!!!!"		normal: nil.	aCanvas asBalloonCanvas drawPolygon: endsArray fillStyle: fill.] ifFalse:[	"Transform the points rather than the fills"	tfm := (MatrixTransform2x3 new) a11: cos; a12: sin; a21: sin negated; a22: cos.	"Install the start point offset"	tfm offset: startPoint.	points := endsArray collect:[:pt| tfm invertPoint: pt].	aCanvas asBalloonCanvas transformBy: tfm during:[:cc|		cc drawPolygon: points fillStyle: fill.	].].! !!Morph methodsFor: 'meta-actions' stamp: 'dgd 9/18/2004 17:23'!buildHandleMenu: aHand	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	(Preferences generalizedYellowButtonMenu			and: [Preferences noviceMode])		ifTrue: [^ self buildYellowButtonMenu: aHand].	menu := MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu addLine.	self addStandardHaloMenuItemsTo: menu hand: aHand.	menu defaultTarget: aHand.	self addAddHandMenuItemsForHalo: menu  hand: aHand.	menu defaultTarget: self.	self addCustomHaloMenuItems: menu hand: aHand.	menu defaultTarget: aHand.	^ menu! !!SystemWindow methodsFor: 'panes' stamp: 'RAA 1/10/2001 19:01'!setUpdatablePanesFrom: getSelectors	| aList aPane possibles |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList := OrderedCollection new.	possibles := OrderedCollection new.	self allMorphsDo: [ :pane | 		(pane isKindOf: PluggableListMorph) ifTrue: [			possibles add: pane.		].	].	getSelectors do: [:sel | 		aPane := possibles detect: [ :pane | pane getListSelector == sel] ifNone: [nil].		aPane			ifNotNil:				[aList add: aPane]			ifNil:				[Transcript cr; show: 'Warning: pane ', sel, ' not found.']].	updatablePanes := aList asArray! !!FileList methodsFor: 'initialization' stamp: 'tk 5/21/1998 12:28'!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName := aStream localName.	pattern := '*'.	listIndex := 1.  "pretend a file is selected"	aStream close.	brevityState := #needToGetBrief.	self changed: #contents.! !!ObjectExplorerWrapper methodsFor: 'converting' stamp: 'edt 5/26/2003 12:36'!asString	| explorerString string |	explorerString := 		[item asExplorerString]			on: Error 			do: ['<error: ', item class name, ' in asExplorerString: evaluate "' , itemName , ' asExplorerString" to debug>'].	string := (itemName ifNotNil: [itemName , ': '] ifNil: ['']) , explorerString.	(string includes: Character cr)		ifTrue: [^ string withSeparatorsCompacted].	^ string! !!HandMorph methodsFor: 'focus handling' stamp: 'nk 2/14/2004 18:44'!mouseFocus: aMorphOrNil	mouseFocus := aMorphOrNil! !!ProjectViewMorph methodsFor: 'geometry' stamp: 'RAA 10/27/2000 11:08'!extent: aPoint	"Set my image form to the given extent."	| newExtent scaleP scale |	((bounds extent = aPoint) and: [image depth = Display depth]) ifFalse: [		lastProjectThumbnail ifNil: [ lastProjectThumbnail := image ].		scaleP := aPoint / lastProjectThumbnail extent.		scale := scaleP "scaleP x asFloat max: scaleP y asFloat".		newExtent := (lastProjectThumbnail extent * scale) rounded.		self image: (Form extent: newExtent depth: Display depth).		self updateImageFrom: lastProjectThumbnail.	].	self updateNamePosition.! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/16/2000 22:07'!line: pt1 to: pt2 width: w color: c	| offset |	offset := origin - (w // 2) asPoint.	self setFillColor: c.	port width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!PluggableButtonMorph methodsFor: 'private' stamp: 'RAA 6/12/2000 09:04'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu := self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpEvent: evt in: self world]! !!OrientedFillStyle methodsFor: '*Morphic-Balloon' stamp: 'ar 6/18/1999 07:41'!changeOrientationIn: aMorph event: evt	"Interactively change the origin of the receiver"	| handle |	handle := HandleMorph new forEachPointDo:[:pt|		self direction: pt - self origin.		self normal: nil.		aMorph changed].	evt hand attachMorph: handle.	handle startStepping.! !!PolygonMorph methodsFor: 'accessing' stamp: 'nk 9/4/2004 17:23'!borderWidth: anInteger	borderColor ifNil: [borderColor := Color black].	borderWidth := anInteger max: 0.	self computeBounds! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'nk 2/15/2004 08:19'!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu, given that the receiver is a World"	| unlockables |	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addStackItemsTo: aMenu.	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size == 1 ifTrue:		[aMenu add: ('unlock "{1}"' translated format:{unlockables first externalName})action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!ProjectViewMorph methodsFor: 'layout' stamp: 'RAA 11/2/2000 10:39'!acceptDroppingMorph: morphToDrop event: evt	| myCopy smallR |	(self isTheRealProjectPresent) ifFalse: [		^morphToDrop rejectDropMorphEvent: evt.		"can't handle it right now"	].	(morphToDrop isKindOf: NewHandleMorph) ifTrue: [	"don't send these"		^morphToDrop rejectDropMorphEvent: evt.	].	self eToyRejectDropMorph: morphToDrop event: evt.		"we will send a copy"	myCopy := morphToDrop veryDeepCopy.	"gradient fills require doing this second"	smallR := (morphToDrop bounds scaleBy: image height / Display height) rounded.	smallR := smallR squishedWithin: image boundingBox.	image getCanvas		paintImage: (morphToDrop imageForm scaledToSize: smallR extent)		at: smallR topLeft.	myCopy openInWorld: project world! !!TransferMorphAnimation methodsFor: 'initialization' stamp: 'ar 3/17/2001 23:43'!on: aTransferMorph	self flag: #bob.		"there was a reference to World, but the class seems to be unused"	self color: Color transparent.	transferMorph := aTransferMorph.	transferMorph addDependent: self.	ActiveWorld addMorph: self	"or perhaps aTransferMorph world"! !!TheWorldMenu methodsFor: 'commands' stamp: 'dgd 9/21/2003 13:20'!readMorphFromAFile	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| morphOrList ff aName f m |	aName := Utilities chooseFileWithSuffixFromList:(#('.morph'), Utilities graphicsFileSuffixes) withCaption: 'Choose a fileto load' translated.	aName ifNil: [^ self].  "User made no choice"	aName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .morph, .gif,.bmp, .jpeg, .jpe, .jp, or .form)' translated].	(aName asLowercase endsWith: '.morph')		ifTrue:			[ff := FileStream readOnlyFileNamed: aName.			morphOrList := ff fileInObjectAndCode.		"code filed in is the Model class"			"the file may contain either a single morph or an array of morphs"			myWorld addMorphsAndModel: morphOrList]		ifFalse:			[f := Form fromFileNamed: aName.			f ifNil: [^ self error: 'unrecognized image file format' translated].			m := myWorld drawingClass new form: f.			myHand attachMorph: m]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 4/23/1998 18:50'!padding: aNumber	padding := aNumber! !!TextContainer methodsFor: 'private' stamp: 'di 11/4/97 14:06'!for: aTextMorph minWidth: wid	textMorph := aTextMorph.	minWidth := wid.	fillsOwner := true.	avoidsOcclusions := false.! !!TextMorph methodsFor: 'accessing' stamp: 'di 7/23/2001 15:30'!backgroundColor: newColor	backgroundColor := newColor.	self changed! !!SimpleButtonMorph methodsFor: 'accessing' stamp: ''!label	| s |	s := ''.	self allMorphsDo: [:m | (m isKindOf: StringMorph) ifTrue: [s := m contents]].	^ s! !!TransformationMorph methodsFor: 'initialization' stamp: 'di 2/21/98 14:35'!asFlexOf: aMorph	"Initialize me with position and bounds of aMorph,	and with an offset that provides centered rotation."	| pos |	pos := aMorph position.	self addMorph: aMorph.	aMorph position: (aMorph extent // 2) negated.	self position: pos.	transform := transform withOffset: aMorph position - pos! !!AbstractHierarchicalList methodsFor: 'as yet unclassified' stamp: 'RAA 4/7/1999 16:46'!noteNewSelection: x	currentSelection := x.	self changed: #getCurrentSelection.	currentSelection ifNil: [^self].	currentSelection sendSettingMessageTo: self.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'bf 1/5/2000 19:11'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld startPoint endPoint |	aForm := self imageForm offset: 0@0.	aWorld := self world.	startPoint := evt hand fullBounds origin.	self delete.	aWorld displayWorld.	endPoint := aPosition.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.	Preferences soundsEnabled ifTrue: [TrashCanMorph playDeleteSound].! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'tk 1/7/1999 16:53'!veryDeepFixupWith: deepCopier	"If fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.model := deepCopier references at: model ifAbsent: [model].! !!UserInputEvent methodsFor: 'private' stamp: 'ar 10/24/2000 16:33'!setPosition: aPoint	position := aPoint! !!HaloMorph methodsFor: 'accessing' stamp: 'sw 1/26/2000 15:36'!haloBox: aBox	haloBox := aBox! !!FileList2 methodsFor: 'private' stamp: 'ar 2/12/2001 16:20'!directoryNamesFor: item	"item may be file directory or server directory"	| entries |	entries := item directoryNames.	dirSelectionBlock ifNotNil:[entries := entries select: dirSelectionBlock].	^entries! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'tk 1/6/1999 17:55'!veryDeepFixupWith: deepCopier	"If target and arguments fields were weakly copied, fix them here.  If they were in the tree being copied, fix them up, otherwise point to the originals!!!!"super veryDeepFixupWith: deepCopier.target := deepCopier references at: target ifAbsent: [target].arguments := arguments collect: [:each |	deepCopier references at: each ifAbsent: [each]].! !!CircleMorph methodsFor: 'geometry' stamp: 'nk 7/1/2002 16:39'!extent: aPoint	| size oldRotationCenter |	oldRotationCenter := self rotationCenter.	size := aPoint x min: aPoint y.	super extent: size @ size.	self rotationCenter: oldRotationCenter.! !!ObjectExplorerWrapper methodsFor: 'as yet unclassified' stamp: 'nk 7/24/2003 09:14'!parent: anObject	parent := anObject! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'dgd 10/17/2003 22:50'!setPrecision	"Allow the user to specify a number of decimal places.  This UI is invoked from a menu.  Nowadays the precision can be set by simple type-in, making this menu approach mostly obsolete.  However, it's still useful for read-only readouts, where type-in is not allowed."	| aMenu |	aMenu := MenuMorph new.	aMenu addTitle: ('How many decimal places? (currently {1})' translated format: {self decimalPlaces}).	0 to: 5 do:		[:places |			aMenu add: places asString target: self selector: #setDecimalPlaces: argument: places].	aMenu popUpInWorld! !!DamageRecorder methodsFor: 'recording' stamp: 'di 11/17/2001 14:19'!recordInvalidRect: newRect	"Record the given rectangle in my damage list, a list of rectangular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	| mergeRect a |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	invalidRects do:		[:rect |		((a := (rect intersect: newRect) area) > 40			and: ["Avoid combining a vertical and horizontal rects.				  Can make a big diff and we only test when likely."				  a > (newRect area // 4) or: [a > (rect area // 4)]])			ifTrue:			["merge rectangle in place (see note below) if there is significant overlap"			rect setOrigin: (rect origin min: newRect origin) truncated				corner: (rect corner max: newRect corner) truncated.			^ self]].	invalidRects size >= 15 ifTrue:		["if there are too many separate areas, merge them all"		mergeRect := Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect].	"add the given rectangle to the damage list"	"Note: We make a deep copy of all rectangles added to the damage list,		since rectangles in this list may be extended in place."	invalidRects addLast:		(newRect topLeft truncated corner: newRect bottomRight truncated).! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 1/17/2000 20:04'!x: xCoord y: yCoord	| aWorld xyOffset delta aPlayfield |	(aWorld := self world) ifNil: [^ self position: xCoord @ yCoord].	xyOffset := self topLeft - self referencePosition.	delta := (aPlayfield := self referencePlayfield)		ifNil:			[xCoord @ (aWorld bottom - yCoord)]		ifNotNil:			[aPlayfield cartesianOrigin + (xCoord @ (yCoord negated))].	self position: (xyOffset + delta)! !!DropEvent methodsFor: 'initialize' stamp: 'ar 10/10/2000 01:18'!resetHandlerFields	"Reset anything that is used to cross-communicate between two eventual handlers during event dispatch"	wasHandled := false.! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 9/4/2001 19:51'!framePolygon2: vertices on: aCanvas	| dir1 dir2 dir3 nrm1 nrm2 nrm3 point1 point2 point3 	 cross1 cross2 pointA pointB pointC pointD w p1 p2 p3 p4 balloon ends |	balloon := aCanvas asBalloonCanvas.	balloon == aCanvas ifFalse:[balloon deferred: true].	ends := Array new: 4.	w := width * 0.5.	pointA := nil.	1 to: vertices size do:[:i|		p1 := vertices atWrap: i.		p2 := vertices atWrap: i+1.		p3 := vertices atWrap: i+2.		p4 := vertices atWrap: i+3.		dir1 := p2 - p1.		dir2 := p3 - p2.		dir3 := p4 - p3.		i = 1 ifTrue:[			"Compute the merge points of p1->p2 with p2->p3"			cross1 := dir2 crossProduct: dir1.			nrm1 := dir1 normalized. nrm1 := (nrm1 y * w) @ (0 - nrm1 x * w).			nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm1 := nrm1 negated. nrm2 := nrm2 negated].			point1 := (p1 x + nrm1 x) @ (p1 y + nrm1 y).			point2 := (p2 x + nrm2 x) @ (p2 y + nrm2 y).			pointA := self intersectFrom: point1 with: dir1 to: point2 with: dir2.			point1 := (p1 x - nrm1 x) @ (p1 y - nrm1 y).			point2 := (p2 x - nrm2 x) @ (p2 y - nrm2 y).			pointB := self intersectFrom: point1 with: dir1 to: point2 with: dir2.			pointB ifNotNil:[				(pointB x - p2 x) abs + (pointB y - p2 y) abs > (4*w) ifTrue:[pointA := pointB := nil].			].		].		"Compute the merge points of p2->p3 with p3->p4"		cross2 := dir3 crossProduct: dir2.		nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).		nrm3 := dir3 normalized. nrm3 := (nrm3 y * w) @ (0 - nrm3 x * w).		cross2 < 0 ifTrue:[nrm2 := nrm2 negated. nrm3 := nrm3 negated].		point2 := (p2 x + nrm2 x) @ (p2 y + nrm2 y).		point3 := (p3 x + nrm3 x) @ (p3 y + nrm3 y).		pointC := self intersectFrom: point2 with: dir2 to: point3 with: dir3.		point2 := (p2 x - nrm2 x) @ (p2 y - nrm2 y).		point3 := (p3 x - nrm3 x) @ (p3 y - nrm3 y).		pointD := self intersectFrom: point2 with: dir2 to: point3 with: dir3.		pointD ifNotNil:[			(pointD x - p3 x) abs + (pointD y - p3 y) abs > (4*w) ifTrue:[pointC := pointD := nil].		].		cross1 * cross2 < 0.0 ifTrue:[			point1 := pointA.			pointA := pointB.			pointB := point1.			cross1 := 0.0 - cross1].		ends at: 1 put: pointA; at: 2 put: pointB; at: 3 put: pointD; at: 4 put: pointC.		pointA ifNil:["degenerate and slow"			nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm2 := nrm2 negated].			point2 := (p2 x + nrm2 x) @ (p2 y + nrm2 y).			ends at: 1 put: point2].		pointB ifNil:["degenerate and slow"			nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm2 := nrm2 negated].			point2 := (p2 x - nrm2 x) @ (p2 y - nrm2 y).			ends at: 2 put: point2].		pointC ifNil:["degenerate and slow"			nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).			cross2 < 0 ifTrue:[nrm2 := nrm2 negated].			point2 := (p3 x + nrm2 x) @ (p3 y + nrm2 y).			ends at: 4 put: point2].		pointD ifNil:["degenerate and slow"			nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).			cross2 < 0 ifTrue:[nrm2 := nrm2 negated].			point2 := (p3 x - nrm2 x) @ (p3 y - nrm2 y).			ends at: 3 put: point2].		self drawPolyPatchFrom: p2 to: p3 on: balloon usingEnds: ends.		pointA := pointC.		pointB := pointD.		cross1 := cross2.	].	balloon == aCanvas ifFalse:[balloon flush].! !!Morph methodsFor: 'menus' stamp: 'dgd 8/30/2003 20:34'!addStackItemsTo: aMenu	"Add stack-related items to the menu"	| stackSubMenu |	stackSubMenu := MenuMorph new defaultTarget: self.	(owner notNil and: [owner isStackBackground]) ifTrue:		[self isShared			ifFalse:				[self couldHoldSeparateDataForEachInstance					ifTrue:						[stackSubMenu add: 'Background field, shared value' translated target: self action: #putOnBackground.						stackSubMenu add: 'Background field, individual values' translated target: self action: #becomeSharedBackgroundField]					ifFalse:						[stackSubMenu add: 'put onto Background' translated target: self action: #putOnBackground]]			ifTrue:				[stackSubMenu add: 'remove from Background' translated target: self action: #putOnForeground.				self couldHoldSeparateDataForEachInstance ifTrue:					[self holdsSeparateDataForEachInstance						ifFalse:							[stackSubMenu add: 'start holding separate data for each instance' translated target: self action: #makeHoldSeparateDataForEachInstance]						ifTrue:							[stackSubMenu add: 'stop holding separate data for each instance' translated target: self action: #stopHoldingSeparateDataForEachInstance].							stackSubMenu add: 'be default value on new card' translated target: self action: #setAsDefaultValueForNewCard.							(self hasProperty: #thumbnailImage)								ifTrue:									[stackSubMenu add: 'stop using for reference thumbnail' translated target: self action: #stopUsingForReferenceThumbnail]								ifFalse:									[stackSubMenu add: 'start using for reference thumbnail' translated target: self action: #startUsingForReferenceThumbnail]]].				stackSubMenu addLine].	(self isStackBackground) ifFalse:		[stackSubMenu add: 'be a card in an existing stack...' translated action: #insertAsStackBackground].	stackSubMenu add: 'make an instance for my data' translated action: #abstractAModel.	(self isStackBackground) ifFalse:		[stackSubMenu add: 'become a stack of cards' translated action: #wrapWithAStack].	aMenu add: 'stacks and cards...' translated subMenu: stackSubMenu! !!TextMorph methodsFor: 'initialization' stamp: 'di 12/29/97 14:42'!beAllFont: aFont	textStyle := TextStyle fontArray: (Array with: aFont).	self releaseCachedState; changed! !!JoystickMorph methodsFor: 'event handling' stamp: 'jm 11/18/97 14:26'!mouseUp: evt	lastAngle := self angle.	autoCenter ifTrue: [self moveHandleToCenter].! !!BalloonCanvas methodsFor: 'accessing' stamp: 'ar 12/30/1998 10:53'!aaLevel: newLevel	"Only allow changes to aaLevel if we're working on >= 8 bit forms"	form depth >= 8 ifFalse:[^self].	aaLevel = newLevel ifTrue:[^self].	self flush.	"In case there are pending primitives in the engine"	aaLevel := newLevel.	engine ifNotNil:[engine aaLevel: aaLevel].! !!SketchMorph methodsFor: 'menu' stamp: 'yo 2/12/2005 19:11'!addBorderToShape: evt	| str borderWidth borderedForm r |	str := FillInTheBlank		request: 'Please enter the desired border width' translated		initialAnswer: '0'.	borderWidth := Integer readFrom: (ReadStream on: str).	(borderWidth between: 1 and: 10) ifFalse: [^ self].	"Take care of growing appropriately.  Does this lose the reg point?"	borderedForm := originalForm shapeBorder: Color black width: borderWidth.	r := borderedForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (borderedForm copy: r).! !!TextMorph methodsFor: 'menu' stamp: 'di 12/3/97 10:25'!setCurveBaseline: evt	| handle origin |	origin := evt cursorPoint.	handle := HandleMorph new forEachPointDo:		[:newPoint | handle removeAllMorphs.		handle addMorph:			(PolygonMorph vertices: (Array with: origin with: newPoint)				color: Color black borderWidth: 1 borderColor: Color black).		container baseline: (newPoint - origin) y negated asInteger // 5.		self paragraph composeAll].	evt hand attachMorph: handle.	handle startStepping	! !!ScriptEditorMorph methodsFor: 'event handling' stamp: 'ar 12/14/2001 17:44'!mouseEnter: evt	| hand tile |	self flag: #bob.		"needed renderedMorph due to transformations"	hand := evt hand.	hand submorphs size = 1 ifFalse: [^self].	tile := hand firstSubmorph renderedMorph.	(self wantsDroppedMorph: tile event: evt) ifFalse: [^self].	handWithTile := hand.	self startSteppingSelector: #trackDropZones.! !!TextMorph methodsFor: 'private' stamp: 'tk 11/13/2001 01:57'!setDefaultContentsIfNil	"Set the default contents"	| toUse |	text ifNil:		[toUse := self valueOfProperty: #defaultContents.		toUse ifNil: [toUse :='abc' asText "allBold"].	"try it plain for a while"		text := toUse]! !!PasteUpMorph class methodsFor: 'scripting' stamp: 'sw 3/4/1999 15:05'!authoringPrototype	"Answer an instance of the receiver suitable for placing in a parts bin for authors"		| proto |	proto := self new markAsPartsDonor.	proto color: Color green muchLighter;  extent: 100 @ 80; borderColor: (Color r: 0.645 g: 0.935 b: 0.161).	proto extent: 300 @ 240.	proto beSticky.	^ proto! !!Morph methodsFor: 'e-toy support' stamp: 'sw 9/13/2002 17:44'!decimalPlacesForGetter: aGetter	"Answer the decimal places I prefer for showing a slot with the given getter, or nil if none"	| decimalPrefs |	decimalPrefs := self renderedMorph valueOfProperty: #decimalPlacePreferences ifAbsent: [^ nil].	^ decimalPrefs at: aGetter ifAbsent: [nil]! !!HaloMorph methodsFor: 'objects from disk' stamp: 'RAA 12/20/2000 17:46'!convertToCurrentVersion: varDict refStream: smartRefStrm		simpleMode ifNil: [simpleMode := false].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!SystemWindow methodsFor: 'top window' stamp: 'LC 9/28/1999 19:04'!extantSketchEditor	"If my world has an extant SketchEditorMorph associated with anything  	in this window, return that SketchEditor, else return nil"	| w sketchEditor pasteUp |	(w := self world) isNil ifTrue: [^ nil].	(sketchEditor := w sketchEditorOrNil) isNil ifTrue: [^ nil].	(pasteUp := sketchEditor enclosingPasteUpMorph) isNil ifTrue: [^ nil].	self findDeepSubmorphThat: [:m | m = pasteUp]		ifAbsent: [^ nil].	^ sketchEditor! !!MenuMorph methodsFor: 'control' stamp: 'sw 4/24/2001 11:11'!popUpEvent: evt in: aWorld	"Present this menu in response to the given event."	| aHand aPosition |	aHand := evt ifNotNil: [evt hand] ifNil: [ActiveHand].	aPosition := aHand position truncated.	^ self popUpAt: aPosition forHand: aHand in: aWorld! !!ProgressMorph class methodsFor: 'example' stamp: 'sma 3/3/2000 19:07'!example	"ProgressMorph example"	| progress |	progress := ProgressMorph label: 'Test progress'.	progress subLabel: 'this is the subheading'.	progress openInWorld.	[10 timesRepeat:		[(Delay forMilliseconds: 200) wait.		progress incrDone: 0.1].	progress delete] fork! !!DropEvent methodsFor: 'private' stamp: 'ar 9/13/2000 19:23'!setPosition: pos contents: aMorph hand: aHand	position := pos.	contents := aMorph.	source := aHand.	wasHandled := false.! !!Morph methodsFor: 'meta-actions' stamp: 'sw 1/29/2001 02:50'!applyStatusToAllSiblings: evt	"Apply the statuses of all my scripts to the script status of all my siblings"	| aPlayer |	(aPlayer := self topRendererOrSelf player) belongsToUniClass ifFalse: [self error: 'not uniclass'].	aPlayer instantiatedUserScriptsDo: 		[:aScriptInstantiation | aScriptInstantiation assignStatusToAllSiblings]! !!JoystickMorph methodsFor: 'event handling' stamp: ''!mouseMove: evt	"Make handle track the cursor within my bounds."	| m r center |	m := handleMorph.	center := m center.	r := m owner innerBounds insetBy:		((center - m fullBounds origin) corner: (m fullBounds corner - center)).	m position: (evt cursorPoint adhereTo: r) - (m extent // 2).! !!WorldState methodsFor: 'hands' stamp: 'RAA 5/24/2000 12:56'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result hBnds |	result := OrderedCollection new.	hands do: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					hBnds := h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: [nil])						ifNotNil: [result add: h]]]].	^ result! !!HaloMorph methodsFor: 'events' stamp: 'ar 8/8/2001 15:50'!popUpMagicallyFor: aMorph hand: aHand	"Programatically pop up a halo for a given hand."	Preferences magicHalos ifTrue:[		self isMagicHalo: true.		self magicAlpha: 0.2].	self target: aMorph.	aHand halo: self.	aHand world addMorphFront: self.	Preferences haloTransitions ifTrue:[		self magicAlpha: 0.0.		self startSteppingSelector: #fadeInInitially.	].	positionOffset := aHand position - (aMorph point: aMorph position in: owner).	self startStepping.! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'fbs 1/7/2005 15:43'!preferredKeyboardPosition	| pos |	pos := super preferredKeyboardPosition.	^ pos + (self bounds: self bounds in: World) topLeft.! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 22:55'!reframePanesAdjoining: growingPane along: side to: aDisplayBox 	| delta newRect minDim theMin horiz |	growingPane ifNil: [^ self].  "As from click outside"	newRect := aDisplayBox.	horiz := #(left right) includes: side.	theMin := horiz ifTrue: [40] ifFalse: [20].	"First check that this won't make any pane smaller than theMin screen dots"	minDim := (((paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side])		collect: [:pane | pane bounds adjustTo: newRect along: side]) copyWith: aDisplayBox)			inject: 999 into:				[:was :rect | was min: (horiz ifTrue: [rect width] ifFalse: [rect height])].	"If so, amend newRect as required"	minDim > theMin ifFalse:		[delta := minDim - theMin.		newRect := newRect withSide: side setTo: 				((newRect perform: side) > (growingPane bounds perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	paneMorphs do:		[:pane | (pane bounds bordersOn: growingPane bounds along: side) ifTrue:			[pane bounds: (pane bounds adjustTo: newRect along: side)]].	"And adjust the growing pane itself"	growingPane bounds: newRect.	"Finally force a recomposition of the whole window"	self setPaneRectsFromBounds.	self extent: self extent! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 5/1/2005 00:29'!prepareToBeSaved	"Prepare for export via the ReferenceStream mechanism"	| exportDict soundKeyList players |	super prepareToBeSaved.	turtlePen := nil.	self isWorldMorph		ifTrue:			[self removeProperty: #scriptsToResume.			soundKeyList := Set new.			(players := self presenter allExtantPlayers)				do: [:aPlayer | aPlayer slotInfo						associationsDo: [:assoc | assoc value type == #Sound								ifTrue: [soundKeyList										add: (aPlayer instVarNamed: assoc key)]]].			players				do: [:p | p allScriptEditors						do: [:e | (e allMorphs								select: [:m | m isKindOf: SoundTile])								do: [:aTile | soundKeyList add: aTile literal]]].			(self allMorphs				select: [:m | m isKindOf: SoundTile])				do: [:aTile | soundKeyList add: aTile literal].			soundKeyList removeAllFoundIn: SampledSound universalSoundKeys.			soundKeyList				removeAllSuchThat: [:aKey | (SampledSound soundLibrary includesKey: aKey) not].			soundKeyList isEmpty				ifFalse: [exportDict := Dictionary new.					soundKeyList						do: [:aKey | exportDict								add: (SampledSound soundLibrary associationAt: aKey)].					self setProperty: #soundAdditions toValue: exportDict]]! !!MatrixTransformMorph methodsFor: 'flexing' stamp: 'mdr 12/19/2001 10:49'!rotateBy: delta	| pt m |	delta = 0.0 ifTrue:[^self].	self changed.	pt := self transformFromWorld globalPointToLocal: self referencePosition.	m := MatrixTransform2x3 withOffset: pt.	m := m composedWithLocal: (MatrixTransform2x3 withAngle: delta).	m := m composedWithLocal: (MatrixTransform2x3 withOffset: pt negated).	self transform: (transform composedWithLocal: m).	self changed.! !!ImageMorph class methodsFor: 'scripting' stamp: 'sw 5/19/1998 18:30'!authoringPrototype	| aMorph aForm |	aMorph := super authoringPrototype.	aForm := ScriptingSystem formAtKey: 'Image'.	aForm ifNil: [aForm := aMorph image rotateBy: 90].	aMorph image: aForm.	^ aMorph! !!StringMorph methodsFor: 'editing' stamp: 'di 9/6/1999 22:44'!doneWithEdits	hasFocus := false! !!SystemWindow methodsFor: 'geometry' stamp: 'bvs 3/16/2004 11:12'!extent: aPoint 	"Set the receiver's extent to value provided. Respect my minimumExtent."	| newExtent |	newExtent := self isCollapsed		ifTrue: [aPoint]		ifFalse: [aPoint max: self minimumExtent].	newExtent = self extent ifTrue: [^ self].	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	isCollapsed		ifTrue: [collapsedFrame := self bounds]		ifFalse: [fullFrame := self bounds]! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/12/2000 14:52'!initialize	prompt := 'Select File'.	directory := FileDirectory default.	newFiles := OrderedCollection new.	fileFilterBlock := PluggableFileList allFilesAndFoldersFileFilter.	canAcceptBlock := PluggableFileList fileNameSelectedAcceptBlock.	resultBlock := PluggableFileList pathNameResultBlock.	validateBlock := PluggableFileList checkExistingFileValidateBlock.! !!Morph class methodsFor: 'fileIn/Out' stamp: 'yo 8/7/2003 11:02'!fromFileName: fullName	"Reconstitute a Morph from the file, presumed to be represent a Morph saved	via the SmartRefStream mechanism, and open it in an appropriate Morphic world" 	| aFileStream morphOrList |	aFileStream := (MultiByteBinaryOrTextStream with: ((FileStream readOnlyFileNamed: fullName) binary contentsOfEntireFile)) binary reset.	morphOrList := aFileStream fileInObjectAndCode.	(morphOrList isKindOf: SqueakPage) ifTrue: [morphOrList := morphOrList contentsMorph].	Smalltalk isMorphic		ifTrue: [ActiveWorld addMorphsAndModel: morphOrList]		ifFalse:			[morphOrList isMorph ifFalse: [self inform: 'Can only load a single morphinto an mvc project via this mechanism.'].			morphOrList openInWorld]! !!PluggableButtonMorph methodsFor: 'copying' stamp: 'sw 2/17/2002 05:29'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."model := model.		Weakly copied"label := label veryDeepCopyWith: deepCopier."getStateSelector := getStateSelector.		a Symbol""actionSelector := actionSelector.		a Symbol""getLabelSelector := getLabelSelector.		a Symbol""getMenuSelector := getMenuSelector.		a Symbol"shortcutCharacter := shortcutCharacter veryDeepCopyWith: deepCopier.askBeforeChanging := askBeforeChanging veryDeepCopyWith: deepCopier.triggerOnMouseDown := triggerOnMouseDown veryDeepCopyWith: deepCopier.offColor := offColor veryDeepCopyWith: deepCopier.onColor := onColor veryDeepCopyWith: deepCopier.feedbackColor := feedbackColor veryDeepCopyWith: deepCopier.showSelectionFeedback := showSelectionFeedback veryDeepCopyWith: deepCopier.allButtons := nil.		"a cache"arguments := arguments veryDeepCopyWith: deepCopier.argumentsProvider := argumentsProvider veryDeepCopyWith: deepCopier.argumentsSelector := argumentsSelector.  " a Symbol" ! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'sma 1/1/2000 17:56'!drawCharactersOn: aCanvas	| glyph origin r offset cy m |	0 to: 255 do:[:i|		glyph := font at: i.		origin := font bounds extent * ((i \\ 16) @ (i // 16)).		r := origin extent: font bounds extent.		offset := r center - glyph bounds center.		cy := glyph bounds center y.		m := MatrixTransform2x3 withOffset: 0@cy.		m := m composedWithLocal: (MatrixTransform2x3 withScale: 1@-1).		m := m composedWithLocal: (MatrixTransform2x3 withOffset: 0@cy negated).		m := m composedWithGlobal: (MatrixTransform2x3 withOffset: offset).		aCanvas asBalloonCanvas preserveStateDuring:[:balloonCanvas|			balloonCanvas transformBy: m.			balloonCanvas drawGeneralBezierShape: glyph contours					color: color					borderWidth: 0					borderColor: Color black.		].	].! !!Canvas methodsFor: 'Nebraska/embeddedWorlds' stamp: 'RAA 12/5/2000 18:28'!transform2By: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"an attempt to use #displayInterpolatedOn: instead of WarpBlt."	| patchRect subCanvas pureRect biggerPatch biggerClip interForm |	self flag: #bob.		"added to Canvas in hopes it will work for Nebraska"	(aDisplayTransform isPureTranslation) ifTrue: [		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to aClipRect"	pureRect := (aDisplayTransform globalBoundsToLocal: aClipRect).	patchRect := pureRect rounded.	patchRect area = 0 ifTrue: [^self]. 	"oh, well!!"	biggerPatch := patchRect expandBy: 1.	biggerClip := (aDisplayTransform localBoundsToGlobal: biggerPatch) rounded.	"Render the submorphs visible in the clipping rectangle, as patchForm"	subCanvas := FormCanvas extent: biggerPatch extent depth: self depth.	self isShadowDrawing ifTrue: [		subCanvas shadowColor: self shadowColor	].	"this biggerPatch/biggerClip is an attempt to improve positioning of the final image in high magnification conditions. Since we cannot grab fractional pixels from the source, take one extra and then take just the part we need from the expanded form"	subCanvas 		translateBy: biggerPatch topLeft negated rounded		during: [ :offsetCanvas | aBlock value: offsetCanvas].	interForm := Form extent: biggerClip extent depth: self depth.	subCanvas form 		displayInterpolatedIn: interForm boundingBox		on: interForm.	self 		drawImage: interForm 		at: aClipRect origin 		sourceRect: (aClipRect origin - biggerClip origin extent: aClipRect extent)! !!ProgressMorph methodsFor: 'initialization' stamp: 'sma 3/3/2000 19:13'!initSubLabelMorph	^ subLabelMorph := StringMorph contents: '' font: (self fontOfPointSize: 12)! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 1/27/2000 14:51'!toggleMouseOverHalos	wantsMouseOverHalos := self wantsMouseOverHalos not! !!SimpleButtonMorph methodsFor: 'copying' stamp: 'nk 1/23/2004 17:14'!veryDeepInner: deepCopier	"Copy all of my instance variables.  Some need to be not copied at all, but shared.  	Warning!!!!  Every instance variable defined in this class must be handled.  We must also implement veryDeepFixupWith:.  See DeepCopier class comment."super veryDeepInner: deepCopier."target := target.		Weakly copied""actionSelector := actionSelector.		a Symbol""arguments := arguments.		All weakly copied"actWhen := actWhen veryDeepCopyWith: deepCopier.oldColor := oldColor veryDeepCopyWith: deepCopier.mouseDownTime := nil.! !!Slider methodsFor: 'model access' stamp: ''!value: newValue	"Drive the slider position externally..."	value := newValue min: 1.0 max: 0.0.	self computeSlider! !!PluggableButtonMorph methodsFor: 'event handling' stamp: 'jm 5/20/1998 11:49'!mouseDown: evt	"Details: If this button is triggered on mouse down or the event is the menu gesture, handle it immediately. Otherwise, make a list of buttons (including the receiver) for mouseMove feedback. This allows a simple radio-button effect among the button submorphs of a given morph."	allButtons := nil.	evt yellowButtonPressed ifTrue: [^ self invokeMenu: evt].	triggerOnMouseDown		ifTrue: [self performAction]		ifFalse: [			allButtons := owner submorphs select: [:m | m class = self class].			self updateFeedbackForEvt: evt].! !!HaloMorph methodsFor: 'handles' stamp: 'sw 12/13/2001 14:07'!addCollapseHandle: handleSpec	"Add the collapse handle, with all of its event handlers set up, unless the target's owner is not the world or the hand."	| collapseHandle |	(target owner notNil "nil happens, amazingly"			and: [target owner isWorldOrHandMorph])		ifFalse: [^ self].	collapseHandle := self addHandle: handleSpec		on: #mouseDown send: #mouseDownInCollapseHandle:with: to: self.	collapseHandle on: #mouseUp send: #maybeCollapse:with: to: self.	collapseHandle on: #mouseMove send: #setDismissColor:with: to: self! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 8/3/1998 13:43'!laySubpartsOutInOneRow	| aPosition |	aPosition := 0 @ padding.	submorphs do:	[:aMorph |		aMorph position: (aPosition + (padding @ 0)).		aPosition := aMorph topRight]! !!SimpleButtonMorph methodsFor: 'event handling' stamp: 'wiz 5/18/2006 21:36'!mouseDown: evt	super mouseDown: evt.	evt yellowButtonPressed ifTrue: [ ^self ] .	mouseDownTime := Time millisecondClockValue.	oldColor := self fillStyle. 	actWhen == #buttonDown		ifTrue: [ self doButtonAction]		ifFalse: [ self updateVisualState: evt ].	self mouseStillDown: evt.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 3/11/2000 20:05'!target: anObject	target := anObject.	getSelector ifNotNil: [floatPrecision := anObject defaultFloatPrecisionFor: getSelector]! !!DamageRecorder methodsFor: 'recording' stamp: ''!doFullRepaint	"Record that a full redisplay is needed. No further damage rectangles will be recorded until after the next reset."	^ totalRepaint := true.! !!SystemWindow methodsFor: 'top window' stamp: 'nk 8/6/2003 10:53'!updatePanesFromSubmorphs	"Having removed some submorphs, make sure this is reflected in my paneMorphs."	paneMorphs := paneMorphs select: [ :pane | submorphs includes: pane ].! !!PolygonMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:10'!initialize"initialize the state of the receiver"	super initialize.""	vertices := Array				with: 5 @ 0				with: 20 @ 10				with: 0 @ 20.	closed := true.	smoothCurve := false.	arrows := #none.	self computeBounds! !!TextMorph methodsFor: 'menu' stamp: 'nk 9/1/2004 20:26'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'text properties...' translated action: #changeTextColor.	aCustomMenu addUpdating: #autoFitString target: self action: #autoFitOnOff.	aCustomMenu addUpdating: #wrapString target: self action: #wrapOnOff.	aCustomMenu add: 'text margins...' translated action: #changeMargins:.	aCustomMenu add: 'add predecessor' translated action: #addPredecessor:.	aCustomMenu add: 'add successor' translated action: #addSuccessor:.	(Preferences noviceMode			or: [Preferences simpleMenus])		ifFalse: [aCustomMenu add: 'code pane menu...' translated action: #yellowButtonActivity.			aCustomMenu add: 'code pane shift menu...' translated action: #shiftedYellowButtonActivity].	outer := self owner.	outer ifNotNil: [	outer isLineMorph ifTrue:		[container isNil			ifTrue: [aCustomMenu add: 'follow owner''s curve' translated action: #followCurve]			ifFalse: [aCustomMenu add: 'reverse direction' translated action: #reverseCurveDirection.					aCustomMenu add: 'set baseline' translated action: #setCurveBaseline:]]		ifFalse:		[self fillsOwner			ifFalse: [aCustomMenu add: 'fill owner''s shape' translated action: #fillingOnOff]			ifTrue: [aCustomMenu add: 'rectangular bounds' translated action: #fillingOnOff].		self avoidsOcclusions			ifFalse: [aCustomMenu add: 'avoid occlusions' translated action: #occlusionsOnOff]			ifTrue: [aCustomMenu add: 'ignore occlusions' translated action: #occlusionsOnOff]]].	aCustomMenu addLine.	aCustomMenu add: 'holder for characters' translated action: #holderForCharacters! !!FileList class methodsFor: 'instance creation' stamp: 'md 2/24/2006 16:07'!addButtonsAndFileListPanesTo: window at: upperFraction plus: offset forFileList: aFileList 	| fileListMorph row buttonHeight fileListTop divider dividerDelta buttons |	fileListMorph := PluggableListMorph				on: aFileList				list: #fileList				selected: #fileListIndex				changeSelected: #fileListIndex:				menu: #fileListMenu:.	fileListMorph enableDrag: true; enableDrop: false.	aFileList wantsOptionalButtons		ifTrue: [buttons := aFileList optionalButtonRow.			divider := BorderedSubpaneDividerMorph forBottomEdge.			dividerDelta := 0.			buttons color: Color transparent.					buttons						submorphsDo: [:m | m borderWidth: 2;								 borderColor: #raised].divider extent: 4 @ 4;						 color: Color transparent;						 borderColor: #raised;						 borderWidth: 2.					fileListMorph borderColor: Color transparent.					dividerDelta := 3.			row := AlignmentMorph newColumn hResizing: #spaceFill;						 vResizing: #spaceFill;						 layoutInset: 0;						 borderWidth: 2;						 layoutPolicy: ProportionalLayout new.			buttonHeight := self defaultButtonPaneHeight.			row				addMorph: buttons				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 0)						offsets: (0 @ 0 corner: 0 @ buttonHeight)).			row				addMorph: divider				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 0)						offsets: (0 @ buttonHeight corner: 0 @ buttonHeight + dividerDelta)).			row				addMorph: fileListMorph				fullFrame: (LayoutFrame						fractions: (0 @ 0 corner: 1 @ 1)						offsets: (0 @ buttonHeight + dividerDelta corner: 0 @ 0)).			window				addMorph: row				fullFrame: (LayoutFrame						fractions: upperFraction						offsets: (0 @ offset corner: 0 @ 0)).			row borderWidth: 2]		ifFalse: [fileListTop := 0.			window				addMorph: fileListMorph				frame: (0.3 @ fileListTop corner: 1 @ 0.3)].! !!ComplexBorder methodsFor: 'drawing' stamp: 'ar 9/4/2001 19:50'!framePolygon: vertices on: aCanvas	| dir1 dir2 dir3 nrm1 nrm2 nrm3 point1 point2 point3 	 cross1 cross2 pointA pointB pointC pointD w p1 p2 p3 p4 balloon ends pointE pointF |	balloon := aCanvas asBalloonCanvas.	balloon == aCanvas ifFalse:[balloon deferred: true].	ends := Array new: 6.	w := width * 0.5.	pointA := nil.	1 to: vertices size do:[:i|		p1 := vertices atWrap: i.		p2 := vertices atWrap: i+1.		p3 := vertices atWrap: i+2.		p4 := vertices atWrap: i+3.		dir1 := p2 - p1.		dir2 := p3 - p2.		dir3 := p4 - p3.		(i = 1 | true) ifTrue:[			"Compute the merge points of p1->p2 with p2->p3"			cross1 := dir2 crossProduct: dir1.			nrm1 := dir1 normalized. nrm1 := (nrm1 y * w) @ (0 - nrm1 x * w).			nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).			cross1 < 0 ifTrue:[nrm1 := nrm1 negated. nrm2 := nrm2 negated].			point1 := (p1 x + nrm1 x) @ (p1 y + nrm1 y).			point2 := (p2 x + nrm2 x) @ (p2 y + nrm2 y).			pointA := self intersectFrom: point1 with: dir1 to: point2 with: dir2.			point1 := (p1 x - nrm1 x) @ (p1 y - nrm1 y).			point2 := (p2 x - nrm2 x) @ (p2 y - nrm2 y).			pointB := point1 + dir1 + point2 * 0.5.			pointB := p2 + ((pointB - p2) normalized * w).			pointC := point2.		].		"Compute the merge points of p2->p3 with p3->p4"		cross2 := dir3 crossProduct: dir2.		nrm2 := dir2 normalized. nrm2 := (nrm2 y * w) @ (0 - nrm2 x * w).		nrm3 := dir3 normalized. nrm3 := (nrm3 y * w) @ (0 - nrm3 x * w).		cross2 < 0 ifTrue:[nrm2 := nrm2 negated. nrm3 := nrm3 negated].		point2 := (p2 x + nrm2 x) @ (p2 y + nrm2 y).		point3 := (p3 x + nrm3 x) @ (p3 y + nrm3 y).		pointD := self intersectFrom: point2 with: dir2 to: point3 with: dir3.		point2 := (p2 x - nrm2 x) @ (p2 y - nrm2 y).		point3 := (p3 x - nrm3 x) @ (p3 y - nrm3 y).		pointF := point2 + dir2.		pointE := pointF + point3 * 0.5.		pointE := p3 + ((pointE - p3) normalized * w).		cross1 * cross2 < 0.0 ifTrue:[			ends				at: 1 put: pointA;				at: 2 put: pointB;				at: 3 put: pointC;				at: 4 put: pointD;				at: 5 put: pointE;				at: 6 put: pointF.		] ifFalse:[			ends 				at: 1 put: pointA; 				at: 2 put: pointB;				at: 3 put: pointC; 				at: 4 put: pointF; 				at: 5 put: pointE;				at: 6 put: pointD.		].		self drawPolyPatchFrom: p2 to: p3 on: balloon usingEnds: ends.		pointA := pointD.		pointB := pointE.		pointC := pointF.		cross1 := cross2.	].	balloon == aCanvas ifFalse:[balloon flush].! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 9/27/2000 11:48'!trackColorUnderMouse	"Track the mouse with the special eyedropper cursor, and accept whatever color is under the mouse as the currently-chosen color; reflect that choice in the feedback box, and return that color."	| pt |	selectedColor := originalColor.	self trackColorAt: (pt := Sensor cursorPoint).	isModal ifTrue:		[self activeHand position: pt.		self world displayWorldSafely; runStepMethods.		self modalBalloonHelpAtPoint: pt].	^ selectedColor	! !!BorderedMorph methodsFor: 'menu' stamp: 'ar 10/5/2000 18:50'!changeBorderColor: evt	| aHand |	aHand := evt ifNotNil: [evt hand] ifNil: [self primaryHand].	self changeColorTarget: self selector: #borderColor: originalColor: self borderColor hand: aHand! !!UpdatingStringMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:28'!step	| s |	super step.	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s := self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!PolygonMorph methodsFor: 'dashes' stamp: 'di 9/9/2000 09:20'!dashedBorder: dashSpec	"A dash spec is a 3- or 5-element array with		{ length of normal border color.		length of alternate border color.		alternate border color.		starting offset.		amount to add to offset at each step }	Starting offset is usually = 0, but changing it moves the dashes along the curve."	borderDashSpec := dashSpec.	self changed! !!Morph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:23'!imageFormWithout: stopMorph andStopThere: stopThere	"Like imageForm, except it does not display stopMorph,	and it will not display anything above it if stopThere is true.	Returns a pair of the imageForm and a boolean that is true		if it has hit stopMorph, and display should stop."	| canvas rect |	rect := self fullBounds.	canvas := ColorPatchCanvas extent: rect extent depth: Display depth.	canvas stopMorph: stopMorph.	canvas doStop: stopThere.	canvas translateBy: rect topLeft negated during:[:tempCanvas| tempCanvas fullDrawMorph: self].	^ Array with: (canvas form offset: rect topLeft)			with: canvas foundMorph! !!Morph methodsFor: 'printing' stamp: 'sw 10/27/2000 17:45'!reportableSize	"Answer a size worth reporting as the receiver's size in a list view"	| total |	total := super reportableSize.	submorphs do:		[:m | total := total + m reportableSize].	^ total! !!PluggableButtonMorph methodsFor: 'initialize-release' stamp: 'gk 9/22/2003 09:10'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self model: anObject.	getStateSelector := getStateSel.	actionSelector := actionSel.	getLabelSelector := labelSel.	getMenuSelector := menuSel.	self update: labelSel.! !!TransferMorph class methodsFor: 'instance creation' stamp: 'nk 6/16/2003 16:29'!withPassenger: anObject from: source 	| ddm |	ddm := self new.	ddm passenger: anObject.	ddm source: source.	Sensor shiftPressed ifTrue: [ddm shouldCopy: true].	^ ddm! !!MenuMorph methodsFor: 'construction' stamp: 'jrp 6/19/2005 20:54'!addStayUpIcons	| title closeBox pinBox titleBarArea titleString |	title := submorphs				detect: [:ea | ea hasProperty: #titleString]				ifNone: [self setProperty: #needsTitlebarWidgets toValue: true.					^ self].	closeBox := IconicButton new target: self;				 actionSelector: #delete;				 labelGraphic: self class closeBoxImage;				 color: Color transparent;				 extent: 14 @ 16;				 borderWidth: 0.	pinBox := IconicButton new target: self;				 actionSelector: #stayUp:;				 arguments: {true};				 labelGraphic: self class pushPinImage;				 color: Color transparent;				 extent: 14 @ 15;				 borderWidth: 0.	Preferences noviceMode		ifTrue: [closeBox setBalloonText: 'close this menu'.			pinBox setBalloonText: 'keep this menu up'].	titleBarArea :=  AlignmentMorph newRow vResizing: #shrinkWrap;			 layoutInset: 3;			 color: Preferences menuTitleColor;			 addMorphBack: closeBox;			 addMorphBack: title;			 addMorphBack: pinBox.		title color: Color transparent.	titleString := title 		findDeepSubmorphThat: [:each | each respondsTo: #font: ]		ifAbsent: [nil].	titleString font: Preferences windowTitleFont.	Preferences roundedMenuCorners		ifTrue: [titleBarArea useRoundedCorners].		self addMorphFront: titleBarArea.	titleBarArea setProperty: #titleString toValue: (title valueOfProperty: #titleString).	title removeProperty: #titleString.	self setProperty: #hasTitlebarWidgets toValue: true.	self removeProperty: #needsTitlebarWidgets.	self removeStayUpItems! !!FileList2 methodsFor: 'private' stamp: 'RAA 6/21/2000 12:06'!modalView: aSystemWindowOrSuch	modalView := aSystemWindowOrSuch! !!Morph methodsFor: 'drop shadows' stamp: 'dgd 8/30/2003 16:48'!addDropShadowMenuItems: aMenu hand: aHand	| menu |	menu := MenuMorph new defaultTarget: self.	menu		addUpdating: #hasDropShadowString		action: #toggleDropShadow.	menu addLine.	menu add: 'shadow color...' translated target: self selector: #changeShadowColor.	menu add: 'shadow offset...' translated target: self selector: #setShadowOffset:.	aMenu add: 'drop shadow' translated subMenu: menu.! !!Morph methodsFor: 'geometry eToy' stamp: 'sw 10/25/1999 23:33'!referencePositionInWorld: aPoint	| localPosition |	localPosition := owner		ifNil: [aPoint]		ifNotNil: [(owner transformFrom: self world) globalPointToLocal: aPoint].	self referencePosition: localPosition! !!HandMorph methodsFor: 'listeners' stamp: 'ar 10/24/2000 20:40'!addListener: anObject to: aListenerGroup	"Add anObject to the given listener group. Return the new group."	| listeners |	listeners := aListenerGroup.	(listeners notNil and:[listeners includes: anObject]) ifFalse:[		listeners			ifNil:[listeners := WeakArray with: anObject]			ifNotNil:[listeners := listeners copyWith: anObject]].	listeners := listeners copyWithout: nil. "obsolete entries"	^listeners! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 12/25/2002 16:16'!hScrollBarWidth"Return the width of the horizontal scrollbar"	| w |		w := bounds width - (2 * borderWidth).		(retractableScrollBar not and: [self vIsScrollbarNeeded])		ifTrue: [w := w - self scrollBarThickness ].			^w ! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 3/24/1999 14:11'!addCenteredAtBottom: aMorph offset: anOffset	"Add aMorph beneath all other morphs currently in the receiver, centered horizontally, with the vertical offset from the bottom of the previous morph given by anOffset"	| curBot |	curBot := 0.	submorphs do: [:m | curBot := curBot max: m bottom].	self addMorphBack: aMorph.	aMorph position: ((self center x - (aMorph width // 2)) @ (curBot + anOffset))! !!MixedCurveMorph methodsFor: 'initialization' stamp: 'wiz 2/12/2006 05:59'!initialize"initialize the state of the receiver"	super initialize.	self extent: 32@20 .	self rectOval.	self clamps . "This initializes slopeClamps."	slopeClamps at: 1 put: 0 .	slopeClamps at: 4 put: 0 .		closed := true.	smoothCurve := true.	arrows := #none.	self computeBounds! !!Morph methodsFor: 'printing' stamp: 'RAA 9/18/2000 10:22'!printSpecs	| printSpecs |	printSpecs := self valueOfProperty: #PrintSpecifications.	printSpecs ifNil: [		printSpecs := PrintSpecifications defaultSpecs.		self printSpecs: printSpecs.	].	^printSpecs! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 20:02'!vResizing	"Layout specific. This property describes how the receiver should be resized with respect to its owner and its children. Possible values are:		#rigid			-	do not resize the receiver		#spaceFill		-	resize to fill owner's available space		#shrinkWrap	- resize to fit children	"	| props |	props := self layoutProperties.	^props ifNil:[#rigid] ifNotNil:[props vResizing].! !!MenuMorph methodsFor: 'menu' stamp: 'nk 3/31/2002 18:36'!removeStayUpItems	| stayUpItems |	stayUpItems := self items select: [ :item | item isStayUpItem ].	stayUpItems do: [ :ea | ea delete ].! !!ScriptEditorMorph methodsFor: 'menu commands' stamp: 'yo 1/26/2005 14:56'!deleteThreadShowing	threadPolygon ifNotNil: [threadPolygon delete. threadPolygon := nil].! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/11/1998 16:58'!setMorph: anActorMorph	"Not really the way to do this any more"	playerScripted := anActorMorph player! !!PolygonMorph methodsFor: 'attachments' stamp: 'nk 4/23/2002 15:49'!nudgeForLabel: aRectangle	"Try to move the label off me. Prefer labels on the top and right."	| i flags nudge |	(self bounds intersects: aRectangle) ifFalse: [^ 0@0 ].	flags := 0.	nudge := 0@0.	i := 1.	aRectangle lineSegmentsDo: [ :rp1 :rp2 | | rectSeg int |		rectSeg := LineSegment from: rp1 to: rp2.		self straightLineSegmentsDo: [ :lp1 :lp2 | | polySeg  |			polySeg := LineSegment from: lp1 to: lp2.			int := polySeg intersectionWith: rectSeg.			int ifNotNil: [ flags := flags bitOr: i ].		].		i := i * 2.	].	"Now flags has bitflags for which sides"	nudge := flags caseOf: {"no intersection"		[ 0 ] -> [ 0@0 ]."2 adjacent sides only" 		[ 9 ] -> [ 1@1 ].		[ 3 ] -> [ -1@1 ].		[ 12 ] -> [ 1@-1 ].		[ 6 ] -> [ -1@-1 ]."2 opposite sides only" 		[ 10 ] -> [ 0@-1 ].		[ 5 ] -> [ 1@0 ]."only 1 side" 		[ 8 ] -> [ -1@0 ].		[ 1 ] -> [ 0@-1 ].		[ 2 ] -> [ 1@0 ].		[ 4 ] -> [ 0@1 ]."3 sides" 		[ 11 ] -> [ 0@1 ].		[ 13 ] -> [ 1@0 ].		[ 14 ] -> [ 0@-1 ].		[ 7 ] -> [ -1@0 ]. "all sides" 		[ 15 ] -> [ 1@-1 "move up and to the right" ].	}.	^nudge! !!StandardScriptingSystem methodsFor: 'utilities' stamp: 'sw 11/26/1999 15:44'!stripGraphicsForExternalRelease	"ScriptingSystem stripGraphicsForExternalRelease"	|  replacement |	replacement := FormDictionary at: #Gets.	#('BadgeMiniPic' 'BadgePic' 'Broom' 'CedarPic' 'CollagePic' 'CoverMain' 'CoverSpiral' 'CoverTexture' 'Fred' 'ImagiPic' 'KayaPic' 'StudioPic')		do:			[:aKey | FormDictionary at: aKey asSymbol put: replacement]! !!HandMorph class methodsFor: 'initialization' stamp: 'yo 8/13/2003 15:49'!clearCompositionWindowManager	CompositionWindowManager := nil.! !!NewParagraph methodsFor: 'composition' stamp: 'yo 12/18/2002 15:00'!testNewComposeAll3	| newResult |	newResult := TextComposer new		multiComposeLinesFrom: firstCharacterIndex 		to: text size 		delta: 0		into: OrderedCollection new 		priorLines: Array new 		atY: container top		textStyle: textStyle 		text: text 		container: (0@0 extent: 31@60)		wantsColumnBreaks: false.	^{newResult. {lines. maxRightX}}! !!HandMorph methodsFor: 'accessing' stamp: 'ar 9/25/2000 14:24'!mouseOverHandler	^mouseOverHandler ifNil:[mouseOverHandler := MouseOverHandler new].! !!TextMorph methodsFor: 'accessing' stamp: 'di 9/30/97 09:51'!contentsWrapped: stringOrText	"Accept new text contents.  Lay it out, wrapping within my current width.	Then fit my height to the result."	wrapFlag := true.	self newContents: stringOrText! !!MorphicModel methodsFor: 'compilation' stamp: ''!slotSelectorFor: selectorBody	| selector |	model ifNil: [^ nil].	"Make up selector from slotname if any"	selector := (slotName ifNil: [selectorBody]					ifNotNil: [slotName , selectorBody]) asSymbol.	(model canUnderstand: selector) ifFalse:		[self halt: 'Compiling a null response for ' , model class name , '>>' , selector].	^ selector! !!ImageMorph methodsFor: 'accessing' stamp: 'sw 10/24/2000 05:53'!setNewImageFrom: formOrNil	"Change the receiver's image to be one derived from the supplied form.  If nil is supplied, clobber any existing image in the receiver, and in its place put a default graphic, either the one known to the receiver as its default value, else a squeaky mouse"	|  defaultImage |	formOrNil ifNotNil: [^ self image: formOrNil].	defaultImage := self defaultValueOrNil ifNil: [ScriptingSystem squeakyMouseForm].	self image: defaultImage! !!PasteUpMorph methodsFor: 'world state' stamp: 'sw 7/9/2005 12:58'!installVectorVocabulary	"Install the experimental Vector vocabulary as the default for the current project"	| standardViewers aVocabulary |	self setProperty: #currentVocabularySymbol toValue: #Vector.	standardViewers := (self submorphsSatisfying: [:m | m isKindOf: ViewerFlapTab]) collect:		[:m | m referent firstSubmorph].	aVocabulary := Vocabulary vocabularyNamed: #Vector.	standardViewers do: [:m | m switchToVocabulary: aVocabulary]! !!FileList class methodsFor: 'instance creation' stamp: 'md 2/24/2006 15:59'!addVolumesAndPatternPanesTo: window at: upperFraction plus: offset forFileList: aFileList 	| row patternHeight volumeListMorph patternMorph divider dividerDelta |	row := AlignmentMorph newColumn hResizing: #spaceFill;				 vResizing: #spaceFill;				 layoutInset: 0;				 borderWidth: 0;				 layoutPolicy: ProportionalLayout new.	patternHeight := 25.	volumeListMorph := (PluggableListMorph				on: aFileList				list: #volumeList				selected: #volumeListIndex				changeSelected: #volumeListIndex:				menu: #volumeMenu:)				autoDeselect: false.	volumeListMorph enableDrag: false; enableDrop: true.	patternMorph := PluggableTextMorph				on: aFileList				text: #pattern				accept: #pattern:.	patternMorph acceptOnCR: true.	patternMorph hideScrollBarsIndefinitely.	divider := BorderedSubpaneDividerMorph horizontal.	dividerDelta := 0.	divider extent: 4 @ 4;			color: Color transparent;			borderColor: #raised;			borderWidth: 2.		volumeListMorph borderColor: Color transparent.		patternMorph borderColor: Color transparent.		dividerDelta := 3.	row		addMorph: (volumeListMorph autoDeselect: false)		fullFrame: (LayoutFrame				fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ patternHeight negated - dividerDelta)).	row		addMorph: divider		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ patternHeight negated - dividerDelta corner: 0 @ patternHeight negated)).	row		addMorph: patternMorph		fullFrame: (LayoutFrame				fractions: (0 @ 1 corner: 1 @ 1)				offsets: (0 @ patternHeight negated corner: 0 @ 0)).	window		addMorph: row		fullFrame: (LayoutFrame				fractions: upperFraction				offsets: (0 @ offset corner: 0 @ 0)).	row borderWidth: 2! !!FileList methodsFor: 'file list menu' stamp: 'dgd 10/1/2004 13:55'!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| shiftMenu services maybeLine extraLines |	shifted ifTrue:		[shiftMenu := ParagraphEditor shiftedYellowButtonMenu.		^ aMenu addAllFrom: shiftMenu].	fileName ifNotNil:		[services := OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine := services size.		(FileStream sourceFileSuffixes includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines := OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'jm 2/2/98 00:33'!getItemsArgs: aCollection	getItemsArgs := aCollection asArray copy.! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 2/4/98 00:45'!playerScripted: aPlayer	playerScripted := aPlayer ! !!BalloonCanvas methodsFor: 'transforming' stamp: 'ar 12/30/1998 10:47'!preserveStateDuring: aBlock	| state result |	state := BalloonState new.	state transform: transform.	state colorTransform: colorTransform.	state aaLevel: self aaLevel.	result := aBlock value: self.	transform := state transform.	colorTransform := state colorTransform.	self aaLevel: state aaLevel.	^result! !!Morph methodsFor: 'layout' stamp: 'ar 10/31/2000 21:09'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"	| outer inner |	outer := self bounds.	inner := self layoutBounds.	bounds := aRectangle origin + (outer origin - inner origin) corner:				aRectangle corner + (outer corner - inner corner).! !!HandMorph methodsFor: 'meta-actions' stamp: 'ar 11/21/2000 17:42'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| grabbed |	self releaseMouseFocus. "Break focus"	grabbed := aMorph aboutToBeGrabbedBy: self.	grabbed ifNil:[^self].	grabbed := grabbed topRendererOrSelf.	^self grabMorph: grabbed from: grabbed owner! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/18/1998 09:12'!toggleAutomaticPhraseExpansion	| expand |	expand := self hasProperty: #automaticPhraseExpansion.	expand		ifTrue:			[self removeProperty: #automaticPhraseExpansion]		ifFalse:			[self setProperty: #automaticPhraseExpansion toValue: true]! !!Morph methodsFor: 'drawing' stamp: 'ar 9/1/2000 14:23'!imageForm: depth forRectangle: rect	| canvas |	canvas := Display defaultCanvasClass extent: rect extent depth: depth.	canvas translateBy: rect topLeft negated		during:[:tempCanvas| tempCanvas fullDrawMorph: self].	^ canvas form offset: rect topLeft! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFolderSelectorForProject: aProject"FileList2 modalFolderSelectorForProject: Project current"	| window fileModel w |	window := FileList2 morphicViewProjectSaverFor: aProject.	fileModel := window valueOfProperty: #FileList.	w := self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	w addMorphInLayer: window.	w startSteppingSubmorphsOf: window.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!TTSampleFontMorph methodsFor: 'accessing' stamp: 'bf 10/18/1999 16:19'!smoothing: aNumber	smoothing := aNumber.	self changed! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/14/2000 17:48'!wrapCentering: aSymbol	wrapCentering := aSymbol! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/19/1999 09:53'!updatablePanes	"Answer the list of panes, in order, which should be sent the #verifyContents message"	^ updatablePanes ifNil: [updatablePanes := #()]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/13/2000 19:54'!cellInset	"Layout specific. This property specifies an extra inset for each cell in the layout."	| props |	props := self layoutProperties.	^props ifNil:[0] ifNotNil:[props cellInset].! !!SimpleHierarchicalListMorph methodsFor: 'selection' stamp: 'RAA 8/1/1998 00:13'!selectedMorph: aMorph	self unhighlightSelection.	selectedMorph := aMorph.	self highlightSelection! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 1/26/2001 09:14'!showBorderAs: aColor	"image border: image boundingBox width: 1 fillColor: aColor.	currentBorderColor := aColor.	self changed"! !!TheWorldMenu methodsFor: 'construction' stamp: 'sw 2/14/2001 17:55'!projectMenu	"Build the project menu for the world."	| menu |	self flag: #bob0302.	menu := self menu: 'projects...'.	self fillIn: menu from: { 		{ 'save on server (also makes a local copy)' . { #myProject . #storeOnServer } }.		{ 'save to a different server' . { #myProject . #saveAs } }.		{ 'save project on local file only' . { #myWorld . #saveOnFile } }.		{ 'see if server version is more recent...' . { #myProject . #loadFromServer } }.		{ 'load project from file...' . { self . #loadProject } }.		nil.	}.	self fillIn: menu from:		{{'show project hierarchy'. {Project. #showProjectHierarchyInWindow}. 'Opens a window that shows names and relationships of all the projects in your system.'}.		nil}.	self mvcProjectsAllowed ifTrue: [		self fillIn: menu from: {			{ 'create new mvc project'. { self . #openMVCProject } }.		}	].	self fillIn: menu from: { 		{ 'create new morphic project' . { self . #openMorphicProject } }.		nil.		{ 'go to previous project' . { Project . #returnToPreviousProject } }.		{ 'go to next project' . { Project . #advanceToNextProject } }.		{ 'jump to project...' . { #myWorld . #jumpToProject } }.	}.	Preferences simpleMenus ifFalse: [		self fillIn: menu from: { 			nil.			{ 'save for future revert' . { #myProject . #saveForRevert } }.			{ 'revert to saved copy' . { #myProject . #revert } }.		}.	].	^ menu! !!MouseButtonEvent methodsFor: 'initialize' stamp: 'ar 10/24/2000 16:29'!type: eventType readFrom: aStream	super type: eventType readFrom: aStream.	aStream skip: 1.	whichButton := Integer readFrom: aStream.! !!PasteUpMorph methodsFor: 'Nebraska' stamp: 'RAA 11/6/2000 17:24'!remoteServer: aNebraskaServer	| h |	worldState remoteServer: aNebraskaServer.	h := self primaryHand.	aNebraskaServer ifNil:[		(h hasProperty: #representingTheServer) ifTrue: [			h removeProperty: #representingTheServer.			h userInitials: '' andPicture: nil.		]	] ifNotNil:[		(h hasProperty: #representingTheServer) ifFalse: [			h setProperty: #representingTheServer toValue: true.			h userInitials: Utilities authorName andPicture: nil.		]	].! !!Morph methodsFor: 'meta-actions' stamp: 'fc 4/27/2004 21:54'!invokeMetaMenu: evt	| menu |	menu := self buildMetaMenu: evt.	menu addTitle: self externalName.	self world ifNotNil: [		menu popUpEvent: evt in: self world	]! !!TextMorph methodsFor: 'menu' stamp: 'sw 2/18/2003 03:20'!holderForCharacters	"Hand the user a Holder that is populated with individual text morphs representing my characters"	| aHolder |	aHolder := ScriptingSystem prototypicalHolder.	aHolder setNameTo: 'H', self externalName.	text string do:		[:aChar |			aHolder addMorphBack: (TextMorph new contents: aChar asText)].	aHolder setProperty: #donorTextMorph toValue: self.	aHolder fullBounds.	aHolder openInHand! !!WorldState methodsFor: 'undo' stamp: 'ar 8/31/2000 22:57'!commandHistory	^commandHistory ifNil:[commandHistory := CommandHistory new]! !!TextMorph methodsFor: 'private' stamp: 'RAA 5/6/2001 15:12'!setSuccessor: newSuccessor	successor := newSuccessor.	paragraph ifNotNil: [paragraph wantsColumnBreaks: successor notNil].! !!HaloMorph methodsFor: 'initialization' stamp: 'sw 10/2/2001 21:20'!acceptNameEdit	"If the name is currently under edit, accept the changes"	| label |	(label := self findA: NameStringInHalo) ifNotNil:		[label hasFocus ifTrue:			[label lostFocusWithoutAccepting]]! !!TextMorph methodsFor: 'accessing' stamp: 'nk 7/12/2003 08:39'!fontName: fontName size: fontSize	| newTextStyle |	newTextStyle := ((TextStyle named: fontName asSymbol) ifNil: [ TextStyle default ]) copy.	textStyle := newTextStyle.	text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOfSize: fontSize)).	paragraph ifNotNil: [paragraph textStyle: newTextStyle]! !!Morph methodsFor: 'menus' stamp: 'nk 2/16/2004 13:29'!addExportMenuItems: aMenu hand: aHandMorph	"Add export items to the menu"	aMenu ifNotNil:		[ | aSubMenu |		aSubMenu := MenuMorph new defaultTarget: self.		aSubMenu add: 'BMP file' translated action: #exportAsBMP.		aSubMenu add: 'GIF file' translated action: #exportAsGIF.		aSubMenu add: 'JPEG file' translated action: #exportAsJPEG.		aSubMenu add: 'PNG file' translated action: #exportAsPNG.		aMenu add: 'export...' translated subMenu: aSubMenu]! !!Morph methodsFor: 'event handling' stamp: 'sw 11/16/1998 08:06'!restoreSuspendedEventHandler	| savedHandler |	(savedHandler := self valueOfProperty: #suspendedEventHandler) ifNotNil:		[self eventHandler: savedHandler].	submorphs do: [:m | m restoreSuspendedEventHandler]! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'sw 2/17/2002 05:29'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed. If the button's actionSelector takes any arguments, they are obtained dynamically by sending the argumentSelector to the argumentsProvider"	askBeforeChanging ifTrue: [model okToChange ifFalse: [^ self]].	actionSelector ifNotNil:		[actionSelector numArgs == 0			ifTrue:				[model perform: actionSelector]			ifFalse:				[argumentsProvider ifNotNil:					[arguments := argumentsProvider perform: argumentsSelector].					model perform: actionSelector withArguments: arguments]]! !!ScrollPane methodsFor: 'initialization' stamp: 'md 2/24/2006 21:26'!initializePreferences	"initialize the receiver's Preferences"	retractableScrollBar := false.	scrollBarOnLeft := (Preferences valueOfFlag: #scrollBarsOnRight) not.	! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 6/16/2000 13:08'!fileSelectionBlock: aBlock	fileSelectionBlock := aBlock! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'RAA 2/6/2001 14:00'!infiniteFillRectangle: aRectangle fillStyle: aFillStyle	| additionalOffset rInPortTerms clippedPort targetTopLeft clipOffset ex |	"this is a bit of a kludge to get the form to be aligned where I *think* it should be.	something better is needed, but not now"	additionalOffset := 0@0.	ex := aFillStyle form extent.	rInPortTerms := aRectangle translateBy: origin.	clippedPort := port clippedBy: rInPortTerms.	targetTopLeft := clippedPort clipRect topLeft truncateTo: ex.	clipOffset := rInPortTerms topLeft - targetTopLeft.	additionalOffset := (clipOffset \\ ex) - ex.	^aFillStyle		displayOnPort: clippedPort		offsetBy: additionalOffset! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'rbb 2/16/2005 16:59'!confirmExistingFiles: aResult	|choice|	(aResult directory fileExists: aResult name) ifFalse: [^aResult].		choice := (UIManager default chooseFrom: #('overwrite that file' 'choose another name' 'cancel')		title: aResult name, 'already exists.').	choice = 1 ifTrue: [		aResult directory 			deleteFileNamed: aResult name			ifAbsent: 				[^self startUpWithCaption: 'Can''t delete ', aResult name, 'Select another file'].		^aResult].	choice = 2 ifTrue: [^self startUpWithCaption: 'Select Another File'].	^nil ! !!NewParagraph methodsFor: 'composition' stamp: 'yo 12/20/2002 16:18'!recomposeFrom: start to: stop delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed."	| startLine newLines |	"Have to recompose line above in case a word-break was affected."	startLine := (self lineIndexForCharacter: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine := startLine - 1].  "Find leftmost of line pieces"	newLines := OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].	text string isOctetString ifTrue: [		^ self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top.	].	self multiComposeLinesFrom: (lines at: startLine) first to: stop delta: delta		into: newLines priorLines: lines		atY: (lines at: startLine) top.! !!Morph methodsFor: 'user interface' stamp: 'sw 10/2/97 23:08'!initialExtent	| ext |	(ext := self valueOfProperty: #initialExtent)		ifNotNil:			[^ ext].	^ super initialExtent! !!StringMorph class methodsFor: 'testing' stamp: 'di 5/6/1998 21:07'!test	"Return a morph with lots of strings for testing display speed."	| c |	c := AlignmentMorph newColumn.	SystemOrganization categories do:		[:cat | c addMorph: (StringMorph new contents: cat)].	^ c! !!FileList2 class methodsFor: 'morphic ui' stamp: 'BG 2/29/2004 23:26'!morphicViewImageViewer	| dir aFileList window midLine fixedSize |	dir := FileDirectory default.	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList specsForImageViewer.	aFileList fileSelectionBlock: [ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			#('bmp' 'gif' 'jpg' 'form' 'png') includes: 					 (FileDirectory extensionFor: entry name asLowercase)		]	] fixTemps.	window := (SystemWindow labelled: dir pathName) model: aFileList.	fixedSize := 25.	midLine := 0.4.	self addFullPanesTo: window from: {		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0.				0@0 corner: 0@fixedSize}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1.				0@fixedSize corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1.				0@fixedSize corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!TextMorph methodsFor: 'accessing' stamp: 'nk 8/30/2004 05:43'!fontName: fontName pointSize: fontSize	| newTextStyle |	newTextStyle := ((TextStyle named: fontName asSymbol) ifNil: [ TextStyle default ]) copy.	newTextStyle ifNil: [self error: 'font ', fontName, ' not found.'].	textStyle := newTextStyle.	text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOfPointSize: fontSize)).	paragraph ifNotNil: [paragraph textStyle: newTextStyle]! !!Morph methodsFor: 'accessing' stamp: 'ar 8/6/2001 09:03'!color: aColor	"Set the receiver's color.  Directly set the color if appropriate, else go by way of fillStyle"	(aColor isColor or: [aColor isKindOf: InfiniteForm]) ifFalse:[^ self fillStyle: aColor].	color = aColor ifFalse:		[self removeProperty: #fillStyle.		color := aColor.		self changed]! !!PluggableListMorph methodsFor: 'event handling' stamp: 'ar 9/14/2000 19:16'!keyStroke: event 	"Process keys 	specialKeys are things like up, down, etc. ALWAYS HANDLED 	modifierKeys are regular characters either 1) accompanied with ctrl, 	cmd or 2) any character if the list doesn't want to handle basic 	keys (handlesBasicKeys returns false) 	basicKeys are any characters"	| aChar aSpecialKey |	(self scrollByKeyboard: event) ifTrue: [^self].	aChar := event keyCharacter.	aSpecialKey := aChar asciiValue.	aSpecialKey < 32 ifTrue: [^ self specialKeyPressed: aSpecialKey].	(event anyModifierKeyPressed or: [self handlesBasicKeys not])		ifTrue: [^ self modifierKeyPressed: aChar].	^ self basicKeyPressed: aChar! !!PasteUpMorph methodsFor: 'pen' stamp: 'RAA 5/18/2001 10:47'!addImageToPenTrailsFor: aMorph	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| image |	self createOrResizeTrailsForm.	"origin := self topLeft."	image := aMorph imageForm offset: 0@0.	image		displayOn: turtleTrailsForm 		at: aMorph topLeft - self topLeft		rule: Form paint.	self invalidRect: (image boundingBox translateBy: aMorph topLeft).! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 16:39'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor := nil].! !!ScrollPane methodsFor: 'geometry' stamp: 'sps 5/3/2004 13:49'!extent: newExtent		| oldW oldH wasHShowing wasVShowing noVPlease noHPlease minH minW |		oldW := self width.	oldH := self height.	wasHShowing := self hIsScrollbarShowing.	wasVShowing := self vIsScrollbarShowing.	"Figure out the minimum width and height for this pane so that scrollbars will appear"	noVPlease := self valueOfProperty: #noVScrollBarPlease ifAbsent: [false]. 	noHPlease := self valueOfProperty: #noHScrollBarPlease ifAbsent: [false]. 	minH := self scrollBarThickness + 16.	minW := self scrollBarThickness + 20.	noVPlease ifTrue:[ 		noHPlease			ifTrue:[minH := 1. minW := 1 ]			ifFalse:[minH := self scrollBarThickness ].	] ifFalse:[		noHPlease			ifTrue:[minH := self scrollBarThickness + 5].	].	super extent: (newExtent max: (minW@minH)).	"Now reset widget sizes"	self resizeScrollBars; resizeScroller; hideOrShowScrollBars.		"Now resetScrollDeltas where appropriate, first the vScrollBar..."	((self height ~~ oldH) or: [ wasHShowing ~~ self hIsScrollbarShowing]) ifTrue:		[(retractableScrollBar or: [ self vIsScrollbarShowing ]) ifTrue:			[ self vSetScrollDelta ]].				"...then the hScrollBar"	((self width ~~ oldW) or: [wasVShowing ~~ self vIsScrollbarShowing]) ifTrue:		[(retractableScrollBar or: [ self hIsScrollbarShowing ]) ifTrue:			[ self hSetScrollDelta ]].! !!PasteUpMorph methodsFor: 'accessing' stamp: 'di 6/8/1999 14:06'!presenter	"Normally only the world will have a presenter, but the architecture supports individual localized presenters as well"	^ presenter ifNil:		[self isWorldMorph			ifTrue: [presenter := Presenter new associatedMorph: self]			ifFalse: [super presenter]]! !!ProportionalSplitterMorph methodsFor: 'as yet unclassified' stamp: 'jrp 8/6/2005 23:59'!drawOn: aCanvas 	| dotBounds size alphaCanvas dotSize |	super drawOn: aCanvas.	self class showSplitterHandles ifTrue: [	size := self splitsTopAndBottom				ifTrue: [self handleSize transposed]				ifFalse: [self handleSize].	dotSize := self splitsTopAndBottom				ifTrue: [6 @ self class splitterWidth]				ifFalse: [self class splitterWidth @ 6].	alphaCanvas := aCanvas asAlphaBlendingCanvas: 0.7.	dotBounds := Rectangle center: self bounds center extent: size.	alphaCanvas fillRectangle: dotBounds color: self handleColor.	dotBounds := Rectangle center: self bounds center extent: dotSize.	alphaCanvas fillRectangle: dotBounds color: self dotColor]! !!ColorPickerMorph methodsFor: 'private' stamp: 'yo 9/29/2004 10:57'!pickColorAt: aGlobalPoint 	| alpha selfRelativePoint pickedColor c |	clickedTranslucency ifNil: [clickedTranslucency := false].	selfRelativePoint := (self globalPointToLocal: aGlobalPoint) - self topLeft.	(FeedbackBox containsPoint: selfRelativePoint) ifTrue: [^ self].	(RevertBox containsPoint: selfRelativePoint)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: selfRelativePoint) ifTrue:		[clickedTranslucency ifFalse: [^ self].  "Can't wander into translucency control"		alpha := (selfRelativePoint x - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"		self 			updateColor: (selectedColor alpha: alpha)			feedbackColor: (selectedColor alpha: alpha).		^ self].	"pick up color, either inside or outside this world"	clickedTranslucency ifTrue: [^ self].  "Can't wander out of translucency control"	self locationIndicator visible: false. self refreshWorld.	pickedColor := Display colorAt: aGlobalPoint.	c := self getColorFromKedamaWorldIfPossible: aGlobalPoint.	c ifNotNil: [pickedColor := c].	self locationIndicator visible: true. self refreshWorld.	self 		updateColor: (			(selectedColor isColor and: [selectedColor isTranslucentColor])						ifTrue: [pickedColor alpha: selectedColor alpha]						ifFalse: [pickedColor]		)		feedbackColor: pickedColor! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 4/3/2006 14:00'!morphicViewGeneralLoaderInWorld: aWorld"FileList2 morphicViewGeneralLoaderInWorld: self currentWorld"	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b fileTypeInfo fileTypeButtons fileTypeRow actionRow |	fileTypeInfo := self endingSpecs.	window := AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	aFileList := self new directory: FileDirectory default.	aFileList 		fileSelectionBlock: self projectOnlySelectionBlock;		modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: ColorTheme current dialogBorderWidth;		borderColor: ColorTheme current dialogBorderColor;		useRoundedCorners.	fileTypeButtons := fileTypeInfo collect: [ :each |		(self blueButtonText: each first textColor: Color gray inWindow: window)			setProperty: #enabled toValue: true;			hResizing: #shrinkWrap;			useSquareCorners	].	buttons := {{'OK'. ColorTheme current okColor}. {'Cancel'. ColorTheme current cancelColor}} collect: [ :each |		self blueButtonText: each first textColor: textColor1 color: each second inWindow: window	].	treePane := aFileList morphicDirectoryTreePane 		extent: 250@300; 		retractable: false;		borderWidth: 0.	fileListPane := aFileList morphicFileListPane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window addARow: {window fancyText: 'Find...' translated font: Preferences standardEToysTitleFont color: textColor1}.	fileTypeRow := window addARowCentered: fileTypeButtons cellInset: 2.	actionRow := window addARowCentered: {		buttons first. 		(Morph new extent: 30@5) color: Color transparent. 		buttons second	} cellInset: 2.	window		addARow: {				(window inAColumn: {(pane2a := window inARow: {window inAColumn: {treePane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.				(window inAColumn: {(pane2b := window inARow: {window inAColumn: {fileListPane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.		}.	window fullBounds.	window fillWithRamp: ColorTheme current dialogRampOrColor oriented: 0.65.	pane2a fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35).	pane2b fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35)."	buttons do: [ :each |		each fillWithRamp: ColorTheme current dialogButtonsRampOrColor oriented: (0.75 @ 0).	]."	fileTypeButtons do: [ :each | 		each 			on: #mouseUp 			send: #value:value: 			to: [ :evt :morph | 				self update: actionRow in: window fileTypeRow: fileTypeRow morphUp: morph.			] fixTemps	].	buttons first on: #mouseUp send: #okHit to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	aFileList directoryChangeBlock: [ :newDir |		self update: actionRow in: window fileTypeRow: fileTypeRow morphUp: nil.		self enableTypeButtons: fileTypeButtons info: fileTypeInfo forDir: newDir.	] fixTemps.	aFileList directory: aFileList directory.	window adoptPaneColor: (Color r: 0.548 g: 0.677 b: 1.0).	window becomeModal.	^ window openInWorld: aWorld.! !!TransferMorph methodsFor: 'dropping/grabbing' stamp: ''!justDroppedInto: targetMorph event: anEvent 	"If only world wants this TransferMorph, treat it as unaccepted (see also >>delete)."	super justDroppedInto: targetMorph event: anEvent.	accepted := targetMorph ~= self world.	self animationForMoveSuccess: accepted.	accepted ifTrue: [self dropNotifyRecipient ifNotNil: [self dropNotifyRecipient dropAcceptedMorph: self from: targetMorph]].	self delete! !!TextMorph methodsFor: 'drawing' stamp: 'sw 4/25/2002 00:52'!drawOn: aCanvas	"Draw the receiver on a canvas"	| fauxBounds |	self setDefaultContentsIfNil.	super drawOn: aCanvas.  "Border and background if any"	false ifTrue: [self debugDrawLineRectsOn: aCanvas].  "show line rects for debugging"	(self startingIndex > text size)		ifTrue: [self drawNullTextOn: aCanvas].	"Hack here:  The canvas expects bounds to carry the location of the text, but we also need to communicate clipping."	fauxBounds := self bounds topLeft corner: self innerBounds bottomRight.	aCanvas paragraph: self paragraph bounds: fauxBounds color: color! !!RectangleMorph class methodsFor: 'parts bin' stamp: 'tk 11/14/2001 20:09'!diagonalPrototype	| rr |	rr := self authoringPrototype.	rr useGradientFill; borderWidth: 0.	rr fillStyle direction: rr extent.	^ rr! !!PasteUpMorph methodsFor: 'world menu' stamp: 'nk 1/6/2004 12:38'!extractScreenRegion: poly andPutSketchInHand: hand	"The user has specified a polygonal area of the Display.	Now capture the pixels from that region, and put in the hand as a Sketch."	| screenForm outline topLeft innerForm exterior |	outline := poly shadowForm.	topLeft := outline offset.	exterior := (outline offset: 0@0) anyShapeFill reverse.	screenForm := Form fromDisplay: (topLeft extent: outline extent).	screenForm eraseShape: exterior.	innerForm := screenForm trimBordersOfColor: Color transparent.	innerForm isAllWhite ifFalse:		[hand attachMorph: (self drawingClass withForm: innerForm)]! !!MenuItemMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 20:43'!initialize	"initialize the state of the receiver"	super initialize.	""		contents := ''.	hasFocus := false.	isEnabled := true.	subMenu := nil.	isSelected := false.	target := nil.	selector := nil.	arguments := nil.	font := Preferences standardMenuFont.	self hResizing: #spaceFill;		 vResizing: #shrinkWrap! !!SelectionMorph methodsFor: 'private' stamp: 'dgd 9/20/2004 14:01'!doneExtending	otherSelection ifNotNil:		[selectedItems := otherSelection selectedItems , selectedItems.		otherSelection delete.		self setOtherSelection: nil].	self changed.	self layoutChanged.	super privateBounds:		((Rectangle merging: (selectedItems collect: [:m | m fullBounds]))			expandBy: 8).	self changed.	self addHalo.! !!ScriptEditorMorph methodsFor: 'menu commands' stamp: 'yo 1/26/2005 14:56'!createThreadShowing	| vertices b |	self deleteThreadShowing.	vertices := OrderedCollection new.	self tileRows do: [:row |		row first isTurtleRow ifTrue: [			b := row first bounds.			vertices add: ((b topLeft + (4@0)) + ((0 * 0.1 * b width)@0)).			0 to: 9 do: [:i |				vertices add: ((b topLeft + (4@4))+ ((i * 0.1 * b width )@0)).				vertices add: ((b bottomLeft + (4@-4)) + ((i * 0.1 * b width)@0)).			].				vertices add: ((b bottomLeft + (4@0)) + ((9 * 0.1 * b width)@0)).		] ifFalse: [			b := row first bounds.			vertices add: ((b origin x + b corner x)//2)@(b origin y).			vertices add: ((b origin x + b corner x)//2)@(b origin y + 4).			vertices add: ((b origin x + b corner x)//2)@(b corner y - 4).			vertices add: ((b origin x + b corner x)//2)@(b corner y).		].	].	threadPolygon := PolygonMorph vertices: vertices color: Color black borderWidth: 2 borderColor: Color black.	threadPolygon makeOpen.	threadPolygon openInWorld.! !!TextMorph methodsFor: 'containment' stamp: 'sw 12/16/1998 09:09'!recognizerArena	"Answer the rectangular area, in world coordinates, that the character recognizer should regard as its tablet"	| outer |	^ (outer := self ownerThatIsA: PluggableTextMorph)		ifNotNil:			[outer boundsInWorld]		ifNil:			[self boundsInWorld]! !!MouseButtonEvent methodsFor: 'private' stamp: 'ar 10/5/2000 23:55'!setType: evtType position: evtPos which: button buttons: evtButtons hand: evtHand stamp: stamp	type := evtType.	position := evtPos.	buttons := evtButtons.	source := evtHand.	wasHandled := false.	whichButton := button.	timeStamp := stamp.! !!EventHandler methodsFor: 'initialization' stamp: 'nk 2/15/2004 08:16'!on: eventName send: selector to: recipient	eventName == #mouseDown ifTrue:		[mouseDownRecipient := recipient.  mouseDownSelector := selector. ^ self].	eventName == #mouseMove ifTrue:		[mouseMoveRecipient := recipient.  mouseMoveSelector := selector. ^ self].	eventName == #mouseStillDown ifTrue:		[mouseStillDownRecipient := recipient.  mouseStillDownSelector := selector. ^ self].	eventName == #mouseUp ifTrue:		[mouseUpRecipient := recipient.  mouseUpSelector := selector. ^ self].	eventName == #mouseEnter ifTrue:		[mouseEnterRecipient := recipient.  mouseEnterSelector := selector. ^ self].	eventName == #mouseLeave ifTrue:		[mouseLeaveRecipient := recipient.  mouseLeaveSelector := selector. ^ self].	eventName == #mouseEnterDragging ifTrue:		[mouseEnterDraggingRecipient := recipient.  mouseEnterDraggingSelector := selector. ^ self].	eventName == #mouseLeaveDragging ifTrue:		[mouseLeaveDraggingRecipient := recipient.  mouseLeaveDraggingSelector := selector. ^ self].	eventName == #click ifTrue:		[clickRecipient := recipient. clickSelector := selector. ^ self].	eventName == #doubleClick ifTrue:		[doubleClickRecipient := recipient. doubleClickSelector := selector. ^ self].	eventName == #doubleClickTimeout ifTrue:		[doubleClickTimeoutRecipient := recipient. doubleClickTimeoutSelector := selector. ^ self].	eventName == #startDrag ifTrue:		[startDragRecipient := recipient. startDragSelector := selector. ^ self].	eventName == #keyStroke ifTrue:		[keyStrokeRecipient := recipient.  keyStrokeSelector := selector. ^ self].	eventName == #gesture ifTrue:		[ ^self onGestureSend: selector to: recipient ].	self error: 'Event name, ' , eventName , ' is not recognizable.'! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 3/10/2005 01:53'!acceptValueFromTarget: v	"Accept a value from the target"	lastValue := v.	self format == #string ifTrue: [^ v asString].	self format == #symbol ifTrue: [^ v asString translated].	(format == #default and: [v isNumber]) ifTrue:		[^ self stringForNumericValue: v].	^ v printString translated! !!UpdatingStringMorph methodsFor: 'formats' stamp: 'yo 1/12/2005 14:28'!useSymbolFormat	format := #symbol.! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!name: aString	^name := aString! !!StandardScriptingSystem class methodsFor: 'utilities' stamp: 'nk 9/1/2004 10:53'!applyNewEToyLook	"Apply the new EToy look based on free fonts, approximating the classic look as closely as possible."	"StandardScriptingSystem applyNewEToyLook""	| aTextStyle aFont | 	aTextStyle := TextStyle named: #BitstreamVeraSansMono.	aFont := aTextStyle fontOfSize: 12.	aFont := aFont emphasis: 1.	Preferences setEToysFontTo: aFont.	Preferences setButtonFontTo: aFont.	aTextStyle := TextStyle named: #Accushi.	aFont := aTextStyle fontOfSize: 12.	Preferences setFlapsFontTo: aFont.	(aTextStyle := TextStyle named: #Accuny)		ifNotNil:			[Preferences setSystemFontTo: (aTextStyle fontOfSize: 12)]"	Preferences setDefaultFonts: #(		(setEToysFontTo:			BitstreamVeraSansBold	10)		(setButtonFontTo:		BitstreamVeraSansMono	9)		(setFlapsFontTo:			Accushi				12)		(setSystemFontTo:		Accuny				10)		(setWindowTitleFontTo:	BitstreamVeraSansBold	12)	)! !!StandardFileMenu methodsFor: 'menu building' stamp: 'tpr 11/28/2003 15:12'!menuLinesArray: aDirectory"Answer a menu lines object corresponding to aDirectory"	| typeCount nameCnt dirDepth|	typeCount := canTypeFileName 		ifTrue: [1] 		ifFalse: [0].	nameCnt := aDirectory directoryNames size.	dirDepth := aDirectory pathParts size.	^Array streamContents: [:s |		canTypeFileName ifTrue: [s nextPut: 1].		s nextPut: dirDepth + typeCount + 1.		s nextPut: dirDepth + nameCnt + typeCount + 1]! !!Morph methodsFor: 'events-alarms' stamp: 'ar 9/14/2000 12:15'!removeAlarm: aSelector at: scheduledTime	"Remove the given alarm"	| scheduler |	scheduler := self alarmScheduler.	scheduler ifNotNil:[scheduler removeAlarm: aSelector at: scheduledTime for: self].! !!Morph methodsFor: 'fileIn/out' stamp: 'di 11/18/1999 08:35'!attachToResource	"Produce a morph from a file -- either a saved .morph file or a graphics file"	| pathName |	pathName := Utilities chooseFileWithSuffixFromList: (#('.morph'), Utilities graphicsFileSuffixes)			withCaption: 'Choose a fileto load'.	pathName ifNil: [^ self].  "User made no choice"	pathName == #none ifTrue: [^ self inform: 'Sorry, no suitable files found(names should end with .morph, .gif,.bmp, .jpeg, .jpe, .jp, or .form)'].	self setProperty: #resourceFilePath toValue: pathName! !!PasteUpMorph methodsFor: 'world menu' stamp: 'sw 3/13/2003 13:52'!initializeDesktopCommandKeySelectors	"Provide the starting settings for desktop command key selectors.  Answer the dictionary."	"ActiveWorld initializeDesktopCommandKeySelectors"	| dict messageSend |	dict := IdentityDictionary new.	self defaultDesktopCommandKeyTriplets do:		[:trip |			messageSend := MessageSend receiver: trip second selector: trip third.			dict at: trip first put: messageSend].	self setProperty: #commandKeySelectors toValue: dict.	^ dict! !!MorphExtension methodsFor: 'connectors-copying' stamp: 'nk 5/1/2004 17:45'!veryDeepInner: deepCopier 	"Copy all of my instance variables.	Some otherProperties need to be not copied at all, but shared. Their names are given by copyWeakly.	Some otherProperties should not be copied or shared. Their names are given by propertyNamesNotCopied.	This is special code for the dictionary. See DeepCopier, and veryDeepFixupWith:."	| namesOfWeaklyCopiedProperties weaklyCopiedValues |	super veryDeepInner: deepCopier.	locked := locked veryDeepCopyWith: deepCopier.	visible := visible veryDeepCopyWith: deepCopier.	sticky := sticky veryDeepCopyWith: deepCopier.	balloonText := balloonText veryDeepCopyWith: deepCopier.	balloonTextSelector := balloonTextSelector veryDeepCopyWith: deepCopier.	externalName := externalName veryDeepCopyWith: deepCopier.	isPartsDonor := isPartsDonor veryDeepCopyWith: deepCopier.	actorState := actorState veryDeepCopyWith: deepCopier.	player := player veryDeepCopyWith: deepCopier.		"Do copy the player of this morph"	eventHandler := eventHandler veryDeepCopyWith: deepCopier. 	"has its own restrictions"	otherProperties ifNil: [ ^self ].	otherProperties := otherProperties copy.	self propertyNamesNotCopied do: [ :propName | otherProperties removeKey: propName ifAbsent: [] ].	namesOfWeaklyCopiedProperties := self copyWeakly.	weaklyCopiedValues := namesOfWeaklyCopiedProperties collect: [  :propName | otherProperties removeKey: propName ifAbsent: [] ].	"Now copy all the others."	otherProperties := otherProperties veryDeepCopyWith: deepCopier.	"And replace the weak ones."	namesOfWeaklyCopiedProperties with: weaklyCopiedValues do: [ :name :value | value ifNotNil: [ otherProperties at: name put: value ]].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'jrp 7/23/2005 00:03'!removeCornerGrips	| corners |	corners := self submorphsSatisfying: [:each | each isKindOf: CornerGripMorph].	corners do: [:each | each delete]! !!TextLine methodsFor: 'accessing' stamp: ''!paddingWidth: padWidthInteger 	"Set the amount of space to be added to the font to be padWidthInteger."	paddingWidth := padWidthInteger! !!NewParagraph methodsFor: 'private' stamp: 'di 10/26/97 15:57'!adjustRightX	| shrink |	shrink := container right - maxRightX.	lines do: [:line | line paddingWidth: (line paddingWidth - shrink)].	container := container withRight: maxRightX! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseUp: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp := evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseUp: evt]]]! !!FileList methodsFor: 'private' stamp: 'ka 8/26/2000 18:48'!readContentsShiftJIS	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: ShiftJISTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 10/3/2000 17:03'!deleteBalloon	"If I am showing a balloon, delete it."	| w |	w := self world ifNil:[^self].	w deleteBalloonTarget: self.! !!SelectionMorph methodsFor: 'private' stamp: 'di 8/31/2000 21:45'!setSelectedItems: items	selectedItems := items.	self changed! !!PreDebugWindow methodsFor: 'label' stamp: 'tk 1/3/2000 12:54'!setLabelWidgetAllowance	^ labelWidgetAllowance := (Smalltalk isMorphic | Preferences optionalButtons)		ifTrue:			[super setLabelWidgetAllowance]		ifFalse:			[180]! !!PluggableMultiColumnListMorphByItem methodsFor: 'initialization' stamp: 'ls 8/19/2001 14:55'!list: arrayOfStrings 	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.  	The instance variable 'list' is a paragraph constructed from  	this list.""NO LONGER TRUE.  list is a real list, and listItems is obsolete."self isThisEverCalled .	itemList := arrayOfStrings first.	^ super list: arrayOfStrings! !!PasteUpMorph methodsFor: 'pen' stamp: 'sw 4/17/2003 12:01'!drawPenTrailFor: aMorph from: oldPoint to: targetPoint	"Draw a pen trail for aMorph, using its pen state (the pen is assumed to be down)."	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| origin mPenSize offset turtleTrailsDelta newPoint aPlayer trailStyle aRadius dotSize |	turtleTrailsDelta := self valueOfProperty: #turtleTrailsDelta ifAbsent:[0@0].	newPoint := targetPoint - turtleTrailsDelta.	oldPoint = newPoint ifTrue: [^ self].	self createOrResizeTrailsForm.	origin := self topLeft.	mPenSize := aMorph getPenSize.	turtlePen color: aMorph getPenColor.	turtlePen sourceForm width ~= mPenSize		ifTrue: [turtlePen squareNib: mPenSize].	offset := (mPenSize // 2)@(mPenSize // 2).	(#(lines arrows) includes: (trailStyle := (aPlayer := aMorph player) getTrailStyle))		ifTrue:			[turtlePen drawFrom: (oldPoint - origin - offset) asIntegerPoint				to: (newPoint - origin - offset) asIntegerPoint].	((#(arrowheads arrows) includes: trailStyle) and: [oldPoint ~= newPoint]) ifTrue:		[turtlePen			arrowHeadFrom: (oldPoint - origin - offset) 			to: (newPoint - origin - offset)			forPlayer: aPlayer].	(#(dots) includes: trailStyle)		ifTrue:			[dotSize := aPlayer getDotSize.			turtlePen				putDotOfDiameter: dotSize at: (oldPoint - origin).			turtlePen				putDotOfDiameter: dotSize at: (targetPoint - origin).			aRadius := (dotSize // 2) + 1.			dotSize := dotSize + 1.  "re round-off-derived gribblies"			self invalidRect: ((oldPoint - origin - (aRadius @ aRadius)) extent: (dotSize @ dotSize)).			self invalidRect: ((targetPoint - origin - (aRadius @ aRadius)) extent: (dotSize @ dotSize))]		ifFalse:			[self invalidRect: ((oldPoint rect: newPoint) expandBy: mPenSize)]! !!SystemWindow methodsFor: 'menu' stamp: 'dao 10/1/2004 12:57'!fullScreenMaximumExtent	"Zoom Window to Full World size with possible DeskMargins	obey the maximum extent rules"		| left right possibleBounds |	left := right := 0.	self paneMorphs		do: [:pane | ((pane isKindOf: ScrollPane)					and: [pane retractableScrollBar])				ifTrue: [pane scrollBarOnLeft						ifTrue: [left := left max: pane scrollBarThickness]						ifFalse: [right := right max: pane scrollBarThickness]]].	possibleBounds := self worldBounds				insetBy: (left @ 0 corner: right @ 0).	self maximumExtent ifNotNil:		[possibleBounds := possibleBounds origin extent: ( self maximumExtent min: ( possibleBounds extent ))].	((Flaps sharedFlapsAllowed				and: [Project current flapsSuppressed not])			or: [Preferences fullScreenLeavesDeskMargins])		ifTrue: [possibleBounds := possibleBounds insetBy: 22].	self bounds: possibleBounds! !!Morph methodsFor: 'printing' stamp: 'RAA 2/25/2001 17:47'!morphReportFor: attributeList	| s |	s := WriteStream on: String new.	self		morphReportFor: attributeList 		on: s 		indent: 0.	StringHolder new contents: s contents; openLabel: 'morph report'! !!UserInputEvent methodsFor: 'transforming' stamp: 'ar 10/9/2000 00:38'!transformBy: aMorphicTransform	"Transform the receiver into a local coordinate system."	position :=  aMorphicTransform globalPointToLocal: position.! !!ComplexBorder methodsFor: 'initialize' stamp: 'ar 11/26/2001 14:43'!releaseCachedState	colors := nil.	lineStyles := nil.! !!Morph methodsFor: 'accessing' stamp: 'sw 3/6/1999 02:09'!highlightColor		| val |	^ (val := self valueOfProperty: #highlightColor)		ifNotNil:			[val ifNil: [self error: 'nil highlightColor']]		ifNil:			[owner ifNil: [self color] ifNotNil: [owner highlightColor]]! !!FileList methodsFor: 'initialization' stamp: 'sw 2/26/2002 00:37'!dynamicButtonServices	"Answer services for buttons that may come and go in the button pane, depending on selection"	^ fileName isEmptyOrNil		ifTrue:			[#()]		ifFalse:			[ | toReject |				toReject := self buttonSelectorsToSuppress.				(self itemsForFile: self fullName) reject:					[:svc | toReject includes: svc selector]]! !!SystemWindow methodsFor: 'events' stamp: 'bmk 3/19/2002 02:11'!mouseMove: evt	"Handle a mouse-move event"	| cp |	cp := evt cursorPoint.	self valueOfProperty: #clickPoint ifPresentDo: 		[:firstClick |		((self labelRect containsPoint: firstClick) and: [(cp dist: firstClick) > 3]) ifTrue:		["If this is a drag that started in the title bar, then pick me up"		^ self isSticky ifFalse:			[self fastFramingOn 				ifTrue: [self doFastFrameDrag: firstClick]				ifFalse: [evt hand grabMorph: self topRendererOrSelf]]]].	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseMove: evt]]]! !!SketchMorph methodsFor: 'menu' stamp: 'sw 12/12/2001 13:14'!restoreBaseGraphic	"Restore the receiver's base graphic"	| aGraphic |	((aGraphic := self baseGraphic) notNil and:				[aGraphic ~= originalForm])		ifTrue:			[self form: aGraphic]! !!UpdatingStringMorph methodsFor: 'target access' stamp: 'sw 3/3/2005 02:55'!setDecimalPlacesFromTypeIn: typeIn	"The user has typed in a number as the new value of the receiver.  Glean off decimal-places-preference from the type-in"	| decimalPointPosition tail places |	(typeIn includes: $e) ifTrue: [^ self].	decimalPointPosition := typeIn indexOf: $. ifAbsent: [nil].	places := 0.	decimalPointPosition		ifNotNil:			[tail := typeIn copyFrom: decimalPointPosition + 1 to: typeIn size.			[places < tail size and: [(tail at: (places + 1)) isDigit]]				whileTrue:					[places := places + 1]].			self decimalPlaces: places! !!PasteUpMorph methodsFor: 'world menu' stamp: 'tak 1/26/2005 22:08'!keystrokeInWorld: evt	"A keystroke was hit when no keyboard focus was set, so it is sent here to the world instead."	|  aChar isCmd ascii |	aChar := evt keyCharacter.	(ascii := aChar asciiValue) = 27 ifTrue: "escape key"		[^ self putUpWorldMenuFromEscapeKey].	(evt controlKeyPressed not		and: [(#(1 4 8 28 29 30 31 32) includes: ascii)  "home, end, backspace, arrow keys, space"			and: [self keyboardNavigationHandler notNil]])				ifTrue: [self keyboardNavigationHandler navigateFromKeystroke: aChar].	isCmd := evt commandKeyPressed and: [Preferences cmdKeysInText].	(evt commandKeyPressed and: [Preferences eToyFriendly])			ifTrue:				[(aChar == $W) ifTrue: [^ self putUpWorldMenu: evt]].	(isCmd and: [Preferences honorDesktopCmdKeys]) ifTrue:		[^ self dispatchCommandKeyInWorld: aChar event: evt].	"It was unhandled. Remember the keystroke."	self lastKeystroke: evt keyString.	self triggerEvent: #keyStroke! !!TableLayoutProperties methodsFor: 'accessing' stamp: 'ar 11/13/2000 17:58'!maxCellSize: aNumber	maxCellSize := aNumber.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'jm 5/4/1998 17:47'!feedbackColor: aColor	"Set the color of this button's selection feedback border."	feedbackColor := aColor.	self changed.! !!PasteUpMorph methodsFor: 'objects from disk' stamp: 'yo 7/2/2004 13:21'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream ok |	self flag: #bob0302.	self isWorldMorph ifTrue: [^self project saveAs].	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := FillInTheBlank request: 'File name? (".project" will be added to end)' translated 			initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^ Beeper beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.project'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName,'.project'].	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!Morph methodsFor: 'meta-actions' stamp: 'sw 4/12/2005 23:09'!makeMultipleSiblings: evt	"Make multiple siblings, first prompting the user for how many"	| result |	self topRendererOrSelf couldMakeSibling ifFalse: [^ Beeper beep].	result := FillInTheBlank request: 'how many siblings do you want?' translated initialAnswer: '2'.	result isEmptyOrNil ifTrue: [^ self].	result first isDigit ifFalse: [^ Beeper beep].	self topRendererOrSelf makeSiblings: result asInteger.! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'tk 6/30/97 10:49'!actionSelector: aSymbolOrString	(nil = aSymbolOrString or:	 ['nil' = aSymbolOrString or:	 [aSymbolOrString isEmpty]])		ifTrue: [^ actionSelector := nil].	actionSelector := aSymbolOrString asSymbol.! !!ImageMorph class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 13:09'!initialize	"ImageMorph initialize"	| h p d |	DefaultForm := (Form extent: 80@40 depth: 16).	h := DefaultForm height // 2.	0 to: h - 1 do: [:i |		p := (i * 2)@i.		d := i asFloat / h asFloat.		DefaultForm fill:			(p corner: DefaultForm extent - p)			fillColor: (Color r: d g: 0.5 b: 1.0 - d)].	self registerInFlapsRegistry.! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/25/1998 01:15'!fileNameFormattedFrom: entry sizePad: sizePad	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr := (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr := ((Date fromSeconds: (entry at: 3) )					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr := (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!NewParagraph methodsFor: 'composition' stamp: 'di 11/15/97 09:21'!composeAllStartingAt: characterIndex	firstCharacterIndex := characterIndex.	offsetToEnd := text size - firstCharacterIndex.	self composeAll! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'di 10/16/2000 10:46'!targetOffset: offsetPoint	"Set the offset at which we clicked down in the target morph"	targetOffset := offsetPoint! !!TextMorph methodsFor: 'containment' stamp: 'di 11/12/97 09:06'!setContainer: newContainer	"Adopt (or abandon) container shape"	self changed.	container := newContainer.	self releaseParagraph! !!ColorPatchCanvas methodsFor: 'drawing-general' stamp: 'ar 6/22/1999 16:14'!fullDrawMorph: aMorph	(foundMorph and:[doStop]) ifTrue:[^self]. "Found it and should stop"	aMorph == stopMorph ifTrue:[		"Never draw the stopMorph"		foundMorph := true.		^self].	^super fullDrawMorph: aMorph.! !!StringMorphAttributeScanner methodsFor: 'initialize-release' stamp: 'nk 2/26/2004 13:10'!initialize	emphasis := 0.	indent := 0.	kern := 0.	fontNumber := 1.	actualFont := TextStyle defaultFont! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 4/9/98 16:25'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	self model: anObject.	getTextSelector := getTextSel.	setTextSelector := setTextSel.	getSelectionSelector := getSelectionSel.	getMenuSelector := getMenuSel.	self borderWidth: 1.	self setText: self getText.	self setSelection: self getSelection.! !!MorphicModel methodsFor: 'initialization' stamp: 'di 6/21/97 13:25'!model: thang slotName: nameOfThisPart	model := thang.	slotName := nameOfThisPart.	open := false.! !!HandMorph class methodsFor: 'class initialization' stamp: 'kfr 7/13/2003 14:15'!initialize	"HandMorph initialize"	PasteBuffer := nil.	DoubleClickTime := 350.	NormalCursor := CursorWithMask normal asCursorForm.! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:22'!resetTimer	timeOfMouseDown := Time millisecondClockValue.	timeOfLastScroll := timeOfMouseDown - 1000 max: 0.	nextPageDirection := nil.	currentScrollDelay := nil! !!Morph methodsFor: 'e-toy support' stamp: 'sw 8/31/2004 14:11'!pinkXButton	"Answer a button with the old X on a pink background, targeted to self"	| aButton |	aButton := IconicButton new labelGraphic: (ScriptingSystem formAtKey: #PinkX).	aButton color: Color transparent; borderWidth: 0; shedSelvedge; actWhen: #buttonUp.	aButton target: self.	^ aButton! !!TextLine methodsFor: 'accessing' stamp: 'hmm 2/9/2001 11:58'!rectangle: lineRectangle	left := lineRectangle left.	right := lineRectangle right.	top := lineRectangle top.	bottom := lineRectangle bottom! !!SimpleHierarchicalListMorph methodsFor: 'dropping/grabbing' stamp: 'mir 5/8/2000 15:38'!resetPotentialDropMorph	potentialDropMorph ifNotNil: [		potentialDropMorph resetHighlightForDrop.		potentialDropMorph := nil]! !!UserInputEvent methodsFor: 'printing' stamp: 'ar 10/7/2000 21:57'!buttonString	"Return a string identifying the currently pressed buttons"	| string |	string := ''.	self redButtonPressed ifTrue:[string := string,'red '].	self yellowButtonPressed ifTrue:[string := string,'yellow '].	self blueButtonPressed ifTrue:[string := string,'blue '].	^string! !!FileList methodsFor: 'file menu action' stamp: 'ka 8/3/2001 21:12'!compressFile	"Compress the currently selected file"	| f |	f := StandardFileStream				readOnlyFileNamed: (directory fullNameFor: self fullName).	f compressFile.	self updateFileList! !!ScriptEditorMorph methodsFor: 'initialization' stamp: 'sw 8/28/2004 20:57'!initialize	"initialize the state of the receiver"	super initialize.	""	self listDirection: #topToBottom;		 hResizing: #shrinkWrap;		 vResizing: #shrinkWrap;		 cellPositioning: #topLeft;		 setProperty: #autoFitContents toValue: true;	 layoutInset: 2;	 useRoundedCorners.	self setNameTo: 'Script Editor' translated.	firstTileRow := 1.	"index of first tile-carrying submorph"	self addNewRow.	showingMethodPane := false! !!MovieMorph methodsFor: 'menu' stamp: ''!playLoop	playMode := #loop.! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'jm 11/4/97 07:15'!deleteOnMouseUp: aBoolean	deleteOnMouseUp := aBoolean.! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/15/2003 13:07'!dropDestinationDirectory: dest event: evt 	"Answer a FileDirectory representing the drop destination in the volume list morph dest"	| index dir delim path |	index := volList indexOf: (dest itemFromPoint: evt position) contents.	index = 1		ifTrue: [dir := FileDirectory on: '']		ifFalse: [delim := directory pathNameDelimiter.			path := String						streamContents: [:str | 							2								to: index								do: [:d | 									str nextPutAll: (volList at: d) withBlanksTrimmed.									d < index										ifTrue: [str nextPut: delim]].							nil].			dir := directory on: path].	^ dir! !!ListItemWrapper methodsFor: 'accessing' stamp: 'RAA 3/31/1999 16:44'!setItem: anObject model: aModel	item := anObject.	model := aModel.! !!Morph methodsFor: 'layout-menu' stamp: 'dgd 8/30/2003 20:07'!addTableLayoutMenuItems: aMenu hand: aHand	| menu sub |	menu := MenuMorph new defaultTarget: self.	menu addUpdating: #hasReverseCellsString action: #changeReverseCells.	menu addUpdating: #hasClipLayoutCellsString action: #changeClipLayoutCells.	menu addUpdating: #hasRubberBandCellsString action: #changeRubberBandCells.	menu addLine.	menu add: 'change cell inset...' translated action: #changeCellInset:.	menu add: 'change min cell size...' translated action: #changeMinCellSize:.	menu add: 'change max cell size...' translated action: #changeMaxCellSize:.	menu addLine.	sub := MenuMorph new defaultTarget: self.	#(leftToRight rightToLeft topToBottom bottomToTop) do:[:sym|		sub addUpdating: #listDirectionString: target: self selector: #changeListDirection: argumentList: (Array with: sym)].	menu add: 'list direction' translated subMenu: sub.	sub := MenuMorph new defaultTarget: self.	#(none leftToRight rightToLeft topToBottom bottomToTop) do:[:sym|		sub addUpdating: #wrapDirectionString: target: self selector: #wrapDirection: argumentList: (Array with: sym)].	menu add: 'wrap direction' translated subMenu: sub.	sub := MenuMorph new defaultTarget: self.	#(center topLeft topRight bottomLeft bottomRight topCenter leftCenter rightCenter bottomCenter) do:[:sym|		sub addUpdating: #cellPositioningString: target: self selector: #cellPositioning: argumentList: (Array with: sym)].	menu add: 'cell positioning' translated subMenu: sub.	sub := MenuMorph new defaultTarget: self.	#(topLeft bottomRight center justified) do:[:sym|		sub addUpdating: #listCenteringString: target: self selector: #listCentering: argumentList: (Array with: sym)].	menu add: 'list centering' translated subMenu: sub.	sub := MenuMorph new defaultTarget: self.	#(topLeft bottomRight center justified) do:[:sym|		sub addUpdating: #wrapCenteringString: target: self selector: #wrapCentering: argumentList: (Array with: sym)].	menu add: 'wrap centering' translated subMenu: sub.	sub := MenuMorph new defaultTarget: self.	#(none equal) do:[:sym|		sub addUpdating: #listSpacingString: target: self selector: #listSpacing: argumentList: (Array with: sym)].	menu add: 'list spacing' translated subMenu: sub.	sub := MenuMorph new defaultTarget: self.	#(none localRect localSquare globalRect globalSquare) do:[:sym|		sub addUpdating: #cellSpacingString: target: self selector: #cellSpacing: argumentList: (Array with: sym)].	menu add: 'cell spacing' translated subMenu: sub.	aMenu ifNotNil:[aMenu add: 'table layout' translated subMenu: menu].	^menu! !!PasteUpMorph methodsFor: 'gridding' stamp: 'di 8/24/2000 16:48'!griddingOnOff	griddingOn := self griddingOn not.	self changed! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 10:45'!autoAcceptOnFocusLoss: aBoolean	autoAcceptOnFocusLoss := aBoolean! !!NewHandleMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:29'!initialize"initialize the state of the receiver"	super initialize.""	waitingForClickInside := true.	Preferences noviceMode		ifTrue: [self setBalloonText: 'stretch']! !!FileList class methodsFor: 'instance creation' stamp: 'SD 11/8/2001 21:20'!openFileDirectly	| aResult |	(aResult := StandardFileMenu oldFile) ifNotNil:		[self openEditorOn: (aResult directory readOnlyFileNamed: aResult name) editString: nil]! !!Morph methodsFor: 'layout-properties' stamp: 'ar 11/14/2000 16:38'!layoutInset	"Return the extra inset for layouts"	| props |	props := self layoutProperties.	^props ifNil:[0] ifNotNil:[props layoutInset].! !!StringMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 21:57'!initWithContents: aString font: aFont emphasis: emphasisCode 	super initialize.		font := aFont.	emphasis := emphasisCode.	hasFocus := false.	self contents: aString! !!HandleMorph methodsFor: 'initialize' stamp: 'di 8/30/2000 21:48'!forEachPointDo: aBlock lastPointDo: otherBlock	pointBlock := aBlock.	lastPointBlock := otherBlock! !!BalloonMorph class methodsFor: 'instance creation' stamp: 'sd 12/5/2001 20:27'!string: str for: morph corner: cornerName 	"Make up and return a balloon for morph. Find the quadrant that 	clips the text the least, using cornerName as a tie-breaker. tk 9/12/97"	| tm vertices |	tm := self getTextMorph: str for: morph.	vertices := self getVertices: tm bounds.	vertices := self				getBestLocation: vertices				for: morph				corner: cornerName.	^ self new color: morph balloonColor;		 setVertices: vertices;		 addMorph: tm;		 setTarget: morph! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'RAA 8/30/2000 19:11'!fontForName	| pickem |	pickem := 3.	pickem = 1 ifTrue: [		^(((TextStyle named: #Helvetica) ifNil: [TextStyle default]) fontOfSize: 13) emphasized: 1.	].	pickem = 2 ifTrue: [		^(((TextStyle named: #Palatino) ifNil: [TextStyle default]) fontOfSize: 12) emphasized: 1.	].	^((TextStyle default) fontAt: 1) emphasized: 1! !!SelectionMorph methodsFor: 'dropping/grabbing' stamp: 'dgd 9/11/2004 22:00'!justDroppedInto: newOwner event: evt	selectedItems isEmpty ifTrue:		["Hand just clicked down to draw out a new selection"		^ self extendByHand: evt hand].	dupLoc ifNotNil: [dupDelta := self position - dupLoc].	selectedItems reverseDo: [:m | 		WorldState addDeferredUIMessage:			[m referencePosition: (newOwner localPointToGlobal: m referencePosition).			newOwner handleDropMorph:				(DropEvent new setPosition: evt cursorPoint contents: m hand: evt hand)] fixTemps].	evt wasHandled: true! !!MVCMenuMorph methodsFor: 'private' stamp: 'ar 9/18/2000 12:10'!cancelValue: selectionOrNil	"Set the value to be returned if the user cancels without making a selection."	mvcSelection := selectionOrNil.! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:29'!putFile	| result |	result := self getFilePathNameWithExistenceCheck.	^result ifNotNil: 		[FileDirectory deleteFilePath: result.		 FileStream newFileNamed: result]! !!WorldState methodsFor: 'stepping' stamp: 'sk 1/26/2003 18:31'!runStepMethodsIn: aWorld	"Perform periodic activity inbetween event cycles"	| queue numItems i limit stamp |	queue := self class deferredUIMessages.	numItems := queue size.	i := 0.	limit := self class deferredExecutionTimeLimit.	stamp := Time millisecondClockValue.	"Dispatch deferred messages while maintaing rudimentary UI responsiveness."	[i < numItems and: [(Time millisecondsSince: stamp) < limit]]		whileTrue: [queue next value. i := i + 1].	self runLocalStepMethodsIn: aWorld.	"we are using a normal #step for these now"	"aWorld allLowerWorldsDo: [ :each | each runLocalStepMethods ]."! !!PolygonMorph methodsFor: 'geometry eToy' stamp: 'di 9/24/2000 09:21'!rotationCenter	"Return the rotation center of the receiver. The rotation center defines the relative offset inside the receiver's bounds for locating the reference position."	| refPos |	refPos := self valueOfProperty: #referencePosition		ifAbsent: [^ 0.5@0.5].	^ (refPos - self bounds origin) / self bounds extent asFloatPoint! !!UserInputEvent methodsFor: 'transforming' stamp: 'ar 10/9/2000 00:37'!translateBy: delta	"add delta to cursorPoint, and return the new event"	position := position + delta.! !!MatrixTransformMorph methodsFor: 'geometry testing' stamp: 'ar 11/15/1998 21:52'!fullContainsPoint: aPoint	| p |	self visible ifFalse:[^false].	(self fullBounds containsPoint: aPoint) ifFalse:[^false].	(self containsPoint: aPoint) ifTrue:[^true].	p := self transform globalPointToLocal: aPoint.	submorphs do:[:m|		(m fullContainsPoint: p) ifTrue:[^true].	].	^false! !!Morph methodsFor: 'visual properties' stamp: 'nk 8/28/2003 15:57'!useBitmapFill	"Make receiver use a solid fill style (e.g., a simple color)"	| fill |	self fillStyle isBitmapFill ifTrue:[^self]. "Already done"	fill := BitmapFillStyle fromForm: self defaultBitmapFillForm.	"Note: Must fix the origin due to global coordinates"	fill origin: self bounds origin.	self fillStyle: fill.! !!FileList methodsFor: 'drag''n''drop' stamp: 'nk 6/19/2003 10:08'!acceptDroppingMorph: aTransferMorph event: evt inMorph: dest	| oldName oldEntry destDirectory newName newEntry baseName response |	destDirectory := self dropDestinationDirectory: dest event: evt.	oldName := aTransferMorph passenger.	baseName := FileDirectory localNameFor: oldName.	newName := destDirectory fullNameFor: baseName.	newName = oldName ifTrue: [ "Transcript nextPutAll: 'same as old name'; cr." ^ true ].	oldEntry := FileDirectory directoryEntryFor: oldName.	newEntry := FileDirectory directoryEntryFor: newName.	newEntry ifNotNil: [ | msg |		msg := String streamContents: [ :s |			s nextPutAll: 'destination file ';				nextPutAll: newName;				nextPutAll: ' exists already,';				cr;				nextPutAll: 'and is ';				nextPutAll: (oldEntry modificationTime < newEntry modificationTime					ifTrue: [ 'newer' ] ifFalse: [ 'not newer' ]);				nextPutAll: ' than source file ';				nextPutAll: oldName;				nextPut: $.;				cr;				nextPutAll: 'Overwrite file ';				nextPutAll: newName;				nextPut: $?		].		response := self confirm: msg.		response ifFalse: [ ^false ].	].	aTransferMorph shouldCopy		ifTrue: [ self primitiveCopyFileNamed: oldName to: newName ]		ifFalse: [ directory rename: oldName toBe: newName ].	self updateFileList; fileListIndex: 0.	aTransferMorph source model ~= self		ifTrue: [ aTransferMorph source model updateFileList; fileListIndex: 0 ].	"Transcript nextPutAll: 'copied'; cr."	^true! !!SimpleBorder methodsFor: 'accessing' stamp: 'ar 8/25/2001 18:23'!baseColor: aColor	| cc |	cc := aColor isTransparent ifTrue:[nil] ifFalse:[aColor].	baseColor = cc ifTrue:[^self].	baseColor := cc.	self releaseCachedState.	self color: cc.! !!SystemProgressMorph methodsFor: 'initialization' stamp: 'laza 7/29/2004 10:26'!close: aBlock	| slot |	slot := aBlock value: SmallInteger maxVal. "This should prevent a redraw"	self freeSlot: slot	! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'RAA 5/6/2001 15:15'!slideOneLineDown	| priorLine |	"Having detected the end of rippling recoposition, we are only sliding old lines"	prevIndex < prevLines size ifFalse: [		"There are no more prevLines to slide."		^nowSliding := possibleSlide := false	].	"Adjust and re-use previously composed line"	prevIndex := prevIndex + 1.	priorLine := (prevLines at: prevIndex)				slideIndexBy: deltaCharIndex andMoveTopTo: currentY.	lines addLast: priorLine.	currentY := priorLine bottom.	currCharIndex := priorLine last + 1.	wantsColumnBreaks ifTrue: [		priorLine first to: priorLine last do: [ :i |			(theText at: i) = TextComposer characterForColumnBreak ifTrue: [				nowSliding := possibleSlide := false.				^nil			].		].	].! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35'!leftFraction: aNumber	leftFraction := aNumber! !MenuMorph initialize!SystemWindow initialize!ColorPickerMorph initialize!TextMorph initialize!TextContainer initialize!WorldState initialize!SystemProgressMorph initialize!Morph initialize!ThreePhaseButtonMorph initialize!MenuItemMorph initialize!ImageMorph initialize!HandMorph initialize!