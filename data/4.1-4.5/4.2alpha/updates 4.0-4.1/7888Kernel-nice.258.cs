"Change Set:		7888Kernel-nice.258Kernel-nice.258:Patch for http://bugs.squeak.org/view.php?id=7401Float negativeZero shallowCopy loose its negative sign.self assert: Float negativeZero copy hex = Float negativeZero hex.Kernel-nice.255:Fix from http://bugs.squeak.org/view.php?id=6697Number>>storeOn:base: default implementation is wrong: It calls printOn:base:But printOn:Base: does not print the radix, when storeOn:Base: should.As every subclass (except ScaledDecimal) does implement storeOn:Base: the best thing to do is to defer subclassResponsibility.Kernel-nice.256:Fix for http://bugs.squeak.org/view.php?id=6781self should: [0.0 raisedTo: -1.0] raise: ZeroDivide.I used the license clean fix from Pharo here and also introduce license clean #raisedToInteger: #/ #reciprocal #one by GabrielOmarCotelliThis code is MIT as Gabriel signed the pharo agreement.Kernel-nice.257:Fix red tests related to ScaledDecimal raisedToInteger:"!!Float methodsFor: 'arithmetic' stamp: 'GabrielOmarCotelli 6/6/2009 17:12'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber = 0.0 ifTrue: [ ZeroDivide signalWithDividend: self].	^aNumber adaptToFloat: self andSend: #/! !!Number methodsFor: 'arithmetic' stamp: 'GabrielOmarCotelli 5/23/2009 20:20'!reciprocal	"Returns the reciprocal of self.	In case self is 0 the / signals ZeroDivide"		^1 / self! !!SmallInteger methodsFor: 'arithmetic' stamp: 'tak 9/25/2008 15:14'!/ aNumber 	"Primitive. This primitive (for /) divides the receiver by the argument	and returns the result if the division is exact. Fail if the result is not a	whole integer. Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 10>	aNumber isZero ifTrue: [^(ZeroDivide dividend: self) signal].	^(aNumber isMemberOf: SmallInteger)		ifTrue: [(Fraction numerator: self denominator: aNumber) reduced]		ifFalse: [super / aNumber]! !!Float class methodsFor: 'constants' stamp: 'GabrielOmarCotelli 5/25/2009 15:42'!one		^1.0! !!Number methodsFor: 'mathematical functions' stamp: 'GabrielOmarCotelli 5/26/2009 19:49'!raisedToInteger: anInteger	"The 0 raisedToInteger: 0 is an special case. In some contexts must be 1 and in others must	be handled as an indeterminate form.	I take the first context because that's the way that was previously handled.	Maybe further discussion is required on this topic."		|bitProbe result|	anInteger negative ifTrue: [^(self raisedToInteger: anInteger negated) reciprocal].	bitProbe := 1 bitShift: anInteger highBit - 1. 	result := self class one.  	[		(anInteger bitAnd: bitProbe) = 0 ifFalse: [result := result * self].       bitProbe := bitProbe bitShift: -1.		bitProbe > 0 ]	whileTrue: [result := result * result].		^result! !!Number methodsFor: 'printing' stamp: 'nice 9/25/2007 02:35'!storeOn: aStream base: base	"This method should print a representation of the number for the given base,	including the base prefix (with letter r for radix)"		^self subclassResponsibility! !!Number methodsFor: 'truncation and round off' stamp: 'GabrielOmarCotelli 5/26/2009 21:58'!fractionPart		"Added for ANSI compatibility"		^self - self integerPart! !!ScaledDecimal methodsFor: 'mathematical functions' stamp: 'nice 10/4/2009 22:20'!raisedToInteger: aNumber	^self class newFromNumber: (fraction raisedToInteger: aNumber) scale: scale! !!Float methodsFor: 'copying' stamp: 'nice 10/4/2009 23:16'!shallowCopy	^self - 0.0! !!Number methodsFor: 'mathematical functions' stamp: 'nice 12/6/2007 21:46'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].	self < 0 ifTrue:		[ self error: self printString, ' raised to a non-integer power' ].	0 = aNumber ifTrue: [^ self class one].	"Special case of exponent=0"	1 = aNumber ifTrue: [^ self].	"Special case of exponent=1"	0 = self ifTrue: [				"Special case of self = 0"		aNumber < 0			ifTrue: [^ (ZeroDivide dividend: self) signal]			ifFalse: [^ self]].	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Float methodsFor: 'arithmetic' stamp: 'GabrielOmarCotelli 5/23/2009 20:40'!reciprocal	"Returns the reciprocal.	If self is 0.0 the / signals a ZeroDivide"		^1.0 / self! !!Fraction methodsFor: 'private' stamp: 'GabrielOmarCotelli 5/23/2009 20:36'!reciprocal		numerator abs = 1 ifTrue: [^denominator * numerator].	^self class numerator: denominator denominator: numerator! !!Number methodsFor: 'truncation and round off' stamp: 'GabrielOmarCotelli 5/26/2009 21:57'!integerPart	"Added for ANSI compatibility"	^self truncated! !!Number class methodsFor: 'constants' stamp: 'GabrielOmarCotelli 5/23/2009 20:46'!one	^1! !!Number methodsFor: 'printing' stamp: 'nice 9/25/2007 02:36'!printOn: aStream base: base	"This method should print a representation of the number for the given base,	excluding the base prefix (and the letter r for radix)"		^self subclassResponsibility! !ScaledDecimal class removeSelector: #one!Float removeSelector: #raisedTo:!Integer class removeSelector: #one!Fraction class removeSelector: #one!