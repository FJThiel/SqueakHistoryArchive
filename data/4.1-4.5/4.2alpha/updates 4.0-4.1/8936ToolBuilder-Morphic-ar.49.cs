"Change Set:		8936ToolBuilder-Morphic-ar.49ToolBuilder-Morphic-ar.49:Merging ToolBuilder-Morphic-mtf.46:Merged in the Cobalt version of ToolBuilder. Just makes use of the new properties and the fact that any widget can now have help texsToolBuilder-Morphic-Igor.Stasenko.48:- placed a widget classes, used by MorphicToolBuilderinto separate methods.So, one could subclass the MorphicToolBuilder and use different widgets, while retaining rest of building logic"!PluggableSystemWindow subclass: #PluggableDialogWindow	instanceVariableNames: 'statusValue'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!SimpleHierarchicalListMorph subclass: #PluggableTreeMorph	instanceVariableNames: 'roots selectedWrapper getRootsSelector getChildrenSelector hasChildrenSelector getLabelSelector getIconSelector getSelectedPathSelector setSelectedSelector getHelpSelector dropItemSelector wantsDropSelector dragItemSelector'	classVariableNames: ''	poolDictionaries: ''	category: 'ToolBuilder-Morphic'!!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:20'!menuClass	^ MenuMorph! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'btr 11/26/2006 12:49'!buildHelpFor: widget spec: aSpec	aSpec help		ifNotNil: [widget setBalloonText: aSpec help]! !!PluggableTreeMorph methodsFor: 'morphic' stamp: 'mvdg 2/14/2007 14:58'!acceptDroppingMorph: aMorph event: evt	| item dropTarget |	dropItemSelector ifNil:[^self].	item := aMorph passenger.	dropTarget := (self itemFromPoint: evt position) withoutListWrapper.	model perform: dropItemSelector with: item with: dropTarget.	evt hand releaseMouseFocus: self.	Cursor normal show.! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:16'!windowClass	^ PluggableSystemWindow! !!PluggableTreeMorph methodsFor: 'accessing' stamp: 'mvdg 2/11/2007 13:53'!dragItemSelector	^dragItemSelector! !!PluggableTreeMorph methodsFor: 'morphic' stamp: 'mvdg 2/14/2007 14:35'!wantsDroppedMorph: aMorph event: anEvent	aMorph dragTransferType == #dragTransferPlus ifFalse:[^false].	dropItemSelector ifNil:[^false].	wantsDropSelector ifNil:[^true].	^ (model perform: wantsDropSelector with: aMorph passenger) == true.! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'ar 1/23/2010 14:32'!buildPluggableList: aSpec	| widget listClass getIndex setIndex |	aSpec getSelected ifNil:[		listClass := self listClass.		getIndex := aSpec getIndex.		setIndex := aSpec setIndex.	] ifNotNil:[		listClass := self listByItemClass.		getIndex := aSpec getSelected.		setIndex := aSpec setSelected.	].	widget := listClass on: aSpec model				list: aSpec list				selected: getIndex				changeSelected: setIndex				menu: aSpec menu				keystroke: aSpec keyPress.	self register: widget id: aSpec name.	widget getListElementSelector: aSpec listItem.	widget getListSizeSelector: aSpec listSize.	widget doubleClickSelector: aSpec doubleClick.	widget dragItemSelector: aSpec dragItem.	widget dropItemSelector: aSpec dropItem.	widget wantsDropSelector: aSpec dropAccept.	widget autoDeselect: aSpec autoDeselect.	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	panes ifNotNil:[		aSpec list ifNotNil:[panes add: aSpec list].	].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'Igor.Stasenko 1/17/2010 04:12'!buildPluggableCodePane: aSpec	"Install the default styler for code panes.	Implementation note: We should just be doing something like, e.g.,		^(self buildPluggableText: aSpec) useDefaultStyler	Unfortunately, this will retrieve and layout the initial text twice which	can make for a noticable performance difference when looking at some	larger piece of code. So instead we copy the implementation from 	buildPlugggableText: here and insert #useDefaultStyler at the right point"	| widget |	widget := self codePaneClass new.	widget useDefaultStyler.	widget on: aSpec model				text: aSpec getText 				accept: aSpec setText				readSelection: aSpec selection 				menu: aSpec menu.	widget font: Preferences standardCodeFont.	self register: widget id: aSpec name.	widget getColorSelector: aSpec color.	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	widget borderColor: Color lightGray.	widget color: Color white.	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'ar 1/23/2010 14:33'!buildPluggableText: aSpec	| widget |	widget := self textPaneClass on: aSpec model				text: aSpec getText 				accept: aSpec setText				readSelection: aSpec selection 				menu: aSpec menu.	widget askBeforeDiscardingEdits: aSpec askBeforeDiscardingEdits.	widget font: Preferences standardCodeFont.	self register: widget id: aSpec name.	widget getColorSelector: aSpec color.	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	widget borderColor: Color lightGray.	widget color: Color white.	^widget! !!PluggableDialogWindow methodsFor: 'as yet unclassified' stamp: 'jrd 12/1/2008 23:56'!statusValue	^statusValue! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:11'!listByItemClass	^ PluggableListMorphByItemPlus! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 1/23/2010 14:38'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice 	"Put up a yes/no menu with caption queryString. The actual wording for the two choices will be as provided in the trueChoice and falseChoice parameters. Answer true if the response is the true-choice, false if it's the false-choice.	This is a modal question -- the user must respond one way or the other."	^ UserDialogBoxMorph confirm: queryString trueChoice: trueChoice falseChoice: falseChoice ! !!PluggableButtonMorphPlus methodsFor: 'accessing' stamp: 'dc 1/9/2008 18:17'!enabled	^ enabled ifNil: [enabled := true]! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:03'!codePaneClass	^ PluggableTextMorphPlus! !!PluggableListMorphByItemPlus methodsFor: 'model access' stamp: 'jrd 12/8/2008 23:24'!getCurrentSelectionIndex	"Answer the index of the current selection."	| item |	getIndexSelector == nil ifTrue: [^ 0].	item := model perform: getIndexSelector.	^ itemList findFirst: [ :x | x = item]! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:14'!multiSelectListClass	^ PluggableListMorphOfMany! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:14'!panelClass	^ PluggablePanelMorph! !!PluggableDialogWindow methodsFor: 'as yet unclassified' stamp: 'jrd 12/1/2008 23:56'!statusValue: val	statusValue := val! !!PluggableTreeMorph methodsFor: 'accessing' stamp: 'mvdg 2/11/2007 13:53'!dragItemSelector: aSymbol	dragItemSelector := aSymbol.	aSymbol ifNotNil:[self dragEnabled: true].! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:15'!textPaneClass	^ PluggableTextMorphPlus! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:06'!listClass	^ PluggableListMorphPlus! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:16'!treeClass	^ PluggableTreeMorph! !!MorphicToolBuilder methodsFor: 'building' stamp: 'Igor.Stasenko 1/17/2010 04:20'!buildPluggableMenu: menuSpec 	| prior menu |	prior := parentMenu.	parentMenu := menu := self menuClass new.	menuSpec label ifNotNil:[parentMenu addTitle: menuSpec label].	menuSpec items do:[:each| each buildWith: self].	parentMenu := prior.	^menu! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:01'!buttonClass	^ PluggableButtonMorphPlus! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'ar 1/23/2010 14:32'!buildPluggableButton: aSpec	| widget label state action enabled |	label := aSpec label.	state := aSpec state.	action := aSpec action.	widget := self buttonClass on: aSpec model				getState: (state isSymbol ifTrue:[state])				action: nil				label: (label isSymbol ifTrue:[label]).	self register: widget id: aSpec name.	enabled := aSpec enabled.	enabled isSymbol		ifTrue:[widget getEnabledSelector: enabled]		ifFalse:[widget enabled:enabled].	widget action: action.	widget getColorSelector: aSpec color.	widget offColor: Color white..	self buildHelpFor: widget spec: aSpec. 	(label isSymbol or:[label == nil]) ifFalse:[widget label: label].	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'ar 1/23/2010 14:33'!buildPluggableWindow: aSpec	| widget children label |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := self windowClass new.	self register: widget id: aSpec name.	widget model: aSpec model.	(label := aSpec label) ifNotNil:[		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	children := aSpec children.	children isSymbol ifTrue:[		widget getChildrenSelector: children.		widget update: children.		children := #().	].	widget closeWindowSelector: aSpec closeAction.	panes := OrderedCollection new.	self buildAll: children in: widget.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: (aSpec extent ifNil:[widget initialExtent])		world: self currentWorld).	widget setUpdatablePanesFrom: panes.	^widget! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'Igor.Stasenko 1/17/2010 04:20'!menuItemClass	^ MenuItemMorph! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'ar 1/23/2010 14:33'!buildPluggableTree: aSpec	| widget |	widget := self treeClass new.	self register: widget id: aSpec name.	widget model: aSpec model.	widget getSelectedPathSelector: aSpec getSelectedPath.	widget setSelectedSelector: aSpec setSelected.	widget getChildrenSelector: aSpec getChildren.	widget hasChildrenSelector: aSpec hasChildren.	widget getLabelSelector: aSpec label.	widget getIconSelector: aSpec icon.	widget getHelpSelector: aSpec help.	widget getMenuSelector: aSpec menu.	widget keystrokeActionSelector: aSpec keyPress.	widget getRootsSelector: aSpec roots.	widget autoDeselect: aSpec autoDeselect.	widget dropItemSelector: aSpec dropItem.	widget wantsDropSelector: aSpec dropAccept.	widget dragItemSelector: aSpec dragItem.	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent]."	panes ifNotNil:[		aSpec roots ifNotNil:[panes add: aSpec roots].	].	"	^widget! !!MorphicToolBuilder methodsFor: 'private' stamp: 'dc 1/10/2008 14:17'!setFrame: aRectangle in: widget	| frame |	aRectangle ifNil:[^nil].	frame := aRectangle isRectangle		ifTrue: [self asFrame: aRectangle]		ifFalse: [aRectangle]. "assume LayoutFrame"	widget layoutFrame: frame.	widget hResizing: #spaceFill; vResizing: #spaceFill.	(parent isSystemWindow) ifTrue:[		widget borderWidth: 2; borderColor: #inset.	].! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'ar 1/23/2010 14:33'!buildPluggablePanel: aSpec	| widget children frame |	widget := self panelClass new.	self register: widget id: aSpec name.	widget model: aSpec model.	widget color: Color transparent.	widget clipSubmorphs: true.	children := aSpec children.	children isSymbol ifTrue:[		widget getChildrenSelector: children.		widget update: children.		children := #().	].	self buildAll: children in: widget.	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	self setLayout: aSpec layout in: widget.	widget layoutInset: 0.	widget borderWidth: 0.	widget submorphsDo:[:sm|		(frame := sm layoutFrame) ifNotNil:[			(frame rightFraction = 0 or:[frame rightFraction = 1]) 				ifFalse:[frame rightOffset:1].			(frame bottomFraction = 0 or:[frame bottomFraction = 1]) 				ifFalse:[frame bottomOffset: 1]]].	widget color: Color transparent.	^widget! !!PluggableTreeMorph methodsFor: 'morphic' stamp: 'mvdg 2/14/2007 15:08'!startDrag: evt 	| ddm itemMorph passenger |	self dragEnabled		ifTrue: [itemMorph := scroller submorphs						detect: [:any | any highlightedForMouseDown]						ifNone: []].	(itemMorph isNil			or: [evt hand hasSubmorphs])		ifTrue: [^ self].	itemMorph highlightForMouseDown: false.	itemMorph ~= self selectedMorph		ifTrue: [self setSelectedMorph: itemMorph].	passenger := self model perform: dragItemSelector with: itemMorph withoutListWrapper.	passenger		ifNotNil: [ddm := TransferMorph withPassenger: passenger from: self.			ddm dragTransferType: #dragTransferPlus.			Preferences dragNDropWithAnimation				ifTrue: [self model dragAnimationFor: itemMorph transferMorph: ddm].			evt hand grabMorph: ddm].	evt hand releaseMouseFocus: self! !!MorphicToolBuilder methodsFor: 'building' stamp: 'Igor.Stasenko 1/17/2010 04:20'!buildPluggableMenuItem: itemSpec	| item action label menu |	item := self menuItemClass new.	label := itemSpec label.	itemSpec checked ifTrue:[label := '<on>', label] ifFalse:[label := '<off>', label].	item contents: label.	item isEnabled: itemSpec enabled.	(action := itemSpec action) ifNotNil:[		item 			target: action receiver;			selector: action selector;			arguments: action arguments.	].	(menu := itemSpec subMenu) ifNotNil:[		item subMenu: (menu buildWith: self).	].	parentMenu ifNotNil:[parentMenu addMorphBack: item].	itemSpec separator ifTrue:[parentMenu addLine].	^item! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'ar 1/23/2010 14:33'!buildPluggableMultiSelectionList: aSpec	| widget listClass |	aSpec getSelected ifNotNil:[^self error:'There is no PluggableListMorphOfManyByItem'].	listClass := self multiSelectListClass.	widget := listClass on: aSpec model		list: aSpec list		primarySelection: aSpec getIndex		changePrimarySelection: aSpec setIndex		listSelection: aSpec getSelectionList		changeListSelection: aSpec setSelectionList		menu: aSpec menu.	self register: widget id: aSpec name.	widget keystrokeActionSelector: aSpec keyPress.	widget getListElementSelector: aSpec listItem.	widget getListSizeSelector: aSpec listSize.	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	panes ifNotNil:[		aSpec list ifNotNil:[panes add: aSpec list].	].	^widget! !!PluggableTreeMorph methodsFor: 'accessing' stamp: 'mvdg 2/9/2007 21:37'!dropItemSelector: aSymbol	dropItemSelector := aSymbol.	aSymbol ifNotNil:[self dropEnabled: true].! !