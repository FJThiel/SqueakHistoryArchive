"Change Set:		8641Monticello-ar.343Monticello-ar.343:NanoTraits preparations: Vector traits creation through ClassDescription protocol so that we can replace Berne traits.Monticello-nice.342:change #findSnapshotWithVersionInfo: to silently ignore a missing ancestor rather than sending #snapshot to nil.This happens for example when merging Pharo/CollectionTests.Don't know if this is the good strategy though (maybe a notification could be signalled)+ Cosmetic: move or remove a few temps inside closures"!!MCSnapshotBrowserTest methodsFor: 'asserting' stamp: 'nice 12/27/2009 20:58'!assertAListMatches: strings	| listMorphs |	listMorphs := self listMorphs.	listMorphs 		detect: [:m | | list |			list := m getList. (list size = strings size) and: [list includesAllOf: strings]]		ifNone: [self assert: false].! !!MCTraitDefinition methodsFor: 'visiting' stamp: 'ar 12/27/2009 19:07'!createClass	^ClassDescription		newTraitNamed: name		uses: (Compiler evaluate: self traitCompositionString)		category: category		! !!MCFtpRepository methodsFor: 'required' stamp: 'nice 12/27/2009 03:11'!readStreamForFileNamed: aString do: aBlock		^ self clientDo:		[:client | | stream |		client binary.		stream := RWBinaryOrTextStream on: String new.		stream nextPutAll: (client getFileNamed: aString).		aBlock value: stream reset]! !!MCClassTraitDefinition class methodsFor: 'instance creation' stamp: 'al 10/9/2005 20:22'!baseTraitName: aString classTraitComposition: classTraitCompositionString	^self instanceLike: (		self new			initializeWithBaseTraitName: aString			classTraitComposition: classTraitCompositionString).! !!MCClassDefinitionTest methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!testKindOfSubclass	| classes |	classes := {self mockClassA. String. MethodContext. WeakArray. Float}.	classes do: [:c | | d |		d :=  c asClassDefinition.		self assert: d kindOfSubclass = c kindOfSubclass.	].! !!MCVersion methodsFor: 'enumerating' stamp: 'nice 12/27/2009 03:11'!allDependenciesNotIn: aDictionary do: aBlock ifUnresolved: failBlock		self dependencies do: 		[:ea | | version | 		version := aDictionary at: ea ifAbsent: [ea resolve].		version 			ifNil: [failBlock value: ea]			ifNotNil: [(aDictionary includes: version) ifFalse:						[aDictionary at: ea put: version.						version 							allDependenciesNotIn: aDictionary 							do: aBlock							ifUnresolved: failBlock.						aBlock value: version]]]! !!MCMethodDefinition methodsFor: 'installing' stamp: 'nice 12/27/2009 20:58'!scanForPreviousVersion	| sourceFilesCopy method position |	method := self actualClass compiledMethodAt: selector ifAbsent: [^ nil].	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos tokens preamble methodCategory stamp prevFileIndex |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		methodCategory = category ifFalse:			[methodCategory = (Smalltalk 									at: #Categorizer 									ifAbsent: [Smalltalk at: #ClassOrganizer]) 										default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: className category: methodCategory meta: classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!MCSubDirectoryRepository methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!findFullNameForWriting: aBaseName	| possible split prefix fpattern now |	split := directory splitNameVersionExtensionFor: aBaseName.	fpattern := split first, '*'.	possible := SortedCollection sortBlock: [ :a :b |		a first = b first			ifTrue: [ a second = b second					ifFalse: [ a second < b second ]					ifTrue: [ a third fullName size < b third fullName size ]]			ifFalse: [ a first > b first ] ].	now := Time totalSeconds.	prefix := directory pathParts size.	self allDirectories do: [:dir | | parts dirScore fileScore |		parts := dir pathParts allButFirst: prefix.		dirScore := (parts select: [ :part | fpattern match: part ]) size.		fileScore := (dir entries collect: [ :ent |			(ent isDirectory not and: [ fpattern match: ent name ])				ifFalse: [ SmallInteger maxVal ]				ifTrue: [ now - ent modificationTime ]]).	"minimum age"		fileScore := fileScore isEmpty ifTrue: [ SmallInteger maxVal  ]			ifFalse: [ fileScore min ].		possible add: { dirScore. fileScore. dir } ].	^ (possible first third) fullNameFor: aBaseName! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!refresh	| packageNames |	packageNames := Set new.	packageList := nil.	versions := repository readableFileNames collect: [ :each | | name |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	versions := versions select: [:each | (each at: 3) isNumber].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each | | latest |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor | | av |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!versionWithInfo: aVersionInfo ifAbsent: errorBlock		(self allFileNamesForVersionNamed: aVersionInfo name) do:		[:fileName | | version |		version := self versionFromFileNamed: fileName.		version info = aVersionInfo ifTrue: [^ version]].	^ errorBlock value! !!MCToolWindowBuilder methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!buttonRow: specArray	| panel |	panel := builder pluggablePanelSpec new.	panel children: OrderedCollection new.	specArray do:		[:spec | | button |				button := builder pluggableButtonSpec new.		button model: tool.		button label: spec first asString.		button action: spec second.		button help: spec third.		button enabled: (spec at: 4 ifAbsent: [#buttonEnabled]).		button state: (spec at: 5 ifAbsent: [#buttonSelected]).		panel children add: button].	panel layout: #horizontal.	panel frame: currentFrame.	window children add: panel! !!MCAncestry methodsFor: 'ancestry' stamp: 'nice 12/27/2009 03:11'!topologicalAncestors		^ Array streamContents:		[:s | | frontier f |		frontier := MCFrontier frontierOn: self.		[f := frontier frontier.		s nextPutAll: f.		frontier removeAll: f.		f isEmpty] whileFalse] ! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!testSelectiveBackport	| inst base intermediate final |	inst := self mockInstanceA.	base :=  self snapshot.	self assert: inst one = 1.	self change: #one toReturn: 2.	intermediate := self snapshot.	self change: #two toReturn: 3.	final := self snapshot.	[workingCopy backportChangesTo: base info]		on: MCChangeSelectionRequest		do: [:e | | selected patch |			patch := e patch.			selected := patch operations select: [:ea | ea definition selector = #two].			e resume: (MCPatch operations: selected)]. 	self assert: inst one = 1.	self assert: inst two = 3.	self assert: workingCopy ancestry ancestors size = 1.	self assert: workingCopy ancestry ancestors first = base info.	self assert: workingCopy ancestry stepChildren size = 1.	self assert: workingCopy ancestry stepChildren first = final info! !!MCVersion methodsFor: 'enumerating' stamp: 'nice 12/27/2009 20:59'!allAvailableDependenciesDo: aBlock		self dependencies do:		[:ea |		[ | version |		version := ea resolve.		version allAvailableDependenciesDo: aBlock.		aBlock value: version]			on: Error do: []]! !!MCWorkingCopy methodsFor: 'private' stamp: 'nice 12/25/2009 14:39'!findSnapshotWithVersionInfo: aVersionInfo	^ aVersionInfo		ifNil: [MCSnapshot empty]		ifNotNil: [(self repositoryGroup versionWithInfo: aVersionInfo)			ifNil: [MCSnapshot empty]			ifNotNil: [:aVersion | aVersion snapshot]]! !!MCVersionMerger methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!addVersion: aVersion		records add: (MCMergeRecord version: aVersion).	aVersion dependencies do:		[:ea | | dep |		dep := ea resolve.		(records anySatisfy: [:r | r version = dep]) ifFalse: [self addVersion: dep]]! !!MCTool methodsFor: 'morphic ui' stamp: 'nice 12/27/2009 03:11'!buttonRow: specArray	| aRow |	aRow := AlignmentMorph newRow.	aRow 		color: (Display depth <= 8 ifTrue: [Color transparent] ifFalse: [Color gray alpha: 0.2]);		borderWidth: 0.	aRow hResizing: #spaceFill; vResizing: #spaceFill; rubberBandCells: true.	aRow clipSubmorphs: true.	aRow layoutInset:2@2; cellInset: 1; color: Color white.	aRow wrapCentering: #center; cellPositioning: #leftCenter.	specArray do:		[:triplet | | aButton state |			state := triplet at: 4 ifAbsent: [#buttonState].			aButton := PluggableButtonMorph				on: self				getState: state				action: #performButtonAction:enabled:.			aButton				hResizing: #spaceFill;				vResizing: #spaceFill;				label: triplet first asString;				arguments: (Array with: triplet second with: state); 				onColor: Color white offColor: Color white.			aRow addMorphBack: aButton.			aButton setBalloonText: triplet third].	^ aRow! !!MCHttpRepository methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!userAndPasswordFromSettingsDo: aBlock	"The mcSettings file in ExternalSettings preferenceDirectory should contain entries for each account:			account1: *myhost.mydomain* user:password		account2: *otherhost.mydomain/somerep* dXNlcjpwYXNzd29yZA==	That is it must start with 'account', followed by anything to distinguish accounts, and a colon. Then comes a match expression for the repository url, and after a space the user:password string.		To not have the clear text password on your disc, you can base64 encode it:			(Base64MimeConverter mimeEncode: 'user:password' readStream) contents	"		Settings ifNotNil: [		Settings keysAndValuesDo: [:key :value | | userAndPassword entry |			(key asLowercase beginsWith: 'account') ifTrue: [				entry := value findTokens: '	 '.				(entry first match: location) ifTrue: [					userAndPassword := entry second.					(userAndPassword includes: $:) ifFalse: [						userAndPassword := (Base64MimeConverter mimeDecodeToChars: userAndPassword readStream) contents].					userAndPassword := userAndPassword findTokens: $:.					^aBlock value: userAndPassword first 						value: userAndPassword second 					]			]		]	].	^nil! !