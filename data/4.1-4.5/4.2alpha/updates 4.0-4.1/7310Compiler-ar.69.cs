"Change Set:		7310Compiler-ar.69Compiler-ar.69:Closure compiler, main part."!Warning subclass: #UndeclaredVariableWarning	instanceVariableNames: 'name selector class'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!TestCase subclass: #ContextCompilationTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!Object subclass: #Compiler	instanceVariableNames: 'sourceStream requestor class category context parser'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!ParseNode subclass: #BlockNode	instanceVariableNames: 'arguments statements returns nArgsNode size remoteCopyNode temporaries optimized blockExtent remoteTempNode copiedValues closureCreationNode startOfLastStatement'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!DecompilerConstructor subclass: #DecompilerConstructorForClosures	instanceVariableNames: 'tempNameCounter'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!TestCase subclass: #ClosureCompilerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!InstructionClient subclass: #BlockLocalTempCounter	instanceVariableNames: 'stackPointer scanner blockEnd joinOffsets'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!BytecodeEncoder subclass: #EncoderForV3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!Encoder subclass: #BytecodeEncoder	instanceVariableNames: 'stream position rootNode blockExtentsToLocals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!InstructionStream subclass: #Decompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps'	classVariableNames: 'ArgumentFlag CascadeFlag IfNilFlag CaseFlag'	poolDictionaries: ''	category: 'Compiler-Kernel'!EncoderForLongFormV3 subclass: #EncoderForLongFormV3PlusClosures	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!ParseNodeVisitor subclass: #RegenerationPreparingVisitor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!BytecodeEncoder subclass: #EncoderForLongFormV3	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!MethodNode subclass: #BytecodeAgnosticMethodNode	instanceVariableNames: 'locationCounter localsPool'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!EncoderForV3 subclass: #EncoderForV3PlusClosures	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!ParseNode subclass: #MessageNode	instanceVariableNames: 'receiver selector precedence special arguments sizes equalNode caseErrorNode'	classVariableNames: 'MacroSelectors MacroEmitters MacroTransformers StdTypers NewStyleMacroEmitters MacroSizers ThenFlag NewStyleMacroSizers MacroPrinters'	poolDictionaries: ''	category: 'Compiler-ParseNodes'!VariableNode subclass: #TempVariableNode	instanceVariableNames: 'argType hasRefs hasDefs scope definingScope readingScopes writingScopes remoteNode'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!!MessageNode class methodsFor: 'class initialization' stamp: 'eem 5/14/2008 18:15'!initialize		"MessageNode initialize"	MacroSelectors := 		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers := 		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters := 		#(	emitIf:on:value: emitIf:on:value: emitIf:on:value: emitIf:on:value:			emitIf:on:value: emitIf:on:value:			emitWhile:on:value: emitWhile:on:value: emitWhile:on:value: emitWhile:on:value:			emitToDo:on:value: emitToDo:on:value:			emitCase:on:value: emitCase:on:value:			emitIfNil:on:value: emitIfNil:on:value: emitIf:on:value: emitIf:on:value:).	NewStyleMacroEmitters := 		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:).	MacroSizers := 		#(	sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value:			sizeIf:value: sizeIf:value:			sizeWhile:value: sizeWhile:value: sizeWhile:value: sizeWhile:value:			sizeToDo:value: sizeToDo:value:			sizeCase:value: sizeCase:value:			sizeIfNil:value: sizeIfNil:value: sizeIf:value: sizeIf:value:).	NewStyleMacroSizers := 		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:			sizeCodeForToDo:value: sizeCodeForToDo:value:			sizeCodeForCase:value: sizeCodeForCase:value:			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:).	MacroPrinters := 		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/19/2008 17:15'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: (BlockNode withJust: NodeNil) noteOptimized					with: (arguments at: 1) noteOptimized.			^true]		ifFalse:			[^false]! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:54'!genPushLiteralVar: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue: 		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 64 ifTrue: 		["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 128;			nextPut: 192 + literalIndex.		 ^self].	literalIndex < 256 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 128;			nextPut: literalIndex.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!Decompiler methodsFor: 'private' stamp: 'eem 9/6/2008 09:27'!scanBlockScopeFor: refpc from: startpc to: endpc with: scan scanner: scanner	| bsl maybeBlockSize |	bsl := BlockStartLocator new.	scanner pc: startpc.	[scanner pc <= endpc] whileTrue:		[refpc = scanner pc ifTrue:			[scanner pc: startpc.			 [scanner pc <= endpc] whileTrue:				[(scan value: scanner firstByte) ifTrue:					[^endpc].				 (maybeBlockSize := scanner interpretNextInstructionFor: bsl) isInteger ifTrue:					[scanner pc: scanner pc + maybeBlockSize]].			   ^self].		 (maybeBlockSize := scanner interpretNextInstructionFor: bsl) isInteger ifTrue:			[refpc <= (scanner pc + maybeBlockSize)				ifTrue: [^self scanBlockScopeFor: refpc from: scanner pc to: scanner pc + maybeBlockSize with: scan scanner: scanner]				ifFalse: [scanner pc: scanner pc + maybeBlockSize]]]! !!LiteralNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:03'!sizeCodeForValue: encoder	self reserve: encoder.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizePushSpecialLiteral: specialLiteral])		ifFalse:			[^encoder sizePushLiteral: index]! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/15/2008 10:00'!sizeStorePopInstVar: instVarIndex	^self sizeOpcodeSelector: #genStorePopInstVar: withArguments: {instVarIndex}! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:13'!sizeCode: encoder forBranchOn: condition dist: dist	dist = 0 ifTrue: [^encoder sizePop].	^condition		ifTrue: [encoder sizeBranchPopTrue: dist]		ifFalse: [encoder sizeBranchPopFalse: dist]! !!MessageNode methodsFor: 'printing' stamp: 'eem 9/25/2008 14:53'!printWithClosureAnalysisToDoOn: aStream indent: level	| limitNode |	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.	limitNode := (arguments last == nil				or: [arguments last isAssignmentNode not])					ifTrue: [arguments first]					ifFalse: [arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key == 1]])		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printWithClosureAnalysisKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 12:16'!blockExtent "^<Interval>"	^blockExtent! !!Parser methodsFor: 'expression types' stamp: 'eem 5/29/2008 09:36'!newMethodNode	^self encoder methodNodeClass new! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:58'!genStoreTemp: tempIndex	"See BlueBook page 596"	tempIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].	tempIndex < 64 ifTrue: 		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 129;			nextPut: 64 + tempIndex.		 ^self].	^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63! !!BlockNode methodsFor: 'accessing' stamp: 'eem 7/24/2008 12:37'!optimized	^optimized! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 16:55'!sizeCodeForValue: encoder	self generateAsClosure ifTrue:		[^self sizeCodeForClosureValue: encoder].	nArgsNode := encoder encodeLiteral: arguments size.	remoteCopyNode := encoder encodeSelector: #blockCopy:.	size := self sizeCodeForEvaluatedValue: encoder.	self returns ifFalse:		[size := size + encoder sizeReturnTopToCaller]. "endBlock"	arguments := arguments collect:  "Chance to prepare debugger remote temps"						[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size := size + (arg sizeCodeForStorePop: encoder)].	^encoder sizePushThisContext	 + (nArgsNode sizeCodeForValue: encoder) 	 + (remoteCopyNode sizeCode: encoder args: 1 super: false)	 + (encoder sizeJumpLong: size)	 + size! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:43'!sizeStoreLiteralVar: literalIndex	^self sizeOpcodeSelector: #genStoreLiteralVar: withArguments: {literalIndex}! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:24'!send: selector super: supered numArgs: numberArguments	"Send Message With Selector, selector, bytecode. The argument, 	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found in 	the top numArguments locations on the stack and the receiver just 	below them."	stackPointer := stackPointer - numberArguments! !!BytecodeAgnosticMethodNode methodsFor: 'debugger support' stamp: 'eem 6/21/2008 13:39'!blockExtentsToTempRefs	| blockExtentsToTempRefs methNode |	blockExtentsToTempRefs := encoder blockExtentsToTempRefs.	blockExtentsToTempRefs ifNil:		[methNode := sourceText					ifNil: "No source, use decompile string as source to map from"						[self parserClass new							encoderClass: encoder class;							parse: self decompileString							class: self methodClass]					ifNotNil: [self prepareForRegeneration.							 self].		methNode generate: #(0 0 0 0).  "set bytecodes to map to"		 blockExtentsToTempRefs := methNode encoder blockExtentsToTempRefs].	^blockExtentsToTempRefs! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:48'!genStoreInstVar: instVarIndex	"See BlueBook page 596"	(instVarIndex >= 0 and: [instVarIndex < 64]) ifTrue: 		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 129;			nextPut: instVarIndex.		 ^self].	self genStoreInstVarLong: instVarIndex! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genPushReceiver	"See BlueBook page 596"	"112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]"	stream nextPut: 112! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:00'!genPushTemp: tempIndex	"See BlueBook page 596"	tempIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].	tempIndex < 16 ifTrue: 		["16-31 	0001iiii 	Push Temporary Location #iiii"		 stream nextPut: 16 + tempIndex.		 ^self].	tempIndex < 64 ifTrue: 		["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 128;			nextPut: 64 + tempIndex.		 ^self].	^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 18:19'!emitCodeForLoadFor: aTempVariableNode stack: stack encoder: encoder	encoder supportsClosureOpcodes ifTrue:		[^self].	"Need to generate the first half of		tempVector at: index put: expr	 i.e. the push of tempVector and index."	super emitCodeForValue: stack encoder: encoder.	self emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder! !!ReturnNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:14'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	"Note we could do this:		scopeBlock ~~ rootNode block ifTrue:			[scopeBlock noteNonLocalReturn].	 and pass up the flag in <BlockNode>>>analyseTempsWithin:rootNode:	 which may be fast but may also screw up the debugger.  For now we	 consider clean blocks a premature optimization."	self flag: 'consider clean blocks'.	expr analyseTempsWithin: scopeBlock rootNode: rootNode! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisIfNilNotNil: aStream indent: level	self printWithClosureAnalysisReceiver: receiver ifNilReceiver on: aStream indent: level.	(arguments first isJust: NodeNil) ifTrue:		[^self printWithClosureAnalysisKeywords: #ifNotNil:				arguments: { arguments second }				on: aStream indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^self printWithClosureAnalysisKeywords: #ifNil:				arguments: { arguments first }				on: aStream indent: level].	^self printWithClosureAnalysisKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aStream indent: level! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:51'!genPushInstVarLong: instVarIndex	"See BlueBook page 596"	"See also MaybeContextInstanceVariableNode"	(instVarIndex >= 0 and: [instVarIndex < 256]) ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 64;			nextPut: instVarIndex.		 ^self].	^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:43'!sizePushLiteral: literalIndex	^self sizeOpcodeSelector: #genPushLiteral: withArguments: {literalIndex}! !!BlockNode methodsFor: 'printing' stamp: 'eem 9/23/2008 15:05'!printStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level := 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printCommentOn: aStream indent: level.			aStream crtab: level].	len := shown := statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown := 1 max: shown - 1]		ifFalse: ["should a trailing nil be printed or not? Not if it is an implicit result."				(arguments size = 0				and: [len >= 1				and: [(statements at: len) == NodeNil				and: [len = 1					or: [len > 1						and: [(statements at: len - 1) isMessageNode						and: [(statements at: len - 1) isNilIf]]]]]])					ifTrue: [shown := shown - 1]].	1 to: shown do: 		[:i | 		thisStatement := statements at: i.		thisStatement printOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 5/29/2008 15:51'!remoteNode	^remoteNode! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 6/14/2008 19:05'!blockExtentsToTempRefs	| blockExtentsToTempRefs |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempRefs := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempRefs			at: blockExtent			put: (locals collect:					[:local|					local isIndirectTempVector						ifTrue: [local remoteTemps collect:									[:remoteLocal| remoteLocal key]]						ifFalse: [local key]])].	^blockExtentsToTempRefs! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:53'!sizeCodeForEffect: encoder	^(self sizeCodeForValue: encoder) + encoder sizePop! !!UndeclaredVariableWarning methodsFor: 'initialize-release' stamp: 'eem 7/27/2008 17:37'!name: aString selector: aSymbolOrNil class: aBehavior	name := aString.	selector := aSymbolOrNil.	class := aBehavior! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:00'!genPushLiteral: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue: 		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 32 ifTrue: 		["32-63 	001iiiii 	Push Literal Constant #iiiii"		 stream nextPut: 32 + literalIndex.		 ^self].	literalIndex < 64 ifTrue: 		["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 128;			nextPut: 128 + literalIndex.		 ^self].	literalIndex < 256 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 96;			nextPut: literalIndex.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 10:55'!addWriteWithin: scopeBlock "<BlockNode>" at: location "<Integer>"	writingScopes ifNil: [writingScopes := Dictionary new].	(writingScopes at: scopeBlock ifAbsentPut: [Set new]) add: location! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 6/4/2008 14:45'!storeIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	self sawClosureBytecode.	self pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex; doStore: stack! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/22/2008 10:01'!closureCreationNode	closureCreationNode ifNil:		[closureCreationNode := LeafNode new									key: #closureCreationNode									code: nil].	^closureCreationNode! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 7/27/2008 16:19'!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimized].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 6/2/2008 14:14'!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment := encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit := arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimized.	^true! !!BlockNode methodsFor: 'initialize-release' stamp: 'eem 8/4/2008 14:12'!noteSourceRangeStart: start end: end encoder: encoder	"Note two source ranges for this node.  One is for the debugger	 and is of the last expression, the result of the block.  One is for	 source analysis and is for the entire block."	encoder		noteSourceRange: (start to: end)		forNode: self closureCreationNode.	startOfLastStatement		ifNil:			[encoder				noteSourceRange: (start to: end)				forNode: self]		ifNotNil:			[encoder				noteSourceRange: (startOfLastStatement to: end - 1)				forNode: self]! !!Decompiler methodsFor: 'private' stamp: 'eem 7/29/2008 17:41'!sawBlueBookBlock	constructor isForClosures ifTrue:		[constructor primitiveChangeClassTo: DecompilerConstructor new]! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 9/8/2008 18:22'!beBlockArg	argType := #block! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:41'!emitCodeForStorePop: stack encoder: encoder	self type ~= 1 ifTrue:		[self halt].	encoder genStorePopInstVar: index.	stack pop: 1! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 6/23/2008 10:55'!bindAndJuggle: name	"This is used to insert a new temp and reorcder temps on editing.	 It doesn't really work for closure compilation since we have multiple	 locations for temps.  Simply signal a reparse is necessary."	ReparseAfterSourceEditing signal! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:55'!genSendSuper: selectorLiteralIndex numArgs: nArgs	"See BlueBook page 596 (with exceptions for 132 & 134)"	nArgs < 0 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].	selectorLiteralIndex < 0 ifTrue:		[^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255].	(selectorLiteralIndex < 32 and: [nArgs < 8]) ifTrue: 		["	133 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk To Superclass With jjj Arguments"		 stream			nextPut: 133;			nextPut: ((nArgs bitShift: 5) + selectorLiteralIndex).		 ^self].	(selectorLiteralIndex <= 255 and: [nArgs <= 31]) ifTrue: 		["In Squeak V3			132 	10000100 jjjjjjjj kkkkkkkk 	Send Literal Selector #kkkkkkkk With jjjjjjjj Arguments		  is replaced by			132 	10000100 ooojjjjj kkkkkkkk				ooo = 0 => Send Literal Selector #kkkkkkkk With jjjjj Arguments				ooo = 1 => Send Literal Selector #kkkkkkkk To Superclass With jjjjj Arguments"		stream			nextPut: 132;			nextPut: 32 + nArgs;			nextPut: selectorLiteralIndex.		 ^self].	nArgs > 31 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31].	selectorLiteralIndex > 255 ifTrue: 		[^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255]! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 9/29/2008 14:45'!emitCodeForCase: stack encoder: encoder value: forValue	| braceNode sizeStream allReturn |	forValue ifFalse:		[^super emitCodeForEffect: stack encoder: encoder].	braceNode := arguments first.	sizeStream := ReadStream on: sizes.	receiver emitCodeForValue: stack encoder: encoder.	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last | | thenSize elseSize |		thenSize := sizeStream next.		elseSize := sizeStream next.		last ifFalse: [encoder genDup. stack push: 1].		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.		equalNode emitCode: stack args: 1 encoder: encoder.		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.		last ifFalse: [encoder genPop. stack pop: 1].		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse:			[self emitCodeForJump: elseSize encoder: encoder.			 allReturn := false].		(last and: [allReturn]) ifTrue:			[self emitCodeForJump: elseSize encoder: encoder]].	arguments size = 2		ifTrue:			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"		ifFalse:			[NodeSelf emitCodeForValue: stack encoder: encoder.			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/15/2008 09:06'!sizeReturnTopToCaller	^self sizeOpcodeSelector: #genReturnTopToCaller withArguments: #()! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:58'!genStorePopLiteralVar: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 64 ifTrue: 		["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 130;			nextPut: 192 + literalIndex.		 ^self].	literalIndex <= 255 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 224;			nextPut: literalIndex.		 self genPop.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 9/8/2008 18:21'!beMethodArg	argType := #method! !!Parser methodsFor: 'public access' stamp: 'eem 9/12/2008 13:34'!parse: sourceStreamOrString class: behavior	^ self parse: sourceStreamOrString readStream class: behavior		noPattern: false context: nil notifying: nil ifFail: [^nil]! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 9/8/2008 18:24'!isArg	^argType notNil! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 6/16/2008 09:43'!postNumberingProcessTemps: rootNode "<MethodNode>"	(temporaries isNil or: [temporaries isEmpty]) ifTrue:		["Add all arguments to the pool so that copiedValues can be computed during sizing."		 rootNode addLocalsToPool: arguments.		 ^self].	"A temp can be local (and copied if it is not written to after it is captured.	 A temp cannot be local if it is written to remotely.	 Need to enumerate a copy of the temporaries because any temps becoming remote	 will be removed from temporaries in analyseClosure: (and a single remote temp node	 will get added)"	temporaries copy do:		[:each| each analyseClosure: rootNode].	"Now we may have added a remoteTempNode.  So we need a statement to initialize it."	remoteTempNode ~~ nil ifTrue:		["statements isArray ifTrue:			[statements := statements asOrderedCollection]." "true for decompiled trees"		(statements notEmpty		 and: [statements first isAssignmentNode		 and: [statements first variable isTemp		 and: [statements first variable isIndirectTempVector]]])			ifTrue: "If this is a decompiled tree there already is a temp vector initialization node."				[statements first variable become: remoteTempNode]			ifFalse:				[statements addFirst: (remoteTempNode nodeToInitialize: rootNode encoder)]].	"Now add all arguments and locals to the pool so that copiedValues can be computed during sizing."	rootNode		addLocalsToPool: arguments;		addLocalsToPool: temporaries! !!EncoderForLongFormV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:10'!genPushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize	"143 	10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num Args kkkk BlockSize jjjjjjjjiiiiiiii"	(jumpSize < 0 or: [jumpSize > 65535]) ifTrue:		[^self outOfRangeError: 'block size' index: jumpSize range: 0 to: 65535].	(numCopied < 0 or: [numCopied > 15]) ifTrue:		[^self outOfRangeError: 'num copied' index: numCopied range: 0 to: 15].	(numArgs < 0 or: [numArgs > 15]) ifTrue:		[^self outOfRangeError: 'num args' index: numArgs range: 0 to: 15].	stream		nextPut: 143;		nextPut: numArgs + (numCopied bitShift: 4);		nextPut: (jumpSize bitShift: -8);		nextPut: (jumpSize bitAnd: 16rFF)! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/21/2008 11:36'!emitCodeForEvaluatedValue: stack encoder: encoder	| position |	position := stack position.	self emitCodeExceptLast: stack encoder: encoder.	statements last emitCodeForBlockValue: stack encoder: encoder.	self assert: stack position - 1 = position! !!MessageNode methodsFor: 'testing' stamp: 'eem 9/26/2008 12:39'!isReturningIf	^((special between: 3 and: 4) "ifTrue:ifFalse:/ifFalse:ifTrue:"	    or: [special between: 17 and: 18]) "ifNil:ifNotNil:/ifNotNil:ifNil:"		and: [arguments first returns and: [arguments last returns]]! !!SelectorNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:15'!sizeCode: encoder args: nArgs super: supered	self reserve: encoder.	^supered		ifTrue:			[code < Send "i.e. its a special selector" ifTrue:				[code := self code: (index := encoder sharableLitIndex: key) type: 5].			 encoder sizeSendSuper: index numArgs: nArgs]		ifFalse:			[self flag: #yuck. "special selector sends cause this problem"			 encoder				sizeSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!MessageNode methodsFor: 'equation translation' stamp: 'eem 9/25/2008 14:50'!eval	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"	| rec args |	receiver isVariableNode ifFalse: [^ #illegal].	rec := receiver key value.	args := arguments collect: [:each | each eval].	^ rec perform: selector key withArguments: args! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:06'!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^(encoder sizePushLiteralVar: index)	 + (writeNode sizeCode: encoder args: 1 super: false)! !!ReturnNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	^expr sizeCodeForReturn: encoder! !!BytecodeEncoder methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:52'!outOfRangeError: string index: index range: rangeStart to: rangeEnd	"For now..."	^self error: thisContext sender method selector, ' ', string				, ' index ', index printString				, ' is out of range ', rangeStart printString, ' to ', rangeEnd printString! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 10/20/2008 13:01'!codeRemoteTemp: index remoteTemps: tempVector	^(RemoteTempVectorNode new		name: '_r', index printString		index: index		type: LdTempType		scope: 0)			remoteTemps: tempVector;			yourself! !!Encoder methodsFor: 'results' stamp: 'eem 5/27/2008 12:07'!tempNodes 	| tempNodes |	tempNodes := SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].	scopeTable associationsDo:		[:assn |		assn value isArray			ifTrue: [assn value do: [:temp| tempNodes add: temp]]			ifFalse: [assn value isTemp ifTrue: [tempNodes add: assn value]]].	^tempNodes! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 09:52'!sizeCode: encoder forJump: dist	^dist = 0 ifTrue: [0] ifFalse: [encoder sizeJump: dist]! !!SelectorNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	self shouldNotImplement! !!Compiler methodsFor: 'public access' stamp: 'eem 5/15/2008 15:13'!parser	parser ifNil: [parser := self parserClass new].	^parser! !!Encoder methodsFor: 'results' stamp: 'eem 5/19/2008 10:34'!allLiterals	(literalStream isKindOf: WriteStream) ifTrue:		[self litIndex: nil.		 self litIndex: self associationForClass].	^literalStream contents! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/26/2008 11:36'!methodReturnReceiver	"Return Self bytecode."	self doJoin! !!InstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVar: index! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (new scheme)' stamp: 'eem 9/12/2008 11:00'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is the reference to the source code that is	 stored with every CompiledMethod."	| blkSize nLits literals stack method |	self generate: trailer ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := block sizeCodeForEvaluatedValue: encoder.	method := CompiledMethod				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments, temporaries.									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	stack position: method numTemps.	block emitCodeForEvaluatedValue: stack encoder: encoder.	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!BlockNode methodsFor: 'accessing' stamp: 'eem 6/2/2008 14:00'!addArgument: aTempVariableNode	temporaries := temporaries copyWith: aTempVariableNode! !!BlockNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:48'!printWithClosureAnalysisStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level := 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printCommentOn: aStream indent: level.			aStream crtab: level].	len := shown := statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown := 1 max: shown - 1]		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])					ifTrue: [shown := shown - 1]].	1 to: shown do: 		[:i | 		thisStatement := statements at: i.		thisStatement printWithClosureAnalysisOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!RegenerationPreparingVisitor methodsFor: 'visiting' stamp: 'eem 7/2/2008 12:18'!visitTempVariableNode: aTempNode	aTempNode cleanUpForRegeneration! !!TempVariableNode methodsFor: 'debugger access' stamp: 'eem 6/21/2008 13:32'!cleanUpForRegeneration	remoteNode := nil.	definingScope := writingScopes := readingScopes := nil! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	"Do nothing"! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:07'!emitCodeForValue: stack encoder: encoder	stack push: 1.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder genPushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder genPushReceiver].	code = LdThisContext ifTrue:		[^encoder genPushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder genPushInstVar: index! !!Encoder methodsFor: 'encoding' stamp: 'eem 7/27/2008 17:41'!undeclared: name	| sym |	requestor interactive ifTrue:		[requestor requestor == #error: ifTrue:			[requestor error: 'Undeclared'].		 ^self notify: 'Undeclared'].	"Allow knowlegeable clients to squash the undeclared warning if they want (e.g.	 Diffing pretty printers that are simply formatting text).  As this breaks	 compilation it should only be used by clients that want to discard the result	 of the compilation.  To squash the warning use e.g.		[Compiler format: code in: class notifying: nil decorated: false]			on: UndeclaredVariableWarning			do: [:ex| ex resume: false]"	sym := name asSymbol.	^(UndeclaredVariableWarning new name: name selector: selector class: class) signal		ifTrue:			[Undeclared at: sym put: nil.			self global: (Undeclared associationAt: sym) name: sym]		ifFalse:			[self global: (Association key: sym) name: sym]! !!MessageNode methodsFor: 'printing' stamp: 'eem 9/25/2008 14:53'!printWithClosureAnalysisParenReceiver: rcvr on: aStream indent: level						rcvr isBlockNode ifTrue:		[^rcvr printWithClosureAnalysisOn: aStream indent: level].	aStream nextPut: $(.	rcvr printWithClosureAnalysisOn: aStream indent: level.	aStream nextPut: $)! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/23/2008 21:52'!argumentsInEvaluationOrder	"Answer the receivers arguments in evaluation order.	 If the receiver is a transformed to:do: node this will undo the misordering done by the transformation."	^(special > 0	   and: [(MacroTransformers at: special) == #transformToDo:	   and: [arguments size >= 7]])		"arguments are in a weid order and may be nil in a transformed to:do: loop.  sigh...		 c.f. emitCodeForToDo:encoder:value:"		ifTrue:			[(arguments at: 7)	"limitInit"				ifNil: [{	(arguments at: 4).	"initStmt"						(arguments at: 5).	"test"						(arguments at: 3).	"block"						(arguments at: 6) 	"incStmt" }]				ifNotNil: [:limitInit|						{ limitInit.						(arguments at: 4).	"initStmt"						(arguments at: 5).	"test"						(arguments at: 3).	"block"						(arguments at: 6) 	"incStmt" }]]		ifFalse:			[arguments]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2008 14:10'!emitCodeForClosureValue: stack encoder: encoder	"if not supportsClosureOpcodes closureCreationSupportNode is the	 node for thisContext closureCopy: numArgs [ copiedValues: { values } ]"	encoder supportsClosureOpcodes		ifTrue:			[copiedValues do:				[:copiedValue| copiedValue emitCodeForValue: stack encoder: encoder].			 closureCreationNode pc: encoder methodStreamPosition + 1.			 encoder				genPushClosureCopyNumCopiedValues: copiedValues size				numArgs: arguments size				jumpSize: size.			 stack				pop: copiedValues size;				push: 1]		ifFalse:			[closureCreationNode emitCodeForValue: stack encoder: encoder.			 encoder genJumpLong: size]. "Force a two byte jump."	"Emit the body of the block"	self emitCodeForEvaluatedClosureValue: stack encoder: encoder! !!CascadeNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level precedence: p 	p > 0 ifTrue: [aStream nextPut: $(].	messages first printWithClosureAnalysisReceiver: receiver on: aStream indent: level.	1 to: messages size do: 		[:i | (messages at: i) printWithClosureAnalysisOn: aStream indent: level.		i < messages size ifTrue: 				[aStream nextPut: $;.				messages first precedence >= 2 ifTrue: [aStream crtab: level + 1]]].	p > 0 ifTrue: [aStream nextPut: $)]! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 9/8/2008 18:24'!bindBlockArg: name within: aBlockNode	"Read the comment in the superclass's method.	 If we have closures we should check the argument	 count against the block, not the method.	(Note that this isn't entirely adequate either since optimized blocks	 will slip through the cracks (their arguments (i.e. ifNotNil: [:expr|)	 are charged against their enclosing block, not themselves))."	| nArgs |	self supportsClosureOpcodes ifFalse:		[^super bindBlockArg: name within: aBlockNode].	(nArgs := aBlockNode nArgsSlot) isNil ifTrue:		[aBlockNode nArgsSlot: (nArgs := 0)].	nArgs  >= 15 ifTrue:		[^self notify: 'Too many arguments'].	aBlockNode nArgsSlot: nArgs + 1.	^(self bindTemp: name)		beBlockArg;		nowHasDef;		nowHasRef;		yourself! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 9/26/2008 15:43'!methodReturnTop	| last |	last := stack removeLast "test test" asReturnNode.	stack size > blockStackBase  "get effect of elided pop before return"		ifTrue: [statements addLast: stack removeLast].	exit := pc.	lastJumpPc := lastReturnPc := lastPc.	statements addLast: last! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/19/2008 17:17'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: (arguments at: 1) noteOptimized					with: (BlockNode withJust: NodeNil) noteOptimized.			^true]		ifFalse: 			[^false]! !!EncoderForLongFormV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:05'!genPushNewArray: size	(size < 0 or: [size > 127]) ifTrue:		[^self outOfRangeError: 'size' index: size range: 0 to: 127].	"138 	10001010 0kkkkkkk 	Push (Array new: kkkkkkk)"	stream		nextPut: 138;		nextPut: size! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 12:12'!noteBlockExit: aBlock	"Evaluate aBlock with the numbering for the block exit."	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!AssignmentNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level precedence: p	aStream nextPut: $(.	self printWithClosureAnalysisOn: aStream indent: level.	aStream nextPut: $)! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:38'!emitCodeForEffect: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genPop.	stack pop: 1! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForBlueBookInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForBlueBookInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForV3;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 6/16/2008 09:45'!genPushRemoteTemp: tempIndex inVectorAt: tempVectorIndex	(tempIndex >= 0 and: [tempIndex < 256	 and: [tempVectorIndex >= 0 and: [tempVectorIndex < 256]]]) ifTrue:		["140 	10001100 kkkkkkkk jjjjjjjj 	Push Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"		 stream			nextPut: 140;			nextPut: tempIndex;			nextPut: tempVectorIndex.		 ^self].	tempIndex >= 256 ifTrue:		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].	tempVectorIndex >= 256 ifTrue:		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255]! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/24/2008 12:35'!sizePushNewArray: size	^self sizeOpcodeSelector: #genPushNewArray: withArguments: {size}! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genDup	"See BlueBook page 596"	"136 	10001000 	Duplicate Stack Top"	stream nextPut: 136! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 14:53'!emitCodeForStore: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStoreInto: self stack: stack encoder: encoder].	encoder genStoreTemp: index! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:36'!sizeStorePopTemp: tempIndex	^self sizeOpcodeSelector: #genStorePopTemp: withArguments: {tempIndex}! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 14:00'!ifOptimizedBlockHoistTempsInto: scopeBlock "<BlockNode>"	"This is a No-op for all nodes except non-optimized BlockNodes."	"Let's assume the special > 0 guard in MessageNode>>analyseTempsWithin:forValue:encoder: is correct.	 Then we can simply hoist our temps up."	self assert: (arguments isNil or: [arguments size <= 1]).	(arguments notNil and: [arguments notEmpty]) ifTrue:		[scopeBlock addHoistedTemps: arguments.		arguments := #()].	temporaries notEmpty ifTrue:		[scopeBlock addHoistedTemps: temporaries.		temporaries := #()]! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:01'!genStorePopTemp: tempIndex	"See BlueBook page 596"	tempIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].	tempIndex < 8 ifTrue: 		["104-111 	01101iii 	Pop and Store Temporary Location #iii"		 stream nextPut: 104 + tempIndex.		 ^self].	tempIndex < 64 ifTrue: 		["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 130;			nextPut: 64 + tempIndex.		 ^self].	^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:12'!emitCodeForIf: stack encoder: encoder value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize := sizes at: 1.	elseSize := sizes at: 2.	(forValue not and: [elseSize * thenSize > 0]) ifTrue:		"Two-armed IFs forEffect share a single pop"		[^super emitCodeForEffect: stack encoder: encoder].	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	receiver emitCodeForValue: stack encoder: encoder.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.			pc := encoder methodStreamPosition.			thenExpr emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not ifTrue:				"...not ifTrue: avoids using ifFalse: alone during this compile)"				"Elide jump over else after a return"				[self emitCodeForJump: elseSize encoder: encoder].			elseExpr emitCodeForEvaluatedValue: stack encoder: encoder]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					thenExpr emitCodeForEvaluatedEffect: stack encoder: encoder]				ifFalse:					[self emitCodeForBranchOn: true dist: elseSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					elseExpr emitCodeForEvaluatedEffect: stack encoder: encoder]]! !!BytecodeAgnosticMethodNode methodsFor: 'debugger support' stamp: 'eem 6/20/2008 15:13'!prepareForRegeneration	"Closure methods need to remove any remote temps prior to being regenerated."	(temporaries notEmpty and: [temporaries last isIndirectTempVector]) ifTrue:		[temporaries := temporaries allButLast].	self accept: RegenerationPreparingVisitor new! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 20:45'!methodWithCopiedAndPostClosedOverAssignedTemps	| blk a b c r1 r2 |	a := 1.	b := 2.	c := 4.	blk := [a + b + c].	r1 := blk value.	b := nil.	r2 := blk value.	r1 -> r2	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedAndPostClosedOverAssignedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 5/30/2008 12:31'!scope	"Answer scope of temporary variables.	 Currently only the following distinctions are made:		 0	outer level: args and user-declared temps		 1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:"	^scope! !!Parser methodsFor: 'error handling' stamp: 'eem 9/25/2008 12:41'!notify: string at: location	requestor isNil		ifTrue: [(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxErrorNotification					inClass: encoder classEncoding					category: category					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag					errorMessage: string					location: location]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 13:43'!locationCounter	^locationCounter! !!BraceNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/30/2008 17:40'!emitCodeForValue: stack encoder: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].		 encoder genPushConsArray: elements size.		 stack			pop: elements size;			push: 1.		 ^self].	^emitNode emitCodeForValue: stack encoder: encoder! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 7/27/2008 00:39'!sizeOpcodeSelector: genSelector withArguments: args	stream := self.	position := 0.	self perform: genSelector withArguments: args.	^position! !!TempVariableNode methodsFor: 'decompiler' stamp: 'eem 9/25/2008 09:45'!remoteNode: aRemoteTempVectorNode	remoteNode := aRemoteTempVectorNode! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/26/2008 11:36'!methodReturnConstant: value 	"Return Constant bytecode."	self doJoin! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 9/25/2008 09:48'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	self sawClosureBytecode.	stack addLast: ((tempVars at: tempVectorIndex + 1) remoteTemps at: remoteTempIndex + 1)! !!SelectorNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level 	aStream nextPutAll: (key == nil							ifTrue: ['<key==nil>']							ifFalse: [key])! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:31'!emitCodeForToDo: stack encoder: encoder value: forValue 	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].	initStmt emitCodeForEffect: stack encoder: encoder.	test emitCodeForValue: stack encoder: encoder.	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.	pc := encoder methodStreamPosition.	block emitCodeForEvaluatedEffect: stack encoder: encoder.	incStmt emitCodeForEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/21/2008 11:24'!analyseClosure: rootNode "<MethodNode>"	"A temp cannot be local if it is written to remotely,	  or if it is written to after it is closed-over."	| latestWrite |	latestWrite := 0.	((writingScopes notNil	 and: [writingScopes associations anySatisfy: [:assoc|			[:blockScope :refs|			refs do: [:write| latestWrite := write max: latestWrite].			"A temp cannot be local if it is written to remotely."			blockScope ~~ definingScope]				value: assoc key value: assoc value]])	or: [readingScopes notNil		and: [readingScopes associations anySatisfy: [:assoc|				[:blockScope :refs|				 "A temp cannot be local if it is written to after it is closed-over."				 blockScope ~~ definingScope				 and: [refs anySatisfy: [:read| read < latestWrite]]]					value: assoc key value: assoc value]]]) ifTrue:		[remoteNode := definingScope addRemoteTemp: self rootNode: rootNode]! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 10:00'!sizeCodeForWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).	branchSize := self					sizeCode: encoder					forBranchOn: selector key == #whileFalse:  "Btp for whileFalse"					dist: stmtSize.	loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.	sizes := Array with: stmtSize with: loopSize.	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2008 14:11'!sizeCodeForClosureValue: encoder	"Compute the size for the creation of the block and its code."	"If we have the closure bytecodes constructClosureCreationNode: will note	 the copied values in the copiedValues inst var and answer #pushCopiedValues."	closureCreationNode := self constructClosureCreationNode: encoder.	"Remember size of body for emit time so we know the size of the jump around it."	size := self sizeCodeForEvaluatedClosureValue: encoder.	^encoder supportsClosureOpcodes		ifTrue:			[(copiedValues inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])			 + (encoder sizePushClosureCopyNumCopiedValues: copiedValues size numArgs: arguments size jumpSize: size)			 + size]		ifFalse:			["closureCreationSupportNode is send closureCopy:copiedValues:"			(closureCreationNode sizeCodeForValue: encoder)			 + (encoder sizeJumpLong: size)			 + size]! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:24'!methodWithOptimizedBlocksA	| s c |	s := self isNil			ifTrue: [| a | a := 'isNil'. a]			ifFalse: [| a | a := 'notNil'. a].	c := String new: s size.	1 to: s size do:		[:i| c at: i put: (s at: i)].	^c	"Parser new		parse: (self class sourceCodeAt: #methodWithOptimizedBlocksA)		class: self class"! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:19'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Remove Top Of Stack And Store Into Offset of Temp Vector bytecode."	stackPointer := stackPointer - 1! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 16:56'!supportTestSourceRangeAccessForInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	':= thisValue'								'do: [:each | nextValue := binaryBlock value: nextValue value: each]'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								']'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								']'								'^nextValue')! !!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 5/14/2008 17:49'!if: code isSpecialLiteralForReturn: aBlock	"If code is that of a special literal for return then evaluate aBlock with the special literal.	 The special literals for return are nil true false which have special encodings	 in the blue book bytecode set.  Answer whether it was a special literal."	^(code between: LdTrue and: LdNil)	   and: [aBlock value: (#(true false nil) at: code - LdSelf).			true]! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/26/2008 13:40'!jump: offset	"Unconditional Jump bytecode."	offset > 0 ifTrue:		[joinOffsets at: scanner pc + offset put: stackPointer.		 self doJoin]! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block"	^self emitCodeForValue: stack encoder: encoder! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/24/2008 23:02'!sizeStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex	^self sizeOpcodeSelector: #genStorePopRemoteTemp:inVectorAt: withArguments: {tempIndex. tempVectorIndex}! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 10:56'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	self addReadWithin: scopeBlock at: rootNode locationCounter! !!VariableNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level 	aStream nextPutAll: name! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 15:53'!copiedValuesWithinBlockExtent: anInterval 	^((localsPool select:		[:temp|		 temp isReferencedWithinBlockExtent: anInterval]) collect:			[:temp|			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]) asSortedCollection:				[:t1 :t2 |				t1 index < t2 index]! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:41'!emitCodeForReturn: stack encoder: encoder	encoder		if: code		isSpecialLiteralForReturn:			[:specialLiteral|			"short returns"			 encoder genReturnSpecialLiteral: specialLiteral.			 stack push: 1 "doesnt seem right".			 ^self].	(self code = LdSelf or: [self code = LdSuper]) ifTrue: 		["short returns"		 encoder genReturnReceiver.		 stack push: 1 "doesnt seem right".		 ^self].	super emitCodeForReturn: stack encoder: encoder! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:51'!genStoreInstVarLong: instVarIndex	"See BlueBook page 596"	"See also MaybeContextInstanceVariableNode"	(instVarIndex >= 0 and: [instVarIndex < 256]) ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 160;			nextPut: instVarIndex.		 ^self].	^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:22'!pushNewArrayOfSize: numElements 	"Push New Array of size numElements bytecode."	stackPointer := stackPointer + 1! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2008 10:04'!ensureClosureAnalysisDone	block blockExtent ifNil:		[temporaries := block analyseArguments: arguments temporaries: temporaries rootNode: self]! !!NewArrayNode methodsFor: 'code generation (closures)' stamp: 'eem 6/16/2008 09:31'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	"This is a no-op except in TempVariableNode"	^self! !!ParseNode methodsFor: 'code generation' stamp: 'eem 8/4/2008 13:57'!pc: anInteger	"Used by encoder source mapping."	pc := anInteger! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:02'!genStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex	"141 	10001101 kkkkkkkk jjjjjjjj 	Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"	(tempIndex >= 0 and: [tempIndex < 256	 and: [tempVectorIndex >= 0 and: [tempVectorIndex < 256]]]) ifTrue:		[stream			nextPut: 141;			nextPut: tempIndex;			nextPut: tempVectorIndex.		 ^self].	tempIndex >= 256 ifTrue:		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].	tempVectorIndex >= 256 ifTrue:		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255]! !!Encoder methodsFor: 'results' stamp: 'eem 5/19/2008 10:25'!associationForClass	| name assoc |	assoc := Smalltalk associationAt: class name ifAbsent:[nil].	assoc value == class ifTrue:[^assoc].	name := Smalltalk keyAtIdentityValue: class ifAbsent: [^Association new value: class].	^Smalltalk associationAt: name! !!Encoder methodsFor: 'accessing' stamp: 'eem 5/29/2008 09:36'!methodNodeClass	^MethodNode! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 16:21'!sizePushReceiver	^self sizeOpcodeSelector: #genPushReceiver withArguments: #()! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:01'!genStoreTemp: tempIndex	"See BlueBook page 596"	tempIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].	tempIndex < 64 ifTrue: 		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 129;			nextPut: 64 + tempIndex.		 ^self].	^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63! !!ParseNode methodsFor: 'code generation (closures)' stamp: 'eem 5/19/2008 16:54'!ifOptimizedBlockHoistTempsInto: scopeBlock "<BlockNode>" 	"This is a No-op for all nodes except non-optimized BlockNodes."	^self! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 14:51'!sizeCodeForValue: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForValueOf: self encoder: encoder].	self reserve: encoder.	^encoder sizePushTemp: index! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:44'!sizeStoreInstVar: instVarIndex	^self sizeOpcodeSelector: #genStoreInstVar: withArguments: {instVarIndex}! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 7/27/2008 18:50'!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifTrue:		[((caseNode blockAssociationCheck: encoder)		  and: [arguments size = 1			    or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder]]) ifFalse:			[^false].		 caseNode elements do:			[:messageNode|			messageNode receiver noteOptimized.			messageNode arguments first noteOptimized].		 arguments size = 2 ifTrue:			[arguments last noteOptimized].		 ^true].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not]) ifTrue:		[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisIfOn: aStream indent: level	receiver ifNotNil:		[receiver printWithClosureAnalysisOn: aStream indent: level + 1 precedence: precedence].	(arguments last isJust: NodeNil) ifTrue:		[^self printWithClosureAnalysisKeywords: #ifTrue: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments last isJust: NodeFalse) ifTrue:		[^self printWithClosureAnalysisKeywords: #and: arguments: (Array with: arguments first)					on: aStream indent: level].	(arguments first isJust: NodeNil) ifTrue:		[^self printWithClosureAnalysisKeywords: #ifFalse: arguments: (Array with: arguments last)					on: aStream indent: level].	(arguments first isJust: NodeTrue) ifTrue:		[^self printWithClosureAnalysisKeywords: #or: arguments: (Array with: arguments last)					on: aStream indent: level].	self printWithClosureAnalysisKeywords: #ifTrue:ifFalse: arguments: arguments					on: aStream indent: level! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 16:16'!genPushReceiver	"See BlueBook page 596"	"112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]"	stream nextPut: 112! !!DecompilerConstructor methodsFor: 'testing' stamp: 'eem 6/4/2008 14:41'!isForClosures	^false! !!InstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVar: index! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:21'!pushConsArrayWithElements: numElements	"Push Cons Array of size numElements popping numElements items from the stack into the array bytecode."	stackPointer := stackPointer - numElements + 1! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:37'!genStoreInstVar: instVarIndex	"See BlueBook page 596"	(instVarIndex >= 0 and: [instVarIndex < 64]) ifTrue: 		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 129;			nextPut: instVarIndex.		 ^self].	self genStoreInstVarLong: instVarIndex! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 10:43'!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 16:50'!isIndirectTempVector	^false! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 16:23'!sizeCodeForLoad: encoder	^remoteNode isNil		ifTrue: [0]		ifFalse: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:59'!genPushLiteralVar: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue: 		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 32 ifTrue: 		["64-95 	010iiiii 	Push Literal Variable #iiiii"		 stream nextPut: 64 + literalIndex.		 ^self].	literalIndex < 64 ifTrue: 		["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 128;			nextPut: 192 + literalIndex.		 ^self].	literalIndex < 256 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 128;			nextPut: literalIndex.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:51'!genPushInstVarLong: instVarIndex	"See BlueBook page 596"	"See also MaybeContextInstanceVariableNode"	(instVarIndex >= 0 and: [instVarIndex < 256]) ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 64;			nextPut: instVarIndex.		 ^self].	^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:36'!emitCodeForWhile: stack encoder: encoder value: forValue 	"L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := sizes at: 1.	loopSize := sizes at: 2.	cond emitCodeForEvaluatedValue: stack encoder: encoder.	self emitCodeForBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"	pc := encoder methodStreamPosition.	stmt emitCodeForEvaluatedEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!BraceNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level	aStream nextPut: ${.	1 to: elements size do: 		[:i | (elements at: i) printWithClosureAnalysisOn: aStream indent: level.		i < elements size ifTrue: [aStream nextPutAll: '. ']].	aStream nextPut: $}! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 18:20'!sizeCodeForIndexOf: aTempVariableNode encoder: encoder	self assert: encoder supportsClosureOpcodes not.	^(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode)) sizeCodeForValue: encoder! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:40'!sizeJump: distance	^self sizeOpcodeSelector: #genJump: withArguments: {distance}! !!BlockNode methodsFor: 'accessing' stamp: 'eem 5/30/2008 12:12'!nArgsSlot	"Private for the Encoder to use in bindArg"	^nArgsNode! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:22'!pushReceiver	"Push Active Context's Receiver on Top Of Stack bytecode."	stackPointer := stackPointer + 1! !!VariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/21/2008 16:15'!beingAssignedToAnalyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	"No-op overridden by TempVariableNode"! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genPushThisContext	"See BlueBook page 596"	"137 	10001001 	Push Active Context"	stream nextPut: 137! !!Decompiler methodsFor: 'private' stamp: 'eem 6/4/2008 14:43'!sawClosureBytecode	constructor isForClosures ifFalse:		[constructor primitiveChangeClassTo: DecompilerConstructorForClosures new]! !!NewArrayNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/25/2008 14:58'!sizeCodeForValue: encoder	^encoder sizePushNewArray: numElements! !!BytecodeEncoder methodsFor: 'initialize-release' stamp: 'eem 7/24/2008 17:24'!streamToMethod: aCompiledMethod	stream := WriteStream with: aCompiledMethod.	stream position: aCompiledMethod initialPC - 1! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:34'!sizeReturnTop	^self sizeOpcodeSelector: #genReturnTop withArguments: #()! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genReturnTop	"See BlueBook page 596"	"124-125 	0111110i 	Return Stack Top From (Message, Block) [i]"	stream nextPut: 124! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 9/8/2008 18:20'!isMethodArg	^#method == argType! !!MessageNode methodsFor: 'code generation (closures)' stamp: 'eem 7/27/2008 19:10'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	special > 0 ifTrue:		[receiver ifOptimizedBlockHoistTempsInto: scopeBlock.		 "caseOf: is complicated.  We need to handle it specially.		  The cases are within a BraceNode where each case is of the form			[guard block] -> [action block]"		 (selector key beginsWith: 'caseOf:') ifTrue:			[arguments first elements do:				[:messageNode|				messageNode receiver ifOptimizedBlockHoistTempsInto: scopeBlock.				messageNode arguments first ifOptimizedBlockHoistTempsInto: scopeBlock]].		 arguments do:			[:node|			node == nil ifFalse: "last argument of optimized to:do: can be nil"				[node ifOptimizedBlockHoistTempsInto: scopeBlock]]].	"receiver is nil in cascades"	receiver == nil ifFalse:		[receiver analyseTempsWithin: scopeBlock rootNode: rootNode].	arguments do:		[:node|		node == nil ifFalse: "last argument of optimized to:do: can be nil"			[node analyseTempsWithin: scopeBlock rootNode: rootNode]]! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:20'!popIntoTemporaryVariable: offset 	"Remove Top Of Stack And Store Into Temporary Variable bytecode."	stackPointer := stackPointer - 1! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:16'!sizeCodeForEffect: encoder	special > 0 		ifTrue: [^self perform: (NewStyleMacroSizers at: special) with: encoder with: false].	^super sizeCodeForEffect: encoder! !!Parser methodsFor: 'expression types' stamp: 'eem 5/30/2008 11:51'!statements: argNodes innerBlock: inner	^self statements: argNodes innerBlock: inner blockNode: BlockNode new! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/29/2008 15:21'!sizeCodeExceptLast: encoder	| codeSize |	codeSize := 0.	1 to: statements size - 1 do: 		[:i | | statement |		 statement := statements at: i.		 codeSize := codeSize + (statement sizeCodeForEffect: encoder)].	^codeSize! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 9/25/2008 17:16'!nodeToInitialize: encoder	^AssignmentNode new		variable: self		value: (encoder supportsClosureOpcodes					ifTrue: [NewArrayNode new numElements: remoteTemps size]					ifFalse:						[MessageNode new							receiver: (encoder encodeVariable: 'Array')							selector: #new:							arguments: (Array with: (encoder encodeLiteral: remoteTemps size))							precedence: 3							from: encoder])! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:37'!emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder	stack pop: 1.	dist = 0 ifTrue: [^encoder genPop].	condition		ifTrue: [encoder genBranchPopTrue: dist]		ifFalse: [encoder genBranchPopFalse: dist]! !!CascadeNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 09:41'!emitCodeForValue: stack encoder: encoder	receiver emitCodeForValue: stack encoder: encoder.	1 to: messages size - 1 do: 		[:i | 		encoder genDup.		stack push: 1.		(messages at: i) emitCodeForValue: stack encoder: encoder.		encoder genPop.		stack pop: 1].	messages last emitCodeForValue: stack encoder: encoder! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 09:57'!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector key == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector key == theSelector 					dist: theSize)				+ theSize]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/12/2008 10:55'!emitCodeForEvaluatedClosureValue: stack encoder: encoder	| position |	position := stack position.	stack position: arguments size + copiedValues size.	temporaries size timesRepeat:		[NodeNil emitCodeForValue: stack encoder: encoder].	self		reindexingLocalsDo: [self emitCodeForEvaluatedValue: stack encoder: encoder]		encoder: encoder.	self returns ifFalse:		[encoder genReturnTopToCaller.		 pc := encoder methodStreamPosition].	stack position: position! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:01'!genStorePopLiteralVar: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 64 ifTrue: 		["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 130;			nextPut: 192 + literalIndex.		 ^self].	literalIndex < 256 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 224;			nextPut: literalIndex.		 self genPop.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!Decompiler methodsFor: 'private' stamp: 'eem 9/6/2008 08:45'!blockScopeRefersOnlyOnceToTemp: offset	| nRefs byteCode extension scanner scan |	scanner := InstructionStream on: method.	nRefs := 0.	scan := offset <= 15				ifTrue:					[byteCode := 16 + offset.					 [:instr |					  instr = byteCode ifTrue:						[nRefs := nRefs + 1].					  nRefs > 1]]				ifFalse:					[extension := 64 + offset.					 [:instr |					  (instr = 128 and: [scanner followingByte = extension]) ifTrue:						[nRefs := nRefs + 1].					   nRefs > 1]].	self scanBlockScopeFor: pc from: method initialPC to: method endPC with: scan scanner: scanner.	^nRefs = 1! !!BlockNode methodsFor: 'printing' stamp: 'eem 6/2/2008 12:06'!printWithClosureAnalysisArgumentsOn: aStream indent: level	arguments size = 0 ifTrue: [^self].	arguments do:		[:tempNode |		 aStream space; nextPut: $:.		 tempNode printDefinitionForClosureAnalysisOn: aStream].	aStream nextPut: $|; space.	"If >0 args and >1 statement, put all statements on separate lines"	statements size > 1 ifTrue:		[aStream crtab: level]! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/26/2008 11:36'!blockReturnTop	"Return Top Of Stack bytecode."	stackPointer := stackPointer - 1.	scanner pc < blockEnd ifTrue:		[self doJoin]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 11:40'!testSourceRangeAccessForInjectInto	"Test debugger source range selection for inject:into: for the current version of the method"	"self new testSourceRangeAccessForInjectInto"	self supportTestSourceRangeAccessForInjectInto: (Collection compiledMethodAt: #inject:into:)		source: (Collection sourceCodeAt: #inject:into:) asString! !!TempVariableNode methodsFor: 'printing' stamp: 'eem 7/23/2008 21:21'!printDefinitionForClosureAnalysisOn: aStream 	| refs |	aStream		nextPut: ${;		nextPutAll: key.	definingScope ifNotNil: [definingScope blockExtent ifNotNil: [:be| aStream nextPutAll: ' d@'; print: be first]].	readingScopes notNil ifTrue:		[refs := Set new.		readingScopes do: [:elems| refs addAll: elems].		refs asSortedCollection do: [:read| aStream nextPutAll: ' r@'; print: read]].	writingScopes notNil ifTrue:		[refs := Set new.		writingScopes do: [:elems| refs addAll: elems].		refs asSortedCollection do: [:write| aStream nextPutAll: ' w@'; print: write]].	aStream nextPut: $}! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 16:58'!supportTestSourceRangeAccessForDecompiledInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	':= t1'								'do: [:t4 | t3 := t2 value: t3 value: t4]'								'value: t3 value: t4'								':= t2 value: t3 value: t4'								']'								'value: t3 value: t4'								':= t2 value: t3 value: t4'								']'								'^t3')! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:52'!genBranchPopFalse: distance	"See BlueBook page 596"	distance < 0 ifTrue:		[^self outOfRangeError: 'distance' index: distance range: 0 to: 1023].	distance < 1024 ifTrue:		["172-175 	101011ii jjjjjjjj 	Pop and Jump On False ii *256+jjjjjjjj"		 stream			nextPut: 172 + (distance bitShift: -8);			nextPut: distance + 1024 \\ 256.		 ^self].	^self outOfRangeError: 'distance' index: distance range: 0 to: 1023! !!AssignmentNode methodsFor: 'code generation (new scheme)' stamp: 'eem 6/4/2008 11:27'!emitCodeForValue: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStore: stack encoder: encoder! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genPop	"See BlueBook page 596"	"135 	10000111 	Pop Stack Top"	stream nextPut: 135! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 23:02'!emitCodeForStoreInto: aTempVariableNode stack: stack encoder: encoder	encoder supportsClosureOpcodes		ifTrue:			[encoder				genStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1				inVectorAt: index]		ifFalse:			[writeNode				emitCode: stack				args: 2				encoder: encoder				super: false]! !!BlockLocalTempCounter class methodsFor: 'instance creation' stamp: 'eem 9/23/2008 16:07'!tempCountForBlockAt: pc in: method	^self new tempCountForBlockAt: pc in: method! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/21/2008 11:28'!emitCodeForEvaluatedEffect: stack encoder: encoder	| position |	position := stack position.	self returns		ifTrue: 			[self emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1]		ifFalse: 			[self emitCodeExceptLast: stack encoder: encoder.			statements last emitCodeForEffect: stack encoder: encoder].	self assert: stack position = position! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/4/2008 10:48'!startOfLastStatement	^startOfLastStatement! !!BlockNode methodsFor: 'accessing' stamp: 'eem 7/27/2008 15:57'!temporaries	^temporaries! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 6/20/2008 15:11'!analyseArguments: methodArguments temporaries: methodTemporaries rootNode: rootNode "<MethodNode>" "^<Sequence of: <TempVarNade>>"	"Top level entry-point for analysing temps within the hierarchy of blocks in the receiver's method.	 Answer the (possibly modified) sequence of temp vars.	 Need to hoist temps out of macro-optimized blocks into their actual blocks.	 Need to note reads and writes to temps from blocks other than their actual blocks to determine	 whether blocks can be local (simple slots within a block/method context) or remote (slots in	 indirection vectors that are shared between contexts by sharing indirection vectors).	 The algorithm is based on numbering temporary reads and writes and block extents.	 The index used for numbering starts at zero and is incremented on every block entry	 and block exit.  So the following		| a b blk r1 r2 t |		a := 1. b := 2. t := 0.		blk := [ | s | s := a + b. t := t + s].		r1 := blk value.		b := -100.		r2 := blk value.		r1 -> r2 -> t	is numbered as		method block 0 to: 6:		| a b blk r1 r2 t |		a w@1 := 1. b w@1 := 2. t w@1 := 0.		blk w@5 := [entry@2 | s |					 t  w@3 := t r@3 + a r@3 + b r@3					] exit@4.		r1 w@5 := blk r@5 value.		b w@5 := nil.		r2 w@5 := blk r@5 value.		r1 r@5 -> r2 r@5 -> t r@5	So:		b and blk cannot be copied because fpr both there exists a write @5 that follows a			read @4 within block 2 through 4		t must be remote because there exists a write @3 within block (2 to: 4)"	self assert: (arguments isEmpty or: [arguments hasEqualElements: methodArguments]).	arguments := methodArguments asArray. "won't change"	self assert: (temporaries isNil or: [temporaries isEmpty or: [temporaries hasEqualElements: methodTemporaries]]).	temporaries := OrderedCollection withAll: methodTemporaries.	self assert: optimized not. "the top-level block should not be optimized."	self analyseTempsWithin: self rootNode: rootNode.	"The top-level block needs to reindex temporaries since analysis may have rearranged them.	 This happens during sizing for nested blocks."	temporaries withIndexDo:		[:temp :offsetPlusOne| temp index: arguments size + offsetPlusOne - 1].	"Answer the (possibly modified) sequence of temps."	^temporaries asArray! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genPushSpecialLiteral: aLiteral	"112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]"	| index |	index := #(true false nil -1 0 1 2) indexOf: aLiteral ifAbsent: 0.	index = 0 ifTrue:		[^self error: 'push special literal: ', aLiteral printString,  ' is not one of true false nil -1 0 1 2'].	stream nextPut: index + 112! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 9/29/2008 19:23'!send: selector super: superFlag numArgs: numArgs	| args rcvr selNode msgNode messages |	args := Array new: numArgs.	(numArgs to: 1 by: -1) do:		[:i | args at: i put: stack removeLast].	rcvr := stack removeLast.	superFlag ifTrue: [rcvr := constructor codeSuper].	((#(blockCopy: closureCopy:copiedValues:) includes: selector)	  and: [self checkForBlock: rcvr selector: selector arguments: args]) ifFalse:		[selNode := constructor codeAnySelector: selector.		rcvr == CascadeFlag			ifTrue:				["May actually be a cascade or an ifNil: for value."				self willJumpIfFalse					ifTrue: "= generated by a case macro"						[selector == #= ifTrue:							[" = signals a case statement..."							statements addLast: args first.							stack addLast: rcvr. "restore CascadeFlag"							^ self].						selector == #== ifTrue:							[" == signals an ifNil: for value..."							stack removeLast; removeLast.							rcvr := stack removeLast.							stack addLast: IfNilFlag;								addLast: (constructor									codeMessage: rcvr									selector: selNode									arguments: args).							^ self]]					ifFalse:						[(self willJumpIfTrue and: [selector == #==]) ifTrue:							[" == signals an ifNotNil: for value..."							stack removeLast; removeLast.							rcvr := stack removeLast.							stack addLast: IfNilFlag;								addLast: (constructor									codeMessage: rcvr									selector: selNode									arguments: args).							^ self]].				msgNode := constructor								codeCascadedMessage: selNode								arguments: args.				stack last == CascadeFlag ifFalse:					["Last message of a cascade"					statements addLast: msgNode.					messages := self popTo: stack removeLast.  "Depth saved by first dup"					msgNode := constructor									codeCascade: stack removeLast									messages: messages]]			ifFalse:				[msgNode := constructor							codeMessage: rcvr							selector: selNode							arguments: args].		stack addLast: msgNode]! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:00'!genSendSuper: selectorLiteralIndex numArgs: nArgs	"See BlueBook page 596 (with exceptions for 132 & 134)"	nArgs < 0 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].	selectorLiteralIndex < 0 ifTrue:		[^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255].	(selectorLiteralIndex < 32 and: [nArgs < 8]) ifTrue: 		["	133 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk To Superclass With jjj Arguments"		 stream			nextPut: 133;			nextPut: ((nArgs bitShift: 5) + selectorLiteralIndex).		 ^self].	(selectorLiteralIndex < 256 and: [nArgs < 32]) ifTrue: 		["In Squeak V3			132 	10000100 jjjjjjjj kkkkkkkk 	Send Literal Selector #kkkkkkkk With jjjjjjjj Arguments		  is replaced by			132 	10000100 ooojjjjj kkkkkkkk				ooo = 0 => Send Literal Selector #kkkkkkkk With jjjjj Arguments				ooo = 1 => Send Literal Selector #kkkkkkkk To Superclass With jjjjj Arguments"		stream			nextPut: 132;			nextPut: 32 + nArgs;			nextPut: selectorLiteralIndex.		 ^self].	nArgs >= 32 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31].	selectorLiteralIndex >= 256 ifTrue: 		[^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255]! !!Compiler methodsFor: 'public access' stamp: 'eem 5/15/2008 15:07'!parser: aParser	parser := aParser! !!ParseNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level precedence: p	self printWithClosureAnalysisOn: aStream indent: level! !!MethodNode methodsFor: 'code generation' stamp: 'eem 9/25/2008 15:20'!selectorNode	"Answer a SelectorNode for the message selector of the method represented by the receiver."	^(selectorOrFalse isMemberOf: SelectorNode)		ifTrue: [selectorOrFalse]		ifFalse: [SelectorNode new key: selectorOrFalse]! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:58'!sizeCodeForReturn: encoder	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizeReturnSpecialLiteral: specialLiteral].	(self code = LdSelf or: [self code = LdSuper]) ifTrue:		[^encoder sizeReturnReceiver].	^super sizeCodeForReturn: encoder! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/31/2008 14:31'!sizeCodeForEvaluatedClosureValue: encoder	"The closure value primitives push the arguments and the copied values.	 The compiler guarantees that any copied values come before all local temps.	 So on closure activation we only need to push nils for the remaining temporaries."	^temporaries size * (NodeNil sizeCodeForValue: encoder)	+ (self		reindexingLocalsDo: [self sizeCodeForEvaluatedValue: encoder]		encoder: nil "don't store temps yet")	+ (self returns ifTrue: [0] ifFalse: [encoder sizeReturnTopToCaller])! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:38'!sizeReturnSpecialLiteral: specialLiteral	^self sizeOpcodeSelector: #genReturnSpecialLiteral: withArguments: {specialLiteral}! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:19'!popIntoReceiverVariable: offset 	"Remove Top Of Stack And Store Into Instance Variable bytecode."	stackPointer := stackPointer - 1! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:03'!sizeCodeForValue: encoder	self reserve: encoder.	^encoder sizePushLiteralVar: index! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:17'!sizeCodeForValue: encoder	| total argSize |	special > 0 		ifTrue: [^self perform: (NewStyleMacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector := selector copy "only necess for splOops"].	total := selector sizeCode: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total := total + (receiver sizeCodeForValue: encoder)].	sizes := arguments collect: 					[:arg | 					argSize := arg sizeCodeForValue: encoder.					total := total + argSize.					argSize].	^total! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:43'!sizePushLiteralVar: literalIndex	^self sizeOpcodeSelector: #genPushLiteralVar: withArguments: {literalIndex}! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:39'!emitCodeForJump: dist encoder: encoder	dist = 0 ifFalse: [encoder genJump: dist]! !!RemoteTempVectorNode methodsFor: 'debugger access' stamp: 'eem 6/21/2008 13:34'!cleanUpForRegeneration	super cleanUpForRegeneration.	remoteTemps := nil! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/26/2008 13:40'!jump: offset if: condition 	"Conditional Jump bytecode."	stackPointer := stackPointer - 1.	offset > 0 ifTrue:		[joinOffsets at: scanner pc + offset put: stackPointer]! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/19/2008 15:09'!sizeCodeForToDo: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize initSize limitInit |	block := arguments at: 3.	initStmt := arguments at: 4.	test := arguments at: 5.	incStmt := arguments at: 6.	limitInit := arguments at: 7.	initSize := initStmt sizeCodeForEffect: encoder.	limitInit == nil ifFalse:		[initSize := initSize + (limitInit sizeCodeForEffect: encoder)].	blockSize := (block sizeCodeForEvaluatedEffect: encoder)			+ (incStmt sizeCodeForEffect: encoder)			+ (encoder sizeJumpLong: -1).	loopSize := (test sizeCodeForValue: encoder)			+ (self sizeCode: encoder forBranchOn: false dist: blockSize)			+ blockSize.	sizes := Array with: blockSize with: loopSize.	^initSize	+ loopSize	+ (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/24/2008 23:02'!sizeStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex	^self sizeOpcodeSelector: #genStoreRemoteTemp:inVectorAt: withArguments: {tempIndex. tempVectorIndex}! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:13'!doDup	"Duplicate Top Of Stack bytecode."	stackPointer := stackPointer + 1! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'eem 5/21/2008 13:28'!codeArguments: args temps: temps block: block 	block		arguments: args;		temporaries: temps.	^block! !!BraceNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 17:22'!maxElementsForConsArray	"Hack; we have no way of knowing how much stack space is available during sizing"	^8! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genReturnTopToCaller	"See BlueBook page 596"	"124-125 	0111110i 	Return Stack Top From (Message, Block) [i]"	stream nextPut: 125! !!Compiler methodsFor: 'private' stamp: 'stephaneducassse 11/5/2005 16:39'!interactive	"this version of the method is necessary to load code from MC else the interactive mode is one. 	This method is really bad since it links the compiler package with the Tools	one. The solution would be to have a real SyntaxError exception belonging to the 	compiler package and not a subclass of StringHolder - sd Nov 2005"	"the code submitted by PlusTools is ideally the one that should be used	interactive	      ^requestor ~~ nil "		^ (requestor == nil or: [requestor isKindOf: SyntaxError]) not! !!NewArrayNode methodsFor: 'accessing' stamp: 'eem 5/25/2008 14:59'!numElements: n	numElements := n! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 09:45'!sizeCodeForLoad: encoder	^writeNode ifNil: [0] ifNotNil: [encoder sizePushLiteral: index]! !!Decompiler methodsFor: 'control' stamp: 'eem 7/29/2008 17:42'!checkForBlockCopy: receiver	"We just saw a blockCopy: message. Check for a following block."	| savePc jump args argPos block |	receiver == constructor codeThisContext ifFalse: [^false].	savePc := pc.	(jump := self interpretJump) ifNil:		[pc := savePc.  ^false].	self sawBlueBookBlock.	"Definitely a block"	jump := jump + pc.	argPos := statements size.	[self willStorePop]		whileTrue:			[stack addLast: ArgumentFlag.  "Flag for doStore:"			self interpretNextInstructionFor: self].	args := Array new: statements size - argPos.	1 to: args size do:  "Retrieve args"		[:i | args at: i put: statements removeLast.		(args at: i) scope: -1  "flag args as block temps"].	block := self blockTo: jump.	stack addLast: (constructor codeArguments: args block: block).	^true! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:46'!genPushInstVar: instVarIndex	"See BlueBook page 596"	(instVarIndex >= 0 and: [instVarIndex < 64]) ifTrue: 		["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 128;			nextPut: instVarIndex.		 ^self].	self genPushInstVarLong: instVarIndex! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/4/2008 10:50'!startOfLastStatement: anInteger	"Note the source index of the start of the last full statement.  The	 last full statement is the value answered by a block and hence the	 expression the debugger should display as the value of the block."	startOfLastStatement := anInteger! !!BytecodeEncoder methodsFor: 'special literal encodings' stamp: 'eem 5/14/2008 16:02'!if: code isSpecialLiteralForPush: aBlock	"If code is that of a special literal for push then evaluate aBlock with the special literal	 The special literals for push are nil true false -1 0 1 & 2 which have special encodings	 in the blue book bytecode set.  Answer whether it was a special literal."	^(code between: LdTrue and: LdNil + 4)	    and: [aBlock value: (#(true false nil -1 0 1 2) at: code - LdSelf).			true]! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:13'!emitCodeForEffect: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (NewStyleMacroEmitters at: special) with: stack with: encoder with: false]		ifFalse: 			[super emitCodeForEffect: stack encoder: encoder]! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 18:19'!sizeCodeForLoadFor: aTempVariableNode encoder: encoder	encoder supportsClosureOpcodes ifTrue:		[^0].	"Need to size the first half of		tempVector at: index put: expr	 i.e. the push of tempVector and index."	^(super sizeCodeForValue: encoder)	+ (self sizeCodeForIndexOf: aTempVariableNode encoder: encoder)! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStorePop: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStorePopInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStorePopTemp: index! !!Compiler methodsFor: 'error handling' stamp: 'eem 9/25/2008 12:41'!notify: aString at: location	"Refer to the comment in Object|notify:."	^requestor == nil		ifTrue: [SyntaxErrorNotification					inClass: class					category: category					withCode: 						(sourceStream contents							copyReplaceFrom: location							to: location - 1							with: aString)					doitFlag: false					errorMessage: aString					location: location]		ifFalse: [requestor					notify: aString					at: location					in: sourceStream]! !!InstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVar: index! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 9/10/2008 10:04'!assignmentCheck: encoder at: location	^((self isBlockArg and: [Preferences allowBlockArgumentAssignment not])	    or: [self isMethodArg])			ifTrue: [location]			ifFalse: [-1]! !!LiteralNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:19'!emitCodeForValue: stack encoder: encoder	stack push: 1.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 encoder genPushSpecialLiteral: specialLiteral])		ifFalse:			[encoder genPushLiteral: index]! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStore: encoder	self shouldNotImplement! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 7/27/2008 00:39'!nextPut: aByte	"For sizing make the encoder its own stream and	 keep track of position with this version of nextPut:"	position := position + 1! !!BlockNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:54'!printWithClosureAnalysisTemporariesOn: aStream indent: level	(temporaries == nil or: [temporaries size = 0]) ifFalse:		[aStream nextPut: $|.		temporaries do: 			[:tempNode |			 aStream space.			 tempNode printDefinitionForClosureAnalysisOn: aStream].		aStream nextPutAll: ' | '.		"If >0 args and >1 statement, put all statements on separate lines"		statements size > 1 ifTrue: [aStream crtab: level]]! !!BlockLocalTempCounter methodsFor: 'private' stamp: 'eem 9/26/2008 13:40'!doJoin	scanner pc < blockEnd ifTrue:		[stackPointer := joinOffsets at: scanner pc]! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 16:55'!emitCodeForValue: stack encoder: encoder	self generateAsClosure ifTrue:		[^self emitCodeForClosureValue: stack encoder: encoder].	encoder genPushThisContext.	stack push: 1.	nArgsNode emitCodeForValue: stack encoder: encoder.	remoteCopyNode		emitCode: stack		args: 1		encoder: encoder.	"Force a two byte jump."	encoder genJumpLong: size.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitCodeForStorePop: stack encoder: encoder].	self emitCodeForEvaluatedValue: stack encoder: encoder.	self returns ifFalse:		[encoder genReturnTopToCaller.		pc := encoder methodStreamPosition].	stack pop: 1! !!CascadeNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level	self printWithClosureAnalysisOn: aStream indent: level precedence: 0! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/30/2008 16:46'!sizePushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize	^self		sizeOpcodeSelector: #genPushClosureCopyNumCopiedValues:numArgs:jumpSize:		withArguments: {numCopied. numArgs. jumpSize}! !!Compiler class methodsFor: 'accessing' stamp: 'eem 5/15/2008 15:12'!new	^ super new parser: self parserClass new! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/15/2008 10:20'!sizeStorePopLiteralVar: literalIndex	^self sizeOpcodeSelector: #genStorePopLiteralVar: withArguments: {literalIndex}! !!MessageNode methodsFor: 'printing' stamp: 'eem 9/25/2008 14:51'!printParenReceiver: rcvr on: aStream indent: level						rcvr isBlockNode ifTrue:		[^rcvr printOn: aStream indent: level].	aStream nextPut: $(.	rcvr printOn: aStream indent: level.	aStream nextPut: $)! !!NewArrayNode methodsFor: 'accessing' stamp: 'eem 5/25/2008 14:58'!numElements	^numElements! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisWhileOn: aStream indent: level	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.	(arguments isEmpty not	 and: [arguments first isJust: NodeNil]) ifTrue:			[selector := SelectorNode new							key:									(selector key == #whileTrue:										ifTrue: [#whileTrue]										ifFalse: [#whileFalse])							code: #macro.			arguments := Array new].	self printWithClosureAnalysisKeywords: selector key arguments: arguments		on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'eem 9/25/2008 14:51'!printWithClosureAnalysisKeywords: key arguments: args on: aStream indent: level	| keywords indent arg kwd doCrTab |	args size = 0 ifTrue: [aStream space; nextPutAll: key. ^self].	keywords := key keywords.	doCrTab := args size > 2				or: [{receiver} , args anySatisfy:						[:thisArg |						thisArg isBlockNode						or: [thisArg isMessageNode and: [thisArg precedence >= 3]]]].	1 to: (args size min: keywords size) do:		[:i |		arg := args at: i.		kwd := keywords at: i.		doCrTab			ifTrue: [aStream crtab: level+1. indent := 1] "newline after big args"			ifFalse: [aStream space. indent := 0].		aStream nextPutAll: kwd; space.		arg printWithClosureAnalysisOn: aStream			indent: level + 1 + indent			precedence: (precedence = 2 ifTrue: [1] ifFalse: [precedence])]! !!AssignmentNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level 	variable printWithClosureAnalysisOn: aStream indent: level.	aStream nextPutAll: ' := '.	value printWithClosureAnalysisOn: aStream indent: level + 2! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 9/8/2008 10:47'!scope	"Answer scope of temporary variables.	 Currently only the following distinctions are made:		 0	outer level: args and user-declared temps		 1	block args and doLimiT temps		-1	a block temp that is no longer active		-2	a block temp that held limit of to:do:		-3	an indirect temp vector"	^-3! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 09:40'!genDup	"See BlueBook page 596"	"136 	10001000 	Duplicate Stack Top"	stream nextPut: 136! !!Encoder methodsFor: 'temps' stamp: 'eem 5/30/2008 12:05'!bindBlockArg: name within: aBlockNode	"With standard Smalltalk-80 (BlueBook) blocks it used to be legal to use a	 method temp as a block argument.  This shouldn't be the case with the	 current compiler, which checks for temp names already being used as	 block arguments.  But it is easily fooled by local block temps in optimized	 blocks, e.g.		false			ifTrue: [| temp |]			ifFalse:[[:temp|]]	Rather than fix this we keep the semantics and fix it in the closure compiler."	^self autoBind: name! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/19/2008 19:17'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: (BlockNode withJust: NodeNil) noteOptimized.		 receiver noteOptimized.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimized.			arguments first noteOptimized.			true]! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 18:01'!referenceScopesAndIndicesDo: aBinaryBlock	"Evaluate aBinaryBlock with all read or write scopes and locations.	 This is used to copy the reference information into RemoteTempVectorNodes"	readingScopes ~~ nil ifTrue:		[readingScopes keysAndValuesDo:			[:scopeBlock "<BlockNode>" :set "<Set of <Integer>>"|			set do: [:location| aBinaryBlock value: scopeBlock value: location]]].	writingScopes ~~ nil ifTrue:		[writingScopes keysAndValuesDo:			[:scopeBlock "<BlockNode>" :set "<Set of <Integer>>"|			set do: [:location| aBinaryBlock value: scopeBlock value: location]]]! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:50'!genStorePopInstVar: instVarIndex	"See BlueBook page 596"	(instVarIndex >= 0 and: [instVarIndex < 64]) ifTrue:		["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 130;			nextPut: instVarIndex.		 ^self].	self genStorePopInstVarLong: instVarIndex! !!MessageNode methodsFor: 'testing' stamp: 'eem 9/23/2008 14:06'!isNilIf	^(special between: 3 and: 4)	   and: [(arguments first returns or: [arguments first isJust: NodeNil])	   and: [(arguments last returns or: [arguments last isJust: NodeNil])]]! !!BlockNode methodsFor: 'printing' stamp: 'eem 9/25/2008 12:48'!printOn: aStream indent: level	"statements size <= 1 ifFalse: [aStream crtab: level]."	aStream nextPut: $[.	self printArgumentsOn: aStream indent: level.	(self printTemporaries: temporaries on: aStream doPrior: []) ifTrue:		["If >0 temps and >1 statement, put all statements on separate lines"		 statements size > 1			ifTrue: [aStream crtab: level]			ifFalse: [aStream space]].	self printStatementsOn: aStream indent: level.	aStream nextPut: $]! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/24/2008 22:59'!sizePushRemoteTemp: tempIndex inVectorAt: tempVectorIndex	^self sizeOpcodeSelector: #genPushRemoteTemp:inVectorAt: withArguments: {tempIndex. tempVectorIndex}! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'eem 9/23/2008 22:06'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| node methodTemps arguments temporaries |	node := self codeSelector: selector code: nil.	tempVars := vars.	methodTemps := tempVars select: [:t | t scope >= 0].	arguments := methodTemps copyFrom: 1 to: nArgs.	temporaries := methodTemps copyFrom: nArgs + 1 to: methodTemps size.	block		arguments: arguments;		temporaries: temporaries.	^MethodNode new		selector: node		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (Encoder new initScopeAndLiteralTables					temps: tempVars					literals: literalValues					class: class)		primitive: primitive! !!EncoderForV3PlusClosures methodsFor: 'testing' stamp: 'eem 5/24/2008 18:12'!supportsClosureOpcodes	^true! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:57'!genStoreLiteralVar: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 64 ifTrue: 		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 129;			nextPut: 192 + literalIndex.		 ^self].	literalIndex <= 255 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 224;			nextPut: literalIndex.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!MethodNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:56'!printWithClosureAnalysisOn: aStream 	precedence = 1		ifTrue: 			[(self selector includesSubString: '()/')				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).						arguments							do: [:arg| aStream nextPutAll: arg key]							separatedBy: [aStream nextPutAll: ', '].						aStream nextPut: $)]				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				arg printDefinitionForClosureAnalysisOn: aStream.				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			 self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1; nextPut: $|.			temporaries do: [:temp | 				aStream space.				temp printDefinitionForClosureAnalysisOn: aStream].			aStream space; nextPut: $|].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	aStream crtab: 1.	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !!ContextCompilationTest methodsFor: 'tests' stamp: 'eem 6/19/2008 10:11'!testVariablesAndOffsetsDo	"ContextCompilationTest new testVariablesAndOffsetsDo"	| contextClasses |	contextClasses := ContextPart withAllSuperclasses, ContextPart allSubclasses asArray.	contextClasses do:		[:class|		class variablesAndOffsetsDo:			[:var :offset|			self assert: offset < 0.			self assert: (class instVarNameForIndex: offset negated) == var]].	InstructionStream withAllSuperclasses, InstructionStream allSubclasses asArray do:		[:class|		(contextClasses includes: class) ifFalse:			[class variablesAndOffsetsDo:				[:var :offset|				(InstructionStream instVarNames includes: var) ifFalse:					[self assert: offset > 0.					 self assert: (class instVarNameForIndex: offset) == var]]]]! !!EncoderForLongFormV3 methodsFor: 'initialize-release' stamp: 'eem 5/15/2008 14:11'!initScopeAndLiteralTables	super initScopeAndLiteralTables.	"Start with an empty selector set to avoid the special selectors."	selectorSet := Dictionary new: 16! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForBlueBookLongFormInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForBlueBookLongFormInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForLongFormV3;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 15:27'!addLocalsToPool: locals "<Set of: TempVariableNode>"	localsPool isNil ifTrue:		[localsPool := IdentitySet new].	localsPool addAll: locals! !!EncoderForLongFormV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 6/16/2008 09:45'!genPushRemoteTemp: tempIndex inVectorAt: tempVectorIndex	(tempIndex >= 0 and: [tempIndex < 256	 and: [tempVectorIndex >= 0 and: [tempVectorIndex < 256]]]) ifTrue:		["140 	10001100 kkkkkkkk jjjjjjjj 	Push Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"		 stream			nextPut: 140;			nextPut: tempIndex;			nextPut: tempVectorIndex.		 ^self].	tempIndex >= 256 ifTrue:		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].	tempVectorIndex >= 256 ifTrue:		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/19/2008 17:17'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimized].			true]]! !!Decompiler methodsFor: 'public access' stamp: 'eem 10/20/2008 14:09'!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode tempNames home source |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home who first) == #unknown ifTrue: [^ nil].	constructor := self constructorForMethod: aBlock method.	method fileIndex ~~ 0		ifTrue: ["got any source code?"			source := [method getSourceFromFile]						on: Error						do: [:ex | ^ nil].			tempNames := ([homeClass compilerClass new						parse: source						in: homeClass						notifying: nil]						on: (Smalltalk classNamed: 'SyntaxErrorNotification')						do: [:ex | ^ nil]) tempNames.			self withTempNames: tempNames].	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock isClosure				ifTrue: [(method at: startpc - 2) * 256					  + (method at: startpc - 1) + startpc - 1]				ifFalse:					[(method at: startpc - 2)						\\ 16 - 4 * 256						+ (method at: startpc - 1) + startpc - 1].	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super		method: method		pc: (aBlock isClosure ifTrue: [startpc - 4] ifFalse: [startpc - 5]).	aBlock isClosure ifTrue:		[numLocalTemps := #decompileBlock: "Get pushClosureCopy... to hack fake temps for copied values"].	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 16:11'!sizeSendSuper: selectorLiteralIndex numArgs: nArgs	^self sizeOpcodeSelector: #genSendSuper:numArgs: withArguments: {selectorLiteralIndex. nArgs}! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:20'!genJump: distance	"See BlueBook page 596"	^self genJumpLong: distance! !!SelectorNode methodsFor: 'printing' stamp: 'eem 9/25/2008 14:56'!key: aSelector	"This is for printing of FFI selectors."	key := aSelector! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:02'!genStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex	"142 	10001110 kkkkkkkk jjjjjjjj 	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"	(tempIndex >= 0 and: [tempIndex < 256	 and: [tempVectorIndex >= 0 and: [tempVectorIndex < 256]]]) ifTrue:		[stream			nextPut: 142;			nextPut: tempIndex;			nextPut: tempVectorIndex.		 ^self].	tempIndex >= 256 ifTrue:		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].	tempVectorIndex >= 256 ifTrue:		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255]! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:19'!popIntoLiteralVariable: anAssociation 	"Remove Top Of Stack And Store Into Literal Variable bytecode."	stackPointer := stackPointer - 1! !!Decompiler methodsFor: 'private' stamp: 'eem 9/5/2008 18:41'!convertToDoLoop	"If statements contains the pattern		var := startExpr.		[var <= limit] whileTrue: [...statements... var := var + incConst]	then replace this by		startExpr to: limit by: incConst do: [:var | ...statements...]"	| initStmt toDoStmt limitStmt |	statements size < 2 ifTrue: [^ self].	initStmt := statements at: statements size-1.	(toDoStmt := statements last toDoFromWhileWithInit: initStmt)		== nil ifTrue: [^ self].	initStmt variable scope: -1.  "Flag arg as block temp"	statements removeLast; removeLast; addLast: toDoStmt.	"Attempt further conversion of the pattern		limitVar := limitExpr.		startExpr to: limitVar by: incConst do: [:var | ...statements...]	to		startExpr to: limitExpr by: incConst do: [:var | ...statements...]"	statements size < 2 ifTrue: [^ self].	limitStmt := statements at: statements size-1.	((limitStmt isMemberOf: AssignmentNode)		and: [limitStmt variable isTemp		and: [limitStmt variable == toDoStmt arguments first		and: [self blockScopeRefersOnlyOnceToTemp: limitStmt variable fieldOffset]]])		ifFalse: [^ self].	toDoStmt arguments at: 1 put: limitStmt value.	limitStmt variable scope: -2.  "Flag limit var so it won't print"	statements removeLast; removeLast; addLast: toDoStmt.! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 20:10'!methodWithCopiedTemps	| a b c r |	a := 1.	b := 2.	c := 4.	r := [a + b + c] value.	b := nil.	r	"Parser new		parse: (self class sourceCodeAt: #methodWithCopiedTemps)		class: self class"	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!BraceNode methodsFor: 'testing' stamp: 'eem 9/25/2008 14:48'!blockAssociationCheck: encoder	"If all elements are MessageNodes of the form [block]->[block], and there is at	 least one element, answer true.	 Otherwise, notify encoder of an error."	elements size = 0		ifTrue: [^encoder notify: 'At least one case required'].	elements with: sourceLocations do:			[:x :loc |			(x 	isMessage: #->				receiver:					[:rcvr |					rcvr isBlockNode and: [rcvr numberOfArguments = 0]]				arguments:					[:arg |					arg isBlockNode and: [arg numberOfArguments = 0]])			  ifFalse:				[^encoder notify: 'Association between 0-argument blocks required' at: loc]].	^true! !!Decompiler methodsFor: 'public access' stamp: 'eem 10/20/2008 14:09'!decompile: aSelector in: aClass method: aMethod	"Answer a MethodNode that is the root of the parse tree for the 	argument, aMethod, which is the CompiledMethod associated with the 	message, aSelector. Variables are determined with respect to the 	argument, aClass."	^self		decompile: aSelector		in: aClass		method: aMethod		using: (self constructorForMethod: aMethod)! !!Decompiler methodsFor: 'control' stamp: 'eem 9/25/2008 09:41'!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| savedTemps savedNumLocalTemps jump blockArgs blockTemps blockTempsOffset block |	savedTemps := tempVars.	savedNumLocalTemps := numLocalTemps.	jump := blockSize + pc.	numLocalTemps := BlockLocalTempCounter tempCountForBlockAt: pc - 4 in: method.	blockArgs := (1 to: numArgs) collect:					[:i| (constructor codeTemp: i - 1) beBlockArg].	blockTempsOffset := numArgs + blockCopiedValues size.	blockTemps := (1 to: numLocalTemps) collect:					[:i| constructor codeTemp: i + blockTempsOffset - 1].	tempVars := blockArgs, blockCopiedValues, blockTemps.	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	block := self blockTo: jump.	stack addLast: (constructor					codeArguments: (tempVars copyFrom: 1 to: numArgs)					temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)					block: block).	tempVars := savedTemps.	numLocalTemps := savedNumLocalTemps! !!InstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVar: index! !!MessageAsTempNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self sizeCodeForEffect: encoder! !!LiteralNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level	key isVariableBinding		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###'; nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##'; nextPutAll: key key]]		ifFalse:			[key storeOn: aStream]! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 10:17'!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStorePop: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !!Decompiler methodsFor: 'private' stamp: 'eem 10/20/2008 15:49'!constructorForMethod: aMethod	^(aMethod isBlueBookCompiled		ifTrue: [DecompilerConstructor]		ifFalse: [DecompilerConstructorForClosures]) new! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:13'!sizeCodeForEvaluatedEffect: encoder	^self returns		ifTrue: [self sizeCodeForEvaluatedValue: encoder]		ifFalse: [(self sizeCodeExceptLast: encoder)				+ (statements last sizeCodeForEffect: encoder)]! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:16'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	"Push Closure bytecode.  Either compute the end of the block if this is	 the block we're analysing, or skip it, adjusting the stack as appropriate."	blockEnd		ifNil: [blockEnd := scanner pc + blockSize]		ifNotNil:			[stackPointer := stackPointer - numCopied + 1.			 scanner pc: scanner pc + blockSize]! !!BlockNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:53'!printWithClosureAnalysisOn: aStream indent: level	aStream nextPut: $[.	blockExtent ifNotNil: [aStream print: blockExtent].	self printWithClosureAnalysisArgumentsOn: aStream indent: level.	self printWithClosureAnalysisTemporariesOn: aStream indent: level.	self printWithClosureAnalysisStatementsOn: aStream indent: level.	aStream nextPut: $]! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:28'!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:51'!genStoreInstVarLong: instVarIndex	"See BlueBook page 596"	"See also MaybeContextInstanceVariableNode"	(instVarIndex >= 0 and: [instVarIndex < 256]) ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 160;			nextPut: instVarIndex.		 ^self].	^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255! !!Decompiler methodsFor: 'initialize-release' stamp: 'eem 9/8/2008 18:29'!initSymbols: aClass	| nTemps namedTemps |	constructor method: method class: aClass literals: method literals.	constTable := constructor codeConstants.	instVars := Array new: aClass instSize.	nTemps := method numTemps.	namedTemps := tempVars ifNil: [method tempNames].	tempVars := (1 to: nTemps) collect:				[:i | i <= namedTemps size					ifTrue: [constructor codeTemp: i - 1 named: (namedTemps at: i)]					ifFalse: [constructor codeTemp: i - 1]].	1 to: method numArgs do:		[:i|		(tempVars at: i) beMethodArg]! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 9/29/2008 14:43'!sizeCodeForCase: encoder value: forValue	| braceNode sizeIndex thenSize elseSize allReturn |	forValue not ifTrue:		[^super sizeCodeForEffect: encoder].	equalNode := encoder encodeSelector: #=.	braceNode := arguments first.	sizes := Array new: 2 * braceNode numElements.	sizeIndex := sizes size.	elseSize := arguments size = 2		ifTrue:			[arguments last sizeCodeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode := encoder encodeSelector: #caseError.			 (NodeSelf sizeCodeForValue: encoder)			 + (caseErrorNode sizeCode: encoder args: 0 super: false)]. "self caseError"	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last |		valueNode returns ifFalse: [allReturn := false]].	braceNode casesReverseDo:		[:keyNode :valueNode :last |		sizes at: sizeIndex put: elseSize.		thenSize := valueNode sizeCodeForEvaluatedValue: encoder.		last ifFalse: [thenSize := thenSize + encoder sizePop].		valueNode returns ifFalse: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		(last and: [allReturn]) ifTrue: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize := elseSize + encoder sizeDup].		elseSize := elseSize					+ (keyNode sizeCodeForEvaluatedValue: encoder)					+ (equalNode sizeCode: encoder args: 1 super: false)					+ (self sizeCode: encoder forBranchOn: false dist: thenSize)					+ thenSize.		sizeIndex := sizeIndex - 2].	^(receiver sizeCodeForValue: encoder) + elseSize! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 6/19/2008 08:54'!sizePushInstVarLong: instVarIndex	^self sizeOpcodeSelector: #genPushInstVarLong: withArguments: {instVarIndex}! !!BytecodeEncoder methodsFor: 'accessing' stamp: 'eem 5/14/2008 17:47'!methodStreamPosition	^stream position! !!ParseNode class methodsFor: 'accessing' stamp: 'ajh 8/12/2002 11:10'!blockReturnCode	^ EndRemote! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 5/30/2008 14:35'!bindBlockTemp: name within: aBlockNode	"Read the comment in the superclass's bindBlockArg:within: method.	 If we have closures we should check the argument	 count against the block, not the method.	(Note that this isn't entirely adequate either since optimized blocks	 will slip through the cracks (their arguments (i.e. ifNotNil: [:expr|)	 are charged against their enclosing block, not themselves))."	| nArgs |	self supportsClosureOpcodes ifFalse:		[^super bindBlockTemp: name within: aBlockNode].	(nArgs := aBlockNode nArgsSlot) isNil ifTrue:		[aBlockNode nArgsSlot: (nArgs := 0)].	nArgs >= (CompiledMethod fullFrameSize - 1) ifTrue:		[^self notify: 'Too many temporaries'].	aBlockNode nArgsSlot: nArgs + 1.	^self bindTemp: name! !!BlockNode methodsFor: 'accessing' stamp: 'eem 5/30/2008 12:12'!nArgsSlot: anInteger	"Private for the Encoder to use in bindArg"	nArgsNode := anInteger! !!Compiler methodsFor: 'public access' stamp: 'eem 5/15/2008 15:06'!parserClass: aParserClass	parser := aParserClass new! !!BytecodeAgnosticMethodNode methodsFor: 'printing' stamp: 'eem 7/24/2008 10:07'!printWithClosureAnalysisOn: aStream	self ensureClosureAnalysisDone.	super printWithClosureAnalysisOn: aStream! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisIfNil: aStream indent: level	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.	^self printWithClosureAnalysisKeywords: selector key		arguments: (Array with: arguments first)		on: aStream indent: level! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/24/2008 11:03'!testDebuggerTempAccess	self doTestDebuggerTempAccessWith: 1 with: 2! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:17'!doPop	"Remove Top Of Stack bytecode."	stackPointer := stackPointer - 1! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:51'!genStorePopInstVarLong: instVarIndex	"See BlueBook page 596"	"See also MaybeContextInstanceVariableNode"	(instVarIndex >= 0 and: [instVarIndex < 256]) ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 192;			nextPut: instVarIndex.		 ^self].	^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genReturnReceiver	"See BlueBook page 596"	"120-123 	011110ii 	Return (receiver, true, false, nil) [ii] From Message"	stream nextPut: 120! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 18:23'!sizeCodeForValueOf: aTempVariableNode encoder: encoder	encoder supportsClosureOpcodes ifTrue:		[^encoder sizePushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1 inVectorAt: index].	^(self sizeCodeForValue: encoder)	+ (self sizeCodeForIndexOf: aTempVariableNode encoder: encoder)	+ (readNode sizeCode: encoder args: 1 super: false)! !!ReturnNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:40'!emitCodeForValue: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:21'!pushConstant: value	"Push Constant, value, on Top Of Stack bytecode."	stackPointer := stackPointer + 1! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 16:50'!isIndirectTempVector	^true! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:56'!genSend: selectorLiteralIndex numArgs: nArgs	"See BlueBook page 596 (with exceptions for 132 & 134)"	nArgs < 0 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].	selectorLiteralIndex < 0 ifTrue:		["No special selector sends in long form."		^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255].	(selectorLiteralIndex < 32 and: [nArgs < 8]) ifTrue: 		["	131 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk With jjj Arguments"		 stream			nextPut: 131;			nextPut: ((nArgs bitShift: 5) + selectorLiteralIndex).		 ^self].	(selectorLiteralIndex < 64 and: [nArgs < 4]) ifTrue: 	 	["In Squeak V3			134 	10000110 jjjjjjjj kkkkkkkk 	Send Literal Selector #kkkkkkkk To Superclass With jjjjjjjj Arguments		 is replaced by			134 	10000110 jjkkkkkk 	Send Literal Selector #kkkkkk With jj Arguments"		 stream			nextPut: 134;			nextPut: ((nArgs bitShift: 6) + selectorLiteralIndex).		 ^self].	(selectorLiteralIndex <= 255 and: [nArgs <= 31]) ifTrue: 		["In Squeak V3			132 	10000100 jjjjjjjj kkkkkkkk 	Send Literal Selector #kkkkkkkk With jjjjjjjj Arguments		  is replaced by			132 	10000100 ooojjjjj kkkkkkkk				ooo = 0 => Send Literal Selector #kkkkkkkk With jjjjj Arguments				ooo = 1 => Send Literal Selector #kkkkkkkk To Superclass With jjjjj Arguments"		stream			nextPut: 132;			nextPut: nArgs;			nextPut: selectorLiteralIndex.		 ^self].	nArgs > 31 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31].	selectorLiteralIndex > 255 ifTrue: 		[^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255]! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 6/4/2008 14:44'!popIntoRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	self sawClosureBytecode.	self pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex; doStore: statements! !!Encoder methodsFor: 'results' stamp: 'eem 9/8/2008 18:27'!tempsAndBlockArgs	| tempNodes |	tempNodes := OrderedCollection new.	scopeTable associationsDo:		[:assn | | var |		var := assn value.		(var isTemp		 and: [var isMethodArg not		 and: [var scope = 0 or: [var scope = -1]]]) ifTrue:			[tempNodes add: var]].	^tempNodes! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/15/2008 14:12'!genReturnSpecialLiteral: aLiteral	"120-123 	011110ii 	Return (receiver, true, false, nil) [ii] From Message"	| index |	index := #(true false nil) indexOf: aLiteral ifAbsent: 0.	index = 0 ifTrue:		[^self error: 'return special literal: ', aLiteral printString,  ' is not one of true false nil'].	stream nextPut: 120 + index! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:35'!genReturnTop	"See BlueBook page 596"	"124-125 	0111110i 	Return Stack Top From (Message, Block) [i]"	stream nextPut: 124! !!EncoderForLongFormV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:04'!genStoreRemoteTemp: tempIndex inVectorAt: tempVectorIndex	"141 	10001101 kkkkkkkk jjjjjjjj 	Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"	(tempIndex >= 0 and: [tempIndex < 256	 and: [tempVectorIndex >= 0 and: [tempVectorIndex < 256]]]) ifTrue:		[stream			nextPut: 141;			nextPut: tempIndex;			nextPut: tempVectorIndex.		 ^self].	tempIndex >= 256 ifTrue:		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].	tempVectorIndex >= 256 ifTrue:		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255]! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:24'!methodWithOptimizedBlocks	| s c |	s := self isNil			ifTrue: [| a | a := 'isNil'. a]			ifFalse: [| b | b := 'notNil'. b].	c := String new: s size.	1 to: s size do:		[:i| c at: i put: (s at: i)].	^c	"Parser new		parse: (self class sourceCodeAt: #methodWithOptimizedBlocks)		class: self class"! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:23'!pushReceiverVariable: offset	"Push Contents Of the Receiver's Instance Variable Whose Index 	is the argument, offset, On Top Of Stack bytecode."	stackPointer := stackPointer + 1! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 6/4/2008 14:45'!pushNewArrayOfSize: size	self sawClosureBytecode.	stack addLast: #pushNewArray -> (Array new: size)! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	self shouldNotImplement! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2008 14:10'!constructClosureCreationNode: encoder	copiedValues := self computeCopiedValues: encoder rootNode.	encoder supportsClosureOpcodes ifTrue:		[^self closureCreationNode].	"Without the bytecode we can still get by."	^MessageNode new		receiver: (encoder encodeVariable: 'thisContext')		selector: #closureCopy:copiedValues:		arguments: (Array						with: (encoder encodeLiteral: arguments size)						with: (copiedValues isEmpty								ifTrue: [NodeNil]								ifFalse: [BraceNode new elements: copiedValues]))		precedence: 3		from: encoder! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEvaluatedValue: encoder	^(self sizeCodeExceptLast: encoder)		+ (statements last sizeCodeForBlockValue: encoder)! !!SelectorNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	self shouldNotImplement! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 23:20'!emitCodeForValueOf: aTempVariableNode stack: stack encoder: encoder	encoder supportsClosureOpcodes		ifTrue:			[encoder				genPushRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1				inVectorAt: index.			 stack push: 1]		ifFalse:			[self emitCodeForLoadFor: aTempVariableNode stack: stack encoder: encoder.			 readNode				emitCode: stack				args: 1				encoder: encoder				super: false]! !!RegenerationPreparingVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:13'!visitBlockNode: aBlockNode	aBlockNode cleanUpForRegeneration.	super visitBlockNode: aBlockNode! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:36'!genPushThisContext	"See BlueBook page 596"	"137 	10001001 	Push Active Context"	stream nextPut: 137! !!RemoteTempVectorNode methodsFor: 'printing' stamp: 'eem 7/23/2008 21:21'!printDefinitionForClosureAnalysisOn: aStream 	| refs |	aStream		nextPut: ${;		nextPutAll: key.	definingScope ifNotNil: [definingScope blockExtent ifNotNil: [:be| aStream nextPutAll: ' d@'; print: be first]].	readingScopes notNil ifTrue:		[refs := Set new.		readingScopes do: [:elems| refs addAll: elems].		refs asSortedCollection do: [:read| aStream nextPutAll: ' r@'; print: read]].	remoteTemps		do: [:rt| rt printDefinitionForClosureAnalysisOn: aStream]		separatedBy: [aStream nextPut: $,; space].	aStream nextPut: $}! !!Encoder methodsFor: 'encoding' stamp: 'eem 5/16/2008 18:30'!sharableLitIndex: literal	"Special access prevents multiple entries for post-allocated super send special selectors"	1 to: literalStream position do:		[:index|		(litSet literalEquality: literal and: (literalStream originalContents at: index)) ifTrue:			[^index - 1]].	^self litIndex: literal! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:59'!genBranchPopFalse: distance	"See BlueBook page 596"	distance < 0 ifTrue:		[^self outOfRangeError: 'distance' index: distance range: 0 to: 1023].	(distance > 0 and: [distance < 9]) ifTrue:		["152-159 	10011iii 	Pop and Jump 0n False iii +1 (i.e., 1 through 8)"		 stream nextPut: 152 + distance - 1.		 ^self].	distance < 1024 ifTrue:		["172-175 	101011ii jjjjjjjj 	Pop and Jump On False ii *256+jjjjjjjj"		 stream			nextPut: 172 + (distance bitShift: -8);			nextPut: distance + 1024 \\ 256.		 ^self].	^self outOfRangeError: 'distance' index: distance range: 0 to: 1023! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/3/2008 12:34'!testBlockNumbering	"Test that the compiler and CompiledMethod agree on the block numbering of a substantial doit."	"self new testBlockNumbering"	| methodNode method tempRefs |	methodNode :=		Parser new			encoderClass: EncoderForV3PlusClosures;			parse: 'foo					| numCopiedValuesCounts |					numCopiedValuesCounts := Dictionary new.					0 to: 32 do: [:i| numCopiedValuesCounts at: i put: 0].					Transcript clear.					Smalltalk allClasses remove: GeniePlugin; do:						[:c|						{c. c class} do:							[:b|							Transcript nextPut: b name first; endEntry.							b selectorsAndMethodsDo:								[:s :m| | pn |								m isQuick not ifTrue:									[pn := b parserClass new												encoderClass: EncoderForV3PlusClosures;												parse: (b sourceCodeAt: s)												class: b.									 pn generate: #(0 0 0 0).									 [pn accept: nil]										on: MessageNotUnderstood										do: [:ex| | msg numCopied |											msg := ex message.											(msg selector == #visitBlockNode:											 and: [(msg argument instVarNamed: ''optimized'') not]) ifTrue:												[numCopied := (msg argument computeCopiedValues: pn) size.												 numCopiedValuesCounts													at: numCopied													put: (numCopiedValuesCounts at: numCopied) + 1].											msg setSelector: #==.											ex resume: nil]]]]].					numCopiedValuesCounts'			class: Object.	method := methodNode generate: #(0 0 0 0).	tempRefs := methodNode encoder blockExtentsToTempRefs.	self assert: tempRefs keys = method startpcsToBlockExtents values asSet! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:27'!genPop	"See BlueBook page 596"	"135 	10000111 	Pop Stack Top"	stream nextPut: 135! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/29/2008 17:16'!supportTestSourceRangeAccessForInjectInto: method source: source selectionSequence: selections	"Test debugger source range selection for inject:into:"	| evaluationCount sourceMap debugTokenSequence debugCount |	DebuggerMethodMap voidMapCache.	evaluationCount := 0.	sourceMap := method debuggerMap abstractSourceMap.	debugTokenSequence := selections collect: [:string| Scanner new scanTokens: string].	debugCount := 0.	thisContext		runSimulated: [(1 to: 2)						withArgs:							{	0.								[:sum :each|								 evaluationCount := evaluationCount + 1.								 sum + each]}						executeMethod: method]		contextAtEachStep:			[:ctxt| | range debugTokens |			(ctxt method == method			and: ["Exclude the send of #blockCopy: or #closureCopy:copiedValues: and braceWith:with:				    to create the block, and the #new: and #at:'s for the indirect temp vector.				   This for compilation without closure bytecodes. (Note that at:put:'s correspond to stores)"				(ctxt willSend					and: [(#(closureCopy:copiedValues: blockCopy: new: at: braceWith:with:) includes: ctxt selectorToSendOrSelf) not])				"Exclude the store of the argument into the home context (for BlueBook blocks)				 and the store of an indirection vector into an initial temp"				or: [(ctxt willStore					and: [(ctxt isBlock and: [ctxt pc = ctxt startpc]) not					and: [(ctxt isBlock not						and: [(method usesClosureBytecodes and: [ctxt abstractPC = 2])]) not]])				or: [ctxt willReturn]]]) ifTrue:				[debugTokens := debugTokenSequence at: (debugCount := debugCount + 1) ifAbsent: [#(bogusToken)].				 self assert: (sourceMap includesKey: ctxt abstractPC).				 range := sourceMap at: ctxt abstractPC ifAbsent: [(1 to: 0)].				 self assert: (Scanner new scanTokens: (source copyFrom: range first to: range last)) = debugTokens]].	self assert: evaluationCount = 2! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisCaseOn: aStream indent: level 	"receiver caseOf: {[key]->[value]. ...} otherwise: [otherwise]"	| braceNode otherwise extra |	braceNode := arguments first.	otherwise := arguments last.	(arguments size = 1 or: [otherwise isJustCaseError]) ifTrue:		[otherwise := nil].	receiver		printWithClosureAnalysisOn: aStream		indent: level		precedence: 3.	aStream nextPutAll: ' caseOf: '.	braceNode isVariableReference		ifTrue: [braceNode printWithClosureAnalysisOn: aStream indent: level]		ifFalse: 			[aStream nextPutAll: '{'; crtab: level + 1.			 braceNode casesForwardDo:				[:keyNode :valueNode :last | 				keyNode printWithClosureAnalysisOn: aStream indent: level + 1.				aStream nextPutAll: ' -> '.				valueNode isComplex					ifTrue: 						[aStream crtab: level + 2.						extra := 1]					ifFalse: [extra := 0].				valueNode printWithClosureAnalysisOn: aStream indent: level + 1 + extra.				last ifTrue: [aStream nextPut: $}]					ifFalse: [aStream nextPut: $.;							 crtab: level + 1]]].	otherwise notNil ifTrue:		[aStream crtab: level + 1; nextPutAll: ' otherwise: '.		 extra := otherwise isComplex					ifTrue: 						[aStream crtab: level + 2.						 1]					ifFalse: [0].		 otherwise printWithClosureAnalysisOn: aStream indent: level + 1 + extra]! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:09'!isDefinedWithinBlockExtent: anInterval	^anInterval rangeIncludes: definingScope blockExtent first! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:03'!genPushConsArray: size	(size < 0 or: [size > 127]) ifTrue:		[^self outOfRangeError: 'numElements' index: size range: 0 to: 127].	"138 	10001010 1kkkkkkk 	Push (Array new: kkkkkkk)"	stream		nextPut: 138;		nextPut: size + 128! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisReceiver: rcvr on: aStream indent: level						rcvr ifNil: [^self].	"Force parens around keyword receiver of kwd message"	rcvr printWithClosureAnalysisOn: aStream indent: level precedence: precedence! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:38'!genPushSpecialLiteral: aLiteral	"112-119 	01110iii 	Push (receiver, true, false, nil, -1, 0, 1, 2) [iii]"	| index |	index := #(true false nil -1 0 1 2) indexOf: aLiteral ifAbsent: 0.	index = 0 ifTrue:		[^self error: 'push special literal: ', aLiteral printString,  ' is not one of true false nil -1 0 1 2'].	stream nextPut: index + 112! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:23'!pushTemporaryVariable: offset	"Push Contents Of Temporary Variable Whose Index Is the 	argument, offset, On Top Of Stack bytecode."	stackPointer := stackPointer + 1! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 6/4/2008 14:44'!pushConsArrayWithElements: numElements 	| array |	self sawClosureBytecode.	array := Array new: numElements.	numElements to: 1 by: -1 do:		[:i|		array at: i put: stack removeLast].	stack addLast: (constructor codeBrace: array)! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 9/25/2008 10:27'!popIntoTemporaryVariable: offset	| maybeTVTag tempVector start |	maybeTVTag := stack last.	((maybeTVTag isMemberOf: Association)	 and: [maybeTVTag key == #pushNewArray]) ifTrue:		[tempVector := maybeTVTag value.		 offset + 1 <= tempVars size			ifTrue:				[start := 2.				 tempVector at: 1 put: (tempVars at: offset + 1)]			ifFalse:				[tempVars := (Array new: offset + 1)								replaceFrom: 1								to: tempVars size								with: tempVars.				start := 1].		 start to: tempVector size do:			[:i|			tempVector				at: i				put: (constructor codeTemp: numLocalTemps + offset + i - 1)].		 tempVars at: offset + 1 put: (constructor codeRemoteTemp: offset + 1 remoteTemps: tempVector).		 stack removeLast.		 ^self].	self pushTemporaryVariable: offset; doStore: statements! !!Decompiler methodsFor: 'instruction decoding' stamp: ''!doStore: stackOrBlock	"Only called internally, not from InstructionStream. StackOrBlock is stack	for store, statements for storePop."	| var expr |	var := stack removeLast.	expr := stack removeLast.	stackOrBlock addLast: (expr == ArgumentFlag		ifTrue: [var]		ifFalse: [constructor codeAssignTo: var value: expr])! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/19/2008 14:12'!methodWithVariousTemps	| classes total totalLength |	classes := self withAllSuperclasses.	total := totalLength := 0.	classes do: [:class| | className |		className := class name.		total := total + 1.		totalLength := totalLength + className size].	^total -> totalLength	"Parser new		parse: (self class sourceCodeAt: #methodWithVariousTemps)		class: self class"! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 5/29/2008 15:51'!isRemote	^remoteNode notNil! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: strm indent: level precedence: outerPrecedence	| parenthesize |	parenthesize := precedence > outerPrecedence		or: [outerPrecedence = 3 and: [precedence = 3 "both keywords"]].	parenthesize		ifTrue: [strm nextPutAll: '('.				self printWithClosureAnalysisOn: strm indent: level.				strm nextPutAll: ')']		ifFalse: [self printWithClosureAnalysisOn: strm indent: level]! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:40'!sizeJumpLong: distance	^self sizeOpcodeSelector: #genJumpLong: withArguments: {distance}! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:53'!genJumpLong: distance	"See BlueBook page 596"	(distance >= -1024 and: [distance < 1024]) ifTrue:		["160-167 	10100iii jjjjjjjj 	Jump(iii - 4) *256+jjjjjjjj"		 stream			nextPut: 160 + (distance + 1024 bitShift: -8);			nextPut: distance + 1024 \\ 256.		 ^self].	^self outOfRangeError: 'distance' index: distance range: -1024 to: 1023! !!ReturnNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:49'!printWithClosureAnalysisOn: aStream indent: level	aStream nextPutAll: '^ '. "make this a preference??"	expr printWithClosureAnalysisOn: aStream indent: level.	expr printCommentOn: aStream indent: level! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:53'!genBranchPopTrue: distance	"See BlueBook page 596"	distance < 0 ifTrue:		[^self outOfRangeError: 'distance' index: distance range: 0 to: 1023].	distance < 1024 ifTrue:		["168-171 	101010ii jjjjjjjj 	Pop and Jump On True ii *256+jjjjjjjj"		 stream			nextPut: 168 + (distance bitShift: -8);			nextPut: distance + 1024 \\ 256.		 ^self].	^self outOfRangeError: 'distance' index: distance range: 0 to: 1023! !!BlockNode methodsFor: 'accessing' stamp: 'eem 7/27/2008 15:57'!arguments	^arguments! !!ParseStack methodsFor: 'accessing' stamp: 'eem 9/12/2008 10:31'!position: n 	(position := n) > length		ifTrue: [length := position]! !!ReturnNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:40'!emitCodeForReturn: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 16:22'!sizePushInstVar: instVarIndex	^self sizeOpcodeSelector: #genPushInstVar: withArguments: {instVarIndex}! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 14:54'!emitCodeForStorePop: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStorePopInto: self stack: stack encoder: encoder].	encoder genStorePopTemp: index.	stack pop: 1! !!ParseNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: anInteger 	"If control gets here, avoid recursion loop."	super printWithClosureAnalysisOn: aStream! !!SelectorNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	self shouldNotImplement! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:38'!emitCodeForReturn: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genReturnTop! !!ParseNode class methodsFor: 'accessing' stamp: 'ajh 8/6/2002 12:04'!popCode	^ Pop! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:40'!genPushInstVar: instVarIndex	"See BlueBook page 596"	instVarIndex >= 0 ifTrue:		[instVarIndex < 16 ifTrue:			["0-15 	0000iiii 	Push Receiver Variable #iiii"			 stream nextPut: 0 + instVarIndex.			 ^self].		instVarIndex < 64 ifTrue:			["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"			 stream				nextPut: 128;				nextPut: instVarIndex.			 ^self]].	self genPushInstVarLong: instVarIndex! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 16:37'!reindexingLocalsDo: aBlock encoder: encoderOrNil	"Evaluate aBlock wih arguments, temporaries and copiedValues reindexed for	 their positions within the receiver's block, restoring the correct indices afterwards.	 If encoder is not nil remember the temps for this block's extent."	| tempIndices result tempsToReindex |	self assert: copiedValues notNil.	tempsToReindex := arguments asArray, copiedValues, temporaries.	tempIndices := tempsToReindex collect: [:temp| temp index].	tempsToReindex withIndexDo:		[:temp :newIndex| temp index: newIndex - 1. self assert: temp index + 1 = newIndex].	encoderOrNil ifNotNil:		[encoderOrNil noteBlockExtent: blockExtent hasLocals: tempsToReindex].	result := aBlock ensure:				["Horribly pragmatic hack.  The copiedValues will have completely				  unrelated indices within the closure method and sub-method.				  Avoiding the effort of rebinding temps in the inner scope simply				  update the indices to their correct ones during the generation of				  the closure method and restore the indices immedately there-after."				 tempsToReindex with: tempIndices do:					[:temp :oldIndex| temp index: oldIndex. self assert: temp index = oldIndex]].	^result! !!Parser methodsFor: 'expression types' stamp: 'eem 5/30/2008 14:16'!temporaryBlockVariablesFor: aBlockNode	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse:		"There are't any temporary variables."		[^#()].	variables := OrderedCollection new.	[hereType == #word] whileTrue:		[variables addLast: (encoder bindBlockTemp: self advance within: aBlockNode)].	^(self match: #verticalBar)		ifTrue: [variables]		ifFalse: [self expected: 'Vertical bar']! !!DecompilerConstructorForClosures methodsFor: 'testing' stamp: 'eem 6/4/2008 14:41'!isForClosures	^true! !!SelectorNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	self shouldNotImplement! !!MessageNode methodsFor: 'initialize-release' stamp: 'eem 9/25/2008 17:22'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	selNode code == #macro		ifTrue: [self noteSpecialSelector: selNode key]		ifFalse: [special := 0].	selector := selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!BlockNode methodsFor: 'initialize-release' stamp: 'eem 5/20/2008 13:40'!statements: statementsCollection returns: returnBool 	"Decompile."	| returnLast |	returnLast := returnBool.	returns := false.	statements := 		(statementsCollection size > 1 			and: [(statementsCollection at: statementsCollection size - 1) 					isReturningIf])				ifTrue: 					[returnLast := false.					statementsCollection allButLast]				ifFalse: [statementsCollection size = 0						ifTrue: [Array with: NodeNil]						ifFalse: [statementsCollection]].	arguments := #().	temporaries := #().	optimized := false.	returnLast ifTrue: [self returnLast]! !!AssignmentNode methodsFor: 'testing' stamp: 'eem 6/16/2008 09:37'!isAssignmentNode	^true! !!UndeclaredVariableWarning methodsFor: 'exceptionDescription' stamp: 'eem 7/29/2008 15:09'!defaultAction	"The user should be notified of the occurrence of an exceptional occurrence and	 given an option of continuing or aborting the computation. The description of the	 occurrence should include any text specified as the argument of the #signal: message."		selector ifNotNil:		[Transcript nextPutAll: class name, '>>', selector, ' '].	Transcript show: '(' , name , ' is Undeclared) '.	^true! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:35'!genReturnTopToCaller	"See BlueBook page 596"	"124-125 	0111110i 	Return Stack Top From (Message, Block) [i]"	stream nextPut: 125! !!TempVariableNode methodsFor: 'initialize-release' stamp: 'eem 9/8/2008 18:27'!name: varName index: i type: type scope: level	"Only used for initting temporary variables"	hasDefs := hasRefs := false.	scope := level.	^super name: varName key: varName index: i type: type! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/19/2008 17:15'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: (arguments at: 1) noteOptimized					with: (BlockNode withJust: NodeFalse) noteOptimized.			^true]		ifFalse: 			[^false]! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:28'!sizePushThisContext	^self sizeOpcodeSelector: #genPushThisContext withArguments: #()! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:22'!pushLiteralVariable: anAssociation	"Push Contents Of anAssociation On Top Of Stack bytecode."	stackPointer := stackPointer + 1! !!ClosureCompilerTest class methodsFor: 'code examples' stamp: 'eem 5/20/2008 09:40'!methodWithCopiedAndAssignedTemps	| blk "0w" a "0w" b "0w" c "0w" t "0w" r1 "0w" r2 "0w" |	a := 1. "1w"	b := 2. "1w"	c := 4. "1w"	t := 0. "1w"	blk "5w" := ["2" t  "3w" := t "3r" + a "3r" + b "3r" + c "3r" ] "4".	r1 "5w" := blk "5r" value.	b "5w" := -100.	r2 "5w" := blk "5r" value.	^r1 "5r" -> r2 "5r" -> t "5r"	"a: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read	 b: main(read(),write(0,1,5)), block(read(3),write()) => remote; write follows contained read	 blk: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 c: main(read(),write(0,1)), block(read(3),write()) => copy; no writes follow read	 r1: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 r2: main(read(5),write(0,5)), block(read(),write()) => no copy in blocks < 5	 t: main(read(5),write(0,1)), block(read(3),write(3)) => remote; read follows contained write"	"(Parser new		encoderClass: EncoderForV3;		parse: (self class sourceCodeAt: #methodWithCopiedAndAssignedTemps)		class: self class) generateUsingClosures: #(0 0 0 0)"! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:18'!addHoistedTemps: additionalTemporaries "<SequenceableCollection>"	additionalTemporaries do:		[:temp| temp definingScope: self].	temporaries := (temporaries == nil ifTrue: [#()] ifFalse: [temporaries]), additionalTemporaries! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 9/29/2008 10:32'!jump: dist if: condition	| savePc sign elsePc elseStart end cond ifExpr thenBlock elseBlock	  thenJump elseJump condHasValue isIfNil saveStack |	stack last == CascadeFlag ifTrue: [^ self case: dist].	elsePc := lastPc.	elseStart := pc + dist.	end := limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign := condition.	savePc := pc.	self interpretJump ifNotNil:		[:elseDist|		 (elseDist >= 0 and: [elseStart = pc]) ifTrue:			 [sign := sign not.  elseStart := pc + elseDist]].	pc := savePc.	ifExpr := stack removeLast.	(isIfNil := stack size > 0 and: [stack last == IfNilFlag]) ifTrue:		[stack removeLast].	saveStack := stack.	stack := OrderedCollection new.	thenBlock := self blockTo: elseStart.	condHasValue := hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump := exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			  thenJump will jump to the beginning of the while expr."			stack := saveStack.			statements addLast:				(constructor					codeMessage: (constructor codeBlock: { ifExpr } returns: false)					selector: (constructor								codeSelector: (sign												ifTrue: [#whileFalse:]												ifFalse: [#whileTrue:])								code: #macro)					arguments: { thenBlock }).			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock := self blockTo: thenJump.			elseJump := exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc ifTrue:				[pc := lastPc].			cond := isIfNil						ifTrue:							[constructor								codeMessage: ifExpr ifNilReceiver								selector: (constructor											codeSelector: (sign ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])											code: #macro)								arguments: (Array with: thenBlock)]						ifFalse:							[constructor								codeMessage: ifExpr								selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)								arguments:	(sign												ifTrue: [{elseBlock. thenBlock}]												ifFalse: [{thenBlock. elseBlock}])].			stack := saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!BraceNode methodsFor: 'code generation (closures)' stamp: 'eem 5/19/2008 20:26'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	elements do: [:node| node analyseTempsWithin: scopeBlock rootNode: rootNode]! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 16:22'!emitCodeForLoad: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 18:20'!emitCodeForIndexOf: aTempVariableNode stack: stack encoder: encoder	self assert: encoder supportsClosureOpcodes not.	(encoder encodeLiteral: (remoteTemps indexOf: aTempVariableNode))		emitCodeForValue: stack encoder: encoder! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:54'!sizeCodeForValue: encoder	self reserve: encoder.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral| "i.e. the pseudo-variables nil true & false"			 ^encoder sizePushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder sizePushReceiver].	code = LdThisContext ifTrue:		[^encoder sizePushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder sizePushInstVar: index! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForClosureBytecodeInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForClosureBytecodeInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForV3PlusClosures;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 14:53'!emitCodeForValue: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForValueOf: self stack: stack encoder: encoder].	encoder genPushTemp: index.	stack push: 1! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:11'!genPushClosureCopyNumCopiedValues: numCopied numArgs: numArgs jumpSize: jumpSize	"143 	10001111 llllkkkk jjjjjjjj iiiiiiii	Push Closure Num Copied llll Num Args kkkk BlockSize jjjjjjjjiiiiiiii"	(jumpSize < 0 or: [jumpSize > 65535]) ifTrue:		[^self outOfRangeError: 'block size' index: jumpSize range: 0 to: 65535].	(numCopied < 0 or: [numCopied > 15]) ifTrue:		[^self outOfRangeError: 'num copied' index: numCopied range: 0 to: 15].	(numArgs < 0 or: [numArgs > 15]) ifTrue:		[^self outOfRangeError: 'num args' index: numArgs range: 0 to: 15].	stream		nextPut: 143;		nextPut: numArgs + (numCopied bitShift: 4);		nextPut: (jumpSize bitShift: -8);		nextPut: (jumpSize bitAnd: 16rFF)! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 9/29/2008 15:02'!case: dist	"statements = keyStmts CascadeFlag keyValueBlock ... keyStmts"	| nextCase thenJump stmtStream elements b node cases otherBlock myExits |	nextCase := pc + dist.	"Now add CascadeFlag & keyValueBlock to statements"	statements addLast: stack removeLast.	stack addLast: CaseFlag. "set for next pop"	statements addLast: (self blockForCaseTo: nextCase).	stack last == CaseFlag		ifTrue: "Last case"			["ensure jump is within block (in case thenExpr returns wierdly I guess)"			stack removeLast. "get rid of CaseFlag"			stmtStream := ReadStream on: (self popTo: stack removeLast).						elements := OrderedCollection new.			b := OrderedCollection new.			[stmtStream atEnd] whileFalse:				[(node := stmtStream next) == CascadeFlag					ifTrue:						[elements addLast: (constructor							codeMessage: (constructor codeBlock: b returns: false)							selector: (constructor codeSelector: #-> code: #macro)							arguments: (Array with: stmtStream next)).						 b := OrderedCollection new]					ifFalse: [b addLast: node]].			b size > 0 ifTrue: [self error: 'Bad cases'].			cases := constructor codeBrace: elements.						"try find the end of the case"			myExits := caseExits removeLast: elements size.			myExits := myExits reject: [ :e | e isNil or: [ e < 0 or: [ e > method endPC ] ] ].			thenJump := myExits isEmpty							ifTrue: [ nextCase ]							ifFalse: [ myExits max ].						otherBlock := self blockTo: thenJump.			stack addLast:				(constructor					codeMessage: stack removeLast					selector: (constructor codeSelector: #caseOf:otherwise: code: #macro)					arguments: (Array with: cases with: otherBlock))].! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 16:57'!testInjectIntoDecompilations	"Test various compilations decompile to the same code for a method sufficiently	 simple that this is possible and sufficiently complex that the code generated	 varies between the compilations."	"self new testInjectIntoDecompilations"	| source |	source := (Collection sourceCodeAt: #inject:into:) asString.	{ Encoder.	   EncoderForV3. EncoderForLongFormV3.	   EncoderForV3PlusClosures. EncoderForLongFormV3PlusClosures } do:		[:encoderClass| | method |		method := (Parser new							encoderClass: encoderClass;							parse: source							class: Collection)						generate: #(0 0 0 0).		self assert: (Scanner new scanTokens: method decompileString)					= #(inject: t1 into: t2							| t3 |							t3 ':=' t1 .							self do: [ ':t4' | t3 ':=' t2 value: t3 value: t4 ] .							^ t3)]! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 23:02'!emitCodeForStorePopInto: aTempVariableNode stack: stack encoder: encoder	encoder supportsClosureOpcodes		ifTrue:			[encoder				genStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1				inVectorAt: index]		ifFalse:			[self emitCodeForStoreInto: aTempVariableNode stack: stack encoder: encoder.			 encoder genPop].	stack pop: 1! !!BlockNode methodsFor: 'code generation (new scheme)' stamp: 'eem 6/2/2008 13:29'!emitCodeExceptLast: stack encoder: encoder	| position nextToLast |	position := stack position.	nextToLast := statements size - 1.	1 to: nextToLast do:		[:i | | statement |		statement := statements at: i.		statement emitCodeForEffect: stack encoder: encoder.		self assert: stack position = position].! !!RemoteTempVectorNode methodsFor: 'decompiler' stamp: 'eem 9/25/2008 09:46'!remoteTemps: anArray	remoteTemps := anArray.	anArray do: [:tempNode| tempNode remoteNode: self]! !!LeafNode methodsFor: 'code generation (closures)' stamp: 'eem 6/16/2008 09:32'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	"This is a no-op except in TempVariableNode"	^self! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:37'!sizePushSpecialLiteral: specialLiteral	^self sizeOpcodeSelector: #genPushSpecialLiteral: withArguments: {specialLiteral}! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 17:57'!referenceScopesAndIndicesDo: aBinaryBlock	self shouldNotImplement! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 9/8/2008 18:20'!isBlockArg	^#block == argType! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 18:22'!sizeBranchPopFalse: distance	^self sizeOpcodeSelector: #genBranchPopFalse: withArguments: {distance}! !!Compiler methodsFor: 'private' stamp: 'eem 5/15/2008 15:10'!format: aStream noPattern: noPattern ifFail: failBlock	^self parser		parse: aStream		class: class		noPattern: noPattern		context: context		notifying: requestor		ifFail: [^failBlock value]! !!SelectorNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCode: stack args: nArgs encoder: encoder	self emitCode: stack		args: nArgs		encoder: encoder		super: false! !!SelectorNode methodsFor: 'printing' stamp: 'eem 9/25/2008 15:01'!printAsFFICallWithArguments: aSequence on: aStream indent: level	aStream nextPutAll: (key copyUpTo: $)).	aSequence		do: [:arg| arg printOn: aStream indent: level]		separatedBy: [aStream nextPutAll: ', '].	aStream nextPut: $)! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:45'!sizeStoreTemp: tempIndex	^self sizeOpcodeSelector: #genStoreTemp: withArguments: {tempIndex}! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:43'!genStorePopInstVar: instVarIndex	"See BlueBook page 596"	instVarIndex >= 0 ifTrue:		[instVarIndex < 8 ifTrue:			["96-103 	01100iii 	Pop and Store Receiver Variable #iii"			 stream nextPut: 96 + instVarIndex.			 ^self].		instVarIndex < 64 ifTrue:			["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"			 stream				nextPut: 130;				nextPut: instVarIndex.			 ^self]].	self genStorePopInstVarLong: instVarIndex! !!MessageAsTempNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForStorePop: stack encoder: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self emitCodeForEffect: stack encoder: encoder! !!InstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 10:05'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVar: index.	stack pop: 1! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:26'!sizePushTemp: tempIndex	^self sizeOpcodeSelector: #genPushTemp: withArguments: {tempIndex}! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:28'!sizeDup	^self sizeOpcodeSelector: #genDup withArguments: #()! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:54'!genPushTemp: tempIndex	"See BlueBook page 596"	tempIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].	tempIndex < 64 ifTrue: 		["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 128;			nextPut: 64 + tempIndex.		 ^self].	^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/15/2008 09:07'!sizeReturnReceiver	^self sizeOpcodeSelector: #genReturnReceiver withArguments: #()! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 10:09'!emitCodeForStorePop: stack encoder: encoder	writeNode ifNil:		[stack pop: 1.		 ^encoder genStorePopLiteralVar: index].	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!BraceNode methodsFor: 'code generation (closures)' stamp: 'eem 5/21/2008 10:40'!elements	^elements! !!NewArrayNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/25/2008 14:58'!emitCodeForValue: stack encoder: encoder	encoder genPushNewArray: numElements.	stack push: 1! !!SelectorNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:47'!emitCode: stack args: nArgs encoder: encoder super: supered	stack pop: nArgs.	^supered		ifTrue:			[encoder genSendSuper: index numArgs: nArgs]		ifFalse:			[encoder				genSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:01'!genStoreLiteralVar: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 64 ifTrue: 		["129 	10000001 jjkkkkkk 	Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 129;			nextPut: 192 + literalIndex.		 ^self].	literalIndex < 256 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 224;			nextPut: literalIndex.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!BraceNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/30/2008 17:22'!sizeCodeForValue: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])		  + (encoder sizePushConsArray: elements size)].	emitNode := elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^emitNode sizeCodeForValue: encoder! !!ReturnNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForReturn: encoder	^expr sizeCodeForReturn: encoder! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:27'!noteBlockEntry: aBlock	"Evaluate aBlock with the numbering for the block entry."	locationCounter isNil ifTrue:		[locationCounter := -1].	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:54'!genPushLiteral: literalIndex	"See BlueBook page 596"	literalIndex < 0 ifTrue: 		[^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255].	literalIndex < 64 ifTrue: 		["128 	10000000 jjkkkkkk 	Push (Receiver Variable, Temporary Location, Literal Constant, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 128;			nextPut: 128 + literalIndex.		 ^self].	literalIndex < 256 ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 96;			nextPut: literalIndex.		 ^self].	^self outOfRangeError: 'index' index: literalIndex range: 0 to: 255! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:41'!genJump: distance	"See BlueBook page 596"	(distance > 0 and: [distance < 9]) ifTrue:		["144-151 	10010iii 	Jump iii + 1 (i.e., 1 through 8)"		 stream nextPut: 144 + distance - 1.		 ^self].	"160-167 	10100iii jjjjjjjj 	Jump(iii - 4) *256+jjjjjjjj"	^self genJumpLong: distance! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:57'!sizeCodeForReturn: encoder	^(self sizeCodeForValue: encoder) + encoder sizeReturnTop! !!RemoteTempVectorNode methodsFor: 'accessing' stamp: 'eem 6/2/2008 16:47'!remoteTemps	^remoteTemps! !!EncoderForLongFormV3PlusClosures methodsFor: 'testing' stamp: 'eem 5/24/2008 18:12'!supportsClosureOpcodes	^true! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 6/5/2008 16:48'!emitCodeForValue: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (NewStyleMacroEmitters at: special) with: stack with: encoder with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitCodeForValue: stack encoder: encoder].			arguments do: [:argument | argument emitCodeForValue: stack encoder: encoder].			pc := encoder methodStreamPosition + 1. "debug pc is first byte of the send, i.e. the next byte".			selector				emitCode: stack				args: arguments size				encoder: encoder				super: receiver == NodeSuper]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:26'!addRemoteTemp: aTempVariableNode rootNode: rootNode "<MethodNode>"	temporaries isArray ifTrue:		[temporaries := temporaries asOrderedCollection].	remoteTempNode == nil ifTrue:		[remoteTempNode := RemoteTempVectorNode new								name: '<', blockExtent first printString, '-', blockExtent last printString, '>'								index: arguments size + temporaries size								type: LdTempType								scope: 0.		 temporaries addLast: remoteTempNode.		 remoteTempNode definingScope: self].	remoteTempNode addRemoteTemp: aTempVariableNode encoder: rootNode encoder.	temporaries remove: aTempVariableNode.	^remoteTempNode! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:19'!addRemoteTemp: aTempVariableNode encoder: encoder	remoteTemps isNil ifTrue:		[remoteTemps := OrderedCollection new].	remoteTemps addLast: aTempVariableNode.	aTempVariableNode referenceScopesAndIndicesDo:		[:scopeBlock "<BlockNode>" :location "<Integer>"|		 self addReadWithin: scopeBlock at: location].	encoder supportsClosureOpcodes ifFalse:		[encoder encodeLiteral: remoteTemps size.		 readNode := encoder encodeSelector: #at:.		 writeNode := encoder encodeSelector: #at:put:]! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 6/19/2008 08:52'!genStorePopInstVarLong: instVarIndex	"See BlueBook page 596"	"See also MaybeContextInstanceVariableNode"	(instVarIndex >= 0 and: [instVarIndex < 256]) ifTrue: 		["132 	10000100 iiijjjjj kkkkkkkk 	(Send, Send Super, Push Receiver Variable, Push Literal Constant, Push Literal Variable, Store Receiver Variable, Store-Pop Receiver Variable, Store Literal Variable)[iii] #kkkkkkkk jjjjj"		 stream			nextPut: 132;			nextPut: 192;			nextPut: instVarIndex.		 ^self].	^self outOfRangeError: 'index' index: instVarIndex range: 0 to: 255! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:40'!genReturnReceiver	"See BlueBook page 596"	"120-123 	011110ii 	Return (receiver, true, false, nil) [ii] From Message"	stream nextPut: 120! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:08'!reserve: encoder 	"If this is a yet unused literal of type -code, reserve it."	code < 0 ifTrue: [code := self code: (index := encoder sharableLitIndex: key) type: 0 - code]! !!MessageNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:15'!sizeCodeForIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	(forValue	 or: [(thenExpr isJust: NodeNil)	 or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^super sizeCodeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize := elseExpr sizeCodeForEvaluatedValue: encoder.			thenSize := (thenExpr sizeCodeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeCode: encoder forJump: elseSize]).			branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize := 0.					thenSize := thenExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]				ifFalse:					[thenSize := 0.					elseSize := elseExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: true dist: elseSize]].	sizes := Array with: thenSize with: elseSize.	^(receiver sizeCodeForValue: encoder)	+ branchSize + thenSize + elseSize! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/15/2008 11:26'!testTempNameAccessForInjectInto	"self new testTempNameAccessForInjectInto"	| methodNode method evaluationCount block debuggerMap |	methodNode := Parser new						encoderClass: EncoderForV3PlusClosures;						parse: (Collection sourceCodeAt: #inject:into:)						class: Collection.	method := methodNode generate: #(0 0 0 0).	debuggerMap := DebuggerMethodMap forMethod: method methodNode: methodNode.	evaluationCount := 0.	block := [:prev :each| | theContext tempNames |			evaluationCount := evaluationCount + 1.			theContext := thisContext sender.			tempNames := debuggerMap tempNamesForContext: theContext.			self assert: (tempNames hasEqualElements: tempNames).			#('thisValue' 'each' 'binaryBlock' 'nextValue')				with: { 0. each. block. prev}				do: [:tempName :value|					self assert: (debuggerMap namedTempAt: (tempNames indexOf: tempName) in: theContext) == value.					tempName ~= 'each' ifTrue:						[self assert: (debuggerMap namedTempAt: (tempNames indexOf: tempName) in: theContext home) == value]]].	(1 to: 10) withArgs: { 0. block } executeMethod: method.	self assert: evaluationCount = 10! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 16:11'!sizeSend: selectorLiteralIndex numArgs: nArgs	^self sizeOpcodeSelector: #genSend:numArgs: withArguments: {selectorLiteralIndex. nArgs}! !!CascadeNode methodsFor: 'code generation (closures)' stamp: 'eem 5/19/2008 20:26'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	{ receiver }, messages do:		[:node| node analyseTempsWithin: scopeBlock rootNode: rootNode]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 5/19/2008 17:15'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: (BlockNode withJust: NodeTrue) noteOptimized					with: (arguments at: 1) noteOptimized.			^true]		ifFalse: 			[^false]! !!Encoder methodsFor: 'results' stamp: 'eem 6/24/2008 14:24'!unusedTempNames 	| unused |	unused := OrderedCollection new.	scopeTable associationsDo:		[:assn | | name |		(assn value isUnusedTemp) ifTrue:			[name := assn value key.			 name ~= self doItInContextName ifTrue: [unused add: name]]].	^ unused! !!TempVariableNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level 	aStream nextPutAll: name! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 10:56'!addReadWithin: scopeBlock "<BlockNode>" at: location "<Integer>"	readingScopes ifNil: [readingScopes := Dictionary new].	(readingScopes at: scopeBlock ifAbsentPut: [Set new]) add: location! !!Decompiler methodsFor: 'control' stamp: 'eem 5/29/2008 13:16'!checkForBlock: receiver selector: selector arguments: arguments	selector == #blockCopy: ifTrue:		[^self checkForBlockCopy: receiver].	self assert: selector == #closureCopy:copiedValues:.	^self checkForClosureCopy: receiver arguments: arguments! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'eem 6/24/2008 11:50'!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector key ~= #namedTempAt: 		ifTrue: [^self error: 'cant transform this message'].	^ MessageAsTempNode new		receiver: receiver		selector: #namedTempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:00'!genSend: selectorLiteralIndex numArgs: nArgs	"See BlueBook page 596 (with exceptions for 132 & 134)"	nArgs < 0 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31 "!!!!"].	selectorLiteralIndex < 0 ifTrue:		["Special selector sends.			176-191 	1011iiii 	Send Arithmetic Message #iiii			192-207 	1100iiii 	Send Special Message #iiii"		self flag: #yuck.		 (selectorLiteralIndex negated between: 176 and: 207) ifFalse:			[^self outOfRangeError: 'special selector code' index: selectorLiteralIndex negated range: 176 to: 207].		 stream nextPut: selectorLiteralIndex negated.		 ^self].	(selectorLiteralIndex < 16 and: [nArgs < 3]) ifTrue:		["	208-223 	1101iiii 	Send Literal Selector #iiii With No Arguments			224-239 	1110iiii 	Send Literal Selector #iiii With 1 Argument			240-255 	1111iiii 	Send Literal Selector #iiii With 2 Arguments"		 stream nextPut: 208 + (nArgs * 16) + selectorLiteralIndex.		 ^self].	(selectorLiteralIndex < 32 and: [nArgs < 8]) ifTrue: 		["	131 	10000011 jjjkkkkk 	Send Literal Selector #kkkkk With jjj Arguments"		 stream			nextPut: 131;			nextPut: ((nArgs bitShift: 5) + selectorLiteralIndex).		 ^self].	(selectorLiteralIndex < 64 and: [nArgs < 4]) ifTrue: 	 	["In Squeak V3			134 	10000110 jjjjjjjj kkkkkkkk 	Send Literal Selector #kkkkkkkk To Superclass With jjjjjjjj Arguments		 is replaced by			134 	10000110 jjkkkkkk 	Send Literal Selector #kkkkkk With jj Arguments"		 stream			nextPut: 134;			nextPut: ((nArgs bitShift: 6) + selectorLiteralIndex).		 ^self].	(selectorLiteralIndex < 256 and: [nArgs < 32]) ifTrue: 		["In Squeak V3			132 	10000100 jjjjjjjj kkkkkkkk 	Send Literal Selector #kkkkkkkk With jjjjjjjj Arguments		  is replaced by			132 	10000100 ooojjjjj kkkkkkkk				ooo = 0 => Send Literal Selector #kkkkkkkk With jjjjj Arguments				ooo = 1 => Send Literal Selector #kkkkkkkk To Superclass With jjjjj Arguments"		stream			nextPut: 132;			nextPut: nArgs;			nextPut: selectorLiteralIndex.		 ^self].	nArgs >= 32 ifTrue:		[^self outOfRangeError: 'numArgs' index: nArgs range: 0 to: 31].	selectorLiteralIndex >= 256 ifTrue: 		[^self outOfRangeError: 'selector literal index' index: selectorLiteralIndex range: 0 to: 255]! !!EncoderForV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:06'!genPushNewArray: size	(size < 0 or: [size > 127]) ifTrue:		[^self outOfRangeError: 'numElements' index: size range: 0 to: 127].	"138 	10001010 0kkkkkkk 	Pop kkkkkkk into: (Array new: kkkkkkk)"	stream		nextPut: 138;		nextPut: size! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 19:44'!supportTestSourceRangeAccessForDecompiledNoBytecodeInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	'at: 1 put: t1'								'do: [:t4 | t3 at: 1 put: (t2 value: (t3 at: 1) value: t4)]'								'value: (t3 at: 1) value: t4'								'at: 1 put: (t2 value: (t3 at: 1) value: t4)'								']'								'value: (t3 at: 1) value: t4'								'at: 1 put: (t2 value: (t3 at: 1) value: t4)'								']'								'^t3 at: 1')! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 09:44'!emitCodeForLoad: stack encoder: encoder	writeNode ifNotNil:		[encoder genPushLiteral: index.		 stack push: 1]! !!InstanceVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVar: index! !!EncoderForLongFormV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:04'!genStorePopRemoteTemp: tempIndex inVectorAt: tempVectorIndex	"142 	10001110 kkkkkkkk jjjjjjjj 	Pop and Store Temp At kkkkkkkk In Temp Vector At: jjjjjjjj"	(tempIndex >= 0 and: [tempIndex < 256	 and: [tempVectorIndex >= 0 and: [tempVectorIndex < 256]]]) ifTrue:		[stream			nextPut: 142;			nextPut: tempIndex;			nextPut: tempVectorIndex.		 ^self].	tempIndex >= 256 ifTrue:		[^self outOfRangeError: 'remoteTempIndex' index: tempIndex range: 0 to: 255].	tempVectorIndex >= 256 ifTrue:		[^self outOfRangeError: 'tempVectorIndex' index: tempVectorIndex range: 0 to: 255]! !!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'eem 9/26/2008 13:40'!tempCountForBlockAt: pc in: method	"Compute the number of local temporaries in a block.	 If the block begins with a sequence of push: nil bytecodes then some of	 These could be initializing local temps.  We can only reliably disambuguate	 them from other uses of nil by parsing the stack and seeing what the offset	 of the stack pointer is at the end of the block.	 There are short-cuts.  The ones we take here are		- if there is no sequence of push nils there can be no local temps		- we follow forward jumps to shorten the amount of scanning"	stackPointer := 0.	scanner := InstructionStream new method: method pc: pc.	scanner interpretNextInstructionFor: self.	blockEnd isNil ifTrue:		[self error: 'pc is not that of a block'].	scanner nextByte = Encoder pushNilCode ifTrue:		[joinOffsets := Dictionary new.		 [scanner pc < blockEnd] whileTrue:			[scanner interpretNextInstructionFor: self]].	^stackPointer! !!AssignmentNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 09:37'!analyseTempsWithin: scopeBlock "<BlockNode>"  rootNode: rootNode "<MethodNode>"	"N.B.  since assigment happens _after_ the value is evaluated the value is sent the message _first_."	value analyseTempsWithin: scopeBlock rootNode: rootNode.	variable beingAssignedToAnalyseTempsWithin: scopeBlock rootNode: rootNode! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/26/2008 11:36'!methodReturnTop	"Return Top Of Stack bytecode."	stackPointer := stackPointer - 1.	self doJoin! !!BlockLocalTempCounter methodsFor: 'initialize-release' stamp: 'eem 9/26/2008 13:41'!testTempCountForBlockAt: startPc in: method	"Compute the number of local temporaries in a block.	 If the block begins with a sequence of push: nil bytecodes then some of	 These could be initializing local temps.  We can only reliably disambuguate	 them from other uses of nil by parsing the stack and seeing what the offset	 of the stack pointer is at the end of the block.There are short-cuts.  The only	 one we take here is		- if there is no sequence of push nils there can be no local temps"	| symbolicLines line prior thePc |	symbolicLines := Dictionary new.	method symbolicLinesDo:		[:pc :lineForPC| symbolicLines at: pc put: lineForPC].	stackPointer := 0.	scanner := InstructionStream new method: method pc: startPc.	scanner interpretNextInstructionFor: self.	blockEnd isNil ifTrue:		[self error: 'pc is not that of a block'].	scanner nextByte = Encoder pushNilCode ifTrue:		[joinOffsets := Dictionary new.		 [scanner pc < blockEnd] whileTrue:			[line := symbolicLines at: scanner pc.			 prior := stackPointer.			 thePc := scanner pc.			 scanner interpretNextInstructionFor: self.			 Transcript cr; print: prior; nextPutAll: '->'; print: stackPointer;  tab; print: thePc; tab; nextPutAll: line; flush]].	^stackPointer! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/14/2008 17:39'!genReturnSpecialLiteral: aLiteral	"120-123 	011110ii 	Return (receiver, true, false, nil) [ii] From Message"	| index |	index := #(true false nil) indexOf: aLiteral ifAbsent: 0.	index = 0 ifTrue:		[^self error: 'return special literal: ', aLiteral printString,  ' is not one of true false nil'].	stream nextPut: 120 + index! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/3/2008 13:03'!testBlockNumberingForInjectInto	"Test that the compiler and CompiledMethod agree on the block numbering of Collection>>inject:into:	 and that temp names for inject:into: are recorded."	"self new testBlockNumberingForInjectInto"	| methodNode method tempRefs |	methodNode := Parser new						encoderClass: EncoderForV3PlusClosures;						parse: (Collection sourceCodeAt: #inject:into:)						class: Collection.	method := methodNode generate: #(0 0 0 0).	tempRefs := methodNode encoder blockExtentsToTempRefs.	self assert: tempRefs keys = method startpcsToBlockExtents values asSet.	self assert: ((tempRefs includesKey: (0 to: 6))				and: [(tempRefs at: (0 to: 6)) hasEqualElements: {'thisValue'. 'binaryBlock'. OrderedCollection with: 'nextValue'}]).	self assert: ((tempRefs includesKey: (2 to: 4))				and: [(tempRefs at: (2 to: 4)) hasEqualElements: {'each'. 'binaryBlock'.  OrderedCollection with: 'nextValue'}])! !!Compiler methodsFor: 'public access' stamp: 'ar 9/27/2005 19:20'!from: textOrStream class: aClass classified: aCategory context: aContext notifying: req	(textOrStream isKindOf: PositionableStream)		ifTrue: [sourceStream  := textOrStream]		ifFalse: [sourceStream  := ReadStream on: textOrStream asString].	class  := aClass.	context  := aContext.	requestor  := req.	category  := aCategory! !!Decompiler methodsFor: 'control' stamp: 'eem 5/29/2008 17:02'!checkForClosureCopy: receiver arguments: arguments	"We just saw a closureCopy:copiedValues: message. Check for and construct a following block."	| savePc jump |	receiver == constructor codeThisContext ifFalse: [^false].	savePc := pc.	(jump := self interpretJump) notNil ifFalse:		[pc := savePc.		 ^nil].	"Definitely a block"	self doClosureCopyCopiedValues: arguments last "<BraceNode>" elements		numArgs: arguments first key		blockSize: jump.	^true! !!BlockNode methodsFor: 'debugger access' stamp: 'eem 7/2/2008 12:13'!cleanUpForRegeneration	arguments notNil ifTrue:		[arguments do: [:temp| temp cleanUpForRegeneration]].	temporaries notNil ifTrue:		[temporaries do: [:temp| temp cleanUpForRegeneration]].	(temporaries notNil	 and: [temporaries notEmpty	 and: [temporaries last isIndirectTempVector]]) ifTrue:		[temporaries := temporaries allButLast.		 (statements notEmpty		  and: [statements first isAssignmentNode		  and: [statements first variable isTemp		  and: [statements first variable isIndirectTempVector]]]) ifTrue:			[statements removeFirst]].	remoteTempNode := nil! !!AssignmentNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 15:16'!sizeCodeForEffect: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStorePop: encoder)! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:11'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushLiteralVar: index! !!ParseNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:51'!printWithClosureAnalysis	^String streamContents: [:str| self printWithClosureAnalysisOn: str]! !!VariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStorePop: encoder	self shouldNotImplement! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 18:24'!sizeCodeForStoreInto: aTempVariableNode encoder: encoder	encoder supportsClosureOpcodes ifTrue:		[^encoder sizeStoreRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1 inVectorAt: index].	^writeNode sizeCode: encoder args: 2 super: false! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 18:22'!sizeBranchPopTrue: distance	^self sizeOpcodeSelector: #genBranchPopTrue: withArguments: {distance}! !!Encoder methodsFor: 'private' stamp: 'eem 9/10/2008 14:03'!lookupInPools: varName ifFound: assocBlock	^Symbol		hasInterned: varName		ifTrue:			[:sym|			(class bindingOf: sym)				ifNil: [^false]				ifNotNil: [:assoc| assocBlock value: assoc]]! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 9/25/2008 10:34'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| node visibleTemps invisibleTemps arguments temporaries |	node := self codeSelector: selector code: nil.	tempVars := vars.	visibleTemps := OrderedCollection new.	invisibleTemps := OrderedCollection new.	tempVars do: [:t|				   ((t isIndirectTempVector or: [t scope >= 0])						ifTrue: [visibleTemps]						ifFalse: [invisibleTemps]) addLast: t].	arguments := visibleTemps copyFrom: 1 to: nArgs.	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.	block		arguments: arguments;		temporaries: temporaries.	^BytecodeAgnosticMethodNode new		selector: node		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (EncoderForV3PlusClosures new initScopeAndLiteralTables					temps: visibleTemps, invisibleTemps					literals: literalValues					class: class)		primitive: primitive		properties: method properties! !!BlockNode methodsFor: 'initialize-release' stamp: 'eem 5/20/2008 13:40'!arguments: argNodes statements: statementsCollection returns: returnBool from: encoder	"Compile."	arguments := argNodes.	statements := statementsCollection size > 0				ifTrue: [statementsCollection]				ifFalse: [argNodes size > 0						ifTrue: [statementsCollection copyWith: arguments last]						ifFalse: [Array with: NodeNil]].	optimized := false.	returns := returnBool! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/29/2008 17:17'!testInjectIntoDecompiledDebugs	"Test various debugs of the decompiled form debug correctly."	"self new testInjectIntoDecompiledDebugs"	| source |	source := (Collection sourceCodeAt: #inject:into:) asString.	{ Encoder.	   EncoderForV3PlusClosures. EncoderForLongFormV3PlusClosures } do:		[:encoderClass| | method |		method := (Parser new							encoderClass: encoderClass;							parse: source							class: Collection)						generate: #(0 0 0 0).		self supportTestSourceRangeAccessForDecompiledInjectInto: method source: method decompileString]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/25/2008 12:48'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:	 and: [initStmt isAssignmentNode	 and: [initStmt variable isTemp]]) ifFalse:		[^nil].	body := arguments last statements.	variable := initStmt variable.	increment := body last toDoIncrement: variable.	(increment == nil	 or: [receiver statements size ~= 1]) ifTrue:		[^nil].	test := receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	(test isMessageNode	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:		[^nil].	toDoBlock := BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	variable scope: -1.	^MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!Parser methodsFor: 'expression types' stamp: 'eem 8/4/2008 13:38'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| blockNode variableNodes temporaryBlockVariables start |	blockNode := BlockNode new.	variableNodes := OrderedCollection new.	start := prevMark + requestorOffset.	"Gather parameters."	[self match: #colon] whileTrue:		[variableNodes addLast: (encoder bindBlockArg: self argumentName within: blockNode)].	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue:		[^self expected: 'Vertical bar'].	temporaryBlockVariables := self temporaryBlockVariablesFor: blockNode.	self statements: variableNodes innerBlock: true blockNode: blockNode.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].	blockNode noteSourceRangeStart: start end: self endOfLastToken encoder: encoder.	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 9/5/2008 14:27'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	| copiedValues |	self sawClosureBytecode.	numCopied > 0		ifTrue:			[copiedValues := Array new: numCopied.			 numLocalTemps == #decompileBlock: ifTrue: "Hack fake temps for copied values"				[1 to: numCopied do: [:i| stack addLast: (constructor codeTemp: i - 1)]].			 numCopied to: 1 by: -1 do:				[:i|				copiedValues at: i put: stack removeLast]]		ifFalse:			[copiedValues := #()].	self doClosureCopyCopiedValues: copiedValues numArgs: numArgs blockSize: blockSize! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 14:39'!index: anInteger	"For renumbering temps in the closure compiler.	 Intended to be used only in BlockNode>>postNumberingProcessTemps:"	index := anInteger.	code := self code: index type: LdTempType! !!BlockNode methodsFor: 'testing' stamp: 'eem 7/17/2008 12:20'!generateAsClosure	"Answer if we're compiling under the closure regime.  If blockExtent has been set by	analyseTempsWithin:rootNode: et al then we're compiling under the closure regime."	^blockExtent ~~ nil! !!CascadeNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 09:39'!sizeCodeForValue: encoder	| size |	size := (receiver sizeCodeForValue: encoder)			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)).	messages do: [:aMessage | size := size + (aMessage sizeCodeForValue: encoder)].	^size! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 6/19/2008 08:54'!sizeStorePopInstVarLong: instVarIndex	^self sizeOpcodeSelector: #genStorePopInstVarLong: withArguments: {instVarIndex}! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:23'!pushRemoteTemp: remoteTempIndex inVectorAt: tempVectorIndex	"Push Contents at Offset in Temp Vector bytecode."	stackPointer := stackPointer + 1! !!Encoder methodsFor: 'temps' stamp: 'eem 5/30/2008 14:14'!bindBlockTemp: name within: aBlockNode	"The BlockContext compiler (the Smalltalk-80 BlueBook compiler)	 does provide support for ANSI block syntax, but not for ANSI block	 semantics.  Here all temps live at the same level, the method level.	 The approach taken to two block-local temps in different blocks is to	 merge them into a single temp.  e.g.		expr			ifTrue: [|temp| self statementOne]			ifFalse: [|temp| self statementTwo]	 is effectvely transformed into		| temp |		expr			ifTrue: [self statementOne]			ifFalse: [self statementTwo]	 and		expr do: [:each| | temp | ...].		expr do: [:each| | temp | ...].	 is also effectively transformed into		| temp |		expr do: [:each|  ...].		expr do: [:each| ...].	 The closure compiler treats the former similarly, but not the latter.	 The indirection through #bindBlockTemp:within: allows the closure encoder to do this."	^self bindBlockTemp: name! !!ParseNode methodsFor: 'testing' stamp: 'eem 6/16/2008 09:37'!isAssignmentNode	^false! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 11:42'!beingAssignedToAnalyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	self addWriteWithin: scopeBlock at: rootNode locationCounter! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 09:25'!computeCopiedValues: rootNode	| referencedValues |	referencedValues := rootNode referencedValuesWithinBlockExtent: blockExtent.	^((referencedValues reject:		[:temp| temp isDefinedWithinBlockExtent: blockExtent]) asSortedCollection:			[:t1 :t2 | t1 index < t2 index]) asArray! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:17'!definingScope: scopeBlock "<BlockNode>"	definingScope := scopeBlock! !!AssignmentNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 15:16'!sizeCodeForValue: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStore: encoder)! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:59'!genJumpLong: distance	"See BlueBook page 596"	(distance >= -1024 and: [distance < 1024]) ifTrue:		["160-167 	10100iii jjjjjjjj 	Jump(iii - 4) *256+jjjjjjjj"		 stream			nextPut: 160 + (distance + 1024 bitShift: -8);			nextPut: distance + 1024 \\ 256.		 ^self].	^self outOfRangeError: 'distance' index: distance range: -1024 to: 1023! !!MessageNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream indent: level	"may not need this check anymore - may be fixed by the #receiver: change"	special ifNil: [^aStream nextPutAll: '** MessageNode with nil special **'].	special > 0 ifTrue:		[^self perform: self macroPrinter with: aStream with: level].	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.	self printWithClosureAnalysisKeywords: selector key		 arguments: arguments		 on: aStream		 indent: level! !!EncoderForV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:59'!genBranchPopTrue: distance	"See BlueBook page 596"	distance < 0 ifTrue:		[^self outOfRangeError: 'distance' index: distance range: 0 to: 1023].	distance < 1024 ifTrue:		["168-171 	101010ii jjjjjjjj 	Pop and Jump On True ii *256+jjjjjjjj"		 stream			nextPut: 168 + (distance bitShift: -8);			nextPut: distance + 1024 \\ 256.		 ^self].	^self outOfRangeError: 'distance' index: distance range: 0 to: 1023! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 6/19/2008 08:54'!sizeStoreInstVarLong: instVarIndex	^self sizeOpcodeSelector: #genStoreInstVarLong: withArguments: {instVarIndex}! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/24/2008 12:28'!doTestDebuggerTempAccessWith: one with: two	"Test debugger access for temps"	| outerContext local1 remote1 |	outerContext := thisContext.	local1 := 3.	remote1 := 1/2.	self assert: (Compiler new evaluate: 'one' in: thisContext to: self) == one.	self assert: (Compiler new evaluate: 'two' in: thisContext to: self) == two.	self assert: (Compiler new evaluate: 'local1' in: thisContext to: self) == local1.	self assert: (Compiler new evaluate: 'remote1' in: thisContext to: self) == remote1.	Compiler new evaluate: 'local1 := -3.0' in: thisContext to: self.	self assert: local1 = -3.0.	(1 to: 2) do:		[:i| | local2 r1 r2 r3 r4 |		local2 := i * 3.		remote1 := local2 / 7.		self assert: thisContext ~~ outerContext.		self assert: (r1 := Compiler new evaluate: 'one' in: thisContext to: self) == one.		self assert: (r2 := Compiler new evaluate: 'two' in: thisContext to: self) == two.		self assert: (r3 := Compiler new evaluate: 'i' in: thisContext to: self) == i.		self assert: (r4 := Compiler new evaluate: 'local2' in: thisContext to: self) == local2.		self assert: (r4 := Compiler new evaluate: 'remote1' in: thisContext to: self) == remote1.		self assert: (r4 := Compiler new evaluate: 'remote1' in: outerContext to: self) == remote1.		Compiler new evaluate: 'local2 := 15' in: thisContext to: self.		self assert: local2 = 15.		Compiler new evaluate: 'local1 := 25' in: thisContext to: self.		self assert: local1 = 25.		{ r1. r2. r3. r4 } "placate the compiler"].	self assert: local1 = 25.	self assert: remote1 = (6/7)! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 7/18/2008 07:33'!bindTemp: name	"Declare a temporary; error not if a field or class variable or out-of-scope temp.	 Read the comment in Encoder>>bindBlockArg:within: and subclass implementations."	self supportsClosureOpcodes ifFalse:		[^super bindTemp: name].	scopeTable at: name ifPresent:		[:node|		"When non-interactive raise the error only if it is a duplicate"		node isTemp			ifTrue:[node scope >= 0 ifTrue:						[^self notify:'Name is already defined']]			ifFalse:[self warnAboutShadowed: name]].	^self reallyBind: name! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/30/2008 16:36'!sizePushConsArray: numElements	^self sizeOpcodeSelector: #genPushConsArray: withArguments: {numElements}! !!EncoderForLongFormV3 methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 16:58'!genStorePopTemp: tempIndex	"See BlueBook page 596"	tempIndex < 0 ifTrue:		[^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63].	tempIndex < 64 ifTrue: 		["130 	10000010 jjkkkkkk 	Pop and Store (Receiver Variable, Temporary Location, Illegal, Literal Variable) [jj] #kkkkkk"		 stream			nextPut: 130;			nextPut: 64 + tempIndex.		 ^self].	^self outOfRangeError: 'index' index: tempIndex range: 0 to: 63! !!AssignmentNode methodsFor: 'code generation (new scheme)' stamp: 'eem 6/4/2008 11:27'!emitCodeForEffect: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStorePop: stack encoder: encoder! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 18:07'!isReferencedWithinBlockExtent: anInterval 	readingScopes ~~ nil ifTrue:		[readingScopes do:			[:set "<Set of <Integer>>"|			set do:				[:location|				 (anInterval rangeIncludes: location) ifTrue:					[^true]]]].	writingScopes ~~ nil ifTrue:		[writingScopes do:			[:set "<Set of <Integer>>"|			set do:				[:location|				 (anInterval rangeIncludes: location) ifTrue:					[^true]]]].	^false! !!BytecodeEncoder methodsFor: 'accessing' stamp: 'eem 5/24/2008 11:56'!rootNode "^<BlockNode>"	^rootNode! !!BlockLocalTempCounter methodsFor: 'instruction decoding' stamp: 'eem 9/23/2008 16:20'!pushActiveContext	"Push Active Context On Top Of Its Own Stack bytecode."	stackPointer := stackPointer + 1! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/4/2008 15:20'!testSourceRangeAccessForClosureLongFormBytecodeInjectInto	"Test debugger source range selection for inject:into: for a version compiled with closures"	"self new testSourceRangeAccessForClosureLongFormBytecodeInjectInto"	| source method |	source := (Collection sourceCodeAt: #inject:into:) asString.	method := (Parser new						encoderClass: EncoderForLongFormV3PlusClosures;						parse: source						class: Collection)					generate: (Collection compiledMethodAt: #inject:into:) trailer.	self supportTestSourceRangeAccessForInjectInto: method source: source! !!BytecodeEncoder methodsFor: 'opcode sizing' stamp: 'eem 5/14/2008 17:28'!sizePop	^self sizeOpcodeSelector: #genPop withArguments: #()! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:28'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	| blockStart |	optimized ifTrue:		[self assert: (temporaries isEmpty and: [arguments isNil or: [arguments size <= 1]]).		 statements do:			[:statement|			 statement analyseTempsWithin: scopeBlock rootNode: rootNode].		 ^self].	rootNode noteBlockEntry:		[:entryNumber|		 blockStart := entryNumber.		 arguments notNil ifTrue: [arguments do: [:temp| temp definingScope: self]].		 temporaries notNil ifTrue: [temporaries do: [:temp| temp definingScope: self]]].	statements do:		[:statement|		 statement analyseTempsWithin: self rootNode: rootNode].	rootNode noteBlockExit:		[:exitNumber|		 blockExtent := blockStart to: exitNumber].	self postNumberingProcessTemps: rootNode! !!BytecodeEncoder methodsFor: 'accessing' stamp: 'eem 5/29/2008 09:36'!methodNodeClass	^BytecodeAgnosticMethodNode! !!BytecodeEncoder methodsFor: 'accessing' stamp: 'eem 5/24/2008 11:56'!rootNode: node "<BlockNode>"	rootNode := node! !!BlockNode methodsFor: 'printing' stamp: 'eem 11/12/2008 12:31'!printTemporaries: tempSequence on: aStream doPrior: aBlock	"Print any in-scope temporaries.  If there are any evaluate aBlock	 prior to printing.  Answer whether any temporaries were printed."	(tempSequence == nil	 or: [tempSequence size = 0	 or: [tempSequence allSatisfy: [:temp|								   temp scope < 0								   and: [temp isIndirectTempVector not]]]]) ifTrue:		[^false].	aBlock value.	aStream nextPut: $|.	tempSequence do:		[:tempNode |		tempNode isIndirectTempVector			ifTrue:				[tempNode remoteTemps do:					[:tempVariableNode|					 tempVariableNode scope >= 0 ifTrue:						[aStream space; nextPutAll: tempVariableNode key]]]			ifFalse:				[tempNode scope >= 0 ifTrue:					[aStream space; nextPutAll: tempNode key]]].	aStream		space;		nextPut: $|.	^true! !!EncoderForLongFormV3PlusClosures methodsFor: 'bytecode generation' stamp: 'eem 5/30/2008 17:06'!genPushConsArray: size	(size < 0 or: [size > 127]) ifTrue:		[^self outOfRangeError: 'numElements' index: size range: 0 to: 127].	"138 	10001010 1kkkkkkk 	Pop kkkkkkk into: (Array new: kkkkkkk)"	stream		nextPut: 138;		nextPut: size + 128! !!ParseNode methodsFor: 'printing' stamp: 'eem 6/2/2008 11:47'!printWithClosureAnalysisOn: aStream 	"Refer to the comment in Object|printOn:."	aStream nextPut: ${.	self printWithClosureAnalysisOn: aStream indent: 0.	aStream nextPut: $}.! !!ParseNode methodsFor: 'private' stamp: 'eem 5/14/2008 17:29'!notYetImplemented	self flag: 'remove eventually'.	self error: 'Not yet implemented (', thisContext sender printString, ')'! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 6/3/2008 12:33'!noteBlockExtent: blockExtent hasLocals: tempNodes	blockExtentsToLocals ifNil:		[blockExtentsToLocals := Dictionary new].	blockExtentsToLocals at: blockExtent put: tempNodes asArray! !!BytecodeEncoder methodsFor: 'testing' stamp: 'eem 7/17/2008 12:34'!supportsClosureOpcodes	"Answer if the receiver supports the		genPushNewArray:/genPushConsArray:		genPushRemoteTemp:inVectorAt:		genStoreRemoteTemp:inVectorAt:		genStorePopRemoteTemp:inVectorAt:		genPushClosureCopyCopiedValues:numArgs:jumpSize:	 opcodes"	^false! !!RemoteTempVectorNode methodsFor: 'code generation (closures)' stamp: 'eem 5/24/2008 18:23'!sizeCodeForStorePopInto: aTempVariableNode encoder: encoder	encoder supportsClosureOpcodes ifTrue:		[^encoder sizeStorePopRemoteTemp: (remoteTemps indexOf: aTempVariableNode) - 1 inVectorAt: index].	^(self sizeCodeForStoreInto: aTempVariableNode encoder: encoder)	+ encoder sizePop! !!ParseNode class methodsFor: 'accessing' stamp: 'eem 5/21/2008 13:18'!pushNilCode	^LdNil! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:07'!referencedValuesWithinBlockExtent: anInterval 	^(localsPool select:		[:temp|		 temp isReferencedWithinBlockExtent: anInterval]) collect:			[:temp|			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]! !!ParseNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeCodeForValue: encoder! !!TempVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStore: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStoreInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStoreTemp: index! !!Compiler methodsFor: 'private' stamp: 'eem 5/15/2008 15:11'!translate: aStream noPattern: noPattern ifFail: failBlock	^self parser		parse: aStream		class: class		category: category		noPattern: noPattern		context: context		notifying: requestor		ifFail: [^failBlock value]! !BlockNode removeSelector: #returnSelfIfNoOther!MessageNode removeSelector: #printKeywords:arguments:on:indent:prefix:!MessageAsTempNode removeSelector: #isTemp!MessageAsTempNode removeSelector: #scope!Decompiler removeSelector: #checkForBlock:!TempVariableNode removeSelector: #isArg:!Parser removeSelector: #temporaryBlockVariables!MethodNode removeSelector: #sourceMap!MessageAsTempNode removeSelector: #scope:!MessageAsTempNode removeSelector: #nowHasRef!MessageAsTempNode removeSelector: #nowHasDef!MessageNode initialize!