"Change Set:		8511System-ar.200System-ar.200:CompiledMethodTrailer phase 1: Preparations.System-nice.199:Cosmetic changes from Pharo- use notNil- use ifAbsentPut:Cosmetic clean up from me:- remove misleading (file position: position - 150) when looking at preamble."!!ChangeSet class methodsFor: 'filein/out' stamp: 'marcus.denker 9/14/2008 21:10'!superclassOrder: classes	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in. Do it in sets instead of ordered collections.	SqR 4/12/2000 22:04"	| all list aClass inclusionSet aClassIndex cache |	list := classes copy. "list is indexable"	inclusionSet := list asSet. cache := Dictionary new.	all := OrderedCollection new: list size.	list size timesRepeat:		[			aClassIndex := list findFirst: [:one | one notNil and: 				[self doWeFileOut: one given: inclusionSet cache: cache]].			aClass := list at: aClassIndex.			all addLast: aClass.			inclusionSet remove: aClass.			list at: aClassIndex put: nil		].	^all! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'Lukas Renggli 11/2/2009 00:29'!findOrMakeMethodChangeAt: selector priorMethod: priorMethod 	^methodChanges at: selector		ifAbsentPut: [MethodChangeRecord new priorMethod: priorMethod]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'Igor.Stasenko 12/20/2009 03:53'!testFormatter	"Smalltalk testFormatter"	"Reformats the source for every method in the system, and	then compiles that source and verifies that it generates	identical code. The formatting used will be either classic	monochrome or fancy polychrome, depending on the setting	of the preference #colorWhenPrettyPrinting." 		"Note: removed references to Preferences colorWhenPrettyPrinting and replaced them simply with false, as I've been removing this preference lately. --Ron Spengler 8/23/09"	| newCodeString methodNode oldMethod newMethod badOnes n |	badOnes := OrderedCollection new.	self forgetDoIts.	'Formatting all classes...' 		displayProgressAt: Sensor cursorPoint		from: 0		to: CompiledMethod instanceCount		during: 			[:bar | 			n := 0.			self systemNavigation allBehaviorsDo: 					[:cls | 					"Transcript cr; show: cls name."					cls selectorsDo: 							[:selector | 							(n := n + 1) \\ 100 = 0 ifTrue: [bar value: n].							newCodeString := cls prettyPrinterClass 										format: (cls sourceCodeAt: selector)										in: cls										notifying: nil										decorated: false.							methodNode := cls compilerClass new 										compile: newCodeString										in: cls										notifying: nil										ifFail: [].							newMethod := methodNode generate.							oldMethod := cls compiledMethodAt: selector.							oldMethod = newMethod 								ifFalse: 									[Transcript										cr;										show: '***' , cls name , ' ' , selector.									badOnes add: cls name , ' ' , selector]]]].	self systemNavigation browseMessageList: badOnes asSortedCollection		name: 'Formatter Discrepancies'! !!ChangeSet class methodsFor: 'scanning' stamp: 'nice 12/22/2009 00:24'!scanVersionsOf: method class: class meta: meta category: cat selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp changeList file |	changeList := OrderedCollection new.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:[:x | x ifNotNil:[x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil] whileTrue:[		preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-3) = #stamp: ifTrue:[					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size-2.					prevPos := tokens last.					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.					prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos.				] ifFalse: ["Old format gives no stamp; prior pointer in two parts"					prevPos := tokens at: tokens size-2.					prevFileIndex := tokens last.				].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]			].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-1) = #stamp: ifTrue: [					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size.			]		]. 		changeList add: (ChangeRecord new file: file position: position type: #method						class: class name category: cat meta: meta stamp: stamp).		position := prevPos.		prevPos notNil ifTrue:[file := sourceFilesCopy at: prevFileIndex].	].	sourceFilesCopy do: [:x | x ifNotNil:[x close]].	^changeList! !