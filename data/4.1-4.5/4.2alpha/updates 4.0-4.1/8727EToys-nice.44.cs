"Change Set:		8727EToys-nice.44EToys-nice.44:move #basicType to EToysremove some #or:or: #and:and: sends"!!Point methodsFor: '*eToys-tiles' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Player methodsFor: '*eToys-tiles' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Player! !!Text methodsFor: '*eToys-tiles' stamp: 'tk 11/1/2001 14:37'!basicType	"Answer a symbol representing the inherent type I hold"	"Number String Boolean player collection sound color etc"	^ #Text! !!Number methodsFor: '*eToys-tiles' stamp: 'sw 10/31/97 13:54'!newTileMorphRepresentative	^ TileMorph new addArrows; setLiteral: self; addSuffixIfCan! !!StringHolder methodsFor: '*eToys-tiles' stamp: 'di 11/4/2000 11:07'!openSyntaxView	"Open a syntax view on the current method"	| class selector |	(selector := self selectedMessageName) ifNotNil: [		class := self selectedClassOrMetaClass.		SyntaxMorph testClass: class andMethod: selector.	]! !!Player methodsFor: 'scripts-kernel' stamp: 'nice 1/1/2010 22:10'!acceptableScriptNameFrom: originalString forScriptCurrentlyNamed: currentName	"Produce an acceptable script name, derived from the current name, for the receiver.  This method will always return a valid script name that will be suitable for use in the given situation, though you might not like its beauty sometimes."	| aString stemAndSuffix proscribed stem suffix withoutColon currentNumArgs withColon |	withoutColon := originalString copyWithoutAll: {$:. $ }.	(currentName notNil and: [(currentName copyWithout: $:) = withoutColon])		ifTrue:			[^ currentName].  "viz. no change; otherwise, the #respondsTo: check gets in the way"	currentNumArgs := currentName ifNil: [0] ifNotNil: [currentName numArgs].	aString := withoutColon asIdentifier: false.  "get an identifier starting with a lowercase letter"	stemAndSuffix := aString stemAndNumericSuffix.	proscribed := #(self super thisContext costume costumes dependents #true #false size).	stem := stemAndSuffix first.	suffix := stemAndSuffix last.	withoutColon := aString asSymbol.	withColon := (withoutColon, ':') asSymbol.	[(proscribed includes: withoutColon)		or: [(self respondsTo: withoutColon)		or: [(self respondsTo: withColon)		or:	[(Smalltalk includesKey: withoutColon)		or: [(Smalltalk includesKey: withColon)]]]]]	whileTrue:		[suffix := suffix + 1.		withoutColon := (stem, suffix printString) asSymbol.		withColon := (withoutColon, ':') asSymbol].	^ currentNumArgs = 0		ifTrue:			[withoutColon]		ifFalse:			[withColon]! !!Number methodsFor: '*eToys-tiles' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Number! !!TilePadMorph methodsFor: 'miscellaneous' stamp: 'nice 1/1/2010 21:50'!morphToDropFrom: aMorph 	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| vwr |	(aMorph isKindOf: WatcherWrapper)		ifTrue: [^ aMorph getterTilesForDrop].	^ ((self type capitalized = #Graphic)  "Special-case requested by Alan 4/30/05"		and: [(aMorph isKindOf: TileMorph) and: [aMorph resultType = #Player]])			ifFalse:				[aMorph]			ifTrue:				[vwr := CategoryViewer new initializeFor: aMorph associatedPlayer categoryChoice: #basic.				vwr getterTilesFor: (Utilities getterSelectorFor: #graphic)  type: #Graphic]! !!Object methodsFor: '*eToys-tiles' stamp: 'sw 8/22/97 13:14'!newTileMorphRepresentative	^ TileMorph new setLiteral: self! !!Object methodsFor: '*eToys-tiles' stamp: 'sw 9/26/2001 11:58'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Object! !!TextMorph methodsFor: '*eToys-tiles' stamp: 'tk 11/1/2001 14:37'!basicType	"Answer a symbol representing the inherent type I hold"	"Number String Boolean player collection sound color etc"	^ #Text! !!ImageMorph methodsFor: '*eToys-tiles' stamp: 'tk 11/1/2001 12:43'!basicType	"Answer a symbol representing the inherent type I hold"	"Number String Boolean player collection sound color etc"	^ #Image! !!NumericReadoutTile methodsFor: '*eToys-tiles' stamp: 'tk 11/1/2001 12:41'!basicType	"Answer a symbol representing the inherent type I hold"	"Number String Boolean player collection sound color etc"	^ #Number! !!PhraseTileMorph methodsFor: 'mouse' stamp: 'nice 1/1/2010 22:03'!morphToDropInPasteUp: aPasteUp	"Answer the morph to drop in aPasteUp, given that the receiver is the putative droppee"	| actualObject itsSelector aScriptor pos aWatcher op |	((actualObject := self actualObject) isNil or: [actualObject costume isInWorld not]) ifTrue: [^ self].	self isCommand ifFalse:  "Can't expand to a scriptor, but maybe launch a watcher..."		[^ (Preferences dropProducesWatcher			and: [(#(unknown command) includes: self resultType) not			and: [(op := self operatorTile operatorOrExpression) notNil			and: [op numArgs = 0			and: [(Vocabulary gettersForbiddenFromWatchers includes: op) not]]]])			ifTrue:				[aWatcher := WatcherWrapper new fancyForPlayer: self associatedPlayer getter: op.				aWatcher position: self position]			ifFalse:				[self]].	self justGrabbedFromViewer ifFalse: [^ self].	actualObject assureUniClass.	itsSelector := self userScriptSelector.	pos := self position.	aScriptor := itsSelector isEmptyOrNil		ifFalse:			[actualObject scriptEditorFor: itsSelector]		ifTrue:			["It's a system-defined selector; construct an anonymous scriptor around it"			actualObject newScriptorAround: self].	aScriptor ifNil:[^self].	(self hasOwner: aScriptor) ifTrue:[		aScriptor fullBounds. "force layout"		aScriptor position: pos - self position.	] ifFalse:[		aScriptor position: self position.	].	^ aScriptor! !!SketchMorph methodsFor: '*eToys-tiles' stamp: 'tk 11/1/2001 12:42'!basicType	"Answer a symbol representing the inherent type I hold"	"Number String Boolean player collection sound color etc"	^ #Image! !!UndefinedObject methodsFor: '*eToys-tiles' stamp: 'sw 10/29/1998 16:34'!newTileMorphRepresentative	^ UndescribedTile new! !!Boolean methodsFor: '*eToys-tiles' stamp: 'sw 8/20/1999 17:42'!newTileMorphRepresentative	^ TileMorph new addArrows; setLiteral: self! !!String methodsFor: '*eToys-tiles' stamp: 'ar 4/10/2005 17:06'!newTileMorphRepresentative	^ TileMorph new setLiteral: self;addSuffixIfCan! !!Boolean methodsFor: '*eToys-tiles' stamp: 'sw 9/27/2001 17:19'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Boolean! !!Player methodsFor: 'misc' stamp: 'nice 1/1/2010 21:54'!offerViewerMenuFor: aViewer event: evt	"Put up the Viewer menu on behalf of the receiver.  If the shift key is held down, put up the alternate menu. The menu omits the 'add a new variable' item when in eToyFriendly mode, as per request from teachers using Squeakland in 2003 once the button for adding a new variable was added to the viewer"	| aMenu aWorld  |	(evt notNil and: [evt shiftPressed and: [Preferences eToyFriendly not]]) ifTrue:[		^ self offerAlternateViewerMenuFor: aViewer event: evt	].	aWorld := aViewer world.	aMenu := MenuMorph new defaultTarget: self.	aMenu title: self externalName.	aMenu addStayUpItem.	self costume renderedMorph offerCostumeViewerMenu: aMenu.	Preferences eToyFriendly ifFalse: "exclude this from squeakland-like UI "		[aMenu add: 'add a new variable' translated target: self action: #addInstanceVariable.		aMenu balloonTextForLastItem: 'Add a new variable to this object and all of its siblings.  You will be asked to supply a name for it.' translated].	aMenu add: 'add a new script' translated target: aViewer action: #newPermanentScript.	aMenu balloonTextForLastItem: 'Add a new script that will work for this object and all of its siblings' translated.	aMenu addLine.	self hasCostumeThatIsAWorld ifFalse:[		aMenu add: 'grab me' translated target: self selector: #grabPlayerIn: argument: aWorld.		aMenu balloonTextForLastItem: 'This will actually pick up the object this Viewer is looking at, and hand it to you.  Click the (left) button to drop it' translated.	].	aMenu add: 'reveal me' translated target: self selector: #revealPlayerIn: argument: aWorld.	aMenu balloonTextForLastItem: 'If you have misplaced the object that this Viewer is looking at, use this item to (try to) make it visible' translated.	aMenu addLine.	aMenu add: 'tile representing me' translated action: #tearOffTileForSelf.	aMenu add: 'add search pane' translated target: aViewer action: #addSearchPane.	Preferences eToyFriendly ifFalse:[		aMenu addLine.		aMenu add: 'more...' translated target: self selector: #offerAlternateViewerMenuFor:event: argumentList: {aViewer. evt}.	].	aMenu popUpEvent: evt in: aWorld! !!String methodsFor: '*eToys-tiles' stamp: 'yo 11/3/2004 19:24'!basicType	"Answer a symbol representing the inherent type of the receiver"	"Number String Boolean player collection sound color etc"	^ #String! !!Color methodsFor: '*eToys-tiles' stamp: 'sw 6/10/1998 17:50'!newTileMorphRepresentative	^ ColorTileMorph new colorSwatchColor: self! !!Color methodsFor: '*eToys-tiles' stamp: 'sw 9/27/2001 17:26'!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Color! !