"Change Set:		9773Nebraska-nice.28Nebraska-nice.28:Fix underscores"!!StringSocket methodsFor: 'private-IO' stamp: 'yo 10/10/2005 18:49'!addToInBuf: aString	| newAlloc |	newAlloc := aString size * 2 max: 80000.	inBuf ifNil: [		inBuf := String new: newAlloc.		inBufIndex := 1.		inBufLastIndex := 0.	].	aString size > (inBuf size - inBufLastIndex) ifTrue: [		inBuf := inBuf , (String new: newAlloc)	].	inBuf 		replaceFrom: inBufLastIndex + 1 		to: inBufLastIndex + aString size		with: aString 		startingAt: 1.	inBufLastIndex := inBufLastIndex + aString size.! !!CanvasDecoder class methodsFor: 'class initialization' stamp: 'yo 12/15/2005 16:07'!initialize	"CanvasDecoder initialize"	"Set up my cache and decode table if necessary."	CachedForms ifNil: [CachedForms := Array new: 100].	DecodeTable ifNotNil: [ ^self ].	DecodeTable := Array new: 128.	#((codeClip setClip:)	(codeTransform setTransform:)	(codeText drawText:)	(codeLine drawLine:)	(codeRect drawRect:)	(codeBalloonRect drawBalloonRect:)	(codeBalloonOval drawBalloonOval:)	(codeInfiniteFill drawInfiniteFill:)	(codeOval drawOval:)	(codeImage drawImage:)	(codeReleaseCache releaseImage:)	(codePoly drawPoly:)	(codeStencil drawStencil:)	(codeForce forceToScreen:)	(codeFont addFontToCache:)	(codeFontSet addFontSetToCache:)	(codeMultiText drawMultiText:) 	(codeTTCFont addTTCFontToCache:)	(codeExtentDepth extentDepth:)	(codeShadowColor shadowColor:))		do: [ :arr |			(DecodeTable at: ((CanvasEncoder perform: arr first) asciiValue + 1)) ifNotNil: [self error: 'duplicated code'].			DecodeTable				at: ((CanvasEncoder perform: arr first) asciiValue + 1)				put: arr second		].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'yo 10/6/2005 17:00'!image: aForm at: aPoint sourceRect: sourceRect rule: argRule	| cacheID cacheNew cacheReply formToSend cacheEntry destRect visRect aFormArea d2 rule |	rule := argRule.	"first if we are only going to be able to draw a small part of the form,	it may be faster just to send the part of the form that will actually show up"	destRect := aPoint extent: sourceRect extent.	d2 := (lastTransform invertBoundsRect: destRect) expandBy: 1.	(d2 intersects: lastClipRect) ifFalse: [		^NebraskaDebug at: #bigImageSkipped add: {lastClipRect. d2}.	].	aFormArea := aForm boundingBox area.	(aFormArea > 20000 and: [aForm isStatic not and: [lastTransform isPureTranslation]]) ifTrue: [		visRect := destRect intersect: lastClipRect.		visRect area < (aFormArea // 20) ifTrue: [			"NebraskaDebug 				at: #bigImageReduced 				add: {lastClipRect. aPoint. sourceRect extent. lastTransform}."			formToSend := aForm copy: (visRect translateBy: sourceRect origin - aPoint).			formToSend depth = 32 ifTrue: [formToSend := formToSend asFormOfDepth: 16. rule = 24 ifTrue: [rule := 25]].			^self 				image: formToSend 				at: visRect origin 				sourceRect: formToSend boundingBox				rule: rule				cacheID: 0 		"no point in trying to cache this - it's a one-timer"				newToCache: false.		].	].	cacheID := 0.	cacheNew := false.	formToSend := aForm.	(aFormArea > 1000 and: [(cacheReply := self testCache: aForm) notNil]) ifTrue: [		cacheID := cacheReply first.		cacheEntry := cacheReply third.		(cacheNew := cacheReply second) ifFalse: [			formToSend := aForm isStatic 				ifTrue: [nil] 				ifFalse: [aForm depth <= 8 ifTrue: [aForm] ifFalse: [aForm deltaFrom: cacheEntry fourth]].		].		cacheEntry at: 4 put: (aForm isStatic ifTrue: [aForm] ifFalse: [aForm deepCopy]).	].	(formToSend notNil and: [formToSend depth = 32]) ifTrue: [formToSend := formToSend asFormOfDepth: 16. rule = 24 ifTrue: [rule := 25]].	self		image: formToSend 		at: aPoint 		sourceRect: sourceRect 		rule: rule 		cacheID: cacheID 		newToCache: cacheNew.! !!StringSocket methodsFor: 'as yet unclassified' stamp: 'yo 10/10/2005 18:47'!readBuffer	^ readBuffer ifNil: [readBuffer := String new: 20000].! !!StringSocket methodsFor: 'private-IO' stamp: 'yo 10/10/2005 18:47'!processInput	| totalReceived chunkOfData |	"do as much input as possible"	self flag: #XXX.  "should have resource limits here--no more than X objects and Y bytes"	chunkOfData := socket receiveAvailableDataIntoBuffer: self readBuffer.	self addToInBuf: chunkOfData.	totalReceived := chunkOfData size.	totalReceived > 0 ifTrue: [		NebraskaDebug at: #SendReceiveStats add: {'GET'. totalReceived}.	].	[ self gotSomething ] whileTrue: [].		"decode as many string arrays as possible"	self shrinkInBuf.! !!NebraskaServerMorph class methodsFor: 'as yet unclassified' stamp: 'yo 12/17/2005 23:07'!serveWorldButton	| button |	button := ScriptableButton new.	button target: NebraskaServerMorph.	button actionSelector: #serveWorld.	button arguments: #().	button label: 'Share'.	button color: Color yellow.	^ button.! !!RemoteCanvas methodsFor: 'drawing-rectangles' stamp: 'yo 10/6/2005 15:53'!fillRectangle: aRectangle fillStyle: aFillStyle	"Fill the given rectangle."	| pattern |	(self isShadowDrawing not and: [self shadowColor notNil]) ifTrue:		[^self fillRectangle: aRectangle color: self shadowColor].	(aFillStyle isKindOf: InfiniteForm) ifTrue: [		^self infiniteFillRectangle: aRectangle fillStyle: aFillStyle	].	(aFillStyle isSolidFill) 		ifTrue:[^self fillRectangle: aRectangle color: aFillStyle asColor].	"We have a very special case for filling with infinite forms"	(aFillStyle isBitmapFill and:[aFillStyle origin = (0@0)]) ifTrue:[		pattern := aFillStyle form.		(aFillStyle direction = (pattern width @ 0) 			and:[aFillStyle normal = (0@pattern height)]) ifTrue:[				"Can use an InfiniteForm"				^self fillRectangle: aRectangle color: (InfiniteForm with: pattern)].	].	"Use a BalloonCanvas instead"	self balloonFillRectangle: aRectangle fillStyle: aFillStyle.! !!CanvasEncoder methodsFor: 'drawing' stamp: 'yo 12/17/2005 22:44'!drawString: s from: firstIndex to: lastIndex in: boundsRect font: fontOrNil color: c	| fontIndex str |	fontIndex := self establishFont: (fontOrNil ifNil: [ TextStyle defaultFont ]).	str := s asString copyFrom: firstIndex to: lastIndex.	str isWideString ifTrue: [		self sendCommand: {			String with: CanvasEncoder codeMultiText.			str asByteArray asString.			self class encodeRectangle: boundsRect.			self class encodeInteger: fontIndex.			self class encodeColor: c		}	] ifFalse: [		self sendCommand: {			String with: CanvasEncoder codeText.			str.			self class encodeRectangle: boundsRect.			self class encodeInteger: fontIndex.			self class encodeColor: c		}	].! !!StrikeFont class methodsFor: '*nebraska-instance creation' stamp: 'yo 12/17/2005 22:41'!decodedFromRemoteCanvas: aString	| array style base |	array := aString findTokens: #($ ).	style := TextStyle named: (array at: 1) asSymbol.	style ifNil: [^ TextStyle defaultFont].	(style fontArray first name = style fontArray first name withoutTrailingDigits) ifTrue: [			^ self familyName: (array at: 1) size: (array at: 3) asNumber emphasized: (array at: 4) asNumber].	base := style fontArray detect: [:f | (array at: 2) beginsWith: f name].	^ base emphasized: (array at: 4) asNumber.	"^ self familyName: (array at: 1) size: (array at: 2) asNumber emphasized: (array at: 3) asNumber."! !CanvasDecoder initialize!