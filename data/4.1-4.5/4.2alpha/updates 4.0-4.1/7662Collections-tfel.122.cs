"Change Set:		7662Collections-tfel.122Collections-tfel.122:For the Method asHtml we have HtmlEntities as class-side Dictionary. I propose to use it for asUnHtml as well and fail silently if we couldn't find a match instead of throwing an Error saying 'please add the missing entity to this method'Collections-dtl.119:Reference Mantis 7221: Remove some leftover VMMaker methods from base images.Remove several C code generation methods that have previously been recategorized to the VMMaker package.Collections-ar.120:PositionableStream>>upToAnyOf: is just like #upTo: but allows for a collection of elements to be matched against. Very useful when there is a potential set of matches ahead, for example when dealing with a mixture of cr and lfs in files, such as in:[stream atEnd] whileFalse:[	(stream upToAnyOf: String crlf) ifNotEmpty:[:line| 'etc'].].Collections-ar.121:Adds String>>asPrecomposedUnicode and String>>asDecomposedUnicode for quick conversions between precomposed and decomposed Unicode string representations."!!String methodsFor: 'converting' stamp: 'tfel 8/28/2009 21:15'!asUnHtml	"Strip out all Html stuff (commands in angle brackets <>) and convertthe characters &<> back to their real value.  Leave actual cr and tab asthey were in text."	| in out char rest |	in := ReadStream on: self.	out := WriteStream on: (String new: self size).	[in atEnd] whileFalse:		[in peek = $<			ifTrue: [in unCommand] 	"Absorb <...><...>"			ifFalse: [(char := in next) = $&						ifTrue: [rest := in upTo: $;.								out nextPut: (HtmlEntities									at: rest									ifAbsent: [Character space])]						ifFalse: [out nextPut: char]].		].	^ out contents! !!String methodsFor: 'converting' stamp: 'ar 8/27/2009 20:41'!asPrecomposedUnicode	"Convert the receiver into a precomposed Unicode representation.	Optimized for the common case that no composition needs to take place."	| lastIndex nextIndex composed out |	lastIndex := 1.	nextIndex := 0.	[(nextIndex := nextIndex+1) < self size] whileTrue:[		composed := Unicode compose: (self at: nextIndex) with: (self at: nextIndex+1).		composed ifNotNil:[			lastIndex = 1 ifTrue:[out := WriteStream on: (String new: self size)].			out nextPutAll: (self copyFrom: lastIndex to: nextIndex-1).			out nextPut: composed.			nextIndex := nextIndex+1.			lastIndex := nextIndex+1.		].	].	^out ifNil:[self] ifNotNil:[		out nextPutAll: (self copyFrom: lastIndex to: self size).		out contents]! !!String methodsFor: 'converting' stamp: 'ar 8/27/2009 20:41'!asDecomposedUnicode	"Convert the receiver into a decomposed Unicode representation.	Optimized for the common case that no decomposition needs to take place."	| lastIndex nextIndex out decomposed |	lastIndex := 1.	nextIndex := 0.	[(nextIndex := nextIndex+1) <= self size] whileTrue:[		decomposed := Unicode decompose: (self at: nextIndex).		decomposed ifNotNil:[			lastIndex = 1 ifTrue:[out := WriteStream on: (String new: self size)].			out nextPutAll: (self copyFrom: lastIndex to: nextIndex-1).			out nextPutAll: decomposed.			lastIndex := nextIndex+1.		].	].	^out ifNil:[self] ifNotNil:[		out nextPutAll: (self copyFrom: lastIndex to: self size).		out contents]! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 8/17/2009 21:06'!upToAnyOf: aCollection 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of any object in the collection. If 	no matching object is found, answer the entire rest of the receiver."	| newStream element |	newStream := WriteStream on: (collection species new: 100).	[self atEnd or: [aCollection includes: (element := self next)]]		whileFalse: [newStream nextPut: element].	^newStream contents! !ArrayedCollection class removeSelector: #ccg:generateCoerceToValueFrom:on:!ArrayedCollection class removeSelector: #ccg:generateCoerceToOopFrom:on:!