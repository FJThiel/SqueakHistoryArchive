"Change Set:		7462MorphicExtras-ar.37MorphicExtras-ar.37:UIManagerization. Replaces all the trivial references to PopUpMenu, SelectionMenu, CustomMenu, and FillInTheBlank."!!BookMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:38'!goToPage	| pageNum |	pageNum := UIManager default request: 'Page?' translated initialAnswer: '0'.	pageNum isEmptyOrNil ifTrue: [^true].	self goToPage: pageNum asNumber.! !!MagnifierMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 18:54'!chooseMagnification	| result |	result := UIManager default chooseFrom: #(1.5 2 4 8) values: #(1.5 2 4 8) 		title:  ('Choose magnification(currently {1})' translated format:{magnification}).	(result isNil or: [result = magnification]) ifTrue: [^ self].	magnification := result.	self extent: self extent. "round to new magnification"	self changed. "redraw even if extent wasn't changed"! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'ar 8/6/2009 20:47'!renameEntry	| reply curr |	reply := UIManager default		request: 'New key? '		initialAnswer: (curr := entryNames at: currentIndex).	(reply isEmptyOrNil or: [reply = curr]) ifTrue: [^ Beeper beep].	(baseDictionary includesKey: reply) ifTrue:		[^ self inform: 'sorry that conflicts withthe name of anotherentry in this dictionary'].	baseDictionary at: reply put: (baseDictionary at: curr).	baseDictionary removeKey: curr.	self baseDictionary: baseDictionary.	self updateThumbnail! !!StringButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 19:10'!setActWhen	| selections |	selections := #(buttonDown buttonUp whilePressed).	actWhen := UIManager default 		chooseFrom: (selections collect: [:t | t translated]) 		values: selections		title: 'Choose one of the following conditions' translated.! !!BookMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:39'!textSearch	"search the text on all pages of this book"	| wanted wants list str |	list := self valueOfProperty: #searchKey ifAbsent: [#()].	str := String streamContents: [:strm | 			list do: [:each | strm nextPutAll: each; space]].	wanted := UIManager default request: 'words to search for.  Order is not important.Beginnings of words are OK.' translated		initialAnswer: str.	wants := wanted findTokens: Character separators.	wants isEmpty ifTrue: [^ self].	self getAllText.		"save in allText, allTextUrls"	^ self findText: wants	"goes to the page and highlights the text"! !!ZASMScriptMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 20:46'!saveScript	| newScript scriptName |	newScript := self compileScript.	scriptName := UIManager default 		request: 'Name this script' 		initialAnswer: (self valueOfProperty: #cameraScriptName ifAbsent: ['']).	scriptName isEmptyOrNil ifTrue: [^self].	(self valueOfProperty: #cameraController)		saveScript: newScript		as: scriptName.	self delete.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:39'!adjustScale: evt 	| scaleString oldScale baseValue |	oldScale := envelope scale.	scaleString := UIManager default request: 'Enter the new full-scale value...'				initialAnswer: oldScale printString.	scaleString isEmpty ifTrue: [^self].	envelope scale: (Number readFrom: scaleString) asFloat.	baseValue := envelope updateSelector = #pitch: ifTrue: [0.5] ifFalse: [0.0].	envelope 		setPoints: (envelope points collect: 					[:p | 					p x @ ((p y - baseValue) * oldScale / envelope scale + baseValue min: 1.0								max: 0.0)])		loopStart: (limits first)		loopEnd: (limits second).	self buildView! !!BookMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 18:15'!savePagesOnURL	"Write out all pages in this book onto a server.  For any page that does not have a SqueakPage and a url already, ask the user for one.  Give the option of naming all page files by page number.  Any pages that are not in memory will stay that way.  The local disk could be the server."	| response list firstTime newPlace rand dir bookUrl |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	self getAllText.	"stored with index later"	response := UIManager default chooseFrom:  {		'Use page numbers' translated.		'Type in file names' translated.		'Save in a new place (using page numbers)' translated.		'Save in a new place (typing names)' translated.		'Save new book sharing old pages' translated.	} title:  'Each page will be a file on the server.  Do you want to page numbers be the names of the files? or name each one yourself?' translated.	response = 1 ifTrue: [self saveAsNumberedURLs. ^ self].	response = 3 ifTrue: [self forgetURLs; saveAsNumberedURLs. ^ self].	response = 4 ifTrue: [self forgetURLs].	response = 5 ifTrue: [		"Make up new url for .bo file and confirm with user."  "Mark as shared"		[rand := String new: 4.		1 to: rand size do: [:ii |			rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].		(newPlace := self getStemUrl) isEmpty ifTrue: [^ self].		newPlace := (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.		dir := ServerFile new fullPath: newPlace.		(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"		self setProperty: #url toValue: newPlace.		self saveAsNumberedURLs. 		bookUrl := self valueOfProperty: #url.		(SqueakPage stemUrl: bookUrl) = 			(SqueakPage stemUrl: currentPage url) ifTrue: [				bookUrl := true].		"not a shared book"		(URLMorph grabURL: currentPage url) book: bookUrl.		^ self].	response = 0 ifTrue: [^ self]."self reserveUrlsIfNeeded.	Need two passes here -- name on one, write on second"pages do: [:aPage |	"does write the current page too"	aPage isInMemory ifTrue: ["not out now"		aPage presenter ifNotNil: [aPage presenter flushPlayerListCache].		aPage saveOnURLbasic.		]].	"ask user if no url"list := pages collect: [:aPage |	 aPage sqkPage prePurge].	"knows not to purge the current page"list := (list select: [:each | each notNil]) asArray."do bulk become:"(list collect: [:each | each contentsMorph])	elementsExchangeIdentityWith:		(list collect: [:spg | MorphObjectOut new xxxSetUrl: spg url page: spg]).firstTime := (self valueOfProperty: #url) isNil.self saveIndexOnURL.self presenter ifNotNil: [self presenter flushPlayerListCache].firstTime ifTrue: ["Put a thumbnail into the hand"	URLMorph grabForBook: self.	self setProperty: #futureUrl toValue: nil].	"clean up"! !!Morph class methodsFor: '*MorphicExtras-arrow head size' stamp: 'ar 8/6/2009 20:42'!obtainArrowheadFor: aPrompt defaultValue: defaultPoint	"Allow the user to supply a point to serve as an arrowhead size.  Answer nil if we fail to get a good point"	| result  |	result := UIManager default request: aPrompt initialAnswer: defaultPoint asString.	result isEmptyOrNil ifTrue: [^ nil].	^ [(Point readFrom: (ReadStream on: result))]		on: Error do: [:ex |  nil].! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 18:20'!removeEnvelope	(UIManager default confirm: 'Really remove ' , envelope name , '?')		ifFalse: [^ self].	sound removeEnvelope: envelope.	self editEnvelope: sound envelopes first.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 20:45'!addJumpEnd	| ed attribute jumpLabel selectedString |	ed := self editor.	selectedString := ed selection asString.	selectedString isEmpty ifTrue: [^self inform: 'Please select something first'].	jumpLabel := UIManager default request: 'Name this place' initialAnswer: selectedString.	jumpLabel isEmpty ifTrue: [^self].	self removeJumpEndFor: jumpLabel.	attribute := TextPlusJumpEnd new jumpLabel: jumpLabel.	ed replaceSelectionWith: (ed selection addAttribute: attribute).! !!DropDownChoiceMorph methodsFor: 'event handling' stamp: 'ar 8/6/2009 20:07'!mouseDown: evt	| selectedItem |	self items isEmpty ifTrue: [^ self].	selectedItem := UIManager default chooseFrom: self items values: self items.	selectedItem ifNil: [^ self].	self contentsClipped: selectedItem.  "Client can override this if necess"	actionSelector ifNotNil: [		target			perform: actionSelector			withArguments: (arguments copyWith: selectedItem)].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45'!setMinVal	| newMinVal |	newMinVal := UIManager default		request: 'Minimum value?'		initialAnswer: minVal printString.	newMinVal isEmpty ifFalse: [		minVal := newMinVal asNumber.		maxVal := maxVal max: minVal].! !!Flaps class methodsFor: 'new flap' stamp: 'ar 8/6/2009 20:40'!addLocalFlap	"Menu command -- let the user add a new project-local flap.  Once the new flap is born, the user can tell it to become a shared flap.  Obtain an initial name and edge for the flap, launch the flap, and also launch a menu governing the flap, so that the user can get started right away with customizing it."	| aMenu reply aFlapTab aWorld edge |	aMenu := MenuMorph entitled: 'Where should the new flap cling?' translated.	aMenu defaultTarget: aMenu.	#(left right top bottom) do:		[:sym | aMenu add: sym asString translated selector: #selectMVCItem: argument: sym].	edge := aMenu invokeModalAt: self currentHand position in: self currentWorld.	edge ifNotNil:		[reply := UIManager default request: 'Wording for this flap: ' translated initialAnswer: 'Flap' translated.		reply isEmptyOrNil ifFalse:			[aFlapTab := self newFlapTitled: reply onEdge: edge.			(aWorld := self currentWorld) addMorphFront: aFlapTab.			aFlapTab adaptToWorld: aWorld.			aMenu := aFlapTab buildHandleMenu: ActiveHand.			aFlapTab addTitleForHaloMenu: aMenu.			aFlapTab computeEdgeFraction.			aMenu popUpEvent: ActiveEvent in: ActiveWorld]]	! !!BookMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 18:15'!saveOnUrlPage: pageMorph	"Write out this single page in this book onto a server.  See savePagesOnURL.  (Don't compute the texts, only this page's is written.)"	| stem ind response rand newPlace dir |	(self valueOfProperty: #keepTogether) ifNotNil: [		self inform: 'This book is marked ''keep in one file''. Several pages use a common Player.Save the owner of the book instead.' translated.		^ self].	"Don't give the chance to put in a different place.  Assume named by number"	((self valueOfProperty: #url) isNil and: [pages first url notNil]) ifTrue: [		response := UIManager default chooseFrom: {			'Old book' translated.			'New book sharing old pages' translated		} title: 'Modify the old book, or make a newbook sharing its pages?' translated.		response = 2 ifTrue: [			"Make up new url for .bo file and confirm with user."  "Mark as shared"			[rand := String new: 4.			1 to: rand size do: [:ii |				rand at: ii put: ('bdfghklmnpqrstvwz' at: 17 atRandom)].			(newPlace := self getStemUrl) isEmpty ifTrue: [^ self].			newPlace := (newPlace copyUpToLast: $/), '/BK', rand, '.bo'.			dir := ServerFile new fullPath: newPlace.			(dir includesKey: dir fileName)] whileTrue.	"keep doing until a new file"			self setProperty: #url toValue: newPlace].		response = 0 ifTrue: [^ self]].	stem := self getStemUrl.	"user must approve"	stem isEmpty ifTrue: [^ self].	ind := pages identityIndexOf: pageMorph ifAbsent: [self error: 'where is the page?' translated].	pageMorph isInMemory ifTrue: ["not out now"			pageMorph saveOnURL: stem,(ind printString),'.sp'].	self saveIndexOfOnly: pageMorph.! !!StringButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := UIManager default		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 8/6/2009 20:40'!readTape	^ self readTape: (UIManager default							request: 'Tape to read'							initialAnswer: 'tapeName.tape').! !!GraphicalDictionaryMenu methodsFor: 'menu commands' stamp: 'ar 8/6/2009 20:40'!findEntry	"Prompt the user for a search string and find the next match for it"	| toFind searchIndex |	lastSearchString ifNil: [lastSearchString := 'controls'].	toFind := UIManager default request: 'Type name or fragment: ' initialAnswer: lastSearchString.	toFind isEmptyOrNil ifTrue: [^ self].	lastSearchString := toFind asLowercase.	searchIndex := currentIndex + 1.	toFind := '*', lastSearchString, '*'.	[toFind match: (entryNames at: searchIndex) asString]		whileFalse:			[searchIndex := (searchIndex \\ entryNames size) + 1.			searchIndex == currentIndex ifTrue: [^ self inform: 'not found']].	currentIndex := searchIndex.	self updateThumbnail! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 19:23'!editAScript	| d names reply s |	d := self targetScriptDictionary.	names := d keys asSortedCollection.	reply := UIManager default chooseFrom: names values: names title: 'Script to edit?'.	reply ifNil: [^ self].	(s := ZASMScriptMorph new)		decompileScript: (d at: reply) named: reply for: self;		fullBounds;		align: s center with: self center;		openInWorld	! !!WaveEditor methodsFor: 'menu' stamp: 'ar 8/6/2009 20:29'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu := MenuMorph new.	aMenu addList:	{		{'play straight through' translated.	#play}.		{'play before cursor' translated.	#playBeforeCursor}.		{'play after cursor' translated.		#playAfterCursor}.		{'play test note' translated.			#playTestNote}.		{'play loop' translated.				#playLoop}.		{'trim before cursor' translated.	#trimBeforeCursor}.		{'trim after cursor' translated.		#trimAfterCursor}.		{'choose loop start' translated.		#chooseLoopStart}.		{'jump to loop start' translated.		#jumpToLoopStart}.		{'jump to loop end' translated.		#jumpToLoopEnd}.		{'make unlooped' translated.		#setUnlooped}.		{'make unpitched' translated.		#setUnpitched}.		{'show envelope' translated.		#showEnvelope}.		{'show FFT' translated.				#showFFTAtCursor}}.	aMenu invokeModal.! !!Component methodsFor: 'naming' stamp: 'ar 8/6/2009 20:39'!chooseNameLike: someName 	| stem otherNames i partName |	stem := someName.	(stem size > 5 and: [stem endsWith: 'Morph'])		ifTrue: [stem := stem copyFrom: 1 to: stem size - 5].	stem := stem first asLowercase asString , stem allButFirst.	otherNames := self class allInstVarNames asSet.	"otherNames addAll: self world allKnownNames."	i := 1.	[otherNames includes: (partName := stem , i printString)]		whileTrue: [i := i + 1].	partName := UIManager default request: 'Please give this part a name'						initialAnswer: partName.	partName isEmpty ifTrue: [^ nil].	(otherNames includes: partName) ifTrue:			[self inform: 'Sorry, that name is already used'.			^ nil].	^ partName! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setMaxVal	| newMaxVal |	newMaxVal := UIManager default		request: 'Maximum value?'		initialAnswer: maxVal printString.	newMaxVal isEmpty ifFalse: [		maxVal := newMaxVal asNumber.		minVal := minVal min: maxVal].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setActionSelector	| oldSel newSel |	oldSel := setValueSelector isNil ifTrue: [''] ifFalse: [setValueSelector].	newSel := UIManager default 				request: 'Please type the selector to be sent tothe target when this slider is changed' translated				initialAnswer: oldSel.	newSel isEmpty ifFalse: [self actionSelector: newSel]! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setLabel	| newLabel |	newLabel := UIManager default		request:'Please a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'ar 8/6/2009 20:40'!writeTape	| args b |	args := (b := self button: 'writeTape') isNil 				ifTrue: [#()]				ifFalse: [b arguments].	(args notEmpty and: [args first notEmpty]) 		ifTrue: 			[args first.			self writeTape: args first]		ifFalse: 			[^self writeTape: (UIManager default request: 'Tape to write'								initialAnswer: 'tapeName.tape')].! !!BasicButton methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 20:38'!setLabel	| newLabel |	newLabel := UIManager default		request:'Enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self label: newLabel font: nil].! !!BookMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:38'!buildThreadOfProjects	| thisPVM projectNames threadName |	projectNames := pages collect: [ :each |		(thisPVM := each findA: ProjectViewMorph) ifNil: [			nil		] ifNotNil: [			{thisPVM project name}.		].	].	projectNames := projectNames reject: [ :each | each isNil].	threadName := UIManager default 		request: 'Please name this thread.' translated 		initialAnswer: (			self valueOfProperty: #nameOfThreadOfProjects ifAbsent: ['Projects on Parade' translated]		).	threadName isEmptyOrNil ifTrue: [^self].	InternalThreadNavigationMorph 		know: projectNames as: threadName;		openThreadNamed: threadName atIndex: nil.! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ar 8/6/2009 18:33'!deliverPainting: result evt: evt	"Done painting.  May come from resume, or from original call.  Execute user's post painting instructions in the block.  Always use this standard one.  4/21/97 tk"	| newBox newForm ans |	palette ifNotNil: "nil happens" [palette setAction: #paint: evt: evt].	"Get out of odd modes"	"rot := palette getRotations."	"rotate with heading, or turn to and fro"	"palette setRotation: #normal."	result == #cancel ifTrue: [		ans := UIManager default chooseFrom: {			 'throw it away' translated.			'keep painting it' translated.		} title: 'Do you really want to throw away what you just painted?' translated.		^ ans = 1 ifTrue: [self cancelOutOfPainting]				ifFalse: [nil]].	"cancelled out of cancelling."	"hostView rotationStyle: rot."		"rotate with heading, or turn to and fro"	newBox := paintingForm rectangleEnclosingPixelsNotOfColor: Color transparent.	registrationPoint ifNotNil:		[registrationPoint := registrationPoint - newBox origin]. "relative to newForm origin"	newForm := 	Form extent: newBox extent depth: paintingForm depth.	newForm copyBits: newBox from: paintingForm at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm isAllWhite ifTrue: [		(self valueOfProperty: #background) == true 			ifFalse: [^ self cancelOutOfPainting]].	newForm fixAlpha. "so alpha channel stays intact for 32bpp"	self delete.	"so won't find me again"	dimForm ifNotNil: [dimForm delete].	newPicBlock value: newForm value: (newBox copy translateBy: bounds origin).	ActiveWorld resumeScriptsPausedByPainting! !!FlapTab methodsFor: 'menu' stamp: 'ar 8/6/2009 20:40'!changeTabText	"Allow the user to change the text on the tab"	| reply |	reply := UIManager default		request: 'new wording for this tab:' translated		initialAnswer: self existingWording.	reply isEmptyOrNil ifTrue: [^ self].	self changeTabText: reply.! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:40'!saveToDisk: evt	| newName f |	newName := UIManager default request: 'Please confirm name for save...'						initialAnswer: soundName.	newName isEmpty ifTrue: [^ self].	f := FileStream newFileNamed: newName , '.fmp'.	sound storeOn: f.	f close! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'ar 8/6/2009 20:19'!doFindButtonMenuEvent: evt	| selection |	selection := UIManager default chooseFrom:{		'find a project' translated.		'find a project (more places)' translated.		'find any file' translated.		'search the SuperSwiki' translated.	} values: { 		[self findAProjectSimple].		[self findAProject].		[self findAnything].		[self findSomethingOnSuperSwiki].	} title: 'Find options' translated.	selection ifNil: [^self].	selection value.! !!ProjectNavigationMorph methodsFor: 'the buttons' stamp: 'ar 8/6/2009 18:32'!findSomethingOnSuperSwiki	| projectServers server index |	projectServers := ServerDirectory projectServers.	projectServers isEmpty		ifTrue: [^self].	projectServers size = 1		ifTrue: [server := projectServers first]		ifFalse: [index := UIManager default chooseFrom: (projectServers collect: [:each | (ServerDirectory nameForServer: each) translatedIfCorresponds]) 				title: 'Choose a super swiki:' translated.			index > 0				ifTrue: [server := projectServers at: index]				ifFalse: [^self]].	EToyProjectQueryMorph onServer: server! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:39'!setAtomCount	| countString count |	countString := UIManager default		request: 'Number of atoms?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count := Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ar 8/6/2009 18:50'!undoTo	"Not yet functional, and not yet sent.  Allow the user to choose a point somewhere in the undo/redo tape, and undo his way to there.   Applicable only if infiniteUndo is set. "	| anIndex commandList reply |	(anIndex := self historyIndexOfLastCommand) == 0 ifTrue: [^ Beeper beep].	commandList := history		copyFrom:	((anIndex - 10) max: 1)		to:			((anIndex + 10) min: history size).	reply := UIManager default chooseFrom: (commandList collect: [:cmd | cmd cmdWording truncateWithElipsisTo: 20]) values: commandList title: 'undo or redo to...'.	reply ifNotNil: [self inform: #deferred]	"ActiveWorld commandHistory undoTo"! !!ReferenceMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:43'!changeTabText	| reply |	reply := UIManager default		request: 'new wording for this tab:'		initialAnswer: submorphs first contents.	reply isEmptyOrNil ifFalse: [submorphs first contents: reply]! !!DSCPostscriptCanvasToDisk class methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 20:39'!morphAsPostscript: aMorph rotated: rotateFlag offsetBy: offset specs: specsOrNil	| newFileName stream |	^[		(self new morphAsPostscript: aMorph rotated: rotateFlag offsetBy: offset) close	]		on: PickAFileToWriteNotification		do: [ :ex |			newFileName := UIManager default				request: 'Name of file to write:' translated				initialAnswer: 'xxx',Time millisecondClockValue printString, self defaultExtension. 			newFileName isEmptyOrNil ifFalse: [				stream := FileStream fileNamed: newFileName.				stream ifNotNil: [ex resume: stream].			].		].! !!WaveEditor methodsFor: 'menu' stamp: 'ar 8/6/2009 20:30'!chooseLoopStart 	| bestLoops secs choice start labels values |	possibleLoopStarts ifNil: [		Utilities			informUser: 'Finding possible loop points...' translated			during: [possibleLoopStarts := self findPossibleLoopStartsFrom: graph cursor]].	bestLoops := possibleLoopStarts copyFrom: 1 to: (100 min: possibleLoopStarts size).	labels := OrderedCollection new.	values := OrderedCollection new.	bestLoops do: [:entry |		secs := ((loopEnd - entry first) asFloat / self samplingRate) roundTo: 0.01.		labels add: ('{1} cycles; {2} secs' translated format:{entry third. secs}).		values add: entry].	choice := UIManager default chooseFrom: labels values: values.	choice ifNil: [^ self].	loopCycles := choice third.	start := self fractionalLoopStartAt: choice first.	self loopLength: (loopEnd asFloat - start) + 1.0.! !!EnvelopeEditorMorph methodsFor: 'initialization' stamp: 'ar 8/6/2009 18:19'!editSound: aSound	| p |	(aSound respondsTo: #envelopes)		ifFalse: [			UIManager default inform: 'You selected a ', aSound class name, '.', String cr,				'I can''t handle these kinds of sounds.'.			^self ].	sound := aSound.	sound envelopes isEmpty ifTrue: [		"provide a default volume envelope"		p := OrderedCollection new.		p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.		sound addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3)].	self editEnvelope: sound envelopes first.	keyboard soundPrototype: sound.! !!TextPlusMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 20:26'!chooseOneJumpEnd	^UIManager default		chooseFrom: self allJumpEndStrings		values: self allJumpEndStrings		title: 'Possible jump ends'.	! !!EventRecorderMorph methodsFor: 'commands' stamp: 'ar 8/6/2009 20:40'!button	"Make a simple button interface for replay only"	| butnCaption erm |	butnCaption := UIManager default request: 'Caption for this butn?' translated initialAnswer: 'play' translated.	butnCaption isEmpty ifTrue: [^ self].	erm := (EventRecorderMorph basicNew				caption: butnCaption				voiceRecorder: voiceRecorder copy				tape: tape) initialize.	self world primaryHand attachMorph: erm! !!BookMorph methodsFor: 'scripting' stamp: 'ar 8/6/2009 18:11'!chooseAndRevertToVersion	| time which |	"Let the user choose an older version for all code in MethodMorphs in this book.  Run through that code and revert each one to that time."	self methodHolders.	"find them in me"	self methodHolderVersions.	which := UIManager default chooseFrom: #('leave as is'), VersionNames title:					'Put all scripts in this book back the way they were at this time:'.	which <= 1 ifTrue: [^ self].	time := VersionTimes at: which-1.	self revertToCheckpoint: time.! !!StringButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45'!setActionSelector	| newSel |	newSel := UIManager default		request:'Please type the selector to be sent tothe target when this button is pressed' translated		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!MorphObjectOut methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 18:29'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| aMorph myUrl oldFlag response |	"Transcript show: thisContext sender selector; cr." "useful for debugging"	oldFlag := recursionFlag.	recursionFlag := true.	myUrl := url.	"can't use inst vars after become"	"fetch the object"	aMorph := self xxxFetch.		"watch out for the become!!"			"Now we ARE a MORPH"	oldFlag == true ifTrue: [		response := UIManager default chooseFrom: #('proceed normally' 'debug')			title: 'Object being fetched for a second time.Should not happen, and needs to be fixed later.'.		response = 2 ifTrue: [self halt]].	"We are already the new object"	aMorph setProperty: #SqueakPage toValue: 			(SqueakPageCache pageCache at: myUrl).	"Can't be a super message, since this is the first message sent to this object"	^ aMorph perform: aMessage selector withArguments: aMessage arguments! !!BookMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:38'!getStemUrl	"Try to find the old place where this book was stored. Confirm with the 	user. Else ask for new place."	| initial pg url knownURL |	knownURL := false.	initial := ''.	(pg := currentPage valueOfProperty: #SqueakPage)		ifNotNil: [pg contentsMorph == currentPage				ifTrue: [initial := pg url.					knownURL := true]].	"If this page has a url"	pages		doWithIndex: [:aPage :ind | initial isEmpty				ifTrue: [aPage isInMemory						ifTrue: [(pg := aPage valueOfProperty: #SqueakPage)								ifNotNil: [initial := pg url]]]].	"any page with a url"	initial isEmpty		ifTrue: [initial := ServerDirectory defaultStemUrl , '1.sp'].	"A new legal place"	url := knownURL		ifTrue: [initial]		ifFalse: [UIManager default request: 'url of the place to store a typical page in this book.Must begin with file:// or ftp://' translated initialAnswer: initial].	^ SqueakPage stemUrl: url! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:40'!saveLibToDisk: evt	"Save the library to disk"	| newName f snd |	newName := UIManager default request: 'Please confirm name for library...'						initialAnswer: 'MySounds'.	newName isEmpty ifTrue: [^ self].	f := FileStream newFileNamed: newName , '.fml'.	AbstractSound soundNames do:		[:name | snd := AbstractSound soundNamed: name.		"snd isStorable" true ifTrue: [f nextChunkPut: 'AbstractSound soundNamed: ' , name , ' put: ' , snd storeString; cr; cr]			ifFalse: [self inform: name , ' is not currently storable']].	f close! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'ar 8/6/2009 20:43'!makeTile	"Make a tile representing my sound.  Get a sound-name from the user by which the sound is to be known."	| newStyleTile sndName tile |	recorder verifyExistenceOfRecordedSound ifFalse: [^ self].	recorder pause.	newStyleTile := true.	newStyleTile		ifTrue:			[sndName := UIManager default				request: 'Please name your new sound' translated				initialAnswer: 'sound' translated.			sndName isEmpty ifTrue: [^ self].			sndName := SampledSound unusedSoundNameLike: sndName.			SampledSound				addLibrarySoundNamed: sndName				samples: recorder condensedSamples				samplingRate: recorder samplingRate.			tile := SoundTile new literal: sndName]		ifFalse:			[tile := InterimSoundMorph new sound: 				(SampledSound					samples: recorder condensedSamples					samplingRate: recorder samplingRate)].	tile bounds: tile fullBounds.	tile openInHand! !!StringButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45'!setLabel	| newLabel |	newLabel := UIManager default		request:'Please type a new label for this button'		initialAnswer: self contents.	newLabel isEmpty ifFalse: [self contents: newLabel].! !!BookMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:39'!reload	"Fetch the pages of this book from the server again.  For all pages that have not been modified, keep current ones.  Use new pages.  For each, look up in cache, if time there is equal to time of new, and its in, use the current morph.	Later do fancy things when a page has changed here, and also on the server."	| url onServer onPgs sq which |	(url := self valueOfProperty: #url) ifNil: ["for .bo index file"	url := UIManager default 		request: 'url of the place where this book''s index is stored.Must begin with file:// or ftp://' translated		initialAnswer: (self getStemUrl, '.bo').	url notEmpty ifTrue: [self setProperty: #url toValue: url]				ifFalse: [^ self]].	onServer := self class new fromURL: url.	"Later: test book times?"	onPgs := onServer pages collect: [:out |		sq := SqueakPageCache pageCache at: out url ifAbsent: [nil].		(sq notNil and: [sq contentsMorph isInMemory])			ifTrue: [((out sqkPage lastChangeTime > sq lastChangeTime) or: 					  [sq contentsMorph isNil]) 						ifTrue: [SqueakPageCache atURL: out url put: out sqkPage.							out]						ifFalse: [sq contentsMorph]]			ifFalse: [SqueakPageCache atURL: out url put: out sqkPage.				out]].	which := (onPgs findFirst: [:pg | pg url = currentPage url]) max: 1.	self newPages: onPgs currentIndex: which.		"later stay at current page"	self setProperty: #modTime toValue: (onServer valueOfProperty: #modTime).	self setProperty: #allText toValue: (onServer valueOfProperty: #allText).	self setProperty: #allTextUrls toValue: (onServer valueOfProperty: #allTextUrls).! !!FlapTab methodsFor: 'solid tabs' stamp: 'ar 8/6/2009 20:40'!changeTabThickness	| newThickness |	newThickness := UIManager default request: 'New thickness:'				initialAnswer: self tabThickness printString.	newThickness notEmpty ifTrue: [self applyTabThickness: newThickness]! !!BookMorph methodsFor: 'menus' stamp: 'ar 8/6/2009 20:39'!printPSToFile	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag |	fileName := ('MyBook') translated asFileName.	fileName := UIManager default request: 'File name? (".ps" will be added to end)' translated 			initialAnswer: fileName.	fileName isEmpty ifTrue: [^ Beeper beep].	(fileName endsWith: '.ps') ifFalse: [fileName := fileName,'.ps'].	rotateFlag := (UIManager default chooseFrom: {		'portrait (tall)' translated.		'landscape (wide)' translated	} title: 'Choose orientation...' translated) = 2.	(FileStream newFileNamed: fileName asFileName)		nextPutAll: (DSCPostscriptCanvas morphAsPostscript: self rotated: rotateFlag); close.! !!InternalThreadNavigationMorph methodsFor: 'sorting' stamp: 'ar 8/6/2009 20:40'!acceptSortedContentsFrom: aHolder	"Update my page list from the given page sorter."	| nameOfThisProject cachedData proj |	threadName isEmpty ifTrue: [threadName := 'I need a name' translated].	threadName := UIManager default 		request: 'Name this thread.' translated 		initialAnswer: threadName.	threadName isEmptyOrNil ifTrue: [^self].	listOfPages := OrderedCollection new.	aHolder submorphs doWithIndex: [:m :i |		(nameOfThisProject := m valueOfProperty: #nameOfThisProject) ifNotNil: [			cachedData := {nameOfThisProject}.			proj := Project named: nameOfThisProject.			(proj isNil or: [proj thumbnail isNil]) ifFalse: [				cachedData := cachedData, {proj thumbnail scaledToSize: self myThumbnailSize}.			].			listOfPages add: cachedData.		].	].	self class know: listOfPages as: threadName.	self removeAllMorphs; addButtons.	self world ifNil: [		self openInWorld; positionAppropriately.	].! !!EnvelopeEditorMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:40'!saveSound: evt	| newName |	newName := UIManager default request: 'Please confirm name for save...'						initialAnswer: soundName.	newName isEmpty ifTrue: [^ self].	AbstractSound soundNamed: newName put: sound.	soundName := newName.! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := UIManager default		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!ZoomAndScrollControllerMorph methodsFor: 'as yet unclassified' stamp: 'ar 8/6/2009 19:23'!runAScript	| d names reply |	d := self targetScriptDictionary.	names := d keys asSortedCollection.	reply := UIManager default chooseFrom: names values: names title: 'Script to run?'.	reply ifNil: [^ self].	programmedMoves := (d at: reply) veryDeepCopy.! !!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'ar 8/6/2009 20:20'!doPublishButtonMenuEvent: evt	| selection |	selection := UIManager default chooseFrom: {		'Publish' translated.		'Publish As...' translated.		'Publish to Different Server' translated.		 'edit project info' translated.	} values: {		[self publishProject].		[self publishProjectAs].		[self publishDifferent].		[self editProjectInfo].	} title:  'Publish options' translated.	selection ifNil: [^self].	selection value.! !