"Change Set:		7720Compiler-eem.78Compiler-eem.78:Third package of eight in closure compiler fixes 9/5/2009.Stage one of the closure compiler fixes for- miscompilation of optimized blocks- bugs in statement highlighting in the debugger- storing the selector as the penultimate literal of a method  directly unless it has properties, in which case it has an  AdditionalMethodState.  Saves significant space.Requires	Exceptions-eem.12	Kernel-eem.242Compiler-tfel.74:MethodNode>>generateWith:using: was missing a variable declaration for 'literals', I just put it inCompiler-tfel.75:MethodNode>>generateWith:using:Nuked the method according to Andreas' request on the mailinglistCompiler-mha.76:inserted an extension originally contributed by Eliot Miranda (to make Alien support possible in the trunk)Compiler-mha.77:removed obsolete method Parser >> #pragmaLiteral (replaced by #pragmaLiteral: in Compiler-mha.76)"!Notification subclass: #UndeclaredVariableReference	instanceVariableNames: 'parser varName varStart varEnd'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!InstructionStream subclass: #Decompiler	instanceVariableNames: 'constructor method instVars tempVars constTable stack statements lastPc exit caseExits lastJumpPc lastReturnPc limit hasValue blockStackBase numLocalTemps blockStartsToTempVars tempVarCount'	classVariableNames: 'ArgumentFlag CascadeFlag CaseFlag IfNilFlag'	poolDictionaries: ''	category: 'Compiler-Kernel'!TestCase subclass: #DecompilerTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!TestCase subclass: #MirrorPrimitiveTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!ParseNode subclass: #BlockNode	instanceVariableNames: 'arguments statements returns nArgsNode size remoteCopyNode temporaries optimized actualScopeIfOptimized blockExtent remoteTempNode copiedValues closureCreationNode startOfLastStatement'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-ParseNodes'!EncoderForV3 subclass: #EncoderForV3PlusClosures	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!EncoderForLongFormV3 subclass: #EncoderForLongFormV3PlusClosures	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!DecompilerTests subclass: #DecompilerTestFailuresCollector	instanceVariableNames: 'failures'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!ClosureCompilerTest subclass: #MethodHighlightingTests	instanceVariableNames: 'creator timeStamp duration tracks'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!ParseNode subclass: #Encoder	instanceVariableNames: 'scopeTable nTemps supered requestor class selector literalStream selectorSet litIndSet litSet sourceRanges globalSourceRanges addedSelectorAndMethodClassLiterals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Kernel'!ParseNodeVisitor subclass: #ParseNodeEnumerator	instanceVariableNames: 'theBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Support'!TestCase subclass: #ClosureTests	instanceVariableNames: 'collection'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-Tests'!TestCase subclass: #ClosureCompilerTest	instanceVariableNames: ''	classVariableNames: 'CmpRR CogRTLOpcodes Jump MoveCqR Nop'	poolDictionaries: ''	category: 'Compiler-Tests'!!MethodNode methodsFor: 'primitive error codes' stamp: 'eem 12/1/2008 14:56'!removeAndRenameLastTempIfErrorCode	self primitiveErrorVariableName ifNotNil:		[:primitiveErrorVariableName|		 temporaries last			name: primitiveErrorVariableName			key: primitiveErrorVariableName			code: temporaries last code.		 temporaries removeLast].! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesXAtoXM	self decompileClassesSelect: [:cn| cn first = $X and: [cn second asUppercase <= $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitMessageNodeInCascade: aMessageNodeInCascade	theBlock value: aMessageNodeInCascade.	^super visitMessageNodeInCascade: aMessageNodeInCascade! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitAssignmentNode: anAssignmentNode	theBlock value: anAssignmentNode.	^super visitAssignmentNode: anAssignmentNode! !!Encoder methodsFor: 'temps' stamp: 'eem 7/13/2007 14:13'!floatTemp: node	(node ~~ (scopeTable at: node name ifAbsent: [])	or: [node class ~~ TempVariableNode	or: [node code ~= (node code: nTemps - 1 type: LdTempType)]]) ifTrue:		[self error: 'can only float the last allocated temp var'].	nTemps := nTemps - 1! !!MethodNode methodsFor: 'converting' stamp: 'eem 7/18/2008 06:37'!asColorizedSmalltalk80Text	"Answer a colorized Smalltalk-80-syntax string description of the parse tree whose root is the receiver."	| printText |	printText := self printString asText.	^(Smalltalk at: #SHTextStylerST80 ifAbsent: [nil])		ifNotNil: [:stylerClass| stylerClass new styledTextFor: printText]		ifNil: [printText]! !!Encoder methodsFor: 'results' stamp: 'eem 5/27/2009 09:25'!associationForClass	| assoc |	assoc := self environment associationAt: class name ifAbsent: [nil].	^assoc value == class		ifTrue: [assoc]		ifFalse: [Association new value: class]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 7/22/2009 10:48'!remoteTempNodeName	"Answer a useful name for a RemoteTempVectorNode in the receiver."	| prefix scope extent |	prefix := actualScopeIfOptimized ifNil: ['<'] ifNotNil: [ '<...'].	scope := self.	[extent := scope blockExtent.	 extent == nil	 and: [scope actualScope ~~ scope]] whileTrue:		[scope := scope actualScope].	^extent		ifNil: [prefix, '?-?>']		ifNotNil:			[prefix, extent first printString, '-',				(extent last isZero					ifTrue: ['?']					ifFalse: [extent last printString]), '>']! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesFNtoFZ	self decompileClassesSelect: [:cn| cn first = $F and: [cn second asUppercase > $M]]! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder! !!Parser methodsFor: 'expression types' stamp: 'eem 6/2/2009 10:26'!assignment: varNode	" var ':=' expression => AssignmentNode."	| loc start |	(loc := varNode assignmentCheck: encoder at: prevMark + requestorOffset) >= 0		ifTrue: [^self notify: 'Cannot store into' at: loc].	start := self startOfNextToken.	self advance.	self expression ifFalse: [^self expected: 'Expression'].	parseNode := AssignmentNode new				variable: varNode				value: parseNode				from: encoder				sourceRange: (start to: self endOfLastToken).	varNode nowHasDef.	^true! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesUNtoUZ	self decompileClassesSelect: [:cn| cn first = $U and: [cn second asUppercase > $M]]! !!MethodNode methodsFor: 'accessing' stamp: 'eem 7/21/2009 15:59'!temporaries	"For transformations etc, not used in compilation"	^temporaries! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitMessageNode: aMessageNode	theBlock value: aMessageNode.	^super visitMessageNode: aMessageNode! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 11/10/2008 16:52'!isFailure: cls sel: selector 	"self new isKnowProblem: PNMReaderWriter sel: #nextImage"	"#((PNMReadWriter nextImage)) includes: {PNMReadWriter	name asSymbol . #nextImage}."	^(#(#DoIt #DoItIn:) includes: selector)	   or: [self decompilerFailures includes: {cls name asSymbol. selector}]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesNAtoNM	self decompileClassesSelect: [:cn| cn first = $N and: [cn second asUppercase <= $M]]! !!Parser methodsFor: 'expression types' stamp: 'eem 7/20/2009 12:09'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| blockNode variableNodes temporaryBlockVariables start |	blockNode := BlockNode new.	variableNodes := OrderedCollection new.	start := prevMark + requestorOffset.	"Gather parameters."	[self match: #colon] whileTrue:		[variableNodes addLast: (encoder bindBlockArg: self argumentName within: blockNode)].	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue:		[^self expected: 'Vertical bar'].	temporaryBlockVariables := self temporaryBlockVariablesFor: blockNode.	self statements: variableNodes innerBlock: true blockNode: blockNode.	blockNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].	blockNode noteSourceRangeStart: start end: self endOfLastToken encoder: encoder.	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitInstanceVariableNode: anInstanceVariableNode	theBlock value: anInstanceVariableNode.	^super visitInstanceVariableNode: anInstanceVariableNode! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesDNtoDZ	self decompileClassesSelect: [:cn| cn first = $D and: [cn second asUppercase > $M]]! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:17'!primitive: anIntegerOrString	"Create indexed primitive."		^self primitive: anIntegerOrString error: nil! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitSelectorNode: aSelectorNode	theBlock value: aSelectorNode.	^super visitSelectorNode: aSelectorNode! !!DecompilerTests methodsFor: 'utilities' stamp: 'sd 9/25/2004 15:30'!blockingClasses	^ #(CompiledMethod)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesSNtoSZ	self decompileClassesSelect: [:cn| cn first = $S and: [cn second asUppercase > $M]]! !!Parser methodsFor: 'pragmas' stamp: 'eem 12/1/2008 11:39'!pragmaLiteral: selectorSoFar	"Read a pragma literal.  As a nicety we allow a variable name (rather	 than a literal string) as the second argument to primitive:error:"	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	"This nicety allows one to supply a primitive error	 temp as a variable name, rather than a string."	((selectorSoFar beginsWith: 'primitive:')	 and: [(selectorSoFar endsWith: 'error:')	 and: [hereType == #word]]) ifTrue:		[^self advance].	^self expected: 'Literal constant'! !!ParseNode methodsFor: 'tiles' stamp: 'ab 7/13/2004 13:47'!addCommentToMorph: aMorph	| row |	(self comment isNil or: [self comment isEmpty]) ifTrue: [^ self].	row := aMorph addTextRow:		(String streamContents: [:strm | self printCommentOn: strm indent: 1]).	row firstSubmorph color: (SyntaxMorph translateColor: #comment).	row parseNode: (self as: CommentNode).! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	rcvrNode emitCodeForValue: stack encoder: encoder.	fieldDef accessKey ifNotNil:[		super emitCodeForValue: stack encoder: encoder.	].! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesLAtoLM	self decompileClassesSelect: [:cn| cn first = $L and: [cn second asUppercase <= $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitFutureNode: aFutureNode	theBlock value: aFutureNode.	^super visitFutureNode: aFutureNode! !!UndeclaredVariableReference methodsFor: 'exceptionDescription' stamp: 'ar 12/8/2002 13:13'!defaultAction	^parser correctVariable: varName interval: (varStart to: varEnd)! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varEnd: aNumber	varEnd := aNumber! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:52'!testWhileWithTemp	| index |	index := 0.	[ index < 5 ] whileTrue: [		| temp |		temp := index := index + 1.		collection add: [ temp ] ].	self assertValues: #(1 2 3 4 5)! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoInsideTempNotInlined	| block |	block := [ :index | 		| temp | 		temp := index. 		collection add: [ temp ] ].	1 to: 5 do: block.	self assertValues: #(1 2 3 4 5)! !!UndeclaredVariableWarning methodsFor: 'exceptionDescription' stamp: 'bgf 3/10/2009 19:03'!defaultAction	"The user should be notified of the occurrence of an exceptional occurrence and	 given an option of continuing or aborting the computation. The description of the	 occurrence should include any text specified as the argument of the #signal: message."		selector ifNotNil: [Transcript cr; nextPutAll: class name, '>>', selector, ' ']			ifNil: [Transcript cr ].	Transcript show: '(' , name , ' is Undeclared) '.	^true! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 11/10/2008 15:47'!failures	^failures! !!MethodNode methodsFor: 'accessing' stamp: 'eem 7/21/2009 16:00'!arguments: aSequence	"For transformations etc, not used in compilation"	arguments := aSequence! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/8/2009 09:52'!testMirrorAt	| stackpBefore stackpAfter array byteArray |	stackpBefore := thisContext stackPtr.	array := { 1. 2. 3 }.	byteArray := ByteArray with: 1 with: 2 with: 3.	self assert: (thisContext object: array basicAt: 1) = 1.	self assert: (thisContext object: byteArray basicAt: 2) = 2.	thisContext object: array basicAt: 2 put: #two.	self assert: array = #(1 #two 3).	thisContext object: byteArray basicAt: 2 put: 222.	self assert: byteArray asArray = #(1 222 3).	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"	self should: [thisContext object: array basicAt: 4] raise: Error.	self should: [thisContext object: byteArray basicAt: 0] raise: Error.	self should: [thisContext object: byteArray basicAt: 1 put: -1] raise: Error! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/22/2009 16:55'!testInlineBlockCollectionSD1	| a1 b1 a2 b2 |	b1 := OrderedCollection new.	1 to: 3 do:		[:i |		a1 := i.		b1 add: [a1]].	b1 := b1 asArray collect: [:b | b value].	b2 := OrderedCollection new.	1 to: 3 do:		[:i |		a2 := i.		b2 add: [a2]] yourself. "defeat optimization"	b2 := b2 asArray collect: [:b | b value].	self assert: b1 = b2! !!Parser methodsFor: 'error correction' stamp: 'eem 9/5/2009 11:53'!correctVariable: proposedVariable interval: spot 	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| tempIvar binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	tempIvar := proposedVariable first isLowercase.	(tempIvar and: [(binding := requestor bindingOf: proposedVariable) notNil]) 		ifTrue: [^encoder global: binding name: proposedVariable].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	action := UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesINtoIZ	self decompileClassesSelect: [:cn| cn first = $I and: [cn second asUppercase > $M]]! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/12/2009 21:17'!testMirrorPerform	| stackpBefore stackpAfter anInterval |	stackpBefore := thisContext stackPtr.	anInterval := 1 to: 2.	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval) == Array.	self assert: (thisContext object: anInterval perform:# species withArguments: #() inClass: Interval superclass) == Interval.	self should: [thisContext object: anInterval perform:# species withArguments: #() inClass: Point]		raise: Error.	self should: [thisContext object: anInterval perform:# species withArguments: OrderedCollection new inClass: Interval]		raise: Error.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!Encoder methodsFor: 'results' stamp: 'bgf 3/12/2009 17:42'!allLiterals	((literalStream isKindOf: WriteStream)	 and: [ (addedSelectorAndMethodClassLiterals ifNil: [ false ]) not]) ifTrue:		[addedSelectorAndMethodClassLiterals := true.		 self litIndex: nil.		 self litIndex: self associationForClass].	^literalStream contents	"The funky ifNil: [false], even though the init method initializes addedSAMCL,	 is simply so that Monticello can load and compile this update without	 killing the encoder that is compiling that update itself..."! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesBAtoBM	self decompileClassesSelect: [:cn| cn first = $B and: [cn second asUppercase <= $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitTempVariableNode: aTempVariableNode	theBlock value: aTempVariableNode.	^super visitTempVariableNode: aTempVariableNode! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesQAtoQM	self decompileClassesSelect: [:cn| cn first = $Q and: [cn second asUppercase <= $M]]! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:36'!testMethodArgument	| temp block |	temp := 0.	block := [ [ temp ] ].	temp := 1.	block := block value.	temp := 2.	self assert: block value = 2! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2009 11:42'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	| effectiveScope blockStart |	effectiveScope := optimized						ifTrue: [actualScopeIfOptimized := scopeBlock]						ifFalse: [self].	arguments ifNotNil:		[arguments do: [:temp| temp definingScope: self]].	temporaries ifNotNil:		[temporaries do: [:temp| temp definingScope: self]].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockEntry:			[:entryNumber|			 blockExtent := (blockStart := entryNumber) to: 0]].	"Need to enumerate a copy because closure analysis can add a statement	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."	statements copy do:		[:statement|		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockExit:			[:exitNumber|			 blockExtent := blockStart to: exitNumber]].	"Now that the analysis is done move any temps that need to be moved."	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.	"This is simply a nicety for compiler developers..."	temporaries do:		[:temp|		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:			[temp name: temp definingScope remoteTempNodeName]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitCascadeNode: aCascadeNode	theBlock value: aCascadeNode.	^super visitCascadeNode: aCascadeNode! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesGNtoGZ	self decompileClassesSelect: [:cn| cn first = $G and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 6/11/2009 17:24'!checkDecompileMethod: oldMethod		| cls selector oldMethodNode methodNode newMethod oldCodeString newCodeString |	cls := oldMethod methodClass.	selector := oldMethod selector.	oldMethodNode := cls decompilerClass new						decompile: selector						in: cls						method: oldMethod.	[oldMethodNode properties includesKey: #warning] whileTrue:		[oldMethodNode properties removeKey: #warning].	oldCodeString := oldMethodNode decompileString.	methodNode := [cls compilerClass new						compile: oldCodeString						in: cls						notifying: nil						ifFail: []]						on: SyntaxErrorNotification						do: [:ex|							ex errorMessage = 'Cannot store into' ifTrue:								[ex return: #badStore].							ex pass].	"Ignore cannot store into block arg errors; they're not our issue."	methodNode ~~ #badStore ifTrue:		[newMethod := methodNode generate: #(0 0 0 0).		 newCodeString := (cls decompilerClass new							decompile: selector							in: cls							method: newMethod) decompileString.		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldCodeString to: newCodeString))				openLabel: 'Decompilation Differences for ', cls name,'>>',selector"		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldMethod abstractSymbolic to: newMethod abstractSymbolic))				openLabel: 'Bytecode Differences for ', cls name,'>>',selector"		 self assert: oldCodeString = newCodeString			description: cls name asString, ' ', selector asString			resumable: true]! !!VariableNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!isVariableNode	^true! !!Scanner methodsFor: 'initialize-release' stamp: 'eem 8/20/2008 20:57'!initScannerForTokenization	"Use a version of typeTable that doesn't raise xIllegal when enocuntering an _"	| underscoreIndex |	underscoreIndex := typeTable indexOf: #xUnderscore ifAbsent: [^self].	typeTable := typeTable copy.	typeTable at: underscoreIndex put: #xUnderscoreForTokenization! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForStore: stack encoder: encoder	fieldDef accessKey ifNil:[		writeNode emitCode: stack args: 1 encoder: encoder super: false.	] ifNotNil:[		writeNode emitCode: stack args: 2 encoder: encoder super: false.	].! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/5/2009 17:13'!testBlockNumberingForInjectInto	"Test that the compiler and CompiledMethod agree on the block numbering of Collection>>inject:into:	 and that temp names for inject:into: are recorded."	"self new testBlockNumberingForInjectInto"	| methodNode method tempRefs |	methodNode := Parser new						encoderClass: EncoderForV3PlusClosures;						parse: (Collection sourceCodeAt: #inject:into:)						class: Collection.	method := methodNode generate: #(0 0 0 0).	tempRefs := methodNode encoder blockExtentsToTempsMap.	self assert: tempRefs keys = method startpcsToBlockExtents values asSet.	self assert: ((tempRefs includesKey: (0 to: 6))				and: [(tempRefs at: (0 to: 6)) hasEqualElements: #(('thisValue' 1) ('binaryBlock' 2) ('nextValue' (3 1)))]).	self assert: ((tempRefs includesKey: (2 to: 4))				and: [(tempRefs at: (2 to: 4)) hasEqualElements: #(('each' 1) ('binaryBlock' 2) ('nextValue' (3 1)))])! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitCommentNode: aCommentNode	theBlock value: aCommentNode.	^super visitCommentNode: aCommentNode! !!BytecodeEncoder methodsFor: 'results' stamp: 'eem 5/29/2009 09:11'!schematicTempNamesOn: aStream blockExtents: blockExtents fromIndex: startIndex	"Print the locals in the blockExtent startIndex, recursing to print any locals in nested blockExtents.	 Answer the index of the last blockExtent printed."	| blockExtent subsequentIndex |	blockExtent := blockExtents at: startIndex.	((blockExtentsToLocals at: blockExtent) reject: [:local| local isRemote]) do:		[:local|		local isIndirectTempVector			ifTrue: [local remoteTemps do:						[:remoteLocal| aStream nextPut: remoteLocal key]]			ifFalse: [aStream nextPut: local key]].	subsequentIndex := startIndex + 1.	[subsequentIndex <= blockExtents size	 and: [(blockExtents at: subsequentIndex) last < blockExtent last]] whileTrue:		[aStream nextPut: (Array streamContents:				[:nestedTempStream|				subsequentIndex := self schematicTempNamesOn: nestedTempStream										blockExtents: blockExtents										fromIndex: subsequentIndex])].	^subsequentIndex! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesVNtoVZ	self decompileClassesSelect: [:cn| cn first = $V and: [cn second asUppercase > $M]]! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationAfter	| index |	index := 0.	[ index < 5 ] whileTrue: [		collection add: [ index ].		index := index + 1 ].	self assertValues: #(5 5 5 5 5)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesOAtoOM	self decompileClassesSelect: [:cn| cn first = $O and: [cn second asUppercase <= $M]]! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 5/8/2009 09:54'!testMirrorEqEq	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext object: Array new eqeq: Array new) == false.	self assert: (thisContext object: Array eqeq: Array) == true.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2009 16:23'!postNumberingProcessTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>"	"A temp can be local (and copied) if it is not written to after it is captured.	 A temp cannot be local if it is written to remotely.	 Need to enumerate a copy of the temporaries because any temps becoming remote	 will be removed from temporaries in analyseClosure: (and a single remote temp node	 will get added)"	temporaries copy do:		[:each|		each isIndirectTempVector ifFalse:			[each analyseClosure: rootNode]].	"If this is an optimized node we need to hoist temporaries up into the relevant block scope."	optimized ifTrue:		[self optimizedBlockHoistTempsInto: scopeBlock].	"Now we may have added a remoteTempNode.  So we need a statement to initialize it."	self ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode.	"Now add all arguments and locals to the pool so that copiedValues can be computed during sizing."	rootNode		addLocalsToPool: arguments;		addLocalsToPool: temporaries! !!ParseNode class methodsFor: 'accessing' stamp: 'eem 8/4/2009 12:34'!tempSortBlock	"Answer a block that can sort a set of temporaries into a stable	 order so that different compilations produce the same results."	^[:t1 :t2| | be1 be2 bs1 bs2 |	   t1 index < t2 index "simple sort by index."	   or: [t1 index = t2 index "complex tie break" 		  and: [t1 isRemote ~= t2 isRemote				ifTrue: [t2 isRemote] "put direct temps before indirect temps"				ifFalse: 					[((be1 := t1 definingScope blockExtent) isNil					  or: [(be2 := t2 definingScope blockExtent) isNil])						ifTrue: [t1 name < t2 name] "only have the name left to go on"						ifFalse: "put temps from outer scopes before those from inner scopes"							[(bs1 := be1 first) < (bs2 := be2 first)							 or: [bs1 = bs2 and: [t1 name < t2 name]]]]]]] "only have the name left to go on"! !!ParseNode methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:44'!nodesDo: aBlock	self accept: (ParseNodeEnumerator ofBlock: aBlock)! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:21'!primitive: anIntegerOrString error: errorCodeVariableOrNil	"Create indexed primitive with optional error code."		^anIntegerOrString isInteger		ifTrue:			[errorCodeVariableOrNil ifNotNil:				[encoder floatTemp: (encoder bindTemp: errorCodeVariableOrNil) nowHasDef].			 anIntegerOrString]		ifFalse:			[anIntegerOrString isString				ifTrue: [self primitive: anIntegerOrString module: nil error: errorCodeVariableOrNil]				ifFalse: [self expected: 'Indexed primitive']]! !!MethodHighlightingTests methodsFor: 'tests' stamp: 'eem 9/5/2009 10:58'!testMethodHighlighting	| map before after method retpc |	"Test the highlighting of the asXML method.  Test the highlighting of the return	 statement which should include the whole block supplied to streamContents:."	"DebuggerMethodMap voidMapCache"	"DebuggerMethodMap forMethod: MethodHighlightingTests >> #asXML"	method := MethodHighlightingTests >> #asXML.	map := DebuggerMethodMap forMethod: method.	retpc := method endPC.	before := map rangeForPC: retpc contextIsActiveContext: false.	map instVarNamed: 'abstractSourceRanges' put: nil.	after := map rangeForPC: retpc contextIsActiveContext: false.	self assert: before size > 500.	self assert: before = after! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 22:45'!testMirrorInstVarAt	| stackpBefore stackpAfter array point |	stackpBefore := thisContext stackPtr.	array := { 1. 2. 3 }.	point := Point x: 1 y: 2.	self assert: (thisContext object: array instVarAt: 1) = 1.	self assert: (thisContext object: point instVarAt: 2) = 2.	thisContext object: array instVarAt: 2 put: #two.	self assert: array = #(1 #two 3).	thisContext object: point instVarAt: 1 put: 1/2.	self assert: point = (Point x: 1 / 2 y: 2).	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"	self should: [thisContext object: array instVarAt: 4] raise: Error.	self should: [thisContext object: point instVarAt: 3] raise: Error! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2009 11:46'!beingAssignedToAnalyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	self addWriteWithin: scopeBlock at: rootNode locationCounter.	"For analysis of optimized blocks also record the set of temporaries written to	 within optimized blocks so that additional writes can be added at locations that	 represent subsequent iterations of the loop. e.g. testInlineBlockCollectionSD1"	assignmentPools keysAndValuesDo:		[:outerScopeBlock :set|		"definingScope can be nil in expr in expr ifNil: [:arg|...] expressions because		 arg gets its definingScope set when [:arg|...] is analysed."		outerScopeBlock actualScope			= (definingScope				ifNil: [scopeBlock]				ifNotNil: [definingScope actualScope]) ifTrue:			[set add: self]]! !!BytecodeAgnosticMethodNode methodsFor: 'debugger support' stamp: 'eem 7/6/2009 09:46'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occur	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with the schematicTempNamesString."	encoder hasGeneratedMethod ifFalse:		["create the encoder's blockExtentsToLoals map, except if the method is quick		  in which case it has no temps."		(self generate: #(0 0 0 0)) isQuick ifTrue:			[^'']].	^encoder schematicTempNamesString! !!Parser methodsFor: 'pragmas' stamp: 'mha 9/1/2009 16:32'!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: (self pragmaLiteral: selector) ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesTNtoTZ	self decompileClassesSelect: [:cn| cn first = $T and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 11/10/2008 15:30'!decompilerFailures	"here is the list of failures: DNU resulting in trying to decompile the following methods"	^ #((BalloonEngineSimulation circleCosTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		 (BalloonEngineSimulation circleSinTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		 (GeniePlugin primSameClassAbsoluteStrokeDistanceMyPoints:otherPoints:myVectors:otherVectors:mySquaredLengths:otherSquaredLengths:myAngles:otherAngles:maxSizeAndReferenceFlag:rowBase:rowInsertRemove:rowInsertRemoveCount: "Cannot compile -- stack including temps is too deep")		(QPickable2D pick:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(QUsersPane userEntryCompare:to:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(TShaderProgram vertexStrings) "foo ifTrue: []. => foo. => ."		(TShaderProgram fragmentStrings) "foo ifTrue: []. => foo. => ."		(TWindow zoomWindow:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		"(PNMReadWriter nextImage) (Collection #ifEmpty:ifNotEmpty:) (Collection #ifEmpty:) (Collection #ifNotEmpty:ifEmpty:) (Text #alignmentAt:ifAbsent:) (ObjectWithDocumentation propertyAt:ifAbsent:)")! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:33'!testBlockArgument	| block block1 block2 |	block := [ :arg | | temp | temp := arg. [ temp ] ].	block1 := block value: 1.	block2 := block value: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!MessageNode methodsFor: 'code generation (closures)' stamp: 'eem 8/4/2009 11:58'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	"Assignments within optimized loops are tricky.  Because a loop repeats a	 write to a temporary in an optimized loop effectively occurs after the loop.	 To handle this collect the set of temps assigned to in optimized loops and	 add extra writes after traversing the optimized loop constituents."	| writtenToTemps |	self isOptimizedLoop ifTrue:		[{ receiver }, arguments do:			[:node|			(node notNil and: [node isBlockNode and: [node optimized]]) ifTrue:				[assignmentPools at: node put: Set new]]].	"receiver is nil in cascades"	receiver == nil ifFalse:		[receiver analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools].	arguments do:		[:node|		node == nil ifFalse: "last argument of optimized to:do: can be nil"			[node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]].	"Add assignments representing subsequent iterations	 and redo the closure analysis for the written-to temps."	self isOptimizedLoop ifTrue:		[writtenToTemps := Set new.		 { receiver }, arguments do:			[:node|			(node notNil and: [node isBlockNode and: [node optimized]]) ifTrue:				[(assignmentPools removeKey: node) do:					[:temp|					temp isBlockArg ifFalse: "ignore added assignments to to:do: loop args"						[writtenToTemps add: temp.						 temp addWriteWithin: node at: rootNode locationCounter]]]].		 writtenToTemps isEmpty ifFalse:			[(writtenToTemps asSortedCollection: ParseNode tempSortBlock) do:				[:each| each analyseClosure: rootNode].			 (writtenToTemps collect: [:each| each definingScope]) do:				[:blockNode|				blockNode ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode]]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesEAtoEM	self decompileClassesSelect: [:cn| cn first = $E and: [cn second asUppercase <= $M]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/7/2009 11:39'!testInlineBlockCollectionLR2	"Test case from Lukas Renggli"	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | #(1) do: [:ignored| col add: [ each ]] ].	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !!UndefinedVariable methodsFor: 'as yet unclassified' stamp: 'cwp 10/17/2007 22:39/eem 9/5/2009 11:10 - => :='!openMenuIn: aBlock	| labels caption index |	labels := #('yes' 'no').	caption := name, ' appears to be undefined at this point.Proceed anyway?'.	index := aBlock value: labels value: #() value: caption.	^ self resume: index = 1! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 4/5/2006 01:31'!xIllegal	"An illegal character was encountered"	self notify: 'Illegal character' at: mark! !!Parser methodsFor: 'error correction' stamp: 'rbb 3/1/2005 11:06'!defineClass: className 	"prompts the user to define a new class,  	asks for it's category, and lets the users edit further  	the definition"	| sym cat def d2 |	sym := className asSymbol.	cat := UIManager default request: 'Enter class category : ' initialAnswer: self encoder classEncoding category.	cat		ifEmpty: [cat := 'Unknown'].	def := 'Object subclass: #' , sym , '		instanceVariableNames: '''' 		classVariableNames: ''''		poolDictionaries: ''''		category: ''' , cat , ''''.	d2 := UIManager default request: 'Edit class definition : ' initialAnswer: def.	d2		ifEmpty: [d2 := def].	Compiler evaluate: d2.	^ encoder		global: (Smalltalk associationAt: sym)		name: sym! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesJNtoJZ	self decompileClassesSelect: [:cn| cn first = $J and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesCAtoCM	self decompileClassesSelect: [:cn| cn first = $C and: [cn second asUppercase <= $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesYNtoYZ	self decompileClassesSelect: [:cn| cn first = $Y and: [cn second asUppercase > $M]]! !!Parser methodsFor: 'public access' stamp: 'eem 8/20/2008 20:55'!parseSelector: aString 	"Answer the message selector for the argument, aString, which should 	 parse successfully up to the temporary declaration or the end of the 	 method header."	self initScannerForTokenization.	^self		initPattern: aString		notifying: nil		return: [:pattern | pattern at: 1]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitBlockNode: aBlockNode	theBlock value: aBlockNode.	^super visitBlockNode: aBlockNode! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesRAtoRM	self decompileClassesSelect: [:cn| cn first = $R and: [cn second asUppercase <= $M]]! !!MethodNode methodsFor: 'accessing' stamp: 'eem 6/11/2009 17:27'!removeProperty: aSymbol	properties := properties copyWithout: (Association											key: aSymbol											value: (properties propertyValueAt: aSymbol))! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/3/2009 12:55'!actualScope	"Answer the actual scope for the receiver.  If this is an unoptimized block then it is its	 actual scope, but if this is an optimized block then the actual scope is some outer block."	^actualScopeIfOptimized ifNil: [self]! !!BytecodeEncoder methodsFor: 'results' stamp: 'eem 6/29/2009 11:22'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occurr	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with teh schematicTempNamesString."	blockExtentsToLocals ifNil:		[self error: 'blockExtentsToLocals uninitialized.  method not yet generated?'].	^String streamContents:		[:aStream|		self printSchematicTempNamesOn: aStream			blockExtents: (blockExtentsToLocals keys asSortedCollection:							[:range1 :range2|							range1 first <= range2 first])			fromIndex: 1]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesHNtoHZ	self decompileClassesSelect: [:cn| cn first = $H and: [cn second asUppercase > $M]]! !!VariableNode methodsFor: 'code generation (closures)' stamp: 'eem 7/20/2009 10:38'!beingAssignedToAnalyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	"No-op overridden by TempVariableNode"! !!MethodNode methodsFor: 'accessing' stamp: 'eem 7/21/2009 15:59'!temporaries: aSequence	"For transformations etc, not used in compilation"	temporaries := aSequence! !!UnusedVariable methodsFor: 'as yet unclassified' stamp: 'eem 9/5/2009 11:10'!openMenuIn: aBlock	| index |	index := aBlock value: #('yes' 'no')					value: #()					value: name, ' appears to be\unused in this method.\OK to remove it?' withCRs.	self resume: index = 1! !!Encoder methodsFor: 'temps' stamp: 'eem 12/1/2008 12:07'!fixTemp: name	| node |	node := scopeTable at: name ifAbsent: [].	node class ~~ TempVariableNode ifTrue:		[self error: 'can only fix a floating temp var'].	node index: nTemps.	nTemps := nTemps + 1.	^node! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesWNtoWZ	self decompileClassesSelect: [:cn| cn first = $W and: [cn second asUppercase > $M]]! !!Encoder methodsFor: 'encoding' stamp: 'eem 5/27/2009 09:25'!environment	"Answer the environment of the current compilation context,	 be it in a class or global (e.g. a workspace)"	^class == nil		ifTrue: [Smalltalk]		ifFalse: [class environment]! !!VariableNode methodsFor: 'initialize-release' stamp: 'eem 12/1/2008 13:51'!name: string	"Change name"	name := string! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!varName	^varName! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesPAtoPM	self decompileClassesSelect: [:cn| cn first = $P and: [cn second asUppercase <= $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitBraceNode: aBraceNode	theBlock value: aBraceNode.	^super visitBraceNode: aBraceNode! !!CascadeNode methodsFor: 'code generation (closures)' stamp: 'eem 5/19/2008 20:26'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	{ receiver }, messages do:		[:node| node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:53'!testWhileWithTempNotInlined	| index block |	index := 0.	block := [		| temp |		temp := index := index + 1.		collection add: [ temp ] ].	[ index < 5 ] whileTrue: block.	self assertValues: #(1 2 3 4 5)! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:17'!sizeCodeForStorePop: encoder	^(self sizeCodeForStore: encoder) + encoder sizePop! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 16:18'!emitCodeForStorePop: stack encoder: encoder	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesMNtoMZ	self decompileClassesSelect: [:cn| cn first = $M and: [cn second asUppercase > $M]]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 2/9/2009 10:04'!visitFutureNode: aFutureNode	aFutureNode receiver accept: self.	(aFutureNode originalSelector isKindOf: SelectorNode) ifTrue:		[aFutureNode originalSelector accept: self]! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varStart: aNumber	varStart := aNumber! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesFAtoFM	self decompileClassesSelect: [:cn| cn first = $F and: [cn second asUppercase <= $M]]! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 10:56'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	self addReadWithin: scopeBlock at: rootNode locationCounter! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesUAtoUM	self decompileClassesSelect: [:cn| cn first = $U and: [cn second asUppercase <= $M]]! !!VariableNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 16:34'!currentValueIn: aContext	aContext ifNil: [^nil].	^((self variableGetterBlockIn: aContext) ifNil: [^nil]) value printString	! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationBefore	| index |	index := 0.	[ index < 5 ] whileTrue: [ 		index := index + 1.		collection add: [ index ] ].	self assertValues: #(5 5 5 5 5)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesKNtoKZ	self decompileClassesSelect: [:cn| cn first = $K and: [cn second asUppercase > $M]]! !!BytecodeAgnosticMethodNode methodsFor: 'debugger support' stamp: 'eem 7/1/2009 13:45'!hasGeneratedMethod	^encoder hasGeneratedMethod! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeCodeForValue: encoder) + 			(writeNode sizeCode: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) +			(writeNode sizeCode: encoder args: 2 super: false)! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitReturnNode: aReturnNode	theBlock value: aReturnNode.	^super visitReturnNode: aReturnNode! !!LeafNode methodsFor: 'code generation (closures)' stamp: 'eem 6/16/2008 09:32'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	"This is a no-op except in TempVariableNode"	^self! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesDAtoDM	self decompileClassesSelect: [:cn| cn first = $D and: [cn second asUppercase <= $M]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/5/2009 17:11'!testBlockNumbering	"Test that the compiler and CompiledMethod agree on the block numbering of a substantial doit."	"self new testBlockNumbering"	| methodNode method tempRefs |	methodNode :=		Parser new			encoderClass: EncoderForV3PlusClosures;			parse: 'foo					| numCopiedValuesCounts |					numCopiedValuesCounts := Dictionary new.					0 to: 32 do: [:i| numCopiedValuesCounts at: i put: 0].					Transcript clear.					Smalltalk allClasses remove: GeniePlugin; do:						[:c|						{c. c class} do:							[:b|							Transcript nextPut: b name first; endEntry.							b selectorsAndMethodsDo:								[:s :m| | pn |								m isQuick not ifTrue:									[pn := b parserClass new												encoderClass: EncoderForV3PlusClosures;												parse: (b sourceCodeAt: s)												class: b.									 pn generate: #(0 0 0 0).									 [pn accept: nil]										on: MessageNotUnderstood										do: [:ex| | msg numCopied |											msg := ex message.											(msg selector == #visitBlockNode:											 and: [(msg argument instVarNamed: ''optimized'') not]) ifTrue:												[numCopied := (msg argument computeCopiedValues: pn) size.												 numCopiedValuesCounts													at: numCopied													put: (numCopiedValuesCounts at: numCopied) + 1].											msg setSelector: #==.											ex resume: nil]]]]].					numCopiedValuesCounts'			class: Object.	method := methodNode generate: #(0 0 0 0).	tempRefs := methodNode encoder blockExtentsToTempsMap.	self assert: tempRefs keys = method startpcsToBlockExtents values asSet! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 9/29/2008 15:07'!decompileClassesSelect: aBlock		(Smalltalk classNames select: aBlock) do:		[:cn | | cls |		cls := Smalltalk at: cn.		Smalltalk garbageCollect.		 Transcript cr; show: cn.		 cls selectors do:			[:selector | | methodNode oldMethod newMethod oldCodeString newCodeString |			(self isFailure: cls sel: selector) ifFalse:				[" to help making progress					(self						isStoredProblems: cls theNonMetaClass						sel: selector						meta: cls isMeta)					ifFalse: [ "				Transcript nextPut: $.; flush.				self checkDecompileMethod: (cls compiledMethodAt: selector)]]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 6/30/2009 12:15'!testMethodAndNodeTempNames	"self new testMethodAndNodeTempNames"	"Test that BytecodeAgnosticMethodNode>>blockExtentsToTempRefs answers the same	 structure as CompiledMethod>>blockExtentsToTempRefs when the method has been	 copied with the appropriate temps.  This tests whether doit methods are debuggable	 since they carry their own temps."	self closureCases do:		[:source| | mn om m mbe obe |		mn := source first isLetter					ifTrue:						[self class compilerClass new							compile: source							in: self class							notifying: nil							ifFail: [self error: 'compilation error']]					ifFalse:						[self class compilerClass new							compileNoPattern: source							in: self class							context: nil							notifying: nil							ifFail: [self error: 'compilation error']].		m := (om := mn generate: #(0 0 0 0)) copyWithTempsFromMethodNode: mn.		self assert: m holdsTempNames.		self assert: m endPC = om endPC.		mbe := m blockExtentsToTempsMap.		obe := mn blockExtentsToTempsMap.		self assert: mbe keys = obe keys.		(mbe keys intersection: obe keys) do:			[:interval|			self assert: (mbe at: interval) = (obe at: interval)]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesZNtoZZ	self decompileClassesSelect: [:cn| cn first = $Z and: [cn second asUppercase > $M]]! !!Scanner methodsFor: 'multi-character scans' stamp: 'eem 5/8/2008 17:01'!xUnderscoreForTokenization	self step.	tokenType := #leftArrow.	^token := #'_'! !!BytecodeAgnosticMethodNode methodsFor: 'debugger support' stamp: 'eem 6/5/2009 16:51'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	^encoder blockExtentsToTempsMap ifNil:		[| methNode |		methNode := encoder classEncoding parserClass new						encoderClass: encoder class;						parse: (sourceText ifNil: [self decompileString])						class: self methodClass.		"As a side effect generate: creates data needed for the map."		methNode generate: #(0 0 0 0).		methNode encoder blockExtentsToTempsMap]! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoArgument	1 to: 5 do: [ :index |		collection add: [ index ] ].	self assertValues: #(1 2 3 4 5)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesSAtoSM	self decompileClassesSelect: [:cn| cn first = $S and: [cn second asUppercase <= $M]]! !!ParseNode methodsFor: 'tiles' stamp: 'RAA 8/24/1999 13:06'!currentValueIn: aContext	^nil! !!Parser methodsFor: 'error correction' stamp: 'cwp 10/17/2007 23:39/eem 9/5/2009 11:10 - => :='!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| correctSelector userSelection |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [^proposedKeyword asSymbol].	userSelection := requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	correctSelector := UnknownSelector name: proposedKeyword.	correctSelector ifNil: [^abortAction value].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	self substituteSelector: correctSelector keywords wordIntervals: spots.	^(proposedKeyword last ~~ $:	   and: [correctSelector last == $:])		ifTrue: [abortAction value]		ifFalse: [correctSelector]! !!AssignmentNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 09:37'!analyseTempsWithin: scopeBlock "<BlockNode>"  rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	"N.B.  since assigment happens _after_ the value is evaluated the value is sent the message _first_."	value analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools.	variable beingAssignedToAnalyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/15/2008 10:43'!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:21'!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		^self primitive: aNameString module: aModuleStringOrNil error: nil! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesANtoAZ	self decompileClassesSelect: [:cn| cn first = $A and: [cn second asUppercase > $M]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesXNtoXZ	self decompileClassesSelect: [:cn| cn first = $X and: [cn second asUppercase > $M]]! !!Parser methodsFor: 'error correction' stamp: 'eem 5/27/2009 09:27'!declareGlobal: name	| sym |	sym := name asSymbol.	^encoder		global: (encoder environment					at: sym put: nil;					associationAt: sym)		name: sym! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesIAtoIM	self decompileClassesSelect: [:cn| cn first = $I and: [cn second asUppercase <= $M]]! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	fieldDef accessKey ifNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 0 encoder: encoder super: false.	] ifNotNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		super emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 1 encoder: encoder super: false.	].! !!BytecodeEncoder methodsFor: 'results' stamp: 'eem 6/5/2009 17:53'!printSchematicTempNamesOn: aStream blockExtents: blockExtents fromIndex: startIndex	"Print the locals in the blockExtent startIndex, recursing to print any locals in nested blockExtents.	 Answer the index of the last blockExtent printed."	| blockExtent subsequentIndex |	blockExtent := blockExtents at: startIndex.	blockExtent first > 0 ifTrue:		[aStream nextPut: $[ ].	((blockExtentsToLocals at: blockExtent) reject: [:local| local isRemote])		do:	[:local|			local isIndirectTempVector				ifTrue:					[aStream nextPut: $(.					 local remoteTemps						do: [:remoteLocal| aStream nextPutAll: remoteLocal key]						separatedBy: [aStream space].					 aStream nextPut: $)]				ifFalse: [aStream nextPutAll: local key]]		separatedBy: [aStream space].	subsequentIndex := startIndex + 1.	[subsequentIndex <= blockExtents size	 and: [(blockExtents at: subsequentIndex) last < blockExtent last]] whileTrue:		[subsequentIndex := self printSchematicTempNamesOn: aStream								blockExtents: blockExtents								fromIndex: subsequentIndex].	blockExtent first > 0 ifTrue:		[aStream nextPut: $] ].	^subsequentIndex! !!Encoder methodsFor: 'initialize-release' stamp: 'eem 3/12/2009 16:13'!initScopeAndLiteralTables	scopeTable := StdVariables copy.	litSet := StdLiterals copy.	"comments can be left hanging on nodes from previous compilations.	 probably better than this hack fix is to create the nodes afresh on each compilation."	scopeTable do:		[:varNode| varNode comment: nil].	litSet do:		[:varNode| varNode comment: nil].	selectorSet := StdSelectors copy.	litIndSet := Dictionary new: 16.	literalStream := WriteStream on: (Array new: 32).	addedSelectorAndMethodClassLiterals := false! !!Scanner methodsFor: 'public access' stamp: 'eem 6/11/2009 14:28'!typedScanTokens: textOrString 	"Answer an Array that has been tokenized with literals mapped to literals,	 special characters mapped to symbols and variable names and keywords	 to strings. This methiod accepts _ (underscore) as an assignment token	 irrespective of whether the system prefers := as the assignment token."	| s |	self initScannerForTokenization.	self scan: (ReadStream on: textOrString asString).	s := WriteStream on: (Array new: 16).	[tokenType = #doIt] whileFalse:		[(token == #- 		  and: [(self typeTableAt: hereChar) = #xDigit]) ifTrue: 			[self scanToken.			 token := token negated].		s nextPut: token.		self scanToken].	^s contents	"Scanner new typedScanTokens: (Scanner sourceCodeAt: #typedScanTokens:)"! !!BytecodeEncoder methodsFor: 'testing' stamp: 'eem 6/29/2009 11:11'!hasGeneratedMethod	^blockExtentsToLocals notNil! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesNNtoNZ	self decompileClassesSelect: [:cn| cn first = $N and: [cn second asUppercase > $M]]! !!UnknownSelector methodsFor: 'as yet unclassified' stamp: 'cwp 10/17/2007 23:34/eem 9/5/2009 11:10 - => :='!openMenuIn: aBlock	| alternatives labels lines caption choice |	alternatives := Symbol possibleSelectorsFor: name.	labels := Array streamContents:				[:s | s nextPut: name; nextPutAll: alternatives; nextPut: 'cancel'].	lines := {1. alternatives size + 1}.	caption := 'Unknown selector, please\confirm, correct, or cancel' withCRs.		choice := aBlock value: labels value: lines value: caption.	choice = 0 ifTrue: [self resume: nil].	choice = 1 ifTrue: [self resume: name asSymbol].	choice = labels size ifTrue: [self resume: nil].	self resume: (alternatives at: choice - 1)! !!NewArrayNode methodsFor: 'code generation (closures)' stamp: 'eem 6/16/2008 09:31'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	"This is a no-op except in TempVariableNode"	^self! !!Encoder methodsFor: 'private' stamp: 'eem 6/11/2008 17:31'!name: name key: key class: leafNodeClass type: type set: dict	^dict 		at: key		ifAbsent: 			[dict				at: key				put: (leafNodeClass new						name: name						key: key						index: nil						type: type)]! !!MethodNode methodsFor: 'accessing' stamp: 'eem 7/21/2009 16:00'!arguments	"For transformations etc, not used in compilation"	^arguments! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesGAtoGM	self decompileClassesSelect: [:cn| cn first = $G and: [cn second asUppercase <= $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitMethodNode: aMethodNode	theBlock value: aMethodNode.	^super visitMethodNode: aMethodNode! !!BytecodeEncoder methodsFor: 'temps' stamp: 'eem 6/5/2009 16:51'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	| blockExtentsToTempsMap |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempsMap := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempsMap			at: blockExtent			put: (Array streamContents:					[:stream|					locals withIndexDo:						[:local :index|						local isIndirectTempVector							ifTrue: [local remoteTemps withIndexDo:										[:remoteLocal :innerIndex| stream nextPut: { remoteLocal key. { index. innerIndex } }]]							ifFalse: [stream nextPut: { local key. index }]]])].	^blockExtentsToTempsMap! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:33'!testBlockTemp	| block block1 block2 |	block := [ :arg | [ arg ] ].	block1 := block value: 1.	block2 := block value: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!BraceNode methodsFor: 'code generation (closures)' stamp: 'eem 7/20/2009 09:33'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	elements do:		[:node|		node analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesVAtoVM	self decompileClassesSelect: [:cn| cn first = $V and: [cn second asUppercase <= $M]]! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 11/10/2008 15:46'!assert: aBoolean description: aString resumable: resumableBoolean 	aBoolean ifFalse: 		[failures isNil ifTrue:			[failures := OrderedCollection new].		 failures addLast: (thisContext sender tempAt: 1) methodReference]! !!ParseNode methodsFor: 'testing' stamp: 'ar 11/19/2002 14:58'!isVariableNode	^false! !!MethodNode methodsFor: 'accessing' stamp: 'eem 1/19/2009 10:28'!primitiveErrorVariableName	"Answer the primitive error code temp name, or nil if none."	(primitive isInteger and: [primitive > 0]) ifTrue:		[properties pragmas do:			[:pragma| | kwds ecIndex |			((kwds := pragma keyword keywords) first = 'primitive:'			and: [(ecIndex := kwds indexOf: 'error:') > 0]) ifTrue:				[^pragma argumentAt: ecIndex]]].	^nil	"(Parser new parse: (MethodNode sourceCodeAt: #primitiveErrorVariableName) class: Parser) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: ''foo''> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: ''foo'' error: foo module: ''bar''> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: ''foo'' module: ''bar'' error: foo> self primitiveFailed' class: Object) primitiveErrorVariableName"	"(Parser new parse: 'foo <primitive: 111 error: foo> self primitiveFailed' class: Object) generate"! !!ReturnNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2009 09:44'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	"Note we could do this:		scopeBlock ~~ rootNode block ifTrue:			[scopeBlock noteNonLocalReturn].	 and pass up the flag in <BlockNode>>>analyseTempsWithin:rootNode:	 which may be fast but will also give less information the debugger.	 For now we consider clean blocks a premature optimization."	self flag: 'consider clean blocks'.	expr analyseTempsWithin: scopeBlock rootNode: rootNode assignmentPools: assignmentPools! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesLNtoLZ	self decompileClassesSelect: [:cn| cn first = $L and: [cn second asUppercase > $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitFieldNode: aFieldNode	theBlock value: aFieldNode.	^super visitFieldNode: aFieldNode! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoOutsideTempNotInlined	| block temp |	block := [ :index | 		temp := index. 		collection add: [ temp ] ].	1 to: 5 do: block.	self assertValues: #(5 5 5 5 5)! !!ClosureCompilerTest methodsFor: 'source' stamp: 'eem 7/1/2009 10:51'!closureCases	^#('| n |n := 1.^n + n''| i |i := 0.[i := i + 1. i <= 10] whileTrue.^i''[:c :s| | mn |mn := Compiler new		compile: (c sourceCodeAt: s)		in: c		notifying: nil		ifFail: [self halt].mn generate: #(0 0 0 0).{mn blockExtentsToTempsMap.  mn encoder schematicTempNames}]			value: AbstractInstructionTests			value: #runBinaryConditionalJumps:''inject: thisValue into: binaryBlock	| nextValue |	nextValue := thisValue.	self do: [:each | nextValue := binaryBlock value: nextValue value: each].	^nextValue''runBinaryConditionalJumps: assertPrintBar	"CogIA32CompilerTests new runBinaryConditionalJumps: false"	| mask reg1 reg2 reg3 |	mask := 1 << self processor bitsInWord - 1.	self concreteCompilerClass dataRegistersWithAccessorsDo:		[:n :get :set|		n = 0 ifTrue: [reg1 := get].		n = 1 ifTrue: [reg2 := set].		n = 2 ifTrue: [reg3 := set]].	#(	(JumpAbove > unsigned)			(JumpBelowOrEqual <= unsigned)		(JumpBelow < unsigned)			(JumpAboveOrEqual >= unsigned)		(JumpGreater > signed)			(JumpLessOrEqual <= signed)		(JumpLess < signed)				(JumpGreaterOrEqual >= signed)		(JumpZero = signed)				(JumpNonZero ~= signed)) do:		[:triple|		[:opName :relation :signednessOrResult| | opcode jumpNotTaken jumpTaken nop memory bogus |		self resetGen.		opcode := CogRTLOpcodes classPool at: opName.		self gen: CmpRR operand: 2 operand: 1.		jumpTaken := self gen: opcode.		self gen: MoveCqR operand: 0 operand: 0.		jumpNotTaken := self gen: Jump.		jumpTaken jmpTarget: (self gen: MoveCqR operand: 1 operand: 0).		jumpNotTaken jmpTarget: (nop := self gen: Nop).		memory := self generateInstructions.		bogus := false.		self pairs: (-2 to: 2)  do:			[:a :b| | taken |			self processor				reset;				perform: reg2 with: a signedIntToLong;				perform: reg3 with: b signedIntToLong.			[self processor singleStepIn: memory.			 self processor pc ~= nop address] whileTrue.			taken := (self processor perform: reg1) = 1.			assertPrintBar				ifTrue:					[self assert: taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b])]				ifFalse:					[Transcript						nextPutAll: reg2; nextPut: $(; print: a; nextPutAll: '') ''; nextPutAll: relation; space;						nextPutAll: reg3; nextPut: $(; print: b; nextPutAll: '') = '';						print: taken; cr; flush.					 taken = (signednessOrResult == #unsigned											ifTrue: [(a bitAnd: mask) perform: relation with: (b bitAnd: mask)]											ifFalse: [a perform: relation with: b]) ifFalse:						[bogus := true]]].			 bogus ifTrue:				[self processor printRegistersOn: Transcript.				 Transcript show: (self processor disassembleInstructionAt: jumpTaken address In: memory); cr]]					valueWithArguments: triple]''mapFromBlockStartsIn: aMethod toTempVarsFrom: schematicTempNamesString constructor: aDecompilerConstructor	| map |	map := aMethod				mapFromBlockKeys: aMethod startpcsToBlockExtents keys asSortedCollection				toSchematicTemps: schematicTempNamesString.	map keysAndValuesDo:		[:startpc :tempNameTupleVector| | subMap tempVector numTemps |		subMap := Dictionary new.		"Find how many temp slots there are (direct & indirect temp vectors)		 and for each indirect temp vector find how big it is."		tempNameTupleVector do:			[:tuple|			tuple last isArray				ifTrue:					[subMap at: tuple last first put: tuple last last.					 numTemps := tuple last first]				ifFalse:					[numTemps := tuple last]].		"create the temp vector for this scope level."		tempVector := Array new: numTemps.		"fill it in with any indirect temp vectors"		subMap keysAndValuesDo:			[:index :size|			tempVector at: index put: (Array new: size)].		"fill it in with temp nodes."		tempNameTupleVector do:			[:tuple| | itv |			tuple last isArray				ifTrue:					[itv := tempVector at: tuple last first.					 itv at: tuple last last						put: (aDecompilerConstructor								codeTemp: tuple last last - 1								named: tuple first)]				ifFalse:					[tempVector						at: tuple last						put: (aDecompilerConstructor								codeTemp: tuple last - 1								named: tuple first)]].		"replace any indirect temp vectors with proper RemoteTempVectorNodes"		subMap keysAndValuesDo:			[:index :size|			tempVector				at: index				put: (aDecompilerConstructor						codeRemoteTemp: index						remoteTemps: (tempVector at: index))].		"and update the entry in the map"		map at: startpc put: tempVector].	^map' 'gnuifyFrom: inFileStream to: outFileStream"convert interp.c to use GNU features"	| inData beforeInterpret inInterpret inInterpretVars beforePrimitiveResponse inPrimitiveResponse |	inData := inFileStream upToEnd withSqueakLineEndings.	inFileStream close.	"print a header"	outFileStream		nextPutAll: ''/* This file has been post-processed for GNU C */'';		cr; cr; cr.	beforeInterpret := true.    "whether we are before the beginning of interpret()"	inInterpret := false.     "whether we are in the middle of interpret"	inInterpretVars := false.    "whether we are in the variables of interpret"	beforePrimitiveResponse := true.  "whether we are before the beginning of primitiveResponse()"	inPrimitiveResponse := false.   "whether we are inside of primitiveResponse"	''Gnuifying''		displayProgressAt: Sensor cursorPoint		from: 1 to: (inData occurrencesOf: Character cr)		during:			[:bar | | lineNumber |			lineNumber := 0.			inData linesDo:				[ :inLine | | outLine extraOutLine caseLabel |				bar value: (lineNumber := lineNumber + 1).				outLine := inLine. 	"print out one line for each input line; by default, print out the line that was input, but some rules modify it"				extraOutLine := nil.   "occasionally print a second output line..."				beforeInterpret ifTrue: [					inLine = ''#include "sq.h"'' ifTrue: [						outLine := ''#include "sqGnu.h"'' ].					inLine = ''interpret(void) {'' ifTrue: [						"reached the beginning of interpret"						beforeInterpret := false.						inInterpret := true.						inInterpretVars := true ] ]				ifFalse: [				inInterpretVars ifTrue: [					(inLine findString: ''register struct foo * foo = &fum;'') > 0 ifTrue: [						outLine := ''register struct foo * foo FOO_REG = &fum;'' ].					(inLine findString: '' localIP;'') > 0 ifTrue: [						outLine := ''    char* localIP IP_REG;'' ].					(inLine findString: '' localFP;'') > 0 ifTrue: [						outLine := ''    char* localFP FP_REG;'' ].					(inLine findString: '' localSP;'') > 0 ifTrue: [						outLine := ''    char* localSP SP_REG;'' ].					(inLine findString: '' currentBytecode;'') > 0 ifTrue: [						outLine := ''    sqInt currentBytecode CB_REG;'' ].					inLine isEmpty ifTrue: [						"reached end of variables"						inInterpretVars := false.						outLine := ''    JUMP_TABLE;''.						extraOutLine := inLine ] ]				ifFalse: [				inInterpret ifTrue: [					"working inside interpret(); translate the switch statement"					(inLine beginsWith: ''		case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''		CASE('', caseLabel, '')'' ].					inLine = ''			break;'' ifTrue: [						outLine := ''			BREAK;'' ].					inLine = ''}'' ifTrue: [						"all finished with interpret()"						inInterpret := false ] ]				ifFalse: [				beforePrimitiveResponse ifTrue: [					(inLine beginsWith: ''primitiveResponse('') ifTrue: [						"into primitiveResponse we go"						beforePrimitiveResponse := false.						inPrimitiveResponse := true.						extraOutLine := ''    PRIM_TABLE;'' ] ]				ifFalse: [				inPrimitiveResponse ifTrue: [					inLine = ''	switch (primitiveIndex) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					inLine = ''	switch (GIV(primitiveIndex)) {'' ifTrue: [						extraOutLine := outLine.						outLine := ''	PRIM_DISPATCH;'' ].					(inLine beginsWith: ''	case '') ifTrue: [						caseLabel := (inLine findTokens: ''	 :'') second.						outLine := ''	CASE('', caseLabel, '')'' ].					inLine = ''}'' ifTrue: [						inPrimitiveResponse := false ] ]				] ] ] ].				outFileStream nextPutAll: outLine; cr.				extraOutLine ifNotNil: [					outFileStream nextPutAll: extraOutLine; cr ]]].	outFileStream close' )! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2009 18:56'!ifHasRemoteTempNodeEnsureInitializationStatementExists: rootNode	"If a remoteTempNode has been added ensure a statement exists to initialize it."	remoteTempNode ~~ nil ifTrue:		[(statements notEmpty		  and: [statements first isAssignmentNode		  and: [statements first variable isTemp		  and: [statements first variable isIndirectTempVector]]])			ifTrue: "If this is a decompiled tree, or if a temporary has been added later in					the analysis then there already is a temp vector initialization node."				[(statements first variable ~~ remoteTempNode) ifTrue:					[statements first variable become: remoteTempNode].				 statements first value numElements: remoteTempNode remoteTemps size]			ifFalse:				[statements addFirst: (remoteTempNode nodeToInitialize: rootNode encoder)]].! !!Encoder methodsFor: 'temps' stamp: 'ar 9/9/2006 12:05'!autoBind: name 	"Declare a block argument as a temp if not already declared."	| node |	node := scopeTable 			at: name			ifAbsent: 				[(self lookupInPools: name ifFound: [:assoc | assoc])					ifTrue: [self warnAboutShadowed: name].				^ (self reallyBind: name) nowHasDef nowHasRef scope: 1].	node isTemp		ifTrue: [node scope >= 0 ifTrue:					[^ self notify: 'Name already used in this method'].				node nowHasDef nowHasRef scope: 1]		ifFalse: [^ self notify: 'Name already used in this class'].	^node! !!MessageNode methodsFor: 'testing' stamp: 'eem 7/20/2009 10:44'!isOptimizedLoop	^special > 0	   and: [#(transformWhile: transformToDo:) includes: (MacroTransformers at: special)]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesTAtoTM	self decompileClassesSelect: [:cn| cn first = $T and: [cn second asUppercase <= $M]]! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:36'!testMethodTemp	| block1 block2 |	block1 := self methodArgument: 1.	block2 := self methodArgument: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!ParseNodeEnumerator methodsFor: 'initialize-release' stamp: 'eem 7/20/2009 19:44'!ofBlock: aBlock	theBlock := aBlock! !!Parser class methodsFor: 'accessing' stamp: 'eem 12/1/2008 14:32'!primitivePragmaSelectors	"Answer the selectors of pragmas that specify VM primitives.	 Needed for compile and decomple."	^#(primitive:		primitive:error:		primitive:error:module:		primitive:module:		primitive:module:error:)! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/9/2009 11:00'!testInlineBlockCollectionLR3	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | | i | i := each. col add: [ i ]. i := i + 1 ].	self assert: (col collect: [ :each | each value ]) asArray = (2 to: 12) asArray! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varEnd	^varEnd! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationAfterNotInlined	| index block |	index := 0.	block := [ 		collection add: [ index ].		index := index + 1 ].	[ index < 5 ] whileTrue: block.	self assertValues: #(5 5 5 5 5)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesBNtoBZ	self decompileClassesSelect: [:cn| cn first = $B and: [cn second asUppercase > $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitVariableNode: aVariableNode	theBlock value: aVariableNode.	^super visitVariableNode: aVariableNode! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/24/2009 21:12'!testDecompiledDoitMethodTempNames	"self new testDecompiledDoitMethodTempNames"	"Test that a decompiled doit that has been copied with temps decompiles to the input"	| removeComments |	removeComments := [:n| n comment: nil].	self closureCases do:		[:source| | mns m mps mnps |		"Need to compare an ungenerated tree with the generated method's methodNode		 because generating code alters the tree when it introduces remote temp vectors."		mns := #(first last) collect:					[:ignored|					source first isLetter						ifTrue:							[self class compilerClass new								compile: source								in: self class								notifying: nil								ifFail: [self error: 'compilation error']]						ifFalse:							[self class compilerClass new								compileNoPattern: source								in: self class								context: nil								notifying: nil								ifFail: [self error: 'compilation error']]].		m := (mns last generate: #(0 0 0 0)) copyWithTempsFromMethodNode: mns last.		removeComments value: mns first.		mns first nodesDo: removeComments.		self assert: (mnps := mns first printString) = (mps := m methodNode printString)]! !!Parser methodsFor: 'error correction' stamp: 'eem 9/5/2009 14:41'!substituteVariable: each atInterval: anInterval 	self 		substituteWord: each		wordInterval: anInterval		offset: 0.	^encoder encodeVariable: each! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesQNtoQZ	self decompileClassesSelect: [:cn| cn first = $Q and: [cn second asUppercase > $M]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/24/2009 11:51'!testInlineBlockCollectionEM1	| a1 b1 i1 a2 b2 i2 we wb |	b1 := OrderedCollection new.	i1 := 1.	[a1 := i1.	 i1 <= 3] whileTrue:		[b1 add: [a1].		i1 := i1 + 1].	b1 := b1 asArray collect: [:b | b value].	b2 := OrderedCollection new.	i2 := 1.	we := [a2 := i2. i2 <= 3].	wb := [b2 add: [a2]. i2 := i2 + 1].	we whileTrue: wb. "defeat optimization"	b2 := b2 asArray collect: [:b | b value].	self assert: b1 = b2! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:20'!primitive: aNameString error: errorCodeVariableOrNil module: aModuleStringOrNil	"Create named primitive with optional error code."		^self primitive: aNameString module: aModuleStringOrNil error: errorCodeVariableOrNil! !!ClosureTests methodsFor: 'testing-while' stamp: 'lr 3/10/2009 14:29'!testWhileModificationBeforeNotInlined	| index block |	index := 0.	block := [ 		index := index + 1.		collection add: [ index ] ].	[ index < 5 ] whileTrue: block.	self assertValues: #(5 5 5 5 5)! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesJAtoJM	self decompileClassesSelect: [:cn| cn first = $J and: [cn second asUppercase <= $M]]! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!parser	^parser! !!TempVariableNode methodsFor: 'code generation (closures)' stamp: 'eem 7/20/2009 16:33'!definingScope	^definingScope! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesYAtoYM	self decompileClassesSelect: [:cn| cn first = $Y and: [cn second asUppercase <= $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitNewArrayNode: aNewArrayNode	theBlock value: aNewArrayNode.	^super visitNewArrayNode: aNewArrayNode! !!ClosureTests methodsFor: 'utilities' stamp: 'lr 3/9/2009 16:48'!assertValues: anArray	| values |	values := collection collect: [ :each | each value ].	self 		assert: anArray asArray = values asArray		description: 'Expected: ' , anArray asArray printString , 			', but got ' , values asArray printString! !!BlockNode methodsFor: 'accessing' stamp: 'ar 11/17/2002 19:57'!returnNilIfNoOther	self returns		ifFalse: 			[statements last == NodeNil ifFalse: [statements add: NodeNil].			self returnLast]! !!BytecodeAgnosticMethodNode methodsFor: 'code generation (new scheme)' stamp: 'eem 12/1/2008 13:48'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is the reference to the source code that is	 stored with every CompiledMethod."	| primErrNode blkSize nLits literals stack method |	self generate: trailer ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primErrNode ifNil: [0] ifNotNil: [2 "We force store-long (129)"]).	method := CompiledMethod				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments,											  temporaries,											  (primErrNode												ifNil: [#()]												ifNotNil: [{primErrNode}]).									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].	stack position: method numTemps.	block emitCodeForEvaluatedValue: stack encoder: encoder.	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!Scanner methodsFor: 'multi-character scans' stamp: 'ar 4/5/2006 01:31'!xUnderscore	Preferences allowUnderscoreAssignment ifFalse:[^self xIllegal].	self step.	tokenType := #leftArrow.	^token := #':='! !!ParserNotification methodsFor: 'as yet unclassified' stamp: 'cwp 10/17/2007 23:29/eem 9/5/2009 11:10 - => :='!setName: aString	name := aString! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesONtoOZ	self decompileClassesSelect: [:cn| cn first = $O and: [cn second asUppercase > $M]]! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesHAtoHM	self decompileClassesSelect: [:cn| cn first = $H and: [cn second asUppercase <= $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitLiteralNode: aLiteralNode	theBlock value: aLiteralNode.	^super visitLiteralNode: aLiteralNode! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesWAtoWM	self decompileClassesSelect: [:cn| cn first = $W and: [cn second asUppercase <= $M]]! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoInsideTemp	1 to: 5 do: [ :index | 		| temp | 		temp := index. 		collection add: [ temp ] ].	self assertValues: #(1 2 3 4 5)! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!parser: aParser	parser := aParser! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:13'!varName: aString	varName := aString! !!Encoder methodsFor: 'initialize-release' stamp: 'eem 6/24/2008 14:24'!init: aClass context: aContext notifying: req	requestor := req.	class := aClass.	nTemps := 0.	supered := false.	self initScopeAndLiteralTables.	class variablesAndOffsetsDo:		[:variable "<String|CFieldDefinition>" :offset "<Integer|nil>" |		offset isNil			ifTrue: [scopeTable at: variable name put: (FieldNode new fieldDefinition: variable)]			ifFalse: [scopeTable						at: variable						put: (offset >= 0								ifTrue: [InstanceVariableNode new											name: variable index: offset]								ifFalse: [MaybeContextInstanceVariableNode new											name: variable index: offset negated])]].	aContext ~~ nil ifTrue:		[| homeNode |		 homeNode := self bindTemp: self doItInContextName.		 "0th temp = aContext passed as arg"		 aContext tempNames withIndexDo:			[:variable :index|			scopeTable				at: variable				put: (MessageAsTempNode new						receiver: homeNode						selector: #namedTempAt:						arguments: (Array with: (self encodeLiteral: index))						precedence: 3						from: self)]].	sourceRanges := Dictionary new: 32.	globalSourceRanges := OrderedCollection new: 32! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 17:06'!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^(encoder sizePushLiteralVar: index)	 + (writeNode sizeCode: encoder args: 1 super: false)! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 3/7/2009 11:25'!testInlineBlockCollectionLR1	"Test case from Lukas Renggli"	| col |	col := OrderedCollection new.	1 to: 11 do: [ :each | col add: [ each ] ].	self assert: (col collect: [ :each | each value ]) asArray = (1 to: 11) asArray! !!ClosureTests methodsFor: 'running' stamp: 'lr 3/9/2009 16:48'!setUp	super setUp.	collection := OrderedCollection new! !!MessageNode methodsFor: 'testing' stamp: 'eem 7/20/2009 09:31'!isOptimized	^special > 0! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesENtoEZ	self decompileClassesSelect: [:cn| cn first = $E and: [cn second asUppercase > $M]]! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoArgumentNotInlined	| block |	block := [ :index |		collection add: [ index ] ].	1 to: 5 do: block.	self assertValues: #(1 2 3 4 5)! !!Parser methodsFor: 'primitives' stamp: 'eem 9/5/2009 14:47'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module fn |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == #')'] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(self matchToken:#')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addPragma: (Pragma keyword: #primitive: arguments: #(120)).	^true! !!Decompiler methodsFor: 'initialize-release' stamp: 'eem 6/30/2009 18:13'!mapFromBlockStartsIn: aMethod toTempVarsFrom: schematicTempNamesString constructor: aDecompilerConstructor	| map |	map := aMethod				mapFromBlockKeys: aMethod startpcsToBlockExtents keys asSortedCollection				toSchematicTemps: schematicTempNamesString.	map keysAndValuesDo:		[:startpc :tempNameTupleVector|		tempNameTupleVector isEmpty ifFalse:			[| subMap numTemps tempVector |			subMap := Dictionary new.			"Find how many temp slots there are (direct & indirect temp vectors)			 and for each indirect temp vector find how big it is."			tempNameTupleVector do:				[:tuple|				tuple last isArray					ifTrue:						[subMap at: tuple last first put: tuple last last.						 numTemps := tuple last first]					ifFalse:						[numTemps := tuple last]].			"create the temp vector for this scope level."			tempVector := Array new: numTemps.			"fill it in with any indirect temp vectors"			subMap keysAndValuesDo:				[:index :size|				tempVector at: index put: (Array new: size)].			"fill it in with temp nodes."			tempNameTupleVector do:				[:tuple| | itv |				tuple last isArray					ifTrue:						[itv := tempVector at: tuple last first.						 itv at: tuple last last							put: (aDecompilerConstructor									codeTemp: tuple last last - 1									named: tuple first)]					ifFalse:						[tempVector							at: tuple last							put: (aDecompilerConstructor									codeTemp: tuple last - 1									named: tuple first)]].			"replace any indirect temp vectors with proper RemoteTempVectorNodes"			subMap keysAndValuesDo:				[:index :size|				tempVector					at: index					put: (aDecompilerConstructor							codeRemoteTemp: index							remoteTemps: (tempVector at: index))].			"and update the entry in the map"			map at: startpc put: tempVector]].	^map! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitRemoteTempVectorNode: aRemoteTempVectorNode	theBlock value: aRemoteTempVectorNode.	^super visitRemoteTempVectorNode: aRemoteTempVectorNode! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 7/20/2009 09:52'!optimizedBlockHoistTempsInto: scopeBlock "<BlockNode>"	"This is a No-op for all nodes except non-optimized BlockNodes."	"Let's assume the special > 0 guard in MessageNode>>analyseTempsWithin:forValue:encoder: is correct.	 Then we can simply hoist our temps up."	self assert: (arguments isNil or: [arguments size <= 1]).	(arguments notNil and: [arguments notEmpty]) ifTrue:		[scopeBlock addHoistedTemps: arguments.		arguments := #()].	temporaries notEmpty ifTrue:		[scopeBlock addHoistedTemps: temporaries.		temporaries := #()]! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 19:44'!testMirrorClass	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext objectClass: Array new) = Array.	self assert: (thisContext objectClass: 1) = 1 class.	self assert: (thisContext objectClass: ProtoObject new) = ProtoObject.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter "Make sure primitives pop all their arguments"! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesMAtoMM	self decompileClassesSelect: [:cn| cn first = $M and: [cn second asUppercase <= $M]]! !!ClosureTests methodsFor: 'testing-todo' stamp: 'lr 3/10/2009 14:51'!testToDoOutsideTemp	| temp |	1 to: 5 do: [ :index | 		temp := index. 		collection add: [ temp ] ].	self assertValues: #(5 5 5 5 5)! !!Encoder methodsFor: 'temps' stamp: 'ar 9/9/2006 12:06'!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp)			ifTrue:[^self notify:'Name is already defined']			ifFalse:[self warnAboutShadowed: name]].	^self reallyBind: name! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 7/21/2009 12:34'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:	 and: [initStmt isAssignmentNode	 and: [initStmt variable isTemp]]) ifFalse:		[^nil].	body := arguments last statements.	variable := initStmt variable.	increment := body last toDoIncrement: variable.	(increment == nil	 or: [receiver statements size ~= 1]) ifTrue:		[^nil].	test := receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	(test isMessageNode	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:		[^nil].	toDoBlock := BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	variable scope: -1.	variable beBlockArg.	^MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesCNtoCZ	self decompileClassesSelect: [:cn| cn first = $C and: [cn second asUppercase > $M]]! !!Scanner methodsFor: 'public access' stamp: 'eem 8/20/2008 20:55'!scanTokenPositionsIn: textOrString into: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments, in textOrString."	self initScannerForTokenization.	source := (ReadStream on: textOrString asString).	self step.	self step.	self scanAllTokenPositionsInto: aBlock	"| code |	code := '       #( 1 2 #( 3 4 ))  16r123 123 123.0  ', (Scanner sourceCodeAt: #scanTokenPositionsIn:into:).	Scanner new scanTokenPositionsIn: code into: [:start :end| Transcript cr; nextPut: $_; nextPutAll: (code copyFrom: start to: end); nextPut: $_; endEntry]"	"CodeDiffBuilder buildDisplayPatchFrom:  (Scanner sourceCodeAt: #scanTokenPositionsIn:into:) to:  ((Scanner sourceCodeAt: #scanTokenPositionsIn:into:) copyReplaceAll: (String with: Character cr) with: '')"	"CodeDiffBuilder buildDisplayPatchFrom:  'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]' to:'colorTable ^colorTable ifNil: [colorTable _ ST80ColorTable]'"! !!ClosureTests methodsFor: 'testing' stamp: 'lr 3/11/2009 17:35'!methodArgument: anObject	^ [ anObject ]	! !!UndeclaredVariableReference methodsFor: 'accessing' stamp: 'ar 12/8/2002 13:14'!varStart	^varStart! !!MirrorPrimitiveTests methodsFor: 'tests' stamp: 'eem 4/8/2009 22:50'!testMirrorSize	| stackpBefore stackpAfter |	stackpBefore := thisContext stackPtr.	self assert: (thisContext objectSize: #(1 2 3)) = 3.	self assert: (thisContext objectSize: '123') = 3.	self assert: (thisContext objectSize: nil) = 0.	self assert: (thisContext objectSize: 1) = 0.	stackpAfter := thisContext stackPtr.	self assert: stackpBefore = stackpAfter. "Make sure primitives pop all their arguments"! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesRNtoRZ	self decompileClassesSelect: [:cn| cn first = $R and: [cn second asUppercase > $M]]! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 7/20/2009 19:41'!visitLiteralVariableNode: aLiteralVariableNode	theBlock value: aLiteralVariableNode.	^super visitLiteralVariableNode: aLiteralVariableNode! !!ParseNode methodsFor: 'code generation (closures)' stamp: 'eem 7/20/2009 09:54'!optimizedBlockHoistTempsInto: scopeBlock "<BlockNode>" 	"This is a No-op for all nodes except non-optimized BlockNodes."	^self! !!MethodNode methodsFor: 'printing' stamp: 'eem 12/1/2008 14:35'!printPragmasOn: aStream	properties ifNil: [^self].	properties pragmas do:		[:pragma|		"Primitives are printed in printPrimitiveOn:; skip these"		(Parser primitivePragmaSelectors includes: pragma keyword) ifFalse:			[aStream crtab: 1.			 pragma printOn: aStream]]! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesKAtoKM	self decompileClassesSelect: [:cn| cn first = $K and: [cn second asUppercase <= $M]]! !!MethodHighlightingTests methodsFor: 'tests' stamp: 'eem 3/13/2009 14:13'!asXML	"self new asXML"	"Convert the master index into external XML representation"	| writer |	^String streamContents:[:s|		writer := XMLWriter on: s.		writer xmlDeclaration: '1.0'.		writer startTag: 'recording'; endTag.			writer tag: 'creator' pcData: creator.			writer tag: 'timestamp' pcData: timeStamp.			writer tag: 'duration' pcData: duration.			writer startTag: 'tracks'; endTag.				tracks do:[:tdata|					writer startTag: 'track'; attribute: 'type' value: tdata value; endTag.					writer pcData: tdata key.					writer endTag: 'track'.				].			writer endTag: 'tracks'.		writer endTag: 'recording'.	].! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 2/9/2009 10:04'!visitMessageNodeInCascade: aMessageNode	"receiver is nil for cascades"	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!VariableNode methodsFor: 'tiles' stamp: 'ab 7/13/2004 13:54'!variableGetterBlockIn: aContext	| temps index ivars |	(self type = 4 and: [self key isVariableBinding]) ifTrue: [		^[self key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars := aContext receiver class allInstVarNames.		index := ivars indexOf: self name ifAbsent: [^nil].		^[aContext receiver instVarAt: index]	].	self type = 2 ifTrue: [		temps := aContext tempNames.		index := temps indexOf: self name ifAbsent: [^nil].		^[aContext tempAt: index]	].	^nil! !!Encoder methodsFor: 'source mapping' stamp: 'ar 11/19/2002 14:41'!sourceRangeFor: node	^sourceRanges at: node! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesZAtoZM	self decompileClassesSelect: [:cn| cn first = $Z and: [cn second asUppercase <= $M]]! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'eem 9/5/2009 14:41'!openMenuIn: aBlock 	| alternatives labels actions lines caption choice |	alternatives := parser possibleVariablesFor: name.	labels := OrderedCollection new.	actions := OrderedCollection new.	lines := OrderedCollection new.	name first isLowercase 		ifTrue: 			[labels add: 'declare temp'.			actions add: [parser declareTempAndPaste: name].			labels add: 'declare instance'.			actions add: [parser declareInstVar: name]]		ifFalse: 			[labels add: 'define new class'.			actions add: [parser defineClass: name].			labels add: 'declare global'.			actions add: [parser declareGlobal: name].			parser canDeclareClassVariable 				ifTrue: 					[labels add: 'declare class variable'.					actions add: [parser declareClassVar: name]]].	lines add: labels size.	alternatives do: 		[:each | 		labels add: each.		actions add: [parser substituteVariable: each atInterval: interval] fixTemps].	lines add: labels size.	labels add: 'cancel'.	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesPNtoPZ	self decompileClassesSelect: [:cn| cn first = $P and: [cn second asUppercase > $M]]! !!FieldNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 1 super: false)! !!ParseNodeEnumerator class methodsFor: 'instance creation' stamp: 'eem 7/20/2009 19:45'!ofBlock: aBlock	^self new ofBlock: aBlock! !!Parser methodsFor: 'primitives' stamp: 'eem 12/1/2008 09:18'!primitive: aNameString module: aModuleStringOrNil error: errorCodeVariableOrNil	"Create named primitive with optional error code."		(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	errorCodeVariableOrNil ifNotNil:		[encoder floatTemp: (encoder bindTemp: errorCodeVariableOrNil) nowHasDef].	^117! !!DecompilerTests methodsFor: 'tests' stamp: 'eem 9/23/2008 11:16'!testDecompilerInClassesAAtoAM	self decompileClassesSelect: [:cn| cn first = $A and: [cn second asUppercase <= $M]]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 7/24/2009 20:53'!supportTestSourceRangeAccessForInjectInto: method source: source	"Test debugger source range selection for inject:into:"	^self		supportTestSourceRangeAccessForInjectInto: method		source: source		selectionSequence: #(	':= thisValue'								'do: [:each | nextValue := binaryBlock value: nextValue value: each]'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								'nextValue := binaryBlock value: nextValue value: each'								'value: nextValue value: each'								':= binaryBlock value: nextValue value: each'								'nextValue := binaryBlock value: nextValue value: each'								'^nextValue')! !Parser removeSelector: #pragmaLiteral!Parser removeSelector: #subsituteVariable:atInterval:!Compiler removeSelector: #compiledMethodFor:in:to:!MethodNode removeSelector: #generateWith:using:!