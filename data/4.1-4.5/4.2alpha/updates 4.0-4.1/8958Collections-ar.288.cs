"Change Set:		8958Collections-ar.288Collections-ar.288:Sets with nil: Merge code from http://bugs.squeak.org/view.php?id=7413 before it rots even more.Collections-ar.287:Merge Collections-edc.286 with some changes:- Implement both beginsWithAnyOf: as well as endsWithAnyOf:- Push the implementation up to SequenceableCollection- Simplify the implementation (using #anySatisfy:)- Add comments (also in beginsWith: and endsWith:)- Add tests"!Object subclass: #SetElement	instanceVariableNames: 'enclosedElement'	classVariableNames: 'NilElement'	poolDictionaries: ''	category: 'Collections-Support'!!SequenceableCollection methodsFor: 'testing' stamp: 'ar 2/1/2010 19:10'!beginsWith: aSequenceableCollection	"Answer true if the receiver starts with the argument collection"	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	aSequenceableCollection withIndexDo: [:each :index | (self at: index) ~= each ifTrue: [^false]].	^true! !!IdentitySet methodsFor: 'private' stamp: 'ar 2/1/2010 19:53'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject scaledIdentityHash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ element enclosedSetElement == anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!Set methodsFor: 'private' stamp: 'ar 2/1/2010 19:56'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :object |			array				at: (self scanForEmptySlotFor: object enclosedSetElement)				put: object ] ]! !!Set methodsFor: 'adding' stamp: 'Igor.Stasenko 11/13/2009 06:59'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	index := self scanFor: newObject.	(array at: index) ifNil: [self atNewIndex: index put: newObject asSetElement].	^ newObject! !!Set methodsFor: 'private' stamp: 'ar 2/1/2010 19:55'!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| element index |	index := start.	[ (element := array at: (index := index \\ array size + 1)) == nil ] whileFalse: [		| newIndex |		(newIndex := self scanFor: element enclosedSetElement) = index ifFalse: [			array swap: index with: newIndex ] ]! !!SequenceableCollection methodsFor: 'testing' stamp: 'ar 2/1/2010 19:10'!endsWith: aSequenceableCollection	"Answer true if the receiver ends with the argument collection"	| start |	(aSequenceableCollection isEmpty or: [self size < aSequenceableCollection size]) ifTrue: [^false].	start := self size - aSequenceableCollection size.	aSequenceableCollection withIndexDo: [:each :index | (self at: start + index) ~= each ifTrue: [^false]].	^true! !!Set methodsFor: 'accessing' stamp: 'ar 2/1/2010 20:09'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	^(array at: (self scanFor: anObject)) ifNotNil:[:obj| obj enclosedSetElement]! !!SetElement class methodsFor: 'class initialization' stamp: 'Igor.Stasenko 11/13/2009 05:55'!initialize	NilElement := self with: nil.! !!SetElement methodsFor: 'accessing' stamp: 'Igor.Stasenko 11/13/2009 05:49'!enclosedSetElement: anObject	enclosedElement := anObject! !!Set methodsFor: 'private' stamp: 'ar 2/1/2010 20:02'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ element enclosedSetElement = anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!Set methodsFor: 'accessing' stamp: 'Igor.Stasenko 11/13/2009 07:13'!like: anObject ifAbsent: aBlock	"Answer an object in the receiver that is equal to anObject,	or evaluate the block if not found. Relies heavily on hash properties"	| element |	element := array at: (self scanFor: anObject).	^ element ifNil: [ aBlock value ] ifNotNil: [ element enclosedSetElement ]! !!SetElement methodsFor: 'comparing' stamp: 'Igor.Stasenko 11/13/2009 05:51'!= anObject	^ anObject class = self class and: [ enclosedElement = anObject enclosedSetElement ]! !!SetElement methodsFor: 'comparing' stamp: 'Igor.Stasenko 11/13/2009 05:52'!hash	^ enclosedElement hash! !!PluggableSet methodsFor: 'private' stamp: 'ar 2/1/2010 20:17'!scanFor: anObject 	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."		| index start |	index := start := (hashBlock		ifNil: [ anObject hash ]		ifNotNil: [ hashBlock value: anObject ]) \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [			equalBlock				ifNil: [ element enclosedSetElement = anObject ]				ifNotNil: [ equalBlock value: element enclosedSetElement value: anObject ] ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!SetElement methodsFor: 'converting' stamp: 'Igor.Stasenko 11/13/2009 06:29'!asSetElement	"A receiver has to be included into a set, as a distinct object.	We need to wrap receiver in own turn, otherwise #enclosedSetElement will return wrong object for that set"	^ SetElement with: self! !!SetElement class methodsFor: 'accessing' stamp: 'Igor.Stasenko 11/13/2009 05:56'!withNil	^ NilElement! !!SequenceableCollection methodsFor: 'testing' stamp: 'ar 2/1/2010 19:10'!endsWithAnyOf: aCollection	"Return true if the receiver ends with any of the elements in aCollection."	^aCollection anySatisfy:[:suffix| self endsWith: suffix].! !!SequenceableCollection methodsFor: 'testing' stamp: 'ar 2/1/2010 19:06'!beginsWithAnyOf: aCollection	"Return true if the receiver starts with any of the elements in aCollection."	^aCollection anySatisfy:[:prefix| self beginsWith: prefix].! !!SetElement methodsFor: 'accessing' stamp: 'Igor.Stasenko 11/13/2009 05:49'!enclosedSetElement	^ enclosedElement! !!Set methodsFor: 'enumerating' stamp: 'ar 2/1/2010 19:55'!do: aBlock 	tally = 0 ifTrue: [ ^self ].	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :element |			aBlock value: element enclosedSetElement] ]! !!SetElement class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 11/13/2009 05:53'!with: anObject	^ self new enclosedSetElement: anObject! !String removeSelector: #beginsWithAnyOf:!SetElement initialize!