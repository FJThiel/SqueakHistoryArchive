"Change Set:		9393MultilingualTests-ul.8MultilingualTests-ul.8:- make sure we don't leave files on the disk- use #xxxFileNamed:do: when possible- use #lf and #crlf with streams"!TestCase subclass: #MultiByteFileStreamTest	instanceVariableNames: 'fileName'	classVariableNames: ''	poolDictionaries: ''	category: 'MultilingualTests-TextConversion'!!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:27'!testLineEnding	fileName := 'foolinend.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file 			wantsLineEndConversion: false;			nextPutAll: 'line 1'; cr;			nextPutAll: 'line 2'; crlf;			nextPutAll: 'line 3'; lf;			nextPutAll: 'line 4' ].	{		{#cr.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{#lf.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{#crlf.  'line 1' , String cr , 'line 2' , String cr , 'line 3' , String cr , 'line 4'}.		{nil.  'line 1' , String cr , 'line 2' , String crlf , 'line 3' , String lf , 'line 4'}	} do: [:lineEndingResult |		MultiByteFileStream oldFileNamed: fileName do: [ :file |			file lineEndConvention: lineEndingResult first.			self assert: file upToEnd = lineEndingResult last ] ]! !!MultiByteFileStreamTest methodsFor: 'as yet unclassified' stamp: 'ul 2/14/2010 13:21'!tearDown	fileName ifNotNil: [		FileDirectory default deleteFileNamed: fileName ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:26'!testBinaryUpTo	"This is a non regression test for bug http://bugs.squeak.org/view.php?id=6933"		fileName := 'foobug6933'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file			binary;			nextPutAll: #[ 1 2 3 4 ] ].	MultiByteFileStream oldFileNamed: fileName do: [ :file |		file binary.		self assert: (file upTo: 3) = #[ 1 2 ] ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:21'!testAsciiBackChunk		fileName := 'foobackchunk.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file 			lineEndConvention: #cr; 			converter: UTF8TextConverter new;			cr; nextChunkPut: 'test1' printString;			cr; nextChunkPut: 'test2' printString.		self 			assert: file backChunk = (String cr , 'test2' printString);			assert: file backChunk = (String cr , 'test1' printString) ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:23'!testNextLine	fileName := 'foobackchunk.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file			wantsLineEndConversion: false;			nextPutAll: 'line 1'; cr;			nextPutAll: 'line 2'; crlf;			nextPutAll: 'line 3'; lf;			nextPutAll: 'line 4' ].	#(cr lf crlf nil) do: [:lineEnding |		MultiByteFileStream oldFileNamed: fileName do: [ :file |			file lineEndConvention: lineEnding.			self				assert: file nextLine = 'line 1';				assert: file nextLine = 'line 2';				assert: file nextLine = 'line 3';				assert: file nextLine = 'line 4';				assert: file nextLine = nil ] ]! !!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 2/14/2010 13:22'!testNonAsciiBackChunk	"Note: this is an expected failure: MultiByteFileStream is not equipped to read back non ASCII String... (no comment)	As a consequence, never use non ASCII in method category nor in your initials. That would make a few tools blind..."		fileName :=  'foobackchunk.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		file 			lineEndConvention: #cr; 			converter: UTF8TextConverter new;			cr; nextChunkPut: 'testé' printString;			cr; nextChunkPut: 'test' printString.		self assert: file backChunk = (String cr , 'test' printString).		self assert: file backChunk = (String cr , 'testé' printString) ]! !