"Change Set:		8781Morphic-ar.294Morphic-ar.294:Make Etoys unloadable: Move lots of methods to Etoys package. Remove the old Fabrik remnants."!!PluggableTextMorphWithModel methodsFor: 'contents' stamp: 'ar 1/3/2010 19:52'!newTextContents: stringOrText	"Accept new text contents."	| newText myText |	"Just underway; trying to make this work like TextMorph does, but not quite there yet."	newText := stringOrText asText.	(myText := textMorph text) = newText ifTrue: [^ self].  "No substantive change"		self world ifNotNil:		[self world startSteppingSubmorphsOf: self ].! !!Morph methodsFor: 'dropping/grabbing' stamp: 'ar 1/3/2010 19:53'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on -- and been accepted by -- a drop-sensitive morph"	| aWindow partsBinCase cmd |	(self formerOwner notNil and: [self formerOwner ~~ aMorph])		ifTrue: [self removeHalo].	self formerOwner: nil.	self formerPosition: nil.	cmd := self valueOfProperty: #undoGrabCommand.	cmd ifNotNil:[aMorph rememberCommand: cmd.				self removeProperty: #undoGrabCommand].	(partsBinCase := aMorph isPartsBin) ifFalse:		[self isPartsDonor: false].	(aWindow := aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	(self isInWorld and: [partsBinCase not]) ifTrue:		[self world startSteppingSubmorphsOf: self].	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."	"An object launched by certain parts-launcher mechanisms should end up fully visible..."	(self hasProperty: #beFullyVisibleAfterDrop) ifTrue:		[aMorph == ActiveWorld ifTrue:			[self goHome].		self removeProperty: #beFullyVisibleAfterDrop].! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:11'!isCompoundTileMorph	^false! !!Morph methodsFor: 'private' stamp: 'ar 1/3/2010 15:52'!privateMoveBy: delta 	"Private!! Use 'position:' instead."	| fill |	self player ifNotNil: ["Most cases eliminated fast by above test"		self getPenDown ifTrue: [			"If this is a costume for a player with its 			pen down, draw a line."			self moveWithPenDownBy: delta]].	bounds := bounds translateBy: delta.	fullBounds ifNotNil: [fullBounds := fullBounds translateBy: delta].	fill := self fillStyle.	fill isOrientedFill ifTrue: [fill origin: fill origin + delta]! !!MorphicProject methodsFor: 'file in/out' stamp: 'ar 1/3/2010 18:11'!storeSegmentNoFile	"For testing.  Make an ImageSegment.  Keep the outPointers in memory.  Also useful if you want to enumerate the objects in the segment afterwards (allObjectsDo:)"	| is |	(World == world) ifTrue: [^ self].		" inform: 'Can''t send the current world out'."	world isInMemory ifFalse: [^ self].  "already done"	world ifNil: [^ self].  world presenter ifNil: [^ self].	"Do this on project enter"	World flapTabs do: [:ft | ft referent adaptToWorld: World].		"Hack to keep the Menu flap from pointing at my project"	"Preferences setPreference: #useGlobalFlaps toValue: false."	"Utilities globalFlapTabsIfAny do:		[:aFlapTab | Utilities removeFlapTab: aFlapTab keepInList: false].	Utilities clobberFlapTabList.	"	"project world deleteAllFlapArtifacts."	"self currentWorld deleteAllFlapArtifacts.	"	Utilities emptyScrapsBook.	World checkCurrentHandForObjectToPaste2.	is := ImageSegment new copyFromRootsLocalFileFor: 			(Array with: world presenter with: world)	"world, and all Players"		sizeHint: 0.	is segment size < 800 ifTrue: ["debugging" 		Transcript show: self name, ' did not get enough objects'; cr.  ^ Beeper beep].	is extract.	"is instVarAt: 2 put: is segment clone."		"different memory"! !!Morph methodsFor: 'meta-actions' stamp: 'ar 1/3/2010 16:26'!openATextPropertySheet	"should only be sent to morphs that are actually supportive"	Smalltalk at: #TextPropertiesMorph ifPresent:[:aClass|		^aClass basicNew			targetMorph: self;			initialize;			openNearTarget	].	Beeper beep.! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:11'!isTileMorph	^false! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:17'!isSoundTile	^false! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'ar 1/3/2010 16:08'!valueFromContents	"Return a new value from the current contents string.""	| expression tilePadMorphOrNil asNumberBlock |	asNumberBlock := [:string | [string asNumber]				on: Error				do: []].	format = #string		ifTrue: [^ contents].	(format = #default			and: [self owner isKindOf: NumericReadoutTile])		ifTrue: [^ asNumberBlock value: contents].	tilePadMorphOrNil := self ownerThatIsA: TilePadMorph.	(tilePadMorphOrNil notNil			and: [tilePadMorphOrNil type = #Number])		ifTrue: [^ asNumberBlock value: contents].	expression := Vocabulary eToyVocabulary translationKeyFor: contents.	expression isNil		ifTrue: [expression := contents].	^ Compiler evaluate: expression"	format = #symbol ifTrue: [^ lastValue].	format = #string ifTrue: [^ contents].	(owner notNil and: [owner isNumericReadoutTile]) ifTrue: [		^ Number readFrom: contents	].	target ifNotNil: [target owner ifNotNil: [		((target owner isTilePadMorph) and: [target owner type = #Number])			ifTrue: [^ Number readFrom: contents]]].	^ Compiler evaluate: contents! !!Morph methodsFor: 'meta-actions' stamp: 'ar 1/3/2010 16:09'!openAPropertySheet	Smalltalk at: #ObjectPropertiesMorph ifPresent:[:aClass|		^aClass basicNew			targetMorph: self;			initialize;			openNearTarget	].	Beeper beep.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'ar 1/3/2010 19:57'!decimalPlaces: aNumber	"Set the receiver's number of decimal places to be shown.  If my target is a morph or a player, tell it about the change, in case it wants to remember it."	| constrained |	self setProperty: #decimalPlaces toValue: (constrained := aNumber min: 11).	self pvtFloatPrecision: (Utilities floatPrecisionForDecimalPlaces: constrained).	(target isMorph or:[target isPlayer]) ifTrue:		[target noteDecimalPlaces: constrained forGetter: getSelector]! !!Morph methodsFor: 'debug and other' stamp: 'ar 1/4/2010 00:29'!buildDebugMenu: aHand	"Answer a debugging menu for the receiver.  The hand argument is seemingly historical and plays no role presently"	| aMenu aPlayer |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue:		[aMenu add: 'start drawing again' translated action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue:		[aMenu add: 'start stepping again' translated action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' translated action: #inspectInMorphic:.	aMenu add: 'inspect owner chain' translated action: #inspectOwnerChain.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' translated action: #inspect].	self isMorphicModel ifTrue:		[aMenu add: 'inspect model' translated target: self model action: #inspect].	(aPlayer := self player) ifNotNil:		[aMenu add: 'inspect player' translated target: aPlayer action: #inspect].     aMenu add: 'explore morph' translated target: self selector: #explore.	aMenu addLine.	aPlayer ifNotNil:		[ aMenu add: 'viewer for Player' translated target: self player action: #beViewed.	aMenu balloonTextForLastItem: 'Opens a viewer on my Player -- this is the same thing you get if you click on the cyan "View" halo handle' translated ].	aMenu add: 'viewer for Morph' translated target: self action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'Opens a Viewer on this Morph, rather than on its Player' translated.	aMenu addLine.	aPlayer ifNotNil:		[aPlayer class isUniClass ifTrue: [			aMenu add: 'browse player class' translated target: aPlayer action: #browseHierarchy]].	aMenu add: 'browse morph class' translated target: self selector: #browseHierarchy.	(self isMorphicModel)		ifTrue: [aMenu				add: 'browse model class'				target: self model				selector: #browseHierarchy].	aMenu addLine.	self addViewingItemsTo: aMenu.	aMenu 		add: 'make own subclass' translated action: #subclassMorph;		add: 'save morph in file' translated  action: #saveOnFile;		addLine;		add: 'call #tempCommand' translated action: #tempCommand;		add: 'define #tempCommand' translated action: #defineTempCommand;		addLine;		add: 'control-menu...' translated target: self selector: #invokeMetaMenu:;		add: 'edit balloon help' translated action: #editBalloonHelpText.	^ aMenu! !!PasteUpMorph methodsFor: 'initialization' stamp: 'ar 3/17/2001 20:12'!adaptedToWorld: aWorld	"If I refer to a world or a hand, return the corresponding items in the new world."	self isWorldMorph ifTrue:[^aWorld].! !!PasteUpMorph methodsFor: 'misc' stamp: 'ar 1/3/2010 19:01'!allScriptEditors	^ self allMorphs select:		[:s | s isScriptEditorMorph]! !!Morph methodsFor: 'meta-actions' stamp: 'ar 1/3/2010 17:01'!buildMetaMenu: evt	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	menu := MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' translated action: #grabMorph:.	menu add: 'copy to paste buffer' translated action: #copyToPasteBuffer:.	self maybeAddCollapseItemTo: menu.	menu add: 'delete' translated action: #dismissMorph:.	menu addLine.	menu add: 'copy text' translated action: #clipText.	menu add: 'copy Postscript' translated action: #clipPostscript.	menu add: 'print Postscript to file...' translated action: #printPSToFile.	menu addLine.	menu add: 'go behind' translated action: #goBehind.	menu add: 'add halo' translated action: #addHalo:.	menu add: 'duplicate' translated action: #maybeDuplicateMorph:.	self addEmbeddingMenuItemsTo: menu hand: evt hand.	menu add: 'resize' translated action: #resizeMorph:.	"Give the argument control over what should be done about fill styles"	self addFillStyleMenuItems: menu hand: evt hand.	self addDropShadowMenuItems: menu hand: evt hand.	self addLayoutMenuItems: menu hand: evt hand.	menu addUpdating: #hasClipSubmorphsString target: self selector: #changeClipSubmorphs argumentList: #().	menu addLine.	(self morphsAt: evt position) size > 1 ifTrue:		[menu add: 'submorphs...' translated			target: self			selector: #invokeMetaMenuAt:event:			argument: evt position].	menu addLine.	menu add: 'inspect' translated selector: #inspectAt:event: argument: evt position.	menu add: 'explore' translated action: #explore.	menu add: 'browse hierarchy' translated action: #browseHierarchy.	menu add: 'make own subclass' translated action: #subclassMorph.	menu addLine.	(self isMorphicModel) ifTrue:		[menu add: 'save morph as prototype' translated action: #saveAsPrototype.		(self ~~ self world modelOrNil) ifTrue:			 [menu add: 'become this world''s model' translated action: #beThisWorldsModel]].	menu add: 'save morph in file' translated action: #saveOnFile.	(self hasProperty: #resourceFilePath)		ifTrue: [((self valueOfProperty: #resourceFilePath) endsWith: '.morph')				ifTrue: [menu add: 'save as resource' translated action: #saveAsResource].				menu add: 'update from resource' translated action: #updateFromResource]		ifFalse: [menu add: 'attach to resource' translated action: #attachToResource].	menu add: 'show actions' translated action: #showActions.	menu addLine.	self addDebuggingItemsTo: menu hand: evt hand.	self addCustomMenuItems: menu hand: evt hand.	^ menu! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:24'!isStickySketchMorph	^false! !!Morph methodsFor: 'testing' stamp: 'ar 1/3/2010 19:01'!renameTo: aName 	"Set Player name in costume. Update Viewers. Fix all tiles (old style). fix 	References. New tiles: recompile, and recreate open scripts. If coming in 	from disk, and have name conflict, References will already have new 	name. "	| aPresenter putInViewer aPasteUp renderer oldKey assoc classes oldName |	oldName := self knownName.	(renderer := self topRendererOrSelf) setNameTo: aName.	putInViewer := false.	((aPresenter := self presenter) isNil or: [renderer player isNil]) 		ifFalse: 			[putInViewer := aPresenter currentlyViewing: renderer player.			putInViewer ifTrue: [renderer player viewerFlapTab hibernate]].	"empty it temporarily"	(aPasteUp := self topPasteUp) 		ifNotNil: [aPasteUp allTileScriptingElements do: [:m | m bringUpToDate]].	"Fix References dictionary. See restoreReferences to know why oldKey is  	already aName, but oldName is the old name."	oldKey := References keyAtIdentityValue: renderer player ifAbsent: [].	oldKey ifNotNil: 			[assoc := References associationAt: oldKey.			oldKey = aName 				ifFalse: 					["normal rename"					assoc key: (renderer player uniqueNameForReferenceFrom: aName).					References rehash]].	putInViewer ifTrue: [aPresenter viewMorph: self].	"recreate my viewer"	oldKey ifNil: [^aName].	"Force strings in tiles to be remade with new name. New tiles only."	Preferences universalTiles ifFalse: [^aName].	classes := (self systemNavigation allCallsOn: assoc) 				collect: [:each | each classSymbol].	classes asSet 		do: [:clsName | (Smalltalk at: clsName) replaceSilently: oldName to: aName].	"replace in text body of all methods. Can be wrong!!"	"Redo the tiles that are showing. This is also done in caller in 	unhibernate. "	aPasteUp ifNotNil: 			[aPasteUp allTileScriptingElements do: 					[:mm | 					"just ScriptEditorMorphs"					nil.					(mm isScriptEditorMorph) 						ifTrue: 							[((mm playerScripted class compiledMethodAt: mm scriptName) 								hasLiteral: assoc) 									ifTrue: 										[mm											hibernate;											unhibernate]]]].	^aName! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 1/3/2010 19:51'!okayToAddGrabHandle	"Answer whether a halo on the receiver should offer a grab handle.  This provides a hook for making it harder to deconstruct some strucures even momentarily"	^ true! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'ar 1/3/2010 18:47'!acceptValue: aValue	self updateContentsFrom: (self acceptValueFromTarget: aValue).! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:08'!isNumericReadoutTile	^false! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:39'!isScriptEditorMorph	^false! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 1/3/2010 16:10'!morphToDropFrom: aMorph 	"Given a morph being carried by the hand, which the hand is about to drop, answer the actual morph to be deposited.  Normally this would be just the morph itself, but several unusual cases arise, which this method is designed to service."	| aNail representee handy posBlock |	handy := self primaryHand.	posBlock := 			[:z | | tempPos | 			tempPos := handy position 						- ((handy targetOffset - aMorph formerPosition) 								* (z extent / aMorph extent)) rounded.			self pointFromWorld: tempPos].	self alwaysShowThumbnail 		ifTrue: 			[aNail := aMorph 						representativeNoTallerThan: self maxHeightToAvoidThumbnailing						norWiderThan: self maximumThumbnailWidth						thumbnailHeight: self heightForThumbnails.			aNail == aMorph 				ifFalse: 					[aMorph formerPosition: aMorph position.					aNail position: (posBlock value: aNail)].			^aNail].	((aMorph isKindOf: MorphThumbnail) 		and: [(representee := aMorph morphRepresented) owner isNil]) 			ifTrue: 				[representee position: (posBlock value: representee).				^representee].	self showingListView 		ifTrue: 			[^aMorph 				listViewLineForFieldList: (self valueOfProperty: #fieldListSelectors)].	(aMorph hasProperty: #newPermanentScript) 		ifTrue: [^aMorph asEmptyPermanentScriptor].	((aMorph isPhraseTileMorph) or: [aMorph isSyntaxMorph]) 		ifFalse: [^aMorph].	aMorph userScriptSelector isEmptyOrNil 		ifTrue: 			["non-user"			self automaticPhraseExpansion ifFalse: [^aMorph]].	^aMorph morphToDropInPasteUp: self! !!Morph methodsFor: 'menus' stamp: 'ar 1/4/2010 00:28'!addHaloActionsTo: aMenu	"Add items to aMenu representing actions requestable via halo"	| subMenu |	subMenu := MenuMorph new defaultTarget: self.	subMenu addTitle: self externalName.	subMenu addStayUpItemSpecial.	subMenu addLine.	subMenu add: 'delete' translated action: #dismissViaHalo.	subMenu balloonTextForLastItem: 'Delete this object -- warning -- can be destructive!!' translated.	self maybeAddCollapseItemTo: subMenu.	subMenu add: 'grab' translated action: #openInHand.	subMenu balloonTextForLastItem: 'Pick this object up -- warning, since this removes it from its container, it can have adverse effects.' translated.	subMenu addLine.	subMenu add: 'resize' translated action: #resizeFromMenu.	subMenu balloonTextForLastItem: 'Change the size of this object' translated.	subMenu add: 'duplicate' translated action: #maybeDuplicateMorph.	subMenu balloonTextForLastItem: 'Hand me a copy of this object' translated.	"Note that this allows access to the non-instancing duplicate even when this is a uniclass instance"	self couldMakeSibling ifTrue:		[subMenu add: 'make a sibling' translated action: #handUserASibling.		subMenu balloonTextForLastItem: 'Make a new sibling of this object and hand it to me' translated].	subMenu addLine.	subMenu add: 'property sheet' translated target: self renderedMorph action: #openAPropertySheet.	subMenu balloonTextForLastItem: 'Open a property sheet for me. Allows changing lots of stuff at once.' translated.	subMenu add: 'set color' translated target: self renderedMorph action: #changeColor.	subMenu balloonTextForLastItem: 'Change the color of this object' translated.	subMenu add: 'viewer' translated target: self action: #beViewed.	subMenu balloonTextForLastItem: 'Open a Viewer that will allow everything about this object to be seen and controlled.' translated.	subMenu balloonTextForLastItem: 'Open a tool that will facilitate tile scripting of this object.' translated.	subMenu add: 'hand me a tile' translated target: self action: #tearOffTile.	subMenu balloonTextForLastItem: 'Hand me a tile represting this object' translated.	subMenu addLine.	subMenu add: 'inspect' translated target: self action: #inspect.	subMenu balloonTextForLastItem: 'Open an Inspector on this object' translated.	aMenu add: 'halo actions...' translated subMenu: subMenu! !!Morph methodsFor: 'e-toy support' stamp: 'ar 1/3/2010 16:39'!objectViewed	"Answer the morph associated with the player that the structure the receiver currently finds itself within represents."	^ (self outermostMorphThat: [:o | o isViewer or:[ o isScriptEditorMorph]]) objectViewed! !!HaloMorph methodsFor: 'handles' stamp: 'ar 1/4/2010 00:28'!tearOffTileForTarget: evt with: aHandle	"Tear off a tile representing my inner target.  If shift key is down, open up an instance browser on the morph itself, not the player, with tiles showing, instead"	self obtainHaloForEvent: evt andRemoveAllHandlesBut: nil.	innerTarget tearOffTile! !!PasteUpMorph methodsFor: 'drawing' stamp: 'ar 1/3/2010 16:31'!drawOn: aCanvas 	"Draw in order:	- background color	- grid, if any	- background sketch, if any	- Update and draw the turtleTrails form. See the comment in updateTrailsForm.	- cursor box if any	Later (in drawSubmorphsOn:) I will skip drawing the background sketch."	"draw background fill"	super drawOn: aCanvas.	"draw grid"	(self griddingOn and: [self gridVisible]) 		ifTrue: 			[aCanvas fillRectangle: self bounds				fillStyle: (self 						gridFormOrigin: self gridOrigin						grid: self gridModulus						background: nil						line: Color lightGray)].	"draw background sketch."	backgroundMorph ifNotNil: [		self clipSubmorphs ifTrue: [			aCanvas clipBy: self clippingBounds				during: [ :canvas | canvas fullDrawMorph: backgroundMorph ]]			ifFalse: [ aCanvas fullDrawMorph: backgroundMorph ]].	"draw turtle trails"	(lastTurtlePositions isNil or: [lastTurtlePositions isEmpty]) ifFalse:[		self updateTrailsForm.	].	turtleTrailsForm 		ifNotNil: [aCanvas paintImage: turtleTrailsForm at: self position].	"draw cursor"	(submorphs notEmpty and: [self indicateCursor]) 		ifTrue: 			[aCanvas 				frameRectangle: self selectedRect				width: 2				color: Color black]! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:39'!isViewer	^false! !!Morph methodsFor: 'accessing' stamp: 'ar 1/3/2010 18:05'!defaultNameStemForInstances	^self class name! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 1/3/2010 16:37'!makeNewDrawing: evt at: aPoint	"make a new drawing, triggered by the given event, with the painting area centered around the given point"	| w newSketch newPlayer sketchEditor aPalette rect aPaintBox aPaintTab aWorld |	w := self world.	w assureNotPaintingElse: [^ self].	rect := self paintingBoundsAround: aPoint.	aPalette := self standardPalette.	aPalette ifNotNil: [aPalette showNoPalette; layoutChanged].	w prepareToPaint.	newSketch := self drawingClass new.	Smalltalk at: #UnscriptedPlayer ifPresent:[:aClass|		newSketch player: (newPlayer := aClass newUserInstance).		newPlayer costume: newSketch.	].	newSketch nominalForm: (Form extent: rect extent depth: w assuredCanvas depth).	newSketch bounds: rect.	sketchEditor := SketchEditorMorph new.	w addMorphFront: sketchEditor.	sketchEditor initializeFor: newSketch inBounds: rect pasteUpMorph: self.	sketchEditor		afterNewPicDo: [:aForm :aRect | | tfx ownerBeforeHack whereToPresent |			whereToPresent := self presenter.			newSketch form: aForm.			tfx := self transformFrom: w.			newSketch position: (tfx globalPointToLocal: aRect origin).			newSketch rotationStyle: sketchEditor rotationStyle.			newSketch forwardDirection: sketchEditor forwardDirection.			ownerBeforeHack := newSketch owner.	"about to break the invariant!!!!"			newSketch privateOwner: self. "temp for halo access"			newPlayer ifNotNil:[newPlayer setHeading: sketchEditor forwardDirection].			(aPaintTab := (aWorld := self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox := aWorld paintBox) ifNotNil:[aPaintBox delete]].			"Includes  newSketch rotationDegrees: sketchEditor forwardDirection."			newSketch privateOwner: ownerBeforeHack. "probably nil, but let's be certain"			self addMorphFront: (newPlayer ifNil:[newSketch] ifNotNil:[newPlayer costume]).			w startSteppingSubmorphsOf: newSketch.			whereToPresent drawingJustCompleted: newSketch]		 ifNoBits:[			(aPaintTab := (aWorld := self world) paintingFlapTab)				ifNotNil:[aPaintTab hideFlap]				ifNil:[(aPaintBox := aWorld paintBox) ifNotNil:[aPaintBox delete]].			aPalette ifNotNil: [aPalette showNoPalette].]! !!ColorPickerMorph methodsFor: 'kedama' stamp: 'ar 1/3/2010 18:52'!getColorFromKedamaWorldIfPossible: aGlobalPoint	self world submorphs do: [:sub |		 (sub isKedamaMorph) ifTrue: [			sub morphsAt: aGlobalPoint unlocked: false do: [:e |				^ e colorAt: (aGlobalPoint - e topLeft).			].		].	].	^ nil.! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 18:53'!isKedamaMorph	^false! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:10'!isPhraseTileMorph	^false! !!Morph methodsFor: 'naming' stamp: 'ar 1/3/2010 19:52'!tryToRenameTo: aName	"A new name has been submited; make sure it's appropriate, and react accordingly.  This circumlocution provides the hook by which the simple renaming of a field can result in a change to variable names in a stack, etc.  There are some problems to worry about here."	self renameTo: aName.! !!MorphicProject methodsFor: 'file in/out' stamp: 'ar 1/3/2010 19:01'!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder |	self flag: #toRemove.	self halt.  "unused"	"world == World ifTrue: [^ false]."		"self inform: 'Can''t send the current world out'."	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers. 	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	holder := Project allProjects.	"force them in to outPointers, where DiskProxys are made"	"Just export me, not my previous version"	revertSeg := self projectParameters at: #revertToMe ifAbsent: [nil].	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots := OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).	roots := roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	catList do: [:sysCat | 		(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |			roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].	is := ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is := ImageSegment new copyFromRootsForExport: roots asArray)"	is state = #tooBig ifTrue: [^ false].	str := ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str := str, '\Project''s own world is not in the segment.' withCRs].	str isEmpty ifFalse: [		ans := (UIManager default				 chooseFrom: #('Do not write file' 'Write file anyway' 'Debug')				 title: str).		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].			^ false].		ans = 3 ifTrue: [self halt: 'Segment not written']].	is writeForExportWithSources: aFileName inDirectory: aDirectory.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	world flapTabs do: [:ft | 			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj isScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 1/3/2010 16:24'!findWindow: evt	"Present a menu names of windows and naked morphs, and activate the one that gets chosen.  Collapsed windows appear below line, expand if chosen; naked morphs appear below second line; if any of them has been given an explicit name, that is what's shown, else the class-name of the morph shows; if a naked morph is chosen, bring it to front and have it don a halo."	| menu expanded collapsed nakedMorphs |	menu := MenuMorph new.	expanded := SystemWindow windowsIn: self satisfying: [:w | w isCollapsed not].	collapsed := SystemWindow windowsIn: self satisfying: [:w | w isCollapsed].	nakedMorphs := self submorphsSatisfying:		[:m | (m isSystemWindow not and: [(m isStickySketchMorph) not]) and:			[(m isFlapTab) not]].	(expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty)) ifTrue: [^ Beeper beep].	(expanded asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do:		[:w | menu add: w label target: w action: #activateAndForceLabelToShow.			w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	(expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty)) ifFalse: [menu addLine].	(collapsed asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do: 		[:w | menu add: w label target: w action: #collapseOrExpand.		w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asSortedCollection: [:w1 :w2 | w1 nameForFindWindowFeature caseInsensitiveLessOrEqual: w2 nameForFindWindowFeature]) do:		[:w | menu add: w nameForFindWindowFeature target: w action: #comeToFrontAndAddHalo].	menu addTitle: 'find window' translated.		menu popUpEvent: evt in: self.! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'ar 1/3/2010 16:14'!acceptDroppingMorph: dropped event: evt	"The supplied morph, known to be acceptable to the receiver, is now to be assimilated; the precipitating event is supplied"	| aMorph |	aMorph := self morphToDropFrom: dropped.	self isWorldMorph		ifTrue:["Add the given morph to this world and start stepping it if it wants to be."				self addMorphFront: aMorph.				(aMorph fullBounds intersects: self viewBox) ifFalse:					[Beeper beep.  aMorph position: self bounds center]]		ifFalse:[super acceptDroppingMorph: aMorph event: evt].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	aMorph allMorphsDo:  "Establish any penDown morphs in new world"		[:m | | tfm mm |		m player ifNotNil:			[m player getPenDown ifTrue:				[((mm := m player costume) notNil and: [(tfm := mm owner transformFrom: self) notNil])					ifTrue: [self noteNewLocation: (tfm localPointToGlobal: mm referencePosition)									forPlayer: m player]]]].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph stopSteppingSelfAndSubmorphs.			aMorph suspendEventHandler]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph]."	self presenter morph: aMorph droppedIntoPasteUpMorph: self."	self showingListView ifTrue:		[self sortSubmorphsBy: (self valueOfProperty: #sortOrder).		self currentWorld abandonAllHalos].	self bringTopmostsToFront.! !!TransformationMorph methodsFor: 'private' stamp: 'ar 1/3/2010 15:52'!adjustAfter: changeBlock 	"Cause this morph to remain cetered where it was before, and	choose appropriate smoothing, after a change of scale or rotation."	| oldRefPos |	oldRefPos := self referencePosition.	changeBlock value.	self chooseSmoothing.	self actorStateOrNil ifNotNil:[		self penUpWhile: [self position: self position + (oldRefPos - self referencePosition)].	].	self layoutChanged.	owner ifNotNil: [owner invalidRect: bounds]! !!MorphicProject methodsFor: 'enter' stamp: 'ar 1/3/2010 16:16'!finalEnterActions	"Perform the final actions necessary as the receiver project is entered"	| navigator armsLengthCmd navType thingsToUnhibernate |	self projectParameters 		at: #projectsToBeDeleted 		ifPresent: [ :projectsToBeDeleted |			self removeParameter: #projectsToBeDeleted.			projectsToBeDeleted do: [ :each | 				Project deletingProject: each.				each removeChangeSetIfPossible]].	Locale switchAndInstallFontToID: self localeID.	thingsToUnhibernate := world valueOfProperty: #thingsToUnhibernate ifAbsent: [#()].	thingsToUnhibernate do: [:each | each unhibernate].	world removeProperty: #thingsToUnhibernate.	navType := ProjectNavigationMorph preferredNavigator.	armsLengthCmd := self parameterAt: #armsLengthCmd ifAbsent: [nil].	navigator := world findA: navType.	(Preferences classicNavigatorEnabled and: [Preferences showProjectNavigator and: [navigator isNil]]) ifTrue:		[(navigator := navType new)			bottomLeft: world bottomLeft;			openInWorld: world].	navigator notNil & armsLengthCmd notNil ifTrue:		[navigator color: Color lightBlue].	armsLengthCmd notNil ifTrue:		[Preferences showFlapsWhenPublishing			ifFalse:				[self flapsSuppressed: true.				navigator ifNotNil:	[navigator visible: false]].		armsLengthCmd openInWorld: world].	world reformulateUpdatingMenus.	world presenter positionStandardPlayer.	self assureMainDockingBarPresenceMatchesPreference.	WorldState addDeferredUIMessage: [self startResourceLoading].! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 1/3/2010 19:51'!okayToAddDismissHandle	"Answer whether a halo on the receiver should offer a dismiss handle.  This provides a hook for making it harder to disassemble some strucures even momentarily"	^ self resistsRemoval not! !!Morph methodsFor: 'classification' stamp: 'ar 1/3/2010 16:08'!isTilePadMorph	^false! !!Morph methodsFor: 'accessing' stamp: 'ar 1/3/2010 16:10'!methodCommentAsBalloonHelp	"Given that I am a morph that is associated with an object and a method, answer a suitable method comment relating to that object & method if possible"	| inherentSelector actual |	(inherentSelector := self valueOfProperty: #inherentSelector)		ifNotNil:			[(actual := (self firstOwnerSuchThat:[:m| m isPhraseTileMorph or:[m isSyntaxMorph]]) actualObject) ifNotNil:				[^ actual class precodeCommentOrInheritedCommentFor: inherentSelector]].	^ nil! !!PasteUpMorph methodsFor: 'misc' stamp: 'ar 1/3/2010 16:17'!prepareToBeSaved	"Prepare for export via the ReferenceStream mechanism"	| exportDict soundKeyList players |	super prepareToBeSaved.	turtlePen := nil.	self isWorldMorph		ifTrue:			[self removeProperty: #scriptsToResume.			soundKeyList := Set new.			(players := self presenter allExtantPlayers)				do: [:aPlayer | aPlayer slotInfo						associationsDo: [:assoc | assoc value type == #Sound								ifTrue: [soundKeyList										add: (aPlayer instVarNamed: assoc key)]]].			players				do: [:p | p allScriptEditors						do: [:e | (e allMorphs								select: [:m | m isSoundTile])								do: [:aTile | soundKeyList add: aTile literal]]].			(self allMorphs				select: [:m | m isSoundTile])				isTileMorph				do: [:aTile | soundKeyList add: aTile literal].			soundKeyList removeAllFoundIn: SampledSound universalSoundKeys.			soundKeyList				removeAllSuchThat: [:aKey | (SampledSound soundLibrary includesKey: aKey) not].			soundKeyList isEmpty				ifFalse: [exportDict := Dictionary new.					soundKeyList						do: [:aKey | exportDict								add: (SampledSound soundLibrary associationAt: aKey)].					self setProperty: #soundAdditions toValue: exportDict]]! !!MorphicProject methodsFor: 'file in/out' stamp: 'ar 1/3/2010 19:01'!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileNamedirectory: aDirectory	"Store my project out on the disk as an *exported*ImageSegment.  All outPointers will be in a form that can be resolvedin the target image.  Name it <project name>.extSeg.  Whatdo we doabout subProjects, especially if they are out as local imagesegments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder collector fd mgr stacks |	"Files out a changeSet first, so that a project can containits own classes"	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any	references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers.	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	holder := Project allProjects.	"force them in to outPointers, where	DiskProxys are made"	"Just export me, not my previous version"	revertSeg := self projectParameters at: #revertToMe ifAbsent: [nil].	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots := OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand.		"; addAll: classList; addAll: (classList collect: [:cls | cls class])"	roots := roots reject: [ :x | x isNil].	"early saves may not have	active hand or thumbnail"		fd := aDirectory directoryNamed: self resourceDirectoryName.		fd assureExistence.		"Clean up resource references before writing out"		mgr := self resourceManager.		self resourceManager: nil.		ResourceCollector current: ResourceCollector new.		ResourceCollector current localDirectory: fd.		ResourceCollector current baseUrl: self resourceUrl.		ResourceCollector current initializeFrom: mgr.		ProgressNotification signal: '2:findingResources' extra:	'(collecting resources...)' translated.		"Must activate old world because this is run at #armsLength.		Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent		will not be captured correctly if referenced from blocks or user code."		world becomeActiveDuring:[			is := ImageSegment new copySmartRootsExport: roots asArray.			"old way was (is := ImageSegment new	copyFromRootsForExport: roots asArray)"		].		self resourceManager: mgr.		collector := ResourceCollector current.		ResourceCollector current: nil.		ProgressNotification signal: '2:foundResources' extra: ''.		is state = #tooBig ifTrue: [			collector replaceAll.			^ false].	str := ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str := str, '\Project''s own world is not in the segment.' translated withCRs].	str isEmpty ifFalse: [		ans := UIManager default chooseFrom: {			'Do not write file' translated.			'Write file anyway' translated.			'Debug' translated.		} title: str.		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at:	#revertToMe put: revertSeg].			collector replaceAll.			^ false].		ans = 3 ifTrue: [			collector replaceAll.			self halt: 'Segment not written' translated]].		stacks := is findStacks.		is			writeForExportWithSources: aFileName			inDirectory: fd			changeSet: aChangeSetOrNil.		SecurityManager default signFile: aFileName directory: fd.		"Compress all files and update check sums"		collector forgetObsolete.		self storeResourceList: collector in: fd.		self storeHtmlPageIn: fd.		self storeManifestFileIn: fd.		self writeStackText: stacks in: fd registerIn: collector.		"local proj.005.myStack.t"		self compressFilesIn: fd to: aFileName in: aDirectory	resources: collector.				"also deletes the resource directory"		"Now update everything that we know about"		mgr updateResourcesFrom: collector.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	collector replaceAll.	world flapTabs do: [:ft |			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj isScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!PasteUpMorph methodsFor: 'accessing' stamp: 'ar 1/3/2010 18:11'!presenter	"Normally only the world will have a presenter, but the architecture supports individual localized presenters as well"	^ presenter ifNil:		[self isWorldMorph			ifTrue: [presenter := Presenter defaultPresenterClass new associatedMorph: self]			ifFalse: [super presenter]]! !Morph removeSelector: #updateLiteralLabel!Morph removeSelector: #makeAllTilesGreen!Morph removeSelector: #arrowDeltaFor:!Morph removeSelector: #traverseRowTranslateSlotOld:to:!PasteUpMorph removeSelector: #backgroundForm:!Morph removeSelector: #choosePenColor:!Morph removeSelector: #stopHoldingSeparateDataForEachInstance!Morph removeSelector: #definePath!ScriptEditorMorph removeSelector: #addDismissButtonTo:!Morph removeSelector: #triggerScript:!PasteUpMorph removeSelector: #attemptCleanup!PasteUpMorph removeSelector: #noArrowheadsOnAllPens!Morph removeSelector: #variableDocks!Morph removeSelector: #couldHoldSeparateDataForEachInstance!ScriptEditorMorph removeSelector: #showingMethodPane!Morph removeSelector: #insertCard!Morph removeSelector: #wrapWithAStack!Morph removeSelector: #traverseRowTranslateSlotOld:of:to:!PasteUpMorph removeSelector: #deleteBackgroundPainting!PasteUpMorph removeSelector: #abandonOldReferenceScheme!ScriptEditorMorph removeSelector: #defaultColor!Morph removeSelector: #set:!PasteUpMorph removeSelector: #viewByIcon!ScriptEditorMorph removeSelector: #hibernate!PasteUpMorph removeSelector: #toggleAutomaticViewing!Morph removeSelector: #putOnForeground!ScriptEditorMorph removeSelector: #handUserTileForSelf!Morph removeSelector: #isTileScriptingElement!Morph removeSelector: #moveWithPenDownBy:!Morph removeSelector: #firedMouseUpCode!ScriptEditorMorph removeSelector: #phrase:!Morph removeSelector: #creationStamp!ComponentLikeModel removeSelector: #nameMeIn:!StandardScriptingSystem class removeSelector: #removeUnreferencedPlayers!Morph removeSelector: #makeHoldSeparateDataForEachInstance!Morph removeSelector: #choosePenSize!Morph removeSelector: #deletePath!ScriptEditorMorph removeSelector: #handlesMouseOver:!ScriptEditorMorph removeSelector: #userScriptObject!Morph removeSelector: #showBackgroundObjects!ScriptEditorMorph removeSelector: #releaseCachedState!Morph removeSelector: #fenceEnabled!Morph class removeSelector: #helpContributions!Morph class removeSelector: #additionsToViewerCategoryConnection!ScriptEditorMorph removeSelector: #printOn:!Morph removeSelector: #buttonProperties!ScriptEditorMorph removeSelector: #defaultBorderWidth!Morph removeSelector: #currentDataValue!ScriptEditorMorph removeSelector: #handUserParameterTile!PasteUpMorph removeSelector: #attemptCleanupReporting:!Morph removeSelector: #scriptEditorFor:!Morph removeSelector: #tanOButton!Morph removeSelector: #enforceTileColorPolicy!PasteUpMorph removeSelector: #batchPenTrailsString!ComponentLikeModel removeSelector: #initPinSpecs!Morph removeSelector: #currentVocabulary!PasteUpMorph removeSelector: #viewByName!ScriptEditorMorph class removeSelector: #writingUniversalTiles!Morph removeSelector: #succeededInRevealing:!Morph removeSelector: #relaxGripOnVariableNames!PasteUpMorph removeSelector: #impartPrivatePresenter!Morph removeSelector: #bringTileScriptingElementsUpToDate!ScriptEditorMorph removeSelector: #setParameterType:!ScriptEditorMorph removeSelector: #hasScriptInvoking:ofPlayer:!Morph removeSelector: #makeAllTilesColored!PasteUpMorph class removeSelector: #additionsToViewerCategoryPreferences!ScriptEditorMorph class removeSelector: #includeInNewMorphMenu!Morph removeSelector: #adoptVocabulary:!ComponentLikeModel removeSelector: #addPinFromSpec:!ScriptEditorMorph removeSelector: #renameScript!PasteUpMorph removeSelector: #backgroundForm!ScriptEditorMorph removeSelector: #savedTileVersionsCount!Morph removeSelector: #tearOffTile!Morph removeSelector: #asWearableCostume!ComponentLikeModel removeSelector: #pinsDo:!PluggableTextMorph removeSelector: #selectionAsTiles!PasteUpMorph removeSelector: #toggleBehaveLikeAHolder!ScriptEditorMorph removeSelector: #buttonRowForEditor!ScriptEditorMorph removeSelector: #hasScriptReferencing:ofPlayer:!ScriptEditorMorph removeSelector: #tileRows!Morph removeSelector: #convertAugust1998:using:!Morph removeSelector: #jettisonScripts!ScriptEditorMorph removeSelector: #scriptInstantiation!ScriptEditorMorph removeSelector: #isEmpty!PasteUpMorph removeSelector: #becomeLikeAHolder!PasteUpMorph removeSelector: #toggleOriginAtCenter!ScriptEditorMorph removeSelector: #myMorph!Morph removeSelector: #stack!Morph removeSelector: #wantsConnectionVocabulary!ScriptEditorMorph removeSelector: #scriptTitle!Morph removeSelector: #penUpWhile:!PasteUpMorph removeSelector: #fenceEnabledString!ScriptEditorMorph removeSelector: #renameScriptTo:!ScriptEditorMorph removeSelector: #scriptEdited!PasteUpMorph removeSelector: #arrowheadsOnAllPens!ScriptEditorMorph removeSelector: #setScriptNameTo:!Morph removeSelector: #asEmptyPermanentScriptor!PasteUpMorph removeSelector: #viewingNonOverlappingString!PasteUpMorph removeSelector: #batchPenTrails!Morph removeSelector: #explainDesignations!Morph removeSelector: #getCharacters!Morph removeSelector: #isTurtleRow!Morph removeSelector: #hasButtonProperties!Morph removeSelector: #addPlayerItemsTo:!ScriptEditorMorph removeSelector: #addNewRow!PasteUpMorph removeSelector: #toggleBatchPenTrails!ScriptEditorMorph removeSelector: #installWithNewLiteral!ComponentLikeModel removeSelector: #justDroppedInto:event:!ScriptEditorMorph removeSelector: #destroyScript!Morph removeSelector: #viewAfreshIn:showingScript:at:!Morph removeSelector: #stackDo:!ScriptEditorMorph removeSelector: #addYesNoToHand!ComponentLikeModel removeSelector: #initComponentIn:!Morph removeSelector: #isTileLike!ScriptEditorMorph removeSelector: #updateStatusMorph:!ScriptEditorMorph removeSelector: #handUserButtonUpTile!ScriptEditorMorph removeSelector: #removeEmptyRows!Morph removeSelector: #newCard!ScriptEditorMorph removeSelector: #addCustomMenuItems:hand:!ComponentLikeModel removeSelector: #deleteComponent!PasteUpMorph removeSelector: #updateSubmorphThumbnails!Morph removeSelector: #useUniformTileColor!Morph removeSelector: #tabHitWithEvent:!ScriptEditorMorph removeSelector: #showingMethodPane:!PasteUpMorph removeSelector: #presentViewMenu!ScriptEditorMorph removeSelector: #revertScriptVersion!ScriptEditorMorph removeSelector: #dismissViaHalo!ScriptEditorMorph removeSelector: #methodNodeMorph!ScriptEditorMorph removeSelector: #recreateScript!PasteUpMorph removeSelector: #behaveLikeAHolderString!PasteUpMorph removeSelector: #clearTurtleTrails!PasteUpMorph removeSelector: #relaunchAllViewers!Morph removeSelector: #trailMorph!ScriptEditorMorph removeSelector: #trackDropZones!Morph removeSelector: #enclosingEditor!ScriptEditorMorph removeSelector: #isTileScriptingElement!PasteUpMorph removeSelector: #toggleIndicateCursor!PasteUpMorph removeSelector: #modernizeBJProject!Morph removeSelector: #currentDataInstance!Morph removeSelector: #newPlayerInstance!ScriptEditorMorph removeSelector: #setTimeStamp!PasteUpMorph removeSelector: #linesForAllPens!ScriptEditorMorph removeSelector: #assureParameterTilesValid!ScriptEditorMorph removeSelector: #updateToPlayer:!ScriptEditorMorph removeSelector: #drawOn:!PasteUpMorph removeSelector: #scriptorForTextualScript:ofPlayer:!Morph removeSelector: #makeFenceSound!Morph removeSelector: #isStackBackground!PasteUpMorph removeSelector: #dotsForAllPens!ScriptEditorMorph removeSelector: #fixLayoutOfSubmorphsNotIn:!PasteUpMorph removeSelector: #updateTrailsForm!ScriptEditorMorph removeSelector: #dismiss!PasteUpMorph removeSelector: #imposeListViewSortingBy:retrieving:!ScriptEditorMorph removeSelector: #codeString!ScriptEditorMorph removeSelector: #handlesMouseOverDragging:!PasteUpMorph removeSelector: #batchPenTrails:!Morph removeSelector: #ensuredButtonProperties!Morph removeSelector: #showForegroundObjects!Morph removeSelector: #assuredPlayer!Morph removeSelector: #showDesignationsOfObjects!PasteUpMorph removeSelector: #addViewingItemsTo:!ScriptEditorMorph class removeSelector: #writingUniversalTiles:!ScriptEditorMorph removeSelector: #removeSpaces!PasteUpMorph removeSelector: #backgroundSketch:!PasteUpMorph removeSelector: #currentVocabularyFor:!Morph class removeSelector: #additionsToViewerCategoryColorAndBorder!ScriptEditorMorph removeSelector: #showSourceInScriptor!Morph removeSelector: #bringUpToDate!ScriptEditorMorph removeSelector: #editMethodDescription!ScriptEditorMorph removeSelector: #timeStamp!ScriptEditorMorph removeSelector: #becomeTextuallyCoded!ComponentLikeModel removeSelector: #showPins!ScriptEditorMorph removeSelector: #isCandidateForAutomaticViewing!ScriptEditorMorph removeSelector: #wantsHaloHandleWithSelector:inHalo:!ScriptEditorMorph removeSelector: #recompileScript!ScriptEditorMorph removeSelector: #modernize!PasteUpMorph removeSelector: #autoViewingString!ScriptEditorMorph removeSelector: #tryMe!Morph removeSelector: #defaultFloatPrecisionFor:!PasteUpMorph removeSelector: #viewNonOverlapping!ScriptEditorMorph removeSelector: #playerScripted!PasteUpMorph removeSelector: #tellAllContents:!PasteUpMorph removeSelector: #fenceEnabled!Morph removeSelector: #changeAllBorderColorsFrom:to:!MorphicProject removeSelector: #currentStack!Morph removeSelector: #scriptPerformer!ScriptEditorMorph removeSelector: #fixUponLoad:seg:!PasteUpMorph removeSelector: #hideAllPlayers!PasteUpMorph removeSelector: #showAllPlayers!ScriptEditorMorph removeSelector: #veryDeepFixupWith:!PasteUpMorph removeSelector: #lowerAllPens!ScriptEditorMorph removeSelector: #insertUniversalTilesForClass:selector:!Morph removeSelector: #reshapeBackground!ScriptEditorMorph removeSelector: #toggleWhetherShowingTiles!Morph removeSelector: #putOnBackground!PasteUpMorph removeSelector: #createOrResizeTrailsForm!ScriptEditorMorph removeSelector: #methodString!ScriptEditorMorph removeSelector: #chooseFrequency!ScriptEditorMorph removeSelector: #veryDeepInner:!ScriptEditorMorph removeSelector: #tearOfButtonToFireScript!ScriptEditorMorph removeSelector: #rowInsertionIndexFor:!ScriptEditorMorph removeSelector: #adaptToWorld:!ComponentLikeModel removeSelector: #renameMe!Morph removeSelector: #goToNextCardInStack!Morph removeSelector: #defaultVariableName!ScriptEditorMorph removeSelector: #explainStatusAlternatives!Morph removeSelector: #asWearableCostumeOfExtent:!Morph removeSelector: #appearsToBeSameCostumeAs:!Morph removeSelector: #getPenSize!Morph removeSelector: #containsCard:!ScriptEditorMorph removeSelector: #repelsMorph:event:!PasteUpMorph removeSelector: #viewingBySizeString!ScriptEditorMorph removeSelector: #handUserButtonDownTile!Morph removeSelector: #holdsSeparateDataForEachInstance!Morph removeSelector: #choosePartName!ScriptEditorMorph removeSelector: #scriptee!PasteUpMorph removeSelector: #notePenDown:forPlayer:at:!Morph removeSelector: #beAStackBackground!Morph removeSelector: #buttonProperties:!ScriptEditorMorph removeSelector: #saveScriptVersion!Morph removeSelector: #installAsCurrent:!ScriptEditorMorph removeSelector: #acceptDroppingMorph:event:!ScriptEditorMorph removeSelector: #insertTileRow:after:!ScriptEditorMorph removeSelector: #fixLayout!Morph removeSelector: #followPath!ScriptEditorMorph removeSelector: #storeCodeOn:indent:!ComponentLikeModel removeSelector: #initFromPinSpecs!JoystickMorph class removeSelector: #additionsToViewerCategories!Morph removeSelector: #listViewLineForFieldList:!Morph removeSelector: #restoreTypeColor!ScriptEditorMorph removeSelector: #insertUniversalTiles!PasteUpMorph removeSelector: #backgroundSketch!Morph removeSelector: #jumpTo:!Morph removeSelector: #actorState!PasteUpMorph removeSelector: #setThumbnailHeight!ScriptEditorMorph removeSelector: #extent:!Morph removeSelector: #isValidWonderlandTexture!Morph removeSelector: #becomeSharedBackgroundField!ScriptEditorMorph removeSelector: #autoFitOnOff!PasteUpMorph removeSelector: #fenceEnabled:!ScriptEditorMorph removeSelector: #morph!ComponentLikeModel removeSelector: #extent:!PasteUpMorph removeSelector: #makeDetachable!ScriptEditorMorph removeSelector: #actuallyDestroyScript!ScriptEditorMorph removeSelector: #fromExistingMethod:forPlayer:!PasteUpMorph removeSelector: #getCharacters!PasteUpMorph removeSelector: #viewerFlapTabFor:!ScriptEditorMorph removeSelector: #revertToTileVersion!ScriptEditorMorph removeSelector: #unhibernate!PasteUpMorph removeSelector: #toggleAlwaysShowThumbnail!ScriptEditorMorph removeSelector: #addDestroyButtonTo:!ScriptEditorMorph removeSelector: #install!Morph removeSelector: #copyCostumeStateFrom:!Morph removeSelector: #configureForKids!PasteUpMorph removeSelector: #toggleFenceEnabled!Morph removeSelector: #accumlatePlayersInto:andSelectorsInto:!ScriptEditorMorph removeSelector: #restoreScriptName:!PasteUpMorph removeSelector: #autoExpansionString!PasteUpMorph removeSelector: #noteNewLocation:forPlayer:!Morph removeSelector: #assuredCardPlayer!PasteUpMorph removeSelector: #trailMorph!ScriptEditorMorph removeSelector: #setFrequencyTo:!ScriptEditorMorph removeSelector: #prepareToUndoDropOf:!ScriptEditorMorph removeSelector: #bringUpToDate!ScriptEditorMorph removeSelector: #mouseEnterDragging:!ScriptEditorMorph removeSelector: #mouseLeave:!PasteUpMorph removeSelector: #paintBackground!Morph removeSelector: #showPlayerMenu!ScriptEditorMorph removeSelector: #updateStatus!ScriptEditorMorph removeSelector: #objectViewed!Morph removeSelector: #getPenDown!Morph removeSelector: #fire!Morph removeSelector: #topEditor!PasteUpMorph removeSelector: #liftAllPens!ScriptEditorMorph removeSelector: #handUserRandomTile!MorphExtension removeSelector: #convertProperty:toValue:!Morph removeSelector: #lowerPen!ScriptEditorMorph removeSelector: #willingToBeDiscarded!Morph removeSelector: #abstractAModel!ScriptEditorMorph removeSelector: #setMorph:scriptName:!Morph removeSelector: #getPenColor!ScriptEditorMorph removeSelector: #typeInFrequency!PasteUpMorph removeSelector: #viewingByIconString!ScriptEditorMorph removeSelector: #offerScriptorMenu!Morph removeSelector: #reassessBackgroundShape!ScriptEditorMorph removeSelector: #scriptName!ScriptEditorMorph removeSelector: #indexOfMorphAbove:!Morph removeSelector: #convertNovember2000DropShadow:using:!Morph removeSelector: #goToPreviousCardInStack!ScriptEditorMorph removeSelector: #replaceReferencesToSlot:inPlayer:with:!PasteUpMorph removeSelector: #playfieldOptionsMenu!PasteUpMorph removeSelector: #scriptSelectorToTriggerFor:!ScriptEditorMorph removeSelector: #makeIsolatedCodePane!Morph removeSelector: #affiliatedSelector!ComponentLikeModel removeSelector: #delete!ScriptEditorMorph removeSelector: #replaceRow1!PasteUpMorph removeSelector: #viewingByNameString!ScriptEditorMorph removeSelector: #resetHandWithTile!Morph removeSelector: #convertToCurrentVersion:refStream:!PasteUpMorph removeSelector: #arrowsForAllPens!ScriptEditorMorph removeSelector: #autoFitString!ScriptEditorMorph removeSelector: #updateHeader!Morph removeSelector: #insertAsStackBackground!Morph removeSelector: #liftPen!ComponentLikeModel removeSelector: #duplicate:from:!PasteUpMorph removeSelector: #viewBySize!PasteUpMorph removeSelector: #trailStyleForAllPens:!ScriptEditorMorph removeSelector: #ceaseHavingAParameter!ScriptEditorMorph removeSelector: #chooseTrigger!Morph removeSelector: #penColor:!ScriptEditorMorph removeSelector: #mouseLeaveDragging:!Smalltalk removeClassNamed: #ScriptEditorMorph!ScriptEditorMorph removeSelector: #addParameter!Morph removeSelector: #addStackItemsTo:!ScriptEditorMorph removeSelector: #mouseEnter:!ScriptEditorMorph removeSelector: #isTileEditor!Morph removeSelector: #filterViewerCategoryDictionary:!ScriptEditorMorph removeSelector: #reinsertSavedTiles:!ScriptEditorMorph removeSelector: #hasParameter!StandardScriptingSystem class removeSelector: #removePlayersIn:!ScriptEditorMorph removeSelector: #deleteThreadShowing!ScriptEditorMorph removeSelector: #setMorph:!Smalltalk removeClassNamed: #ComponentLikeModel!Morph removeSelector: #noteNegotiatedName:for:!ScriptEditorMorph removeSelector: #wantsDroppedMorph:event:!ScriptEditorMorph removeSelector: #playerScripted:!PasteUpMorph removeSelector: #elementCount!PasteUpMorph removeSelector: #recreateScripts!PasteUpMorph removeSelector: #toggleAutomaticPhraseExpansion!ScriptEditorMorph removeSelector: #stepTime!PasteUpMorph removeSelector: #automaticViewing:!ComponentLikeModel removeSelector: #choosePartName!PasteUpMorph removeSelector: #linesAndArrowsForAllPens!PasteUpMorph removeSelector: #addImageToPenTrailsFor:!ScriptEditorMorph removeSelector: #localeChanged!ScriptEditorMorph removeSelector: #createThreadShowing!StandardScriptingSystem class removeSelector: #applyNewEToyLook!Morph class removeSelector: #hasAdditionsToViewerCategories!PasteUpMorph removeSelector: #drawPenTrailFor:from:to:!PasteUpMorph removeSelector: #galleryOfPlayers!Morph removeSelector: #setAsDefaultValueForNewCard!ScriptEditorMorph removeSelector: #isTextuallyCoded!Morph removeSelector: #pinkXButton!ScriptEditorMorph removeSelector: #initialize!Morph removeSelector: #isPlayer:ofReferencingTile:!ScriptEditorMorph removeSelector: #typeForParameter!Morph removeSelector: #beep:!Morph removeSelector: #slotSpecifications!ComponentLikeModel removeSelector: #pinSpecs!