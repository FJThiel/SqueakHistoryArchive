"Change Set:		9271Tools-dtl.179Tools-dtl.179:Move FileList from Morphic-FileList to Tools-FileListMove FileList2  from Morphic-FileList to Tools-FileListMove FileLPluggableFileListst2  from Morphic-FileList to Tools-FileListMove StandardFileMenuResult  from Morphic-FileList to Tools-MenusRemove package category from Morphic-FileListTools-dtl.170:Move StandardFileMenu from Morphic-FileList to Tools-Menus. StandardFileMenu is not Morphic specific.Move SelectionMenu, CustomMenu, and EmphasizedMenu from ST80-Menus to Tools-Menus. These classes are not MVC specific.With these changes, PopUpMenu and all its subclasses are in package Tools-Menus. The MVC/Morphic dependencies are handled in PopUpMenu>>startUpLeftFlush and PopUpMenu>>startUpWithCaption:icon:at:allowKeyboard:Tools-nice.171:remove useless tempsavoid unnecessary non local returnTools-dtl.172:Remove explicit MVC and Morphic dependencies from SyntaxError. SyntaxError is a model in Debugger (not an exception class).Tools-dtl.173:Restore simulation guard in SyntaxError class>>open: (lost due to editing error in the previous change)Tools-nice.174:Workaround to avoid a bug in MessageNames finder update logic:In method #inheritanceButtonColor, currentCompiledMethod becomes undefined when selecting an un-implemented message.Apparently, inheritanceButtonColor seems to be called several times, the first one with a non nil instance which is changed to nil before method finishes...Tools-dtl.175:Remove #openAsMVC and #openAsMorph from ProcessBrowser and resolve related dependency in CPUWatcher. ProcessBrowser now uses ToolBuilder and no longer requires these methods.Tools-dtl.176:Remove MVC/Morphic dependencies from Browser>>couldBrowseAnyClass. The change removes two #isKindOf: and adds one #respondsTo: arguably yeilding a slight net reduction in total cruftiness.Tools-dtl.177:Fix SelectorBrowser>>classListIndex: to use #changed: #update: to notify MVC views that control should be terminated prior to opening a new browser. Original implemention polled dependents with #isKIndOf: and had explicit dependency on MVC PluggableListView.Tools-dtl.178:Change Workspace>>saveContentsInFile to use #changed: #update: rather than traverse dependents. Removes MVC/Morphic dependency."!FileList subclass: #PluggableFileList	instanceVariableNames: 'accepted fileFilterBlock canAcceptBlock validateBlock newFiles prompt resultBlock'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!FileList subclass: #FileList2	instanceVariableNames: 'showDirsInFileList currentDirectorySelected fileSelectionBlock dirSelectionBlock optionalButtonSpecs modalView directoryChangeBlock ok'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-FileList'!PopUpMenu subclass: #SelectionMenu	instanceVariableNames: 'selections'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!SelectionMenu subclass: #EmphasizedMenu	instanceVariableNames: 'emphases'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!Object subclass: #StandardFileMenuResult	instanceVariableNames: 'directory name'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!SelectionMenu subclass: #StandardFileMenu	instanceVariableNames: 'canTypeFileName pattern'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!StringHolder subclass: #FileList	instanceVariableNames: 'fileName directory volList volListIndex list listIndex pattern sortMode brevityState directoryCache'	classVariableNames: 'FileReaderRegistry RecentDirs'	poolDictionaries: ''	category: 'Tools-FileList'!SelectionMenu subclass: #CustomMenu	instanceVariableNames: 'labels dividers lastDivider title targets arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'Tools-Menus'!!StandardFileMenu methodsFor: 'menu building' stamp: 'zz 8/15/2005 16:28'!makeFileMenuFor: aDirectory"Initialize an instance of me to operate on aDirectory"	| theMenu |	pattern ifNil: [pattern := {'*'}].	Cursor wait showWhile: 		[self 			labels: 	(self menuLabelsString: aDirectory)			font: 	(MenuStyle fontAt: 1) 			lines: 	(self menuLinesArray: aDirectory).		theMenu := self selections: (self menuSelectionsArray: aDirectory)].	^theMenu! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 21:45'!buildWith: builder	"FileList open"	| windowSpec window |	windowSpec := 	self buildWindowWith: builder specs: {		(0@0 corner: 1@0.06) -> [self buildPatternInputWith: builder].		(0.25@0.06 corner: 1@0.15) -> [self buildButtonPaneWith: builder].		(0@0.06 corner: 0.25@1) -> [self buildDirectoryTreeWith: builder].		(0.25@0.15 corner: 1@0.5) -> [self buildFileListWith: builder].		(0.25@0.5 corner: 1@1) -> [self buildContentPaneWith: builder].	}.	window := builder build: windowSpec.	self changed: #selectedPath.	^window! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:31'!resultBlock: aBlock	^resultBlock := aBlock! !!FileList methodsFor: 'private' stamp: 'bf 9/2/2009 12:45'!selectEncoding	| encodingItems |	encodingItems := OrderedCollection new.	TextConverter allSubclasses do: [:each | | names |		names := each encodingNames.		names notEmpty ifTrue: [ | label |			label := '' writeStream.			names do: [:eachName | label nextPutAll: eachName ] separatedBy: [ label nextPutAll: ', '].			encodingItems add: {label contents. names first asSymbol}.		].	].	brevityState := UIManager default		chooseFrom: (encodingItems collect: [:spec| spec first])		values: (encodingItems collect: [:spec| spec last]).	brevityState ifNil: [brevityState := #needToGetBrief].! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:19'!directoryResultBlock	^[:theDirectory :theFileName | theDirectory]! !!FileList2 methodsFor: 'private' stamp: 'LC 1/6/2002 09:03'!setSelectedDirectoryTo: aFileDirectoryWrapper	currentDirectorySelected := aFileDirectoryWrapper.	self directory: aFileDirectoryWrapper withoutListWrapper.	brevityState := #FileList.	"self addPath: path."	self changed: #fileList.	self changed: #contents.	self changed: #currentDirectorySelected.! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/3/1998 19:01'!pattern: textOrStringOrNil	textOrStringOrNil		ifNil: [pattern := '*']		ifNotNil: [pattern := textOrStringOrNil asString].	self updateFileList.	^ true! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:56'!readContentsEUCKR	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: EUCKRTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList2 class methodsFor: 'blue ui' stamp: 'nice 12/27/2009 03:11'!enableTypeButtons: typeButtons info: fileTypeInfo forDir: aDirectory	| foundSuffixes firstEnabled |	firstEnabled := nil.	foundSuffixes := (aDirectory ifNil: [ #()] ifNotNil: [ aDirectory fileNames]) collect: [ :each | (each findTokens: '.') last asLowercase].	foundSuffixes := foundSuffixes asSet.	fileTypeInfo with: typeButtons do: [ :info :button | | enableIt fileSuffixes |		fileSuffixes := info second.		enableIt := fileSuffixes anySatisfy: [ :patt | foundSuffixes includes: patt].		button 			setProperty: #enabled 			toValue: enableIt.		enableIt ifTrue: [firstEnabled ifNil: [firstEnabled := button]].	].	firstEnabled ifNotNil: [^firstEnabled mouseUp: nil].	typeButtons do: [ :each | each color: Color gray].! !!FileList2 class methodsFor: 'morphic ui' stamp: 'dgd 4/3/2006 14:04'!update: actionRow in: window fileTypeRow: fileTypeRow morphUp: morph	| fileTypeInfo info2 buttons textColor1 fileSuffixes fileActions aFileList fileTypeString |	(morph notNil and:[(morph valueOfProperty: #enabled) not]) ifTrue: [^self].	fileTypeRow submorphsDo: [ :sub |		sub color: (			sub == morph 				ifTrue: [Color white] 				ifFalse: [(sub valueOfProperty: #enabled) 							ifTrue: [Color transparent] ifFalse: [Color gray]]		).	].	fileTypeString := morph isNil ifTrue:['xxxx'] ifFalse:[morph valueOfProperty: #buttonText].	aFileList := window valueOfProperty: #FileList.	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	actionRow removeAllMorphs.	fileTypeInfo := self endingSpecs.	info2 := fileTypeInfo detect: [ :each | each first = fileTypeString] ifNone: [ nil ].	info2 isNil		ifTrue:[			buttons := OrderedCollection new		]		ifFalse:[			fileSuffixes := info2 second.			fileActions := info2 third.			buttons := fileActions collect: [ :each | aFileList blueButtonForService: each textColor: textColor1 inWindow: window ].			buttons do: [ :each |				each fillWithRamp: ColorTheme current okColor oriented: (0.75 @ 0).			].		].	buttons addLast: (self								blueButtonText: 'Cancel'								textColor: textColor1								color: ColorTheme current cancelColor								inWindow: window								balloonText: 'Cancel this search' selector: #cancelHit recipient: aFileList).	buttons do: [ :each | actionRow addMorphBack: each].	window fullBounds.	fileSuffixes isNil ifFalse:[		aFileList fileSelectionBlock: (			self selectionBlockForSuffixes: (fileSuffixes collect: [ :each | '*.',each])		).	].	aFileList updateFileList.! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/10/2000 08:27'!alwaysValidateBlock	^[:theDirectory :theFileName :theNewFiles | true].! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'acg 4/15/1999 22:17'!oldFileStream	^self oldFileStreamFrom: (FileDirectory default)! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:39'!serviceSortByDate	"Answer a service for sorting by date"	^  (SimpleServiceEntry new			provider: self 			label: 'by date' 			selector: #sortByDate 			description: 'sort entries by date')		extraSelector: #sortingByDate;		buttonLabel: 'date'! !!FileList2 methodsFor: 'own services' stamp: 'yo 7/31/2004 18:08'!removeLinefeeds	"Remove any line feeds by converting to CRs instead.  This is a temporary implementation for 3.6 only... should be removed during 3.7alpha."	| fileContents |	fileContents := ((FileStream readOnlyFileNamed: self fullName) wantsLineEndConversion: true) contentsOfEntireFile.	(FileStream newFileNamed: self fullName) 		nextPutAll: fileContents;		close.! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 20:40'!getButtonRow	"Answer the dynamic button row to use for the currently selected item."	| builder svc |	builder := ToolBuilder default.	svc := self universalButtonServices.	self fileListIndex = 0 ifFalse:[svc := svc, self dynamicButtonServices].	^svc collect:[:service| service buildWith: builder in: self].! !!FileList methodsFor: 'volume list and pattern' stamp: 'sw 3/6/1999 11:39'!veryDeepFixupWith: deepCopier	super veryDeepFixupWith: deepCopier.	volListIndex := 1.	self directory: FileDirectory default.	self updateFileList! !!FileList methodsFor: 'file list menu' stamp: 'nk 11/16/2002 13:00'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 services |	firstItems := self itemsForFile: self fullName.	secondItems := self itemsForAnyFile.	thirdItems := self itemsForNoFile.	n1 := firstItems size.	n2 := n1 + secondItems size.	n3 := n2 + thirdItems size.	services := firstItems, secondItems, thirdItems, self serviceAllFileOptions.	services do: [ :svc | svc addDependent: self ].	^ aMenu 		addServices2: services 		for: self		extraLines: (Array with: n1 with: n2 with: n3)! !!CustomMenu methodsFor: 'compatibility' stamp: 'sw 2/16/2002 00:57'!targets	"Answer my targets, initializing them to an empty collection if found to be nil"	^ targets ifNil: [targets := OrderedCollection new]! !!FileList2 methodsFor: 'user interface' stamp: 'RAA 6/16/2000 10:53'!morphicFileContentsPane	^PluggableTextMorph 		on: self 		text: #contents 		accept: #put:		readSelection: #contentsSelection 		menu: #fileContentsMenu:shifted:! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:52'!canAcceptBlock: aBlock	^canAcceptBlock := aBlock! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:14'!selections: selList emphases: emphList	"Answer an instance of the receiver with the given selections and 	emphases."	^ (self selections: selList) emphases: emphList"Example:	(EmphasizedMenu		selections: #('how' 'well' 'does' 'this' 'work?') 		emphases: #(bold plain italic struckOut plain)) startUp"! !!FileList methodsFor: 'own services' stamp: 'sd 2/1/2002 20:50'!serviceGetHex	^  (SimpleServiceEntry 			provider: self 			label: 'view as hex' 			selector: #getHex			description: 'view as hex')			! !!PluggableFileList class methodsFor: 'canAcceptBlocks' stamp: 'acg 2/10/2000 08:10'!fileNameSelectedAcceptBlock	^[:theDirectory :theFileName | theFileName isNil not]! !!FileList2 class methodsFor: 'morphic ui' stamp: 'miki 8/14/2005 21:21'!morphicViewFileSelectorForSuffixes: aList	"Answer a morphic file-selector tool for the given suffix list."	^self 		morphicViewFileSelectorForSuffixes: aList 		directory: FileDirectory default.! !!FileList2 methodsFor: 'private' stamp: 'TN 4/13/2005 18:32'!okHitForProjectLoader	| areaOfProgress |	fileName ifNil: [^ self].	ok := true.	areaOfProgress := modalView firstSubmorph.	[		areaOfProgress setProperty: #deleteOnProgressCompletion toValue: modalView.		self openProjectFromFile.		modalView delete.	"probably won't get here"	]		on: ProgressTargetRequestNotification		do: [ :ex | ex resume: areaOfProgress].! !!FileList methodsFor: 'private' stamp: 'nk 12/10/2002 07:57'!updateFileList	"Update my files list with file names in the current directory  	that match the pattern.	The pattern string may have embedded newlines or semicolons; these separate different patterns."	| patterns |	patterns := OrderedCollection new.	Cursor wait showWhile: [	(pattern findTokens: (String with: Character cr with: Character lf with: $;))		do: [ :each |			(each includes: $*) | (each includes: $#)					ifTrue: [ patterns add: each]					ifFalse: [each isEmpty										ifTrue: [ patterns add: '*']										ifFalse: [ patterns add: '*' , each , '*']]].	list := self listForPatterns: patterns.	listIndex := 0.	volListIndex := volList size.	fileName := nil.	contents := ''.	self changed: #volumeListIndex.	self changed: #fileList.	self updateButtonRow]! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'fc 2/19/2004 22:08'!example3	"EmphasizedMenu example3"	^ (self		selectionAndEmphasisPairs: #('how' #bold 'well' #normal 'does' #italic 'this' #struckOut 'work' #normal))		startUpWithCaption: 'A Menu with Emphases'! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'zz 8/15/2005 18:21'!newFileMenu: aDirectory withPatternList: aPatternList	Smalltalk isMorphic ifFalse: [^ PluggableFileList newFileMenu: aDirectory].	^ super new newFileFrom: aDirectory withPatternList: aPatternList! !!EmphasizedMenu methodsFor: 'emphasis' stamp: 'fc 2/19/2004 22:07'!onlyBoldItem: itemNumber	"Set up emphasis such that all items are plain except for the given item number.  "	emphases := (Array new: selections size) atAllPut: #normal.	emphases at: itemNumber put: #bold! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!projectOnlySelectionMethod: incomingEntries	| versionsAccepted |	"this shows only the latest version of each project"	versionsAccepted := Dictionary new.	incomingEntries do: [ :entry | | basicInfoTuple basicVersion basicName |		entry isDirectory ifFalse: [			(#('*.pr' '*.pr.gz' '*.project') anySatisfy: [ :each | each match: entry name]) ifTrue: [				basicInfoTuple := Project parseProjectFileName: entry name.				basicName := basicInfoTuple first.				basicVersion := basicInfoTuple second.				((versionsAccepted includesKey: basicName) and: 						[(versionsAccepted at: basicName) first > basicVersion]) ifFalse: [					versionsAccepted at: basicName put: {basicVersion. entry}				].			]		]	].	^versionsAccepted asArray collect: [ :each | each second]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:02'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string  	with embedded CRs, or a collection of strings. Record the given array of 	selections corresponding to the items in labels."	| labelString |	(labels isString)		ifTrue: [labelString := labels]		ifFalse: [labelString := String streamContents:					[:s |					labels do: [:l | s nextPutAll: l; cr].					s skip: -1]].	^ (self labels: labelString lines: linesArray) selections: selectionsArray! !!StandardFileMenuResult methodsFor: 'private' stamp: 'acg 4/15/1999 08:42'!directory: aDirectory name: aString	directory := aDirectory.	name := aString.	^self! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/12/2000 14:52'!checkExistingFileValidateBlock	^[:theDirectory :theFileName :theNewFiles | 		(theNewFiles includes: theFileName) or:			[(PluggableFileList okToOverwrite: theFileName)]].! !!FileList methodsFor: 'private' stamp: 'ka 6/23/2002 15:55'!readContentsUTF8	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: UTF8TextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'updating' stamp: 'sw 11/30/2002 16:49'!update: aParameter	"Receive a change notice from an object of whom the receiver is a dependent"	(aParameter == #fileListChanged) ifTrue: [self updateFileList].	super update: aParameter! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/9/2000 01:16'!getFolder	^self getFolderDialog open! !!FileList methodsFor: 'initialization' stamp: 'tk 5/21/1998 12:28'!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName := aStream localName.	pattern := '*'.	listIndex := 1.  "pretend a file is selected"	aStream close.	brevityState := #needToGetBrief.	self changed: #contents.! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/9/2000 01:05'!leftButtonPressed	accepted := false.	self changed: #close.! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'dtl 2/2/2010 21:14'!open	^ Project current		dispatchTo: self		addPrefixAndSend: #OpenLabel:in:		withArguments: { prompt . self currentWorld }! !!FileList2 methodsFor: 'drag''n''drop' stamp: 'nk 6/15/2003 13:07'!dropDestinationDirectory: dest event: evt	"Answer a FileDirectory representing the drop destination in the directory hierarchy morph dest"	^ (dest itemFromPoint: evt position) withoutListWrapper! !!FileList methodsFor: 'file list menu' stamp: 'nk 12/7/2002 12:57'!suffixOfSelectedFile	"Answer the file extension of the receiver's selected file"	^ self class suffixOf: self fullName.! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 21:17'!buildPatternInputWith: builder	| textSpec |	textSpec := builder pluggableInputFieldSpec new.	textSpec 		model: self;		getText: #pathAndPattern; 		setText: #pathAndPattern:.	^textSpec! !!FileList methodsFor: 'own services' stamp: 'sw 2/15/2002 19:07'!serviceAddNewDirectory	"Answer a service entry characterizing the 'add new directory' command"	^ SimpleServiceEntry 		provider: self 		label: 'add new directory' 		selector: #addNewDirectory		description: 'adds a new, empty directory (folder)' ! !!StandardFileMenu methodsFor: 'menu building' stamp: 'zz 8/15/2005 18:18'!menuSelectionsArray: aDirectory"Answer a menu selections object corresponding to aDirectory.  The object is an array corresponding to each item, each element itself constituting a two-element array, the first element of which contains a selector to operate on and the second element of which contains the parameters for that selector."	|dirSize|	dirSize := aDirectory pathParts size.	^Array streamContents: [:s |		canTypeFileName ifTrue:			[s nextPut: (StandardFileMenuResult				directory: aDirectory				name: nil)].		s nextPut: (StandardFileMenuResult			directory: (FileDirectory root)			name: '').		aDirectory pathParts doWithIndex: 			[:d :i | s nextPut: (StandardFileMenuResult					directory: (self 						advance: dirSize - i						containingDirectoriesFrom: aDirectory)					name: '')].		aDirectory directoryNames do: 			[:dn |  s nextPut: (StandardFileMenuResult						directory: (FileDirectory on: (aDirectory fullNameFor: dn))						name: '')].		aDirectory fileNames do: 			[:fn | pattern do: [:pat | (pat match: fn) ifTrue: [					s nextPut: (StandardFileMenuResult						directory: aDirectory						name: fn)]]]]! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections	^ selections! !!FileList methodsFor: 'file menu action' stamp: 'rbb 3/1/2005 10:53'!renameFile	"Rename the currently selected file"	| newName response |	listIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(response := UIManager default request: 'NewFileName?' translated 					initialAnswer: fileName)		isEmpty ifTrue: [^ self].	newName := response asFileName.	newName = fileName ifTrue: [^ self].	directory rename: fileName toBe: newName.	self updateFileList.	listIndex := list findFirst: [:item | (self fileNameFromFormattedItem: item) = newName].	listIndex > 0 ifTrue: [fileName := newName].	self changed: #fileListIndex.! !!FileList methodsFor: 'file menu action' stamp: 'ka 8/3/2001 21:12'!compressFile	"Compress the currently selected file"	| f |	f := StandardFileStream				readOnlyFileNamed: (directory fullNameFor: self fullName).	f compressFile.	self updateFileList! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 11/16/2002 23:45'!invokeOn: targetObject orSendTo: anObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return  nil if no item is selected.  If the chosen selector has arguments, obtain appropriately.  If the recipient does not respond to the resulting message, send it to the alternate object provided"	| aSelector anIndex recipient |	^ (aSelector := self startUp) ifNotNil:		[anIndex := self selection.		recipient := ((targets := self targets) isEmptyOrNil or: [anIndex > targets size])			ifTrue:				[targetObject]			ifFalse:				[targets at: anIndex].		aSelector numArgs == 0			ifTrue:				[recipient perform: aSelector orSendTo: anObject]			ifFalse:				[recipient perform: aSelector withArguments: (self arguments at: anIndex)]]! !!FileList methodsFor: 'volume list and pattern' stamp: 'ar 10/4/2009 21:08'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex := index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim := directory pathNameDelimiter.				path := String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState := #FileList.	self addPath: path.	self changed: #fileList.	self changed: #contents.	self updateButtonRow.! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 11/8/1999 17:52'!fromArray: anArray	"Construct a menu from anArray.  The elements of anArray must be either:	*  A pair of the form: <label> <selector>or	*  The 'dash' (or 'minus sign') symbol	Refer to the example at the bottom of the method"	| labelList lines selections anIndex |	labelList := OrderedCollection new.	lines := OrderedCollection new.	selections := OrderedCollection new.	anIndex := 0.	anArray do:		[:anElement |			anElement size == 1				ifTrue:					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].					lines add: anIndex]				ifFalse:					[anElement size == 2 ifFalse: [self error: 'badly-formed menu constructor'].					anIndex := anIndex + 1.					labelList add: anElement first.					selections add: anElement second]].	^ self labelList: labelList lines: lines selections: selections"(SelectionMenu fromArray:	#(	('first label'		moja)		('second label'	mbili)		-		('third label' 	tatu)		-		('fourth label'	nne)		('fifth label'	tano))) startUp"! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:58'!sortingBySize	^ sortMode == #size! !!FileList methodsFor: 'file list menu' stamp: 'nk 12/7/2002 12:56'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| suffix |	suffix := self class suffixOf: fullName.	^ (self class itemsForFile: fullName) , (self myServicesForFile: fullName suffix: suffix)! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:29'!putFile	| result |	result := self getFilePathNameWithExistenceCheck.	^result ifNotNil: 		[FileDirectory deleteFilePath: result.		 FileStream newFileNamed: result]! !!FileList methodsFor: 'private' stamp: 'ar 10/4/2009 20:44'!entriesMatching: patternString	"Answer a list of directory entries which match the patternString.	The patternString may consist of multiple patterns separated by ';'.	Each pattern can include a '*' or '#' as wildcards - see String>>match:"	| entries patterns |	entries := directory entries reject:[:e| e isDirectory].	patterns := patternString findTokens: ';'.	(patterns anySatisfy: [:each | each = '*'])		ifTrue: [^ entries].	^ entries select: [:entry | patterns anySatisfy: [:each | each match: entry first]]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList lines: lines selections: selections	^ (self labelArray: labelList lines: lines) selections: selections! !!FileList2 methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!initialDirectoryList	| dirList |	dirList := (FileDirectory on: '') directoryNames collect: [ :each |		FileDirectoryWrapper with: (FileDirectory on: each) name: each model: self].	dirList isEmpty ifTrue:[		dirList := Array with: (FileDirectoryWrapper 			with: FileDirectory default 			name: FileDirectory default localName 			model: self)].	dirList := dirList,(		ServerDirectory serverNames collect: [ :n | | nameToShow dir | 			dir := ServerDirectory serverNamed: n.			nameToShow := n.			(dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl		]	).	^dirList! !!FileList2 class methodsFor: 'utility' stamp: 'miki 8/15/2005 18:34'!modalLoopOn: aMorph	[aMorph world notNil] whileTrue: [		aMorph outermostWorldMorph doOneCycle.	].! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/9/2000 00:34'!open	^self new open! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 09:10'!canAccept	^canAcceptBlock value: directory value: fileName! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!directory: aDirectory	^directory := aDirectory! !!FileList methodsFor: 'initialization' stamp: 'ar 10/4/2009 22:11'!initialize	super initialize.	directoryCache := WeakIdentityKeyDictionary new.! !!CustomMenu methodsFor: 'construction' stamp: 'sw 2/27/2001 07:52'!addList: listOfTuplesAndDashes	"Add a menu item to the receiver for each tuple in the given list of the form (<what to show> <selector>). Add a line for each dash (-) in the list.  The tuples may have an optional third element, providing balloon help for the item, but such an element is ignored in mvc."	listOfTuplesAndDashes do: [:aTuple |		aTuple == #-			ifTrue: [self addLine]			ifFalse: [self add: aTuple first action: aTuple second]]	"CustomMenu new addList: #(		('apples' buyApples)		('oranges' buyOranges)		-		('milk' buyMilk)); startUp"! !!FileList2 methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!limitedSuperSwikiDirectoryList	| dirList localDirName localDir |	dirList := OrderedCollection new.	ServerDirectory serverNames do: [ :n | | dir nameToShow | 		dir := ServerDirectory serverNamed: n.		dir isProjectSwiki ifTrue: [			nameToShow := n.			dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)				balloonText: dir realUrl)		].	].	ServerDirectory localProjectDirectories do: [ :each |		dirList add: (FileDirectoryWrapper with: each name: each localName model: self)	].	"Make sure the following are always shown, but not twice"	localDirName := SecurityManager default untrustedUserDirectory.	localDir := FileDirectory on: localDirName.	((ServerDirectory localProjectDirectories collect: [:each | each pathName]) includes: localDirName)			ifFalse: [dirList add: (FileDirectoryWrapper with: localDir name: localDir localName model: self)].	FileDirectory default pathName = localDirName			ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	(dirList anySatisfy: [:each | each withoutListWrapper acceptsUploads])		ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	^dirList! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:39'!serviceGet	"Answer a service for getting the entire file"	^  (SimpleServiceEntry 			provider: self 			label: 'get entire file' 			selector: #get			description: 'if the file has only been partially read in, because it is very large, read the entire file in at this time.')! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'ar 3/18/2001 00:55'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor cursorPoint]).! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 11/3/2004 19:56'!morphicViewProjectSaverFor: aProject"(FileList2 morphicViewProjectSaverFor: Project current) openInWorld"	| window aFileList buttons treePane pane2 textColor1 option treeExtent buttonData buttonRow |	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	aFileList := self new directory: ServerDirectory projectDefaultDirectory.	aFileList dirSelectionBlock: self hideSqueakletDirectoryBlock.	window := AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	aFileList modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: ColorTheme current dialogBorderWidth;		borderColor: ColorTheme current dialogBorderColor;		useRoundedCorners.	buttonData := Preferences enableLocalSave				ifTrue: [{							{'Save'. #okHit. 'Save in the place specified below, and in the Squeaklets folder on your local disk'. ColorTheme current okColor}.							{'Save on local disk only'. #saveLocalOnlyHit. 'saves in the Squeaklets folder'. ColorTheme current okColor}.							{'Cancel'. #cancelHit. 'return without saving'. ColorTheme current cancelColor}						}]				ifFalse: [{							{'Save'. #okHit. 'Save in the place specified below, and in the Squeaklets folder on your local disk'. ColorTheme current okColor}.							{'Cancel'. #cancelHit. 'return without saving'. ColorTheme current cancelColor}						}].	buttons := buttonData collect: [ :each |		(self blueButtonText: each first textColor: textColor1 color: each fourth inWindow: window)			setBalloonText: each third translated;			hResizing: #shrinkWrap;			on: #mouseUp send: each second to: aFileList	].	option := aProject world 		valueOfProperty: #SuperSwikiPublishOptions 		ifAbsent: [#initialDirectoryList].	aProject world removeProperty: #SuperSwikiPublishOptions.	treeExtent := World height < 500						ifTrue: [ 350@150 ]						ifFalse: [ 350@300 ].	(treePane := aFileList morphicDirectoryTreePaneFiltered: option) 		extent: treeExtent; 		retractable: false;		borderWidth: 0.	window		addARowCentered: {			window fancyText: 'Publish This Project' translated font: Preferences standardEToysTitleFont color: textColor1		}.	buttonRow := OrderedCollection new.	buttons do: [:button | buttonRow add: button] separatedBy: [buttonRow add: ((Morph new extent: 30@5) color: Color transparent)]."	addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second.			(Morph new extent: 30@5) color: Color transparent. 			buttons third		};"	window		addARowCentered: buttonRow;		addARowCentered: { (window inAColumn: {(ProjectViewMorph on: aProject) lock}) layoutInset: 4};		addARowCentered: {			window fancyText: 'Please select a folder' translated font: Preferences standardEToysFont color: textColor1		};		addARow: {			(				window inAColumn: {					(pane2 := window inARow: {window inAColumn: {treePane}}) 						useRoundedCorners;						layoutInset: 0;						borderWidth: ColorTheme current dialogPaneBorderWidth;						borderColor: ColorTheme current dialogPaneBorderColor				}			) layoutInset: 10		}.	window fullBounds.	window fillWithRamp: ColorTheme current dialogRampOrColor oriented: 0.65.	pane2 fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35)."	buttons do: [ :each |		each fillWithRamp: ColorTheme current dialogButtonsRampOrColor oriented: (0.75 @ 0).	]."	window setProperty: #morphicLayerNumber toValue: 11.	aFileList postOpen.	window adoptPaneColor: (Color r: 0.548 g: 0.677 b: 1.0).	^ window ! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/18/2000 21:21'!fileListIndex	self changed: #fileString.	^super fileListIndex! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 11/3/2004 20:04'!blueButtonText: aString textColor: textColor inWindow: window balloonText: balloonText selector: sel recipient: recip 	^ self		blueButtonText: aString		textColor: textColor		color: nil		inWindow: window		balloonText: balloonText		selector: sel		recipient: recip ! !!FileList2 methodsFor: 'private' stamp: 'LC 1/6/2002 06:50'!currentDirectorySelected	^ currentDirectorySelected! !!FileList2 methodsFor: 'own services' stamp: 'dtl 2/10/2010 15:34'!openImageInWindow	"Handle five file formats: GIF, JPG, PNG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image myStream |	myStream := (directory readOnlyFileNamed: fileName) binary.	[image := Form fromBinaryStream: myStream.	Project current openImage: image name: fileName saveResource: false]		ensure: [myStream close]! !!FileList2 methodsFor: 'own services' stamp: 'sd 5/11/2003 22:15'!importImage	"Import the given image file and store the resulting Form in the default Imports"	| fname image |	fname := fileName sansPeriodSuffix.	image := Form fromFileNamed: self fullName.	Imports default importImage: image named: fname.! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'rbb 2/18/2005 11:35'!okToOpen: aFileNameString without: aSuffixString	"Answer whether user confirms that it is ok to overwrite the file named in aString"	^ 1 = (UIManager default 				chooseFrom: #('overwrite that file' 'select another file')				title:  aFileNameString, ' already exists.').! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFileSelectorForSuffixes: aList	| window aFileList |	window := self morphicViewFileSelectorForSuffixes: aList.	aFileList := window valueOfProperty: #fileListModel.	window openCenteredInWorld.	self modalLoopOn: window.	^aFileList getSelectedFile! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 20:50'!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: (MenuStyle leftFlush)! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 07:33'!fileFilterBlock: aBlock	^fileFilterBlock := aBlock! !!FileList methodsFor: 'private' stamp: 'ar 8/6/2009 18:50'!recentDirs	"Put up a menu and let the user select from the list of recently visited directories."	| dirName |	RecentDirs isEmpty ifTrue: [^self].	dirName := UIManager default chooseFrom: RecentDirs values: RecentDirs.	dirName == nil ifTrue: [^self].	self directory: (FileDirectory on: dirName)! !!FileList2 methodsFor: 'initialize-release' stamp: 'ar 10/10/2000 15:57'!initialize	showDirsInFileList := false.	fileSelectionBlock := [ :entry :myPattern |		entry isDirectory ifTrue: [			showDirsInFileList		] ifFalse: [			myPattern = '*' or: [myPattern match: entry name]		]	] fixTemps.	dirSelectionBlock := [ :dirName | true].! !!FileList2 methodsFor: 'volume list and pattern' stamp: 'nk 2/20/2001 12:09'!listForPatterns: anArray	"Make the list be those file names which match the patterns."	| sizePad newList |	directory ifNil: [^#()].	(fileSelectionBlock isKindOf: MessageSend) ifTrue: [		fileSelectionBlock arguments: {directory entries}.		newList := fileSelectionBlock value.		fileSelectionBlock arguments: #().	] ifFalse: [		newList := Set new.		anArray do: [ :pat |			newList addAll: (directory entries select: [:entry | fileSelectionBlock value: entry value: pat]) ].	].	newList := newList asSortedCollection: self sortBlock.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	^ newList asArray! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:24'!put: aText	"Private - put the supplied text onto the file"	| ff type |	brevityState == #fullFile ifTrue:		[ff := directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents := aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[self inform: 'No fileName is selected' translated.		^ false  "failed"].	type := 'These'.	brevityState = #briefFile ifTrue: [type := 'Abbreviated'].	brevityState = #briefHex ifTrue: [type := 'Abbreviated'].	brevityState = #fullHex ifTrue: [type := 'Hexadecimal'].	brevityState = #FileList ifTrue: [type := 'Directory'].	self inform: ('{1} contents cannotmeaningfully be saved at present.' translated format:{type translated}).	^ false  "failed"! !!StandardFileMenu methodsFor: 'menu building' stamp: 'tpr 11/28/2003 15:12'!menuLinesArray: aDirectory"Answer a menu lines object corresponding to aDirectory"	| typeCount nameCnt dirDepth|	typeCount := canTypeFileName 		ifTrue: [1] 		ifFalse: [0].	nameCnt := aDirectory directoryNames size.	dirDepth := aDirectory pathParts size.	^Array streamContents: [:s |		canTypeFileName ifTrue: [s nextPut: 1].		s nextPut: dirDepth + typeCount + 1.		s nextPut: dirDepth + nameCnt + typeCount + 1]! !!FileList2 methodsFor: 'private' stamp: 'md 10/22/2003 15:27'!okHit	ok := true.	currentDirectorySelected		ifNil: [Beeper beep]		ifNotNil: [modalView delete]! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:39'!serviceSortByName	"Answer a service for soring by name"	^ (SimpleServiceEntry new		provider: self label: 'by name' selector: #sortByName 		description: 'sort entries by name')		extraSelector: #sortingByName;		buttonLabel: 'name'! !!PluggableFileList methodsFor: 'file list menu' stamp: 'sma 11/11/2000 18:14'!listForPattern: pat	"Make the list be those file names which match the pattern."	| entries sizePad newList allFiles |	entries := directory entries select: fileFilterBlock.	sizePad := (entries inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := (SortedCollection new: 30) sortBlock: self sortBlock.	allFiles := pat = '*'.	entries do:		[:entry | "<dirflag><name><creationTime><modificationTime><fileSize>"		(allFiles or: [entry isDirectory or: [pat match: entry first]]) ifTrue:			[newList add: entry]].	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	newFiles := OrderedCollection new.	^ newList asArray.! !!FileList methodsFor: 'volume menu' stamp: 'nk 6/12/2004 12:07'!volumeMenu: aMenu	aMenu addList: {			{'recent...' translated.		#recentDirs}.			#-.			{'add server...' translated.		#askServerInfo}.			{'remove server...' translated.		#removeServer}.			#-.			{'delete directory...' translated.	#deleteDirectory}.			#-}.	aMenu		addServices: (self itemsForDirectory: self directory)		for: self		extraLines: #().	^aMenu.! !!FileList methodsFor: 'own services' stamp: 'sw 2/17/2002 02:36'!serviceCompressFile	"Answer a service for compressing a file"	^ SimpleServiceEntry provider: self label: 'compress' selector: #compressFile description: 'compress file' buttonLabel: 'compress'! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 4/3/2006 14:00'!morphicViewGeneralLoaderInWorld: aWorld"FileList2 morphicViewGeneralLoaderInWorld: self currentWorld"	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b fileTypeInfo fileTypeButtons fileTypeRow actionRow |	fileTypeInfo := self endingSpecs.	window := AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	aFileList := self new directory: FileDirectory default.	aFileList 		fileSelectionBlock: self projectOnlySelectionBlock;		modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: ColorTheme current dialogBorderWidth;		borderColor: ColorTheme current dialogBorderColor;		useRoundedCorners.	fileTypeButtons := fileTypeInfo collect: [ :each |		(self blueButtonText: each first textColor: Color gray inWindow: window)			setProperty: #enabled toValue: true;			hResizing: #shrinkWrap;			useSquareCorners	].	buttons := {{'OK'. ColorTheme current okColor}. {'Cancel'. ColorTheme current cancelColor}} collect: [ :each |		self blueButtonText: each first textColor: textColor1 color: each second inWindow: window	].	treePane := aFileList morphicDirectoryTreePane 		extent: 250@300; 		retractable: false;		borderWidth: 0.	fileListPane := aFileList morphicFileListPane 		extent: 350@300; 		retractable: false;		borderWidth: 0.	window addARow: {window fancyText: 'Find...' translated font: Preferences standardEToysTitleFont color: textColor1}.	fileTypeRow := window addARowCentered: fileTypeButtons cellInset: 2.	actionRow := window addARowCentered: {		buttons first. 		(Morph new extent: 30@5) color: Color transparent. 		buttons second	} cellInset: 2.	window		addARow: {				(window inAColumn: {(pane2a := window inARow: {window inAColumn: {treePane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.				(window inAColumn: {(pane2b := window inARow: {window inAColumn: {fileListPane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.		}.	window fullBounds.	window fillWithRamp: ColorTheme current dialogRampOrColor oriented: 0.65.	pane2a fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35).	pane2b fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35)."	buttons do: [ :each |		each fillWithRamp: ColorTheme current dialogButtonsRampOrColor oriented: (0.75 @ 0).	]."	fileTypeButtons do: [ :each | 		each 			on: #mouseUp 			send: #value:value: 			to: [ :evt :morph | 				self update: actionRow in: window fileTypeRow: fileTypeRow morphUp: morph.			] fixTemps	].	buttons first on: #mouseUp send: #okHit to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	aFileList directoryChangeBlock: [ :newDir |		self update: actionRow in: window fileTypeRow: fileTypeRow morphUp: nil.		self enableTypeButtons: fileTypeButtons info: fileTypeInfo forDir: newDir.	] fixTemps.	aFileList directory: aFileList directory.	window adoptPaneColor: (Color r: 0.548 g: 0.677 b: 1.0).	window becomeModal.	^ window openInWorld: aWorld.! !!FileList2 methodsFor: 'volume list and pattern' stamp: 'nk 6/14/2004 09:45'!changeDirectoryTo: aFileDirectory	"Change directory as requested."	self directory: aFileDirectory.	self updateDirectory! !!FileList2 methodsFor: 'own services' stamp: 'nk 6/14/2004 09:43'!addNewDirectory	super addNewDirectory.	self updateDirectory.! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'sw 9/11/97 16:14'!example2	"EmphasizedMenu example2"	| aMenu |	aMenu := EmphasizedMenu selections: #('One' 'Two' 'Three' 'Four').	aMenu onlyBoldItem: 3.	^ aMenu startUpWithCaption: 'Only the Bold'! !!FileList methodsFor: 'file menu action' stamp: 'dgd 9/21/2003 17:37'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: ('Really delete {1}?' translated format:{fileName})) ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState := #FileList.	self get! !!FileList2 methodsFor: 'user interface' stamp: 'BG 2/28/2004 22:58'!morphicPatternPane   | pane |    pane := PluggableTextMorph 		on: self 		text: #pattern 		accept: #pattern:.    pane acceptOnCR: true.   ^pane		! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:28'!oldFile	^self oldFileFrom: (FileDirectory default)! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 20:51'!executeService: aService	aService performServiceFor: self.! !!FileList methodsFor: 'file list menu' stamp: 'SD 11/8/2001 20:34'!noFileSelectedMenu: aMenu	^ aMenu		addServices: self itemsForNoFile 		for: self		extraLines: #()		! !!FileList2 methodsFor: 'own services' stamp: 'sw 2/22/2002 02:36'!servicesForProjectLoader	"Answer the services to show in the button pane for the project loader"	^ {self serviceSortByName. self serviceSortByDate. self serviceSortBySize. self serviceOpenProjectFromFile}! !!FileList methodsFor: 'server list' stamp: 'ar 8/6/2009 18:50'!putUpdate: fullFileName	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names := ServerDirectory groupNames asSortedArray.	choice := UIManager default chooseFrom: names values: names.	choice == nil ifTrue: [^ self].	(ServerDirectory serverInGroupNamed: choice) putUpdate: 				(directory oldFileNamed: fullFileName).	self volumeListIndex: volListIndex.! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sw 12/23/96'!selectionAndEmphasisPairs: interleavedList	"An alternative form of call.  "	| selList  emphList |	selList := OrderedCollection new.	emphList := OrderedCollection new.	interleavedList pairsDo:		[:aSel :anEmph |			selList add: aSel.			emphList add: anEmph].	^ self selections:selList emphases: emphList! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sumim 2/10/2002 01:26'!initialize	labels := OrderedCollection new.	selections := OrderedCollection new.	dividers := OrderedCollection new.	lastDivider := 0.	targets := OrderedCollection new.	arguments := OrderedCollection new	! !!FileList2 methodsFor: 'as yet unclassified' stamp: 'BG 2/29/2004 23:40'!specsForImageViewer	 ^{self serviceSortByName. self serviceSortByDate. self serviceSortBySize }! !!FileList2 methodsFor: 'user interface' stamp: 'rww 12/13/2003 13:07'!morphicDirectoryTreePaneFiltered: aSymbol	^(SimpleHierarchicalListMorph 		on: self		list: aSymbol		selected: #currentDirectorySelected		changeSelected: #setSelectedDirectoryTo:		menu: #volumeMenu:		keystroke: nil)			autoDeselect: false;			enableDrag: false;			enableDrop: true;			yourself		! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 22:03'!newFileFrom: aDirectory	canTypeFileName := true.	^self makeFileMenuFor: aDirectory! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'mha 1/18/2010 10:13'!labelList: labelList lines: lines	^ self labelArray: labelList lines: lines! !!FileList methodsFor: 'private' stamp: 'SD 11/8/2001 21:11'!registeredFileReaderClasses	"return the list of classes that provide file reader services"	^ self class registeredFileReaderClasses! !!FileList methodsFor: 'initialization' stamp: 'sw 2/17/2002 00:07'!optionalButtonSpecs	"Answer a list of services underlying the optional buttons in their initial inception."	^ {self serviceSortByName. self serviceSortByDate. self serviceSortBySize}! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'gh 9/16/2002 10:33'!modalFolderSelector	^self modalFolderSelector: FileDirectory default! !!FileList class methodsFor: 'instance creation' stamp: 'ar 10/4/2009 20:55'!open	"Open a view of an instance of me on the default directory."	^ToolBuilder open: self! !!FileList methodsFor: 'file menu action' stamp: 'jm 5/3/1998 18:04'!getHex	"Get contents of file again, and display in Hex. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		brevityState := #needToGetBriefHex.		self changed: #contents].! !!StandardFileMenu methodsFor: 'private' stamp: 'zz 8/15/2005 16:31'!pattern: aPattern	" * for all files, or '*.cs' for changeSets, etc.  Just like fileLists"	pattern := {aPattern}! !!FileList methodsFor: 'directory tree' stamp: 'ar 10/4/2009 20:34'!subDirectoriesOf: aDirectory	^aDirectory directoryNames collect:[:each| aDirectory directoryNamed: each].! !!CustomMenu methodsFor: 'invocation' stamp: ''!startUp: initialSelection withCaption: caption	"Build and invoke this menu with the given initial selection and caption. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	self build.	(initialSelection notNil) ifTrue: [self preSelect: initialSelection].	^ super startUpWithCaption: caption! !!FileList methodsFor: 'own services' stamp: 'sw 2/17/2002 01:36'!serviceBroadcastUpdate	"Answer a service for broadcasting a file as an update"	^ SimpleServiceEntry		provider: self 		label: 'broadcast as update'		selector: #putUpdate:		description: 'broadcast file as update'		buttonLabel: 'broadcast'! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/3/1998 18:20'!volumeList	"Answer the current list of volumes."	^ volList! !!StandardFileMenuResult methodsFor: 'testing' stamp: 'acg 4/15/1999 09:05'!isCommand	^name isNil! !!FileList methodsFor: 'volume list and pattern' stamp: 'ls 7/25/1998 01:15'!fileNameFormattedFrom: entry sizePad: sizePad	"entry is a 5-element array of the form:		(name creationTime modificationTime dirFlag fileSize)"	| sizeStr nameStr dateStr |	nameStr := (entry at: 4)		ifTrue: [entry first , self folderString]		ifFalse: [entry first].	dateStr := ((Date fromSeconds: (entry at: 3) )					printFormat: #(3 2 1 $. 1 1 2)) , ' ' ,				(String streamContents: [:s |					(Time fromSeconds: (entry at: 3) \\ 86400)						print24: true on: s]).	sizeStr := (entry at: 5) asStringWithCommas.	sortMode = #name ifTrue:		[^ nameStr , '    (' , dateStr , ' ' , sizeStr , ')'].	sortMode = #date ifTrue:		[^ '(' , dateStr , ' ' , sizeStr , ') ' , nameStr].	sortMode = #size ifTrue:		[^ '(' , ((sizeStr size to: sizePad) collect: [:i | $ ]) , sizeStr , ' ' , dateStr , ') ' , nameStr].! !!FileList methodsFor: 'file list' stamp: ''!fileListIndex	"Answer the index of the currently selected file."	^ listIndex! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:31'!getFilePathName	^self getFilePathNameDialog open! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'yo 8/30/2002 17:00'!labels: labels lines: linesArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string 	with embedded CRs, or a collection of strings."	(labels isString)		ifTrue: [^ super labels: labels lines: linesArray]		ifFalse: [^ super labelArray: labels lines: linesArray]! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 22:42'!buildEditorWith: builder	^super buildWith: builder! !!Browser methodsFor: 'accessing' stamp: 'dtl 2/9/2010 23:52'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d | (d respondsTo: #getListSelector)				and: [d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'dgd 9/21/2003 13:17'!newFileFrom: aDirectory	^(self newFileMenu: aDirectory)		startUpWithCaption: 'Select a File:' translated! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 6/16/2000 13:00'!optionalButtonSpecs	^optionalButtonSpecs ifNil: [super optionalButtonSpecs]! !!FileList methodsFor: 'private' stamp: 'ar 10/4/2009 20:48'!defaultContents	contents := list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr]].	brevityState := #FileList.	^ contents! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 22:15'!serviceRenameFile	^ (SimpleServiceEntry provider: self label: 'rename' selector: #renameFile description: 'rename file')! !!CustomMenu methodsFor: 'invocation' stamp: ''!startUp	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: nil! !!FileList methodsFor: 'directory tree' stamp: 'ar 10/4/2009 20:34'!rootDirectoryList	| dirList dir servers |	dir := FileDirectory on: ''.	dirList := dir directoryNames collect:[:each| dir directoryNamed: each]..	dirList isEmpty ifTrue:[dirList := Array with: FileDirectory default].	servers := ServerDirectory serverNames collect: [ :n | ServerDirectory serverNamed: n].	"This is so FileListPlus will work on ancient Squeak versions."	servers := servers select:[:each| each respondsTo: #localName].	^dirList, servers! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sw 12/17/2001 17:26'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Overridden to return value returned by manageMarker.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)"	| index |	index := super startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.	(selections = nil or: [(index between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: index! !!FileList methodsFor: 'file list' stamp: 'ul 12/12/2009 14:11'!readOnlyStream	"Answer a read-only stream on the selected file. For the various stream-reading services."	^self directory ifNotNil: [ :dir | dir readOnlyFileNamed: self fileName ]! !!FileList2 methodsFor: 'initialization' stamp: 'ar 10/10/2000 16:00'!dirSelectionBlock: aBlock	dirSelectionBlock := aBlock! !!CodeHolder methodsFor: 'toolbuilder' stamp: 'nice 2/9/2010 15:16'!inheritanceButtonColor	"Check to see if the currently-viewed method has a super send or an override, and if so, change screen feedback, unless the #decorateBrowserButtons says not to."	| flags aColor cm |	cm := currentCompiledMethod.	((cm isKindOf: CompiledMethod) and: [Preferences decorateBrowserButtons])		ifFalse: [^Color transparent].	"This table duplicates the old logic, but adds two new colors for the cases where there is a superclass definition, but this method doesn't call it."	flags := 0.	self isThisAnOverride ifTrue: [ flags := flags bitOr: 4 ].	cm sendsToSuper ifTrue: [ flags := flags bitOr: 2 ].	self isThereAnOverride ifTrue: [ flags := flags bitOr: 1 ].	aColor := {		Color transparent.		Color tan lighter.		Color green muchLighter.		Color blue muchLighter.		Color red muchLighter.	"has super but doesn't call it"		(Color r: 0.94 g: 0.823 b: 0.673).	"has sub; has super but doesn't call it"		Color green muchLighter.		Color blue muchLighter.	} at: flags + 1.	^aColor! !!FileList class methodsFor: 'file reader registration' stamp: 'ar 9/29/2005 12:27'!registeredFileReaderClasses	FileReaderRegistry := nil. "wipe it out"	^FileServices registeredFileReaderClasses	! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/18/2000 21:21'!fileVolumeIndex	self changed: #fileString.	^super fileVolumeIndex! !!CustomMenu methodsFor: 'construction' stamp: 'sw 7/20/1999 18:47'!balloonTextForLastItem: aString	"Vacuous backstop provided for compatibility with MorphicMenu"! !!PluggableFileList methodsFor: 'file list menu' stamp: 'asm 8/25/2003 18:37'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 services |	firstItems := self itemsForFile: self fullName asLowercase.	secondItems := self itemsForAnyFile.	thirdItems := self itemsForNoFile.	n1 := firstItems size.	n2 := n1 + secondItems size.	n3 := n2 + thirdItems size.	services := firstItems, secondItems, thirdItems, 			(OrderedCollection with: (SimpleServiceEntry provider: self label: 'more...' selector: #offerAllFileOptions)).	^ aMenu 		addServices2: services 		for: self		extraLines: (Array with: n1 with: n2 with: n3)! !!FileList methodsFor: 'volume list and pattern' stamp: 'sma 11/11/2000 18:06'!listForPattern: pat	"Make the list be those file names which match the pattern."	| sizePad newList |	newList := (self entriesMatching: pat) asSortedCollection: self sortBlock.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray! !!FileList2 methodsFor: 'initialization' stamp: 'tpr 12/1/2003 17:14'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory := dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode := #date].	volList := Array with: '[]'.	directory ifNotNil: [		volList := volList, directory pathParts.  "Nesting suggestion from RvL"	].	volList := volList withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern.	directoryChangeBlock ifNotNil: [directoryChangeBlock value: directory].! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'acg 2/12/2000 14:52'!existingFileValidateBlock	^[:theDirectory :theFileName :theNewFiles | 		(theNewFiles includes: theFileName) or:			[(PluggableFileList okToOverwrite: theFileName)]].! !!FileList methodsFor: 'own services' stamp: 'yo 3/31/2003 11:24'!serviceGetEncodedText	^  (SimpleServiceEntry 			provider: self 			label: 'view as encoded text'			selector: #getEncodedText			description: 'view as encoded text')! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'rww 9/23/2001 09:56'!newFileMenu: aDirectory withPattern: aPattern	Smalltalk isMorphic ifFalse: [^ PluggableFileList newFileMenu: aDirectory].	^ super new newFileFrom: aDirectory withPattern: aPattern! !!FileList2 methodsFor: 'private' stamp: 'RAA 4/6/2001 12:45'!cancelHit	modalView delete.	directory := fileName := currentDirectorySelected := nil.! !!FileList2 class methodsFor: 'utility' stamp: 'nice 12/27/2009 03:11'!addFullPanesTo: window from: aCollection		aCollection do: [ :each | | frame |		frame := LayoutFrame 			fractions: each second 			offsets: each third.		window addMorph: each first fullFrame: frame.	]! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFilePathNameDialog	^(self new)		validateBlock: PluggableFileList alwaysValidateBlock;		yourself! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/13/2000 15:28'!validate	^validateBlock value: directory value: fileName value: newFiles! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:24'!getFile	| result |	result := self getFilePathName.	^result ifNotNil: [FileStream oldFileNamed: result]! !!FileList methodsFor: 'private' stamp: 'rhi 9/8/2001 02:17'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| from to |	self sortingByName		ifTrue: [			from := item lastIndexOf: $( ifAbsent: [0].			to := item lastIndexOf: $) ifAbsent: [0]]		ifFalse: [			from := item indexOf: $( ifAbsent: [0].			to := item indexOf: $) ifAbsent: [0]].	^ (from * to = 0		ifTrue: [item]		ifFalse: [item copyReplaceFrom: from to: to with: '']) withBlanksTrimmed! !!FileList2 class methodsFor: 'morphic ui' stamp: 'RAA 1/8/2001 21:39'!morphicViewNoFile	| dir aFileList window midLine fixedSize |	dir := FileDirectory default.	aFileList := self new directory: dir.	window := (SystemWindow labelled: dir pathName) model: aFileList.	fixedSize := 25.	midLine := 0.4.	self addFullPanesTo: window from: {		{aFileList morphicPatternPane. 0@0 corner: 0.3@0. 0@0 corner: 0@fixedSize}.		{aFileList optionalButtonRow. 0.3 @ 0 corner: 1@0. 0@0 corner: 0@fixedSize}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1. 0@fixedSize corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1. 0@fixedSize corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'fc 2/19/2004 22:06'!example1	"EmphasizedMenu example1"	^ (self		selections: #('how' 'well' 'does' 'this' 'work?' ) 		emphases: #(#bold #normal #italic #struckOut #normal ))			startUpWithCaption: 'A Menu with Emphases'! !!FileList methodsFor: 'private' stamp: 'stp 12/11/1999 20:05'!addPath: aString	"Add the given string to the list of recently visited directories."	| full |	aString ifNil: [^self].	full := String streamContents: 		[ :strm | 2 to: volList size do: 			[ :i | strm nextPutAll: (volList at: i) withBlanksTrimmed.			strm nextPut: FileDirectory pathNameDelimiter]].	full := full, aString."Remove and super-directories of aString from the collection."	RecentDirs removeAllSuchThat: [ :aDir | ((aDir, '*') match: full)]."If a sub-directory is in the list, do nothing."	(RecentDirs detect: [ :aDir | ((full, '*') match: aDir)] ifNone: [nil])		ifNotNil: [^self].	[RecentDirs size >= 10]		whileTrue: [RecentDirs removeFirst].	RecentDirs addLast: full! !!FileList methodsFor: 'file menu action' stamp: 'di 4/15/98 12:36'!sortBySize	self resort: #size! !!FileList class methodsFor: 'file reader registration' stamp: 'nk 12/7/2002 12:52'!suffixOf: aName	"Answer the file extension of the given file"	^ aName		ifNil:			['']		ifNotNil:			[(FileDirectory extensionFor: aName) asLowercase]! !!FileList methodsFor: 'file list menu' stamp: 'nk 6/12/2004 12:06'!itemsForNoFile	| services |	services := OrderedCollection new.	services add: self serviceSortByName.	services add: self serviceSortBySize.	services add: (self serviceSortByDate useLineAfter: true).	services addAll: (self itemsForDirectory: (self isFileSelected ifFalse: [ self directory ] ifTrue: [])).	^ services		! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!labels: labels selections: selectionsArray	"Answer an instance of me whose items are in labels, recording 	the given array of selections corresponding to the items in labels."	^ self		labels: labels		lines: #()		selections: selectionsArray! !!PluggableFileList class methodsFor: 'canAcceptBlocks' stamp: 'acg 2/10/2000 08:18'!alwaysAcceptBlock	^[:theDirectory :theFileName | true]! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 7/31/97 19:31'!startUpWithCaption: caption	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen; use the provided caption"	^ self startUp: nil withCaption: caption! !!FileList2 class methodsFor: 'morphic ui' stamp: 'gh 9/16/2002 10:30'!morphicViewFolderSelector	^self morphicViewFolderSelector: FileDirectory default! !!FileList2 methodsFor: 'initialization' stamp: 'sw 2/22/2002 02:34'!universalButtonServices	"Answer the services to be reflected in the receiver's buttons"	^ self optionalButtonSpecs! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 20:32'!buildDirectoryTreeWith: builder	| treeSpec |	treeSpec := builder pluggableTreeSpec new.	treeSpec 			model: self;			roots: #rootDirectoryList;			hasChildren: #hasMoreDirectories:;			getChildren: #subDirectoriesOf:;			getSelectedPath: #selectedPath; 			setSelected: #setDirectoryTo:;			label: #directoryNameOf:;			autoDeselect: false.	^treeSpec! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'ar 10/10/2000 15:59'!hideSqueakletDirectoryBlock	^[:dirName| (dirName sameAs: 'Squeaklets') not]! !!FileList2 methodsFor: 'own services' stamp: 'nk 6/8/2004 17:09'!serviceCancel	"Answer a service for hitting the cancel button"	^ (SimpleServiceEntry new		provider: self label: 'cancel' selector: #cancelHit 		description: 'hit here to cancel ')		buttonLabel: 'cancel'! !!FileList methodsFor: 'private' stamp: 'sma 11/11/2000 17:04'!sortBlock	"Answer block to decide what order to display the directory entries."	^ [ :x :y |			(x isDirectory = y isDirectory) 				ifTrue: [  					"sort by user-specified criterion"					sortMode = #name 						ifTrue: [(x name compare: y name) <= 2]						ifFalse: [ sortMode = #date							ifTrue: [ x modificationTime = y modificationTime									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x modificationTime > y modificationTime ] ]							ifFalse: [ "size"								x fileSize = y fileSize 									ifTrue: [ (x name compare: y name) <= 2 ]									ifFalse: [ x fileSize > y fileSize ] ] ] ]				ifFalse: [					"directories always precede files"					x isDirectory ] ]! !!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title := aTitle! !!StandardFileMenu methodsFor: 'menu building' stamp: 'acg 4/15/1999 21:03'!pathPartsString: aDirectory"Answer a string concatenating the path parts strings in aDirectory, each string followed by a cr."	^String streamContents:		[:s | 			s nextPutAll: '[]'; cr.			aDirectory pathParts asArray doWithIndex: 				[:part :i |					s next: i put: $ .					s nextPutAll: part withBlanksTrimmed; cr]]! !!FileList class methodsFor: 'instance creation' stamp: 'ar 10/4/2009 22:10'!new	^self newOn: FileDirectory default! !!CustomMenu methodsFor: 'compatibility' stamp: 'sumim 2/10/2002 01:23'!add: aString target: target selector: aSymbol argument: arg	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given argument."	self add: aString		target: target		selector: aSymbol		argumentList: (Array with: arg)! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 21:17'!serviceDeleteFile	^ (SimpleServiceEntry provider: self label: 'delete' selector: #deleteFile)			description: 'delete the seleted item'! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections: selectionArray	selections := selectionArray! !!CustomMenu methodsFor: 'private' stamp: 'di 4/14/1999 21:28'!preSelect: action	"Pre-select and highlight the menu item associated with the given action."	| i |	i := selections indexOf: action ifAbsent: [^ self].	marker ifNil: [self computeForm].	marker := marker		align: marker topLeft		with: (marker left)@(frame inside top + (marker height * (i - 1))).	selection := i.! !!FileList methodsFor: 'private' stamp: 'sw 11/30/2002 16:34'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name := self fileNameFromFormattedItem: (list at: listIndex)].	sortMode := newMode.	self pattern: pattern.	name ifNotNil: [		fileName := name.		listIndex := list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents].	self updateButtonRow! !!ProcessBrowser methodsFor: 'updating' stamp: 'nice 2/8/2010 09:04'!setUpdateCallbackAfter: seconds 	[(Delay forSeconds: seconds) wait.	Project current addDeferredUIMessage: [self updateProcessList]] fork! !!FileList2 class methodsFor: 'utility' stamp: 'RAA 3/6/2001 12:39'!textRow: aString 	^AlignmentMorph newRow 		wrapCentering: #center; cellPositioning: #leftCenter;		color: Color transparent;		layoutInset: 0;		addMorph: (			AlignmentMorph newColumn			wrapCentering: #center; cellPositioning: #topCenter;			color: Color transparent;			vResizing: #shrinkWrap;			layoutInset: 0;			addMorph: (				AlignmentMorph newRow				wrapCentering: #center; cellPositioning: #leftCenter;				color: Color transparent;				hResizing: #shrinkWrap;				vResizing: #shrinkWrap;				layoutInset: 0;				addMorph: ((StringMorph contents: aString) color: Color blue; lock)			)		)! !!FileList class methodsFor: 'class initialization' stamp: 'asm 4/08/2003 12:15'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!FileList methodsFor: 'initialization' stamp: 'sbw 12/30/1999 15:53'!optionalButtonHeight	^ 15! !!FileList methodsFor: 'directory tree' stamp: 'nice 12/27/2009 03:10'!selectedPath	| top here |	top := FileDirectory root.	here := directory.	^(Array streamContents:[:s| | next |		s nextPut: here.		[next := here containingDirectory.		top pathName = next pathName] whileFalse:[			s nextPut: next.			here := next.		]]) reversed.! !!CustomMenu methodsFor: 'compatibility' stamp: 'nk 2/15/2004 16:19'!addService: aService for: serviceUser	"Append a menu item with the given service. If the item is selected, it will perform the given service."	aService addServiceFor: serviceUser toMenu: self.! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/12/2000 21:44'!defaultBackgroundColor	^Color lightYellow! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:14'!newFileMenu: aDirectory	Smalltalk isMorphic ifFalse: [^ PluggableFileList newFileMenu: aDirectory].	^ super new newFileFrom: aDirectory! !!FileList methodsFor: 'server list' stamp: 'ar 8/6/2009 18:51'!removeServer	| choice names |	self flag: #ViolateNonReferenceToOtherClasses.	names := ServerDirectory serverNames asSortedArray.	choice := UIManager default chooseFrom: names values: names.	choice == nil ifTrue: [^ self].	ServerDirectory removeServerNamed: choice! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!name: aString	^name := aString! !!StandardFileMenu methodsFor: 'private' stamp: 'zz 8/15/2005 17:29'!patternList: aPatternList	pattern := aPatternList! !!FileList methodsFor: 'volume list and pattern' stamp: 'ar 10/4/2009 21:07'!pathAndPattern	"Answers both path and pattern"	^directory fullName, directory slash, pattern! !!FileList methodsFor: 'own services' stamp: 'edc 4/24/2007 09:49'!viewContentsInWorkspace	"View the contents of my selected file in a new workspace"		| aString aFileStream aName |	aString := (aFileStream := directory readOnlyFileNamed: self fullName) setConverterForCode contentsOfEntireFile.	aName := aFileStream localName.	aFileStream close.	UIManager default edit: aString withSqueakLineEndings label: 'Workspace from ', aName! !!FileList2 class methodsFor: 'morphic ui' stamp: 'RAA 3/6/2001 12:47'!morphicViewFileSelector	^self morphicViewFileSelectorForSuffixes: nil! !!PluggableFileList methodsFor: 'initialize-release' stamp: 'acg 2/12/2000 14:52'!initialize	prompt := 'Select File'.	directory := FileDirectory default.	newFiles := OrderedCollection new.	fileFilterBlock := PluggableFileList allFilesAndFoldersFileFilter.	canAcceptBlock := PluggableFileList fileNameSelectedAcceptBlock.	resultBlock := PluggableFileList pathNameResultBlock.	validateBlock := PluggableFileList checkExistingFileValidateBlock.! !!FileList2 methodsFor: 'private' stamp: 'sw 9/12/2002 00:43'!getSelectedFile	"Answer a filestream on the selected file.  If it cannot be opened for read/write, try read-only before giving up; answer nil if unsuccessful"	ok == true ifFalse: [^ nil].	directory ifNil: [^ nil].	fileName ifNil: [^ nil].	^ (directory oldFileNamed: fileName) ifNil:		[directory readOnlyFileNamed: fileName]! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 7/21/2000 11:40'!projectOnlySelectionBlock	^[ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			#('*.pr' '*.pr.gz' '*.project') anySatisfy: [ :each | each match: entry name]		]	] fixTemps! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:07'!pathNameResultBlock	^[:theDirectory :theFileName | 		theFileName 			ifNil: [theDirectory pathName]			ifNotNil: [theDirectory fullNameFor: theFileName]].! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'RAA 5/25/2000 09:30'!oldFileMenu: aDirectory withPattern: aPattern	Smalltalk isMorphic ifFalse: [^PluggableFileList oldFileMenu: aDirectory].	^super new oldFileFrom: aDirectory withPattern: aPattern! !!FileList2 methodsFor: 'own services' stamp: 'nk 6/8/2004 17:09'!serviceOkay	"Answer a service for hitting the okay button"	^ (SimpleServiceEntry new		provider: self label: 'okay' selector: #okHit 		description: 'hit here to accept the current selection')		buttonLabel: 'ok'! !!PluggableFileList class methodsFor: 'StandardFileMenu' stamp: 'BG 12/13/2002 15:31'!newFileMenu: aDirectory	"For compatibility with StandardFileMenu for now, answer a StandardFileMenuResult"	^(self getFilePathNameDialogWithExistenceCheck)		resultBlock: self sfmResultBlock;		directory: aDirectory;		yourself! !!FileList methodsFor: 'directory tree' stamp: 'ar 10/4/2009 21:34'!getSelectedPath	self halt.! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:31'!readContentsEUCJP	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: EUCJPTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 22:16'!serviceCopyName	^ (SimpleServiceEntry provider: self label: 'copy name to clipboard' selector: #copyName description:'copy name to clipboard' )! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 00:32'!advance: anInteger containingDirectoriesFrom: aDirectory	| theDirectory |	theDirectory := aDirectory.	1 to: anInteger do: [:i | theDirectory := theDirectory containingDirectory].	^theDirectory! !!FileList class methodsFor: 'instance creation' stamp: 'ar 10/4/2009 22:10'!newOn: aDirectory	^super new directory: aDirectory! !!CustomMenu methodsFor: 'compatibility' stamp: 'sw 2/16/2002 00:57'!arguments	"Answer my arguments, initializing them to an empty collection if they're found to be nil."	^ arguments ifNil: [arguments := OrderedCollection new]! !!FileList class methodsFor: 'window color' stamp: 'sw 2/26/2002 14:04'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name  wording: 'File List' brightColor: #lightMagenta pastelColor: #paleMagenta helpMessage: 'A tool for looking at files'! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'rbb 3/1/2005 11:14'!getTypedFileName: aResult	| name |	name := UIManager default 		request: 'Enter a new file name' 		initialAnswer: ''.	name = '' ifTrue: [^self startUpWithCaption: 'Select a File:' translated].	name := aResult directory fullNameFor: name.	^ StandardFileMenuResult			directory: (FileDirectory forFileName: name)			name: (FileDirectory localNameFor: name)! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'acg 9/28/1999 23:34'!startUpWithCaption: aString at: location	|result|	result := super startUpWithCaption: aString at: location.	result ifNil: [^nil].	result isDirectory ifTrue:		[self makeFileMenuFor: result directory.		 self computeForm.		 ^self startUpWithCaption: aString at: location].	result isCommand ifTrue: 		[result := self getTypedFileName: result.		result ifNil: [^nil]].	canTypeFileName ifTrue: [^self confirmExistingFiles: result].	^result	! !!FileList methodsFor: 'own services' stamp: 'nice 12/27/2009 03:10'!servicesFromSelectorSpecs: symbolArray	"Answer an array of services represented by the incoming symbols, eliminating any that do not have a currently-registered service.  Pass the symbol #- along unchanged to serve as a separator between services"	"FileList new servicesFromSelectorSpecs: #(fileIn: fileIntoNewChangeSet: browseChangesFile:)"	| services col | 	col := OrderedCollection new.	services := self class allRegisteredServices, (self myServicesForFile: #dummy suffix: '*').	symbolArray do: 		[:sel | | res | 			sel == #-				ifTrue:					[col add: sel]				ifFalse:					[res := services							detect: [:each | each selector = sel] ifNone: [nil].					res notNil							ifTrue: [col add: res]]].	^ col! !!FileList methodsFor: 'file list menu' stamp: 'dgd 10/1/2004 13:55'!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| shiftMenu services maybeLine extraLines |	shifted ifTrue:		[shiftMenu := ParagraphEditor shiftedYellowButtonMenu.		^ aMenu addAllFrom: shiftMenu].	fileName ifNotNil:		[services := OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine := services size.		(FileStream sourceFileSuffixes includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines := OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!FileList2 class methodsFor: 'instance creation' stamp: 'nk 6/14/2004 08:41'!prototypicalToolWindow	"Answer an example of myself seen in a tool window, for the benefit of parts-launching tools"	^ self morphicView applyModelExtent! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:58'!sortingByDate	^ sortMode == #date! !!StandardFileMenu methodsFor: 'menu building' stamp: 'zz 8/15/2005 17:33'!fileNamesString: aDirectory"Answer a string concatenating the file name strings in aDirectory, each string followed by a cr."	^String streamContents:		[:s | 			aDirectory fileNames do: 				[:fn |					pattern do:[:each | (each match: fn) ifTrue: [						s nextPutAll: fn withBlanksTrimmed; cr]]]]		! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 22:44'!buildCodePaneWith: builder	| textSpec |	textSpec := builder pluggableTextSpec new.	textSpec 		model: self;		getText: #contents; 		setText: #put:; 		selection: #contentsSelection; 		menu: #fileContentsMenu:shifted:.	^textSpec! !!FileList class methodsFor: 'class initialization' stamp: 'ar 9/27/2005 21:48'!removeObsolete	"FileList removeObsolete"	self registeredFileReaderClasses copy 		do:[:cls| cls isObsolete ifTrue:[self unregisterFileReader: cls]]! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'acg 4/15/1999 22:18'!newFileStream	^self newFileStreamFrom: (FileDirectory default)! !!FileList methodsFor: 'volume list and pattern' stamp: 'tk 4/7/98 15:26'!pattern	^ pattern ifNil: ['*']! !!CustomMenu methodsFor: 'compatibility' stamp: 'nk 2/15/2004 16:02'!addServices2: services for: served extraLines: linesArray	services withIndexDo: [:service :i |		service addServiceFor: served toMenu: self.		(linesArray includes: i)  ifTrue: [self addLine] ]! !!FileList methodsFor: 'file list' stamp: 'sd 2/14/2002 16:58'!fileName	^ fileName! !!PluggableFileList methodsFor: 'StandardFileMenu' stamp: 'acg 2/12/2000 15:35'!startUpWithCaption: aString at: location	self prompt: aString.	^self open! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/14/2000 22:43'!rightButtonState	^self canAccept! !!FileList methodsFor: 'server list' stamp: 'dtl 1/3/2010 23:41'!askServerInfo	"Get the user to create a ServerDirectory for a new server.  Fill in and say Accept."	| template |	template := '"Please fill in the following info, then select all text and choose DoIt."	| aa | 	self flag: #ViolateNonReferenceToOtherClasses.	aa := ServerDirectory new.	aa server: ''st.cs.uiuc.edu''.    "host"	aa user: ''anonymous''.	aa password: ''yourEmail@school.edu''.	aa directory: ''/Smalltalk/Squeak/Goodies''.	aa url: ''''.    "<- this is optional.  Only used when *writing* update files."	ServerDirectory addServer: aa named: ''UIUCArchive''.  "<- known by this name in Squeak"'.	(StringHolder new contents: template) openLabel: 'FTP Server Form'	! !!StandardFileMenu methodsFor: 'private' stamp: 'acg 4/15/1999 22:03'!oldFileFrom: aDirectory	canTypeFileName := false.	^self makeFileMenuFor: aDirectory! !!FileList methodsFor: 'file list menu' stamp: 'nk 6/12/2004 12:05'!itemsForDirectory: dir 	| services |	services := OrderedCollection new.	dir ifNotNil: [		services			addAll: (self class itemsForDirectory: dir).		services last useLineAfter: true. ].	services add: self serviceAddNewFile.	services add: self serviceAddNewDirectory.	^ services! !!PluggableFileList methodsFor: 'file list menu' stamp: 'rbb 3/1/2005 11:07'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response := UIManager default request: 'New ',aString,' Name?' 					initialAnswer: aString,'Name')		isEmpty ifTrue: [^ self].	newName := response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index := list indexOf: newName.	index = 0 ifTrue: [ending := ') ',newName.		index := list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.	newFiles add: newName! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 8/18/1998 12:01'!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: title! !!SyntaxError class methodsFor: 'instance creation' stamp: 'dtl 2/9/2010 08:11'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."		<primitive: 19> "Simulation guard"	^ Project current		dispatchTo: self		addPrefixAndSend: #Open:		withArguments: {aSyntaxError}! !!StandardFileMenuResult class methodsFor: 'instance creation' stamp: 'acg 4/15/1999 08:42'!directory: aDirectory name: aString	^super new directory: aDirectory name: aString! !!CustomMenu methodsFor: 'construction' stamp: ''!addLine	"Append a line to the menu after the last entry. Suppress duplicate lines."	(lastDivider ~= selections size) ifTrue: [		lastDivider := selections size.		dividers addLast: lastDivider].! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 2/19/2001 10:14'!morphicViewProjectLoader2InWorld: aWorld reallyLoad: aBoolean	^self 		morphicViewProjectLoader2InWorld: aWorld 		reallyLoad: aBoolean		dirFilterType: #initialDirectoryList! !!FileList methodsFor: 'private' stamp: 'ka 8/24/2000 18:55'!readContentsCNGB	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: CNGBTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:09'!readServerBrief	| lString sizeStr fsize ff first5000 parts |	"If file on server is known to be long, just read the beginning.  Cheat badly by reading the fileList string."	listIndex = 0 ifTrue: [^ self].	"Get size from file list entry"	lString := list at: listIndex.	parts := lString findTokens: '()'.	sortMode = #name ifTrue: [sizeStr := (parts second findTokens: ' ') third].	sortMode = #date ifTrue: [sizeStr := (parts first findTokens: ' ') third].	sortMode = #size ifTrue: [sizeStr := (parts first findTokens: ' ') first].	fsize := (sizeStr copyWithout: $,) asNumber.	fsize <= 50000 ifTrue:		[ff := directory oldFileOrNoneNamed: self fullName.		ff ifNil: [^ 'For some reason, this file cannot be read' translated].		contents := ff contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 := directory getOnly: 3500 from: fileName.	contents := 'File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 3500 characters...------------------------------------------{3}------------------------------------------... end of the first 3500 characters.' translated format: {fileName. sizeStr. first5000}.	brevityState := #briefFile.   "don't change till actually read"	^ contents.! !!Workspace methodsFor: 'as yet unclassified' stamp: 'dtl 2/10/2010 17:00'!saveContentsInFile	"Pass along this message to the controller or morph.  (Possibly this Workspace menu item could be deleted, since it's now in the text menu.)"	self changed: #saveContents! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList selections: selections	^ self		labelList: labelList		lines: #()		selections: selections! !!FileList2 class methodsFor: 'instance creation' stamp: 'nk 7/12/2000 11:03'!openMorphicViewInWorld	"FileList2 openMorphicViewInWorld"	^self morphicView openInWorld! !!FileList methodsFor: 'file list menu' stamp: 'RAA 2/2/2002 08:18'!dirAndFileName	^{directory. fileName}! !!FileList methodsFor: 'volume list and pattern' stamp: 'SD 11/11/2001 13:59'!directory	^ directory! !!FileList2 methodsFor: 'initialization' stamp: 'nk 6/14/2004 09:39'!updateDirectory	"directory has been changed externally, by calling directory:.	Now change the view to reflect the change."	self changed: #currentDirectorySelected.	self postOpen.! !!FileList methodsFor: 'volume list and pattern' stamp: 'tpr 11/28/2003 11:44'!deleteDirectory	"Remove the currently selected directory"	| localDirName |	directory entries size = 0 ifFalse:[^self inform:'Directory must be empty'].	localDirName := directory localName.	(self confirm: 'Really delete ' , localDirName , '?') ifFalse: [^ self].	self volumeListIndex: self volumeListIndex-1.	directory deleteDirectory: localDirName.	self updateFileList.! !!FileList methodsFor: 'file list' stamp: 'sw 2/17/2002 02:32'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents.	self updateButtonRow! !!FileList methodsFor: 'own services' stamp: 'sw 2/16/2002 01:40'!serviceSortBySize	"Answer a service for sorting by size"	^  (SimpleServiceEntry 			provider: self 			label: 'by size' 			selector: #sortBySize			description: 'sort entries by size')				extraSelector: #sortingBySize;				buttonLabel: 'size'! !!FileList methodsFor: 'private' stamp: 'yo 3/14/2005 13:55'!readContentsAsEncoding: encodingName	| f writeStream converter c |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	converter := TextConverter defaultConverterClassForEncoding: encodingName.	converter ifNil: [^ 'This encoding is not supported'].	f converter: converter new.	f wantsLineEndConversion: true.	[f atEnd or: [(c := f next) isNil]]		whileFalse: [writeStream nextPut: c].	f close.	^ writeStream contents! !!FileList methodsFor: 'private' stamp: 'nk 2/20/2001 12:36'!listForPatterns: anArray	"Make the list be those file names which match the pattern."	| sizePad newList |	newList := Set new.	anArray do: [ :pat | newList addAll: (self entriesMatching: pat) ].	newList := (SortedCollection sortBlock: self sortBlock) addAll: newList; yourself.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	volList size = 1 ifTrue:		["Include known servers along with other desktop volumes" 		^ newList asArray ,		(ServerDirectory serverNames collect: [:n | '^' , n , self folderString])].	^ newList asArray! !!FileList methodsFor: 'own services' stamp: 'sw 11/8/2003 13:34'!serviceViewContentsInWorkspace	"Answer a service for viewing the contents of a file in a workspace"		^ (SimpleServiceEntry provider: self label: 'workspace with contents' selector: #viewContentsInWorkspace)			description: 'open a new Workspace whose contents are set to the contents of this file'! !!FileList2 methodsFor: 'own services' stamp: 'sw 2/22/2002 02:35'!okayAndCancelServices	"Answer ok and cancel services"	^ {self serviceOkay. self serviceCancel}! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'zz 8/15/2005 17:41'!oldFileMenu: aDirectory withPatternList: aPatternList	Smalltalk isMorphic ifFalse: [^PluggableFileList oldFileMenu: aDirectory].	^super new oldFileFrom: aDirectory withPatternList: aPatternList! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'dgd 9/21/2003 13:17'!oldFileFrom: aDirectory	^(self oldFileMenu: aDirectory)		startUpWithCaption: 'Select a File:' translated! !!FileList class methodsFor: 'file reader registration' stamp: 'nk 6/12/2004 11:42'!itemsForDirectory: aFileDirectory	"Answer a list of services appropriate when no file is selected."	| services |	services := OrderedCollection new.	self registeredFileReaderClasses do: [:reader |		reader ifNotNil: [services addAll: (reader fileReaderServicesForDirectory: aFileDirectory) ]].	^ services! !!FileList methodsFor: 'file menu action' stamp: 'sge 11/28/1999 09:04'!addNewDirectory	self 		addNew: 'Directory'		byEvaluating: [:newName | directory createDirectory: newName]! !!FileList2 methodsFor: 'own services' stamp: 'hg 8/3/2000 16:55'!openProjectFromFile	"Reconstitute a Morph from the selected file, presumed to be represent	a Morph saved via the SmartRefStream mechanism, and open it in an	appropriate Morphic world."	Project canWeLoadAProjectNow ifFalse: [^ self].	ProjectViewMorph 		openFromDirectory: directory 		andFileName: fileName! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFileSelectorForSuffixes: aList directory: aDirectory	| window aFileList |	window := self morphicViewFileSelectorForSuffixes: aList directory: aDirectory.	aFileList := window valueOfProperty: #fileListModel.	window openCenteredInWorld.	self modalLoopOn: window.	^aFileList getSelectedFile! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/14/2000 22:40'!leftButtonState	^true! !!FileList2 methodsFor: 'private' stamp: 'RAA 6/21/2000 12:06'!modalView: aSystemWindowOrSuch	modalView := aSystemWindowOrSuch! !!FileList class methodsFor: 'file reader registration' stamp: 'sd 2/1/2002 21:30'!allRegisteredServices	"self allRegisteredServices"	| col |	col := OrderedCollection new.	self registeredFileReaderClasses do: [:each | col addAll: (each services)].	^ col! !!PluggableFileList class methodsFor: 'validateBlocks' stamp: 'rbb 2/18/2005 11:36'!okToOverwrite: aString	"Answer whether user confirms that it is ok to overwrite the file named in aString"	^ 1 = (UIManager default chooseFrom: #('overwrite that file' 'select another file')			title:  aString, ' already exists.')! !!FileList2 methodsFor: 'private' stamp: 'LC 1/6/2002 07:12'!saveLocalOnlyHit	ok := true.	modalView delete.	directory := fileName := nil.	currentDirectorySelected := #localOnly.! !!StandardFileMenuResult methodsFor: 'testing' stamp: 'acg 4/15/1999 20:57'!isDirectory	^name = ''! !!FileList methodsFor: 'file list menu' stamp: 'sw 11/8/2003 13:32'!itemsForAnyFile	"Answer a list of universal services that could apply to any file"		| services |	services := OrderedCollection new: 4.	services add: self serviceCopyName. 	services add: self serviceRenameFile. 	services add: self serviceDeleteFile.	services add: self serviceViewContentsInWorkspace.	^ services! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'dtl 2/10/2010 13:01'!classListIndex: anInteger	classListIndex := anInteger.	classListIndex > 0 ifTrue:		[self changed: #startNewBrowser. "MVC view will terminate control to prepare for new browser"		Browser fullOnClass: self selectedClass selector: self selectedMessageName.		"classListIndex := 0"]! !!FileList methodsFor: 'file list menu' stamp: 'sd 2/6/2002 21:25'!myServicesForFile: fullName suffix: suffix	^(FileStream isSourceFileSuffix: suffix)		ifTrue: [ {self serviceBroadcastUpdate} ]		ifFalse: [ #() ]! !!FileList2 methodsFor: 'private' stamp: 'RAA 6/16/2000 10:48'!postOpen	directory ifNotNil: [		self changed: #(openPath) , directory pathParts. 	].! !!FileList methodsFor: 'directory tree' stamp: 'ar 10/6/2009 00:54'!setDirectoryTo: dir	"Set the current directory shown in the FileList. 	Does not allow setting the directory to nil since this blows up in various places."	dir ifNil:[^self].	self directory: dir.	brevityState := #FileList.	self changed: #fileList.	self changed: #contents.	self changed: #pathAndPattern.! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:28'!newFileStreamFrom: aDirectory	| sfmResult fileStream |	sfmResult := self newFileFrom: aDirectory.	sfmResult ifNil: [^nil].	fileStream := sfmResult directory newFileNamed: sfmResult name.	[fileStream isNil] whileTrue:		[sfmResult := self newFileFrom: aDirectory.		sfmResult ifNil: [^nil].		fileStream := sfmResult directory newFileNamed: sfmResult name].	^fileStream! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 6/16/2000 13:01'!optionalButtonSpecs: anArray	optionalButtonSpecs := anArray! !!EmphasizedMenu methodsFor: 'private' stamp: 'fc 2/20/2004 11:01'!setEmphasis	"Set up the receiver to reflect the emphases in the emphases array.  "	| selStart selEnd currEmphasis |		labelString := labelString asText.	emphases isEmptyOrNil ifTrue: [^ self].	selStart := 1.	1 to: selections size do:		[:line |			selEnd := selStart + (selections at: line) size - 1.			((currEmphasis := emphases at: line) size > 0 and: [currEmphasis ~~ #normal]) ifTrue:				[labelString addAttribute: (TextEmphasis perform: currEmphasis)					from: selStart to: selEnd].			selStart := selEnd + 2]! !!FileList methodsFor: 'directory tree' stamp: 'ar 10/4/2009 22:12'!hasMoreDirectories: aDirectory	(aDirectory isKindOf: FileDirectory) ifFalse:[^true]. "server directory; don't ask"	^directoryCache at: aDirectory ifAbsentPut:[		[aDirectory directoryNames notEmpty] on: Error do:[:ex| true].	].! !!FileList2 methodsFor: 'volume list and pattern' stamp: 'RAA 8/17/2000 13:59'!directory	^directory! !!FileList2 methodsFor: 'own services' stamp: 'nk 6/14/2004 09:42'!deleteDirectory	super deleteDirectory.	self updateDirectory.! !!FileList class methodsFor: 'file reader registration' stamp: 'nk 12/7/2002 12:53'!itemsForFile: fullName	"Answer a list of services appropriate for a file of the given full name"	| services suffix |	suffix := self suffixOf: fullName.	services := OrderedCollection new.	self registeredFileReaderClasses do: [:reader |		reader ifNotNil: [services addAll: (reader fileReaderServicesForFile: fullName suffix: suffix)]].	^ services! !!FileList methodsFor: 'file menu action' stamp: 'sge 11/28/1999 09:04'!addNewFile	self 		addNew: 'File'		byEvaluating: [:newName | (directory newFileNamed: newName) close]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray lines: linesArray	"Answer an instance of me whose labels and selections are identical."	^ self		labelList: (selectionsArray collect: [:each | each asString])		lines: linesArray		selections: selectionsArray! !!CustomMenu methodsFor: 'construction' stamp: 'sw 8/12/2002 17:14'!addStayUpItem	"For compatibility with MenuMorph.  Here it is a no-op"! !!FileList2 methodsFor: 'drag''n''drop' stamp: 'nk 6/15/2003 22:00'!isDirectoryList: aMorph	^aMorph isKindOf: SimpleHierarchicalListMorph! !!FileList class methodsFor: 'file reader registration' stamp: 'SD 11/8/2001 21:17'!registerFileReader: aProviderClass	"register the given class as providing services for reading files"	| registeredReaders |	registeredReaders := self registeredFileReaderClasses.	(registeredReaders includes: aProviderClass) 			ifFalse: [ registeredReaders addLast: aProviderClass ]! !!StandardFileMenu methodsFor: 'private' stamp: 'zz 8/15/2005 16:29'!newFileFrom: aDirectory withPattern: aPattern	canTypeFileName := true.	pattern := {aPattern}.	^self makeFileMenuFor: aDirectory! !!FileList2 methodsFor: 'user interface' stamp: 'nk 6/15/2003 13:05'!morphicFileListPane	^(PluggableListMorph 		on: self 		list: #fileList 		selected: #fileListIndex		changeSelected: #fileListIndex: 		menu: #fileListMenu:)			enableDrag: true;			enableDrop: false;			yourself! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:33'!modalFolderSelector: aDir	| window fileModel |	window := self morphicViewFolderSelector: aDir.	fileModel := window model.	window openInWorld: self currentWorld extent: 300@400.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 20:33'!buildContentPaneWith: builder	| textSpec |	textSpec := builder pluggableTextSpec new.	textSpec 		model: self;		getText: #contents; 		setText: #put:; 		selection: #contentsSelection; 		menu: #fileContentsMenu:shifted:.	^textSpec! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:35'!modalFileSelector	| window |	window := self morphicViewFileSelector.	window openCenteredInWorld.	self modalLoopOn: window.	^(window valueOfProperty: #fileListModel) getSelectedFile! !!StandardFileMenu methodsFor: 'menu building' stamp: 'di 5/12/2000 10:31'!directoryNamesString: aDirectory"Answer a string concatenating the directory name strings in aDirectory, each string followed by a '[...]' indicator, and followed by a cr."	^ String streamContents:		[:s | aDirectory directoryNames do: 				[:dn | s nextPutAll: dn withBlanksTrimmed , ' [...]'; cr]]! !!FileList class methodsFor: 'class initialization' stamp: 'dvf 8/23/2003 12:17'!initialize	"FileList initialize"	RecentDirs := OrderedCollection new.	(self systemNavigation allClassesImplementing: #fileReaderServicesForFile:suffix:) do: 		[:providerMetaclass |			self registerFileReader: providerMetaclass soleInstance]! !!CustomMenu methodsFor: 'construction' stamp: 'nk 11/25/2003 10:00'!addTranslatedList: listOfTuplesAndDashes	"Add a menu item to the receiver for each tuple in the given list of the form (<what to show> <selector>). Add a line for each dash (-) in the list.  The tuples may have an optional third element, providing balloon help for the item, but such an element is ignored in mvc.	The first element will be translated."	listOfTuplesAndDashes do: [:aTuple |		aTuple == #-			ifTrue: [self addLine]			ifFalse: [self add: aTuple first translated action: aTuple second]]	"CustomMenu new addTranslatedList: #(		('apples' buyApples)		('oranges' buyOranges)		-		('milk' buyMilk)); startUp"! !!FileList methodsFor: 'private' stamp: 'BG 3/16/2005 08:22'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f := directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read' translated].	f binary.	((size := f size)) > 5000 & brevity		ifTrue: [data := f next: 10000. f close. brevityState := #briefHex]		ifFalse: [data := f contentsOfEntireFile. brevityState := #fullHex].	s := WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc printStringHex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) printStringHex; space].		s cr].	hexData := s contents.	^ contents := ((size > 5000) & brevity		ifTrue: ['File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. size. hexData}]		ifFalse: [hexData]).! !!FileList2 methodsFor: 'own services' stamp: 'sw 2/22/2002 02:36'!servicesForFolderSelector	"Answer the ok and cancel servies for the folder selector"	^ self okayAndCancelServices! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object 	the selector corresponding to the menu item selected by the user. Return 	nil if no item is selected."	| sel |	sel := self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"Example:	(SelectionMenu labels: 'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!FileList methodsFor: 'file list menu' stamp: 'em 3/29/2005 12:25'!fullFileListMenu: aMenu shifted: aBoolean	"Fill the menu with all possible items for the file list pane, regardless of selection."	| lastProvider |	aMenu title: 'all possible file operations' translated.	Smalltalk isMorphic ifTrue: [aMenu addStayUpItemSpecial].	lastProvider := nil.	(self itemsForFile: 'a.*') do: [ :svc |		(lastProvider notNil and: [svc provider ~~ lastProvider])			ifTrue: [ aMenu addLine ].		svc addServiceFor: self toMenu: aMenu.		Smalltalk isMorphic ifTrue: [aMenu submorphs last setBalloonText: svc description].		lastProvider := svc provider.		svc addDependent: self.	].	^aMenu! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/10/2000 08:02'!validateBlock: aBlock	^validateBlock := aBlock! !!FileList methodsFor: 'private' stamp: 'tlk 11/13/2004 19:01'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	brevityFlag ifTrue: [		directory isRemoteDirectory ifTrue: [^ self readServerBrief]].	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read' translated].	f converter: (self defaultEncoderFor: self fullName).	(brevityFlag not or: [(fileSize := f size) <= 100000]) ifTrue:		[contents := f contentsOfEntireFile.		brevityState := #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 := f next: 5000.	f close.	contents := 'File ''{1}'' is {2} bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------{3}------------------------------------------... end of the first 5000 characters.' translated format: {fileName. fileSize. first5000}.	brevityState := #briefFile.   "don't change till actually read"	^ contents.! !!EmphasizedMenu methodsFor: 'emphasis' stamp: ''!emphases: emphasisArray	emphases := emphasisArray! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList := (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray := #()]		ifNotNil: [linesArray := anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font := aFont].! !!FileList methodsFor: 'file menu action' stamp: 'jm 5/3/1998 18:03'!get	"Get contents of file again, it may have changed. Do this by making the cancel string be the contents, and doing a cancel."	Cursor read showWhile: [		self okToChange ifFalse: [^ nil].		brevityState == #briefHex			ifTrue: [brevityState := #needToGetFullHex]			ifFalse: [brevityState := #needToGetFull].		self changed: #contents].! !!PluggableFileList class methodsFor: 'standard dialog operations' stamp: 'acg 2/10/2000 08:29'!getFilePathNameWithExistenceCheck	^self getFilePathNameDialogWithExistenceCheck open! !!FileList methodsFor: 'file menu action' stamp: 'rbb 3/1/2005 10:53'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response := UIManager default						request: ('New {1} Name?' translated format: {aString translated})						initialAnswer: ('{1}Name' translated format: {aString translated}))		isEmpty ifTrue: [^ self].	newName := response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index := list indexOf: newName.	index = 0 ifTrue: [ending := ') ',newName.		index := list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'private' stamp: ''!folderString	^ ' [...]'! !!FileList methodsFor: 'initialization' stamp: 'sw 11/30/2002 00:05'!buttonSelectorsToSuppress	"Answer a list of action selectors whose corresponding services we would prefer *not* to have appear in the filelist's button pane; this can be hand-jimmied to suit personal taste."	^ #(removeLineFeeds: addFileToNewZip: compressFile: putUpdate:)! !!EmphasizedMenu methodsFor: 'display' stamp: ''!startUpWithCaption: captionOrNil	self setEmphasis.	^ super startUpWithCaption: captionOrNil! !!FileList methodsFor: 'own services' stamp: 'sd 1/31/2002 22:12'!serviceAllFileOptions	^ {SimpleServiceEntry provider: self label: 'more...' selector: #offerAllFileOptions description: 'show all the options available'}! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList	^ self labelArray: labelList! !!CustomMenu methodsFor: 'private' stamp: 'sw 12/10/1999 11:21'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream := WriteStream on: (String new).	labels do: [:label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: MenuStyle defaultFont		lines: dividers! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:57'!sortingByName	^ sortMode == #name! !!FileList methodsFor: 'file list menu' stamp: 'sw 2/27/2001 13:52'!offerAllFileOptions	"Put up a menu offering all possible file options, whatever the suffix of the current selection may be.  Specially useful if you're wanting to keep the menu up"	self offerMenuFrom: #fullFileListMenu:shifted: shifted: true! !!FileList methodsFor: 'initialization' stamp: 'nk 1/19/2005 13:25'!modelWakeUp	"User has entered or expanded the window -- reopen any remote connection."	(directory notNil and:[directory isRemoteDirectory])		ifTrue: [[directory wakeUp] on: TelnetProtocolError do: [ :ex | self inform: ex printString ]] "It would be good to implement a null method wakeUp on the root of directory"! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 20:40'!buildButtonPaneWith: builder	| panelSpec |	panelSpec := builder pluggablePanelSpec new.	panelSpec 		model: self;		children: #getButtonRow;		layout: #horizontal.	^panelSpec! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!name	^name! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 11/3/2004 20:13'!blueButtonText: aString textColor: textColor color: aColor inWindow: window balloonText: balloonText selector: sel recipient: recip 	| result |	result := window				fancyText: aString translatedfont: Preferences standardEToysFont				color: textColor.	result setProperty: #buttonText toValue: aString;		 hResizing: #rigid;		 extent: 100 @ 20;		 layoutInset: 4;		 borderWidth: ColorTheme current dialogButtonBorderWidth;		 useRoundedCorners;		 setBalloonText: balloonText.	result		on: #mouseUp		send: sel		to: recip.	aColor isNil		ifFalse: [""			result color: aColor.			result borderColor: aColor muchDarker].	^ result! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFolderDialog	^(self new)		prompt: 'Select a Folder';		fileFilterBlock: PluggableFileList allFoldersFileFilter;		canAcceptBlock: PluggableFileList alwaysAcceptBlock;		resultBlock: PluggableFileList directoryResultBlock;		validateBlock: PluggableFileList alwaysValidateBlock;		yourself! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 4/3/2006 14:03'!morphicViewProjectLoader2InWorld: aWorld reallyLoad: aBoolean dirFilterType: aSymbol	| window aFileList buttons treePane textColor1 fileListPane pane2a pane2b treeExtent filesExtent |	window := AlignmentMorphBob1 newColumn.	window hResizing: #shrinkWrap; vResizing: #shrinkWrap.	textColor1 := Color r: 0.742 g: 0.839 b: 1.0.	aFileList := self new directory: FileDirectory default.	aFileList 		optionalButtonSpecs: aFileList servicesForProjectLoader;		fileSelectionBlock: (			aSymbol == #limitedSuperSwikiDirectoryList ifTrue: [				MessageSend receiver: self selector: #projectOnlySelectionMethod:			] ifFalse: [				self projectOnlySelectionBlock			]		);		"dirSelectionBlock: self hideSqueakletDirectoryBlock;"		modalView: window.	window		setProperty: #FileList toValue: aFileList;		wrapCentering: #center; cellPositioning: #topCenter;		borderWidth: ColorTheme current dialogBorderWidth;		borderColor: ColorTheme current dialogBorderColor;		useRoundedCorners.	buttons := {{'OK'. ColorTheme current okColor}. {'Cancel'. ColorTheme current cancelColor}} collect: [ :each |		self blueButtonText: each first textColor: textColor1 color: each second inWindow: window	].	aWorld width < 800 ifTrue: [		treeExtent := 150@300.		filesExtent := 350@300.	] ifFalse: [		treeExtent := 250@300.		filesExtent := 350@300.	].	(treePane := aFileList morphicDirectoryTreePaneFiltered: aSymbol)		extent: treeExtent; 		retractable: false;		borderWidth: 0.	fileListPane := aFileList morphicFileListPane 		extent: filesExtent; 		retractable: false;		borderWidth: 0.	window		addARow: {			window fancyText: 'Load A Project' translated font: Preferences standardEToysTitleFont color: textColor1		};		addARowCentered: {			buttons first. 			(Morph new extent: 30@5) color: Color transparent. 			buttons second		};		addARow: {			window fancyText: 'Please select a project' translated  font: Preferences standardEToysFont color: textColor1		};		addARow: {				(window inAColumn: {(pane2a := window inARow: {window inAColumn: {treePane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.				(window inAColumn: {(pane2b := window inARow: {window inAColumn: {fileListPane}}) 					useRoundedCorners;					layoutInset: 0;					borderWidth: ColorTheme current dialogPaneBorderWidth;					borderColor: ColorTheme current dialogPaneBorderColor				}) layoutInset: 10.		}.	window fullBounds.	window fillWithRamp: ColorTheme current dialogRampOrColor oriented: 0.65.	pane2a fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35).	pane2b fillWithRamp: ColorTheme current dialogPaneRampOrColor oriented: (0.7 @ 0.35)."	buttons do: [ :each |		each fillWithRamp: ColorTheme current dialogButtonsRampOrColor oriented: (0.75 @ 0).	]."	buttons first 		on: #mouseUp 		send: (aBoolean ifTrue: [#okHitForProjectLoader] ifFalse: [#okHit])		to: aFileList.	buttons second on: #mouseUp send: #cancelHit to: aFileList.	aFileList postOpen.	window position: aWorld topLeft + (aWorld extent - window extent // 2).	window adoptPaneColor: (Color r: 0.548 g: 0.677 b: 1.0).	window becomeModal.	^ window openInWorld: aWorld.! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/10/2000 07:58'!rightButtonPressed	(canAcceptBlock value: directory value: fileName) ifFalse: [^nil].	(validateBlock value: directory value: fileName value: newFiles) ifFalse: [^nil].	accepted := true.	self changed: #close! !!FileList methodsFor: 'toolbuilder' stamp: 'ar 10/4/2009 20:32'!buildFileListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fileList; 		getIndex: #fileListIndex; 		setIndex: #fileListIndex:; 		menu: #fileListMenu:; 		keyPress: nil.	^listSpec! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 11/3/2004 20:09'!blueButtonText: aString textColor: textColor color: aColor inWindow: window 	| result |	result := window				fancyText: aString translated				font: Preferences standardEToysFont				color: textColor.	result setProperty: #buttonText toValue: aString;		 hResizing: #rigid;		 extent: 100 @ 20;		 layoutInset: 4;		 borderWidth: ColorTheme current dialogButtonBorderWidth;		 useRoundedCorners.	aColor isNil		ifFalse: [""result color: aColor. result borderColor: aColor muchDarker].	^ result! !!StandardFileMenu class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:15'!oldFileMenu: aDirectory	Smalltalk isMorphic ifFalse: [^ PluggableFileList oldFileMenu: aDirectory].	^ super new oldFileFrom: aDirectory! !!FileList methodsFor: 'file list' stamp: ''!fileList	"Answer the list of files in the current volume."	^ list! !!FileList2 class methodsFor: 'morphic ui' stamp: 'bkv 11/12/2002 16:55'!morphicViewFolderSelector: aDir	"Answer a tool that allows the user to select a folder"	| aFileList window fixedSize |	aFileList := self new directory: aDir.	aFileList optionalButtonSpecs: aFileList servicesForFolderSelector.	window := (SystemWindow labelled: aDir pathName) model: aFileList.	aFileList modalView: window.	fixedSize := 25.	self addFullPanesTo: window from: {		{self textRow: 'Please select a folder'. 0 @ 0 corner: 1 @ 0. 				0@0 corner: 0@fixedSize}.		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0. 				0@fixedSize corner: 0@(fixedSize * 2)}.		{aFileList morphicDirectoryTreePane. 0@0 corner: 1@1.				0@(fixedSize * 2) corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!FileList methodsFor: 'initialization' stamp: 'ar 10/4/2009 21:45'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory := dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode := #date].	volList := ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	volListIndex := volList size.	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern.! !!FileList class methodsFor: 'instance creation' stamp: 'SD 11/8/2001 21:20'!openFileDirectly	| aResult |	(aResult := StandardFileMenu oldFile) ifNotNil:		[self openEditorOn: (aResult directory readOnlyFileNamed: aResult name) editString: nil]! !!CustomMenu methodsFor: 'construction' stamp: 'yo 8/28/2002 22:34'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray := labelList findTokens: String cr]		ifFalse: [labelArray := labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!FileList methodsFor: 'volume list and pattern' stamp: 'ar 10/4/2009 21:46'!pathAndPattern: stringOrText	"Answers both path and pattern"	| base pat aString |	aString := stringOrText asString.	base := aString copyUpToLast: directory pathNameDelimiter.	pat := aString copyAfterLast: directory pathNameDelimiter.	self changed: #pathAndPattern. "avoid asking if it's okToChange"	pattern := pat.	self directory: (FileDirectory on: base).	self changed: #pathAndPattern.	self changed: #selectedPath.! !!StandardFileMenu methodsFor: 'private' stamp: 'zz 8/15/2005 18:25'!newFileFrom: aDirectory withPatternList: aPatternList	canTypeFileName := true.	pattern := aPatternList.	^self makeFileMenuFor: aDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'zz 8/15/2005 16:28'!oldFileFrom: aDirectory withPattern: aPattern	canTypeFileName := false.	pattern := {aPattern}.	^self makeFileMenuFor: aDirectory! !!FileList2 class methodsFor: 'blue ui' stamp: 'dgd 11/2/2004 21:43'!blueButtonText: aString textColor: textColor inWindow: window 	^ self		blueButtonText: aString		textColor: textColor		color: nil		inWindow: window! !!FileList methodsFor: 'private' stamp: 'yo 7/5/2004 19:41'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	(TextConverter allEncodingNames includes: brevityState) 		ifTrue: [ ^self readContentsAsEncoding: brevityState].	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'file menu action' stamp: 'di 4/15/98 12:36'!sortByDate	self resort: #date! !!PluggableFileList class methodsFor: 'fileFilterBlocks' stamp: 'acg 2/10/2000 08:17'!allFoldersFileFilter	^[:each | each isDirectory]! !!CustomMenu methodsFor: 'invocation' stamp: 'jm 11/17/97 16:54'!invokeOn: targetObject defaultSelection: defaultSelection	"Invoke the menu with the given default selection (i.e. one of my 'action' symbols). Answer the 'action' selector associated with the menu item chosen by the user or nil if none is chosen."	| sel |	sel := self startUp: defaultSelection.	sel = nil ifFalse: [		sel numArgs = 0			ifTrue: [^ targetObject perform: sel]			ifFalse: [^ targetObject perform: sel with: nil]].	^ nil! !!FileList2 class methodsFor: 'as yet unclassified' stamp: 'RAA 7/24/2000 19:13'!selectionBlockForSuffixes: anArray	^[ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			anArray anySatisfy: [ :each | each match: entry name]		]	] fixTemps! !!PluggableFileList class methodsFor: 'StandardFileMenu' stamp: 'BG 12/13/2002 15:32'!oldFileMenu: aDirectory	"For compatibility with StandardFileMenu for now, answer a StandardFileMenuResult"	^(self getFilePathNameDialog)		resultBlock: self sfmResultBlock;		directory: aDirectory;		yourself! !!FileList methodsFor: 'private' stamp: 'ka 8/26/2000 18:48'!readContentsShiftJIS	| f writeStream |	f := directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	writeStream := WriteStream on: String new.	f converter: ShiftJISTextConverter new.	[f atEnd]		whileFalse: [writeStream nextPut: f next].	f close.	^ writeStream contents! !!ProcessBrowser methodsFor: 'process list' stamp: 'nice 2/8/2010 09:03'!nextContext	| initialProcessIndex initialStackIndex |	searchString isEmpty ifTrue: [ ^false ].	initialProcessIndex := self processListIndex.	initialStackIndex := self stackListIndex.	initialProcessIndex		to: self processList size		do: [:pi | self processListIndex: pi.					self stackNameList						withIndexDo: [:name :si | (pi ~= initialProcessIndex											or: [si > initialStackIndex])								ifTrue: [(name includesSubString: searchString)										ifTrue: [self stackListIndex: si.											^true]]]].	self processListIndex: initialProcessIndex.	self stackListIndex: initialStackIndex.	^ false! !!FileList2 class methodsFor: 'morphic ui' stamp: 'miki 8/14/2005 21:21'!morphicViewFileSelectorForSuffixes: aList directory: dir	"Answer a morphic file-selector tool for the given suffix list and the given directory."	| aFileList window fixedSize midLine gap |	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList okayAndCancelServices.	aList ifNotNil:		[aFileList fileSelectionBlock: [:entry :myPattern |			entry isDirectory				ifTrue:					[false]				ifFalse:					[aList includes: (FileDirectory extensionFor: entry name asLowercase)]] fixTemps].	window := BorderedMorph new		layoutPolicy: ProportionalLayout new;		color: Color lightBlue;		borderColor: Color blue;		borderWidth: 4;		layoutInset: 4;		extent: 600@400;		useRoundedCorners.	window setProperty: #fileListModel toValue: aFileList.	aFileList modalView: window.	midLine := 0.4.	fixedSize := 25.	gap := 5.	self addFullPanesTo: window from: {		{self textRow: 'Please select a file'. 0 @ 0 corner: 1 @ 0. 0@0 corner: 0@fixedSize}.		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0. 0@fixedSize corner: 0@(fixedSize * 2)}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1. 					gap @(fixedSize * 2) corner: gap negated@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1. 					gap@(fixedSize * 2) corner: gap negated@0}.	}.	aFileList postOpen.	^ window ! !!FileList2 methodsFor: 'initialization' stamp: 'nice 12/27/2009 03:10'!publishingServers	| dirList |	dirList := OrderedCollection new.	ServerDirectory serverNames do: [ :n | | dir nameToShow | 		dir := ServerDirectory serverNamed: n.		(dir isProjectSwiki and: [dir acceptsUploads])			 ifTrue: [				nameToShow := n.				dirList add: ((dir directoryWrapperClass with: dir name: nameToShow model: self)					balloonText: dir realUrl)]].	^dirList! !!FileList methodsFor: 'initialization' stamp: 'ar 10/4/2009 20:49'!updateButtonRow	"Dynamically update the contents of the button row, if any."	self changed: #getButtonRow.! !!CustomMenu class methodsFor: 'example' stamp: 'sw 11/8/1999 17:27'!example	"CustomMenu example"	| menu |	menu := CustomMenu new.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu startUp: #apples"NB:  The following is equivalent to the above, but uses the compact #fromArray: consruct:	(CustomMenu fromArray:		#(	('apples'		apples)			('oranges'		oranges)			-			-			('peaches'		peaches)			-			('pears'			pears)			-))				startUp: #apples"! !!FileList methodsFor: 'initialization' stamp: 'tk 12/17/1999 18:00'!modelSleep	"User has exited or collapsed the window -- close any remote connection."	directory ifNotNil: [directory sleep]! !!FileList2 class methodsFor: 'blue ui' stamp: 'RAA 7/15/2000 19:21'!morphicViewProjectLoader2InWorld: aWorld	^self morphicViewProjectLoader2InWorld: aWorld reallyLoad: true! !!StandardFileMenu methodsFor: 'private' stamp: 'zz 8/15/2005 17:28'!oldFileFrom: aDirectory withPatternList: aPatternList	canTypeFileName := false.	pattern := aPatternList.	^self makeFileMenuFor: aDirectory! !!FileList methodsFor: 'initialization' stamp: 'sw 2/17/2002 05:38'!universalButtonServices	"Answer a list of services underlying the universal buttons in their initial inception.  For the moment, only the sorting buttons are shown."	^ {self serviceSortByName. self serviceSortByDate. self serviceSortBySize}! !!FileList2 class methodsFor: 'blue ui' stamp: 'nice 12/27/2009 03:11'!endingSpecs	"Answer a collection of specs to build the selective 'find anything' tool called by the Navigator. This version uses the services registry to do so."	"FileList2 morphicViewGeneralLoaderInWorld: World"	| categories specs rejects |	rejects := #(addFileToNewZip: compressFile: openInZipViewer: extractAllFrom: openOn:).	categories := #(		('Art' ('bmp' 'gif' 'jpg' 'jpeg' 'form' 'png' 'pcx' 'xbm' 'xpm' 'ppm' 'pbm'))		('Morphs' ('morph' 'morphs' 'sp'))		('Projects' ('extseg' 'project' 'pr'))		('MIDI' ('mid' 'midi'))		('Music' ('mp3'))		('Movies' ('movie' 'mpg' 'mpeg' 'qt' 'mov'))		('Flash' ('swf'))	).		"('Books' ('bo'))"		"('Code' ('st' 'cs'))"		"('TrueType' ('ttf'))"		"('3ds' ('3ds'))"		"('Tape' ('tape'))"		"('Wonderland' ('wrl'))"		"('HTML' ('htm' 'html'))"	categories first at: 2 put: ImageReadWriter allTypicalFileExtensions.	specs := OrderedCollection new.	categories do: [ :cat | | catSpecs catServices okExtensions services |		services := Dictionary new.		catSpecs := Array new: 3.		catServices := OrderedCollection new.		okExtensions := Set new.		cat second do: [ :ext | (FileList itemsForFile: 'fred.',ext) do: [ :i |			(rejects includes: i selector) ifFalse: [				okExtensions add: ext.				services at: i label put: i ]]].		services do: [ :svc | catServices add: svc ].		services isEmpty ifFalse: [ 			catSpecs at: 1 put: cat first;				at: 2 put: okExtensions;				at: 3 put: catServices.			specs add: catSpecs ]	].	^specs! !!CustomMenu methodsFor: 'compatibility' stamp: 'sumim 2/10/2002 01:20'!addServices: services for: served extraLines: linesArray	services withIndexDo: [:service :i |		self addService: service for: served.		(linesArray includes: i) | service useLineAfter 			ifTrue: [self addLine]]! !!CustomMenu methodsFor: 'compatibility' stamp: 'ads 2/20/2003 08:59'!add: aString subMenu: aMenu target: target selector: aSymbol argumentList: argList	"Create a sub-menu with the given label. This isn't really a sub-menu the way Morphic does it; it'll just pop up another menu."	self		add: aString		target: aMenu		selector: #invokeOn:		argumentList: argList asArray.! !!FileList2 methodsFor: 'private' stamp: 'ar 2/12/2001 16:20'!directoryNamesFor: item	"item may be file directory or server directory"	| entries |	entries := item directoryNames.	dirSelectionBlock ifNotNil:[entries := entries select: dirSelectionBlock].	^entries! !!FileList class methodsFor: 'instance creation' stamp: 'ar 10/4/2009 22:45'!openEditorOn: aFileStream editString: editString	"Open an editor on the given FileStream."	| fileModel topView builder |	fileModel := FileList new setFileStream: aFileStream.	"closes the stream"	builder := ToolBuilder default.	topView := fileModel buildEditorWith: builder.	^builder open: topView.! !!FileList class methodsFor: 'file reader registration' stamp: 'SD 11/11/2001 13:53'!isReaderNamedRegistered: aSymbol	"return if a given reader class has been registered. Note that this is on purpose that the argument is	a symbol and not a class"	 ^ (self registeredFileReaderClasses collect: [:each | each name]) includes: aSymbol! !!FileList2 methodsFor: 'private' stamp: 'LC 1/6/2002 06:51'!getSelectedDirectory	ok == true ifFalse: [^ nil].	^ currentDirectorySelected! !!CustomMenu methodsFor: 'compatibility' stamp: 'sumim 2/10/2002 01:18'!add: aString target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument."	self add: aString action: aSymbol.	targets addLast: target.	arguments addLast: argList asArray! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'MM 4/6/2004 22:56'!oldFileFrom: aDirectory withPattern: aPattern"Select an existing file from a selection conforming to aPattern."	^(self oldFileMenu: aDirectory withPattern: aPattern)		startUpWithCaption: 'Select a File:' translated! !!PluggableFileList methodsFor: 'file string' stamp: 'acg 2/18/2000 21:23'!fileString	fileName ifNil: [^directory pathName].	^directory fullNameFor: fileName! !!PluggableFileList methodsFor: 'file string' stamp: 'acg 2/19/2000 01:02'!fileString: aString	"| textName index ending |	textName := aString asString.	(FileDirectory default fileExists: textName) ifTrue:		[self directory: (FileDirectory forFileName: textName).		 index := list indexOf: (FileDirectory localNameFor: textName).		 index = 0 ifTrue: 			[ending := ') ', (FileDirectory localNameFor: textName).		  	 index := list findFirst: [:line | line endsWith: ending]].		 self fileListIndex: index].	(FileDirectory default directoryExists: textName) ifTrue:		[self directory: (FileDirectory on: textName)]."	self changed: #fileString.	self changed: #contents.	^true! !!FileList2 methodsFor: 'initialization' stamp: 'mir 2/6/2004 17:25'!limitedSuperSwikiPublishDirectoryList	| dirList localDirName localDir |	dirList := self publishingServers.	ServerDirectory localProjectDirectories do: [ :each |		dirList add: (FileDirectoryWrapper with: each name: each localName model: self)].	"Make sure the following are always shown, but not twice"	localDirName := SecurityManager default untrustedUserDirectory.	localDir := FileDirectory on: localDirName.	((ServerDirectory localProjectDirectories collect: [:each | each pathName]) includes: localDirName)			ifFalse: [dirList add: (FileDirectoryWrapper with: localDir name: localDir localName model: self)].	FileDirectory default pathName = localDirName			ifFalse: [dirList add: (FileDirectoryWrapper with: FileDirectory default name: FileDirectory default localName model: self)].	^dirList! !!SelectionMenu methodsFor: 'invocation' stamp: 'sw 11/18/2002 16:24'!invokeOn: targetObject orSendTo: anObject	"Pop up the receiver, obtaining a selector; return the result of having the target object perform the selector.  If it dos not understand the selector, give the alternate object a chance"	| aSelector |	^ (aSelector := self startUp) ifNotNil:		[(targetObject respondsTo: aSelector)			ifTrue:				[targetObject perform: aSelector]			ifFalse:				[anObject perform: aSelector]]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'acg 4/15/1999 21:57'!menuLabelsString: aDirectory"Answer a menu labels object corresponding to aDirectory"	^ String streamContents: 		[:s | 			canTypeFileName ifTrue: 				[s nextPutAll: 'Enter File Name...'; cr].			s nextPutAll: (self pathPartsString: aDirectory).			s nextPutAll: (self directoryNamesString: aDirectory).			s nextPutAll: (self fileNamesString: aDirectory).			s skip: -1]! !!FileList methodsFor: 'own services' stamp: 'sw 2/11/2002 23:36'!serviceAddNewFile	"Answer a service entry characterizing the 'add new file' command"	^ SimpleServiceEntry provider: self label: 'add new file' selector: #addNewFile description: 'create a new,. empty file, and add it to the current directory.'! !!FileList class methodsFor: 'file reader registration' stamp: 'sd 1/31/2002 21:42'!detectService: aBlock ifNone: anotherBlock	"self detectService: [:each | each selector = #fileIn:] ifNone: [nil]"	^ self allRegisteredServices			detect: aBlock			ifNone: anotherBlock! !!FileList2 class methodsFor: 'morphic ui' stamp: 'sw 2/22/2002 02:02'!morphicViewProjectLoader	| dir aFileList window midLine fixedSize |	dir := FileDirectory default.	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList servicesForProjectLoader.	aFileList fileSelectionBlock: self projectOnlySelectionBlock.	window := (SystemWindow labelled: dir pathName) model: aFileList.	fixedSize := 25.	midLine := 0.4.	self addFullPanesTo: window from: {		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0. 0@0 corner: 0@fixedSize}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1. 0@fixedSize corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1. 0@fixedSize corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!FileList methodsFor: 'initialization' stamp: 'di 5/11/1999 22:25'!release	self modelSleep! !!PluggableFileList class methodsFor: 'fileFilterBlocks' stamp: 'acg 2/10/2000 08:16'!allFilesAndFoldersFileFilter	^[:each | true]! !!FileList methodsFor: 'menu messages' stamp: 'sw 11/30/2002 15:38'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user.	If it's one of the three sort-by items, handle it specially.	If I can respond myself, then perform it on myself. 	If not, send it to otherTarget, presumably the editPane from which the menu was invoked."	^ (#(sortByDate sortBySize sortByName) includes: selector)		ifTrue:			[self resort: selector]		ifFalse:			[(#(get getHex copyName openImageInWindow importImage renameFile deleteFile addNewFile) includes: selector)				ifTrue: [self perform: selector]				ifFalse: [super perform: selector orSendTo: otherTarget]]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/10/2000 08:07'!fileNameResultBlock	^[:theDirectory :theFileName | theFileName]! !!FileList2 methodsFor: 'initialization' stamp: 'ar 10/4/2009 21:31'!optionalButtonRow	"Answer the button row associated with a file list"	| aRow |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent.	aRow clipSubmorphs: true.	aRow layoutInset: 5@1; cellInset: 6.	self universalButtonServices do:  "just the three sort-by items"			[:service |				aRow addMorphBack: (service buttonToTriggerIn: self).				(service selector  == #sortBySize)					ifTrue:						[aRow addTransparentSpacerOfSize: (4@0)]].	aRow setNameTo: 'buttons'.	aRow setProperty: #buttonRow toValue: true.  "Used for dynamic retrieval later on"	^ aRow! !!CustomMenu methodsFor: 'construction' stamp: 'dhhi 9/14/2000 22:39'!add: aString action: actionItem	"Add the given string as the next menu item. If it is selected, the given action (usually but not necessarily a symbol) will be returned to the client."	| s |	aString ifNil: [^ self addLine].	s := String new: aString size + 2.	s at: 1 put: Character space.	s replaceFrom: 2 to: s size - 1 with: aString.	s at: s size put: Character space.	labels addLast: s.	selections addLast: actionItem.! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/3/1998 18:21'!volumeListIndex	"Answer the index of the currently selected volume."	^ volListIndex! !!PluggableFileList methodsFor: 'accepting/cancelling' stamp: 'acg 2/9/2000 00:38'!result	accepted ifFalse: [^nil].	^resultBlock value: directory value: fileName! !!PluggableFileList class methodsFor: 'instance creation' stamp: 'acg 2/12/2000 14:52'!getFilePathNameDialogWithExistenceCheck	^(self new)		prompt: 'Select New File:';		validateBlock: PluggableFileList checkExistingFileValidateBlock;		yourself! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/13/2000 15:33'!beAccepted	^accepted := true! !!FileList class methodsFor: 'file reader registration' stamp: 'SD 11/8/2001 21:18'!unregisterFileReader: aProviderClass	"unregister the given class as providing services for reading files"	self registeredFileReaderClasses remove: aProviderClass ifAbsent: [nil]! !!PluggableFileList class methodsFor: 'resultBlocks' stamp: 'acg 2/12/2000 15:08'!sfmResultBlock	^[:theDirectory :theFileName | 		StandardFileMenuResult directory: theDirectory name: theFileName]! !!FileList methodsFor: 'private' stamp: 'yo 7/6/2004 20:52'!defaultEncoderFor: aFileName	"This method just illustrates the stupidest possible implementation of encoder selection."	| l |	l := aFileName asLowercase."	((l endsWith: FileStream multiCs) or: [		l endsWith: FileStream multiSt]) ifTrue: [		^ UTF8TextConverter new.	]."	((l endsWith: FileStream cs) or: [		l endsWith: FileStream st]) ifTrue: [		^ MacRomanTextConverter new.	].	^ Latin1TextConverter new.	! !!FileList methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!copyName	listIndex = 0 ifTrue: [^ self].	Clipboard clipboardText: self fullName asText.! !!FileList2 class methodsFor: 'morphic ui' stamp: 'BG 2/29/2004 23:26'!morphicViewImageViewer	| dir aFileList window midLine fixedSize |	dir := FileDirectory default.	aFileList := self new directory: dir.	aFileList optionalButtonSpecs: aFileList specsForImageViewer.	aFileList fileSelectionBlock: [ :entry :myPattern |		entry isDirectory ifTrue: [			false		] ifFalse: [			#('bmp' 'gif' 'jpg' 'form' 'png') includes: 					 (FileDirectory extensionFor: entry name asLowercase)		]	] fixTemps.	window := (SystemWindow labelled: dir pathName) model: aFileList.	fixedSize := 25.	midLine := 0.4.	self addFullPanesTo: window from: {		{aFileList optionalButtonRow. 0 @ 0 corner: 1 @ 0.				0@0 corner: 0@fixedSize}.		{aFileList morphicDirectoryTreePane. 0@0 corner: midLine@1.				0@fixedSize corner: 0@0}.		{aFileList morphicFileListPane. midLine @ 0 corner: 1@1.				0@fixedSize corner: 0@0}.	}.	aFileList postOpen.	^ window ! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFolderSelectorForProjectLoad	| window fileModel w |	window := self morphicViewProjectLoader2InWorld: self currentWorld reallyLoad: false.	fileModel := window valueOfProperty: #FileList.	w := self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	window openInWorld: w.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!PluggableFileList methodsFor: 'accessing' stamp: 'acg 2/9/2000 00:28'!prompt: aString	 prompt := aString! !!FileList methodsFor: 'directory tree' stamp: 'ar 10/4/2009 20:33'!directoryNameOf: aDirectory	^aDirectory localName! !!TimeProfileBrowser methodsFor: 'private' stamp: 'nice 1/18/2010 19:19'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	self flag: #mref.	"fix for faster references to methods"	^[ | strm string class parens sel |	string := self selection asString.	string first == $* ifTrue: [^contents := nil].		"Ignore lines starting with *"	parens := string includes: $(.					"Does it have open-paren?"	strm := ReadStream on: string.	parens		ifTrue: [strm skipTo: $(.		"easy case"			class := strm upTo: $).			strm next: 2.			sel := strm upToEnd]		ifFalse: [strm position: (string findString: ' class>>').			strm position > 0				ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])]				ifTrue:					[ | subString |  "find the next to last space character"					subString := strm contents copyFrom: 1 to: (string findLast: [ :ch | ch == $ ]) - 1.					strm position: (subString findLast: [ :ch | ch == $ ])].		"ifFalse: [strm position: (string findLast: [ :ch | ch == $ ])."			class := strm upTo: $>.			strm next.			sel := strm upToEnd].	MessageSet parse: (class, ' ', sel) toClassAndSelector: csBlock]		on: Error do: [:ex | contents := nil]! !!FileList2 methodsFor: 'volume list and pattern' stamp: 'mir 8/24/2001 12:03'!listForPattern: pat	"Make the list be those file names which match the pattern."	| sizePad newList entries |	directory ifNil: [^#()].	entries := (Preferences eToyLoginEnabled		and: [Utilities authorNamePerSe notNil])		ifTrue: [directory matchingEntries: {'submittedBy: ' , Utilities authorName.} ]		ifFalse: [directory entries].	(fileSelectionBlock isKindOf: MessageSend) ifTrue: [		fileSelectionBlock arguments: {entries}.		newList := fileSelectionBlock value.		fileSelectionBlock arguments: #().	] ifFalse: [		newList := entries select: [:entry | fileSelectionBlock value: entry value: pat].	].	newList := newList asSortedCollection: self sortBlock.	sizePad := (newList inject: 0 into: [:mx :entry | mx max: (entry at: 5)])					asStringWithCommas size - 1.	newList := newList collect: [ :e | self fileNameFormattedFrom: e sizePad: sizePad ].	^ newList asArray! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 2/17/2002 04:48'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return nil if no item is selected.  If the chosen selector has arguments, obtain them from my arguments"	^ self invokeOn: targetObject orSendTo: nil! !!FileList class methodsFor: 'class initialization' stamp: 'asm 4/10/2003 12:47'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(FileList					prototypicalToolWindow		'File List'			'A File List is a tool for browsing folders and files on disks and on ftp types.') 						forFlapNamed: 'Tools']! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'miki 8/15/2005 18:34'!modalFolderSelectorForProject: aProject"FileList2 modalFolderSelectorForProject: Project current"	| window fileModel w |	window := FileList2 morphicViewProjectSaverFor: aProject.	fileModel := window valueOfProperty: #FileList.	w := self currentWorld.	window position: w topLeft + (w extent - window extent // 2).	w addMorphInLayer: window.	w startSteppingSubmorphsOf: window.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:27'!oldFileStreamFrom: aDirectory	| sfmResult fileStream |	sfmResult := self oldFileFrom: aDirectory.	sfmResult ifNil: [^nil].	fileStream := sfmResult directory oldFileNamed: sfmResult name.	[fileStream isNil] whileTrue:		[sfmResult := self oldFileFrom: aDirectory.		sfmResult ifNil: [^nil].		fileStream := sfmResult directory oldFileNamed: sfmResult name].	^fileStream! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2003 17:08'!fullName	"Answer the full name for the currently selected file; answer nil if no file is selected."	^ fileName ifNotNil: [directory		ifNil:			[FileDirectory default fullNameFor: fileName]		ifNotNil:			[directory fullNameFor: fileName]]! !!FileList class methodsFor: 'instance creation' stamp: 'ar 10/4/2009 20:55'!prototypicalToolWindow	"Answer an example of myself seen in a tool window, for the benefit of parts-launching tools"	^ ToolBuilder build: self new! !!FileList methodsFor: 'initialization' stamp: 'ar 10/4/2009 22:48'!labelString	^fileName ifNil:['File List'] ifNotNil:[directory fullNameFor: fileName].! !!FileList methodsFor: 'file menu action' stamp: 'sd 2/1/2002 20:02'!spawn: code	"Open a simple Edit window"	listIndex = 0 ifTrue: [^ self].	self class openEditorOn: (directory readOnlyFileNamed: fileName)				"read only just for initial look"			editString: code! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray	"Answer an instance of me whose labels and selections are identical."	^ self selections: selectionsArray lines: nil! !!StandardFileMenu class methodsFor: 'standard file operations' stamp: 'tk 2/14/2000 14:28'!newFile	^self newFileFrom: (FileDirectory default)! !!FileList2 methodsFor: 'user interface' stamp: 'dgd 4/3/2006 13:59'!blueButtonForService: aService textColor: textColor inWindow: window 	| block result |	block := [self fullName isNil				ifTrue: [self inform: 'Please select a file' translated]				ifFalse: [aService performServiceFor: self]] copy fixTemps.	result := window				fancyText: aService buttonLabel capitalized translated				font: Preferences standardEToysFont				color: textColor.	result setProperty: #buttonText toValue: aService buttonLabel capitalized;		 hResizing: #rigid;		 extent: 100 @ 20;		 layoutInset: 4;		 borderWidth: ColorTheme current dialogButtonBorderWidth;		 useRoundedCorners;		 setBalloonText: aService label.	result		on: #mouseUp		send: #value		to: block.	^ result! !!FileList methodsFor: 'file menu action' stamp: 'yo 3/31/2003 11:25'!getEncodedText	Cursor read showWhile: [		self selectEncoding.		self changed: #contents].! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 8/17/2000 13:22'!directoryChangeBlock: aBlockOrNil	directoryChangeBlock := aBlockOrNil.! !!CPUWatcher methodsFor: 'porcine capture' stamp: 'dtl 2/9/2010 22:00'!openMVCWindowForSuspendedProcess: aProcess	ProcessBrowser open! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'acg 4/15/1999 08:43'!directory	^directory! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'rbb 2/16/2005 16:59'!confirmExistingFiles: aResult	|choice|	(aResult directory fileExists: aResult name) ifFalse: [^aResult].		choice := (UIManager default chooseFrom: #('overwrite that file' 'choose another name' 'cancel')		title: aResult name, 'already exists.').	choice = 1 ifTrue: [		aResult directory 			deleteFileNamed: aResult name			ifAbsent: 				[^self startUpWithCaption: 'Can''t delete ', aResult name, 'Select another file'].		^aResult].	choice = 2 ifTrue: [^self startUpWithCaption: 'Select Another File'].	^nil ! !!FileList methodsFor: 'file menu action' stamp: 'di 4/15/98 12:37'!sortByName	self resort: #name! !!FileList methodsFor: 'file list menu' stamp: 'LEG 10/24/2001 15:37'!fileListMenu: aMenu	fileName		ifNil: [^ self noFileSelectedMenu: aMenu]		ifNotNil: [^ self fileSelectedMenu: aMenu].! !!FileList2 methodsFor: 'user interface' stamp: 'RAA 2/17/2001 12:18'!morphicDirectoryTreePane	^self morphicDirectoryTreePaneFiltered: #initialDirectoryList! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 6/16/2000 13:08'!fileSelectionBlock: aBlock	fileSelectionBlock := aBlock! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'sw 6/9/1999 11:50'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' with directory: '.	directory printOn: aStream.	aStream nextPutAll: ' name: '.	name printOn: aStream"StandardFileMenu oldFile"! !!FileList methodsFor: 'initialization' stamp: 'sw 2/26/2002 00:37'!dynamicButtonServices	"Answer services for buttons that may come and go in the button pane, depending on selection"	^ fileName isEmptyOrNil		ifTrue:			[#()]		ifFalse:			[ | toReject |				toReject := self buttonSelectorsToSuppress.				(self itemsForFile: self fullName) reject:					[:svc | toReject includes: svc selector]]! !!FileList2 methodsFor: 'initialization' stamp: 'RAA 6/16/2000 10:40'!labelString	^ (directory ifNil: [^'[]']) pathName contractTo: 50! !!FileList2 methodsFor: 'own services' stamp: 'sw 2/22/2002 02:07'!serviceOpenProjectFromFile	"Answer a service for opening a .pr project file"	^ SimpleServiceEntry 		provider: self 		label: 'load as project'		selector: #openProjectFromFile		description: 'open project from file'		buttonLabel: 'load'! !!FileList methodsFor: 'private' stamp: 'SD 11/14/2001 21:59'!isFileSelected	"return if a file is currently selected"	^ fileName isNil not! !SyntaxError class removeSelector: #buildMVCViewOn:!ProcessBrowser removeSelector: #openAsMVC!ProcessBrowser removeSelector: #openAsMorph!SyntaxError class removeSelector: #buildMorphicViewOn:!FileList initialize!