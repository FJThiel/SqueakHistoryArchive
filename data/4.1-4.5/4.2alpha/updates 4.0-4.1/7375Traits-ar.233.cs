"Change Set:		7375Traits-ar.233Traits-ar.233:Put variablesAndOffsetsDo: into TraitDescription instead of Trait since we need the same implementation for ClassTrait.Traits-ar.232:Post-closure cleanup and underscore removal."!!QuickStack methodsFor: 'accessing' stamp: 'apb 8/31/2003 21:42'!removeLast: n	top := top - n! !!TraitComposition methodsFor: 'private' stamp: 'al 3/19/2004 10:30'!transformations: aCollection	transformations := aCollection! !!TUpdateTraitsBehavior methodsFor: 'traits' stamp: 'al 8/6/2004 13:09'!noteChangedSelectors: aCollection	"Start update of my methodDict (after changes to traits in traitComposition	or after a local method was removed from my methodDict). The argument 	is a collection of method selectors that may have been changed. Most of the time	aCollection only holds one selector. But when there are aliases involved 	there may be several method changes that have to be propagated to users."	| affectedSelectors |	affectedSelectors := IdentitySet new.	aCollection do: [:selector |		affectedSelectors addAll: (self updateMethodDictionarySelector: selector)].	self notifyUsersOfChangedSelectors: affectedSelectors.	^ affectedSelectors! !!TUpdateTraitsBehavior methodsFor: 'traits' stamp: 'al 3/26/2006 21:36'!updateMethodDictionarySelector: aSymbol	"A method with selector aSymbol in myself or my traitComposition has been changed.	Do the appropriate update to my methodDict (remove or update method) and	return all affected selectors of me so that my useres get notified."	| effectiveMethod modifiedSelectors descriptions selector |	modifiedSelectors := IdentitySet new.	descriptions := self hasTraitComposition		ifTrue: [ self traitComposition methodDescriptionsForSelector: aSymbol ]		ifFalse: [ #() ].	descriptions do: [:methodDescription |		selector := methodDescription selector.		(self includesLocalSelector: selector) ifFalse: [			methodDescription isEmpty				ifTrue: [					self removeTraitSelector: selector.					modifiedSelectors add: selector]				ifFalse: [					effectiveMethod := methodDescription effectiveMethod.					(self compiledMethodAt: selector ifAbsent: [nil]) ~~ effectiveMethod ifTrue: [						self addTraitSelector: selector withMethod: effectiveMethod.						modifiedSelectors add: selector]]]].	^modifiedSelectors! !!SendInfo methodsFor: 'instruction decoding' stamp: 'apb 9/7/2004 10:42'!jump: distance 	"Simulate the action of a 'unconditional jump' bytecode whose  	offset is the argument, distance."	distance < 0		ifTrue: [^ self].	distance = 0		ifTrue: [self error: 'bad compiler!!'].	savedStacks at: (self pc + distance) put: stack.	"We empty the stack to signify that execution cannot 'fall through' to the	next statement.  Note that since we just stored the current stack, not a copy, in	the savedStacks dictionary, here we need to allocate a new stack."	self newEmptyStack.  	isStartOfBlock		ifTrue: [isStartOfBlock := false.			numBlockArgs	timesRepeat: [self push: #stuff]]! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'dvf 9/8/2005 16:14'!initialize	possiblyAffectedPerRoot := IdentityDictionary new.! !!TFileInOutDescription methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 17:15'!fileOutMethod: selector asHtml: useHtml	"Write source code of a single method on a file in .st or .html format"	| internalStream |	(selector == #Comment) ifTrue: [^ self inform: 'Sorry, cannot file out class comment in isolation.'].	(self includesSelector: selector) ifFalse: [^ self error: 'Selector ', selector asString, ' not found'].	internalStream := WriteStream on: (String new: 1000).	internalStream header; timeStamp.	self printMethodChunk: selector withPreamble: true		on: internalStream moveSource: false toFile: 0.	FileStream writeSourceCodeFrom: internalStream baseName: (self name , '-' , (selector copyReplaceAll: ':' with: '')) isSt: true useHtml: useHtml.! !!QuickStack methodsFor: 'copying' stamp: 'apb 9/7/2004 10:37'!copy	"Answer a copy of a myself"	| newSize |	newSize := self basicSize.	^ (self class new: newSize)		replaceFrom: 1		to: top		with: self		startingAt: 1;		 setTop: top! !!TCommentDescription methodsFor: 'fileIn/Out' stamp: 'al 12/1/2005 15:43'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue:		[SystemChangeNotifier uniqueInstance classCommented: self.		^ self organization classComment: aString stamp: aStamp].	oldCommentRemoteStr := self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ self organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr := oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file := SourceFiles at: 2) ifNotNil:		[file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header := String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	self organization classComment: (RemoteString newString: aString onFileNumber: 2) stamp: aStamp.	SystemChangeNotifier uniqueInstance classCommented: self.! !!TraitBehavior methodsFor: 'initialize-release' stamp: 'NS 4/12/2004 14:28'!initialize	self methodDict: MethodDictionary new.	self traitComposition: nil.	users := IdentitySet new.! !!TFileInOutDescription methodsFor: 'fileIn/Out' stamp: 'al 5/9/2004 18:56'!putClassCommentToCondensedChangesFile: aFileStream	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file #2.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."	| header aStamp aCommentRemoteStr |	self isMeta ifTrue: [^ self].  "bulletproofing only"	((aCommentRemoteStr := self organization commentRemoteStr) isNil or:		[aCommentRemoteStr sourceFileNumber == 1]) ifTrue: [^ self].	aFileStream cr; nextPut: $!!.	header := String streamContents: [:strm | strm nextPutAll: self name;		nextPutAll: ' commentStamp: '.		(aStamp := self organization commentStamp ifNil: ['<historical>']) storeOn: strm.		strm nextPutAll: ' prior: 0'].	aFileStream nextChunkPut: header.	aFileStream cr.	self organization classComment: (RemoteString newString: self organization classComment onFileNumber: 2 toFile: aFileStream) stamp: aStamp! !!SendInfo methodsFor: 'initialization' stamp: 'apb 8/28/2003 17:32'!collectSends	| end |	end := self method endPC.	[pc <= end]		whileTrue: [self interpretNextInstructionFor: self]! !!TFileInOutDescription methodsFor: 'fileIn/Out' stamp: 'al 5/9/2004 18:52'!fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org sels |	(org := self organization) categories do: 		[:cat | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels do:			[:sel |  self printMethodChunk: sel withPreamble: true on: aFileStream							moveSource: moveSource toFile: fileIndex]]! !!TCompilingBehavior methodsFor: 'testing method dictionary' stamp: 'md 2/15/2006 11:01'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who := IdentitySet new.	self selectorsAndMethodsDo: 		[:sel :method |		((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!TPureBehavior methodsFor: 'accessing class hierarchy' stamp: 'al 12/31/2005 13:40'!withAllSuperclasses	"Answer an OrderedCollection of the receiver and the receiver's 	superclasses. The first element is the receiver, 	followed by its superclass; the last element is Object."	| temp |	temp := self allSuperclasses.	temp addFirst: self.	^ temp! !!TraitDescription methodsFor: 'organization' stamp: 'NS 4/8/2004 11:04'!organization: aClassOrg	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."	aClassOrg ifNotNil: [aClassOrg setSubject: self].	organization := aClassOrg! !!LocatedMethod methodsFor: 'comparing' stamp: 'al 3/6/2004 18:53'!argumentNames	"Return an array with the argument names of the method's selector"	| keywords stream argumentNames argumentName delimiters |	delimiters := {Character space. Character cr}.	keywords := self selector keywords.	stream := self source readStream.	argumentNames := OrderedCollection new.	keywords do: [ :each |		stream match: each.		[stream peekFor: Character space] whileTrue.		argumentName := ReadWriteStream on: String new.		[(delimiters includes: stream peek) or: [stream peek isNil]]			whileFalse: [argumentName nextPut: stream next].		argumentName isEmpty ifFalse: [			argumentNames add: argumentName contents withBlanksTrimmed]].	^(argumentNames copyFrom: 1 to: self method numArgs) asArray! !!TraitDescription methodsFor: 'private' stamp: 'md 6/2/2006 10:32'!linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	| lines |	lines := self methodDict values inject: 0 into: [:sum :each | sum + each linesOfCode]. 	self isMeta 		ifTrue: [^ lines]		ifFalse: [^ lines + self class linesOfCode]! !!TCompilingBehavior methodsFor: 'accessing method dictionary' stamp: 'al 7/30/2004 21:01'!compressedSourceCodeAt: selector	"(Paragraph compressedSourceCodeAt: #displayLines:affectedRectangle:) size 721 1921	Paragraph selectors inject: 0 into: [:tot :sel | tot + (Paragraph compressedSourceCodeAt: sel) size] 13606 31450"	| rawText parse |	rawText := (self sourceCodeAt: selector) asString.	parse := self compilerClass new parse: rawText in: self notifying: nil.	^ rawText compressWithTable:		((selector keywords ,		parse tempNames ,		self instVarNames ,		#(self super ifTrue: ifFalse:) ,		((0 to: 7) collect:			[:i | String streamContents:				[:s | s cr. i timesRepeat: [s tab]]]) ,		(self compiledMethodAt: selector) literalStrings)			asSortedCollection: [:a :b | a size > b size])! !!TraitDescription methodsFor: 'private' stamp: 'al 2/4/2004 14:22'!logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor	| priorMethodOrNil newText |	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [].	newText := ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [aText askIfAddStyle: priorMethodOrNil req: requestor]			ifFalse: [aText].	aCompiledMethodWithNode method putSource: newText		fromParseNode: aCompiledMethodWithNode node		class: self category: category withStamp: changeStamp 		inFile: 2 priorMethod: priorMethodOrNil.! !!FixedIdentitySet methodsFor: 'enumerating' stamp: 'NS 5/24/2005 09:04'!do: aBlock	| obj count |	count := 0.	1 to: self basicSize do: [:index |		count >= tally ifTrue: [^ self].		obj := self basicAt: index.		obj ifNotNil: [count := count + 1. aBlock value: obj].	].! !!Behavior methodsFor: '*Traits-requires' stamp: 'NS 5/26/2005 14:27'!computeSelfSendersFromInheritedSelfSenders: inheritedCollection localSelfSenders: localCollection	"Compute the set of all self-senders from the set of inherited self-senders and the set of local self-senders."	| result mDict |	mDict := self methodDict.	result := IdentitySet new: inheritedCollection size + localCollection size.	"This if-statement is just a performance optimization. 	Both branches are semantically equivalent."	inheritedCollection size > mDict size ifTrue: [		result addAll: inheritedCollection.		mDict keysDo: [:each | result remove: each ifAbsent: []].	] ifFalse: [		inheritedCollection do: [:each | (mDict includesKey: each) ifFalse: [result add: each]].	].	result addAll: localCollection.	^ result.! !!FixedIdentitySet methodsFor: 'accessing' stamp: 'NS 5/24/2005 10:47'!add: anObject	| index old |	self isFull ifTrue: [^ false].	index := self indexOf: anObject.	old := self basicAt: index.	old == anObject ifTrue: [^ true].	old ifNotNil: [^ false].	self basicAt: index put: anObject.	tally := tally + 1.	^ true! !!Trait methodsFor: 'initialize-release' stamp: 'al 7/17/2004 23:00'!name: aString traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization	"Used by copy"		self name: aString.	localSelectors := aSet.	methodDict := aMethodDict.	traitComposition := aComposition.	self organization: aClassOrganization		! !!LocatedMethod methodsFor: 'accessing' stamp: 'al 1/23/2004 10:07'!location: aPureBehavior selector: aSymbol	location := aPureBehavior.	selector := aSymbol! !!SendInfo methodsFor: 'instruction decoding' stamp: 'apb 8/31/2003 21:50'!jump: distance if: aBooleanConstant 	"Simulate the action of a 'conditional jump' bytecode whose offset is 	distance, and whose condition is aBooleanConstant."	| destination |	distance < 0 ifTrue:[^ self].	distance = 0 ifTrue:[self error: 'bad compiler!!'].	destination := self pc + distance.	"remove the condition from the stack."	self pop.	savedStacks at: destination put: stack copy.! !!SendInfo methodsFor: 'stack manipulation' stamp: 'apb 9/7/2004 10:41'!newEmptyStack	stack := QuickStack new! !!TraitComposition methodsFor: 'testing' stamp: 'al 4/10/2004 23:25'!isAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in this or in another composition somewhere deeper in 	the tree of traits compositions."	| methodDescription |	methodDescription := (self methodDescriptionsForSelector: aSymbol)		detect: [:each | each selector = aSymbol].	^methodDescription isAliasSelector! !!QuickStack methodsFor: 'private' stamp: 'apb 8/30/2003 17:56'!grow	| newStack |	newStack := self class new: (self basicSize * 2).	newStack replaceFrom: 1 to: top with: self startingAt: 1.	newStack setTop: top.	self becomeForward: newStack.! !!Trait methodsFor: 'initialize-release' stamp: 'al 7/17/2004 14:16'!initialize	super initialize.	classTrait := ClassTrait for: self! !!TraitAlias methodsFor: 'enquiries' stamp: 'al 4/7/2004 21:16'!collectMethodsFor: aSelector into: methodDescription	| originalSelector association |	self subject		collectMethodsFor: aSelector		into: methodDescription.				association := self aliasNamed: aSelector ifAbsent: [nil].	association notNil ifTrue: [		originalSelector := association value.		self subject			collectMethodsFor: originalSelector			into: methodDescription]! !!TraitComposition methodsFor: 'enquiries' stamp: 'al 7/22/2004 15:35'!traitProvidingSelector: aSymbol	"Return the trait which originally provides the method aSymbol or return nil	if trait composition does not provide this selector or there is a conflict.	Take aliases into account. Return the trait which the aliased method is defined in."	| methodDescription locatedMethod |	methodDescription := self methodDescriptionForSelector: aSymbol.	(methodDescription isProvided not or: [methodDescription isConflict])			ifTrue: [^nil].	locatedMethod := methodDescription providedLocatedMethod.	^locatedMethod location traitOrClassOfSelector: locatedMethod selector! !!Behavior methodsFor: '*Traits-requires' stamp: 'NS 5/26/2005 12:11'!classAndMethodFor: aSymbol do: binaryBlock ifAbsent: absentBlock	"Looks up the selector aSymbol in the class chain. If it is found, binaryBlock is evaluated	with the class that defines the selector and the associated method. Otherwise	absentBlock is evaluated."	| method |	self withAllSuperclassesDo: [:class |		method := class compiledMethodAt: aSymbol ifAbsent: [nil].		method ifNotNil: [^ binaryBlock value: class value: method].	].	^ absentBlock value.! !!Trait methodsFor: 'accessing parallel hierarchy' stamp: 'al 7/17/2004 14:16'!classTrait: aTrait	"Assigns the class trait associated with the receiver."		self assert: aTrait isClassTrait.	classTrait := aTrait! !!TraitMethodDescription methodsFor: 'private' stamp: 'md 2/13/2006 14:36'!generateTemplateMethodWithMarker: aSymbol forArgs: aNumber binary: aBoolean	| source node |	source := String streamContents: [:stream |		aNumber < 1			ifTrue: [stream nextPutAll: 'selector']			ifFalse: [aBoolean				ifTrue: [					stream nextPutAll: '* anObject']				ifFalse: [					1 to: aNumber do: [:argumentNumber |						stream							nextPutAll: 'with:'; space;							nextPutAll: 'arg'; nextPutAll: argumentNumber asString; space]]].		stream cr; tab; nextPutAll: 'self '; nextPutAll: aSymbol].	node := self class compilerClass new		compile: source		in: self class		notifying: nil		ifFail: [].	^node generate.! !!QuickStack methodsFor: 'initialization' stamp: 'apb 8/30/2003 11:34'!initialize	top := 0! !!ClassTrait methodsFor: 'composition' stamp: 'al 7/18/2004 14:02'!uses: aTraitCompositionOrArray	| copyOfOldTrait newComposition |	copyOfOldTrait := self copy.	newComposition := aTraitCompositionOrArray asTraitComposition.	self assertConsistantCompositionsForNew: newComposition.	self setTraitComposition: newComposition.	SystemChangeNotifier uniqueInstance		traitDefinitionChangedFrom: copyOfOldTrait to: self.! !!TraitTransformation methodsFor: 'accessing' stamp: 'al 4/9/2004 18:23'!subject: aTraitTransformation	subject := aTraitTransformation! !!TPureBehavior methodsFor: 'accessing method dictionary' stamp: 'al 9/16/2005 14:49'!formalParametersAt: aSelector	"Return the names of the arguments used in this method."	| source parser message list params |	source := self sourceCodeAt: aSelector ifAbsent: [^ #()].	"for now"	(parser := self parserClass new) parseSelector: source.	message := source copyFrom: 1 to: (parser endOfLastToken min: source size).	list := message string findTokens: Character separators.	params := OrderedCollection new.	list withIndexDo: [:token :ind | ind even ifTrue: [params addLast: token]].	^ params! !!TCompilingBehavior methodsFor: 'compiling' stamp: 'al 11/28/2005 11:28'!bindingOf: varName		"Answer the binding of some variable resolved in the scope of the receiver"	| aSymbol binding |	aSymbol := varName asSymbol.	"Look in declared environment."	binding := self environment bindingOf: aSymbol.	^binding! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'NS 4/19/2004 16:13'!effectiveMethod	"Return the effective compiled method of this method description." 	| locatedMethod method |	method := self providedMethod.	method isNil ifFalse: [^ method].	method := self conflictMethod.	method isNil ifFalse: [^ method].	^ self requiredMethod.! !!TTraitsCategorisingDescription methodsFor: 'organization updating' stamp: 'al 5/9/2004 14:01'!noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition	| oldCategory newCategory |	aCollection do: [:each | 		oldCategory := self organization categoryOfElement: each.		newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.		self noteRecategorizedSelector: each from: oldCategory to: newCategory]! !!TraitMethodDescription methodsFor: 'testing' stamp: 'al 4/10/2004 23:29'!isAliasSelector	"Return true if the selector is an alias (if it is different	from the original selector) or already an aliased method	in the original location (recursively search the compositions).	Return false, if not or if we have a conflict."		| locatedMethod |	^self size = 1 and: [		locatedMethod := self locatedMethods anyOne.		(locatedMethod selector ~= self selector) or: [			locatedMethod location isAliasSelector: self selector]]! !!Trait class methodsFor: 'instance creation' stamp: 'md 3/3/2006 11:05'!named: aSymbol uses: aTraitCompositionOrCollection category: aString	| env |	env := self environment.	^self		named: aSymbol		uses: aTraitCompositionOrCollection		category: aString		env: env! !!TTraitsCategorisingDescription methodsFor: 'organization updating' stamp: 'al 5/9/2004 14:08'!applyChangesOfNewTraitCompositionReplacing: oldComposition	| changedSelectors |	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.	self noteRecategorizedSelectors: changedSelectors oldComposition: oldComposition.	^ changedSelectors.! !!Trait methodsFor: 'accessing' stamp: 'al 7/17/2004 14:16'!name: aSymbol	name := aSymbol! !!TPureBehavior methodsFor: 'accessing method dictionary' stamp: 'al 9/16/2005 14:51'!standardMethodHeaderFor: aSelector	| args |	args := (1 to: aSelector numArgs)	collect:[:i| 'arg', i printString].	args size = 0 ifTrue:[^aSelector asString].	args size = 1 ifTrue:[^aSelector,' arg1'].	^String streamContents:[:s|		(aSelector findTokens:':') with: args do:[:tok :arg|			s nextPutAll: tok; nextPutAll:': '; nextPutAll: arg; nextPutAll:' '.		].	].! !!TCopyingDescription methodsFor: 'copying' stamp: 'al 5/8/2004 18:54'!copy: sel from: class classified: cat 	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."	| code category |	"Useful when modifying an existing class"	code := class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category := class organization categoryOfElement: sel]				ifFalse: [category := cat].			(self methodDict includesKey: sel)				ifTrue: [code asString = (self sourceMethodAt: sel) asString 							ifFalse: [self error: self name 										, ' ' 										, sel 										, ' will be redefined if you proceed.']].			self compile: code classified: category]! !!TPureBehavior methodsFor: 'adding/removing methods' stamp: 'al 3/26/2006 21:37'!removeSelector: aSelector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method.		If the method to remove will be replaced by a method from my trait composition,	the current method does not have to be removed because we mark it as non-local.	If it is not identical to the actual method from the trait it will be replaced automatically	by #noteChangedSelectors:.		This is useful to avoid bootstrapping problems when moving methods to a trait	(e.g., from TPureBehavior to TMethodDictionaryBehavior). Manual moving (implementing	the method in the trait and then remove it from the class) does not work if the methods	themselves are used for this process (such as compiledMethodAt:, includesLocalSelector: or	addTraitSelector:withMethod:)"	| changeFromLocalToTraitMethod |	changeFromLocalToTraitMethod := (self includesLocalSelector: aSelector)		and: [self hasTraitComposition]		and: [self traitComposition includesMethod: aSelector].	changeFromLocalToTraitMethod		ifFalse: [self basicRemoveSelector: aSelector]		ifTrue: [self ensureLocalSelectors].	self deregisterLocalSelector: aSelector.	self noteChangedSelectors: (Array with: aSelector)	! !!QuickStack methodsFor: 'accessing' stamp: 'apb 8/30/2003 11:43'!removeLast	| answer |	answer := self at: top.	top := top - 1.	^ answer! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'al 1/23/2004 10:19'!selector: aSymbol 	selector := aSymbol! !!SendCaches methodsFor: 'updates' stamp: 'apb 3/2/2006 23:27'!addSelfSender: sendingSelector of: sentSelector	| senders |	senders := selfSenders at: sentSelector ifAbsent: [#()].	selfSenders at: sentSelector put: (senders copyWith: sendingSelector).! !!TraitMethodDescription class methodsFor: 'class initialization' stamp: 'NS 4/19/2004 16:26'!initialize	"	self initialize	"	ConflictMethods := Array new: self maxArguments + 2.	RequiredMethods := Array new: self maxArguments + 2.! !!SendInfo methodsFor: 'stack manipulation' stamp: 'apb 8/31/2003 21:30'!mergeStacks	| otherStack |	otherStack := savedStacks at: pc.	savedStacks removeKey: pc.	stack isEmpty ifTrue: [		"This happens at the end of a block, or a short circuit conditional.  		In these cases, it is not possible for execution to 'fall through' to 		the merge point.  In other words, this is not a real merge point at all, 		and we just continue execution with the saved stack."		^ stack := otherStack ]. 	"self assert: [stack size = otherStack size].  This assertion was true for every	method in every subclass of Object, so I think that we can safely omit it!!"	1 to: stack size		do: [:i | ((stack at: i) ~~ #self					and: [(otherStack at: i) == #self])				ifTrue: [stack at: i put: #self]]! !!FixedIdentitySet methodsFor: 'accessing' stamp: 'NS 5/24/2005 10:46'!destructiveAdd: anObject	| index old |	self isFull ifTrue: [^ false].	index := self indexOf: anObject.	old := self basicAt: index.	self basicAt: index put: anObject.	old ifNil: [tally := tally + 1].	^ true! !!TUpdateTraitsBehavior methodsFor: 'traits' stamp: 'al 7/30/2004 21:48'!setTraitComposition: aTraitComposition	| oldComposition |	(self hasTraitComposition not and: [aTraitComposition isEmpty]) ifTrue: [^self].	aTraitComposition assertValidUser: self.	oldComposition := self traitComposition.	self traitComposition: aTraitComposition.	self applyChangesOfNewTraitCompositionReplacing: oldComposition.		oldComposition traits do: [:each | each removeUser: self].	aTraitComposition traits do: [:each | each addUser: self]! !!TPureBehavior methodsFor: 'accessing method dictionary' stamp: 'al 9/16/2005 14:50'!methodHeaderFor: selector 	"Answer the string corresponding to the method header for the given selector"	| sourceString parser |	sourceString := self ultimateSourceCodeAt: selector ifAbsent: [self standardMethodHeaderFor: selector].	(parser := self parserClass new) parseSelector: sourceString.	^ sourceString asString copyFrom: 1 to: (parser endOfLastToken min: sourceString size)	"Behavior methodHeaderFor: #methodHeaderFor: "! !!TFileInOutDescription methodsFor: 'fileIn/Out' stamp: 'md 2/22/2006 16:25'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble := self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble := ''].	method := self methodDict at: selector ifAbsent:		[outStream nextPutAll: selector; cr.		outStream tab; nextPutAll: '** ERROR!!  THIS SCRIPT IS MISSING ** ' translated; cr; cr.		outStream nextPutAll: '  '.		^ outStream].	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos := method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: method decompileString]		ifFalse:		[sourceFile := SourceFiles at: method fileIndex.		preamble size > 0			ifTrue:    "Copy the preamble"				[outStream copyPreamble: preamble from: sourceFile at: oldPos]			ifFalse:				[sourceFile position: oldPos].		"Copy the method chunk"		newPos := outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos := outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!FixedIdentitySet methodsFor: 'printing' stamp: 'NS 5/23/2005 18:32'!printOn: aStream	| count |	aStream nextPutAll: '#('.	count := 0.	self do: [:each | 		count := count + 1.		each printOn: aStream.		count < self size ifTrue: [aStream nextPut: $ ]	].	aStream nextPut: $).! !!Trait methodsFor: 'accessing' stamp: 'al 7/17/2004 14:16'!environment: anObject	environment := anObject! !!TCompilingBehavior methodsFor: 'compiling' stamp: 'al 7/30/2004 22:03'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method := oldClass compiledMethodAt: selector.	trailer := method trailer.	methodNode := self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self basicAddSelector: selector withMethod: (methodNode generate: trailer).! !!TTraitsCategorisingDescription methodsFor: 'organization updating' stamp: 'al 5/9/2004 14:00'!noteRecategorizedSelector: aSymbol from: oldCategoryOrNil to: newCategoryOrNil	| changedCategories |	changedCategories := self updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil.	changedCategories do: [:each |		(self organization isEmptyCategoryNamed: each) ifTrue: [self organization removeCategory: each]]! !!TCompilingBehavior methodsFor: 'private' stamp: 'al 12/1/2005 15:20'!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space method |	space := 0.	self selectorsDo: [:sel |		space := space + 16.  "dict and org'n space"		method := self compiledMethodAt: sel.		space := space + (method size + 6 "hdr + avg pad").		method literals do: [:lit |			(lit isMemberOf: Array) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space := space + 12].			(lit isMemberOf: ByteString) ifTrue: [space := space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space := space + ((lit size + 1) * 4)]]].		^ space! !!LocatedMethodTest methodsFor: 'running' stamp: 'al 1/23/2004 17:16'!testEquality	| locatedMethod1 locatedMethod2 |	locatedMethod1 := LocatedMethod location: self class selector: #testEquality.	locatedMethod2 := LocatedMethod location: self class selector: #testEquality.	self assert: locatedMethod1 = locatedMethod2.	self assert: locatedMethod1 hash = locatedMethod2 hash! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'dvf 9/12/2005 16:52'!findRootsAndRoutes	"Based on the 	1. target classes (ones considered interesting by our clients) and the 	2. modifiedBehaviors (ones we are told might have changed), 	decide the 	A. rootClasses (superclasses of target classes that include methods from modifiedBehaviors) 	B. classesToUpdate (classes that may have been affected AND are on an inheritance path between a root class and a target class, will be updated by the algorithm. This includes the every target class that may have been affected).	C. mapping from root classes to its classesToUpdate."	| highestSuperclassOfCurrentTarget modifiedClasses |	classesToUpdate := IdentitySet new.	rootClasses := IdentitySet new.	modifiedClasses := (modifiedBehaviors gather: [:mb | mb classesComposedWithMe]) asIdentitySet.	targetClasses do: [:currentTargetClass | 		highestSuperclassOfCurrentTarget := nil.		currentTargetClass withAllSuperclassesDo: [:sc | 			(modifiedClasses includes: sc) ifTrue: 				[highestSuperclassOfCurrentTarget := sc.				self noteRoot: sc possiblyAffected: currentTargetClass]].			highestSuperclassOfCurrentTarget ifNotNilDo: [:highestRoot | 				self addUpdatePathTo: currentTargetClass from: highestRoot]]! !!TimeMeasuringTest methodsFor: 'as yet unclassified' stamp: 'dvf 8/31/2005 15:09'!initialize	shouldProfile := false.! !!SendInfo methodsFor: 'private' stamp: 'NS 5/23/2005 11:01'!addClassSentSelector: aSymbol	classSentSelectors ifNil: [classSentSelectors := IdentitySet new].	classSentSelectors add: aSymbol.! !!TPureBehavior methodsFor: 'printing' stamp: 'al 12/1/2005 15:37'!storeLiteral: aCodeLiteral on: aStream	"Store aCodeLiteral on aStream, changing an Association to ##GlobalName	 or ###MetaclassSoleInstanceName format if appropriate"	| key value |	(aCodeLiteral isVariableBinding)		ifFalse:			[aCodeLiteral storeOn: aStream.			 ^self].	key := aCodeLiteral key.	(key isNil and: [(value := aCodeLiteral value) isMemberOf: Metaclass])		ifTrue:			[aStream nextPutAll: '###'; nextPutAll: value soleInstance name.			 ^self].	(key isSymbol and: [(self bindingOf: key) notNil])		ifTrue:			[aStream nextPutAll: '##'; nextPutAll: key.			 ^self].	aCodeLiteral storeOn: aStream! !!TBasicCategorisingDescription methodsFor: 'accessing method dictionary' stamp: 'al 5/8/2004 19:50'!removeCategory: aString 	"Remove each of the messages categorized under aString in the method 	dictionary of the receiver. Then remove the category aString."	| categoryName |	categoryName := aString asSymbol.	(self organization listAtCategoryNamed: categoryName) do:		[:sel | self removeSelector: sel].	self organization removeCategory: categoryName! !!Trait methodsFor: 'private' stamp: 'al 7/17/2004 14:16'!applyChangesOfNewTraitCompositionReplacing: oldComposition	"Duplicated on Class"		| changedSelectors |	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.	self classSide		noteNewBaseTraitCompositionApplied: self traitComposition.	^ changedSelectors! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'al 7/25/2004 21:39'!requiredMethod	| templateMethod argumentNames numberOfArguments binary |	self isRequired ifFalse: [^nil].	self size = 1 ifTrue: [^self locatedMethods anyOne method].		argumentNames := self getArgumentNames.	binary := self isBinarySelector.	numberOfArguments := binary		ifTrue: [1]		ifFalse: [argumentNames size + 2].	templateMethod := self requiredMethodForArguments: numberOfArguments ifAbsentPut: [		self			generateTemplateMethodWithMarker: CompiledMethod implicitRequirementMarker			forArgs: argumentNames size			binary: binary].	^templateMethod copyWithTempNames: argumentNames		 ! !!TTraitsCategorisingDescription methodsFor: 'organization updating' stamp: 'al 3/27/2006 10:21'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories := IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel := each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory := self organization categoryOfElement: sel.			effectiveCategory := each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TraitAlias methodsFor: 'accessing' stamp: 'al 3/17/2004 15:22'!aliases: anArrayOfAssociations	| newNames |	newNames := (anArrayOfAssociations collect: [:each | each key]) asIdentitySet.	newNames size < anArrayOfAssociations size ifTrue: [		TraitCompositionException signal: 'Cannot use the same alias name twice'].	anArrayOfAssociations do: [:each |		(newNames includes: each value) ifTrue: [			TraitCompositionException signal: 'Cannot define an alias for an alias']].	aliases := anArrayOfAssociations! !!TApplyingOnClassSide methodsFor: 'composition' stamp: 'al 7/30/2004 09:07'!assertConsistantCompositionsForNew: aTraitComposition	"Applying or modifying a trait composition on the class side	of a behavior has some restrictions."	| baseTraits notAddable message |	baseTraits := aTraitComposition traits select: [:each | each isBaseTrait].	baseTraits isEmpty ifFalse: [		notAddable := (baseTraits reject: [:each | each classSide methodDict isEmpty]).		notAddable isEmpty ifFalse: [			message := String streamContents: [:stream |				stream nextPutAll: 'You can not add the base trait(s)'; cr.				notAddable					do: [:each | stream nextPutAll: each name]					separatedBy: [ stream nextPutAll: ', '].				stream cr; nextPutAll: 'to this composition because it/they define(s) methods on the class side.'].		^TraitCompositionException signal: message]].			(self instanceSide traitComposition traits asSet =			(aTraitComposition traits				select: [:each | each isClassTrait]				thenCollect: [:each | each baseTrait]) asSet) ifFalse: [				^TraitCompositionException signal: 'You can not add or remove class side traits on				the class side of a composition. (But you can specify aliases or exclusions				for existing traits or add a trait which does not have any methods on the class side.)']! !!TCompilingBehavior methodsFor: 'accessing method dictionary' stamp: 'al 7/30/2004 21:03'!selectorsWithArgs: numberOfArgs	"Return all selectors defined in this class that take this number of arguments.  Could use String.keywords.  Could see how compiler does this."	| list num |	list := OrderedCollection new.	self selectorsDo: [:aSel | 		num := aSel count: [:char | char == $:].		num = 0 ifTrue: [aSel last isLetter ifFalse: [num := 1]].		num = numberOfArgs ifTrue: [list add: aSel]].	^ list! !!TraitExclusion methodsFor: 'enquiries' stamp: 'al 3/7/2004 22:48'!allSelectors	| selectors |	selectors := self subject allSelectors.	self exclusions do: [:each |		selectors remove: each ifAbsent: []].	^selectors! !!TUpdateTraitsBehavior methodsFor: 'traits' stamp: 'al 7/30/2004 21:39'!applyChangesOfNewTraitCompositionReplacing: oldComposition	| changedSelectors |	changedSelectors := self traitComposition		changedSelectorsComparedTo: oldComposition.	changedSelectors isEmpty ifFalse: [		self noteChangedSelectors: changedSelectors].	self traitComposition isEmpty ifTrue: [		self purgeLocalSelectors].	^changedSelectors! !!TraitComposition methodsFor: 'testing' stamp: 'al 4/10/2004 23:34'!isLocalAliasSelector: aSymbol	"Return true if the selector aSymbol is an alias defined	in this composition."	| methodDescription |	methodDescription := (self methodDescriptionsForSelector: aSymbol)		detect: [:each | each selector = aSymbol].	^methodDescription isLocalAliasSelector! !!TraitBehavior methodsFor: 'compiling' stamp: 'al 7/30/2004 22:03'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method := oldClass compiledMethodAt: selector.	trailer := method trailer.	methodNode := self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self basicAddSelector: selector withMethod: (methodNode generate: trailer).! !!TCompilingDescription methodsFor: 'compiling' stamp: 'al 5/8/2004 20:00'!compile: text classified: category notifying: requestor	| stamp |	stamp := self acceptsLoggingOfCompilation ifTrue: [Utilities changeStamp] ifFalse: [nil].	^ self compile: text classified: category		withStamp: stamp notifying: requestor! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'al 7/21/2004 21:17'!providedLocatedMethod	| locatedMethod |	locatedMethod := nil.	self locatedMethods do: [:each |		each method isProvided ifTrue: [			locatedMethod isNil ifFalse: [^nil].			locatedMethod := each]].	^locatedMethod! !!Behavior methodsFor: '*Traits-requires' stamp: 'NS 5/24/2005 16:38'!translateReachableSelfSenders: senderCollection translations: translationDictionary	| result superSenders |	(translationDictionary isEmptyOrNil or: [senderCollection isEmpty]) ifTrue: [^ senderCollection].	result := FixedIdentitySet new.	senderCollection do: [:s |		superSenders := translationDictionary at: s ifAbsent: [nil].		superSenders isNil			ifTrue: [result add: s]			ifFalse: [result addAll: superSenders].		result isFull ifTrue: [^ result].	].	^ result.! !!FixedIdentitySet class methodsFor: 'instance creation' stamp: 'NS 5/26/2005 13:05'!readonlyWithAll: aCollection notIn: notCollection	"For performance reasons, this method may return an array rather than a FixedIdentitySet. 	Therefore it should only be used if the return value does not need to be modified.	Use #withAll:notIn: if the return value might need to be modified."	| size |	aCollection isEmpty ifTrue: [^ #()].	size := aCollection size = 1 		ifTrue: [1]		ifFalse: [self sizeFor: aCollection].	^ (self new: size) addAll: aCollection notIn: notCollection; yourself! !!TraitDescription methodsFor: 'as yet unclassified' stamp: 'ar 7/19/2009 23:47'!variablesAndOffsetsDo: aBinaryBlock	"This is the interface between the compiler and a class's instance or field names.  The	 class should enumerate aBinaryBlock with the field definitions (with nil offsets) followed	 by the instance variable name strings and their integer offsets (1-relative).  The order is	 important; names evaluated later will override the same names occurring earlier."	"Since Traits don't confer state there is nothing to do here."! !!TAccessingMethodDictDescription methodsFor: 'accessing method dictionary' stamp: 'al 5/8/2004 20:36'!addAndClassifySelector: selector withMethod: compiledMethod inProtocol: category notifying: requestor	| priorMethodOrNil |	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [nil].	self addSelectorSilently: selector withMethod: compiledMethod.	SystemChangeNotifier uniqueInstance 		doSilently: [self organization classify: selector under: category].	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inProtocol: category class: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: self requestor: requestor].! !!TFileInOutDescription methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 17:13'!fileOutCategory: catName asHtml: useHtml	"FileOut the named category, possibly in Html format."	| internalStream |	internalStream := WriteStream on: (String new: 1000).	internalStream header; timeStamp.	self fileOutCategory: catName on: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: (self name , '-' , catName) isSt: true useHtml: useHtml.! !!TCompilingBehavior methodsFor: 'testing method dictionary' stamp: 'al 7/30/2004 22:37'!whichSelectorsReferTo: literal 	"Answer a Set of selectors whose methods access the argument as aliteral."	| special byte |	special := self environment hasSpecialSelector: literal ifTrueSetByte: [:b |byte := b].	^self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."! !!TCompilingBehavior methodsFor: 'compiling' stamp: 'al 7/30/2004 22:17'!recompileNonResidentMethod: method atSelector: selector from: oldClass	"Recompile the method supplied in the context of this class."	| trailer methodNode |	trailer := method trailer.	methodNode := self compilerClass new			compile: (method getSourceFor: selector in: oldClass)			in: self			notifying: nil			ifFail: ["We're in deep doo-doo if this fails (syntax error).				Presumably the user will correct something and proceed,				thus installing the result in this methodDict.  We must				retrieve that new method, and restore the original (or remove)				and then return the method we retrieved."				^ self error: 'see comment'].	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ methodNode generate: trailer! !!TraitAlias methodsFor: 'enquiries' stamp: 'al 3/12/2004 17:10'!aliasesForSelector: aSymbol	| selectors |	selectors := self aliases		select: [:association | association value = aSymbol]		thenCollect: [:association | association key].	^(super aliasesForSelector: aSymbol)		addAll: selectors;		yourself		 ! !!TAccessingMethodDictDescription methodsFor: 'accessing method dictionary' stamp: 'al 5/8/2004 20:33'!addSelector: selector withMethod: compiledMethod notifying: requestor	| priorMethodOrNil |	priorMethodOrNil := self compiledMethodAt: selector ifAbsent: [nil].	self addSelectorSilently: selector withMethod: compiledMethod.	priorMethodOrNil isNil		ifTrue: [SystemChangeNotifier uniqueInstance methodAdded: compiledMethod selector: selector inClass: self requestor: requestor]		ifFalse: [SystemChangeNotifier uniqueInstance methodChangedFrom: priorMethodOrNil to: compiledMethod selector: selector inClass: self requestor: requestor].! !!TraitComposition methodsFor: 'enquiries' stamp: 'al 7/21/2004 21:03'!methodDescriptionsForSelector: aSymbol	"Return a collection of TraitMethodDescriptions for aSymbol and all the 	aliases of aSymbol."	| selectors collection |	selectors := IdentitySet with: aSymbol.	self transformations do: [:each |		selectors addAll: (each aliasesForSelector: aSymbol)].	collection := OrderedCollection new: selectors size.	selectors do: [:each |		collection add: (self methodDescriptionForSelector: each)].	^collection! !!TAccessingMethodDictDescription methodsFor: 'accessing method dictionary' stamp: 'al 5/8/2004 20:49'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."		| priorMethod priorProtocol | 	priorMethod := self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol := self whichCategoryIncludesSelector: selector.	super removeSelector: selector.	SystemChangeNotifier uniqueInstance 		doSilently: [self updateOrganizationSelector: selector oldCategory: priorProtocol newCategory: nil].	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!TraitMethodDescriptionTest methodsFor: 'running' stamp: 'al 1/23/2004 12:57'!testInitialize	| empty |	empty := TraitMethodDescription new.	self assert: empty isEmpty.	self deny: empty isConflict.	self deny: empty isProvided.	self deny: empty isRequired! !!FixedIdentitySet methodsFor: 'accessing' stamp: 'NS 5/24/2005 13:12'!remove: anObject ifAbsent: aBlock	| index |	index := self indexOf: anObject.	^ (self basicAt: index) == anObject 		ifTrue: [self basicAt: index put: nil. tally := tally - 1. anObject]		ifFalse: [aBlock value].! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'al 7/22/2004 14:50'!effectiveMethodCategoryCurrent: currentCategoryOrNil new: newCategoryOrNil	| isCurrent result cat size isConflict |	size := self size.	size = 0 ifTrue: [^ nil].	result := self locatedMethods anyOne category.	size = 1 ifTrue: [^ result].		isCurrent := currentCategoryOrNil isNil.	isConflict := false.	self locatedMethods do: [:each |		cat := each category.		isCurrent := isCurrent or: [cat == currentCategoryOrNil].		isConflict := isConflict or: [cat ~~ result]].	isConflict ifFalse: [^ result].	(isCurrent not and: [newCategoryOrNil notNil]) ifTrue: [^ newCategoryOrNil].	^ ClassOrganizer ambiguous.! !!TraitExclusion methodsFor: 'accessing' stamp: 'al 12/7/2003 11:58'!exclusions: aCollection	exclusions := aCollection! !!TraitBehavior methodsFor: 'accessing method dictionary' stamp: 'NS 3/30/2004 13:26'!basicLocalSelectors: aSetOrNil	localSelectors := aSetOrNil! !!TFileInOutDescription methodsFor: 'fileIn/Out' stamp: 'al 5/9/2004 18:51'!fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors := (aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	selectors := selectors select: [:each | self includesLocalSelector: each].		"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!TPureBehavior methodsFor: 'copying' stamp: 'al 9/16/2005 14:19'!copy	"Answer a copy of the receiver without a list of subclasses."	| myCopy |	myCopy := self shallowCopy.	^myCopy methodDictionary: self copyOfMethodDictionary! !!TraitCompositionTest methodsFor: 'testing-basic' stamp: 'al 12/15/2003 20:51'!testEmptyTrait	| composition |	composition := {} asTraitComposition.		self assert: (composition isKindOf: TraitComposition).	self assert: composition transformations isEmpty.	self assert: composition traits isEmpty! !!TimeMeasuringTest methodsFor: 'as yet unclassified' stamp: 'dvf 8/31/2005 15:13'!setToDebug	shouldProfile := true! !!ClassTrait methodsFor: 'initialize' stamp: 'al 7/17/2004 22:56'!traitComposition: aComposition methodDict: aMethodDict localSelectors: aSet organization: aClassOrganization	"Used by copy of Trait"	localSelectors := aSet.	methodDict := aMethodDict.	traitComposition := aComposition.	self organization: aClassOrganization! !!TCompilingBehavior methodsFor: 'testing method dictionary' stamp: 'md 2/15/2006 11:01'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "	| who |	who := IdentitySet new.	self selectorsAndMethodsDo:		[:sel :method |		((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isVariableBinding) not					or: [method literals allButLast includes: literal])						ifTrue: [who add: sel]]].	^ who! !!SendCaches methodsFor: 'updates' stamp: 'apb 3/2/2006 23:29'!addClassSender: sendingSelector of: sentSelector	| senders |	senders := classSenders at: sentSelector ifAbsent: [#()].	classSenders at: sentSelector put: (senders copyWith: sendingSelector).! !!Behavior methodsFor: '*Traits-requires' stamp: 'NS 5/26/2005 14:11'!computeTranslationsAndUpdateUnreachableSet: unreachableCollection	"This method computes the set of unreachable selectors in the superclass by altering the set of unreachable selectors in this class. In addition, it builds a dictionary mapping super-sent selectors to the selectors of methods sending these selectors."	| translations reachableSenders oldUnreachable |	oldUnreachable := unreachableCollection copy.	translations := IdentityDictionary new.	"Add selectors implemented in this class to unreachable set."	self methodDict keysDo: [:s | unreachableCollection add: s].		"Fill translation dictionary and remove super-reachable selectors from unreachable."	self sendCaches superSentSelectorsAndSendersDo: [:sent :senders |		reachableSenders := FixedIdentitySet readonlyWithAll: senders notIn: oldUnreachable.		reachableSenders isEmpty ifFalse: [			translations at: sent put: reachableSenders.			unreachableCollection remove: sent ifAbsent: [].		].	].	^ translations! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'dvf 9/9/2005 20:48'!findOriginalSins	| sinnedSelectors sinners checkedClasses |	checkedClasses := IdentitySet new.	originalSinsPerSelector := IdentityDictionary new.	rootClasses do: 			[:rootClass | 			rootClass withAllSuperclassesDo: [:superClass | 				(checkedClasses includes: superClass) ifFalse: [					checkedClasses add: superClass.					sinnedSelectors := self sinsIn: superClass.					sinnedSelectors do: 							[:sinSel | 							sinners := originalSinsPerSelector at: sinSel										ifAbsentPut: [IdentitySet new].							sinners add: superClass]]]]! !!TAccessingTraitCompositionBehavior methodsFor: 'traits' stamp: 'al 7/30/2004 21:55'!traitsProvidingSelector: aSymbol	| result |	result := OrderedCollection new.	self hasTraitComposition ifFalse: [^result].	(self traitComposition methodDescriptionsForSelector: aSymbol)		do: [:methodDescription | methodDescription selector = aSymbol ifTrue: [			result addAll: (methodDescription locatedMethods				collect: [:each | each location])]].	^result! !!RequiredSelectors methodsFor: 'accessing' stamp: 'dvf 9/8/2005 18:46'!newlyInterestingClasses	newlyInterestingClasses ifNil: [newlyInterestingClasses := IdentitySet new].	^newlyInterestingClasses! !!TraitBehavior methodsFor: 'accessing method dictionary' stamp: 'al 2/8/2004 19:08'!zapAllMethods	"Remove all methods in this trait which is assumed to be obsolete"	methodDict := MethodDictionary new.	self hasClassTrait ifTrue: [self classTrait zapAllMethods]! !!TCommentDescription methodsFor: 'accessing comment' stamp: 'al 5/9/2004 17:09'!hasComment	"return whether this class truly has a comment other than the default"	| org |	org := self instanceSide organization.	^org classComment isEmptyOrNil not! !!TraitComposition methodsFor: 'copying' stamp: 'al 12/7/2005 20:50'!copyWithoutAlias: aSymbol of: aTrait	| composition transformation |	composition := self copyTraitExpression.	transformation := (composition transformationOfTrait: aTrait).	^composition		remove: transformation;		add: (transformation removeAlias: aSymbol);		normalizeTransformations;		yourself! !!SendInfo methodsFor: 'initialization' stamp: 'NS 5/23/2005 11:12'!prepareState	| nrsArray |	self newEmptyStack.	savedStacks := QuickIntegerDictionary new: (sender endPC).	isStartOfBlock := false.	nrsArray := self class neverRequiredSelectors.	self assert:[nrsArray size = 5] because: 'Size of neverRequiredSelectors has been changed; re-optimize (by hand) #tallySelfSendsFor:'.	nr1 := nrsArray at: 1.	nr2 := nrsArray at: 2.	nr3 := nrsArray at: 3.	nr4 := nrsArray at: 4.	nr5 := nrsArray at: 5.! !!ClassTrait methodsFor: 'accessing parallel hierarchy' stamp: 'al 3/16/2004 10:48'!baseTrait: aTrait	self assert: aTrait isBaseTrait.	baseTrait := aTrait		! !!TCompilingBehavior methodsFor: 'adding/removing methods' stamp: 'md 2/18/2006 20:07'!basicAddSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary.	Do this without sending system change notifications"	| oldMethodOrNil |	oldMethodOrNil := self lookupSelector: selector.	self methodDict at: selector put: compiledMethod.	compiledMethod methodClass: self.	compiledMethod selector: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethodOrNil == nil ifFalse: [oldMethodOrNil flushCache].	selector flushCache.! !!TCompilingBehavior methodsFor: 'accessing method dictionary' stamp: 'al 11/28/2005 21:54'!firstPrecodeCommentFor:  selector	"If there is a comment in the source code at the given selector that preceeds the body of the method, return it here, else return nil"	| parser source tree |	"Behavior firstPrecodeCommentFor: #firstPrecodeCommentFor:"	(#(Comment Definition Hierarchy) includes: selector)		ifTrue:			["Not really a selector"			^ nil].	source := self sourceCodeAt: selector asSymbol ifAbsent: [^ nil].	parser := self parserClass new.	tree := 		parser			parse: (ReadStream on: source)			class: self			noPattern: false			context: nil			notifying: nil			ifFail: [^ nil].	^ (tree comment ifNil: [^ nil]) first! !!SendInfo methodsFor: 'private' stamp: 'NS 5/23/2005 11:15'!addSuperSentSelector: aSymbol	superSentSelectors ifNil: [superSentSelectors := IdentitySet new].	superSentSelectors add: aSymbol.! !!SendsInfoTest methodsFor: 'test subjects' stamp: 'apb 3/2/2006 23:55'!clip		"This method is never run. It is here just so that the sends in it can be	tallied by the SendInfo interpreter."	| temp |	self printString.	temp := self.	temp error: 4 + 5! !!TraitMethodDescription methodsFor: 'initialize-release' stamp: 'NS 3/30/2004 16:12'!initialize	super initialize.	locatedMethods := Set new! !!QuickStack methodsFor: 'private' stamp: 'apb 8/30/2003 11:55'!setTop: t	top := t! !!TraitTransformation methodsFor: 'enquiries' stamp: 'NS 4/16/2004 14:20'!changedSelectorsComparedTo: aTraitTransformation	| selectors otherSelectors changedSelectors aliases otherAliases |	selectors := self allSelectors asIdentitySet.	otherSelectors := aTraitTransformation allSelectors asIdentitySet.	changedSelectors := IdentitySet withAll: (		(selectors difference: otherSelectors) union: (otherSelectors difference: selectors)).	aliases := self allAliasesDict.	otherAliases := aTraitTransformation allAliasesDict.	aliases keysAndValuesDo: [:key :value |		(value ~~ (otherAliases at: key ifAbsent: [nil])) ifTrue: [changedSelectors add: key]].	otherAliases keysAndValuesDo: [:key :value |		(value ~~ (aliases at: key ifAbsent: [nil])) ifTrue: [changedSelectors add: key]].	^ changedSelectors.! !!TraitBehavior methodsFor: 'traits' stamp: 'NS 12/11/2003 16:35'!traitComposition: aTraitComposition	traitComposition := aTraitComposition! !!QuickStack methodsFor: 'accessing' stamp: 'apb 9/7/2004 10:25'!becomeEmpty	top := 0! !!Trait methodsFor: 'private' stamp: 'al 7/17/2004 14:16'!rename: aString 	"The new name of the receiver is the argument, aString."	| newName |	(newName := aString asSymbol) ~= self name		ifFalse: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	self environment renameClass: self as: newName.	name := newName! !!FixedIdentitySet methodsFor: 'enumerating' stamp: 'NS 5/24/2005 13:52'!select: aBlock	| result |	result := self species new: self capacity.	self do: [:each | (aBlock value: each) ifTrue: [result add: each]].	^ result.! !!SendInfo methodsFor: 'instruction decoding' stamp: 'NS 5/23/2005 11:01'!send: selector super: superFlag numArgs: numArgs 	"Simulate the action of bytecodes that send a message with  	selector. superFlag, tells whether the receiver of the  	message was 'super' in the source. The arguments  	of the message are found in the top numArgs locations on the  	stack and the receiver just below them."	| stackTop |	selector == #blockCopy:		ifTrue: ["self assert: [numArgs = 1]."			isStartOfBlock := true.			numBlockArgs := self pop.			^ self].	self pop: numArgs.	stackTop := self pop.	superFlag		ifTrue: [self addSuperSentSelector: selector]		ifFalse: [stackTop == #self				ifTrue: [self tallySelfSendsFor: selector].			stackTop == #class				ifTrue: [self addClassSentSelector: selector]].	self		push: ((selector == #class and: [stackTop == #self])				ifTrue: [#class]				ifFalse: [#stuff])! !!TraitBehavior methodsFor: 'accessing method dictionary' stamp: 'NS 12/9/2003 10:50'!methodDict: aDictionary	methodDict := aDictionary! !!SendCaches methodsFor: 'updates' stamp: 'apb 3/2/2006 23:28'!addSuperSender: sendingSelector of: sentSelector	| senders |	senders := superSenders at: sentSelector ifAbsent: [#()].	superSenders at: sentSelector put: (senders copyWith: sendingSelector).! !!TraitBehavior methodsFor: 'traits' stamp: 'al 12/12/2003 21:42'!traitComposition	traitComposition ifNil: [traitComposition := TraitComposition new].	^traitComposition! !!ClassTrait methodsFor: 'compiling' stamp: 'al 4/7/2004 14:54'!compile: text classified: category withStamp: changeStamp notifying: requestor logSource: logSource		| classSideUsersOfBaseTrait message |	classSideUsersOfBaseTrait := self baseTrait users select: [:each | each isClassSide].	classSideUsersOfBaseTrait isEmpty ifFalse: [		message := String streamContents: [:stream |			stream nextPutAll: 'The instance side of this trait is used on '; cr.			classSideUsersOfBaseTrait				do: [:each | stream nextPutAll: each name]				separatedBy: [ stream nextPutAll: ', '].			stream cr; nextPutAll: ' You can not add methods to the class side of this trait!!'].		^TraitException signal:  message].		^super		compile: text		classified: category		withStamp: changeStamp		notifying: requestor		logSource: logSource! !!SendInfo methodsFor: 'private' stamp: 'NS 5/23/2005 11:15'!addSelfSentSelector: aSymbol	selfSentSelectors ifNil: [selfSentSelectors := IdentitySet new].	selfSentSelectors add: aSymbol.! !!TraitAlias methodsFor: 'enquiries' stamp: 'al 7/13/2004 16:53'!allAliasesDict	| dict |	dict := super allAliasesDict.	self aliases do: [:assoc |		dict at: assoc key put: assoc value].	^dict! !!ClassTrait methodsFor: 'initialize' stamp: 'dvf 8/30/2005 16:48'!initializeFrom: anotherClassTrait	traitComposition := self traitComposition copyTraitExpression.	methodDict := self methodDict copy.	localSelectors := self localSelectors copy.	organization := self organization copy.! !!TraitFileOutTest methodsFor: 'running' stamp: 'al 4/25/2004 13:26'!setUp	super setUp.	SystemOrganization addCategory: self categoryName.		td := self createTraitNamed: #TD uses: {}.			td compile: 'd' classified: #cat1.	tc := self createTraitNamed: #TC uses: td.			tc compile: 'c' classified: #cat1.	tb := self createTraitNamed: #TB uses: td.			tb compile: 'b' classified: #cat1.	ta := self createTraitNamed: #TA uses: tb + tc @ {#cc->#c} - {#c}.	ta compile: 'a' classified: #cat1.		ca := self createClassNamed: #CA superclass: Object uses: {}.	ca compile: 'ca' classified: #cat1.	cb := self createClassNamed: #CB superclass: ca uses: ta.	cb compile: 'cb' classified: #cat1.		"make the class of cb also use tc:"	cb class uses: ta classTrait + tc instanceVariableNames: ''.! !!TraitComposition methodsFor: 'initialize-release' stamp: 'al 3/12/2004 17:06'!initialize	super initialize.	transformations := OrderedCollection new! !!TraitComposition methodsFor: 'copying' stamp: 'apb 8/24/2005 13:49'!copyTraitExpression	| newCopy |	newCopy := self shallowCopy.	newCopy transformations: (self transformations collect: [ : each | each copyTraitExpression ]).	^ newCopy! !!Trait class methodsFor: 'instance creation' stamp: 'al 3/18/2006 13:48'!named: aSymbol uses: aTraitCompositionOrCollection category: aString env: anEnvironment	| trait oldTrait systemCategory |	systemCategory := aString asSymbol.	trait := anEnvironment		at: aSymbol		ifAbsent: [nil].	oldTrait := trait copy.	trait := trait ifNil: [super new].		(trait isKindOf: Trait) ifFalse: [		^self error: trait name , ' is not a Trait'].	trait		setName: aSymbol		andRegisterInCategory: systemCategory		environment: anEnvironment.			trait setTraitComposition: aTraitCompositionOrCollection asTraitComposition.		"... notify interested clients ..."	oldTrait isNil ifTrue: [		SystemChangeNotifier uniqueInstance classAdded: trait inCategory: systemCategory.		^ trait].	SystemChangeNotifier uniqueInstance traitDefinitionChangedFrom: oldTrait to: trait.	systemCategory ~= oldTrait category 		ifTrue: [SystemChangeNotifier uniqueInstance class: trait recategorizedFrom: oldTrait category to: systemCategory].			^ trait! !!TraitFileOutTest methodsFor: 'testing' stamp: 'al 7/19/2004 20:50'!testFileOutCategory	"File out whole system category, delete all classes and traits and then	file them in again."	"self run: #testFileOutCategory"	| file |	SystemOrganization fileOutCategory: self categoryName.	SystemOrganization removeSystemCategory: self categoryName.	self deny: (Smalltalk keys includesAnyOf: #(CA CB TA TB TC TD)).	[	file := FileStream readOnlyFileNamed: self categoryName , '.st'.		file fileIn]		ensure: [file close].	self assert: (Smalltalk keys includesAllOf: #(CA CB TA TB TC TD)).	ta := Smalltalk at: #TA.	self assert: ta traitComposition asString = 'TB + TC @ {#cc->#c} - {#c}'.	self assert: (ta methodDict keys includesAllOf: #(a b cc)).	cb := Smalltalk at: #CB.	self assert: cb traitComposition asString = 'TA'.	self assert: (cb methodDict keys includesAllOf: #(cb a b cc)).	"test classSide traitComposition of CB"	self assert: cb classSide traitComposition asString =  'TA classTrait + TC'.	self assert: (cb classSide methodDict keys includesAllOf: #(d c))	! !!Trait methodsFor: 'fileIn/Out' stamp: 'al 12/1/2005 16:06'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| internalStream |	internalStream := WriteStream on: (String new: 100).	internalStream header; timeStamp.	self fileOutOn: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true useHtml: useHtml.! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/14/2005 17:02'!noteInterestOf: client inAll: classes 	| newlyInteresting |	LocalSends current noteInterestOf: self		inAll: (classes gather: [:cl | cl withAllSuperclasses]).	ProvidedSelectors current noteInterestOf: self		inAll: (classes gather: [:cl | cl withAllSuperclasses]).	newlyInteresting := classes copyWithoutAll: self classesOfInterest.	super noteInterestOf: client inAll: classes.	newlyInteresting do: [:cl | self newlyInteresting: cl]! !!TraitMethodDescription methodsFor: 'private' stamp: 'al 3/12/2004 17:04'!getArgumentNames	| argumentNamesCollection names defaultName |	defaultName := 'arg'.	argumentNamesCollection := self locatedMethods		collect: [:each | each argumentNames ].	names := Array new: argumentNamesCollection anyOne size.	argumentNamesCollection do: [:collection |		1 to: names size do: [:index |			(names at: index) isNil				ifTrue: [names at: index put: (collection at: index)]				ifFalse: [(names at: index) ~= (collection at: index)					ifTrue: [names at: index put: defaultName, index asString]]]].	^names		! !!TimeMeasuringTest methodsFor: 'as yet unclassified' stamp: 'dvf 8/31/2005 15:09'!openDebuggerOnFailingTestMethod	shouldProfile := true! !!TraitComposition methodsFor: 'copying' stamp: 'al 12/7/2005 20:49'!copyWithExclusionOf: aSymbol to: aTrait	| composition transformation |	composition := self copyTraitExpression.	transformation := (composition transformationOfTrait: aTrait).	^composition		remove: transformation;		add: (transformation addExclusionOf: aSymbol);		yourself! !!FixedIdentitySet methodsFor: 'initialize-release' stamp: 'NS 5/23/2005 17:39'!initializeCapacity: anInteger	tally := 0.	capacity := anInteger.! !!SendInfo class methodsFor: 'accessing' stamp: 'NS 5/23/2005 10:53'!neverRequiredSelectors	| nrs |	nrs := Array new: 5.	nrs at: 1 put: CompiledMethod conflictMarker.	nrs at: 2 put: CompiledMethod disabledMarker.	nrs at: 3 put: CompiledMethod explicitRequirementMarker.	nrs at: 4 put: CompiledMethod implicitRequirementMarker.	nrs at: 5 put: CompiledMethod subclassResponsibilityMarker.	^ nrs.! !!FixedIdentitySet methodsFor: 'comparing' stamp: 'NS 5/24/2005 08:56'!hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| hash |	hash := self species hash.	self size <= 10 ifTrue:		[self do: [:elem | hash := hash bitXor: elem hash]].	^hash bitXor: self size hash! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'al 7/25/2004 21:21'!conflictMethod	| templateMethod argumentNames binary numberOfArguments |	self isConflict ifFalse: [^nil].	argumentNames := self getArgumentNames.	binary := self isBinarySelector.	numberOfArguments := binary		ifTrue: [1]		ifFalse: [argumentNames size + 2].	templateMethod := self conflictMethodForArguments: numberOfArguments ifAbsentPut: [		self			generateTemplateMethodWithMarker: CompiledMethod conflictMarker			forArgs: argumentNames size			binary: binary].	^templateMethod copyWithTempNames: argumentNames		 ! !!TPureBehavior methodsFor: 'printing' stamp: 'al 12/1/2005 15:25'!literalScannedAs: scannedLiteral notifying: requestor	"Postprocesses a literal scanned by Scanner scanToken (esp. xLitQuote).	If scannedLiteral is not an association, answer it.	Else, if it is of the form:		nil->#NameOfMetaclass	answer nil->theMetaclass, if any has that name, else report an error.	Else, if it is of the form:		#NameOfGlobalVariable->anythiEng	answer the global, class, or pool association with that nameE, if any, else	add it to Undeclared a answer the new Association."	| key value |	(scannedLiteral isVariableBinding)		ifFalse: [^ scannedLiteral].	key := scannedLiteral key.	value := scannedLiteral value.	key isNil 		ifTrue: "###<metaclass soleInstance name>"			[(self bindingOf: value) ifNotNilDo:[:assoc|				 (assoc value isKindOf: Behavior)					ifTrue: [^ nil->assoc value class]].			 requestor notify: 'No such metaclass'.			 ^false].	(key isSymbol)		ifTrue: "##<global var name>"			[(self bindingOf: key) ifNotNilDo:[:assoc | ^assoc].			Undeclared at: key put: nil.			 ^Undeclared bindingOf: key].	requestor notify: '## must be followed by a non-local variable name'.	^false"	Form literalScannedAs: 14 notifying: nil 14	Form literalScannedAs: #OneBitForm notiEfying: nil  OneBitForm	Form literalScannedAs: ##OneBitForm notifying: nil  OneBitForm->a Form	Form literalScannedAs: ##Form notifying: nil   Form->Form	Form literalScannedAs: ###Form notifying: nil   nilE->Form class"! !!QuickStack methodsFor: 'accessing' stamp: 'apb 8/30/2003 18:09'!addLast: aValue	top = self basicSize ifTrue: [self grow].	top := top + 1.	^ self at: top put: aValue! !!TCompilingBehavior methodsFor: 'adding/removing methods' stamp: 'al 7/30/2004 22:43'!basicRemoveSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	oldMethod := self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache! !!TraitDescription methodsFor: 'accessing method dictionary' stamp: 'al 6/29/2004 21:42'!allMethodsInCategory: aName 	"Answer a list of all the method categories of the receiver"		| aColl |	aColl := aName = ClassOrganizer allCategory		ifTrue: [self organization allMethodSelectors]		ifFalse: [self organization listAtCategoryNamed: aName].	^aColl asSet asSortedArray	"TileMorph allMethodsInCategory: #initialization"! !!TraitBehavior methodsFor: 'send caches' stamp: 'dvf 9/6/2005 14:12'!requiredSelectors	| sss selfSentNotProvided otherRequired |	sss := self selfSentSelectorsFromSelectors: self allSelectors.	selfSentNotProvided := sss copyWithoutAll: (self allSelectors select: [:e | (self >> e) isProvided]).	otherRequired := self allSelectors select: [:e | (self >> e) isRequired].	^(selfSentNotProvided, otherRequired) asSet! !!TraitComposition methodsFor: 'enquiries' stamp: 'al 7/21/2004 21:03'!methodDescriptionForSelector: aSymbol	"Return a TraitMethodDescription for the selector aSymbol."	| description |	description := TraitMethodDescription selector: aSymbol.	self transformations do: [:each |		each collectMethodsFor: aSymbol into: description].	^description! !!TraitMethodDescription methodsFor: 'testing' stamp: 'al 1/23/2004 10:30'!isConflict	| count |	count := 0.	self methodsDo: [:each |		each isProvided ifTrue: [			count := count + 1.			count > 1 ifTrue: [^true]]].	^false! !Trait removeSelector: #variablesAndOffsetsDo:!TraitMethodDescription initialize!