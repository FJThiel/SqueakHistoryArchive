"Change Set:		8963Collections-ar.289Collections-ar.289:Complete Set with nil support by providing proper modifications to KeyedSet and WeakSet."!!WeakSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:32'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils and flag to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	tally := 0.	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :object |			object == flag ifFalse: [ 				array					at: (self scanForEmptySlotFor: object enclosedSetElement)					put: object.				tally := tally + 1 ] ] ]! !!KeyedIdentitySet methodsFor: 'private' stamp: 'ar 2/1/2010 21:19'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject scaledIdentityHash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ (keyBlock value: element enclosedSetElement) == anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!KeyedSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:17'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == nil or: [ (keyBlock value: element enclosedSetElement) = anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!KeyedSet methodsFor: 'adding' stamp: 'ar 2/1/2010 21:17'!member: newObject	"Include newObject as one of the receiver's elements, if already exists just return it"	| index |	index := self scanFor: (keyBlock value: newObject).	(array at: index) ifNotNil: [ :element | ^element enclosedSetElement].	self atNewIndex: index put: newObject asSetElement.	^ newObject! !!WeakSet methodsFor: 'adding' stamp: 'ar 2/1/2010 21:31'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject"	| index element |	index := self scanFor: newObject.	((element := array at: index) == flag or: [ element == nil ])		ifTrue: [self atNewIndex: index put: newObject asSetElement].	^newObject! !!KeyedSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:19'!noCheckAdd: anObject	self deprecated: 'This method should not be used anymore.'.	array at: (self scanFor: (keyBlock value: anObject)) put: anObject asSetElement.	tally := tally + 1! !!WeakSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:30'!fixCollisionsFrom: start	"The element at start has been removed and replaced by flag.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| element index |	index := start.	[ (element := array at: (index := index \\ array size + 1)) == flag ] whileFalse: [		| newIndex |		(newIndex := self scanFor: element enclosedSetElement) = index ifFalse: [			array swap: index with: newIndex ] ]! !!KeyedSet methodsFor: 'accessing' stamp: 'ar 2/1/2010 21:18'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	^(array at: (self scanFor: key)) ifNil: [ aBlock value ] ifNotNil:[:obj| obj enclosedSetElement]! !!WeakSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:30'!scanForLoadedSymbol: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements"	| element start finish |	start := (anObject hash \\ array size) + 1.	finish := array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := array at: index) == flag or: [element enclosedSetElement asString = anObject asString])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := array at: index) == flag or: [element enclosedSetElement asString = anObject asString])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!WeakSet methodsFor: 'public' stamp: 'ar 2/1/2010 21:32'!do: aBlock after: anElement	| startIndex |	tally = 0 ifTrue: [ ^self ].	startIndex := anElement		ifNil: [ 0 ]		ifNotNil: [ self scanFor: anElement ].	startIndex + 1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :object |			object == flag ifFalse: [				aBlock value: object enclosedSetElement] ] ]! !!WeakSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:30'!scanFor: anObject	"Scan the key array for the first slot containing either flag (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start |	index := start := anObject hash \\ array size + 1.	[ 		| element |		((element := array at: index) == flag or: [ element enclosedSetElement = anObject ])			ifTrue: [ ^index ].		(index := index \\ array size + 1) = start ] whileFalse.	self errorNoFreeSpace! !!KeyedSet methodsFor: 'removing' stamp: 'ar 2/1/2010 21:18'!removeKey: key ifAbsent: aBlock	| index obj |	index := self scanFor: key.	(obj := array at: index) == nil ifTrue: [ ^ aBlock value ].	array at: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ obj enclosedSetElement! !!KeyedSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:18'!noCheckNoGrowFillFrom: anArray	"Add the elements of anArray except nils to me assuming that I don't contain any of them, they are unique and I have more free space than they require."	1 to: anArray size do: [ :index |		(anArray at: index) ifNotNil: [ :object |			array				at: (self scanForEmptySlotFor: (keyBlock value: object enclosedSetElement))				put: object ] ]! !!KeyedSet methodsFor: 'adding' stamp: 'ar 2/1/2010 21:18'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	index := self scanFor: (keyBlock value: newObject).	(array at: index) ifNil: [self atNewIndex: index put: newObject asSetElement].	^ newObject! !!KeyedSet methodsFor: 'private' stamp: 'ar 2/1/2010 21:19'!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| element index |	index := start.	[ (element := array at: (index := index \\ array size + 1)) == nil ] whileFalse: [		| newIndex |		(newIndex := self scanFor: (keyBlock value: element enclosedSetElement)) = index ifFalse: [			array swap: index with: newIndex ] ]! !!WeakSet methodsFor: 'enumerating' stamp: 'ar 2/1/2010 21:31'!do: aBlock	tally = 0 ifTrue: [ ^self ].	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :object |			object  == flag ifFalse: [				aBlock value: object enclosedSetElement] ] ]! !!WeakSet methodsFor: 'accessing' stamp: 'ar 2/1/2010 21:30'!like: anObject	"Answer an object in the receiver that is equal to anObject,	nil if no such object is found. Relies heavily on hash properties"	| element |	^(element  := array at: (self scanFor: anObject)) == flag		ifFalse: [ element enclosedSetElement]! !!WeakSet methodsFor: 'enumerating' stamp: 'ar 2/1/2010 21:32'!collect: aBlock	| newSet |	newSet := self species new: self size.	tally = 0 ifTrue: [ ^newSet ].	1 to: array size do: [ :index |		(array at: index) ifNotNil: [ :object |			object == flag ifFalse: [				newSet add: (aBlock value: object enclosedSetElement) ] ] ].	^newSet! !