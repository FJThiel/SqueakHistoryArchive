"Change Set:		7959ST80-ar.60ST80-ar.60:Demote ParagraphEditor from Kernel to ST80."!ScrollController subclass: #ParagraphEditor	instanceVariableNames: 'paragraph startBlock stopBlock beginTypeInBlock emphasisHere initialText selectionShowing otherInterval lastParentLocation'	classVariableNames: 'ChangeText CmdActions FindText Keyboard ShiftCmdActions UndoInterval UndoMessage UndoParagraph UndoSelection Undone'	poolDictionaries: 'TextConstants'	category: 'ST80-Controllers'!!ParagraphEditor methodsFor: 'new selection' stamp: ''!selectAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	self selectFrom: characterIndex to: characterIndex - 1! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 4/30/2001 21:20'!cursorTopHome: characterStream 	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."		sensor keyboard.	self selectAt: 1.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:25'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s := paragraph string.	i := self stopIndex.	tabCount := 0.	[(i := i-1) > 0 and: [(char := s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [i < s size and: [(s at: i+1) ~= $[ ]]) ifTrue: [tabCount := tabCount + 1].		char = $[ ifTrue: [tabCount := tabCount + 1].		char = $] ifTrue: [tabCount := tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:14'!stopBlock	^ self pointBlock max: self markBlock! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!exchange: characterStream	"Exchange the current and prior selections.  Keeps typeahead."	sensor keyboard.	 "Flush character"	self closeTypeIn: characterStream.	self exchange.	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/20/2002 11:21'!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary.  Undoer & Redoer: undoAndReselect."	self replace: self selectionInterval with: self clipboardText and:		[self selectAt: self pointIndex]! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'dgd 11/25/2004 17:33'!yellowButtonNoviceMenu	^ MenuMorph fromArray: {			{'set font... (k)' translated.				#offerFontMenu}.			{'set style... (K)' translated.				#changeStyle}.			{'set alignment... (u)' translated.		#chooseAlignment}.			#-.			{'make project link (P)' translated.	#makeProjectLink}.			#-.			{'find...(f)' translated.					#find}.			{'find again (g)' translated.				#findAgain}.			{'set search string (h)' translated.		#setSearchString}.			#-.			{'do again (j)' translated.				#again}.			{'undo (z)' translated.					#undo}.			#-.			{'copy (c)' translated.					#copySelection}.			{'cut (x)' translated.						#cut}.			{'paste (v)' translated.					#paste}.			{'paste...' translated.					#pasteRecent}.			#-.			{'accept (s)' translated.					#accept}.			{'cancel (l)' translated.					#cancel}.		}.! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:49'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start := self startIndex.	stop := self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue:			[before := prior last < start.			selection := self selection.			priorSelection := paragraph text copyFrom: prior first to: prior last.			delta := before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta := before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval := prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval := start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse:			[view flash]! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:40'!cancel: characterStream 	"Cancel unsubmitted changes.  Flushes typeahead.  1/12/96 sw	 1/22/96 sw: put in control terminate/init"	sensor keyboard.	self terminateAndInitializeAround: [self cancel].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 8/1/97 15:18'!methodNamesContainingIt: characterStream 	"Browse methods whose selectors containing the selection in their names"	sensor keyboard.		"flush character"	self methodNamesContainingIt.	^ true! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock: aCharacterBlock	stopBlock := aCharacterBlock.! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!selectAll: characterStream 	"select everything, invoked by cmd-a.  1/17/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectFrom: 1 to: paragraph text string size.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:51'!comment	"All key actions that are neither editing nor typing actions have to	send closeTypeIn at first. See comment in openTypeIn closeTypeIn"! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!startIndex	^ self startBlock stringIndex! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!normalCharacter: characterStream 	"A nonspecial character is to be added to the stream of characters."	characterStream nextPut: sensor keyboard.	^false! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'rbb 2/16/2005 16:49'!presentSpecialMenu	"Present a list of expressions, and if the user chooses one, evaluate it in the context of the receiver, a ParagraphEditor.  Primarily for debugging, this provides a convenient way to talk to the various views, controllers, and models associated with any text pane"	| reply items |	self terminateAndInitializeAround:		[reply := (UIManager default chooseFrom: (items := self specialMenuItems) lines: #()).		reply = 0 ifTrue: [^ self].		Compiler new evaluate: (items at: reply) in: [] to: self]	! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:07'!cursorLeft: characterStream 	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	self closeTypeIn: characterStream.	self		moveCursor:[:position | position - 1 max: 1]		forward: false		specialBlock:[:position | self previousWord: position].	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!displayIfFalse: characterStream 	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifFalse:'.	^false! !!ParagraphEditor methodsFor: 'sensor access' stamp: 'th 9/19/2002 18:24'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	|  selectionBlocks clickPoint oldDelta oldInterval previousMarkBlock previousPointBlock |	clickPoint := sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	oldInterval := self selectionInterval.	previousMarkBlock := self markBlock.	previousPointBlock := self pointBlock.	oldDelta := paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks := paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks := paragraph extendSelectionMark: self markBlock pointBlock: self pointBlock.			self closeTypeIn].	selectionShowing := true.	self markBlock: (selectionBlocks at: 1).	self pointBlock: (selectionBlocks at: 2).	(self hasCaret		and: [previousMarkBlock = self markBlock and: [previousPointBlock = self pointBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval := oldInterval]! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'dgd 10/1/2004 10:59'!yellowButtonMenu	^ Preferences noviceMode			ifTrue: [self yellowButtonNoviceMenu]			ifFalse: [self yellowButtonExpertMenu]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'yo 3/16/2004 13:05'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit := beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection := self nullText. self stopIndex]		ifFalse: [self startOfTyping].	self setMark: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers := self startOfTyping - startIndex.		beginTypeInBlock := self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	self unselect! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'pmm 7/6/2006 20:50'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry |	self flag: #yoCharCases.	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol := self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry := (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isBehavior or: [ anEntry isTrait ])					ifFalse: [ anEntry := anEntry class ].				ToolSet browse: anEntry selector: nil.		] ifFalse:[ self systemNavigation browseAllImplementorsOf: aSymbol]]! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!implementorsOfIt: characterStream 	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self implementorsOfIt.	^ true! !!ParagraphEditor methodsFor: 'displaying' stamp: ''!flash	"Causes the view of the paragraph to complement twice in succession."	paragraph flash! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!pointIndex	^ self pointBlock stringIndex! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 4/24/2001 12:28'!fileItIn: characterStream 	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self fileItIn].	^ true! !!ParagraphEditor methodsFor: 'do-its' stamp: 'gk 3/3/2004 17:15'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	^ result! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 2/23/2001 09:26'!selectionAsTiles	"Try to make new universal tiles from the selected text"	| selection tiles |	selection := self selection.	self terminateAndInitializeAround:		[self currentHand attachMorph: (tiles := Player tilesFrom: selection).		Preferences tileTranslucentDrag			ifTrue: [tiles lookTranslucent]			ifFalse: [tiles align: tiles topLeft 			 			with: self currentHand position + tiles cursorBaseOffset]].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 10/22/2003 15:27'!changeStyle	"Let user change styles for the current text pane  	 Moved from experimentalCommand to its own method  "	| aList reply style |	aList := StrikeFont actualFamilyNames.	aList addFirst: 'DefaultTextStyle'.	reply := (SelectionMenu labelList: aList lines: #(1) selections: aList) startUp.	reply ifNotNil:		[(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 19:57'!moveCursor: directionBlock forward: forward specialBlock: specialBlock	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| shift indices newPosition |	shift := sensor leftShiftDown.	indices := self setIndices: shift forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition := specialBlock value: newPosition].	sensor keyboard.	shift		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:44'!spawnWorkspace	| toUse |	self selectLine.	toUse := self selection asString.	toUse size > 0 ifFalse:		[toUse := paragraph text string.		toUse size > 0 ifFalse: [^ self flash]].	"NB: BrowserCodeController's version does a cancel here"	self terminateAndInitializeAround:		[Utilities openScratchWorkspaceLabeled: 'Untitled' contents: toUse]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 5/22/2007 11:28'!tallyIt	^ self tallySelection! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'mir 8/3/2004 13:31'!blinkParenAt: parenLocation 	self text		addAttribute: TextEmphasis bold		from: parenLocation		to: parenLocation.	lastParentLocation := parenLocation.! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'dvf 12/8/2001 00:46'!raiseContextMenu: characterStream 	"AFAIK, this is never called in morphic, because a subclass overrides it. Which is good, because a ParagraphEditor doesn't know about Morphic and thus duplicates the text-editing actions that really belong in the specific application, not the controller. So the context menu this would raise is likely to be out of date."	self yellowButtonActivity.	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:12'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	self hasSelection ifFalse: [self flash.  ^ returnBlock value]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dvf 8/23/2003 11:51'!classNamesContainingIt	"Open a browser on classes whose names contain the selected string"	self lineSelectAndEmptyCheck: [^self].	self systemNavigation 		browseClassesWithNamesContaining: self selection string		caseSensitive: Sensor leftShiftDown! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'ar 10/5/2009 23:18'!yellowButtonExpertMenu	^ SelectionMenu fromArray: StringHolder yellowButtonMenuItems.! !!ParagraphEditor methodsFor: 'explain' stamp: 'apb 1/5/2000 16:56'!explainNumber: string 	"Is string a Number?"	| strm c |	(c := string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])			ifFalse: [^nil]].	strm := ReadStream on: string.	c := Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText := stateArray at: 1.	FindText := stateArray at: 2.	UndoInterval := stateArray at: 3.	UndoMessage := stateArray at: 4.	UndoParagraph := stateArray at: 5.	UndoSelection := stateArray at: 6.	Undone := stateArray at: 7.	sel := stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock := stateArray at: 9.	emphasisHere := stateArray at: 10.! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!printIt: characterStream 	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self printIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!browseItHere: characterStream 	"Triggered by Cmd-shift-B; browse the thing represented by the current selection, if plausible, in the receiver's own window.  3/1/96 sw"	sensor keyboard.		"flush character"	self browseItHere.	^ true! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!scrollView: anInteger 	"Paragraph scrolling uses opposite polarity"	^ self scrollBy: anInteger negated! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!search: characterStream	"Invoked by Ctrl-S.  Same as 'again', but always uses the existing FindText	 and ChangeText regardless of the last edit."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: true. "true means use same keys"	^true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard.  This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits."	self deselect.	self openTypeIn.	self markBlock = self pointBlock ifFalse: [UndoSelection := self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	self unselect.	self selectAndScroll.	self updateMarker.	view ifNotNil:		[view topView uncacheBits		"in mvc, this makes sure the recognized character shows up in the pane right now; in morphic, a different mechanism is used for the same effect -- see TextMorphEditor method #recognizeCharactersWhileMouseIn:"]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'eem 7/1/2009 13:53'!compileSelectionFor: anObject in: evalContext	| methodNode method |	methodNode := [Compiler new		compileNoPattern: self selectionAsStream		in: anObject class		context: evalContext		notifying: self		ifFail: [^nil]]			on: OutOfScopeNotification			do: [:ex | ex resume: true].	method := methodNode generate: #(0 0 0 0).	^method copyWithTempsFromMethodNode: methodNode! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:17'!selectInvisiblyMark: mark point: point	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: mark to: point! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'dgd 4/4/2006 15:46'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to	accept characters with the change in emphasis. Emphasis	change amounts to a font change. Keeps typeahead."		| keyCode attribute oldAttributes index thisSel colors extras |	"control 0..9 -> 0..9"	keyCode := ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes := paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel := self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue: [		attribute := TextFontChange fontNumber: keyCode	].	keyCode = 6 ifTrue: [		| labels lines | 		colors := #(#black #magenta #red #yellow #green #blue #cyan #white ).		extras := (self class name = #TextMorphEditor and: [(self morph isKindOf: TextMorphForEditView) not])						ifTrue: ["not a system window" #()]						ifFalse: [#('Link to comment of class' 'Link to definition of class' 'Link to hierarchy of class' 'Link to method' )].		Preferences noviceMode ifTrue: [			labels := colors , #('choose color...' ).			lines := #()		]		ifFalse: [			labels := colors , #('choose color...' 'Do it' 'Print it' ) , extras , #('be a web URL link' 'Edit hidden info' 'Copy hidden info' ).			lines := Array with: colors size + 1		].		"index := (PopUpMenu labelArray: labels lines: lines) startUp. "		index := UIManager default chooseFrom: labels lines: lines.		index = 0			ifTrue: [ ^ true].					index <= colors size ifTrue: [			attribute := TextColor color: (Color perform: (colors at: index))		]		ifFalse: [			index := index - colors size - 1. "Re-number!!!!!!"			index = 0 ifTrue: [				attribute := self chooseColor			].			index = 1 ifTrue: [				attribute := TextDoIt new.				thisSel := attribute analyze: self selection asString			].			index = 2 ifTrue: [				attribute := TextPrintIt new.				thisSel := attribute analyze: self selection asString			].			extras size = 0 & (index > 2) ifTrue: [				index := index + 4 "skip those"			].			index = 3 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Comment'			].			index = 4 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Definition'			].			index = 5 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Hierarchy'			].			index = 6 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString			].					index = 7 ifTrue: [				attribute := TextURL new.				thisSel := attribute analyze: self selection asString			].					index = 8 ifTrue: [				"Edit hidden info"				thisSel := self hiddenInfo. "includes selection"				attribute := TextEmphasis normal			].			index = 9 ifTrue: [				"Copy hidden info"				self copyHiddenInfo.				^ true			].					"no other action"			thisSel				ifNil: [ ^ true ]		]	].	(keyCode between: 7 and: 11) ifTrue: [		sensor leftShiftDown ifTrue: [			keyCode = 10 ifTrue: [				attribute := TextKern kern: -1			].			keyCode = 11 ifTrue: [				attribute := TextKern kern: 1			]		]		ifFalse: [			attribute := TextEmphasis perform: (#(#bold #italic #narrow #underlined #struckOut ) at: keyCode - 6).			oldAttributes						do: [:att | (att dominates: attribute) ifTrue: [attribute turnOff]]		]	].	keyCode = 0		ifTrue: [attribute := TextEmphasis normal].	beginTypeInBlock ~~ nil ifTrue: [		"only change emphasisHere while typing"		self insertTypeAhead: characterStream.		emphasisHere := Text addAttribute: attribute toArray: oldAttributes.		^ true	].	self		replaceSelectionWith: (thisSel asText addAttribute: attribute).			^ true! !!ParagraphEditor methodsFor: 'current selection' stamp: ''!deselect	"If the text selection is visible on the screen, reverse its highlight."	selectionShowing ifTrue: [self reverseSelection]! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'dvf 7/28/2003 14:54'!activateTextActions	(paragraph text attributesAt: startBlock stringIndex) 		do: [:att | att actOnClickFor: model in: paragraph]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 3/14/2005 13:03'!changeEmphasis	| aList reply  |	aList := #(normal bold italic narrow underlined struckOut).	reply := (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ~~ nil ifTrue:		[self setEmphasis: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: ''!closeTypeIn: characterStream	"Call instead of closeTypeIn when you want typeahead to be inserted before the	 control character is executed, e.g., from Ctrl-V."	self insertTypeAhead: characterStream.	self closeTypeIn! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!undoer: aSelector	"See comment in undoMessage:.  Use this version when aSelector has no arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector) forRedo: false! !!ParagraphEditor methodsFor: 'private' stamp: 'BG 4/29/2004 11:19'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle := Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines := paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  := paragraph lineIndexOfCharacterIndex: start.			currentLine := lines at: currentLineNumber]		ifFalse: [			lines := self lines.			numberOfLines := lines size.			currentLine := lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber := currentLine second].	column := start - currentLine first.	targetLineNumber := ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine := (lines at: targetLineNumber) first.	targetEOL := (lines at: targetLineNumber) last + (targetLineNumber == numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber == currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock := nil! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!undoer: aSelector with: arg1	"See comment in undoMessage:.  Use this version when aSelector has one argument, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector argument: arg1) forRedo: false! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!updateMarker	"A variation of computeMarkerRegion--only redisplay the marker in the scrollbar if an actual change has occurred in the positioning of the paragraph."	self moveMarkerTo: self computeMarkerRegion! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!isUndoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #undoing! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!undoer: aSelector with: arg1 with: arg2 with: arg3	"See comment in undoMessage:.  Use this version when aSelector has three arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2 with: arg3)) forRedo: false! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'gm 2/16/2003 20:38'!sendContentsToPrinter	| textToPrint printer parentWindow |	textToPrint := paragraph text.	textToPrint size == 0 ifTrue: [^self inform: 'nothing to print.'].	printer := TextPrinter defaultTextPrinter.	parentWindow := self model dependents 				detect: [:dep | dep isSystemWindow]				ifNone: [nil].	parentWindow isNil 		ifTrue: [printer documentTitle: 'Untitled']		ifFalse: [printer documentTitle: parentWindow label].	printer printText: textToPrint! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'bf 10/13/1999 09:09'!selectedSelector	"Try to make a selector out of the current text selection"	^self selection string findSelector! !!ParagraphEditor methodsFor: 'menu messages' stamp: ''!again	"Text substitution. If the left shift key is down, the substitution is made 	throughout the entire Paragraph. Otherwise, only the next possible 	substitution is made.	Undoer & Redoer: #undoAgain:andReselect:typedKey:."	"If last command was also 'again', use same keys as before"	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:12'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start := self startIndex.	stop := self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere := (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval := otherInterval := self selectionInterval]! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:13'!mark	^ self markBlock stringIndex! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!doAgainOnce: characterStream 	"Do the previous thing again once. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self again.	^ true! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!undoer: aSelector with: arg1 with: arg2	"See comment in undoMessage:.  Use this version when aSelector has two arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2)) forRedo: false! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:31'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList := paragraph text attributesAt: (self pointIndex +self markIndex)//2 forStyle: paragraph textStyle.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self selection asString, '<', attr info, '>']].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self selection asString, '<', attr color printString, '>']].	^ self selection asString, '[No hidden info]'! !!ParagraphEditor methodsFor: 'accessing' stamp: ''!setSearch: aString	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	FindText string = aString		ifFalse: [FindText := ChangeText := aString asText]! !!ParagraphEditor methodsFor: 'undoers' stamp: ''!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText index subject |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize := (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText := self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i |		index := indices at: i.		(subject := index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/20/2002 11:09'!pageHeight	| howManyLines visibleHeight totalHeight ratio |	howManyLines := paragraph numberOfLines.	visibleHeight := self visibleHeight.	totalHeight := self totalTextHeight.	ratio := visibleHeight / totalHeight.	^(ratio * howManyLines) rounded - 2! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!insertTypeAhead: typeAhead	typeAhead position = 0 ifFalse:		[self zapSelectionWith: (Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 8/2/2005 20:53'!browseClassFromIt	"Launch a browser for the class indicated by the current selection. 	If multiple classes matching the selection exist, let the user choose among them."	| aBrow aClass |	self		lineSelectAndEmptyCheck: [^ self].	aClass := Utilities				classFromPattern: (self selection string copyWithout: Character cr)				withCaption: 'choose a class to browse...'.	aClass		ifNil: [^ view flash].	self		terminateAndInitializeAround: 			[aBrow := SystemBrowser default new.			aBrow setClass: aClass selector: nil.			aBrow class				openBrowserView: (aBrow openEditString: nil) label: 'System Browser'].! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:53'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home := self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText := UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText := ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey := FindText size = 0)		ifTrue: "just inserted at a caret"			[home := self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText := ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices := WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home := self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/18/2002 11:39'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex := self mark.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	self hasSelection ifTrue:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection := self nullText].	uinterval := UndoInterval deepCopy.	upara := UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph := upara.  UndoInterval := uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel := UndoSelection.			ind := startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock	^ stopBlock! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 3/23/2005 16:49'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt cm v valueAsString |	self lineSelectAndEmptyCheck: [^ -1].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: (Array with: ctxt)].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !!ParagraphEditor methodsFor: 'menu messages' stamp: ''!fit	"Make the bounding rectangle of the paragraph contain all the text while 	 not changing the width of the view of the paragraph.  No effect on undoability	 of the preceding command."	paragraph clearVisibleRectangle.	paragraph fit.	paragraph displayOn: Display; outline.	self recomputeInterval! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 10/28/2003 12:11'!afterSelectionInsertAndSelect: aString	self insertAndSelect: aString at: self stopIndex ! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!referencesToIt: characterStream 	"Triggered by Cmd-N; browse references to the current selection"	sensor keyboard.		"flush character"	self referencesToIt.	^ true! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!scrollToBottom	"Scroll so that the tail end of the text is visible in the view.  5/6/96 sw"	self scrollView: (paragraph clippingRectangle bottom 		- paragraph compositionRectangle bottom)! !!ParagraphEditor methodsFor: 'accessing' stamp: 'jm 3/18/98 20:38'!userHasEdited	"Note that the user has edited my text. Here it is just a noop so that the Character Recognizer won't fail when used with a vanilla ParagrahEditor."! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!offerFontMenu: characterStream 	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw	 Keeps typeahead.  (?? should flush?)"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self offerFontMenu.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/19/2002 20:01'!cursorRight: characterStream 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	self closeTypeIn: characterStream.	self		moveCursor: [:position | position + 1]		forward: true		specialBlock:[:position | self nextWord: position].	^ true! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 14:27'!stopIndex	^ self stopBlock stringIndex! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 7/5/2004 16:38'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString := self selection string.	aString isOctetString ifTrue: [aString := aString asOctetString].	aString := aString copyWithoutAll:		{Character space.  Character cr.  Character tab}.	aString size == 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!noUndoer	"The Undoer to use when the command can not be undone.  Checked for	 specially by readKeyboard."	UndoMessage := Message selector: #noUndoer! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!cut: characterStream 	"Cut out the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self cut.	^true! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!undoMessage: aMessage forRedo: aBoolean	"Call this from an undoer/redoer to set up UndoMessage as the	 corresponding redoer/undoer.  Also set up UndoParagraph, as well	 as the state variable Undone.  It is assumed that UndoInterval has been	 established (generally by zapSelectionWith:) and that UndoSelection has been	 saved (generally by replaceSelectionWith: or replace:With:and:)."	self isDoing ifTrue: [UndoParagraph := paragraph].	UndoMessage := aMessage.	Undone := aBoolean! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 5/7/2001 08:47'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hiddeninfo.  Copy that to the clipboard.  You can paste it and see what it is.Usually enclosed in <>."	^ self clipboardTextPut: self hiddenInfo asText! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'RAA 3/15/2001 12:10'!changeStyleTo: aNewStyle	paragraph textStyle: aNewStyle.	paragraph composeAll.	self recomputeSelection.! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ar 8/18/2009 00:18'!clearParens	lastParentLocation ifNotNil:		[self text string size >= lastParentLocation ifTrue: [			self text				removeAttribute: TextEmphasis bold				from: lastParentLocation				to: lastParentLocation]].	lastParentLocation := nil.! !!ParagraphEditor methodsFor: 'explain' stamp: 'nk 6/10/2004 07:02'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class := model selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class := class soleInstance].	classes := (Array with: class)				, class allSuperclasses.	"class variables"	reply := classes detect: [:each | (each classVarNames detect: [:name | symbol = name]					ifNone: [])					~~ nil]				ifNone: [].	reply == nil ifFalse: [^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol)					and: 						[reply := pool.						true]]			ifNone: [])			~~ nil].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [^ '"is an undeclared variable.' , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes := WriteStream on: Array new.			self systemNavigation				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: [])						~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply) asString , ', which is used by the following classes ' , classes contents printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , (Smalltalk keyAtIdentityValue: reply) asString , ' bindingOf: #' , symbol , ').'].	^ nil! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/20/1998 08:31'!notify: aString at: anInteger in: aStream 	"The compilation of text failed. The syntax error is noted as the argument, 	aString. Insert it in the text at starting character position anInteger."	self insertAndSelect: aString at: (anInteger max: 1)! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageDown: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo + self pageHeight]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:21'!encompassLine: anInterval	"Return an interval that encompasses the entire line"	| string left right |	string := paragraph text string.	left := (string lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right := (string indexOf: Character cr startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:19'!explainTemp: string 	"Is string the name of a temporary variable (or block argument variable)?"	| selectedClass tempNames i reply methodNode method msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^nil].	"not in a message"	selectedClass := model selectedClassOrMetaClass.	tempNames := selectedClass parserClass new 			parseArgsAndTemps: model selectedMessage notifying: nil.	method := selectedClass compiledMethodAt: msg.	(i := tempNames findFirst: [:each | each = string]) = 0 ifTrue: [		(method numTemps > tempNames size)			ifTrue: 				["It must be an undeclared block argument temporary"				methodNode := selectedClass compilerClass new							parse: model selectedMessage							in: selectedClass							notifying: nil.				tempNames := methodNode tempNames]			ifFalse: [^nil]].	(i := tempNames findFirst: [:each | each = string]) > 0 ifTrue: [i > method numArgs			ifTrue: [reply := '"is a temporary variable in this method"']			ifFalse: [reply := '"is an argument to this method"']].	^reply! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!align: characterStream 	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"	sensor keyboard.		"flush character"	self align.	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 9/7/1999 11:26'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	sensor keyboard.  "consume enter key"	self terminateAndInitializeAround: [	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self accept].	].	^ true! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:40'!totalTextHeight	^paragraph boundingBox height! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:38'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelection.! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:30'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: aSelector]! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:48'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	self select.	lineHeight := paragraph textStyle lineGrid.	clippingRectangle := paragraph clippingRectangle.	deltaY := self stopBlock top - clippingRectangle top.	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'menu messages' stamp: ''!performMenuMessage: aSelector	"If a menu command is invoked, typeIn must be closed first, the selection	 must be unhighlighted before and rehighlighted after, and the marker	 must be updated."	self closeTypeIn.	self deselect.	super performMenuMessage: aSelector.	self selectAndScroll.	self updateMarker! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:21'!makeProjectLink: characterStream 	""	| attribute oldAttributes thisSel |		sensor keyboard.	oldAttributes := paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel := self selection.	attribute := TextSqkProjectLink new. 	thisSel := attribute analyze: self selection asString.	thisSel ifNil: [^ true].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere := Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!clipboardTextPut: text	^ Clipboard clipboardText: text! !!ParagraphEditor methodsFor: 'sensor access' stamp: ''!processBlueButton	"The user pressed the blue button on the mouse. Determine what action 	to take."	^self! !!ParagraphEditor methodsFor: 'do-its' stamp: 'sd 4/16/2003 11:41'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "	| result |	self terminateAndInitializeAround: [	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [view flash]		ifFalse: [self systemNavigation					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]].	]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 11:47'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectLine.	((aSymbol := self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:34'!experimentalCommand	"Use for experimental command-key implementation.  Using this, 	you can try things out without forever needing to reinitialize the 	ParagraphEditor."	self prettyPrint.	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:41'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| selection |	selection := self selection.	self terminateAndInitializeAround:		[(ReadWriteStream on: selection string from: 1 to: selection size) fileIn].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:38'!clipboardText: text	^ Clipboard clipboardText: text! !!ParagraphEditor methodsFor: 'explain' stamp: 'sw 5/3/1998 14:32'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls |	symbol = #nil ifTrue: [reply := '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply := '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply := '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply := '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes := cls withAllSubclasses.			classes size > 12				ifTrue: [text := cls printString , ' or a subclass']				ifFalse: 					[classes := classes printString.					text := 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply := '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply := '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 11/23/1998 15:21'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 := self clipboardText string.	s2 := paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'fc 2/19/2004 22:09'!changeEmphasisOrAlignment	| aList reply  |	aList := #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).	reply := (SelectionMenu labelList: aList lines: #(6) selections: aList) startUp.	reply ~~ nil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[paragraph perform: reply.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!spawnIt: characterStream	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	sensor keyboard.	self terminateAndInitializeAround: [self spawn].	^ true! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sps 7/24/2003 17:25'!multiRedoOverride"Call this to set meta-r to perform the multilevel redo (or tweak the code below to have it bound to some other key sequence).""ParagraphEditor multiRedoOverride."	CmdActions at: $r asciiValue + 1 put: #multiRedo: ! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/12/2004 16:22'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes := (Array with: cls)				, cls allSuperclasses.	classes := classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes := classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:18'!selectMark: mark point: point	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse:		[self deselect.		self selectInvisiblyMark: mark point: point].	self selectAndScroll! !!ParagraphEditor methodsFor: 'undoers' stamp: ''!undoAndReselect: undoHighlight redoAndReselect: redoHighlight	"Undo typing, cancel, paste, and other operations that are like replaces	 but the selection is not the whole restored text after undo, redo, or both.	 undoHighlight is selected after this phase and redoHighlight after the next phase.	Redoer: itself."	self replace: self selectionInterval with: UndoSelection and:		[self selectInterval: undoHighlight].	self undoMessage: (UndoMessage argument: redoHighlight) forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'th 10/21/2003 15:49'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	stopBlock := paragraph defaultCharacterBlock.	self pointBlock: stopBlock copy.	beginTypeInBlock := nil.	UndoInterval := otherInterval := 1 to: 0.	self setEmphasisHere.	selectionShowing := false.	initialText := paragraph text copy! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!viewDelta 	"Refer to the comment in ScrollController|viewDelta."	^paragraph clippingRectangle top 		- paragraph compositionRectangle top 		- ((marker top - scrollBar inside top) asFloat 				/ scrollBar inside height asFloat * self scrollRectangleHeight asFloat)			roundTo: paragraph lineGrid! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!indent: characterStream	"Add a tab at the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-R.  2/29/96 sw"	^ self inOutdent: characterStream delta: 1! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'SqR 11/14/2000 12:15'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	sensor flushKeyboard. "a way to flush stuck keys"	self closeTypeIn.	UndoParagraph == paragraph ifFalse: "Can't undo another paragraph's edit"		[UndoMessage := Message selector: #undoReplace.		UndoInterval := 1 to: 0.		Undone := true].	UndoInterval ~= self selectionInterval ifTrue: "blink the actual target"		[self selectInterval: UndoInterval; deselect].	"Leave a signal of which phase is in progress"	UndoParagraph := Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph := paragraph! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!paste: characterStream 	"Replace the current text selection by the text in the shared buffer.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self paste.	^true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!displayIfTrue: characterStream 	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifTrue:'.	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 17:34'!simulatedBackspace	"Backspace over the last character, derived from hand-char recognition.  2/5/96 sw"	| startIndex |	startIndex := self markIndex + (self hasSelection ifTrue: [1] ifFalse: [0]).	startIndex := 1 max: startIndex - 1.	self backTo: startIndex.	^ false! !!ParagraphEditor methodsFor: 'controlling' stamp: ''!controlTerminate	self closeTypeIn.  "Must call to establish UndoInterval"	super controlTerminate.	self deselect! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'yo 5/27/2004 13:56'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes := paragraph text attributesAt: self selectionInterval first forStyle: paragraph textStyle.	attribute := TextEmphasis perform: emphasisSymbol.	(emphasisSymbol == #normal) 		ifFalse:	[oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:50'!selectFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = self startIndex and: [stop + 1 = self stopIndex]) ifFalse:		[self deselect.		self selectInvisiblyFrom: start to: stop].	self selectAndScroll! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'di 12/3/2001 21:49'!escapeToDesktop: characterStream 	"Pop up a morph to field keyboard input in the context of the desktop"	Smalltalk isMorphic ifTrue: [ActiveWorld putUpWorldMenuFromEscapeKey].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:09'!copySelection	"Copy the current selection and store it in the paste buffer, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection := self selection.	self undoer: #undoCutCopy: with: self clipboardText.	UndoInterval := self selectionInterval.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 9/6/2005 18:45'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source). Slow!!"	self lineSelectAndEmptyCheck: [^ self].	self systemNavigation browseMethodsWithSourceString: self selection string! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!stopBlock: aCharacterBlock	self pointBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:48'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where := paragraph text findString: FindText startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !!ParagraphEditor methodsFor: 'initialize-release' stamp: ''!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	UndoParagraph == paragraph ifTrue: [UndoParagraph := nil].	paragraph := aParagraph.	self resetState! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'ar 10/5/2009 21:38'!abandonChangeText	^self class abandonChangeText! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 09:42'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [ self systemNavigation browseAllImplementorsOf: aSelector]! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 9/9/97 16:44'!methodStringsContainingIt: characterStream 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	sensor keyboard.		self methodStringsContainingit.	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!copySelection: characterStream 	"Copy the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self copySelection.	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/29/96'!specialMenuItems	"Refer to comment under #presentSpecialMenu.  .	 : added objectsReferencingIt,"	^ #(	'Transcript cr; show: ''testing'''			'view superView model inspect'			'view superView model browseObjClass'			'view display'			'self inspect'			'view backgroundColor: Color fromUser'			'view topView inspect'			'self compareToClipboard'			'view insideColor: Form white'			'self objectsReferencingIt'		) ! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/15/2003 22:40'!classCommentsContainingIt	"Open a browser class comments which contain the current selection somewhere in them."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [		self systemNavigation browseClassCommentsWithString: self selection string]! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasCaret	^self markBlock = self pointBlock! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 18:26'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead := WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char := sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				self setEmphasisHere.				^self selectAndScroll; updateMarker].			self openTypeIn].		self hasSelection ifTrue: "save highlighted characters"			[UndoSelection := self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'mikki 1/5/2005 14:10'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	self clearParens.  	"mikki 1/3/2005 21:31 Preference for auto-indent on return added."	char asciiValue = 13 ifTrue: [		^Preferences autoIndent 			ifTrue: [				sensor controlKeyPressed					ifTrue: [self normalCharacter: typeAheadStream]					ifFalse: [self crWithIndent: typeAheadStream]]			ifFalse: [				sensor controlKeyPressed					ifTrue: [self crWithIndent: typeAheadStream]					ifFalse: [self normalCharacter: typeAheadStream]]].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].			"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	(')]}' includes: char)		ifTrue: [self blinkPrevParen].	^ self perform: #normalCharacter: with: typeAheadStream! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'CdG 10/17/2005 20:47'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName lastIndex |	stringToSave := paragraph text string.	stringToSave size == 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow := self model dependents						detect: [:dep | dep isKindOf: SystemWindow orOf: StandardSystemView]						ifNone: [nil].	labelToUse := parentWindow		ifNil: 		['Untitled']		ifNotNil: 	[parentWindow label].	suggestedName := nil.	#(('Decompressed contents of: '		'.gz')) do:  "can add more here..."		[:leaderTrailer |			(labelToUse beginsWith: leaderTrailer first) ifTrue:				[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1 to: labelToUse size.				(labelToUse endsWith: leaderTrailer last)					ifTrue:						[suggestedName := suggestedName copyFrom: 1 to: suggestedName size - leaderTrailer last size]					ifFalse:						[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].						(lastIndex = 0 or: [lastIndex = 1]) ifFalse:							[suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil:		[suggestedName := labelToUse, '.text'].				fileName := UIManager default request: 'File name?' translated			initialAnswer: suggestedName.	fileName isEmptyOrNil ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave; close]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:17'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	self hasSelection ifTrue:[^self].	self selectInterval: (self encompassLine: self selectionInterval)! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/9/1998 20:59'!selectInvisiblyFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	^ self computeIntervalFrom: start to: stop! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock	^ startBlock! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/20/2002 11:41'!duplicate: characterStream	"Paste the current selection over the prior selection, if it is non-overlapping and	 legal.  Flushes typeahead.  Undoer & Redoer: undoAndReselect."	sensor keyboard.	self closeTypeIn.	(self hasSelection and: [self isDisjointFrom: otherInterval])		ifTrue: "Something to duplicate"			[self replace: otherInterval with: self selection and:				[self selectAt: self pointIndex]]		ifFalse:			[view flash].	^true! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/29/2003 20:07'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply := Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes := Set new.			self systemNavigation allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes := classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 18:49'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok := false.	string := paragraph text string.	stop := self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop := stop - 1].	sep := stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok := true. sep := sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:37'!adjustSelection: directionBlock	"Helper function for Cursor movement. Always moves point thus allowing selections to shrink. "	"See also expandSelection:"	"Accepts a one argument Block that computes the new postion given an old one."	| newPosition |	newPosition := directionBlock value: self pointIndex.	self selectMark: self markIndex point: newPosition.	^true.! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!scrollRectangleHeight	^paragraph compositionRectangle height 		+ paragraph lineGrid! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 12:31'!markIndex	^ self markBlock stringIndex! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'dgd 10/4/2004 13:53'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap |	"shift-command and control shortcuts"	cmdMap := Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.				"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.				"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.				"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.				"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.				"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	"triplet = {character. comment selector. novice appropiated}"	#(		($a		argAdvance:						false)		($b		browseItHere:					false)		($c		compareToClipboard:			false)		($d		duplicate:							true)		($e		methodStringsContainingIt:	false)		($f		displayIfFalse:					false)		($g		fileItIn:							false)		($h		cursorTopHome:					true)		($i		exploreIt:							false)		($j		doAgainMany:					true)		($k		changeStyle:						true)		($l		outdent:							true)		($m	selectCurrentTypeIn:			true)		($n		referencesToIt:					false)		($p		makeProjectLink:				true)		($r		indent:							true)		($s		search:							true)		($t		displayIfTrue:					false)		($u		changeLfToCr:					false)		($v		pasteInitials:						false)		($w	methodNamesContainingIt:	false)		($x		makeLowercase:					true)		($y		makeUppercase:					true)		($z		makeCapitalized:				true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet |			cmdMap at: (triplet first asciiValue         + 1) put: triplet second.		"plain keys"			cmdMap at: (triplet first asciiValue - 32 + 1) put: triplet second.		"shifted keys"			cmdMap at: (triplet first asciiValue - 96 + 1) put: triplet second.		"ctrl keys"		].	ShiftCmdActions := cmdMap! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setPoint: anIndex	self pointBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:40'!prettyPrintWithColor	self prettyPrint: true! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'dgd 10/1/2004 11:00'!initialize	"Initialize the keyboard shortcut maps and the shared buffers 	for copying text across views and managing again and undo. 	Marked this method changed to trigger reinit"	"ParagraphEditor initialize"	UndoSelection := FindText := ChangeText := Text new.	UndoMessage := Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!changeStyle: characterStream 	"Put up the style-change menu"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self changeStyle.	^ true! !!ParagraphEditor methodsFor: 'explain' stamp: 'di 1/30/2002 21:09'!explainChar: string	"Does string start with a special character?"	| char |	char _ string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = ${ or: [char = $}]) ifTrue: [^ '"A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array"'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	^nil! !!ParagraphEditor methodsFor: 'private' stamp: 'raok 11/15/2001 14:01'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = ${ and: [string last = $}]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str := string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:09'!cursorPageUp: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine:[:lineNo | lineNo - self pageHeight]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 9/7/1999 11:25'!inspectIt	"1/13/96 sw: minor fixup"	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result inspect].! !!ParagraphEditor methodsFor: 'current selection' stamp: ''!initializeSelection	"Do the initial activity when starting up the receiver. For example, in the 	ParagraphEditor highlight the current selection."	self select! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:47'!selectAndScroll	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle endBlock |	self select.	endBlock := self stopBlock.	lineHeight := paragraph textStyle lineGrid.	clippingRectangle := paragraph clippingRectangle.	deltaY := endBlock top - clippingRectangle top.	deltaY >= 0 		ifTrue: [deltaY := endBlock bottom - clippingRectangle bottom max: 0].						"check if stopIndex below bottom of clippingRectangle"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:31'!compareToClipboard: characterStream 	"Compare the receiver to the text on the clipboard.  Flushes typeahead.  5/1/96 sw"	sensor keyboard.		self terminateAndInitializeAround: [self compareToClipboard].	^ true! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits := Array with: msg.	(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply := ', which is the selector of this very method!!'.			s := '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply := '.'.			s := '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes := self systemNavigation allClassesImplementing: whole.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!ParagraphEditor methodsFor: 'menu messages' stamp: ''!findAgain	"Find the text-to-find again.  1/24/96 sw"	self againOrSame: true! !!ParagraphEditor methodsFor: 'private' stamp: ''!againOrSame: useOldKeys	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.	 1/26/96 sw: real worked moved to againOrSame:many:"	^ self againOrSame: useOldKeys many: sensor leftShiftDown! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self inspectIt].	^ true! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/20/2002 11:41'!recomputeInterval	"The same characters are selected but their coordinates may have changed."	self computeIntervalFrom: self mark to: self pointIndex - 1! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!undo: characterStream 	"Undo the last edit.  Keeps typeahead, so undo twice is a full redo."	sensor keyboard. 	"flush character"	self closeTypeIn: characterStream.	self undo.	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString :=  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'ls 11/10/2002 12:11'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-Y."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:01'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{"''' indexOf: char ifAbsent: [ ^true ].	left := '([<{"''' at: which.	right := ')]>}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'undoers' stamp: 'th 9/19/2002 18:46'!undoQuery: hintText lastOffering: selectorOrNil	"Undo ctrl-q.  selectorOrNil (if not nil) is the previously offered selector.	 hintText is the original hint.  Redoer: completeSymbol."	self zapSelectionWith: UndoSelection.	self undoMessage: (Message selector: #completeSymbol:lastOffering: arguments: UndoMessage arguments) forRedo: true.	self selectAt: self stopIndex! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'acg 12/7/1999 07:56'!exploreIt: characterStream 	"Explore the selection -- invoked via cmd-shift-I.  If there is no current selection, use the current line."	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self exploreIt].	^ true! !!ParagraphEditor methodsFor: 'new selection' stamp: ''!selectInterval: anInterval	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: anInterval first to: anInterval last! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:51'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string := paragraph text string.	here := self pointIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters := '([{<''"'.	rightDelimiters := ')]}>''"'.	openDelimiter := string at: here - 1.	match := leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start := here.			direction := 1.			here := here - 1.			closeDelimiter := rightDelimiters at: match]		ifFalse: 			[openDelimiter := string at: here.			match := rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop := here - 1.					direction := -1.					closeDelimiter := leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction := -1]].	level := 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar := string at: (here := here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start := 1.									"go right if hit string start"									direction := 1]]						ifFalse: [direction < 0								ifTrue: 									[start := here + 1.									"go right if hit non-token"									direction := 1]								ifFalse: [level := 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level := level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level := level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here := here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ar 8/18/2009 00:18'!blinkParen	"Highlight the last parenthesis in the text"	lastParentLocation ifNotNil:		[self text string size >= lastParentLocation ifTrue: [			self text				addAttribute: TextEmphasis bold				from: lastParentLocation				to: lastParentLocation]]! !!ParagraphEditor methodsFor: 'undoers' stamp: ''!undoReplace	"Undo of any command that replaced a selection by other text that it left	 highlighted, and that is undone and redone by simple reversal of the	 operation.  This is the most common Undoer; call replaceSelectionWith:	 to get this setup.  Redoer: itself, so never isRedoing."	self replaceSelectionWith: UndoSelection! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!isRedoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #redoing! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:33'!visibleHeight	^paragraph clippingRectangle height! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dgd 11/25/2004 18:03'!makeProjectLink		| attribute thisSel |		thisSel := self selection.	attribute := TextSqkProjectLink new. 	thisSel := attribute analyze: self selection asString.	thisSel ifNil: [^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:00'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars := self selection) size == 0		ifTrue:			[currentSelection := self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection := self pointIndex - 1]].	aString := self selection string.	self replaceSelectionWith: (Text string: aString reversed emphasis: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:22'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start := paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start := paragraph text size + 1].	self selectAt: start + 2.	^true! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock: aCharacterBlock	startBlock := aCharacterBlock.! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 18:25'!querySymbol: characterStream	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	"keep typeahead"	self hasCaret		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[view flash].	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:36'!pasteRecent	"Paste an item chose from RecentClippings."	| clipping |	(clipping := Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self paste! !!ParagraphEditor methodsFor: 'accessing' stamp: ''!replace: oldInterval with: newText and: selectingBlock 	"Replace the text in oldInterval with newText and execute selectingBlock to establish the new selection.  Create an undoAndReselect:redoAndReselect: undoer to allow perfect undoing."	| undoInterval |	undoInterval := self selectionInterval.	undoInterval = oldInterval ifFalse: [self selectInterval: oldInterval].	UndoSelection := self selection.	self zapSelectionWith: newText.	selectingBlock value.	otherInterval := self selectionInterval.	self undoer: #undoAndReselect:redoAndReselect: with: undoInterval with: otherInterval! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self closeTypeIn: characterStream.	prior := otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval := prior.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/20/2002 12:14'!cursorHome: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string := paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOf: Character cr						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		specialBlock: [:dummy | 1].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:23'!doIt: characterStream 	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	sensor keyboard.		self terminateAndInitializeAround: [self doIt].	^ true! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:23'!unselect	self markBlock: self pointBlock copy.! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'pk 9/10/2005 22:53'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |		sensor keyboard.  "Flush typeahead"	cr := Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart := self startIndex.	realStop := self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^ true].	lines := paragraph lines.	startLine := paragraph lineIndexOfCharacterIndex: realStart.	stopLine := paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start := (lines at: startLine) first.	stop := (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart := realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation := (startLine to: stopLine) inject: 1000 into:		[:m :l |		m := m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size :=  stop + 1 - start.	numLines := stopLine + 1 - startLine.	inStream := ReadStream on: paragraph string from: start to: stop.	newString := WideString new: size + ((numLines * delta) max: 0).	outStream := ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart := (realStart + delta) max: start].	realStop := realStop + outStream position - size.	"Prepare for another iteration"	indentation := indentation + delta.	size := outStream position.	inStream := outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[view flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString := outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!ParagraphEditor methodsFor: 'controlling' stamp: ''!controlInitialize	super controlInitialize.	self recomputeInterval.	self initializeSelection.	beginTypeInBlock := nil! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 1/19/2000 11:14'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList := paragraph textStyle fontNamesWithPointSizes.	reply := (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:20'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	char = $9 ifTrue: [ char := $( ].	char = $, ifTrue: [ char := $< ].	char = $[ ifTrue: [ char := ${ ].	char = $' ifTrue: [ char := $" ].	char asciiValue = 27 ifTrue: [ char := ${ ].	"ctrl-["	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{"''' indexOf: char ifAbsent: [1].	left := '([<{"''' at: which.	right := ')]>}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'scrolling' stamp: 'BG 12/12/2003 15:31'!scrollBy: heightToMove	"Move the paragraph by heightToMove, and reset the text selection."	^ paragraph scrollBy: heightToMove withSelectionFrom: self pointBlock to: self markBlock! !!ParagraphEditor methodsFor: 'private' stamp: 'cmm 4/9/2004 14:00'!isDisjointFrom: anInterval	"Answer true if anInterval is a caret not touching or within the current	 interval, or if anInterval is a non-caret that does not overlap the current	 selection."	| fudge |	fudge := anInterval size = 0 ifTrue: [1] ifFalse: [0].	^(anInterval last + fudge < self startIndex or:			[anInterval first - fudge >= self stopIndex])! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 12/17/1998 09:41'!insertAndSelect: aString at: anInteger	self replace: (anInteger to: anInteger - 1)		with: (Text string: (' ' , aString)					attributes: emphasisHere)		and: [self selectAndScroll]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 17:40'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin := self startOfTyping.			stop := self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval := begin to: stop - 1].		beginTypeInBlock := nil]! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'dgd 4/4/2006 16:04'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap |	cmdMap := Array new: 256 withAll: #noop:.	"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.			"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.		"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.	"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.	"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.			"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.			"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.			"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.			"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"	'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].	'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].	cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.	"triplet = {character. comment selector. novice appropiated}"	#(		($a		#selectAll:				true)		($b		#browseIt:				false)		($c		#copySelection:			true)		($d		#doIt:						false)		($e		#exchange:				true)		($f		#find:						true)		($g		#findAgain:				true)		($h		#setSearchString:		true)		($i		#inspectIt:				false)		($j		#doAgainOnce:			true)		($k		#offerFontMenu:		true)		($l		#cancel:					true)		($m	#implementorsOfIt:		false)		($n		#sendersOfIt:			false)		($o		#spawnIt:				false)		($p		#printIt:					false)		($q		#querySymbol:			false)		($s		#save:					true)		($t		#tempCommand:		false)		($u		#align:					true)		($v		#paste:					true)		($w	#backWord:				true)		($x		#cut:						true)		($y		#swapChars:				true)		($z		#undo:					true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet | cmdMap at: triplet first asciiValue + 1 put: triplet second].	CmdActions := cmdMap.! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!outdent: characterStream	"Remove a tab from the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-L.  2/29/96 sw"	^ self inOutdent: characterStream delta: -1! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:25'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc := start + dir.	str := paragraph text string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc := loc + dir].	^ loc! !!ParagraphEditor class methodsFor: 'instance creation' stamp: 'nk 9/3/2004 14:10'!new	"Answer a new instance of me with a null Paragraph to be edited."	| aParagraphEditor |	aParagraphEditor := super new.	aParagraphEditor changeParagraph: '' asParagraph.	^aParagraphEditor! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/2/97 11:34'!mvcRedisplay	"Overridable by subclasses that do their own display"	Display fill: paragraph clippingRectangle 			fillColor: view backgroundColor.	"very brute force"	self display! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'yo 7/31/2004 16:27'!selection	"Answer the text in the paragraph that is currently selected."	| t |	t := paragraph text copyFrom: self startIndex to: self stopIndex - 1.	t string isOctetString ifTrue: [t asOctetStringText].	^ t.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:21'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| wasShowing userSelection delta loc |	aString = '#insert period' ifTrue:		[loc := start.		[(loc := loc-1)>0 and: [(paragraph text string at: loc) isSeparator]]			whileTrue: [loc := loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing := selectionShowing) ifTrue: [ self reverseSelection ].	userSelection := self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString asText.	delta := aString size - (stop - start + 1).	self selectInvisiblyFrom:		userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'hpt 8/5/2004 20:21'!browseIt: characterStream 	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"	sensor keyboard.		"flush character"	self browseIt.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 10/28/2003 10:47'!cursorEnd: characterStream 	"Private - Move cursor end of current line."	| string |	self closeTypeIn: characterStream.	string := paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| targetLine |					targetLine := paragraph lines at:(paragraph lineIndexOfCharacterIndex: position).					targetLine = paragraph lines last						ifTrue:[targetLine last + 1]						ifFalse:[targetLine last]]				ifFalse:[					string						indexOf: Character cr						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		specialBlock:[:dummy | string size + 1].	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 7/13/2006 16:00'!prettyPrint: decorated	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageCategoryName ifNil: [^ view flash].	selectedClass := model selectedClassOrMetaClass.	newText := selectedClass prettyPrinterClass		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!ParagraphEditor methodsFor: 'accessing' stamp: 'tk 4/21/1998 09:55'!initialText	^ initialText! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!scrollAmount 	"Refer to the comment in ScrollController|scrollAmount."	^sensor cursorPoint y - scrollBar top! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:40'!prettyPrint	self prettyPrint: false! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'sw 5/27/2000 00:03'!abandonChangeText	"Call this to get out of the maddening situation in which the system keeps aggressively trying to do a replacement that you no longer wish to make, every time you make choose a new method in a list."	ChangeText := FindText	"ParagraphEditor abandonChangeText"! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/18/2002 17:28'!setAlignment: aSymbol	| attr interval |	attr := TextAlignment perform: aSymbol.	interval := self encompassLine: self selectionInterval.	paragraph replaceFrom: interval first to: interval last with:		((paragraph text copyFrom: interval first to: interval last) addAttribute: attr) displaying: true.! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!save: characterStream	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self terminateAndInitializeAround: [self accept].	^ true! !!ParagraphEditor methodsFor: 'accessing' stamp: ''!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInBlock ~~ nil ifTrue: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection := self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!ParagraphEditor methodsFor: 'explain' stamp: 'nk 6/26/2003 22:02'!explainAnySel: symbol 	"Is this any message selector?"	| list reply |	list := self systemNavigation allClassesImplementing: symbol.	list size = 0 ifTrue: [^nil].	list size < 12		ifTrue: [reply := ' is a message selector which is defined in these classes ' , list printString]		ifFalse: [reply := ' is a message selector which is defined in many classes'].	^'"' , symbol , reply , '."' , '\' withCRs, 'SystemNavigation new browseAllImplementorsOf: #' , symbol! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:52'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'acg 12/7/1999 07:53'!exploreIt	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result explore].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:37'!clipboardText	^ Clipboard clipboardText! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!find: characterStream	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self find.	^ true! !!ParagraphEditor methodsFor: 'controlling' stamp: 'sma 3/11/2000 15:17'!normalActivity	self processKeyboard.	self processMouseButtons! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:02'!setMark: anIndex	self markBlock: (paragraph characterBlockForIndex: anIndex)! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:48'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection := self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock := self startIndex]! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'BG 6/1/2003 09:43'!offerMenuFromEsc: aStream   sensor keyboard. " consume the character "   self yellowButtonActivity.  ^true "tell the caller that the character was processed "! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!sendersOfIt: characterStream 	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self sendersOfIt.	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/19/2002 18:27'!setSearchString	"Make the current selection, if any, be the current search string."	self hasCaret ifTrue: [view flash. ^ self].	self setSearch:  self selection string! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!scrollToTop	"Scroll so that the paragraph is at the top of the view."	self scrollView: (paragraph clippingRectangle top 		- paragraph compositionRectangle top)! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:28'!methodStringsContainingit	"Open a browser on methods which contain the current selection as part of a string constant."	self lineSelectAndEmptyCheck: [^ self].	self terminateAndInitializeAround: [self systemNavigation browseMethodsWithString: self selection string]! !!ParagraphEditor methodsFor: 'accessing' stamp: ''!text	"Answer the text of the paragraph being edited."	^paragraph text! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'md 1/18/2006 23:42'!makeCapitalized: characterStream 	"Force the current selection to be capitalized. Triggered by Cmd-Z."	| prev |	sensor keyboard.		"Flush the triggering cmd-key character"	prev := $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev := prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: ''!noop: characterStream 	"Unimplemented keyboard command; just ignore it."	sensor keyboard.	  "flush character"	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 10/21/2003 15:46'!backWord: characterStream 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	sensor keyboard.	characterStream isEmpty		ifTrue:			[self hasCaret				ifTrue: "a caret, delete at least one character"					[startIndex := 1 max: self markIndex - 1.					[startIndex > 1 and:						[(paragraph text at: startIndex - 1) asCharacter tokenish]]						whileTrue:							[startIndex := startIndex - 1]]				ifFalse: "a non-caret, just delete it"					[startIndex := self markIndex].			self backTo: startIndex]		ifFalse:			[characterStream reset].	^false! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:33'!previousWord: position	| string index |	string := paragraph text string.	index := position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index := index - 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index := index - 1].	^ index + 1! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/17/2002 16:11'!computeIntervalFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	self setMark: start.	self setPoint: stop + 1.! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!isDoing	"Call from a doer/undoer/redoer any time to see which it is."	^(self isUndoing | self isRedoing) not! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:31'!methodNamesContainingIt	"Open a browser on methods names containing the selected string"	self lineSelectAndEmptyCheck: [^ self].	Cursor wait showWhile:		[self terminateAndInitializeAround: [self systemNavigation browseMethodsWhoseNamesContain: self selection string withBlanksTrimmed]].	Cursor normal show! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!markerDelta	^marker top - scrollBar top - ((paragraph clippingRectangle top -		paragraph compositionRectangle top) asFloat /			(self scrollRectangleHeight max: 1) asFloat *				scrollBar height asFloat) rounded! !!ParagraphEditor methodsFor: 'sensor access' stamp: ''!processKeyboard	"Determine whether the user pressed the keyboard. If so, read the keys."	sensor keyboardPressed ifTrue: [self readKeyboard]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:45'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex	! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:15'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	self closeTypeIn: characterStream.	self		moveCursor: [:position | self				sameColumn: position				newLine:[:line | line - 1]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ls 10/10/199911:36'!explain	"Try to shed some light on what kind of entity the current selectionis. 	The selection must be a single token or construct. Insert the answerafter 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply symbol|Cursor execute showWhile: 			[sorry := '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry := sorry , (view canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string := self selection asString) isEmpty				ifTrue: [reply := '']				ifFalse: [string := self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are allletters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars := self explainTemp: string.							tiVars == nil ifTrue: [tiVars := self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars := model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars := '']						ifFalse: [tiVars := tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol := s])						ifTrue: [cgVars := self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars := self explainClass: symbol.									cgVars == nil ifTrue: [cgVars := self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors := self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors := self explainPartSel: string.									selectors == nil ifTrue: [										selectors := self explainAnySel: symbol]]]						ifFalse: [selectors := self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars := '']						ifFalse: [cgVars := cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors := '']						ifFalse: [selectors := selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors := self explainChar: string]						ifFalse: ["matched delimitors"							delimitors := self explainDelimitor: string].					numbers := self explainNumber: string.					numbers == nil ifTrue: [numbers := ''].					delimitors == nil ifTrue: [delimitors := ''].					reply := tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply := sorry].			self afterSelectionInsertAndSelect: reply]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:49'!setEmphasisHere	emphasisHere := (paragraph text attributesAt: (self pointIndex - 1 max: 1) forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 16:10'!startBlock	^ self pointBlock min: self markBlock! !!ParagraphEditor methodsFor: 'private' stamp: 'md 2/22/2006 21:17'!setIndices: shiftPressed forward: forward	"Little helper method that sets the moving and fixed indices according to some flags."	| indices |	indices := Dictionary new.	shiftPressed ifTrue: [			indices at: #moving put: self pointIndex.			indices at: #fixed put: self markIndex		] ifFalse: [			forward				ifTrue:[					indices at: #moving put: self stopIndex.					indices at: #fixed put: self startIndex.				] ifFalse: [					indices at: #moving put: self startIndex.					indices at: #fixed put: self stopIndex.				]		].	^indices! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:48'!pasteInitials: characterStream 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!doAgainMany: characterStream 	"Do the previous thing again repeatedly. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:) many: true.	^ true! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!scrollBar	^ scrollBar! !!ParagraphEditor methodsFor: 'menu messages' stamp: ''!exchange	"See comment in exchangeWith:"	self exchangeWith: otherInterval! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: ''!findAgain: characterStream 	"Find the desired text again.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self findAgain.	^ true! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 5/15/2000 13:51'!stateArray	^ {ChangeText.		FindText.		UndoInterval.		UndoMessage.		UndoParagraph.		UndoSelection.		Undone.		self selectionInterval.		self startOfTyping.		emphasisHere}! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/17/2002 13:10'!startBlock: aCharacterBlock	self markBlock: aCharacterBlock! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 16:33'!cut	"Cut out the current selection and redisplay the paragraph if necessary.  Undoer & Redoer: undoCutCopy:"	self lineSelectAndEmptyCheck: [^ self].	self replaceSelectionWith: self nullText. 	self undoer: #undoCutCopy: with: self clipboardText.	self clipboardTextPut: UndoSelection! !!ParagraphEditor methodsFor: 'private' stamp: 'th 11/24/2002 17:13'!lines	"Other than my member paragraph i compute lines based on logical	line breaks, not optical (which may change due to line wrapping of the editor)"	| lines string index lineIndex stringSize |	string := paragraph text string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize := string size.	lines := OrderedCollection new: (string size // 15).	index := 0.	lineIndex := 0.	string linesDo:[:line |		lines addLast: (Array			with: (index := index + 1)			with: (lineIndex := lineIndex + 1)			with: (index := index + line size min: stringSize))].	"Special workaround for last line empty."	string last == Character cr	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/18/2002 16:18'!selectionInterval	"Answer the interval that is currently selected."	^self startIndex to: self stopIndex - 1 ! !!ParagraphEditor methodsFor: 'scrolling' stamp: ''!computeMarkerRegion 	"Refer to the comment in ScrollController|computeMarkerRegion."	paragraph compositionRectangle height = 0		ifTrue:	[^0@0 extent: Preferences scrollBarWidth @ scrollBar inside height]		ifFalse:	[^0@0 extent:					Preferences scrollBarWidth 						@ ((paragraph clippingRectangle height asFloat /							self scrollRectangleHeight * scrollBar inside height) rounded							min: scrollBar inside height)]! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'ar 10/5/2009 23:20'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down"	^ SelectionMenu fromArray: StringHolder shiftedYellowButtonMenuItems! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/98 12:57'!cancel 	"Restore the text of the paragraph to be the text saved since initialization 	or the last accept.  Undoer & Redoer: undoAndReselect:redoAndReselect:.	This used to call controlTerminate and controlInitialize but this seemed illogical.	Sure enough, nobody overrode them who had cancel in the menu, and if	anybody really cared they could override cancel."	UndoSelection := paragraph text.	self undoer: #undoAndReselect:redoAndReselect: with: self selectionInterval with: (1 to: 0).	view ifNotNil: [view clearInside].	self changeParagraph: (paragraph text: initialText).	UndoParagraph := paragraph.	otherInterval := UndoInterval := 1 to: initialText size. "so undo will replace all"	paragraph displayOn: Display.	self selectAt: 1.	self scrollToTop! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'tk 5/7/2001 09:11'!chooseColor	"Make a new Text Color Attribute, let the user pick a color, and return the attribute.  This is the non-Morphic version."	^ TextColor color: (Color fromUser)! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:10'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^ReadWriteStream		on: paragraph string		from: self startIndex		to: self stopIndex - 1! !!ParagraphEditor methodsFor: 'sensor access' stamp: ''!processYellowButton	"User pressed the yellow button on the mouse. Determine what actions to 	take."	self yellowButtonActivity! !!ParagraphEditor methodsFor: 'current selection' stamp: ''!recomputeSelection	"Redetermine the selection according to the start and stop block indices; 	do not highlight."	self deselect; recomputeInterval! !!ParagraphEditor methodsFor: 'current selection' stamp: 'BG 12/12/2003 12:50'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing := selectionShowing not.	paragraph reverseFrom: self pointBlock to: self markBlock! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^nil].	"not in a message"	classes := self systemNavigation allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 11/2/1998 15:50'!tempCommand: characterStream 	"Experimental.  Triggered by Cmd-t; put trial cmd-key commands here to see how they work, before hanging them on their own cmd accelerators."	Sensor keyboard.	self experimentalCommand.	^ true	"sensor keyboard.	self spawnWorkspace.	^ true"! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 9/27/1999 11:54'!chooseAlignment	self changeAlignment! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'jm 5/3/1998 19:19'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling."	initialText := paragraph text copy.! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'ktt 11/28/2005 12:16'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	startIndex := self markIndex + (self hasCaret ifTrue: [0] ifFalse: [1]).	[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex := 1 max: startIndex - 1.			].	self backTo: startIndex.			^false! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sbw 10/8/1999 21:42'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	11	"page up"	12	"page down"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!ParagraphEditor class methodsFor: 'instance creation' stamp: ''!newParagraph: aParagraph 	"Answer an instance of me with aParagraph as the text to be edited."	| aParagraphEditor |	aParagraphEditor := super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: aParagraph.	^aParagraphEditor! !!ParagraphEditor methodsFor: 'sensor access' stamp: ''!processMouseButtons	"Determine whether the user pressed any mouse button. For each possible 	button, determine what actions to take."	sensor redButtonPressed ifTrue: [self processRedButton].	sensor yellowButtonPressed ifTrue: [self processYellowButton].	sensor blueButtonPressed ifTrue: [self processBlueButton]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'CdG 10/17/2005 20:49'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply := UIManager default request: 'Find what? ' translated initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText := FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'AB 1/7/2002 04:03'!blinkPrevParen	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph text string.	here := startBlock stringIndex.	openDelimiter := sensor keyboardPeek.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 2]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dgd 8/28/2004 13:59'!spawn	"Create and schedule a message browser for the code of the model's 	selected message. Retain any edits that have not yet been accepted."	| code |	code := paragraph text string.	self cancel.	model notNil ifTrue:[model spawn: code].! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:22'!hasSelection	^self hasCaret not! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sw 8/29/2000 14:58'!selectAll	"Make the selection be all the characters of the receiver"	self selectFrom: 1 to: paragraph text string size! !!ParagraphEditor methodsFor: 'explain' stamp: ''!explainScan: string 	"Remove beginning and trailing space, tab, cr.	 1/15/96 sw: copied intact from BrowserCodeController"	| c beg end |	beg := 1.	end := string size.		[beg = end ifTrue: [^string copyFrom: 1 to: 1].	"if all blank, tell about the first"	c := string at: beg.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [beg := beg + 1].		[c := string at: end.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [end := end - 1].	^string copyFrom: beg to: end	"Return purely visible characters"! !!ParagraphEditor methodsFor: 'menu messages' stamp: ''!align	"Align text according to the next greater alignment value--cycling among 	left flush, right flush, center, justified.  No effect on the undoability of the pre	preceding command."	paragraph toggleAlignment.	paragraph displayOn: Display.	self recomputeInterval! !!ParagraphEditor methodsFor: 'displaying' stamp: ''!display	"Redisplay the paragraph."	| selectionState |	selectionState := selectionShowing.	self deselect.	paragraph foregroundColor: view foregroundColor			backgroundColor: view backgroundColor;			displayOn: Display.	selectionState ifTrue: [self select]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 2/17/2005 17:53'!changeAlignment	| aList reply  |	aList := #(leftFlush centered justified rightFlush).	reply := (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ifNil:[^self].	self setAlignment: reply.	paragraph composeAll.	self recomputeSelection.	self mvcRedisplay.	^ true! !!ParagraphEditor methodsFor: 'private' stamp: ''!indent: delta fromStream: inStream toStream: outStream	"Append the contents of inStream to outStream, adding or deleting delta or -delta	 tabs at the beginning, and after every CR except a final CR.  Do not add tabs	 to totally empty lines, and be sure nothing but tabs are removed from lines."	| ch skip cr tab prev atEnd |	cr := Character cr.	tab := Character tab.	delta > 0		ifTrue: "shift right"			[prev := cr.			 [ch := (atEnd := inStream atEnd) ifTrue: [cr] ifFalse: [inStream next].			  (prev == cr and: [ch ~~ cr]) ifTrue:				[delta timesRepeat: [outStream nextPut: tab]].			  atEnd]				whileFalse:					[outStream nextPut: ch.					prev := ch]]		ifFalse: "shift left"			[skip := delta. "a negative number"			 [inStream atEnd] whileFalse:				[((ch := inStream next) == tab and: [skip < 0]) ifFalse:					[outStream nextPut: ch].				skip := ch == cr ifTrue: [delta] ifFalse: [skip + 1]]]! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:32'!nextWord: position	| string index |	string := paragraph text string.	index := position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index := index + 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index := index + 1].	^ index! !!ParagraphEditor methodsFor: 'current selection' stamp: ''!select	"If the text selection is visible on the screen, highlight it."	selectionShowing ifFalse: [self reverseSelection]! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 11/18/2002 17:08'!cursorDown: characterStream 	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self closeTypeIn: characterStream.	self 		moveCursor:[:position | self				sameColumn: position				newLine:[:line | line + 1]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!ParagraphEditor methodsFor: 'undoers' stamp: ''!undoCutCopy: oldPasteBuffer	"Undo of a cut, copy, or any edit that changed CurrentSelection.  Be sure	 undo-copy does not lock the model.  Redoer: itself, so never isRedoing."	| recentCut |	recentCut := self clipboardText.		UndoSelection size = UndoInterval size		ifFalse: [self replaceSelectionWith: UndoSelection].	self clipboardTextPut: oldPasteBuffer.	self undoer: #undoCutCopy: with: recentCut! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dew 3/7/2000 21:06'!printerSetup		TextPrinter defaultTextPrinter inspect! !!ParagraphEditor methodsFor: 'private' stamp: ''!nullText	^Text string: '' emphasis: emphasisHere! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'sma 12/15/1999 11:46'!selectWord: characterStream	sensor keyboard.	self closeTypeIn: characterStream.	self selectWord.	^ true! !!ParagraphEditor methodsFor: 'private' stamp: 'tk 7/14/2000 12:15'!getPluggableYellowButtonMenu: shiftKeyState	| customMenu |	^ ((view ~~ nil) and: [(customMenu := view getMenu: shiftKeyState) notNil])		ifTrue: [customMenu]		ifFalse:			[shiftKeyState				ifTrue: [self class shiftedYellowButtonMenu]				ifFalse: [self class yellowButtonMenu]]! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr := Character cr.  lf := Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:16'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime := self isRedoing		ifTrue: [prior := sym := selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret := self startIndex.			self selectPrecedingIdentifier.			input := self selection]		ifFalse: "Repeated Ctrl-q"			[caret := UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input := hintText.			prior := selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym := Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart := self startIndex.			outStream := WriteStream on: (String new: 2 * sym size).			1 to: (kwds := sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret := newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection := input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection := self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone := true].			view flash].	self selectAt: caret! !ParagraphEditor initialize!