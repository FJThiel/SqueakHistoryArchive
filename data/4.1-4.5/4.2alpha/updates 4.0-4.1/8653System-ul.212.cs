"Change Set:		8653System-ul.212System-ul.212:- new TextDiffBuilder implementationSystem-ul.207:- added TextDiffBuilderTestSystem-ul.208:- new tests and a fixSystem-dtl.209:Remove #isMorphic sends from Rectangle, supported by #pointerMoved in Project and MorphicProject.System-klub.209:- new TextDiffBuilder implementationSystem-dtl.210:Move #restoreDisplay implementation from ScreenController to Project to eliminate #isMorphic sends.Eliminate #isMorphic from #snapshot:andQuit:embedded: by adding #startUpComplete to Project and MorphicProject.Move #offerMenuFrom:shifted: from StringHolder to Project to eliminate #isMorphic send.System-klub.210:- use #pairsDo: instead of #groupsOf:atATimeDo: in #findMatches- make sure that inserts are listed before removes in the patchSequenceSystem-dtl.211:Rename #startUpComplete to #wakeUpTopWindow because it is used in contexts other than image startup. Change ChangesOrganizer class>>reorderChangesSets to use 'Project current wakeUpTopWindow' rather than an #isMorphic test."!Object subclass: #TextDiffBuilder	instanceVariableNames: 'xLines yLines'	classVariableNames: 'InsertTextAttributes NormalTextAttributes RemoveTextAttributes'	poolDictionaries: ''	category: 'System-FilePackage'!TestCase subclass: #TextDiffBuilderTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-FilePackage-Tests'!Object subclass: #DiffElement	instanceVariableNames: 'string hash match'	classVariableNames: ''	poolDictionaries: ''	category: 'System-FilePackage'!TextDiffBuilder subclass: #PrettyTextDiffBuilder	instanceVariableNames: 'sourceClass'	classVariableNames: ''	poolDictionaries: ''	category: 'System-FilePackage'!TextDiffBuilder subclass: #ClassDiffBuilder	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'System-FilePackage'!!DiffElement methodsFor: 'accessing' stamp: 'klub 12/27/2009 01:20'!match: aDiffMatch	match := aDiffMatch	! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'klub 12/28/2009 00:16'!buildDisplayPatch	^Text streamContents: [ :stream |		self 			patchSequenceDoIfMatch: [ :string |				self print: string withAttributes: NormalTextAttributes on: stream ]			ifInsert: [ :string |				self print: string withAttributes: InsertTextAttributes on: stream ]			ifRemove: [ :string |				self print: string withAttributes: RemoveTextAttributes on: stream ] ]! !!DiffElement methodsFor: 'comparing' stamp: 'ul 12/26/2009 01:10'!hash	^hash! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testSameSequence	| patch |	patch := self patchSequenceFor: #(a b c) and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!DiffElement methodsFor: 'accessing' stamp: 'klub 12/27/2009 01:20'!matches: aDiffMatch	match := aDiffMatch.	aDiffMatch match: self! !!DiffElement methodsFor: 'accessing' stamp: 'ul 12/26/2009 01:48'!string	^string! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:09'!testEmptySequences	| patch |	patch := self patchSequenceFor: #() and: #().	self assert: patch isEmpty! !!DiffElement methodsFor: 'accessing' stamp: 'ul 12/26/2009 04:38'!match	^match! !!PrettyTextDiffBuilder methodsFor: 'private' stamp: 'ul 12/27/2009 18:51'!split: aString	| formatted |	aString ifEmpty: [ ^super split: aString ].	formatted := [		sourceClass prettyPrinterClass			format: aString			in: sourceClass			notifying: nil			decorated: false ] 				on: Error				do: [ :ex | aString ].	^super split: formatted! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'klub 12/28/2009 04:16'!from: xString to: yString	xLines := (self split: xString asString) replace: [ :each | DiffElement string: each ].	yLines := (self split: yString asString) replace: [ :each | DiffElement string: each ].	self findMatches! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testEmptyLcs1	| patch |	patch := self patchSequenceFor: #(a b c) and: #().	self assert: patch size = 3.	self assert: (patch allSatisfy: [ :each | each key = #remove ])! !!DiffElement methodsFor: 'testing' stamp: 'klub 12/27/2009 01:56'!hasMatch	^match notNil! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'klub 12/29/2009 15:44'!patchSequenceDoIfMatch: matchBlock ifInsert: insertBlock ifRemove: removeBlock	"I'm the general purpose method to iterate through the patch sequence. See my senders to learn how to use me."	| xLine xLineStream |	xLineStream := xLines readStream.	yLines do: [ :yLine | 		yLine hasMatch 			ifFalse: [ insertBlock value: yLine string  ]			ifTrue: [				[ (xLine := xLineStream next) == nil or: [ xLine == yLine match  ] ]					whileFalse: [ removeBlock value: xLine string ].				matchBlock value: yLine string ] ].	[ (xLine := xLineStream next) == nil ] whileFalse: [		removeBlock value: xLine string ]! !!TextDiffBuilder methodsFor: 'private' stamp: 'klub 12/28/2009 03:49'!lcsFor: xFilteredLines and: yFilteredLines	"I find one of the longest common subsequences of my the arguments. I assume that none of my arguments are empty. I return an OrderedCollection with 2 * L elements where L is the length of the longest common subsequence. Every odd indexed element is from the first argument others are from the second. I'm a modified version of the greedy lcs algorithm from the 6th page of 'An O(ND) Difference Algorithm and Its Variations (1986)' by Eugene W. Myers"	| n m v lcs lcss max x y |	n := xFilteredLines size.	m := yFilteredLines size.	max := m + n.	v := Array new: 2 * max + 1.	v at: max + 2 put: 0.	lcss := Array new: 2 * max + 1.	0 to: max do: [ :d |		d negated to: d by: 2 do: [ :k |			| index |			(k + d = 0 or: [ k ~= d and: [ (v at: max + k ) < (v at: max + k + 2) ] ])				ifTrue: [ 					index := max + k + 2.					x := v at: index ]				ifFalse: [ 					index := max + k.					x := (v at: index) + 1 ].			lcs := nil.			y := x - k.			[ x < n and: [ y < m and: [ (xFilteredLines at: x + 1) = (yFilteredLines at: y + 1) ] ] ]				whileTrue: [					(lcs ifNil: [ 						lcs := (lcss at: index) 							ifNil: [ OrderedCollection new ]							ifNotNil: [ :oc | oc copy ] ])								add: (xFilteredLines at: x + 1);								add: (yFilteredLines at: y + 1).					x := x + 1.					y := y + 1 ].			v at: max + k + 1 put: x.			lcss at: max + k + 1 put: (lcs ifNil: [ 				lcs := (lcss at: index) 					ifNil: [ nil ]					ifNotNil: [ :oc | oc copy ] ]).			(x >= n and: [ y >= m ]) ifTrue: [				^lcs ifNil: [ (lcss at: index) ifNil: [ #() ] ] ] ] ].	self error! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:23'!testEmptyLcs2	| patch |	patch := self patchSequenceFor: #() and: #(a b c).	self assert: patch size = 3.		self assert: (patch allSatisfy: [ :each | each key = #insert ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'klub 12/28/2009 00:02'!testEmptyLcs3	| patch |	patch := self patchSequenceFor: #(a b c) and: #(d e f g).	self assert: patch size = 7.		patch do: [ :each |		each key = #remove ifTrue: [ self assert: ('abc' includes: each value first) ].		each key = #insert ifTrue: [ self assert: ('defg' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:12'!testIfPatchIsMinimal	| patch |	patch := self patchSequenceFor: #(a a a b) and: #(a b a a).	self assert: patch size = 5.	"lcs is aaa"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $a ]			ifFalse: [ self assert: each value first = $b ] ]! !!DiffElement methodsFor: 'comparing' stamp: 'ul 12/26/2009 01:47'!= anObject	^anObject class == self class and: [		anObject hash = hash and: [			anObject string = string ] ]! !!DiffElement class methodsFor: 'as yet unclassified' stamp: 'klub 12/27/2009 01:51'!string: aString	^self new		string: aString;		yourself! !!Project methodsFor: 'enter' stamp: 'dtl 12/28/2009 22:55'!wakeUpTopWindow	"Image has been restarted, and the startUp list has been processed. Perform	any additional actions needed to restart the user interface."	^ self! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/27/2009 21:24'!testSameSequenceWithRepetitions	| patch |	patch := self patchSequenceFor: #(a a b a) and: #(a a b a).	self assert: patch size = 4.		self assert: (patch allSatisfy: [ :each | each key = #match ])! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:12'!testIfSequence1	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d c b a).	self assert: patch size = 7.	"lcs is any one letter sequence"	self assert: (patch count: [ :each | each key = #match ]) = 1.	self assert: (patch count: [ :each | each key = #insert ]) = 3.	self assert: (patch count: [ :each | each key = #remove ]) = 3.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: each value first = $d ]			ifFalse: [ self assert: ('abc' includes: each value first) ] ]! !!TextDiffBuilder class methodsFor: 'class initialization' stamp: 'klub 12/27/2009 01:27'!initializeTextAttributes	InsertTextAttributes := { TextColor red }.	RemoveTextAttributes := { TextEmphasis struckOut. TextColor blue }.	NormalTextAttributes :={ TextEmphasis normal }! !!TextDiffBuilder class methodsFor: 'instance creation' stamp: 'klub 12/27/2009 02:59'!buildDisplayPatchFrom: sourceText to: destinationText	^(self from: sourceText to: destinationText) buildDisplayPatch! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 05:58'!testIfSequence2	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(c d b a).	self assert: patch size = 6.	"lcs is cd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('cd' includes: each value first) ]			ifFalse: [ self assert: ('ab' includes: each value first) ] ]! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'dtl 12/28/2009 22:55'!snapshot: save andQuit: quit embedded: embeddedFlag	"Mark the changes file and close all files as part of #processShutdownList.	If save is true, save the current state of this Smalltalk in the image file.	If quit is true, then exit to the outer OS shell.	The latter part of this method runs when resuming a previously saved image. This resume logic checks for a document file to process when starting up."	| resuming msg |	Object flushDependents.	Object flushEvents.	(SourceFiles at: 2) ifNotNil:[		msg := String streamContents: [ :s |			s nextPutAll: '----';			nextPutAll: (save ifTrue: [ quit ifTrue: [ 'QUIT' ] ifFalse: [ 'SNAPSHOT' ] ]							ifFalse: [quit ifTrue: [ 'QUIT/NOSAVE' ] ifFalse: [ 'NOP' ]]);			nextPutAll: '----';			print: Date dateAndTimeNow; space;			nextPutAll: (FileDirectory default localNameFor: self imageName);			nextPutAll: ' priorSource: ';			print: LastQuitLogPosition ].		self assureStartupStampLogged.		save ifTrue: [ LastQuitLogPosition := (SourceFiles at: 2) setToEnd; position ].		self logChange: msg.		Transcript cr; show: msg	].	Smalltalk processShutDownList: quit.	Cursor write show.	save ifTrue: [resuming := embeddedFlag 					ifTrue: [self snapshotEmbeddedPrimitive] 					ifFalse: [self snapshotPrimitive].  "<-- PC frozen here on image file"				resuming == false "guard against failure" ifTrue:					["Time to reclaim segment files is immediately after a save"					Smalltalk at: #ImageSegment						ifPresent: [:theClass | theClass reclaimObsoleteSegmentFiles]]]		ifFalse: [resuming := false].	quit & (resuming == false) ifTrue: [self quitPrimitive].	Cursor normal show.	Smalltalk setGCParameters.	resuming == true ifTrue: [Smalltalk clearExternalObjects].	Smalltalk processStartUpList: resuming == true.	resuming == true ifTrue:[		self setPlatformPreferences.		self recordStartupStamp].	Project current wakeUpTopWindow.	"Now it's time to raise an error"	resuming == nil ifTrue: [self error:'Failed to write image file (disk full?)'].	^ resuming! !!TextDiffBuilder class methodsFor: 'instance creation' stamp: 'ul 12/27/2009 17:16'!buildDisplayPatchFrom: sourceText to: destinationText inClass: sourceClass 		self deprecated: 'Use #buildDisplayPatchFrom:to:inClass:prettyDiffs:'.	^self 		buildDisplayPatchFrom: sourceText 		to: destinationText		inClass: sourceClass		prettyDiffs: (Preferences valueOfFlag: #diffsWithPrettyPrint)! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 05:59'!testIfSequence3	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(b d c a).	self assert: patch size = 6.	"lcs is bd"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bd' includes: each value first) ]			ifFalse: [ self assert: ('ac' includes: each value first) ] ]! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:00'!testIfSequence4	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d b c a).	self assert: patch size = 6.	"lcs is bc"	self assert: (patch count: [ :each | each key = #match ]) = 2.	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('bc' includes: each value first) ]			ifFalse: [ self assert: ('ad' includes: each value first) ] ]! !!TextDiffBuilder methodsFor: 'private' stamp: 'klub 12/29/2009 15:43'!findMatches	"I find the matching pairs of xLines and yLines. First I filter out all lines that can't have a pair, then I find the longest common subsequence of the remaining elements. Finally I mark the matching pairs."	| lineSet lcs xFilteredLines yFilteredLines |	lineSet := yLines asSet.	xFilteredLines := xLines select: [ :each |		lineSet includes: each ].	xFilteredLines size = 0 ifTrue: [ ^self ].	lineSet := xLines asSet.	yFilteredLines := yLines select: [ :each |		(lineSet includes: each) ].	yFilteredLines size = 0 ifTrue: [ ^self ].	lcs := self		lcsFor: xFilteredLines		and: yFilteredLines.	lcs pairsDo: [ :first :second | first matches: second ]! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ul 12/27/2009 23:37'!buildPatchSequence	"This method is only implemented for backwards compatibility and testing."	^Array streamContents: [ :stream |		self 			patchSequenceDoIfMatch: [ :string | stream nextPut: #match -> string ]			ifInsert: [ :string | stream nextPut: #insert -> string ]			ifRemove: [ :string | stream nextPut: #remove -> string ] ]! !!Project methodsFor: 'utilities' stamp: 'dtl 12/28/2009 19:52'!offerMenuFrom: menuRetriever shifted: aBoolean	"Pop up a menu whose target is the receiver and whose contents are provided	by sending the menuRetriever to the receiver. The menuRetriever takes two	arguments: a menu, and a boolean representing the shift state."	self subclassResponsibility! !!ClassDiffBuilder methodsFor: 'private' stamp: 'klub 12/28/2009 04:14'!split: aString	"I return an array with aString splitted by Character >> #separators."	^Array streamContents: [ :stream |		| out |		out := aString copy writeStream.		aString do: [ :c |			out nextPut: c.			c isSeparator ifTrue:[				stream nextPut: out contents.				out reset ] ].		out position = 0 ifFalse: [ 			stream nextPut: out contents ] ]! !!DiffElement methodsFor: 'printing' stamp: 'klub 12/27/2009 01:52'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: hash;		nextPutAll: ', ';		print: string;		nextPutAll: ', ';		print: (match class == self class);		nextPut: $)! !!Project methodsFor: 'utilities' stamp: 'dtl 12/28/2009 13:08'!pointerMoved	"Pointer has moved during a drag operation. Perform any necessary updates."	^ self! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:09'!testIfSequence5	| patch matches nonMatches |	patch := self patchSequenceFor: #(a b c d) and: #(c d a b).	self assert: patch size = 6.	"lcs is ab or cd"	matches := (patch select: [ :each | each key = #match ])		collect: [ :each | each value first ] as: String.	self assert: (#('ab' 'cd') includes: matches).	self assert: (patch count: [ :each | each key = #insert ]) = 2.	self assert: (patch count: [ :each | each key = #remove ]) = 2.	nonMatches := #('ab' 'cd') detect: [ :each | each ~= matches ].	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: (matches includes: each value first) ]			ifFalse: [ self assert: (nonMatches includes: each value first) ] ]! !!Project methodsFor: 'displaying' stamp: 'dtl 12/28/2009 16:13'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	self subclassResponsibility! !!TextDiffBuilderTest methodsFor: 'private' stamp: 'ul 12/27/2009 21:03'!patchSequenceFor: x and: y	^(TextDiffBuilder		from: (self convertToString: x)		to:  (self convertToString: y)) buildPatchSequence! !!TextDiffBuilder class methodsFor: 'instance creation' stamp: 'klub 12/27/2009 01:46'!from: sourceText to: destinationText	^self new		from: sourceText to: destinationText;		yourself! !!TextDiffBuilderTest methodsFor: 'private' stamp: 'klub 12/28/2009 00:04'!convertToString: array	^String streamContents: [ :stream |		array do: [ :each |			stream nextPutAll: each asString; cr ] ]! !!PrettyTextDiffBuilder methodsFor: 'initialize' stamp: 'klub 12/27/2009 04:59'!sourceClass: aClass	sourceClass := aClass.! !!TextDiffBuilderTest methodsFor: 'tests' stamp: 'ul 12/28/2009 06:10'!testIfSequence6	| patch |	patch := self patchSequenceFor: #(a b c d) and: #(d a b c).	self assert: patch size = 5.	"lcs is abc"	self assert: (patch count: [ :each | each key = #match ]) = 3.	self assert: (patch count: [ :each | each key = #insert ]) = 1.	self assert: (patch count: [ :each | each key = #remove ]) = 1.	patch do: [ :each | 		each key = #match 			ifTrue: [ self assert: ('abc' includes: each value first) ]			ifFalse: [ self assert: each value first = $d ] ]! !!ClassDiffBuilder methodsFor: 'private' stamp: 'klub 12/28/2009 00:22'!print: aString withAttributes: attributes on: stream	stream		withAttributes: attributes 		do: [ stream nextPutAll: aString ]! !!TextDiffBuilder class methodsFor: 'class initialization' stamp: 'klub 12/27/2009 01:26'!initialize	self initializeTextAttributes! !!DiffElement methodsFor: 'accessing' stamp: 'klub 12/28/2009 05:09'!string: aString	string := aString.	string isOctetString ifTrue: [ "Make sure that #hash will return the same value if the strings are equal."		string := string asOctetString ].	hash := string hash! !!TextDiffBuilder methodsFor: 'private' stamp: 'klub 12/28/2009 04:12'!split: aString	"I return an Array of strings which are the lines extracted from aString. All lines contain the line separator characters"	^Array streamContents: [ :stream |		aString lineIndicesDo: [ :start :endWithoutSeparators :end |			stream nextPut: (aString copyFrom: start to: end) ] ]! !!TextDiffBuilder methodsFor: 'private' stamp: 'klub 12/28/2009 00:21'!print: aString withAttributes: attributes on: stream	stream		withAttributes: attributes 		do: [ 			stream nextPutAll: aString.			(aString isEmpty or: [ aString last ~= Character cr ]) ifTrue: [ stream cr ] ]! !!PrettyTextDiffBuilder class methodsFor: 'instance creation' stamp: 'klub 12/27/2009 04:59'!from: srcString to: dstString inClass: srcClass 	^ (self new sourceClass: srcClass) from: srcString to: dstString		! !!TextDiffBuilder class methodsFor: 'instance creation' stamp: 'ul 12/27/2009 17:16'!buildDisplayPatchFrom: sourceText to: destinationText inClass: sourceClass prettyDiffs: prettyDiffs		^((sourceClass notNil and: [ prettyDiffs ])		ifFalse: [ self from: sourceText to: destinationText ]		ifTrue: [			PrettyTextDiffBuilder				from: sourceText				to: destinationText				inClass: sourceClass ]) buildDisplayPatch! !TwoLevelSet removeSelector: #isEmpty!TwoLevelDictionary removeSelector: #initialize!TextDiffBuilder removeSelector: #attributesOf:!ClassDiffBuilder removeSelector: #printPatchSequence:on:!TwoLevelDictionary removeSelector: #twoLevelKeys!TwoLevelSet removeSelector: #removeAllXAndY:!TextDiffBuilder removeSelector: #splitCharacter!TextDiffBuilder removeSelector: #stringHashBlock!Smalltalk removeClassNamed: #TwoLevelSet!TextDiffBuilder removeSelector: #processDiagonalsFrom:!TextDiffBuilder removeSelector: #generatePatchSequence!TextDiffBuilder removeSelector: #printPatchSequence:on:!TextDiffBuilder removeSelector: #pointEqualBlock!TextDiffBuilder removeSelector: #collectRunFrom:startingWith:into:!TextDiffBuilder removeSelector: #processDiagonals!Smalltalk removeClassNamed: #TwoLevelDictionary!TextDiffBuilder removeSelector: #split:by:!TextDiffBuilder removeSelector: #hasMultipleMatches!TextDiffBuilder removeSelector: #pointHashBlock!TextDiffBuilder removeSelector: #incorporateAddsInto:!TextDiffBuilder removeSelector: #buildReferenceMap!TwoLevelSet removeSelector: #do:!TextDiffBuilder removeSelector: #incorporateMatchesInto:!TwoLevelDictionary removeSelector: #at:!TextDiffBuilder removeSelector: #processShiftedRuns!TwoLevelSet removeSelector: #includes:!TextDiffBuilder removeSelector: #validateRuns:!TextDiffBuilder removeSelector: #detectShiftedRuns!TwoLevelSet removeSelector: #copy!TextDiffBuilder removeSelector: #formatLine:!TextDiffBuilder removeSelector: #remove:from:!TextDiffBuilder removeSelector: #sourceString:!TwoLevelDictionary removeSelector: #keysDo:!TwoLevelSet removeSelector: #initialize!TwoLevelSet removeSelector: #add:!TextDiffBuilder removeSelector: #incorporateRemovalsInto:!TwoLevelSet removeSelector: #detect:!TextDiffBuilder removeSelector: #destString:!TwoLevelDictionary removeSelector: #at:put:!TwoLevelSet removeSelector: #remove:!TextDiffBuilder initialize!