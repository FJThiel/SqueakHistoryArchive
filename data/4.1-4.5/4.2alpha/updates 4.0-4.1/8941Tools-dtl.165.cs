"Change Set:		8941Tools-dtl.165Tools-dtl.165:Move PopUpMenu from ST80-Menus to Tools-Menus.Remove explicit MVC and Morphic dependencies from PopUpMenu.Tools-ar.162:Replace offerMenuFrom:shifted: by offerMenu:from:shifted: which takes an additional argument, the model to retrieve the menu from and perform the actions on.Tools-ar.163:Fix setting the editString in Browser opening.Tools-ar.164:CodeHolder>>validateMessageSource: should parse the selector proper instead of using #findString: which causes all sorts of random warnings."!Object subclass: #PopUpMenu	instanceVariableNames: 'labelString font lineArray frame form marker selection'	classVariableNames: 'CacheMenuForms MenuStyle'	poolDictionaries: ''	category: 'Tools-Menus'!!Browser methodsFor: 'initialize-release' stamp: 'ar 1/19/2010 20:39'!openMessageCatEditString: aString        "Create a pluggable version of the views for a Browser that just shows one message category."	"Example: 		Preferences browseThemes.	" 	| builder max |	aString ifNotNil:[		"Note: The views aren't actually built yet after we've called buildWindowWith:.		Since we can't send changed: #editString before the views have been built		we just shoot the #changed: message into the #future. This is the easiest		way to solve this issue locally."		self future changed: #editString with: aString].	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0@0 corner: 1.0@0.08) -> [self buildMessageListCatSingletonWith: builder].		(0.0@0.08 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:57'!notify: message	"Deprecated. Use #inform: instead."	self inform: message! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'sw 12/6/1999 13:08'!initialize  "PopUpMenu initialize"	(MenuStyle := TextStyle default copy)		gridForFont: TextStyle default defaultFontIndex withLead: 0;		centered.	PopUpMenu allSubInstancesDo: [:m | m rescan]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'dtl 1/30/2010 16:16'!startUpLeftFlush	"Build and invoke this menu with no initial selection.  By Jerry Archibald, 4/01.	If in MVC, align menus items with the left margin.	Answer the selection associated with the menu item chosen by the user or nil if none is chosen.  	The mechanism for getting left-flush appearance in mvc leaves a tiny possibility for misadventure: if the user, in mvc, puts up the jump-to-project menu, then hits cmd period while it is up, then puts up a second jump-to-project menu before dismissing or proceeding through the debugger, it's possible for mvc popup-menus thereafter to appear left-aligned rather than centered; this very unlikely condition can be cleared by evaluating 'PopUpMenu alignment: 2'"	^ Project current		dispatchTo: self		addPrefixAndSend: #StartUpLeftFlush		withArguments: #()! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 6/1/2000 13:01'!markerOn: aPoint 	"The item whose bounding area contains aPoint should be marked as 	selected. Highlight its area and set the selection to its index."	selection = 0 | (marker containsPoint: aPoint) not 		ifTrue: [selection = 0 & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[selection > 0 ifTrue: [Display reverse: marker].						marker := 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection := marker top - frame top // marker height + 1! !!PopUpMenu methodsFor: 'marker adjustment' stamp: ''!markerTop: aPoint 	"Answer aPoint, gridded to lines in the receiver."	^(aPoint y - frame inside top truncateTo: font height) + frame inside top! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:44'!labelArray: labelArray	"Answer an instance of me whose items are in labelArray."	^ self labelArray: labelArray lines: nil! !!PopUpMenu methodsFor: 'private' stamp: ''!computeLabelParagraph	"Answer a Paragraph containing this menu's labels, one per line and centered."	^ Paragraph withText: labelString asText style: MenuStyle! !!PopUpMenu methodsFor: 'displaying' stamp: 'sw 12/10/1999 09:55'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame := frame align: marker leftCenter with: aPoint + (2@0).	outerFrame := frame.	captionOrNil notNil ifTrue:		[captionText := (DisplayText				text: captionOrNil asText				textStyle: MenuStyle copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame := captionText boundingBox insetBy: -2.		outerFrame := frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta := outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta := 0 - frame width @ delta y].	frame := frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm := captionText form.		captionBox := captionForm boundingBox expandBy: 4.		captionBox := captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave := Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker := marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea := Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc := frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 13:04'!controlActivity	"Do whatever a menu must do - now with keyboard support."	| didNotMove downPos |	didNotMove := true.	Sensor anyButtonPressed		ifFalse:			[didNotMove := false.			Sensor waitButtonOrKeyboard]. 		Sensor keyboardPressed ifFalse: [self manageMarker].	(didNotMove and: [selection = 0])		ifTrue:			[downPos := Sensor cursorPoint.			[didNotMove and: [Sensor anyButtonPressed]]				whileTrue:					[(downPos dist: Sensor cursorPoint) < 2 ifFalse: [didNotMove := false]].			didNotMove ifTrue: [Sensor waitButtonOrKeyboard]].	[Sensor keyboardPressed] whileTrue:		[self readKeyboard ifTrue: [^ self].		Sensor waitButtonOrKeyboard].	[Sensor anyButtonPressed] whileTrue: [self manageMarker]! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!labelString	^ labelString! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 10:55'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch := Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch := ch asCharacter asLowercase.	labels := labelString findTokens: Character cr asString.	occurences := 0.	1 + selection to: selection + labels size do:		[:index |		| i | i := index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences := occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:43'!labelArray: labelArray lines: lineArray	"Answer an instance of me whose items are in labelArray, with lines 	drawn after each item indexed by anArray. 2/1/96 sw"	labelArray isEmpty ifTrue: [self error: 'Menu must not be zero size'].	^ self		labels: (String streamContents: 			[:stream |			labelArray do: [:each | stream nextPutAll: each; cr].			stream skip: -1 "remove last CR"])		lines: lineArray"Example:	(PopUpMenu labelArray: #('frog' 'and' 'toad') lines: #()) startUp"! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 3/18/2001 00:55'!startUpCenteredWithCaption: captionOrNil	"Differs from startUpWithCaption: by appearing with cursor in the menu,	and thus ready to act on mouseUp, without requiring user tweak to confirm"	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor]) cursorPoint - (20@0)! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'dgd 10/12/2004 13:44'!startUpWithCaption: captionOrNil icon: aForm at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down,	then track the selection as long as the button is pressed. When the button is released, 	answer the index of the current selection, or zero if the mouse is not released over 	any menu item. Location specifies the desired topLeft of the menu body rectangle."	^ self			startUpWithCaption: captionOrNil			icon: aForm			at: location			allowKeyboard: Preferences menuKeyboardControl! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'jla 4/2/2001 20:41'!alignment	^ MenuStyle alignment! !!PopUpMenu methodsFor: 'accessing' stamp: 'di 4/20/1999 14:33'!frameHeight	"Designed to avoid the entire frame computation (includes MVC form),	since the menu may well end up being displayed in Morphic anyway."	| nItems |	frame ifNotNil: [^ frame height].	nItems := 1 + (labelString occurrencesOf: Character cr).	^ (nItems * MenuStyle lineGrid) + 4 "border width"! !!StringHolder methodsFor: '*Tools' stamp: 'ar 1/10/2010 10:24'!offerMenuFrom: menuRetriever shifted: aBoolean	"Pop up a menu whose target is the receiver and whose contents are provided	by sending the menuRetriever to the receiver. The menuRetriever takes two	arguments: a menu, and a boolean representing the shift state."	Project current offerMenu: menuRetriever from: self shifted: aBoolean! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'dgd 10/12/2004 13:43'!startUpWithCaption: captionOrNil icon: aForm	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self			startUpWithCaption: captionOrNil			icon: aForm			at: (ActiveHand ifNil:[Sensor]) cursorPoint! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'jla 4/2/2001 20:56'!leftFlush	MenuStyle leftFlush! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'nk 8/30/2004 07:59'!withCaption: cap chooseFrom: labels 	"Simply put up a menu. Get the args in the right order with the caption 	first. labels may be either an array of items or a string with CRs in it. 	May use backslashes for returns."	^ (labels isString		ifTrue: [self labels: labels withCRs lines: nil]		ifFalse: [self labelArray: labels lines: nil])		startUpWithCaption: cap withCRs! !!PopUpMenu methodsFor: 'private' stamp: 'BG 8/6/2003 12:34'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm inside |	borderInset := 4@4.	paraForm := (DisplayText text: labelString asText textStyle: MenuStyle) form.	menuForm := Form extent: paraForm extent + (borderInset * 2) depth: paraForm depth.      menuForm fill: (0 @ 0 extent: menuForm  extent)                        rule: Form over                        fillColor: Color white.	menuForm borderWidth: 2.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse:		[lineArray do:			[ :line |			menuForm fillBlack: (4 @ ((line * font height) + borderInset y)				extent: (menuForm width - 8 @ 1))]].	frame := Quadrangle new.	frame region: menuForm boundingBox.	frame borderWidth: 4.	inside := frame inside.	marker := inside topLeft extent: (inside width @ MenuStyle lineGrid).	selection := 1.	^ form := menuForm! !!PopUpMenu methodsFor: 'private' stamp: 'sma 2/5/2000 11:56'!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString := 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	frame := marker := form := nil.	"PopUpMenu allSubInstancesDo: [:m | m rescan]"! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'dtl 1/30/2010 17:13'!inform: aString	"PopUpMenu inform: 'I like Squeak'"	| iconOrNil |	iconOrNil := (Smalltalk at: #MenuIcons ifAbsent: []) ifNotNilDo: [:cls | cls confirmIcon].	(PopUpMenu labels: ' OK ' translated)		startUpWithCaption: aString		icon: iconOrNil! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!lineArray	^ lineArray! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'yo 3/15/2005 12:55'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:44'!center	"Answer the point at the center of the receiver's rectangular area."	^ frame center! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 5/28/2000 15:27'!markerOff	"No item is selected. Reverse the highlight if any item has been marked 	as selected."	self setSelection: 0! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'jla 4/2/2001 20:46'!alignment: anAlignment	^ MenuStyle alignment: anAlignment! !!PopUpMenu methodsFor: 'basic control sequence' stamp: ''!startUp	"Display and make a selection from the receiver as long as the button 	is pressed. Answer the current selection."		^ self startUpWithCaption: nil! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 12/27/2001 22:47'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down,	then track the selection as long as the button is pressed. When the button is released, 	answer the index of the current selection, or zero if the mouse is not released over 	any menu item. Location specifies the desired topLeft of the menu body rectangle."		^ self startUpWithCaption: captionOrNil at: location allowKeyboard: Preferences menuKeyboardControl! !!CodeHolder methodsFor: 'message list' stamp: 'ar 1/21/2010 20:43'!validateMessageSource: sourceString forSelector: aSelector	"Check whether there is evidence that method source is invalid"	| sourcesName |	(self selectedClass parserClass new parseSelector: sourceString asString) = aSelector		ifFalse: [sourcesName := FileDirectory localNameFor: SmalltalkImage current sourcesName.			self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.(Occasionally, the source code for a method may legitimatelystart with a non-alphabetic character -- for example, Behaviormethod #formalHeaderPartsFor:.  In such rare cases, you canhappily disregard this warning.)'].! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 17:51'!menuForm	"Answer a Form to be displayed for this menu."	form == nil ifTrue: [self computeForm].	^ form! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 4/13/1999 17:42'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt := Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				((Display boundingBox insetBy: 0@3) containsPoint: pt)					ifFalse: [pt := pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'ar 3/18/2001 00:55'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil at: (ActiveHand ifNil:[Sensor]) cursorPoint! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'dtl 1/30/2010 16:10'!startUpWithCaption: captionOrNil icon: aForm at: location allowKeyboard: aBoolean	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."	| maxHeight |	(ProvideAnswerNotification signal: captionOrNil) ifNotNil:		[:answer | ^ selection := answer ifTrue: [1] ifFalse: [2]].		 	maxHeight := Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location			allowKeyboard: aBoolean].	^ Project current		dispatchTo: self		addPrefixAndSend: #StartUpWithCaption:icon:at:allowKeyboard:		withArguments: {captionOrNil. aForm. location. aBoolean}! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'yo 3/15/2005 12:55'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 5/28/2000 12:27'!selection	"Answer the current selection."	^ selection! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sw 12/17/2001 17:01'!startUpWithoutKeyboard	"Display and make a selection from the receiver as long as the button  is pressed. Answer the current selection.  Do not allow keyboard input into the menu"		^ self startUpWithCaption: nil at: ((ActiveHand ifNil:[Sensor]) cursorPoint) allowKeyboard: false! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sw 12/6/1999 17:55'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^ self new		labels: aString		font: MenuStyle defaultFont		lines: anArray! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'dgd 4/4/2006 14:47'!startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean	"Display the menu, with caption if supplied. Wait for the mouse button to go down, then track the selection as long as the button is pressed. When the button is released,	Answer the index of the current selection, or zero if the mouse is not released over  any menu item. Location specifies the desired topLeft of the menu body rectangle. The final argument indicates whether the menu should seize the keyboard focus in order to allow the user to navigate it via the keyboard."	^ self			startUpWithCaption: captionOrNil			icon: nil			at: location			allowKeyboard: aBoolean! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 12:32'!nItems	^ (labelString occurrencesOf: Character cr) + 1! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 3/9/98 19:46'!scrollIntoView: cursorLoc	| dy |	dy := 0.	cursorLoc y < 2 ifTrue: [dy := font height].	cursorLoc y > (Display height-3) ifTrue: [dy := font height negated].	dy = 0 ifTrue: [^ 0@0].	self markerOff.	frame := frame translateBy: 0@dy.	marker := marker translateBy: 0@dy.	self menuForm displayOn: Display at: frame topLeft.	^ 0@dy! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 6/1/2000 11:01'!setSelection: index	| newSelection |	selection = index ifTrue: [^ self].	newSelection := (0 max: index) min: frame height // marker height.	selection > 0 ifTrue: [Display reverse: marker].	marker := marker translateBy: 0 @ (newSelection - selection * marker height).	selection := newSelection.	selection > 0 ifTrue: [Display reverse: marker]! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'dgd 9/5/2003 18:24'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"PopUpMenu confirm: 'Are you hungry?'"	^ self confirm: queryString trueChoice: 'Yes' translated falseChoice: 'No' translated! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'nk 9/1/2004 10:27'!setMenuFontTo: aFont	"Set the menu font as indicated"	MenuStyle := TextStyle fontArray: { aFont }.	MenuStyle 		gridForFont: 1 withLead: 0;		centered.	self allSubInstancesDo: [:m | m rescan]! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'dgd 10/12/2004 13:49'!confirm: queryString orCancel: cancelBlock 	"Put up a yes/no/cancel menu with caption aString. Answer 	true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond 	yes or no."	"PopUpMenu confirm: 'Reboot universe' orCancel: 	[^'Nevermind'] "	| menu choice |	menu := PopUpMenu labelArray: {'Yes' translated. 'No' translated. 'Cancel' translated}.	choice := menu startUpWithCaption: queryString icon: MenuIcons confirmIcon.	choice = 1		ifTrue: [^ true].	choice = 2		ifTrue: [^ false].	^ cancelBlock value! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:36'!labels: aString	"Answer an instance of me whose items are in aString."	^ self labels: aString lines: nil! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 16:21'!labels: aString font: aFont lines: anArray	labelString := aString.	font := aFont.	lineArray := anArray.! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'dgd 10/12/2004 13:49'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice 	"Put up a yes/no menu with caption queryString. The actual 	wording  	for the two choices will be as provided in the trueChoice and  	falseChoice parameters. Answer true if the response is the 	true-choice,  	false if it's the false-choice. 	This is a modal question -- the user must respond one way or 	the other."	"PopUpMenu  	confirm: 'Are you hungry?' 	trueChoice: 'yes, I''m famished' 	falseChoice: 'no, I just ate'"	| menu choice |	menu := PopUpMenu labelArray: {trueChoice. falseChoice}.	[(choice := menu startUpWithCaption: queryString icon: MenuIcons confirmIcon) isNil] whileTrue.	^ choice = 1! !PopUpMenu initialize!