"Change Set:		7339Kernel-ar.197Kernel-ar.197:The valueSuppressing/SupplyingAnswers protocol was missing from BlockClosure which caused several tests to fail.Kernel-ar.192:Post-closure cleanup and underscore removal.Kernel-nice.193:Fixes for both:http://bugs.squeak.org/view.php?id=6729Float infinity closeTo: Float infinity negated.http://bugs.squeak.org/view.php?id=73681.0 closeTo: 200 factorial.Kernel-nice.194:Fix forhttp://bugs.squeak.org/view.php?id=7134Float rounded is inexactKernel-nice.195:Fix forhttp://bugs.squeak.org/view.php?id=69900.0 significandAsIntegerKernel-nice.196:remove #asFloatSimplyhttp://bugs.squeak.org/view.php?id=7040#asFloatSimply was introduced temporarily by me for fixinghttp://bugs.squeak.org/view.php?id=3564However, it was soon superseded, and I doubt it were ever used.I propose to not even deprecate it, but simply remove it."!!Class methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 17:35'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| internalStream |	internalStream := WriteStream on: (String new: 100).	internalStream header; timeStamp.	self sharedPools size > 0 ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: internalStream]].	self fileOutOn: internalStream moveSource: false toFile: 0.	internalStream trailer.	FileStream writeSourceCodeFrom: internalStream baseName: self name isSt: true useHtml: useHtml.! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 4/24/1999 19:29'!mapData 	"Force the data through the map (permutation) to create the data to test."	thisData := data collect: [:realData |					argMap collect: [:ind | realData at: ind]].		! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!renameCategory: oldCatString toBe: newCatString	"Rename a category. No action if new name already exists, or if old name does not exist."	| index oldCategory newCategory |	oldCategory := oldCatString asSymbol.	newCategory := newCatString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^ self].	"new name exists, so no action"	(index := categoryArray indexOf: oldCategory) = 0		ifTrue: [^ self].	"old name not found, so no action"	categoryArray := categoryArray copy.  "need to change identity so smart list update will notice the change"	categoryArray at: index put: newCategory! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 13:03'!informUserDuring: aBlock	self class isSilent ifTrue:[^aBlock value].	Utilities informUserDuring:[:bar|		progress := bar.		aBlock value].	progress := nil.! !!Number methodsFor: 'truncation and round off' stamp: ''!floor	"Answer the integer nearest the receiver toward negative infinity."	| truncation |	truncation := self truncated.	self >= 0 ifTrue: [^truncation].	self = truncation		ifTrue: [^truncation]		ifFalse: [^truncation - 1]! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:16'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime := self isRedoing		ifTrue: [prior := sym := selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret := self startIndex.			self selectPrecedingIdentifier.			input := self selection]		ifFalse: "Repeated Ctrl-q"			[caret := UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input := hintText.			prior := selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym := Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart := self startIndex.			outStream := WriteStream on: (String new: 2 * sym size).			1 to: (kwds := sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret := newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection := input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection := self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone := true].			view flash].	self selectAt: caret! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 3/5/2004 03:44'!return: value from: aSender 	"For simulation.  Roll back self to aSender and return value from it.  Execute any unwind blocks on the way.  ASSUMES aSender is a sender of self"	| newTop ctxt |	aSender isDead ifTrue: [		^ self send: #cannotReturn: to: self with: {value} super: false].	newTop := aSender sender.	ctxt := self findNextUnwindContextUpTo: newTop.	ctxt ifNotNil: [		^ self send: #aboutToReturn:through: to: self with: {value. ctxt} super: false].	self releaseTo: newTop.	newTop ifNotNil: [newTop push: value].	^ newTop! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:41'!initializeDependentsFields	"Object initialize"	DependentsFields := WeakIdentityKeyDictionary new.! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher := SmallInteger maxVal highBit.	u := self abs max: (v := anInteger abs).	v := self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat := u bitShift: (k := higher - u highBit)) class == SmallInteger				ifFalse: 					[k := k - 1.					uHat := uHat bitShift: -1].			vHat := v bitShift: k.			a := 1.			b := 0.			c := 0.			d := 1.			"Test quotient"			[(vPrime := vHat + d) ~= 0				and: [(vPrimePrime := vHat + c) ~= 0 and: [(q := uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c := a - (q * (a := c)).					d := b - (q * (b := d)).					vHat := uHat - (q * (uHat := vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v := u rem: (u := v)]				ifFalse: 					[t := u * a + (v * b).					v := u * c + (v * d).					u := t]].	^ v gcd: u! !!Message methodsFor: 'stub creation' stamp: 'ads 7/21/2003 17:33'!createStubMethod	| argNames aOrAn argName arg argClassName |	argNames := Set new.	^ String streamContents: [ :s |		self selector keywords doWithIndex: [ :key :i |			s nextPutAll: key.			((key last = $:) or: [self selector isInfix]) ifTrue: [				arg := self arguments at: i.				argClassName := (arg isKindOf: Class) ifTrue: ['Class'] ifFalse: [arg class name].				aOrAn := argClassName first isVowel ifTrue: ['an'] ifFalse: ['a'].				argName := aOrAn, argClassName.				[argNames includes: argName] whileTrue: [argName := argName, i asString].				argNames add: argName.				s nextPutAll: ' '; nextPutAll: argName; space			].		].		s cr; tab.		s nextPutAll: 'self shouldBeImplemented'	]! !!Object methodsFor: 'message handling' stamp: 'nk 4/11/2002 14:13'!perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args! !!DateAndTime class methodsFor: 'accessing' stamp: 'brp 9/4/2003 06:39'!localTimeZone	"Answer the local time zone"	^ LocalTimeZone ifNil: [ LocalTimeZone := TimeZone default ]! !!Class methodsFor: 'class variables' stamp: 'dvf 9/27/2005 17:32'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol oldState |	oldState := self copy.	aString first canBeGlobalVarInitial		ifFalse: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol := aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		(subclass bindingOf: symbol) ifNotNil:[			^ self error: aString 				, ' is already used as a variable name in class ' 				, subclass name]].	classPool == nil ifTrue: [classPool := Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		classPool declare: symbol from: Undeclared.		SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: oldState to: self]! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:25'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s := paragraph string.	i := self stopIndex.	tabCount := 0.	[(i := i-1) > 0 and: [(char := s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [i < s size and: [(s at: i+1) ~= $[ ]]) ifTrue: [tabCount := tabCount + 1].		char = $[ ifTrue: [tabCount := tabCount + 1].		char = $] ifTrue: [tabCount := tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!Behavior methodsFor: 'testing class hierarchy' stamp: ''!inheritsFrom: aClass 	"Answer whether the argument, aClass, is on the receiver's superclass 	chain."	| aSuperclass |	aSuperclass := superclass.	[aSuperclass == nil]		whileFalse: 			[aSuperclass == aClass ifTrue: [^true].			aSuperclass := aSuperclass superclass].	^false! !!ProcessorScheduler methodsFor: 'CPU usage tally' stamp: 'nk 3/8/2001 12:56'!nextReadyProcess	quiescentProcessLists reverseDo: [ :list |		list isEmpty ifFalse: [ | proc |			proc := list first.			proc suspendedContext ifNotNil: [ ^proc ]]].	^nil! !!Object methodsFor: 'macpal' stamp: 'ar 3/18/2001 00:08'!currentWorld	"Answer a morphic world that is the current UI focus.		If in an embedded world, it's that world.		If in a morphic project, it's that project's world.  		If in an mvc project, it is the topmost morphic-mvc-window's worldMorph. 		If in an mvc project that has no morphic-mvc-windows, then it's just some existing worldmorph instance.		If in an mvc project in a Squeak that has NO WorldMorph instances, one is created.	This method will never return nil, it will always return its best effort at returning a relevant world morph, but if need be -- if there are no worlds anywhere, it will create a new one."	| aView aSubview |	ActiveWorld ifNotNil:[^ActiveWorld].	World ifNotNil:[^World].	aView := ScheduledControllers controllerSatisfying:		[:ctrl | (aSubview := ctrl view firstSubView) notNil and:			[aSubview model isMorph and: [aSubview model isWorldMorph]]].	^aView		ifNotNil:			[aSubview model]		ifNil:			[MVCWiWPasteUpMorph newWorldForProject: nil].! !!Process methodsFor: 'changing suspended state' stamp: ''!install: aContext 	"Replace the suspendedContext with aContext."	self == Processor activeProcess		ifTrue: [^self error: 'The active process cannot install contexts'].	suspendedContext := aContext! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!categoryOfElement: element 	"Answer the category associated with the argument, element."	| index |	index := self numberOfCategoryOfElement: element.	index = 0		ifTrue: [^nil]		ifFalse: [^categoryArray at: index]! !!MethodContext methodsFor: 'closure support' stamp: 'md 2/20/2006 20:39'!freeNamesAndValues	| aStream eval |	eval := [:string |		self class evaluatorClass new			evaluate2: (ReadStream on: string)			in: self			to: nil			notifying: nil	"fix this"			ifFail: [self error: 'bug']			logged: false].	aStream := '' writeStream.	self freeNames doWithIndex: [:name :index |		aStream nextPutAll: name; nextPut: $:; space; tab.		(eval value: name) printOn: aStream.		aStream cr].	^ aStream contents! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitOr: n 	"Answer an Integer whose bits are the logical OR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitOr' module:'LargeIntegers'>	norm := n normalize.	^ self		digitLogic: norm		op: #bitOr:		length: (self digitLength max: norm digitLength)! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dgd 8/28/2004 13:59'!spawn	"Create and schedule a message browser for the code of the model's 	selected message. Retain any edits that have not yet been accepted."	| code |	code := paragraph text string.	self cancel.	model notNil ifTrue:[model spawn: code].! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/30/2004 09:40'!printStringRoman	| stream integer |	stream := WriteStream on: String new.	integer := self negative ifTrue: [stream nextPut: $-. self negated] ifFalse: [self].	integer // 1000 timesRepeat: [stream nextPut: $M].	integer		romanDigits: 'MDC' for: 100 on: stream;		romanDigits: 'CLX' for: 10 on: stream;		romanDigits: 'XVI' for: 1 on: stream.	^stream contents! !!MethodDictionary methodsFor: 'private' stamp: 'RAA 12/17/2000 11:11'!rehashWithoutBecome	| newSelf key |	newSelf := self species new: self size.	1 to: self basicSize do:		[:i | key := self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	^newSelf! !!Behavior methodsFor: 'accessing method dictionary' stamp: ''!supermostPrecodeCommentFor: selector 	"Answer a string representing the precode comment in the most distant 	superclass's implementation of the selector. Return nil if none found."	| aSuper superComment |	(self == Behavior			or: [superclass == nil					or: [(aSuper := superclass whichClassIncludesSelector: selector) == nil]])		ifFalse: ["There is a super implementor"			superComment := aSuper supermostPrecodeCommentFor: selector].	^ superComment		ifNil: [self firstPrecodeCommentFor: selector			"ActorState supermostPrecodeCommentFor: #printOn:"]! !!Class methodsFor: 'pool variables' stamp: 'tpr 5/30/2003 13:04'!addSharedPool: aSharedPool 	"Add the argument, aSharedPool, as one of the receiver's shared pools. 	Create an error if the shared pool is already one of the pools.	This method will work with shared pools that are plain Dictionaries or thenewer SharedPool subclasses"	(self sharedPools includes: aSharedPool)		ifTrue: [^self error: 'This is already in my shared pool list'].	sharedPools == nil		ifTrue: [sharedPools := OrderedCollection with: aSharedPool]		ifFalse: [sharedPools add: aSharedPool]! !!Class methodsFor: 'pool variables' stamp: 'tk 9/12/96'!removeSharedPool: aDictionary 	"Remove the pool dictionary, aDictionary, as one of the receiver's pool 	dictionaries. Create an error notification if the dictionary is not one of 	the pools.	: Note that it removes the wrong one if there are two empty Dictionaries in the list."	| satisfiedSet workingSet aSubclass |	(self sharedPools includes: aDictionary)		ifFalse: [^self error: 'the dictionary is not in my pool'].	"first see if it is declared in a superclass in which case we can remove it."	(self selectSuperclasses: [:class | class sharedPools includes: aDictionary]) isEmpty		ifFalse: [sharedPools remove: aDictionary.				sharedPools isEmpty ifTrue: [sharedPools := nil].				^self]. 	"second get all the subclasses that reference aDictionary through me rather than a 	superclass that is one of my subclasses."	workingSet := self subclasses asOrderedCollection.	satisfiedSet := Set new.	[workingSet isEmpty] whileFalse:		[aSubclass := workingSet removeFirst.		(aSubclass sharedPools includes: aDictionary)			ifFalse: 				[satisfiedSet add: aSubclass.				workingSet addAll: aSubclass subclasses]].	"for each of these, see if they refer to any of the variables in aDictionary because 	if they do, we can not remove the dictionary."	satisfiedSet add: self.	satisfiedSet do: 		[:sub | 		aDictionary associationsDo: 			[:aGlobal | 			(sub whichSelectorsReferTo: aGlobal) isEmpty 				ifFalse: [^self error: aGlobal key 								, ' is still used in code of class '								, sub name]]].	sharedPools remove: aDictionary.	sharedPools isEmpty ifTrue: [sharedPools := nil]! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!classify: element under: heading suppressIfDefault: aBoolean	| oldCat newCat |	oldCat := self categoryOfElement: element.	SystemChangeNotifier uniqueInstance doSilently: [		super classify: element under: heading suppressIfDefault: aBoolean].	newCat := self categoryOfElement: element.	self notifyOfChangedSelector: element from: oldCat to: newCat.! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitMultiply: arg neg: ng 	| prod prodLen carry digit k ab |	<primitive: 'primDigitMultiplyNegative' module:'LargeIntegers'>	(arg digitLength = 1 and: [(arg digitAt: 1)			= 0])		ifTrue: [^ 0].	(self digitLength = 1 and: [(self digitAt: 1)			= 0])		ifTrue: [^ 0].	prodLen := self digitLength + arg digitLength.	prod := Integer new: prodLen neg: ng.	"prod starts out all zero"	1 to: self digitLength do: [:i | (digit := self digitAt: i) ~= 0			ifTrue: 				[k := i.				carry := 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1"				1 to: arg digitLength do: 					[:j | 					ab := (arg digitAt: j)								* digit + carry + (prod digitAt: k).					carry := ab bitShift: -8.					prod digitAt: k put: (ab bitAnd: 255).					k := k + 1].				prod digitAt: k put: carry]].	^ prod normalize! !!CompiledMethod methodsFor: 'decompiling' stamp: 'ajh 7/14/2001 12:34'!primitiveNode	| primNode n |	primNode := PrimitiveNode new num: (n := self primitive).	(n = 117 or: [n = 120]) ifTrue: [		primNode spec: (self literalAt: 1)].	^ primNode! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'md 7/14/2006 21:21'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex flag: flag	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits method flagBit |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	"For now the high bit of the primitive no. is in a high bit of the header"	primBits := (primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19).	flagBit := flag ifTrue: [ 1 ] ifFalse: [ 0 ].	method := self newMethod: numberOfBytes + trailer size		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits +				(flagBit bitShift: 29).	"Copy the source code trailer to the end"	1 to: trailer size do:		[:i | method at: method size - trailer size + i put: (trailer at: i)].	^ method! !!EventSensor methodsFor: 'private' stamp: 'nk 3/17/2004 07:09'!nextEventSynthesized	"Return a synthesized event. This method is called if an event driven client wants to receive events but the primary user interface is not event-driven (e.g., the receiver does not have an event queue but only updates its state). This can, for instance, happen if a Morphic World is run in an MVC window. To simplify the clients work this method will always return all available keyboard events first, and then (repeatedly) the mouse events. Since mouse events come last, the client can assume that after one mouse event has been received there are no more to come. Note that it is impossible for EventSensor to determine if a mouse event has been issued before so the client must be aware of the possible problem of getting repeatedly the same mouse events. See HandMorph>>processEvents for an example on how to deal with this."	| kbd array buttons pos modifiers mapped |	"First check for keyboard"	array := Array new: 8.	kbd := self primKbdNext.	kbd ifNotNil:		["simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^ array].	"Then check for mouse"	pos := self primMousePt.	buttons := mouseButtons.	modifiers := buttons bitShift: -3.	buttons := buttons bitAnd: 7.	mapped := self mapButtons: buttons modifiers: modifiers.	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.	^ array! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!pointBlock: aCharacterBlock	startBlock := aCharacterBlock.! !!SmallInteger methodsFor: 'private' stamp: 'sr 6/8/2000 01:14'!highBitOfPositiveReceiver	| shifted bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted := self.	bitNo := 0.	[shifted < 16]		whileFalse: 			[shifted := shifted bitShift: -4.			bitNo := bitNo + 4].	[shifted = 0]		whileFalse: 			[shifted := shifted bitShift: -1.			bitNo := bitNo + 1].	^ bitNo! !!Random methodsFor: 'private' stamp: 'sma 5/12/2000 12:28'!nextValue	"This method generates random instances of Integer 	in the interval	0 to 16r7FFFFFFF. This method does NOT update the seed; repeated sends	answer the same value.	The algorithm is described in detail in 'Random Number Generators: 	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller 	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988)."	| lo hi aLoRHi answer |	hi := (seed quo: q) asFloat.	lo := seed - (hi * q).  " = seed rem: q"  	aLoRHi := (a * lo) - (r * hi).	answer := (aLoRHi > 0.0)		ifTrue:  [aLoRHi]		ifFalse: [aLoRHi + m].	^ answer! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:16'!completeStep: aContext 	"Resume self until aContext is on top, or if already on top, complete next step"	| callee |	self suspendedContext == aContext ifFalse: [		^ self complete: (self calleeOf: aContext)].	callee := self step.	callee == aContext ifTrue: [^ callee].	aContext isDead ifTrue: [^ self suspendedContext].  "returned"	^ self complete: callee  "finish send"! !!Behavior methodsFor: 'initialize-release' stamp: 'sd 3/28/2003 15:07'!nonObsoleteClass	"Attempt to find and return the current version of this obsolete class"	| obsName |	obsName := self name.	[obsName beginsWith: 'AnObsolete']		whileTrue: [obsName := obsName copyFrom: 'AnObsolete' size + 1 to: obsName size].	^ self environment at: obsName asSymbol! !!ParagraphEditor methodsFor: 'private' stamp: 'BG 4/29/2004 11:19'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle := Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines := paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  := paragraph lineIndexOfCharacterIndex: start.			currentLine := lines at: currentLineNumber]		ifFalse: [			lines := self lines.			numberOfLines := lines size.			currentLine := lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber := currentLine second].	column := start - currentLine first.	targetLineNumber := ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine := (lines at: targetLineNumber) first.	targetEOL := (lines at: targetLineNumber) last + (targetLineNumber == numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber == currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText := stateArray at: 1.	FindText := stateArray at: 2.	UndoInterval := stateArray at: 3.	UndoMessage := stateArray at: 4.	UndoParagraph := stateArray at: 5.	UndoSelection := stateArray at: 6.	Undone := stateArray at: 7.	sel := stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock := stateArray at: 9.	emphasisHere := stateArray at: 10.! !!Fraction methodsFor: 'private' stamp: 'tfei 4/12/1999 12:45'!setNumerator: n denominator: d	d = 0		ifTrue: [^(ZeroDivide dividend: n) signal]		ifFalse: 			[numerator := n asInteger.			denominator := d asInteger abs. "keep sign in numerator"			d < 0 ifTrue: [numerator := numerator negated]]! !!Object methodsFor: 'viewer' stamp: 'sw 8/11/2002 02:03'!offerViewerMenuFor: aViewer event: evt	"Offer the primary Viewer menu to the user.  Copied up from Player code, but most of the functions suggested here don't work for non-Player objects, many aren't even defined, some relate to exploratory sw work not yet reflected in the current corpus.  We are early in the life cycle of this method..."	| aMenu |	aMenu := MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	aMenu title: '**CAUTION -- UNDER CONSTRUCTION!!**Many things may not work!!', self nameForViewer.	(aViewer affordsUniclass and: [self belongsToUniClass not]) ifTrue:		[aMenu add: 'give me a Uniclass' action: #assureUniClass.		aMenu addLine].	aMenu add: 'choose vocabulary...' target: aViewer action: #chooseVocabulary.	aMenu add: 'choose limit class...' target: aViewer action: #chooseLimitClass.	aMenu add: 'add search pane' target: aViewer action: #addSearchPane.	aMenu balloonTextForLastItem: 'Specify which class should be the most generic one to have its methods shown in this Viewer'.	aMenu addLine.	self belongsToUniClass ifTrue:		[aMenu add: 'add a new instance variable' target: self selector: #addInstanceVariableIn: argument: aViewer.		aMenu add: 'add a new script' target: aViewer selector: #newPermanentScriptIn: argument: aViewer.		aMenu addLine.		aMenu add: 'make my class be first-class' target: self selector: #makeFirstClassClassIn: argument: aViewer.		aMenu add: 'move my changes up to my superclass' target: self action: #promoteChangesToSuperclass.		aMenu addLine].	aMenu add: 'tear off a tile' target: self selector: #launchTileToRefer.	aMenu addLine.	aMenu add: 'inspect me' target: self selector: #inspect.	aMenu add: 'inspect my class' target: self class action: #inspect.	aMenu addLine.	aMenu add: 'browse vocabulary' action: #haveFullProtocolBrowsed.	aMenu add: 'inspect this Viewer' target: aViewer action: #inspect.	aMenu popUpEvent: evt in: aViewer currentWorld"	aMenu add: 'references to me' target: aViewer action: #browseReferencesToObject.	aMenu add: 'toggle scratch pane' target: aViewer selector: #toggleScratchPane.	aMenu add: 'make a nascent script for me' target: aViewer selector: #makeNascentScript.	aMenu add: 'rename me' target: aViewer selector: #chooseNewNameForReference.	aMenu add: 'browse full' action: #browseOwnClassFull.	aMenu add: 'browse hierarchy' action: #browseOwnClassHierarchy.	aMenu add: 'set user level...' target: aViewer action: #setUserLevel.	aMenu add: 'browse sub-protocol' action: #browseOwnClassSubProtocol.	aMenu addLine."! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!listAtCategoryNamed: categoryName	"Answer the array of elements associated with the name, categoryName."	| i |	i := categoryArray indexOf: categoryName ifAbsent: [^Array new].	^self listAtCategoryNumber: i! !!BlockContext methodsFor: 'exceptions' stamp: 'ar 3/6/2001 14:25'!on: exception do: handlerAction	"Evaluate the receiver in the scope of an exception handler."	| handlerActive |	<primitive: 199>	handlerActive := true.	^self value! !!Integer methodsFor: 'private' stamp: 'hmm 1/7/2002 20:55'!digitLogic: arg op: op length: len	| result neg1 neg2 rneg z1 z2 rz b1 b2 b |	neg1 := self negative.	neg2 := arg negative.	rneg := 		((neg1 ifTrue: [-1] ifFalse: [0])			perform: op 			with: (neg2					ifTrue: [-1]					ifFalse: [0])) < 0.	result := Integer new: len neg: rneg.	rz := z1 := z2 := true.	1 to: result digitLength do: 		[:i | 		b1 := self digitAt: i.		neg1 			ifTrue: [b1 := z1						ifTrue: [b1 = 0									ifTrue: [0]									ifFalse: 										[z1 := false.										256 - b1]]						ifFalse: [255 - b1]].		b2 := arg digitAt: i.		neg2 			ifTrue: [b2 := z2						ifTrue: [b2 = 0									ifTrue: [0]									ifFalse: 										[z2 := false.										256 - b2]]						ifFalse: [255 - b2]].		b := b1 perform: op with: b2.		result 			digitAt: i 			put: (rneg					ifTrue: [rz ifTrue: [b = 0										ifTrue: [0]										ifFalse:											[rz := false.											256 - b]]								ifFalse: [255 - b]]				ifFalse: [b])].	^ result normalize! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'pk 9/10/2005 22:53'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |		sensor keyboard.  "Flush typeahead"	cr := Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart := self startIndex.	realStop := self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^ true].	lines := paragraph lines.	startLine := paragraph lineIndexOfCharacterIndex: realStart.	stopLine := paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start := (lines at: startLine) first.	stop := (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart := realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation := (startLine to: stopLine) inject: 1000 into:		[:m :l |		m := m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size :=  stop + 1 - start.	numLines := stopLine + 1 - startLine.	inStream := ReadStream on: paragraph string from: start to: stop.	newString := WideString new: size + ((numLines * delta) max: 0).	outStream := ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart := (realStart + delta) max: start].	realStop := realStop + outStream position - size.	"Prepare for another iteration"	indentation := indentation + delta.	size := outStream position.	inStream := outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[view flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString := outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger ifTrue:		[quoRem := self digitDiv: aNumber abs	"*****I've added abs here*****"						neg: self negative ~~ aNumber negative.		(quoRem at: 2) = 0			ifTrue: [^ (quoRem at: 1) normalize]			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].	^ aNumber adaptToInteger: self andSend: #/! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:41'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| selection |	selection := self selection.	self terminateAndInitializeAround:		[(ReadWriteStream on: selection string from: 1 to: selection size) fileIn].! !!ParagraphEditor methodsFor: 'explain' stamp: 'apb 1/5/2000 16:56'!explainNumber: string 	"Is string a Number?"	| strm c |	(c := string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])			ifFalse: [^nil]].	strm := ReadStream on: string.	c := Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!CompiledMethod methodsFor: 'scanning' stamp: ''!scanLongStore: extension 	"Answer whether the receiver contains a long store whose extension is 	the argument."	| scanner |	scanner := InstructionStream on: self.	^scanner scanFor: 		[:instr |  (instr = 129 or: [instr = 130]) and: [scanner followingByte = extension]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 11:47'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectLine.	((aSymbol := self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!Object class methodsFor: 'instance creation' stamp: 'nk 8/30/2004 07:57'!readCarefullyFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream.  Return an error instead of putting up a SyntaxError window."	| object |	(Compiler couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object := Compiler evaluate: textStringOrStream for: nil 				notifying: #error: "signal we want errors" logged: false.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 4/14/1999 11:16'!organizationFiltered: aClass	"Return the organization of the class with all selectors defined in superclasses removed.  (except those in Object)"	| org str |	org := aClass organization deepCopy.	Dangerous do: [:sel |			org removeElement: sel].	Approved do: [:sel |			org removeElement: sel].	AddAndRemove do: [:sel |			org removeElement: sel].	str := org printString copyWithout: $(.	str := '(', (str copyWithout: $) ).	str := str replaceAll: $' with: $".	^ str! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 5/20/2004 17:32'!restart	"Unwind thisContext to self and resume from beginning.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: nil to: self].	self privRefresh.	ctxt := thisContext.	[	ctxt := ctxt findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock := ctxt tempAt: 1.		unwindBlock ifNotNil: [			ctxt tempAt: 1 put: nil.			thisContext terminateTo: ctxt.			unwindBlock value].	].	thisContext terminateTo: self.	self jump.! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'mikki 1/5/2005 14:10'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	self clearParens.  	"mikki 1/3/2005 21:31 Preference for auto-indent on return added."	char asciiValue = 13 ifTrue: [		^Preferences autoIndent 			ifTrue: [				sensor controlKeyPressed					ifTrue: [self normalCharacter: typeAheadStream]					ifFalse: [self crWithIndent: typeAheadStream]]			ifFalse: [				sensor controlKeyPressed					ifTrue: [self crWithIndent: typeAheadStream]					ifFalse: [self normalCharacter: typeAheadStream]]].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].			"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	(')]}' includes: char)		ifTrue: [self blinkPrevParen].	^ self perform: #normalCharacter: with: typeAheadStream! !!CompiledMethod methodsFor: 'source code management' stamp: 'md 2/28/2006 17:51'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte sourceSelector |	flagByte := self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue: ["No source pointer -- decompile without temp names"		^ self decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((self decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"		[ source := self getSourceFromFile ] on: Error do: [ :ex |		"An error can happen here if, for example, the changes file has been truncated by an aborted download.  The present solution is to ignore the error and fall back on the decompiler.  A more thorough solution should probably trigger a systematic invalidation of all source pointers past the end of the changes file.  Consider that, as time goes on, the changes file will eventually grow large enough to cover the lost code, and then instead of falling into this error case, random source code will get returned."		source := nil ].		source ifNotNil: [		sourceSelector := Parser parserClass new parseSelector: source.		^sourceSelector = selector			ifTrue: [source]			ifFalse: [				self replace: sourceSelector with: selector in: source]].	"Something really wrong -- decompile blind (no temps)"	^ self decompileString! !!Class methodsFor: 'accessing' stamp: 'al 9/3/2004 13:37'!classPool: aDictionary	classPool := aDictionary! !!Class class methodsFor: 'fileIn/Out' stamp: 'dvf 9/27/2005 17:30'!fileOutPool: aString	"file out the global pool named aString"		| internalStream |	internalStream := WriteStream on: (String new: 1000).	self new fileOutPool: (self environment at: aString asSymbol) onFileStream: internalStream.	FileStream writeSourceCodeFrom: internalStream baseName: aString isSt: true useHtml: false.! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 10:09'!bitShift: shiftCount 	"Answer an Integer whose value (in twos-complement representation) is  	the receiver's value (in twos-complement representation) shifted left by 	the number of bits indicated by the argument. Negative arguments  	shift right. Zeros are shifted in from the right in left shifts."	| magnitudeShift |	magnitudeShift := self bitShiftMagnitude: shiftCount.	^ ((self negative and: [shiftCount negative])		and: [self anyBitOfMagnitudeFrom: 1 to: shiftCount negated])		ifTrue: [magnitudeShift - 1]		ifFalse: [magnitudeShift]! !!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'NS 4/7/2004 16:03'!fileOutCommentOn: aFileStream moveSource: moveSource toFile: fileIndex	"Copy the class comment to aFileStream.  If moveSource is true (as in compressChanges or compressSources, then update classComment to point to the new file."	| fileComment |	classComment ifNotNil: 			[aFileStream cr.			fileComment := RemoteString newString: classComment text							onFileNumber: fileIndex toFile: aFileStream.			moveSource ifTrue: [classComment := fileComment]]! !!Integer methodsFor: 'private' stamp: ''!digitRshift: anInteger bytes: b lookfirst: a 	 "Shift right 8*b+anInteger bits, 0<=n<8.	Discard all digits beyond a, and all zeroes at or below a."	| n x r f m digit count i |	n := 0 - anInteger.	x := 0.	f := n + 8.	i := a.	m := 255 bitShift: 0 - f.	digit := self digitAt: i.	[((digit bitShift: n) bitOr: x) = 0 and: [i ~= 1]] whileTrue:		[x := digit bitShift: f "Can't exceed 8 bits".		i := i - 1.		digit := self digitAt: i].	i <= b ifTrue: [^Integer new: 0 neg: self negative].  "All bits lost"	r := Integer new: i - b neg: self negative.	count := i.	x := (self digitAt: b + 1) bitShift: n.	b + 1 to: count do:		[:j | digit := self digitAt: j + 1.		r digitAt: j - b put: (((digit bitAnd: m) bitShift: f) bitOr: x) 			"Avoid values > 8 bits".		x := digit bitShift: n].	^r! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 4/9/2001 17:59'!constUsingData1Value	| const subTest got |	"See if (data1 <= C) or (data1 >= C) is the answer"	"quick test"	((answers at: 1) class superclass == Boolean) ifFalse: [^ false].	2 to: answers size do: [:ii | 		((answers at: ii) class superclass == Boolean) ifFalse: [^ false]].	thisData do: [:datums | 		const := datums first.	"use data as a constant!!"		got := (subTest := MethodFinder new copy: self addArg: const) 					searchForOne isEmpty not.		got ifTrue: [			"replace data2 with const in expressions"			subTest expressions do: [:exp |				expressions add: (exp copyReplaceAll: 'data2' with: const printString)].			selector addAll: subTest selectors.			^ true]].	^ false! !!ContextPart class methodsFor: 'examples' stamp: ''!tallyInstructions: aBlock	"This method uses the simulator to count the number of occurrences of	each of the Smalltalk instructions executed during evaluation of aBlock.	Results appear in order of the byteCode set."	| tallies |	tallies := Bag new.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current | tallies add: current nextByte].	^tallies sortedElements	"ContextPart tallyInstructions: [3.14159 printString]"! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 3/1/2001 20:48'!updateInstancesFrom: oldClass	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary. Return the array of old instances (none of which should be	pointed to legally by anyone but the array)."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	See bottom below for a simple example:"	| oldInstances |	oldInstances := oldClass allInstances asArray.	oldInstances := self updateInstances: oldInstances from: oldClass isMeta: self isMeta.	"Now fix up instances in segments that are out on the disk."	ImageSegment allSubInstancesDo: [:seg |		seg segUpdateInstancesOf: oldClass toBe: self isMeta: self isMeta].	^oldInstances"	| crashingBlock class |	class := Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar := value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock := (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"! !!Semaphore methodsFor: 'communication' stamp: ''!signal	"Primitive. Send a signal through the receiver. If one or more processes 	have been suspended trying to receive a signal, allow the first one to 	proceed. If no process is waiting, remember the excess signal. Essential. 	See Object documentation whatIsAPrimitive."	<primitive: 85>	self primitiveFailed	"self isEmpty    		ifTrue: [excessSignals := excessSignals+1]    		ifFalse: [Processor resume: self removeFirstLink]"! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self closeTypeIn: characterStream.	prior := otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval := prior.	^ true! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 10:54'!removeSubclass: aSubclass 	"If the argument, aSubclass, is one of the receiver's subclasses, remove it."	subclasses == nil ifFalse:		[subclasses :=  subclasses copyWithout: aSubclass.		subclasses isEmpty ifTrue: [subclasses := nil]].! !!ParagraphEditor methodsFor: 'undoers' stamp: ''!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText index subject |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize := (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText := self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i |		index := indices at: i.		(subject := index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 11/23/1998 15:21'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 := self clipboardText string.	s2 := paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!EventSensor methodsFor: 'private' stamp: 'nk 3/18/2004 13:21'!lastEventPoll	"Answer the last clock value at which fetchMoreEvents was called."	^lastEventPoll ifNil: [ lastEventPoll := Time millisecondClockValue ]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'al 11/28/2005 11:52'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree := self environment garbageCollect.	candidatesForRemoval :=		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c | c removeFromSystem].	^ self environment garbageCollect - oldFree! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:01'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{"''' indexOf: char ifAbsent: [ ^true ].	left := '([<{"''' at: which.	right := ')]>}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/10/1999 23:03'!tabletTimestamp	"Answer the time (in tablet clock ticks) at which the tablet's primary pen last changed state. This can be used in polling loops; if this timestamp hasn't changed, then the pen state hasn't changed either."	| data |	data := self primTabletRead: 1.  "state of first/primary pen"	^ data at: 2! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'di 2/4/1999 08:45'!startUp	"Install a background process of the lowest possible priority that is always runnable."	"Details: The virtual machine requires that there is aways some runnable process that can be scheduled; this background process ensures that this is the case."	Smalltalk installLowSpaceWatcher.	BackgroundProcess == nil ifFalse: [BackgroundProcess terminate].	BackgroundProcess := [self idleProcess] newProcess.	BackgroundProcess priority: SystemRockBottomPriority.	BackgroundProcess resume.! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr := Character cr.  lf := Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ObjectOut methodsFor: 'access' stamp: 'tk 12/18/1998 21:29'!xxxReset	"mark as never brought in"	recursionFlag := nil! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:42'!check: nDice difficulty: diff	"Roll some dice, WoD-style."	| result die |	result := 0.	nDice timesRepeat: 		[(die := self nextInt: 10) = 1			ifTrue: [result := result - 1]			ifFalse: [die >= diff ifTrue: [result := result + 1]]].	^ result! !!BlockContext methodsFor: 'controlling' stamp: 'jf 9/3/2003 16:45'!doWhileFalse: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is false." 	| result |	[result := self value.	conditionBlock value] whileFalse.	^ result! !!ParagraphEditor methodsFor: 'undoers' stamp: ''!undoCutCopy: oldPasteBuffer	"Undo of a cut, copy, or any edit that changed CurrentSelection.  Be sure	 undo-copy does not lock the model.  Redoer: itself, so never isRedoing."	| recentCut |	recentCut := self clipboardText.		UndoSelection size = UndoInterval size		ifFalse: [self replaceSelectionWith: UndoSelection].	self clipboardTextPut: oldPasteBuffer.	self undoer: #undoCutCopy: with: recentCut! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sumim 9/2/2003 14:37'!moveChangesWithVersionsTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	changes := self methodDict keys select: [:sel | (self methodDict at: sel) fileIndex > 1].	self fileOutChangedMessagesHistorically: changes		on: newFile		moveSource: true		toFile: 2! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nk 12/8/2002 12:15'!valueWithEnoughArguments: anArray	"call the selector with enough arguments from arguments and anArray"	| args |	self ensureReceiverAndArguments ifFalse: [ ^nil ].	args := Array new: selector numArgs.	args replaceFrom: 1		to: ( arguments size min: args size)		with: arguments		startingAt: 1.	args size > arguments size ifTrue: [		args replaceFrom: arguments size + 1			to: (arguments size + anArray size min: args size)			with: anArray			startingAt: 1.	].	^ self receiver perform: selector withArguments: args! !!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'NS 4/7/2004 16:04'!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource forClass: aClass	"Store the comment about the class onto file, aFileStream."	| header |	classComment ifNotNil:		[aFileStream cr; nextPut: $!!.		header := String streamContents: [:strm | 				strm nextPutAll: aClass name;				nextPutAll: ' commentStamp: '.				commentStamp ifNil: [commentStamp := '<historical>'].				commentStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].		aFileStream nextChunkPut: header.		aClass organization fileOutCommentOn: aFileStream				moveSource: moveSource toFile: sourceIndex.		aFileStream cr]! !!Object methodsFor: 'viewer' stamp: 'sd 3/30/2005 22:04'!uniqueInstanceVariableNameLike: aString excluding: takenNames	"Answer a nice instance-variable name to be added to the receiver which resembles aString, making sure it does not coincide with any element in takenNames"	| okBase uniqueName usedNames |	usedNames := self class allInstVarNamesEverywhere.	usedNames removeAllFoundIn: self class instVarNames.	usedNames addAll: takenNames.	okBase := Scanner wellFormedInstanceVariableNameFrom: aString.	uniqueName := Utilities keyLike: okBase satisfying: 		[:aKey | (usedNames includes: aKey) not].	^ uniqueName! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 13:37'!enter	self isOwnerProcess ifTrue: [		nestingLevel := nestingLevel + 1.	] ifFalse: [		mutex wait.		ownerProcess := Processor activeProcess.		nestingLevel := 1.	].! !!Object methodsFor: 'objects from disk' stamp: 'tk 8/9/2001 15:40'!storeDataOn: aDataStream	"Store myself on a DataStream.  Answer self.  This is a low-level DataStream/ReferenceStream method. See also objectToStoreOnDataStream.  NOTE: This method must send 'aDataStream beginInstance:size:' and then (nextPut:/nextPutWeak:) its subobjects.  readDataFrom:size: reads back what we write here."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	cntIndexedVars := self basicSize.	aDataStream		beginInstance: self class		size: cntInstVars + cntIndexedVars.	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self instVarAt: i)].	"Write fields of a variable length object.  When writing to a dummy 		stream, don't bother to write the bytes"	((aDataStream byteStream class == DummyStream) and: [self class isBits]) ifFalse: [		1 to: cntIndexedVars do:			[:i | aDataStream nextPut: (self basicAt: i)]].! !!EventSensor methodsFor: 'private' stamp: 'ar 7/23/2000 00:34'!primInterruptSemaphore: aSemaphore 	"Primitive. Install the argument as the semaphore to be signalled whenever the user presses the interrupt key. The semaphore will be signaled once each time the interrupt key is pressed."	interruptSemaphore := aSemaphore.	"backward compatibility: use the old primitive which is obsolete now"	super primInterruptSemaphore: aSemaphore! !!CompiledMethod methodsFor: 'printing' stamp: 'ajh 3/20/2001 11:41'!symbolic	"Answer a String that contains a list of all the byte codes in a method 	with a short description of each."	| aStream |	aStream := WriteStream on: (String new: 1000).	self longPrintOn: aStream.	^aStream contents! !!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'NS 2/19/2002 11:49'!countReallyObsoleteClassesAndMetaclasses	"Counting really obsolete classes and metaclasses"	| metaSize classSize |	Smalltalk garbageCollect.	metaSize := self reallyObsoleteMetaclasses size.	Transcript cr; show: 'Really obsolete metaclasses: ', metaSize printString.	classSize := self reallyObsoleteClasses size.	Transcript cr; show: 'Really obsolete classes: ', classSize printString; cr.	"Metaclasses must correspond to classes!!"	metaSize ~= classSize 		ifTrue: [self error: 'Serious metalevel inconsistency!!!!'].! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/27/2003 21:18'!copyTo: aContext blocks: dict	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home."	| copy |	self == aContext ifTrue: [^ nil].	copy := self copy.	dict at: self ifPresent: [:blocks | blocks do: [:b | b privHome: copy]].	self sender ifNotNil: [		copy privSender: (self sender copyTo: aContext blocks: dict)].	^ copy! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 22:07'!processMouseEvent: evt	"process a mouse event, updating InputSensor state"	| modifiers buttons mapped |	mousePosition := (evt at: 3) @ (evt at: 4).	buttons := evt at: 5.	modifiers := evt at: 6.	mapped := self mapButtons: buttons modifiers: modifiers.	mouseButtons := mapped bitOr: (modifiers bitShift: 3).! !!Number class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 22:41'!readFrom: stringOrStream base: base	"Answer a number as described on aStream in the given number base."	| aStream sign |	aStream := (stringOrStream isString)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	^ self readRemainderOf: (Integer readFrom: aStream base: base)			from: aStream base: base withSign: sign! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:17'!induceMDFault	"Stache a copy of the methodDict in the organization slot (hack!!),	and set the methodDict to nil.  This will induce an MD fault on any message send.	See: ClassDescription>>recoverFromMDFault	and ImageSegment>>discoverActiveClasses."	organization := Array with: methodDict with: organization.	methodDict := nil.	self flushCache! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 7/20/2009 00:13'!valueSuppressingAllMessages	^ self valueSuppressingMessages: #('*')! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'md 9/7/2006 22:22'!fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors := (aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	selectors := selectors select: [:each | 		(self includesLocalSelector: each) or: [(self methodDict at: each) sendsToSuper]].		"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!BlockContext methodsFor: 'evaluating' stamp: 'nk 3/11/2001 11:49'!valueWithEnoughArguments: anArray	"call me with enough arguments from anArray"	| args |	(anArray size == self numArgs)		ifTrue: [ ^self valueWithArguments: anArray ].	args := Array new: self numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self valueWithArguments: args! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'rbb 2/18/2005 14:55'!doesNotUnderstand: aMessage 	"Bring in the object, install, then resend aMessage"	| realObject oldFlag response |	oldFlag := recursionFlag.	recursionFlag := true.	"fetch the object"	realObject := self xxxFetch.		"watch out for the become!!"			"Now we ARE the realObject"	oldFlag == true ifTrue: [		response := (UIManager default chooseFrom: #('proceed normally' 'debug')			title: 'Object being fetched for a second time.Should not happen, and needs to be fixed later.').		response = 2 ifTrue: [self halt]].	"We are already the new object"	"Can't be a super message, since this is the first message sent to this object"	^ realObject perform: aMessage selector withArguments: aMessage arguments! !!InstructionPrinter methodsFor: 'initialize-release' stamp: 'ajh 2/9/2003 14:16'!indent: numTabs	indent := numTabs! !!Behavior methodsFor: 'enumerating' stamp: ''!selectSubclasses: aBlock 	"Evaluate the argument, aBlock, with each of the receiver's (next level) 	subclasses as its argument. Collect into a Set only those subclasses for 	which aBlock evaluates to true. In addition, evaluate aBlock for the 	subclasses of each of these successful subclasses and collect into the set 	those for which aBlock evaluates true. Answer the resulting set."	| aSet |	aSet := Set new.	self allSubclasses do: 		[:aSubclass | 		(aBlock value: aSubclass) ifTrue: [aSet add: aSubclass]].	^aSet! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ajh 7/6/2003 20:38'!jump: distance if: condition 	"Simulate the action of a 'conditional jump' bytecode whose offset is the 	argument, distance, and whose condition is the argument, condition."	| bool |	bool := self pop.	(bool == true or: [bool == false]) ifFalse: [		^self			send: #mustBeBooleanIn:			to: bool			with: {self}			super: false].	(bool eqv: condition) ifTrue: [self jump: distance]! !!Process methodsFor: 'error handling' stamp: ''!errorHandler: aBlock    errorHandler := aBlock! !!Integer methodsFor: 'private' stamp: 'sma 5/20/2000 17:00'!romanDigits: digits for: base on: aStream	| n |	n := self \\ (base * 10) // base.	n = 9 ifTrue: [^ aStream nextPut: digits last; nextPut: digits first].	n = 4 ifTrue: [^ aStream nextPut: digits last; nextPut: digits second].	n > 4 ifTrue: [aStream nextPut: digits second].	n \\ 5 timesRepeat: [aStream nextPut: digits last]! !!CompiledMethod methodsFor: 'initialize-release' stamp: 'di 10/22/1999 13:14'!needsFrameSize: newFrameSize	"Set the largeFrameBit to accomodate the newFrameSize"	| largeFrameBit header |	largeFrameBit := 16r20000.	(self numTemps + newFrameSize) > LargeFrame ifTrue:		[^ self error: 'Cannot compile -- stack including temps is too deep'].	header := self objectAt: 1.	(header bitAnd: largeFrameBit) ~= 0		ifTrue: [header := header - largeFrameBit].	self objectAt: 1 put: header			+ ((self numTemps + newFrameSize) > SmallFrame					ifTrue: [largeFrameBit]					ifFalse: [0])! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'fc 2/19/2004 22:09'!changeEmphasisOrAlignment	| aList reply  |	aList := #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).	reply := (SelectionMenu labelList: aList lines: #(6) selections: aList) startUp.	reply ~~ nil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[paragraph perform: reply.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!Complex methodsFor: 'private' stamp: 'mk 10/27/2003 17:26'!real: aNumber	real := aNumber.! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 1/7/2004 15:32'!copyWithTempNames: tempNames	| tempStr compressed |	tempStr := String streamContents:		[:strm | tempNames do: [:n | strm nextPutAll: n; space]].	compressed := self qCompress: tempStr firstTry: true.	compressed ifNil:		["failure case (tempStr too big) will just decompile with tNN names"		^ self copyWithTrailerBytes: #(0 0 0 0)].	^ self copyWithTrailerBytes: compressed! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sumim 9/2/2003 14:36'!fileOutChangedMessagesHistorically: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File all historical description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org sels |	(org := self organization) categories do: 		[:cat | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels do:			[:sel |  self printMethodChunkHistorically: sel on: aFileStream							moveSource: moveSource toFile: fileIndex]]! !!ClassDescription methodsFor: 'private' stamp: 'NS 1/28/2004 14:22'!logMethodSource: aText forMethodWithNode: aCompiledMethodWithNode inCategory: category withStamp: changeStamp notifying: requestor	| priorMethodOrNil newText |	priorMethodOrNil := self compiledMethodAt: aCompiledMethodWithNode selector ifAbsent: [].	newText := ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [aText askIfAddStyle: priorMethodOrNil req: requestor]			ifFalse: [aText].	aCompiledMethodWithNode method putSource: newText		fromParseNode: aCompiledMethodWithNode node		class: self category: category withStamp: changeStamp 		inFile: 2 priorMethod: priorMethodOrNil.! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 13:36'!storeOn: aStream base: base	"Print a representation of the receiver on the stream	<aStream> in base <base> where	2 <= <baseInteger> <= 16. If <base> is other than 10	it is written first separated by $r followed by the number	like for example: 16rFCE2"	| integer |	integer := self negative		ifTrue: [aStream nextPut: $-. self negated]		ifFalse: [self].	base = 10 ifFalse: [aStream nextPutAll: base printString; nextPut: $r].	aStream nextPutAll: (integer printStringBase: base).! !!Object methodsFor: 'copying' stamp: 'tk 3/11/2003 14:12'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new uc sup has mine |	deepCopier references at: self ifPresent: [:newer | ^ newer]. 	"already did him"	class := self class.	class isMeta ifTrue: [^ self].		"a class"	new := self clone.	(class isSystemDefined not and: [deepCopier newUniClasses "allowed"]) ifTrue: [		uc := deepCopier uniClasses at: class ifAbsent: [nil].		uc ifNil: [			deepCopier uniClasses at: class put: (uc := self copyUniClassWith: deepCopier).			deepCopier references at: class put: uc].	"remember"		new := uc new.		new copyFrom: self].	"copy inst vars in case any are weak"	deepCopier references at: self put: new.	"remember"	(class isVariable and: [class isPointers]) ifTrue: 		[index := self basicSize.		[index > 0] whileTrue: 			[sub := self basicAt: index.			(subAss := deepCopier references associationAt: sub ifAbsent: [nil])				ifNil: [new basicAt: index put: (sub veryDeepCopyWith: deepCopier)]				ifNotNil: [new basicAt: index put: subAss value].			index := index - 1]].	"Ask each superclass if it wants to share (weak copy) any inst vars"	new veryDeepInner: deepCopier.		"does super a lot"	"other superclasses want all inst vars deep copied"	sup := class.  index := class instSize.	[has := sup compiledMethodAt: #veryDeepInner: ifAbsent: [nil].	has := has ifNil: [class isSystemDefined not "is a uniClass"] ifNotNil: [true].	mine := sup instVarNames.	has ifTrue: [index := index - mine size]	"skip inst vars"		ifFalse: [1 to: mine size do: [:xx |				sub := self instVarAt: index.				(subAss := deepCopier references associationAt: sub ifAbsent: [nil])						"use association, not value, so nil is an exceptional value"					ifNil: [new instVarAt: index put: 								(sub veryDeepCopyWith: deepCopier)]					ifNotNil: [new instVarAt: index put: subAss value].				index := index - 1]].	(sup := sup superclass) == nil] whileFalse.	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!EventSensor methodsFor: 'private' stamp: 'ls 10/23/2000 14:14'!primSetInterruptKey: anInteger	"Primitive. Register the given keycode as the user interrupt key. The low byte of the keycode is the ISO character and its next four bits are the Smalltalk modifer bits <cmd><opt><ctrl><shift>."	interruptKey := anInteger.	"backward compatibility: use the old primitive which is obsolete now"	super primSetInterruptKey: anInteger! !!DependentsArray methodsFor: 'enumerating' stamp: 'ar 2/11/2001 01:50'!select: aBlock 	"Refer to the comment in Collection|select:."	| aStream |	aStream := WriteStream on: (self species new: self size).	self do:[:obj|		(aBlock value: obj)			ifTrue: [aStream nextPut: obj]].	^ aStream contents! !!InstructionStream methodsFor: 'decoding' stamp: ''!interpretJump	| byte |	byte := self method at: pc.	(byte between: 144 and: 151) ifTrue:		[pc := pc + 1. ^byte - 143].	(byte between: 160 and: 167) ifTrue:		[pc := pc + 2. ^(byte - 164) * 256 + (self method at: pc - 1)].	^nil! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/20/2002 11:09'!pageHeight	| howManyLines visibleHeight totalHeight ratio |	howManyLines := paragraph numberOfLines.	visibleHeight := self visibleHeight.	totalHeight := self totalTextHeight.	ratio := visibleHeight / totalHeight.	^(ratio * howManyLines) rounded - 2! !!ContextPart class methodsFor: 'examples' stamp: 'sma 4/22/2000 17:03'!trace: aBlock on: aStream		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls to a file."	| prev |	prev := aBlock.	^ thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			current == prev				ifFalse:					[prev sender ifNil:						[aStream space; nextPut: $^.						self carefullyPrint: current top on: aStream].					aStream cr.					(current depthBelow: aBlock) timesRepeat: [aStream space].					self carefullyPrint: current receiver on: aStream.					aStream space; nextPutAll: current selector; flush.					prev := current]]! !!Number methodsFor: 'converting' stamp: 'sw 10/7/1999 12:24'!asSmallPositiveDegrees	"Return the receiver normalized to lie within the range (0, 360)"	| result |	result := self.	[result < 0] whileTrue: [result := result + 360].	^ result \\ 360"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallPositiveDegrees]"! !!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'NS 2/15/2002 16:52'!reallyObsoleteClasses	| obsoleteClasses |	obsoleteClasses := OrderedCollection new.	Metaclass allInstances do: [:meta | meta allInstances do: [:each | 		(self isReallyObsolete: each) ifTrue: [obsoleteClasses add: each]]].	^ obsoleteClasses! !!Behavior methodsFor: 'private' stamp: 'sd 3/28/2003 15:06'!becomeCompact	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct index |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct := self environment compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index := cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format := format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 5/18/1999 14:46'!makeAllMaps 	"Make a giant list of all permutations of the args.  To find the function, we will try these permutations of the input data.  receiver, args."	| ii |	mapList := Array new: argMap size factorial.	ii := 1.	argMap permutationsDo: [:perm |		mapList at: ii put: perm copy.		ii := ii + 1].	mapStage := 1.	"about to be bumped"! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/28/2000 19:27'!findNextHandlerContextStarting	"Return the next handler marked context, returning nil if there is none.  Search starts with self and proceeds up to nil."	| ctx |	<primitive: 197>	ctx := self.		[ctx isHandlerContext ifTrue:[^ctx].		(ctx := ctx sender) == nil ] whileFalse.	^nil! !!ContextPart methodsFor: 'instruction decoding' stamp: 'hmm 7/17/2001 20:52'!send: selector super: superFlag numArgs: numArgs	"Simulate the action of bytecodes that send a message with selector, 	selector. The argument, superFlag, tells whether the receiver of the 	message was specified with 'super' in the source method. The arguments 	of the message are found in the top numArgs locations on the stack and 	the receiver just below them."	| receiver arguments answer |	arguments := Array new: numArgs.	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].	receiver := self pop.	selector == #doPrimitive:method:receiver:args:		ifTrue: [answer := receiver 					doPrimitive: (arguments at: 1)					method: (arguments at: 2)					receiver: (arguments at: 3)					args: (arguments at: 4).				self push: answer.				^self].	QuickStep == self ifTrue: [		QuickStep := nil.		^self quickSend: selector to: receiver with: arguments super: superFlag].	^self send: selector to: receiver with: arguments super: superFlag! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 10/28/2003 10:47'!cursorEnd: characterStream 	"Private - Move cursor end of current line."	| string |	self closeTypeIn: characterStream.	string := paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| targetLine |					targetLine := paragraph lines at:(paragraph lineIndexOfCharacterIndex: position).					targetLine = paragraph lines last						ifTrue:[targetLine last + 1]						ifFalse:[targetLine last]]				ifFalse:[					string						indexOf: Character cr						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		specialBlock:[:dummy | string size + 1].	^true! !!CompiledMethod methodsFor: 'source code management' stamp: 'tk 12/7/2000 12:28'!checkOKToAdd: size at: filePosition	"Issue several warnings as the end of the changes file approaches its limit,	and finally halt with an error when the end is reached."	| fileSizeLimit margin |	fileSizeLimit := 16r2000000.	3 to: 1 by: -1 do:		[:i | margin := i*100000.		(filePosition + size + margin) > fileSizeLimit			ifTrue: [(filePosition + margin) > fileSizeLimit ifFalse:						[self inform: 'WARNING: your changes file is within' , margin printString , ' characters of its size limit.You should take action soon to reduce its size.You may proceed.']]			ifFalse: [^ self]].	(filePosition + size > fileSizeLimit) ifFalse: [^ self].	self error: 'You have reached the size limit of the changes file.You must take action now to reduce it.Close this error.  Do not attempt to proceed.'! !!Object methodsFor: 'copying' stamp: 'tk 3/11/2003 13:58'!veryDeepCopy	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy."	| copier new |	copier := DeepCopier new initialize: self initialDeepCopierSize.	new := self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	copier fixDependents.	^ new! !!Process methodsFor: 'debugging' stamp: 'ar 9/27/2005 20:32'!debug: context title: title full: bool	"Open debugger on self with context shown on top"	| topCtxt |	topCtxt := self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	(topCtxt hasContext: context) ifFalse: [^ self error: 'context not in process'].	ToolSet debug: self context: context label: title contents: nil fullView: bool.! !!Time class methodsFor: 'clock' stamp: 'kph 12/14/2006 01:43'!secondsWhenClockTicks	"waits for the moment when a new second begins"	| lastSecond delay |	delay :=  Delay forMilliseconds: 1.	lastSecond := self primSecondsClock.	[ lastSecond = self primSecondsClock ] whileTrue: [ delay wait ]. 	^ lastSecond + 1! !!ParagraphEditor methodsFor: 'sensor access' stamp: 'th 9/19/2002 18:24'!processRedButton	"The user pressed a red mouse button, meaning create a new text 	selection. Highlighting the selection is carried out by the paragraph 	itself. Double clicking causes a selection of the area between the nearest 	enclosing delimitors."	|  selectionBlocks clickPoint oldDelta oldInterval previousMarkBlock previousPointBlock |	clickPoint := sensor cursorPoint.	(view containsPoint: clickPoint) ifFalse: [^ self].	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [^ self].	oldInterval := self selectionInterval.	previousMarkBlock := self markBlock.	previousPointBlock := self pointBlock.	oldDelta := paragraph scrollDelta.	sensor leftShiftDown		ifFalse:			[self deselect.			self closeTypeIn.			selectionBlocks := paragraph mouseSelect: clickPoint]		ifTrue:			[selectionBlocks := paragraph extendSelectionMark: self markBlock pointBlock: self pointBlock.			self closeTypeIn].	selectionShowing := true.	self markBlock: (selectionBlocks at: 1).	self pointBlock: (selectionBlocks at: 2).	(self hasCaret		and: [previousMarkBlock = self markBlock and: [previousPointBlock = self pointBlock]])		ifTrue: [self selectWord].	oldDelta ~= paragraph scrollDelta "case of autoscroll"			ifTrue: [self updateMarker].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval := oldInterval]! !!Object class methodsFor: 'instance creation' stamp: 'tk 6/29/1998 12:11'!newUniqueClassInstVars: instVarString classInstVars: classInstVarString	"Create a unique class for the receiver"	| aName aClass |	self isSystemDefined ifFalse:		[^ superclass newUniqueClassInstVars: instVarString classInstVars: classInstVarString].	aName := self chooseUniqueClassName.	aClass := self subclass: aName instanceVariableNames: instVarString 		classVariableNames: '' poolDictionaries: '' category: self categoryForUniclasses.	classInstVarString size > 0 ifTrue:		[aClass class instanceVariableNames: classInstVarString].	^ aClass! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'rbb 2/16/2005 16:49'!presentSpecialMenu	"Present a list of expressions, and if the user chooses one, evaluate it in the context of the receiver, a ParagraphEditor.  Primarily for debugging, this provides a convenient way to talk to the various views, controllers, and models associated with any text pane"	| reply items |	self terminateAndInitializeAround:		[reply := (UIManager default chooseFrom: (items := self specialMenuItems) lines: #()).		reply = 0 ifTrue: [^ self].		Compiler new evaluate: (items at: reply) in: [] to: self]	! !!BlockContext methodsFor: 'accessing' stamp: ''!fixTemps	"Fix the values of the temporary variables used in the block that are 	ordinarily shared with the method in which the block is defined."	home := home copy.	home swapSender: nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 1/2/1999 15:45'!lookupSelector: selector	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| lookupClass |	lookupClass := self.	[lookupClass == nil]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass compiledMethodAt: selector].			lookupClass := lookupClass superclass].	^ nil! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 3/5/2004 03:26'!return: aContext value: value	"Pop thread down to aContext's sender.  Execute any unwind blocks on the way.  See #popTo: comment and #runUntilErrorOrReturnFrom: for more details."	suspendedContext == aContext ifTrue: [		^ suspendedContext := aContext return: value from: aContext].	self activateReturn: aContext value: value.	^ self complete: aContext.! !!Object methodsFor: 'viewer' stamp: 'sw 8/10/2004 11:53'!tilePhrasesForMethodInterfaces: methodInterfaceList inViewer: aViewer	"Return a collection of ViewerLine objects corresponding to the method-interface list provided.   The resulting list will be in the same order as the incoming list, but may be smaller if the viewer's vocbulary suppresses some of the methods, or if, in classic tiles mode, the selector requires more arguments than can be handled."	| toSuppress interfaces resultType itsSelector |	toSuppress := aViewer currentVocabulary phraseSymbolsToSuppress.	interfaces := methodInterfaceList reject: [:int | toSuppress includes: int selector].	Preferences universalTiles ifFalse:  "Classic tiles have their limitations..."		[interfaces := interfaces select:			[:int |				itsSelector := int selector.				itsSelector numArgs < 2 or:					"The lone two-arg loophole in classic tiles"					[#(color:sees:) includes: itsSelector]]].	^ interfaces collect:		[:aMethodInterface |			((resultType := aMethodInterface resultType) notNil and: [resultType ~~ #unknown]) 				ifTrue:					[aViewer phraseForVariableFrom: aMethodInterface]				ifFalse:					[aViewer phraseForCommandFrom: aMethodInterface]]! !!Process methodsFor: 'private' stamp: ''!suspendedContext: aContext	suspendedContext := aContext! !!Behavior methodsFor: 'testing method dictionary' stamp: 'NS 3/30/2004 14:25'!whichSelectorsAccess: instVarName 	"Answer a set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex := self allInstVarNames indexOf: instVarName ifAbsent: [^IdentitySet new].	^ self methodDict keys select: 		[:sel | 		((self methodDict at: sel)			readsField: instVarIndex)			or: [(self methodDict at: sel) writesField: instVarIndex]]	"Point whichSelectorsAccess: 'x'."! !!MethodDictionary methodsFor: 'private' stamp: ''!swap: oneIndex with: otherIndex	| element |	element := self basicAt: oneIndex.	self basicAt: oneIndex put: (self basicAt: otherIndex).	self basicAt: otherIndex put: element.	super swap: oneIndex with: otherIndex.! !!ContextPart methodsFor: 'private' stamp: 'di 10/23/1999 17:31'!stackp: newStackp	"Storing into the stack pointer is a potentially dangerous thing.	This primitive stores nil into any cells that become accessible as a result,	and it performs the entire operation atomically."	"Once this primitive is implemented, failure code should cause an error"	<primitive: 76>	self error: 'stackp store failure'."	stackp == nil ifTrue: [stackp := 0].	newStackp > stackp  'effectively checks that it is a number'		ifTrue: [oldStackp := stackp.				stackp := newStackp.				'Nil any newly accessible cells'				oldStackp + 1 to: stackp do: [:i | self at: i put: nil]]		ifFalse: [stackp := newStackp]"! !!Metaclass methodsFor: 'accessing' stamp: 'al 3/25/2006 12:35'!traitComposition	traitComposition ifNil: [traitComposition := TraitComposition new].	^traitComposition! !!ParagraphEditor methodsFor: 'private' stamp: 'cmm 4/9/2004 14:00'!isDisjointFrom: anInterval	"Answer true if anInterval is a caret not touching or within the current	 interval, or if anInterval is a non-caret that does not overlap the current	 selection."	| fudge |	fudge := anInterval size = 0 ifTrue: [1] ifFalse: [0].	^(anInterval last + fudge < self startIndex or:			[anInterval first - fudge >= self stopIndex])! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:25'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc := start + dir.	str := paragraph text string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc := loc + dir].	^ loc! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:32'!nextWord: position	| string index |	string := paragraph text string.	index := position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index := index + 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index := index + 1].	^ index! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'th 9/18/2002 17:28'!setAlignment: aSymbol	| attr interval |	attr := TextAlignment perform: aSymbol.	interval := self encompassLine: self selectionInterval.	paragraph replaceFrom: interval first to: interval last with:		((paragraph text copyFrom: interval first to: interval last) addAttribute: attr) displaying: true.! !!Integer methodsFor: 'printing' stamp: 'tk 4/1/2002 11:30'!asWords	"SmallInteger maxVal asWords"	| mils minus three num answer milCount |	self = 0 ifTrue: [^'zero'].	mils := #('' ' thousand' ' million' ' billion' ' trillion' ' quadrillion' ' quintillion' ' sextillion' ' septillion' ' octillion' ' nonillion' ' decillion' ' undecillion' ' duodecillion' ' tredecillion' ' quattuordecillion' ' quindecillion' ' sexdecillion' ' septendecillion' ' octodecillion' ' novemdecillion' ' vigintillion').	num := self.	minus := ''.	self < 0 ifTrue: [		minus := 'negative '.		num := num negated.	].	answer := String new.	milCount := 1.	[num > 0] whileTrue: [		three := (num \\ 1000) threeDigitName.		num := num // 1000.		three isEmpty ifFalse: [			answer isEmpty ifFalse: [				answer := ', ',answer			].			answer := three,(mils at: milCount),answer.		].		milCount := milCount + 1.	].	^minus,answer! !!ParagraphEditor methodsFor: 'controlling' stamp: ''!controlInitialize	super controlInitialize.	self recomputeInterval.	self initializeSelection.	beginTypeInBlock := nil! !!ParagraphEditor methodsFor: 'accessing' stamp: ''!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInBlock ~~ nil ifTrue: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection := self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!MethodFinder methodsFor: 'find a constant' stamp: 'md 11/14/2003 16:47'!constEquiv	| const subTest got jj |	"See if (data1 = C) or (data1 ~= C) is the answer"	"quick test"	((answers at: 1) class superclass == Boolean) ifFalse: [^ false].	2 to: answers size do: [:ii | 		((answers at: ii) class superclass == Boolean) ifFalse: [^ false]].	const := (thisData at: 1) at: 1.	got := (subTest := MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: ["try other polarity for ~~ "		(jj := answers indexOf: (answers at: 1) not) > 0 ifTrue: [		const := (thisData at: jj) at: 1.		got := (subTest := MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not]]. 	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!EventSensor methodsFor: 'private-I/O' stamp: 'nk 4/12/2004 20:01'!fetchMoreEvents	"Fetch more events from the VM"	| eventBuffer type |	"Reset input semaphore so clients can wait for the next events after this one."	inputSemaphore isSignaled		ifTrue: [ hasInputSemaphore := true.			inputSemaphore initSignals ].	"Remember the last time that I checked for events."	lastEventPoll := Time millisecondClockValue.	eventBuffer := Array new: 8.	[self primGetNextEvent: eventBuffer.	type := eventBuffer at: 1.	type = EventTypeNone]		whileFalse: [self processEvent: eventBuffer].! !!Object methodsFor: 'viewer' stamp: 'sw 11/21/2001 15:16'!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.  At present this uses a global References dictionary to hold the database of references, but in due course this will need to acquire some locality"	| aName nameSym stem knownClassVars |	(aName := self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	(stem := self knownName) ifNil:		[stem := self defaultNameStemForInstances asString].	stem := stem select: [:ch | ch isLetter or: [ch isDigit]].	stem size == 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	knownClassVars := ScriptingSystem allKnownClassVariableNames.	aName := Utilities keyLike:  stem satisfying:		[:jinaLake |			nameSym := jinaLake asSymbol.			 ((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(knownClassVars includes: nameSym) not]].	References at: (aName := aName asSymbol) put: self.	^ aName! !!ParagraphEditor methodsFor: 'private' stamp: ''!indent: delta fromStream: inStream toStream: outStream	"Append the contents of inStream to outStream, adding or deleting delta or -delta	 tabs at the beginning, and after every CR except a final CR.  Do not add tabs	 to totally empty lines, and be sure nothing but tabs are removed from lines."	| ch skip cr tab prev atEnd |	cr := Character cr.	tab := Character tab.	delta > 0		ifTrue: "shift right"			[prev := cr.			 [ch := (atEnd := inStream atEnd) ifTrue: [cr] ifFalse: [inStream next].			  (prev == cr and: [ch ~~ cr]) ifTrue:				[delta timesRepeat: [outStream nextPut: tab]].			  atEnd]				whileFalse:					[outStream nextPut: ch.					prev := ch]]		ifFalse: "shift left"			[skip := delta. "a negative number"			 [inStream atEnd] whileFalse:				[((ch := inStream next) == tab and: [skip < 0]) ifFalse:					[outStream nextPut: ch].				skip := ch == cr ifTrue: [delta] ifFalse: [skip + 1]]]! !!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'tk 1/27/2000 23:24'!scanFromNoCompile: aStream 	"Just move the source code for the methods from aStream."	| methodText selector |	[methodText := aStream nextChunkText.	 methodText size > 0]		whileTrue:		[(SourceFiles at: 2) ifNotNil: [			selector := class parserClass new parseSelector: methodText.			(class compiledMethodAt: selector) putSource: methodText 				fromParseNode: nil class: class category: category				withStamp: changeStamp inFile: 2 priorMethod: nil]]! !!BlockContext methodsFor: 'evaluating' stamp: 'cmm 2/16/2003 16:08'!bench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count |	count := 0.	endTime := Time millisecondClockValue + 5000.	startTime := Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count := count + 1 ].	endTime := Time millisecondClockValue.	^count = 1		ifTrue: [ ((endTime - startTime) // 1000) printString, ' seconds.' ]		ifFalse:			[ ((count * 1000) / (endTime - startTime)) asFloat printString, ' per second.' ]! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!selector: aSymbol	selector := aSymbol! !!Complex class methodsFor: 'instance creation' stamp: 'mk 10/27/2003 17:27'!real: aNumber1 imaginary: aNumber2	| newComplex |	newComplex := super new.	newComplex		real: aNumber1;		imaginary: aNumber2.	^ newComplex! !!Delay methodsFor: 'private' stamp: 'tpr 10/3/2005 17:22'!beGuardianDelay	"see comment for class method guardianDelay"	beingWaitedOn := false.	resumptionTime := SmallInteger maxVal.	delaySemaphore := Semaphore new! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'md 2/20/2006 21:10'!primitive: primNum numArgs: numArgs numTemps: numTemps stackSize: stackSize literals: literals bytecodes: bytecodes trailer: trailerBytes	"Create method with given attributes.  numTemps includes numArgs.  stackSize does not include numTemps."	| compiledMethod |	compiledMethod := self		newBytes: bytecodes size		trailerBytes: trailerBytes 		nArgs: numArgs		nTemps: numTemps		nStack: stackSize		nLits: literals size		primitive: primNum.	(WriteStream with: compiledMethod)		position: compiledMethod initialPC - 1;		nextPutAll: bytecodes.	literals withIndexDo: [:obj :i | compiledMethod literalAt: i put: obj].	^ compiledMethod! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:20'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	char = $9 ifTrue: [ char := $( ].	char = $, ifTrue: [ char := $< ].	char = $[ ifTrue: [ char := ${ ].	char = $' ifTrue: [ char := $" ].	char asciiValue = 27 ifTrue: [ char := ${ ].	"ctrl-["	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([<{"''' indexOf: char ifAbsent: [1].	left := '([<{"''' at: which.	right := ')]>}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])		and:		[(text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue:			["already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse:			["not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string ,(String with: right)					emphasis: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'SqR 11/14/2000 12:15'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	sensor flushKeyboard. "a way to flush stuck keys"	self closeTypeIn.	UndoParagraph == paragraph ifFalse: "Can't undo another paragraph's edit"		[UndoMessage := Message selector: #undoReplace.		UndoInterval := 1 to: 0.		Undone := true].	UndoInterval ~= self selectionInterval ifTrue: "blink the actual target"		[self selectInterval: UndoInterval; deselect].	"Leave a signal of which phase is in progress"	UndoParagraph := Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph := paragraph! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 11/28/1999 19:37'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex := self primitive.	primIndex = 0 ifTrue:[^self].	primIndex = 120 "External call spec"		ifTrue:[^aStream print: (self literalAt: 1); cr].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl := self literalAt: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>; cr! !!ParagraphEditor methodsFor: 'private' stamp: 'th 11/24/2002 17:13'!lines	"Other than my member paragraph i compute lines based on logical	line breaks, not optical (which may change due to line wrapping of the editor)"	| lines string index lineIndex stringSize |	string := paragraph text string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize := string size.	lines := OrderedCollection new: (string size // 15).	index := 0.	lineIndex := 0.	string linesDo:[:line |		lines addLast: (Array			with: (index := index + 1)			with: (lineIndex := lineIndex + 1)			with: (index := index + line size min: stringSize))].	"Special workaround for last line empty."	string last == Character cr	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!Process methodsFor: 'changing suspended state' stamp: 'gk 12/18/2003 13:09'!popTo: aContext value: aValue	"Replace the suspendedContext with aContext, releasing all contexts 	between the currently suspendedContext and it."	| callee |	self == Processor activeProcess		ifTrue: [^ self error: 'The active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ self].  "aContext is on top"	self return: callee value: aValue! !!EventSensor methodsFor: 'accessing' stamp: 'ar 2/6/2004 14:48'!flushAllButDandDEvents	| newQueue oldQueue  |		newQueue := SharedQueue new.	self eventQueue ifNil: 		[eventQueue := newQueue.		^self].	oldQueue := self eventQueue.	[oldQueue size > 0] whileTrue: 		[| item type | 		item := oldQueue next.		type := item at: 1.		type = EventTypeDragDropFiles ifTrue: [ newQueue nextPut: item]].	eventQueue := newQueue.! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 2/27/2003 22:44'!mutate: oldClass to: newClass	"Mutate the old class and subclasses into newClass and subclasses.	Note: This method is slightly different from: #mutate:toSuper: since	here we are at the root of reshaping and have two distinct roots."	| newSubclass |	self showProgressFor: oldClass.	"Convert the subclasses"	oldClass subclasses do:[:oldSubclass| 		newSubclass := self reshapeClass: oldSubclass toSuper: newClass.		self mutate: oldSubclass to: newSubclass.	].	"And any obsolete ones"	oldClass obsoleteSubclasses do:[:oldSubclass|		oldSubclass ifNotNil:[			newSubclass := self reshapeClass: oldSubclass toSuper: newClass.			self mutate: oldSubclass to: newSubclass.		].	].	self update: oldClass to: newClass.	^newClass! !!ParagraphEditor methodsFor: 'typing support' stamp: 'yo 3/16/2004 13:05'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit := beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection := self nullText. self stopIndex]		ifFalse: [self startOfTyping].	self setMark: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers := self startOfTyping - startIndex.		beginTypeInBlock := self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	self unselect! !!MethodFinder methodsFor: 'search' stamp: 'ar 4/10/2005 18:48'!findMessage	"Control the search."	data do: [:alist |		(alist isKindOf: SequenceableCollection) ifFalse: [			^ OrderedCollection with: 'first and third items are not Arrays']].	Approved ifNil: [self initialize].	"Sets of allowed selectors"	expressions := OrderedCollection new.	self search: true.	"multi"	expressions isEmpty ifTrue: [^ OrderedCollection with: 'no single method does that function'].	expressions isString ifTrue: [^ OrderedCollection with: expressions]. 	^ expressions! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/18/2001 22:46'!constMod	| subTest low |	"See if mod, (data1 \\ C) is the answer"	low := answers max.	low+1 to: low+20 do: [:const |		subTest := MethodFinder new copy: self addArg: const.		(subTest testPerfect: #\\) ifTrue: [			expressions add: 'data1 \\ ', const printString.			selector add: #\\.			^ true]].	^ false! !!Behavior methodsFor: 'accessing instances and variables' stamp: ''!subclassInstVarNames	"Answer a Set of the names of the receiver's subclasses' instance 	variables."	| vars |	vars := Set new.	self allSubclasses do: [:aSubclass | vars addAll: aSubclass instVarNames].	^vars! !!Object methodsFor: 'message handling' stamp: 'NS 1/28/2004 11:19'!withArgs: argArray executeMethod: compiledMethod	"Execute compiledMethod against the receiver and args in argArray"	| selector |	<primitive: 188>	selector := Symbol new.	self class addSelectorSilently: selector withMethod: compiledMethod.	^ [self perform: selector withArguments: argArray]		ensure: [self class basicRemoveSelector: selector]! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'sd 4/18/2003 10:26'!allMethodsInCategory: aName 	"Answer a list of all the method categories of the receiver and all its 	superclasses "	| aColl |	aColl := OrderedCollection new.	self withAllSuperclasses		do: [:aClass | aColl				addAll: (aName = ClassOrganizer allCategory						ifTrue: [aClass organization allMethodSelectors]						ifFalse: [aClass organization listAtCategoryNamed: aName])].	^ aColl asSet asSortedArray	"TileMorph allMethodsInCategory: #initialization"! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'yo 7/31/2004 16:27'!selection	"Answer the text in the paragraph that is currently selected."	| t |	t := paragraph text copyFrom: self startIndex to: self stopIndex - 1.	t string isOctetString ifTrue: [t asOctetStringText].	^ t.! !!MethodDictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:00'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value = (array at: index)			ifTrue:				[(theKey := self basicAt: index) == nil					ifFalse: [^ theKey]]].	^ exceptionBlock value! !!Object methodsFor: 'debugging-haltOnce' stamp: 'sbw 6/2/2004 08:26'!checkHaltCountExpired	| counter |	counter := Smalltalk at: #HaltCount ifAbsent: [0].	^counter = 0! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/24/2003 00:50'!cut: aContext	"Cut aContext and its senders from my sender chain"	| ctxt callee |	ctxt := self.	[ctxt == aContext] whileFalse: [		callee := ctxt.		ctxt := ctxt sender.		ctxt ifNil: [aContext ifNotNil: [self error: 'aContext not a sender']].	].	callee privSender: nil.! !!CompiledMethod methodsFor: 'scanning' stamp: ''!scanVeryLongLoad: extension offset: offset	"Answer whether the receiver contains a long load whose extension is the 	argument."	| scanner |	scanner := InstructionStream on: self.	^ scanner scanFor: [:instr | (instr = 132 and: [scanner followingByte = extension])											and: [scanner thirdByte = offset]]! !!ClassBuilder methodsFor: 'class definition' stamp: 'NS 1/21/2004 09:20'!class: oldClass instanceVariableNames: instVarString unsafe: unsafe	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass needNew copyOfOldClass |	environ := oldClass environment.	instVars := Scanner new scanFieldNames: instVarString.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].	"See if we need a new subclass or not"	needNew := self needsSubclassOf: oldClass superclass type: oldClass typeOfClass instanceVariables: instVars from: oldClass.	needNew ifNil:[^nil]. "some error"	needNew ifFalse:[^oldClass]. "no new class needed"	"Create the new class"	copyOfOldClass := oldClass copy.	newClass := self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass.			newClass := self recompile: false from: oldClass to: newClass mutate: false.	self doneCompiling: newClass.	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:20'!elementCategoryDict	| dict firstIndex lastIndex |	elementArray isNil ifTrue: [^ nil].	dict := Dictionary new: elementArray size.	1to: categoryStops size do: [:cat |		firstIndex := self firstIndexOfCategoryNumber: cat.		lastIndex := self lastIndexOfCategoryNumber: cat.		firstIndex to: lastIndex do: [:el |			dict at: (elementArray at: el) put: (categoryArray at: cat)].	].	^ dict.! !!Object methodsFor: 'viewer' stamp: 'sw 8/10/2004 12:23'!tilePhrasesForSelectorList: aList inViewer: aViewer	"Particular to the search facility in viewers.  Answer a list, in appropriate order, of ViewerLine objects to put into the viewer."	| interfaces aVocab |	aVocab := aViewer currentVocabulary.	interfaces := self		methodInterfacesInPresentationOrderFrom:			(aList collect: [:aSel | aVocab methodInterfaceForSelector: aSel class: self class])		forCategory: #search.	^ self tilePhrasesForMethodInterfaces: interfaces inViewer: aViewer! !!Number methodsFor: 'comparing' stamp: 'tk 4/16/1999 18:26'!closeTo: num	"are these two numbers close?"	| ans |	num isFloat ifTrue: [^ num closeTo: self asFloat].	[ans := self = num] ifError: [:aString :aReceiver | ^ false].	^ ans! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'sw 5/27/2000 00:03'!abandonChangeText	"Call this to get out of the maddening situation in which the system keeps aggressively trying to do a replacement that you no longer wish to make, every time you make choose a new method in a list."	ChangeText := FindText	"ParagraphEditor abandonChangeText"! !!CompiledMethod methodsFor: 'printing' stamp: 'yo 3/16/2004 12:29'!timeStamp	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"	| file preamble stamp tokens tokenCount |	self fileIndex == 0 ifTrue: [^ String new].  "no source pointer for this method"	file := SourceFiles at: self fileIndex.	file ifNil: [^ String new].  "sources file not available"	"file does not exist happens in secure mode"	file := [file readOnlyCopy] on: FileDoesNotExistException do:[:ex| nil].	file ifNil: [^ String new].	preamble := self getPreambleFrom: file at: (0 max: self filePosition - 3).		stamp := String new.		tokens := (preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [Scanner new scanTokens: preamble]			ifFalse: [Array new  "ie cant be back ref"].		(((tokenCount := tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount - 3) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"							stamp := tokens at: tokenCount - 2]].		((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount  - 1) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokenCount]].	file close.	^ stamp! !!Complex methodsFor: 'private' stamp: 'mk 10/27/2003 17:26'!imaginary: aNumber	imaginary := aNumber.! !!CompiledMethod methodsFor: 'closures' stamp: 'md 1/20/2006 16:10'!allEmbeddedBlockMethods	| set |	set := OrderedCollection new.	1 to: self numLiterals do: [:i |  | lit |		lit := self literalAt: i.		(lit isKindOf: CompiledMethod) ifTrue: [			set add: lit.			set addAll: lit allEmbeddedBlockMethods.		] ifFalse: [(lit isKindOf: BlockClosure) ifTrue: [			set add: lit method.			set addAll: lit method allEmbeddedBlockMethods		]].	].	^ set! !!CompiledMethod methodsFor: 'accessing' stamp: ''!endPC	"Answer the index of the last bytecode."	| flagByte |	flagByte := self last.	flagByte = 0 ifTrue:		["If last byte = 0, may be either 0, 0, 0, 0 or just 0"		1 to: 4 do: [:i | (self at: self size - i) = 0 ifFalse: [^ self size - i]]].	flagByte < 252 ifTrue:		["Magic sources (tempnames encoded in last few bytes)"		^ self size - self last - 1].	"Normal 4-byte source pointer"	^ self size - 4! !!Object methodsFor: 'objects from disk' stamp: 'tk 4/8/1999 12:05'!readDataFrom: aDataStream size: varsOnDisk	"Fill in the fields of self based on the contents of aDataStream.  Return self.	 Read in the instance-variables written by Object>>storeDataOn:.	 NOTE: This method must send beginReference: before reading any objects from aDataStream that might reference it.	 Allow aDataStream to have fewer inst vars.  See SmartRefStream."	| cntInstVars cntIndexedVars |	cntInstVars := self class instSize.	self class isVariable		ifTrue: [cntIndexedVars := varsOnDisk - cntInstVars.				cntIndexedVars < 0 ifTrue: [					self error: 'Class has changed too much.  Define a convertxxx method']]		ifFalse: [cntIndexedVars := 0.				cntInstVars := varsOnDisk]. 	"OK if fewer than now"	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self instVarAt: i put: aDataStream next].	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next].	"Total number read MUST be equal to varsOnDisk!!"	^ self	"If we ever return something other than self, fix calls 			on (super readDataFrom: aDataStream size: anInteger)"! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'mga 3/21/2005 10:53'!commentsIn: sourceString		| commentStart nextQuotePos someComments aPos |	('*"*' match: sourceString) ifFalse: [^#()].	someComments:= OrderedCollection new.	sourceString size == 0 ifTrue: [^ someComments].	aPos:=1.	nextQuotePos:= 0.	[commentStart := sourceString findString: '"' startingAt: aPos.	nextQuotePos:= self nextQuotePosIn: sourceString startingFrom: commentStart.	(commentStart ~= 0 and: [nextQuotePos >commentStart])] whileTrue: [		commentStart ~= nextQuotePos ifTrue: [			someComments add: ((sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"').].	aPos := nextQuotePos+1].	^someComments! !!Categorizer class methodsFor: 'documentation' stamp: 'NS 4/5/2004 17:44'!documentation	"Instances consist of an Array of category names (categoryArray), each of 	which refers to an Array of elements (elementArray). This association is 	made through an Array of stop indices (categoryStops), each of which is 	the index in elementArray of the last element (if any) of the 	corresponding category. For example: categories := Array with: 'firstCat' 	with: 'secondCat' with: 'thirdCat'. stops := Array with: 1 with: 4 with: 4. 	elements := Array with: #a with: #b with: #c with: #d. This means that 	category firstCat has only #a, secondCat has #b, #c, and #d, and 	thirdCat has no elements. This means that stops at: stops size must be the 	same as elements size." ! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/10/1999 11:17'!newInstanceFrom: oldInstance variable: variable size: instSize map: map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| new |	variable		ifTrue: [new := self basicNew: oldInstance basicSize]		ifFalse: [new := self basicNew].	1 to: instSize do: 		[:offset |  (map at: offset) > 0 ifTrue:			[new instVarAt: offset					put: (oldInstance instVarAt: (map at: offset))]].	variable 		ifTrue: [1 to: oldInstance basicSize do: 					[:offset |					new basicAt: offset put: (oldInstance basicAt: offset)]].	^new! !!Float methodsFor: 'printing' stamp: 'tao 4/19/98 23:21'!absPrintExactlyOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version guarantees that the printed representation exactly represents my value	by using exact integer arithmetic."	| fBase significand exp baseExpEstimate be be1 r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	fBase := base asFloat.	significand := self significandAsInteger.	roundingIncludesLimits := significand even.	exp := (self exponent - 52) max: MinValLogBase2.	baseExpEstimate := (self exponent * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[be := 1 << exp.			significand ~= 16r10000000000000				ifTrue:					[r := significand * be * 2.					s := 2.					mPlus := be.					mMinus := be]				ifFalse:					[be1 := be * 2.					r := significand * be1 * 2.					s := 4.					mPlus := be1.					mMinus := be]]		ifFalse:			[(exp = MinValLogBase2) | (significand ~= 16r10000000000000)				ifTrue:					[r := significand * 2.					s := (1 << (exp negated)) * 2.					mPlus := 1.					mMinus := 1]				ifFalse:					[r := significand * 4.					s := (1 << (exp negated + 1)) * 2.					mPlus := 2.					mMinus := 1]].	baseExpEstimate >= 0		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]		ifFalse:			[scale := base raisedToInteger: baseExpEstimate negated.			r := r * scale.			mPlus := mPlus * scale.			mMinus := mMinus * scale].	(r + mPlus > s) | (roundingIncludesLimits & (r + mPlus = s))		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[r := r * base.			mPlus := mPlus * base.			mMinus := mMinus * base].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1]. 	[d := r // s.	r := r \\ s.	(tc1 := (r < mMinus) | (roundingIncludesLimits & (r = mMinus))) |	(tc2 := (r + mPlus > s) | (roundingIncludesLimits & (r + mPlus = s)))] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * base.		mPlus := mPlus * base.		mMinus := mMinus * base.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!ContextPart methodsFor: 'private' stamp: 'ar 5/25/2000 20:45'!tryPrimitiveFor: method receiver: receiver args: arguments 	"If this method has a primitive index, then run the primitive and return its result.	Otherwise (and also if the primitive fails) return PrimitiveFailToken,	as an indication that the method should be activated and run as bytecodes."	| primIndex |	(primIndex := method primitive) = 0 ifTrue: [^ PrimitiveFailToken].	^ self doPrimitive: primIndex method: method receiver: receiver args: arguments! !!ParagraphEditor methodsFor: 'private' stamp: 'raok 11/15/2001 14:01'!explainDelimitor: string	"Is string enclosed in delimitors?"	| str |	(string at: 1) isLetter ifTrue: [^nil].  "only special chars"	(string first = string last) ifTrue:			[^ self explainChar: (String with: string first)]		ifFalse:			[(string first = $( and: [string last = $)]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $[ and: [string last = $]]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = ${ and: [string last = $}]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $< and: [string last = $>]) ifTrue:				[^ self explainChar: (String with: string first)].			(string first = $# and: [string last = $)]) ifTrue:				[^'"An instance of class Array.  The Numbers, Characters, or Symbols between the parenthesis are the elements of the Array."'].			string first = $# ifTrue:				[^'"An instance of class Symbol."'].			(string first = $$ and: [string size = 2]) ifTrue:				[^'"An instance of class Character.  This one is the character ', (String with: string last), '."'].			(string first = $:) ifTrue:				[str := string allButFirst.				(self explainTemp: str) ~~ nil ifTrue:					[^'"An argument to this block will be bound to the temporary variable ',						str, '."']]].	^ nil! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!noUndoer	"The Undoer to use when the command can not be undone.  Checked for	 specially by readKeyboard."	UndoMessage := Message selector: #noUndoer! !!Float methodsFor: 'printing' stamp: 'MPW 1/1/1901 01:59'!absByteEncode: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream print: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[s := s * (fBase raisedToInteger: baseExpEstimate).			exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s / fBase.					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream print: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream print: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream print: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream print: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream print: $0].		aStream print: '.0'].	fixedFormat ifFalse:		[aStream print: $e.		aStream print: (baseExpEstimate - 1) printString]! !!BlockContext methodsFor: 'private' stamp: 'ar 3/2/2001 01:16'!valueUnpreemptively	"Evaluate the receiver (block), without the possibility of preemption by higher priority processes. Use this facility VERY sparingly!!"	"Think about using Block>>valueUninterruptably first, and think about using Semaphore>>critical: before that, and think about redesigning your application even before that!! 	After you've done all that thinking, go right ahead and use it..."	| activeProcess oldPriority result |	activeProcess := Processor activeProcess.	oldPriority := activeProcess priority.	activeProcess priority: Processor highestPriority.	result := self ensure: [activeProcess priority: oldPriority].	"Yield after restoring priority to give the preempted processes a chance to run"	Processor yield.	^result! !!Process methodsFor: 'printing' stamp: 'svp 12/5/2002 14:45'!browserPrintStringWith: anObject 	| stream |	stream := WriteStream				on: (String new: 100).	stream nextPut: $(.	priority printOn: stream.	self isSuspended		ifTrue: [stream nextPut: $s].	stream nextPutAll: ') '.	stream nextPutAll: self name.	stream nextPut: $:.	stream space.	stream nextPutAll: anObject asString.	^ stream contents! !!BasicClassOrganizer class methodsFor: 'instance creation' stamp: 'NS 4/7/2004 16:04'!class: aClassDescription defaultList: aSortedCollection	| inst |	inst := self defaultList: aSortedCollection.	inst setSubject: aClassDescription.	^ inst! !!ContextPart methodsFor: 'private' stamp: 'ajh 1/23/2003 22:35'!privSender: aContext 	sender := aContext! !!InstructionStream methodsFor: 'private' stamp: 'ajh 8/1/2001 02:57'!pc: n	pc := n! !!InstVarRefLocator methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:46'!storeIntoReceiverVariable: offset 	bingo := true! !!ParagraphEditor methodsFor: 'do-its' stamp: 'acg 12/7/1999 07:53'!exploreIt	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result explore].! !!Class methodsFor: 'subclass creation' stamp: 'al 7/19/2004 11:18'!weakSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."		| newClass copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		weakSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass	! !!CompiledMethod methodsFor: 'initialize-release' stamp: ''!copyWithTrailerBytes: bytes"Testing:	(CompiledMethod compiledMethodAt: #copyWithTrailerBytes:)		tempNamesPut: 'copy end '"	| copy end start |	start := self initialPC.	end := self endPC.	copy := CompiledMethod newMethod: end - start + 1 + bytes size				header: self header.	1 to: self numLiterals do: [:i | copy literalAt: i put: (self literalAt: i)].	start to: end do: [:i | copy at: i put: (self at: i)].	1 to: bytes size do: [:i | copy at: end + i put: (bytes at: i)].	^ copy! !!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'NS 2/19/2002 11:48'!checkClassHierarchyConsistencyFor: aClassDescription	"Check whether aClassDescription has a consistent superclass and consistent regular and obsolete	subclasses"	| mySuperclass |	mySuperclass := aClassDescription superclass.	(mySuperclass subclasses includes: aClassDescription) = aClassDescription isObsolete			ifTrue: [self error: 'Something wrong!!'].	mySuperclass ifNil: [^ self].  "Obsolete subclasses of nil cannot be stored"	(mySuperclass obsoleteSubclasses includes: aClassDescription) = aClassDescription isObsolete			ifFalse: [self error: 'Something wrong!!'].	aClassDescription subclasses do: [:each |		each isObsolete ifTrue: [self error: 'Something wrong!!'].		each superclass == aClassDescription ifFalse: [self error: 'Something wrong!!']	].	aClassDescription obsoleteSubclasses do: [:each |		each isObsolete ifFalse: [self error: 'Something wrong!!'].		each superclass == aClassDescription ifFalse: [self error: 'Something wrong!!']	].! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/20/2002 11:22'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start := paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start := paragraph text size + 1].	self selectAt: start + 2.	^true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ar 1/15/2001 18:36'!pasteRecent	"Paste an item chose from RecentClippings."	| clipping |	(clipping := Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self paste! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/18/2002 11:39'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex := self mark.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	self hasSelection ifTrue:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection := self nullText].	uinterval := UndoInterval deepCopy.	upara := UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph := upara.  UndoInterval := uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel := UndoSelection.			ind := startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:38'!sortCategories	| oldCategories |	oldCategories := self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super sortCategories].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ParagraphEditor methodsFor: 'private' stamp: 'tk 7/14/2000 12:15'!getPluggableYellowButtonMenu: shiftKeyState	| customMenu |	^ ((view ~~ nil) and: [(customMenu := view getMenu: shiftKeyState) notNil])		ifTrue: [customMenu]		ifFalse:			[shiftKeyState				ifTrue: [self class shiftedYellowButtonMenu]				ifFalse: [self class yellowButtonMenu]]! !!InstVarRefLocator methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:46'!pushReceiverVariable: offset	bingo := true! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 17:21'!encompassLine: anInterval	"Return an interval that encompasses the entire line"	| string left right |	string := paragraph text string.	left := (string lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right := (string indexOf: Character cr startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!ClassDescription methodsFor: 'initialize-release' stamp: 'NS 4/8/2004 11:26'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	instanceVariables := nil.	self organization: nil.! !!Object methodsFor: 'viewer' stamp: 'sw 10/16/2000 10:35'!assureUniClass	"If the receiver is not yet an instance of a uniclass, create a uniclass for it and make the receiver become an instance of that class."	| anInstance |	self belongsToUniClass ifTrue: [^ self].	anInstance := self class instanceOfUniqueClass.	self become: (self as: anInstance class).	^ anInstance! !!MethodDictionary methodsFor: 'enumeration' stamp: ''!associationsDo: aBlock 	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key := self basicAt: i) == nil ifFalse:			[aBlock value: (Association key: key									value: (array at: i))]]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 18:26'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead := WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char := sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				self setEmphasisHere.				^self selectAndScroll; updateMarker].			self openTypeIn].		self hasSelection ifTrue: "save highlighted characters"			[UndoSelection := self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		self unselect.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!CompiledMethod methodsFor: 'literals' stamp: ''!literals	"Answer an Array of the literals referenced by the receiver."	| literals numberLiterals |	literals := Array new: (numberLiterals := self numLiterals).	1 to: numberLiterals do:		[:index |		literals at: index put: (self objectAt: index + 1)].	^literals! !!Object methodsFor: 'converting' stamp: 'ajh 7/6/2003 20:40'!mustBeBooleanIn: context	"context is the where the non-boolean error occurred. Rewind context to before jump then raise error."	| proceedValue |	context skipBackBeforeJump.	proceedValue := NonBooleanReceiver new		object: self;		signal: 'proceed for truth.'.	^ proceedValue ~~ false! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'di 6/20/97 10:51'!allSubInstances 	"Answer a list of all current instances of the receiver and all of its subclasses."	| aCollection |	aCollection := OrderedCollection new.	self allSubInstancesDo:		[:x | x == aCollection ifFalse: [aCollection add: x]].	^ aCollection! !!Integer class methodsFor: 'prime numbers' stamp: 'md 2/13/2006 14:38'!primesUpTo: max do: aBlock	"Compute aBlock with all prime integers up to the given integer."	"Integer primesUpTo: 100"	| limit flags prime k |	limit := max asInteger - 1.	"Fall back into #largePrimesUpTo:do: if we'd require more than 100k of memory; 	the alternative will only requre 1/154th of the amount we need here and is almost as fast."	limit > 25000 ifTrue:[^self largePrimesUpTo: max do: aBlock].	flags := (Array new: limit) atAllPut: true.	1 to: limit - 1 do: [:i |		(flags at: i) ifTrue: [			prime := i + 1.			k := i + prime.			[k <= limit] whileTrue: [				flags at: k put: false.				k := k + prime].			aBlock value: prime]].! !!CompiledMethod methodsFor: 'source code management' stamp: 'md 8/2/2006 20:25'!sourceSelector	"Answer my selector extracted from my source.  If no source answer nil"	| sourceString |	sourceString := self getSourceFromFile ifNil: [^ nil].	^self methodClass parserClass new parseSelector: sourceString! !!MethodDictionary methodsFor: 'removing' stamp: 'raa 5/30/2001 15:19'!removeKeyNoBecome: key	"The interpreter might be using this MethodDict while	this method is running!!  Therefore we perform the removal	in a copy, and then return the copy for subsequent installation"	| copy |	copy := self copy.	copy removeDangerouslyKey: key ifAbsent: [^ self].	^copy! !!Object methodsFor: 'copying' stamp: 'jm 11/14/97 11:08'!shallowCopy	"Answer a copy of the receiver which shares the receiver's instance variables."	| class newObject index |	<primitive: 148>	class := self class.	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index).					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index).			index := index - 1].	^ newObject! !!Class methodsFor: 'initialize-release' stamp: 'ar 7/20/1999 11:23'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	subclasses := nil. "Important for moving down the subclasses field into Class"! !!ClassDescription methodsFor: 'instance variables' stamp: 'Noury Bouraqadi 12/13/2005 07:12'!chooseInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| lines labelStream vars allVars index count offerAlpha |	(count := self allInstVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noinstance variables.'].	allVars := OrderedCollection new.	lines := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	(offerAlpha := count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	self withAllSuperclasses reverseDo:		[:class |		vars := class instVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index := (UIManager default chooseFrom: (labelStream contents subStrings: {Character cr}) lines: linestitle: 'Instance variables in', self name).	index = 0 ifTrue: [^ self].	(index = 1 and: [offerAlpha]) ifTrue: [^ selfchooseInstVarAlphabeticallyThenDo: aBlock].	aBlock value: (allVars at: index)! !!ParagraphEditor methodsFor: 'displaying' stamp: ''!display	"Redisplay the paragraph."	| selectionState |	selectionState := selectionShowing.	self deselect.	paragraph foregroundColor: view foregroundColor			backgroundColor: view backgroundColor;			displayOn: Display.	selectionState ifTrue: [self select]! !!Behavior methodsFor: 'accessing method dictionary' stamp: ''!precodeCommentOrInheritedCommentFor: selector 	"Answer a string representing the first comment in the method associated 	with selector, considering however only comments that occur before the 	beginning of the actual code. If the version recorded in the receiver is 	uncommented, look up the inheritance chain. Return nil if none found."	| aSuper aComment |	^ (aComment := self firstPrecodeCommentFor: selector) isEmptyOrNil		ifTrue: [(self == Behavior					or: [superclass == nil							or: [(aSuper := superclass whichClassIncludesSelector: selector) == nil]])				ifFalse: [aSuper precodeCommentOrInheritedCommentFor: selector]			"ActorState precodeCommentOrInheritedCommentFor: #printOn:"]		ifFalse: [aComment]! !!ParagraphEditor methodsFor: 'explain' stamp: 'nk 6/10/2004 07:02'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class := model selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class := class soleInstance].	classes := (Array with: class)				, class allSuperclasses.	"class variables"	reply := classes detect: [:each | (each classVarNames detect: [:name | symbol = name]					ifNone: [])					~~ nil]				ifNone: [].	reply == nil ifFalse: [^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol)					and: 						[reply := pool.						true]]			ifNone: [])			~~ nil].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [^ '"is an undeclared variable.' , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes := WriteStream on: Array new.			self systemNavigation				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: [])						~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply) asString , ', which is used by the following classes ' , classes contents printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , (Smalltalk keyAtIdentityValue: reply) asString , ' bindingOf: #' , symbol , ').'].	^ nil! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 20:44'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	The returned value is either 0 (if no source is stored) or a number between 16r1000000 and 16r4FFFFFF.	The actual interpretation of this number is up to the SourceFileArray stored in the global variable SourceFiles."	| pos |	self last < 252 ifTrue: [^ 0  "no source"].	pos := self last - 251.	self size - 1 to: self size - 3 by: -1 do: [:i | pos := pos * 256 + (self at: i)].	^pos! !!Metaclass methodsFor: 'accessing' stamp: 'al 3/25/2006 13:16'!basicLocalSelectors: aSetOrNil	localSelectors := aSetOrNil! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 9/20/2002 12:14'!cursorHome: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string := paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOf: Character cr						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		specialBlock: [:dummy | 1].	^true! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'NS 12/12/2003 15:08'!newInstanceFrom: oldInstance variable: variable size: instSize map: map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| new |	new := self newFrom: oldInstance.	1 to: instSize do: 		[:offset |  (map at: offset) > 0 ifTrue:			[new instVarAt: offset					put: (oldInstance instVarAt: (map at: offset))]].	^new! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 9/19/2002 18:12'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start := self startIndex.	stop := self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere := (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval := otherInterval := self selectionInterval]! !!Categorizer methodsFor: 'printing' stamp: 'NS 4/5/2004 17:44'!printOn: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex |	elementIndex := 1.	1 to: categoryArray size do: 		[:i | 		aStream nextPut: $(.		(categoryArray at: i) asString printOn: aStream.		[elementIndex <= (categoryStops at: i)]			whileTrue: 				[aStream space; nextPutAll: (elementArray at: elementIndex).				elementIndex := elementIndex + 1].		aStream nextPut: $); cr]! !!Object methodsFor: 'macpal' stamp: 'sw 6/16/1998 15:07'!instanceVariableValues	"Answer a collection whose elements are the values of those instance variables of the receiver which were added by the receiver's class"	| c |	c := OrderedCollection new.	self class superclass instSize + 1 to: self class instSize do:		[:i | c add: (self instVarAt: i)].	^ c! !!MethodReference methodsFor: '*Kernel-Traits' stamp: 'md 3/3/2006 09:25'!actualClass 	| actualClass |	actualClass := Smalltalk at: classSymbol ifAbsent: [^nil].	classIsMeta ifTrue: [^actualClass classSide].	^actualClass! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/12/2004 16:22'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes := (Array with: cls)				, cls allSuperclasses.	classes := classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes := classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!ParagraphEditor class methodsFor: 'instance creation' stamp: 'nk 9/3/2004 14:10'!new	"Answer a new instance of me with a null Paragraph to be edited."	| aParagraphEditor |	aParagraphEditor := super new.	aParagraphEditor changeParagraph: '' asParagraph.	^aParagraphEditor! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/15/2004 12:33'!isEmptyCategoryNamed: categoryName	| i |	i := categoryArray indexOf: categoryName ifAbsent: [^false].	^self isEmptyCategoryNumber: i! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:40'!pop	"Answer the top of the receiver's stack and remove the top of the stack."	| val |	val := self at: stackp.	self stackp: stackp - 1.	^ val! !!Float methodsFor: 'mathematical functions' stamp: 'tao 4/19/98 23:22'!reciprocalFloorLog: radix 	"Quick computation of (self log: radix) floor, when self < 1.0.	Avoids infinite recursion problems with denormalized numbers"	| adjust scale n |	adjust := 0.	scale := 1.0.	[(n := radix / (self * scale)) isInfinite]		whileTrue:			[scale := scale * radix.			adjust := adjust + 1].	^ ((n floorLog: radix) + adjust) negated! !!SmallInteger methodsFor: 'arithmetic' stamp: 'LC 4/22/1998 14:21'!gcd: anInteger 	"See SmallInteger (Integer) | gcd:"	| n m |	n := self.	m := anInteger.	[n = 0]		whileFalse: 			[n := m \\ (m := n)].	^ m abs! !!ParagraphEditor methodsFor: 'accessing' stamp: ''!setSearch: aString	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	FindText string = aString		ifFalse: [FindText := ChangeText := aString asText]! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^nil].	"not in a message"	classes := self systemNavigation allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!Float methodsFor: 'truncation and round off' stamp: 'nice 7/24/2008 01:32'!rounded	"Answer the integer nearest the receiver.	Implementation note: super would not handle tricky inexact arithmetic"		"self assert: 5000000000000001.0 rounded = 5000000000000001"	self fractionPart abs < 0.5		ifTrue: [^self truncated]		ifFalse: [^self truncated + self sign rounded]! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 11/29/2000 14:32'!anyBitOfMagnitudeFrom: start to: stopArg 	"Tests for any magnitude bits in the interval from start to stopArg."	"Primitive fixed in LargeIntegers v1.2. If you have an earlier version 	comment out the primitive call (using this ST method then)."	| magnitude firstDigitIx lastDigitIx rightShift leftShift stop |	<primitive: 'primAnyBitFromTo' module:'LargeIntegers'>	start < 1 | (stopArg < 1)		ifTrue: [^ self error: 'out of range'].	magnitude := self abs.	stop := stopArg min: magnitude highBit.	start > stop		ifTrue: [^ false].	firstDigitIx := start - 1 // 8 + 1.	lastDigitIx := stop - 1 // 8 + 1.	rightShift := (start - 1 \\ 8) negated.	leftShift := 7 - (stop - 1 \\ 8).	firstDigitIx = lastDigitIx		ifTrue: [| digit mask | 			mask := (255 bitShift: rightShift negated)						bitAnd: (255 bitShift: leftShift negated).			digit := magnitude digitAt: firstDigitIx.			^ (digit bitAnd: mask)				~= 0].	((magnitude digitAt: firstDigitIx)			bitShift: rightShift)			~= 0		ifTrue: [^ true].	firstDigitIx + 1		to: lastDigitIx - 1		do: [:ix | (magnitude digitAt: ix)					~= 0				ifTrue: [^ true]].	(((magnitude digitAt: lastDigitIx)			bitShift: leftShift)			bitAnd: 255)			~= 0		ifTrue: [^ true].	^ false! !!CompiledMethod methodsFor: 'closures' stamp: 'md 1/20/2006 16:00'!embeddedBlockMethods	| set |	set := OrderedCollection new.	1 to: self numLiterals do: [:i |  | lit |		lit := self literalAt: i.		(lit isKindOf: CompiledMethod) ifTrue: [			set add: lit.		] ifFalse: [(lit isKindOf: BlockClosure) ifTrue: [			set add: lit method.		]].	].	^ set! !!Integer methodsFor: 'printing' stamp: 'ar 7/18/2001 22:09'!asStringWithCommasSigned	"123456789 asStringWithCommasSigned"	"-123456789 asStringWithCommasSigned"	| digits |	digits := self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-] ifFalse:[strm nextPut: $+].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!BlockContext methodsFor: 'evaluating' stamp: 'md 11/10/2004 18:43'!valueSupplyingAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first or:						[caption includesSubstring: each first caseSensitive: false] or:						[each first match: caption]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/14/1999 11:19'!subclasses	"Answer the receiver's subclasses."	thisClass == nil ifTrue:[^#()].	^thisClass subclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"! !!MethodFinder methodsFor: 'initialize' stamp: 'md 1/17/2006 17:57'!initialize2	"The methods we are allowed to use.  (MethodFinder new initialize) ""Set"	#("in class" sizeFor:"testing" "adding" "removing" "enumerating""private" array findElementOrNil: "accessing" someElement) do: [:sel | Approved add: sel]."Dictionary, IdentityDictionary, IdentitySet"	#("accessing" associationAt: associationAt:ifAbsent: at:ifPresent: keyAtIdentityValue: keyAtIdentityValue:ifAbsent: keyAtValue: keyAtValue:ifAbsent: keys"testing" includesKey: ) do: [:sel | Approved add: sel].	#(removeKey: removeKey:ifAbsent:) do: [:sel | AddAndRemove add: sel]."LinkedList, Interval, MappedCollection"	#("in class"  from:to: from:to:by:"accessing" contents) do: [:sel | Approved add: sel].	#("adding" addFirst: addLast:) do: [:sel | AddAndRemove add: sel]."OrderedCollection, SortedCollection"	#("accessing" after: before:"copying" copyEmpty"adding"  growSize"removing" "enumerating" "private" "accessing" sortBlock) do: [:sel | Approved add: sel].	#("adding" add:after: add:afterIndex: add:before: addAllFirst: addAllLast: addFirst: addLast:"removing" removeAt: removeFirst removeLast"accessing" sortBlock:) do: [:sel | AddAndRemove add: sel]."Character"	#("in class, instance creation" allCharacters digitValue: new separators	"accessing untypeable characters" backspace cr enter lf linefeed nbsp newPage space tab	"constants" alphabet characterTable"accessing" asciiValue digitValue"comparing""testing" isAlphaNumeric isDigit isLetter isLowercase isSafeForHTTP isSeparator isSpecial isUppercase isVowel tokenish"copying""converting" asIRCLowercase asLowercase asUppercase	) do: [:sel | Approved add: sel]."String"	#("in class, instance creation" crlf fromPacked:	"primitives" findFirstInString:inSet:startingAt: indexOfAscii:inString:startingAt: 	"internet" valueOfHtmlEntity:"accessing" byteAt: endsWithDigit findAnySubStr:startingAt: findBetweenSubStrs: findDelimiters:startingAt: findString:startingAt: findString:startingAt:caseSensitive: findTokens: findTokens:includes: findTokens:keep: includesSubString: includesSubstring:caseSensitive: indexOf:startingAt: indexOfAnyOf: indexOfAnyOf:ifAbsent: indexOfAnyOf:startingAt: indexOfAnyOf:startingAt:ifAbsent: lineCorrespondingToIndex: lineCount lineNumber: skipAnySubStr:startingAt: skipDelimiters:startingAt: startsWithDigit"comparing" alike: beginsWith: caseSensitiveLessOrEqual: charactersExactlyMatching: compare: crc16 endsWith: endsWithAnyOf: sameAs: startingAt:match:startingAt:"copying" copyReplaceTokens:with: padded:to:with:"converting" asByteArray asDate asDisplayText asFileName asHtml asLegalSelector asPacked asParagraph asText asTime asUnHtml asUrl asUrlRelativeTo: capitalized compressWithTable: contractTo: correctAgainst: encodeForHTTP initialIntegerOrNil keywords quoted sansPeriodSuffix splitInteger stemAndNumericSuffix substrings surroundedBySingleQuotes truncateWithElipsisTo: withBlanksTrimmed withFirstCharacterDownshifted withNoLineLongerThan: withSeparatorsCompacted withoutLeadingDigits withoutTrailingBlanks"displaying" "printing""system primitives" compare:with:collated: "Celeste" withCRs"internet" decodeMimeHeader decodeQuotedPrintable unescapePercents withInternetLineEndings withSqueakLineEndings withoutQuoting"testing" isAllSeparators lastSpacePosition"paragraph support" indentationIfBlank:"arithmetic" ) do: [:sel | Approved add: sel].	#(byteAt:put: translateToLowercase match:) do: [:sel | AddAndRemove add: sel]."Symbol"	#("in class, private" hasInterned:ifTrue:	"access" morePossibleSelectorsFor: possibleSelectorsFor: selectorsContaining: thatStarts:skipping:"accessing" "comparing" "copying" "converting" "printing" "testing" isInfix isKeyword isPvtSelector isUnary) do: [:sel | Approved add: sel]."Array"	#("comparing" "converting" evalStrings "printing" "private" hasLiteralSuchThat:) do: [:sel | Approved add: sel]."Array2D"	#("access" at:at: atCol: atCol:put: atRow: extent extent:fromArray: height width width:height:type:) do: [:sel | Approved add: sel].	#(at:at:add: at:at:put: atRow:put: ) do: [:sel | AddAndRemove add: sel]."ByteArray"	#("accessing" doubleWordAt: wordAt: "platform independent access" longAt:bigEndian: shortAt:bigEndian: unsignedLongAt:bigEndian: unsignedShortAt:bigEndian: "converting") do: [:sel | Approved add: sel].	#(doubleWordAt:put: wordAt:put: longAt:put:bigEndian: shortAt:put:bigEndian: unsignedLongAt:put:bigEndian: unsignedShortAt:put:bigEndian:	) do: [:sel | AddAndRemove add: sel]."FloatArray"		"Dont know what happens when prims not here"	false ifTrue: [#("accessing" "arithmetic" *= += -= /="comparing""primitives-plugin" primAddArray: primAddScalar: primDivArray: primDivScalar: primMulArray: primMulScalar: primSubArray: primSubScalar:"primitives-translated" primAddArray:withArray:from:to: primMulArray:withArray:from:to: primSubArray:withArray:from:to:"converting" "private" "user interface") do: [:sel | Approved add: sel].	]."IntegerArray, WordArray""RunArray"	#("in class, instance creation" runs:values: scanFrom:"accessing" runLengthAt: "adding" "copying""private" runs values) do: [:sel | Approved add: sel].	#(coalesce addLast:times: repeatLast:ifEmpty: repeatLastIfEmpty:		) do: [:sel | AddAndRemove add: sel]."Stream  -- many operations change its state"	#("testing" atEnd) do: [:sel | Approved add: sel].	#("accessing" next: nextMatchAll: nextMatchFor: upToEndnext:put: nextPut: nextPutAll: "printing" print: printHtml:	) do: [:sel | AddAndRemove add: sel]."PositionableStream"	#("accessing" contentsOfEntireFile originalContents peek peekFor: "testing""positioning" position ) do: [:sel | Approved add: sel].	#(nextDelimited: nextLine upTo: position: reset resetContents setToEnd skip: skipTo: upToAll: ) do: [:sel | AddAndRemove add: sel].	"Because it is so difficult to test the result of an operation on a Stream (you have to supply another Stream in the same state), we don't support Streams beyond the basics.  We want to find the messages that convert Streams to other things.""ReadWriteStream"	#("file status" closed) do: [:sel | Approved add: sel].	#("accessing" next: on: ) do: [:sel | AddAndRemove add: sel]."WriteStream"	#("in class, instance creation" on:from:to: with: with:from:to:		) do: [:sel | Approved add: sel].	#("positioning" resetToStart"character writing" crtab crtab:) do: [:sel | AddAndRemove add: sel]."LookupKey, Association, Link"	#("accessing" key nextLink) do: [:sel | Approved add: sel].	#(key: key:value: nextLink:) do: [:sel | AddAndRemove add: sel]."Point"	#("in class, instance creation" r:degrees: x:y:"accessing" x y "comparing" "arithmetic" "truncation and round off""polar coordinates" degrees r theta"point functions" bearingToPoint: crossProduct: dist: dotProduct: eightNeighbors flipBy:centerAt: fourNeighbors grid: nearestPointAlongLineFrom:to: nearestPointOnLineFrom:to: normal normalized octantOf: onLineFrom:to: onLineFrom:to:within: quadrantOf: rotateBy:centerAt: transposed unitVector"converting" asFloatPoint asIntegerPoint corner: extent: rect:"transforming" adhereTo: rotateBy:about: scaleBy: scaleFrom:to: translateBy: "copying""interpolating" interpolateTo:at:) do: [:sel | Approved add: sel]."Rectangle"	#("in class, instance creation" center:extent: encompassing: left:right:top:bottom: 	merging: origin:corner: origin:extent: "accessing" area bottom bottomCenter bottomLeft bottomRight boundingBox center corner corners innerCorners left leftCenter origin right rightCenter top topCenter topLeft topRight"comparing""rectangle functions" adjustTo:along: amountToTranslateWithin: areasOutside: bordersOn:along: encompass: expandBy: extendBy: forPoint:closestSideDistLen: insetBy: insetOriginBy:cornerBy: intersect: merge: pointNearestTo: quickMerge: rectanglesAt:height: sideNearestTo: translatedToBeWithin: withBottom: withHeight: withLeft: withRight: withSide:setTo: withTop: withWidth:"testing" containsPoint: containsRect: hasPositiveExtent intersects: isTall isWide"truncation and round off""transforming" align:with: centeredBeneath: newRectFrom: squishedWithin: "copying"	) do: [:sel | Approved add: sel]."Color"	#("in class, instance creation" colorFrom: colorFromPixelValue:depth: fromRgbTriplet: gray: h:s:v: r:g:b: r:g:b:alpha: r:g:b:range:	"named colors" black blue brown cyan darkGray gray green lightBlue lightBrown lightCyan lightGray lightGreen lightMagenta lightOrange lightRed lightYellow magenta orange red transparent veryDarkGray veryLightGray veryVeryDarkGray veryVeryLightGray white yellow	"other" colorNames indexedColors pixelScreenForDepth: quickHighLight:"access" alpha blue brightness green hue luminance red saturation"equality""queries" isBitmapFill isBlack isGray isSolidFill isTranslucent isTranslucentColor"transformations" alpha: dansDarker darker lighter mixed:with: muchLighter slightlyDarker slightlyLighter veryMuchLighter alphaMixed:with:"groups of shades" darkShades: lightShades: mix:shades: wheel:"printing" shortPrintString"other" colorForInsets rgbTriplet"conversions" asB3DColor asColor balancedPatternForDepth: bitPatternForDepth: closestPixelValue1 closestPixelValue2 closestPixelValue4 closestPixelValue8 dominantColor halfTonePattern1 halfTonePattern2 indexInMap: pixelValueForDepth: pixelWordFor:filledWith: pixelWordForDepth: scaledPixelValue32"private" privateAlpha privateBlue privateGreen privateRGB privateRed "copying"	) do: [:sel | Approved add: sel]."	For each selector that requires a block argument, add (selector argNum) 		to the set Blocks.""ourClasses := #(Object Boolean True False UndefinedObject Behavior ClassDescription Class Metaclass MethodContext BlockContext Message Magnitude Date Time Number Integer SmallInteger LargeNegativeInteger LargePositiveInteger Float Fraction Random Collection SequenceableCollection ArrayedCollection Bag Set Dictionary IdentityDictionary IdentitySet LinkedList Interval MappedCollection OrderedCollection SortedCollection Character String Symbol Array Array2D ByteArray FloatArray IntegerArray WordArray RunArray Stream PositionableStream ReadWriteStream WriteStream LookupKey Association Link Point Rectangle Color).ourClasses do: [:clsName | cls := Smalltalk at: clsName.	(cls selectors) do: [:aSel |		((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [			(cls formalParametersAt: aSel) withIndexDo: [:tName :ind |				(tName endsWith: 'Block') ifTrue: [					Blocks add: (Array with: aSel with: ind)]]]]]."#((timesRepeat: 1 ) (indexOf:ifAbsent: 2 ) (pairsCollect: 1 ) (mergeSortFrom:to:by: 3 ) (ifNotNil:ifNil: 1 ) (ifNotNil:ifNil: 2 ) (ifNil: 1 ) (at:ifAbsent: 2 ) (ifNil:ifNotNil: 1 ) (ifNil:ifNotNil: 2 ) (ifNotNil: 1 ) (at:modify: 2 ) (identityIndexOf:ifAbsent: 2 ) (sort: 1 ) (sortBlock: 1 ) (detectMax: 1 ) (repeatLastIfEmpty: 1 ) (allSubclassesWithLevelDo:startingLevel: 1 ) (keyAtValue:ifAbsent: 2 ) (in: 1 ) (ifTrue: 1 ) (or: 1 ) (select: 1 ) (inject:into: 2 )  (forPoint:closestSideDistLen: 2 ) (value:ifError: 2 ) (selectorsDo: 1 ) (removeAllSuchThat: 1 ) (keyAtIdentityValue:ifAbsent: 2 ) (detectMin: 1 ) (detect:ifNone: 1 ) (ifTrue:ifFalse: 1 ) (ifTrue:ifFalse: 2 ) (detect:ifNone: 2 ) (hasLiteralSuchThat: 1 ) (indexOfAnyOf:ifAbsent: 2 ) (reject: 1 ) (newRectFrom: 1 ) (removeKey:ifAbsent: 2 ) (at:ifPresent: 2 ) (associationAt:ifAbsent: 2 ) (withIndexCollect: 1 ) (repeatLast:ifEmpty: 2 ) (findLast: 1 ) (indexOf:startingAt:ifAbsent: 3 ) (remove:ifAbsent: 2 ) (ifFalse:ifTrue: 1 ) (ifFalse:ifTrue: 2 ) (caseOf:otherwise: 2 ) (count: 1 ) (collect: 1 ) (sortBy: 1 ) (and: 1 ) (asSortedCollection: 1 ) (with:collect: 2 ) (sourceCodeAt:ifAbsent: 2 ) (detect: 1 ) (collectWithIndex: 1 ) (compiledMethodAt:ifAbsent: 2 ) (bindWithTemp: 1 ) (detectSum: 1 ) (indexOfSubCollection:startingAt:ifAbsent: 3 ) (findFirst: 1 ) (sourceMethodAt:ifAbsent: 2 ) (collect:thenSelect: 1 ) (collect:thenSelect: 2 ) (select:thenCollect: 1 ) (select:thenCollect: 2 ) (ifFalse: 1 ) (indexOfAnyOf:startingAt:ifAbsent: 3 ) (indentationIfBlank: 1 ) ) do: [:anArray |	Blocks add: anArray].self initialize3."MethodFinder new initialize.MethodFinder new organizationFiltered: TranslucentColor class ""Do not forget class messages for each of these classes"! !!Monitor methodsFor: 'private' stamp: 'NS 7/1/2002 15:10'!queueDict	queueDict ifNil: [queueDict := IdentityDictionary new].	^ queueDict.! !!LargeNegativeInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:10'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen minVal |	<primitive: 'primNormalizeNegative' module:'LargeIntegers'>	"First establish len = significant length"	len := oldLen := self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len := len - 1].	"Now check if in SmallInteger range"	sLen := 4  "SmallInteger minVal digitLength".	len <= sLen ifTrue:		[minVal := SmallInteger minVal.		(len < sLen			or: [(self digitAt: sLen) < minVal lastDigit])			ifTrue: ["If high digit less, then can be small"					val := 0.					len to: 1 by: -1 do:						[:i | val := (val *256) - (self digitAt: i)].					^ val].		1 to: sLen do:  "If all digits same, then = minVal"			[:i | (self digitAt: i) = (minVal digitAt: i)					ifFalse: ["Not so; return self shortened"							len < oldLen								ifTrue: [^ self growto: len]								ifFalse: [^ self]]].		^ minVal].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!ProcessorScheduler methodsFor: 'process state change' stamp: 'tpr 4/28/2004 17:53'!yield	"Give other Processes at the current priority a chance to run."	| semaphore |	<primitive: 167>	semaphore := Semaphore new.	[semaphore signal] fork.	semaphore wait! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:13'!printOn: aStream base: base length: minimum padded: zeroFlag	| prefix |	prefix := self negative ifTrue: ['-'] ifFalse: [String new].	self print: (self abs printStringBase: base) on: aStream prefix: prefix length: minimum padded: zeroFlag! !!Float methodsFor: 'mathematical functions' stamp: ''!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base := E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract := self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction := 1.0 + fract.	delta := fract * fract / 2.0.	div := 2.0.	[delta > Epsilon] whileTrue: [		correction := correction + delta.		div := div + 1.0.		delta := delta * fract / div].	correction := correction + delta.	^ base * correction! !!ContextPart methodsFor: 'system simulation' stamp: 'hmm 7/15/2001 20:58'!quickStep	"If the next instruction is a send, just perform it.	Otherwise, do a normal step."	self willReallySend ifTrue: [QuickStep := self].	^self step! !!Class methodsFor: 'accessing' stamp: 'al 3/25/2006 12:35'!traitComposition	traitComposition ifNil: [traitComposition := TraitComposition new].	^traitComposition! !!Metaclass methodsFor: 'copying' stamp: ''!copy	"Make a copy of the receiver without a list of subclasses. Share the 	reference to the sole instance."	| copy t |	t := thisClass.	thisClass := nil.	copy := super copy.	thisClass := t.	^copy! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'di 3/7/2001 17:05'!recoverFromMDFault	"This method handles methodDict faults to support, eg, discoverActiveClasses (qv)."	(organization isMemberOf: Array) ifFalse: [^ self error: 'oops'].	methodDict := organization first.	organization := organization second.! !!EventSensor class methodsFor: 'class initialization' stamp: 'nk 4/12/2004 18:55'!eventPollPeriod: msec	"Set the number of milliseconds between checking for events to msec."	EventPollPeriod := msec max: 10.! !!ContextPart class methodsFor: 'examples' stamp: ''!tallyMethods: aBlock	"This method uses the simulator to count the number of calls on each method	invoked in evaluating aBlock. Results are given in order of decreasing counts."	| prev tallies |	tallies := Bag new.	prev := aBlock.	thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			current == prev ifFalse: "call or return"				[prev sender == nil ifFalse: "call only"					[tallies add: current printString].				prev := current]].	^tallies sortedCounts	"ContextPart tallyMethods: [3.14159 printString]"! !!Object methodsFor: 'testing' stamp: 'sw 11/19/2001 13:28'!nameForViewer	"Answer a name to be shown in a Viewer that is viewing the receiver"	| aName |	(aName := self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	(aName := self knownName) ifNotNil: [^ aName].	^ [(self asString copyWithout: Character cr) truncateTo:  27] ifError:		[:msg :rcvr | ^ self class name printString]! !!Object methodsFor: 'casing' stamp: ''!caseOf: aBlockAssociationCollection otherwise: aBlock	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, answer the result	 of evaluating aBlock."	aBlockAssociationCollection associationsDo:		[:assoc | (assoc key value = self) ifTrue: [^assoc value value]].	^ aBlock value"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z otherwise: [0]""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]} otherwise: [0]"! !!Object methodsFor: 'comparing' stamp: 'tk 4/16/1999 18:26'!closeTo: anObject	"Answer whether the receiver and the argument represent the same	object. If = is redefined in any subclass, consider also redefining the	message hash."	| ans |	[ans := self = anObject] ifError: [:aString :aReceiver | ^ false].	^ ans! !!BlockContext methodsFor: 'system simulation' stamp: 'di 1/11/1999 10:24'!pushArgs: args from: sendr 	"Simulates action of the value primitive."	args size ~= nargs ifTrue: [^self error: 'incorrect number of args'].	self stackp: 0.	args do: [:arg | self push: arg].	sender := sendr.	pc := startpc! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 18:17'!simpleSearch	"Run through first arg's class' selectors, looking for one that works."| class supers listOfLists |self exceptions.class := thisData first first class."Cache the selectors for the receiver class"(class == cachedClass and: [cachedArgNum = ((argMap size) - 1)]) 	ifTrue: [listOfLists := cachedSelectorLists]	ifFalse: [supers := class withAllSuperclasses.		listOfLists := OrderedCollection new.		supers do: [:cls |			listOfLists add: (cls selectorsWithArgs: (argMap size) - 1)].		cachedClass := class.		cachedArgNum := (argMap size) - 1.		cachedSelectorLists := listOfLists].listOfLists do: [:selectorList |	selectorList do: [:aSel |		(selector includes: aSel) ifFalse: [			((Approved includes: aSel) or: [AddAndRemove includes: aSel]) ifTrue: [				(self testPerfect: aSel) ifTrue: [					selector add: aSel.					expressions add: (String streamContents: [:strm | 						strm nextPutAll: 'data', argMap first printString.						aSel keywords doWithIndex: [:key :ind |							strm nextPutAll: ' ',key.							(key last == $:) | (key first isLetter not)								ifTrue: [strm nextPutAll: ' data', 									(argMap at: ind+1) printString]]])					]]]]].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:44'!spawnWorkspace	| toUse |	self selectLine.	toUse := self selection asString.	toUse size > 0 ifFalse:		[toUse := paragraph text string.		toUse size > 0 ifFalse: [^ self flash]].	"NB: BrowserCodeController's version does a cancel here"	self terminateAndInitializeAround:		[Utilities openScratchWorkspaceLabeled: 'Untitled' contents: toUse]! !!Object methodsFor: 'undo' stamp: 'di 9/11/2000 20:30'!rememberUndoableAction: actionBlock named: caption	| cmd result |	cmd := Command new cmdWording: caption.	cmd undoTarget: self selector: #undoFromCapturedState: argument: self capturedState.	result := actionBlock value.	cmd redoTarget: self selector: #redoFromCapturedState: argument: self capturedState.	self rememberCommand: cmd.	^ result! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:25'!next	"Answer a random Float in the interval [0 to 1)."	^ (seed := self nextValue) / m! !!Number methodsFor: 'printing' stamp: 'fcs 12/13/2006 19:47'!printShowingDecimalPlaces: placesDesired	"Print the receiver showing precisely the given number of places desired.  If placesDesired is positive, a decimal point and that many digits after the decimal point will always be shown.  If placesDesired is zero, a whole number will be shown, without a decimal point.  It now handles negative numbers between 0 and -1 and rounds correctly in more cases.  This method probably could be optimized -- improvements welcomed.  Category was/is 'converting' but should be 'printing' "	| precision rounded frac sign integerString fractionString result |	placesDesired <= 0 ifTrue: [^ self rounded printString].	precision := Utilities floatPrecisionForDecimalPlaces: placesDesired.	rounded := self roundTo: precision.	sign := rounded negative ifTrue: ['-'] ifFalse: [''].	integerString := rounded abs integerPart asInteger printString.	frac := ((rounded abs fractionPart roundTo: precision) * (10 raisedToInteger: placesDesired)) asInteger.	fractionString := frac printString padded: #right to: placesDesired with: $0.	result := sign , integerString , '.' , fractionString.	^result"23 printShowingDecimalPlaces: 223.5698 printShowingDecimalPlaces: 2-234.567 printShowingDecimalPlaces: 523.4567 printShowingDecimalPlaces: 023.5567 printShowingDecimalPlaces: 0-23.4567 printShowingDecimalPlaces: 0-23.5567 printShowingDecimalPlaces: 0100000000 printShowingDecimalPlaces: 10.98 printShowingDecimalPlaces: 2-0.98 printShowingDecimalPlaces: 22.567 printShowingDecimalPlaces: 2-2.567 printShowingDecimalPlaces: 20 printShowingDecimalPlaces: 2Number categoryForSelector: #printShowingDecimalPlaces:"! !!EventSensor methodsFor: 'private' stamp: 'JMM 11/7/2005 14:39'!primKbdPeek	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| char |	self wait2ms.	self fetchMoreEvents.	keyboardBuffer isEmpty ifFalse: [^ keyboardBuffer peek].	char := nil.	eventQueue ifNotNil:		[eventQueue nextOrNilSuchThat:  "NOTE: must not return out of this block, so loop to end"			[:buf | (self isKbdEvent: buf) ifTrue: [char ifNil: [char := buf at: 3]].			false  "NOTE: block value must be false so Queue won't advance"]].	^ char! !!Categorizer methodsFor: 'printing' stamp: 'NS 4/5/2004 17:44'!printOnStream: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex  |	elementIndex := 1.	1 to: categoryArray size do: 		[:i | 		aStream print: '(';		write:(categoryArray at:i).		" is the asString redundant? "		[elementIndex <= (categoryStops at: i)]			whileTrue: 				[aStream print:' '; write:(elementArray at: elementIndex).				elementIndex := elementIndex + 1].		aStream print:')'.		aStream cr]! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!removeCategory: cat 	| oldCategories |	oldCategories := self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super removeCategory: cat].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger ifTrue: 		[ng := self negative == aNumber negative == false.		quo := (self digitDiv:			(aNumber class == SmallInteger				ifTrue: [aNumber abs]				ifFalse: [aNumber])			neg: ng) at: 1.		^ quo normalize].	^ aNumber adaptToInteger: self andSend: #quo:! !!Metaclass methodsFor: 'private' stamp: 'ar 3/3/2001 00:20'!replaceObsoleteInstanceWith: newInstance	thisClass class == self ifTrue:[^self error:'I am fine, thanks'].	newInstance class == self ifFalse:[^self error:'Not an instance of me'].	thisClass := newInstance.! !!Complex methodsFor: 'mathematical functions' stamp: 'md 7/16/2004 16:16'!cos	"Answer receiver's cosine."	| iself |	iself := 1 i * self.	^ (iself exp + iself negated exp) / 2! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/23/2003 22:06'!stepToCallee	"Step until top context changes"	| ctxt |	ctxt := suspendedContext.	[ctxt == suspendedContext] whileTrue: [		suspendedContext := suspendedContext step].	^ suspendedContext! !!SmallInteger methodsFor: 'private' stamp: ''!fromString: str radix: radix	| maxdigit c val |	maxdigit := 		radix + (radix > 10					ifTrue: [55 - 1]					ifFalse: [48 - 1]).	val := 0.	1 to: str size do: 		[:i | 		c := str at: i.		(c < 48 ifFalse: [c > maxdigit])			ifTrue: [^false].		val := val * radix + (c <= 57							ifTrue: [c - 48]							ifFalse: 								[c < 65 ifTrue: [^false].								c - 55])].	^val! !!ClassBuilder methodsFor: 'private' stamp: 'ar 2/27/2003 22:56'!privateNewSubclassOf: newSuper	"Create a new meta and non-meta subclass of newSuper"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta newMeta |	newSuperMeta := newSuper ifNil:[Class] ifNotNil:[newSuper class].	newMeta := Metaclass new.	newMeta 		superclass: newSuperMeta 		methodDictionary: MethodDictionary new 		format: newSuperMeta format.	^newMeta new! !!ParagraphEditor methodsFor: 'explain' stamp: 'tpr 5/29/2003 20:07'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply := Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes := Set new.			self systemNavigation allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes := classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!BasicClassOrganizer methodsFor: 'private' stamp: 'NS 4/7/2004 16:04'!setSubject: aClassDescription	subject := aClassDescription! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:15'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero.  	This method is used for LargeNegativeIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	| realLength lastDigit |	realLength := self digitLength.	[(lastDigit := self digitAt: realLength) = 0]		whileTrue: [(realLength := realLength - 1) = 0 ifTrue: [^ 0]].	^ lastDigit highBitOfPositiveReceiver + (8 * (realLength - 1))! !!InstructionStream methodsFor: 'scanning' stamp: 'ajh 7/18/2003 21:36'!peekInstruction	"Return the next bytecode instruction as a message that an InstructionClient would understand.  The pc remains unchanged."	| currentPc instr |	currentPc := self pc.	instr := self nextInstruction.	self pc: currentPc.	^ instr! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:48'!constPlus	| const subTest got |	"See if (data1 + C) is the answer"	const := (answers at: 1) - ((thisData at: 1) at: 1).	got := (subTest := MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!BlockContext methodsFor: 'initialize-release' stamp: 'ls 6/21/2000 17:42'!home: aContextPart startpc: position nargs: anInteger 	"This is the initialization message. The receiver has been initialized with 	the correct size only."	home := aContextPart.	pc := startpc := position.	nargs := anInteger.	stackp := 0.! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 07:55'!selector: aSymbol	selector := aSymbol! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:31'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList := paragraph text attributesAt: (self pointIndex +self markIndex)//2 forStyle: paragraph textStyle.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self selection asString, '<', attr info, '>']].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self selection asString, '<', attr color printString, '>']].	^ self selection asString, '[No hidden info]'! !!ContextPart methodsFor: 'controlling' stamp: ''!hasSender: context 	"Answer whether the receiver is strictly above context on the stack."	| s |	self == context ifTrue: [^false].	s := sender.	[s == nil]		whileFalse: 			[s == context ifTrue: [^true].			s := s sender].	^false! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'jm 5/20/1998 15:53'!allInstances 	"Answer a collection of all current instances of the receiver."	| all |	all := OrderedCollection new.	self allInstancesDo: [:x | x == all ifFalse: [all add: x]].	^ all asArray! !!Class methodsFor: 'initialize-release' stamp: 'sd 3/28/2003 16:09'!sharing: poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| oldPools found |	oldPools := self sharedPools.	sharedPools := OrderedCollection new.	(Scanner new scanFieldNames: poolString) do: 		[:poolName | 		sharedPools add: (self environment at: poolName asSymbol ifAbsent:[			(self confirm: 'The pool dictionary ', poolName,' does not exist.',						'\Do you want it automatically created?' withCRs)				ifTrue:[self environment at: poolName asSymbol put: Dictionary new]				ifFalse:[^self error: poolName,' does not exist']])].	sharedPools isEmpty ifTrue: [sharedPools := nil].	oldPools do: [:pool | found := false.				self sharedPools do: [:p | p == pool ifTrue: [found := true]].				found ifFalse: [^ true "A pool got deleted"]].	^ false! !!MethodDictionary methodsFor: 'enumeration' stamp: ''!keysDo: aBlock 	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key := self basicAt: i) == nil			ifFalse: [aBlock value: key]]! !!Class methodsFor: 'organization' stamp: 'di 12/23/1999 11:42'!environment: anEnvironment	environment := anEnvironment! !!Process methodsFor: 'printing' stamp: 'ajh 10/2/2001 14:36'!longPrintOn: stream	| ctxt |	super printOn: stream.	stream cr.	ctxt := self suspendedContext.	[ctxt == nil] whileFalse: [		stream space.		ctxt printOn: stream.		stream cr.		ctxt := ctxt sender.	].! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 15:15'!saveResumptionTimes	"Private!! Record the resumption times of all Delays relative to a base time of zero. This is done prior to snapshotting or adjusting the resumption times after a clock roll-over. This method should be called only while the AccessProtect semaphore is held."	| oldBaseTime |	oldBaseTime := Time millisecondClockValue.	ActiveDelay == nil		ifFalse: [			oldBaseTime < ActiveDelayStartTime				ifTrue: [oldBaseTime := ActiveDelayStartTime].  "clock rolled over"			ActiveDelay adjustResumptionTimeOldBase: oldBaseTime newBase: 0].	SuspendedDelays do:		[:d | d adjustResumptionTimeOldBase: oldBaseTime newBase: 0].! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:37'!roll: diceString	"Roll some dice, DnD-style, according to this mini-grammar:		dice := epxr {pm expr}		pm := '+' | '-'		expr := num | num dD | dD numP | num dD numP		dD := 'd' | 'D'		num := digit+		numP := num | '%'"	| stream op result dice range res token |	stream := diceString readStream.	result := 0.	op := #+.	[token := self diceToken: stream.	token isNumber		ifTrue: [dice := token.				token := self diceToken: stream]		ifFalse: [token == $d			ifTrue: [dice := 1]			ifFalse: [res := 0]].	token == $d		ifTrue: [token := self diceToken: stream.				token isNumber					ifTrue: [range := token.							token := self diceToken: stream]					ifFalse: [token == $%						ifTrue: [range := 100.								token := self diceToken: stream]						ifFalse: [range := 6]].				res := 0.				dice timesRepeat: [res := res + (self nextInt: range)]].	result := result perform: op with: res.	token ifNil: [^ result].	(token == $+ or: [token == $-])		ifFalse: [self error: 'unknown token ' , token].	op := token asSymbol] repeat! !!Categorizer methodsFor: 'accessing' stamp: 'hmm 2/25/2005 10:53'!changeFromCategorySpecs: categorySpecs 	"Tokens is an array of categorySpecs as scanned from a browser 'reorganize' pane, or built up by some other process, such as a scan of an environment."	| oldElements newElements newCategories newStops currentStop temp ii cc catSpec |	oldElements := elementArray asSet.	newCategories := Array new: categorySpecs size.	newStops := Array new: categorySpecs size.	currentStop := 0.	newElements := WriteStream on: (Array new: 16).	1 to: categorySpecs size do: 		[:i | | selectors |		catSpec := categorySpecs at: i.		newCategories at: i put: catSpec first asSymbol.		selectors := catSpec allButFirst collect: [:each | each isSymbol							ifTrue: [each]							ifFalse: [each printString asSymbol]].		selectors asSortedCollection do:			[:elem |			(oldElements remove: elem ifAbsent: [nil]) notNil ifTrue:				[newElements nextPut: elem.				currentStop := currentStop+1]].		newStops at: i put: currentStop].	"Ignore extra elements but don't lose any existing elements!!"	oldElements := oldElements collect:		[:elem | Array with: (self categoryOfElement: elem) with: elem].	newElements := newElements contents.	categoryArray := newCategories.	(cc := categoryArray asSet) size = categoryArray size ifFalse: ["has duplicate element"		temp := categoryArray asOrderedCollection.		temp removeAll: categoryArray asSet asOrderedCollection.		temp do: [:dup | 			ii := categoryArray indexOf: dup.			[dup := (dup,' #2') asSymbol.  cc includes: dup] whileTrue.			cc add: dup.			categoryArray at: ii put: dup]].	categoryStops := newStops.	elementArray := newElements.	oldElements do: [:pair | self classify: pair last under: pair first].! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:47'!selectAndScroll	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle endBlock |	self select.	endBlock := self stopBlock.	lineHeight := paragraph textStyle lineGrid.	clippingRectangle := paragraph clippingRectangle.	deltaY := endBlock top - clippingRectangle top.	deltaY >= 0 		ifTrue: [deltaY := endBlock bottom - clippingRectangle bottom max: 0].						"check if stopIndex below bottom of clippingRectangle"	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 7/20/2009 00:12'!valueAt: blockPriority 	"Evaluate the receiver (block), with another priority as the actual one 	and restore it afterwards. The caller should be careful with using 	higher priorities."	| activeProcess result outsidePriority |	activeProcess := Processor activeProcess.	outsidePriority := activeProcess priority.	activeProcess priority: blockPriority.	result := self ensure: [activeProcess priority: outsidePriority].	"Yield after restoring lower priority to give the preempted processes a  	chance to run."	blockPriority > outsidePriority		ifTrue: [Processor yield].	^ result! !!Integer methodsFor: 'benchmarks' stamp: 'jm 11/20/1998 07:06'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t |	  t := Time millisecondsToRun: [r := 26 benchFib].	  (r * 1000) // t"	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !!Class methodsFor: 'subclass creation' stamp: 'al 7/19/2004 11:18'!variableByteSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."		| newClass copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		variableByteSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass! !!Process methodsFor: 'debugging' stamp: 'ajh 7/20/2003 23:55'!debugWithTitle: title	"Open debugger on self"	| context |	context := self isActiveProcess ifTrue: [thisContext] ifFalse: [self suspendedContext].	self debug: context title: title full: true.! !!CompiledMethod methodsFor: 'scanning' stamp: ''!sendsToSuper	"Answer whether the receiver sends any message to super."	| scanner |	scanner := InstructionStream on: self.	^ scanner scanFor: 		[:instr |  instr = 16r85 or: [instr = 16r84						and: [scanner followingByte between: 16r20 and: 16r3F]]]! !!Object methodsFor: 'user interface' stamp: 'sw 6/12/2001 11:09'!launchPartVia: aSelector	"Obtain a morph by sending aSelector to self, and attach it to the morphic hand.  This provides a general protocol for parts bins"	| aMorph |	aMorph := self perform: aSelector.	aMorph setProperty: #beFullyVisibleAfterDrop toValue: true.	aMorph openInHand! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:39'!receiver: anObject	receiver := anObject! !!MethodFinder methodsFor: 'initialize' stamp: 'md 2/22/2006 21:21'!noteDangerous	"Remember the methods with really bad side effects."	Dangerous := Set new."Object accessing, testing, copying, dependent access, macpal, flagging"	#(addInstanceVarNamed:withValue: haltIfNil copyAddedStateFrom: veryDeepCopy veryDeepCopyWith: veryDeepFixupWith: veryDeepInner: addDependent: evaluate:wheneverChangeIn: codeStrippedOut: playSoundNamed: isThisEverCalled isThisEverCalled: logEntry logExecution logExit)		do: [:sel | Dangerous add: sel]."Object error handling"	#(cannotInterpret: caseError confirm: confirm:orCancel: doesNotUnderstand: error: halt halt: notify: notify:at: primitiveFailed shouldNotImplement subclassResponsibility)		do: [:sel | Dangerous add: sel]."Object user interface"	#(basicInspect beep inform: inspect inspectWithLabel: notYetImplemented inspectElement )		do: [:sel | Dangerous add: sel]."Object system primitives"	#(become: becomeForward: instVarAt:put: instVarNamed:put: nextInstance nextObject rootStubInImageSegment: someObject tryPrimitive:withArgs:)		do: [:sel | Dangerous add: sel]."Object private"	#(errorImproperStore errorNonIntegerIndex errorNotIndexable errorSubscriptBounds: mustBeBoolean primitiveError: species storeAt:inTempFrame:)		do: [:sel | Dangerous add: sel]."Object, translation support"	#(cCode: cCode:inSmalltalk: cCoerce:to: export: inline: returnTypeC: sharedCodeNamed:inCase: var:declareC:)		do: [:sel | Dangerous add: sel]."Object, objects from disk, finalization.  And UndefinedObject"	#(comeFullyUpOnReload: objectForDataStream: readDataFrom:size: rehash saveOnFile storeDataOn: actAsExecutor executor finalize retryWithGC:until:   suspend)		do: [:sel | Dangerous add: sel]."No Restrictions:   Boolean, False, True, ""Morph"	#()		do: [:sel | Dangerous add: sel]."Behavior"	#(obsolete confirmRemovalOf: copyOfMethodDictionary literalScannedAs:notifying: storeLiteral:on: addSubclass: removeSubclass: superclass: "creating method dictionary" addSelector:withMethod: compile: compile:notifying: compileAll compileAllFrom: compress decompile: defaultSelectorForMethod: methodDictionary: recompile:from: recompileChanges removeSelector: compressedSourceCodeAt: selectorAtMethod:setClass: allInstances allSubInstances inspectAllInstances inspectSubInstances thoroughWhichSelectorsReferTo:special:byte: "enumerating" allInstancesDo: allSubInstancesDo: allSubclassesDo: allSuperclassesDo: selectSubclasses: selectSuperclasses: subclassesDo: withAllSubclassesDo:   "too slow->" crossReference removeUninstantiatedSubclassesSilently "too slow->" unreferencedInstanceVariables"private" becomeCompact becomeUncompact flushCache format:variable:words:pointers: format:variable:words:pointers:weak: printSubclassesOn:level: basicRemoveSelector: addSelector:withMethod:notifying: addSelectorSilently:withMethod:)		do: [:sel | Dangerous add: sel]."CompiledMethod"	#(defaultSelector)		do: [:sel | Dangerous add: sel]."Others "	#("no tangible result" do: associationsDo:  "private" adaptToCollection:andSend: adaptToNumber:andSend: adaptToPoint:andSend: adaptToString:andSend: instVarAt:put: asDigitsToPower:do: combinations:atATimeDo: doWithIndex: pairsDo: permutationsDo: reverseDo: reverseWith:do: with:do: withIndexDo: asDigitsAt:in:do: combinationsAt:in:after:do: errorOutOfBounds permutationsStartingAt:do: fromUser)		do: [:sel | Dangerous add: sel].	#(    fileOutPrototype addSpareFields makeFileOutFile )		do: [:sel | Dangerous add: sel].	#(recompile:from: recompileAllFrom: recompileChanges asPrototypeWithFields: asPrototype addInstanceVarNamed:withValue: addInstanceVariable addClassVarName: removeClassVarName: findOrAddClassVarName: instanceVariableNames: )		do: [:sel | Dangerous add: sel]. ! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'md 7/14/2006 21:21'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits method |	nTemps > 63 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		nLits > 255 ifTrue:		[^ self error: 'Cannot compile -- too many literals variables'].		largeBit := (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits := primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high bit of primitive no. is in the 29th bit of header"				primitiveIndex > 16r3FF ifTrue: [self error: 'prim num too large'].				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r200) bitShift: 19)].	method := self newMethod: numberOfBytes + trailer size		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits.	1 to: trailer size do:  "Copy the source code trailer to the end"		[:i | method at: method size - trailer size + i put: (trailer at: i)].	^ method! !!Random methodsFor: 'initialization' stamp: 'sma 5/12/2000 12:29'!seed: anInteger 	seed := anInteger! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'AB 1/7/2002 04:03'!blinkPrevParen	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph text string.	here := startBlock stringIndex.	openDelimiter := sensor keyboardPeek.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 2]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]].! !!Semaphore methodsFor: 'initialize-release' stamp: 'jf 12/2/2003 18:53'!resumeProcess: aProcess	"Remove the given process from the list of waiting processes (if it's there) and resume it.  This is used when a process asked for its wait to be timed out."	| process |	process := self remove: aProcess ifAbsent: [nil].	process ifNotNil: [process resume].! !!ContextPart methodsFor: 'system simulation' stamp: 'ajh 4/15/2003 10:01'!runSimulated: aBlock contextAtEachStep: block2	"Simulate the execution of the argument, aBlock, until it ends. aBlock 	MUST NOT contain an '^'. Evaluate block2 with the current context 	prior to each instruction executed. Answer the simulated value of aBlock."	| current |	(aBlock isBlock and: [aBlock hasMethodReturn])		ifTrue: [self error: 'simulation of blocks with ^ can run loose'].	current := aBlock asContext.	current privSender: self.	[current == self]		whileFalse:			[block2 value: current.			current := current step].	^ self pop! !!ParagraphEditor class methodsFor: 'instance creation' stamp: ''!newParagraph: aParagraph 	"Answer an instance of me with aParagraph as the text to be edited."	| aParagraphEditor |	aParagraphEditor := super new.	aParagraphEditor initialize.	aParagraphEditor changeParagraph: aParagraph.	^aParagraphEditor! !!Categorizer methodsFor: 'private' stamp: 'NS 4/5/2004 17:50'!setDefaultList: aSortedCollection	categoryArray := Array with: Default.	categoryStops := Array with: aSortedCollection size.	elementArray := aSortedCollection asArray! !!Object class methodsFor: 'class initialization' stamp: 'ar 2/11/2001 01:45'!reInitializeDependentsFields	"Object reInitializeDependentsFields"	| oldFields |	oldFields := DependentsFields.	DependentsFields := WeakIdentityKeyDictionary new.	oldFields keysAndValuesDo:[:obj :deps|		deps do:[:d| obj addDependent: d]].! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:14'!privateCleanup	queuesMutex critical: [		defaultQueue isEmpty ifTrue: [defaultQueue := nil].		queueDict ifNotNil: [			queueDict copy keysAndValuesDo: [:id :queue | 				queue isEmpty ifTrue: [queueDict removeKey: id]].			queueDict isEmpty ifTrue: [queueDict := nil].		].	].! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitAnd: n 	"Answer an Integer whose bits are the logical AND of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitAnd' module:'LargeIntegers'>	norm := n normalize.	^ self		digitLogic: norm		op: #bitAnd:		length: (self digitLength max: norm digitLength)! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'apb 7/12/2004 23:22'!removeObsoleteSubclass: aClass	"Remove aClass from the weakly remembered obsolete subclasses"	| obs |	obs := ObsoleteSubclasses at: self ifAbsent:[^ self].	(obs includes: aClass) ifFalse:[^self].	obs := obs copyWithout: aClass.	obs := obs copyWithout: nil.	ObsoleteSubclasses at: self put: obs! !!BlockContext methodsFor: 'accessing' stamp: ''!hasMethodReturn	"Answer whether the receiver has a return ('^') in its code."	| method scanner end |	method := self method.	"Determine end of block from long jump preceding it"	end := (method at: startpc-2)\\16-4*256 + (method at: startpc-1) + startpc - 1.	scanner := InstructionStream new method: method pc: startpc.	scanner scanFor: [:byte | (byte between: 120 and: 124) or: [scanner pc > end]].	^scanner pc <= end! !!CompiledMethod methodsFor: 'source code management' stamp: 'md 6/2/2006 10:34'!linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	| strm line lines |	lines := 0.	strm := ReadStream on: self getSource.		[strm atEnd] whileFalse:			[line := strm upTo: Character cr.			line isEmpty ifFalse: [lines := lines+1]].	^lines ! !!Float methodsFor: 'printing' stamp: ''!hex  "If ya really want to know..."	| word nibble |	^ String streamContents:		[:strm |		1 to: 2 do:			[:i | word := self at: i.			1 to: 8 do: 				[:s | nibble := (word bitShift: -8+s*4) bitAnd: 16rF.				strm nextPut: ('0123456789ABCDEF' at: nibble+1)]]]"(-2.0 to: 2.0) collect: [:f | f hex]"! !!Process methodsFor: 'changing process state' stamp: 'ajh 7/20/2003 22:47'!suspend	"Stop the process that the receiver represents in such a way 	that it can be restarted at a later time (by sending the receiver the 	message resume). If the receiver represents the activeProcess, suspend it. 	Otherwise remove the receiver from the list of waiting processes."	self isActiveProcess ifTrue: [		myList := nil.		self primitiveSuspend.	] ifFalse: [		myList ifNotNil: [			myList remove: self ifAbsent: [].			myList := nil].	]! !!MessageSend methodsFor: 'accessing' stamp: 'sma 2/29/2000 20:40'!arguments: anArray	arguments := anArray! !!Object methodsFor: 'user interface' stamp: 'sw 8/15/97 17:25'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	| adj |	adj := (3 * Preferences scrollBarWidth) @ 0.	^ Rectangle origin: adj extent: (DisplayScreen actualScreenSize - adj)! !!Object methodsFor: 'printing' stamp: 'tk 10/16/2001 19:41'!longPrintString	"Answer a String whose characters are a description of the receiver."		| str |	str := String streamContents: [:aStream | self longPrintOn: aStream].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!Object methodsFor: 'testing' stamp: 'tk 9/6/2001 19:15'!openInstanceBrowserWithTiles	"Open up an instance browser on me with tiles as the code type, and with the search level as desired."	| aBrowser |	aBrowser := InstanceBrowser new.	aBrowser useVocabulary: Vocabulary fullVocabulary.	aBrowser limitClass: self class.	aBrowser contentsSymbol: #tiles.		"preset it to make extra buttons (tile menus)"	aBrowser openOnObject: self inWorld: ActiveWorld showingSelector: nil.	aBrowser contentsSymbol: #source.	aBrowser toggleShowingTiles.	"(2@3) openInstanceBrowserWithTiles.WatchMorph new openInstanceBrowserWithTiles"! !!Complex methodsFor: 'mathematical functions' stamp: 'md 7/16/2004 16:16'!sin	"Answer receiver's sine."	| iself |	iself := 1 i * self.	^ (iself exp - iself negated exp) / 2 i! !!Metaclass methodsFor: 'accessing' stamp: 'al 3/25/2006 12:38'!traitComposition: aTraitComposition	traitComposition := aTraitComposition! !!Delay methodsFor: 'private' stamp: 'laza 2/12/2005 11:45'!setDelay: milliseconds forSemaphore: aSemaphore	"Private!! Initialize this delay to signal the given semaphore after the given number of milliseconds."	delayDuration := milliseconds asInteger.	delayDuration < 0 ifTrue: [self error: 'delay times cannot be negative'].	delayDuration > (SmallInteger maxVal // 2)		ifTrue: [self error: 'delay times can''t be longer than about six days (', (SmallInteger maxVal // 2) printString , 'ms)'].	delaySemaphore := aSemaphore.	beingWaitedOn := false.! !!Object methodsFor: 'copying' stamp: ''!deepCopy	"Answer a copy of the receiver with its own copy of each instance 	variable."	| newObject class index |	class := self class.	(class == Object) ifTrue: [^self].	class isVariable		ifTrue: 			[index := self basicSize.			newObject := class basicNew: index.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) deepCopy.					index := index - 1]]		ifFalse: [newObject := class basicNew].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) deepCopy.			index := index - 1].	^newObject! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 9/19/2004 10:52'!printStringBase: base	| stream integer next |	self = 0 ifTrue: [^'0'].	self negative ifTrue: [^'-', (self negated printStringBase: base)].	stream := WriteStream on: String new.	integer := self normalize.	[integer > 0] whileTrue: [		next := integer quo: base.		stream nextPut: (Character digitValue: integer - (next * base)).		integer := next].	^stream contents reversed! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 7/21/2003 09:45'!holdsTempNames	"Are tempNames stored in trailer bytes"	| flagByte |	flagByte := self last.	(flagByte = 0 or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue: [^ false].  "No source pointer & no temp names"	flagByte < 252 ifTrue: [^ true].  "temp names compressed"	^ false	"Source pointer"! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:48'!validateClassvars: classVarArray from: oldClass forSuper: newSuper	"Check if any of the classVars of oldClass conflict with the new superclass"	| usedNames classVars temp |	classVarArray isEmpty ifTrue:[^true]. "Okay"	"Validate the class var names"	usedNames := classVarArray asSet.	usedNames size = classVarArray size 		ifFalse:[	classVarArray do:[:var|					usedNames remove: var ifAbsent:[temp := var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp := var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames := newSuper allClassVarNames asSet.		classVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl classVarNames includes: iv) ifTrue:[temp := cl]].				self error: iv, ' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames := Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl classVarNames].		classVars := classVarArray.		newSuper == nil ifFalse:[classVars := classVars, newSuper allClassVarNames asArray].		classVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!MethodDictionary methodsFor: 'private' stamp: ''!removeDangerouslyKey: key ifAbsent: aBlock	"This is not really dangerous.  But if normal removal	were done WHILE a MethodDict were being used, the	system might crash.  So instead we make a copy, then do	this operation (which is NOT dangerous in a copy that is	not being used), and then use the copy after the removal."	| index element |	index := self findElementOrNil: key.	(self basicAt: index) == nil ifTrue: [ ^ aBlock value ].	element := array at: index.	array at: index put: nil.	self basicAt: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^ element! !!ProcessorScheduler methodsFor: 'accessing' stamp: ''!highestPriority: newHighestPriority	"Change the number of priority levels currently available for use."	| continue newProcessLists |	(quiescentProcessLists size > newHighestPriority		and: [self anyProcessesAbove: newHighestPriority])			ifTrue: [self error: 'There are processes with priority higher than '													,newHighestPriority printString].	newProcessLists := Array new: newHighestPriority.	1 to: ((quiescentProcessLists size) min: (newProcessLists size)) do: 		[:priority | newProcessLists at: priority put: (quiescentProcessLists at: priority)].	quiescentProcessLists size to: newProcessLists size do: 		[:priority | newProcessLists at: priority put: LinkedList new].	quiescentProcessLists := newProcessLists! !!ObjectOut methodsFor: 'access' stamp: 'tk 1/15/1999 11:43'!url: aString	url := aString! !!Object methodsFor: 'scripts-kernel' stamp: 'nk 10/14/2004 10:55'!universalTilesForGetterOf: aMethodInterface	"Return universal tiles for a getter on the given method interface."	| ms argTile argArray itsSelector |	itsSelector := aMethodInterface selector.	argArray := #().	"Four gratuituous special cases..."	(itsSelector == #color:sees:) ifTrue:		[argTile := ScriptingSystem tileForArgType: #Color.		argArray := Array with: argTile colorSwatch color with: argTile colorSwatch color copy].	itsSelector == #seesColor: ifTrue:		[argTile := ScriptingSystem tileForArgType: #Color.		argArray :=  Array with: argTile colorSwatch color].	(#(touchesA: overlaps: overlapsAny:) includes: itsSelector) ifTrue:		[argTile := ScriptingSystem tileForArgType: #Player.		argArray := Array with: argTile actualObject].	ms := MessageSend receiver: self selector: itsSelector arguments: argArray.	^ ms asTilesIn: self class globalNames: (self class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'sw 1/5/2001 06:53'!allMethodCategoriesIntegratedThrough: mostGenericClass	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"	| aColl |	aColl := OrderedCollection new.	self withAllSuperclasses do:		[:aClass |			(aClass includesBehavior: mostGenericClass)				ifTrue:	[aColl addAll: aClass organization categories]].	aColl remove: 'no messages' asSymbol ifAbsent: [].	^ (aColl asSet asSortedCollection: [:a :b | a asLowercase < b asLowercase]) asArray"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !!Integer methodsFor: 'benchmarks' stamp: 'dwh 11/21/1999 16:40'!tinyBenchmarks	"Report the results of running the two tiny Squeak benchmarks.	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"	"0 tinyBenchmarks"	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"	"On a 400 MHz PII/Win98:  18028169 bytecodes/sec; 1081272 sends/sec"	| t1 t2 r n1 n2 |	n1 := 1.	[t1 := Time millisecondsToRun: [n1 benchmark].	t1 < 1000] whileTrue:[n1 := n1 * 2]. "Note: #benchmark's runtime is about O(n)"	n2 := 28.	[t2 := Time millisecondsToRun: [r := n2 benchFib].	t2 < 1000] whileTrue:[n2 := n2 + 1]. 	"Note: #benchFib's runtime is about O(k^n),		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."	^ ((n1 * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',	  ((r * 1000) // t2) printString, ' sends/sec'! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 7/18/2003 22:13'!stepToHome: aContext 	"Resume self until the home of top context is aContext.  Top context may be a block context."	| home ctxt |	home := aContext home.	[	ctxt := self step.		home == ctxt home.	] whileFalse: [		home isDead ifTrue: [^ self suspendedContext].	].	^ self suspendedContext! !!MethodDictionary methodsFor: 'removing' stamp: ''!removeKey: key ifAbsent: errorBlock 	"The interpreter might be using this MethodDict while	this method is running!!  Therefore we perform the removal	in a copy, and then atomically become that copy"	| copy |	copy := self copy.	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock value].	self become: copy! !!ParagraphEditor methodsFor: 'do-its' stamp: 'sd 4/16/2003 11:41'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "	| result |	self terminateAndInitializeAround: [	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [view flash]		ifFalse: [self systemNavigation					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]].	]! !!ParagraphEditor methodsFor: 'initialize-release' stamp: ''!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	UndoParagraph == paragraph ifTrue: [UndoParagraph := nil].	paragraph := aParagraph.	self resetState! !!Class methodsFor: 'accessing class hierarchy' stamp: 'tk 10/17/1999 13:31'!addSubclass: aSubclass 	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."		aSubclass superclass ~~ self 		ifTrue: [^self error: aSubclass name , ' is not my subclass'].	subclasses == nil		ifTrue:	[subclasses := Array with: aSubclass.				^self].	subclasses do:[:cl| cl == aSubclass ifTrue:[^self]]. "Already my subclass"	subclasses := subclasses copyWith: aSubclass.! !!ClassOrganizer methodsFor: 'private' stamp: 'NS 4/12/2004 20:56'!notifyOfChangedSelectorsOldDict: oldDictionaryOrNil newDict: newDictionaryOrNil	| newCat |	(oldDictionaryOrNil isNil and: [newDictionaryOrNil isNil])		ifTrue: [^ self].			oldDictionaryOrNil isNil ifTrue: [	newDictionaryOrNil keysAndValuesDo: [:el :cat |		self notifyOfChangedSelector: el from: nil to: cat].		^ self.	].	newDictionaryOrNil isNil ifTrue: [	oldDictionaryOrNil keysAndValuesDo: [:el :cat |		self notifyOfChangedSelector: el from: cat to: nil].		^ self.	].			oldDictionaryOrNil keysAndValuesDo: [:el :cat |		newCat := newDictionaryOrNil at: el.		self notifyOfChangedSelector: el from: cat to: newCat.	].! !!CompiledMethod methodsFor: 'printing' stamp: ''!storeOn: aStream	| noneYet |	aStream nextPutAll: '(('.	aStream nextPutAll: self class name.	aStream nextPutAll: ' newMethod: '.	aStream store: self size - self initialPC + 1.	aStream nextPutAll: ' header: '.	aStream store: self header.	aStream nextPut: $).	noneYet := self storeElementsFrom: self initialPC to: self endPC on: aStream.	1 to: self numLiterals do:		[:index |		noneYet			ifTrue: [noneYet := false]			ifFalse: [aStream nextPut: $;].		aStream nextPutAll: ' literalAt: '.		aStream store: index.		aStream nextPutAll: ' put: '.		aStream store: (self literalAt: index)].	noneYet ifFalse: [aStream nextPutAll: '; yourself'].	aStream nextPut: $)! !!Class methodsFor: 'accessing' stamp: 'al 3/25/2006 13:16'!basicLocalSelectors: aSetOrNil	localSelectors := aSetOrNil! !!Class methodsFor: 'subclass creation' stamp: 'al 7/19/2004 11:18'!variableWordSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."		| newClass copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		variableWordSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass	! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!classComment: aString  stamp: aStamp	"Store the comment, aString, associated with the object that refers to the receiver."	self commentStamp: aStamp.	(aString isKindOf: RemoteString) 		ifTrue: [classComment := aString]		ifFalse: [(aString == nil or: [aString size = 0])			ifTrue: [classComment := nil]			ifFalse:				[self error: 'use aClass classComment:'.				classComment := RemoteString newString: aString onFileNumber: 2]]				"Later add priorSource and date and initials?"! !!EventSensor class methodsFor: 'class initialization' stamp: 'nk 4/12/2004 18:55'!eventPollPeriod	^EventPollPeriod ifNil: [ EventPollPeriod := 500 ].! !!Class methodsFor: 'compiling' stamp: 'sd 3/28/2003 15:24'!possibleVariablesFor: misspelled continuedFrom: oldResults	| results |	results := misspelled correctAgainstDictionary: self classPool continuedFrom: oldResults.	self sharedPools do: [:pool | 		results := misspelled correctAgainstDictionary: pool continuedFrom: results ].	superclass == nil		ifTrue: 			[ ^ misspelled correctAgainstDictionary: self environment continuedFrom: results ]		ifFalse:			[ ^ superclass possibleVariablesFor: misspelled continuedFrom: results ]! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 1/24/2003 00:56'!terminate	"Make myself unresumable."	sender := nil.	pc := nil.! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 20:23'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents |	dependents := self dependents reject: [:each | each == anObject].	self myDependents: (dependents isEmpty ifFalse: [dependents]).	^ anObject! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 7/20/2009 00:14'!valueSuppressingMessages: aListOfStrings supplyingAnswers: aListOfPairs	^ self valueSupplyingAnswers: aListOfPairs, (aListOfStrings collect: [:each | {each. true}])! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 5/20/2004 17:20'!runUntilErrorOrReturnFrom: aSender 	"ASSUMES aSender is a sender of self.  Execute self's stack until aSender returns or an unhandled exception is raised.  Return a pair containing the new top context and a possibly nil exception.  The exception is not nil if it was raised before aSender returned and it was not handled.  The exception is returned rather than openning the debugger, giving the caller the choice of how to handle it."	"Self is run by jumping directly to it (the active process abandons thisContext and executes self).  However, before jumping to self we insert an ensure block under aSender that jumps back to thisContext when evaluated.  We also insert an exception handler under aSender that jumps back to thisContext when an unhandled exception is raised.  In either case, the inserted ensure and exception handler are removed once control jumps back to thisContext."	| error ctxt here topContext |	here := thisContext.	"Insert ensure and exception handler contexts under aSender"	error := nil.	ctxt := aSender insertSender: (ContextPart		contextOn: UnhandledError do: [:ex |			error ifNil: [				error := ex exception.				topContext := thisContext.				ex resumeUnchecked: here jump]			ifNotNil: [ex pass]		]).	ctxt := ctxt insertSender: (ContextPart		contextEnsure: [error ifNil: [				topContext := thisContext.				here jump]		]).	self jump.  "Control jumps to self"	"Control resumes here once above ensure block or exception handler is executed"	^ error ifNil: [		"No error was raised, remove ensure context by stepping until popped"		[ctxt isDead] whileFalse: [topContext := topContext stepToCallee].		{topContext. nil}	] ifNotNil: [		"Error was raised, remove inserted above contexts then return signaler context"		aSender terminateTo: ctxt sender.  "remove above ensure and handler contexts"		{topContext. error}	].! !!ProcessorScheduler class methodsFor: 'class initialization' stamp: 'ar 7/8/2001 16:39'!initialize     	SystemRockBottomPriority := 10.	SystemBackgroundPriority := 20.	UserBackgroundPriority := 30.	UserSchedulingPriority := 40.	UserInterruptPriority := 50.	LowIOPriority := 60.	HighIOPriority := 70.	TimingPriority := 80.	"ProcessorScheduler initialize."! !!CompiledMethod methodsFor: 'accessing' stamp: ''!returnField	"Answer the index of the instance variable returned by a quick return 	method."	| prim |	prim := self primitive.	prim < 264		ifTrue: [self error: 'only meaningful for quick-return']		ifFalse: [^ prim - 264]! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:17'!stepToSendOrReturn	^ suspendedContext := suspendedContext stepToSendOrReturn! !!ContextPart methodsFor: 'query' stamp: 'ajh 1/24/2003 00:12'!findContextSuchThat: testBlock	"Search self and my sender chain for first one that satisfies testBlock.  Return nil if none satisfy"	| ctxt |	ctxt := self.	[ctxt isNil] whileFalse: [		(testBlock value: ctxt) ifTrue: [^ ctxt].		ctxt := ctxt sender.	].	^ nil! !!ContextPart methodsFor: 'private' stamp: 'ajh 7/21/2003 09:59'!insertSender: aContext	"Insert aContext and its sender chain between me and my sender.  Return new callee of my original sender."	| ctxt |	ctxt := aContext bottomContext.	ctxt privSender: self sender.	self privSender: aContext.	^ ctxt! !!LargePositiveInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:09'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen |	<primitive: 'primNormalizePositive' module:'LargeIntegers'>	"First establish len = significant length"	len := oldLen := self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len := len - 1].	"Now check if in SmallInteger range"	sLen := SmallInteger maxVal digitLength.	(len <= sLen		and: [(self digitAt: sLen) <= (SmallInteger maxVal digitAt: sLen)])		ifTrue: ["If so, return its SmallInt value"				val := 0.				len to: 1 by: -1 do:					[:i | val := (val *256) + (self digitAt: i)].				^ val].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!Object methodsFor: 'viewer' stamp: 'md 1/17/2006 17:58'!uniqueNameForReferenceFrom: proposedName	"Answer a satisfactory symbol, similar to the proposedName but obeying the rules, to represent the receiver"	| aName nameSym stem okay |	proposedName = self uniqueNameForReferenceOrNil 		ifTrue: [^ proposedName].  "No change"	stem := proposedName select: [:ch | ch isLetter or: [ch isDigit]].	stem size == 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	aName := Utilities keyLike: stem satisfying:		[:jinaLake |			nameSym := jinaLake asSymbol.			okay := true.			(self class bindingOf: nameSym) ifNotNil: [okay := false "don't use it"].			okay].	^ aName asSymbol! !!EventSensor methodsFor: 'private-I/O' stamp: 'ar 8/16/2000 22:06'!primGetNextEvent: array	"Store the next OS event available into the provided array.	Essential. If the VM is not event driven the ST code will fall	back to the old-style mechanism and use the state based	primitives instead."	| kbd buttons modifiers pos mapped |	<primitive: 94>	"Simulate the events"	array at: 1 put: EventTypeNone. "assume no more events"	"First check for keyboard"	kbd := super primKbdNext.	kbd = nil ifFalse:[		"simulate keyboard event"		array at: 1 put: EventTypeKeyboard. "evt type"		array at: 2 put: Time millisecondClockValue. "time stamp"		array at: 3 put: (kbd bitAnd: 255). "char code"		array at: 4 put: EventKeyChar. "key press/release"		array at: 5 put: (kbd bitShift: -8). "modifier keys"		^self].	"Then check for mouse"	buttons := super primMouseButtons.	pos := super primMousePt.	modifiers := buttons bitShift: -3.	buttons := buttons bitAnd: 7.	mapped := self mapButtons: buttons modifiers: modifiers.	(pos = mousePosition and:[(mapped bitOr: (modifiers bitShift: 3)) = mouseButtons])		ifTrue:[^self].	array 		at: 1 put: EventTypeMouse;		at: 2 put: Time millisecondClockValue;		at: 3 put: pos x;		at: 4 put: pos y;		at: 5 put: mapped;		at: 6 put: modifiers.! !!InputSensor methodsFor: 'keyboard' stamp: 'yo 8/18/2003 23:36'!keyboard	"Answer the next character from the keyboard."	| firstCharacter secondCharactor stream multiCharacter converter |	firstCharacter := self characterForKeycode: self primKbdNext.	secondCharactor := self characterForKeycode: self primKbdPeek.	secondCharactor isNil		ifTrue: [^ firstCharacter].	converter := TextConverter defaultSystemConverter.	converter isNil		ifTrue: [^ firstCharacter].	stream := ReadStream				on: (String with: firstCharacter with: secondCharactor).	multiCharacter := converter nextFromStream: stream.	multiCharacter isOctetCharacter		ifTrue: [^ multiCharacter].	self primKbdNext.	^ multiCharacter! !!Float methodsFor: 'mathematical functions' stamp: ''!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta := (self * Halfpi) / (self + 1.0).	"iterate"	eps := Halfpi * Epsilon.	step := theta.	[(step * step) > eps] whileTrue: [		sinTheta := theta sin.		cosTheta := theta cos.		step := (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta := theta - step].	^ theta! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'md 2/20/2006 15:13'!printMethodChunkHistorically: selector on: outStream moveSource: moveSource toFile: fileIndex	"Copy all source codes historically for the method associated with selector onto the 	fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method newPos sourceFile endPos category changeList prior |	category := self organization categoryOfElement: selector.	preamble := self name , ' methodsFor: ', category asString printString.	method := self methodDict at: selector.	((method fileIndex = 0	or: [(SourceFiles at: method fileIndex) == nil])	or: [method filePosition = 0])	ifTrue: [		outStream cr; nextPut: $!!; nextChunkPut: preamble; cr.		outStream nextChunkPut: method decompileString.		outStream nextChunkPut: ' '; cr]	ifFalse: [		changeList := ChangeSet 			scanVersionsOf: method 			class: self 			meta: self isMeta			category: category 			selector: selector.		newPos := nil.		sourceFile := SourceFiles at: method fileIndex.		changeList reverseDo: [ :chgRec |			chgRec fileIndex = fileIndex ifTrue: [				outStream copyPreamble: preamble from: sourceFile at: chgRec position.				(prior := chgRec prior) ifNotNil: [					outStream position: outStream position - 2.					outStream nextPutAll: ' prior: ', (						prior first = method fileIndex ifFalse: [prior third] ifTrue: [							SourceFiles 								sourcePointerFromFileIndex: method fileIndex 								andPosition: newPos]) printString.					outStream nextPut: $!!; cr].				"Copy the method chunk"				newPos := outStream position.				outStream copyMethodChunkFrom: sourceFile at: chgRec position.				sourceFile skipSeparators.      "The following chunk may have ]style["				sourceFile peek == $] ifTrue: [					outStream cr; copyMethodChunkFrom: sourceFile].				outStream nextChunkPut: ' '; cr]].		moveSource ifTrue: [			endPos := outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	^ outStream! !!BlockContext methodsFor: 'instruction decoding' stamp: 'ajh 1/24/2003 16:35'!blockReturnTop	"Simulate the interpreter's action when a ReturnTopOfStack bytecode is 	encountered in the receiver."	| save dest |	save := home.	"Needed because return code will nil it"	dest := self return: self pop from: self.	home := save.	sender := nil.	^ dest! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 10/21/2003 15:46'!backWord: characterStream 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	sensor keyboard.	characterStream isEmpty		ifTrue:			[self hasCaret				ifTrue: "a caret, delete at least one character"					[startIndex := 1 max: self markIndex - 1.					[startIndex > 1 and:						[(paragraph text at: startIndex - 1) asCharacter tokenish]]						whileTrue:							[startIndex := startIndex - 1]]				ifFalse: "a non-caret, just delete it"					[startIndex := self markIndex].			self backTo: startIndex]		ifFalse:			[characterStream reset].	^false! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'tk 9/28/2000 15:44'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a reference to a class in Smalltalk instead."	(refStrm insideASegment and: [self isSystemDefined not]) ifTrue: [		^ self].	"do trace me"	dp := DiskProxy global: self theNonMetaClass name selector: #class			args: (Array new).	refStrm replace: self with: dp.	^ dp! !!InstructionStream class methodsFor: 'class initialization' stamp: ''!initialize	"Initialize an array of special constants returned by single-bytecode returns."	SpecialConstants := 		(Array with: true with: false with: nil)			, (Array with: -1 with: 0 with: 1 with: 2)		"InstructionStream initialize."! !!MethodFinder methodsFor: 'initialize' stamp: 'md 11/14/2003 16:47'!copy: mthFinder addArg: aConstant	| more |	"Copy inputs and answers, add an additional data argument to the inputs.  The same constant for every example"	more := Array with: aConstant.	data := mthFinder data collect: [:argList | argList, more].	answers := mthFinder answers.	self load: nil.! !!ClassBuilder methodsFor: 'class definition' stamp: 'NS 1/21/2004 09:21'!silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName	"Move the instvar from srcClass to dstClass.	Do not perform any checks."	| srcVars dstVars dstIndex newClass copyOfSrcClass copyOfDstClass |	copyOfSrcClass := srcClass copy.	copyOfDstClass := dstClass copy.		srcVars := srcClass instVarNames copyWithout: instVarName.	srcClass == dstClass		ifTrue:[dstVars := srcVars]		ifFalse:[dstVars := dstClass instVarNames].	dstIndex := dstVars indexOf: prevInstVarName.	dstVars := (dstVars copyFrom: 1 to: dstIndex),				(Array with: instVarName),				(dstVars copyFrom: dstIndex+1 to: dstVars size).	instVarMap at: srcClass name put: srcVars.	instVarMap at: dstClass name put: dstVars.	(srcClass inheritsFrom: dstClass) ifTrue:[		newClass := self reshapeClass: dstClass toSuper: dstClass superclass.		self recompile: false from: dstClass to: newClass mutate: true.	] ifFalse:[		(dstClass inheritsFrom: srcClass) ifTrue:[			newClass := self reshapeClass: srcClass toSuper: srcClass superclass.			self recompile: false from: srcClass to: newClass mutate: true.		] ifFalse:[ "Disjunct hierarchies"			srcClass == dstClass ifFalse:[				newClass := self reshapeClass: dstClass toSuper: dstClass superclass.				self recompile: false from: dstClass to: newClass mutate: true.			].			newClass := self reshapeClass: srcClass toSuper: srcClass superclass.			self recompile: false from: srcClass to: newClass mutate: true.		].	].	self doneCompiling: srcClass.	self doneCompiling: dstClass.	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfSrcClass to: srcClass.	SystemChangeNotifier uniqueInstance classDefinitionChangedFrom: copyOfDstClass to: dstClass.! !!Message methodsFor: 'private' stamp: ''!setSelector: aSymbol arguments: anArray	selector := aSymbol.	args := anArray! !!Object methodsFor: 'events' stamp: 'nk 8/27/2003 17:45'!renameActionsWithReceiver: anObject forEvent: anEventSelector toEvent: newEvent	| oldActions newActions |	oldActions := Set new.	newActions := Set new.	(self actionSequenceForEvent: anEventSelector) do: [ :action |		action receiver == anObject			ifTrue: [ oldActions add: anObject ]			ifFalse: [ newActions add: anObject ]].	self setActionSequence: (ActionSequence withAll: newActions) forEvent: anEventSelector.	oldActions do: [ :act | self when: newEvent evaluate: act ].! !!InstVarRefLocator methodsFor: 'instruction decoding' stamp: 'RAA 1/5/2001 08:46'!popIntoReceiverVariable: offset 	bingo := true! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 16:51'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string := paragraph text string.	here := self pointIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters := '([{<''"'.	rightDelimiters := ')]}>''"'.	openDelimiter := string at: here - 1.	match := leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start := here.			direction := 1.			here := here - 1.			closeDelimiter := rightDelimiters at: match]		ifFalse: 			[openDelimiter := string at: here.			match := rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop := here - 1.					direction := -1.					closeDelimiter := leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction := -1]].	level := 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar := string at: (here := here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start := 1.									"go right if hit string start"									direction := 1]]						ifFalse: [direction < 0								ifTrue: 									[start := here + 1.									"go right if hit non-token"									direction := 1]								ifFalse: [level := 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level := level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level := level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here := here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!InputSensor methodsFor: 'user interrupts' stamp: 'nk 6/21/2004 10:41'!installInterruptWatcher	"Initialize the interrupt watcher process. Terminate the old process if any."	"Sensor installInterruptWatcher"	InterruptWatcherProcess ifNotNil: [InterruptWatcherProcess terminate].	InterruptSemaphore := Semaphore new.	InterruptWatcherProcess := [self userInterruptWatcher] forkAt: Processor lowIOPriority.	self primInterruptSemaphore: InterruptSemaphore.! !!Message methodsFor: 'private' stamp: 'ajh 9/23/2001 04:59'!lookupClass: aClass	lookupClass := aClass! !!BlockContext methodsFor: 'private' stamp: 'ajh 1/27/2003 21:08'!privHome: context	home := context! !!ClassDescription methodsFor: 'private' stamp: 'al 11/28/2005 11:51'!instVarMappingFrom: oldClass	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."	| oldInstVarNames |	oldInstVarNames := oldClass allInstVarNames.	^self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 10/21/1998 13:01'!xxxSetUrl: aString page: aSqkPage	url := aString.	page := aSqkPage.! !!Class methodsFor: 'subclass creation' stamp: 'al 7/19/2004 11:17'!variableSubclass: t uses: aTraitCompositionOrArray instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."		| newClass copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		variableSubclass: t 		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.		newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass	! !!Process methodsFor: 'accessing' stamp: 'svp 12/5/2002 14:42'!name: aString	name := aString! !!ContextPart methodsFor: 'system simulation' stamp: 'hmm 7/30/2001 20:43'!completeCallee: aContext	"Simulate the execution of bytecodes until a return to the receiver."	| ctxt current ctxt1 |	ctxt := aContext.	[ctxt == current or: [ctxt hasSender: self]]		whileTrue: 			[current := ctxt.			ctxt1 := ctxt quickStep.			ctxt1 ifNil: [self halt].			ctxt := ctxt1].	^self stepToSendOrReturn! !!Complex class methodsFor: 'instance creation' stamp: 'mk 10/27/2003 21:03'!abs: aNumber1 arg: aNumber2	| real imaginary |	real := aNumber1 * aNumber2 cos.	imaginary := aNumber1 * aNumber2 sin.	^ real + imaginary i! !!Object methodsFor: 'undo' stamp: 'di 9/11/2000 20:29'!commandHistory	"Return the command history for the receiver"	| w |	(w := self currentWorld) ifNotNil: [^ w commandHistory].	^ CommandHistory new. "won't really record anything but prevent breaking things"! !!MethodDictionary class methodsFor: 'instance creation' stamp: 'nice 4/4/2006 22:09'!new: nElements	"Create a Dictionary large enough to hold nElements without growing.	Note that the basic size must be a power of 2.	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"	| size |	size := 1 bitShift: nElements highBit.	^ (self basicNew: size) initialize: size! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 10:17'!step	^ suspendedContext := suspendedContext step! !!BlockContext methodsFor: 'private' stamp: 'ajh 1/27/2003 21:18'!copyTo: aContext blocks: dict	"Copy self and my sender chain down to, but not including, aContext.  End of copied chain will have nil sender.  BlockContexts whose home is also copied will point to the copy.  However, blockContexts that are not on the stack but may be later will not have their home pointing in the new copied thread.  So an error will be raised if one of these tries to return directly to its home."	| copy |	self == aContext ifTrue: [^ nil].	copy := self copy.	(dict at: self home ifAbsentPut: [OrderedCollection new]) add: copy.	self sender ifNotNil: [		copy privSender: (self sender copyTo: aContext blocks: dict)].	^ copy! !!Integer methodsFor: 'mathematical functions' stamp: 'hh 8/4/2000 01:09'!raisedTo: y modulo: n	"Answer the modular exponential. Code by Jesse Welton."	| s t u |	s := 1.	t := self.	u := y.	[u = 0] whileFalse: [		u odd ifTrue: [			s := s * t.			s >= n ifTrue: [s := s \\\ n]].		t := t * t.		t >= n ifTrue: [t := t \\\ n].		u := u bitShift: -1].	^ s! !!Behavior methodsFor: 'user interface' stamp: 'md 8/27/2005 17:18'!allLocalCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol, anywhere in my class hierarchy."	| aSet special byte cls |	aSet := Set new.	cls := self theNonMetaClass.	special := self environment hasSpecialSelector: aSymbol					ifTrueSetByte: [:b | byte := b ].	cls withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel isDoIt ifFalse: [aSet add: class name , ' ', sel]]].	cls class withAllSuperAndSubclassesDoGently: [ :class |		(class whichSelectorsReferTo: aSymbol special: special byte: byte)			do: [:sel |				sel isDoIt ifFalse: [aSet add: class name , ' ', sel]]].	^aSet! !!EventSensor class methodsFor: 'class initialization' stamp: 'ar 7/23/2000 15:06'!install	"EventSensor install"	"Install an EventSensor in place of the current Sensor."	| newSensor |	Sensor shutDown.	newSensor := self new.	newSensor startUp.	"Note: We must use #become: here to replace all references to the old sensor with the new one, since Sensor is referenced from all the existing controllers."	Sensor becomeForward: newSensor. "done"! !!Object class methodsFor: 'instance creation' stamp: 'sw 7/28/97 15:56'!chooseUniqueClassName	| i className |	i := 1.	[className := (self name , i printString) asSymbol.	 Smalltalk includesKey: className]		whileTrue: [i := i + 1].	^ className! !!Class methodsFor: 'fileIn/Out' stamp: 'al 9/3/2004 14:04'!fileOutSharedPoolsOn: aFileStream	"file out the shared pools of this class after prompting the user about each pool"	| poolsToFileOut |	poolsToFileOut := self sharedPools select: 		[:aPool | (self shouldFileOutPool: (self environment keyAtIdentityValue: aPool))].	poolsToFileOut do: [:aPool | self fileOutPool: aPool onFileStream: aFileStream].	! !!InputSensor methodsFor: 'keyboard' stamp: 'di 10/29/97 20:20'!kbdTest    "Sensor kbdTest"	"This test routine will print the unmodified character, its keycode,	and the OR of all its modifier bits, until the character x is typed"	| char |	char := nil.	[char = $x] whileFalse: 		[[self keyboardPressed] whileFalse: [].		char := self characterForKeycode: self keyboard.		(String streamContents: 			[:s | s nextPut: char; space; print: char asciiValue;					space; print: self primMouseButtons; nextPutAll: '     '])			displayAt: 10@10]! !!Class methodsFor: 'copying' stamp: 'di 2/17/2000 22:43'!copy 	| newClass |	newClass := self class copy new		superclass: superclass		methodDict: self methodDict copy		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString :=  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!addCategory: catString before: nextCategory	| oldCategories |	oldCategories := self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super addCategory: catString before: nextCategory].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!Behavior methodsFor: 'testing method dictionary' stamp: 'NS 3/30/2004 14:25'!whichSelectorsStoreInto: instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex := self allInstVarNames indexOf: instVarName ifAbsent: [^IdentitySet new].	^ self methodDict keys select: 		[:sel | (self methodDict at: sel) writesField: instVarIndex]	"Point whichSelectorsStoreInto: 'x'."! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!changeFromString: aString 	"Parse the argument, aString, and make this be the receiver's structure."	| categorySpecs |	categorySpecs := Scanner new scanTokens: aString.	"If nothing was scanned and I had no elements before, then default me"	(categorySpecs isEmpty and: [elementArray isEmpty])		ifTrue: [^ self setDefaultList: Array new].	^ self changeFromCategorySpecs: categorySpecs! !!Class methodsFor: 'pool variables' stamp: 'al 9/3/2004 14:25'!allSharedPools	"Answer a Set of the pools the receiver shares, including those defined  	in the superclasses of the receiver."	| aSet | 	^self superclass == nil		ifTrue: [self sharedPools copy]		ifFalse: [aSet := self superclass allSharedPools.			aSet addAll: self sharedPools.			aSet]! !!InstructionStream methodsFor: 'private' stamp: ''!method: method pc: startpc	sender := method. 	"allows this class to stand alone as a method scanner"	pc := startpc! !!MethodContext methodsFor: 'initialize-release' stamp: 'ajh 1/23/2003 20:27'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	pc := method initialPC.	self stackp: method numTemps.	method numArgs+1 to: method numTemps		do: [:i | self tempAt: i put: nil]! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:38'!removeEmptyCategories	| oldCategories |	oldCategories := self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super removeEmptyCategories].	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:37'!removeElement: element	| oldCat |	oldCat := self categoryOfElement: element.	SystemChangeNotifier uniqueInstance doSilently: [		super removeElement: element].	self notifyOfChangedSelector: element from: oldCat to: (self categoryOfElement: element).! !!ParagraphEditor methodsFor: 'explain' stamp: 'sw 5/3/1998 14:32'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls |	symbol = #nil ifTrue: [reply := '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply := '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply := '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply := '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls := model selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes := cls withAllSubclasses.			classes size > 12				ifTrue: [text := cls printString , ' or a subclass']				ifFalse: 					[classes := classes printString.					text := 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply := '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply := '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:48'!divideSecureBy: anObject	"Answer the result of dividing receiver by aNumber"	" Both operands are scaled to avoid arithmetic overflow. This algorithm 	  works for a wide range of values, but it requires six divisions.  	  #divideFastAndSecureBy:  is also quite good, but it uses only 3 divisions.	   Note: #reciprocal uses #/ for devision"	 	| s ars ais brs bis newReal newImaginary |	anObject isComplex ifTrue:		[s := anObject real abs + anObject imaginary abs.		 ars := self real / s.		 ais := self imaginary / s.		 brs := anObject real / s.		 bis := anObject imaginary / s.		 s := brs squared + bis squared.				newReal := ars*brs + (ais*bis) /s.		newImaginary := ais*brs - (ars*bis)/s.		^ Complex real: newReal imaginary: newImaginary].	^ anObject adaptToComplex: self andSend: #/.! !!LargePositiveInteger methodsFor: 'converting' stamp: 'RAA 3/2/2002 14:32'!withAtLeastNDigits: desiredLength	| new |	self size >= desiredLength ifTrue: [^self].	new := self class new: desiredLength.	new		replaceFrom: 1 		to: self size 		with: self 		startingAt: 1.	^new! !!Metaclass methodsFor: 'instance creation' stamp: 'nk 11/9/2003 10:00'!new	"The receiver can only have one instance. Create it or complain that	one already exists."	thisClass class ~~ self		ifTrue: [^thisClass := self basicNew]		ifFalse: [self error: 'A Metaclass should only have one instance!!']! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 8/29/1999 12:32'!initialize	environ := Smalltalk.	instVarMap := IdentityDictionary new.! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'brp 1/29/2005 10:27'!dayOfYear	"This code was contributed by Dan Ingalls. It is equivalent to the terser		^ jdn - (Year year: self year) start julianDayNumber + 1 but much quicker."	| monthStart |	^ self dayMonthYearDo:		[ :d :m :y |			monthStart := #(1 32 60 91 121 152 182 213 244 274 305 335) at: m.			(m > 2 and: [ Year isLeapYear: y ])				ifTrue: [ monthStart + d ]				ifFalse: [ monthStart + d - 1 ]]! !!Object methodsFor: 'viewer' stamp: 'sw 10/25/2000 07:20'!chooseNewNameForReference	"Offer an opportunity for the receiver, presumed already to be known in the References registry, to be renamed"	|  nameSym current newName |	current := References keyAtValue: self ifAbsent: [^ self error: 'not found in References'].	newName := FillInTheBlank request: 'Please enter new name' initialAnswer: current.	"Want to user some better way of determining the validity of the chosen identifier, and also want to give more precise diagnostic if the string the user types in is not acceptable.  Work to be done here."	newName isEmpty ifTrue: [^ nil].	((Scanner isLiteralSymbol: newName) and: [(newName includes: $:) not])		ifTrue:			[nameSym := newName capitalized asSymbol.			(((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(ScriptingSystem allKnownClassVariableNames includes: nameSym) not])					ifTrue:						[(References associationAt: current) key: nameSym.						References rehash.						^ nameSym]].	self inform: 'Sorry, that name is not available.'.	^ nil! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 10:38'!renameCategory: oldCatString toBe: newCatString	| oldCat newCat oldElementsBefore oldElementsAfter |	oldCat := oldCatString asSymbol.	newCat := newCatString asSymbol.	oldElementsBefore := self listAtCategoryNamed: oldCat.	SystemChangeNotifier uniqueInstance doSilently: [		super renameCategory: oldCatString toBe: newCatString].	oldElementsAfter := (self listAtCategoryNamed: oldCat) asSet.	oldElementsBefore do: [:each |		(oldElementsAfter includes: each)			ifFalse: [self notifyOfChangedSelector: each from: oldCat to: newCat].	].	self notifyOfChangedCategoryFrom: oldCat to: newCat.! !!PseudoContext class methodsFor: 'filing out' stamp: 'ikp 9/26/97 14:45'!definition	"Our superclass is really nil, but this causes problems when we try to become compact	after filing in for the first time.  Fake the superclass as Object, and repair the situation	during class initialisation."	| defn |	defn := super definition.	^(defn beginsWith: 'nil ')		ifTrue: ['Object' , (defn copyFrom: 4 to: defn size)]		ifFalse: [defn].! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/22/2002 02:57'!needsSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass	"Answer whether we need a new subclass to conform to the requested changes"	| newFormat |	"Compute the format of the new class"	newFormat := 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	"Check if we really need a new subclass"	oldClass ifNil:[^true]. "yes, it's a new class"	newSuper == oldClass superclass ifFalse:[^true]. "yes, it's a superclass change"	newFormat = oldClass format ifFalse:[^true]. "yes, it's a format change"	instVars = oldClass instVarNames ifFalse:[^true]. "yes, it's an iVar change"	^false! !!Monitor methodsFor: 'private' stamp: 'NS 7/1/2002 15:06'!defaultQueue	defaultQueue ifNil: [defaultQueue := OrderedCollection new].	^ defaultQueue! !!Class methodsFor: 'private' stamp: 'ar 7/15/1999 15:37'!setName: aSymbol	"Private - set the name of the class"	name := aSymbol.! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 1/19/2000 11:14'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList := paragraph textStyle fontNamesWithPointSizes.	reply := (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!Integer class methodsFor: 'instance creation' stamp: 'bf 2/2/2004 00:23'!byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4 	"Depending on high-order byte copy directly into a LargeInteger,	or build up a SmallInteger by shifting"	| value |	byte4 < 16r40 ifTrue:		[^ (byte4 bitShift: 24)		 + (byte3 bitShift: 16)		 + (byte2 bitShift: 8)		 + byte1].	value := LargePositiveInteger new: 4.	value digitAt: 4 put: byte4.	value digitAt: 3 put: byte3.	value digitAt: 2 put: byte2.	value digitAt: 1 put: byte1.	^ value! !!CompiledMethod methodsFor: 'scanning' stamp: ''!scanLongLoad: extension 	"Answer whether the receiver contains a long load whose extension is the 	argument."	| scanner |	scanner := InstructionStream on: self.	^scanner scanFor: [:instr | instr = 128 and: [scanner followingByte = extension]]! !!ProcessorScheduler methodsFor: 'CPU usage tally' stamp: 'nk 3/17/2001 10:06'!tallyCPUUsageFor: seconds every: msec	"Start a high-priority process that will tally the next ready process for the given	number of seconds. Answer a Block that will return the tally (a Bag) after the task	is complete" 	| tally sem delay endDelay |	tally := IdentityBag new: 200.	delay := Delay forMilliseconds: msec truncated.	endDelay := Delay forSeconds: seconds.	endDelay schedule.	sem := Semaphore new.	[		[ endDelay isExpired ] whileFalse: [			delay wait.			tally add: Processor nextReadyProcess		].		sem signal.	] forkAt: self highestPriority.	^[ sem wait. tally ]! !!ContextPart methodsFor: 'system simulation' stamp: 'ajh 1/24/2003 22:54'!stepToCallee	"Step to callee or sender"	| ctxt |	ctxt := self.	[(ctxt := ctxt step) == self] whileTrue.	^ ctxt! !!Behavior methodsFor: 'initialize-release' stamp: 'al 12/12/2003 20:59'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := aClass.	format := fmt.	methodDict := mDict.	self traitComposition: nil! !!ClassDescription methodsFor: 'instance variables' stamp: 'al 11/28/2005 22:14'!chooseClassVarName 	"Present the user with a list of class variable names and answer the one selected, or nil if none"	| lines labelStream vars allVars index |	lines := OrderedCollection new.	allVars := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[:class |		vars := class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^Beeper beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index := (UIManager default chooseFrom: (labelStream contents substrings) lines: lines).	index := (PopUpMenu labels: labelStream contents lines: lines) startUp.	index = 0 ifTrue: [^ nil].	^ allVars at: index! !!Metaclass methodsFor: 'instance variables' stamp: ''!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newArray newString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newArray := self instVarNames copyWithout: aString.	newString := ''.	newArray do: [:aString2 | newString := aString2 , ' ' , newString].	self instanceVariableNames: newString! !!ContextPart methodsFor: 'controlling' stamp: 'hmm 7/17/2001 20:57'!quickSend: selector to: receiver with: arguments super: superFlag	"Send the given selector with arguments in an environment which closely resembles the non-simulating environment, with an interjected unwind-protected block to catch nonlocal returns.	Attention: don't get lost!!"	| oldSender contextToReturnTo result lookupClass |	contextToReturnTo := self.	lookupClass := superFlag					ifTrue: [(self method literalAt: self method numLiterals) value superclass]					ifFalse: [receiver class].	[oldSender := thisContext sender swapSender: self.	result := receiver perform: selector withArguments: arguments inSuperclass: lookupClass.	thisContext sender swapSender: oldSender] ifCurtailed: [		contextToReturnTo := thisContext sender receiver.	"The block context returning nonlocally"		contextToReturnTo jump: -1.	"skip to front of return bytecode causing this unwind"		contextToReturnTo nextByte = 16r7C ifTrue: [			"If it was a returnTop, push the value to be returned.			Otherwise the value is implicit in the bytecode"			contextToReturnTo push: (thisContext sender tempAt: 1)].		thisContext swapSender: thisContext home sender.	"Make this block return to the method's sender"		contextToReturnTo].	contextToReturnTo push: result.	^contextToReturnTo! !!ProcessorScheduler methodsFor: 'accessing' stamp: 'ar 8/22/2001 17:33'!preemptedProcess	"Return the process that the currently active process just preempted."	| list |	activeProcess priority to: 1 by: -1 do:[:priority|		list := quiescentProcessLists at: priority.		list isEmpty ifFalse:[^list last].	].	^nil	"Processor preemptedProcess"! !!Monitor methodsFor: 'signaling-specific' stamp: 'NS 7/1/2002 22:02'!signalAll: aSymbolOrNil	"All process waiting for the given event or the default event are woken up."	| queue |	self checkOwnerProcess.	queue := self queueFor: aSymbolOrNil.	self signalAllInQueue: self defaultQueue.	queue ~~ self defaultQueue ifTrue: [self signalAllInQueue: queue].! !!Behavior methodsFor: 'printing' stamp: ''!printHierarchy	"Answer a description containing the names and instance variable names 	of all of the subclasses and superclasses of the receiver."	| aStream index |	index := 0.	aStream := WriteStream on: (String new: 16).	self allSuperclasses reverseDo: 		[:aClass | 		aStream crtab: index.		index := index + 1.		aStream nextPutAll: aClass name.		aStream space.		aStream print: aClass instVarNames].	aStream cr.	self printSubclassesOn: aStream level: index.	^aStream contents! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/13/1999 11:02'!tabletExtent	"Answer the full tablet extent in tablet coordinates."	| params |	params := self primTabletGetParameters: 1.	params ifNil: [^ self error: 'no tablet available'].	^ (params at: 1)@(params at: 2)! !!Number methodsFor: 'intervals' stamp: ''!to: stop do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: 1)."	| nextValue |	nextValue := self.	[nextValue <= stop]		whileTrue: 			[aBlock value: nextValue.			nextValue := nextValue + 1]! !!Float class methodsFor: 'class initialization' stamp: 'yo 6/17/2004 17:44'!initialize	"Float initialize"	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288		Pi/2 = 1.57079632679489661923132169163975144		Pi*2 = 6.28318530717958647692528676655900576		Pi/180 = 0.01745329251994329576923690768488612		2.0 ln = 0.69314718055994530941723212145817657		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi := 3.14159265358979323846264338327950288.	Halfpi := Pi / 2.0.	Twopi := Pi * 2.0.	ThreePi := Pi * 3.0.	RadiansPerDegree := Pi / 180.0.	Ln2 := 0.69314718055994530941723212145817657.	Ln10 := 10.0 ln.	Sqrt2 := 1.41421356237309504880168872420969808.	E := 2.718281828459045235360287471353.	Epsilon := 0.000000000001.  "Defines precision of mathematical functions"	MaxVal := 1.7976931348623159e308.	MaxValLn := 709.782712893384.	MinValLogBase2 := -1074.	Infinity := MaxVal * MaxVal.	NegativeInfinity := 0.0 - Infinity.	NaN := Infinity - Infinity.	NegativeZero := 1.0 / Infinity negated.! !!Float methodsFor: 'truncation and round off' stamp: 'nice 3/23/2008 16:03'!significandAsInteger	| exp sig |	exp _ self exponent.	sig _ (((self at: 1) bitAnd: 16r000FFFFF) bitShift: 32) bitOr: (self at: 2).	(exp > -1023 and: [self ~= 0.0])		ifTrue: [sig _ sig bitOr: (1 bitShift: 52)].	^ sig.! !!Integer methodsFor: 'enumerating' stamp: ''!timesRepeat: aBlock 	"Evaluate the argument, aBlock, the number of times represented by the 	receiver."	| count |	count := 1.	[count <= self]		whileTrue: 			[aBlock value.			count := count + 1]! !!SmallInteger methodsFor: 'printing' stamp: 'RAA 8/24/2001 13:59'!threeDigitName	| units answer |	self = 0 ifTrue: [^''].	units := #('one' 'two' 'three' 'four' 'five' 'six' 'seven' 'eight' 'nine' 'ten' 		'eleven' 'twelve' 'thirteen' 'fourteen' 'fifteen' 'sixteen' 'seventeen' 		'eighteen' 'nineteen').	self > 99 ifTrue: [		answer := (units at: self // 100),' hundred'.		(self \\ 100) = 0 ifFalse: [			answer := answer,' ',(self \\ 100) threeDigitName		].		^answer	].	self < 20 ifTrue: [		^units at: self	].	answer := #('twenty' 'thirty' 'forty' 'fifty' 'sixty' 'seventy' 'eighty' 'ninety')			at: self // 10 - 1.	(self \\ 10) = 0 ifFalse: [		answer := answer,'-',(units at: self \\ 10)	].	^answer! !!Behavior methodsFor: 'private' stamp: 'sd 3/28/2003 15:06'!becomeUncompact	| cct index |	cct := self environment compactClassesArray.	(index := self indexIfCompact) = 0		ifTrue: [^ self].	(cct includes: self)		ifFalse: [^ self halt  "inconsistent state"].	"Update instspec so future instances will not be compact"	format := format - (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Make sure there are no compact ones left around"	Smalltalk garbageCollect.	"Remove this class from the compact class table"	cct at: index put: nil.! !!BlockContext methodsFor: 'accessing' stamp: 'md 4/27/2006 15:14'!hasInstVarRef	"Answer whether the receiver references an instance variable."	| method scanner end printer |	home ifNil: [^false].	method := self method.	end := self endPC.	scanner := InstructionStream new method: method pc: startpc.	printer := InstVarRefLocator new.	[scanner pc <= end] whileTrue: [		(printer interpretNextInstructionUsing: scanner) ifTrue: [^true].	].	^false! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'ar 7/10/1999 12:10'!superclass: aClass 	"Change the receiver's superclass to be aClass."	"Note: Do not use 'aClass isKindOf: Behavior' here		in case we recompile from Behavior itself."	(aClass == nil or: [aClass isBehavior])		ifTrue: [superclass := aClass.				Object flushCache]		ifFalse: [self error: 'superclass must be a class-describing object']! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'sw 5/21/2001 22:51'!inspectSubInstances 	"Inspect all instances of the receiver and all its subclasses.  CAUTION - don't do this for something as generic as Object!!  1/26/96 sw"	| all allSize prefix |	all := self allSubInstances.	(allSize := all size) == 0 ifTrue: [^ self inform: 'There are no instances of ', self name, 'or any of its subclasses'].	prefix := allSize == 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name, ' & its subclasses')! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 9/22/2002 03:16'!reshapeClass: oldClass toSuper: newSuper	"Reshape the given class to the new super class. Recompile all the methods in the newly created class. Answer the new class."	| instVars |	"ar 9/22/2002: The following is a left-over from some older code. 	I do *not* know why we uncompact oldClass here. If you do, then 	please let me know so I can put a comment here..."	oldClass becomeUncompact.	instVars := instVarMap at: oldClass name ifAbsent:[oldClass instVarNames].	^self newSubclassOf: newSuper 			type: oldClass typeOfClass 			instanceVariables: instVars 			from: oldClass! !!ObjectViewer methodsFor: 'very few messages' stamp: ''!xxxViewedObject: viewedObject evaluate: block1 wheneverChangeIn: block2	"This message name must not clash with any other (natch)."	tracedObject := viewedObject.	valueBlock := block2.	changeBlock := block1.	recursionFlag := false! !!BlockContext methodsFor: 'initialize-release' stamp: 'ajh 7/18/2003 21:49'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	pc := startpc.	self stackp: 0.	nargs timesRepeat: [  "skip arg popping"		self nextInstruction selector = #popIntoTemporaryVariable:			ifFalse: [self halt: 'unexpected bytecode instruction']	].! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:49'!constDiv	| const subTest got |	"See if (data1 // C) is the answer"	const := ((thisData at: 1) at: 1) // (answers at: 1).  "May not be right!!"	got := (subTest := MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!BlockContext methodsFor: 'exceptions' stamp: 'ajh 3/4/2004 22:36'!ensure: aBlock	"Evaluate a termination block after evaluating the receiver, regardless of whether the receiver's evaluation completes."	| returnValue b |	<primitive: 198>	returnValue := self value.	"aBlock wasn't nil when execution of this method began; it is nil'd out by the unwind machinery, and that's how we know it's already been evaluated ... otherwise, obviously, it needs to be evaluated"	aBlock == nil ifFalse: [		"nil out aBlock temp before evaluating aBlock so it is not executed again if aBlock remote returns"		b := aBlock.		thisContext tempAt: 1 put: nil.  "aBlock := nil"		b value.	].	^ returnValue! !!MethodFinder methodsFor: 'arg maps' stamp: 'tk 5/24/1999 16:31'!permuteArgs 	"Run through ALL the permutations.  First one was as presented."	data first size <= 1 ifTrue: [^ false].	"no other way"	mapList ifNil: [self makeAllMaps].	mapStage := mapStage + 1.	mapStage > mapList size ifTrue: [^ false].	argMap := mapList at: mapStage.	self mapData.	^ true	! !!Object methodsFor: 'debugging-haltOnce' stamp: 'sbw 6/2/2004 08:28'!decrementHaltCount	| counter |	counter := Smalltalk				at: #HaltCount				ifAbsent: [0].	counter > 0 ifTrue: [		counter := counter - 1.		self setHaltCountTo: counter]! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 5/20/2004 17:32'!resume: value	"Unwind thisContext to self and resume with value as result of last send.  Execute unwind blocks when unwinding.  ASSUMES self is a sender of thisContext"	| ctxt unwindBlock |	self isDead ifTrue: [self cannotReturn: value to: self].	ctxt := thisContext.	[	ctxt := ctxt findNextUnwindContextUpTo: self.		ctxt isNil	] whileFalse: [		unwindBlock := ctxt tempAt: 1.		unwindBlock ifNotNil: [			ctxt tempAt: 1 put: nil.			thisContext terminateTo: ctxt.			unwindBlock value].	].	thisContext terminateTo: self.	^ value! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:30'!digitLshift: shiftCount 	| carry rShift mask len result digit byteShift bitShift highBit |	(highBit := self highBitOfMagnitude) = 0 ifTrue: [^ 0].	len := highBit + shiftCount + 7 // 8.	result := Integer new: len neg: self negative.	byteShift := shiftCount // 8.	bitShift := shiftCount \\ 8.	bitShift = 0 ifTrue: ["Fast version for byte-aligned shifts"		^ result			replaceFrom: byteShift + 1			to: len			with: self			startingAt: 1].	carry := 0.	rShift := bitShift - 8.	mask := 255 bitShift: 0 - bitShift.	1 to: byteShift do: [:i | result digitAt: i put: 0].	1 to: len - byteShift do: 		[:i | 		digit := self digitAt: i.		result digitAt: i + byteShift put: (((digit bitAnd: mask)				bitShift: bitShift)				bitOr: carry).		carry := digit bitShift: rShift].	^ result! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:48'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection := self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock := self startIndex]! !!EventSensor methodsFor: 'private-I/O' stamp: 'nk 4/11/2001 18:28'!processKeyboardEvent: evt	"process a keyboard event, updating InputSensor state"	| charCode pressCode |	"Never update keyboardBuffer if we have an eventQueue active"	mouseButtons := (mouseButtons bitAnd: 7) bitOr: ((evt at: 5) bitShift: 3).	eventQueue ifNotNil:[^self]. 	charCode := evt at: 3.	charCode = nil ifTrue:[^self]. "extra characters not handled in MVC"	pressCode := evt at: 4.	pressCode = EventKeyChar ifFalse:[^self]. "key down/up not handled in MVC"	"mix in modifiers"	charCode := charCode bitOr: ((evt at: 5) bitShift: 8).	keyboardBuffer nextPut: charCode.! !!Number methodsFor: 'converting' stamp: 'sw 9/8/97 16:30'!asSmallAngleDegrees	"Return the receiver normalized to lie within the range (-180, 180)"	| pos |	pos := self \\ 360.	pos > 180 ifTrue: [pos := pos - 360].	^ pos"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallAngleDegrees]"! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'pmm 7/6/2006 20:50'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry |	self flag: #yoCharCases.	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol := self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry := (Smalltalk					at: aSymbol					ifAbsent:						[ self systemNavigation browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isBehavior or: [ anEntry isTrait ])					ifFalse: [ anEntry := anEntry class ].				ToolSet browse: anEntry selector: nil.		] ifFalse:[ self systemNavigation browseAllImplementorsOf: aSymbol]]! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 9/19/2002 23:44'!obsoleteSubclasses	"Answer the receiver's subclasses."	thisClass == nil ifTrue:[^#()].	^thisClass obsoleteSubclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses:=nil' for: m logged: false]"! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 7/5/2004 16:38'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString := self selection string.	aString isOctetString ifTrue: [aString := aString asOctetString].	aString := aString copyWithoutAll:		{Character space.  Character cr.  Character tab}.	aString size == 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!InstructionStream methodsFor: 'testing' stamp: 'di 1/29/2000 14:42'!willJumpIfTrue 	"Answer whether the next bytecode is a jump-if-true." 	| byte |	byte := self method at: pc.	^ byte between: 168 and: 171! !!CompiledMethod methodsFor: 'accessing' stamp: 'ajh 11/17/2001 14:30'!trailer	| end trailer |	end := self endPC.	trailer := ByteArray new: self size - end.	end + 1 to: self size do: [:i | 		trailer at: i - end put: (self at: i)].	^ trailer! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!dateCommentLastSubmitted	"Answer a Date object indicating when my class comment was last submitted.  If there is no date stamp, or one of the old-time <historical>  guys, return nil"	"RecentMessageSet organization dateCommentLastSubmitted"	| aStamp tokens |	(aStamp := self commentStamp) isEmptyOrNil ifTrue: [^ nil].	tokens := aStamp findBetweenSubStrs: ' '.  "space is expected delimiter, but cr is sometimes seen, though of mysterious provenance"	^ tokens size > 1		ifTrue:			[[tokens second asDate] ifError: [nil]]		ifFalse:			[nil]! !!Integer methodsFor: 'benchmarks' stamp: 'di 4/11/1999 11:20'!benchmark  "Handy bytecode-heavy benchmark"	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags prime k count |    size := 8190.    1 to: self do:        [:iter |        count := 0.        flags := (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime := i+1.                k := i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k := k + prime].                count := count + 1]]].    ^ count! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:53'!beSilentDuring: aBlock	"Temporarily suppress information about what is going on"	| wasSilent result |	wasSilent := self isSilent.	self beSilent: true.	result := aBlock value.	self beSilent: wasSilent.	^result! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 1/24/2003 14:31'!contextEnsure: block	"Create an #ensure: context that is ready to return from executing its receiver"	| ctxt chain |	ctxt := thisContext.	[chain := thisContext sender cut: ctxt. ctxt jump] ensure: block.	"jump above will resume here without unwinding chain"	^ chain! !!Object methodsFor: 'copying' stamp: 'tpr 2/14/2004 21:53'!copyFrom: anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	| mine his |	<primitive: 168>	mine := self class allInstVarNames.	his := anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!InputSensor class methodsFor: 'class initialization' stamp: 'dew 12/13/2004 23:21'!installKeyDecodeTable	"Create a decode table that swaps some keys if 	Preferences swapControlAndAltKeys is set"	KeyDecodeTable := Dictionary new.	Preferences duplicateControlAndAltKeys 		ifTrue: [ self defaultCrossPlatformKeys do:				[ :c | self installDuplicateKeyEntryFor: c ] ].	Preferences swapControlAndAltKeys 		ifTrue: [ self defaultCrossPlatformKeys do:				[ :c | self installSwappedKeyEntryFor: c ] ].	Preferences duplicateAllControlAndAltKeys		ifTrue: [ (Character allCharacters select: [:ea | ea isAlphaNumeric]) do:				[ :c | self installDuplicateKeyEntryFor: c ] ].! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:49'!constMult	| const subTest got |	"See if (data1 * C) is the answer"	((thisData at: 1) at: 1) = 0 ifTrue: [^ false].	const := ((answers at: 1) asFloat / ((thisData at: 1) at: 1)) reduce.	got := (subTest := MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!MethodFinder methodsFor: 'search' stamp: 'tk 1/8/2001 17:53'!searchForOne	"Look for and return just one answer"	expressions := OrderedCollection new.	self search: false.	"non-multi"	^ expressions			! !!WeakMessageSend methodsFor: 'accessing' stamp: 'nk 4/25/2002 09:38'!arguments: anArray	arguments := WeakArray withAll: anArray.	"no reason this should be a WeakArray"	shouldBeNil := Array withAll: (anArray collect: [ :ea | ea isNil ]).! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 5/6/1998 15:21'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| wasShowing userSelection delta loc |	aString = '#insert period' ifTrue:		[loc := start.		[(loc := loc-1)>0 and: [(paragraph text string at: loc) isSeparator]]			whileTrue: [loc := loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing := selectionShowing) ifTrue: [ self reverseSelection ].	userSelection := self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString asText.	delta := aString size - (stop - start + 1).	self selectInvisiblyFrom:		userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sd 11/19/2004 15:18'!zapAllMethods	"Remove all methods in this class which is assumed to be obsolete"	methodDict := self emptyMethodDictionary.	self class isMeta ifTrue: [self class zapAllMethods]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'gk 3/3/2004 17:15'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	^ result! !!Class methodsFor: 'class variables' stamp: 'tk 3/15/98 20:19'!ensureClassPool	classPool ifNil: [classPool := Dictionary new].! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/17/2002 16:23'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard.  This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits."	self deselect.	self openTypeIn.	self markBlock = self pointBlock ifFalse: [UndoSelection := self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	self unselect.	self selectAndScroll.	self updateMarker.	view ifNotNil:		[view topView uncacheBits		"in mvc, this makes sure the recognized character shows up in the pane right now; in morphic, a different mechanism is used for the same effect -- see TextMorphEditor method #recognizeCharactersWhileMouseIn:"]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 09:42'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [ self systemNavigation browseAllImplementorsOf: aSelector]! !!Number class methodsFor: 'instance creation' stamp: 'yo 8/28/2002 22:40'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	include a leading radix specification, as in 16rFADE"	| value base aStream sign |	aStream := (stringOrStream isString)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign := (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	base := 10.	value := Integer readFrom: aStream base: base.	(aStream peekFor: $r)		ifTrue: 			["<base>r<integer>"			(base := value) < 2 ifTrue: [^self error: 'Invalid radix'].			(aStream peekFor: $-) ifTrue: [sign := sign negated].			value := Integer readFrom: aStream base: base].	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/12/1999 13:05'!tabletPressure	"Answer the current pressure of the first tablet pointing device (pen, puck, or eraser), a number between 0.0 (no pressure) and 1.0 (max pressure)"	| params data |	params := self primTabletGetParameters: 1.	params ifNil: [^ self].	data := self primTabletRead: 1.  "state of first/primary pen"	^ (data at: 10) asFloat / ((params at: 10) - 1)! !!ContextPart methodsFor: 'printing' stamp: 'tk 10/19/2001 11:24'!printDetails: strm	"Put my class>>selector and arguments and temporaries on the stream.  Protect against errors during printing."	| str |	self printOn: strm.  	strm cr; tab; nextPutAll: 'Arguments and temporary variables: '; cr.	str := [self tempsAndValuesLimitedTo: 80 indent: 2] ifError: [:err :rcvr | 						'<<error during printing>>'].	strm nextPutAll: str.	strm peekLast == Character cr ifFalse: [strm cr].! !!ContextPart methodsFor: 'private' stamp: 'ar 5/25/2000 20:41'!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod := aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	^aReceiver perform: selector withArguments: arguments! !!ParagraphEditor methodsFor: 'explain' stamp: ''!explainScan: string 	"Remove beginning and trailing space, tab, cr.	 1/15/96 sw: copied intact from BrowserCodeController"	| c beg end |	beg := 1.	end := string size.		[beg = end ifTrue: [^string copyFrom: 1 to: 1].	"if all blank, tell about the first"	c := string at: beg.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [beg := beg + 1].		[c := string at: end.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [end := end - 1].	^string copyFrom: beg to: end	"Return purely visible characters"! !!Class methodsFor: 'fileIn/Out' stamp: 'al 9/3/2004 14:04'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName aValue |	(aPool  isKindOf: SharedPool class) ifTrue:[^self notify: 'we do not fileout SharedPool type shared pools for now'].	aPoolName := self environment keyAtIdentityValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asSortedCollection do: [ :aKey |		aValue := aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!MethodDictionary methodsFor: 'accessing' stamp: 'ar 10/12/2000 17:25'!at: key put: value	"Set the value at key to be value."	| index |	index := self findElementOrNil: key.	(self basicAt: index) == nil		ifTrue: 			[tally := tally + 1.			self basicAt: index put: key]		ifFalse:			[(array at: index) flushCache].	array at: index put: value.	self fullCheck.	^ value! !!ClassDescription methodsFor: 'instance variables' stamp: 'al 11/28/2005 11:50'!checkForInstVarsOK: instVarString	"Return true if instVarString does no include any names used in a subclass"	| instVarArray |	instVarArray := Scanner new scanFieldNames: instVarString.	self allSubclasses do:		[:cl | cl instVarNames do:			[:n | (instVarArray includes: n)				ifTrue: [self error: n , ' is already used in ' , cl name.						^ false]]].	^ true! !!Behavior methodsFor: 'enumerating' stamp: ''!selectSuperclasses: aBlock 	"Evaluate the argument, aBlock, with the receiver's superclasses as the 	argument. Collect into an OrderedCollection only those superclasses for 	which aBlock evaluates to true. In addition, evaluate aBlock for the 	superclasses of each of these successful superclasses and collect into the 	OrderedCollection ones for which aBlock evaluates to true. Answer the 	resulting OrderedCollection."	| aSet |	aSet := Set new.	self allSuperclasses do: 		[:aSuperclass | 		(aBlock value: aSuperclass) ifTrue: [aSet add: aSuperclass]].	^aSet! !!ContextPart methodsFor: 'debugger access' stamp: 'nk 7/29/2004 10:09'!errorReportOn: strm	"Write a detailed error report on the stack (above me) on a stream.  For both the error file, and emailing a bug report.  Suppress any errors while getting printStrings.  Limit the length."	| cnt aContext startPos | 	strm print: Date today; space; print: Time now; cr.	strm cr.	strm nextPutAll: 'VM: ';		nextPutAll:  SmalltalkImage current platformName asString;		nextPutAll: ' - ';		nextPutAll: SmalltalkImage current asString;		cr.	strm nextPutAll: 'Image: ';		nextPutAll:  SystemVersion current version asString;		nextPutAll: ' [';		nextPutAll: SmalltalkImage current lastUpdateString asString;		nextPutAll: ']';		cr.	strm cr.	SecurityManager default printStateOn: strm.		"Note: The following is an open-coded version of ContextPart>>stackOfSize: since this method may be called during a low space condition and we might run out of space for allocating the full stack."	cnt := 0.  startPos := strm position.	aContext := self.	[aContext notNil and: [(cnt := cnt + 1) < 5]] whileTrue:		[aContext printDetails: strm.	"variable values"		strm cr.		aContext := aContext sender].	strm cr; nextPutAll: '--- The full stack ---'; cr.	aContext := self.	cnt := 0.	[aContext == nil] whileFalse:		[cnt := cnt + 1.		cnt = 5 ifTrue: [strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; cr].		strm print: aContext; cr.  "just class>>selector"			strm position > (startPos+4000) ifTrue: [strm nextPutAll: '...etc...'.			^ self]. 	"exit early"		cnt > 60 ifTrue: [strm nextPutAll: '-- and more not shown --'.  ^ self].		aContext := aContext sender].! !!Object methodsFor: 'casing' stamp: ''!caseOf: aBlockAssociationCollection	"The elements of aBlockAssociationCollection are associations between blocks.	 Answer the evaluated value of the first association in aBlockAssociationCollection	 whose evaluated key equals the receiver.  If no match is found, report an error."	^ self caseOf: aBlockAssociationCollection otherwise: [self caseError]"| z | z := {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""| z | z := {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}. #b caseOf: z""The following are compiled in-line:""#b caseOf: {[#a]->[1+1]. ['b' asSymbol]->[2+2]. [#c]->[3+3]}""#b caseOf: {[#a]->[1+1]. ['d' asSymbol]->[2+2]. [#c]->[3+3]}"! !!Integer methodsFor: 'printing-numerative' stamp: 'laza 3/29/2004 18:16'!storeOn: aStream base: base length: minimum padded: zeroFlag	| prefix |	prefix := self negative ifTrue: ['-'] ifFalse: [String new].	base = 10 ifFalse: [prefix := prefix, base printString, 'r'].	self print: (self abs printStringBase: base) on: aStream prefix: prefix length: minimum padded: zeroFlag! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 08:05'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys and values passed to the block"	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key := self basicAt: i) == nil ifFalse:			[aBlock value: key value: (array at: i)]		]! !!Class methodsFor: 'traits' stamp: 'NS 4/12/2004 16:48'!applyChangesOfNewTraitCompositionReplacing: oldComposition	"See Trait>>applyChangesOfNewTraitCompositionReplacing:"	| changedSelectors |	changedSelectors := super applyChangesOfNewTraitCompositionReplacing: oldComposition.	self classSide		noteNewBaseTraitCompositionApplied: self traitComposition.	^ changedSelectors! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'yo 5/27/2004 13:56'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes := paragraph text attributesAt: self selectionInterval first forStyle: paragraph textStyle.	attribute := TextEmphasis perform: emphasisSymbol.	(emphasisSymbol == #normal) 		ifFalse:	[oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ContextPart methodsFor: 'private-exceptions' stamp: 'TPR 8/23/2000 16:37'!findNextUnwindContextUpTo: aContext	"Return the next unwind marked above the receiver, returning nil if there is none.  Search proceeds up to but not including aContext."	| ctx |	<primitive: 195>	ctx := self.		[(ctx := ctx sender) == nil or: [ctx == aContext]] whileFalse:		[ ctx isUnwindContext ifTrue: [^ctx]].	^nil! !!ClassBuilder methodsFor: 'class definition' stamp: 'NS 1/21/2004 09:53'!recompile: force from: oldClass to: newClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	oldClass == nil ifTrue:[^ newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		^newClass].	currentClassIndex := 0.	maxClassIndex := oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		"Recompile from newClass without mutating"		self informUserDuring:[			newClass isSystemDefined ifFalse:[progress := nil].			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	self informUserDuring:[		newClass isSystemDefined ifFalse:[progress := nil].		self mutate: oldClass to: newClass.	].	^oldClass "now mutated to newClass"! !!Float methodsFor: 'converting' stamp: 'nice 3/29/2006 01:01'!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  Floats are stored in the same form on all platforms.	  (Does handle gradual underflow but not NANs.)	  By David N. Smith with significant performance	  improvements by Luciano Esteban Notarfrancesco.	  (Version of 11April97)"	| signexp positive expPart exp fraction fractionPart signedFraction result zeroBitsCount |	self isInfinite ifTrue: [self error: 'Cannot represent infinity as a fraction'].	self isNaN ifTrue: [self error: 'Cannot represent Not-a-Number as a fraction'].	" Extract the sign and the biased exponent "	signexp := (self basicAt: 1) bitShift: -20.	positive := (signexp bitAnd: 16r800) = 0.	expPart := signexp bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "	fractionPart := (((self basicAt: 1) bitAnd: 16rFFFFF) bitShift: 32)+ (self basicAt: 2).	( expPart=0 and: [ fractionPart=0 ] ) ifTrue: [ ^ 0  ].	" Replace omitted leading 1 in fraction unless gradual underflow"	fraction := expPart = 0		ifTrue: [fractionPart bitShift: 1]		ifFalse: [fractionPart bitOr: 16r0010000000000000].	signedFraction := positive ifTrue: [fraction] ifFalse: [fraction negated].		"Unbias exponent: 16r3FF is bias; 52 is fraction width"	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "	exp negative		ifTrue: [			result := signedFraction bitShift: exp negated ]		ifFalse:	[			zeroBitsCount := fraction lowBit - 1.			exp := exp - zeroBitsCount.			exp <= 0				ifTrue: [					zeroBitsCount := zeroBitsCount + exp.					"exp := 0."   " Not needed; exp notrefernced again "					result := signedFraction bitShift:zeroBitsCount negated ]				ifFalse: [					result := Fraction						numerator: (signedFractionbitShift: zeroBitsCount negated)						denominator: (1 bitShift:exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."	^ result ! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/21/2004 11:25'!* anObject	"Answer the result of multiplying the receiver by aNumber."	| a b c d newReal newImaginary |	anObject isComplex		ifTrue:			[a := self real.			b := self imaginary.			c := anObject real.			d := anObject imaginary.			newReal := (a * c) - (b * d).			newImaginary := (a * d) + (b * c).			^ Complex real: newReal imaginary: newImaginary]		ifFalse:			[^ anObject adaptToComplex: self andSend: #*]! !!ClassBuilder methodsFor: 'validation' stamp: 'ajh 10/17/2002 11:10'!validateInstvars: instVarArray from: oldClass forSuper: newSuper	"Check if any of the instVars of oldClass conflict with the new superclass"	| instVars usedNames temp |	instVarArray isEmpty ifTrue:[^true]. "Okay"	newSuper allowsSubInstVars ifFalse: [		self error: newSuper printString, ' does not allow subclass inst vars. See allowsSubInstVars.'. ^ false].	"Validate the inst var names"	usedNames := instVarArray asSet.	usedNames size = instVarArray size 		ifFalse:[	instVarArray do:[:var|					usedNames remove: var ifAbsent:[temp := var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp := var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames := newSuper allInstVarNames asSet.		instVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl instVarNames includes: iv) ifTrue:[temp := cl]].				self error: iv,' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames := Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl instVarNames].		instVars := instVarArray.		newSuper == nil ifFalse:[instVars := instVars, newSuper allInstVarNames].		instVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!CompiledMethod methodsFor: 'scanning' stamp: ''!messages	"Answer a Set of all the message selectors sent by this method."	| scanner aSet |	aSet := Set new.	scanner := InstructionStream on: self.	scanner			scanFor: 			[:x | 			scanner addSelectorTo: aSet.			false	"keep scanning"].	^aSet! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'nb 5/6/2003 17:11'!allSubclasses	"Answer a Set of the receiver's and the receiver's descendent's subclasses. "	| scan scanTop |	scan := OrderedCollection withAll: self subclasses.	scanTop := 1.	[scanTop > scan size]		whileFalse: [scan addAll: (scan at: scanTop) subclasses.			scanTop := scanTop + 1].	^ scan asSet! !!InputSensor methodsFor: 'joystick' stamp: 'BG 3/16/2005 08:23'!testJoystick: index	"Sensor testJoystick: 3"	| f pt buttons status |	f := Form extent: 110@50.	[Sensor anyButtonPressed] whileFalse: [		pt := Sensor joystickXY: index.		buttons := Sensor joystickButtons: index.		status :='xy: ', pt printString, 'buttons: ', buttons printStringHex.		f fillWhite.		status displayOn: f at: 10@10.		f displayOn: Display at: 10@10.	].! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'mga 3/21/2005 12:04'!nextQuotePosIn: sourceString startingFrom: commentStart	| pos nextQuotePos |	pos := commentStart + 1.	[((nextQuotePos := sourceString findString: '"' startingAt: pos) == (sourceString findString: '""' startingAt: pos)) and: [nextQuotePos ~= 0]]		whileTrue:			[pos := nextQuotePos + 2].	^nextQuotePos! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/18/2002 16:21'!makeProjectLink: characterStream 	""	| attribute oldAttributes thisSel |		sensor keyboard.	oldAttributes := paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel := self selection.	attribute := TextSqkProjectLink new. 	thisSel := attribute analyze: self selection asString.	thisSel ifNil: [^ true].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere := Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!MonitorDelay methodsFor: 'private' stamp: 'NS 4/13/2004 16:26'!setDelay: anInteger forSemaphore: aSemaphore monitor: aMonitor queue: anOrderedCollection	monitor := aMonitor.	queue := anOrderedCollection.	self setDelay: anInteger forSemaphore: aSemaphore.! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/19/2002 18:49'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok := false.	string := paragraph text string.	stop := self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop := stop - 1].	sep := stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok := true. sep := sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!Integer methodsFor: 'private' stamp: ''!copyto: x	| stop |	stop := self digitLength min: x digitLength.	^ x replaceFrom: 1 to: stop with: self startingAt: 1! !!ContextPart methodsFor: 'system simulation' stamp: 'hmm 7/30/2001 20:48'!stepToSendOrReturn	"Simulate the execution of bytecodes until either sending a message or 	returning a value to the receiver (that is, until switching contexts)."	| ctxt |	[self willReallySend | self willReturn | self willStore]		whileFalse: [			ctxt := self step.			ctxt == self ifFalse: [self halt. 				"Caused by mustBeBoolean handling"				^ctxt]]! !!Object methodsFor: 'printing' stamp: 'tk 5/7/1999 16:20'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString := String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!ContextPart class methodsFor: 'examples' stamp: 'sma 4/22/2000 17:05'!trace: aBlock onFileNamed: fileName		"ContextPart trace: [3 factorial] onFileNamed: 'trace'"	"This method uses the simulator to print calls to a file."	| aStream |	^ [aStream := FileStream fileNamed: fileName.		self trace: aBlock on: aStream] ensure: [aStream close]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'sd 3/28/2003 15:06'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level 	"Walk the tree of subclasses, giving the class and its level"	| subclassNames |	classAndLevelBlock value: self value: level.	self == Class ifTrue:  [^ self].  "Don't visit all the metaclasses"	"Visit subclasses in alphabetical order"	subclassNames := SortedCollection new.	self subclassesDo: [:subC | subclassNames add: subC name].	subclassNames do:		[:name | (self environment at: name)			allSubclassesWithLevelDo: classAndLevelBlock			startingLevel: level+1]! !!Monitor methodsFor: 'initialize-release' stamp: 'NS 4/13/2004 16:12'!initialize	mutex := Semaphore forMutualExclusion.	queuesMutex := Semaphore forMutualExclusion.	nestingLevel := 0.! !!Object methodsFor: 'dependents access' stamp: 'ar 2/11/2001 01:55'!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents := self dependents.	(dependents includes: anObject) ifFalse:		[self myDependents: (dependents copyWithDependent: anObject)].	^ anObject! !!EventSensor methodsFor: 'private' stamp: 'JMM 11/7/2005 14:38'!primKbdNext	"Allows for use of old Sensor protocol to get at the keyboard,	as when running kbdTest or the InterpreterSimulator in Morphic"	| evtBuf |	self wait2ms.	self fetchMoreEvents.	keyboardBuffer isEmpty ifFalse:[^ keyboardBuffer next].	eventQueue ifNotNil:		[evtBuf := eventQueue nextOrNilSuchThat: [:buf | self isKbdEvent: buf].		self flushNonKbdEvents].	^ evtBuf ifNotNil: [evtBuf at: 3]! !!MethodDictionary methodsFor: 'accessing' stamp: ''!at: key ifAbsent: aBlock	| index |	index := self findElementOrNil: key.	(self basicAt: index) == nil ifTrue: [ ^ aBlock value ].	^ array at: index! !!Delay class methodsFor: 'example' stamp: 'jm 9/11/97 11:23'!testDelayOf: delay for: testCount rect: r	"Delay testDelayOf: 100 for: 20 rect: (10@10 extent: 30@30).	 Delay testDelayOf: 400 for: 20 rect: (50@10 extent: 30@30)."	| onDelay offDelay |	onDelay := Delay forMilliseconds: 50.	offDelay := Delay forMilliseconds: delay - 50.	Display fillBlack: r.	[1 to: testCount do: [:i |		Display fillWhite: r.		onDelay wait.		Display reverse: r.		offDelay wait].	] forkAt: Processor userInterruptPriority.! !!ParagraphEditor methodsFor: 'undo support' stamp: ''!undoMessage: aMessage forRedo: aBoolean	"Call this from an undoer/redoer to set up UndoMessage as the	 corresponding redoer/undoer.  Also set up UndoParagraph, as well	 as the state variable Undone.  It is assumed that UndoInterval has been	 established (generally by zapSelectionWith:) and that UndoSelection has been	 saved (generally by replaceSelectionWith: or replace:With:and:)."	self isDoing ifTrue: [UndoParagraph := paragraph].	UndoMessage := aMessage.	Undone := aBoolean! !!ParagraphEditor methodsFor: 'accessing-selection' stamp: 'th 10/21/2003 15:49'!markBlock: aCharacterBlock	stopBlock := aCharacterBlock.! !!Behavior methodsFor: 'obsolete subclasses' stamp: 'apb 7/12/2004 23:13'!addObsoleteSubclass: aClass	"Weakly remember that aClass was a subclass of the receiver and is now obsolete"	| obs |	obs := ObsoleteSubclasses at: self ifAbsent:[WeakArray new].	(obs includes: aClass) ifTrue:[^self].	obs := obs copyWithout: nil.	obs := obs copyWith: aClass.	ObsoleteSubclasses at: self put: obs.! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/18/2001 22:45'!const	| const |	"See if (^ constant) is the answer"	"quick test"	((const := answers at: 1) closeTo: (answers at: 2)) ifFalse: [^ false].	3 to: answers size do: [:ii | (const closeTo: (answers at: ii)) ifFalse: [^ false]].	expressions add: '^ ', const printString.	selector add: #yourself.	^ true! !!Behavior methodsFor: 'private' stamp: 'sd 3/28/2003 15:06'!becomeCompactSimplyAt: index	"Make me compact, but don't update the instances.  For importing segments.""Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct := self environment compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	(cct at: index) ifNotNil: [^ self halt: 'compact table slot already in use'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format := format + (index bitShift: 11).	"Caller must convert the instances"! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitXor: n 	"Answer an Integer whose bits are the logical XOR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitXor' module:'LargeIntegers'>	norm := n normalize.	^ self		digitLogic: norm		op: #bitXor:		length: (self digitLength max: norm digitLength)! !!Float methodsFor: 'mathematical functions' stamp: ''!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt := self exponent.	n := Ln2 * expt.	mant := self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x := mant - 1.0.	div := 1.0.	pow := delta := sum := x.	x := x negated.  "x <= 0"	eps := Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta.		"pass two: delta is negative"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Integer methodsFor: 'printing' stamp: 'sw 11/24/1998 14:53'!asStringWithCommas	"123456789 asStringWithCommas"	"-123456789 asStringWithCommas"	| digits |	digits := self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!Class methodsFor: 'class variables' stamp: 'bf 1/12/2006 10:44'!removeClassVarName: aString 	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."	| aSymbol |	aSymbol := aString asSymbol.	(classPool includesKey: aSymbol)		ifFalse: [^self error: aString, ' is not a class variable'].	self withAllSubclasses do:[:subclass |		(Array with: subclass with: subclass class) do:[:classOrMeta |			(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))				isEmpty ifFalse: [					InMidstOfFileinNotification signal ifTrue: [						Transcript cr; show: self name, ' (' , aString , ' is Undeclared) '.						^Undeclared declare: aSymbol from: classPool].					(self confirm: (aString,' is still used in code of class ', classOrMeta name,						'.\Is it okay to move it to Undeclared?') withCRs)						ifTrue:[^Undeclared declare: aSymbol from: classPool]						ifFalse:[^self]]]].	classPool removeKey: aSymbol.	classPool isEmpty ifTrue: [classPool := nil].! !!CompiledMethod methodsFor: 'source code management' stamp: 'yo 3/16/2004 12:23'!getPreambleFrom: aFileStream at: position	|  writeStream |	writeStream := String new writeStream.	position		to: 0		by: -1		do: [:p | 			| c | 			aFileStream position: p.			c := aFileStream basicNext.			c == $!!				ifTrue: [^ writeStream contents reverse]				ifFalse: [writeStream nextPut: c]]! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 19:33'!verbosePrimesUpTo: max do: aBlock	"Integer verbosePrimesUpTo: SmallInteger maxVal" "<- heh, heh"	"Compute primes up to max, but be verbose about it"	| lastTime nowTime |	lastTime := Time millisecondClockValue.	Utilities informUserDuring:[:bar|		bar value:'Computing primes...'.		self primesUpTo: max do:[:prime|			aBlock value: prime.			nowTime := Time millisecondClockValue.			(nowTime - lastTime > 1000) ifTrue:[				lastTime := nowTime.				bar value:'Last prime found: ', prime printString]]].! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:33'!previousWord: position	| string index |	string := paragraph text string.	index := position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index := index - 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index := index - 1].	^ index + 1! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'th 10/21/2003 15:49'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	stopBlock := paragraph defaultCharacterBlock.	self pointBlock: stopBlock copy.	beginTypeInBlock := nil.	UndoInterval := otherInterval := 1 to: 0.	self setEmphasisHere.	selectionShowing := false.	initialText := paragraph text copy! !!Model methodsFor: 'dependents' stamp: 'sma 2/29/2000 19:54'!myDependents: aCollectionOrNil	dependents := aCollectionOrNil! !!ClassDescription methodsFor: 'copying' stamp: 'KR 4/14/2006 16:10'!copyUnobtrusively: sel from: class classified: cat 	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."	| code category |	"Useful when modifying an existing class"	code := class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category := class organization categoryOfElement: sel]				ifFalse: [category := cat].			(self methodDict includesKey: sel)				ifTrue: [].			self compileSilently: code classified: category]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sd 4/16/2003 19:30'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector := self selectedSelector) == nil ifTrue: [^ view flash].	self terminateAndInitializeAround: [self systemNavigation browseAllCallsOn: aSelector]! !!MethodDictionary methodsFor: 'private' stamp: 'di 11/4/97 20:11'!grow 	| newSelf key |	newSelf := self species new: self basicSize.  "This will double the size"	1 to: self basicSize do:		[:i | key := self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:31'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title := self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!ParagraphEditor methodsFor: 'explain' stamp: 'nb 5/6/2003 16:54'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits := Array with: msg.	(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply := ', which is the selector of this very method!!'.			s := '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits := (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole := lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply := '.'.			s := '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes := self systemNavigation allClassesImplementing: whole.	classes size > 12		ifTrue: [classes := 'many classes']		ifFalse: [classes := 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!CompiledMethod methodsFor: 'private' stamp: 'al 2/13/2006 17:44'!markerOrNil	"If I am a marker method, answer the symbol used to mark me.  Otherwise	answer nil.	What is a marker method?  It is method with body like 		'self subclassResponsibility' or '^ self subclassResponsibility' 	used to indicate ('mark') a special property.	Marker methods compile to bytecode like:		9 <70> self		10 <D0> send: <literal 1>		11 <87> pop		12 <78> returnSelf	for the first form, or 		9 <70> self		10 <D0> send: <literal 1>		11 <7C> returnTop	for the second form."	| e |	((e := self endPC) = 19 or: [e = 20]) ifFalse: [^ nil].	(self numLiterals = 3) ifFalse:[^ nil].	(self at: 17) =  16r70 ifFalse:[^ nil].		"push self"	(self at: 18) = 16rD0 ifFalse:[^ nil].		"send <literal 1>"	"If we reach this point, we have a marker method that sends self <literal 1>"	^ self literalAt: 1! !!Categorizer class methodsFor: 'class initialization' stamp: 'NS 4/6/2004 11:48'!initialize	"	self  initialize	"		Default := 'as yet unclassified' asSymbol.	NullCategory := 'no messages' asSymbol.! !!ClassBuilder methodsFor: 'private' stamp: 'ar 2/27/2003 22:56'!privateNewSubclassOf: newSuper from: oldClass	"Create a new meta and non-meta subclass of newSuper using oldClass as template"	"WARNING: This method does not preserve the superclass/subclass invariant!!"	| newSuperMeta oldMeta newMeta |	oldClass ifNil:[^self privateNewSubclassOf: newSuper].	newSuperMeta := newSuper ifNil:[Class] ifNotNil:[newSuper class].	oldMeta := oldClass class.	newMeta := oldMeta clone.	newMeta 		superclass: newSuperMeta		methodDictionary: MethodDictionary new		format: (self computeFormat: oldMeta typeOfClass 					instSize: oldMeta instVarNames size 					forSuper: newSuperMeta					ccIndex: 0);		setInstVarNames: oldMeta instVarNames;		organization: oldMeta organization.	"Recompile the meta class"	oldMeta hasMethods 		ifTrue:[newMeta compileAllFrom: oldMeta].	"Record the meta class change"	self recordClass: oldMeta replacedBy: newMeta.	"And create a new instance"	^newMeta adoptInstance: oldClass from: oldMeta! !!Complex methodsFor: 'arithmetic' stamp: 'mk 1/18/2004 23:31'!+ anObject	"Answer the sum of the receiver and aNumber."	| a b c d newReal newImaginary |	anObject isComplex		ifTrue:			[a := self real.			b := self imaginary.			c := anObject real.			d := anObject imaginary.			newReal := a + c.			newImaginary := b + d.			^ Complex real: newReal imaginary: newImaginary]		ifFalse:			[^ anObject adaptToComplex: self andSend: #+]! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 2/17/2000 22:21'!comeFullyUpOnReload: smartRefStream	"Normally this read-in object is exactly what we want to store.  Try to dock first.  If it is here already, use that one."	| sp |	"Transcript show: 'has ref to: ', url; cr."	(sp := SqueakPageCache pageCache at: page ifAbsent: [nil]) ifNotNil: [		sp isContentsInMemory ifTrue: [^ sp contentsMorph]].	^ self! !!Integer methodsFor: 'system primitives' stamp: ''!replaceFrom: start to: stop with: replacement startingAt: repStart	| j |  "Catches failure if LgInt replace primitive fails"	j := repStart.	start to: stop do:		[:i |		self digitAt: i put: (replacement digitAt: j).		j := j+1]! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 3/1/2001 23:25'!updateInstances: oldInstances from: oldClass isMeta: isMeta	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary. Return the array of old instances (none of which should be pointed to legally by anyone but the array)."	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."	| map variable instSize newInstances |	oldInstances isEmpty ifTrue:[^#()]. "no instances to convert"	isMeta ifTrue: [		oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].		self soleInstance class == self ifTrue:[			^self error:'Metaclasses can only have one instance']].	map := self instVarMappingFrom: oldClass.	variable := self isVariable.	instSize := self instSize.	newInstances := Array new: oldInstances size.	1 to: oldInstances size do:[:i|		newInstances at: i put: (			self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.	^newInstances "which are now old"! !!Float methodsFor: 'printing' stamp: 'tao 4/22/98 11:58'!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[s := s * (fBase raisedToInteger: baseExpEstimate).			exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s / fBase.					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!CompiledMethod methodsFor: 'testing' stamp: 'NS 12/12/2003 15:18'!isAbstract	| marker |	marker := self markerOrNil.	^ marker notNil and: [self class abstractMarkers includes: marker].! !!ParagraphEditor methodsFor: 'explain' stamp: 'nk 6/26/2003 22:02'!explainAnySel: symbol 	"Is this any message selector?"	| list reply |	list := self systemNavigation allClassesImplementing: symbol.	list size = 0 ifTrue: [^nil].	list size < 12		ifTrue: [reply := ' is a message selector which is defined in these classes ' , list printString]		ifFalse: [reply := ' is a message selector which is defined in many classes'].	^'"' , symbol , reply , '."' , '\' withCRs, 'SystemNavigation new browseAllImplementorsOf: #' , symbol! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 7/21/2003 00:29'!tempNames	| byteCount bytes |	self holdsTempNames ifFalse: [		^ (1 to: self numTemps) collect: [:i | 't', i printString]	].	byteCount := self at: self size.	byteCount = 0 ifTrue: [^ Array new].	bytes := (ByteArray new: byteCount)		replaceFrom: 1 to: byteCount with: self 		startingAt: self size - byteCount.	^ (self qDecompress: bytes) findTokens: ' '! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 16:32'!exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil	| lock delay |	queuesMutex 		critical: [lock := anOrderedCollection addLast: Semaphore new].	self exit.	anIntegerOrNil isNil ifTrue: [		lock wait	] ifFalse: [		delay := MonitorDelay signalLock: lock afterMSecs: anIntegerOrNil inMonitor: self queue: anOrderedCollection.		lock wait.		delay unschedule.	].	self enter.! !!ContextPart methodsFor: 'query' stamp: 'md 1/20/2006 16:14'!findSimilarSender	"Return the closest sender with the same method, return nil if none found"	| meth |	meth := self method.	^ self sender findContextSuchThat: [:c | c method == meth]! !!ClassBuilder methodsFor: 'validation' stamp: 'bkv 4/2/2003 17:19'!validateSubclassFormat: newType from: oldClass forSuper: newSuper extra: newInstSize	"Validate the # of instVars and the format of the subclasses"	| deltaSize |	oldClass == nil ifTrue: [^ true]. "No subclasses"	"Compute the # of instvars needed for all subclasses"	deltaSize := newInstSize.	(oldClass notNil)		ifTrue: [deltaSize := deltaSize - oldClass instVarNames size].	(newSuper notNil)		ifTrue: [deltaSize := deltaSize + newSuper instSize].	(oldClass notNil and: [oldClass superclass notNil]) 		ifTrue: [deltaSize := deltaSize - oldClass superclass instSize].	(oldClass == nil)		 ifTrue: [ (deltaSize > 254)					ifTrue: [ self error: 'More than 254 instance variables'.							^ false].				  ^ true].	oldClass withAllSubclassesDo: [:sub |  ( sub instSize + deltaSize > 254 )											ifTrue: [ self error: sub name,' has more than 254 instance variables'.					 								^ false].										"If we get this far, check whether the immediate subclasses of oldClass can keep its layout."               							(newType ~~ #normal) 											ifTrue: [ self validateSubclass: sub canKeepLayoutFrom: oldClass forSubclassFormat: newType ]].	^ true! !!ContextPart methodsFor: 'controlling' stamp: 'di 11/26/1999 19:34'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	| class meth val |	class := superFlag			ifTrue: [(self method literalAt: self method numLiterals) value superclass]			ifFalse: [rcvr class].	meth := class lookupSelector: selector.	meth == nil		ifTrue: [^ self send: #doesNotUnderstand:					to: rcvr					with: (Array with: (Message selector: selector arguments: args))					super: superFlag]		ifFalse: [val := self tryPrimitiveFor: meth						receiver: rcvr						args: args.				val == PrimitiveFailToken ifFalse: [^ val].				(selector == #doesNotUnderstand: and: [class == ProtoObject]) ifTrue:					[^ self error: 'Simulated message ' , (args at: 1) selector									, ' not understood'].				^ self activateMethod: meth					withArgs: args					receiver: rcvr					class: class]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 7/13/2006 16:00'!prettyPrint: decorated	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageCategoryName ifNil: [^ view flash].	selectedClass := model selectedClassOrMetaClass.	newText := selectedClass prettyPrinterClass		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!Metaclass methodsFor: 'instance variables' stamp: ''!addInstVarName: aString 	"Add the argument, aString, as one of the receiver's instance variables."	| fullString |	fullString := aString.	self instVarNames do: [:aString2 | fullString := aString2 , ' ' , fullString].	self instanceVariableNames: fullString! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'th 9/19/2002 17:34'!simulatedBackspace	"Backspace over the last character, derived from hand-char recognition.  2/5/96 sw"	| startIndex |	startIndex := self markIndex + (self hasSelection ifTrue: [1] ifFalse: [0]).	startIndex := 1 max: startIndex - 1.	self backTo: startIndex.	^ false! !!Class methodsFor: 'instance variables' stamp: 'al 9/3/2004 14:25'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString := ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString := newInstVarString , ' ' , varName].	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: self superclass		type: self typeOfClass		instanceVariableNames: newInstVarString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!BlockContext methodsFor: 'scheduling' stamp: 'jm 11/9/1998 10:16'!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	| forkedProcess |	forkedProcess := self newProcess.	forkedProcess priority: priority.	^ forkedProcess resume! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'dgd 10/4/2004 13:53'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap |	"shift-command and control shortcuts"	cmdMap := Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.				"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.				"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.				"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.				"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.				"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	"triplet = {character. comment selector. novice appropiated}"	#(		($a		argAdvance:						false)		($b		browseItHere:					false)		($c		compareToClipboard:			false)		($d		duplicate:							true)		($e		methodStringsContainingIt:	false)		($f		displayIfFalse:					false)		($g		fileItIn:							false)		($h		cursorTopHome:					true)		($i		exploreIt:							false)		($j		doAgainMany:					true)		($k		changeStyle:						true)		($l		outdent:							true)		($m	selectCurrentTypeIn:			true)		($n		referencesToIt:					false)		($p		makeProjectLink:				true)		($r		indent:							true)		($s		search:							true)		($t		displayIfTrue:					false)		($u		changeLfToCr:					false)		($v		pasteInitials:						false)		($w	methodNamesContainingIt:	false)		($x		makeLowercase:					true)		($y		makeUppercase:					true)		($z		makeCapitalized:				true)	)		select:[:triplet | Preferences noviceMode not or:[triplet third]]		thenDo:[:triplet |			cmdMap at: (triplet first asciiValue         + 1) put: triplet second.		"plain keys"			cmdMap at: (triplet first asciiValue - 32 + 1) put: triplet second.		"shifted keys"			cmdMap at: (triplet first asciiValue - 96 + 1) put: triplet second.		"ctrl keys"		].	ShiftCmdActions := cmdMap! !!InstructionStream methodsFor: 'testing' stamp: 'ajh 8/13/2002 11:10'!willJump	"unconditionally"	| byte |	byte := self method at: pc.	^ (byte between: 144 and: 151) or: [byte between: 160 and: 167]! !!Number methodsFor: 'printing' stamp: 'sw 6/29/1999 21:10'!isOrAreStringWith: aNoun	| result |	result := self = 1		ifTrue:			[' is one ']		ifFalse:			[self = 0				ifTrue:					[' are no ']				ifFalse:					[' are ', self printString, ' ']].	result := result, aNoun.	self = 1 ifFalse: [result := result, 's'].	^ result"#(0 1 2 98.6) do:	[:num | Transcript cr; show: 'There', (num isOrAreStringWith: 'way'), ' to skin a cat']"! !!MethodDictionary methodsFor: 'private' stamp: 'raa 5/30/2001 15:02'!growNoBecome 	| newSelf key |	newSelf := self species new: self basicSize.  "This will double the size"	1 to: self basicSize do:		[:i | key := self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	^newSelf! !!Process methodsFor: 'accessing' stamp: ''!offList	"Inform the receiver that it has been taken off a list that it was 	suspended on. This is to break a backpointer."	myList := nil! !!BlockContext methodsFor: 'controlling' stamp: 'ls 9/24/1999 09:45'!repeatWithGCIf: testBlock	| ans |	"run the receiver, and if testBlock returns true, garbage collect and run the receiver again"	ans := self value.	(testBlock value: ans) ifTrue: [ Smalltalk garbageCollect. ans := self value ].	^ans! !!Process class methodsFor: 'instance creation' stamp: ''!forContext: aContext priority: anInteger 	"Answer an instance of me that has suspended aContext at priority 	anInteger."	| newProcess |	newProcess := self new.	newProcess suspendedContext: aContext.	newProcess priority: anInteger.	^newProcess! !!Float methodsFor: 'mathematical functions' stamp: ''!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum := delta := self.	self2 := 0.0 - (self * self).	i := 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta.		"twice"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta].	^ sum! !!Behavior methodsFor: 'user interface' stamp: 'al 11/28/2005 21:58'!unreferencedInstanceVariables	"Return a list of the instance variables defined in the receiver which are not referenced in the receiver or any of its subclasses.  2/26/96 sw"	| any |	^ self instVarNames copy reject:		[:ivn | any := false.		self withAllSubclasses do:			[:class |  (class whichSelectorsAccess: ivn) do: 					[:sel | sel isDoIt ifFalse: [any := true]]].		any]"Ob unreferencedInstanceVariables"! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'th 9/19/2002 18:00'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars := self selection) size == 0		ifTrue:			[currentSelection := self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size == 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection := self pointIndex - 1]].	aString := self selection string.	self replaceSelectionWith: (Text string: aString reversed emphasis: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!CompiledMethod methodsFor: 'literals' stamp: 'ar 4/10/2005 22:16'!literalStrings	| lits litStrs |	lits := self literals.	litStrs := OrderedCollection new: lits size * 3.	self literals do:		[:lit | 		(lit isVariableBinding)			ifTrue: [litStrs addLast: lit key]			ifFalse: [(lit isSymbol)				ifTrue: [litStrs addAll: lit keywords]				ifFalse: [litStrs addLast: lit printString]]].	^ litStrs! !!ContextPart methodsFor: 'query' stamp: 'md 1/20/2006 16:15'!findSecondToOldestSimilarSender	"Search the stack for the second-to-oldest occurance of self's method.  Very useful for an infinite recursion.  Gets back to the second call so you can see one complete recursion cycle, and how it was called at the beginning."	| sec ctxt bot |	sec := self.	ctxt := self.	[	bot := ctxt findSimilarSender.		bot isNil	] whileFalse: [		sec := ctxt.		ctxt := bot.	].	^ sec! !!ClassBuilder methodsFor: 'class format' stamp: 'ar 7/11/1999 06:39'!format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak	"Compute the format for the given instance specfication."	| cClass instSpec sizeHiBits fmt |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits := (nInstVars+1) // 64.	cClass := 0.  "for now"	instSpec := isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	fmt := sizeHiBits.	fmt := (fmt bitShift: 5) + cClass.	fmt := (fmt bitShift: 4) + instSpec.	fmt := (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	fmt := (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"	^fmt! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!sortCategories	| privateCategories publicCategories newCategories |	privateCategories := self categories select:		[:one | (one findString: 'private' startingAt: 1 caseSensitive: false) = 1].	publicCategories := self categories copyWithoutAll: privateCategories.	newCategories := publicCategories asSortedCollection asOrderedCollection		addAll: privateCategories asSortedCollection;		asArray.	self categories: newCategories! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 5/4/1999 20:19'!testRandom	"verify that the methods allowed don't crash the system.  Pick 3 or 4 from a mixed list of the fundamental types." | objects other aa cnt take tuple fName sss |objects := #((1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')	(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).objects := objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.	{Point class. SmallInteger class. Association class. Array class}.	"{ 4 blocks }."	{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.	{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.	{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.	{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 		#($a 3 d) asOrderedCollection. #() asOrderedCollection}.	{3->true. 5.6->$a. #x->2. 'abcd'->false}.	{9@3 extent: 5@4. 0@0 extent: 45@9. -3@-7 extent: 2@2. 4@4 extent: 16@16}.	{Color red.  Color blue. Color black. Color gray}}.self test2: objects."rec+0, rec+1, rec+2, rec+3 need to be tested.  " fName := (FileDirectory default fileNamesMatching: '*.ran') first.sss := fName splitInteger first.(Collection classPool at: #RandomForPicking) seed: sss.cnt := 0.[take := #(3 4) atRandom.	tuple := (1 to: take) collect: [:ind | (objects atRandom) atRandom].	other := (1 to: take) collect: [:ind | (objects atRandom) atRandom].	self load: (aa := Array with: tuple with: 1 with: other with: 7).	((cnt := cnt+1) \\ 10 = 0) " | (cnt > Skip)" ifTrue: [		Transcript cr; show: cnt printString; tab; tab; show: aa first printString].	cnt > (Smalltalk at: #StopHere) ifTrue: [self halt].		"stop just before crash"	cnt > (Smalltalk at: #Skip) ifTrue: ["skip this many at start"		self search: true.		self test2: aa first.  self test2: (aa at: 3).		"self test2: objects"		].	true] whileTrue.	! !!ClassDescription methodsFor: 'instance variables' stamp: 'al 11/28/2005 22:16'!chooseInstVarAlphabeticallyThenDo: aBlock	| allVars index |	"Put up a menu of all the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."	allVars := self allInstVarNames asSortedArray.	allVars isEmpty ifTrue: [^ self inform: 'There are noinstance variables'].	index := (UIManager default chooseFrom: allVars lines: #() title: 'Instance variables in', self name).	index = 0 ifTrue: [^ self].	aBlock value: (allVars at: index)! !!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'NS 5/8/2002 10:55'!cleanupClassHierarchyFor: aClassDescription		| myName mySuperclass |	mySuperclass := aClassDescription superclass.	(self isReallyObsolete: aClassDescription) ifTrue: [				"Remove class >>>from SystemDictionary if it is obsolete"		myName := aClassDescription name asString.		Smalltalk keys asArray do: [:each | 			(each asString = myName and: [(Smalltalk at: each) == aClassDescription])				ifTrue: [Smalltalk removeKey: each]].		"Make class officially obsolete if it is not"		(aClassDescription name asString beginsWith: 'AnObsolete')			ifFalse: [aClassDescription obsolete].		aClassDescription isObsolete 			ifFalse: [self error: 'Something wrong!!'].		"Add class to obsoleteSubclasses of its superclass"		mySuperclass			ifNil: [self error: 'Obsolete subclasses of nil cannot be stored'].		(mySuperclass obsoleteSubclasses includes: aClassDescription)			ifFalse: [mySuperclass addObsoleteSubclass: aClassDescription].	] ifFalse:[		"check if superclass has aClassDescription in its obsolete subclasses"		mySuperclass ifNil:[mySuperclass := Class]. "nil subclasses"		mySuperclass removeObsoleteSubclass: aClassDescription.	].	"And remove its obsolete subclasses if not actual superclass"	aClassDescription obsoleteSubclasses do:[:obs|		obs superclass == aClassDescription ifFalse:[			aClassDescription removeObsoleteSubclass: obs]].! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'bf 12/17/2005 00:04'!fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org sels |	(org := self organization) categories do: 		[:cat | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		((cat beginsWith: '*') and: [cat endsWith: '-override'])			ifTrue: [				sels do:					[:sel |  self printMethodChunkHistorically: sel on: aFileStream						moveSource: moveSource toFile: fileIndex]]			ifFalse: [				sels do:					[:sel |  self printMethodChunk: sel withPreamble: true on: aFileStream						moveSource: moveSource toFile: fileIndex]]]! !!Object class methodsFor: 'instance creation' stamp: 'nk 8/30/2004 07:57'!readFrom: textStringOrStream	"Create an object based on the contents of textStringOrStream."	| object |	(Compiler couldEvaluate: textStringOrStream)		ifFalse: [^ self error: 'expected String, Stream, or Text'].	object := Compiler evaluate: textStringOrStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'SqR 8/3/2000 13:29'!hashMultiply	| low |	low := self bitAnd: 16383.	^(16r260D * low + ((16r260D * (self bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384))			bitAnd: 16r0FFFFFFF! !!Object methodsFor: 'private' stamp: 'ar 2/6/2004 14:47'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	| context |	(String		streamContents: 			[:s |			s nextPutAll: '***System error handling failed***'.			s cr; nextPutAll: aString.			context := thisContext sender sender.			20 timesRepeat: [context == nil ifFalse: [s cr; print: (context := context sender)]].			s cr; nextPutAll: '-------------------------------'.			s cr; nextPutAll: 'Type CR to enter an emergency evaluator.'.			s cr; nextPutAll: 'Type any other character to restart.'])		displayAt: 0 @ 0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard = Character cr ifTrue: [Transcripter emergencyEvaluator].	Smalltalk isMorphic		ifTrue: [World install "init hands and redisplay"]		ifFalse: [ScheduledControllers searchForActiveController]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'ab 3/23/2005 16:49'!tallySelection	"Treat the current selection as an expression; evaluate it and return the time took for this evaluation"	| result rcvr ctxt cm v valueAsString |	self lineSelectAndEmptyCheck: [^ -1].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr := model doItReceiver.				ctxt := model doItContext]		ifFalse: [rcvr := ctxt := nil].	result := [		cm := rcvr class evaluatorClass new 			compiledMethodFor: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: false.		Time millisecondsToRun: 			[v := cm valueWithReceiver: rcvr arguments: (Array with: ctxt)].	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	"We do not want to have large result displayed"	valueAsString := v printString.	(valueAsString size > 30) ifTrue: [valueAsString := (valueAsString copyFrom: 1 to: 30), '...'].	PopUpMenu 		inform: 'Time to compile and execute: ', result printString, 'ms res: ', valueAsString.! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'NS 12/12/2003 15:03'!newFrom: aCompiledMethod	| inst |	inst := super basicNew: aCompiledMethod size.	1 to: aCompiledMethod size do: [:index |		inst at: index put: (aCompiledMethod at: index)].	^ inst.! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'NS 12/12/2003 15:57'!allSelectors	"Answer all selectors understood by instances of the receiver"	| coll |	coll := OrderedCollection new.	self withAllSuperclasses do:		[:aClass | coll addAll: aClass selectors].	^ coll asIdentitySet! !!Object methodsFor: 'user interface' stamp: 'RAA 7/10/2000 08:11'!eToyStreamedRepresentationNotifying: aWidget	| outData |	[ outData := SmartRefStream streamedRepresentationOf: self ] 		on: ProgressInitiationException		do: [ :ex | 			ex sendNotificationsTo: [ :min :max :curr |				aWidget ifNotNil: [aWidget flashIndicator: #working].			].		].	^outData! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'sw 5/21/2001 22:51'!inspectAllInstances 	"Inpsect all instances of the receiver.  1/26/96 sw"	| all allSize prefix |	all := self allInstances.	(allSize := all size) == 0 ifTrue: [^ self inform: 'There are no instances of ', self name].	prefix := allSize == 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name)! !!BlockContext methodsFor: 'accessing' stamp: 'di 9/9/2000 10:44'!copyForSaving	"Fix the values of the temporary variables used in the block that are 	ordinarily shared with the method in which the block is defined."	home := home copy.	home swapSender: nil! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:41'!digitAdd: arg 	| len arglen accum sum |	<primitive: 'primDigitAdd' module:'LargeIntegers'>	accum := 0.	(len := self digitLength) < (arglen := arg digitLength) ifTrue: [len := arglen].	"Open code max: for speed"	sum := Integer new: len neg: self negative.	1 to: len do: 		[:i | 		accum := (accum bitShift: -8)					+ (self digitAt: i) + (arg digitAt: i).		sum digitAt: i put: (accum bitAnd: 255)].	accum > 255		ifTrue: 			[sum := sum growby: 1.			sum at: sum digitLength put: (accum bitShift: -8)].	^ sum! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:43'!digitCompare: arg 	"Compare the magnitude of self with that of arg.   	Return a code of 1, 0, -1 for self >, = , < arg"	| len arglen argDigit selfDigit |	<primitive: 'primDigitCompare' module:'LargeIntegers'>	len := self digitLength.	(arglen := arg digitLength) ~= len		ifTrue: [arglen > len				ifTrue: [^ -1]				ifFalse: [^ 1]].	[len > 0]		whileTrue: 			[(argDigit := arg digitAt: len) ~= (selfDigit := self digitAt: len)				ifTrue: [argDigit < selfDigit						ifTrue: [^ 1]						ifFalse: [^ -1]].			len := len - 1].	^ 0! !!ContextPart methodsFor: 'debugger access' stamp: 'ajh 1/24/2003 00:03'!singleRelease	"Remove information from the receiver in order to break circularities."	stackp == nil ifFalse: [1 to: stackp do: [:i | self at: i put: nil]].	sender := nil.	pc := nil.! !!ObjectTracer methodsFor: 'very few messages' stamp: ''!xxxViewedObject: anObject	"This message name must not clash with any other (natch)."	tracedObject := anObject! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'jm 5/3/1998 19:19'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling."	initialText := paragraph text copy.! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!categories: anArray 	"Reorder my categories to be in order of the argument, anArray. If the 	resulting organization does not include all elements, then give an error."	| newCategories newStops newElements catName list runningTotal | 	newCategories := Array new: anArray size.	newStops := Array new: anArray size.	newElements := Array new: 0.	runningTotal := 0.	1 to: anArray size do:		[:i |		catName := (anArray at: i) asSymbol.		list := self listAtCategoryNamed: catName.				newElements := newElements, list.				newCategories at: i put: catName.				newStops at: i put: (runningTotal := runningTotal + list size)].	elementArray do:		[:element | "check to be sure all elements are included"		(newElements includes: element)			ifFalse: [^self error: 'New categories must match old ones']].	"Everything is good, now update my three arrays."	categoryArray := newCategories.	categoryStops := newStops.	elementArray := newElements! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!numberOfCategoryOfElement: element 	"Answer the index of the category with which the argument, element, is 	associated."	| categoryIndex elementIndex |	categoryIndex := 1.	elementIndex := 0.	[(elementIndex := elementIndex + 1) <= elementArray size]		whileTrue: 			["point to correct category"			[elementIndex > (categoryStops at: categoryIndex)]				whileTrue: [categoryIndex := categoryIndex + 1].			"see if this is element"			element = (elementArray at: elementIndex) ifTrue: [^categoryIndex]].	^0! !!Behavior methodsFor: 'user interface' stamp: 'md 8/27/2005 17:17'!allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	| any definingClass |	^ self allInstVarNames copy reject:		[:ivn | any := false.		definingClass := self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses do:			[:class |  any ifFalse:				[(class whichSelectorsAccess: ivn asSymbol) do: 					[:sel | sel isDoIt ifFalse: [any := true]]]].			any]! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 7/20/2009 00:14'!valueSuppressingMessages: aListOfStrings	^ self		valueSuppressingMessages: aListOfStrings		supplyingAnswers: #()! !!ObjectOut methodsFor: 'fetch from disk' stamp: 'tk 11/16/1998 09:57'!xxxFetch	"Bring in my object and replace all references to me with references to him.  First try looking up my url in the pageCache.  Then try the page (and install it, under its url).  Then start from scratch with the url."	| truePage object existing |	existing := SqueakPageCache pageCache at: url ifAbsent: [nil].	existing ifNotNil: [existing isContentsInMemory		ifTrue: [page := truePage := existing]].	"This url already has an object in this image"	truePage ifNil: [		truePage := SqueakPageCache atURL: url oldPage: page].	object := truePage isContentsInMemory 		ifTrue: [truePage contentsMorph]		ifFalse: [truePage fetchInformIfError].	"contents, not the page"			"Later, collect pointers to object and fix them up.  Not scan memory"	object ifNil: [^ 'Object could not be fetched.'].	"recursionFlag := false."  	"while I still have a pointer to myself"	truePage contentsMorph: object.	page := truePage.	self xxxFixup.	^ object	"the final object!!" ! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/15/1999 17:04'!setInstVarNames: instVarArray	"Private - for class initialization only"	| required |	required := self instSize.	superclass notNil ifTrue:[required := required - superclass instSize].	instVarArray size = required		ifFalse:[^self error: required printString, ' instvar names are required'].	instVarArray isEmpty		ifTrue:[instanceVariables := nil]		ifFalse:[instanceVariables := instVarArray asArray].! !!CompiledMethod methodsFor: 'file in/out' stamp: 'tk 3/26/98 09:10'!storeDataOn: aDataStream	"Store myself on a DataStream.  I am a mixture of objects and raw data bytes.  Only use this for blocks.  Normal methodDictionaries should not be put out using ReferenceStreams.  Their fileOut should be attached to the beginning of the file."	| byteLength lits |	"No inst vars of the normal type"	byteLength := self basicSize.	aDataStream		beginInstance: self class		size: byteLength.	lits := self numLiterals + 1.	"counting header"	1 to: lits do:		[:ii | aDataStream nextPut: (self objectAt: ii)].	lits*4+1 to: byteLength do:		[:ii | aDataStream byteStream nextPut: (self basicAt: ii)].			"write bytes straight through to the file"! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 07:29'!valuesDo: aBlock 	| value |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (value := array at: i) == nil			ifFalse: [aBlock value: value]]! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 5/4/1999 20:18'!testFromTuple: nth	"verify that the methods allowed don't crash the system.  Try N of each of the fundamental types.  up to 4 of each kind." | objects nonRepeating even other aa cnt |objects := #((1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')	(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).objects := objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.	{Point class. SmallInteger class. Association class. Array class}.	"{ 4 blocks }."	{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.	{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.	{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.	{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 		#($a 3 d) asOrderedCollection. #() asOrderedCollection}.	{3->true. 5.6->$a. #x->2. 'abcd'->false}.	{9@3 extent: 5@4. 0@0 extent: 45@9. -3@-7 extent: 2@2. 4@4 extent: 16@16}.	{Color red.  Color blue. Color black. Color gray}}.self test2: objects."rec+0, rec+1, rec+2, rec+3 need to be tested.  " cnt := 0.nth to: 4 do: [:take |	nonRepeating := OrderedCollection new.	objects do: [:each |		nonRepeating addAll: (each copyFrom: 1 to: take)].	"all combinations of take, from nonRepeating"	even := true.	nonRepeating combinations: take atATimeDo: [:tuple |		even ifTrue: [other := tuple clone]			ifFalse: [self load: (aa := Array with: tuple with: 1 with: other with: 7).				(cnt := cnt+1) \\ 50 = 0 ifTrue: [					Transcript cr; show: aa first printString].				self search: true.				self test2: aa.				self test2: nonRepeating.				"self test2: objects"].		even := even not].	].! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:55'!subclasses	"Return all the subclasses of nil"	| classList |	classList := WriteStream on: Array new.	self subclassesDo:[:class| classList nextPut: class].	^classList contents! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 1/21/2003 17:59'!unwindTo: aContext	| ctx unwindBlock |	ctx := self.	[(ctx := ctx findNextUnwindContextUpTo: aContext) isNil] whileFalse: [		unwindBlock := ctx tempAt: 1.		unwindBlock == nil ifFalse: [			ctx tempAt: 1 put: nil.			unwindBlock value]	].! !!Object methodsFor: 'copying' stamp: 'ajh 5/23/2002 00:38'!copySameFrom: otherObject	"Copy to myself all instance variables named the same in otherObject.	This ignores otherObject's control over its own inst vars."	| myInstVars otherInstVars match |	myInstVars := self class allInstVarNames.	otherInstVars := otherObject class allInstVarNames.	myInstVars doWithIndex: [:each :index |		(match := otherInstVars indexOf: each) > 0 ifTrue:			[self instVarAt: index put: (otherObject instVarAt: match)]].	1 to: (self basicSize min: otherObject basicSize) do: [:i |		self basicAt: i put: (otherObject basicAt: i)].! !!CompiledMethod methodsFor: 'source code management' stamp: 'tk 12/12/97 13:03'!getSourceFromFile	"Read the source code from file, determining source file index and	file position from the last 3 bytes of this method."	| position |	(position := self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: position)			text! !!Delay class methodsFor: 'testing' stamp: 'tpr 10/3/2005 17:26'!primSignal: aSemaphore atMilliseconds: aSmallInteger	"Signal the semaphore when the millisecond clock reaches the value of the second argument. Fail if the first argument is neither a Semaphore nor nil. Essential. See Object documentation whatIsAPrimitive."	| guardianDelay |	<primitive: 136>	"VM code actually only fails if the time parameter is not a SmallInteger value"	aSmallInteger isInteger ifFalse:["somebody messed up badly and we can't do much about it"		aSemaphore ifNotNil: [			ActiveDelay := nil.			aSemaphore signal. "Prevent an image crash"].	^self primitiveError: 'primSignal:atMilliseconds: failed because of a non-Integer resumption time parameter. The Semaphore has been signalled as a best guess of the right thing to do'].	"So now we feel fairly sure that the aSmallInteger resumption time is actually a large integer and we need to just wait some more. To make the system do that we need a fake Delay and a reasonable resumption time to feed to the VM. A decent value is SmallInteger maxVal since the VM handles correlating that sort of largish value and clock wrapping.	First though we return the problem Delay to the queue"	SuspendedDelays add: ActiveDelay.	"Now we want a Delay set to fire and do nothing"	guardianDelay := self guardianDelay.	guardianDelay activate	! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 14:02'!bitShiftMagnitude: shiftCount 	"Answer an Integer whose value (in magnitude representation) is  	the receiver's value (in magnitude representation) shifted left by  	the number of bits indicated by the argument. Negative arguments	shift right. Zeros are shifted in from the right in left shifts."	| rShift |	<primitive: 'primDigitBitShiftMagnitude' module:'LargeIntegers'>	shiftCount >= 0 ifTrue: [^ self digitLshift: shiftCount].	rShift := 0 - shiftCount.	^ (self		digitRshift: (rShift bitAnd: 7)		bytes: (rShift bitShift: -3)		lookfirst: self digitLength) normalize! !!ContextPart methodsFor: 'debugger access' stamp: ''!releaseTo: caller 	"Remove information from the receiver and the contexts on its sender 	chain up to caller in order to break circularities."	| c s |	c := self.	[c == nil or: [c == caller]]		whileFalse: 			[s := c sender.			c singleRelease.			c := s]! !!Object methodsFor: 'copying' stamp: 'tk 3/11/2003 13:58'!veryDeepCopySibling	"Do a complete tree copy using a dictionary.  Substitute a clone of oldPlayer for the root.  Normally, a Player or non systemDefined object would have a new class.  We do not want one this time.  An object in the tree twice, is only copied once.  All references to the object in the copy of the tree will point to the new copy."	| copier new |	copier := DeepCopier new initialize: self initialDeepCopierSize.	copier newUniClasses: false.	new := self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	copier fixDependents.	^ new! !!Model methodsFor: 'copying' stamp: 'tk 10/21/2002 12:59'!veryDeepFixupWith: deepCopier 	"See if the dependents are being copied also.  If so, point at the new copies.  (The dependent has self as its model.)	Dependents handled in class Object, when the model is not a Model, are fixed up in Object veryDeepCopy."	| originalDependents refs newDependent |	super veryDeepFixupWith: deepCopier.	originalDependents := dependents.	originalDependents ifNil: [		^self.		].	dependents := nil.	refs := deepCopier references.	originalDependents		do: [:originalDependent | 			newDependent := refs						at: originalDependent						ifAbsent: [].			newDependent				ifNotNil: [self addDependent: newDependent]]! !!ContextPart methodsFor: 'controlling' stamp: 'ajh 3/25/2004 00:07'!jump	"Abandon thisContext and resume self instead (using the same current process).  You may want to save thisContext's sender before calling this so you can jump back to it.	Self MUST BE a top context (ie. a suspended context or a abandoned context that was jumped out of).  A top context already has its return value on its stack (see Interpreter>>primitiveSuspend and other suspending primitives).	thisContext's sender is converted to a top context (by pushing a nil return value on its stack) so it can be jump back to."	| top |	"Make abandoned context a top context (has return value (nil)) so it can be jumped back to"	thisContext sender push: nil.	"Pop self return value then return it to self (since we jump to self by returning to it)"	stackp = 0 ifTrue: [self stepToSendOrReturn].	stackp = 0 ifTrue: [self push: nil].  "must be quick return self/constant"	top := self pop.	thisContext privSender: self.	^ top! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock := nil! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 7/20/2009 00:14'!valueSupplyingAnswers: aListOfPairs	"evaluate the block using a list of questions / answers that might be called upon to	automatically respond to Object>>confirm: or FillInTheBlank requests"	^ [self value] 		on: ProvideAnswerNotification		do: 			[:notify | | answer caption |						caption := notify messageText withSeparatorsCompacted. "to remove new lines"			answer := aListOfPairs				detect: 					[:each | caption = each first or:						[caption includesSubstring: each first caseSensitive: false] or:						[each first match: caption]]					ifNone: [nil].			answer				ifNotNil: [notify resume: answer second]				ifNil: 					[ | outerAnswer |					outerAnswer := ProvideAnswerNotification signal: notify messageText.					outerAnswer 						ifNil: [notify resume] 						ifNotNil: [notify resume: outerAnswer]]]! !!CompiledMethod methodsFor: 'scanning' stamp: 'di 6/25/97 19:08'!scanVeryLongStore: extension offset: offset	"Answer whether the receiver contains a long load with the given offset.	Note that the constant +32 is the known difference between a	store and a storePop for instVars, and it will always fail on literal variables,	but these only use store (followed by pop) anyway."	| scanner ext |	scanner := InstructionStream on: self.	^ scanner scanFor:		[:instr | (instr = 132 and: [(ext := scanner followingByte) = extension											or: ["might be a store/pop into rcvr"												ext = (extension+32)]])							and: [scanner thirdByte = offset]]! !!Number methodsFor: 'truncation and round off' stamp: 'di 2/19/98 21:58'!detentBy: detent atMultiplesOf: grid snap: snap	"Map all values that are within detent/2 of any multiple of grid to that multiple.  Otherwise, if snap is true, return self, meaning that the values in the dead zone will never be returned.  If snap is false, then expand the range between dead zones so that it covers the range between multiples of the grid, and scale the value by that factor."	| r1 r2 |	r1 := self roundTo: grid.  "Nearest multiple of grid"	(self roundTo: detent) = r1 ifTrue: [^ r1].  "Snap to that multiple..."	snap ifTrue: [^ self].  "...or return self"	r2 := self < r1  "Nearest end of dead zone"		ifTrue: [r1 - (detent asFloat/2)]		ifFalse: [r1 + (detent asFloat/2)].	"Scale values between dead zones to fill range between multiples"	^ r1 + ((self - r2) * grid asFloat / (grid - detent))"	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: true] 	(170 to: 190 by: 2) collect: [:a | a detentBy: 10 atMultiplesOf: 90 snap: false]	(3.9 to: 4.1 by: 0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: true] 	(-3.9 to: -4.1 by: -0.02) collect: [:a | a detentBy: 0.1 atMultiplesOf: 1.0 snap: false]"! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:18'!storeDataOn: aDataStream	"Store myself on a DataStream. See also objectToStoreOnDataStream.	must send 'aDataStream beginInstance:size:'"	| cntInstVars |	cntInstVars := self class instSize.	"cntIndexedVars := self basicSize."	aDataStream		beginInstance: self xxxClass		size: cntInstVars "+ cntIndexedVars".	1 to: cntInstVars do:		[:i | aDataStream nextPut: (self xxxInstVarAt: i)]."	1 to: cntIndexedVars do:		[:i | aDataStream nextPut: (self basicAt: i)]"! !!InputSensor methodsFor: 'initialize' stamp: 'nk 4/12/2004 19:45'!shutDown	InterruptWatcherProcess ifNotNil: [		InterruptWatcherProcess terminate.		InterruptWatcherProcess := nil ].! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 7/1/2000 23:11'!cleanInputs: dataAndAnswerString	"Find an remove common mistakes.  Complain when ill formed."| fixed ddd rs places |ddd := dataAndAnswerString.fixed := false.rs := ReadStream on: ddd, ' '.places := OrderedCollection new.[rs upToAll: '#true'.  rs atEnd] whileFalse: [places addFirst: rs position-4]. places do: [:pos | ddd := ddd copyReplaceFrom: pos to: pos with: ''.	fixed := true]. 	"remove #"rs := ReadStream on: ddd.places := OrderedCollection new.[rs upToAll: '#false'.  rs atEnd] whileFalse: [places addFirst: rs position-5]. places do: [:pos | ddd := ddd copyReplaceFrom: pos to: pos with: ''.	fixed := true]. 	"remove #"fixed ifTrue: [self inform: '#(true false) are Symbols, not Booleans.  Next time use { true. false }.'].fixed := false.rs := ReadStream on: ddd.places := OrderedCollection new.[rs upToAll: '#nil'.  rs atEnd] whileFalse: [places addFirst: rs position-3]. places do: [:pos | ddd := ddd copyReplaceFrom: pos to: pos with: ''.	fixed := true]. 	"remove #"fixed ifTrue: [self inform: '#nil is a Symbol, not the authentic UndefinedObject.  Next time use nil instead of #nil'].^ ddd! !!InputSensor class methodsFor: 'public' stamp: 'nk 7/11/2002 07:09'!installDuplicateKeyEntryFor: c	| key |	key := c asInteger.	"first do control->alt key"	KeyDecodeTable at: { key bitAnd: 16r9F . 2 } put: { key . 8 }.	"then alt->alt key"	KeyDecodeTable at: { key . 8 } put: { key . 8 }! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 8/1/97 15:09'!copySelection	"Copy the current selection and store it in the paste buffer, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection := self selection.	self undoer: #undoCutCopy: with: self clipboardText.	UndoInterval := self selectionInterval.	self clipboardTextPut: UndoSelection! !!Integer methodsFor: 'mathematical functions' stamp: 'tk 7/30/97 13:08'!take: kk	"Return the number of combinations of (self) elements taken kk at a time.  For 6 take 3, this is 6*5*4 / (1*2*3).  Zero outside of Pascal's triangle.  Use a trick to go faster."	" 6 take: 3  "	| num denom |	kk < 0 ifTrue: [^ 0].	kk > self ifTrue: [^ 0].	num := 1.	self to: (kk max: self-kk) + 1 by: -1 do: [:factor | num := num * factor].	denom := 1.	1 to: (kk min: self-kk) do: [:factor | denom := denom * factor].	^ num // denom! !!ParagraphEditor methodsFor: 'private' stamp: 'md 2/22/2006 21:17'!setIndices: shiftPressed forward: forward	"Little helper method that sets the moving and fixed indices according to some flags."	| indices |	indices := Dictionary new.	shiftPressed ifTrue: [			indices at: #moving put: self pointIndex.			indices at: #fixed put: self markIndex		] ifFalse: [			forward				ifTrue:[					indices at: #moving put: self stopIndex.					indices at: #fixed put: self startIndex.				] ifFalse: [					indices at: #moving put: self startIndex.					indices at: #fixed put: self stopIndex.				]		].	^indices! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:45'!- anObject	"Answer the difference between the receiver and aNumber."	| a b c d newReal newImaginary |	anObject isComplex		ifTrue:			[a := self real.			b := self imaginary.			c := anObject real.			d := anObject imaginary.			newReal := a - c.			newImaginary := b - d.			^ Complex real: newReal imaginary: newImaginary]		ifFalse:			[^ anObject adaptToComplex: self andSend: #-]! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:25'!waitNoButton	"Wait for the user to release any mouse button and then answer the current location of the cursor."	| delay |	delay := Delay forMilliseconds: 50.	[self anyButtonPressed] whileTrue: [ delay wait].	^self cursorPoint! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 2/17/2005 17:53'!changeAlignment	| aList reply  |	aList := #(leftFlush centered justified rightFlush).	reply := (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ifNil:[^self].	self setAlignment: reply.	paragraph composeAll.	self recomputeSelection.	self mvcRedisplay.	^ true! !!MessageCatcher methodsFor: 'as yet unclassified' stamp: 'ajh 7/7/2004 18:22'!privAccumulator: collection	accumulator := collection! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 15:29'!veryDeepCopyWith: deepCopier	"Copy me and the entire tree of objects I point to.  An object in the tree twice is copied once, and both references point to him.  deepCopier holds a dictionary of objects we have seen.  Some classes refuse to be copied.  Some classes are picky about which fields get deep copied."	| class index sub subAss new absent |	new := deepCopier references at: self ifAbsent: [absent := true].	absent ifNil: [^ new].	"already done"	class := self xxxClass.	class isMeta ifTrue: [^ self].		"a class"	new := self xxxClone.	"not a uniClass"	deepCopier references at: self put: new.	"remember"	"class is not variable"	index := class instSize.	[index > 0] whileTrue: 		[sub := self xxxInstVarAt: index.		(subAss := deepCopier references associationAt: sub ifAbsent: [nil])			ifNil: [new xxxInstVarAt: index put: (sub veryDeepCopyWith: deepCopier)]			ifNotNil: [new xxxInstVarAt: index put: subAss value].		index := index - 1].	new rehash.	"force Sets and Dictionaries to rehash"	^ new! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 1/15/98 12:57'!cancel 	"Restore the text of the paragraph to be the text saved since initialization 	or the last accept.  Undoer & Redoer: undoAndReselect:redoAndReselect:.	This used to call controlTerminate and controlInitialize but this seemed illogical.	Sure enough, nobody overrode them who had cancel in the menu, and if	anybody really cared they could override cancel."	UndoSelection := paragraph text.	self undoer: #undoAndReselect:redoAndReselect: with: self selectionInterval with: (1 to: 0).	view ifNotNil: [view clearInside].	self changeParagraph: (paragraph text: initialText).	UndoParagraph := paragraph.	otherInterval := UndoInterval := 1 to: initialText size. "so undo will replace all"	paragraph displayOn: Display.	self selectAt: 1.	self scrollToTop! !!ClassDescription methodsFor: 'instance variables' stamp: 'al 11/28/2005 11:52'!replaceSilently: old to: new	"text-replace any part of a method.  Used for class and pool variables.  Don't touch the header.  Not guaranteed to work if name appears in odd circumstances"	| oldCode newCode parser header body sels oldName newName |	oldName := old asString.	newName := new asString.	self withAllSubclasses do:		[:cls | sels := cls selectors.		sels removeAllFoundIn: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode := cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser := cls parserClass new) parseSelector: oldCode.			header := oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body := header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode := header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode := cls comment.				newCode := oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!InputSensor class methodsFor: 'class initialization' stamp: 'nk 2/10/2002 11:55'!installMouseDecodeTable	"Create a decode table that swaps the lowest-order 2 bits if 	Preferences swapMouseButtons is set"	ButtonDecodeTable := Preferences swapMouseButtons				ifTrue: [ByteArray withAll:							((0 to: 255) collect: [:ea |								((ea bitAnd: 1) << 1									bitOr: (ea bitAnd: 2) >> 1)										bitOr: (ea bitAnd: 16rFC) ])]				ifFalse: [ByteArray						withAll: (0 to: 255)]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/19/2002 17:40'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin := self startOfTyping.			stop := self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval := begin to: stop - 1].		beginTypeInBlock := nil]! !!ContextPart methodsFor: 'instruction decoding' stamp: ''!jump: distance 	"Simulate the action of a 'unconditional jump' bytecode whose offset is 	the argument, distance."	pc := pc + distance! !!InputSensor methodsFor: 'mouse' stamp: 'nk 3/17/2004 07:22'!waitButton	"Wait for the user to press any mouse button and then answer with the 	current location of the cursor."	| delay |	delay := Delay forMilliseconds: 50.	[self anyButtonPressed] whileFalse: [ delay wait ].	^self cursorPoint! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 5/20/2004 16:25'!theReturnMethod	| meth |	meth := self lookupSelector: #return:.	meth primitive = 0 ifFalse: [^ self error: 'expected #return: to not be a primitive'].	^ meth! !!MethodFinder methodsFor: 'initialize' stamp: 'tk 12/29/2000 13:22'!load: dataWithAnswers	"Find a function that takes the data and gives the answers.  Odd list entries are data for it, even ones are the answers.  nil input means data and answers were supplied already.""  (MethodFinder new) load: #( (4 3) 7  (-10 5) -5  (-3 11) 8);		findMessage  "dataWithAnswers ifNotNil: [	data := Array new: dataWithAnswers size // 2.	1 to: data size do: [:ii | data at: ii put: (dataWithAnswers at: ii*2-1)].	answers := Array new: data size.	1 to: answers size do: [:ii | answers at: ii put: (dataWithAnswers at: ii*2)]].data do: [:list | 	(list isKindOf: SequenceableCollection) ifFalse: [		^ self inform: 'first and third items are not Arrays'].	].argMap := (1 to: data first size) asArray.data do: [:list | list size = argMap size ifFalse: [		self inform: 'data arrays must all be the same size']].argMap size > 4 ifTrue: [self inform: 'No more than a receiver and three arguments allowed'].	"Really only test receiver and three args." thisData := data copy.mapStage := mapList := nil.! !!CompiledMethod methodsFor: 'private' stamp: 'md 8/2/2006 20:25'!replace: oldSelector with: newSelector in: aText	| oldKeywords newKeywords args newSelectorWithArgs startOfSource lastSelectorToken |	oldKeywords := oldSelector keywords.	newKeywords := (newSelector ifNil: [self defaultSelector]) keywords.	self assert: oldKeywords size = newKeywords size.	args := (self methodClass parserClass new		parseArgsAndTemps: aText string notifying: nil) copyFrom: 1 to: self numArgs.	newSelectorWithArgs := String streamContents: [:stream |		newKeywords withIndexDo: [:keyword :index |			stream nextPutAll: keyword.			stream space.			args size >= index ifTrue: [				stream nextPutAll: (args at: index); space]]].	lastSelectorToken := args isEmpty		ifFalse: [args last]		ifTrue: [oldKeywords last].	startOfSource := (aText string		indexOfSubCollection: lastSelectorToken startingAt: 1) + lastSelectorToken size.	^newSelectorWithArgs withBlanksTrimmed asText , (aText copyFrom: startOfSource to: aText size)! !!Float methodsFor: 'truncation and round off' stamp: ''!exponent	"Primitive. Consider the receiver to be represented as a power of two	multiplied by a mantissa (between one and two). Answer with the	SmallInteger to whose power two is raised. Optional. See Object	documentation whatIsAPrimitive."	| positive |	<primitive: 53>	self >= 1.0 ifTrue: [^self floorLog: 2].	self > 0.0		ifTrue: 			[positive := (1.0 / self) exponent.			self = (1.0 / (1.0 timesTwoPower: positive))				ifTrue: [^positive negated]				ifFalse: [^positive negated - 1]].	self = 0.0 ifTrue: [^-1].	^self negated exponent! !!MethodDictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:17'!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value == (array at: index)			ifTrue:				[(theKey := self basicAt: index) == nil					ifFalse: [^ theKey]]].	^ exceptionBlock value! !!Number methodsFor: 'intervals' stamp: 'tao 1/30/1999 08:58'!to: stop by: step do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: step)."	| nextValue |	nextValue := self.	step = 0 ifTrue: [self error: 'step must be non-zero'].	step < 0		ifTrue: [[stop <= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue := nextValue + step]]		ifFalse: [[stop >= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue := nextValue + step]]! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 5/10/1998 21:52'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !!MethodFinder methodsFor: 'search' stamp: 'ar 4/10/2005 22:20'!exceptions	"Handle some very slippery selectors.	asSymbol -- want to be able to produce it, but do not want to make every string submitted into a Symbol!!" 	| aSel |	answers first isSymbol ifFalse: [^ self].	thisData first first isString ifFalse: [^ self].	aSel := #asSymbol.	(self testPerfect: aSel) ifTrue: [		selector add: aSel.		expressions add: (String streamContents: [:strm | 			strm nextPutAll: 'data', argMap first printString.			aSel keywords doWithIndex: [:key :ind |				strm nextPutAll: ' ',key.				(key last == $:) | (key first isLetter not)					ifTrue: [strm nextPutAll: ' data', 						(argMap at: ind+1) printString]]])].! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!classComment: aString 	"Store the comment, aString, associated with the object that refers to the 	receiver."	(aString isKindOf: RemoteString) 		ifTrue: [classComment := aString]		ifFalse: [(aString == nil or: [aString size = 0])			ifTrue: [classComment := nil]			ifFalse: [				self error: 'use aClass classComment:'.				classComment := RemoteString newString: aString onFileNumber: 2]]				"Later add priorSource and date and initials?"! !!Class methodsFor: 'subclass creation' stamp: 'sd 3/28/2003 15:24'!newSubclass	| i className |	i := 1.	[className := (self name , i printString) asSymbol.	 self environment includesKey: className]		whileTrue: [i := i + 1].	^ self subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: Object categoryForUniclasses"Point newSubclass new"! !!Class methodsFor: 'class variables' stamp: 'al 9/3/2004 14:25'!allClassVarNames	"Answer a Set of the names of the receiver's class variables, including those	defined in the superclasses of the receiver."	| aSet |	self superclass == nil		ifTrue: 			[^self classVarNames]  "This is the keys so it is a new Set."		ifFalse: 			[aSet := self superclass allClassVarNames.			aSet addAll: self classVarNames.			^aSet]! !!BlockContext methodsFor: 'scheduling' stamp: 'ajh 10/16/2002 11:14'!forkAndWait	"Suspend current process and execute self in new process, when it completes resume current process"	| semaphore |	semaphore := Semaphore new.	[self ensure: [semaphore signal]] fork.	semaphore wait.! !!Behavior methodsFor: 'accessing instances and variables' stamp: ''!instVarNames	"Answer an Array of the instance variable names. Behaviors must make 	up fake local instance variable names because Behaviors have instance 	variables for the purpose of compiling methods, but these are not named 	instance variables."	| mySize superSize |	mySize := self instSize.	superSize := 		superclass == nil			ifTrue: [0]			ifFalse: [superclass instSize].	mySize = superSize ifTrue: [^#()].		^(superSize + 1 to: mySize) collect: [:i | 'inst' , i printString]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!removeCategory: cat 	"Remove the category named, cat. Create an error notificiation if the 	category has any elements in it."	| index lastStop |	index := categoryArray indexOf: cat ifAbsent: [^self].	lastStop := 		index = 1			ifTrue: [0]			ifFalse: [categoryStops at: index - 1].	(categoryStops at: index) - lastStop > 0 		ifTrue: [^self error: 'cannot remove non-empty category'].	categoryArray := categoryArray copyReplaceFrom: index to: index with: Array new.	categoryStops := categoryStops copyReplaceFrom: index to: index with: Array new.	categoryArray size = 0		ifTrue:			[categoryArray := Array with: Default.			categoryStops := Array with: 0]! !!CompiledMethod methodsFor: 'source code management' stamp: 'ajh 8/13/2002 18:18'!sourceFileStream 	"Answer the sources file stream with position set at the beginning of my source string"	| pos |	(pos := self filePosition) = 0 ifTrue: [^ nil].	^ (RemoteString newFileNumber: self fileIndex position: pos) fileStream! !!ClassBuilder methodsFor: 'class mutation' stamp: 'ar 2/27/2003 23:42'!update: oldClass to: newClass	"Convert oldClass, all its instances and possibly its meta class into newClass, instances of newClass and possibly its meta class. The process is surprisingly simple in its implementation and surprisingly complex in its nuances and potentially bad side effects. 	We can rely on two assumptions (which are critical):		#1: The method #updateInstancesFrom: will not create any lasting pointers to 'old' instances ('old' is quote on quote since #updateInstancesFrom: will do a become of the old vs. the new instances and therefore it will not create pointers to *new* instances before the #become: which are *old* afterwards)		#2: The non-preemptive execution of the critical piece of code guarantees that nobody can get a hold by 'other means' (such as process interruption and reflection) on the old instances.	Given the above two, we know that after #updateInstancesFrom: there are no pointer to any old instances. After the forwarding become there will be no pointers to the old class or meta class either. Meaning that if we throw in a nice fat GC at the end of the critical block, everything will be gone (but see the comment right there). There's no need to worry.	"	| meta |	meta := oldClass isMeta.	"Note: Everything from here on will run without the ability to get interrupted	to prevent any other process to create new instances of the old class."	[		"Note: The following removal may look somewhat obscure and needs an explanation. When we mutate the class hierarchy we create new classes for any existing subclass. So it may look as if we don't have to remove the old class from its superclass. However, at the top of the hierarchy (the first class we reshape) that superclass itself is not newly created so therefore it will hold both the oldClass and newClass in its (obsolete or not) subclasses. Since the #become: below will transparently replace the pointers to oldClass with newClass the superclass would have newClass in its subclasses TWICE. With rather unclear effects if we consider that we may convert the meta-class hierarchy itself (which is derived from the non-meta class hierarchy).		Due to this problem ALL classes are removed from their superclass just prior to converting them. Here, breaking the superclass/subclass invariant really doesn't matter since we will effectively remove the oldClass (become+GC) just a few lines below."		oldClass superclass removeSubclass: oldClass.		oldClass superclass removeObsoleteSubclass: oldClass.		"Convert the instances of oldClass into instances of newClass"		newClass updateInstancesFrom: oldClass.		meta			ifTrue:[oldClass becomeForward: newClass]			ifFalse:[(Array with: oldClass with: oldClass class)						elementsForwardIdentityTo:							(Array with: newClass with: newClass class)].		Smalltalk garbageCollect.		"Warning: Read this before you even think about removing the GC. Yes, it slows us down. Quite heavily if you have a large image. However, there's no good and simple alternative here, since unfortunately, #become: does change class pointers. What happens is that after the above become all of the instances of the old class will have a class pointer identifying them as instances of newClass. If we get our hands on any of these instances we will break immediately since their expected instance layout (that of its class, e.g., newClass) will not match their actual instance layout (that of oldClass). And getting your hands on any of those instances is really simple - just reshaping one class two times in rapid succession will do it. Reflection techniques, interrupts, etc. will only add to this problem. In the case of Metaclass things get even worse since when we recompile the entire class hierarchy we will recompile both, Metaclass and its instances (and some of its instances will have the old and some the new layout).		The only easy solution to this problem would be to 'fix up' the class pointers of the old instances to point to the old class (using primitiveChangeClassTo:). But this won't work either - as we do a one-way become we would have to search the entire object memory for the oldClass and couldn't even clearly identify it unless we give it some 'special token' which sounds quite error-prone. If you really need to get rid of the GC here are some alternatives:		On the image level, one could create a copy of the oldClass before becoming it into the new class and, after becoming it, 'fix up' the old instances. That would certainly work but it sounds quite complex, as we need to make sure we're not breaking any of the superclass/subclass meta/non-meta class variants.		Alternatively, fix up #becomeForward on the VM-level to 'dump the source objects' of #become. This would be quite doable (just 'convert' them into a well known special class such as bitmap) yet it has problems if (accidentally or not) one of the objects in #become: appears on 'both sides of the fence' (right now, this will work ... in a way ... even though the consequences are unclear).		Another alternative is to provide a dedicated primitive for this (instead of using it implicitly in become) which would allow us to dump all the existing instances right here. This is equivalent to a more general primitiveChangeClassTo: and might be worthwhile but it would likely have to keep in mind the differences between bits and pointer thingies etc.		Since all of the alternatives seem rather complex and magical compared to a straight-forward GC it seems best to stick with the GC solution for now. If someone has a real need to fix this problem, that person will likely be motivated enough to check out the alternatives. Personally I'd probably go for #1 (copy the old class and remap the instances to it) since it's a solution that could be easily reverted from within the image if there's any problem with it."	] valueUnpreemptively.! !!ContextPart methodsFor: 'debugger access' stamp: ''!depthBelow: aContext	"Answer how many calls there are between this and aContext."	| this depth |	this := self.	depth := 0.	[this == aContext or: [this == nil]]		whileFalse:			[this := this sender.			depth := depth + 1].	^depth! !!ParagraphEditor methodsFor: 'accessing' stamp: ''!replace: oldInterval with: newText and: selectingBlock 	"Replace the text in oldInterval with newText and execute selectingBlock to establish the new selection.  Create an undoAndReselect:redoAndReselect: undoer to allow perfect undoing."	| undoInterval |	undoInterval := self selectionInterval.	undoInterval = oldInterval ifFalse: [self selectInterval: oldInterval].	UndoSelection := self selection.	self zapSelectionWith: newText.	selectingBlock value.	otherInterval := self selectionInterval.	self undoer: #undoAndReselect:redoAndReselect: with: undoInterval with: otherInterval! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 2/23/2001 09:26'!selectionAsTiles	"Try to make new universal tiles from the selected text"	| selection tiles |	selection := self selection.	self terminateAndInitializeAround:		[self currentHand attachMorph: (tiles := Player tilesFrom: selection).		Preferences tileTranslucentDrag			ifTrue: [tiles lookTranslucent]			ifFalse: [tiles align: tiles topLeft 			 			with: self currentHand position + tiles cursorBaseOffset]].! !!MethodDictionary methodsFor: 'private' stamp: ''!rehash 	| newSelf key |	newSelf := self species new: self size.	1 to: self basicSize do:		[:i | key := self basicAt: i.		key == nil ifFalse: [newSelf at: key put: (array at: i)]].	self become: newSelf! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 3/5/2004 03:13'!complete: aContext 	"Run self until aContext is popped or an unhandled error is raised.  Return self's new top context, unless an unhandled error was raised then return the signaler context (rather than open a debugger)."		| ctxt pair error |	ctxt := suspendedContext.	suspendedContext := nil.  "disable this process while running its stack in active process below"	pair := ctxt runUntilErrorOrReturnFrom: aContext.	suspendedContext := pair first.	error := pair second.	error ifNotNil: [^ error signalerContext].	^ suspendedContext! !!MethodFinder methodsFor: 'find a constant' stamp: 'tk 1/8/2001 17:47'!constLinear	| const subTest got denom num slope offset |	"See if (data1 * C1) + C2 is the answer.  In the form  #(C2 C1) polynomialEval: data1 "	denom := ((thisData at: 2) at: 1) - ((thisData at: 1) at: 1).	denom = 0 ifTrue: [^ false].   "will divide by it"	num := (answers at: 2) - (answers at: 1).    slope := (num asFloat / denom) reduce.    offset := ((answers at: 2) - (((thisData at: 2) at: 1) * slope)) reduce.	const := Array with: offset with: slope.	got := (subTest := MethodFinder new copy: self addArg: const) 				searchForOne isEmpty not.	got ifFalse: [^ false]. 	"replace data2 with const in expressions"	subTest expressions do: [:exp |		expressions add: (exp copyReplaceAll: 'data2' with: const printString)].	selector addAll: subTest selectors.	^ true! !!InstructionPrinter class methodsFor: 'printing' stamp: ''!printClass: class 	"Create a file whose name is the argument followed by '.bytes'. Store on 	the file the symbolic form of the compiled methods of the class."	| file |	file := FileStream newFileNamed: class name , '.bytes'.	class selectors do: 		[:sel | 		file cr; nextPutAll: sel; cr.		(self on: (class compiledMethodAt: sel)) printInstructionsOn: file].	file close	"InstructionPrinter printClass: Parser."! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:49'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start := self startIndex.	stop := self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue:			[before := prior last < start.			selection := self selection.			priorSelection := paragraph text copyFrom: prior first to: prior last.			delta := before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta := before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval := prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval := start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse:			[view flash]! !!Object methodsFor: 'viewer' stamp: 'sw 8/22/2002 14:07'!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating to me.  Some of the messages dispatched here are not yet available in this image"	| aMenu elementType |	elementType := self elementTypeFor: anElement vocabulary: aViewer currentVocabulary.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].	self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu := MenuMorph new defaultTarget: aViewer.	#(	('implementors'			browseImplementorsOf:)		('senders'				browseSendersOf:)		('versions'				browseVersionsOf:)		-		('browse full'			browseMethodFull:)		('inheritance'			browseMethodInheritance:)		-		('about this method'		aboutMethod:)) do:			[:pair |				pair = '-'					ifTrue:						[aMenu addLine]					ifFalse:						[aMenu add: pair first target: aViewer selector: pair second argument: anElement]].	aMenu addLine.	aMenu defaultTarget: self.	#(	('destroy script'		removeScript:)		('rename script'		renameScript:)		('pacify script'		pacifyScript:)) do:			[:pair |				aMenu add: pair first target: self selector: pair second argument: anElement].	aMenu addLine.	aMenu  add: 'show categories....' target: aViewer selector: #showCategoriesFor: argument: anElement.	aMenu items size == 0 ifTrue:  "won't happen at the moment a/c the above"		[aMenu add: 'ok' action: nil].  "in case it was a slot -- weird, transitional"	aMenu addTitle: anElement asString, ' (', elementType, ')'.	aMenu popUpInWorld: self currentWorld. ! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'jm 9/11/97 10:32'!sweepHandIdleProcess	"A default background process which shows a sweeping circle of XOR-ed bits on the screen."	| sweepHand |	sweepHand := Pen new.	sweepHand defaultNib: 2.	sweepHand combinationRule: 6.	[true] whileTrue: [		2 timesRepeat: [			sweepHand north.			36 timesRepeat: [				sweepHand place: Display boundingBox topRight + (-25@25).				sweepHand go: 20.				sweepHand turn: 10]].		self relinquishProcessorForMicroseconds: 10000].! !!ContextPart class methodsFor: 'special context creation' stamp: 'ajh 1/24/2003 14:31'!contextOn: exceptionClass do: block	"Create an #on:do: context that is ready to return from executing its receiver"	| ctxt chain |	ctxt := thisContext.	[chain := thisContext sender cut: ctxt. ctxt jump] on: exceptionClass do: block.	"jump above will resume here without unwinding chain"	^ chain! !!Float methodsFor: 'converting' stamp: 'st 9/17/2004 17:14'!asApproximateFractionAtOrder: maxOrder	"Answer a Fraction approximating the receiver. This conversion uses the 	continued fraction method to approximate a floating point number. If maxOrder	is zero, use maximum order"	| num1 denom1 num2 denom2 int frac newD temp order |	num1 := self asInteger.	"The first of two alternating numerators"	denom1 := 1.		"The first of two alternating denominators"	num2 := 1.		"The second numerator"	denom2 := 0.		"The second denominator--will update"	int := num1.		"The integer part of self"	frac := self fractionPart.		"The fractional part of self"	order := maxOrder = 0 ifTrue: [-1] ifFalse: [maxOrder].	[frac = 0 or: [order = 0] ]		whileFalse: 			["repeat while the fractional part is not zero and max order is not reached"			order := order - 1.			newD := 1.0 / frac.			"Take reciprocal of the fractional part"			int := newD asInteger.		"get the integer part of this"			frac := newD fractionPart.	"and save the fractional part for next time"			temp := num2.				"Get old numerator and save it"			num2 := num1.				"Set second numerator to first"			num1 := num1 * int + temp.	"Update first numerator"			temp := denom2.				"Get old denominator and save it"			denom2 := denom1.			"Set second denominator to first"			denom1 := int * denom1 + temp.		"Update first denominator"			10000000000.0 < denom1				ifTrue: 					["Is ratio past float precision?  If so, pick which 					of the two ratios to use"					num2 = 0.0 						ifTrue: ["Is second denominator 0?"								^ Fraction numerator: num1 denominator: denom1].					^ Fraction numerator: num2 denominator: denom2]].	"If fractional part is zero, return the first ratio"	denom1 = 1		ifTrue: ["Am I really an Integer?"				^ num1 "Yes, return Integer result"]		ifFalse: ["Otherwise return Fraction result"				^ Fraction numerator: num1 denominator: denom1]! !!Object methodsFor: 'class membership' stamp: 'sw 9/27/2001 15:51'!inheritsFromAnyIn: aList	"Answer whether the receiver inherits from any class represented by any element in the list.  The elements of the list can be classes, class name symbols, or strings representing possible class names.  This allows speculative membership tests to be made even when some of the classes may not be known to the current image, and even when their names are not interned symbols."	| aClass |	aList do:		[:elem | Symbol hasInterned: elem asString ifTrue: 			[:elemSymbol | (((aClass := Smalltalk at: elemSymbol ifAbsent: [nil]) isKindOf: Class)						and: [self isKindOf: aClass])				ifTrue:					[^ true]]].	^ false"{3.  true. 'olive'} do:	[:token |		 {{#Number. #Boolean}. {Number.  Boolean }.  {'Number'. 'Boolean'}} do:			[:list |				Transcript cr; show: token asString, ' list element provided as a ', list first class name, ' - ', (token inheritsFromAnyIn: list) asString]]"! !!BlockContext methodsFor: 'controlling' stamp: 'jf 9/3/2003 16:39'!doWhileTrue: conditionBlock	"Evaluate the receiver once, then again as long the value of conditionBlock is true." 	| result |	[result := self value.	conditionBlock value] whileTrue.	^ result! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 11:54'!signalWaitingProcess	"The delay time has elapsed; signal the waiting process."	beingWaitedOn := false.	delaySemaphore signal.! !!MethodFinder class methodsFor: 'as yet unclassified' stamp: 'ar 9/27/2005 22:45'!methodFor: dataAndAnswers	"Return a Squeak expression that computes these answers.  (This method is called by the comment in the bottom pane of a MethodFinder.  Do not delete this method.)"	| resultOC resultString |	resultOC := (self new) load: dataAndAnswers; findMessage.	resultString := String streamContents: [:strm |		resultOC do: [:exp | strm nextPut: $(; nextPutAll: exp; nextPut: $); space]].	^ resultString! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/18/2002 16:53'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home := self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText := UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText := ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey := FindText size = 0)		ifTrue: "just inserted at a caret"			[home := self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText := ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices := WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home := self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!Float methodsFor: 'comparing' stamp: 'nice 7/19/2009 19:27'!closeTo: num 	"are these two numbers close?"	num isNumber ifFalse: [^[self = num] ifError: [false]].	self = 0.0 ifTrue: [^num abs < 0.0001].	num = 0 ifTrue: [^self abs < 0.0001].	^self = num asFloat		or: [(self - num) abs / (self abs max: num abs) < 0.0001]! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/13/1999 04:52'!adoptInstance: oldInstance from: oldMetaClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	thisClass class == self ifTrue:[^self error:'Metaclasses have only one instance'].	oldMetaClass isMeta ifFalse:[^self error:'Argument must be Metaclass'].	oldInstance class == oldMetaClass ifFalse:[^self error:'Not the class of argument'].	^thisClass := self 		newInstanceFrom: oldInstance 		variable: self isVariable 		size: self instSize 		map: (self instVarMappingFrom: oldMetaClass)! !!InputSensor methodsFor: 'joystick' stamp: ''!joystickXY: index	| inputWord x y |	inputWord := self primReadJoystick: index.	x := (inputWord bitAnd: 16r7FF) - 16r400.	y := ((inputWord bitShift: -11) bitAnd: 16r7FF) - 16r400.	^ x@y	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'md 10/22/2003 15:27'!changeStyle	"Let user change styles for the current text pane  	 Moved from experimentalCommand to its own method  "	| aList reply style |	aList := StrikeFont actualFamilyNames.	aList addFirst: 'DefaultTextStyle'.	reply := (SelectionMenu labelList: aList lines: #(1) selections: aList) startUp.	reply ifNotNil:		[(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ClassDescription methodsFor: 'instance variables' stamp: 'al 11/28/2005 11:52'!renameSilentlyInstVar: old to: new	| i oldName newName |	oldName := old asString.	newName := new asString.	(i := self instVarNames indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	self instVarNames replaceFrom: i to: i with: (Array with: newName).	self replaceSilently: oldName to: newName.	"replace in text body of all methods"! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ajh 6/27/2003 20:47'!handleSignal: exception	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."	| val |	(((self tempAt: 1) handles: exception) and: [self tempAt: 3]) ifFalse: [		^ self nextHandlerContext handleSignal: exception].	exception privHandlerContext: self contextTag.	self tempAt: 3 put: false.  "disable self while executing handle block"	val := [(self tempAt: 2) valueWithPossibleArgs: {exception}]		ensure: [self tempAt: 3 put: true].	self return: val.  "return from self if not otherwise directed in handle block"! !!ClassDescription methodsFor: 'private' stamp: 'md 6/2/2006 10:33'!linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	| lines |	lines := self methodDict values inject: 0 into: [:sum :each | sum + each linesOfCode]. 	self isMeta 		ifTrue: [^ lines]		ifFalse: [^ lines + self class linesOfCode]! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'md 1/18/2006 23:42'!makeCapitalized: characterStream 	"Force the current selection to be capitalized. Triggered by Cmd-Z."	| prev |	sensor keyboard.		"Flush the triggering cmd-key character"	prev := $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev := prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!InstVarRefLocator methodsFor: 'initialize-release' stamp: 'md 4/8/2003 11:35'!interpretNextInstructionUsing: aScanner 		bingo := false.	aScanner interpretNextInstructionFor: self.	^bingo! !!InputSensor class methodsFor: 'public' stamp: 'nk 2/11/2002 12:39'!installSwappedKeyEntryFor: c	| key |	key := c asInteger.	"first do control->alt key"	KeyDecodeTable at: { key bitAnd: 16r9F . 2 } put: { key . 8 }.	"then alt->control key"	KeyDecodeTable at: { key . 8 } put: { key bitAnd: 16r9F . 2 }! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/13/1999 11:12'!tabletPoint	"Answer the current position of the first tablet pointing device (pen, puck, or eraser) in tablet coordinates."	| data |	data := self primTabletRead: 1.  "state of first/primary pen"	^ (data at: 3) @ (data at: 4)! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'yo 3/14/2005 13:03'!changeEmphasis	| aList reply  |	aList := #(normal bold italic narrow underlined struckOut).	reply := (SelectionMenu labelList: (aList collect: [:t | t translated]) selections: aList) startUp.	reply ~~ nil ifTrue:		[self setEmphasis: reply.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'current selection' stamp: 'BG 12/12/2003 12:50'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing := selectionShowing not.	paragraph reverseFrom: self pointBlock to: self markBlock! !!Metaclass methodsFor: 'initialize-release' stamp: 'al 7/19/2004 20:49'!uses: aTraitCompositionOrArray instanceVariableNames: instVarString 	| newComposition newMetaClass copyOfOldMetaClass |		copyOfOldMetaClass := self copy.	newMetaClass := self instanceVariableNames: instVarString.		newComposition := aTraitCompositionOrArray asTraitComposition.	newMetaClass assertConsistantCompositionsForNew: newComposition.	newMetaClass setTraitComposition: newComposition.		SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldMetaClass to: newMetaClass! !!ProcessorScheduler methodsFor: 'process state change' stamp: ''!suspendFirstAt: aPriority ifNone: noneBlock 	"Suspend the first Process that is waiting to run with priority aPriority. If 	no Process is waiting, evaluate the argument, noneBlock."	| aList |	aList := quiescentProcessLists at: aPriority.	aList isEmpty		ifTrue: [^noneBlock value]		ifFalse: [^aList first suspend]! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:48'!divideFastAndSecureBy: anObject	"Answer the result of dividing receiver by aNumber"	" Both operands are scaled to avoid arithmetic overflow. 	  This algorithm works for a wide range of values, and it needs only three divisions.	  Note: #reciprocal uses #/ for devision "	 	| r d newReal newImaginary |	anObject isComplex ifTrue:		[anObject real abs > anObject imaginary abs		  ifTrue:		    [r := anObject imaginary / anObject real.			d := r*anObject imaginary + anObject real.			newReal := r*imaginary + real/d.			newImaginary := r negated * real + imaginary/d.		    ]		  ifFalse:		    [r := anObject real / anObject imaginary.			d := r*anObject real + anObject imaginary.			newReal := r*real + imaginary/d.			newImaginary := r*imaginary - real/d.		    ].				^ Complex real: newReal imaginary: newImaginary].	^ anObject adaptToComplex: self andSend: #/.! !!ClassDescription methodsFor: 'organization' stamp: 'NS 4/8/2004 11:04'!organization: aClassOrg	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."	aClassOrg ifNotNil: [aClassOrg setSubject: self].	organization := aClassOrg! !!Complex methodsFor: 'arithmetic' stamp: 'md 7/22/2004 11:45'!/ anObject	"Answer the result of dividing receiver by aNumber"	| a b c d newReal newImaginary |	anObject isComplex ifTrue:		[a := self real.		b := self imaginary.		c := anObject real.		d := anObject imaginary.		newReal := ((a * c) + (b * d)) / ((c * c) + (d * d)).		newImaginary := ((b * c) - (a * d)) / ((c * c) + (d * d)).		^ Complex real: newReal imaginary: newImaginary].	^ anObject adaptToComplex: self andSend: #/.! !!Behavior methodsFor: 'accessing instances and variables' stamp: ''!allInstVarNames	"Answer an Array of the names of the receiver's instance variables. The 	Array ordering is the order in which the variables are stored and 	accessed by the interpreter."	| vars |	superclass == nil		ifTrue: [vars := self instVarNames copy]	"Guarantee a copy is answered."		ifFalse: [vars := superclass allInstVarNames , self instVarNames].	^vars! !!EventSensor methodsFor: 'initialize' stamp: 'nk 4/12/2004 20:13'!shutDown	super shutDown.	EventTicklerProcess ifNotNil: [		EventTicklerProcess terminate.		EventTicklerProcess := nil. ].	inputSemaphore ifNotNil:[Smalltalk unregisterExternalObject: inputSemaphore].! !!Class methodsFor: 'initialize-release' stamp: 'dvf 9/27/2005 17:34'!declare: varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| newVars conflicts |	newVars := 		(Scanner new scanFieldNames: varString)			collect: [:x | x asSymbol].	newVars do:		[:var | var first canBeGlobalVarInitial			ifFalse: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].	conflicts := false.	classPool == nil 		ifFalse: [(classPool keys reject: [:x | newVars includes: x]) do: 					[:var | self removeClassVarName: var]].	(newVars reject: [:var | self classPool includesKey: var])		do: [:var | "adding"			"check if new vars defined elsewhere"			(self bindingOf: var) notNil				ifTrue: 					[self error: var , ' is defined elsewhere'.					conflicts := true]].	newVars size > 0		ifTrue: 			[classPool := self classPool.			"in case it was nil"			newVars do: [:var | classPool declare: var from: Undeclared]].	^conflicts! !!ParagraphEditor methodsFor: 'typing support' stamp: 'th 9/18/2002 16:49'!setEmphasisHere	emphasisHere := (paragraph text attributesAt: (self pointIndex - 1 max: 1) forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]! !!Object methodsFor: 'user interface' stamp: 'sw 6/17/2004 01:47'!launchPartVia: aSelector label: aString	"Obtain a morph by sending aSelector to self, and attach it to the morphic hand.  This provides a general protocol for parts bins"	| aMorph |	aMorph := self perform: aSelector.	aMorph setNameTo: (ActiveWorld unusedMorphNameLike: aString).	aMorph setProperty: #beFullyVisibleAfterDrop toValue: true.	aMorph openInHand! !!BasicClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/7/2004 16:03'!commentStamp: aStamp	commentStamp := aStamp! !!MethodDictionary methodsFor: 'accessing' stamp: 'raa 5/30/2001 15:04'!at: key putNoBecome: value	"Set the value at key to be value. Answer the resulting MethodDictionary"	| index |	index := self findElementOrNil: key.	(self basicAt: index) == nil		ifTrue: 			[tally := tally + 1.			self basicAt: index put: key]		ifFalse:			[(array at: index) flushCache].	array at: index put: value.	^self fullCheckNoBecome! !!MethodDictionary methodsFor: 'private' stamp: 'md 10/5/2005 15:43'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	finish := array size.	start := (anObject identityHash \\ finish) + 1.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element := self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element := self basicAt: index) == nil or: [element == anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!Fraction methodsFor: 'private' stamp: ''!reduced	| gcd numer denom |	numerator = 0 ifTrue: [^0].	gcd := numerator gcd: denominator.	numer := numerator // gcd.	denom := denominator // gcd.	denom = 1 ifTrue: [^numer].	^Fraction numerator: numer denominator: denom! !!EventSensor methodsFor: 'private' stamp: 'nk 6/21/2004 10:40'!installEventTickler	"Initialize the interrupt watcher process. Terminate the old process if any."	"Sensor installEventTickler"	EventTicklerProcess ifNotNil: [EventTicklerProcess terminate].	EventTicklerProcess := [self eventTickler] forkAt: Processor lowIOPriority.! !!ClassDescription methodsFor: 'instance variables' stamp: ''!forceNewFrom: anArray    "Create a new instance of the class and fill    its instance variables up with the array."    | object max |    object := self new.    max := self instSize.    anArray doWithIndex: [:each :index |        index > max ifFalse:            [object instVarAt: index put: each]].    ^ object! !!Monitor methodsFor: 'synchronization' stamp: 'NS 4/14/2004 13:13'!critical: aBlock	"Critical section.	Executes aBlock as a critical section. At any time, only one process can be executing code 	in a critical section.	NOTE: All the following synchronization operations are only valid inside the critical section 	of the monitor!!"	| result |	[self enter.	result := aBlock value] ensure: [self exit].	^ result.! !!Object methodsFor: 'dependents access' stamp: ''!evaluate: actionBlock wheneverChangeIn: aspectBlock	| viewerThenObject objectThenViewer |	objectThenViewer := self.	viewerThenObject := ObjectViewer on: objectThenViewer.	objectThenViewer become: viewerThenObject.	"--- Then ---"	objectThenViewer xxxViewedObject: viewerThenObject			evaluate: actionBlock			wheneverChangeIn: aspectBlock! !!Float methodsFor: 'private' stamp: 'ls 10/10/1999 11:55'!absPrintOn: aStream base: base digitCount: digitCount 	"Print me in the given base, using digitCount significant figures."	| fuzz x exp q fBase scale logScale xi |	self isInf ifTrue: [^ aStream nextPutAll: 'Inf'].	fBase := base asFloat.	"x is myself normalized to [1.0, fBase), exp is my exponent"	exp := 		self < 1.0			ifTrue: [self reciprocalFloorLog: fBase]			ifFalse: [self floorLog: fBase].	scale := 1.0.	logScale := 0.	[(x := fBase raisedTo: (exp + logScale)) = 0]		whileTrue:			[scale := scale * fBase.			logScale := logScale + 1].	x := self * scale / x.	fuzz := fBase raisedTo: 1 - digitCount.	"round the last digit to be printed"	x := 0.5 * fuzz + x.	x >= fBase		ifTrue: 			["check if rounding has unnormalized x"			x := x / fBase.			exp := exp + 1].	(exp < 6 and: [exp > -4])		ifTrue: 			["decimal notation"			q := 0.			exp < 0 ifTrue: [1 to: 1 - exp do: [:i | aStream nextPut: ('0.0000'at: i)]]]		ifFalse: 			["scientific notation"			q := exp.			exp := 0].	[x >= fuzz]		whileTrue: 			["use fuzz to track significance"			xi := x asInteger.			aStream nextPut: (Character digitValue: xi).			x := x - xi asFloat * fBase.			fuzz := fuzz * fBase.			exp := exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	[exp >= -1]		whileTrue: 			[aStream nextPut: $0.			exp := exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	q ~= 0		ifTrue: 			[aStream nextPut: $e.			q printOn: aStream]! !!Class methodsFor: 'initialize-release' stamp: 'NS 4/8/2004 10:55'!superclass: sup methodDict: md format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass := sup.	methodDict := md.	format := ft.	name := nm.	instanceVariables := nilOrArray.	classPool := pool.	sharedPools := poolSet.	self organization: org.! !!Process methodsFor: 'changing process state' stamp: 'ajh 1/23/2003 23:02'!run	"Suspend current process and execute self instead"	| proc |	proc := Processor activeProcess.	[	proc suspend.		self resume.	] forkAt: Processor highestPriority! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30'!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName := aString asSymbol) = (oldName := self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name := newName.	self environment renameClass: self from: oldName! !!Monitor methodsFor: 'private' stamp: 'NS 4/13/2004 13:38'!exit	nestingLevel := nestingLevel - 1.	nestingLevel < 1 ifTrue: [		ownerProcess := nil.		mutex signal	].! !!ObjectOut methodsFor: 'object storage' stamp: 'tk 10/22/1998 14:37'!readDataFrom: aDataStream size: varsOnDisk	"Make self be an object based on the contents of aDataStream, which was generated by the object's storeDataOn: method. Return self."	| cntInstVars |	cntInstVars := self xxxClass instSize.	self xxxClass isVariable		ifTrue: [self xxxClass error: 'needs updating']	"assume no variable subclasses"		ifFalse: [cntInstVars := varsOnDisk].	aDataStream beginReference: self.	1 to: cntInstVars do:		[:i | self xxxInstVarAt: i put: aDataStream next]."	1 to: cntIndexedVars do:		[:i | self basicAt: i put: aDataStream next]."	^ self! !!Integer methodsFor: 'private' stamp: 'laza 3/29/2004 18:16'!print: positiveNumberString on: aStream prefix: prefix length: minimum padded: zeroFlag	| padLength |	padLength := minimum - positiveNumberString size - prefix size.	padLength > 0		ifTrue: [zeroFlag				ifTrue: [aStream nextPutAll: prefix; nextPutAll: (String new: padLength withAll: $0)]				ifFalse: [aStream nextPutAll: (String new: padLength withAll: Character space); nextPutAll: prefix]]		ifFalse: [aStream nextPutAll: prefix].	aStream nextPutAll: positiveNumberString	! !!ClassBuilder methodsFor: 'private' stamp: 'ar 3/5/2001 12:00'!showProgressFor: aClass	"Announce that we're processing aClass"	progress == nil ifTrue:[^self].	aClass isObsolete ifTrue:[^self].	currentClassIndex := currentClassIndex + 1.	(aClass hasMethods and: [aClass wantsRecompilationProgressReported]) ifTrue:		[progress value: ('Recompiling ', aClass name,' (', currentClassIndex printString,'/', maxClassIndex printString,')')]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ls 10/10/199911:36'!explain	"Try to shed some light on what kind of entity the current selectionis. 	The selection must be a single token or construct. Insert the answerafter 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply symbol|Cursor execute showWhile: 			[sorry := '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry := sorry , (view canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string := self selection asString) isEmpty				ifTrue: [reply := '']				ifFalse: [string := self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are allletters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars := self explainTemp: string.							tiVars == nil ifTrue: [tiVars := self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars := model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars := '']						ifFalse: [tiVars := tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol := s])						ifTrue: [cgVars := self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars := self explainClass: symbol.									cgVars == nil ifTrue: [cgVars := self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors := self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors := self explainPartSel: string.									selectors == nil ifTrue: [										selectors := self explainAnySel: symbol]]]						ifFalse: [selectors := self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars := '']						ifFalse: [cgVars := cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors := '']						ifFalse: [selectors := selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors := self explainChar: string]						ifFalse: ["matched delimitors"							delimitors := self explainDelimitor: string].					numbers := self explainNumber: string.					numbers == nil ifTrue: [numbers := ''].					delimitors == nil ifTrue: [delimitors := ''].					reply := tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply := sorry].			self afterSelectionInsertAndSelect: reply]! !!InstructionStream methodsFor: 'scanning' stamp: 'hmm 7/29/2001 21:25'!skipBackBeforeJump	"Assuming that the receiver is positioned jast after a jump, skip back one or two bytes, depending on the size of the previous jump instruction."	| strm short |	strm := InstructionStream on: self method.	(strm scanFor: [:byte |		((short := byte between: 152 and: 159) or: [byte between: 168 and: 175])			and: [strm pc = (short ifTrue: [pc-1] ifFalse: [pc-2])]]) ifFalse: [self error: 'Where''s the jump??'].	self jump: (short ifTrue: [-1] ifFalse: [-2]).! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 9/7/1999 11:25'!inspectIt	"1/13/96 sw: minor fixup"	| result |	result := self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result inspect].! !!Class methodsFor: 'pool variables' stamp: 'al 9/3/2004 13:41'!sharedPools: aCollection	sharedPools := aCollection! !!Process methodsFor: 'accessing' stamp: 'ar 7/8/2001 17:04'!priority: anInteger 	"Set the receiver's priority to anInteger."	(anInteger >= Processor lowestPriority and:[anInteger <= Processor highestPriority])		ifTrue: [priority := anInteger]		ifFalse: [self error: 'Invalid priority: ', anInteger printString]! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'mir 8/3/2004 13:31'!blinkParenAt: parenLocation 	self text		addAttribute: TextEmphasis bold		from: parenLocation		to: parenLocation.	lastParentLocation := parenLocation.! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:50'!beSilent: aBool	"ClassDefiner beSilent: true"	"ClassDefiner beSilent: false"	QuietMode := aBool.! !!Behavior methodsFor: 'enumerating' stamp: 'apb 7/13/2004 00:40'!allInstancesDo: aBlock 	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver.		Because aBlock might change the class of inst (for example, using become:),	it is essential to compute next before aBlock value: inst."	| inst next |	self ==  UndefinedObject ifTrue: [^ aBlock value: nil].	inst := self someInstance.	[inst == nil]		whileFalse:		[		next := inst nextInstance.		aBlock value: inst.		inst := next]! !!Semaphore methodsFor: 'initialize-release' stamp: ''!initSignals	"Consume any excess signals the receiver may have accumulated."	excessSignals := 0.! !!EventSensor methodsFor: 'mouse' stamp: 'ar 5/18/2003 18:27'!createMouseEvent	"create and return a new mouse event from the current mouse 	position; this is useful for restarting normal event queue 	processing after manual polling"	| buttons modifiers pos mapped eventBuffer |	eventBuffer := Array new: 8.	buttons := self primMouseButtons.	pos := self primMousePt.	modifiers := buttons bitShift: -3.	buttons := buttons bitAnd: 7.	mapped := self mapButtons: buttons modifiers: modifiers.	eventBuffer		at: 1		put: EventTypeMouse;		 at: 2 put: Time millisecondClockValue;		 at: 3 put: pos x;		 at: 4 put: pos y;		 at: 5 put: mapped;		 at: 6 put: modifiers.	^ eventBuffer! !!ParagraphEditor methodsFor: 'new selection' stamp: 'th 9/18/2002 14:37'!adjustSelection: directionBlock	"Helper function for Cursor movement. Always moves point thus allowing selections to shrink. "	"See also expandSelection:"	"Accepts a one argument Block that computes the new postion given an old one."	| newPosition |	newPosition := directionBlock value: self pointIndex.	self selectMark: self markIndex point: newPosition.	^true.! !!Monitor methodsFor: 'signaling-specific' stamp: 'NS 4/13/2004 15:12'!signal: aSymbolOrNil	"One process waiting for the given event is woken up. If there is no process waiting 	for this specific event, a process waiting for the default event gets resumed."	| queue |	self checkOwnerProcess.	queue := self queueFor: aSymbolOrNil.	queue isEmpty ifTrue: [queue := self defaultQueue].	self signalQueue: queue.! !!MethodContext methodsFor: 'printing' stamp: 'tk 10/19/2001 11:34'!printDetails: strm	"Put my class>>selector and instance variables and arguments and temporaries on the stream.  Protect against errors during printing."	| pe str pos |	self printOn: strm.	strm cr.	strm tab; nextPutAll: 'Receiver: '.	pe := '<<error during printing>>'.	strm nextPutAll: ([receiver printStringLimitedTo: 90] ifError: [:err :rcvr | pe]).	strm cr; tab; nextPutAll: 'Arguments and temporary variables: '; cr.	str := [(self tempsAndValuesLimitedTo: 80 indent: 2) 				padded: #right to: 1 with: $x] ifError: [:err :rcvr | pe].	strm nextPutAll: (str allButLast).	strm cr; tab; nextPutAll: 'Receiver''s instance variables: '; cr.	pos := strm position.	[receiver longPrintOn: strm limitedTo: 80 indent: 2] ifError: [:err :rcvr | 				strm nextPutAll: pe].	pos = strm position ifTrue: ["normal printString for an Array (it has no inst vars)"		strm nextPutAll: ([receiver printStringLimitedTo: 90] ifError: [:err :rcvr | pe])].	strm peekLast == Character cr ifFalse: [strm cr].! !!Class methodsFor: 'subclass creation' stamp: 'al 7/19/2004 11:18'!subclass: t uses: aTraitCompositionOrArray instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	| newClass copyOfOldClass |	copyOfOldClass := self copy.	newClass := self		subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.				newClass setTraitComposition: aTraitCompositionOrArray asTraitComposition.	SystemChangeNotifier uniqueInstance		classDefinitionChangedFrom: copyOfOldClass to: newClass.	^newClass! !!Delay class methodsFor: 'snapshotting' stamp: 'jm 9/11/97 14:59'!restoreResumptionTimes	"Private!! Restore the resumption times of all scheduled Delays after a snapshot or clock roll-over. This method should be called only while the AccessProtect semaphore is held."	| newBaseTime |	newBaseTime := Time millisecondClockValue.	SuspendedDelays do: [:d | d adjustResumptionTimeOldBase: 0 newBase: newBaseTime].	ActiveDelay == nil ifFalse: [		ActiveDelay adjustResumptionTimeOldBase: 0 newBase: newBaseTime.		ActiveDelay activate].! !!Message methodsFor: 'private' stamp: 'ajh 3/9/2003 19:25'!setSelector: aSymbol	selector := aSymbol.! !!MethodContext methodsFor: 'accessing' stamp: ''!removeSelf	"Nil the receiver pointer and answer its former value."	| tempSelf |	tempSelf := receiver.	receiver := nil.	^tempSelf! !!CompiledMethod methodsFor: 'scanning' stamp: 'md 4/27/2006 15:12'!hasInstVarRef	"Answer whether the method references an instance variable."	| scanner end printer |	scanner := InstructionStream on: self.	printer := InstVarRefLocator new.	end := self endPC.	[scanner pc <= end] whileTrue: [		(printer interpretNextInstructionUsing: scanner) ifTrue: [^true].	].	^false! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	| d1 d2 |	aNumber isFraction ifTrue: 		[d1 := numerator gcd: aNumber denominator.		d2 := denominator gcd: aNumber numerator.		(d2 = denominator and: [d1 = aNumber denominator])			ifTrue: [^ numerator // d1 * (aNumber numerator // d2)].		^ Fraction numerator: numerator // d1 * (aNumber numerator // d2)				denominator: denominator // d2 * (aNumber denominator // d1)].	^ aNumber adaptToFraction: self andSend: #*! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/15/2004 12:28'!changeFromCategorySpecs: categorySpecs	| oldDict oldCategories |	oldDict := self elementCategoryDict.	oldCategories := self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super changeFromCategorySpecs: categorySpecs].	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!Time class methodsFor: 'general inquiries' stamp: 'ar 11/25/2004 11:26'!millisecondsToRun: timedBlock 	"Answer the number of milliseconds timedBlock takes to return its value."	| initialMilliseconds |	initialMilliseconds := self millisecondClockValue.	timedBlock value.	^self millisecondsSince: initialMilliseconds! !!MonitorDelay methodsFor: 'private' stamp: 'NS 4/13/2004 16:22'!signalWaitingProcess	"The delay time has elapsed; signal the waiting process."	beingWaitedOn := false.	monitor signalLock: delaySemaphore inQueue: queue.! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'dvf 9/27/2005 17:08'!methodDict: aDictionary	methodDict := aDictionary! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:28'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	<primitive: 'primDigitDivNegative' module:'LargeIntegers'>	arg = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	"TFEI added this line"	l := self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^ Array with: 0 with: self].	"shortcut against #highBit"	d := 8 - arg lastDigit highBitOfPositiveReceiver.	div := arg digitLshift: d.	div := div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem := self digitLshift: d.	rem digitLength = self digitLength ifTrue: [rem := rem growto: self digitLength + 1].	"makes a copy and shifts"	quo := Integer new: l neg: ng.	dl := div digitLength - 1.	"Last actual byte of data"	ql := l.	dh := div digitAt: dl.	dnh := dl = 1				ifTrue: [0]				ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j := rem digitLength + 1 - k.		"r1 := rem digitAt: j."		(rem digitAt: j)			= dh			ifTrue: [qhi := qlo := 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13  				bits."				"r2 := (rem digitAt: j - 1)."				t := ((rem digitAt: j)							bitShift: 4)							+ ((rem digitAt: j - 1)									bitShift: -4).				qhi := t // dh.				t := (t \\ dh bitShift: 4)							+ ((rem digitAt: j - 1)									bitAnd: 15).				qlo := t // dh.				t := t \\ dh.				"Next compute (hi,lo) := q*dnh"				hi := qhi * dnh.				lo := qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi := (hi bitShift: -4)							+ (lo bitShift: -8).				lo := lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 := j < 3							ifTrue: [0]							ifFalse: [rem digitAt: j - 2].				[(t < hi					or: [t = hi and: [r3 < lo]])					and: 						["i.e. (t,r3) < (hi,lo)"						qlo := qlo - 1.						lo := lo - dnh.						lo < 0							ifTrue: 								[hi := hi - 1.								lo := lo + 256].						hi >= dh]]					whileTrue: [hi := hi - dh].				qlo < 0					ifTrue: 						[qhi := qhi - 1.						qlo := qlo + 16]].		"Subtract q*div from rem"		l := j - dl.		a := 0.		1 to: div digitLength do: 			[:i | 			hi := (div digitAt: i)						* qhi.			lo := a + (rem digitAt: l) - ((hi bitAnd: 15)							bitShift: 4) - ((div digitAt: i)							* qlo).			rem digitAt: l put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a := lo // 256 - (hi bitShift: -4).			l := l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo := qlo - 1.				l := j - dl.				a := 0.				1 to: div digitLength do: 					[:i | 					a := (a bitShift: -8)								+ (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l := l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4)				+ qlo].	rem := rem				digitRshift: d				bytes: 0				lookfirst: dl.	^ Array with: quo with: rem! !!Object methodsFor: 'scripts-kernel' stamp: 'tk 9/28/2001 13:30'!universalTilesForInterface: aMethodInterface	"Return universal tiles for the given method interface.  Record who self is."	| ms argTile itsSelector aType argList |	itsSelector := aMethodInterface selector.	argList := OrderedCollection new.	aMethodInterface argumentVariables doWithIndex:		[:anArgumentVariable :anIndex | 			argTile := ScriptingSystem tileForArgType: (aType := aMethodInterface typeForArgumentNumber: anIndex).			argList add: (aType == #Player 				ifTrue: [argTile actualObject]				ifFalse: [argTile literal]).	"default value for each type"].	ms := MessageSend receiver: self selector: itsSelector arguments: argList asArray.	^ ms asTilesIn: self class globalNames: (self class officialClass ~~ CardPlayer)			"For CardPlayers, use 'self'.  For others, name it, and use its name."! !!ClassDescription methodsFor: 'instance variables' stamp: 'al 11/28/2005 11:50'!allInstVarNamesEverywhere	"Answer the set of inst var names used by the receiver, all superclasses, and all subclasses"	| aList |	aList := OrderedCollection new.	(self allSuperclasses , self withAllSubclasses asOrderedCollection) do:		[:cls | aList addAll: cls instVarNames].	^ aList asSet	"BorderedMorph allInstVarNamesEverywhere"! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitSubtract: arg 	| smaller larger z sum sl al ng |	<primitive: 'primDigitSubtract' module:'LargeIntegers'>	sl := self digitLength.	al := arg digitLength.	(sl = al		ifTrue: 			[[(self digitAt: sl)				= (arg digitAt: sl) and: [sl > 1]]				whileTrue: [sl := sl - 1].			al := sl.			(self digitAt: sl)				< (arg digitAt: sl)]		ifFalse: [sl < al])		ifTrue: 			[larger := arg.			smaller := self.			ng := self negative == false.			sl := al]		ifFalse: 			[larger := self.			smaller := arg.			ng := self negative].	sum := Integer new: sl neg: ng.	z := 0.	"Loop invariant is -1<=z<=1"	1 to: sl do: 		[:i | 		z := z + (larger digitAt: i) - (smaller digitAt: i).		sum digitAt: i put: z - (z // 256 * 256).		"sign-tolerant form of (z bitAnd: 255)"		z := z // 256].	^ sum normalize! !!DependentsArray methodsFor: 'enumerating' stamp: 'nk 3/11/2004 09:34'!do: aBlock	"Refer to the comment in Collection|do:."	| dep |	1 to: self basicSize do:[:i|		(dep := self at: i) ifNotNil:[aBlock value: dep]].! !!MessageSend methodsFor: 'evaluating' stamp: 'nk 3/11/2001 11:42'!valueWithEnoughArguments: anArray	"call the selector with enough arguments from arguments and anArray"	| args |	args := Array new: selector numArgs.	args replaceFrom: 1		to: (arguments size min: args size)		with: arguments		startingAt: 1.	args size > arguments size ifTrue: [		args replaceFrom: arguments size + 1			to: (arguments size + anArray size min: args size)			with: anArray			startingAt: 1.	].	^ receiver perform: selector withArguments: args! !!Behavior class methodsFor: 'class initialization' stamp: 'apb 7/12/2004 23:46'!initializeObsoleteSubclasses	ObsoleteSubclasses := WeakKeyToCollectionDictionary new.! !!Integer class methodsFor: 'prime numbers' stamp: 'ar 10/6/2001 02:38'!largePrimesUpTo: max do: aBlock	"Evaluate aBlock with all primes up to maxValue.	The Algorithm is adapted from http://www.rsok.com/~jrm/printprimes.html	It encodes prime numbers much more compactly than #primesUpTo: 	38.5 integer per byte (2310 numbers per 60 byte) allow for some fun large primes.	(all primes up to SmallInteger maxVal can be computed within ~27MB of memory;	the regular #primesUpTo: would require 4 *GIGA*bytes).	Note: The algorithm could be re-written to produce the first primes (which require	the longest time to sieve) faster but only at the cost of clarity."	| limit flags maskBitIndex bitIndex maskBit byteIndex index primesUpTo2310 indexLimit |	limit := max asInteger - 1.	indexLimit := max sqrt truncated + 1.	"Create the array of flags."	flags := ByteArray new: (limit + 2309) // 2310 * 60 + 60.	flags atAllPut: 16rFF. "set all to true"	"Compute the primes up to 2310"	primesUpTo2310 := self primesUpTo: 2310.	"Create a mapping from 2310 integers to 480 bits (60 byte)"	maskBitIndex := Array new: 2310.	bitIndex := -1. "for pre-increment"	maskBitIndex at: 1 put: (bitIndex := bitIndex + 1).	maskBitIndex at: 2 put: (bitIndex := bitIndex + 1).	1 to: 5 do:[:i| aBlock value: (primesUpTo2310 at: i)].	index := 6.	2 to: 2309 do:[:n|		[(primesUpTo2310 at: index) < n] 			whileTrue:[index := index + 1].		n = (primesUpTo2310 at: index) ifTrue:[			maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1).		] ifFalse:[			"if modulo any of the prime factors of 2310, then could not be prime"			(n \\ 2 = 0 or:[n \\ 3 = 0 or:[n \\ 5 = 0 or:[n \\ 7 = 0 or:[n \\ 11 = 0]]]]) 				ifTrue:[maskBitIndex at: n+1 put: 0]				ifFalse:[maskBitIndex at: n+1 put: (bitIndex := bitIndex + 1)].		].	].	"Now the real work begins...	Start with 13 since multiples of 2,3,5,7,11 are handled by the storage method;	increment by 2 for odd numbers only."	13 to: limit by: 2 do:[:n|		(maskBit := maskBitIndex at: (n \\ 2310 + 1)) = 0 ifFalse:["not a multiple of 2,3,5,7,11"			byteIndex := n // 2310 * 60 + (maskBit-1 bitShift: -3) + 1.			bitIndex := 1 bitShift: (maskBit bitAnd: 7).			((flags at: byteIndex) bitAnd: bitIndex) = 0 ifFalse:["not marked -- n is prime"				aBlock value: n.				"Start with n*n since any integer < n has already been sieved 				(e.g., any multiple of n with a number k < n has been cleared 				when k was sieved); add 2 * i to avoid even numbers and				mark all multiples of this prime. Note: n < indexLimit below				limits running into LargeInts -- nothing more."				n < indexLimit ifTrue:[					index := n * n.					(index bitAnd: 1) = 0 ifTrue:[index := index + n].					[index <= limit] whileTrue:[						(maskBit := maskBitIndex at: (index \\ 2310 + 1)) = 0 ifFalse:[							byteIndex := (index // 2310 * 60) + (maskBit-1 bitShift: -3) + 1.							maskBit := 255 - (1 bitShift: (maskBit bitAnd: 7)).							flags at: byteIndex put: ((flags at: byteIndex) bitAnd: maskBit).						].						index := index + (2 * n)].				].			].		].	].! !!ParagraphEditor methodsFor: 'do-its' stamp: 'md 2/13/2006 14:36'!compileSelectionFor: anObject in: evalContext	| methodNode method |	methodNode := [Compiler new		compileNoPattern: self selectionAsStream		in: anObject class		context: evalContext		notifying: self		ifFail: [^nil]]			on: OutOfScopeNotification			do: [:ex | ex resume: true].	method := methodNode generate.	^method copyWithTempNames: methodNode tempNames! !!Object methodsFor: 'printing' stamp: 'BG 11/7/2004 13:39'!longPrintStringLimitedTo: aLimitValue	"Answer a String whose characters are a description of the receiver."		| str |	str := String streamContents: [:aStream | self longPrintOn: aStream limitedTo: aLimitValue indent: 0].	"Objects without inst vars should return something"	^ str isEmpty ifTrue: [self printString, String cr] ifFalse: [str]! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'dgd 4/4/2006 15:46'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to	accept characters with the change in emphasis. Emphasis	change amounts to a font change. Keeps typeahead."		| keyCode attribute oldAttributes index thisSel colors extras |	"control 0..9 -> 0..9"	keyCode := ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes := paragraph text attributesAt: self pointIndex forStyle: paragraph textStyle.	thisSel := self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue: [		attribute := TextFontChange fontNumber: keyCode	].	keyCode = 6 ifTrue: [		| labels lines | 		colors := #(#black #magenta #red #yellow #green #blue #cyan #white ).		extras := (self class name = #TextMorphEditor and: [(self morph isKindOf: TextMorphForEditView) not])						ifTrue: ["not a system window" #()]						ifFalse: [#('Link to comment of class' 'Link to definition of class' 'Link to hierarchy of class' 'Link to method' )].		Preferences noviceMode ifTrue: [			labels := colors , #('choose color...' ).			lines := #()		]		ifFalse: [			labels := colors , #('choose color...' 'Do it' 'Print it' ) , extras , #('be a web URL link' 'Edit hidden info' 'Copy hidden info' ).			lines := Array with: colors size + 1		].		"index := (PopUpMenu labelArray: labels lines: lines) startUp. "		index := UIManager default chooseFrom: labels lines: lines.		index = 0			ifTrue: [ ^ true].					index <= colors size ifTrue: [			attribute := TextColor color: (Color perform: (colors at: index))		]		ifFalse: [			index := index - colors size - 1. "Re-number!!!!!!"			index = 0 ifTrue: [				attribute := self chooseColor			].			index = 1 ifTrue: [				attribute := TextDoIt new.				thisSel := attribute analyze: self selection asString			].			index = 2 ifTrue: [				attribute := TextPrintIt new.				thisSel := attribute analyze: self selection asString			].			extras size = 0 & (index > 2) ifTrue: [				index := index + 4 "skip those"			].			index = 3 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Comment'			].			index = 4 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Definition'			].			index = 5 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString with: 'Hierarchy'			].			index = 6 ifTrue: [				attribute := TextLink new.				thisSel := attribute analyze: self selection asString			].					index = 7 ifTrue: [				attribute := TextURL new.				thisSel := attribute analyze: self selection asString			].					index = 8 ifTrue: [				"Edit hidden info"				thisSel := self hiddenInfo. "includes selection"				attribute := TextEmphasis normal			].			index = 9 ifTrue: [				"Copy hidden info"				self copyHiddenInfo.				^ true			].					"no other action"			thisSel				ifNil: [ ^ true ]		]	].	(keyCode between: 7 and: 11) ifTrue: [		sensor leftShiftDown ifTrue: [			keyCode = 10 ifTrue: [				attribute := TextKern kern: -1			].			keyCode = 11 ifTrue: [				attribute := TextKern kern: 1			]		]		ifFalse: [			attribute := TextEmphasis perform: (#(#bold #italic #narrow #underlined #struckOut ) at: keyCode - 6).			oldAttributes						do: [:att | (att dominates: attribute) ifTrue: [attribute turnOff]]		]	].	keyCode = 0		ifTrue: [attribute := TextEmphasis normal].	beginTypeInBlock ~~ nil ifTrue: [		"only change emphasisHere while typing"		self insertTypeAhead: characterStream.		emphasisHere := Text addAttribute: attribute toArray: oldAttributes.		^ true	].	self		replaceSelectionWith: (thisSel asText addAttribute: attribute).			^ true! !!BasicClassOrganizer methodsFor: 'fileIn/Out' stamp: 'NS 4/7/2004 16:04'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	self hasSubject ifTrue: [		(refStrm insideASegment and: [self subject isSystemDefined not]) ifTrue: [			^ self].	"do trace me"		(self subject isKindOf: Class) ifTrue: [			dp := DiskProxy global: self subject name selector: #organization args: #().			refStrm replace: self with: dp.			^ dp]].	^ self	"in desparation"! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 3/5/2004 03:26'!popTo: aContext 	"Pop self down to aContext by remote returning from aContext's callee.  Unwind blocks will be executed on the way.	This is done by pushing a new context on top which executes 'aContext callee return' then resuming self until aContext is reached.  This way any errors raised in an unwind block will get handled by senders in self and not by senders in the activeProcess.	If an unwind block raises an error that is not handled then the popping stops at the error and the signalling context is returned, othewise aContext is returned."	| callee |	self == Processor activeProcess		ifTrue: [^ self error: 'The active process cannot pop contexts'].	callee := (self calleeOf: aContext) ifNil: [^ aContext].  "aContext is on top"	^ self return: callee value: callee receiver! !!BlockClosure methodsFor: 'evaluating' stamp: 'ar 7/20/2009 00:14'!valueSupplyingAnswer: anObject	^ (anObject isCollection and: [anObject isString not])		ifTrue: [self valueSupplyingAnswers: {anObject}]		ifFalse: [self valueSupplyingAnswers: {{'*'. anObject}}]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/6/2004 13:51'!listAtCategoryNumber: anInteger 	"Answer the array of elements stored at the position indexed by anInteger.  Answer nil if anInteger is larger than the number of categories."	| firstIndex lastIndex |	(anInteger < 1 or: [anInteger > categoryStops size])		ifTrue: [^ nil].	firstIndex := self firstIndexOfCategoryNumber: anInteger.	lastIndex :=  self lastIndexOfCategoryNumber: anInteger.	^elementArray copyFrom: firstIndex to: lastIndex! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 2/17/2000 22:36'!classesThatImplementAllOf: selectorSet	"Return an array of any classes that implement all the messages in selectorSet."	| found remaining |	found := OrderedCollection new.	selectorSet do:		[:sel | (self methodDict includesKey: sel) ifTrue: [found add: sel]].	found isEmpty		ifTrue: [^ self subclasses inject: Array new						into: [:subsThatDo :sub |							subsThatDo , (sub classesThatImplementAllOf: selectorSet)]]		ifFalse: [remaining := selectorSet copyWithoutAll: found.				remaining isEmpty ifTrue: [^ Array with: self].				^ self subclasses inject: Array new						into: [:subsThatDo :sub |							subsThatDo , (sub classesThatImplementAllOf: remaining)]]! !!InstructionStream methodsFor: 'testing' stamp: ''!willJumpIfFalse	"Answer whether the next bytecode is a jump-if-false."	| byte |	byte := self method at: pc.	^(byte between: 152 and: 159) or: [byte between: 172 and: 175]! !!MethodFinder methodsFor: 'initialize' stamp: 'md 2/17/2006 12:00'!initialize	"The methods we are allowed to use.  (MethodFinder new initialize) "	Approved := Set new.	AddAndRemove := Set new.	Blocks := Set new.	"These modify an argument and are not used by the MethodFinder: longPrintOn: printOn: storeOn: sentTo: storeOn:base: printOn:base: absPrintExactlyOn:base: absPrintOn:base: absPrintOn:base:digitCount: writeOn: writeScanOn: possibleVariablesFor:continuedFrom: printOn:format:""Object"  	#("in class, instance creation" categoryForUniclasses chooseUniqueClassName initialInstance isSystemDefined newFrom: officialClass readCarefullyFrom:"accessing" at: basicAt: basicSize bindWithTemp: in: size yourself "testing" basicType ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isColor isFloat isFraction isInMemory isInteger isMorph isNil isNumber isPoint isPseudoContext isText isTransparent isWebBrowser knownName notNil pointsTo: wantsSteps "comparing" = == closeTo: hash hashMappedBy: identityHash identityHashMappedBy: identityHashPrintString ~= ~~ "copying" clone copy shallowCopy "dependents access" canDiscardEdits dependents hasUnacceptedEdits "updating" changed changed: okToChange update: windowIsClosing "printing" fullPrintString isLiteral longPrintString printString storeString stringForReadout stringRepresentation "class membership" class isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass "error handling" "user interface" addModelMenuItemsTo:forMorph:hand: defaultBackgroundColor defaultLabelForInspector fullScreenSize initialExtent modelWakeUp mouseUpBalk: newTileMorphRepresentative windowActiveOnFirstClick windowReqNewLabel: "system primitives" asOop instVarAt: instVarNamed: "private" "associating" -> "converting" as: asOrderedCollection asString "casing" caseOf: caseOf:otherwise: "binding" bindingOf: "macpal" contentsChanged currentEvent currentHand currentWorld flash instanceVariableValues scriptPerformer "flagging" flag: "translation support" "objects from disk" "finalization" ) do: [:sel | Approved add: sel].	#(at:add: at:modify: at:put: basicAt:put: "NOT instVar:at:""message handling" perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: ) do: [:sel | AddAndRemove add: sel]."Boolean, True, False, UndefinedObject"  	#("logical operations" & eqv: not xor: |"controlling" and: ifFalse: ifFalse:ifTrue: ifTrue: ifTrue:ifFalse: or:"copying" "testing" isEmptyOrNil) do: [:sel | Approved add: sel]."Behavior" 	#("initialize-release""accessing" compilerClass decompilerClass evaluatorClass format methodDict parserClass sourceCodeTemplate subclassDefinerClass"testing" instSize instSpec isBits isBytes isFixed isPointers isVariable isWeak isWords"copying""printing" defaultNameStemForInstances printHierarchy"creating class hierarchy""creating method dictionary""instance creation" basicNew basicNew: new new:"accessing class hierarchy" allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses subclasses superclass withAllSubclasses withAllSuperclasses"accessing method dictionary" allSelectors changeRecordsAt: compiledMethodAt: compiledMethodAt:ifAbsent: firstCommentAt: lookupSelector: selectors selectorsDo: selectorsWithArgs: "slow but useful ->" sourceCodeAt: sourceCodeAt:ifAbsent: sourceMethodAt: sourceMethodAt:ifAbsent:"accessing instances and variables" allClassVarNames allInstVarNames allSharedPools classVarNames instVarNames instanceCount sharedPools someInstance subclassInstVarNames"testing class hierarchy" inheritsFrom: kindOfSubclass"testing method dictionary" canUnderstand: classThatUnderstands: hasMethods includesSelector: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichSelectorsStoreInto:"enumerating""user interface""private" indexIfCompact) do: [:sel | Approved add: sel]."ClassDescription"	#("initialize-release" "accessing" classVersion isMeta name theNonMetaClass"copying" "printing" classVariablesString instanceVariablesString sharedPoolsString"instance variables" checkForInstVarsOK: "method dictionary" "organization" category organization whichCategoryIncludesSelector:"compiling" acceptsLoggingOfCompilation wantsChangeSetLogging"fileIn/Out" definition"private" ) do: [:sel | Approved add: sel]."Class"	#("initialize-release" "accessing" classPool"testing""copying" "class name" "instance variables" "class variables" classVarAt: classVariableAssociationAt:"pool variables" "compiling" "subclass creation" "fileIn/Out" ) do: [:sel | Approved add: sel]. "Metaclass"	#("initialize-release" "accessing" isSystemDefined soleInstance"copying" "instance creation" "instance variables"  "pool variables" "class hierarchy"  "compiling""fileIn/Out"  nonTrivial ) do: [:sel | Approved add: sel]."Context, BlockContext"	#(receiver client method receiver tempAt: "debugger access" pc selector sender shortStack sourceCode tempNames tempsAndValues"controlling"  "printing" "system simulation" "initialize-release" "accessing" hasMethodReturn home numArgs"evaluating" value value:ifError: value:value: value:value:value: value:value:value:value: valueWithArguments:"controlling"  "scheduling"  "instruction decoding"  "printing" "private"  "system simulation" ) do: [:sel | Approved add: sel].	#(value: "<- Association has it as a store" ) do: [:sel | AddAndRemove add: sel]."Message"	#("inclass, instance creation" selector: selector:argument: selector:arguments:"accessing" argument argument: arguments sends:"printing" "sending" ) do: [:sel | Approved add: sel].	#("private" setSelector:arguments:) do: [:sel | AddAndRemove add: sel]."Magnitude"	#("comparing" < <= > >= between:and:"testing" max: min: min:max: ) do: [:sel | Approved add: sel]."Date, Time"	#("in class, instance creation" fromDays: fromSeconds: fromString: newDay:month:year: newDay:year: today	"in class, general inquiries" dateAndTimeNow dayOfWeek: daysInMonth:forYear: daysInYear: firstWeekdayOfMonth:year: indexOfMonth: leapYear: nameOfDay: nameOfMonth:"accessing" day leap monthIndex monthName weekday year"arithmetic" addDays: subtractDate: subtractDays:"comparing""inquiries" dayOfMonth daysInMonth daysInYear daysLeftInYear firstDayOfMonth previous:"converting" asSeconds"printing"  mmddyyyy printFormat: "private" weekdayIndex 	"in class, instance creation" fromSeconds: now 	"in class, general inquiries" dateAndTimeFromSeconds: dateAndTimeNow millisecondClockValue millisecondsToRun: totalSeconds"accessing" hours minutes seconds"arithmetic" addTime: subtractTime:"comparing""printing" intervalString print24 "converting") do: [:sel | Approved add: sel].	#("private" 		 ) do: [:sel | AddAndRemove add: sel]."Number"	#("in class" readFrom:base: "arithmetic" * + - / // \\ abs negated quo: reciprocal rem:"mathematical functions" arcCos arcSin arcTan arcTan: cos exp floorLog: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan"truncation and round off" ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated"comparing""testing" even isDivisibleBy: isInf isInfinite isNaN isZero negative odd positive sign strictlyPositive"converting" @ asInteger asNumber asPoint asSmallAngleDegrees degreesToRadians radiansToDegrees"intervals" to: to:by: "printing" printStringBase: storeStringBase: ) do: [:sel | Approved add: sel]."Integer"	#("in class" primesUpTo:"testing" isPowerOfTwo"arithmetic" alignedTo:"comparing""truncation and round off" atRandom normalize"enumerating" timesRepeat:"mathematical functions" degreeCos degreeSin factorial gcd: lcm: take:"bit manipulation" << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:"converting" asCharacter asColorOfDepth: asFloat asFraction asHexDigit"printing" asStringWithCommas hex hex8 radix:"system primitives" lastDigit replaceFrom:to:with:startingAt:"private" "benchmarks" ) do: [:sel | Approved add: sel]."SmallInteger, LargeNegativeInteger, LargePositiveInteger"	#("arithmetic" "bit manipulation" highBit "testing" "comparing" "copying" "converting" "printing" "system primitives" digitAt: digitLength "private" fromString:radix: ) do: [:sel | Approved add: sel].	#(digitAt:put: ) do: [:sel | AddAndRemove add: sel]."Float"	#("arithmetic""mathematical functions" reciprocalFloorLog: reciprocalLogBase2 timesTwoPower:"comparing" "testing""truncation and round off" exponent fractionPart integerPart significand significandAsInteger"converting" asApproximateFraction asIEEE32BitWord asTrueFraction"copying") do: [:sel | Approved add: sel]."Fraction, Random"	#(denominator numerator reduced next nextValue) do: [:sel | Approved add: sel].	#(setNumerator:denominator:) do: [:sel | AddAndRemove add: sel]."Collection"	#("accessing" anyOne"testing" includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isEmpty isSequenceable occurrencesOf:"enumerating" collect: collect:thenSelect: count: detect: detect:ifNone: detectMax: detectMin: detectSum: inject:into: reject: select: select:thenCollect: intersection:"converting" asBag asCharacterSet asSet asSortedArray asSortedCollection asSortedCollection:"printing""private" maxSize"arithmetic""math functions" average max median min range sum) do: [:sel | Approved add: sel].	#("adding" add: addAll: addIfNotPresent:"removing" remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat: remove:ifAbsent:) do: [:sel | AddAndRemove add: sel]."SequenceableCollection"	#("comparing" hasEqualElements:"accessing" allButFirst allButLast at:ifAbsent: atAll: atPin: atRandom: atWrap: fifth first fourth identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last second sixth third"removing""copying" , copyAfterLast: copyAt:put: copyFrom:to: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithout: copyWithoutAll: forceTo:paddingWith: shuffled sortBy:"enumerating" collectWithIndex: findFirst: findLast: pairsCollect: with:collect: withIndexCollect: polynomialEval:"converting" asArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray reversed"private" copyReplaceAll:with:asTokens: ) do: [:sel | Approved add: sel].	#( swap:with:) do: [:sel | AddAndRemove add: sel]."ArrayedCollection, Bag"	#("private" defaultElement "sorting" isSorted"accessing" cumulativeCounts sortedCounts sortedElements "testing" "adding" add:withOccurrences: "removing" "enumerating" 	) do: [:sel | Approved add: sel].	#( mergeSortFrom:to:by: sort sort: add: add:withOccurrences:"private" setDictionary ) do: [:sel | AddAndRemove add: sel]."Other messages that modify the receiver"	#(atAll:put: atAll:putAll: atAllPut: atWrap:put: replaceAll:with: replaceFrom:to:with:  removeFirst removeLast) do: [:sel | AddAndRemove add: sel].	self initialize2."MethodFinder new initialize.MethodFinder new organizationFiltered: Set"! !!ClassOrganizer methodsFor: 'accessing' stamp: 'NS 4/12/2004 20:57'!setDefaultList: aSortedCollection	| oldDict oldCategories |	oldDict := self elementCategoryDict.	oldCategories := self categories copy.	SystemChangeNotifier uniqueInstance doSilently: [		super setDefaultList: aSortedCollection].	self notifyOfChangedSelectorsOldDict: oldDict newDict: self elementCategoryDict.	self notifyOfChangedCategoriesFrom: oldCategories to: self categories.! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 19:57'!moveCursor: directionBlock forward: forward specialBlock: specialBlock	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| shift indices newPosition |	shift := sensor leftShiftDown.	indices := self setIndices: shift forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition := specialBlock value: newPosition].	sensor keyboard.	shift		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!ProcessorScheduler methodsFor: 'objects from disk' stamp: 'tk 9/28/2000 15:46'!objectForDataStream: refStrm	| dp |	"I am about to be written on an object file.  Write a path to me in the other system instead."	dp := DiskProxy global: #Processor selector: #yourself args: #().	refStrm replace: self with: dp.	^ dp! !!ClassCategoryReader methodsFor: 'private' stamp: '6/5/97 di'!setClass: aClass category: aCategory changeStamp: aString	class := aClass.	category := aCategory.	changeStamp := aString! !!Behavior methodsFor: 'accessing instances and variables' stamp: ''!instanceCount	"Answer the number of instances of the receiver that are currently in 	use."	| count |	count := 0.	self allInstancesDo: [:x | count := count + 1].	^count! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!addCategory: catString before: nextCategory	"Add a new category named heading.	If default category exists and is empty, remove it.	If nextCategory is nil, then add the new one at the end,	otherwise, insert it before nextCategory."	| index newCategory |	newCategory := catString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^self].	"heading already exists, so done"	index := categoryArray indexOf: nextCategory		ifAbsent: [categoryArray size + 1].	categoryArray := categoryArray		copyReplaceFrom: index		to: index-1		with: (Array with: newCategory).	categoryStops := categoryStops		copyReplaceFrom: index		to: index-1		with: (Array with: (index = 1				ifTrue: [0]				ifFalse: [categoryStops at: index-1])).	"remove empty default category"	(newCategory ~= Default			and: [(self listAtCategoryNamed: Default) isEmpty])		ifTrue: [self removeCategory: Default]! !!MethodFinder methodsFor: 'search' stamp: 'md 2/22/2006 21:23'!search: multi	"if Multi is true, collect all selectors that work."	selector := OrderedCollection new.	"list of them"	self simpleSearch.	multi not & (selector isEmpty not) ifTrue:[^ selector].	[self permuteArgs] whileTrue:		[self simpleSearch.		multi not & (selector isEmpty not) ifTrue: [^ selector]].	self insertConstants.	"(selector isEmpty not) ifTrue: [^ selector]].    expression is the answer, not a selector"	^ #()! !!ContextPart methodsFor: 'debugger access' stamp: 'tk 10/19/2001 10:20'!tempsAndValuesLimitedTo: sizeLimit indent: indent	"Return a string of the temporary variabls and their current values"	| aStream |	aStream := WriteStream on: (String new: 100).	self tempNames		doWithIndex: [:title :index |			indent timesRepeat: [aStream tab].			aStream nextPutAll: title; nextPut: $:; space; tab.			aStream nextPutAll: 				((self tempAt: index) printStringLimitedTo: (sizeLimit -3 -title size max: 1)).			aStream cr].	^aStream contents! !!ContextPart class methodsFor: 'simulation' stamp: 'di 2/10/1999 22:15'!initialize	"A unique object to be returned when a primitive fails during simulation"	PrimitiveFailToken := Object new  ! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/1/98 14:19'!explainTemp: string 	"Is string the name of a temporary variable (or block argument variable)?"	| selectedClass tempNames i reply methodNode method msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg := model selectedMessageName) ifNil: [^nil].	"not in a message"	selectedClass := model selectedClassOrMetaClass.	tempNames := selectedClass parserClass new 			parseArgsAndTemps: model selectedMessage notifying: nil.	method := selectedClass compiledMethodAt: msg.	(i := tempNames findFirst: [:each | each = string]) = 0 ifTrue: [		(method numTemps > tempNames size)			ifTrue: 				["It must be an undeclared block argument temporary"				methodNode := selectedClass compilerClass new							parse: model selectedMessage							in: selectedClass							notifying: nil.				tempNames := methodNode tempNames]			ifFalse: [^nil]].	(i := tempNames findFirst: [:each | each = string]) > 0 ifTrue: [i > method numArgs			ifTrue: [reply := '"is a temporary variable in this method"']			ifFalse: [reply := '"is an argument to this method"']].	^reply! !!Object methodsFor: 'scripting' stamp: 'yo 12/25/2003 16:43'!methodInterfacesForCategory: aCategorySymbol inVocabulary: aVocabulary limitClass: aLimitClass	"Return a list of methodInterfaces for the receiver in the given category, given a vocabulary.  aCategorySymbol is the inherent category symbol, not necessarily the wording as expressed in the vocabulary."	| categorySymbol |	categorySymbol := aCategorySymbol asSymbol.	(categorySymbol == ScriptingSystem nameForInstanceVariablesCategory) ifTrue: [		"user-defined instance variables"		^ self methodInterfacesForInstanceVariablesCategoryIn: aVocabulary].	(categorySymbol == ScriptingSystem nameForScriptsCategory) ifTrue: [		"user-defined scripts"		^ self methodInterfacesForScriptsCategoryIn: aVocabulary].	"all others"	^ self usableMethodInterfacesIn: (aVocabulary methodInterfacesInCategory: categorySymbol		forInstance: self		ofClass: self class		limitClass: aLimitClass)! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/5/2004 17:44'!removeEmptyCategories	"Remove empty categories."	| categoryIndex currentStop keptCategories keptStops |	keptCategories := WriteStream on: (Array new: 16).	keptStops := WriteStream on: (Array new: 16).	currentStop := categoryIndex := 0.	[(categoryIndex := categoryIndex + 1) <= categoryArray size]		whileTrue: 			[(categoryStops at: categoryIndex) > currentStop				ifTrue: 					[keptCategories nextPut: (categoryArray at: categoryIndex).					keptStops nextPut: (currentStop := categoryStops at: categoryIndex)]].	categoryArray := keptCategories contents.	categoryStops := keptStops contents.	categoryArray size = 0		ifTrue:			[categoryArray := Array with: Default.			categoryStops := Array with: 0]	"ClassOrganizer allInstancesDo: [:co | co removeEmptyCategories]."! !!Object methodsFor: 'copying' stamp: 'tk 4/20/1999 14:44'!copyTwoLevel	"one more level than a shallowCopy"	| newObject class index |	class := self class.	newObject := self clone.	newObject == self ifTrue: [^ self].	class isVariable		ifTrue: 			[index := self basicSize.			[index > 0]				whileTrue: 					[newObject basicAt: index put: (self basicAt: index) shallowCopy.					index := index - 1]].	index := class instSize.	[index > 0]		whileTrue: 			[newObject instVarAt: index put: (self instVarAt: index) shallowCopy.			index := index - 1].	^newObject! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:46'!check: nAttack against: nDefend difficulty: diff	"Roll some dice, WoD-style."	| attacks defends |	attacks := self check: nAttack difficulty: diff.	attacks < 0 ifTrue: [^ attacks].	defends := self check: nDefend difficulty: diff.	^ attacks - defends min: 0! !!Behavior methodsFor: 'accessing class hierarchy' stamp: ''!allSuperclasses	"Answer an OrderedCollection of the receiver's and the receiver's  	ancestor's superclasses. The first element is the receiver's immediate  	superclass, followed by its superclass; the last element is Object."	| temp |	^ superclass == nil		ifTrue: [ OrderedCollection new]		ifFalse: [temp := superclass allSuperclasses.			temp addFirst: superclass.			temp]! !!Categorizer methodsFor: 'accessing' stamp: 'NS 4/15/2004 12:33'!isEmptyCategoryNumber: anInteger	| firstIndex lastIndex |	(anInteger < 1 or: [anInteger > categoryStops size])		ifTrue: [^ true].	firstIndex := self firstIndexOfCategoryNumber: anInteger.	lastIndex :=  self lastIndexOfCategoryNumber: anInteger.	^ firstIndex > lastIndex! !!Delay methodsFor: 'private' stamp: 'jm 9/11/97 14:49'!adjustResumptionTimeOldBase: oldBaseTime newBase: newBaseTime	"Private!! Adjust the value of the system's millisecond clock at which this Delay will be awoken. Used to adjust resumption times after a snapshot or clock roll-over."	resumptionTime := newBaseTime + (resumptionTime - oldBaseTime).! !!CompiledMethod methodsFor: 'accessing' stamp: 'ls 6/22/2000 14:35'!primitive	"Answer the primitive index associated with the receiver.	Zero indicates that this is not a primitive method.	We currently allow 10 bits of primitive index, but they are in two places	for  backward compatibility.  The time to unpack is negligible,	since the reconstituted full index is stored in the method cache."	| primBits |	primBits := self header bitAnd: 16r100001FF.		^ (primBits bitAnd: 16r1FF) + (primBits bitShift: -19)! !!CompiledMethod methodsFor: 'printing' stamp: 'sw 7/29/2002 02:24'!dateMethodLastSubmitted	"Answer a Date object indicating when a method was last submitted.  If there is no date stamp, return nil"	"(CompiledMethod compiledMethodAt: #dateMethodLastSubmitted) dateMethodLastSubmitted"	| aStamp tokens |	aStamp := self timeStamp.	tokens := aStamp findBetweenSubStrs: ' '.  "space is expected delimiter, but cr is sometimes seen, though of mysterious provenance"	^ tokens size > 1		ifTrue:			[[tokens second asDate] ifError: [nil]]		ifFalse:			[nil]! !!ParagraphEditor methodsFor: 'private' stamp: 'th 9/19/2002 18:48'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where := paragraph text findString: FindText startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!+ aNumber 	"Answer the sum of the receiver and aNumber."	| n d d1 d2 |	aNumber isFraction ifTrue: 		[d := denominator gcd: aNumber denominator.		n := numerator * (d1 := aNumber denominator // d) + (aNumber numerator * (d2 := denominator // d)).		d1 := d1 * d2.		n := n // (d2 := n gcd: d).		(d := d1 * (d // d2)) = 1 ifTrue: [^ n].		^ Fraction numerator: n denominator: d].	^ aNumber adaptToFraction: self andSend: #+! !!Process methodsFor: 'changing suspended state' stamp: 'ajh 1/24/2003 16:14'!activateReturn: aContext value: value	"Activate 'aContext return: value', so execution will return to aContext's sender"	^ suspendedContext := suspendedContext activateReturn: aContext value: value! !!MethodDictionary methodsFor: 'accessing' stamp: 'NS 3/30/2004 13:42'!keys	"Since method all method selectors are symbols it is more efficient 	to use an IdentitySet rather than a Set."	| aSet |	aSet := IdentitySet new: self size.	self keysDo: [:key | aSet add: key].	^ aSet! !!Object methodsFor: 'viewer' stamp: 'sw 8/10/2004 11:53'!tilePhrasesForCategory: aCategorySymbol inViewer: aViewer	"Return a collection of phrases for the category."	| interfaces |	interfaces := self methodInterfacesForCategory: aCategorySymbol inVocabulary: aViewer currentVocabulary limitClass: aViewer limitClass.	interfaces := self methodInterfacesInPresentationOrderFrom: interfaces forCategory: aCategorySymbol.	^ self tilePhrasesForMethodInterfaces: interfaces inViewer: aViewer! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'al 11/28/2005 11:51'!printSubclassesOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subclassNames |	aStream crtab: level.	aStream nextPutAll: self name.	aStream space; print: self instVarNames.	self == Class		ifTrue: 			[aStream crtab: level + 1; nextPutAll: '[ ... all the Metaclasses ... ]'.			^self].	subclassNames := self subclasses asSortedCollection:[:c1 :c2| c1 name <= c2 name].	"Print subclasses in alphabetical order"	subclassNames do:		[:subclass | subclass printSubclassesOn: aStream level: level + 1]! !!ParagraphEditor methodsFor: 'current selection' stamp: 'th 9/19/2002 18:48'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	self select.	lineHeight := paragraph textStyle lineGrid.	clippingRectangle := paragraph clippingRectangle.	deltaY := self stopBlock top - clippingRectangle top.	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ObjectViewer methodsFor: 'very few messages' stamp: ''!doesNotUnderstand: aMessage 	"Check for change after sending aMessage"	| returnValue newValue |	recursionFlag ifTrue: [^ aMessage sentTo: tracedObject].	recursionFlag := true.	returnValue := aMessage sentTo: tracedObject.	newValue := valueBlock value.	newValue = lastValue ifFalse:		[changeBlock value.		lastValue := newValue].	recursionFlag := false.	^ returnValue! !!Object methodsFor: 'copying' stamp: 'tk 5/13/2003 19:39'!veryDeepCopyUsing: copier	"Do a complete tree copy using a dictionary.  An object in the tree twice is only copied once.  All references to the object in the copy of the tree will point to the new copy.	Same as veryDeepCopy except copier (with dictionary) is supplied.	** do not delete this method, even if it has no callers **"	| new refs newDep newModel |	new := self veryDeepCopyWith: copier.	copier mapUniClasses.	copier references associationsDo: [:assoc | 		assoc value veryDeepFixupWith: copier].	"Fix dependents"	refs := copier references.	DependentsFields associationsDo: [:pair |		pair value do: [:dep | 			(newDep := refs at: dep ifAbsent: [nil]) ifNotNil: [				newModel := refs at: pair key ifAbsent: [pair key].				newModel addDependent: newDep]]].	^ new! !Behavior removeSelector: #scopeHas:ifTrue:!CompiledMethod removeSelector: #decompileClass:selector:!ContextPart removeSelector: #methodSelector!Behavior removeSelector: #selectorAtMethod:setClass:!CompiledMethod removeSelector: #who!MethodContext removeSelector: #answer:!Integer removeSelector: #asFloatSimply!ContextPart removeSelector: #mclass!MethodContext removeSelector: #who!ProcessorScheduler initialize!InstructionStream initialize!Float initialize!Categorizer initialize!ContextPart initialize!