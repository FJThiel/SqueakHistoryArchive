"Change Set:		8866Kernel-tfel.383Kernel-tfel.383:Seems that (according to ISO8601) reading a Time from a stream without explicit UTC offset should not assume the local timezone, but rather UTC. This fixes DateAndTimeTest>>#testReadFromKernel-nice.371:Let allSubclasses and withAllSubclasses answer an OrderedCollection rather than a Set.PORTABILITY ISSUES:: application that would need a Set should use an explicit asSet.Kernel-nice.372:move a temp assignment to outer scopeKernel-ar.373:Move belongsToUniClass back to Kernel package.Kernel-ul.374:- code criticsKernel-ar.375:Promote isScriptEditorMorph to Object.Kernel-bf.376:- add DateAndTime>>asUnixTimeKernel-nice.377:add #selectorsAndMethodsDo: and use it to fast up some operationsThis is 4x faster than class selectorsDo: [:s | class compiledMethodAt: s]Kernel-nice.378:Fix so that (Float class>>#nan) = (Float class>>#nan)Kernel-nice.379:Correct a small bug in SqNumberParser #expected: does not expect a block argument.The bug was never reached because requestor is never set. The idea of requestor was st80 compiler based: insert the error message in source text, but it's not active yet.Kernel-nice.380:Fast-up linesOfCodeKernel-dtl.381:Use probabilistic algorithm (Knuth) for testing primality of large integers, and add method comments for explanation.Rationale for use of probabilistic algorithm provided by Enrico Spinielli:  http://lists.squeakfoundation.org/pipermail/squeak-dev/2009-December/142372.htmlKernel-ul.382:In MethodDictionary- cosmetic changes: use #ifNotNil: if possible- ensure that #rehashWithoutBecome doesn't send #become:, making #rehashAllInstances a lot faster- ensure that #removeAll preserves the capacity- deprecated #methodArray, it's the same as #array- new comment for #new"!!CompiledMethod methodsFor: 'comparing' stamp: 'nice 1/16/2010 18:33'!= method	| numLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(numLits := self numLiterals) ~= method numLiterals ifTrue: [^false].	"``Dont bother checking FFI and named primitives''	 (#(117 120) includes: self primitive) ifTrue: [^ true]."	1 to: numLits do:		[:i| | lit1 lit2 |		lit1 := self literalAt: i.		lit2 := method literalAt: i.		(lit1 == lit2 or: [lit1 = lit2]) ifFalse:			[(i = 1 and: [#(117 120) includes: self primitive])				ifTrue: [lit1 isArray							ifTrue:								[(lit2 isArray and: [lit1 allButLast = lit2 allButLast]) ifFalse:									[^false]]							ifFalse: "ExternalLibraryFunction"								[(lit1 analogousCodeTo: lit2) ifFalse:									[^false]]] ifFalse:			[i = (numLits - 1) ifTrue: "properties"				[(self properties analogousCodeTo: method properties) ifFalse:					[^false]] ifFalse:			 [lit1 isFloat				ifTrue:					["Floats match if values are close, due to roundoff error."					(lit1 closeTo: lit2) ifFalse: [^false]. self flag: 'just checking'. self halt]				ifFalse:					["any other discrepancy is a failure"					^ false]]]]].	^true! !!MethodDictionary methodsFor: 'copying' stamp: 'ul 1/25/2010 19:39'!postCopy	array := array copy! !!MethodDictionary methodsFor: 'private' stamp: 'ul 1/25/2010 22:39'!rehashWithoutBecome	| newInstance |	newInstance := self species new: self basicSize - 1. "Make sure it has the same capacity"	1 to: self basicSize do: [ :index | 		(self basicAt: index) ifNotNil: [ :key |			newInstance at: key put: (array at: index) ] ].	^newInstance! !!Object methodsFor: 'testing' stamp: 'ar 1/6/2010 23:53'!belongsToUniClass	"Answer whether the receiver belongs to a uniclass.  For the moment (this is not entirely satisfactory) this is precisely equated with the classname ending in a digit"	^ self class isUniClass! !!SqNumberParser methodsFor: 'parsing-private' stamp: 'nice 1/17/2010 18:25'!readNamedFloatOrFail	"This method is used when there is no digit encountered:	It try and read a named Float NaN or Infinity.	Negative sign for -Infinity has been read before sending this method, and is indicated in the neg inst.var.	Fail if no named Float is found"			neg ifFalse: [(sourceStream nextMatchAll: 'NaN')			ifTrue: [^ Float nan]].	(sourceStream nextMatchAll: 'Infinity')		ifTrue: [^ neg			ifTrue: [Float infinity negated]			ifFalse: [Float infinity]].	^self expected: 'a digit between 0 and ' , (Character digitValue: base - 1)! !!Integer methodsFor: 'testing' stamp: 'dtl 1/23/2010 14:16'!isPrime	"Answer true if the receiver is a prime number. See isProbablyPrime for a probabilistic	implementation that is much faster for large integers, and that is correct to an extremely	high statistical level of confidence (effectively deterministic)."		self <= 1 ifTrue: [ ^false ].	self even ifTrue: [ ^self = 2].	3 to: self sqrtFloor by: 2 do: [ :each |		self \\ each = 0 ifTrue: [ ^false ] ].	^true! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'nice 1/5/2010 14:17'!withAllSubclasses	"Answer a Collection of the receiver, the receiver's descendent's, and the  	receiver's descendent's subclasses."	^ self allSubclasses addFirst: self;		 yourself! !!MethodDictionary class methodsFor: 'instance creation' stamp: 'ul 1/25/2010 19:47'!new	"Create a new instance with 32 slots."		^self new: 16! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 1/25/2010 19:04'!associationsDo: aBlock 		tally = 0 ifTrue: [ ^self ].	1 to: self basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :key |			aBlock value: (Association key: key value: (array at: i)) ] ]! !!MethodDictionary methodsFor: 'removing' stamp: 'ul 1/25/2010 19:13'!removeAll	"This provides a faster way than repeated become.	a single become is still in use to prevent system crash."		| newSelf |	tally = 0 ifTrue: [^self].	newSelf := self species new: self basicSize - 1.  "This will preserve the capacity"	self become: newSelf! !!Behavior methodsFor: 'private' stamp: 'nice 1/15/2010 22:46'!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space |	space := 0.	self methodsDo: [:method |		space := space + 16.  "dict and org'n space"		space := space + (method size + 6 "hdr + avg pad").		method literals do: [:lit |			(lit isMemberOf: Array) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space := space + 12].			(lit isMemberOf: ByteString) ifTrue: [space := space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space := space + ((lit size + 1) * 4)]]].		^ space! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 1/25/2010 19:08'!keysDo: aBlock	tally = 0 ifTrue: [ ^self ].	1 to: self basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :key |			aBlock value: key ] ]! !!CompiledMethod methodsFor: 'source code management' stamp: 'nice 1/19/2010 00:34'!linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes empty lines."	| lines |	lines := 0.	self getSource asString lineIndicesDo: [:start :endWithoutDelimiters :end |		endWithoutDelimiters > start ifTrue: [lines := lines+1]].	^lines! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'nice 1/15/2010 23:13'!selectorsAndMethodsDo: selectorAndMethodBlock	"Evaluate the two argument selectorAndMethodBlock for all the selector/method pairs in my method dictionary."	^ self methodDict keysAndValuesDo: selectorAndMethodBlock! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 1/25/2010 19:04'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys and values passed to the block"		tally = 0 ifTrue: [^ self].	1 to: self basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :key |			aBlock value: key value: (array at: i) ] ]! !!Behavior methodsFor: 'accessing class hierarchy' stamp: 'nice 1/5/2010 14:05'!allSubclasses	"Answer a Collection of the receiver's and the receiver's descendent's subclasses. "	| scan scanTop |	scan := OrderedCollection withAll: self subclasses.	scanTop := 1.	[scanTop > scan size]		whileFalse: [scan addAll: (scan at: scanTop) subclasses.			scanTop := scanTop + 1].	^ scan! !!ContextPart class methodsFor: 'examples' stamp: 'ul 1/11/2010 07:48'!trace: aBlock onFileNamed: fileName	"ContextPart trace: [3 factorial] onFileNamed: 'trace'"	"This method uses the simulator to print calls to a file."	^FileStream fileNamed: fileName do: [ :file |		self trace: aBlock on: file ]! !!MethodDictionary methodsFor: 'private' stamp: 'ul 1/25/2010 19:16'!grow	| newSelf |	newSelf := self species new: self basicSize.  "This will double the size"	1 to: self basicSize do: [ :i | 		(self basicAt: i) ifNotNil: [ :key |			newSelf at: key put: (array at: i) ] ].	self become: newSelf! !!Monitor methodsFor: 'private' stamp: 'nice 1/5/2010 21:24'!exitAndWaitInQueue: anOrderedCollection maxMilliseconds: anIntegerOrNil	| lock delay |	lock := queuesMutex 		critical: [anOrderedCollection addLast: Semaphore new].	self exit.	anIntegerOrNil ifNil: [		lock wait	] ifNotNil: [		delay := MonitorDelay signalLock: lock afterMSecs: anIntegerOrNil inMonitor: self queue: anOrderedCollection.		lock wait.		delay unschedule.	].	self enter.! !!LargePositiveInteger methodsFor: 'testing' stamp: 'dtl 1/23/2010 14:30'!isPrime	"Answer true if the receiver is a prime number. Use a probabilistic implementation	 that	is much faster for large integers, and that is correct to an extremely high statistical	level of confidence (effectively deterministic)."	^ self isProbablyPrime! !!MethodDictionary methodsFor: 'private' stamp: 'ul 1/25/2010 19:16'!methodArray		self deprecated: 'Use #array'.	^array! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 1/25/2010 19:08'!valuesDo: aBlock 		tally = 0 ifTrue: [ ^self ].	1 to: self basicSize do: [ :i | 		(array at: i) ifNotNil: [ :value |			aBlock value: value ] ]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'bf 8/28/2008 13:45'!asUnixTime	"answer number of seconds since unix epoch (midnight Jan 1, 1970, UTC)"	^(self - self class unixEpoch) asSeconds! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'tfel 1/28/2010 02:31'!readFrom: aStream	| offset date time ch |	date := Date readFrom: aStream.	[aStream peek isDigit]		whileFalse: [aStream next].	time := Time readFrom: aStream.	aStream atEnd		ifTrue: [ offset := Duration zero ]		ifFalse: [			ch := aStream next.			ch = $+ ifTrue: [ch := Character space].			offset := Duration fromString: ch asString, '0:', aStream upToEnd, ':0'].			^ self		year: date year		month: date monthIndex		day: date dayOfMonth		hour: time hour		minute: time minute		second: time second		nanoSecond: time nanoSecond		offset: offset	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !!Behavior methodsFor: 'compiling' stamp: 'nice 1/15/2010 22:54'!recompileChanges	"Compile all the methods that are in the changes file.	This validates sourceCode and variable references and forces	methods to use the current bytecode set"	self selectorsAndMethodsDo:		[:sel :m | m fileIndex > 1 ifTrue:			[self recompile: sel from: self]]! !!CompiledMethod methodsFor: 'closures' stamp: 'ul 1/11/2010 07:24'!searchImageForHomeMethod	SystemNavigation default allObjectsDo: [:obj |		obj class == CompiledMethod ifTrue: [			(obj pointsTo: self) ifTrue: [^ obj searchImageForHomeMethod]		] ifFalse: [obj class == BlockClosure ifTrue: [			(obj method == self and: [obj size = 0])				ifTrue: [^ obj searchImageForHomeMethod]		]]	].	^ self  "must be a loner block method"! !!InstructionPrinter class methodsFor: 'printing' stamp: 'nice 1/15/2010 22:57'!printClass: class 	"Create a file whose name is the argument followed by '.bytes'. Store on 	the file the symbolic form of the compiled methods of the class."	| file |	file := FileStream newFileNamed: class name , '.bytes'.	class selectorsAndMethodsDo: 		[:sel :m | 		file cr; nextPutAll: sel; cr.		(self on: m) printInstructionsOn: file].	file close	"InstructionPrinter printClass: Parser."! !!Object methodsFor: 'testing' stamp: 'ar 1/11/2010 19:56'!isScriptEditorMorph	^false! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'bf 8/28/2008 13:19'!unixEpoch	"Answer a DateAndTime representing the Unix epoch (1 January 1970, midnight UTC)"	^ self basicNew		ticks: #(2440588 0 0) offset: Duration zero;		yourself.! !