"Change Set:		8087Kernel-nice.286Kernel-nice.286:My last fix conflicted with http://bugs.squeak.org/view.php?id=6695Float storeStringBase: does not store the radix Merge the two fixesKernel-nice.282:Just a comment about #isSelfEvaluatingKernel-nice.283:Make #arcTan: behave as libm atan2 near zero and negativeZeroKernel-ar.284:Merging Kernel-ul.283:Updated MethodDictionary- added MethodDictionary class >> #rehashAllInstances which rehashes all instances and changes the identities in one shot. Much faster than single #become: sends.- removed	- #add: - same implementation in superclass	- #at:putNoBecome:, #fullCheckNoBecome, #growNoBecome, #removeKeyNoBecome: - old methods with no senders (not even in 3.8 full), no comment stating their usefulness- modified several methods which have cleaner code and/or better performance assuming the following invariant: (self basicAt: index) isNil = (array at: index) isNil- added a line about the invariant to the class commentKernel-nice.285:store a Float exactly so it can be interpreted back unchanged - according to my solution proposed at http://bugs.squeak.org/view.php?id=1631Note that SqNumberParser SHOULD be used for interpreting the Number exactly.Previous Number>>readFrom: accumulate roundoff errors"!Dictionary variableSubclass: #MethodDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!MethodDictionary methodsFor: 'private' stamp: 'ul 10/30/2009 03:57'!rehashWithoutBecome	| newSelf |	newSelf := self species new: self size.	1 to: self basicSize do: [ :i | 		| key |		(key := self basicAt: i) ifNotNil: [			newSelf at: key put: (array at: i) ] ].	^newSelf! !!MethodDictionary methodsFor: 'private' stamp: 'ul 10/30/2009 04:20'!keyAt: index	^self basicAt: index! !!MethodDictionary methodsFor: 'private' stamp: 'ul 10/30/2009 03:59'!swap: oneIndex with: otherIndex	| element |	element := self basicAt: oneIndex.	self basicAt: oneIndex put: (self basicAt: otherIndex).	self basicAt: otherIndex put: element.	super swap: oneIndex with: otherIndex! !!Float methodsFor: 'mathematical functions' stamp: 'nice 10/30/2009 22:21'!arcTan: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive.	Implementation note: use sign in order to catch cases of negativeZero"	^self = 0.0		ifTrue: [denominator sign >= 0			ifTrue: [ 0 ]			ifFalse: [ self sign >= 0				ifTrue: [ Pi ]				ifFalse: [ Pi negated ]]]		ifFalse: [denominator = 0.0			ifTrue: [self > 0.0				ifTrue: [ Halfpi ]				ifFalse: [ Halfpi negated ]]			ifFalse: [denominator > 0				ifTrue: [ (self / denominator) arcTan ]				ifFalse: [self > 0					ifTrue: [ ((self / denominator) arcTan) + Pi ]					ifFalse: [ ((self / denominator) arcTan) - Pi ]]]]! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 10/30/2009 03:49'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."		value ifNotNil: [		1 to: self basicSize do: [ :index |			(array at: index) = value ifTrue: [				^self basicAt: index ] ] ].	^exceptionBlock value! !!Float methodsFor: 'printing' stamp: 'nice 10/31/2009 23:45'!storeOn: aStream base: base 	"Print the Number exactly so it can be interpreted back unchanged"	self isFinite		ifTrue: [self sign = -1 ifTrue: [aStream nextPutAll: '-'].			base = 10 ifFalse: [aStream print: base; nextPut: $r].			self = 0.0				ifTrue: [aStream nextPutAll: '0.0']				ifFalse: [self abs absPrintExactlyOn: aStream base: base]]		ifFalse: [self isNaN				ifTrue: [aStream nextPutAll: 'Float nan']				ifFalse: [self > 0.0						ifTrue: [aStream nextPutAll: 'Float infinity']						ifFalse: [aStream nextPutAll: 'Float infinity negated']]]! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 10/30/2009 04:02'!rehashAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: [ :each | each rehashWithoutBecome ].	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary class methodsFor: 'instance creation' stamp: 'ul 10/30/2009 04:01'!new	"change the default size to be a bit bigger to help reduce the number of #grows while filing in"		^self new: 16! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 10/30/2009 03:51'!associationsDo: aBlock 		tally = 0 ifTrue: [ ^self ].	1 to: self basicSize do: [ :i |		| key |		(key := self basicAt: i) ifNotNil: [			aBlock value: (Association key: key value: (array at: i)) ] ]! !!Float methodsFor: 'printing' stamp: 'nice 3/15/2008 22:41'!storeOn: aStream 	"Print the Number exactly so it can be interpreted back unchanged"		self storeOn: aStream base: 10! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 10/30/2009 03:53'!keysDo: aBlock	tally = 0 ifTrue: [ ^self ].	1 to: self basicSize do: [ :i |		| key |		(key := self basicAt: i) ifNotNil: [			aBlock value: key ] ]! !!Object methodsFor: 'self evaluating' stamp: 'nice 10/30/2009 20:46'!isSelfEvaluating	"Answer true if the receiver will print in a format evaluating to itself, that is	(Compiler evaluate: self printString) = self"		^ self isLiteral! !!MethodDictionary methodsFor: 'private' stamp: 'ul 10/30/2009 03:56'!removeDangerouslyKey: key ifAbsent: aBlock	"This is not really dangerous.  But if normal removal	were done WHILE a MethodDict were being used, the	system might crash.  So instead we make a copy, then do	this operation (which is NOT dangerous in a copy that is	not being used), and then use the copy after the removal."	| index element |	index := self scanFor: key.	(element := array at: index) ifNil: [ ^aBlock value ].	array at: index put: nil.	self basicAt: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^element! !!MethodDictionary methodsFor: 'removing' stamp: 'ul 10/30/2009 03:55'!removeKey: key ifAbsent: errorBlock 	"The interpreter might be using this MethodDict while	this method is running!!  Therefore we perform the removal	in a copy, and then atomically become that copy"	| copy |	copy := self copy.	copy removeDangerouslyKey: key ifAbsent: [^ errorBlock value].	self become: copy! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 10/30/2009 03:52'!do: aBlock	tally = 0 ifTrue: [ ^self ].	1 to: self basicSize do: [ :i | 		| value |		(value := array at: i) ifNotNil: [			aBlock value: value ] ]! !!MethodDictionary class methodsFor: 'instance creation' stamp: 'ul 10/30/2009 04:01'!new: nElements	"Create a Dictionary large enough to hold nElements without growing.	Note that the basic size must be a power of 2.	It is VITAL (see grow) that size gets doubled if nElements is a power of 2"		| size |	size := 1 bitShift: nElements highBit.	^(self basicNew: size) initialize: size! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 10/30/2009 03:44'!at: key put: value	"Set the value at key to be value."		| index |	index := self scanFor: key.	(self basicAt: index)		ifNil: [			tally := tally + 1.			self basicAt: index put: key ]		ifNotNil: [ (array at: index) flushCache ].	array at: index put: value.	self fullCheck.	^value! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 10/30/2009 03:52'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys and values passed to the block"		tally = 0 ifTrue: [^ self].	1 to: self basicSize do: [ :i |		| key |		(key := self basicAt: i) ifNotNil: [			aBlock value: key value: (array at: i) ] ]! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 10/30/2009 03:38'!at: key ifAbsent: aBlock	^(array at: (self scanFor: key)) ifNil: [ aBlock value ]! !!MethodDictionary methodsFor: 'private' stamp: 'ul 10/30/2009 04:22'!grow	| newSelf |	newSelf := self species new: self basicSize.  "This will double the size"	1 to: self basicSize do: [ :i | 		| key |		(key := self basicAt: i) ifNotNil: [			newSelf at: key put: (array at: i) ] ].	self become: newSelf! !!MethodDictionary methodsFor: 'private' stamp: 'ul 10/30/2009 04:20'!methodArray	^array! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ul 10/30/2009 04:23'!valuesDo: aBlock 		tally = 0 ifTrue: [ ^self ].	1 to: self basicSize do: [ :i | 		| value |		(value := array at: i) ifNotNil: [			aBlock value: value ] ]! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 10/30/2009 03:49'!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	value ifNotNil: [		1 to: self basicSize do: [ :index |			(array at: index) == value ifTrue: [				^self basicAt: index ] ] ].	^exceptionBlock value! !!MethodDictionary methodsFor: 'private' stamp: 'ul 10/30/2009 03:57'!rehash 		self become: self rehashWithoutBecome! !MethodDictionary removeSelector: #removeKeyNoBecome:!MethodDictionary removeSelector: #growNoBecome!MethodDictionary removeSelector: #add:!MethodDictionary removeSelector: #fullCheckNoBecome!MethodDictionary removeSelector: #at:putNoBecome:!