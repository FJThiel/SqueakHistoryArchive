"Change Set:		9219Traits-nice.280Traits-nice.280:push some temp declarations inside blocksTraits-ar.279:Fixes the traits bug masked by the issues with Class>>binding. When recompiling a selector/method pair, the original trait method needs to be preserved if the method came from a trait. Otherwise the method will be considered a locally defined method after the reshape which is incorrect."!!Trait class methodsFor: 'load-unload' stamp: 'nice 1/10/2010 17:46'!flattenTraitMethodsInClass: aClass	"Flatten all the trait methods in the given class"		(aClass isTrait or:[aClass hasTraitComposition]) ifFalse:[^self].	self storeTraitInfoInClass: aClass.	aClass selectorsAndMethodsDo:[:sel :meth| | oldClass |		(aClass includesLocalSelector: sel) ifFalse:[			oldClass := meth methodHome.			aClass compile: (aClass sourceCodeAt: sel)				classified: (aClass organization categoryOfElement: sel)				withStamp: (oldClass compiledMethodAt: sel ifAbsent:[meth]) timeStamp				notifying: nil]].	aClass traitComposition: #().! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/10/2010 17:46'!assembleTraitMethodsFrom: aTraitComposition	"Assemble the resulting methods for installing the given trait composition.	Returns a Dictionary instead of a MethodDictionary for speed (MDs grow by #become:)"	| methods |	methods := Dictionary new.	"Stick in the local methods first, since this avoids generating conflict methods unnecessarily"	self selectorsAndMethodsDo:[:sel :newMethod|		(self isLocalMethod: newMethod)			ifTrue:[methods at: sel put:newMethod]].	"Now assemble the traits methods"	aTraitComposition do:[:trait|		trait selectorsAndMethodsDo:[:sel :newMethod| | oldMethod |			oldMethod := methods at: sel ifAbsentPut:[newMethod].			newMethod == oldMethod ifFalse:["a conflict"				(self isLocalMethod: oldMethod) ifFalse:[					methods at: sel put: (self resolveTraitsConflict: sel from: oldMethod to: newMethod)]]]].	^methods! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/10/2010 17:46'!installTraitMethodDict: methods	"After having assembled the trait composition, install its methods."	| oldCategories removals |	"Apply the changes. We first add the new or changed methods."	oldCategories := Set new.	methods keysAndValuesDo:[:sel :newMethod| | oldMethod |		oldMethod := self compiledMethodAt: sel ifAbsent:[nil].		oldMethod == newMethod ifFalse:[			self traitAddSelector: sel withMethod: newMethod.			(self organization categoryOfElement: sel) ifNotNil:[:cat| oldCategories add: cat].			self organization classify: sel under: 				(newMethod methodHome organization categoryOfElement: newMethod selector)]].	"Now remove the old or obsoleted ones"	removals := OrderedCollection new.	self selectorsDo:[:sel| (methods includesKey: sel) ifFalse:[removals add: sel]].	removals do:[:sel| self traitRemoveSelector: sel].	"Clean out empty categories"	oldCategories do:[:cat|		(self organization isEmptyCategoryNamed: cat)			ifTrue:[self organization removeCategory: cat]].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'ar 2/2/2010 15:29'!recompile: selector from: oldClass	"Preserve the originalTraitMethod (if any) after recompiling a selector"	| oldMethod |	oldMethod := oldClass compiledMethodAt: selector.	super recompile: selector from: oldClass.	oldMethod originalTraitMethod ifNotNil:[:traitMethod|		(self compiledMethodAt: selector) originalTraitMethod: traitMethod.	].! !!ClassDescription methodsFor: '*Traits-NanoKernel' stamp: 'nice 1/10/2010 17:46'!updateTraitsFrom: instanceTraits	"ClassTrait/Metaclass only. Update me from the given instance traits"	| map newTraits |	self isMeta ifFalse:[self error: 'This is a metaclass operation'].	map := Dictionary new.	self traitComposition do:[:composed| map at: composed trait put: composed].	newTraits := (instanceTraits collect:[:composed| | trait |		trait := composed trait classTrait.		map at: trait ifAbsent:[trait]] 	), (self traitComposition select:[:comp| comp trait isBaseTrait]).	self installTraitsFrom: newTraits! !!Trait class methodsFor: 'load-unload' stamp: 'nice 1/10/2010 17:46'!restoreAllTraits		"Trait restoreAllTraits"	"Restores traits that had been previously removed.	This is the inverse operation to removeAllTraits."	| classes |	classes := Smalltalk allClasses select:[:aClass| aClass includesSelector: #traitInfo].	classes do:[:aClass| | method |		method := aClass compiledMethodAt: #traitInfo.		(method pragmaAt: #traitDefinition:) ifNotNil:[:pragma| 			pragma arguments first				ifTrue:[self convertClassToTrait: aClass]].	] displayingProgress:[:aClass| 'Creating trait ', aClass name].	classes := Smalltalk allClassesAndTraits select:[:aClass| 		(aClass includesSelector: #traitInfo) 			or:[aClass classSide includesSelector: #traitInfo]].	classes do:[:aClass|		self restoreCompositionOf: aClass.		self restoreCompositionOf: aClass classSide.	] displayingProgress:[:aClass| 'Updating ', aClass name].! !