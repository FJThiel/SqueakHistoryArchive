"Change Set:		8423Collections-nice.251Collections-nice.251:CharacterSetComplement can find fast in aByteString tooCollections-nice.247:Clean-up support code for mutating WideCharacterSet internal representation to ByteArrayCollections-nice.248:Just for fun, optimize a bit more WideCharacterSet bitmap:do:1) it now enumerates Characters in ascending value2) the trick to eliminate the lowest bit is just beautiful (a generalization of isPowerOfTwo)Of course, I could also tabulate all the bits in an Array of 255 ByteArray, but that would be no fun...Collections-nice.249:Oops, sorry for double posting, I forgot to update the comment.Note that it would be interesting to see how non inlined version performs in COG:| byte byteOffset |1 to: aMap size do: [:i | 	(byte := aMap at: i) = 0 ifFalse: [		byteOffset := (i bitShift: 3) - 9.		[aBlock value: (byteOffset + byte lowBit).		(byte := byte bitAnd: byte - 1) = 0] whileFalse]]Collections-nice.250:Implement subclassResponsibility remove:ifAbsent: in CharacterSet family.Cache the byteArrayMap of a WideCharacterSet.Update class comment."!Collection subclass: #WideCharacterSet	instanceVariableNames: 'map byteArrayMap'	classVariableNames: ''	poolDictionaries: ''	category: 'Collections-Support'!!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 12/10/2009 19:18'!remove: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	val < 256 ifTrue: [self byteArrayMap at: val + 1 put: 0].	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map				at: high				ifAbsent: [^ aCharacter].	self clearBitmap: lowmap at: low.	(lowmap allSatisfy: [:e | e = 0])		ifTrue: [map removeKey: high].	^ aCharacter! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 12/10/2009 19:20'!remove: aCharacter ifAbsent: aBlock	(self includes: aCharacter) ifFalse: [^aBlock value].	^self remove: aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 12/10/2009 19:20'!remove: aCharacter ifAbsent: aBlock	(self includes: aCharacter) ifFalse: [^aBlock value].	^self remove: aCharacter! !!Character methodsFor: 'converting' stamp: 'nice 12/7/2009 14:39'!asUnicode	| table charset v |	self leadingChar = 0 ifTrue: [^ value].	(charset := EncodedCharSet charsetAt: self leadingChar)		isCharset ifFalse: [^ self charCode].	(table := charset ucsTable)		ifNil: [^ 16rFFFD].	(v := table at: 1 + self charCode)		= -1 ifTrue: [^ 16rFFFD].	^ v.! !!CharacterSetComplement methodsFor: 'collection ops' stamp: 'nice 12/11/2009 09:03'!findFirstInByteString: aByteString startingAt: startIndex	"Double dispatching: since we know this is a ByteString, we can use a superfast primitive using a ByteArray map with 0 slots for byte characters not included and 1 for byte characters included in the receiver."	^ByteString		findFirstInString: aByteString		inSet: self byteArrayMap		startingAt: startIndex! !!WideCharacterSet methodsFor: 'initialize-release' stamp: 'nice 12/10/2009 18:56'!initialize	map := Dictionary new.	byteArrayMap := ByteArray new: 256! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 12/10/2009 19:11'!do: aBlock 	map		keysAndValuesDo: [:index :lowmap |			| high16Bits |			high16Bits := index bitShift: 16.			self				bitmap: lowmap				do: [:low16Bits | aBlock value: (Character value: high16Bits + low16Bits)]]! !!CharacterSet methodsFor: 'collection ops' stamp: 'nice 12/10/2009 19:20'!remove: aCharacter ifAbsent: aBlock	(self includes: aCharacter) ifFalse: [^aBlock value].	^self remove: aCharacter! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 12/10/2009 18:58'!removeAll	map removeAll.	byteArrayMap := ByteArray new: 256! !!WideCharacterSet methodsFor: 'collection ops' stamp: 'nice 12/10/2009 18:57'!add: aCharacter 	| val high low lowmap |	val := aCharacter asciiValue.	val < 256 ifTrue: [self byteArrayMap at: val + 1 put: 1].	high := val bitShift: -16.	low := val bitAnd: 16rFFFF.	lowmap := map at: high ifAbsentPut: ["create a chunk of 65536=8192*8 bits"		ByteArray new: 8192].	self setBitmap: lowmap at: low.	^ aCharacter! !!WideCharacterSet methodsFor: 'comparing' stamp: 'nice 12/10/2009 19:01'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.	Intended for use by primitives only. (and comparison)	This version will answer a subset with only byte characters"		| lowmap |	byteArrayMap ifNil: [		byteArrayMap := ByteArray new: 256.		lowmap := map at: 0 ifAbsent: [^byteArrayMap].		lowmap := lowmap copyFrom: 1 to: 32. "Keep first 8*32=256 bits..."		self bitmap: lowmap do: [:code | byteArrayMap at: code + 1 put: 1]].	^byteArrayMap! !!WideCharacterSet methodsFor: 'private' stamp: 'nice 12/10/2009 18:34'!bitmap: aMap do: aBlock	"Execute a block with each value (0 based) corresponding to set bits.	Implementation notes: this version works best for sparse maps.	It has (byte lowBit) inlined for speed."		| byte byteOffset lowBits |	lowBits := #[1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 8 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 7 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 6 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1 5 1 2 1 3 1 2 1 4 1 2 1 3 1 2 1]. "The lowBits table gives a 1-based bitOffset"	1 to: aMap size do: [:i | 		(byte := aMap at: i) = 0 ifFalse: [			byteOffset := (i bitShift: 3) - 9. "This byteOffset is -1 based"			["Evaluate the block with 0-based (byteOffset + bitOffset)"			aBlock value: (byteOffset + (lowBits at: byte)).			"Eliminate the low bit and loop if some bit remain"			(byte := byte bitAnd: byte - 1) = 0] whileFalse]]! !WideCharacterSet class removeSelector: #initialize!WideCharacterSet removeSelector: #wordBitmap:do:!WideCharacterSet removeSelector: #convertInternalRepresentationToByteArray!WideCharacterSet initialize!