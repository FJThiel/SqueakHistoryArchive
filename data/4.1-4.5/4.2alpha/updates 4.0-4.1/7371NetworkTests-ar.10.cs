"Change Set:		7371NetworkTests-ar.10NetworkTests-ar.10:Underscore removal."!!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal9	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g#s'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g#s'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal13	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x?y#s'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g;x?y#s'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal6	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '//g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://g'].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:32'!testSchemeAbsolutePass3	| uri |	uri := URI fromString: 'ftp://ftp@squeak.org'.	self should: [uri scheme = 'ftp'].	self should: [uri isAbsolute].	self shouldnt: [uri isOpaque].	self shouldnt: [uri isRelative].	self should: [uri userInfo = 'ftp'].	self should: [uri host = 'squeak.org'].	self should: [uri port isNil].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal10	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y#s'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y#s'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal3	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g'].! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:05'!testAbsoluteHTTP		url := 'hTTp://chaos.resnet.gatech.edu:8000/docs/java/index.html?A%20query%20#part' asUrl.	self assert: url schemeName = 'http'.	self assert: url authority = 'chaos.resnet.gatech.edu'.	self assert: url path first = 'docs'.	self assert: url path size = 3.	self assert: url query = 'A%20query%20'.	self assert: url fragment = 'part'.! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal17	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g#s/./x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g#s/./x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal14	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x=1/../y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/y'].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:18'!testCreationFromStringNotNil	| uuid string |	string := UUID new asString.	uuid := UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid asString size = 36].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal8	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '..g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/..g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal5	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g.'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g.'].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:27'!testCreationEquality	| uuid1 uuid2 |	uuid1 := UUID new.	uuid2 := UUID new.	self should: [uuid1 = uuid1].	self should: [uuid2 = uuid2].	self shouldnt: [uuid1 = uuid2].	self shouldnt: [uuid1 hash = uuid2 hash].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal19	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../..'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal2	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../../../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/../../g'].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 22:38'!testDuplicationsKinda	|check uuid size |	size := 5000.	check := Set new: size.	size timesRepeat: 		[uuid := UUID new.		self shouldnt: [check includes: uuid].		check add: uuid].		! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal16	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '..'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal13	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x=1/./y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g;x=1/y'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal10	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './g/.'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g/'].! !!UrlTest methodsFor: 'tests' stamp: 'gk 2/12/2004 21:30'!testAbsoluteFILE3	"Just a few selected tests for FileUrl, not complete by any means."	{'file:'. 'file:/'. 'file://'} do: [:s |	 	url := FileUrl absoluteFromText: s.		self assert: (url asString = 'file:///').		self assert: (url host = '').		self assert: url isAbsolute].		url := FileUrl absoluteFromText: 'file://localhost/dir/file.txt'.	self assert: (url asString = 'file://localhost/dir/file.txt').	self assert: (url host = 'localhost').		url := FileUrl absoluteFromText: 'file://localhost/dir/file.txt'.	self assert: (url asString = 'file://localhost/dir/file.txt').	self assert: (url host = 'localhost').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: 'file:///dir/file.txt'.	self assert: (url asString = 'file:///dir/file.txt').	self assert: (url host = '').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: '/dir/file.txt'.	self assert: (url asString = 'file:///dir/file.txt').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: 'dir/file.txt'.	self assert: (url asString = 'file:///dir/file.txt').	self deny: url isAbsolute.		url := FileUrl absoluteFromText: 'c:/dir/file.txt'.	self assert: (url asString = 'file:///c%3A/dir/file.txt').	self assert: url isAbsolute.		"Only a drive letter doesn't refer to a directory."	url := FileUrl absoluteFromText: 'c:'.	self assert: (url asString = 'file:///c%3A/').	self assert: url isAbsolute.		url := FileUrl absoluteFromText: 'c:/'.	self assert: (url asString = 'file:///c%3A/').	self assert: url isAbsolute! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFTP3		baseUrl := 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url := baseUrl newFromRelativeText: 'http:xyz'.	self assert: url asString = 'http://xyz/'.! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal20	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/'].! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:29'!testAbsoluteFILE		url := Url absoluteFromText: 'file:/etc/passwd#foo'.	self assert: url schemeName = 'file'.	self assert: url path first = 'etc'.	self assert: url path size = 2.		self assert: url fragment = 'foo'.! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeHTTP		baseUrl := 'http://some.where/some/dir?query1#fragment1' asUrl.	url := baseUrl newFromRelativeText: '../another/dir/?query2#fragment2'.	self assert: url asString =  'http://some.where/another/dir/?query2#fragment2'.! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFILE		| url2 |	baseUrl := 'file:/some/dir#fragment1' asUrl.	url := baseUrl newFromRelativeText: 'file:../another/dir/#fragment2'.	self assert: url asText =  'file:///another/dir/#fragment2'.		url := FileUrl absoluteFromText: 'file://localhost/dir/dir2/file.txt'.	url2 := FileUrl absoluteFromText: 'file://hostname/flip/file.txt'.	url2 privateInitializeFromText: '../file2.txt' relativeTo: url.	self assert: (url2 asString = 'file://localhost/dir/file2.txt').	self assert: (url2 host = 'localhost').	self assert: url2 isAbsolute.		url := FileUrl absoluteFromText: 'file://localhost/dir/dir2/file.txt'.	url2 := FileUrl absoluteFromText: 'flip/file.txt'.	self deny: url2 isAbsolute.	url2 privateInitializeFromText: '.././flip/file.txt' relativeTo: url.	self assert: (url2 asString = 'file://localhost/dir/flip/file.txt').	self assert: (url2 host = 'localhost').	self assert: url2 isAbsolute.	! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal8	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y'].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:39'!testSchemeAbsolutePass5	| uri |	uri := URI fromString: 'http://www.squeakland.org#fragment'.	self should: [uri scheme = 'http'].	self should: [uri isAbsolute].	self shouldnt: [uri isOpaque].	self shouldnt: [uri isRelative].	self should: [uri fragment = 'fragment'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal12	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g;x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g;x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal5	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '/g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/g'].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:25'!testSchemeAbsolutePass2	| uri |	uri := URI fromString: 'mailto:somebody@somewhere.nowhere'.	self should: [uri scheme = 'mailto'].	self should: [uri isAbsolute].	self should: [uri isOpaque].	self shouldnt: [uri isRelative]! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:16'!testCreationNil	| uuid |	uuid := UUID nilUUID.	self should: [uuid size = 16].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal2	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 16:12'!testResolveAbnormal16	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y/../x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y/../x'].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:17'!testCreationFromString	| uuid string |	string := UUID nilUUID asString.	uuid := UUID fromString: string.	self should: [uuid size = 16].	self should: [uuid = UUID nilUUID].	self should: [uuid isNilUUID].	self should: [uuid asString size = 36].	self should: [uuid asArray asSet size = 1].	self should: [(uuid asArray asSet asArray at: 1) = 0].! !!UrlTest methodsFor: 'testing' stamp: 'bp 2/12/2005 20:21'!testFromFileNameOrUrlString	url := Url absoluteFromFileNameOrUrlString: 'asdf'.	self assert: url schemeName = 'file'.	self assert: url fragment isNil.	self assert: url class = FileUrl.	url := Url absoluteFromFileNameOrUrlString: 'http://209.143.91.36/super/SuperSwikiProj/AAEmptyTest.001.pr'.	self assert: url schemeName = 'http'.	self assert: url fragment isNil.	self assert: url class = HttpUrl.! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal7	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g..'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g..'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal4	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '/../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/../g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal18	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal1	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/../g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal15	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal12	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g/../h'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/h'].! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFTP2		baseUrl := 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url := baseUrl newFromRelativeText: 'ftp:xyz'.	self assert: url asString =  'ftp://somewhere/some/dir/xyz'.! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:32'!testAbsoluteFILE2		url := 'fILE:/foo/bar//zookie/?fakequery/#fragger' asUrl.	self assert: url schemeName = 'file'.	self assert: url class = FileUrl.	self assert: url path first ='foo'.	self assert: url path size = 5.	self assert: url fragment = 'fragger'.! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal14	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '.'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal7	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '?y'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/?y'].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:38'!testSchemeAbsolutePass4	| uri |	uri := URI fromString: 'mailto:somebody@somewhere.nowhere#fragment'.	self should: [uri scheme = 'mailto'].	self should: [uri isAbsolute].	self should: [uri isOpaque].	self shouldnt: [uri isRelative].	self should: [uri fragment = 'fragment'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal11	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := ';x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/;x'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal1	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g:h'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'g:h'].! !!TestURI methodsFor: 'running parsing' stamp: 'mir 2/20/2002 17:24'!testSchemeAbsolutePass1	| uri |	uri := URI fromString: 'http://www.squeakland.org'.	self should: [uri scheme = 'http'].	self should: [uri isAbsolute].	self shouldnt: [uri isOpaque].	self shouldnt: [uri isRelative]! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal4	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g/'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g/'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal18	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g#s/../x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g#s/../x'].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:14'!testCreation	| uuid |	uuid := UUID new.	self should: [uuid size = 16].	self shouldnt: [uuid isNilUUID].	self should: [uuid asString size = 36].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 23:24'!testCreationNodeBased	| uuid |	(UUID new asString last: 12) = (UUID new asString last: 12) ifFalse: [^self].	1000 timesRepeat:		[uuid := UUID new.		self should: [((uuid at: 7) bitAnd: 16rF0) = 16r10].		self should: [((uuid at: 9) bitAnd: 16rC0) = 16r80]]! !!UrlTest methodsFor: 'tests' stamp: 'fbs 2/2/2005 13:21'!testRelativeFTP		baseUrl := 'ftp://somewhere/some/dir/?query#fragment' asUrl.	url := baseUrl newFromRelativeText: 'ftp://a.b'.	self assert: url asString =  'ftp://a.b/'.! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal15	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g?y/./x'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g?y/./x'].! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:58'!testAbsoluteBrowser	url := Url absoluteFromText: 'browser:bookmarks#mainPart'.	self assert: url schemeName = 'browser'.	self assert: url locator = 'bookmarks'.	self assert:url fragment = 'mainPart'.	self assert: url class = BrowserUrl.	! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:08'!testAbsoluteTELNET		url := 'telNet:chaos.resnet.gatech.edu#goo' asUrl.	self assert: url schemeName = 'telnet'.	self assert: url locator = 'chaos.resnet.gatech.edu'.	self assert: url fragment = 'goo'.	! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal9	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := './../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal6	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '.g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/.g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal3	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '/./g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/./g'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal17	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/'].! !!UrlTest methodsFor: 'tests' stamp: 'gk 2/12/2004 21:31'!testRoundTripFILE	"File URLs should round-trip OK. This test should ultimately be	tested on all platforms."	| fileName |	fileName := FileDirectory default fullNameFor: 'xxx.st'.	url := FileDirectory urlForFileNamed: fileName.	self assert: (url pathForFile = fileName) description: 'fileName didn''t round-trip'.! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveAbnormal11	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := 'g/./h'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/b/c/g/h'].! !!TestURI methodsFor: 'running resolving' stamp: 'mir 2/27/2002 14:42'!testResolveNormal21	| baseURI relURI resolvedURI |	baseURI := 'http://a/b/c/d;p?q' asURI.	relURI := '../../g'.	resolvedURI := baseURI resolveRelativeURI: relURI.	self should: [resolvedURI asString = 'http://a/g'].! !!UUIDPrimitivesTest methodsFor: 'tests' stamp: 'JMM 11/22/2001 17:37'!testOrder	| uuid1 uuid2 |	100 timesRepeat:		[uuid1 := UUID new.		uuid2 := UUID new.		(uuid1 asString last: 12) = (uuid2 asString last: 12) ifTrue:			[self should: [uuid1 < uuid2].			self should: [uuid2 > uuid1].			self shouldnt: [uuid1 = uuid2]]]! !!UrlTest methodsFor: 'tests' stamp: 'md 4/21/2003 13:05'!testAbsoluteFTP		url := 'ftP://some.server/some/directory/' asUrl.	self assert: url schemeName = 'ftp'.	self assert: url class = FtpUrl.	self assert: url authority = 'some.server'.		self assert: url path first = 'some'.	self assert: url path size  = 3.	! !