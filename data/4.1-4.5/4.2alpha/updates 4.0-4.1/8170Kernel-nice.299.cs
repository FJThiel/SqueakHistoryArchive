"Change Set:		8170Kernel-nice.299Kernel-nice.299:move DependentsArrayTest from Kernel to KernelTestsKernel-nice.298:cosmetic clean-up from pharoavoid a useless copy, and avoid inlining anySatisfy:Note that we reject: anySatisfy: references notEmptyWe could as well select: allSatisfy: references isEmptyAffirmations are generally better understood than double negations :)"!Collection weakSubclass: #DependentsArray	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Models'!!DependentsArray methodsFor: 'accessing' stamp: 'nice 11/11/2009 20:15'!at: anIndex put: anObject	| basicSize counter |	anIndex > 0 ifTrue: [		basicSize := self basicSize.		anIndex <= basicSize ifTrue: [			counter := 0.			1 to: basicSize do: [:i |				(self basicAt: i) == nil					ifFalse: [(counter := counter + 1) = anIndex ifTrue: [^self basicAt: i put: anObject]]]]].	self error: 'access with an index out of bounds'! !!DependentsArray methodsFor: 'enumerating' stamp: 'nice 11/11/2009 20:33'!collect: aBlock 	"Refer to the comment in Collection|select:."	| basicSize newSelf size dep selection |	basicSize := self basicSize.	newSelf := self species new: basicSize.	size := 0.	1 to: basicSize do: [:i |		(dep := self basicAt: i) notNil ifTrue: [newSelf basicAt: (size := size+1) put: (aBlock value: dep)]].	selection := self species new: size.	selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.	^selection! !!DependentsArray methodsFor: 'enumerating' stamp: 'nice 11/11/2009 20:34'!select: aBlock 	"Refer to the comment in Collection|select:."	| basicSize newSelf size dep selection |	basicSize := self basicSize.	newSelf := self species new: basicSize.	size := 0.	1 to: basicSize do: [:i |		((dep := self basicAt: i) notNil and: [aBlock value: dep]) ifTrue: [newSelf basicAt: (size := size+1) put: dep]].	selection := self species new: size.	selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.	^selection! !!DependentsArray class methodsFor: 'instance creation' stamp: 'nice 11/11/2009 17:24'!with: anObject	^(self basicNew: 1) basicAt: 1 put: anObject; yourself! !!DependentsArray methodsFor: 'accessing' stamp: 'nice 11/11/2009 19:20'!size	"count each non nil elements in self.	Note: count: will use do: which will already have filtered out nil elements"		^self count: [:each | true]! !!DependentsArray class methodsFor: 'instance creation' stamp: 'nice 11/11/2009 17:29'!with: firstObject with: secondObject with: thirdObject 	^(self basicNew: 3)		basicAt: 1 put: firstObject;		basicAt: 2 put: secondObject;		basicAt: 3 put: thirdObject;		yourself! !!DependentsArray methodsFor: 'accessing' stamp: 'nice 11/11/2009 17:19'!first	self do: [:dep | ^dep].	self error: 'this collection is empty'! !!DependentsArray methodsFor: 'private' stamp: 'nice 11/11/2009 17:08'!basicReplaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	start to: stop do: [:i |		self basicAt: i put: (replacement basicAt: repStart - start + i)]! !!DependentsArray methodsFor: 'copying' stamp: 'nice 11/11/2009 16:56'!copyWith: newElement 	"Re-implemented to not copy any niled out dependents."	| copy i |	copy := self class new: self size + 1.	i := 0.	self do: [:item | copy basicAt: (i:=i+1) put: item].	copy basicAt: (i:=i+1) put: newElement.	^copy! !!DependentsArray methodsFor: 'enumerating' stamp: 'nice 11/11/2009 17:18'!reverseDo: aBlock	"Refer to the comment in Collection|do:."	| dep |	self basicSize to: 1 by: -1 do: [:i |		(dep := self basicAt: i) ifNotNil: [aBlock value: dep]]! !!DependentsArray class methodsFor: 'instance creation' stamp: 'nice 11/11/2009 17:29'!withAll: aCollection	| newInstance |	newInstance := self basicNew: aCollection size.	1 to: aCollection size do: [:i |		newInstance basicAt: i put: (aCollection at: i)].	^newInstance! !!DependentsArray methodsFor: 'accessing' stamp: 'nice 11/11/2009 17:19'!at: anIndex	| basicSize counter dep |	anIndex > 0 ifTrue: [		basicSize := self basicSize.		anIndex <= basicSize ifTrue: [			counter := 0.			1 to: basicSize do: [:i |				(dep := self basicAt: i) == nil					ifFalse: [(counter := counter + 1) = anIndex ifTrue: [^dep]]]]].	self error: 'access with an index out of bounds'! !!DependentsArray class methodsFor: 'instance creation' stamp: 'nice 11/11/2009 17:29'!with: firstObject with: secondObject 	^(self basicNew: 2)		basicAt: 1 put: firstObject;		basicAt: 2 put: secondObject;		yourself! !!Behavior methodsFor: 'user interface' stamp: 'marcus.denker 9/29/2008 15:17'!allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	^ self allInstVarNames reject: [:ivn |		| definingClass |				definingClass := self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses anySatisfy: [:class |  				(class whichSelectorsAccess: ivn asSymbol) notEmpty]]! !!DependentsArray class methodsFor: 'instance creation' stamp: 'nice 11/11/2009 17:30'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	^(self basicNew: 6)		basicAt: 1 put: firstObject;		basicAt: 2 put: secondObject;		basicAt: 3 put: thirdObject;		basicAt: 4 put: fourthObject;		basicAt: 5 put: fifthObject;		basicAt: 6 put: sixthObject;		yourself! !!DependentsArray class methodsFor: 'instance creation' stamp: 'nice 11/11/2009 17:29'!with: firstObject with: secondObject with: thirdObject with: fourthObject 	^(self basicNew: 4)		basicAt: 1 put: firstObject;		basicAt: 2 put: secondObject;		basicAt: 3 put: thirdObject;		basicAt: 4 put: fourthObject;		yourself! !!DependentsArray methodsFor: 'accessing' stamp: 'nice 11/11/2009 17:19'!last	self reverseDo: [:dep | ^dep].	self error: 'this collection is empty'! !!DependentsArray methodsFor: 'enumerating' stamp: 'nice 11/11/2009 20:36'!do: aBlock	"Evaluate a Block on non nil elements of the receiver"	| dep |	1 to: self basicSize do:[:i|		(dep := self basicAt: i) ifNotNil:[aBlock value: dep]].! !!DependentsArray class methodsFor: 'instance creation' stamp: 'nice 11/11/2009 17:29'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	^(self basicNew: 5)		basicAt: 1 put: firstObject;		basicAt: 2 put: secondObject;		basicAt: 3 put: thirdObject;		basicAt: 4 put: fourthObject;		basicAt: 5 put: fifthObject;		yourself! !