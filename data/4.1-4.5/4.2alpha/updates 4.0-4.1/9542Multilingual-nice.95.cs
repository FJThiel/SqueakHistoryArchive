"Change Set:		9542Multilingual-nice.95Multilingual-nice.95:Fix endOfRun and crossedX encodings in paragraph composition - Part 2"!!MultiCharacterBlockScanner methodsFor: 'scanning' stamp: 'nice 2/28/2010 18:21'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX maxAscii startEncoding char charValue floatDestX widthAndKernedWidth nextChar |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		f := [font fontArray at: startEncoding + 1]			on: Exception do: [:ex | nil].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	floatDestX := destX.	widthAndKernedWidth := Array new: 2.	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops endOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		charValue > maxAscii ifTrue: [charValue := maxAscii].		(encoding = 0 and: [(stops at: charValue + 1) ~~ nil]) ifTrue: [			^ stops at: charValue + 1		].		nextChar := (lastIndex + 1 <= stopIndex) 			ifTrue:[sourceString at: lastIndex + 1]			ifFalse:[nil].		font 			widthAndKernedWidthOfLeft: ((char isMemberOf: CombinedChar) ifTrue:[char base] ifFalse:[char]) 			right: nextChar			into: widthAndKernedWidth.		nextDestX := floatDestX + (widthAndKernedWidth at: 1).			nextDestX > rightX ifTrue: [^ stops crossedX].		floatDestX := floatDestX + kernDelta + (widthAndKernedWidth at: 2).		destX := floatDestX.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops endOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'nice 2/28/2010 18:16'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| charCode encoding f startEncoding combining combined combiningIndex c |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		f := [font fontArray at: startEncoding + 1]			on: Exception do: [:ex | nil].		f ifNil: [ f := font fontArray at: 1].	].	spaceWidth := font widthOf: Space.	combining := nil.	[lastIndex <= stopIndex] whileTrue: [		charCode := (sourceString at: lastIndex) charCode.		c := (sourceString at: lastIndex).		combining ifNil: [			combining := CombinedChar new.			combining add: c.			combiningIndex := lastIndex.			lastIndex := lastIndex + 1.		] ifNotNil: [			(combining add: c) ifFalse: [				self addCharToPresentation: (combined := combining combined).				combining := CombinedChar new.				combining add: c.				charCode := combined charCode.				encoding := combined leadingChar.				encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1.					(encoding = 0 and: [charCode < 256 and:[(stops at: charCode + 1) notNil]]) ifTrue: [						^ stops at: charCode + 1					] ifFalse: [						 ^ stops endOfRun					].				].				(encoding = 0 and: [charCode < 256 and:[(stops at: charCode + 1) notNil]]) ifTrue: [					combining ifNotNil: [						self addCharToPresentation: (combining combined).					].					^ stops at: charCode + 1				].				(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [					self registerBreakableIndex.				].						destX > rightX ifTrue: [					destX ~= firstDestX ifTrue: [						lastIndex := combiningIndex.						self removeLastCharFromPresentation.						^ stops crossedX]].				combiningIndex := lastIndex.				lastIndex := lastIndex + 1.			] ifTrue: [				lastIndex := lastIndex + 1.				numOfComposition := numOfComposition + 1.			].		].	].	lastIndex := stopIndex.	combining ifNotNil: [		combined := combining combined.		self addCharToPresentation: combined.		"assuming that there is always enough space for at least one character".		destX := destX + (self widthOf: combined inFont: font).	].	^ stops endOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'nice 2/28/2010 18:20'!scanMultiCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX maxAscii startEncoding floatDestX widthAndKernedWidth nextChar atEndOfRun |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		f := [font fontArray at: startEncoding + 1]			on: Exception do: [:ex | nil].		f ifNil: [ f := font fontArray at: 1].		maxAscii := f maxAscii.		spaceWidth := f widthOf: Space.	] ifFalse: [		maxAscii := font maxAscii.	].	floatDestX := destX.	widthAndKernedWidth := Array new: 2.	atEndOfRun := false.	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops endOfRun].		ascii := (sourceString at: lastIndex) charCode.		ascii > maxAscii ifTrue: [ascii := maxAscii].		(encoding = 0 and: [ascii < stops size and: [(stops at: ascii + 1) ~~ nil]]) ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: Latin1Environment) ifTrue: [			self registerBreakableIndex.		].		nextChar := (lastIndex + 1 <= stopIndex) 			ifTrue:[sourceString at: lastIndex + 1]			ifFalse:[				atEndOfRun := true.				"if there is a next char in sourceString, then get the kern 				and store it in pendingKernX"				lastIndex + 1 <= sourceString size					ifTrue:[sourceString at: lastIndex + 1]					ifFalse:[	nil]].		font 			widthAndKernedWidthOfLeft: (sourceString at: lastIndex) 			right: nextChar			into: widthAndKernedWidth.		nextDestX := floatDestX + (widthAndKernedWidth at: 1).		nextDestX > rightX ifTrue: [destX ~= firstDestX ifTrue: [^stops crossedX]].		floatDestX := floatDestX + kernDelta + (widthAndKernedWidth at: 2).		atEndOfRun 			ifTrue:[				pendingKernX := (widthAndKernedWidth at: 2) - (widthAndKernedWidth at: 1).				floatDestX := floatDestX - pendingKernX].		destX := floatDestX .		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops endOfRun! !!MultiDisplayScanner methodsFor: 'multilingual scanning' stamp: 'nice 2/28/2010 18:16'!scanMultiCharactersCombiningFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| encoding f nextDestX startEncoding char charValue |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		f := [font fontArray at: startEncoding + 1]			on: Exception do: [:ex | nil].		f ifNil: [ f := font fontArray at: 1].		spaceWidth := f widthOf: Space.	].	[lastIndex <= stopIndex] whileTrue: [		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops endOfRun].		char := (sourceString at: lastIndex).		charValue := char charCode.		(encoding = 0 and: [charValue < 256 and:[(stops at: charValue + 1) notNil]]) 			ifTrue: [^stops at: charValue + 1].		nextDestX := destX + (self widthOf: char inFont: font).		nextDestX > rightX ifTrue: [^ stops crossedX].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops endOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'nice 2/28/2010 18:18'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := EncodedCharSet scanSelectorAt: startEncoding.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stops with: kernDelta).	].		^ stops endOfRun! !!MultiCharacterScanner methodsFor: 'scanner methods' stamp: 'nice 2/28/2010 18:18'!scanJapaneseCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| ascii encoding f nextDestX startEncoding |	lastIndex := startIndex.	lastIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].	startEncoding := (sourceString at: startIndex) leadingChar.	font ifNil: [font := (TextConstants at: #DefaultMultiStyle) fontArray at: 1].	((font isMemberOf: StrikeFontSet) or: [font isKindOf: TTCFontSet]) ifTrue: [		f := [font fontArray at: startEncoding + 1]			on: Exception do: [:ex | nil].		f ifNil: [ f := font fontArray at: 1].		spaceWidth := f widthOf: Space.	] ifFalse: [		(font isMemberOf: HostFont) ifTrue: [			f := font.			spaceWidth := f widthOf: Space.		].	].	[lastIndex <= stopIndex] whileTrue: [		"self halt."		encoding := (sourceString at: lastIndex) leadingChar.		encoding ~= startEncoding ifTrue: [lastIndex := lastIndex - 1. ^ stops endOfRun].		ascii := (sourceString at: lastIndex) charCode.		(encoding = 0 and: [ascii < 256 and:[(stops at: ascii + 1) notNil]]) 			ifTrue: [^ stops at: ascii + 1].		(self isBreakableAt: lastIndex in: sourceString in: (EncodedCharSet charsetAt: encoding)) ifTrue: [			self registerBreakableIndex.		].		nextDestX := destX + (font widthOf: (sourceString at: lastIndex)).		nextDestX > rightX ifTrue: [firstDestX ~= destX ifTrue: [^ stops crossedX]].		destX := nextDestX + kernDelta.		lastIndex := lastIndex + 1.	].	lastIndex := stopIndex.	^ stops endOfRun! !!MultiCharacterScanner methodsFor: 'scanning' stamp: 'nice 2/28/2010 18:19'!basicScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char floatDestX widthAndKernedWidth nextChar atEndOfRun |	<primitive: 103>	lastIndex := startIndex.	floatDestX := destX.	widthAndKernedWidth := Array new: 2.	atEndOfRun := false.	[lastIndex <= stopIndex]		whileTrue: 			[char := (sourceString at: lastIndex).			ascii := char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextChar := (lastIndex + 1 <= stopIndex) 				ifTrue:[sourceString at: lastIndex + 1]				ifFalse:[					atEndOfRun := true.					"if there is a next char in sourceString, then get the kern 					and store it in pendingKernX"					lastIndex + 1 <= sourceString size						ifTrue:[sourceString at: lastIndex + 1]						ifFalse:[	nil]].			font 				widthAndKernedWidthOfLeft: char 				right: nextChar				into: widthAndKernedWidth.			nextDestX := floatDestX + (widthAndKernedWidth at: 1).			nextDestX > rightX ifTrue: [^stops crossedX].			floatDestX := floatDestX + kernDelta + (widthAndKernedWidth at: 2).			atEndOfRun 				ifTrue:[					pendingKernX := (widthAndKernedWidth at: 2) - (widthAndKernedWidth at: 1).					floatDestX := floatDestX - pendingKernX].			destX := floatDestX.			lastIndex := lastIndex + 1].	lastIndex := stopIndex.	^stops endOfRun! !