"Change Set:		8028Kernel-nice.278Kernel-nice.278:Use #keys rather than #fasterKeysNote that pattern (x keys asArray sort) could as well be written (x keys sort) now that keys returns an Array...This #asArray is here solely for cross-dialect/fork compatibility.Kernel-nice.277:remove #keys and let super return an Array rather than an IdentitySet"!!Object methodsFor: 'events-removing' stamp: 'nk 8/25/2003 21:46'!removeActionsSatisfying: aBlock	self actionMap keys do:		[:eachEventSelector |			self   				removeActionsSatisfying: aBlock				forEvent: eachEventSelector		]! !!Class methodsFor: 'fileIn/Out' stamp: 'nice 10/21/2009 00:02'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName aValue |	(aPool  isKindOf: SharedPool class) ifTrue:[^self notify: 'we do not fileout SharedPool type shared pools for now'].	aPoolName := self environment keyAtIdentityValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asArray sort do: [ :aKey |		aValue := aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!ClassBuilder class methodsFor: 'cleanup obsolete classes' stamp: 'nice 10/20/2009 23:37'!cleanupClassHierarchyFor: aClassDescription		| myName mySuperclass |	mySuperclass := aClassDescription superclass.	(self isReallyObsolete: aClassDescription) ifTrue: [				"Remove class >>>from SystemDictionary if it is obsolete"		myName := aClassDescription name asString.		Smalltalk keys do: [:each | 			(each asString = myName and: [(Smalltalk at: each) == aClassDescription])				ifTrue: [Smalltalk removeKey: each]].		"Make class officially obsolete if it is not"		(aClassDescription name asString beginsWith: 'AnObsolete')			ifFalse: [aClassDescription obsolete].		aClassDescription isObsolete 			ifFalse: [self error: 'Something wrong!!'].		"Add class to obsoleteSubclasses of its superclass"		mySuperclass			ifNil: [self error: 'Obsolete subclasses of nil cannot be stored'].		(mySuperclass obsoleteSubclasses includes: aClassDescription)			ifFalse: [mySuperclass addObsoleteSubclass: aClassDescription].	] ifFalse:[		"check if superclass has aClassDescription in its obsolete subclasses"		mySuperclass ifNil:[mySuperclass := Class]. "nil subclasses"		mySuperclass removeObsoleteSubclass: aClassDescription.	].	"And remove its obsolete subclasses if not actual superclass"	aClassDescription obsoleteSubclasses do:[:obs|		obs superclass == aClassDescription ifFalse:[			aClassDescription removeObsoleteSubclass: obs]].! !!ClassDescription methodsFor: 'printing' stamp: 'nice 10/21/2009 00:03'!classVariablesString	"Answer a string of my class variable names separated by spaces."	^String streamContents: [ :stream | 		self classPool keys asArray sort 			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream space ] ]! !!Class methodsFor: 'initialize-release' stamp: 'dvf 9/27/2005 17:34'!declare: varString 	"Declare class variables common to all instances. Answer whether 	recompilation is advisable."	| newVars conflicts |	newVars := 		(Scanner new scanFieldNames: varString)			collect: [:x | x asSymbol].	newVars do:		[:var | var first canBeGlobalVarInitial			ifFalse: [self error: var, ' class variable name should be capitalized; proceed to include anyway.']].	conflicts := false.	classPool == nil 		ifFalse: [(classPool keys reject: [:x | newVars includes: x]) do: 					[:var | self removeClassVarName: var]].	(newVars reject: [:var | self classPool includesKey: var])		do: [:var | "adding"			"check if new vars defined elsewhere"			(self bindingOf: var) notNil				ifTrue: 					[self error: var , ' is defined elsewhere'.					conflicts := true]].	newVars size > 0		ifTrue: 			[classPool := self classPool.			"in case it was nil"			newVars do: [:var | classPool declare: var from: Undeclared]].	^conflicts! !MethodDictionary removeSelector: #keys!