"Change Set:		9731Graphics-ar.122Graphics-ar.122:Remove unnecessary X11 font license from the importer.Graphics-nice.121:1) Add some missing pendingKernX reset.2) explicit a loop dependency on stopCondition"!!CharacterScanner methodsFor: 'scanning' stamp: 'nice 3/18/2010 21:25'!plainTab	"This is the basic method of adjusting destX for a tab."	destX := (alignment = Justified and: [self leadingTab not])		ifTrue:		"embedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	pendingKernX := 0.! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'nice 3/18/2010 21:36'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	spaceCount := spaceCount + 1.	destX := destX + spaceWidth + (line justifiedPadFor: spaceCount font: font).	lastIndex := lastIndex + 1.	pendingKernX := 0.	^ false! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'nice 3/19/2010 18:40'!characterBlockAtPoint: aPoint index: index in: textLine	"This method is the Morphic characterBlock finder.  It combines	MVC's characterBlockAtPoint:, -ForIndex:, and buildCharcterBlock:in:"	| runLength lineStop stopCondition |	line := textLine.	rightMargin := line rightMargin.	lastIndex := line first.	self setStopConditions.		"also sets font"	characterIndex := index.  " == nil means scanning for point"	characterPoint := aPoint.	(characterPoint isNil or: [characterPoint y > line bottom])		ifTrue: [characterPoint := line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex notNil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	destX := leftMargin := line leftMarginForAlignment: alignment.	destY := line top.	runLength := text runLengthFor: line first.	characterIndex		ifNotNil:	[lineStop := characterIndex  "scanning for index"]		ifNil:	[lineStop := line last  "scanning for point"].	runStopIndex := lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent := 0 @ line lineHeight.	spaceCount := 0.	[		stopCondition := self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block operations."		self lastCharacterExtentSetX: (specialWidth			ifNil: [font widthOf: (text at: lastIndex)]			ifNotNil: [specialWidth]).		self perform: stopCondition	] whileFalse.	characterIndex		ifNil: [			"Result for characterBlockAtPoint: "			(stopCondition ~~ #cr and: [ lastIndex == line last				and: [ aPoint x > ((characterPoint x) + (lastCharacterExtent x / 2)) ]])					ifTrue: [ "Correct for right half of last character in line"						^ (CharacterBlock new stringIndex: lastIndex + 1								text: text								topLeft: characterPoint + (lastCharacterExtent x @ 0) + (font descentKern @ 0)								extent:  0 @ lastCharacterExtent y)							textLine: line ].				^ (CharacterBlock new					stringIndex: lastIndex					text: text topLeft: characterPoint + (font descentKern @ 0)					extent: lastCharacterExtent - (font baseKern @ 0))							textLine: line]		ifNotNil: ["Result for characterBlockForIndex: "				^ (CharacterBlock new					stringIndex: characterIndex					text: text topLeft: characterPoint + ((font descentKern) - kern @ 0)					extent: lastCharacterExtent)							textLine: line]! !BDFFontReader class removeSelector: #x11FontLegalNotices!