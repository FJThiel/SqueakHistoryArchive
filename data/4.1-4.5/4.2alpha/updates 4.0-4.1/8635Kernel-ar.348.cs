"Change Set:		8635Kernel-ar.348Kernel-ar.348:NanoTrait preparations: Vector all traits dependencies through a protocol in ClassDescription so that we can have alternative trait versions be the default. Provide CompiledMethod>>methodHome to ask for the original place a particular method was defined (methodHome == methodClass for all 'normal' methods). Additional guards for Berne trait idiosynchracies (updateOrganizationSelector: etc) that simply do not apply for alternative traits."!Behavior subclass: #ClassDescription	uses: TCopyingDescription + TBasicCategorisingDescription + TCompilingDescription + TAccessingMethodDictDescription + TTraitsCategorisingDescription + TPrintingDescription + TCommentDescription + TFileInOutDescription + TTestingDescription	instanceVariableNames: 'instanceVariables organization'	classVariableNames: 'TraitImpl'	poolDictionaries: ''	category: 'Kernel-Classes'!!ClassDescription class methodsFor: 'traits' stamp: 'ar 12/27/2009 14:10'!newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString	"Creates a new trait. If no current trait implementation	is installed, raise an error."	^TraitImpl 		ifNil:[self error: 'Traits are not installed'] 		ifNotNil:[TraitImpl newTraitNamed: aSymbol uses: aTraitCompositionOrCollection category: aString]! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'ar 12/27/2009 21:08'!removeSelector: selector 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	| priorMethod priorProtocol | 	priorMethod := self compiledMethodAt: selector ifAbsent: [^ nil].	priorProtocol := self whichCategoryIncludesSelector: selector.	"-- support for alternative trait implementation --"	(self traitComposition isKindOf: TraitComposition) ifFalse:[		SystemChangeNotifier uniqueInstance doSilently: [			self organization removeElement: selector].	].	super removeSelector: selector.	(self traitComposition isKindOf: TraitComposition) ifTrue:[		SystemChangeNotifier uniqueInstance doSilently: [self updateOrganizationSelector: selector oldCategory: priorProtocol newCategory: nil].	].	SystemChangeNotifier uniqueInstance 			methodRemoved: priorMethod selector: selector inProtocol: priorProtocol class: self.! !!ClassDescription methodsFor: 'organization updating' stamp: 'ar 12/27/2009 14:43'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| currentCategory effectiveCategory sel changedCategories composition |	changedCategories := IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	"-- support for alternative trait implementation --"	(composition isKindOf: TraitComposition) ifFalse:[^self].	(composition methodDescriptionsForSelector: aSymbol) do: [:each |		sel := each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory := self organization categoryOfElement: sel.			effectiveCategory := each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!Class methodsFor: 'accessing' stamp: 'ar 12/27/2009 15:24'!hasTraitComposition	^traitComposition notNil and:[traitComposition isEmpty not]! !!ClassDescription class methodsFor: 'traits' stamp: 'ar 12/27/2009 14:07'!traitImpl: aTraitClass	"Make the given trait class the default implementor of traits"	TraitImpl := aTraitClass.! !!ClassDescription class methodsFor: 'traits' stamp: 'ar 12/27/2009 14:32'!allTraitsDo: aBlock	"Evaluate aBlock with all the instance and class traits present in the system"	TraitImpl ifNotNil:[TraitImpl allTraitsDo: aBlock].! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/20/2009 13:32'!fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors := (aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	selectors := selectors select: [:each | (self includesLocalSelector: each)].		"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!Metaclass methodsFor: 'accessing' stamp: 'ar 12/27/2009 14:44'!traitComposition	"Vector the creation through ClassDescription to support alternative traits"	^traitComposition ifNil: [traitComposition := ClassDescription newTraitComposition].! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'ar 12/22/2009 07:54'!methodHome	"The behavior (trait/class) this method was originally defined in. 	The methodClass in AdditionalMethodState but subclasses 	(TraitMethodState) may know differently"	^method methodClass! !!ClassDescription class methodsFor: 'traits' stamp: 'ar 12/27/2009 19:06'!newTraitTemplateIn: categoryString	^TraitImpl ifNil:[''] ifNotNil:[TraitImpl newTemplateIn: categoryString].! !!Behavior methodsFor: 'adding/removing methods' stamp: 'ar 12/27/2009 15:00'!removeSelector: aSelector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method.		If the method to remove will be replaced by a method from my trait composition,	the current method does not have to be removed because we mark it as non-local.	If it is not identical to the actual method from the trait it will be replaced automatically	by #noteChangedSelectors:.		This is useful to avoid bootstrapping problems when moving methods to a trait	(e.g., from TPureBehavior to TMethodDictionaryBehavior). Manual moving (implementing	the method in the trait and then remove it from the class) does not work if the methods	themselves are used for this process (such as compiledMethodAt:, includesLocalSelector: or	addTraitSelector:withMethod:)"	| changeFromLocalToTraitMethod |	"-- support for alternative trait implementation --"	(self traitComposition isKindOf: TraitComposition) 		ifFalse:[^self basicRemoveSelector: aSelector].	changeFromLocalToTraitMethod := (self includesLocalSelector: aSelector)		and: [self hasTraitComposition]		and: [self traitComposition includesMethod: aSelector].	changeFromLocalToTraitMethod		ifFalse: [self basicRemoveSelector: aSelector]		ifTrue: [self ensureLocalSelectors].	self deregisterLocalSelector: aSelector.	self noteChangedSelectors: (Array with: aSelector)	! !!Class methodsFor: 'accessing' stamp: 'ar 12/27/2009 14:44'!traitComposition	"Vector the creation through ClassDescription to support alternative traits"	^traitComposition ifNil: [traitComposition := ClassDescription newTraitComposition].! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'ar 12/20/2009 14:10'!definition	"Refer to the comment in ClassDescription|definition."	^ String streamContents:[:strm |		strm print: self.		self traitComposition isEmpty ifFalse:[			strm crtab; nextPutAll: 'uses: '; nextPutAll: self traitComposition asString.		].		strm			crtab;			nextPutAll: 'instanceVariableNames: ';			store: self instanceVariablesString]! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 12/22/2009 07:46'!methodHome	"The behavior (trait/class) this method was originally defined in. 	Can be different from methodClass if the method was recompiled."	^self properties methodHome! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/27/2009 14:35'!fileOutInitializerOn: aStream	"If the receiver has initialization, file it out. Backstop for subclasses."! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 12/27/2009 14:36'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool	"File out the receiver. Backstop for subclasses."	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex! !!Behavior methodsFor: 'adding/removing methods' stamp: 'ar 12/20/2009 12:58'!basicRemoveSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method. Returns the old method	if found, nil otherwise."	| oldMethod |	oldMethod := self methodDict at: selector ifAbsent: [^ nil].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.	^oldMethod! !!ClassDescription class methodsFor: 'traits' stamp: 'ar 12/27/2009 14:07'!traitImpl	"Answer the default implementor of traits"	^TraitImpl! !!Metaclass methodsFor: 'accessing' stamp: 'ar 12/27/2009 15:24'!hasTraitComposition	^traitComposition notNil and:[traitComposition isEmpty not]! !!ClassDescription class methodsFor: 'traits' stamp: 'ar 12/27/2009 14:09'!newTraitComposition	"Answer a new trait composition. If no current trait implementation	is installed, return an empty array"	^TraitImpl ifNil:[#()] ifNotNil:[TraitImpl newTraitComposition].! !