"Change Set:		8239Compiler-nice.98Compiler-nice.98:Add support for literal ByteArray #[1 2 3]"!!Scanner methodsFor: 'expression types' stamp: 'PeterHugossonMiller 9/3/2009 11:10'!scanLitByte	| stream |	stream := (ByteArray new: 16) writeStream.	[ tokenType = #rightBracket or: [ tokenType = #doIt ] ] whileFalse: [		tokenType = #word			ifTrue: [ self scanLitWord ].		(token isInteger and: [ token between: 0 and: 255 ])			ifFalse: [ ^ self offEnd: '8-bit integer or right bracket expected' ].		stream nextPut: token.		self scanToken ].	token := stream contents! !!Scanner class methodsFor: 'initialization' stamp: 'sd 3/20/2008 22:23'!initialize	| newTable |	newTable := Array new: 256 withAll: #xBinary. "default"	newTable atAll: #(9 10 12 13 32 ) put: #xDelimiter. "tab lf ff cr space"	newTable atAll: ($0 asciiValue to: $9 asciiValue) put: #xDigit.	1 to: 255		do: [:index |			(Character value: index) isLetter				ifTrue: [newTable at: index put: #xLetter]].	newTable at: 30 put: #doIt.	newTable at: $" asciiValue put: #xDoubleQuote.	newTable at: $# asciiValue put: #xLitQuote.	newTable at: $$ asciiValue put: #xDollar.	newTable at: $' asciiValue put: #xSingleQuote.	newTable at: $: asciiValue put: #xColon.	newTable at: $( asciiValue put: #leftParenthesis.	newTable at: $) asciiValue put: #rightParenthesis.	newTable at: $. asciiValue put: #period.	newTable at: $; asciiValue put: #semicolon.	newTable at: $[ asciiValue put: #leftBracket.	newTable at: $] asciiValue put: #rightBracket.	newTable at: ${ asciiValue put: #leftBrace.	newTable at: $} asciiValue put: #rightBrace.	newTable at: $^ asciiValue put: #upArrow.	newTable at: $_ asciiValue put: #leftArrow.	newTable at: $| asciiValue put: #verticalBar.	TypeTable := newTable "bon voyage!!"	"Scanner initialize"! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 11/27/2009 12:42'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	start := mark.	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: [self scanToken; scanLitVec.			mark := start + 1.			tokenType == #doIt				ifTrue: [self offEnd: 'Unmatched parenthesis']]		ifFalse: [tokenType = #leftBracket				ifTrue: [self scanToken; scanLitByte.					mark := start + 1.					tokenType == #doIt						ifTrue: [self offEnd: 'Unmatched bracket']]				ifFalse: [(#(#word #keyword #colon ) includes: tokenType)						ifTrue: [self scanLitWord]						ifFalse: [tokenType == #literal								ifTrue: [token isSymbol										ifTrue: ["##word"											token := token											"May want to move toward ANSI											here "]]								ifFalse: [tokenType == #string										ifTrue: [token := token asSymbol]]]]].	mark := start.	tokenType := #literal	"#(Pen)	#Pen	#'Pen'	##Pen	###Pen	"! !Scanner initialize!