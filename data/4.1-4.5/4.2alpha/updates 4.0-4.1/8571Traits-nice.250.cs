"Change Set:		8571Traits-nice.250Traits-nice.250:Cosmetic: move or remove a few temps inside closuresTraits-nice.246:Move two private Quick* classes off the Array hierarchyThe 3 failing trait tests are unrelated...Traits-nice.247:Use scaledIdentityHash for hashingTraits-nice.248:Move FixedIdentitySet off the Array hierarchy.Provide a fast implementation using MethodDictionary tricks- handles collisions (instead of blindly ignoring the entry)- eventually grow.I did not understand previous design decision...The conflict just did happen (I put a halt: and caught one in Object...)According to my own scale, make it work > make it fast.Rationale about the new design:#grow costs, but I think it is user responsibility to fix a reasonnable capacity.collisions handling should not cost much (except above 4096 entries)If any expert knowing the reasons for this class and knowing how to fire the profiling tests could have a look, thanks...Traits-nice.249:fix #formalParametersAt: where due in Traits...Implemented thanks to new support method in ParserNote: this method has no senders in trunk.I suspect it does not have much value...I presume it could have been used by refactoring tools, but RB must be using its own parser...Anyone knows of a package using #formalParametersAt: ?"!Object variableSubclass: #QuickIntegerDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-LocalSends'!Trait named: #TTransformationCompatibility	uses: {}	category: 'Traits-Kernel-Traits'!Collection variableSubclass: #FixedIdentitySet	instanceVariableNames: 'tally capacity hashShift'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-Requires'!Object variableSubclass: #QuickStack	instanceVariableNames: 'top'	classVariableNames: ''	poolDictionaries: ''	category: 'Traits-LocalSends'!!TraitsResource methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!tearDown		SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	self createdClassesAndTraits do: 			[:aClassOrTrait | | behaviorName | 			behaviorName := aClassOrTrait name.			Smalltalk at: behaviorName				ifPresent: [:classOrTrait | classOrTrait removeFromSystem].			ChangeSet current removeClassChanges: behaviorName].	createdClassesAndTraits := self t1: (self 						t2: (self t3: (self 										t4: (self t5: (self 														t6: (self c1: (self 																		c2: (self c3: (self c4: (self c5: (self c6: (self c7: (self c8: nil)))))))))))))! !!CodeModelExtension methodsFor: 'access to cache' stamp: 'nice 12/26/2009 09:52'!for: aClass 	^perClassCache at: aClass		ifAbsent: 			[| newSendCache |			newSendCache := self newCacheFor: aClass.			(self haveInterestsIn: aClass) 				ifTrue: [perClassCache at: aClass put: newSendCache].			newSendCache]! !!TUpdateTraitsBehavior methodsFor: 'traits' stamp: 'nice 12/27/2009 03:12'!updateMethodDictionarySelector: aSymbol	"A method with selector aSymbol in myself or my traitComposition has been changed.	Do the appropriate update to my methodDict (remove or update method) and	return all affected selectors of me so that my useres get notified."	| modifiedSelectors descriptions |	modifiedSelectors := IdentitySet new.	descriptions := self hasTraitComposition		ifTrue: [ self traitComposition methodDescriptionsForSelector: aSymbol ]		ifFalse: [ #() ].	descriptions do: [:methodDescription | | effectiveMethod selector |		selector := methodDescription selector.		(self includesLocalSelector: selector) ifFalse: [			methodDescription isEmpty				ifTrue: [					self removeTraitSelector: selector.					modifiedSelectors add: selector]				ifFalse: [					effectiveMethod := methodDescription effectiveMethod.					(self compiledMethodAt: selector ifAbsent: [nil]) ~~ effectiveMethod ifTrue: [						self addTraitSelector: selector withMethod: effectiveMethod.						modifiedSelectors add: selector]]]].	^modifiedSelectors! !!TFileInOutDescription methodsFor: 'fileIn/Out' stamp: 'nice 12/27/2009 03:12'!fileOutChangedMessages: aSet on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the messages of this class that have been 	changed (i.e., are entered into the argument, aSet) onto aFileStream.  If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.changes file, and should only write a preamble for every method."	| org |	(org := self organization) categories do: 		[:cat | | sels | 		sels := (org listAtCategoryNamed: cat) select: [:sel | aSet includes: sel].		sels do:			[:sel |  self printMethodChunk: sel withPreamble: true on: aFileStream							moveSource: moveSource toFile: fileIndex]]! !!TraitComposition methodsFor: 'enquiries' stamp: 'nice 12/27/2009 03:11'!changedSelectorsComparedTo: oldComposition	| changedSelectors traits |	changedSelectors := IdentitySet new.	traits := self traits asIdentitySet addAll: oldComposition traits asIdentitySet; yourself.	traits do: [:each | | oldTransformation newTransformation |		newTransformation := self transformationOfTrait: each.		oldTransformation := oldComposition transformationOfTrait: each.		(newTransformation isNil or: [oldTransformation isNil])			ifTrue: [				changedSelectors addAll: each selectors]			ifFalse: [				changedSelectors addAll: 					(newTransformation changedSelectorsComparedTo: oldTransformation)]].	^changedSelectors! !!TraitsTestCase methodsFor: 'running' stamp: 'nice 12/27/2009 03:11'!tearDown		TraitsResource resetIfDirty.	self createdClassesAndTraits do: 			[:aClassOrTrait | | behaviorName | 			behaviorName := aClassOrTrait name.			Smalltalk at: behaviorName				ifPresent: [:classOrTrait | classOrTrait removeFromSystem].			ChangeSet current removeClassChanges: behaviorName].	createdClassesAndTraits := nil! !!LocatedMethod methodsFor: 'comparing' stamp: 'nice 12/27/2009 03:11'!argumentNames	"Return an array with the argument names of the method's selector"	| keywords stream argumentNames delimiters |	delimiters := {Character space. Character cr}.	keywords := self selector keywords.	stream := self source readStream.	argumentNames := OrderedCollection new.	keywords do: [ :each | | argumentName |		stream match: each.		[stream peekFor: Character space] whileTrue.		argumentName := ReadWriteStream on: String new.		[(delimiters includes: stream peek) or: [stream peek isNil]]			whileFalse: [argumentName nextPut: stream next].		argumentName isEmpty ifFalse: [			argumentNames add: argumentName contents withBlanksTrimmed]].	^(argumentNames copyFrom: 1 to: self method numArgs) asArray! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'nice 12/26/2009 20:48'!removeRequirements: oldRequiredSelectorsByClass thatAreNotIn: requiredSelectorsByClass	oldRequiredSelectorsByClass keysAndValuesDo: 			[:class :requirements | 			| cache newRequirements |			newRequirements := requiredSelectorsByClass at: class						ifAbsent: 							[#()].			cache := class requiredSelectorsCache.			requirements 				do: [:sel | (newRequirements includes: sel) ifFalse: [cache removeRequirement: sel]]]! !!RequiresSpeedTestCase methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 20:50'!performanceTestSwitchToMorphClassCategoryScenario	"When changing in one browser the selected category, we add some interesting classes, remove some others, and calculate some values. So this is a pretty full life cycle test."	RequiredSelectors doWithTemporaryInstance: 			[LocalSends doWithTemporaryInstance: 					[ProvidedSelectors doWithTemporaryInstance: 							[| noLongerInteresting newInteresting |							self prepareAllCaches.							noLongerInteresting := self classesInCategories: {'Morphic-Basic'}.							newInteresting := self classesInCategories: {'Morphic-Kernel'}.							self measure: 									[self noteInterestInClasses: newInteresting.									self loseInterestInClasses: noLongerInteresting.									newInteresting do: [:cl | cl hasRequiredSelectors].									self loseInterestInClasses: newInteresting.									self noteInterestInClasses: noLongerInteresting.].							self assert: realTime < 500]]]! !!FixedIdentitySet methodsFor: 'adding' stamp: 'nice 12/24/2009 10:45'!add: anObject	| index |	index := self scanFor: anObject.	(self basicAt: index)		ifNil: [			self basicAt: index put: anObject.			tally := tally + 1.			self isFull ifTrue: [ self grow ]]		"ifNotNil: [] already inside".	^anObject! !!LocatedMethod methodsFor: 'comparing' stamp: 'nice 12/24/2009 03:17'!hash	^ self method scaledIdentityHash! !!FixedIdentitySet class methodsFor: 'instance creation' stamp: 'nice 12/24/2009 10:52'!new: anInteger	^ (self basicNew: (self arraySizeForCapacity: anInteger)) initializeCapacity: anInteger! !!QuickStack methodsFor: 'private' stamp: 'nice 12/24/2009 01:37'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	| index repOff |	repOff := repStart - start.	index := start - 1.	[(index := index + 1) <= stop]		whileTrue: [self at: index put: (replacement at: repOff + index)]! !!Behavior methodsFor: '*Traits-requires' stamp: 'nice 12/26/2009 00:13'!classAndMethodFor: aSymbol do: binaryBlock ifAbsent: absentBlock	"Looks up the selector aSymbol in the class chain. If it is found, binaryBlock is evaluated	with the class that defines the selector and the associated method. Otherwise	absentBlock is evaluated."	self withAllSuperclassesDo: [:class |		| method |		method := class compiledMethodAt: aSymbol ifAbsent: [nil].		method ifNotNil: [^ binaryBlock value: class value: method].	].	^ absentBlock value.! !!QuickStack methodsFor: 'accessing' stamp: 'nice 12/24/2009 02:01'!last	^self at: top! !!TPureBehavior methodsFor: 'accessing method dictionary' stamp: 'nice 12/25/2009 20:54'!formalParametersAt: aSelector	"Return the names of the arguments used in this method."	| source |	source := self sourceCodeAt: aSelector ifAbsent: [^ #()].	"for now"	^(self parserClass new) parseParameterNames: source! !!FixedIdentitySet class methodsFor: 'instance creation' stamp: 'NS 5/23/2005 13:09'!new	^ self new: self defaultSize! !!TTraitsCategorisingDescription methodsFor: 'organization updating' stamp: 'nice 12/27/2009 03:12'!noteRecategorizedSelectors: aCollection oldComposition: aTraitComposition		aCollection do: [:each | | oldCategory newCategory | 		oldCategory := self organization categoryOfElement: each.		newCategory := (self traitComposition methodDescriptionForSelector: each) effectiveMethodCategory.		self noteRecategorizedSelector: each from: oldCategory to: newCategory]! !!FixedIdentitySet methodsFor: 'private' stamp: 'nice 12/24/2009 11:37'!fixCollisionsFrom: start	"The element at start has been removed and replaced by nil.	This method moves forward from there, relocating any entries	that had been placed below due to collisions with this one."	| key index mask |	index := start.	mask := self basicSize - 1.	[ (key := self basicAt: (index := (index bitAnd: mask) + 1)) == nil ] whileFalse: [		| newIndex |		(newIndex := self scanFor: key) = index ifFalse: [			| element |			element := self basicAt: index.			self basicAt: index put: (self basicAt: newIndex).			self basicAt: newIndex put: element.] ]! !!TCompilingBehavior methodsFor: 'private' stamp: 'nice 12/27/2009 03:12'!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space |	space := 0.	self selectorsDo: [:sel | | method |		space := space + 16.  "dict and org'n space"		method := self compiledMethodAt: sel.		space := space + (method size + 6 "hdr + avg pad").		method literals do: [:lit |			(lit isMemberOf: Array) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space := space + 12].			(lit isMemberOf: ByteString) ifTrue: [space := space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space := space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space := space + ((lit size + 1) * 4)]]].		^ space! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'nice 12/27/2009 03:11'!findRootsAndRoutes	"Based on the 	1. target classes (ones considered interesting by our clients) and the 	2. modifiedBehaviors (ones we are told might have changed), 	decide the 	A. rootClasses (superclasses of target classes that include methods from modifiedBehaviors) 	B. classesToUpdate (classes that may have been affected AND are on an inheritance path between a root class and a target class, will be updated by the algorithm. This includes the every target class that may have been affected).	C. mapping from root classes to its classesToUpdate."	| modifiedClasses |	classesToUpdate := IdentitySet new.	rootClasses := IdentitySet new.	modifiedClasses := (modifiedBehaviors gather: [:mb | mb classesComposedWithMe]) asIdentitySet.	targetClasses do: [:currentTargetClass | | highestSuperclassOfCurrentTarget | 		highestSuperclassOfCurrentTarget := nil.		currentTargetClass withAllSuperclassesDo: [:sc | 			(modifiedClasses includes: sc) ifTrue: 				[highestSuperclassOfCurrentTarget := sc.				self noteRoot: sc possiblyAffected: currentTargetClass]].			highestSuperclassOfCurrentTarget ifNotNil: [:highestRoot | 				self addUpdatePathTo: currentTargetClass from: highestRoot]]! !!FixedIdentitySet methodsFor: 'private' stamp: 'nice 12/24/2009 11:39'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or raise an error if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| index start mask |	anObject ifNil: [self error: 'This class collection cannot handle nil as an element'].	mask := self basicSize - 1.	index := start := ((anObject identityHash bitShift: hashShift) bitAnd: mask) + 1.	[ 		| element |		((element := self basicAt: index) == nil or: [ element == anObject ])			ifTrue: [ ^index ].		(index := (index bitAnd: mask) + 1) = start ] whileFalse.	self errorNoFreeSpace! !!FixedIdentitySet class methodsFor: 'private' stamp: 'NS 5/26/2005 13:02'!arraySizeForCapacity: anInteger	"Because of the hash performance, the array size is always a power of 2 	and at least twice as big as the capacity anInteger"	^ anInteger <= 0 		ifTrue: [0]		ifFalse: [1 << (anInteger << 1 - 1) highBit].! !!TTraitsCategorisingDescription methodsFor: 'organization updating' stamp: 'nice 12/27/2009 03:12'!updateOrganizationSelector: aSymbol oldCategory: oldCategoryOrNil newCategory: newCategoryOrNil	| changedCategories composition |	changedCategories := IdentitySet new.	composition := self hasTraitComposition		ifTrue: [self traitComposition]		ifFalse: [TraitComposition new].	(composition methodDescriptionsForSelector: aSymbol) do: [:each | | effectiveCategory currentCategory sel |		sel := each selector.		(self includesLocalSelector: sel) ifFalse: [			currentCategory := self organization categoryOfElement: sel.			effectiveCategory := each effectiveMethodCategoryCurrent: currentCategory new: newCategoryOrNil.			effectiveCategory isNil ifTrue: [				currentCategory ifNotNil: [changedCategories add: currentCategory].				self organization removeElement: sel.			] ifFalse: [				((currentCategory isNil or: [currentCategory == ClassOrganizer ambiguous or: [currentCategory == oldCategoryOrNil]]) and: [currentCategory ~~ effectiveCategory]) ifTrue: [					currentCategory ifNotNil: [changedCategories add: currentCategory].					self organization 						classify: sel 						under: effectiveCategory						suppressIfDefault: false]]]].	^ changedCategories! !!TCompilingBehavior methodsFor: 'accessing method dictionary' stamp: 'nice 12/27/2009 03:12'!selectorsWithArgs: numberOfArgs	"Return all selectors defined in this class that take this number of arguments.  Could use String.keywords.  Could see how compiler does this."	| list |	list := OrderedCollection new.	self selectorsDo: [:aSel | | num | 		num := aSel count: [:char | char == $:].		num = 0 ifTrue: [aSel last isLetter ifFalse: [num := 1]].		num = numberOfArgs ifTrue: [list add: aSel]].	^ list! !!TPureBehavior methodsFor: 'traits' stamp: 'nice 12/26/2009 00:16'!selfSentSelectorsFromSelectors: interestingSelectors 	| result |	result := IdentitySet new.	interestingSelectors collect: 			[:sel | 			| m info |			m := self compiledMethodAt: sel ifAbsent: [].			m ifNotNil: 					[info := (SendInfo on: m) collectSends.					info selfSentSelectors do: [:sentSelector | result add: sentSelector]]].	^result! !!Behavior methodsFor: '*Traits-requires' stamp: 'nice 12/26/2009 00:18'!translateReachableSelfSenders: senderCollection translations: translationDictionary	| result |	(translationDictionary isEmptyOrNil or: [senderCollection isEmpty]) ifTrue: [^ senderCollection].	result := FixedIdentitySet new: senderCollection size * 2.	senderCollection do: [:s |		| superSenders |		superSenders := translationDictionary at: s ifAbsent: [nil].		superSenders			ifNil: [result add: s]			ifNotNil: [result addAll: superSenders].	].	^ result.! !!FixedIdentitySet methodsFor: 'private' stamp: 'nice 12/24/2009 10:49'!grow	| newSelf |	newSelf := self species new: capacity * 2.  "This will double the capacity"	self do: [ :anObject | newSelf add: anObject ].	self become: newSelf! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'nice 12/26/2009 20:49'!removeRequirements: oldRequiredSelectorsByClass thatAreNotIn: requiredSelectorsByClass ifIn: rootsHandledBySel	oldRequiredSelectorsByClass keysAndValuesDo: 			[:class :oldRequirements | 			| cache newRequirements unconfirmedRequirements |			newRequirements := requiredSelectorsByClass at: class						ifAbsent: [#()].			cache := class requiredSelectorsCache.			unconfirmedRequirements := oldRequirements copyWithoutAll: newRequirements.			unconfirmedRequirements do: [:sel | 				| roots |				roots := rootsHandledBySel at: sel ifAbsent: [#()].				(roots anySatisfy: [:rc | 					| affected |					affected := possiblyAffectedPerRoot at: rc ifAbsent: #().					(affected includes: class)]) ifTrue: [cache removeRequirement: sel]]]! !!FixedIdentitySet methodsFor: 'removing' stamp: 'nice 12/24/2009 10:31'!remove: anObject ifAbsent: aBlock	| index element |	index := self scanFor: anObject.	(element := self basicAt: index) ifNil: [ ^aBlock value ].	self basicAt: index put: nil.	tally := tally - 1.	self fixCollisionsFrom: index.	^element! !!TraitTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testTraitMethodSelector	"Tests that the #selector of a trait method isn't screwed up when aliasing traits"	| baseTrait classA classB |	[ | methodA traitMethod methodB |baseTrait := Trait named: #TraitTestBaseTrait uses:{} category: self class category.	baseTrait compileSilently: 'traitMethod' classified: 'tests'.	traitMethod := baseTrait compiledMethodAt: #traitMethod.	self assert: traitMethod selector == #traitMethod.	classA := Object subclass: #TraitTestMethodClassA 					uses: {baseTrait @ {#methodA -> #traitMethod}}					instanceVariableNames: '' 					classVariableNames: '' 					poolDictionaries: '' 					category: self class category.	methodA := classA compiledMethodAt: #methodA.	self assert: traitMethod selector == #traitMethod.	self assert: methodA selector == #methodA.	classB := Object subclass: #TraitTestMethodClassB					uses: {baseTrait @ {#methodB -> #traitMethod}}					instanceVariableNames: '' 					classVariableNames: '' 					poolDictionaries: '' 					category: self class category.	methodB := classB compiledMethodAt: #methodB.	self assert: traitMethod selector == #traitMethod.	self assert: methodA selector == #methodA.	self assert: methodB selector == #methodB.	] ensure:[		classA ifNotNil:[classA removeFromSystem: false].		classB ifNotNil:[classB removeFromSystem: false].		baseTrait ifNotNil:[baseTrait removeFromSystem: false].	].! !!TraitMethodDescription methodsFor: 'accessing' stamp: 'nice 12/27/2009 03:11'!effectiveMethodCategoryCurrent: currentCategoryOrNil new: newCategoryOrNil	| result size isCurrent isConflict |	size := self size.	size = 0 ifTrue: [^ nil].	result := self locatedMethods anyOne category.	size = 1 ifTrue: [^ result].		isCurrent := currentCategoryOrNil isNil.	isConflict := false.	self locatedMethods do: [:each | | cat |		cat := each category.		isCurrent := isCurrent or: [cat == currentCategoryOrNil].		isConflict := isConflict or: [cat ~~ result]].	isConflict ifFalse: [^ result].	(isCurrent not and: [newCategoryOrNil notNil]) ifTrue: [^ newCategoryOrNil].	^ ClassOrganizer ambiguous.! !!TraitTest methodsFor: 'testing' stamp: 'nice 12/27/2009 03:11'!testTraitMethodClass	"Tests that the #methodClass of a trait method isn't screwed up"	| baseTrait classA classB |	[ | methodB traitMethod methodA |baseTrait := Trait named: #TraitTestBaseTrait uses:{} category: self class category.	baseTrait compileSilently: 'traitMethod' classified: 'tests'.	traitMethod := baseTrait compiledMethodAt: #traitMethod.	self assert: traitMethod methodClass == baseTrait.	classA := Object subclass: #TraitTestMethodClassA 					uses: baseTrait 					instanceVariableNames: '' 					classVariableNames: '' 					poolDictionaries: '' 					category: self class category.	methodA := classA compiledMethodAt: #traitMethod.	self assert: traitMethod methodClass == baseTrait.	self assert: methodA methodClass == classA.	classB := Object subclass: #TraitTestMethodClassB					uses: baseTrait 					instanceVariableNames: '' 					classVariableNames: '' 					poolDictionaries: '' 					category: self class category.	methodB := classB compiledMethodAt: #traitMethod.	self assert: traitMethod methodClass == baseTrait.	self assert: methodA methodClass == classA.	self assert: methodB methodClass == classB.	] ensure:[		classA ifNotNil:[classA removeFromSystem: false].		classB ifNotNil:[classB removeFromSystem: false].		baseTrait ifNotNil:[baseTrait removeFromSystem: false].	].! !!Behavior methodsFor: '*Traits-requires' stamp: 'nice 12/26/2009 00:14'!computeTranslationsAndUpdateUnreachableSet: unreachableCollection	"This method computes the set of unreachable selectors in the superclass by altering the set of unreachable selectors in this class. In addition, it builds a dictionary mapping super-sent selectors to the selectors of methods sending these selectors."	| translations oldUnreachable |	oldUnreachable := unreachableCollection copy.	translations := IdentityDictionary new.	"Add selectors implemented in this class to unreachable set."	self methodDict keysDo: [:s | unreachableCollection add: s].		"Fill translation dictionary and remove super-reachable selectors from unreachable."	self sendCaches superSentSelectorsAndSendersDo: [:sent :senders |		| reachableSenders |		reachableSenders := FixedIdentitySet readonlyWithAll: senders notIn: oldUnreachable.		reachableSenders isEmpty ifFalse: [			translations at: sent put: reachableSenders.			unreachableCollection remove: sent ifAbsent: [].		].	].	^ translations! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'nice 12/27/2009 03:18'!findOriginalSins	| checkedClasses |	checkedClasses := IdentitySet new.	originalSinsPerSelector := IdentityDictionary new.	rootClasses do: 			[:rootClass | 			rootClass withAllSuperclassesDo: [:superClass | 				| sinnedSelectors |				(checkedClasses includes: superClass) ifFalse: [					checkedClasses add: superClass.					sinnedSelectors := self sinsIn: superClass.					sinnedSelectors do: 							[:sinSel | 							| sinners |							sinners := originalSinsPerSelector at: sinSel										ifAbsentPut: [IdentitySet new].							sinners add: superClass]]]]! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'nice 12/26/2009 20:50'!storeRequirementsUnder: rc for: selector in: requiredSelectorsByClass 	| requiringClasses |	requiringClasses := rc updateRequiredStatusFor: selector				inSubclasses: (self possiblyAffectedForRoot: rc).	^requiringClasses do: 			[:requiringClass | 			|  selectorsForClass |			selectorsForClass := requiredSelectorsByClass at: requiringClass						ifAbsentPut: [IdentitySet new].			selectorsForClass add: selector]! !!FixedIdentitySet methodsFor: 'removing' stamp: 'nice 12/24/2009 10:40'!removeAll	tally = 0 ifTrue: [^self].	1 to: self basicSize do: [:i | self basicAt: i put: nil].	tally := 0! !!FixedIdentitySet class methodsFor: 'instance creation' stamp: 'nice 12/24/2009 10:58'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer an instance of me, containing the five arguments as the elements."	^ (self new: 5)		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		yourself! !!FixedIdentitySet methodsFor: 'private' stamp: 'nice 12/24/2009 11:39'!rehash	| newSelf |	newSelf := self species new: self size.	self do: [ :anObject | newSelf add: anObject ].	^newSelf! !!RequiredSelectorsChangesCalculator methodsFor: 'calculating' stamp: 'nice 12/26/2009 20:47'!doWork	| requiredSelectorsByClass oldRequiredSelectorsByClass classWithOldRequirementsRecorded rootsHandledBySel |	requiredSelectorsByClass := IdentityDictionary new.	oldRequiredSelectorsByClass := IdentityDictionary new.	classWithOldRequirementsRecorded := IdentitySet new.	rootsHandledBySel := IdentityDictionary new.	originalSinsPerSelector keysAndValuesDo: 			[:selector :sinners | 			| rootsHandled |			rootsHandled := rootsHandledBySel at: selector put: IdentitySet new.			rootClasses do: 					[:rc | 					(self shouldProcess: rc forSinsIn: sinners) 						ifTrue: 							[rootsHandled add: rc.							self 								storeOldRequirementsUnder: rc								into: oldRequiredSelectorsByClass								ignoreSet: classWithOldRequirementsRecorded.							self 								storeRequirementsUnder: rc								for: selector								in: requiredSelectorsByClass]]].	self 		removeRequirements: oldRequiredSelectorsByClass		thatAreNotIn: requiredSelectorsByClass		ifIn: rootsHandledBySel.	self setFoundRequirements: requiredSelectorsByClass! !!LocalSends methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 10:25'!newCacheFor: aClass 	"Creates an instance of SendCaches, assigns it to the instance variable sendCaches and fills it with all the self-sends class-sends and super-sends that occur in methods defined in this class (or by used traits)."	| localSendCache |	localSendCache := SendCaches new.	aClass selectorsAndMethodsDo: 			[:sender :m | 			| info |			info := (SendInfo on: m) collectSends.			info selfSentSelectors 				do: [:sentSelector | localSendCache addSelfSender: sender of: sentSelector].			info superSentSelectors 				do: [:sentSelector | localSendCache addSuperSender: sender of: sentSelector].			info classSentSelectors 				do: [:sentSelector | localSendCache addClassSender: sender of: sentSelector]].	^localSendCache! !!FixedIdentitySet methodsFor: 'initialize-release' stamp: 'nice 12/24/2009 11:31'!initializeCapacity: anInteger	tally := 0.	capacity := anInteger.	hashShift := self basicSize highBit - 4096 highBit max: 0! !!FixedIdentitySet methodsFor: 'adding' stamp: 'nice 12/24/2009 10:47'!addAll: aCollection notIn: notCollection	aCollection do: [:each | 		(notCollection includes: each) ifFalse: [self add: each].	].! !!FixedIdentitySet class methodsFor: 'instance creation' stamp: 'nice 12/24/2009 10:58'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer an instance of me, containing the six arguments as the elements."	^ (self new: 6)		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		add: sixthObject;		yourself! !!FixedIdentitySet methodsFor: 'testing' stamp: 'nice 12/24/2009 10:23'!includes: aSymbol	"This override assumes that pointsTo is a fast primitive"	aSymbol ifNil: [^ false].	^ self pointsTo: aSymbol! !FixedIdentitySet removeSelector: #destructiveAdd:!FixedIdentitySet removeSelector: #addAll:!FixedIdentitySet removeSelector: #indexOf:!FixedIdentitySet removeSelector: #notFull!