"Change Set:		8218Kernel-ul.305Kernel-ul.305:- added Integer >> #sqrtFloor, which returns the floor of the square root of the receiver.- renamed Integer >> #isPrime to #isProbablyPrime.- added Integer >> #isPrime which is implemented as a deterministic primality test- both #isPrime and #isProbablyPrime return false for receivers <= 1 instead of raising an errorKernel-ul.303:- removed MethodDictionary >> #do: because it should be the same as Dictionary >> #do:Load Collections-ul.200 before this package!Kernel-nice.304:cosmetic clean up of allInstancesDo: do not test == UndefinedObject, but rather override where due.remove Metaclass>>#allInstances.We could also remove Metaclass>>#allInstancesDo:"!!Integer methodsFor: 'testing' stamp: 'ul 11/25/2009 02:39'!isPrime		self <= 1 ifTrue: [ ^false ].	self even ifTrue: [ ^self = 2].	3 to: self sqrtFloor by: 2 do: [ :each |		self \\ each = 0 ifTrue: [ ^false ] ].	^true! !!UndefinedObject class methodsFor: 'accessing' stamp: 'nice 11/14/2009 19:22'!allInstancesDo: aBlock	"It is well known there is a single instance"		aBlock value: nil! !!Integer methodsFor: 'testing' stamp: 'ul 11/25/2009 02:28'!isProbablyPrime	"See isProbablyPrimeWithK:andQ: for the algoritm description."		| k q |	self <= 1 ifTrue: [ ^false ].	self even ifTrue: [ ^self = 2 ].	k := 1.	q := self - 1 bitShift: -1.	[ q odd ] whileFalse: [		q := q bitShift: -1.		k := k + 1 ].	25 timesRepeat: [ (self isProbablyPrimeWithK: k andQ: q) ifFalse: [ ^false ] ].	^true! !!Integer methodsFor: 'mathematical functions' stamp: 'ul 11/25/2009 02:34'!sqrtFloor	"Return the integer part of the square root of self"	| guess guessSquared delta |	guess := 1 bitShift: self highBit + 1 // 2.	[		guessSquared := guess * guess.		delta := guessSquared - self // (guess bitShift: 1).		delta = 0 ] whileFalse: [			guess := guess - delta ].	guessSquared = self ifFalse: [ guess := guess - 1 ].	^guess! !!Behavior methodsFor: 'enumerating' stamp: 'nice 11/14/2009 19:22'!allInstancesDo: aBlock 	"Evaluate the argument, aBlock, for each of the current instances of the 	receiver.		Because aBlock might change the class of inst (for example, using become:),	it is essential to compute next before aBlock value: inst."	| inst next |	inst := self someInstance.	[inst == nil]		whileFalse:		[		next := inst nextInstance.		aBlock value: inst.		inst := next]! !MethodDictionary removeSelector: #do:!Metaclass removeSelector: #allInstances!