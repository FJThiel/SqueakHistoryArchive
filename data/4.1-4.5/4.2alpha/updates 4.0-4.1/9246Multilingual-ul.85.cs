"Change Set:		9246Multilingual-ul.85Multilingual-ul.85:- fix #basicNext: and #basicUpTo: in MultiByteFileStream- add chunk reading capabilities to TextConverter- assume that MultiByteFileStream's converter is properly initialized in #next- MultiByteFileStream >> #nextChunk uses its converter's chunk reading capabilities, this speeds gives >3x speedup if the file has UTF-8 encoding- fix: MultiByteFileStream lost it's position if the ! character was encoded to more than a single byte (ex UTF16)"!!MultiByteFileStream methodsFor: 'fileIn/Out' stamp: 'ul 2/5/2010 23:59'!nextChunk	"Answer the contents of the receiver, up to the next terminator character. Doubled terminators indicate an embedded terminator character."	^converter nextChunkFromStream: self! !!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 2/6/2010 00:02'!nextChunkFromStream: input	"Answer the contents of input, up to the next terminator character. Doubled terminators indicate an embedded terminator character."		input skipSeparators.	^input parseLangTagFor: (		String new: 1000 streamContents: [ :output |			| character state |			[ 				(character := self nextFromStream: input) == nil or: [ 					character == $!! and: [ 						state := self saveStateOf: input.						(self nextFromStream: input) ~~ $!! ] ] ] 				whileFalse: [ output nextPut: character ].			character ifNotNil: [ 				self restoreStateOf: input with: state ] ])! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 2/6/2010 00:35'!nextChunkFromStream: input	"Answer the contents of input, up to the next terminator character. Doubled terminators indicate an embedded terminator character."		input skipSeparators.	^input parseLangTagFor: (		String new: 1000 streamContents: [ :stream |			[				stream nextPutAll: (input basicUpTo: $!!).				input basicNext == $!! ]					whileTrue: [ 						stream nextPut: $!! ].			input atEnd ifFalse: [ input skip: -1 ] ]) utf8ToSqueak! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/15/2010 19:52'!next	| char secondChar state |	char := converter nextFromStream: self.	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifTrue: [			char == Cr ifTrue: [				state := converter saveStateOf: self.				secondChar := self bareNext.				secondChar ifNotNil: [					secondChar == Lf ifFalse: [ converter restoreStateOf: self with: state ] ].				^Cr ].			char == Lf ifTrue: [				^Cr ] ].	^char.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'ul 1/28/2010 00:10'!basicUpTo: delim 	"Fast version to speed up nextChunk"	| pos buffer count |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delim startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	pos := self position.	buffer := self basicNext: 2000.	(count := buffer indexOf: delim) > 0 ifTrue: 		["Found the delimiter part way into buffer"		self position: pos + count.		^ buffer copyFrom: 1 to: count - 1].	self atEnd ifTrue:		["Never found it, and hit end of file"		^ buffer].	"Never found it, but there's more..."	^ buffer , (self basicUpTo: delim)! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'ul 1/28/2010 02:29'!basicNext: anInteger	^self basicNextInto: (self collectionSpecies new: anInteger)! !