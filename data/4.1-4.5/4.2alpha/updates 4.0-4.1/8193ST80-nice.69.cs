"Change Set:		8193ST80-nice.69ST80-nice.69:Correct stupid typo I madeST80-nice.67:Let paragraph handle more cases of cr/lf/crlf delimitersST80-nice.68:Handle more crlf cases"!!Paragraph methodsFor: 'private' stamp: 'nice 11/17/2009 01:02'!updateCompositionHeight	"Mainly used to insure that intersections with compositionRectangle work." 	compositionRectangle := compositionRectangle withHeight:		(self bottomAtLineIndex: lastLine) - compositionRectangle top.	(text size ~= 0 and: [(text at: text size) = CR or: [(text at: text size) = Character lf]])		ifTrue: [compositionRectangle := compositionRectangle withHeight:					compositionRectangle height + (lines at: lastLine) lineHeight]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 11/16/2009 16:18'!browseClassFromIt	"Launch a browser for the class indicated by the current selection. 	If multiple classes matching the selection exist, let the user choose among them."	| aBrow aClass |	self		lineSelectAndEmptyCheck: [^ self].	aClass := Utilities				classFromPattern: (self selection string copyWithoutAll: CharacterSet separators)				withCaption: 'choose a class to browse...'.	aClass		ifNil: [^ view flash].	self		terminateAndInitializeAround: 			[aBrow := SystemBrowser default new.			aBrow setClass: aClass selector: nil.			aBrow class				openBrowserView: (aBrow openEditString: nil) label: 'System Browser'].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'nice 11/16/2009 11:33'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString := self selection string.	aString isOctetString ifTrue: [aString := aString asOctetString].	aString := aString copyWithoutAll:		{Character space.  Character cr.  Character lf. Character tab}.	aString size == 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'new selection' stamp: 'nice 11/16/2009 14:41'!encompassLine: anInterval	"Return an interval that encompasses the entire line"	| string left right |	string := paragraph text string.	left := (string lastIndexOfAnyOf: CharacterSet crlf startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right := (string indexOfAnyOf: CharacterSet crlf startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 11/16/2009 16:14'!explainChar: string	"Does string start with a special character?"	| char |	char := string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = ${ or: [char = $}]) ifTrue: [^ '"A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array"'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	char = Character lf ifTrue: [^'"the line feed Character"'].	^nil! !!Paragraph methodsFor: 'accessing' stamp: 'nice 11/16/2009 12:37'!stringAtLineNumber: aNumber	(aNumber > lastLine or: [aNumber < 1]) ifTrue: [^ nil].	^ (text string copyFrom: (lines at: aNumber) first to: (lines at: aNumber) last) copyWithoutAll: CharacterSet crlf! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 11/16/2009 14:39'!cursorHome: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string := paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOfAnyOf: CharacterSet crlf						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		specialBlock: [:dummy | 1].	^true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'nice 11/16/2009 14:37'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |		sensor keyboard.  "Flush typeahead"	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart := self startIndex.	realStop := self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == Character cr or: [(paragraph string at: realStart - 1) == Character lf]]])		ifTrue:			[delta < 0				ifTrue:					[view flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^ true].	lines := paragraph lines.	startLine := paragraph lineIndexOfCharacterIndex: realStart.	stopLine := paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start := (lines at: startLine) first.	stop := (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart := realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation := (startLine to: stopLine) inject: 1000 into:		[:m :l |		m := m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size :=  stop + 1 - start.	numLines := stopLine + 1 - startLine.	inStream := ReadStream on: paragraph string from: start to: stop.	newString := WideString new: size + ((numLines * delta) max: 0).	outStream := ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart := (realStart + delta) max: start].	realStop := realStop + outStream position - size.	"Prepare for another iteration"	indentation := indentation + delta.	size := outStream position.	inStream := outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[view flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString := outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'nice 11/16/2009 10:38'!cursorEnd: characterStream 	"Private - Move cursor end of current line."	| string |	self closeTypeIn: characterStream.	string := paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| targetLine |					targetLine := paragraph lines at:(paragraph lineIndexOfCharacterIndex: position).					targetLine = paragraph lines last						ifTrue:[targetLine last + 1]						ifFalse:[targetLine last]]				ifFalse:[					string						indexOfAnyOf: CharacterSet crlf						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		specialBlock:[:dummy | string size + 1].	^true! !!ParagraphEditor methodsFor: 'private' stamp: 'nice 11/16/2009 10:11'!lines	"Other than my member paragraph i compute lines based on logical	line breaks, not optical (which may change due to line wrapping of the editor)"	| lines string index lineIndex stringSize |	string := paragraph text string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize := string size.	lines := OrderedCollection new: (string size // 15).	index := 0.	lineIndex := 0.	string linesDo:[:line |		lines addLast: (Array			with: (index := index + 1)			with: (lineIndex := lineIndex + 1)			with: (index := index + line size min: stringSize))].	"Special workaround for last line empty."	(string last == Character cr or: [string last == Character lf])	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!ParagraphEditor methodsFor: 'explain' stamp: 'nice 11/16/2009 17:09'!explainScan: string 	"Remove beginning and trailing separators (space, tab, cr,...)"	^string withBlanksTrimmed! !!Paragraph methodsFor: 'accessing' stamp: 'nice 11/16/2009 10:25'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last reader leadingTabs lastSeparator lf tab ch |	lf := Character lf.	tab := Character tab.	arrayIndex := lineIndex.	[first := (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ CR and: [(text string at: first - 1) ~~ lf]]] whileTrue: "word wrap"		[arrayIndex := arrayIndex - 1].	last := (lines at: lastLine) last.	reader := ReadStream on: text string from: first to: last.	leadingTabs := 0.	[reader atEnd not and: [(ch := reader next) == tab]]		whileTrue: [leadingTabs := leadingTabs + 1].	lastSeparator := first - 1 + leadingTabs.	[reader atEnd not and: [ch isSeparator and: [ch ~~ CR and: [ch ~~ lf]]]]		whileTrue: [lastSeparator := lastSeparator + 1. ch := reader next].	(lastSeparator = last or: [ch == CR or: [ch == lf]])		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'nice 11/16/2009 16:19'!changeLfToCr: characterStream 	"Replace all LFs by CRs, and CR-LF pairs by single CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString:			(self selection string withSqueakLineEndings)).	^ true! !