"Change Set:		8077Graphics-nice.87Graphics-nice.87:Rectangle storeOn: needs parenthesisGraphics-jmv.82:Fixed an issue with the #baseKern of italic underlined StrikeFonts.Graphics-jdr.83:correct reading of gray PNMsGraphics-jdr.84:correct reading of gray PNMsGraphics-nice.85:Make h:s:v: work in case of negative angleGraphics-nice.86:while at arcTan: fix 2 ULP in Float thetaNote that Float theta is in [0,2*pi[ while arcTan: is in [-pi,pi](0@0) theta leads to pi/2 instead of 0 for new version of arcTan: (pi for old version)#arcTan: does handle case of negativeZero, #theta doesn't"!!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/20/2009 16:55'!readGray	"gray form, return ColorForm with gray ramp"	| form poker |	maxValue > 255 ifTrue:[self error:'Gray value > 8 bits not supported in Squeak'].	stream binary.	form := ColorForm extent: cols@rows depth: depth.	form colors: nil.	poker := BitBlt current bitPokerToForm: form.	0 to: rows-1 do: [:y |		0 to: cols-1 do: [:x |			|val|			val := stream next.			poker pixelAt: x@y put: val.		]	].	"a better way is using a gamma corrected palette"	form colors: ((0 to: 255) collect:[:c|		c > maxValue			ifTrue:[Color white]			ifFalse:[Color gray: (c/maxValue) asFloat]]).	form colors at: 1 put: (Color black).	^form! !!StrikeFont methodsFor: 'accessing' stamp: 'jmv 10/26/2009 17:55'!baseKern	"Return the base kern value to be used for all characters."		| italic |	italic := emphasis allMask: 2.		glyphs depth > 1 ifTrue: [		^(italic or: [ pointSize < 9 ])			ifTrue: [ 1 ]			ifFalse: [ 0] ].			italic ifFalse: [^ 0].	^ ((self height-1-self ascent+4)//4 max: 0)  "See makeItalicGlyphs"		+ (((self ascent-5+4)//4 max: 0))! !!Point methodsFor: 'polar coordinates' stamp: 'nice 10/12/2007 23:30'!theta	"Answer the angle the receiver makes with origin in radians. right is 0; 	down is 90. 	Corrected the constants from single precision to 64 Bit precision 	and changed the sends in case of overflow to constants HK 2005-07-23"	| tan theta |	x = 0		ifTrue: [y >= 0				ifTrue: [^ 1.5707963267948966 "90.0 degreesToRadians"]				ifFalse: [^ 4.71238898038469 "270.0 degreesToRadians"]]		ifFalse: 			[tan := y asFloat / x asFloat.			theta := tan arcTan.			x >= 0				ifTrue: [y >= 0						ifTrue: [^theta]						ifFalse: [^"360.0 degreesToRadians" 6.283185307179586 + theta]]				ifFalse: [^"180.0 degreesToRadians" 3.141592653589793 + theta]]! !!Color methodsFor: 'private' stamp: 'nice 10/30/2009 21:03'!setHue: hue saturation: saturation brightness: brightness	"Initialize this color to the given hue, saturation, and brightness. See the comment in the instance creation method for details."	| s v hf i f p q t | 	s := (saturation asFloat max: 0.0) min: 1.0.	v := (brightness asFloat max: 0.0) min: 1.0.	"zero saturation yields gray with the given brightness"	s = 0.0 ifTrue: [ ^ self setRed: v green: v blue: v ].	hf := hue asFloat.	(hf < 0.0 or: [hf >= 360.0])		ifTrue: [hf := hf \\ 360].	hf := hf / 60.0.	i := hf asInteger.  "integer part of hue"	f := hf fractionPart.         "fractional part of hue"	p := (1.0 - s) * v.	q := (1.0 - (s * f)) * v.	t := (1.0 - (s * (1.0 - f))) * v.	0 = i ifTrue: [ ^ self setRed: v green: t blue: p ].	1 = i ifTrue: [ ^ self setRed: q green: v blue: p ].	2 = i ifTrue: [ ^ self setRed: p green: v blue: t ].	3 = i ifTrue: [ ^ self setRed: p green: q blue: v ].	4 = i ifTrue: [ ^ self setRed: t green: p blue: v ].	5 = i ifTrue: [ ^ self setRed: v green: p blue: q ].	self error: 'implementation error'.! !!Rectangle methodsFor: 'printing' stamp: 'nice 11/1/2009 20:27'!storeOn: aStream 	"printed form is good for storing too"		aStream nextPut: $(.	self printOn: aStream.	aStream nextPut: $).! !