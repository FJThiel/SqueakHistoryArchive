"Change Set:		8464Tools-ul.146Tools-ul.146:- replace sends of #ifNotNilDo: to #ifNotNil:, #ifNil:ifNotNilDo: to #ifNil:ifNotNil:, #ifNotNilDo:ifNil: to #ifNotNil:ifNil:Tools-dtl.145:Update CodeHolder to allow registration of new code pane display modes in browsers. This change enables SlangBrowser (VMMaker package) to display translated C code in browsers.Note: The label text on the 'source' button for browsers is not properly updated when the edit pane mode is changed. This is an existing bug, not affected by these changes."!StringHolder subclass: #CodeHolder	instanceVariableNames: 'currentCompiledMethod contentsSymbol'	classVariableNames: 'ContentsSymbolQuints EditContentsOptions'	poolDictionaries: ''	category: 'Tools-Base'!!CodeHolder methodsFor: 'controls' stamp: 'dtl 12/9/2009 13:58'!contentsSymbolQuints	"Answer a list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ ContentsSymbolQuints! !!ArchiveViewer methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:12'!readOnlyStream	"Answer a read-only stream on the selected member.	For the various stream-reading services."	^self selectedMember ifNotNil: [ :mem | mem contentStream ascii ]! !!CodeHolder methodsFor: 'what to show' stamp: 'dtl 12/9/2009 16:21'!showingEditContentsOption	"True if any of the optional EditContentsOptions modes is in effect. This	includes bytecode display and possibly other display modes."	^ EditContentsOptions includesKey: self contentsSymbol! !!ObjectExplorer methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:08'!object	^currentSelection ifNotNil: [ :cs | cs withoutListWrapper ]! !!Browser methodsFor: 'accessing' stamp: 'dtl 12/9/2009 16:01'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod := currentCompiledMethod.	currentCompiledMethod := nil.	editSelection == #newTrait		ifTrue: [^Trait newTemplateIn: self selectedSystemCategoryName].	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass := self selectedClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^self classDefinitionText].	editSelection == #editComment 		ifTrue:			[(theClass := self selectedClass) ifNil: [^ ''].			comment := theClass comment.			currentCompiledMethod := theClass organization commentRemoteStr.			^ comment size = 0				ifTrue: ['This class has not yet been commented.']				ifFalse: [comment]].	editSelection == #hierarchy 		ifTrue: [			self selectedClassOrMetaClass isTrait				ifTrue: [^'']				ifFalse: [^self selectedClassOrMetaClass printHierarchy]].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue:			[^ (theClass := self selectedClassOrMetaClass) 				ifNil: ['']				ifNotNil: [theClass sourceCodeTemplate]].	editSelection == #editMessage		ifTrue:			[^ self editContentsWithDefault:				[currentCompiledMethod := latestCompiledMethod.				self selectedMessage]].	self error: 'Browser internal error: unknown edit selection.'! !!CodeHolder class methodsFor: 'controls' stamp: 'dtl 12/9/2009 14:21'!addContentsSymbolQuint: quint afterEntry: aSymbol 	"Register a menu selection item in the position after the entry with	selection symbol aSymbol."	"CodeHolder		addContentsSymbolQuint: #(#altSyntax #toggleAltSyntax #showingAltSyntaxString 'altSyntax' 'alternative syntax')		afterEntry: #colorPrint"	| entry |	ContentsSymbolQuints		detect: [:e | (e isKindOf: Collection) and: [e first = quint first]]		ifNone: [entry := ContentsSymbolQuints						detect: [:e | (e isKindOf: Collection) and: [e first = aSymbol]].			ContentsSymbolQuints add: quint after: entry.			^ self].	self notify: 'entry already exists for ', quint first! !!BrowserCommentTextMorph methodsFor: 'displaying' stamp: 'ul 12/12/2009 14:12'!hidePane	| win |	self window ifNotNil: [:window | window removePaneSplitters].		self lowerPane ifNotNil:		[ :lp | 		lp layoutFrame bottomFraction: self layoutFrame bottomFraction.		lp layoutFrame bottomOffset: SystemWindow borderWidth negated].	win := self window ifNil: [ ^self ].	self delete.	win updatePanesFromSubmorphs.	win addPaneSplitters! !!MessageSet methodsFor: 'contents' stamp: 'dtl 2/4/2007 11:42'!contents	"Answer the contents of the receiver"	^ contents == nil		ifTrue: [currentCompiledMethod := nil. '']		ifFalse: [messageListIndex = 0 			ifTrue: [currentCompiledMethod := nil. contents]			ifFalse: [self editContents]]! !!VersionsBrowser methodsFor: 'init & update' stamp: 'ul 12/12/2009 14:04'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp cat |	selectorOfMethod := selector.	currentCompiledMethod := method.	classOfMethod := meta ifTrue: [class class] ifFalse: [class].	cat := category ifNil: [''].	changeList := OrderedCollection new.	list := OrderedCollection new.	self addedChangeRecord ifNotNil: [ :change |		self addItem: change text: ('{1} (in {2})' translated format: { change stamp. change fileName }) ].	listIndex := 0.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				cat := tokens at: tokens size-4.				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size].				cat := tokens at: tokens size-2]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector, ' {', cat, '}'.		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections := Array new: list size withAll: false! !!CodeHolder methodsFor: 'contents' stamp: 'dtl 12/9/2009 14:03'!editContentsWithDefault: aBlock	| selector |	selector := EditContentsOptions		at: self contentsSymbol		ifAbsent: [^ aBlock value].	^ self perform: selector! !!CodeHolder class methodsFor: 'controls' stamp: 'dtl 2/4/2007 09:59'!defaultEditContentsOptions	"An array of associations of current display mode symbol to selector	that creates the edit contents for that display mode. The default selector	is #selectedMessage; this is a list of alternative to the default."	^ {		#byteCodes -> #selectedBytecodes	}! !!CodeHolder methodsFor: 'contents' stamp: 'dtl 2/3/2007 20:14'!editContents	^ self editContentsWithDefault: [self selectedMessage]! !!ArchiveViewer methodsFor: 'initialization' stamp: 'ul 12/12/2009 14:12'!createWindow	| list heading font text buttonBar |	font := (TextStyle named: #DefaultFixedTextStyle)		ifNotNil: [ :ts | ts fontArray first].	buttonBar := self createButtonBar.	self addMorph: buttonBar		fullFrame: (LayoutFrame fractions: (0@0 corner: 1.0@0.0) offsets: (0@0 corner: 0@44)).	self minimumExtent: (buttonBar fullBounds width + 20) @ 230.	self extent: self minimumExtent.	heading := self createListHeadingUsingFont: font.	self addMorph: heading		fullFrame: (LayoutFrame fractions: (0@0 corner: 1.0@0.0) offsets: (0@44 corner: 0@60)).	(list := PluggableListMorph new)		on: self list: #memberList		selected: #memberIndex changeSelected: #memberIndex:		menu: #memberMenu:shifted: keystroke: nil.	list color: self defaultBackgroundColor.	font ifNotNil: [list font: font].	self addMorph: list		fullFrame: (LayoutFrame fractions: (0@0 corner: 1.0@0.8) offsets: (0@60 corner: 0@0)).	text := PluggableTextMorph on: self 			text: #contents accept: nil			readSelection: nil menu: nil.	self addMorph: text		frame: (0@0.8 corner: 1.0@1.0).	text lock.	self setLabel: 'Ned''s Zip Viewer'! !!CodeHolder class methodsFor: 'controls' stamp: 'dtl 12/9/2009 14:02'!addEditContentsOption: anAssociation	"CodeHolder addEditContentsOption: #translateToC -> #selectedTranslateToC"	EditContentsOptions add: anAssociation! !!MethodHolder methodsFor: 'menu' stamp: 'ul 12/12/2009 14:09'!doItReceiver	"If there is an instance associated with me, answer it, for true mapping of self.  If not, then do what other code-bearing tools do, viz. give access to the class vars."	(self dependents detect: [:m | m isKindOf: MethodMorph]) ifNotNil:		[:mm | (mm owner isKindOf: ScriptEditorMorph) ifTrue:			[^ mm owner playerScripted]].	^ self selectedClass ifNil: [FakeClassPool new]! !!Debugger methodsFor: 'tally support' stamp: 'ul 12/12/2009 12:51'!tally	self getTextMorphWithSelection ifNotNil: [:o| o tallyIt] ifNil: [Beeper beep]! !!BrowserCommentTextMorph methodsFor: 'displaying' stamp: 'ul 12/12/2009 14:12'!showPane	owner ifNil: [		| win |		win := self window ifNil: [ ^self ].		win addMorph: self fullFrame: self layoutFrame.		win updatePanesFromSubmorphs ].	self lowerPane ifNotNil: [ :lp | lp layoutFrame bottomFraction: self layoutFrame topFraction ].		self window ifNotNil: [:win | win addPaneSplitters]! !!ArchiveViewer methodsFor: 'member list' stamp: 'ul 12/12/2009 14:12'!memberMenu: menu shifted: shifted	| services |	menu		add: 'Comment archive' target: self selector: #commentArchive;		balloonTextForLastItem: 'Add a comment for the entire archive'.	self selectedMember ifNotNil: [ :member |		menu			addLine;			add: 'Inspect member' target: self selector: #inspectMember;			balloonTextForLastItem: 'Inspect the selected member';			add: 'Comment member' target: self selector: #commentMember;			balloonTextForLastItem: 'Add a comment for the selected member';			addLine;			add: 'member go up in order ' target: self selector: #upMember;			add: 'member go down in order ' target: self selector: #downMember;			add: 'select member order ' target: self selector: #toIndexPlace;			addLine.		services := FileList itemsForFile: member fileName.		menu addServices2: services for: self extraLines: #().	].	^menu! !!CodeHolder class methodsFor: 'controls' stamp: 'dtl 12/9/2009 14:00'!removeContentsSymbol: aSymbol 	"Unregister the menu selection item with selection symbol aSymbol."	"CodeHolder removeContentsSymbol: #altSyntax"	| entries |	entries := ContentsSymbolQuints		select: [:e | (e isKindOf: Collection) and: [e first = aSymbol]].	ContentsSymbolQuints removeAll: entries.	^ entries! !!ProcessBrowser methodsFor: 'stack list' stamp: 'ul 12/12/2009 12:51'!pcRange	"Answer the indices in the source code for the method corresponding to  	the selected context's program counter value."	(selectedContext isNil or: [methodText isEmptyOrNil])		ifTrue: [^ 1 to: 0].	^selectedContext debuggerMap		rangeForPC: (selectedContext pc ifNotNil: [:pc| pc] ifNil: [selectedContext method endPC])		contextIsActiveContext: stackListIndex = 1! !!CodeHolder class methodsFor: 'controls' stamp: 'dtl 12/9/2009 13:59'!addContentsSymbolQuint: quint afterPosition: index	"Register a menu selection item in the position after index."	"CodeHolder		addContentsSymbolQuint: #(#altSyntax #toggleAltSyntax #showingAltSyntaxString 'altSyntax' 'alternative syntax')		afterPosition: 1"	| entry |	entry := ContentsSymbolQuints at: index.	self contentsSymbolQuints add: quint after: entry! !!CodeHolder methodsFor: 'misc' stamp: 'ul 12/12/2009 14:11'!refreshAnnotation	"If the receiver has an annotation pane that does not bear unaccepted edits, refresh it"	(self dependents detect: [:m | (m inheritsFromAnyIn: #('PluggableTextView' 'PluggableTextMorph')) and: [m getTextSelector == #annotation]] ifNone: [nil]) ifNotNil:		[:aPane | aPane hasUnacceptedEdits ifFalse:			[aPane update: #annotation]]! !!CodeHolder class methodsFor: 'controls' stamp: 'dtl 12/9/2009 13:41'!defaultContentsSymbolQuints	"Default list of quintuplets representing information on the alternative views available in the code pane		first element:	the contentsSymbol used		second element:	the selector to call when this item is chosen.		third element:	the selector to call to obtain the wording of the menu item.		fourth element:	the wording to represent this view		fifth element:	balloon help	A hypen indicates a need for a seperator line in a menu of such choices"	^ {		{#source			. #togglePlainSource 			. #showingPlainSourceString 			. 'source'			. 'the textual source code as written' translated} .		{#documentation			. #toggleShowDocumentation			. #showingDocumentationString			. 'documentation'			. 'the first comment in the method' translated} .		#- .		{#prettyPrint			. #togglePrettyPrint			. #prettyPrintString			. 'prettyPrint'			. 'the method source presented in a standard text format' translated} .		#- .		{#showDiffs			. #toggleRegularDiffing			. #showingRegularDiffsString			. 'showDiffs'			. 'the textual source diffed from its prior version' translated} .		#- .		{#decompile			. #toggleDecompile			. #showingDecompileString			. 'decompile'			. 'source code decompiled from byteCodes' translated} .		{#byteCodes			. #toggleShowingByteCodes			. #showingByteCodesString			. 'byteCodes'				. 'the bytecodes that comprise the compiled method' translated} .		#- .		{#tiles			. #toggleShowingTiles			. #showingTilesString			. 'tiles'			. 'universal tiles representing the method' translated}	}! !!CodeHolder class methodsFor: 'class initialization' stamp: 'dtl 12/9/2009 14:15'!initialize	"CodeHolder initialize"	ContentsSymbolQuints := self defaultContentsSymbolQuints asOrderedCollection.	EditContentsOptions := Dictionary new.	self defaultEditContentsOptions		do: [:opt | EditContentsOptions at: opt key put: opt value]! !!ObjectExplorer methodsFor: 'accessing' stamp: 'ul 12/12/2009 14:08'!selector	^currentSelection ifNotNil: [ :cs | cs selector ]! !!CodeHolder methodsFor: 'misc' stamp: 'dtl 12/9/2009 16:25'!okayToAccept	"Answer whether it is okay to accept the receiver's input"	self showingDocumentation ifTrue:		[self inform: 'Sorry, for the moment you canonly submit changes here whenyou are showing source.  Later, youwill be able to edit the isolated commenthere and save it back, but only if YOUimplement it!!.'.		^ false].	self showingEditContentsOption ifTrue:		[self inform: 'Cannot accept ', self contentsSymbol, ' input'.		^ false].	self showingAnyKindOfDiffs ifFalse:		[^ true]. 	^ (UIManager default chooseFrom: {		'accept anyway -- I''ll take my chances'.		'um, let me reconsider'.	} title:'Caution!!  You are "showing diffs" here, so there is a danger that some of the text in thecode pane is contaminated by the "diff" display') = 1! !CodeHolder initialize!