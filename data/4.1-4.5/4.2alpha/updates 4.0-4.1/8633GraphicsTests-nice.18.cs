"Change Set:		8633GraphicsTests-nice.18GraphicsTests-nice.18:Cosmetic: move or remove a few temps inside closures"!!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'nice 12/27/2009 03:11'!encodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | ff color original encoded |		color := assoc key.		original := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		ff := Form extent: 32@32 depth: requiredDepth.		ff fillColor: color.		encoded := WriteStream on: ByteArray new.		PNGReadWriter putForm: ff onStream: encoded.		self assert: (encoded contents = original contents).	].! !!PNGReadWriterTest methodsFor: 'tests - bits' stamp: 'nice 12/27/2009 20:44'!testPngSuite	"Requires the suite from 		ftp://swrinde.nde.swri.edu/pub/png/images/suite/PngSuite.zip	to be present as PngSuite.zip"	| file |	[file := FileStream readOnlyFileNamed: 'PngSuite.zip'] on: Error do:[:ex| ex return].	file ifNil:[^self].	[ | zip entries |	zip := ZipArchive new readFrom: file.	entries := zip members select:[:mbr| mbr fileName asLowercase endsWith: '.png'].	entries do:[:mbr| 		(mbr fileName asLowercase first = $x)			ifTrue: [self encodeAndDecodeWithError: mbr contentStream ]			ifFalse: [self encodeAndDecodeStream: mbr contentStream ] ].	] ensure:[file close].! !!FormTest methodsFor: 'tests' stamp: 'nice 12/27/2009 03:11'!testIsAllWhite	"self run: #testIsAllWhite"	"Make sure #isAllWhite works for all bit depths"		#(-32 -16 -8 -4 -2 -1 1 2 4 8 16 32) do:[:d| | form |		form := Form extent: 16@16 depth: d.		form fillBlack.		self deny: form isAllWhite.		form fillWhite.		self assert: form isAllWhite.	].! !!BitBltTest methodsFor: 'bugs' stamp: 'nice 12/26/2009 00:24'!testAlphaCompositing2Simulated	"self run: #testAlphaCompositing2Simulated"	Smalltalk at: #BitBltSimulation ifPresent: [:bitblt|	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color transparent.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBitsSimulated.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: result alpha = mixColor alpha.	].]! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 12/27/2009 03:11'!encodeAndDecode: original	"Make sure that the given form is encoded and decoded correctly"	| stream bytes decoded |	"encode"	stream := ByteArray new writeStream.	(PNGReadWriter on: stream) nextPutImage: original; close.	bytes := stream contents.	self writeEncoded: bytes.	"decode"	stream := self readEncoded: bytes.	decoded := (PNGReadWriter new on: stream) nextImage.	decoded display.	"compare"	self assert: original width = decoded width.	self assert: original height = decoded height.	self assert: original depth = decoded depth.	self assert: original bits = decoded bits.	self assert: original class == decoded class.	(original isColorForm) ifTrue:[		original colors with: decoded colors do:[:c1 :c2| | maxErr |			"we must round here due to encoding errors"			maxErr := 1. "max. error for 8bit rgb component"			self assert: ((c1 red * 255) truncated - (c2 red * 255) truncated) abs <= maxErr.			self assert: ((c1 green * 255) truncated - (c2 green * 255) truncated) abs <= maxErr.			self assert: ((c1 blue * 255) truncated - (c2 blue * 255) truncated) abs <= maxErr.			self assert: ((c1 alpha * 255) truncated - (c2 alpha * 255) truncated) abs <= maxErr.		].	].! !!PNGReadWriterTest methodsFor: 'tests - decoding' stamp: 'nice 12/27/2009 03:11'!decodeColors: colorsAndFiles depth: requiredDepth		colorsAndFiles do:[:assoc| | form color bytes |		color := assoc key.		bytes := Base64MimeConverter mimeDecodeToBytes: assoc value readStream.		form := PNGReadWriter formFromStream: bytes.		self assert: form depth = requiredDepth.		self assert: (form pixelValueAt: 1@1) = (color pixelValueForDepth: requiredDepth).	].! !!BitBltTest methodsFor: 'bugs' stamp: 'nice 12/26/2009 00:24'!testAlphaCompositingSimulated	"self run: #testAlphaCompositingSimulated"		Smalltalk at: #BitBltSimulation ifPresent:[:bitblt|	| bb f1 f2 mixColor result eps |	f1 := Form extent: 1@1 depth: 32.	f2 := Form extent: 1@1 depth: 32.	eps := 0.5 / 255.	0 to: 255 do:[:i|		f1 colorAt: 0@0 put: Color blue.		mixColor := Color red alpha: i / 255.0.		f2 colorAt: 0@0 put: mixColor.		mixColor := f2 colorAt: 0@0.		bb := BitBlt toForm: f1.		bb sourceForm: f2.		bb combinationRule: Form blend.		bb copyBitsSimulated.		result := f1 colorAt: 0@0.		self assert: (result red - mixColor alpha) abs < eps.		self assert: (result blue - (1.0 - mixColor alpha)) abs < eps.		self assert: result alpha = 1.0.	]].! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 12/27/2009 03:11'!encodeAndDecodeReverse: original	"Make sure that the given form is encoded and decoded correctly"	| stream bytes decoded reversed |	fileName := 'testReverse', original depth printString,'.png'.	self assert: original class == Form. "won't work with ColorForm"	"Switch pixel order"	reversed := Form extent: original extent depth: original depth negated.	original displayOn: reversed.	self assert: original width = reversed width.	self assert: original height = reversed height.	self assert: original depth = reversed depth.	self deny: original nativeDepth = reversed nativeDepth.	original depth = 32		ifTrue:[self assert: original bits = reversed bits]		ifFalse:[self deny: original bits = reversed bits].	"encode"	stream := ByteArray new writeStream.	(PNGReadWriter on: stream) nextPutImage: reversed; close.	bytes := stream contents.	self writeEncoded: bytes.	"decode"	stream := bytes readStream.	decoded := (PNGReadWriter new on: stream) nextImage.	decoded display.	"compare"	self assert: original width = decoded width.	self assert: original height = decoded height.	self assert: original depth = decoded depth.	self assert: original bits = decoded bits.	self assert: original class == decoded class.	(original isColorForm) ifTrue:[		original colors with: decoded colors do:[:c1 :c2| | maxErr |			"we must round here due to encoding errors"			maxErr := 1. "max. error for 8bit rgb component"			self assert: ((c1 red * 255) truncated - (c2 red * 255) truncated) abs <= maxErr.			self assert: ((c1 green * 255) truncated - (c2 green * 255) truncated) abs <= maxErr.			self assert: ((c1 blue * 255) truncated - (c2 blue * 255) truncated) abs <= maxErr.			self assert: ((c1 alpha * 255) truncated - (c2 alpha * 255) truncated) abs <= maxErr.		].	].! !