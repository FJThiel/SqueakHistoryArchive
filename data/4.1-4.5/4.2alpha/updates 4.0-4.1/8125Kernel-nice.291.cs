"Change Set:		8125Kernel-nice.291Kernel-nice.291:Finish fixing comparison of MethodProperties and AdditionalMethodState for debug purposeMethodProperties is candidate for being removed.But it still has a few instances.After fixing comparison, I can remove some with:(MethodContext allInstances select: [:e | e method notNil    and: [ e method isInstalled not    and: [(e method methodClass notNil)    and: [(e method methodClass includesSelector: e method selector)    and: [e method = (e method methodClass >> e method selector)]]]]])  do: [:mc | mc instVarNamed: #method put:    (mc method methodClass >> mc method selector)]A more efficient weapon for eliminating MethodProperties is Utilities postRecompileCleanup.MethodProperties allInstances size -> 0Kernel-ul.287:- simplified ClassDescription >> #organizationKernel-tbn.288:categorize and format ChronologyConstants>>initialize as a first commit testKernel-nice.289:Fix from http://code.google.com/p/pharo/issues/detail?id=1424This will allow comparing a MethodProperties analogousCodeTo: an AdditionalMethodStateet vice et versaKernel-nice.290:clean-up isSelfEvaluating"!!CompiledMethod methodsFor: 'comparing' stamp: 'nice 11/8/2009 15:27'!= method	| numLits |	"Answer whether the receiver implements the same code as the 	argument, method."	(method isKindOf: CompiledMethod) ifFalse: [^false].	self size = method size ifFalse: [^false].	self header = method header ifFalse: [^false].	self initialPC to: self endPC do:		[:i | (self at: i) = (method at: i) ifFalse: [^false]].	(numLits := self numLiterals) ~= method numLiterals ifTrue: [^false].	"``Dont bother checking FFI and named primitives''	 (#(117 120) includes: self primitive) ifTrue: [^ true]."	1 to: numLits do:		[:i| | lit1 lit2 |		lit1 := self literalAt: i.		lit2 := method literalAt: i.		lit1 = lit2 ifFalse:			[(i = 1 and: [#(117 120) includes: self primitive])				ifTrue: [lit1 isArray							ifTrue:								[(lit2 isArray and: [lit1 allButLast = lit2 allButLast]) ifFalse:									[^false]]							ifFalse: "ExternalLibraryFunction"								[(lit1 analogousCodeTo: lit2) ifFalse:									[^false]]] ifFalse:			[i = (numLits - 1) ifTrue: "properties"				[(self properties analogousCodeTo: method properties) ifFalse:					[^false]] ifFalse:			 [lit1 isFloat				ifTrue:					["Floats match if values are close, due to roundoff error."					(lit1 closeTo: lit2) ifFalse: [^false]. self flag: 'just checking'. self halt]				ifFalse:					["any other discrepancy is a failure"					^ false]]]]].	^true! !!MethodProperties methodsFor: 'testing' stamp: 'nice 11/8/2009 12:22'!hasAtLeastTheSamePropertiesAs: aMethodProperties	"Answer if the recever has at least the same properties as the argument.	 N.B. The receiver may have additional properties and still answer true."	aMethodProperties keysAndValuesDo:		[:k :v|		(v isKindOf: Pragma)			"ifTrue: [Pragmas have already been checked]"			ifFalse: [				properties ifNil: [^false].				^(properties at: k ifAbsent: [^false]) = v]].	^true! !!MethodProperties methodsFor: 'testing' stamp: 'nice 11/8/2009 15:30'!analogousCodeTo: aMethodProperties	pragmas		ifNil: [aMethodProperties pragmas notEmpty ifTrue: [^false]]		ifNotNil:			[pragmas size ~= aMethodProperties pragmas size ifTrue:				[^false].			 pragmas with: aMethodProperties pragmas do:				[:mine :others|				(mine analogousCodeTo: others) ifFalse: [^false]]].	^(self hasAtLeastTheSamePropertiesAs: aMethodProperties)	  and: [aMethodProperties hasAtLeastTheSamePropertiesAs: self]! !!AdditionalMethodState methodsFor: 'testing' stamp: 'nice 11/8/2009 12:27'!hasAtLeastTheSamePropertiesAs: aMethodProperties	"Answer if the recever has at least the same properties as the argument.	 N.B. The receiver may have additional properties and still answer true."	aMethodProperties keysAndValuesDo:		[:k :v|		(v isKindOf: Pragma)			"ifTrue: [Pragmas have already been checked]"			ifFalse: [				(self includes: k->v) ifFalse: [^false]]].	^true! !!ClassDescription methodsFor: 'organization' stamp: 'ul 11/2/2009 03:18'!organization	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."	organization ifNil: [		self organization: (ClassOrganizer defaultList: self methodDict keys sort) ].	(organization isMemberOf: Array) ifTrue: [		self recoverFromMDFaultWithTrace ].		"Making sure that subject is set correctly. It should not be necessary."	organization ifNotNil: [ organization setSubject: self ].	^organization! !!AdditionalMethodState methodsFor: 'testing' stamp: 'nice 11/8/2009 12:47'!analogousCodeTo: aMethodProperties	| bs |	(aMethodProperties isKindOf: MethodProperties) ifTrue: [^aMethodProperties analogousCodeTo: self].	(bs := self basicSize) ~= aMethodProperties basicSize ifTrue:		[^false].	1 to: bs do:		[:i|		((self basicAt: i) analogousCodeTo: (aMethodProperties basicAt: i)) ifFalse:			[^false]].	^true! !!ChronologyConstants class methodsFor: 'class initialization' stamp: 'tbn 11/6/2009 11:33'!initialize	"ChronologyConstants initialize" 				SqueakEpoch := 2415386. 		"Julian day number of 1 Jan 1901" 	SecondsInDay := 86400.	SecondsInHour := 3600.	SecondsInMinute := 60.	NanosInSecond := 10 raisedTo: 9.	NanosInMillisecond := 10 raisedTo: 6.	DayNames := #(Sunday Monday Tuesday Wednesday Thursday Friday Saturday).			MonthNames := #(January February March April May June July 			August September October November December).	DaysInMonth := #(31 28 31 30 31 30 31 31 30 31 30 31)! !Metaclass removeSelector: #isSelfEvaluating!Object removeSelector: #isSelfEvaluating!Class removeSelector: #isSelfEvaluating!Boolean removeSelector: #isSelfEvaluating!Fraction removeSelector: #isSelfEvaluating!ChronologyConstants initialize!