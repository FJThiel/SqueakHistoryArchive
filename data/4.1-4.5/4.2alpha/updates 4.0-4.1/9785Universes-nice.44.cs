"Change Set:		9785Universes-nice.44Universes-nice.44:Fix underscores"!!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 8/14/2007 21:42'!testBrokenDependency	| installer neededPackages |	installer := UGlobalInstaller universe: universe.	neededPackages := installer allPackagesNeededToInstall: (universe newestPackageNamed: 'Broken')  orIfImpossible: [ :ign | nil ].	self should: [ neededPackages isNil ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/28/2004 17:17'!newestPackageNamed: name	| potentials sorted |	potentials := self packagesNamed: name.	sorted := potentials asSortedCollection: [ :p1 :p2 | p1 version < p2 version ].	^sorted last! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:32'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		"process all incoming messages.  Note that some messages move the connection to one of the subsidiary servers, so be careful not to process messages after that happens"	aConnection processIO.	[ 	(connections includes: aConnection) and: [			message := aConnection nextOrNil.	 	 	message notNil ]	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	(connections includes: aConnection) ifFalse: [ ^self ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 8/26/2007 11:24'!morphicView	| win column nameRow versionRow urlRow descriptionField submitButton dependsRow homepageRow providesRow maintainerRow categoryRow smidRow |	window ifNotNil: [ ^window ].	win := SystemWindow labelled: 'Package Editor'.	win model: self.	column := AlignmentMorph newColumn.	win addMorph: column frame: (0@0  extent:  1@0.6).		nameRow := UInterfaceUtilities makeFieldRowNamed: 'name:' getSelector: #packageName setSelector: #packageName: for: self.	column addMorphBack: nameRow.		versionRow := UInterfaceUtilities makeFieldRowNamed: 'version:' getSelector: #versionString setSelector: #versionString: for: self.	column addMorphBack: versionRow.		categoryRow := UInterfaceUtilities makeFieldRowNamed: 'category:' getSelector: #categoryString setSelector: #categoryString: for: self.	column addMorphBack: categoryRow.		maintainerRow := UInterfaceUtilities makeFieldRowNamed: 'maintainer:' getSelector: #maintainer setSelector: #maintainer: for: self.	column addMorphBack: maintainerRow.		homepageRow := UInterfaceUtilities makeFieldRowNamed: 'homepage:' getSelector: #homepageString setSelector: #homepageString: for: self.	column addMorphBack: homepageRow.		smidRow := UInterfaceUtilities makeFieldRowNamed: 'SqueakMap ID:' getSelector: #smidString setSelector: #smidString: for: self.	smidRow addMorphBack: self makeGuessSMIDButton.	column addMorphBack: smidRow.			urlRow := UInterfaceUtilities makeFieldRowNamed: 'download from:' getSelector: #urlString setSelector: #urlString: for: self.	column addMorphBack: urlRow.	providesRow := UInterfaceUtilities makeFieldRowNamed: 'provides:' getSelector: #providesString setSelector: #providesString: for: self.	column addMorphBack: providesRow.		dependsRow := UInterfaceUtilities makeFieldRowNamed: 'depends:' getSelector: #dependsString setSelector: #dependsString: for: self.	column addMorphBack: dependsRow.	column addMorphBack: (StringMorph contents: 'Description:').		descriptionField := self makeFieldGet: #description set: #description:.	win addMorph: descriptionField frame: (0@0.6 extent: 1@0.3).		submitButton := UInterfaceUtilities makeButtonWithAction: #submit andLabel: 'Submit' for: self.	win addMorph: submitButton frame: (0@0.9 extent: 1@0.1).			^window := win! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:36'!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: isPassword for: model	| row field |	row := AlignmentMorph newRow.	row color: Color transparent.	row cellInset: 3@0.		field := self makeFieldGet: getSelector set: setSelector for: model.	isPassword ifTrue:[		field font: (StrikeFont passwordFontSize: TextStyle default defaultFont pointSize) ].	row addMorph: (StringMorph contents: fieldName).	row addMorphBack: field.	^row! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 09:16'!saveDirectory: aDirectory	saveDirectory := aDirectory! !!UConfiguration methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:55'!initialize	installedPackages := Set new.! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/15/2005 22:42'!updatePackagesViaWWW	| rawPackageList newPackages |	packagesURL ifNil: [ ^self ].	rawPackageList := packagesURL retrieveContents content.	(rawPackageList withBlanksTrimmed beginsWith: '<') ifFalse: [		"it is possible that the universe is completely empty, but more likely there was an error retrieving the document"		^self ].	newPackages := UPackage decodePackagesFromXMLStream: (ReadStream on: rawPackageList).	self packages: newPackages! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!description: aString	description := aString! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!packageNames	| names |	names := Set new.	self packages do: [ :p | names add: p name ].	^names! !!UMRemovePackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:39'!username: username0 password: password0 packageName: packageName0 packageVersion: packageVersion0	username := username0.	password := password0.	packageName := packageName0.	packageVersion := packageVersion0.	! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18'!encodeStringArray: stringArray	| size outBuf outBufIndex |	size := self spaceToEncode: stringArray.		outBuf := String new: size.	outBufIndex := 1.	outBuf putInteger32: stringArray size at: outBufIndex.	outBufIndex := outBufIndex + 4.	stringArray do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex := outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex := outBufIndex + each size.	].		^outBuf! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 100 ] whileTrue: [		| newSocket |		newSocket := connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:21'!startListening	self stopListening.	connectionQueue := ConnectionQueue portNumber: universe serverPort queueLength: 5.	! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!allowed: anObject	allowed := anObject! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/15/2005 22:06'!newPackageVersion	| package editor newPackage |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package := self selectedPackage.		newPackage := package deepCopy.	newPackage version: (UVersion readFromString: (newPackage version asString, 'new')).	editor := UPackageEditor package: newPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:10'!shortName: aString	shortName := aString! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!password: anObject	password := anObject! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:41'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue := nil ].	! !!UPackage class methodsFor: 'decoding' stamp: 'ls 8/26/2007 12:01'!decodeFromXMLElement: doc	| package urlString |	package := self new.	package name: (self getXMLPartNamed: 'name' from: doc).	package version: (UVersion readFromString: (self getXMLPartNamed: 'version' from: doc)).	package description: (self getXMLPartNamed: 'description' from: doc).	urlString := self getXMLPartNamed: 'url' from: doc.	urlString isEmpty ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [	 		package url: (Url absoluteFromText: urlString). ] ].	(doc elementAt: 'homepage') ifNotNil: [		package homepage: (Url absoluteFromText: (self getXMLPartNamed: 'homepage' from: doc)) ].	package maintainer: (self getXMLPartNamed: 'maintainer' from: doc).	package provides: (self getXMLPackageList: 'provides' from: doc).	package depends: (self getXMLPackageList: 'depends' from: doc).	(doc elementAt: 'category') ifNotNil: [		package category: (UPackageCategory readFromString: (self getXMLPartNamed: 'category' from: doc ))].	(doc elementAt: 'squeakMapID') ifNotNil: [		| idstr |		idstr := self getXMLPartNamed: 'squeakMapID' from: doc.		idstr isEmpty ifFalse: [			package squeakMapID: (UUID fromString: idstr)]].	^package! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 1/16/2005 14:07'!initialize	description := 'some universe'.! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:32'!policy: aPolicy	policy := aPolicy! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password1: aString	newPassword := aString asString.	self changed: #password1.	^true! !!UPWild methodsFor: 'policies' stamp: 'ls 2/13/2005 16:38'!changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail	| account |	account := self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'username not present or password does not match' ].		newPassword isEmpty ifFalse: [account password: newPassword ].	newEmail isEmpty ifFalse: [account email: newEmail ].	^UPolicyResponse allowed! !!UMAddAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:33'!username: username0  password: password0  email: email0	username := username0.	password := password0.	email := email0.	! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:52'!editAccount	| editor |	self acceptFields.	self closeAccountEditor.		editor := UAccountEditor		username: username		password: password		email:  ''		whenDone: [ :oldPassword :newPassword :newEmail |			password := oldPassword.			self sendMessage: (UMEditAccount username: username password: password newPassword: newPassword newEmail: newEmail) ].			editor openInMorphic.		accountEditor := editor.! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:18'!url: aURL	url := aURL! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42'!newPackage	| editor |	self acceptFields.	editor := UPackageEditor package: self createNewPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 12:50'!morphicView	| win packageList installButton doInstallButton buttonList upgradeButton updateListButton descriptionArea installButtonHolder |	win := SystemWindow labelled: 'Universe'.	win model: self.			packageList := 		PluggableTreeMorph new			model:  self;			name: 'package list';			getRootsSelector: #rootCategoriesAndPackages; 			hasChildrenSelector: #isCategory:; 			getChildrenSelector: #categoriesAndPackagesIn:;			setSelectedSelector: #selectPackageOrCategory:;			getLabelSelector: #packageOneLineDescription:.	win addMorph: packageList frame: ((0@0) extent: (0.5@0.9)).		installButtonHolder := Morph new.  "necessary to keep SystemWindow from screwing up the colors of the button"	installButtonHolder 		name: 'holder for install button';		layoutPolicy: TableLayout new;		borderColor: self defaultBackgroundColor.	doInstallButton := self makeButtonWithAction: #doInstall andGetState: #anyPackagesToInstall andLabel: 'Install Selections'.	doInstallButton		useSquareCorners;		borderWidth: 0;		setBalloonText: 'Download and install all the packages that you have selected';		name: 'install selections button'.	installButtonHolder addMorph: doInstallButton.	win addMorph: installButtonHolder frame: ((0@0.9) extent:(1@0.1)).	descriptionArea := PluggableTextMorph on: self text: #selectedPackageDescription accept: nil.	win addMorph: descriptionArea frame: ((0.5@0.4) extent: (0.5@0.5)).		buttonList := AlignmentMorph newColumn.	buttonList		cellInset: 0@3;		name: 'button list'.	win addMorph: buttonList frame: ((0.5@0) extent: (0.5@0.4)).			installButton := self makeButtonWithAction: #installSelectedPackage andGetState: #canMarkSelectionForInstallation andLabel: 'select package'.	installButton setBalloonText: 'Select this package for installation'.	buttonList addMorph: installButton.		upgradeButton := self makeButtonWithAction: #chooseUpgrades andLabel: 'select all upgrades'.	upgradeButton setBalloonText: 'Select every possible upgrade for the currently installed packages'.	buttonList addMorphBack: upgradeButton.		updateListButton := self makeButtonWithAction: #requestPackageList andLabel: 'update list from network'.	updateListButton setBalloonText: 'Refresh the list of available packages from the network'.	buttonList addMorphBack: updateListButton.		^win! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverName: aString		serverName := aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:32'!maintainer: aString	maintainer := aString! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:01'!packages: aCollection	packages := Set new.	packages addAll: aCollection.	self changed: #packages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverPort: port	serverPort := port! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!reason: anObject	reason := anObject! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:53'!newEmail: anObject	newEmail := anObject! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!username: anObject	username := anObject! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountChangeForUsername: username  password: password  newPassword: newPassword newEmail: newEmail	| response |	response := policy changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail.	response allowed ifFalse: [		^self			sendError: 'changing account for ', username, ' failed (', response reason, ')'			onConnection: connection].			self sendMessage: (UMEditedAccount username: username newPassword: newPassword newEmail: newEmail) onConnection: connection! !!UOneShotConnection methodsFor: 'initialize-release' stamp: 'ls 8/2/2004 16:33'!initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue	inputMessage := inMessage0.	outputQueue := aSharedQueue.	hasBeenRead := false.	hasBeenWritten := false.! !!UMessage class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:41'!fromStringArray: array	| class |	class := nil.	array first = 'requestpackages' ifTrue: [ class := UMRequestPackages ].	array first = 'packages' ifTrue: [ class := UMPackageList ].	array first = 'error' ifTrue: [ class := UMError ].	array first = 'addaccount' ifTrue: [ class := UMAddAccount ].	array first = 'addpackage' ifTrue: [ class := UMAddPackage ].	array first = 'editaccount' ifTrue: [ class := UMEditAccount ].	array first = 'editedaccount' ifTrue: [ class := UMEditedAccount ].	array first = 'packageadded' ifTrue: [ class := UMPackageAdded ].	array first = 'packageremoved' ifTrue: [ class := UMPackageRemoved ].	array first = 'removepackage' ifTrue: [ class := UMRemovePackage ].	array first = 'selectserver' ifTrue: [ class := UMSelectServer ].	array first = 'protocolversion' ifTrue: [ class := UMProtocolVersion ].	class ifNil: [			^UMMalformed fromStringArray: array ].		^[ class fromStringArray: array ] on: Error do: [ :ex | UMMalformed fromStringArray: array ]! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 7/30/2004 15:31'!startConnecting	"start a new connection to the server"	self disconnect.		lastConnectionStart := DateAndTime now.		socket := Socket newTCP.	socket connectTo: (NetNameResolver addressForName: universe serverName) port: universe serverPort.! !!UMEditedAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:36'!username: username0  newPassword: newPassword0  newEmail: newEmail0	username := username0.	newPassword := newPassword0.	newEmail := newEmail0.	! !!UPWild methodsFor: 'policies' stamp: 'ls 5/13/2007 10:04'!addUser: username withPassword: password  andEmail: email	| newAccount |	(accounts anySatisfy: [ :acc | acc username = username]) ifTrue: [		"already an account here"		^UPolicyResponse denied: 'account already exists' ].	superUser ifNotNil: [		superUser username = username ifTrue: [			"cannot create an account with the superuser's name"			^UPolicyResponse denied: 'same account name as the superuser' ] ].			(self class isReasonableUsername: username) ifFalse: [		^UPolicyResponse denied: 'invalid account name' ].		newAccount := UAccount new.	newAccount username: username.	newAccount password: password.	newAccount email: email.		accounts add: newAccount.	^UPolicyResponse allowed! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!name: aString	name := aString! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 16:18'!switchConnection: aConnection  toServerNamed: serverName	| server |	server := servers detect: [ :s | s universe shortName = serverName ] ifNone: [		aConnection nextPut: (UMError description: 'no such server here') asStringArray.		^self ].	server acceptConnection: aConnection.	connections remove: aConnection.! !!UMPackageRemoved methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:57'!packageName: aString  version: aVersion	packageName := aString.	version := aVersion.! !!UAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 18:02'!initialize	username := 'joeblow'.	password := ''.	packageNames := Set new.! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 2/13/2005 16:50'!password: aString	password := aString.	self changed: #password! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:34'!makeFieldGet: getSelector  set: setSelector  for: model	| field fieldHeight |	fieldHeight := TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: model text: getSelector accept: setSelector.	field height: fieldHeight.	field hResizing: #spaceFill.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.	model noteField: field.	^field! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/15/2005 22:02'!morphicView	| win universeDescription buttonList usernameRow passwordRow button  usernamePasswordArea packageList |	win := SystemWindow labelled: 'Universe Editor'.	win model: self.		universeDescription := PluggableTextMorph on: self text: #universeDescription accept: nil.	universeDescription hideScrollBarsIndefinitely.	win addMorph: universeDescription frame: (0@0 extent: 1@0.1).		buttonList := AlignmentMorph newColumn.	buttonList cellInset: 0@3.	win addMorph: buttonList frame: (0@0.5 extent: 0.5@0.5).			usernamePasswordArea := AlignmentMorph newColumn.	win addMorph: usernamePasswordArea frame: (0@0.1 extent: 0.5@0.4).	usernameRow := UInterfaceUtilities makeFieldRowNamed: 'username' getSelector: #username setSelector: #username: for: self.	usernamePasswordArea addMorphBack: usernameRow.		passwordRow := UInterfaceUtilities makeFieldRowNamed: 'password:' getSelector: #password setSelector: #password: isPassword: true for: self.	usernamePasswordArea addMorphBack: passwordRow.		button := self makeButtonWithAction: #createAccount andLabel: 'createAccount'.	buttonList addMorphBack: button.	button := self makeButtonWithAction: #editAccount andLabel: 'edit account'.	buttonList addMorphBack: button.	button := self makeButtonWithAction: #newPackage andLabel: 'new package'.	buttonList addMorphBack: button.	button := self makeButtonWithAction: #newPackageVersion andGetState: #anyPackageSelected andLabel: 'new package version'.	buttonList addMorphBack: button.	button := self makeButtonWithAction: #removeVersion andGetState: #anyPackageSelected andLabel: 'remove package version'.	buttonList addMorphBack: button.	button := self makeButtonWithAction: #requestPackageList andLabel: 'update package list'.	buttonList addMorphBack: button.	packageList := PluggableListMorph on: self list: #packageDescriptions  selected: #selectedPackageIndex changeSelected: #selectedPackageIndex: menu: nil.	win addMorph: packageList frame: ((0.5@0.1) extent: (0.5@0.9)).		^win! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 5/28/2007 17:32'!processRawMessage: aStringArray  fromConnection: connection	| message |	message := UMessage fromStringArray: aStringArray.	message applyToServer: self forConnection: connection.	self logMessage: message.	! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:31'!createAccount	self acceptFields.	email := FillInTheBlankMorph request: 'your email address?'.	email = '' ifTrue: [ ^self ].	self sendMessage: (UMAddAccount username: username password: password email: email).	! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:12'!universe: aUniverse	universe := aUniverse.	universe addDependent: self.! !!UUniverse class methodsFor: 'system' stamp: 'ls 2/13/2005 12:44'!systemUniverse	"return the universe this image uses"	^SystemUniverse ifNil: [ SystemUniverse := self developmentUniverse ]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!version: aVersion	version := aVersion.	! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 11/26/2006 10:50'!testXML	| xmlString stream readp1 readp2 readPackages readp3 |	p2 version: (UVersion readFromString: '1.2').	p1 description: 'blah blah <>&"'''.	xmlString := String streamContents: [ :str |		str 			nextPutAll: p1 xmlForExport;			nextPutAll: p2 xmlForExport.					str nextPutAll: '<package><name>IRCe</name><version>10.7.6</version><description>This is a significant rewrite of the built-in Squeak IRC client GUI. A new user interface includes having one console window per connection and then having all console messages, channel messages and private messages contained inside the main console window using tabbed swapped panes.                                         Numerous other changes are also included but are not described here. The change-set contains documentation for all features added or modified.Instructions at http://squeak.preeminent.org/irc-help/irc-help.html</description><url>http://kilana.unibe.ch:8888/IRC/Network-IRC-fc.10.7.6.mcz</url><maintainer></maintainer><provides></provides><depends></depends><conflicts></conflicts></package>' ].	stream := ReadStream on: xmlString.	readPackages := UPackage decodePackagesFromXMLStream: stream.	self should: [ readPackages size = 3 ].	readp1 := readPackages first.	readp2 := readPackages second.	readp3 := readPackages third.	self should: [ readp1 = p1 ].	self should: [ readp2 = p2 ].	self should: [ readp3 name = 'IRCe'].	self should: [ readp3 version = (UVersion readFromString: '10.7.6')].	! !!UPWild methodsFor: 'account assignment' stamp: 'ls 7/28/2004 18:14'!findAccount: username withPassword: password	| account |	account := accounts detect: [ :acc | acc username = username] ifNone: [		"no such account"		^nil ].		account password = password ifFalse:[		"wrong password"		^nil ].		^account! !!UPackage class methodsFor: 'saving' stamp: 'ls 2/13/2005 14:47'!savePackageList: packageList  onFileNamed: filename	| tmpName file |	tmpName := filename, 'tmp'.	FileDirectory default deleteFileNamed: tmpName ifAbsent:  [].	file := FileStream fileNamed: tmpName.	packageList do: [ :package |		file nextPutAll: package xmlForExport ].	file close.	FileDirectory default rename: tmpName toBe: filename.! !!UMPackageList methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 12:01'!packages: aCollection	packages := aCollection! !!UUniverseEditor methodsFor: 'initialization' stamp: 'ls 2/13/2005 17:16'!initialize: universe0	universe := universe0.	universe addDependent: self.	client := UUniverseClient forUniverse: universe.	username := Utilities authorInitialsPerSe.	password := ''.		packageEditors := Set new.	selectedPackageIndex := 0.! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:24'!decodePackagesFromXMLStream: stream	| doc |	doc := XMLDOMParser parseDocumentFrom: stream.	^doc elements collect: [ :element | self decodeFromXMLElement: element ].! !!UConfiguration methodsFor: 'installing' stamp: 'ls 7/27/2004 21:55'!installPackage: aPackage	| matchingPackages |	matchingPackages := installedPackages select: [ :p | p name = aPackage name ].	installedPackages removeAll: matchingPackages.	aPackage install.	installedPackages add: aPackage.	! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 7/28/2004 18:00'!accountUpdatedWithUsername: newUsername  password:  newPassword  email: newEmail	self acceptFields.	username := newUsername.	password := newPassword.	email := newEmail.		self changed: #username.	self changed: #password.	self changed: #email.		self closeAccountEditor! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue := nil ].	! !!UMEditAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:36'!username: username0  password: password0  newPassword: newPassword0 newEmail: newEmail0	username := username0.	password := password0.	newPassword := newPassword0.	newEmail := newEmail0.	! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:34'!makeFieldGet: getSelector  set: setSelector	| field fieldHeight |	fieldHeight := TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: self text: getSelector accept: setSelector.	field extent: 200@fieldHeight.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.		fields ifNil: [ fields := OrderedCollection new].	fields add: field.		^field! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toRemovePackageNamed: packageName withVersion: version	| packagesToRemove response |	response := policy packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password.		response allowed ifFalse: [		^self 			sendError: 'removing package ', packageName, ' failed (', response reason, ')' 			onConnection: connection].			packagesToRemove := universe packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p |		universe removePackage: p ].		self sendMessage: (UMPackageRemoved packageName: packageName version: version) onConnection: connection.! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!startListening	self stopListening.	connectionQueue := ConnectionQueue portNumber: port queueLength: 5.	! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toAddPackage: package	| response |	response := policy package: package mayBeAddedBy: username withPassword: password.		response allowed		ifFalse: [			^self 				sendError: 'adding package ', package name, ' failed (', response reason, ')'				onConnection: connection].			universe addPackage: package.	self sendMessage: (UMPackageAdded package: package) onConnection: connection.! !!UServerStepperMorph methodsFor: 'initialization' stamp: 'ls 7/28/2004 13:19'!server: aServer	server := aServer! !!UPackage methodsFor: 'installing' stamp: 'ls 5/13/2007 18:10'!cachedCopyFilename	"Download the package to a local cache, if it is not already in the cache.  Return the filename of the file in the cache.  If the package has no URL, download nothing and return nil."	| filename doc file downloadDir |	self url ifNil: [ ^nil ].		downloadDir := FileDirectory default directoryNamed: 'universetmp'.	downloadDir assureExistence.		filename := self url path last.	(downloadDir isAFileNamed: filename)	ifFalse: [		"download the file"		doc := url retrieveContents.		((doc contentType asString = 'text/plain') and: [			doc content beginsWith: 'error']) ifTrue: [			"HACK to see if the download failed; the real solution is to make retrieveContents report errors"			^self error: 'download failed' ].		file := downloadDir newFileNamed: filename.		file binary.		file nextPutAll: doc content.		file close. ].	^ (downloadDir fullNameFor: filename).! !!UGlobalInstallerTest methodsFor: 'Running' stamp: 'ls 1/16/2005 14:11'!setUp	| package |	universe := UStandardUniverse new.		package := UPackage new.	package name: 'A'.	package addDependency: 'B'.	universe addPackage: package.		package := UPackage new.	package name: 'B'.	package addDependency: 'C'.	universe addPackage: package.		package := UPackage new.	package name: 'C'.	package addDependency: 'D'.	package addDependency: 'E'.	universe addPackage: package.		package := UPackage new.	package name: 'D'.	universe addPackage: package.		package := UPackage new.	package name: 'E'.	universe addPackage: package.	package := UPackage new.	package name: 'Broken'.	package addDependency: 'NonExistent'.	universe addPackage: package.	! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 13:44'!packageListFilename: filename	packageListFilename := filename! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!email: aString	email := aString! !!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:27'!readFrom: stream	| components |	components := OrderedCollection new.	[ stream atEnd ] whileFalse: [		stream peek isDigit ifTrue: [			components add: (Integer readFrom: stream) ]		ifFalse: [			components add: (String streamContents: [ :compStr |				[ stream atEnd not and: [ stream peek isDigit not ] ] whileTrue: [					compStr nextPut: stream next ] ]) ] ].			^self fromComponents: components! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:58'!closeAccountEditor	accountEditor ifNil: [ ^self ].	accountEditor window delete.	accountEditor := nil.! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterPassword: password	masterPassword := password! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 15:39'!depends: aCollection	depends := Set withAll: aCollection! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:58'!configuration: aConfiguration	configuration := aConfiguration! !!UUniverse class methodsFor: 'system' stamp: 'ls 7/29/2004 18:54'!switchSystemToUniverse: aUniverse	SystemUniverse := aUniverse! !!UVersion methodsFor: 'initialization' stamp: 'ls 7/27/2004 17:27'!components: aCollection	components := aCollection! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password2: aString	newPassword2 := aString asString.	self changed: #password2.	^true! !!UIFileOut methodsFor: 'installing' stamp: 'ls 7/29/2004 20:01'!install: inStream  usingBaseName: basename	"find a changeset name that is not used"	| num changesetName stream |	num := 0.	[  	changesetName := basename.	   	num > 0 ifTrue:[ changesetName := changesetName, '-', num printString. ].		(ChangeSorter changeSetNamed: changesetName) notNil ]	whileTrue: [ num := num + 1 ].		"decompress if necessary"	inStream peek asInteger = 16r1F		ifTrue: [ stream := ReadStream on: ((GZipReadStream on: inStream) upToEnd) asString ]		ifFalse: [ stream := inStream ].			ChangeSorter newChangesFromStream: stream named: changesetName! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 09:29'!forSaveDirectory: aDirectory	| universe |	universe := self forUniverse: UUniverse new.	universe saveDirectory: aDirectory.	universe loadFromCheckpoint.	^universe! !!UMMalformed methodsFor: 'accessing' stamp: 'ls 7/28/2004 11:45'!stringArray: anObject	stringArray := anObject! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33'!initialize	servers := Set new.	port := UUniverseMultiServer defaultPort.	connections := Set new.! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/3/2004 18:04'!decodeStringArray: aString	| idx numStrings |	idx := 1.	numStrings := aString getInteger32: idx.	idx := idx + 4.	numStrings < 0 ifTrue: [ ^self error: 'invalid string socket encoding' ].	numStrings > 10000000 ifTrue: [ self error: 'refusing to decode humongous string socket' ].		^(1 to: numStrings) collect: [ :ignored |		| size str |		size := aString getInteger32: idx.		idx := idx + 4.		str := aString copyFrom: idx to: idx+size-1.		idx := idx + size.		str ]	! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:20'!initializeForUniverse: aUniverse	universe := aUniverse.	policy := UPolicy new.	connectionQueue := nil.	connections := Set new.! !!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:05'!fromStringArray: array	| str packages numPackages |	str := ReadStream on: array.	str next.  "skip the 'packages' designation".	packages := OrderedCollection new.	numPackages := Integer readFromString: str next.	numPackages timesRepeat: [		packages add: (UPackage decodeFromStringStream: str) ].			^self packages: packages! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:41'!readPackageListFromFileNamed: filename	| file packages |	file := FileStream readOnlyFileNamed: filename.	packages := self decodePackagesFromXMLStream: file.	file close.	^packages! !!UPackageInstaller methodsFor: 'installing' stamp: 'ls 9/4/2004 15:02'!installFileNamed: filename	| stream baseName |	stream := (FileStream readOnlyFileNamed: filename).	baseName := (FileDirectory splitName: filename to: [:path :base|base]) copyUpTo: $. .	self install: stream usingBaseName: baseName.	stream close.	! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountWithUsername: username  password: password  email: email 	| response |	response := policy addUser: username withPassword: password andEmail: email.	response allowed ifFalse: [		self			sendError: 'adding account for ', username, ' failed (', response reason, ')'			onConnection: connection].! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:12'!getXMLPackageList: listname from: element	| listElement |	listElement := element elementAt: listname.	listElement ifNil: [ ^#() ].	^listElement elements collect: [ :nameXML |		nameXML contents first string ]! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32'!nextOrNil	hasBeenRead ifTrue:[ ^nil ].	hasBeenRead := true.	^inputMessage! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 21:28'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		aConnection processIO.	[ 	message := aConnection nextOrNil.	  	message notNil	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 7/29/2004 09:25'!loadFromCheckpoint	"reload from a checkpoint"	| file savedObject |	(saveDirectory isAFileNamed: 'checkpoint')		ifTrue: [ file := saveDirectory readOnlyFileNamed: 'checkpoint' ]		ifFalse: [ file := saveDirectory readOnlyFileNamed: 'checkpoint.die' ].	savedObject := file fileInObjectAndCode.	file close.		universe := savedObject first.	policy := savedObject second.	! !!UIMpeg methodsFor: 'installing' stamp: 'ls 7/29/2004 11:39'!install: stream usingBasename: basename	| movieDir movieFile |	movieDir := FileDirectory default directoryNamed: 'movies'.	movieDir assureExistence.		movieDir removeFileNamed: basename.		movieFile := movieDir newFileNamed: basename, '.mpeg'.	stream binary.  movieFile binary.	movieFile nextPutAll: stream upToEnd.	movieFile close.		Smalltalk at: #MPEGMoviePlayerMorph ifPresent: [ :player |		player playFile: (movieDir fullNameFor: basename, '.mpeg') ]! !!UPackageInstaller class methodsFor: 'initialization' stamp: 'ls 7/29/2004 11:09'!initialize	Installers ifNil: [ Installers := Set new ].		{UIFileOut. UIMonticello. UIMpeg. UIProject. UISar} do: [ :c |		self registerInstaller: c new ]! !!UConfiguration class methodsFor: 'system' stamp: 'ls 7/27/2004 21:57'!forSystem	"return a configuration describing the currently running system"	^SystemConfiguration ifNil: [ SystemConfiguration := self new ].	! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/13/2005 17:20'!removeVersion	| package |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package := self selectedPackage.	(self confirm: ('Delete ', 	package printString, '?')) ifFalse: [		^self ].	self sendMessage: (UMRemovePackage username: username password: password packageName: package name packageVersion: package version).! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 14:34'!processRawMessage: aStringArray  fromConnection: connection	| message |	message := UMessage fromStringArray: aStringArray.	message applyToMultiServer: self forConnection: connection.! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:20'!homepage: aURL	homepage := aURL! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:12'!packagesURL: aURL	packagesURL := aURL! !!UPWild methodsFor: 'account assignment' stamp: 'ls 4/14/2007 18:40'!tryToGivePackageName: packageName toUsername: username  withPassword: password	| account |	(self class isReasonablePackageName: packageName) ifFalse: [		^UPolicyResponse denied: 'invalid package name' ].		account := self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'incorrect password or no such user' ].	account == superUser ifTrue: [		^UPolicyResponse allowed ].	(account ownsPackageName: packageName) ifTrue: [		^UPolicyResponse allowed ].		(accounts anySatisfy: [ :acc | acc ownsPackageName: packageName ]) ifTrue: [		^UPolicyResponse denied: 'package is owned by another' ].		account addPackageName: packageName.	^UPolicyResponse allowed! !!UPWild methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 21:35'!initialize	accounts := OrderedCollection new! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackageIndex: anInteger	selectedPackageIndex := anInteger.	self changed: #selectedPackageIndex.! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!removePackageNamed: packageName withVersion: version	| packagesToRemove |	packagesToRemove := self packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p | self removePackage: p ].	! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 2/15/2005 21:44'!processIO	| rawMsg |	(stringSocket notNil and: [ stringSocket isConnected not ]) ifTrue: [		"connection has died"		stringSocket destroy.		stringSocket := nil ].		(outMessages isEmpty not and: [ socket isNil and: [ stringSocket isNil ] ]) ifTrue: [		"there are outgoing messages queued but there is no stringSocket"		(DateAndTime now - lastConnectionStart) > (Duration minutes: 1) ifTrue: [			self startConnecting ] ].		socket ifNotNil: [		"a connection is in progress"				socket isConnected ifTrue: [			"connection completed"			stringSocket := StringSocket on: socket.			universe shortName ifNotNil: [				outMessages addFirst: (UMProtocolVersion version: 1).				outMessages addFirst: (UMSelectServer shortName: universe shortName) ].			socket := nil. ]		ifFalse: [			socket isWaitingForConnection ifFalse: [				"the connection failed"				inMessages add: (UMConnectionFailed description: 'connection failed').				^self disconnect ] ] ].		stringSocket ifNil: [ ^self ].			[ outMessages isEmpty ] whileFalse: [		stringSocket nextPut: outMessages removeFirst asStringArray ].		stringSocket processIO.		[	rawMsg := stringSocket nextOrNil.		rawMsg isNil not	] whileTrue: [ 		self newInMessage: (UMessage fromStringArray: rawMsg) ]! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/2/2007 15:00'!getXMLPartNamed: partName  from: xmlDoc	| element |	element := xmlDoc elementAt: partName.	(element isNil or: [ element contents isEmpty ]) ifTrue:[ ^ '' ].	^element contents first string! !!UMProtocolVersion methodsFor: 'initialize-release' stamp: 'ls 2/15/2005 21:39'!version: anInteger	version := anInteger! !!UPackageEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 16:28'!package: aPackage  whenComplete: aBlock	package := aPackage.	whenComplete := aBlock.	! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterUser: userName	masterUser := userName! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:56'!components: anObject	components := anObject.	components do: [ :c | c addDependent:  self ].! !!UMPackageAdded methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:59'!package: aPackage	package := aPackage! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:15'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 10 ] whileTrue: [		| newSocket |		newSocket := connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:10'!disconnect	"explicitly close the connection"	socket ifNotNil: [ socket destroy.  socket := nil ].	stringSocket ifNotNil: [ stringSocket destroy.  stringSocket := nil ].! !!UUniverseClient methodsFor: 'initialization' stamp: 'ls 8/5/2004 17:16'!initialize: aUniverse	universe := aUniverse.		inMessages := OrderedCollection new.	outMessages := OrderedCollection new.		lastConnectionStart := DateAndTime epoch.! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:33'!destroy	hasBeenWritten := true! !!UPackageTestCase methodsFor: 'setup' stamp: 'ls 11/26/2006 11:10'!setUp	p1 := UPackage new.	p1 name: 'Scamper'.	p1 category: (UPackageCategory withComponents: #('Networking')).	p1 description: 'A web browser'.	p1 url: 'http://www.squeak.org' asUrl.	p1 homepage: p1 url.	p1 version: (UVersion readFromString: '1.0').	p1 maintainer: 'John Doe'.	p2 := p1 deepCopy.! !!UAccountEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:40'!username: username0  password: password0  email: email0  whenDone: aBlock	username := username0.	password := password0.	newPassword := ''.	newPassword2 := ''.	newEmail := email0.	whenDone := aBlock.! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 16:16'!description: aString	description := aString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:27'!provides: aCollection	provides := Set withAll: aCollection! !!UMSelectServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 16:12'!shortName: aString	shortName := aString! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:12'!closeEditorForPackage: package	| matchingEditors |	matchingEditors := packageEditors select: [ :p | p package = package ].	matchingEditors do: [ :editor |		editor window delete.		packageEditors remove: editor ].! !!UPackage class methodsFor: '*universes-messages' stamp: 'ls 8/26/2007 12:01'!decodeFromStringStream: str	| package numDepends homePageText numProvides numConflicts urlString |	package := self new.	package name: str next.	package version: (UVersion readFromString: str next).	package description: str next.	urlString := str next.	(urlString withBlanksTrimmed beginsWith: '(') ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [			package url: (Url absoluteFromText: urlString) ] ].	homePageText := str next.	package homepage: (homePageText isEmpty ifTrue: [ nil ] ifFalse: [ homePageText asUrl ]).	package maintainer: str next.	numProvides := Integer readFromString: str next. 	package provides: (str next: numProvides).	numDepends := Integer readFromString: str next. 	package depends: (str next: numDepends).	numConflicts := Integer readFromString: str next. 	str next: numConflicts.  "skip them"	str atEnd ifFalse: [		package category: (UPackageCategory readFromString: str next)].		str atEnd ifFalse: [		| idstr |		idstr := str next.		idstr isEmpty ifFalse: [			package squeakMapID:  (UUID fromString: idstr) ].		].		^package! !!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07'!fromStringArray: array	| str |	str := ReadStream on: array.	str next.	^self package: (UPackage decodeFromStringStream: str)! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:13'!username: aString	username := aString asString.	^true! !!UUniverseBrowser class methodsFor: 'dependencies' stamp: 'ls 7/29/2004 15:16'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages := Set new.	orderedPackages := OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^orderedPackages! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:18'!password: aString	password := aString asString.	^true! !!UMAddPackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:37'!username: username0 password: password0 package: package0	username := username0.	password := password0.	package := package0.	! !UPackageInstaller initialize!