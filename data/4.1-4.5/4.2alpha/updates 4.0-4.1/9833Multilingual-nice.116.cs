"Change Set:		9833Multilingual-nice.116Multilingual-nice.116:Don't let Unicode use #scanMultiCharactersCombiningFrom:to:in:rightX:stopConditions:kern: until problems are fixed.Anyway, combining diacritical was experimental and not really operational.Multilingual-ul.115:- move separator skip methods to the TextConverters"!MultiCharacterScanner subclass: #MultiCompositionScanner	instanceVariableNames: 'spaceX lineHeight baseline breakableIndex lineHeightAtBreak baselineAtBreak breakAtSpace'	classVariableNames: ''	poolDictionaries: ''	category: 'Multilingual-Scanning'!!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/26/2010 23:58'!skipSeparatorsAndPeekNextFrom: aStream	"Same as #skipSeparators, but returns the next character after the separators if such exists."	| state character |	[ 		state := self saveStateOf: aStream.		(character := aStream next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		self restoreStateOf: aStream with: state.		^character ].	^aStream	! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:12'!nextChunkFromStream: input	"Answer the contents of input, up to the next terminator character. Doubled terminators indicate an embedded terminator character."		self skipSeparatorsFrom: input.	^self 		parseLangTagFor: (			self class decodeByteString: (				String new: 1000 streamContents: [ :stream |					[						stream nextPutAll: (input basicUpTo: $!!).						input basicNext == $!! ]							whileTrue: [ 								stream nextPut: $!! ].					input atEnd ifFalse: [ input skip: -1 ] ]))		fromStream: input! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 16:44'!skipSeparatorsAndPeekNextFrom: aStream	"Same as #skipSeparators, but returns the next character after the separators if such exists."	| character |	[ 		((character := aStream basicNext) 			ifNil: [ ^aStream "backwards compatibility, should be nil" ])				isSeparator ] whileTrue.	aStream skip: -1.	^character	! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 3/27/2010 16:19'!skipSeparatorsAndPeekNext	"A special function to make nextChunk fast. Same as #skipSeparators, but returns the next character after the separators if such exists."		^converter skipSeparatorsAndPeekNextFrom: self! !!TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:02'!skipSeparatorsFrom: aStream	| state character |	[ 		state := self saveStateOf: aStream.		(character := aStream next) 			ifNil: [ false ]			ifNotNil: [ character isSeparator ] ] whileTrue.	character ifNotNil: [ 		self restoreStateOf: aStream with: state ]	! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'nice 3/24/2010 23:54'!removeLastCharFromPresentation	presentation ifNotNil: [		presentation position: presentation position - 1.	].	super removeLastCharFromPresentation! !!MultiCompositionScanner methodsFor: 'multilingual scanning' stamp: 'nice 3/24/2010 23:55'!addCharToPresentation: char	presentation nextPut: char.	super addCharToPresentation: char! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:04'!skipSeparatorsFrom: aStream	[ (aStream basicNext ifNil: [ ^self ]) isSeparator ] whileTrue.	aStream skip: -1! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 3/27/2010 00:04'!skipSeparators	converter skipSeparatorsFrom: self! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:09'!parseLangTagFor: aString fromStream: stream	| position |	position := stream position.	"Test for ]lang[ tag"	((self skipSeparatorsAndPeekNextFrom: stream) == $] and: [		(stream basicNext: 6) = ']lang[' ]) ifTrue: [			^stream				decodeString: aString				andRuns: (self nextChunkFromStream: stream) ].	"no tag"	stream position: position.	^aString! !!UTF8TextConverter methodsFor: 'fileIn/Out' stamp: 'ul 3/27/2010 00:11'!nextChunkTextFromStream: input	"Deliver the next chunk as a Text.  Decode the following ]style[ chunk if present.  Position at start of next real chunk."		| chunk position runs |	chunk := self nextChunkFromStream: input.	position := input position.	((self skipSeparatorsAndPeekNextFrom: input) == $] and: [		(input basicNext: 7) = ']style[' ])			ifTrue: [				runs := RunArray scanFrom: (self nextChunkFromStream: input) readStream ]			ifFalse: [				input position: position.				runs := RunArray new: chunk size withAll: #() ].	^Text string: chunk runs: runs! !!Unicode class methodsFor: 'accessing - displaying' stamp: 'nice 3/24/2010 23:49'!scanSelector	"^ #scanMultiCharactersCombiningFrom:to:in:rightX:stopConditions:kern:."	^ #scanMultiCharactersFrom:to:in:rightX:stopConditions:kern:.! !