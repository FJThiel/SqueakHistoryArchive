"Change Set:		8588Nebraska-nice.23Nebraska-nice.23:Cosmetic: move or remove a few temps inside closures"!!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!timeSomeThings"CanvasEncoder timeSomeThings"	| answer array color iter |	iter := 1000000.	array := Array new: 4.	color := Color red.	answer := String streamContents: [ :strm | | bm rect writer pt s |		writer := [ :msg :doer | | ms |			ms := [iter timesRepeat: doer] timeToRun.			strm nextPutAll: msg,((ms * 1000 / iter) roundTo: 0.01) printString,' usec'; cr.		].		s := String new: 4.		bm := Bitmap new: 20.		pt := 100@300.		rect := pt extent: pt.	iter := 1000000.		writer value: 'empty loop ' value: [self].		writer value: 'modulo ' value: [12345678 \\ 256].		writer value: 'bitAnd: ' value: [12345678 bitAnd: 255].		strm cr.	iter := 100000.		writer value: 'putInteger ' value: [s putInteger32: 12345678 at: 1].		writer value: 'bitmap put ' value: [bm at: 1 put: 12345678].		writer value: 'encodeBytesOf: (big) ' value: [bm encodeInt: 12345678 in: bm at: 1].		writer value: 'encodeBytesOf: (small) ' value: [bm encodeInt: 5000 in: bm at: 1].		writer value: 'array at: (in) ' value: [array at: 1].		writer value: 'array at: (out) ' value: [array at: 6 ifAbsent: []].		strm cr.	iter := 10000.		writer value: 'color encode ' value: [color encodeForRemoteCanvas].		writer value: 'pt encode ' value: [pt encodeForRemoteCanvas].		writer value: 'rect encode ' value: [self encodeRectangle: rect].		writer value: 'rect encode2 ' value: [rect encodeForRemoteCanvas].		writer value: 'rect encodeb ' value: [rect encodeForRemoteCanvasB].	].	StringHolder new contents: answer; openLabel: 'send/receive stats'.! !!ChatNotes methodsFor: 'file i/o' stamp: 'nice 12/26/2009 09:35'!storeAIFFOnFile: file	"In a better design, this would be handled by SequentialSound,	but I figure you will need a new primitive anyway, so it can	be implemented at that time."	| sampleCount |	sampleCount := recorder recordedSound sounds inject: 0 into: [ :sum :rsound |		sum + rsound samples monoSampleCount	].	file nextPutAll: 'FORM' asByteArray.	file nextInt32Put: (2 * sampleCount) + 46.	file nextPutAll: 'AIFF' asByteArray.	file nextPutAll: 'COMM' asByteArray.	file nextInt32Put: 18.	file nextNumber: 2 put: 1. "channels"	file nextInt32Put: sampleCount.	file nextNumber: 2 put: 16. "bits/sample"	(AbstractSound new) storeExtendedFloat: (recorder samplingRate) on: file.	file nextPutAll: 'SSND' asByteArray.	file nextInt32Put: (2 * sampleCount) + 8.	file nextInt32Put: 0.	file nextInt32Put: 0.	(recorder recordedSound sounds) do: [:rsound |		1 to: (rsound samples monoSampleCount) do: [:i |			| s |			s := rsound samples at: i.			file nextPut: ((s bitShift: -8) bitAnd: 16rFF).			file nextPut: (s bitAnd: 16rFF)]].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'nice 12/27/2009 03:11'!purgeCacheInner	| totalSize |	cachedObjects ifNil: [^0].	totalSize := 0.	cachedObjects withIndexDo: [ :each :index | | cachedObject thisSize |		cachedObject := each first first.		cachedObject ifNil: [			each second ifNotNil: [				2 to: each size do: [ :j | each at: j put: nil].				self sendCommand: {					String with: CanvasEncoder codeReleaseCache.					self class encodeInteger: index.				}.			].		] ifNotNil: [			thisSize := cachedObject depth * cachedObject width * cachedObject height // 8.			totalSize := totalSize + thisSize.		].	].	^totalSize	"---	newEntry := {		WeakArray with: anObject.		1.		Time millisecondClockValue.		nil.	}.	---"! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!showStats"CanvasEncoder showStats"	| answer |	SentTypesAndSizes ifNil: [^Beeper beep].	answer := WriteStream on: String new.	SentTypesAndSizes keys asArray sort do: [ :each | | bucket |		bucket := SentTypesAndSizes at: each.		answer nextPutAll: each printString,' ',				bucket first printString,'  ',				bucket second asStringWithCommas,' ',				(self nameForCode: each); cr.	].	StringHolder new contents: answer contents; openLabel: 'send/receive stats'.! !!CanvasEncoder class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!explainTestVars"CanvasEncoder explainTestVars"	| answer oneBillion total |	SimpleCounters ifNil: [^ Beeper beep].	total := 0.	oneBillion := 1000 * 1000 * 1000.	answer := String streamContents: [ :strm | | data putter |		data := SimpleCounters copy.		putter := [ :msg :index :nSec | | nReps |			nReps := data at: index.			total := total + (nSec * nReps).			strm nextPutAll: nReps asStringWithCommas,' * ',nSec printString,' ',					(nSec * nReps / oneBillion roundTo: 0.01) printString,' secs for ',msg; cr		].		putter value: 'string socket' value: 1 value: 8000.		putter value: 'rectangles' value: 2 value: 40000.		putter value: 'points' value: 3 value: 18000.		putter value: 'colors' value: 4 value: 8000.	].	StringHolder new		contents: answer;		openLabel: 'put integer times'.! !!EToyCommunicatorMorph methodsFor: '*nebraska-*nebraska-Morphic-Collaborative' stamp: 'nice 12/27/2009 03:10'!addGateKeeperMorphs	| list currentTime choices |	self setProperty: #gateKeeperCounterValue toValue: EToyGateKeeperMorph updateCounter.	choices := #(		(60 'm' 'in the last minute')		(3600 'h' 'in the last hour')		(86400 'd' 'in the last day')	).	currentTime := Time totalSeconds.	list := EToyGateKeeperMorph knownIPAddresses.	list do: [ :each | | age row |		age := each timeBetweenLastAccessAnd: currentTime.		age := choices			detect: [ :x | age <= x first]			ifNone: [{0. '-'. (age // 86400) printString,'days ago'}].		row := self addARow:		(EToyIncomingMessage allTypes collect: [ :type |				self toggleButtonFor: each attribute: type]		),		{			(self inAColumn: {				(StringMorph contents: age second) lock.			}) layoutInset: 2; hResizing: #shrinkWrap; setBalloonText: 'Last attempt was ',age third.			(self inAColumn: {				(StringMorph contents: each ipAddress) lock.			}) layoutInset: 2; hResizing: #shrinkWrap.			(self inAColumn: {				(StringMorph contents: each latestUserName) lock.			}) layoutInset: 2.		}.		row			color: (Color r: 0.6 g: 0.8 b: 1.0);			borderWidth: 1;			borderColor: #raised;			vResizing: #spaceFill;			"on: #mouseUp send: #mouseUp:in: to: self;"			setBalloonText: each fullInfoString	].! !!CanvasEncoder methodsFor: 'drawing' stamp: 'nice 12/27/2009 03:11'!testCache: anObject 	| newEntry firstFree |	cachingEnabled 		ifFalse: 			[cachedObjects := nil.			^nil].	cachedObjects ifNil: 			[cachedObjects := (1 to: 100) collect: 							[:x | 							{ 								WeakArray new: 1.								nil.								nil.								nil}]].	self purgeCache.	firstFree := nil.	cachedObjects withIndexDo: 			[:each :index | | cachedObject | 			cachedObject := each first first.			firstFree ifNil: [cachedObject ifNil: [firstFree := index]].			cachedObject == anObject 				ifTrue: 					[each at: 2 put: (each second) + 1.					^{ 						index.						false.						each}]].	firstFree ifNil: [^nil].	newEntry := { 				WeakArray with: anObject.				1.				Time millisecondClockValue.				nil}.	cachedObjects at: firstFree put: newEntry.	^{ 		firstFree.		true.		newEntry}! !!NebraskaDebug class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!showStats: queueName from: aCollection	| answer prevTime |	prevTime := nil.	answer := String streamContents: [ :s | 		s nextPutAll: (aCollection last first - aCollection first first) asStringWithCommas,' ms';cr;cr.		aCollection withIndexDo: [ :each :index | | xx currTime | 			(queueName == #allStats or: [queueName == each last]) ifTrue: [				currTime := each first.				xx := currTime printString.				prevTime ifNil: [prevTime := currTime].				s nextPutAll: index printString,'.  ',					(xx allButLast: 3),'.',(xx last: 3),' ',(currTime - prevTime) printString,' '.				s nextPutAll: each allButFirst printString; cr.				prevTime := currTime.			].		]	].	StringHolder new 		contents: answer;		openLabel: queueName! !!AudioChatGUI methodsFor: 'sending' stamp: 'nice 12/27/2009 03:10'!sendOneOfMany: aSampledSound	| null message aCompressedSound t ratio resultBuf maxVal |	self samplingRateForTransmission = aSampledSound originalSamplingRate ifTrue: [		aCompressedSound := mycodec compressSound: aSampledSound.	] ifFalse: [		t := [ | oldSamples val newCount fromIndex |			ratio := aSampledSound originalSamplingRate // self samplingRateForTransmission.			oldSamples := aSampledSound samples.			newCount := oldSamples monoSampleCount // ratio.			resultBuf := SoundBuffer newMonoSampleCount: newCount.			fromIndex := 1.			maxVal := 0.			1 to: newCount do: [ :i |				maxVal := maxVal max: (val := oldSamples at: fromIndex).				resultBuf at: i put: val.				fromIndex := fromIndex + ratio.			].		] timeToRun.		NebraskaDebug at: #soundReductionTime add: {t. maxVal}.		maxVal < 400 ifTrue: [			NebraskaDebug at: #soundReductionTime add: {'---dropped---'}.			^self		].		"awfully quiet"		aCompressedSound := mycodec compressSound: (			SampledSound new 				setSamples: resultBuf 				samplingRate: aSampledSound originalSamplingRate // ratio		).	].	null := String with: 0 asCharacter.	message := {		EToyIncomingMessage typeAudioChatContinuous,null. 		Preferences defaultAuthorName,null.		aCompressedSound samplingRate asInteger printString,null.		aCompressedSound channels first.	}.	queueForMultipleSends ifNil: [		queueForMultipleSends := EToyPeerToPeer new 			sendSomeData: message			to: mytargetip			for: self			multiple: true.	] ifNotNil: [		queueForMultipleSends nextPut: message	].! !!EToySenderMorph methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:10'!startNebraskaClient		[		[ | newMorph |			newMorph := NetworkTerminalMorph connectTo: self ipAddress.			WorldState addDeferredUIMessage: [newMorph openInStyle: #scaled] fixTemps.		]			on: Error			do: [ :ex |				WorldState addDeferredUIMessage: [					self inform: 'No connection to: '. self ipAddress,' (',ex printString,')'				] fixTemps			].	] fork! !!EToyChatMorph methodsFor: 'as yet unclassified' stamp: 'nice 12/26/2009 10:03'!improveText: someText forMorph: aMorph	| betterText conversions fontForAll |	fontForAll := aMorph eToyGetMainFont.	betterText := someText veryDeepCopy.	conversions := OrderedCollection new.	betterText runs withStartStopAndValueDo: [:start :stop :attributes |		attributes do: [:att |			(att isMemberOf: TextFontChange) ifTrue: [				conversions add: {att. start. stop}			]		]	].	conversions do: [ :old |		| newAttr |		betterText removeAttribute: old first from: old second to: old third.		newAttr := TextFontReference toFont: (fontForAll fontAt: old first fontNumber).		newAttr fontNumber: old first fontNumber.		betterText addAttribute: newAttr from: old second to: old third.	].	^betterText! !