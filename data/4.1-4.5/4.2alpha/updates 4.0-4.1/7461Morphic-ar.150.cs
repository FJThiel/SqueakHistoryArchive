"Change Set:		7461Morphic-ar.150Morphic-ar.150:UIManagerization. Replaces all the trivial references to PopUpMenu, SelectionMenu, CustomMenu, and FillInTheBlank.Morphic-ar.136:Proper round rect drawing. Instead of just corner rounding we can now draw round rects just like any other rectangle with an optional corner radius, for example:	Display getCanvas frameAndFillRoundRect: (100@100 extent: 200@50) radius: 10 fillStyle: Color white borderWidth: 2 borderColor: Color black.Morphic-mha.137:some World menu convenience...* refactored World menu construction a bit* there is now a method makeConvenient that inserts some items at the top of the World menu* for now, there's four popular entries that make common tools available with one less click ;-)Morphic-jmv.138:Part of StrikeFont enhancements to support glyphs up to 32bpp, with anti aliasing.Morphic-jmv.139:Fixes Display alpha channel for AA StrikeFonts.Morphic-jmv.140:Moves the double pass for AA StrikeFonts from GrafPort up to BitBlt.Morphic-ar.141:Push down the additional state from BitBlt to GrafPort since BitBlt cannot deal with the added state. Also rename the state vars internally from 'secondPassRule / secondPassColorMap' to 'extraPassRule / extraPassColorMap' to avoid an exercise in Monticello madness.Morphic-ar.142:Choosing Help>>Preferences from the World menu should open a PreferencesBrowser not the ancient PreferencesPanel.Morphic-ar.143:Provide a set of interfaces to MenuMorph which allow us to vector UIManager requests directly to it instead of having to indirect through PopUpMenu. A necessary step to decouple MVC and Morphic. Also adds NewParagraph>>replaceFrom:to:with: for easier compatibility with Cuis' editors.Morphic-ar.144:With our new great fonts we also need a decent cursor to go along with it. Use a classic blinking text caret instead of a green invisible something.Morphic-ar.145:Use the correct default line height for empty text.Morphic-ar.146:Fix typo in MenuMorph>>confirm:orCancel:.Morphic-jmv.147:Moves dual pass for AA StrikeFonts back to BitBlt, without needing any new instvar (that would break WarpBlt). Enhanced a bit the spacing between glyphs.Morphic-jmv.148:Another round of small fixes for AA StrikeFonts.Morphic-ar.149:Integrate Cuis text editors. The new classes are Editor and TextEditor (in Morphic-Text Support). TextMorph now honors the preference #userNewEditors to determine whether to use the (old) TextMorphEditor or the (new) TextEditor (shameless plug: pragma preferences rock; check out TextMorph class>>useNewEditors). There is still a ways to go before this will work but it gives us the starting point to knock down the remaining issues with the editors (mostly keyboard shortcut issues)."!Object subclass: #NewParagraph	instanceVariableNames: 'text textStyle firstCharacterIndex container lines positionWhenComposed offsetToEnd maxRightX selectionStart selectionStop wantsColumnBreaks focused caretRect showCaret'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!RectangleMorph subclass: #TextMorph	instanceVariableNames: 'textStyle text wrapFlag paragraph editor container predecessor successor backgroundColor margins editHistory'	classVariableNames: 'CaretForm DefaultEditorClass'	poolDictionaries: ''	category: 'Morphic-Basic'!Object subclass: #Editor	instanceVariableNames: 'sensor morph selectionShowing'	classVariableNames: ''	poolDictionaries: ''	category: 'Morphic-Text Support'!Editor subclass: #TextEditor	instanceVariableNames: 'model paragraph pointBlock markBlock beginTypeInBlock emphasisHere otherInterval lastParenLocation oldInterval'	classVariableNames: 'UndoInterval Undone UndoSelection UndoMessage ChangeText FindText UndoParagraph'	poolDictionaries: ''	category: 'Morphic-Text Support'!!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	sensor keyboard.		"flush character"	self inspectIt.	^ true! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!inspectIt	"1/13/96 sw: minor fixup"	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [morph flash]			ifFalse: [result inspect]! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:51'!markBlock	^ markBlock! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!methodStringsContainingit	"Open a browser on methods which contain the current selection as part of a string constant."	self lineSelectAndEmptyCheck: [^ self].	Smalltalk browseMethodsWithString: self selection string! !!TextEditor methodsFor: 'events' stamp: 'jmv 11/5/2008 14:15'!mouseMove: evt 	"Change the selection in response to moue-down drag"	self pointBlock: (paragraph characterBlockAtPoint: (evt cursorPoint)).	self storeSelectionInParagraph! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!copySelection	"Copy the current selection and store it in the paste buffer, unless a caret.  Undoer & Redoer: undoCutCopy"	self lineSelectAndEmptyCheck: [^ self].	"Simulate 'substitute: self selection' without locking the controller"	UndoSelection _ self selection.	self undoer: #undoCutCopy: with: self clipboardText.	UndoInterval _ self selectionInterval.	self clipboardTextPut: UndoSelection! !!Editor methodsFor: 'menu messages' stamp: 'jmv 11/5/2008 10:16'!clipboardText	^ Clipboard clipboardText! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'ar 12/15/2008 22:51'!keyboardFocusChange: aBoolean 	"rr 3/21/2004 22:55 : removed the #ifFalse: branch, 	which was responsible of the deselection of text when the 	paragraph lost focus. This way selection works in a more standard 	way, and this permits the menu keyboard control to be really effective"	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."		self hasFocus ifFalse: [self editor	"Forces install"].		self startBlinking.	] ifFalse:[		self stopBlinking.	].	self changed.! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!yellowButtonActivity	"This normally opens a popup menu. Determine the selected	item and, if one is selected, then send the corresponding message	to either the model or the receiver."	^ self pluggableYellowButtonActivity: sensor leftShiftDown! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 11/4/2008 11:51'!doneTyping	beginTypeInBlock _ nil! !!Editor methodsFor: 'current selection' stamp: 'jmv 11/4/2008 13:20'!deselect	"If the text selection is visible on the screen, reverse its highlight."	selectionShowing ifTrue: [self reverseSelection]! !!Morph methodsFor: 'debug and other' stamp: 'ar 8/6/2009 20:41'!addMouseUpAction	| codeToRun oldCode |	oldCode := self				valueOfProperty: #mouseUpCodeToRun				ifAbsent: [''].	codeToRun := UIManager default request: 'MouseUp expression:' translated initialAnswer: oldCode.	self addMouseUpActionWith: codeToRun! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ morph flash].	aSymbol first isUppercase		ifTrue:			[anEntry _ (Smalltalk				at: aSymbol				ifAbsent:					[ Smalltalk browseAllImplementorsOf: aSymbol.					^ nil]).			anEntry isNil ifTrue: [^ morph flash].			(anEntry isKindOf: Class)				ifFalse:	[anEntry _ anEntry class].			brow _ Preferences browseToolClass new.			brow setClass: anEntry selector: nil.			brow class				openBrowserView: (brow openEditString: nil)				label: 'System Browser']		ifFalse:			[Smalltalk browseAllImplementorsOf: aSymbol]! !!Editor methodsFor: 'typing support' stamp: 'jmv 11/4/2008 23:06'!closeTypeIn: characterStream	"Call instead of closeTypeIn when you want typeahead to be inserted before the	 control character is executed, e.g., from Ctrl-V."	self insertTypeAhead: characterStream.	self closeTypeIn! !!TextEditor methodsFor: 'menu commands' stamp: 'jmv 11/10/2008 11:34'!offerMenuFromEsc: characterStream 	"The escape key was hit while the receiver has the keyboard focus; take action"	^ ActiveEvent shiftPressed		ifFalse:			[self raiseContextMenu: characterStream]! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainChar: string	"Does string start with a special character?"	| char |	char _ string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = ${ or: [char = $}]) ifTrue: [^ '"A sequence of expressions separated by periods, when enclosed in curly braces, are evaluated to yield the elements of a new Array"'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	^nil! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!align: characterStream 	"Triggered by Cmd-u;  cycle through alignment alternatives.  8/11/96 sw"	sensor keyboard.		"flush character"	self align.	^ true! !!Editor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 14:02'!unselect	self markIndex: self pointIndex! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 11:51'!cursorEnd: characterStream 	"Private - Move cursor end of current line."	| string |	self closeTypeIn: characterStream.	string _ paragraph text string.	self		moveCursor:			[:position | Preferences wordStyleCursorMovement				ifTrue:[| targetLine |					targetLine _ paragraph lines at:(paragraph lineIndexOfCharacterIndex: position).					targetLine = paragraph lastLine						ifTrue:[targetLine last + 1]						ifFalse:[targetLine last]]				ifFalse:[					string						indexOf: Character cr						startingAt: position						ifAbsent:[string size + 1]]]		forward: true		specialBlock:[:dummy | string size + 1].	^true! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 7/21/2009 12:34'!initializeYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"TextEditor initialize"	yellowButtonMenu _ SelectionMenu fromArray: {		{'find...(f)' translated.				#find}.		{'find again (g)' translated.			#findAgain}.		{'set search string (h)' translated.	#setSearchString}.		#-.		{'do again (j)' translated.			#again}.		{'undo (z)' translated.				#undo}.		#-.		{'copy (c)' translated.				#copySelection}.		{'cut (x)' translated.				#cut}.		{'paste (v)' translated.				#paste}.		{'paste...' translated.				#pasteRecent}.		#-.		{'set font... (k)' translated.			#offerFontMenu}.		{'set style... (K)' translated.		#changeStyle}.		{'set alignment...' translated.		#chooseAlignment}.		"		#-.		{'more...' translated.				#shiftedTextPaneMenuRequest}.		"	}! !!TextEditor methodsFor: 'undoers' stamp: 'jmv 11/4/2008 11:51'!undoAndReselect: undoHighlight redoAndReselect: redoHighlight	"Undo typing, cancel, paste, and other operations that are like replaces	 but the selection is not the whole restored text after undo, redo, or both.	 undoHighlight is selected after this phase and redoHighlight after the next phase.	Redoer: itself."	self replace: self selectionInterval with: UndoSelection and:		[self selectInterval: undoHighlight].	self undoMessage: (UndoMessage argument: redoHighlight) forRedo: self isUndoing! !!TextEditor methodsFor: 'events' stamp: 'jmv 11/4/2008 11:51'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(self hasCaret 		and: [oldInterval = self selectionInterval])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	self storeSelectionInParagraph! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!Morph methodsFor: 'meta-actions' stamp: 'ar 8/6/2009 20:15'!invokeMetaMenuAt: aPoint event: evt	| morphs target |	morphs := self morphsAt: aPoint.	(morphs includes: self) ifFalse:[morphs := morphs copyWith: self].	morphs size = 1 ifTrue:[morphs first invokeMetaMenu: evt].	target := UIManager default		chooseFrom: (morphs collect: [:m | m knownName ifNil:[m class name asString]])		values: morphs.	target ifNil:[^self].	target invokeMetaMenu: evt! !!Morph methodsFor: 'meta-actions' stamp: 'ar 8/6/2009 20:42'!subclassMorph	"Create a new subclass of this morph's class and make this morph be an instance of it."	| oldClass newClassName newClass newMorph |	oldClass := self class.	newClassName := UIManager default		request: 'Please give this new class a name'		initialAnswer: oldClass name.	newClassName = '' ifTrue: [^ self].	(Smalltalk includesKey: newClassName)		ifTrue: [^ self inform: 'Sorry, there is already a class of that name'].	newClass := oldClass subclass: newClassName asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: oldClass category asString.	newMorph := self as: newClass.	self become: newMorph.! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:50'!pointBlock: aCharacterBlock	pointBlock _ aCharacterBlock.! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 7/29/2009 22:47'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock		ifNil: [self openTypeIn. UndoSelection _ self nullText. self stopIndex]		ifNotNil: [self startOfTyping].	self markIndex: startIndex.	startIndex < saveLimit ifTrue: [		newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	self unselect! !!Editor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 23:43'!hasSelection	^self hasCaret not! !!Editor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 14:33'!userHasEdited	"Note that my text is free of user edits."	morph hasUnacceptedEdits: true! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 8/6/2009 18:30'!grabFloodFromScreen: evt	"Allow the user to plant a flood seed on the Display, and create a new drawing morph from the resulting region. Attach the result to the hand."	| screenForm exterior p1 box |	Cursor crossHair showWhile: [p1 := Sensor waitButton].	box := Display floodFill: Color transparent at: p1.	exterior := ((Display copy: box) makeBWForm: Color transparent) reverse.	self world invalidRect: box; displayWorldSafely.	(box area > (Display boundingBox area // 2))		ifTrue: [^ UIManager default notify: 'Sorry, the region was too big'].	(exterior deepCopy reverse anyShapeFill reverse)  "save interior bits"		displayOn: exterior at: 0@0 rule: Form and.	screenForm := Form fromDisplay: box.	screenForm eraseShape: exterior.	screenForm isAllWhite ifFalse:		[evt hand attachMorph: (self drawingClass withForm: screenForm)]! !!NewParagraph methodsFor: 'editing' stamp: 'jmv 7/29/2009 22:19'!replaceFrom: start to: stop with: aText	"Edit the text, and then recompose the lines." 	text replaceFrom: start to: stop with: aText.	self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop-start+1)! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!displayIfFalse: characterStream 	"Replace the current text selection with the text 'ifFalse:'--initiated by 	ctrl-f."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifFalse:'.	^false! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 7/29/2009 18:37'!setEmphasisHere	emphasisHere _ (paragraph text attributesAt: (self pointIndex - 1 max: 1))					select: [:att | att mayBeExtended]! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!align	"Align text according to the next greater alignment value,	cycling among leftFlush, rightFlush, center, and justified."	self changeAlignment.	self recomputeInterval! !!TextEditor methodsFor: 'mvc compatibility' stamp: 'jmv 7/29/2009 22:49'!zapSelectionWith: aText	| start stop |	self deselect.	start _ self startIndex.	stop _ self stopIndex.	(aText isEmpty and: [stop > start]) ifTrue: [		"If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start) select: [:att | att mayBeExtended]].	(start = stop and: [ aText size = 0 ]) ifFalse: [		paragraph replaceFrom: start to: stop - 1 with: aText.		self markIndex: start; pointIndex: start + aText size.		UndoInterval _ otherInterval _ self selectionInterval].	self userHasEdited  " -- note text now dirty"! !!MenuMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:41'!addItem	| string sel |	string := UIManager default request: 'Label for new item?'.	string isEmpty ifTrue: [^ self].	sel := UIManager default request: 'Selector?'.	sel isEmpty ifFalse: [sel := sel asSymbol].	self add: string action: sel.! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 11:51'!cursorHome: characterStream 	"Private - Move cursor from position in current line to beginning of	current line. If control key is pressed put cursor at beginning of text"	| string |	string _ paragraph text string.	self		moveCursor: [ :position | Preferences wordStyleCursorMovement				ifTrue:[					(paragraph lines at:(paragraph lineIndexOfCharacterIndex: position)) first]				ifFalse:[					(string						lastIndexOf: Character cr						startingAt: position - 1						ifAbsent:[0]) + 1]]		forward: false		specialBlock: [:dummy | 1].	^true! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainTemp: string 	"Is string the name of a temporary variable (or block argument variable)?"	| selectedClass tempNames i reply methodNode method msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	selectedClass _ model selectedClassOrMetaClass.	tempNames _ selectedClass parserClass new 			parseArgsAndTemps: model selectedMessage notifying: nil.	method _ selectedClass compiledMethodAt: msg.	(i _ tempNames findFirst: [:each | each = string]) = 0 ifTrue: [		(method numTemps > tempNames size)			ifTrue: 				["It must be an undeclared block argument temporary"				methodNode _ selectedClass compilerClass new							parse: model selectedMessage							in: selectedClass							notifying: nil.				tempNames _ methodNode tempNames]			ifFalse: [^nil]].	(i _ tempNames findFirst: [:each | each = string]) > 0 ifTrue: [i > method numArgs			ifTrue: [reply _ '"is a temporary variable in this method"']			ifFalse: [reply _ '"is an argument to this method"']].	^reply! !!Editor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 23:36'!selectWord	"Select delimited text or word--the result of double-clicking."	| openDelimiter closeDelimiter direction match level leftDelimiters rightDelimiters	string here hereChar start stop |	string _ self string.	here _ self pointIndex.	(here between: 2 and: string size)		ifFalse: ["if at beginning or end, select entire string"			^self selectFrom: 1 to: string size].	leftDelimiters _ '([{<''"'.	rightDelimiters _ ')]}>''"'.	openDelimiter _ string at: here - 1.	match _ leftDelimiters indexOf: openDelimiter.	match > 0		ifTrue: 			["delimiter is on left -- match to the right"			start _ here.			direction _ 1.			here _ here - 1.			closeDelimiter _ rightDelimiters at: match]		ifFalse: 			[openDelimiter _ string at: here.			match _ rightDelimiters indexOf: openDelimiter.			match > 0				ifTrue: 					["delimiter is on right -- match to the left"					stop _ here - 1.					direction _ -1.					closeDelimiter _ leftDelimiters at: match]				ifFalse: ["no delimiters -- select a token"					direction _ -1]].	level _ 1.	[level > 0 and: [direction > 0			ifTrue: [here < string size]			ifFalse: [here > 1]]]		whileTrue: 			[hereChar _ string at: (here _ here + direction).			match = 0				ifTrue: ["token scan goes left, then right"					hereChar tokenish						ifTrue: [here = 1								ifTrue: 									[start _ 1.									"go right if hit string start"									direction _ 1]]						ifFalse: [direction < 0								ifTrue: 									[start _ here + 1.									"go right if hit non-token"									direction _ 1]								ifFalse: [level _ 0]]]				ifFalse: ["bracket match just counts nesting level"					hereChar = closeDelimiter						ifTrue: [level _ level - 1"leaving nest"]						ifFalse: [hereChar = openDelimiter 									ifTrue: [level _ level + 1"entering deeper nest"]]]].	level > 0 ifTrue: ["in case ran off string end"	here _ here + direction].	direction > 0		ifTrue: [self selectFrom: start to: here - 1]		ifFalse: [self selectFrom: here + 1 to: stop]! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!isUndoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #undoing! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 7/22/2009 21:33'!frameRoundRect: aRectangle radius: radius borderWidth: borderWidth	| nextY outer nextOuterX ovalDiameter rectExtent rectOffset rectX rectY rectWidth rectHeight ovalRadius ovalRect innerRadius innerDiameter innerRect inner nextInnerX wp |	aRectangle area <= 0 ifTrue: [^ self].	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or:[ovalDiameter y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	"force diameter to be even - this simplifies lots of stuff"	ovalRadius := (ovalDiameter x // 2) @ (ovalDiameter y // 2).	(ovalRadius x <= 0 or:[ovalRadius y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	wp := borderWidth asPoint.	ovalDiameter := ovalRadius * 2.	innerRadius := ovalRadius - borderWidth max: 0@0.	innerDiameter := innerRadius * 2.	rectExtent := aRectangle extent - ovalDiameter.	rectWidth := rectExtent x.	rectHeight := rectExtent y.	rectOffset := aRectangle origin + ovalRadius.	rectX := rectOffset x.	rectY := rectOffset y.	ovalRect := 0@0 extent: ovalDiameter.	innerRect := 0@0 extent: innerDiameter.	height := 1.	outer := EllipseMidpointTracer new on: ovalRect.	inner := EllipseMidpointTracer new on: innerRect.	nextY := ovalRadius y.	1 to: (wp y min: nextY) do:[:i|		nextOuterX := outer stepInY.		width := nextOuterX * 2 + rectWidth.		destX := rectX - nextOuterX.		destY := rectY - nextY.		self copyBits.		destY := rectY + nextY + rectHeight - 1.		self copyBits.		nextY := nextY - 1.	].	[nextY > 0] whileTrue:[		nextOuterX := outer stepInY.		nextInnerX := inner stepInY.		destX := rectX - nextOuterX.		destY := rectY - nextY.		width := nextOuterX - nextInnerX.		self copyBits.		destX := rectX + nextInnerX + rectWidth.		self copyBits.		destX := rectX - nextOuterX.		destY := rectY + nextY + rectHeight-1.		self copyBits.		destX := rectX + nextInnerX + rectWidth.		self copyBits.		nextY := nextY - 1.	].	destX := aRectangle left.	destY := rectOffset y.	height := rectHeight.	width := wp x.	self copyBits.	destX := aRectangle right - width.	self copyBits.	innerRadius y = 0 ifTrue:[		destX := aRectangle left + wp x.		destY := rectY.		width := rectWidth.		height := wp y - ovalRadius y.		self copyBits.		destY := aRectangle bottom - wp y.		self copyBits.	].! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!stopIndex	^ self stopBlock stringIndex! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainAnySel: symbol 	"Is this any message selector?"	| list reply |	list _ Smalltalk allClassesImplementing: symbol.	list size = 0 ifTrue: [^nil].	list size < 12		ifTrue: [reply _ ' is a message selector which is defined in these classes ' , list printString]		ifFalse: [reply _ ' is a message selector which is defined in many classes'].	^'"' , symbol , reply , '."' , '\' withCRs, 'Smalltalk browseAllImplementorsOf: #' , symbol! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!pasteInitials: characterStream 	"Replace the current text selection by an authorship name/date stamp; invoked by cmd-shift-v, easy way to put an authorship stamp in the comments of an editor.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self replace: self selectionInterval with: (Text fromString: Utilities changeStamp) and: [self selectAt: self stopIndex].	^ true! !!TextMorphEditor methodsFor: 'attributes' stamp: 'ar 8/6/2009 19:14'!changeStyle	"Let user change styles for the current text pane."	| aList reply style theStyle menuList |	self flag: #arNote. "Move this up once we get rid of MVC"	aList := StrikeFont actualFamilyNames.	theStyle := paragraph textStyle.	menuList := aList collect:[:styleName|		"Hack!! use defaultFont for comparison - we have no name that we could use for compare and the style changes with alignment so they're no longer equal."		(TextConstants at: styleName) defaultFont == theStyle defaultFont			ifTrue:['<on>', styleName]			ifFalse:['<off>',styleName]].	theStyle = TextStyle default		ifTrue:[menuList addFirst: '<on>DefaultTextStyle']		ifFalse:[menuList addFirst: '<off>DefaultTextStyle'].	aList addFirst: 'DefaultTextStyle'.	reply := UIManager default chooseFrom: menuList values: aList lines: #(1).	reply ifNotNil:		[(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 7/21/2009 10:37'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo."  	"TextEditor initialize"	UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeYellowButtonMenu.	self initializeShiftedYellowButtonMenu! !!Editor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 13:06'!morph	^ morph! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!methodNamesContainingIt: characterStream 	"Browse methods whose selectors containing the selection in their names"	sensor keyboard.		"flush character"	self methodNamesContainingIt.	^ true! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!exchange	"See comment in exchangeWith:"	self exchangeWith: otherInterval! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!indent: characterStream	"Add a tab at the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-R.  2/29/96 sw"	^ self inOutdent: characterStream delta: 1! !!TextMorph class methodsFor: 'class initialization' stamp: 'ar 8/6/2009 16:03'!defaultEditorClass: aTextEditorClass	"Sets the default editor class for TextMorph"	"		TextMorph defaultEditorClass: TextMorphEditor.		TextMorph defaultEditorClass: TextEditor.	"	DefaultEditorClass := aTextEditorClass! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!markIndex	^ self markBlock stringIndex! !!TextEditor class methodsFor: 'accessing' stamp: 'jmv 7/21/2009 10:07'!cmdActions	^cmdActions! !!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 7/21/2009 10:34'!yellowButtonMenu	^ yellowButtonMenu! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 11/4/2008 11:51'!stateArray	^ {ChangeText.		FindText.		UndoInterval.		UndoMessage.		UndoParagraph.		UndoSelection.		Undone.		self selectionInterval.		self startOfTyping.		emphasisHere}! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!save: characterStream	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self accept.	^ true! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!methodNamesContainingIt	"Open a browser on methods names containing the selected string"	self lineSelectAndEmptyCheck: [^ self].	Cursor wait showWhile:		[Smalltalk browseMethodsWhoseNamesContain: self selection string withBlanksTrimmed].	Cursor normal show! !!TheWorldMenu methodsFor: 'commands' stamp: 'ar 8/6/2009 20:46'!saveWorldInFile	"Save the world's submorphs, model, and stepList in a file.  "	| fileName fileStream aClass |	fileName := UIManager default request: 'File name for this morph?'.	fileName isEmpty ifTrue: [^ self].  "abort"	"Save only model, stepList, submorphs in this world"	myWorld submorphsDo: [:m |		m allMorphsDo: [:subM | subM prepareToBeSaved]].	"Amen"	fileStream := FileStream newFileNamed: fileName, '.morph'.	aClass := myWorld model ifNil: [nil] ifNotNil: [myWorld model class].	fileStream fileOutClass: aClass andObject: myWorld.! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainScan: string 	"Remove beginning and trailing space, tab, cr.	 1/15/96 sw: copied intact from BrowserCodeController"	| c beg end |	beg _ 1.	end _ string size.		[beg = end ifTrue: [^string copyFrom: 1 to: 1].	"if all blank, tell about the first"	c _ string at: beg.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [beg _ beg + 1].		[c _ string at: end.	c = Character space or: [c = Character tab or: [c = Character cr]]]		whileTrue: [end _ end - 1].	^string copyFrom: beg to: end	"Return purely visible characters"! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:50'!pointBlock	^ pointBlock! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!accept	"Save the current text of the text being edited as the current acceptable version for purposes of canceling.  Allow my morph to take appropriate action"	morph acceptContents! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 4/16/2009 21:22'!prettyPrint: decorated	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageName ifNil: [^ morph flash].	selectedClass _ model selectedClassOrMetaClass.	newText _ selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!TextEditor methodsFor: 'model access' stamp: 'jmv 11/4/2008 11:51'!model: aModel 	"Controller|model: and Controller|view: are sent by View|controller: in 	order to coordinate the links between the model, view, and controller. In 	ordinary usage, the receiver is created and passed as the parameter to 	View|controller: so that the receiver's model and view links can be set 	up by the view."	model _ aModel! !!NewParagraph methodsFor: 'display' stamp: 'ar 12/15/2008 22:54'!displaySelectionInLine: line on: aCanvas 	| leftX rightX w caretColor |	selectionStart ifNil: [^self].	"No selection"	aCanvas isShadowDrawing ifTrue: [ ^self ].	"don't draw selection with shadow"	selectionStart = selectionStop 		ifTrue: 			["Only show caret on line where clicked"			selectionStart textLine ~= line ifTrue: [^self]]		ifFalse: 			["Test entire selection before or after here"			(selectionStop stringIndex < line first 				or: [selectionStart stringIndex > (line last + 1)]) ifTrue: [^self].	"No selection on this line"			(selectionStop stringIndex = line first 				and: [selectionStop textLine ~= line]) ifTrue: [^self].	"Selection ends on line above"			(selectionStart stringIndex = (line last + 1) 				and: [selectionStop textLine ~= line]) ifTrue: [^self]].	"Selection begins on line below"	leftX := (selectionStart stringIndex < line first 				ifTrue: [line ]				ifFalse: [selectionStart ])left.	rightX := (selectionStop stringIndex > (line last + 1) or: 					[selectionStop stringIndex = (line last + 1) 						and: [selectionStop textLine ~= line]]) 				ifTrue: [line right]				ifFalse: [selectionStop left].	selectionStart = selectionStop 		ifTrue: 			[rightX := rightX + 1.			w := self caretWidth.			caretRect := (leftX-w) @ line top corner: (rightX+w)@ line bottom.			self showCaret ifFalse:[^self].			caretColor := self insertionPointColor.			1 to: w				do: 					[:i | 					"Draw caret triangles at top and bottom"					aCanvas fillRectangle: ((leftX - w + i - 1) @ (line top + i - 1) 								extent: ((w - i) * 2 + 3) @ 1)						color: caretColor.					aCanvas fillRectangle: ((leftX - w + i - 1) @ (line bottom - i) 								extent: ((w - i) * 2 + 3) @ 1)						color: caretColor].			aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom)				color: caretColor]		ifFalse: 			[caretRect := nil.			aCanvas fillRectangle: (leftX @ line top corner: rightX @ line bottom)				color: self selectionColor]! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr _ model doItReceiver.				ctxt _ model doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ [		rcvr class evaluatorClass new 			evaluate: self selectionAsStream			in: ctxt			to: rcvr			notifying: self			ifFail: [FakeClassPool adopt: nil. ^ #failedDoit]			logged: true.	] 		on: OutOfScopeNotification 		do: [ :ex | ex resume: true].	FakeClassPool adopt: nil.	^ result! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!outdent: characterStream	"Remove a tab from the front of every line occupied by the selection. Flushes typeahead.  Invoked from keyboard via cmd-shift-L.  2/29/96 sw"	^ self inOutdent: characterStream delta: -1! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!exchange: characterStream	"Exchange the current and prior selections.  Keeps typeahead."	sensor keyboard.	 "Flush character"	self closeTypeIn: characterStream.	self exchange.	^true! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 23:21'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	characterStream isEmpty		ifTrue:			[startIndex _ self markIndex +				(self hasCaret ifTrue: [0] ifFalse: [1]).			[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex _ 1 max: startIndex - 1.			].			self backTo: startIndex]		ifFalse:			[sensor keyboard.			characterStream skip: -1].	^false! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 8/6/2009 20:43'!saveAsWorld	| worldName s |	worldName := UIManager default		request: 'Please give this world a name'		initialAnswer: 'test'.	((self class class includesSelector: worldName asSymbol) and:		[(UIManager default confirm: 'OK to overwrite ' , worldName , '?') not])		ifTrue: [^ self].	s := WriteStream on: (String new: 1000).	s	nextPutAll: worldName; cr; tab;		nextPutAll: '"' , self class name , ' ' , worldName, ' open"'; cr; cr; tab;		nextPutAll: '^ '.	self printConstructorOn: s indent: 0.	s cr.	self class class		compile: s contents		classified: 'examples'		notifying: nil.! !!Editor methodsFor: 'private' stamp: 'jmv 11/4/2008 23:03'!moveCursor: directionBlock forward: forward specialBlock: specialBlock	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| shift indices newPosition |	shift _ sensor leftShiftDown.	indices _ self setIndices: shift forward: forward.	newPosition _ directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition _ specialBlock value: newPosition].	sensor keyboard.	shift		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/5/2008 10:08'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	self closeTypeIn: characterStream.	self		moveCursor: [:position | self				sameColumn: position				newLine:[:line | line - 1]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!TextEditor methodsFor: 'binding' stamp: 'jmv 11/4/2008 11:51'!bindingOf: aString	^model bindingOf: aString! !!Editor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 23:42'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	self hasSelection ifFalse: [morph flash.  ^ returnBlock value]! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setArguments	| s newArgs newArgsArray |	s := WriteStream on: ''.	arguments do: [:arg | arg printOn: s. s nextPutAll: '. '].	newArgs := UIManager default		request:'Please type the arguments to be sent to the targetwhen this button is pressed separated by periods' translated		initialAnswer: s contents.	newArgs isEmpty ifFalse: [		newArgsArray := Compiler evaluate: '{', newArgs, '}' for: self logged: false.		self arguments: newArgsArray].! !!TextMorphEditor methodsFor: 'attributes' stamp: 'ar 8/6/2009 19:14'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply curFont menuList |true ifTrue:[^self changeTextFont].	self flag: #arNote. "Move this up once we get rid of MVC"	curFont := (paragraph text fontAt: self startIndex withStyle: paragraph textStyle) fontNameWithPointSize.	aList := paragraph textStyle fontNamesWithPointSizes.	menuList := aList collect:[:fntName|		fntName = curFont ifTrue:['<on>',fntName] ifFalse:['<off>',fntName]].	reply := UIManager default chooseFrom: menuList values: aList.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!MenuMorph methodsFor: 'menu' stamp: 'ar 8/4/2009 22:20'!addTitle	| string |	string := UIManager default request: 'Title for this menu?'.	string isEmpty ifTrue: [^ self].	self addTitle: string.! !!TextEditor methodsFor: 'private' stamp: 'jmv 12/8/2008 16:45'!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle _ Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines _ paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  _ paragraph lineIndexOfCharacterIndex: start.			currentLine _ lines at: currentLineNumber]		ifFalse: [			lines _ self lines.			numberOfLines := lines size.			currentLine _ lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber _ currentLine second].	column _ start - currentLine first.	targetLineNumber _ ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine _ (lines at: targetLineNumber) first.	targetEOL _ (lines at: targetLineNumber) last + (targetLineNumber = numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber = currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!MenuMorph class methodsFor: 'utilities' stamp: 'ar 8/4/2009 22:52'!inform: queryString	"MenuMorph inform: 'I like Squeak'"	| menu |	(ProvideAnswerNotification signal: queryString) 		ifNotNilDo:[:answer | ^ self].	menu := self new.	menu addTitle: queryString icon: MenuIcons confirmIcon.	menu add: 'OK' target: self selector: #yourself.	MenuIcons decorateMenu: menu.	menu invokeAt: ActiveHand position in: ActiveWorld allowKeyboard: true.! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!exploreIt	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [morph flash]			ifFalse: [result explore]! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!browseClassFromIt	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self lineSelectAndEmptyCheck: [^ self].	aClass _ Utilities classFromPattern: (self selection string copyWithout: Character cr) withCaption: 'choose a class to browse...'.	aClass ifNil: [^ morph flash].	Utilities spawnHierarchyForClass: aClass selector: nil! !!TextEditor methodsFor: 'undoers' stamp: 'jmv 11/4/2008 11:51'!undoAgain: indices andReselect: home typedKey: wasTypedKey	"The last command was again.  Undo it. Redoer: itself."	| findSize substText index subject |	(self isRedoing & wasTypedKey) ifTrue: "redelete search key"		[self selectInterval: home.		self zapSelectionWith: self nullText].	findSize _ (self isRedoing ifTrue: [FindText] ifFalse: [ChangeText]) size.	substText _ self isUndoing ifTrue: [FindText] ifFalse: [ChangeText].	(self isUndoing ifTrue: [indices size to: 1 by: -1] ifFalse: [1 to: indices size]) do:		[:i |		index _ indices at: i.		(subject _ index to: index + findSize - 1) = self selectionInterval ifFalse:			[self selectInterval: subject].		FindText == ChangeText ifFalse: [self zapSelectionWith: substText]].	self isUndoing		ifTrue:  "restore selection to where it was when 'again' was invoked"			[wasTypedKey				ifTrue: "search started by typing key at a caret; restore it"					[self selectAt: home first.					self zapSelectionWith: FindText.					self selectAt: home last + 1]				ifFalse: [self selectInterval: home]].	self undoMessage: UndoMessage forRedo: self isUndoing! !!TheWorldMenu methodsFor: 'commands' stamp: 'ar 8/6/2009 19:16'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result oldDepth allDepths allLabels hasBoth |	oldDepth := Display nativeDepth.	allDepths := #(1 -1 2 -2 4 -4 8 -8 16 -16 32 -32) select: [:d | Display supportsDisplayDepth: d].	hasBoth := (allDepths anySatisfy:[:d| d > 0]) and:[allDepths anySatisfy:[:d| d < 0]].	allLabels := allDepths collect:[:d|		String streamContents:[:s|			s nextPutAll: (d = oldDepth ifTrue:['<on>'] ifFalse:['<off>']).			s print: d abs.			hasBoth ifTrue:[s nextPutAll: (d > 0 ifTrue:['  (big endian)'] ifFalse:['  (little endian)'])].		]].	result := UIManager default		chooseFrom: allLabels v		values: allDepths 		title: 'Choose a display depth' translated.	result ifNotNil: [Display newDepth: result].	oldDepth := oldDepth abs.	(Smalltalk isMorphic and: [(Display depth < 4) ~= (oldDepth < 4)])		ifTrue:			["Repaint windows since they look better all white in depth < 4"			(SystemWindow windowsIn: myWorld satisfying: [:w | true]) do:				[:w |				oldDepth < 4					ifTrue: [w restoreDefaultPaneColor]					ifFalse: [w updatePaneColors]]]! !!GrafPort methodsFor: 'private' stamp: 'jmv 8/5/2009 22:28'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	super installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor.	alpha := foregroundColor privateAlpha.	aStrikeFont glyphs depth = 1 ifTrue: [		"dynamically switch between blend modes to support translucent text"		"To handle the transition from TTCFont to StrikeFont, rule 34 must be taken into account."		alpha = 255 ifTrue:[			combinationRule = 30 ifTrue: [combinationRule := Form over].			combinationRule = 31 ifTrue: [combinationRule := Form paint].			combinationRule = 34 ifTrue: [combinationRule := Form paint].		] ifFalse:[			combinationRule = Form over ifTrue: [combinationRule := 30].			combinationRule = Form paint ifTrue: [combinationRule := 31].			combinationRule = 34 ifTrue: [combinationRule := 31].		].	].	lastFont := aStrikeFont.	lastFontForegroundColor := foregroundColor.	lastFontBackgroundColor := backgroundColor.! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 7/29/2009 18:37'!hiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hidden info.  Return the entire string that was used by Cmd-6 to create this text attribute.  Usually enclosed in < >."	| attrList |	attrList _ paragraph text attributesAt: (self pointIndex + self markIndex)//2.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self selection asString, '<', attr info, '>']].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self selection asString, '<', attr color printString, '>']].	^ self selection asString, '[No hidden info]'! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!isDoing	"Call from a doer/undoer/redoer any time to see which it is."	^(self isUndoing | self isRedoing) not! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 11/4/2008 11:51'!stateArrayPut: stateArray	| sel |	ChangeText _ stateArray at: 1.	FindText _ stateArray at: 2.	UndoInterval _ stateArray at: 3.	UndoMessage _ stateArray at: 4.	UndoParagraph _ stateArray at: 5.	UndoSelection _ stateArray at: 6.	Undone _ stateArray at: 7.	sel _ stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock _ stateArray at: 9.	emphasisHere _ stateArray at: 10! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 8/6/2009 18:30'!checkCurrentHandForObjectToPaste	| response |	self primaryHand pasteBuffer ifNil: [^self].	response := UIManager default chooseFrom: #('Delete' 'Keep')		title: 'Hand is holding a Morph in its paste buffer:\' withCRs,			self primaryHand pasteBuffer printString.	response = 1 ifTrue: [self primaryHand pasteBuffer: nil].! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 11:51'!afterSelectionInsertAndSelect: aString	self insertAndSelect: aString at: self stopIndex ! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 7/21/2009 10:05'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.				"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.			"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.		"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.		"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.				"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.				"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.				"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.				"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"				'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmdMap at: $, asciiValue + 1 put: #shiftEnclose:.		cmds := #($a #selectAll: $c #copySelection: $e #exchange: $f #find: $g #findAgain: $h #setSearchString: $k #offerFontMenu: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).	1 to: cmds size		by: 2		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions := cmdMap! !!MenuMorph class methodsFor: 'utilities' stamp: 'ar 8/6/2009 20:00'!chooseFrom: aList lines: linesArray title: queryString	"Choose an item from the given list. Answer the index of the selected item."	"MenuMorph		chooseFrom: #('Hello' 'World' 'Here' 'We' 'Go')		lines: #(2 4)		title: 'What''s up?'"	| menu aBlock result |	(ProvideAnswerNotification signal: queryString) ifNotNilDo:[:answer | 		1 to: aList size do:[:i| (aList at: i) = answer ifTrue:[^i]].		^0].	aBlock := [:v| result := v].	menu := self new.	menu addTitle: queryString.	1 to: aList size do:[:i| 		menu add: (aList at: i) asString target: aBlock selector: #value: argument: i.		(linesArray includes: i) ifTrue:[menu addLine]	].	MenuIcons decorateMenu: menu.	result := 0.	menu invokeAt: ActiveHand position in: ActiveWorld allowKeyboard: true.	^result! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 11/4/2008 13:51'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	markBlock _ paragraph defaultCharacterBlock.	self pointBlock: markBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 4/6/2009 18:05'!recomputeSelection	"Redetermine the selection according to the start and stop block indices; 	do not highlight."	self deselect; recomputeInterval! !!MenuMorph class methodsFor: 'utilities' stamp: 'ar 8/6/2009 20:00'!chooseFrom: aList values: valueList lines: linesArray title: queryString	"Choose an item from the given list. Answer the index of the selected item."	"MenuMorph		chooseFrom: #('Hello' 'World' 'Here' 'We' 'Go')		values: #('Hello' 'World' 'Here' 'We' 'Go')		lines: #(2 4)		title: 'What''s up?'"	| menu aBlock result |	(ProvideAnswerNotification signal: queryString) ifNotNilDo:[:answer | 		1 to: aList size do:[:i| (aList at: i) = answer ifTrue:[^answer]].		^nil].	aBlock := [:v| result := v].	menu := self new.	menu addTitle: queryString.	1 to: aList size do:[:i| 		menu add: (aList at: i) asString target: aBlock selector: #value: argument: (valueList at: i).		(linesArray includes: i) ifTrue:[menu addLine]	].	MenuIcons decorateMenu: menu.	result := nil.	menu invokeAt: ActiveHand position in: ActiveWorld allowKeyboard: true.	^result! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!changeStyle: characterStream 	"Put up the style-change menu"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self changeStyle.	^ true! !!NewParagraph methodsFor: 'access' stamp: 'ar 12/15/2008 22:42'!caretWidth	^ 0! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:36'!addSaveAndQuit: menu	self		fillIn: menu		from: {			nil.			{ 'save'. { SmalltalkImage current. #saveSession }. 'save the current version of the image on disk' }.			{ 'save as...'. { SmalltalkImage current. #saveAs }. 'save the current version of the image on disk under a new name.' }.			{ 'save as new version'. { SmalltalkImage current. #saveAsNewVersion }. 'give the current image a new version-stamped name and save it under that name on disk.' }.			{ 'save and quit'. { self. #saveAndQuit }. 'save the current image on disk, and quit out of Squeak.' }.			{ 'quit'. { self. #quitSession }. 'quit out of Squeak.' }		}! !!TextEditor methodsFor: 'menu messages' stamp: 'ar 8/6/2009 20:45'!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName lastIndex |	stringToSave := paragraph text string.	stringToSave size = 0 ifTrue: [^self inform: 'nothing to save.'].	parentWindow := model dependents 				detect: [:dep | dep isKindOf: SystemWindow]				ifNone: [nil].	labelToUse := parentWindow ifNil: ['Untitled']				ifNotNil: [parentWindow label].	suggestedName := nil.	#(#('Decompressed contents of: ' '.gz')) do: 			[:leaderTrailer | 			"can add more here..."			(labelToUse beginsWith: leaderTrailer first) 				ifTrue: 					[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1								to: labelToUse size.					(labelToUse endsWith: leaderTrailer last) 						ifTrue: 							[suggestedName := suggestedName copyFrom: 1										to: suggestedName size - leaderTrailer last size]						ifFalse: 							[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].							(lastIndex = 0 or: [lastIndex = 1]) 								ifFalse: [suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil: [suggestedName := labelToUse , '.text'].	fileName := UIManager default request: 'File name?'				initialAnswer: suggestedName.	fileName isEmptyOrNil 		ifFalse: 			[(FileStream newFileNamed: fileName)				nextPutAll: stringToSave;				close]! !!TextMorph methodsFor: 'blinking' stamp: 'ar 12/15/2008 23:01'!onBlinkCursor	"Blink the cursor"	| para |	para := self paragraph ifNil:[^nil].	Time millisecondClockValue < self blinkStart ifTrue:[		"don't blink yet"		^para showCaret: para focused.	].	para showCaret: para showCaret not.	para caretRect ifNotNilDo:[:r| self invalidRect: r].! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 23:32'!cursorRight: characterStream 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	self closeTypeIn: characterStream.	self		moveCursor: [:position | position + 1]		forward: true		specialBlock:[:position | self nextWord: position].	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!sendersOfIt: characterStream 	"Triggered by Cmd-n; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self sendersOfIt.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!crWithIndent: characterStream 	"Replace the current text selection with CR followed by as many tabs	as on the current line (+/- bracket count) -- initiated by Shift-Return."	| char s i tabCount |	sensor keyboard.		"flush character"	s _ paragraph string.	i _ self stopIndex.	tabCount _ 0.	[(i _ i-1) > 0 and: [(char _ s at: i) ~= Character cr]]		whileTrue:  "Count tabs and brackets (but not a leading bracket)"		[(char = Character tab and: [i < s size and: [(s at: i+1) ~= $[ ]]) ifTrue: [tabCount _ tabCount + 1].		char = $[ ifTrue: [tabCount _ tabCount + 1].		char = $] ifTrue: [tabCount _ tabCount - 1]].	characterStream crtab: tabCount.  "Now inject CR with tabCount tabs"	^ false! !!HaloMorph methodsFor: 'private' stamp: 'ar 8/6/2009 18:23'!maybeDismiss: evt with: dismissHandle	"Ask hand to dismiss my target if mouse comes up in it."	evt hand obtainHalo: self.	(dismissHandle containsPoint: evt cursorPoint)		ifFalse:			[self delete.			target addHalo: evt]		ifTrue:			[target resistsRemoval ifTrue:				[(UIManager default chooseFrom: {					'Yes' translated.					'Um, no, let me reconsider' translated.				} title: 'Really throw this away' translated) = 1 ifFalse: [^ self]].			evt hand removeHalo.			self delete.			target dismissViaHalo.			ActiveWorld presenter flushPlayerListCache]! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!fileItIn: characterStream 	"File in the selection; invoked via a keyboard shortcut, -- for now, cmd-shift-G."	sensor keyboard.		"flush character"	self fileItIn.	^ true! !!BalloonCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 7/22/2009 21:33'!fillRoundRect: aRectangle radius: radius fillStyle: fillStyle	| points |	radius asPoint <= (0@0) 		ifTrue:[^self fillRectangle: aRectangle fillStyle: fillStyle].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self fillOval: aRectangle fillStyle: fillStyle].	"decompose aRectangle into bezier form"	points := self makeRoundRectShape: aRectangle radius: radius.	"blast the bezier shape out"	self		drawBezierShape: points		color: fillStyle		borderWidth: 0		borderColor: nil.! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!getPluggableYellowButtonMenu: shiftKeyState	| customMenu |	^ (morph notNil and: [(customMenu _ morph getMenu: shiftKeyState) notNil])		ifTrue: [customMenu]		ifFalse:			[shiftKeyState				ifTrue: [self class shiftedYellowButtonMenu]				ifFalse: [self class yellowButtonMenu]]! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 7/21/2009 10:19'!initializeShiftCmdKeyShortcuts 	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	"TextEditor initialize"		| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256 withAll: #noop:.  		"use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.				"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #offerMenuFromEsc:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	"NB: sw 12/9/2001 commented out the idiosyncratic line just below, which was grabbing shift-esc in the text editor and hence which argued with the wish to have shift-esc be a universal gesture for escaping the local context and calling up the desktop menu."  	"cmdMap at: (27 + 1) put: #shiftEnclose:." 	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	cmds _ #(		$c	compareToClipboard:		$d	duplicate:		$h	cursorTopHome:		$j	doAgainMany:		$k	changeStyle:		$l	outdent:		$m	selectCurrentTypeIn:		$r	indent:		$s	search:		$u	changeLfToCr:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).			"plain keys"		cmdMap at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"		cmdMap at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1).		"ctrl keys"	].	shiftCmdActions _ cmdMap! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!completeSymbol: hintText lastOffering: selectorOrNil	"Invoked by Ctrl-q when there is only a caret.		Do selector-completion, i.e., try to replace the preceding identifier by a		selector that begins with those characters & has as many keywords as possible.	 	Leave two spaces after each colon (only one after the last) as space for		arguments.  Put the caret after the space after the first keyword.  If the		user types Ctrl-q again immediately, choose a different selector.	 Undoer: #undoQuery:lastOffering:; Redoer: itself.	If redoing, just redisplay the last offering, selector[OrNil]."	| firstTime input prior caret newStart sym kwds outStream |	firstTime _ self isRedoing		ifTrue: [prior _ sym _ selectorOrNil. true]		ifFalse: [hintText isNil].	firstTime		ifTrue: "Initial Ctrl-q (or redo)"								[caret _ self startIndex.			self selectPrecedingIdentifier.			input _ self selection]		ifFalse: "Repeated Ctrl-q"			[caret _ UndoInterval first + hintText size.			self selectInvisiblyFrom: UndoInterval first to: UndoInterval last.			input _ hintText.			prior _ selectorOrNil].	(input size ~= 0 and: [sym ~~ nil or:			[(sym _ Symbol thatStarts: input string skipping: prior) ~~ nil]])		ifTrue: "found something to offer"			[newStart _ self startIndex.			outStream _ WriteStream on: (String new: 2 * sym size).			1 to: (kwds _ sym keywords) size do:				[:i |				outStream nextPutAll: (kwds at: i).				i = 1 ifTrue: [caret _ newStart + outStream contents size + 1].				outStream nextPutAll:					(i < kwds size ifTrue: ['  '] ifFalse: [' '])].			UndoSelection _ input.			self deselect; zapSelectionWith: outStream contents asText.			self undoer: #undoQuery:lastOffering: with: input with: sym]		ifFalse: "no more matches"			[firstTime ifFalse: "restore original text & set up for a redo"				[UndoSelection _ self selection.				self deselect; zapSelectionWith: input.				self undoer: #completeSymbol:lastOffering: with: input with: prior.				Undone _ true].			morph flash].	self selectAt: caret! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 11/4/2008 11:51'!selectAndScroll	"Ignore scroll requests."! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 11/4/2008 11:51'!clearParens	lastParenLocation ifNotNil:		[self text string size >= lastParenLocation ifTrue: [			self text				removeAttribute: TextEmphasis bold				from: lastParenLocation				to: lastParenLocation]]! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!browseItHere: characterStream 	"Triggered by Cmd-shift-B; browse the thing represented by the current selection, if plausible, in the receiver's own window.  3/1/96 sw"	sensor keyboard.		"flush character"	self browseItHere.	^ true! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!setSearchString	"Make the current selection, if any, be the current search string."	self hasCaret ifTrue: [morph flash. ^ self].	self setSearch:  self selection string! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:46'!buildWorldMenu	"Build the menu that is put up when the screen-desktop is clicked on"	| menu |	menu := MenuMorph new defaultTarget: self.	menu commandKeyHandler: self.	self colorForDebugging: menu.	menu addStayUpItem.	self makeConvenient: menu.	ServiceGui worldMenu: menu.	ServiceGui onlyServices ifTrue: [^ menu].	self addProjectEntries: menu.	myWorld addUndoItemsTo: menu.	self addRestoreDisplay: menu.	self addUtilities: menu.	self addObjectsAndTools: menu.	self addPrintAndDebug: menu.	self addSaveAndQuit: menu.	^ menu! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!prettyPrintWithColor	self prettyPrint: true! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!compileSelectionFor: anObject in: evalContext	| methodNode method |	methodNode _ [Compiler new		compileNoPattern: self selectionAsStream		in: anObject class		context: evalContext		notifying: self		ifFail: [^nil]]			on: OutOfScopeNotification			do: [:ex | ex resume: true].	method _ methodNode generate: #(0 0 0 0).	^method copyWithTempNames: methodNode tempNames! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 11/4/2008 13:50'!blinkPrevParen	| openDelimiter closeDelimiter level string here hereChar |	string _ paragraph text string.	here _ pointBlock stringIndex.	openDelimiter _ sensor keyboardPeek.	closeDelimiter _ '([{' at: (')]}' indexOf: openDelimiter).	level _ 1.	[level > 0 and: [here > 2]]		whileTrue:			[hereChar _ string at: (here _ here - 1).			hereChar = closeDelimiter				ifTrue:					[level _ level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level _ level + 1]]]! !!TextMorph class methodsFor: 'class initialization' stamp: 'ar 8/6/2009 16:03'!defaultEditorClass	"Answers the default editor class for TextMorph"	^DefaultEditorClass! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!indent: delta fromStream: inStream toStream: outStream	"Append the contents of inStream to outStream, adding or deleting delta or -delta	 tabs at the beginning, and after every CR except a final CR.  Do not add tabs	 to totally empty lines, and be sure nothing but tabs are removed from lines."	| ch skip cr tab prev atEnd |	cr _ Character cr.	tab _ Character tab.	delta > 0		ifTrue: "shift right"			[prev _ cr.			 [ch _ (atEnd _ inStream atEnd) ifTrue: [cr] ifFalse: [inStream next].			  (prev == cr and: [ch ~~ cr]) ifTrue:				[delta timesRepeat: [outStream nextPut: tab]].			  atEnd]				whileFalse:					[outStream nextPut: ch.					prev _ ch]]		ifFalse: "shift left"			[skip _ delta. "a negative number"			 [inStream atEnd] whileFalse:				[((ch _ inStream next) == tab and: [skip < 0]) ifFalse:					[outStream nextPut: ch].				skip _ ch == cr ifTrue: [delta] ifFalse: [skip + 1]]]! !!Morph methodsFor: 'meta-actions' stamp: 'ar 8/6/2009 18:55'!saveAsPrototype	(UIManager default confirm: 'Make this morph the prototype for ', self class printString, '?')		ifFalse: [^ self].	self class prototype: self.! !!TextMorphEditor methodsFor: 'attributes' stamp: 'ar 8/6/2009 19:13'!changeEmphasisOrAlignment	| aList reply  code align menuList startIndex alignSymbol |	self flag: #arNote. "Move this up once we get rid of MVC"	startIndex := self startIndex.	aList := #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).		align := paragraph text alignmentAt: startIndex 		ifAbsent:[paragraph textStyle alignment].	alignSymbol := TextAlignment alignmentSymbol: align.	code := paragraph text emphasisAt: startIndex.	menuList := WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal' translated.	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue:['<on>', emph asString translated]			ifFalse:['<off>',emph asString translated]]).	((paragraph text attributesAt: startIndex forStyle: paragraph textStyle)		anySatisfy:[:attr| attr isKern and:[attr kern < 0]]) 			ifTrue:[menuList nextPut:'<on>', 'narrow' translated]			ifFalse:[menuList nextPut:'<off>', 'narrow' translated].	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collect:[:type|		type == alignSymbol			ifTrue:['<on>',type asString translated]			ifFalse:['<off>',type asString translated]]).	aList := #(normal bold italic underlined struckOut narrow leftFlush centered rightFlush justified).	reply := UIManager default chooseFrom: menuList contents values: aList lines: #(1 6).	reply notNil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[self setAlignment: reply.				paragraph composeAll.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!PolygonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:43'!specifyDashedLine	| executableSpec newSpec |	executableSpec := UIManager default		request:'Enter a dash specification as{ major dash length. minor dash length. minor dash color }The major dash will have the normal border color.A blank response will remove the dash specification.[Note: You may give 5 items as, eg, {10. 5. Color white. 0. 3}where the 4th ityem is zero, and the 5th is the number of pixelsby which the dashes will move in each step of animation]' translated		initialAnswer: '{ 10. 5. Color red }'.	executableSpec isEmpty ifTrue:		[^ self stopStepping; dashedBorder: nil].	newSpec := [Compiler evaluate: executableSpec] ifError:		[^ self stopStepping; dashedBorder: nil].	newSpec first isNumber & newSpec second isNumber & newSpec third isColor ifFalse:		[^ self stopStepping; dashedBorder: nil].	newSpec size = 3 ifTrue:		[^ self stopStepping; dashedBorder: newSpec].	(newSpec size = 5 and: [newSpec fourth isNumber & newSpec fifth isNumber]) ifTrue:		[^ self dashedBorder: newSpec; startStepping].! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:59'!markIndex: anIndex	self markBlock: (paragraph characterBlockForIndex: anIndex)! !!Editor methodsFor: 'menu messages' stamp: 'jmv 11/5/2008 10:12'!paste	"Paste the text from the shared buffer over the current selection and 	redisplay if necessary.  Undoer & Redoer: undoAndReselect."	self replace: self selectionInterval with: self clipboardText and:		[self selectAt: self pointIndex]! !!MenuMorph methodsFor: 'modal control' stamp: 'ar 8/6/2009 20:32'!invokeModalAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	^ self invokeModalAt: aPoint in: aWorld allowKeyboard: Preferences menuKeyboardControl! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!undoer: aSelector	"See comment in undoMessage:.  Use this version when aSelector has no arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector) forRedo: false! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 7/22/2009 21:36'!frameAndFillRoundRect: aRectangle radius: cornerRadius fillStyle: fillStyle borderWidth: bw borderColor: bc	"Draw a rounded rectangle"	self shadowColor ifNotNil:[		^self fillRoundRect: aRectangle radius: cornerRadius fillStyle: shadowColor.	].	"see if the round rect is degenerate"	cornerRadius asPoint <= (0@0) 		ifTrue:[^self frameAndFillRectangle: aRectangle fillColor: fillStyle borderWidth: bw borderColor: bc].	cornerRadius * 2 >= aRectangle width 		ifTrue:[^self fillOval: aRectangle color: fillStyle borderWidth: bw borderColor: bc].	"Okay it's a rounded rectangle"	fillStyle isTransparent ifFalse:["fill interior"		| innerRect radius |		innerRect := aRectangle.		radius := cornerRadius.		bw isZero ifFalse:[			innerRect := innerRect insetBy: bw.			radius := radius - bw.		].		self fillRoundRect: innerRect radius: radius fillStyle: fillStyle.	].	self frameRoundRect: aRectangle radius: cornerRadius width: bw color: bc! !!Editor methodsFor: 'private' stamp: 'jmv 11/5/2008 10:04'!lines	"Compute lines based on logical line breaks, not optical (which may change due to line wrapping of the editor).	Subclasses using kinds of Paragraphs can instead use the service provided by it.	"	| lines string index lineIndex stringSize |	string _ self string.	"Empty strings have no lines at all. Think of something."	string isEmpty ifTrue:[^{#(1 0 0)}].	stringSize _ string size.	lines _ OrderedCollection new: (string size // 15).	index _ 0.	lineIndex _ 0.	string linesDo:[:line |		lines addLast: (Array			with: (index _ index + 1)			with: (lineIndex _ lineIndex + 1)			with: (index _ index + line size min: stringSize))].	"Special workaround for last line empty."	string last == Character cr	"lines last last < stringSize" ifTrue:[lines addLast:{stringSize +1. lineIndex+1. stringSize}].	^lines! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 11:51'!selectLine	"Make the receiver's selection, if it currently consists of an insertion point only, encompass the current line."	self hasSelection ifTrue:[^self].	self selectInterval: (self encompassLine: self selectionInterval)! !!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 7/21/2009 10:37'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down"	^ shiftedYellowButtonMenu! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 8/6/2009 19:01'!deleteNonWindows	(UIManager default confirm:'Do you really want to discard all objectsthat are not in windows?' translated)		ifFalse: [^ self].	self allNonFlapRelatedSubmorphs do:		[:m | m delete]! !!TextMorph methodsFor: 'private' stamp: 'ar 8/6/2009 16:05'!editorClass	"Answer the class used to create the receiver's editor"	^DefaultEditorClass! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 12/8/2008 15:45'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString _  self selection string.	aString size = 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'ar 8/6/2009 19:18'!setFontStyle	| aList reply style |	aList := (TextConstants select: [:anItem | anItem isKindOf: TextStyle]) 				keys asOrderedCollection.	reply := UIManager default chooseFrom: aList values: aList.	reply notNil 		ifTrue: 			[(style := TextStyle named: reply) ifNil: 					[Beeper beep.					^true].			self font: style defaultFont]! !!MorphicModel methodsFor: 'submorphs-add/remove' stamp: 'ar 8/6/2009 18:29'!delete	(model isMorphicModel) ifFalse: [^super delete].	slotName ifNotNil: 			[(UIManager default confirm: 'Shall I remove the slot ' , slotName 						, 'along with all associated methods?') 				ifTrue: 					[(model class selectors select: [:s | s beginsWith: slotName]) 						do: [:s | model class removeSelector: s].					(model class instVarNames includes: slotName) 						ifTrue: [model class removeInstVarName: slotName]]				ifFalse: 					[(UIManager default 						confirm: '...but should I at least dismiss this morph?[choose no to leave everything unchanged]') 							ifFalse: [^self]]].	super delete! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 7/22/2009 21:34'!fillRoundRect: aRectangle radius: radius	| nextY outer nextOuterX ovalDiameter rectExtent rectOffset rectX rectY rectWidth rectHeight ovalRadius ovalRect |	aRectangle area <= 0 ifTrue: [^ self].	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or:[ovalDiameter y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	"force diameter to be even - this simplifies lots of stuff"	ovalRadius := (ovalDiameter x // 2) @ (ovalDiameter y // 2).	(ovalRadius x <= 0 or:[ovalRadius y <= 0]) ifTrue:[		^self fillRect: aRectangle offset: 0@0.	].	ovalDiameter := ovalRadius * 2.	rectExtent := aRectangle extent - ovalDiameter.	rectWidth := rectExtent x.	rectHeight := rectExtent y.	rectOffset := aRectangle origin + ovalRadius.	rectX := rectOffset x.	rectY := rectOffset y.	ovalRect := ovalRadius negated extent: ovalDiameter.	height := 1.	outer := EllipseMidpointTracer new on: ovalRect.	nextY := ovalRadius y.	"upper and lower portions of round rect"	[nextY > 0] whileTrue:[		nextOuterX := outer stepInY.		width := nextOuterX * 2 + rectWidth.		destX := rectX - nextOuterX.		destY := rectY - nextY.		self copyBits.		destY := rectY + nextY + rectHeight - 1.		self copyBits.		nextY := nextY - 1.	].	destX := aRectangle left.	destY := rectOffset y.	height := rectHeight.	width := aRectangle width.	self copyBits.! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 11:51'!raiseContextMenu: characterStream 	(morph respondsTo: #editView)		ifTrue: [morph editView yellowButtonActivity: ActiveEvent shiftPressed].	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!makeCapitalized: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	sensor keyboard.		"flush the triggering cmd-key character"	prev _ $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!Editor class methodsFor: 'class initialization' stamp: 'jmv 11/5/2008 13:07'!initialize	"	Editor initialize	"	self allSubclassesDo: [ :c | c initialize ]! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!hasCaret	^self markBlock = self pointBlock! !!Editor methodsFor: 'editing keys' stamp: 'jmv 11/5/2008 10:17'!cut: characterStream 	"Cut out the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self cut.	^true! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainCtxt: symbol 	"Is symbol a context variable?"	| reply classes text cls |	symbol = #nil ifTrue: [reply _ '"is a constant.  It is the only instance of class UndefinedObject.  nil is the initial value of all variables."'].	symbol = #true ifTrue: [reply _ '"is a constant.  It is the only instance of class True and is the receiver of many control messages."'].	symbol = #false ifTrue: [reply _ '"is a constant.  It is the only instance of class False and is the receiver of many control messages."'].	symbol = #thisContext ifTrue: [reply _ '"is a context variable.  Its value is always the MethodContext which is executing this method."'].	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ reply].	  "no class known"	symbol = #self ifTrue: 			[classes _ cls withAllSubclasses.			classes size > 12				ifTrue: [text _ cls printString , ' or a subclass']				ifFalse: 					[classes _ classes printString.					text _ 'one of these classes' , (classes copyFrom: 4 to: classes size)].			reply _ '"is the receiver of this message; an instance of ' , text , '"'].	symbol = #super ifTrue: [reply _ '"is just like self.  Messages to super are looked up in the superclass (' , cls superclass printString , ')"'].	^reply! !!TextMorph methodsFor: 'blinking' stamp: 'ar 12/15/2008 23:00'!resetBlinkCursor	"Reset the blinking cursor"	| para |	self blinkStart: Time millisecondClockValue + 500.	para := self paragraph ifNil:[^self].	para showCaret = para focused ifFalse:[		para caretRect ifNotNilDo:[:r| self invalidRect: r].		para showCaret: para focused.	].! !!TextEditor methodsFor: 'initialize-release' stamp: 'jmv 11/4/2008 11:51'!changeParagraph: aParagraph 	"Install aParagraph as the one to be edited by the receiver."	UndoParagraph == paragraph ifTrue: [UndoParagraph _ nil].	paragraph _ aParagraph.	self resetState! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!spawnIt: characterStream	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	sensor keyboard.	self spawn.	^ true! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!isDisjointFrom: anInterval	"Answer true if anInterval is a caret not touching or within the current	 interval, or if anInterval is a non-caret that does not overlap the current	 selection."	| fudge |	fudge _ anInterval size = 0 ifTrue: [1] ifFalse: [0].	^(anInterval last + fudge < self startIndex or:			[anInterval first - fudge >= self stopIndex])! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!pointIndex	^ self pointBlock stringIndex! !!PasteUpMorph methodsFor: 'gridding' stamp: 'ar 8/6/2009 20:43'!setGridSpec	"Gridding rectangle provides origin and modulus"	| response result |	response := UIManager default			request: 'New grid origin (usually 0@0):' translated			initialAnswer: self gridOrigin printString.	response isEmpty ifTrue: [^ self].	result := [Compiler evaluate: response] ifError: [^ self].	(result isPoint and: [(result >= (0@0))])		ifTrue: [self gridOrigin: result]		ifFalse: [self inform: ('Must be a Point with coordinates (for example 10@10)' translated )].	response := UIManager default			request: 'New grid spacing:' translated			initialAnswer: self gridModulus printString.	response isEmpty ifTrue: [^ self].	result := [Compiler evaluate: response] ifError: [^ self].	(result isPoint and: [(result > (0@0)) ])		ifTrue: [self gridModulus: result]		ifFalse: [self inform: ('Must be a Point with coordinates (for example 10@10)' translated )].! !!TextEditor methodsFor: 'attributes' stamp: 'ar 8/6/2009 19:13'!changeStyle	"Let user change styles for the current text pane."	| names reply style current menuList |	current := paragraph textStyle.	names := TextStyle availableTextStyleNames.	menuList := names collect: [ :styleName |		styleName = current name			ifTrue: [ '<on>', styleName ]			ifFalse: [ '<off>', styleName ]].	reply := UIManager default chooseFrom: menuList values: names.	reply ifNotNil: [		(style := TextStyle named: reply) ifNil: [Beeper beep. ^ true].		paragraph textStyle: style.		paragraph composeAll.		self recomputeSelection].	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!doIt: characterStream 	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	sensor keyboard.		self doIt.	^ true! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainGlobal: symbol 	"Is symbol a global variable?"	| reply classes |	reply _ Smalltalk at: symbol ifAbsent: [^nil].	(reply class == Dictionary or:[reply isKindOf: SharedPool class])		ifTrue: 			[classes _ Set new.			Smalltalk allBehaviorsDo: [:each | (each sharedPools detect: [:pool | pool == reply]					ifNone: [])					~~ nil ifTrue: [classes add: each]].			classes _ classes printString.			^'"is a global variable.  It is a pool which is used by the following classes ' , (classes allButFirst: 5) , '"'].	(reply isKindOf: Behavior)		ifTrue: [^'"is a global variable.  ' , symbol , ' is a class in category ', reply category,			'."', '\' withCRs, 'Browser newOnClass: ' , symbol , '.'].	symbol == #Smalltalk ifTrue: [^'"is a global.  Smalltalk is the only instance of SystemDictionary and holds all global variables."'].	^'"is a global variable.  ' , symbol , ' is ' , reply printString , '"'! !!Morph methodsFor: 'meta-actions' stamp: 'ar 8/6/2009 20:16'!embedInto: evt	"Embed the receiver into some other morph"	|  target morphs |	morphs := self potentialEmbeddingTargets.	target := UIManager default 		chooseFrom: (morphs collect:[:m| m knownName ifNil:[m class name asString]])		values: self potentialEmbeddingTargets		title: ('Place ', self externalName, ' in...').	target ifNil:[^self].	target addMorphFront: self fromWorldPosition: self positionInWorld.! !!FileList methodsFor: 'server list' stamp: 'ar 8/6/2009 18:50'!putUpdate: fullFileName	"Put this file out as an Update on the servers."	| names choice |	self canDiscardEdits ifFalse: [^ self changed: #flash].	names := ServerDirectory groupNames asSortedArray.	choice := UIManager default chooseFrom: names values: names.	choice == nil ifTrue: [^ self].	(ServerDirectory serverInGroupNamed: choice) putUpdate: 				(directory oldFileNamed: fullFileName).	self volumeListIndex: volListIndex.! !!BalloonCanvas methodsFor: 'private' stamp: 'ar 7/22/2009 21:34'!makeRoundRectShape: aRectangle radius: radius	"decompose a rounded rectangle into bezier form"	| ovalDiameter rectExtent segments points endPoint seg idx offset rectOffset |	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or:[ovalDiameter y <= 0]) ifTrue:[		"degenerates into rectangle - just hand back four lines"		| topLeft topRight bottomLeft bottomRight |		topLeft := aRectangle topLeft.		topRight := aRectangle topRight.		bottomLeft := aRectangle bottomLeft.		bottomRight := aRectangle bottomRight.		points := Array new: 4*3.		points at: 1 put: topLeft.		points at: 2 put: topLeft.		points at: 3 put: topRight.		points at: 4 put: topRight.		points at: 5 put: topRight.		points at: 6 put: bottomRight.		points at: 7 put: bottomRight.		points at: 8 put: bottomRight.		points at: 9 put: bottomLeft.		points at: 10 put: bottomLeft.		points at: 11 put: bottomLeft.		points at: 12 put: topLeft.		^points	].	rectExtent := aRectangle extent - ovalDiameter.	rectOffset := aRectangle origin.	segments := Bezier2Segment makeEllipseSegments: (0@0 extent: ovalDiameter).	"patch up the segments to include lines connecting the oval parts.	we need: 8*3 points for the oval parts + 4*3 points for the connecting lines"	points := Array new: 12*3.	idx := 0.	endPoint := segments last end + rectOffset.	1 to: 8 by: 2 do:[:i|		i = 1 ifTrue:[offset := rectOffset + (rectExtent x @ 0)].		i = 3 ifTrue:[offset := rectOffset + rectExtent].		i = 5 ifTrue:[offset := rectOffset + (0 @ rectExtent y)].		i = 7 ifTrue:[offset := rectOffset].		seg := segments at: i.		"insert a line segment for the horizontal part of the round rect"		points at: (idx := idx+1) put: endPoint.		points at: (idx := idx+1) put: endPoint.		points at: (idx := idx+1) put: seg start + offset.		"now the first half-arc"		points at: (idx := idx+1) put: seg start + offset.		points at: (idx := idx+1) put: seg via + offset.		points at: (idx := idx+1) put: seg end + offset.		"the second half-arc"		seg := segments at: i+1.		points at: (idx := idx+1) put: seg start + offset.		points at: (idx := idx+1) put: seg via + offset.		points at: (idx := idx+1) put: seg end + offset.		endPoint := seg end + offset.	].	^points! !!SketchMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 19:09'!setRotationStyle	| selections labels sel reply |	selections := #(normal leftRight upDown none).	labels := #('rotate smoothly' 'left-right flip only' 'top-down flip only' 'don''t rotate').	sel := labels at: (selections indexOf: self rotationStyle ifAbsent:[1]).	labels := labels collect:[:lbl| sel = lbl ifTrue:['<on>', lbl translated] ifFalse:['<off>', lbl translated]].	reply := UIManager default chooseFrom: labels values: selections.	reply ifNotNil: [self rotationStyle: reply].! !!TextEditor class methodsFor: 'accessing' stamp: 'jmv 7/21/2009 10:17'!shiftCmdActions	^shiftCmdActions! !!TextEditor methodsFor: 'displaying' stamp: 'jmv 11/4/2008 11:51'!flash	^ morph flash! !!TextEditor class methodsFor: 'class initialization' stamp: 'jmv 11/5/2008 22:21'!abandonChangeText	"Call this to get out of the maddening situation in which the system keeps aggressively trying to do a replacement that you no longer wish to make, every time you make choose a new method in a list."	ChangeText _ FindText	"	TextEditor abandonChangeText	"! !!TextMorph methodsFor: 'blinking' stamp: 'ar 12/15/2008 23:00'!blinkStart	"Reset time for blink cursor after which blinking should actually start"	^self valueOfProperty: #blinkStart ifAbsent:[Time millisecondClockValue]! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:44'!addPrintAndDebug: menu	Preferences simpleMenus ifFalse: [		self			fillIn: menu			from: {				{ 'print PS to file...'. { self. #printWorldOnFile }. 'write the world into a postscript file' }.				{ 'debug...'. { self. #debugDo }. 'a menu of debugging items' }			} ]! !!TextMorph methodsFor: 'blinking' stamp: 'ar 12/15/2008 23:00'!blinkStart: msecs	"Reset time for blink cursor after which blinking should actually start"	^self setProperty: #blinkStart toValue: msecs! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits _ Array with: msg.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes _ Smalltalk allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!querySymbol: characterStream	"Invoked by Ctrl-q to query the Symbol table and display alternate symbols.	 See comment in completeSymbol:lastOffering: for details."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	"keep typeahead"	self hasCaret		ifTrue: "Ctrl-q typed when a caret"			[self perform: #completeSymbol:lastOffering: withArguments:				((UndoParagraph == paragraph and: [UndoMessage sends: #undoQuery:lastOffering:])					ifTrue: [UndoMessage arguments] "repeated Ctrl-q"					ifFalse: [Array with: nil with: nil])] "initial Ctrl-q"		ifFalse: "Ctrl-q typed when statements were highlighted"			[morph flash].	^true! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 7/27/2009 14:20'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "		^self changeTextFont! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 12/8/2008 15:45'!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString _ self selection string copyWithoutAll:		{Character space.  Character cr.  Character tab}.	aString size = 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!JoystickMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:41'!setYRange	| range |	range := UIManager default		request:'Type the maximum value for the Y axis'  translated		initialAnswer: ((yScale * (self width - handleMorph width) / 2.0) roundTo: 0.01) printString.	range isEmpty ifFalse: [		yScale := (2.0 * range asNumber asFloat) / (self width - handleMorph width)].! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 23:35'!selectWord: characterStream	sensor keyboard.	self closeTypeIn: characterStream.	self selectWord.	^ true! !!Morph methodsFor: 'meta-actions' stamp: 'ar 8/6/2009 20:16'!targetWith: evt	"Some other morph become target of the receiver"	|  morphs newTarget |	morphs := self potentialTargets.	newTarget := UIManager default		chooseFrom: (morphs collect: [:m | m knownName ifNil:[m class name asString]])		values: morphs		title:  self externalName, ' targets...'.	newTarget ifNil:[^self].	self target: newTarget.! !!Morph methodsFor: 'halos and balloon help' stamp: 'ar 8/6/2009 20:42'!editBalloonHelpContent: aString	| reply |	reply := UIManager default		multiLineRequest: 'Edit the balloon help text for ' translated, self externalName		centerAt: Sensor cursorPoint		initialAnswer: (aString ifNil: [self noHelpString] ifNotNil: [aString])		answerHeight: 200.	reply ifNil: [^ self].  "User cancelled out of the dialog"	(reply isEmpty or: [reply asString = self noHelpString])		ifTrue: [self setBalloonText: nil]		ifFalse: [self setBalloonText: reply]! !!Editor methodsFor: 'initialize-release' stamp: 'jmv 11/4/2008 13:42'!initialize	"Initialize the state of the receiver. Subclasses should include 'super 	initialize' when redefining this message to insure proper initialization."	sensor _ InputSensor default! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 13:56'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ self markIndex.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	self hasSelection ifTrue:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	upara _ UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!MorphExtension methodsFor: 'other' stamp: 'ar 8/6/2009 18:56'!inspectElement	"Create and schedule an Inspector on the otherProperties and the 	named properties."	| key obj |	key := UIManager default chooseFrom: self sortedPropertyNames values: self sortedPropertyNames  title: 'Inspect which property?'.	key		ifNil: [^ self].	obj := otherProperties				at: key				ifAbsent: ['nOT a vALuE'].	obj = 'nOT a vALuE'		ifTrue: [(self perform: key) inspect			"named properties"]		ifFalse: [obj inspect]! !!FileList methodsFor: 'server list' stamp: 'ar 8/6/2009 18:51'!removeServer	| choice names |	self flag: #ViolateNonReferenceToOtherClasses.	names := ServerDirectory serverNames asSortedArray.	choice := UIManager default chooseFrom: names values: names.	choice == nil ifTrue: [^ self].	ServerDirectory removeServerNamed: choice! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 11:51'!encompassLine: anInterval	"Return an interval that encompasses the entire line"	| string left right |	string _ paragraph text string.	left _ (string lastIndexOf: Character cr startingAt: anInterval first - 1 ifAbsent:[0]) + 1.	right _ (string indexOf: Character cr startingAt: anInterval last + 1 ifAbsent: [string size + 1]) - 1.	^left to: right! !!TextMorph class methodsFor: 'class initialization' stamp: 'ar 8/6/2009 16:04'!initialize	"TextMorph initialize"	"Initialize the default text editor class to use"	DefaultEditorClass := TextMorphEditor.	"Initialize constants shared by classes associated with text display."	CaretForm := (ColorForm extent: 16@5					fromArray: #(2r001100e26 2r001100e26 2r011110e26 2r111111e26 2r110011e26)					offset: -2@0)					colors: (Array with: Color transparent with: Preferences textHighlightColor).	self registerInFlapsRegistry.! !!JoystickMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:41'!trackRealJoystick	| s |	s := UIManager default		request: 'Number of joystick to track?'		initialAnswer: '1'.	s isEmpty ifTrue: [^ self].	realJoystickIndex := Number readFromString: s.	self startStepping.! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectLine.	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ morph flash].	Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 7/29/2009 22:47'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin stop |	beginTypeInBlock == nil ifFalse: [		(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ self startOfTyping.			stop _ self stopIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!pageHeight	| howManyLines visibleHeight totalHeight ratio |	howManyLines _ paragraph numberOfLines.	visibleHeight _ self visibleHeight.	totalHeight _ self totalTextHeight.	ratio _ visibleHeight / totalHeight.	^(ratio * howManyLines) rounded - 2! !!TextMorph methodsFor: 'event handling' stamp: 'ar 12/15/2008 22:50'!keyboardFocusChange: aBoolean 	| w |	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"].			self startBlinking.	] ifFalse:["A hand has clicked elsewhere..."		(w := self world) ifNotNil:[			w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].			"Release control unless some hand is still holding on"			self releaseEditor].		self stopBlinking.	].! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 23:40'!selectAll: characterStream 	"select everything, invoked by cmd-a.  1/17/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectFrom: 1 to: self string size.	^ true! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 7/21/2009 10:17'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	((char == Character cr) and: [morph acceptOnCR])		ifTrue: [			sensor keyboard.  "Gobble cr -- probably unnecessary."			self closeTypeIn.			^ true].	self clearParens.  	char asciiValue = 13 ifTrue: [		sensor controlKeyPressed ifTrue: [			^ self normalCharacter: typeAheadStream ].		sensor leftShiftDown ifTrue: [			^ self lf: typeAheadStream ].		sensor commandKeyPressed ifTrue: [			^ self crlf: typeAheadStream ].		^ self crWithIndent: typeAheadStream ].	((honorCommandKeys _ Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue: [				self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [				self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue: [			^ self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	(')]}' includes: char)		ifTrue: [self blinkPrevParen].	^ self normalCharacter: typeAheadStream! !!TextEditor methodsFor: 'attributes' stamp: 'jmv 11/4/2008 11:51'!changeTextFont	"Present a menu of available fonts, and if one is chosen, apply it to the current selection."	| curFont newFont attr startIndex |	startIndex _ self startIndex.	curFont _ (paragraph text fontAt: startIndex withStyle: paragraph textStyle).	newFont _ StrikeFont fromUser: curFont.	newFont ifNil:[^self].	attr _ TextFontReference toFont: newFont.	paragraph text addAttribute: attr from: startIndex to: (self stopIndex-1 min: paragraph text size).	paragraph composeAll.	self recomputeInterval.	morph changed.! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 8/6/2009 19:01'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(UIManager default confirm:'Do you really want to close all windowsexcept those with unaccepted edits?' translated)		ifFalse: [^ self].	(SystemWindow windowsIn: self satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!FileList methodsFor: 'private' stamp: 'ar 8/6/2009 18:50'!recentDirs	"Put up a menu and let the user select from the list of recently visited directories."	| dirName |	RecentDirs isEmpty ifTrue: [^self].	dirName := UIManager default chooseFrom: RecentDirs values: RecentDirs.	dirName == nil ifTrue: [^self].	self directory: (FileDirectory on: dirName)! !!MenuMorph class methodsFor: 'utilities' stamp: 'ar 8/4/2009 22:40'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"MenuMorph confirm: 'Are you hungry?'"	^ self confirm: queryString trueChoice: 'Yes' translated falseChoice: 'No' translated! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 11:51'!correctFrom: start to: stop with: aString	"Make a correction in the model that the user has authorised from somewhere else in the system (such as from the compilier).  The user's selection is not changed, only corrected."	| wasShowing userSelection delta loc |	aString = '#insert period' ifTrue:		[loc _ start.		[(loc _ loc-1)>0 and: [(paragraph text string at: loc) isSeparator]]			whileTrue: [loc _ loc-1].		^ self correctFrom: loc+1 to: loc with: '.'].	(wasShowing _ selectionShowing) ifTrue: [ self reverseSelection ].	userSelection _ self selectionInterval.	self selectInvisiblyFrom: start to: stop.	self replaceSelectionWith: aString asText.	delta _ aString size - (stop - start + 1).	self selectInvisiblyFrom:		userSelection first + (userSelection first > start ifFalse: [ 0 ] ifTrue: [ delta ])		to: userSelection last + (userSelection last > start ifFalse: [ 0 ] ifTrue: [ delta ]).	wasShowing ifTrue: [ self reverseSelection ].! !!TextMorph class methodsFor: 'preferences' stamp: 'ar 8/6/2009 16:14'!useNewEditors: aBool	"Enable/disable the new text editors"	self defaultEditorClass: (aBool ifTrue:[TextEditor] ifFalse:[TextMorphEditor])! !!BalloonCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 7/22/2009 21:33'!frameRoundRect: aRectangle radius: radius width: borderWidth color: borderColor	| outerPoints innerRect innerRadius innerPoints |	(borderWidth isZero or:[borderColor isTransparent])		ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self frameRectangle: aRectangle width: borderWidth color: borderColor].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self frameOval: aRectangle width: borderWidth color: borderColor].	"decompose inner rectangle into bezier shape"	innerRect := aRectangle insetBy: borderWidth.	innerRect area <= 0 		ifTrue:[^self fillRoundRect: aRectangle radius: radius fillStyle: borderColor].	innerRadius := (radius - borderWidth) asPoint.	innerPoints := self makeRoundRectShape: innerRect radius: innerRadius.	"decompose outer rectangle into bezier shape"	outerPoints := self makeRoundRectShape: aRectangle radius: radius.	self		drawGeneralBezierShape: (Array with: outerPoints with: innerPoints)		color: borderColor		borderWidth: 0		borderColor: nil.! !!Morph methodsFor: 'menus' stamp: 'ar 8/6/2009 20:42'!exportAsBMP	| fName |	fName := UIManager default request:'Please enter the name' translated initialAnswer: self externalName,'.bmp'.	fName isEmpty ifTrue:[^self].	self imageForm writeBMPfileNamed: fName.! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 11:51'!replace: xoldInterval with: newText and: selectingBlock 	"Replace the text in oldInterval with newText and execute selectingBlock to establish the new selection.  Create an undoAndReselect:redoAndReselect: undoer to allow perfect undoing."	| undoInterval |	undoInterval _ self selectionInterval.	undoInterval = xoldInterval ifFalse: [self selectInterval: xoldInterval].	UndoSelection _ self selection.	self zapSelectionWith: newText.	selectingBlock value.	otherInterval _ self selectionInterval.	self undoer: #undoAndReselect:redoAndReselect: with: undoInterval with: otherInterval! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:33'!addRestoreDisplay: menu	self		fillIn: menu		from: {			{'restore display (r)'. { World. #restoreMorphicDisplay }. 'repaint the screen -- useful for removing unwanted display artifacts, lingering cursors, etc.' }.			nil		}! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| selection |	selection _ self selection.	(ReadWriteStream on: selection string from: 1 to: selection size) fileIn! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!cancel	"Cancel the changes made so far to this text"	morph cancelEdits! !!NewParagraph methodsFor: 'access' stamp: 'ar 12/15/2008 22:42'!showCaret	^showCaret ifNil:[true]! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 8/6/2009 20:43'!disconnectRemoteUser	"Prompt for the initials of the remote user, then remove the remote hand with those initials, breaking its connection."	"select hand to remove"	| initials handToRemove |	initials := UIManager default request: 'Enter initials for remote user''s cursor?'.	initials isEmpty ifTrue: [^ self].  "abort"	handToRemove := nil.	self handsDo: [:h |		h userInitials = initials ifTrue: [handToRemove := h]].	handToRemove ifNil: [^ self].  "no hand with those initials"	handToRemove withdrawFromWorld.! !!MorphicModel methodsFor: 'compilation' stamp: 'ar 8/6/2009 20:42'!addPartNameLike: className withValue: aMorph	| otherNames i default partName stem |	stem := className first asLowercase asString , className allButFirst.	otherNames := self class allInstVarNames.	i := 1.	[otherNames includes: (default := stem, i printString)]		whileTrue: [i := i + 1].	partName := UIManager default		request: 'Please give this part a name'		initialAnswer: default.	(otherNames includes: partName)		ifTrue: [self inform: 'Sorry, that name is already used'. ^ nil].	self class addInstVarName: partName.	self instVarAt: self class instSize put: aMorph.  "Assumes added as last field"	^ partName! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ morph flash].	model okToChange ifFalse: [^ morph flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ morph flash].	foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).		foundClass isNil ifTrue: [^ morph flash].		(foundClass isKindOf: Class)			ifTrue:				[model systemCategoryListIndex: 					(model systemCategoryList indexOf: foundClass category).	model classListIndex: (model classList indexOf: foundClass name)]! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!noUndoer	"The Undoer to use when the command can not be undone.  Checked for	 specially by readKeyboard."	UndoMessage _ Message selector: #noUndoer! !!Editor methodsFor: 'editing keys' stamp: 'jmv 11/5/2008 10:11'!paste: characterStream 	"Replace the current text selection by the text in the shared buffer.	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self paste.	^true! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!exchangeWith: prior	"If the prior selection is non-overlapping and legal, exchange the text of	 it with the current selection and leave the currently selected text selected	 in the location of the prior selection (or leave a caret after a non-caret if it was	 exchanged with a caret).  If both selections are carets, flash & do nothing.	 Don't affect the paste buffer.  Undoer: itself; Redoer: Undoer."	| start stop before selection priorSelection delta altInterval |	start _ self startIndex.	stop _ self stopIndex - 1.	((prior first <= prior last) | (start <= stop) "Something to exchange" and:			[self isDisjointFrom: prior])		ifTrue:			[before _ prior last < start.			selection _ self selection.			priorSelection _ paragraph text copyFrom: prior first to: prior last.			delta _ before ifTrue: [0] ifFalse: [priorSelection size - selection size].			self zapSelectionWith: priorSelection.			self selectFrom: prior first + delta to: prior last + delta.			delta _ before ifTrue: [stop - prior last] ifFalse: [start - prior first].			self zapSelectionWith: selection.			altInterval _ prior first + delta to: prior last + delta.			self undoer: #exchangeWith: with: altInterval.			"If one was a caret, make it otherInterval & leave the caret after the other"			prior first > prior last ifTrue: [self selectAt: UndoInterval last + 1].			otherInterval _ start > stop				ifTrue: [self selectAt: altInterval last + 1. UndoInterval]				ifFalse: [altInterval]]		ifFalse:			[morph flash]! !!Editor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 23:49'!selectInterval: anInterval	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	self selectFrom: anInterval first to: anInterval last! !!MenuMorph methodsFor: 'modal control' stamp: 'ar 8/6/2009 18:59'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title w |	title := self allMorphs detect: [ :ea | ea hasProperty: #titleString ].	title := title submorphs first.	self visible: false.	w := ActiveWorld.	aBlock value:[:string|		self visible ifFalse:[			w addMorph: self centeredNear: aPoint.			self visible: true].		title contents: string.		self setConstrainedPosition: Sensor cursorPoint hangOut: false.		self changed.		w displayWorld		 "show myself"	]. 	self delete.	w displayWorld! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 7/29/2009 23:06'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[ sensor keyboardPressed ] whileTrue: [		self deselect.		[ sensor keyboardPressed ] whileTrue: [			char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue: [				self doneTyping.				self storeSelectionInParagraph.				^self].			self openTypeIn].		self hasSelection ifTrue: [ "save highlighted characters"			UndoSelection _ self selection].		self zapSelectionWith: 			(Text string: typeAhead contents attributes: emphasisHere).		typeAhead reset.		self unselect].	self storeSelectionInParagraph! !!TextEditor methodsFor: 'attributes' stamp: 'ar 8/6/2009 19:12'!changeEmphasisOrAlignment	| aList reply  code align menuList startIndex |	startIndex := self startIndex.	aList := #(normal bold italic narrow underlined struckOut leftFlush centered rightFlush justified).		align := paragraph text alignmentAt: startIndex 		ifAbsent: [ paragraph textStyle alignment ].	code := paragraph text emphasisAt: startIndex.	menuList := WriteStream on: Array new.	menuList nextPut: (code isZero ifTrue:['<on>'] ifFalse:['<off>']), 'normal' translated.	menuList nextPutAll: (#(bold italic underlined struckOut) collect:[:emph|		(code anyMask: (TextEmphasis perform: emph) emphasisCode)			ifTrue: [ '<on>', emph asString translated ]			ifFalse: [ '<off>',emph asString translated ]]).	((paragraph text attributesAt: startIndex)		anySatisfy: [ :attr | attr isKern and: [attr kern < 0 ]]) 			ifTrue: [ menuList nextPut:'<on>', 'narrow' translated ]			ifFalse: [ menuList nextPut:'<off>', 'narrow' translated ].	menuList nextPutAll: (#(leftFlush centered rightFlush justified) collectWithIndex: [ :type :i |		align = (i-1)			ifTrue: [ '<on>',type asString translated ]			ifFalse: [ '<off>',type asString translated ]]).	aList := #(normal bold italic underlined struckOut narrow leftFlush centered rightFlush justified).	reply := UIManager default chooseFrom: menuList contents values: aList lines: #(1 6).	reply notNil ifTrue: [		(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue: [				self setAlignment: reply.				paragraph composeAll.				self recomputeInterval]			ifFalse: [				self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection]].	^ true! !!TextEditor methodsFor: 'pluggable menus' stamp: 'jmv 11/4/2008 11:51'!shiftedTextPaneMenuRequest	"The user chose the more... branch from the text-pane menu."	^ self pluggableYellowButtonActivity: true! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!printIt	"Treat the current text selection as an expression; evaluate it. Insert the 	description of the result of evaluation after the selection and then make 	this description the new text selection."	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [morph flash]			ifFalse: [self afterSelectionInsertAndSelect: result printString]! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setLabel	| newLabel |	newLabel := UIManager default		request: 'Please enter a new label for this button'		initialAnswer: self label.	newLabel isEmpty ifFalse: [self labelString: newLabel].! !!StringMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 19:11'!changeEmphasis	| reply aList |	aList := #(normal bold italic narrow underlined struckOut).	reply := UIManager default 		chooseFrom: (aList collect: [:t | t translated]) 		values: aList..	reply ifNotNil:[		self emphasis: (TextEmphasis perform: reply) emphasisCode.	].! !!Editor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 23:13'!selectMark: mark point: point	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(mark =  self markIndex and: [point + 1 = self pointIndex]) ifFalse:		[self deselect.		self selectInvisiblyMark: mark point: point]! !!TextEditor methodsFor: 'undoers' stamp: 'jmv 11/4/2008 11:51'!undoCutCopy: oldPasteBuffer	"Undo of a cut, copy, or any edit that changed CurrentSelection.  Be sure	 undo-copy does not lock the model.  Redoer: itself, so never isRedoing."	| recentCut |	recentCut _ self clipboardText.		UndoSelection size = UndoInterval size		ifFalse: [self replaceSelectionWith: UndoSelection].	self clipboardTextPut: oldPasteBuffer.	self undoer: #undoCutCopy: with: recentCut! !!MenuMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 18:26'!detachSubMenu: evt	| possibleTargets item subMenu index |	possibleTargets := self items select:[:any| any hasSubMenu].	possibleTargets size > 0 ifTrue:[		index := UIManager default 				chooseFrom: (possibleTargets collect:[:t| t contents asString])				title: 'Which menu?'.		index = 0 ifTrue:[^self]].	item := possibleTargets at: index.	subMenu := item subMenu.	subMenu ifNotNil: [		item subMenu: nil.		item delete.		subMenu stayUp: true.		subMenu popUpOwner: nil.		subMenu addTitle: item contents.		evt hand attachMorph: subMenu].! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!selectedSelector	"Try to make a selector out of the current text selection"	^self selection string findSelector! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!offerFontMenu: characterStream 	"The user typed the command key that requests a font change; Offer the font menu.  5/27/96 sw	 Keeps typeahead.  (?? should flush?)"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self offerFontMenu.	^ true! !!Morph methodsFor: 'fileIn/out' stamp: 'ar 8/6/2009 20:42'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream ok |	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := UIManager default request: 'File name? (".morph" will be added to end)' translated 			initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^ Beeper beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.morph'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName,'.morph'].	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!TextEditor methodsFor: 'parenblinking' stamp: 'jmv 11/4/2008 11:51'!blinkParenAt: parenLocation 	self text		addAttribute: TextEmphasis bold		from: parenLocation		to: parenLocation.	lastParenLocation _ parenLocation.! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 11/4/2008 11:51'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!implementorsOfIt	"Open an implementors browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ morph flash].	Smalltalk browseAllImplementorsOf: aSelector! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 3/27/2009 08:41'!crlf: characterStream 	"Append a line feed character to the stream of characters."	sensor keyboard.	characterStream		nextPut: Character cr;		nextPut: Character lf.	^false! !!TextEditor methodsFor: 'as yet unclassified' stamp: 'jmv 11/4/2008 11:51'!totalTextHeight	^paragraph lines last bottom! !!Editor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 23:42'!clipboardTextPut: text	^ Clipboard clipboardText: text! !!ComponentLikeModel methodsFor: 'components' stamp: 'ar 8/6/2009 20:39'!renameMe	| otherNames newName |	otherNames := Set newFrom: self pasteUpMorph allKnownNames.	newName := UIManager default request: 'Please give this new a name'						initialAnswer: self knownName.	newName isEmpty ifTrue: [^ nil].	(otherNames includes: newName) ifTrue:			[self inform: 'Sorry, that name is already used'. ^ nil].	self setNamePropertyTo: newName! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 7/29/2009 22:37'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	self closeTypeIn.	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [ ^true ].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])			and: [ (text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'ar 8/4/2009 23:54'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	defaultLineHeight := scanner computeDefaultLineHeight.	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!Editor methodsFor: 'private' stamp: 'jmv 11/4/2008 23:39'!nextWord: position	| string index |	string _ self string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index + 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index + 1].	^ index! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!again	"Text substitution. If the left shift key is down, the substitution is made 	throughout the entire Paragraph. Otherwise, only the next possible 	substitution is made.	Undoer & Redoer: #undoAgain:andReselect:typedKey:."	"If last command was also 'again', use same keys as before"	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:)! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 7/29/2009 22:37'!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars _ self selection) size = 0		ifTrue:			[currentSelection _ self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size = 2				ifFalse:					[morph flash. ^ true]				ifTrue:					[currentSelection _ self pointIndex - 1]].	aString _ self selection string.	self replaceSelectionWith: (Text string: aString reversed attributes: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!TextMorph methodsFor: 'blinking' stamp: 'ar 12/15/2008 22:49'!startBlinking	self startStepping: #onBlinkCursor 		at: Time millisecondClockValue 		arguments: nil stepTime: 500.	self resetBlinkCursor.! !!Morph methodsFor: 'menus' stamp: 'ar 8/6/2009 20:42'!exportAsGIF	| fName |	fName := UIManager default request:'Please enter the name' translated initialAnswer: self externalName,'.gif'.	fName isEmpty ifTrue:[^self].	GIFReadWriter putForm: self imageForm onFileNamed: fName.! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ paragraph text findString: FindText startingAt: self stopIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	^ true! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'ar 8/6/2009 19:18'!setFontSize	| sizes reply family |	family := font ifNil: [TextStyle default] ifNotNil: [font textStyle].	family ifNil: [family := TextStyle default].  "safety net -- this line SHOULD be unnecessary now"	sizes := 	family fontNamesWithPointSizes.	reply := UIManager default chooseFrom: sizes values: sizes.	reply ifNotNil:		[self font: (family fontAt: (sizes indexOf: reply))]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 11:51'!text	"Answer the text of the paragraph being edited."	^paragraph text! !!PasteUpMorph methodsFor: 'world menu' stamp: 'ar 8/6/2009 20:43'!connectRemoteUserWithName: nameStringOrNil picture: aFormOrNil andIPAddress: aStringOrNil	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials := nameStringOrNil.	initials isEmptyOrNil ifTrue: [		initials := UIManager default request: 'Enter initials for remote user''s cursor?'.	].	initials isEmpty ifTrue: [^ self].  "abort"	addr := 0.	aStringOrNil isEmptyOrNil ifFalse: [		addr := NetNameResolver addressForName: aStringOrNil timeout: 30	].	addr = 0 ifTrue: [		addr := NetNameResolver promptUserForHostAddress.	].	addr = 0 ifTrue: [^ self].  "abort"	RemoteHandMorph ensureNetworkConnected.	h := RemoteHandMorph new userInitials: initials andPicture: aFormOrNil.	self addHand: h.	h changed.	h startListening.	h startTransmittingEventsTo: addr.! !!Morph methodsFor: 'fileIn/out' stamp: 'ar 8/6/2009 20:42'!saveOnURLbasic	"Ask the user for a url and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| url pg stamp pol |	(pg := self valueOfProperty: #SqueakPage) ifNil: [pg := SqueakPage new]		ifNotNil: 			[pg contentsMorph ~~ self 				ifTrue: 					[self inform: 'morph''s SqueakPage property is out of date'.					pg := SqueakPage new]].	(url := pg url) ifNil: 			[url := ServerDirectory defaultStemUrl , '1.sp'.	"A new legal place"			url := UIManager default 						request: 'url of a place to store this object.Must begin with file:// or ftp://'						initialAnswer: url.			url isEmpty ifTrue: [^#cancel]].	stamp := Utilities authorInitialsPerSe ifNil: ['*'].	pg saveMorph: self author: stamp.	SqueakPageCache atURL: url put: pg.	"setProperty: #SqueakPage"	(pol := pg policy) ifNil: [pol := #neverWrite].	pg		policy: #now;		dirty: true.	pg write.	"force the write"	pg policy: pol.	^pg! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!selection	"Answer the text in the paragraph that is currently selected."	^paragraph text copyFrom: self startIndex to: self stopIndex - 1 ! !!Morph methodsFor: 'menus' stamp: 'ar 8/6/2009 20:42'!exportAsPNG	| fName |	fName := UIManager default request:'Please enter the name' translated initialAnswer: self externalName,'.png'.	fName isEmpty ifTrue:[^self].	PNGReadWriter putForm: self imageForm onFileNamed: fName.! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 7/22/2009 21:33'!fillRoundRect: aRectangle radius: radius fillStyle: fillStyle	fillStyle isTransparent ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self fillRectangle: aRectangle fillStyle: fillStyle].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self fillOval: aRectangle fillStyle: fillStyle].	fillStyle isSolidFill 		ifFalse:[^self balloonFillRoundRect: aRectangle radius: radius fillStyle: fillStyle].	self setFillColor: (shadowColor ifNil:[fillStyle asColor]).	^port fillRoundRect: (aRectangle translateBy: origin) truncated radius: radius.! !!ProjectViewMorph methodsFor: 'initialization' stamp: 'ar 8/6/2009 18:33'!dismissViaHalo	| choice |	project ifNil:[^self delete]. "no current project"	choice := UIManager chooseFrom: {		'yes - delete the window and the project' translated.		'no - delete the window only' translated	} title: ('Do you really want to delete {1}and all its content?' translated format: {project name printString}).	choice = 1 ifTrue:[^self expungeProject].	choice = 2 ifTrue:[^self delete].! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!classCommentsContainingIt	"Open a browser class comments which contain the current selection somewhere in them."	self lineSelectAndEmptyCheck: [^ self].	Smalltalk browseClassCommentsWithString: self selection string! !!SystemWindow methodsFor: 'label' stamp: 'jmv 8/6/2009 08:57'!widthOfFullLabelText	^Preferences windowTitleFont widthOfString: labelString! !!NewParagraph methodsFor: 'access' stamp: 'ar 12/15/2008 22:41'!caretRect	"The rectangle in which the caret was last drawn,	 or nil if the last drawing drew a range-selection rather than insertion point."	^ caretRect! !!Editor methodsFor: 'private' stamp: 'jmv 11/4/2008 23:15'!setIndices: shiftPressed forward: forward	"Little helper method that sets the moving and fixed indices according to some flags."	| indices |	indices _ Dictionary new.	(shiftPressed and:[Preferences selectionsMayShrink])		ifTrue: [			indices at: #moving put: self pointIndex.			indices at: #fixed put: self markIndex		] ifFalse: [			forward				ifTrue:[					indices at: #moving put: self stopIndex.					indices at: #fixed put: self startIndex.				] ifFalse: [					indices at: #moving put: self startIndex.					indices at: #fixed put: self stopIndex.				]		].	^indices! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!selectionAsStream	"Answer a ReadStream on the text in the paragraph that is currently 	selected."	^ReadStream		on: (paragraph string copyFrom: self startIndex to: self stopIndex - 1)! !!ProgressBarMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:43'!changeProgressValue: evt	| answer |	answer := UIManager default		request: 'Enter new value (0 - 1.0)'		initialAnswer: self value contents asString.	answer isEmptyOrNil ifTrue: [^ self].	self value contents: answer asNumber! !!Editor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 23:16'!noop: characterStream 	"Unimplemented keyboard command; just ignore it."	sensor keyboard.	  "flush character"	^ true! !!Editor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:24'!selectionInterval	"Answer the interval that is currently selected."	^self startIndex to: self stopIndex - 1 ! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!undoMessage: aMessage forRedo: aBoolean	"Call this from an undoer/redoer to set up UndoMessage as the	 corresponding redoer/undoer.  Also set up UndoParagraph, as well	 as the state variable Undone.  It is assumed that UndoInterval has been	 established (generally by zapSelectionWith:) and that UndoSelection has been	 saved (generally by replaceSelectionWith: or replace:With:and:)."	self isDoing ifTrue: [UndoParagraph _ paragraph].	UndoMessage _ aMessage.	Undone _ aBoolean! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/5/2008 10:07'!cursorPageDown: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine: [:lineNo | lineNo + self pageHeight]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/5/2008 10:22'!cursorTopHome: characterStream 	"Put cursor at beginning of text -- invoked from cmd-H shortcut, useful for keyboards that have no home key."		sensor keyboard.	self selectAt: 1.	^ true! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 11:51'!transformFrom: owner	^morph transformFrom: owner! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!methodStringsContainingIt: characterStream 	"Invoked from cmd-E -- open a browser on all methods holding string constants containing it.  Flushes typeahead. "	sensor keyboard.		self methodStringsContainingit.	^ true! !!Morph methodsFor: 'menus' stamp: 'ar 8/6/2009 20:42'!printPSToFileNamed: aString 	"Ask the user for a filename and print this morph as postscript."	| fileName rotateFlag psCanvasType psExtension |	fileName := aString asFileName.	psCanvasType := PostscriptCanvas defaultCanvasType.	psExtension := psCanvasType defaultExtension.	fileName := UIManager default request: (String streamContents: [ :s |		s nextPutAll: ('File name? ("{1}" will be added to end)' translated format: {psExtension})])			initialAnswer: fileName.	fileName isEmpty		ifTrue: [^ Beeper beep].	(fileName endsWith: psExtension)		ifFalse: [fileName := fileName , psExtension].	rotateFlag := (UIManager default chooseFrom: {		'portrait (tall)' translated.		'landscape (wide)' translated.	} title: 'Choose orientation...' translated) = 2.	((FileStream newFileNamed: fileName asFileName) converter: TextConverter defaultSystemConverter)		nextPutAll: (psCanvasType morphAsPostscript: self rotated: rotateFlag);		 close! !!TextEditor methodsFor: 'as yet unclassified' stamp: 'jmv 11/4/2008 11:51'!visibleHeight	^morph owner bounds height! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!doAgainMany: characterStream 	"Do the previous thing again repeatedly. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: (UndoMessage sends: #undoAgain:andReselect:typedKey:) many: true.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!browseIt: characterStream 	"Triggered by Cmd-B; browse the thing represented by the current selection, if plausible.  1/18/96 sw"	sensor keyboard.		"flush character"	self browseIt.	^ true! !!PasteUpMorph methodsFor: 'options' stamp: 'ar 8/6/2009 20:43'!setThumbnailHeight	|  reply |	(self hasProperty: #alwaysShowThumbnail) ifFalse:		[^ self inform: 'setting the thumbnail height is onlyapplicable when you are currentlyshowing thumbnails.' translated].	reply := UIManager default		request: 'New height for thumbnails? ' translated		initialAnswer: self heightForThumbnails printString.	reply isEmpty ifTrue: [^ self].	reply := reply asNumber.	(reply > 0 and: [reply <= 150]) ifFalse:		[^ self inform: 'Please be reasonable!!' translated].	self setProperty: #heightForThumbnails toValue: reply.	self updateSubmorphThumbnails! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 13:51'!markBlock: aCharacterBlock	markBlock _ aCharacterBlock! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!duplicate: characterStream	"Paste the current selection over the prior selection, if it is non-overlapping and	 legal.  Flushes typeahead.  Undoer & Redoer: undoAndReselect."	sensor keyboard.	self closeTypeIn.	(self hasSelection and: [self isDisjointFrom: otherInterval])		ifTrue: "Something to duplicate"			[self replace: otherInterval with: self selection and:				[self selectAt: self pointIndex]]		ifFalse:			[morph flash].	^true! !!TextEditor methodsFor: 'menu messages' stamp: 'ar 8/6/2009 19:11'!changeAlignment	| aList reply  |	aList := #(leftFlush centered justified rightFlush).	reply := UIManager default chooseFrom: aList values: aList.	reply ifNil:[^self].	self setAlignment: reply.	paragraph composeAll.	self recomputeSelection.	^ true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!chooseColor	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"	| attribute |	(ColorPickerMorph new)		choseModalityFromPreference;		sourceHand: morph activeHand;		target: (attribute := TextColor color: Color black);		selector: #color:;		originalColor: Color black;		putUpFor: morph near: morph fullBoundsInWorld.	"default"	^attribute! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!browseChangeSetsWithSelector	"Determine which, if any, change sets have at least one change for the selected selector, independent of class"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ morph flash].	ChangeSorter browseChangeSetsWithSelector: aSelector! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!find: characterStream	"Prompt the user for what to find, then find it, searching from the current selection onward.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self find.	^ true! !!SketchMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45'!reduceColorPalette: evt	"Let the user ask for a reduced number of colors in this sketch"	| str nColors |	str := UIManager default		request: 'Please enter a number greater than one.(note: this cannot be undone, so answer zeroto abort if you need to make a backup first)' translated		initialAnswer: '256'.	nColors := Integer readFrom: (ReadStream on: str).	(nColors between: 2 and: 256) ifFalse: [^ self].	originalForm := originalForm copyWithColorsReducedTo: nColors.	rotatedForm := nil.	self changed! !!TextMorph class methodsFor: 'preferences' stamp: 'ar 8/6/2009 16:14'!useNewEditors	"Enable/disable the new text editors"	<preference: 'Use New Editors'		category: 'Morphic'		description: 'When true, use the new (Cuis-based) editors'		type: #Boolean>	^DefaultEditorClass == TextEditor! !!TextEditor methodsFor: 'mvc compatibility' stamp: 'jmv 11/4/2008 11:51'!storeSelectionInParagraph	paragraph selectionStart: self startBlock selectionStop: self stopBlock! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-Y."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!isRedoing	"Call from a doer/undoer/redoer any time to see which it is."	^UndoParagraph == #redoing! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainInst: string 	"Is string an instance variable of this class?"	| classes cls |	(model respondsTo: #selectedClassOrMetaClass) ifTrue: [		cls _ model selectedClassOrMetaClass].	cls ifNil: [^ nil].	  "no class known"	classes _ (Array with: cls)				, cls allSuperclasses.	classes _ classes detect: [:each | (each instVarNames			detect: [:name | name = string] ifNone: [])			~~ nil] ifNone: [^nil].	classes _ classes printString.	^ '"is an instance variable of the receiver; defined in class ' , classes , 		'"\' withCRs , classes , ' systemNavigation browseAllAccessesTo: ''' , string , ''' from: ', classes, '.'! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!doAgainOnce: characterStream 	"Do the previous thing again once. 1/26/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self again.	^ true! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!debug: aCompiledMethod receiver: anObject in: evalContext	| selector guineaPig debugger context |	selector _ evalContext isNil ifTrue: [#DoIt] ifFalse: [#DoItIn:].	anObject class addSelectorSilently: selector withMethod: aCompiledMethod.	guineaPig _ evalContext isNil		ifTrue: [[anObject DoIt] newProcess]		ifFalse: [[anObject DoItIn: evalContext] newProcess].	context _ guineaPig suspendedContext.	debugger _ Debugger new		process: guineaPig		controller: nil		context: context.	debugger openFullNoSuspendLabel: 'Debug it'.	[debugger interruptedContext method == aCompiledMethod]		whileFalse: [debugger send].	anObject class basicRemoveSelector: selector! !!NewParagraph methodsFor: 'access' stamp: 'ar 12/15/2008 22:42'!showCaret: aBool	showCaret := aBool! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass)		ifFalse: [^ nil].	(class _ model selectedClassOrMetaClass) ifNil: [^ nil].	"no class is selected"	(class isKindOf: Metaclass)		ifTrue: [class _ class soleInstance].	classes _ (Array with: class)				, class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames detect: [:name | symbol = name]					ifNone: [])					~~ nil]				ifNone: [].	reply == nil ifFalse: [^ '"is a class variable, defined in class ' , reply printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , reply printString , ' classPool associationAt: #' , symbol , ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol)					and: 						[reply _ pool.						true]]			ifNone: [])			~~ nil].	reply		ifNil: [(Undeclared includesKey: symbol)				ifTrue: [^ '"is an undeclared variable.' , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (Undeclared associationAt: #' , symbol , ').']]		ifNotNil: 			[classes _ WriteStream on: Array new.			Smalltalk				allBehaviorsDo: [:each | (each sharedPools						detect: 							[:pool | 							pool == reply]						ifNone: [])						~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^ '"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply) asString , ', which is used by the following classes ' , classes contents printString , '"\' withCRs , 'SystemNavigation new browseAllCallsOn: (' , (Smalltalk keyAtIdentityValue: reply) asString , ' bindingOf: #' , symbol , ').'].	^ nil! !!JoystickMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:41'!setXRange	| range |	range := UIManager default		request:'Type the maximum value for the X axis' translated		initialAnswer: ((xScale * (self width - handleMorph width) / 2.0) roundTo: 0.01) printString.	range isEmpty ifFalse: [		xScale := (2.0 * range asNumber asFloat) / (self width - handleMorph width)].! !!TextEditor methodsFor: 'scrolling' stamp: 'jmv 11/4/2008 11:51'!scrollBy: ignore 	"Ignore scroll requests."! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 3/27/2009 09:55'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites	jmv- Modified to als change crlf by cr"		| fixed |	sensor keyboard.		"flush the triggering cmd-key character"		fixed _ self selection string.	fixed _ fixed copyReplaceAll: String crlf with: String cr.	fixed _ fixed copyReplaceAll: String lf with: String cr. 	self replaceSelectionWith: (Text fromString: fixed).	^ true! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!classNamesContainingIt	"Open a browser on classes whose names contain the selected string"	self lineSelectAndEmptyCheck: [^self].	Smalltalk		browseClassesWithNamesContaining: self selection string		caseSensitive: Sensor leftShiftDown! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 7/29/2009 22:37'!shiftEnclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char _ sensor keyboard.	char = $9 ifTrue: [ char _ $( ].	char = $, ifTrue: [ char _ $< ].	char = $[ ifTrue: [ char _ ${ ].	char = $' ifTrue: [ char _ $" ].	char asciiValue = 27 ifTrue: [ char _ ${ ].	"ctrl-["	self closeTypeIn.	startIndex _ self startIndex.	stopIndex _ self stopIndex.	oldSelection _ self selection.	which _ '([<{"''' indexOf: char ifAbsent: [1].	left _ '([<{"''' at: which.	right _ ')]>}"''' at: which.	text _ paragraph text.	((startIndex > 1 and: [stopIndex <= text size])			and: [ (text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 23:01'!string	^self text string! !!Editor methodsFor: 'private' stamp: 'jmv 11/4/2008 23:02'!previousWord: position	| string index |	string _ self string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index - 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index - 1].	^ index + 1! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 7/29/2009 18:37'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes _ paragraph text attributesAt: self selectionInterval first.	attribute _ TextEmphasis perform: emphasisSymbol.	(emphasisSymbol == #normal) 		ifFalse:	[oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!argAdvance: characterStream	"Invoked by Ctrl-a.  Useful after Ctrl-q.	 Search forward from the end of the selection for a colon followed by		a space.  Place the caret after the space.  If none are found, place the		caret at the end of the text.  Does not affect the undoability of the 	 	previous command."	| start |	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	start _ paragraph text findString: ': ' startingAt: self stopIndex.	start = 0 ifTrue: [start _ paragraph text size + 1].	self selectAt: start + 2.	^true! !!Morph methodsFor: 'meta-actions' stamp: 'ar 8/6/2009 20:14'!inspectAt: aPoint event: evt	| morphs target |	morphs := self morphsAt: aPoint.	(morphs includes: self) ifFalse:[morphs := morphs copyWith: self].	target := UIManager default		chooseFrom: (morphs collect: [:m | m knownName ifNil:[m class name asString]])		values: morphs		title:  ('inspect whom?(deepest at top)').	target ifNil:[^self].	target inspectInMorphic: evt! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 7/29/2009 22:53'!insertTypeAhead: typeAhead	typeAhead position = 0 ifFalse: [		self zapSelectionWith: (Text string: typeAhead contents attributes: emphasisHere).		typeAhead reset.		self unselect]! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/6/2008 15:44'!notify: aString at: anInteger in: aStream 	"The compilation of text failed. The syntax error is noted as the argument, 	aString. Insert it in the text at starting character position anInteger."	| pos |	pos _ self selectionInterval notEmpty		ifTrue: [			self startIndex + anInteger - 1 ]		ifFalse: [anInteger].	self insertAndSelect: aString at: (pos max: 1)! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hiddeninfo.  Copy that to the clipboard.  You can paste it and see what it is.Usually enclosed in <>."	^ self clipboardTextPut: self hiddenInfo asText! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!undoer: aSelector with: arg1 with: arg2 with: arg3	"See comment in undoMessage:.  Use this version when aSelector has three arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2 with: arg3)) forRedo: false! !!Editor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 13:06'!morph: aMorph	"Install a link back to the morph being edited (esp for text links)"	morph _ aMorph ! !!FileList methodsFor: 'private' stamp: 'ar 8/6/2009 20:11'!selectEncoding	| encodingItems |	encodingItems := OrderedCollection new.	TextConverter allSubclasses do: [:each | | names |		names := each encodingNames.		names notEmpty ifTrue: [ | label |			label := '' writeStream.			names do: [:eachName | label nextPutAll: eachName ] separatedBy: [ label nextPutAll: ', '].			encodingItems add: {label contents. names first asSymbol}.		].	].	brevityState := UIManager default		chooseFrom: (encodingItems select:[:spec| spec first])		values: (encodingItems select:[:spec| spec last]).	brevityState ifNil: [brevityState := #needToGetBrief].! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!findAgain: characterStream 	"Find the desired text again.  1/24/96 sw"	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self findAgain.	^ true! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:43'!addUtilities: menu	Preferences simpleMenus ifFalse: [		self			fillIn: menu			from: {				{ 'open...'. { self. #openWindow } }.				{ 'windows...'. { self. #windowsDo } }.				{ 'changes...'. { self. #changesDo } }			} ].	self		fillIn: menu		from: {			{ 'help...'. { self. #helpDo }. 'puts up a menu of useful items for updating the system, determining what version you are running, and much else' }.			{ 'appearance...'. { self. #appearanceDo }. 'put up a menu offering many controls over appearance.' }		}.	Preferences simpleMenus ifFalse: [		self			fillIn: menu			from: {				{ 'do...'. { Utilities. #offerCommonRequests }. 'put up an editible list of convenient expressions, and evaluate the one selected.' }			} ]! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/5/2008 10:40'!cancel: characterStream 	"Cancel unsubmitted changes.  Flushes typeahead.  1/12/96 sw"	sensor keyboard.	self cancel.	^ true! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!chooseAlignment	self changeAlignment! !!TextEditor methodsFor: 'undoers' stamp: 'jmv 11/4/2008 11:51'!undoQuery: hintText lastOffering: selectorOrNil	"Undo ctrl-q.  selectorOrNil (if not nil) is the previously offered selector.	 hintText is the original hint.  Redoer: completeSymbol."	self zapSelectionWith: UndoSelection.	self undoMessage: (Message selector: #completeSymbol:lastOffering: arguments: UndoMessage arguments) forRedo: true.	self selectAt: self stopIndex! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 14:00'!pointIndex: anIndex	self pointBlock: (paragraph characterBlockForIndex: anIndex)! !!Editor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 23:14'!selectInvisiblyMark: mark point: point	"Select the designated characters, inclusive.  Make no visual changes."	self markIndex: mark; pointIndex: point + 1! !!PopUpChoiceMorph methodsFor: 'event handling' stamp: 'ar 8/6/2009 20:17'!mouseDown: evt 	| items selectedItem |	(target isNil or: [getItemsSelector isNil]) ifTrue: [^self].	items := target perform: getItemsSelector withArguments: getItemsArgs.	selectedItem := UIManager default 		chooseFrom: items		values: items.	selectedItem ifNil: [^self].	self contentsClipped: selectedItem.	"Client can override this if necess"	actionSelector ifNotNil: 			[target perform: actionSelector				withArguments: (arguments copyWith: selectedItem)]! !!ImageMorph methodsFor: 'menu commands' stamp: 'ar 8/6/2009 20:40'!readFromFile	| fileName |	fileName := UIManager default		request: 'Please enter the image file name'		initialAnswer: 'fileName'.	fileName isEmpty ifTrue: [^ self].	self image: (Form fromFileNamed: fileName).! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:33'!addProjectEntries: menu	self		fillIn: menu		from: {			nil.			{ 'previous project'. { #myWorld. #goBack }. 'return to the most-recently-visited project' }.			{ 'jump to project...'. { #myWorld. #jumpToProject }. 'put up a list of all projects, letting me choose one to go to' }.			{ 'save project on file...'. { #myWorld. #saveOnFile }. 'save this project on a file' }.			{'load project from file...'. {self. #loadProject}. 'load a project from a file' }.			nil		}! !!TextEditor methodsFor: 'menu messages' stamp: 'ar 8/6/2009 20:45'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply := UIManager default request: 'Find what? ' initialAnswer: ''.	reply size = 0 ifTrue: [		^ self].	self setSearch: reply.	ChangeText := FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true.	morph installEditorToReplace: self! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!cut	"Cut out the current selection and redisplay the paragraph if necessary.  Undoer & Redoer: undoCutCopy:"	self lineSelectAndEmptyCheck: [^ self].	self replaceSelectionWith: self nullText. 	self undoer: #undoCutCopy: with: self clipboardText.	self clipboardTextPut: UndoSelection! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!inOutdent: characterStream delta: delta	"Add/remove a tab at the front of every line occupied by the selection. Flushes typeahead.  Derived from work by Larry Tesler back in December 1985.  Now triggered by Cmd-L and Cmd-R.  2/29/96 sw"	| cr realStart realStop lines startLine stopLine start stop adjustStart indentation size numLines inStream newString outStream |	sensor keyboard.  "Flush typeahead"	cr _ Character cr.	"Operate on entire lines, but remember the real selection for re-highlighting later"	realStart _ self startIndex.	realStop _ self stopIndex - 1.	"Special case a caret on a line of its own, including weird case at end of paragraph"	(realStart > realStop and:				[realStart < 2 or: [(paragraph string at: realStart - 1) == cr]])		ifTrue:			[delta < 0				ifTrue:					[morph flash]				ifFalse:					[self replaceSelectionWith: Character tab asSymbol asText.					self selectAt: realStart + 1].			^true].	lines _ paragraph lines.	startLine _ paragraph lineIndexOfCharacterIndex: realStart.	stopLine _ paragraph lineIndexOfCharacterIndex: (realStart max: realStop).	start _ (lines at: startLine) first.	stop _ (lines at: stopLine) last.		"Pin the start of highlighting unless the selection starts a line"	adjustStart _ realStart > start.	"Find the indentation of the least-indented non-blank line; never outdent more"	indentation _ (startLine to: stopLine) inject: 1000 into:		[:m :l |		m _ m min: (paragraph indentationOfLineIndex: l ifBlank: [:tabs | 1000])].				size _  stop + 1 - start.	numLines _ stopLine + 1 - startLine.	inStream _ ReadStream on: paragraph string from: start to: stop.	newString _ String new: size + ((numLines * delta) max: 0).	outStream _ ReadWriteStream on: newString.	"This subroutine does the actual work"	self indent: delta fromStream: inStream toStream: outStream.	"Adjust the range that will be highlighted later"	adjustStart ifTrue: [realStart _ (realStart + delta) max: start].	realStop _ realStop + outStream position - size.	"Prepare for another iteration"	indentation _ indentation + delta.	size _ outStream position.	inStream _ outStream setFrom: 1 to: size.	outStream == nil		ifTrue: 	"tried to outdent but some line(s) were already left flush"			[morph flash]		ifFalse:			[self selectInvisiblyFrom: start to: stop.			size = newString size ifFalse: [newString _ outStream contents].			self replaceSelectionWith: newString asText].	self selectFrom: realStart to: realStop. 	"highlight only the original range"	^ true! !!Morph methodsFor: 'e-toy support' stamp: 'ar 8/6/2009 20:42'!makeGraphPaper	| smallGrid backColor lineColor |	smallGrid := Compiler evaluate: (UIManager default request: 'Enter grid size' translated initialAnswer: '16').	smallGrid ifNil: [^ self].	Utilities informUser: 'Choose a background color' translated during: [backColor := Color fromUser].	Utilities informUser: 'Choose a line color' translated during: [lineColor := Color fromUser].	self makeGraphPaperGrid: smallGrid background: backColor line: lineColor.! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!sendersOfIt	"Open a senders browser on the selected selector"	| aSelector |	self lineSelectAndEmptyCheck: [^ self].	(aSelector _ self selectedSelector) == nil ifTrue: [^ morph flash].	Smalltalk browseAllCallsOn: aSelector! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 11:51'!cursorDown: characterStream 	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self closeTypeIn: characterStream.	self 		moveCursor:[:position | self				sameColumn: position				newLine:[:line | line + 1]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!TextEditor methodsFor: 'scrolling' stamp: 'jmv 11/4/2008 11:51'!updateMarker	"Ignore scrollbar redraw requests."! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!undo: characterStream 	"Undo the last edit.  Keeps typeahead, so undo twice is a full redo."	sensor keyboard. 	"flush character"	self closeTypeIn: characterStream.	self undo.	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!exploreIt: characterStream 	"Explore the selection -- invoked via cmd-shift-I.  If there is no current selection, use the current line."	sensor keyboard.		"flush character"	self exploreIt.	^ true! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!displayIfTrue: characterStream 	"Replace the current text selection with the text 'ifTrue:'--initiated by 	ctrl-t."	sensor keyboard.		"flush character"	characterStream nextPutAll: 'ifTrue:'.	^false! !!Editor methodsFor: 'private' stamp: 'jmv 11/4/2008 13:41'!sensor: aSensor	"Set the receiver's sensor to aSensor."	sensor _ aSensor! !!Editor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 23:40'!copySelection: characterStream 	"Copy the current text selection.  Flushes typeahead."	sensor keyboard.		"flush character"	self copySelection.	^true! !!TextMorph methodsFor: 'event handling' stamp: 'ar 12/15/2008 23:02'!keyStroke: evt	"Handle a keystroke event."	| action |	self resetBlinkCursor. "don't blink during type-in"	evt keyValue = 13 ifTrue:["CR - check for special action"		action _ self crAction.		action ifNotNil:[			"Note: Code below assumes that this was some			input field reacting on CR. Break the keyboard			focus so that the receiver can be safely deleted."			evt hand newKeyboardFocus: nil.			^action value]].	self handleInteraction: [editor readKeyboard] fromEvent: evt.	"self updateFromParagraph."	super keyStroke: evt  "sends to keyStroke event handler, if any"! !!TextEditor methodsFor: 'pluggable menus' stamp: 'jmv 11/4/2008 11:51'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's popup menu."	| menu |	(menu _ self getPluggableYellowButtonMenu: shiftKeyState)		ifNil:			[sensor waitNoButton]		ifNotNil:			[menu invokeOn: model orSendTo: self]! !!Morph methodsFor: 'card in a stack' stamp: 'ar 8/6/2009 18:28'!abstractAModel	"Find data-containing fields in me.  Make a new class, whose instance variables are named for my fields, and whose values are the values I am showing.  Use a CardPlayer for now.  Force the user to name the fields.  Make slots for text, Number Watchers, SketchMorphs, and ImageMorphs."	| instVarNames unnamed ans player twoListsOfMorphs holdsSepData docks oldPlayer iVarName |	(oldPlayer := self player) ifNotNil: 			[oldPlayer belongsToUniClass 				ifTrue: 					["Player"					oldPlayer class instVarNames notEmpty 						ifTrue: 							[self 								inform: 'I already have a regular Player, so I can''t have a CardPlayer'.							^true]]].	twoListsOfMorphs := StackMorph discoverSlots: self.	holdsSepData := twoListsOfMorphs first.	instVarNames := ''.	holdsSepData do: 			[:ea | 			iVarName := Scanner wellFormedInstanceVariableNameFrom: ea knownName.			iVarName = ea knownName ifFalse: [ea name: iVarName].			instVarNames := instVarNames , iVarName , ' '].	unnamed := twoListsOfMorphs second.	"have default names"	instVarNames isEmpty 		ifTrue: 			[self 				inform: 'No named fields were found.Please get a halo on each field and give it a name.Labels or non-data fields should be named "shared xxx".'.			^false].	unnamed notEmpty 		ifTrue: 			[ans := (UIManager default					chooseFrom: #(						 'All other fields are non-data fields'.						'Stop.  Let me give a name to some more fields'.					) title: 'Data fields are ' , instVarNames printString 								, ('\Some fields are not named.  Are they labels or non-data fields?' 										, '\Please get a halo on each data field and give it a name.') withCRs) = 1.			ans ifFalse: [^false]].	unnamed 		withIndexDo: [:mm :ind | mm setName: 'shared label ' , ind printString].	"Make a Player with instVarNames.  Make me be the costume"	player := CardPlayer instanceOfUniqueClassWithInstVarString: instVarNames				andClassInstVarString: ''.	self player: player.	player costume: self.	"Fill in the instance values.  Make docks first."	docks := OrderedCollection new.	holdsSepData do: 			[:morph | 			morph setProperty: #shared toValue: true.	"in case it is deeply embedded"			morph setProperty: #holdsSeparateDataForEachInstance toValue: true.			player class compileInstVarAccessorsFor: morph knownName.			morph isSyntaxMorph ifTrue: [morph setTarget: player].	"hookup the UpdatingString!!"			docks addAll: morph variableDocks].	player class newVariableDocks: docks.	docks do: [:dd | dd storeMorphDataInInstance: player].	"oldPlayer class mdict do: [:assoc | move to player].	move methods to new class?"	"oldPlayer become: player."	^true	"success"! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!startBlock	^ self pointBlock min: self markBlock! !!Editor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 11/4/2008 15:25'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	11	"page up"	12	"page down"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!Morph methodsFor: 'e-toy support' stamp: 'ar 8/6/2009 18:55'!unlockOneSubpart	| unlockables reply |	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size <= 1 ifTrue: [^ self unlockContents].	reply := UIManager default		chooseFrom: (unlockables collect: [:m | m externalName]) 		values: unlockables		title:  'Who should be be unlocked?' translated.	reply isNil ifTrue: [^ self].	reply unlock! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 7/22/2009 21:35'!balloonFillRoundRect: aRectangle radius: radius fillStyle: fillStyle	^self asBalloonCanvas fillRoundRect: aRectangle radius: radius fillStyle: fillStyle! !!ScriptEditorMorph methodsFor: 'frequency' stamp: 'ar 8/6/2009 20:44'!typeInFrequency	| reply aNumber |	reply := UIManager default request: 'Number of firings per tick: ' translated initialAnswer: self scriptInstantiation frequency printString.	reply ifNotNil:		[aNumber := reply asNumber.		aNumber > 0 ifTrue:			[self setFrequencyTo: aNumber]]! !!Morph methodsFor: 'menus' stamp: 'ar 8/6/2009 20:42'!exportAsJPEG	"Export the receiver's image as a JPEG"	| fName |	fName := UIManager default request: 'Please enter the name' translated initialAnswer: self externalName,'.jpeg'.	fName isEmpty ifTrue: [^ self].	self imageForm writeJPEGfileNamed: fName! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!pasteRecent	"Paste an item chose from RecentClippings."	| clipping |	(clipping _ Clipboard chooseRecentClipping) ifNil: [^ self].	Clipboard clipboardText: clipping.	^ self paste! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 7/22/2009 21:36'!frameRoundRect: aRectangle radius: radius width: borderWidth color: borderColor	"Frame a rounded rectangle with the given attributes."	| innerRect |	(borderWidth isZero or:[borderColor isTransparent])		ifTrue:[^self].	radius asPoint <= (0@0) 		ifTrue:[^self frameRectangle: aRectangle width: borderWidth color: borderColor].	(radius * 2) asPoint >= aRectangle extent 		ifTrue:[^self frameOval: aRectangle width: borderWidth color: borderColor].	"decompose inner rectangle into bezier shape"	innerRect := aRectangle insetBy: borderWidth.	innerRect area <= 0 		ifTrue:[^self fillRoundRect: aRectangle radius: radius fillStyle: borderColor].	self setFillColor: borderColor.	port 		frameRoundRect: (aRectangle translateBy: origin) truncated 		radius: radius truncated 		borderWidth: borderWidth truncated.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setTarget		| newLabel |	newLabel := UIManager default request: 'Enter an expression that create the target' translated initialAnswer: 'World'.	newLabel isEmpty		ifFalse: [self target: (Compiler evaluate: newLabel)]! !!TextEditor methodsFor: 'private' stamp: 'jmv 4/1/2009 21:54'!againOrSame: useOldKeys	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.	 1/26/96 sw: real worked moved to againOrSame:many:"	self againOrSame: useOldKeys many: sensor leftShiftDown.	(morph respondsTo: #editView) 		ifTrue: [morph editView selectionInterval: self selectionInterval]! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!printIt: characterStream 	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	sensor keyboard.		"flush character"	self printIt.	^ true! !!TextEditor methodsFor: 'private' stamp: 'jmv 11/4/2008 11:51'!againOrSame: useOldKeys many: many	"Subroutine of search: and again.  If useOldKeys, use same FindText and ChangeText as before.  If many is true, do it repeatedly.  Created 1/26/96 sw by adding the many argument to #againOrSame."	|  home indices wasTypedKey |	home _ self selectionInterval.  "what was selected when 'again' was invoked"	"If new keys are to be picked..."	useOldKeys ifFalse: "Choose as FindText..."		[FindText _ UndoSelection.  "... the last thing replaced."		"If the last command was in another paragraph, ChangeText is set..."		paragraph == UndoParagraph ifTrue: "... else set it now as follows."			[UndoInterval ~= home ifTrue: [self selectInterval: UndoInterval]. "blink"			ChangeText _ ((UndoMessage sends: #undoCutCopy:) and: [self hasSelection])				ifTrue: [FindText] "== objects signal no model-locking by 'undo copy'"				ifFalse: [self selection]]]. "otherwise, change text is last-replaced text"	(wasTypedKey _ FindText size = 0)		ifTrue: "just inserted at a caret"			[home _ self selectionInterval.			self replaceSelectionWith: self nullText.  "delete search key..."			FindText _ ChangeText] "... and search for it, without replacing"		ifFalse: "Show where the search will start"			[home last = self selectionInterval last ifFalse:				[self selectInterval: home]].	"Find and Change, recording start indices in the array"	indices _ WriteStream on: (Array new: 20). "an array to store change locs"	[(self againOnce: indices) & many] whileTrue. "<-- this does the work"	indices isEmpty ifTrue:  "none found"		[self flash.		wasTypedKey ifFalse: [^self]].	(many | wasTypedKey) ifFalse: "after undo, select this replacement"		[home _ self startIndex to:			self startIndex + UndoSelection size - 1].	self undoer: #undoAgain:andReselect:typedKey: with: indices contents with: home with: wasTypedKey! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!undo	"Reset the state of the paragraph prior to the previous edit.	 If another ParagraphEditor instance did that edit, UndoInterval is invalid;	 just recover the contents of the undo-buffer at the start of the paragraph."	sensor flushKeyboard. "a way to flush stuck keys"	self closeTypeIn.	UndoParagraph == paragraph ifFalse: "Can't undo another paragraph's edit"		[UndoMessage _ Message selector: #undoReplace.		UndoInterval _ 1 to: 0.		Undone _ true].	UndoInterval ~= self selectionInterval ifTrue: "blink the actual target"		[self selectInterval: UndoInterval; deselect].	"Leave a signal of which phase is in progress"	UndoParagraph _ Undone ifTrue: [#redoing] ifFalse: [#undoing].	UndoMessage sentTo: self.	UndoParagraph _ paragraph! !!Editor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 23:13'!selectInvisiblyFrom: start to: stop	"Select the designated characters, inclusive.  Make no visual changes."	self markIndex: start; pointIndex: stop + 1! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!MorphicModel class methodsFor: 'compilation' stamp: 'ar 8/6/2009 20:43'!chooseNewName	"Choose a new name for the receiver, persisting until an acceptable name is provided or until the existing name is resubmitted"	| oldName newName |	oldName := self name.		[newName := (UIManager default request: 'Please give this Model a name'					initialAnswer: oldName) asSymbol.		newName = oldName ifTrue: [^ self].		Smalltalk includesKey: newName]		whileTrue:		[self inform: 'Sorry, that name is already in use.'].	self rename: newName.! !!MenuMorph class methodsFor: 'utilities' stamp: 'ar 8/4/2009 22:39'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice 	"Put up a yes/no menu with caption queryString. The actual wording for the two choices will be as provided in the trueChoice and falseChoice parameters. Answer true if the response is the true-choice,  false if it's the false-choice. This is a modal question -- the user must respond one way or the other."	"MenuMorph 		confirm: 'Are you hungry?'  		trueChoice: 'yes, I''m famished'  		falseChoice: 'no, I just ate'"	| menu aBlock result |	(ProvideAnswerNotification signal: queryString) 		ifNotNilDo:[:answer | ^ trueChoice = answer].	aBlock := [:v| result := v].	menu := self new.	menu addTitle: queryString icon: MenuIcons confirmIcon.	menu add: trueChoice target: aBlock selector: #value: argument: true.	menu add: falseChoice target: aBlock selector: #value: argument: false.	MenuIcons decorateMenu: menu.	[menu invokeAt: ActiveHand position in: ActiveWorld allowKeyboard: true.	result == nil] whileTrue.	^result! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 19:09'!setActWhen	| selections |	selections := #(buttonDown buttonUp whilePressed startDrag).	actWhen := UIManager default 		chooseFrom: (selections collect: [:t | t translated]) 		values: selections		title: 'Choose one of the following conditions' translated.! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 11/4/2008 11:51'!reverseSelection	"Reverse the valence of the current selection highlighting."	selectionShowing _ selectionShowing not.	paragraph reverseFrom: self pointBlock to: self markBlock! !!TextMorph methodsFor: 'blinking' stamp: 'ar 12/15/2008 22:49'!stopBlinking	self stopSteppingSelector: #onBlinkCursor.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:44'!setActionSelector	| newSel |	newSel := UIManager default		request:'Please type the selector to be sent tothe target when this button is pressed' translated		initialAnswer: actionSelector.	newSel isEmpty ifFalse: [self actionSelector: newSel].! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!unselect	self markBlock: self pointBlock copy! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!compareToClipboard: characterStream 	"Compare the receiver to the text on the clipboard.  Flushes typeahead.  5/1/96 sw"	sensor keyboard.		self compareToClipboard.	^ true! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/6/2008 15:43'!nextTokenFrom: start direction: dir	"simple token-finder for compiler automated corrections"	| loc str |	loc _ start + dir.	str _ paragraph text string.	[(loc between: 1 and: str size) and: [(str at: loc) isSeparator]]		whileTrue: [loc _ loc + dir].	^ loc! !!TextEditor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 11:51'!search: characterStream	"Invoked by Ctrl-S.  Same as 'again', but always uses the existing FindText	 and ChangeText regardless of the last edit."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self againOrSame: true. "true means use same keys"	^true! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jmv 7/21/2009 12:35'!initializeShiftedYellowButtonMenu	"Initialize the yellow button pop-up menu and corresponding messages."	"TextEditor initialize"	"	shiftedYellowButtonMenu _ SelectionMenu fromArray: {		{'set font... (k)' translated.					#offerFontMenu}.		{'set style... (K)' translated.				#changeStyle}.		{'set alignment...' translated.				#chooseAlignment}.		#-.		{'more...' translated.						#yellowButtonActivity}.	}	"	shiftedYellowButtonMenu _ yellowButtonMenu! !!TextEditor methodsFor: 'events' stamp: 'jmv 5/10/2009 10:11'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint b |	oldInterval _ self selectionInterval.	clickPoint _ evt cursorPoint.	b _ paragraph characterBlockAtPoint: clickPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [		self markBlock: b.		self pointBlock: b.		evt hand releaseKeyboardFocus: self.		^ self ].		"If click is inside the selection, do not modify it.	This is so the 'tap and wait' gesture (used to bring pop-up menu	on pen devices) does not affect selection, allowing to do copy / paste	of selection with menu on pen devices."	(oldInterval includes: b stringIndex) ifTrue: [ ^self ].		evt shiftPressed		ifFalse: [			self closeTypeIn.			self markBlock: b.			self pointBlock: b ]		ifTrue: [			self closeTypeIn.			self mouseMove: evt ].	self storeSelectionInParagraph! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!doIt	"Set the context to include pool vars of the model.  Then evaluate."	^ self evaluateSelection! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 11:51'!setSearch: aString	"Set the FindText and ChangeText to seek aString; except if already seeking aString, leave ChangeText alone so again will repeat last replacement."	FindText string = aString		ifFalse: [FindText _ ChangeText _ aString asText]! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 11/4/2008 11:51'!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInBlock ~~ nil ifTrue: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection _ self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!SketchMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:45'!addBorderToShape: evt	| str borderWidth borderedForm r |	str := UIManager default		request: 'Please enter the desired border width' translated		initialAnswer: '0'.	borderWidth := Integer readFrom: (ReadStream on: str).	(borderWidth between: 1 and: 10) ifFalse: [^ self].	"Take care of growing appropriately.  Does this lose the reg point?"	borderedForm := originalForm shapeBorder: Color black width: borderWidth.	r := borderedForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (borderedForm copy: r).! !!TextEditor methodsFor: 'undoers' stamp: 'jmv 11/4/2008 11:51'!undoReplace	"Undo of any command that replaced a selection by other text that it left	 highlighted, and that is undone and redone by simple reversal of the	 operation.  This is the most common Undoer; call replaceSelectionWith:	 to get this setup.  Redoer: itself, so never isRedoing."	self replaceSelectionWith: UndoSelection! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 15:31'!normalCharacter: characterStream 	"A nonspecial character is to be added to the stream of characters."	characterStream nextPut: sensor keyboard.	^false! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 8/4/2009 20:48'!helpMenu        "Build the help menu for the world."        |  menu |  	menu := self menu: 'help...'.        self fillIn: menu from:        {                {'about this system...'. {SmalltalkImage current. #aboutThisSystem}. 'current version information.'}.                {'update code from server'. {Utilities. #updateFromServer}. 'load latest code updates via the internet'}.                {'preferences...'. {self. #openPreferencesBrowser}. 'view and change various options.'}.			 {'set language...' . {Project. #chooseNaturalLanguage}. 'choose the language in which tiles should be displayed.'} .                nil.               {'command-key help'. { Utilities . #openCommandKeyHelp}. 'summary of keyboard shortcuts.'}	}.	self addGestureHelpItemsTo: menu.	self fillIn: menu from:	{                {'world menu help'. { self . #worldMenuHelp}. 'helps find menu items buried in submenus.'}.                        "{'info about flaps' . { Utilities . #explainFlaps}. 'describes how to enable and use flaps.'}."                {'font size summary' . { TextStyle . #fontSizeSummary}.  'summary of names and sizes of available fonts.'}.                {'useful expressions' . { Utilities . #openStandardWorkspace}. 'a window full of useful expressions.'}.			 {'annotation setup...' . { Preferences . #editAnnotations}. 'Click here to get a little window that will allow you to specify which types of annotations, in which order, you wish to see in the annotation panes of browsers and other tools'}.			nil.                {'graphical imports' . { Imports default . #viewImages}.  'view the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList'}.                {'standard graphics library' . { ScriptingSystem . #inspectFormDictionary}.  'lets you view and change the system''s standard library of graphics.'}.                nil.                {'telemorphic...' . {self. #remoteDo}.  'commands for doing multi-machine "telemorphic" experiments'}.                {#soundEnablingString . { Preferences . #toggleSoundEnabling}. 'turning sound off will completely disable Squeak''s use of sound.'}.                nil.                {'set author initials...' . { Utilities . #setAuthorInitials }. 'supply initials to be used to identify the author of code and other content.'}.                {'vm statistics' . { self . #vmStatistics}.  'obtain some intriguing data about the vm.'}.			  nil.			  {'purge undo records' . { CommandHistory . #resetAllHistory }. 'save space by removing all the undo information remembered in all projects.'}.                {'space left' . { self . #garbageCollect}. 'perform a full garbage-collection and report how many bytes of space remain in the image.'}.        }.	^menu! !!TheWorldMenu methodsFor: 'commands' stamp: 'ar 8/4/2009 20:49'!openPreferencesBrowser	"Open a preferences browser"	^PreferenceBrowser open! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!prettyPrint	self prettyPrint: false! !!TextEditor methodsFor: 'editing keys' stamp: 'ar 8/6/2009 18:36'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis. Emphasis change amounts to a font change.  Keeps typeahead."	"control 0..9 -> 0..9"	| keyCode attribute oldAttributes index thisSel colors |	keyCode := ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes := paragraph text attributesAt: self pointIndex.	thisSel := self selection.	"Decipher keyCodes for Command 0-9..."	"	(keyCode between: 1 and: 5) 		ifTrue: [attribute := TextFontChange fontNumber: keyCode].	"	keyCode = 6 		ifTrue: [			colors := #(#black #magenta #red #yellow #green #blue #cyan #white).			index := UIManager chooseFrom:colors , #('choose color...' )						lines: (Array with: colors size + 1).			index = 0 ifTrue: [^true].			index <= colors size 				ifTrue: [attribute := TextColor color: (Color perform: (colors at: index))]				ifFalse: [					index := index - colors size - 1.	"Re-number!!!!!!"					index = 0 ifTrue: [attribute := self chooseColor].					thisSel ifNil: [^true]	"Could not figure out what to link to"]].	(keyCode between: 7 and: 11) 		ifTrue: [			sensor leftShiftDown 				ifTrue: [					keyCode = 10 ifTrue: [attribute := TextKern kern: -1].					keyCode = 11 ifTrue: [attribute := TextKern kern: 1]]				ifFalse: [					attribute := TextEmphasis 								perform: (#(#bold #italic #narrow #underlined #struckOut) at: keyCode - 6).					oldAttributes 						do: [:att | (att dominates: attribute) ifTrue: [attribute turnOff]]]].	keyCode = 0 ifTrue: [attribute := TextEmphasis normal].	attribute ifNotNil: [		thisSel size = 0			ifTrue: [				"only change emphasisHere while typing"				self insertTypeAhead: characterStream.				emphasisHere _ Text addAttribute: attribute toArray: oldAttributes ]			ifFalse: [				self replaceSelectionWith: (thisSel asText addAttribute: attribute) ]].	^true! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 7/30/2009 20:17'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	self storeSelectionInParagraph.	"Preserve current emphasis if selection is empty"	stop > start ifTrue: [		self setEmphasisHere ]! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	classes _ Smalltalk allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!undoer: aSelector with: arg1 with: arg2	"See comment in undoMessage:.  Use this version when aSelector has two arguments, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector arguments: (Array with: arg1 with: arg2)) forRedo: false! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:05'!makeConvenient: menu	self		fillIn: menu		from: {			{ 'Browser'. { Browser. #open }. 'open a browser' }.			{ 'Workspace'. { Workspace. #open }. 'open a workspace' }.			{ 'Transcript'. { Transcript. #open }. 'open a transcript' }.			{ 'Test Runner'. { TestRunner. #open }. 'open a test runner' }.			nil		}! !!TextEditor methodsFor: 'do-its' stamp: 'jmv 11/4/2008 11:51'!debugIt	| method receiver context |	(model respondsTo: #doItReceiver) 		ifTrue: 			[FakeClassPool adopt: model selectedClass.			receiver _ model doItReceiver.			context _ model doItContext]		ifFalse:			[receiver _ context _ nil].	self lineSelectAndEmptyCheck: [^self].	method _ self compileSelectionFor: receiver in: context.	method notNil ifTrue:		[self debug: method receiver: receiver in: context].	FakeClassPool adopt: nil! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 23:48'!selectAll	self selectFrom: 1 to: self string size! !!TextEditor methodsFor: 'current selection' stamp: 'jmv 11/4/2008 14:28'!recomputeInterval	"The same characters are selected but their coordinates may have changed."	self markIndex: self markIndex; pointIndex: self pointIndex! !!TextEditor methodsFor: 'undo support' stamp: 'jmv 11/4/2008 11:51'!undoer: aSelector with: arg1	"See comment in undoMessage:.  Use this version when aSelector has one argument, and you are doing or redoing and want to prepare for undoing."	self undoMessage: (Message selector: aSelector argument: arg1) forRedo: false! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!findAgain	"Find the text-to-find again.  1/24/96 sw"	self againOrSame: true! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 11/4/2008 11:51'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	sensor keyboard.  "consume enter key"	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self accept].	^ true! !!JoystickMorph methodsFor: 'menu' stamp: 'ar 8/6/2009 20:41'!chooseJoystickNumber	"Allow the user to select a joystick number"	| result aNumber str |	str := self lastRealJoystickIndex asString.	result := UIManager default 				request: ('Joystick device number (currently {1})' translated format: {str})				initialAnswer: str.	[aNumber := result asNumber] on: Error do: [:err | ^Beeper beep].	(aNumber > 0 and: [aNumber <= 32]) 		ifFalse: 			["???"			^Beeper beep].	realJoystickIndex := aNumber.	self setProperty: #lastRealJoystickIndex toValue: aNumber.	self startStepping! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 7/29/2009 22:20'!setAlignment: aSymbol	| attr interval |	attr _ TextAlignment perform: aSymbol.	interval _ self encompassLine: self selectionInterval.	paragraph 		replaceFrom: interval first 		to: interval last 		with: ((paragraph text copyFrom: interval first to: interval last) addAttribute: attr)! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!referencesToIt: characterStream 	"Triggered by Cmd-N; browse references to the current selection"	sensor keyboard.		"flush character"	self referencesToIt.	^ true! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!stopBlock	^ self pointBlock max: self markBlock! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!explain	"Try to shed some light on what kind of entity the current selection is. 	The selection must be a single token or construct. Insert the answer after 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply symbol |Cursor execute showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry _ sorry , (morph canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: [string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are all letters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol _ s])						ifTrue: [cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [										selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 3/27/2009 08:36'!lf: characterStream 	"Append a line feed character to the stream of characters."	sensor keyboard.	characterStream nextPut: Character lf.	^false! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 11:51'!selectPrecedingIdentifier	"Invisibly select the identifier that ends at the end of the selection, if any."	| string sep stop tok |	tok _ false.	string _ paragraph text string.	stop _ self stopIndex - 1.	[stop > 0 and: [(string at: stop) isSeparator]] whileTrue: [stop _ stop - 1].	sep _ stop.	[sep > 0 and: [(string at: sep) tokenish]] whileTrue: [tok _ true. sep _ sep - 1].	tok ifTrue: [self selectInvisiblyFrom: sep + 1 to: stop]! !!TextEditor methodsFor: 'accessing-selection' stamp: 'jmv 11/4/2008 11:51'!startIndex	^ self startBlock stringIndex! !!TextEditor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 11:51'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self closeTypeIn: characterStream.	prior _ otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval _ prior.	^ true! !!Editor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 23:10'!selectAt: characterIndex 	"Deselect, then place the caret before the character at characterIndex.	 Be sure it is in view."	self selectFrom: characterIndex to: characterIndex - 1! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!spawn	"Create and schedule a message browser for the code of the model's 	selected message. Retain any edits that have not yet been accepted."	| code |	code _ paragraph text string.	self cancel.	model spawn: code.! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/5/2008 10:08'!cursorDown: characterStream 	"Private - Move cursor from position in current line to same position in	next line. If next line too short, put at end. If shift key down,	select."	self closeTypeIn: characterStream.	self 		moveCursor:[:position | self				sameColumn: position				newLine:[:line | line + 1]				forward: true]		forward: true		specialBlock:[:dummy | dummy].	^true! !!PasteUpMorph methodsFor: 'objects from disk' stamp: 'ar 8/6/2009 20:43'!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  UniClasses will be filed out."	| aFileName fileStream ok |	self flag: #bob0302.	self isWorldMorph ifTrue: [^self project saveAs].	aFileName := ('my {1}' translated format: {self class name}) asFileName.	"do better?"	aFileName := UIManager default request: 'File name? (".project" will be added to end)' translated 			initialAnswer: aFileName.	aFileName isEmpty ifTrue: [^ Beeper beep].	self allMorphsDo: [:m | m prepareToBeSaved].	ok := aFileName endsWith: '.project'.	"don't double them"	ok := ok | (aFileName endsWith: '.sp').	ok ifFalse: [aFileName := aFileName,'.project'].	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self.	"Puts UniClass definitions out anyway"! !!MenuMorph methodsFor: 'modal control' stamp: 'ar 8/4/2009 22:39'!invokeAt: aPoint in: aWorld allowKeyboard: aBoolean	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	| w originalFocusHolder |	originalFocusHolder := aWorld primaryHand keyboardFocus.	self popUpAt: aPoint forHand: aWorld primaryHand in: aWorld allowKeyboard: aBoolean.	w := aWorld outermostWorldMorph. "containing hand"	[self isInWorld] whileTrue: [w doOneSubCycle].	self delete.	originalFocusHolder ifNotNil: [aWorld primaryHand newKeyboardFocus: originalFocusHolder].! !!Morph methodsFor: 'meta-actions' stamp: 'ar 8/6/2009 20:42'!makeMultipleSiblings: evt	"Make multiple siblings, first prompting the user for how many"	| result |	self topRendererOrSelf couldMakeSibling ifFalse: [^ Beeper beep].	result := UIManager default request: 'how many siblings do you want?' translated initialAnswer: '2'.	result isEmptyOrNil ifTrue: [^ self].	result first isDigit ifFalse: [^ Beeper beep].	self topRendererOrSelf makeSiblings: result asInteger.! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/5/2008 10:07'!cursorPageUp: characterStream 	self closeTypeIn: characterStream.	self 		moveCursor: [:position |			self				sameColumn: position				newLine: [:lineNo | lineNo - self pageHeight]				forward: false]		forward: false		specialBlock:[:dummy | dummy].	^true! !!TextEditor methodsFor: 'editing keys' stamp: 'jmv 11/4/2008 11:51'!implementorsOfIt: characterStream 	"Triggered by Cmd-m; browse implementors of the selector represented by the current selection, if plausible. 2/1/96 sw"	sensor keyboard.		"flush character"	self implementorsOfIt.	^ true! !!TextEditor methodsFor: 'typing support' stamp: 'jmv 7/30/2009 00:46'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock ifNil: [		UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ self startIndex]! !!TextEditor methodsFor: 'explain' stamp: 'jmv 11/4/2008 11:51'!explainNumber: string 	"Is string a Number?"	| strm c |	(c _ string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])			ifFalse: [^nil]].	strm _ ReadStream on: string.	c _ Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!TextEditor methodsFor: 'new selection' stamp: 'jmv 11/4/2008 11:51'!insertAndSelect: aString at: anInteger	self replace: (anInteger to: anInteger - 1)		with: (Text string: (' ' , aString)					attributes: emphasisHere)		and: [self ]! !!MenuMorph class methodsFor: 'utilities' stamp: 'ar 8/5/2009 01:10'!confirm: queryString orCancel: cancelBlock 	"Put up a yes/no/cancel menu with caption aString. Answer true if  the response is yes, false if no. If cancel is chosen, evaluate cancelBlock. This is a modal question--the user must respond yes or no."	"MenuMorph confirm: 'Reboot universe' orCancel:[^'Nevermind'] "	| choice |	choice := self chooseFrom: {'Yes' translated. 'No' translated. 'Cancel' translated}		lines: #()		title: queryString.	choice = 1 ifTrue: [^ true].	choice = 2 ifTrue: [^ false].	^ cancelBlock value! !!TheWorldMenu methodsFor: 'construction' stamp: 'mha 2/3/2009 16:40'!addObjectsAndTools: menu	self		fillIn: menu		from: {			nil.			{ 'objects (o)'. { #myWorld. #activateObjectsTool }. 'A tool for finding and obtaining many kinds of objects' }.			{ 'new morph...'. { self. #newMorph }. 'Offers a variety of ways to create new objects' }.			nil.			{ 'authoring tools...'. { self. #scriptingDo }. 'A menu of choices useful for authoring' }.			{ 'playfield options...'. { self. #playfieldDo }. 'A menu of options pertaining to this object as viewed as a playfield' }.			{ 'flaps...'. { self. #flapsDo }. 'A menu relating to use of flaps.  For best results, use "keep this menu up"' }.			{ 'projects...'. { self. #projectDo }. 'A menu of commands relating to use of projects' }.			nil		}! !!TextEditor methodsFor: 'menu messages' stamp: 'jmv 11/4/2008 11:51'!methodSourceContainingIt	"Open a browser on methods which contain the current selection in their source (case-sensitive full-text search of source).   EXTREMELY slow!!"	self lineSelectAndEmptyCheck: [^ self].	(self confirm: 'This will take a few minutes.Shall I proceed?') ifFalse: [^ self].	Smalltalk browseMethodsWithSourceString: self selection string! !!TheWorldMenu methodsFor: 'commands' stamp: 'ar 8/6/2009 19:15'!cleanUpWorld	(UIManager default confirm:'This will remove all windows except thosecontaining unsubmitted text edits, and willalso remove all non-window morphs (otherthan flaps) found on the desktop.  Are yousure you want to do this?' translated)		ifFalse: [^ self].	myWorld allNonFlapRelatedSubmorphs do:		[:m | m delete].	(SystemWindow windowsIn: myWorld satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!Editor methodsFor: 'typing/selecting keys' stamp: 'jmv 11/4/2008 23:27'!backWord: characterStream 	"If the selection is not a caret, delete it and leave it in the backspace buffer.	 Else if there is typeahead, delete it.	 Else, delete the word before the caret."	| startIndex |	sensor keyboard.	characterStream isEmpty		ifTrue:			[self hasCaret				ifTrue: "a caret, delete at least one character"					[startIndex _ 1 max: self markIndex - 1.					[startIndex > 1 and:						[(self string at: startIndex - 1) tokenish]]						whileTrue:							[startIndex _ startIndex - 1]]				ifFalse: "a non-caret, just delete it"					[startIndex _ self markIndex].			self backTo: startIndex]		ifFalse:			[characterStream reset].	^false! !!Editor methodsFor: 'nonediting/nontyping keys' stamp: 'jmv 11/4/2008 23:15'!cursorLeft: characterStream 	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	self closeTypeIn: characterStream.	self		moveCursor:[:position | position - 1 max: 1]		forward: false		specialBlock:[:position | self previousWord: position].	^ true! !!TextEditor methodsFor: 'private' stamp: 'jmv 7/29/2009 22:36'!nullText	^Text string: '' attributes: emphasisHere! !TextEditor initialize!Editor initialize!TextMorph initialize!