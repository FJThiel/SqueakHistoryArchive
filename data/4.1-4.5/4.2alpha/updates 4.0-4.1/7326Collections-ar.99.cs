"Change Set:		7326Collections-ar.99Collections-ar.99:Underscore cleanup."!!WriteStream methodsFor: 'accessing' stamp: 'BG 5/24/2003 20:41'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse:		[^ super nextPutAll: aCollection ].	newEnd := position + aCollection size.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: 1.	position := newEnd.! !!SparseLargeTable methodsFor: 'accessing' stamp: 'kwl 6/30/2006 03:02'!zapDefaultOnlyEntries	| lastIndex newInst |	1 to: self basicSize do: [:i |		(self allDefaultValueSubtableAt: i) ifTrue: [self basicAt: i put: nil].	].	lastIndex := self findLastNonNilSubTable.	lastIndex = 0 ifTrue: [^ self].		newInst := self class new: lastIndex*chunkSize chunkSize: chunkSize arrayClass: (self basicAt: lastIndex) class base: base defaultValue: defaultValue.	newInst privateSize: self size.	base to: newInst size do: [:i | newInst at: i put: (self at: i)].	1 to: newInst basicSize do: [:i |		(newInst allDefaultValueSubtableAt: i) ifTrue: [newInst basicAt: i put: nil].	].	" this is not allowed in production: self becomeForward: newInst. "	^ newInst.! !!WriteStream methodsFor: 'private' stamp: 'BG 5/24/2003 22:49'!growTo: anInteger   " anInteger is the required minimal new size of the collection "	| oldSize grownCollection newSize |	oldSize := collection size.     newSize := anInteger + (oldSize // 4 max: 20).	grownCollection := collection class new: newSize.	collection := grownCollection replaceFrom: 1 to: oldSize with: collection startingAt: 1.	writeLimit := collection size.! !!Interval methodsFor: 'accessing' stamp: 'BG 6/15/2004 22:58'!indexOf: anElement startingAt: startIndex ifAbsent: exceptionBlock   "  startIndex is an positive integer, the collection index where the search is started. "   " during the computation of  val , floats are only used when the receiver contains floats "   | index val |   (self rangeIncludes: anElement)       ifFalse: [^0].   	val := (anElement - self first)  / self increment.	val fractionPart abs * 100000000 < step abs	  ifFalse: [^0]	  ifTrue: [index := val rounded + 1].   " finally, the value of  startIndex  comes into play: "   ^index < startIndex      ifTrue: [0]      ifFalse: [index].! !!CharacterSet methodsFor: 'conversion' stamp: 'nice 3/23/2007 02:28'!byteComplement	"return a character set containing precisely the single byte characters the receiver does not"		| set |	set := CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!WriteStream methodsFor: 'accessing' stamp: 'BG 5/26/2003 08:01'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	| newEnd |	collection class == aCollection class ifFalse:		[^ super next: anInteger putAll: aCollection startingAt: startIndex].	newEnd := position + anInteger.	newEnd > writeLimit ifTrue:		[self growTo: newEnd + 10].	collection replaceFrom: position+1 to: newEnd  with: aCollection startingAt: startIndex.	position := newEnd.	^aCollection! !