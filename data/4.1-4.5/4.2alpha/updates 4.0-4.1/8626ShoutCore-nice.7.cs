"Change Set:		8626ShoutCore-nice.7ShoutCore-nice.7:Cosmetic: move or remove a few temps inside closuresShoutCore-nice.6:Let #evaluateWithoutStyling: answer the result of evaluating the block argument"!!SHTextStyler methodsFor: 'styling' stamp: 'nice 12/26/2009 21:38'!evaluateWithoutStyling: aBlock	| t |	t := stylingEnabled.	^[stylingEnabled := false.	aBlock value]		ensure: [stylingEnabled := t]! !!SHParserST80 methodsFor: 'parse' stamp: 'nice 12/27/2009 03:12'!parseKeyword     | keyword rangeIndices |    self parseBinary.	keyword := ''.	rangeIndices := #().	[    		[self isKeyword]        		whileTrue: [				keyword := keyword, currentToken. 				self rangeType: #keyword.				"remember where this keyword token is in ranges"				rangeIndices := rangeIndices copyWith: ranges size.				self scanNext.				self parseTerm.				self parseBinary ]	] ensure: [ | type |		"do this in an ensure so that it happens even if the errorBlock evaluates before getting here"		"patch up the keyword tokens, so that incomplete and undefined ones look different"		(keyword isEmpty or:[Symbol hasInterned: keyword ifTrue: [:sym | ]])			ifFalse:[				type := (Symbol thatStartsCaseSensitive: keyword skipping: nil) isNil					ifTrue: [#undefinedKeyword]					ifFalse:[#incompleteKeyword].				rangeIndices do: [:i | (ranges at: i) type: type]]]! !!SHTextStylerST80 methodsFor: 'private' stamp: 'nice 12/27/2009 03:12'!replaceStringForRangesWithType: aSymbol with: aString in: aText 	"Answer aText if no replacements, or a copy of aText with 	each range with a type of aSymbol replaced by aString"	| answer toReplace adjustSourceMap increaseInLength |		toReplace := (self rangesIn: aText setWorkspace: false) 		select: [:each | each type = aSymbol].	toReplace isEmpty ifTrue: [^aText].	answer := aText copy.	increaseInLength := 0.	adjustSourceMap := sourceMap notNil and:[sourceMap ~~ processedSourceMap].	(toReplace asSortedCollection: [:a :b | a start <= b start]) 		do: [:each | | end start thisIncrease | 			start := each start + increaseInLength.			end := each end + increaseInLength.			answer 	replaceFrom: start to: end with: aString.			thisIncrease := aString size - each length.			increaseInLength := increaseInLength + thisIncrease.			adjustSourceMap ifTrue:[				sourceMap do:[:assoc | | first newFirst last newLast |					first := newFirst := assoc value first.					last := newLast := assoc value last.					first > start ifTrue:[newFirst := first + thisIncrease].					last > start ifTrue:[newLast := last + thisIncrease].					(first ~= newFirst or:[last ~= newLast])						ifTrue:[assoc value: (newFirst to: newLast)]]]].	adjustSourceMap ifTrue:[processedSourceMap := sourceMap]. 	^answer! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'nice 12/27/2009 03:12'!initialTextAttributesForPixelHeight: aNumber	| d |	 	d := IdentityDictionary new.	self styleTable do: [:each | | textStyle element emphasis font pixelHeight attrArray color textStyleName |		element := each first.		color := each at: 2 ifAbsent:[nil].		color:=color ifNotNil: [Color colorFrom: color].		emphasis := each at: 3 ifAbsent:[nil].		textStyleName := each at: 4 ifAbsent: [nil].		pixelHeight := each at: 5 ifAbsent: [aNumber].			textStyleName ifNil:[pixelHeight := nil].			textStyle := TextStyle named: textStyleName.		font := textStyle ifNotNil:[pixelHeight ifNotNil:[textStyle fontOfSize: pixelHeight]].		attrArray := self attributeArrayForColor: color emphasis: emphasis font: font.		attrArray notEmpty 			ifTrue:[				d at: element put: attrArray]].	^d		! !