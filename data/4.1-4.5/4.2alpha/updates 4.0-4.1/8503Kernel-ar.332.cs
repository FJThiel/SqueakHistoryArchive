"Change Set:		8503Kernel-ar.332Kernel-ar.332:CompiledMethodTrailer phase 1: Main classesKernel-bs.330:fixed AdditionalMethodState >> #at:put to make newly added test greenKernel-dtl.331:Add BlockClosure>>sender required for MessageTally class>>tallySends:Harvested from Pharo (nice 4/14/2009 19:09)."!CompiledMethodTrailer subclass: #OldMethodTrailer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!Object subclass: #CompiledMethodTrailer	instanceVariableNames: 'data encodedData kind size method'	classVariableNames: ''	poolDictionaries: ''	category: 'Kernel-Methods'!!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 16:45'!size	"Answer the size of method's trailer , in bytes"	^ size! !!CompiledMethodTrailer methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 12/13/2009 11:51'!initialize	self clear! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/20/2009 21:36'!decodeSourceByStringIdentifier	"A method source is determined by a class + string identifier"	| len |		len := self decodeLengthField.	data := (ReadStream on: method from: method size - size+1 to: method size - size + len) contents asString convertFromEncoding: 'utf8'! !!CompiledMethodTrailer methodsFor: 'private' stamp: 'Igor.Stasenko 12/20/2009 21:32'!encodeUsingZip	"data is string, encode it using gzip compression"	| utf8str stream length encodedLength |	self assert: (data isString).	utf8str := data convertToEncoding: 'utf8'.		stream := ((ZipWriteStream on: (ByteArray new: utf8str size))		nextPutAll: utf8str asByteArray;		close;		encodedStream).			length := stream position.	encodedLength := self encodeLengthField: length.	stream nextPutAll: encodedLength.	"trailing byte"	stream nextPut: (self kindAsByte + encodedLength size - 1).		encodedData := stream contents	! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 15:50'!endPC	"Answer the index of the last bytecode."		method ifNil: [ self error: 'Cannot determine the endPC without compiled method' ].		"if method set, then size should be set as well"	^ method size - size! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 07:07'!encodeOldEmptyTrailer	encodedData := #(0 0 0 0).	! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 11:27'!sourcePointer	^ (kind == #SourcePointer or: [ kind == #VarLengthSourcePointer ] )		ifTrue: [ data ]		ifFalse: [ 0 ]! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/20/2009 21:33'!qDecompress 	"Trailer is compressed string using qCompress method + length field + 1 byte		Decompress strings compressed by qCompress:.	Most common 11 chars get values 0-10 packed in one 4-bit nibble;	next most common 52 get values 12-15 (2 bits) * 16 plus next nibble;	escaped chars get three nibbles"	| len str input |		len := self decodeLengthField. 	input := (ReadStream on: method from: method size - size+1 to: method size - size + len).		str := String streamContents:		[:strm | | nextNibble nibble peek charTable |		charTable :=  "Character encoding table must match qCompress:"		'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'.		peek := true.		nextNibble := [peek						ifTrue: [peek := false. input peek ifNil: [0] ifNotNil: [:b| b // 16]]						ifFalse: [peek := true. input next ifNil: [0] ifNotNil: [:b| b \\ 16]]].		[input atEnd] whileFalse:			[(nibble := nextNibble value) = 0				ifTrue: [input atEnd ifFalse:						[strm nextPut: (Character value: nextNibble value * 16 + nextNibble value)]]				ifFalse:					[nibble <= 11						ifTrue:							[strm nextPut: (charTable at: nibble)]						ifFalse:							[strm nextPut: (charTable at: nibble-12 * 16 + nextNibble value)]]]].				data := str convertFromEncoding: 'utf8'! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 11:25'!decodeSourcePointer	"Trailer is a source pointer"	| msz |		size := 4.	msz := method size.	data := (method at: msz) - 251 << 8 + (method at: msz-1) << 8	 + (method at: msz-2) << 8 + (method at: msz-3).	! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 21:49'!setSourceBySelector	"Trailer is used to indicate that method's source code can be retrieved by 	sending #getSourceCodeBySelector: message to method's class" 		self clear.	kind := #SourceBySelector! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 19:34'!decodeVarLengthSourcePointer	| pos shift |		pos := method size-1.	shift := data := 0.		[ | value | 		value := method at: pos.		data := (value bitAnd: 16r7F) << shift + data.		pos := pos - 1.		shift := shift + 7.		value > 127 ] whileTrue.	size := method size - pos.! !!BlockClosure methodsFor: 'debugger access' stamp: 'nice 4/14/2009 19:09'!sender	"Answer the context that sent the message that created the receiver."	^outerContext sender! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 07:08'!encodeNoTrailer	encodedData := #(0 0 0 0)! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 13:30'!encodeTempsNamesQCompress	"data is string with method's temporary names, encode it using qCompress method"	self encodeUsingQCompress! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 16:33'!decodeTempsNamesZip	"data is string with method's temporary names, compressed using zip compression"	self decodeZip.! !!CompiledMethodTrailer methodsFor: 'private' stamp: 'Igor.Stasenko 12/13/2009 11:54'!kindAsByte	| index |	index := self class trailerKinds indexOf: kind.	self assert: (index ~~ 0).	^ (index - 1) << 2! !!CompiledMethodTrailer class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/14/2009 10:08'!empty	"answer the empty trailer"	^ self new! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 13:26'!encodeUsingQCompress	"data is string, encode it using qCompress method"	| str length encodedLength |	self assert: data isString.	str := self qCompress: data.	length := str position.	encodedLength := self encodeLengthField: length.	str nextPutAll: encodedLength.	"trailing byte"	str nextPut: (self kindAsByte + encodedLength size - 1).		encodedData := str contents	! !!CompiledMethodTrailer methodsFor: 'private' stamp: 'Igor.Stasenko 12/20/2009 21:33'!qCompress: string	"A very simple text compression routine designed for method temp names.	 Most common 11 chars get values 1-11 packed in one 4-bit nibble;	 the next most common get values 12-15 (2 bits) * 16 plus next nibble;	 unusual ones get three nibbles, the first being the escape nibble 0.	Answer the write stream with compressed data inside"	| utf8str stream ix oddNibble |	string isEmpty ifTrue:		[^self qCompress: ' '].	utf8str := string convertToEncoding: 'utf8'.	stream := WriteStream on: (ByteArray new: utf8str size).	oddNibble := nil.	utf8str do:	[:char |		ix := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'			indexOf: char ifAbsent: 0.		(ix = 0			ifTrue:				[{ 0. char asInteger // 16. char asInteger \\ 16 }]			ifFalse:				[ix <= 11					ifTrue: [{ ix }]					ifFalse: [{ ix//16+12. ix\\16 }]])				do: [:nibble |					oddNibble						ifNotNil: [stream nextPut: oddNibble*16 + nibble. oddNibble := nil]						ifNil: [oddNibble := nibble]]].	oddNibble ifNotNil: "4 = 'ear tonsil' indexOf: Character space"		[stream nextPut: oddNibble * 16 + 4].	^ stream! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 11:43'!encodeSourcePointer	encodedData := ByteArray new: 4.	encodedData at: 4 put: (data >> 24) + 251.	1 to: 3 do: [:i |		encodedData at: 4-i put: ((data bitShift: (i-3)*8) bitAnd: 16rFF)]! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 06:43'!method: aMethod	"old method trailer format has only 3 kinds:	 0 [ 0 0 0 ] - no trailer	 source pointer	 temps names	"	| flagByte |	data := size := nil.	method := aMethod.	flagByte := method at: (method size).	kind := (flagByte = 0) ifTrue: [ #OldEmptyTrailer ] 		ifFalse: [			(flagByte < 252) ifTrue: [ #OldTempsNames ]			ifFalse: [ #SourcePointer ]].			"decode the trailer bytes"	self perform: ('decode' , kind) asSymbol.		"after decoding the trailer, size must be set"	self assert: (size notNil).! !!CompiledMethodTrailer methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 16:54'!isEmpty	^ kind == #NoTrailer or: [ kind == #ClearedTrailer ]! !!OldMethodTrailer class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 07:03'!testOldStuffIsFine"OldMethodTrailer testOldStuffIsFine"	| meth |	CompiledMethod allInstancesDo: [:m |		| trailer |			trailer := self new method: m.		self assert: (m endPC = trailer endPC).	].	meth := CompiledMethod toReturnSelf copyWithTempNames: #( a b c d e).	self assert: (self new method: meth) tempNames = meth tempNamesString.	self assert: (CompiledMethod toReturnSelfTrailerBytes: (self new tempNames: 'a b c d e ')) tempNamesString	 = meth tempNamesString.	! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 14:43'!encodeVarLengthSourcePointer	| value |	"source pointer must be >=0"	(self assert: data >= 0).		value := data.	encodedData := ByteArray streamContents: [:str |		[value > 0] whileTrue: [			value > 127 ifTrue: [ str nextPut: 128 + (value bitAnd: 16r7F) ]				ifFalse: [ str nextPut: value. ].			value := value >> 7.			].		].	encodedData := encodedData reversed copyWith: (self kindAsByte)! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 15:56'!encodeTempsNamesZip	"data is string with method's temporary names, encode it using zip compression"	self encodeUsingZip		"data is string with method's source code, encoded using qCompress method"! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 14:23'!encodeSourceBySelector	"A method source is determined by a class + selector where it is installed to"	encodedData := ByteArray with: self kindAsByte! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 15:57'!decodeTempsNamesQCompress	"data is string with method's temporary names, encoded using qCompress method"	self qDecompress.! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 15:57'!decodeEmbeddedSourceQCompress	"data is string with method's source code, encoded using qCompress method"	self qDecompress.! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 06:42'!decodeOldEmptyTrailer	"1 to 4 zero bytes"	size := 0.	[ (method at: (method size - size)) = 0 and: [size <4]] whileTrue: [ size := size + 1].! !!CompiledMethodTrailer class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/13/2009 11:15'!trailerKinds	" see class comment for description"^#("000000" #NoTrailer"000001" #ClearedTrailer"000010" #TempsNamesQCompress"000011" #TempsNamesZip"000100" #SourceBySelector"000101" #SourceByStringIdentifier"000110" #EmbeddedSourceQCompress"000111" #EmbeddedSourceZip"001000" #VarLengthSourcePointer"001001" #ExtendedKind"001010" #Undefined"001011" #Undefined"001100" #Undefined"001101" #Undefined"001110" #Undefined"001111" #Undefined"010000" #Undefined"010001" #Undefined"010010" #Undefined"010011" #Undefined"010100" #Undefined"010101" #Undefined"010110" #Undefined"010111" #Undefined"011000" #Undefined"011001" #Undefined"011010" #Undefined"011011" #Undefined"011100" #Undefined"011101" #Undefined"011110" #Undefined"011111" #Undefined"100000" #Undefined"100001" #Undefined"100010" #Undefined"100011" #Undefined"100100" #Undefined"100101" #Undefined"100110" #Undefined"100111" #Undefined"101000" #Undefined"101001" #Undefined"101010" #Undefined"101011" #Undefined"101100" #Undefined"101101" #Undefined"101110" #Undefined"101111" #Undefined"110000" #Undefined"110001" #Undefined"110010" #Undefined"110011" #Undefined"110100" #Undefined"110101" #Undefined"110110" #Undefined"110111" #Undefined"111000" #Undefined"111001" #Undefined"111010" #Undefined"111011" #Undefined"111100" #Undefined"111101" #Undefined"111110" #Undefined"111111" #SourcePointer)! !!CompiledMethodTrailer methodsFor: 'creating a method' stamp: 'Igor.Stasenko 12/20/2009 04:37'!createMethod: numberOfBytesForAllButTrailer header: headerWord 	| meth |	encodedData ifNil: [ self encode ].		meth := CompiledMethod newMethod: numberOfBytesForAllButTrailer + size header: headerWord.		"copy the encoded trailer data"		1 to: size do:		[:i | meth at: meth size - size + i put: (encodedData at: i)].	^ meth! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 14:29'!encodeEmbeddedSourceQCompress	"data is string with method's source code, encode it using qCompress method"	self encodeUsingQCompress! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 15:31'!decodeClearedTrailer	"Size is set in #decodeLengthField"	self decodeLengthField.! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 20:54'!tempNames	"Answer the string, containing the temps names or nil "	^ (kind == #TempsNamesQCompress or: [ kind == #TempsNamesZip ]) 		ifTrue: [ data ] ifFalse: [ nil ]! !!CompiledMethodTrailer methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 20:12'!testEncoding	"Since we are using basic protocol (#at:, #at:put: , #size) for accessing compiled method data,	we can pass the ByteArray instance into #method: accessor and check if encoding/decoding 	operations	is symmetrical.	Use this method only for unit-testing purposes"		encodedData ifNil: [ self encode ].	^ CompiledMethodTrailer new method: encodedData! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 20:52'!tempNames: aString	"Embed the temp names string into compiled method trailer, 	pick best compression method"	| temp |	self clear.	kind := #TempsNamesQCompress.	data := aString.		self encode.	temp := encodedData.	kind := #TempsNamesZip.	self encode.	encodedData size > temp size ifTrue: [		encodedData := temp.		kind := #TempsNamesQCompress.		size := encodedData size.		]! !!CompiledMethodTrailer class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 07:09'!new	^ self trailerClass basicNew initialize! !!CompiledMethodTrailer methodsFor: 'private' stamp: 'Igor.Stasenko 12/13/2009 13:28'!encodeLengthField: integer	| bytes value |	self assert: (integer > 0).	value := integer.		bytes := ByteArray streamContents: [:str |		[ value > 0 ] whileTrue: [			str nextPut: (value bitAnd: 255).			value := value >> 8 ]].	"no more than 4 bytes for length field"	self assert: (bytes size <=4).	^ bytes! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 21:03'!sourceIdentifier: aString	"Trailer is used to indicate that method's source code can be retrieved by 	sending #getSourceCodeByIdentifier: message to method's class" 		self clear.	data := aString.	kind := #SourceByStringIdentifier.	self encode.! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 06:51'!decodeOldTempsNames	| sz flagByte |	flagByte := method at: (sz := method size).	(flagByte = 0 or: [flagByte > 251]) ifTrue: [^self error: 'not yet implemented'].	(flagByte = 251	 and: [(1 to: 3) allSatisfy: [:i | (method at: method size - i) = 0]]) ifTrue:		[^self error: 'not yet implemented'].		size := flagByte <= 127			ifTrue: [flagByte + 1]			ifFalse: [ (flagByte - 128 * 128) + (method at: sz - 1) + 2].					data := self qDecompressFrom: (flagByte <= 127								ifTrue:									[ReadStream on: method from: sz - flagByte to: sz - 1]								ifFalse:									[ReadStream on: method from: sz - (flagByte - 128 * 128 + (method at: sz - 1)) - 1 to: sz - 2])	! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 19:59'!sourceCode: aString	"Embed the source code into compiled method trailer, 	pick best compression method"	| temp |	self clear.	kind := #EmbeddedSourceQCompress.	data := aString.		self encode.	temp := encodedData.	kind := #EmbeddedSourceZip.	self encode.	encodedData size > temp size ifTrue: [		encodedData := temp.		kind := #EmbeddedSourceQCompress.		size := encodedData size.		]! !!CompiledMethodTrailer class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 07:10'!usingNewFormat	^ self trailerClass == CompiledMethodTrailer! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 06:28'!qDecompressFrom: input "<ReadStream on: ByteArray> ^<String>"	"Decompress strings compressed by qCompress:.	Most common 11 chars get values 0-10 packed in one 4-bit nibble;	next most common 52 get values 12-15 (2 bits) * 16 plus next nibble;	escaped chars get three nibbles"	^ String streamContents:		[:strm | | nextNibble nibble peek charTable char |		charTable :=  "Character encoding table must match qCompress:"		'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'.		peek := true.		nextNibble := [peek						ifTrue: [peek := false. input peek ifNil: [0] ifNotNil: [:b| b // 16]]						ifFalse: [peek := true. input next ifNil: [0] ifNotNil: [:b| b \\ 16]]].		[input atEnd] whileFalse:			[(nibble := nextNibble value) = 0				ifTrue: [input atEnd ifFalse:						[strm nextPut: (Character value: nextNibble value * 16 + nextNibble value)]]				ifFalse:					[nibble <= 11						ifTrue:							[strm nextPut: (charTable at: nibble)]						ifFalse:							[strm nextPut: (charTable at: nibble-12 * 16 + nextNibble value)]]]]! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 15:16'!encodeClearedTrailer	"A cleared trailer is replaced by #NoTrailer, when used for encoding"	self clear.	kind := #NoTrailer.		^ self encode! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 06:27'!encodeOldTempsNames		"A very simple text compression routine designed for method temp names.	 Most common 11 chars get values 1-11 packed in one 4-bit nibble;	 the next most common get values 12-15 (2 bits) * 16 plus next nibble;	 unusual ones get three nibbles, the first being the escape nibble 0.	 CompiledMethod>>endPC determines the maximum length of encoded	 output, which means 1 to (251 - 128) * 128 + 127, or 15871 bytes"	data isEmpty ifTrue: [ data := ' '].	encodedData := ByteArray streamContents:		[:strm | | ix oddNibble sz |		oddNibble := nil.		data do:			[:char |			ix := 'ear tonsilcmbdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ012345[]()'					indexOf: char ifAbsent: 0.			(ix = 0				ifTrue:					[char asInteger > 255 ifTrue: [^nil]. "Could use UTF8 here; too lazy right now"					{ 0. char asInteger // 16. char asInteger \\ 16 }]				ifFalse:					[ix <= 11						ifTrue: [{ ix }]						ifFalse: [{ ix//16+12. ix\\16 }]])					do: [:nibble |						oddNibble							ifNotNil: [strm nextPut: oddNibble*16 + nibble. oddNibble := nil]							ifNil: [oddNibble := nibble]]].		oddNibble ifNotNil: "4 = 'ear tonsil' indexOf: Character space"			[strm nextPut: oddNibble * 16 + 4].		(sz := strm position) > ((251 - 128) * 128 + 127) ifTrue:			[^nil].		sz <= 127			ifTrue: [strm nextPut: sz]			ifFalse:				[strm nextPut: sz \\ 128; nextPut: sz // 128 + 128]]! !!CompiledMethodTrailer methodsFor: 'private' stamp: 'Igor.Stasenko 12/20/2009 21:32'!decodeZip	"data := <trailer> unzip utf8ToSqueak"	| len |	len := self decodeLengthField.	data := (ZipReadStream on: method from: method size - size+1 to: method size - size + len) contents asString convertFromEncoding: 'utf8'.! !!CompiledMethodTrailer class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 20:15'!convertTrailers	| toConvert converted |	"Protect against doing this in already converted image."	self assert: (self usingNewFormat not).		toConvert := OrderedCollection new.	CompiledMethod allInstancesDo: [:m |		"we need to convert only methods which has no sourcePointer "		m sourcePointer = 0 ifTrue: [			toConvert add: m.			].		].	toConvert := toConvert asArray.	converted := toConvert collect: [:m |		m copyWithTrailerBytes: self basicNew initialize. "clear the trailers"	].	toConvert elementsExchangeIdentityWith: converted asArray.	"replace the #trailerClass method in CompiledMethodTrailer class"		self class compile: 'trailerClass	^ CompiledMethodTrailer' 	! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 11:39'!sourcePointer: ptr	self clear.	data := ptr.	"see if we can encode pointer using 4-byte trailer"	kind := (ptr between: 16r1000000 and: 16r4FFFFFF) 		ifTrue: [ #SourcePointer ] ifFalse: [ #VarLengthSourcePointer ].	! !!CompiledMethodTrailer methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 12/13/2009 11:38'!clear	kind := #NoTrailer.	size := 1.	data := encodedData := method := nil! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 11:55'!encodeNoTrailer	encodedData := ByteArray with: self kindAsByte! !!CompiledMethodTrailer methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 16:52'!hasSourcePointer	^  kind == #SourcePointer or: [ kind == #VarLengthSourcePointer ] ! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 19:15'!kind	"Answer a symbolic name of trailer kind.	See #trailerKinds on class side and class comment for details"		^ kind! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 11:56'!decodeNoTrailer	"Not much to decode here"	size := 1. ! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 16:35'!decodeSourceBySelector	"no data, size = 1"		size := 1.! !!CompiledMethodTrailer methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 12/13/2009 11:23'!method: aMethod	| flagByte |	data := size := nil.	method := aMethod.	flagByte := method at: (method size).	"trailer kind encoded in 6 high bits of last byte"	kind := self class trailerKinds at: 1+(flagByte>>2).	"decode the trailer bytes"	self perform: ('decode' , kind) asSymbol.		"after decoding the trailer, size must be set"	self assert: (size notNil).	! !!CompiledMethodTrailer methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 16:51'!hasTempNames	^ kind == #TempsNamesQCompress or: [ kind == #TempsNamesZip ]! !!CompiledMethodTrailer methodsFor: 'private' stamp: 'Igor.Stasenko 12/13/2009 15:29'!decodeLengthField	"used in various encodings, where length field is preceeding the last trailer byte.	Two least significant bits in last byte denoting the number of bytes for length field"		| numBytes pos length |	pos := method size.	numBytes := ((method at: pos) bitAnd: 3) + 1.		length := 0.	1 to: numBytes do: [:i |		length := length << 8 + (method at: pos - i ).		].	size := 1 + numBytes + length.		^ length! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 21:47'!sourceCode	"Answer the source code of compiled method.	Note: it does not attempts to read from source files using sourcePointer,	nor reconstruct the source code using temp names"		(kind == #EmbeddedSourceQCompress or: [ kind == #EmbeddedSourceZip ]) ifTrue: [		^ data ].		kind == #SourceBySelector ifTrue: [		^ method methodClass getSourceCodeBySelector: method selector ].		kind == #SourceByStringIdentifier ifTrue: [		^ method methodClass getSourceCodeByIdentifier: data ].	^ nil! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 14:29'!encodeEmbeddedSourceZip	"data is string with method's source code, encode it using Zip compression method"	self encodeUsingZip! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 14:38'!encodeUndefined	self error: 'use of an undefined kind of trailer encoding'! !!CompiledMethodTrailer methodsFor: 'accessing' stamp: 'Igor.Stasenko 12/13/2009 21:03'!sourceIdentifier	"Trailer is used to indicate that method's source code can be retrieved by 	sending #getSourceCodeByIdentifier: message to method's class" 	^ (kind == #SourceByStringIdentifier) ifTrue: [ data ] ifFalse: [ nil ].! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 16:33'!decodeEmbeddedSourceZip	"data is string with method's source code, compressed using zip compression"	self decodeZip.! !!CompiledMethodTrailer methodsFor: 'decoding' stamp: 'Igor.Stasenko 12/13/2009 16:34'!decodeUndefined	self error: 'undefined method encoding'! !!AdditionalMethodState methodsFor: 'accessing' stamp: 'bs 12/18/2009 13:38'!at: aKey put: aValue	"Replace the property value or pragma associated with aKey."	| keyAlreadyExists |	keyAlreadyExists := false.		1 to: self basicSize do:		[:i |		| propertyOrPragma "<Association|Pragma>" |		(propertyOrPragma := self basicAt: i) key == aKey ifTrue: [			keyAlreadyExists := true.			propertyOrPragma isVariableBinding				ifTrue: [propertyOrPragma value: aValue]				ifFalse: [self basicAt: i put: aValue]]].		keyAlreadyExists ifFalse: [		method propertyValueAt: aKey put: aValue ].		^ aValue! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 14:30'!decodeExtendedKind	"reserved for future use"	self shouldBeImplemented.! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/20/2009 21:37'!encodeSourceByStringIdentifier	"A method source is determined by a class + string identifier"	| utf8str len |		self assert: (data isString).		encodedData := ByteArray streamContents: [:str |		utf8str := (data convertToEncoding: 'utf8') asByteArray.		str nextPutAll: utf8str.		len := self encodeLengthField: utf8str size.		str nextPutAll: len.		str nextPut: self kindAsByte + (len size -1)	]! !!CompiledMethodTrailer class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 07:09'!trailerClass	^ OldMethodTrailer! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 06:57'!tempNames	"Answer the string, containing the temps names or nil "	^ (kind == #OldTempsNames) 		ifTrue: [ data ] ifFalse: [ nil ]! !!OldMethodTrailer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/20/2009 06:25'!tempNames: aString	"Embed the temp names string into compiled method trailer"	self clear.	kind := #OldTempsNames.	data := aString.		self encode.! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 15:02'!encodeExtendedKind	"reserved for future use"	self error: 'Not yet implemented'.! !!CompiledMethodTrailer methodsFor: 'encoding' stamp: 'Igor.Stasenko 12/13/2009 18:40'!encode	encodedData := nil.		"encode the trailer into byte array"	self perform: ('encode' , kind) asSymbol.	self assert: (encodedData notNil and: [encodedData size > 0 ]).		"set the size"	size := encodedData size.! !