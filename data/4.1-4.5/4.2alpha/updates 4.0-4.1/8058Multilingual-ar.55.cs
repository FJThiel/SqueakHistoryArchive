"Change Set:		8058Multilingual-ar.55Multilingual-ar.55:Add an installation guard for loading the converter changes.Multilingual-ar.54:Faster conversions in MultiByteFileStream and friends:------------------------------------------------------------------Change Set:		FasterLatin1Conversion-Part1Date:			10 May 2009Author:			niceInstall fast latin1 conversion Part1generalize Andreas Raab trick from ByteString>>#squeakToUtf8to every converter using class instance variables------------------------------------------------------------------Change Set:		FasterLatin1Conversion-Part2Date:			10 May 2009Author:			niceInstall fast latin1 conversion Part2Create TextConverter instance variables to handlelatin1 fast conversion + lineEndConventions fast conversion------------------------------------------------------------------Change Set:		FasterLatin1Conversion-Part3Date:			10 May 2009Author:			niceInstall fast latin1 conversion Part3Use #installLineEndConventionInConverter where due.that is whenever converter or lineEndConvention are changed in MultiByteFileStream------------------------------------------------------------------Change Set:		FasterLatin1Conversion-Part4Date:			10 May 2009Author:			niceInstall fast latin1 conversion Part4Install fast latin1 conversion in MultiByteFileStream>>#nextPutAll:"!Object subclass: #TextConverter	instanceVariableNames: 'latin1Map latin1Encodings'	classVariableNames: ''	poolDictionaries: 'EventSensorConstants'	category: 'Multilingual-TextConversion'!!MultiByteFileStream methodsFor: 'accessing' stamp: 'nice 5/10/2009 00:14'!lineEndConvention: aSymbol	lineEndConvention := aSymbol.	self installLineEndConventionInConverter! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'nice 5/10/2009 00:14'!binary	super binary.	self lineEndConvention: nil! !!TextConverter class methodsFor: 'accessing' stamp: 'nice 5/10/2009 00:45'!initializeLatin1MapAndEncodings	"Initialize the latin1Map and latin1Encodings.	These variables ensure that conversions from latin1 ByteString is reasonably fast"		| latin1 utf8 |	latin1Map := ByteArray new: 256.	latin1Encodings := Array new: 256.	0 to: 255 do:[:i|		utf8 := (String new: 8) writeStream.		latin1 := String with: (Character value: i).		self new nextPut: latin1 first toStream: utf8.		utf8 := utf8 contents.		latin1 = utf8 ifTrue:[			latin1Map at: i+1 put: 0. "no translation needed"		] ifFalse:[			latin1Map at: i+1 put: 1. "translation needed"			latin1Encodings at: i+1 put: utf8.		].	].! !!TextConverter methodsFor: 'conversion' stamp: 'ar 10/23/2009 21:09'!nextPutAll: aString toStream: aStream	"Handle fast conversion if ByteString"		| lastIndex nextIndex |	latin1Map ifNil:[		"Installation guard - during install the SourceFiles' converter 		needs to be dynamically initialized."		self installLineEndConvention: nil].	aString class == ByteString ifFalse: [		(latin1Map at: Character cr asciiValue + 1) = 0			ifTrue: [				aString do: [:char | self nextPut: char toStream: aStream]]			ifFalse: [				aString do: [:char | aStream nextPut: char]].		^self].		lastIndex := 1.	[nextIndex := ByteString findFirstInString: aString inSet: latin1Map startingAt: lastIndex.	nextIndex = 0] whileFalse:		[aStream next: nextIndex-lastIndex putAll: aString startingAt: lastIndex.		aStream basicNextPutAll: (latin1Encodings at: (aString byteAt: nextIndex)+1).		lastIndex := nextIndex + 1].	aStream next: aString size-lastIndex+1 putAll: aString startingAt: lastIndex.	^self! !!TextConverter class methodsFor: 'accessing' stamp: 'nice 5/9/2009 23:35'!latin1Encodings	"Answer an Array mapping latin1 characters to conversion string"	^latin1Encodings ifNil:		[self initializeLatin1MapAndEncodings.		latin1Encodings]! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'nice 5/10/2009 00:53'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead state |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	self wantsLineEndConversion ifFalse: [self lineEndConvention: nil.					^lineEndConvention].	self closed ifTrue: [self lineEndConvention: LineEndDefault.					^lineEndConvention].	"Default if nothing else found"	numRead := 0.	state := converter saveStateOf: self.	lineEndConvention := nil.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char := self next.			char = Lf				ifTrue: 					[converter restoreStateOf: self with: state.					self lineEndConvention: #lf.					^lineEndConvention].			char = Cr				ifTrue: 					[self peek = Lf						ifTrue: [self lineEndConvention: #crlf]						ifFalse: [self lineEndConvention: #cr].					converter restoreStateOf: self with: state.					^ lineEndConvention].			numRead := numRead + 1].	converter restoreStateOf: self with: state.	self lineEndConvention: LineEndDefault.	^ lineEndConvention! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'nice 5/10/2009 00:18'!converter: aConverter	converter := aConverter.	self installLineEndConventionInConverter! !!MultiByteFileStream methodsFor: 'private' stamp: 'nice 5/10/2009 00:13'!installLineEndConventionInConverter	converter ifNotNil: [converter installLineEndConvention: (self doConversion		ifTrue: [LineEndStrings at: lineEndConvention]		ifFalse: [nil])]! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'nice 5/10/2009 00:17'!converter	converter ifNil: [self converter: TextConverter defaultSystemConverter].	^ converter! !!MultiByteFileStream methodsFor: 'public' stamp: 'nice 5/10/2009 00:21'!nextPutAll: aCollection	(self isBinary or: [aCollection class == ByteArray]) ifTrue: [		^ super nextPutAll: aCollection.	].	self converter nextPutAll: aCollection toStream: self.! !!TextConverter methodsFor: 'initialize-release' stamp: 'nice 5/10/2009 00:09'!installLineEndConvention: lineEndStringOrNil	latin1Map := self class latin1Map.	latin1Encodings := self class latin1Encodings.	lineEndStringOrNil ifNotNil:		[latin1Encodings := latin1Encodings copy.		latin1Encodings at: Character cr asciiValue + 1 put: (self convertFromSystemString: lineEndStringOrNil).		latin1Map := latin1Map copy.		latin1Map at: Character cr asciiValue + 1 put: 1]! !!MultiByteFileStream methodsFor: 'open/close' stamp: 'nice 5/10/2009 00:18'!reset	super reset.	converter ifNil: [		self converter: UTF8TextConverter new.	].! !!TextConverter class methodsFor: 'accessing' stamp: 'nice 5/9/2009 23:34'!latin1Map	"Answer a ByteArray map telling if latin1 characters needs conversion or not"	^latin1Map ifNil:		[self initializeLatin1MapAndEncodings.		latin1Map]! !