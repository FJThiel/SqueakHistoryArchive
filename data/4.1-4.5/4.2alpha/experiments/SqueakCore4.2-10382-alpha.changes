'From Squeak4.2alpha of 19 August 2010 [latest update: #10382] on 23 August 2010 at 10:37:36 am'!!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27'!emitCodeForEffect: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStorePop: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27'!emitCodeForValue: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStore: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16'!sizeCodeForEffect: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStorePop: encoder)! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16'!sizeCodeForValue: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStore: encoder)! !!AssignmentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitAssignmentNode: self! !!BDFFontReader methodsFor: 'reading' stamp: 'nice 6/11/2010 21:32'!getLine	^file nextLine! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35'!read	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width blt lastAscii pointSize ret stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	charsNum > 256 ifTrue: [		"it should be 94x94 charset, and should be fixed width font"		strikeWidth := 94*94*maxWidth.		maxAscii := 94*94.		minAscii := 0.		xTable := XTableForFixedFont new.		xTable maxAscii: 94*94.		xTable width: maxWidth.	] ifFalse: [		xTable := (Array new: 258) atAllPut: 0.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	lastAscii := 0.		charsNum > 256 ifTrue: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			encoding := ((encoding // 256) - 33) * 94 + ((encoding \\ 256) - 33).			blt copy: ((encoding * maxWidth)@0 extent: maxWidth@height)				from: 0@0 in: form.		].	] ifFalse: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].			blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))					extent: (bbx at: 1)@(bbx at: 2))				from: 0@0 in: form.			xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).			lastAscii := encoding.		]	].	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35'!readChars	| strikeWidth ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width pointSize stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	^ chars.! !!BalloonCanvas methodsFor: 'drawing' stamp: 'jcg 11/17/2008 17:03'!line: pt1 to: pt2 width: w color: c	"Draw a line from pt1 to: pt2"	(aaLevel == 1 and: [self ifNoTransformWithIn:(pt1 rect: pt2)])		ifTrue:[^super line: pt1 to: pt2 width: w color: c].	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 4/28/2010 12:29'!compress	"Compact the method dictionary of the receiver."	self methodDict compact! !!Behavior methodsFor: 'testing' stamp: 'mtf 6/3/2010 11:03'!sourceMatchesBytecodeAt: selector	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false otherwise. Implemented to detect an error where Monticello did not recompile sources when the class shape changed"	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a method which turned a selector and class into a CompiledMethod, without  installing it into the methodDictionary"	| method trailer methodNode |	method := self compiledMethodAt: selector.	trailer := method trailer.	methodNode := self compilerClass new				compile: (self sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ false].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ (methodNode generate: trailer) = method! !!Behavior methodsFor: '*Tools-Browser-accessors' stamp: 'eem 8/12/2009 11:45'!settersReturnValue	"Determine whether the browser's createInstVarAccessors code will generate	 setters that answer self (the default here) or the value set.  Classes that want	 to answer the value set (e.g. VMStructType) override."	^false! !!BitBlt class methodsFor: 'benchmarks' stamp: 'nice 6/11/2010 21:32'!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log := WriteStream on: String new.	old := ReadStream on: before.	new := ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine := old nextLine.		newLine := new nextLine.		(oldLine includes: Character tab) ifTrue:[			oldLine := ReadStream on: oldLine.			newLine := ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal := Integer readFrom: oldLine.				newVal := Integer readFrom: newLine.				improvement := oldVal asFloat / newVal asFloat roundTo: 0.01.				Transcript show: improvement printString; tab; tab.				log print: improvement; tab; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:52'!once	"Answer and remember my value, answering exactly the same object in any further sends	 of once or value until I become uncached.  This allows one to intern values with the idiom		myResourceMethod			^[expression] once.	 The expression will be evaluated once and its result returned for any subsequent evaluations.	 Originally by Travis Griggs, from whom we copy this idea with thanks."	numArgs ~= 0 ifTrue:		[self error: 'once should only be used with niladic blocks'].	self becomeCached.	^self once! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 11:50'!value	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the copied values to the activation as its copied	 temps. Primitive. Essential."	<primitive: 201>	| newContext |	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:21'!value: firstArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the argument and copied values to the activation	 as its argument and copied temps. Primitive. Essential."	<primitive: 202>	| newContext |	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22'!value: firstArg value: secondArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 203>	| newContext |	numArgs ~= 2 ifTrue:		[self numArgsError: 2].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22'!value: firstArg value: secondArg value: thirdArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 204>	| newContext |	numArgs ~= 3 ifTrue:		[self numArgsError: 3].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:31'!value: firstArg value: secondArg value: thirdArg value: fourthArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 205>	| newContext |	numArgs ~= 4 ifTrue:		[self numArgsError: 4].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			newContext at: 4 put: fourthArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:29'!valueWithArguments: anArray	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments in an anArray and copied values to	 the activation as its arguments and copied temps. Primitive. Essential."	<primitive: 206>	| newContext |	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			1 to: numArgs do:				[:i| newContext at: i put: (anArray at: i)].			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/1/2010 19:30'!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^((MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc) privRefresh! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:23'!becomeCached	self become: ((CachedBlockClosure new: self size)						outerContext: outerContext						startpc: startpc						numArgs: numArgs						cachedValue: self value						copiedValues: self)! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:19'!becomeUncached	"The receiver is already uncached."	^self! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark	^tempsMark! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark: anInteger	tempsMark := anInteger! !!BlockNode methodsFor: 'code generation' stamp: 'eem 6/2/2008 13:29'!emitCodeExceptLast: stack encoder: encoder	| position nextToLast |	position := stack position.	nextToLast := statements size - 1.	1 to: nextToLast do:		[:i | | statement |		statement := statements at: i.		statement emitCodeForEffect: stack encoder: encoder.		self assert: stack position = position].! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:28'!emitCodeForEvaluatedEffect: stack encoder: encoder	| position |	position := stack position.	self returns		ifTrue: 			[self emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1]		ifFalse: 			[self emitCodeExceptLast: stack encoder: encoder.			statements last emitCodeForEffect: stack encoder: encoder].	self assert: stack position = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:36'!emitCodeForEvaluatedValue: stack encoder: encoder	| position |	position := stack position.	self emitCodeExceptLast: stack encoder: encoder.	statements last emitCodeForBlockValue: stack encoder: encoder.	self assert: stack position - 1 = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55'!emitCodeForValue: stack encoder: encoder	self generateAsClosure ifTrue:		[^self emitCodeForClosureValue: stack encoder: encoder].	encoder genPushThisContext.	stack push: 1.	nArgsNode emitCodeForValue: stack encoder: encoder.	remoteCopyNode		emitCode: stack		args: 1		encoder: encoder.	"Force a two byte jump."	encoder genJumpLong: size.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitCodeForStorePop: stack encoder: encoder].	self emitCodeForEvaluatedValue: stack encoder: encoder.	self returns ifFalse:		[encoder genReturnTopToCaller.		pc := encoder methodStreamPosition].	stack pop: 1! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/29/2008 15:21'!sizeCodeExceptLast: encoder	| codeSize |	codeSize := 0.	1 to: statements size - 1 do: 		[:i | | statement |		 statement := statements at: i.		 codeSize := codeSize + (statement sizeCodeForEffect: encoder)].	^codeSize! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13'!sizeCodeForEvaluatedEffect: encoder	^self returns		ifTrue: [self sizeCodeForEvaluatedValue: encoder]		ifFalse: [(self sizeCodeExceptLast: encoder)				+ (statements last sizeCodeForEffect: encoder)]! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEvaluatedValue: encoder	^(self sizeCodeExceptLast: encoder)		+ (statements last sizeCodeForBlockValue: encoder)! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55'!sizeCodeForValue: encoder	self generateAsClosure ifTrue:		[^self sizeCodeForClosureValue: encoder].	nArgsNode := encoder encodeLiteral: arguments size.	remoteCopyNode := encoder encodeSelector: #blockCopy:.	size := self sizeCodeForEvaluatedValue: encoder.	self returns ifFalse:		[size := size + encoder sizeReturnTopToCaller]. "endBlock"	arguments := arguments collect:  "Chance to prepare debugger remote temps"						[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size := size + (arg sizeCodeForStorePop: encoder)].	^encoder sizePushThisContext	 + (nArgsNode sizeCodeForValue: encoder) 	 + (remoteCopyNode sizeCode: encoder args: 1 super: false)	 + (encoder sizeJumpLong: size)	 + size! !!BlockNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitBlockNode: self! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 19:23'!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	| effectiveScope blockStart |	effectiveScope := optimized						ifTrue: [actualScopeIfOptimized := scopeBlock]						ifFalse: [self].	arguments ifNotNil:		[arguments do: [:temp| temp definingScope: self]].	temporaries ifNotNil:		[temporaries do: [:temp| temp definingScope: self]].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockEntry:			[:entryNumber|			 blockExtent := (blockStart := entryNumber) to: 0]].	"Need to enumerate a copy because closure analysis can add a statement	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."	statements copy do:		[:statement|		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].	optimized		ifTrue: "if optimized loop need to add nils for any temps read before written"			[optimizedMessageNode isOptimizedLoop ifTrue:				[self nilReadBeforeWrittenTemps]]		ifFalse: "if optimized this isn't an actual scope"			[rootNode noteBlockExit:				[:exitNumber|				 blockExtent := blockStart to: exitNumber]].	"Now that the analysis is done move any temps that need to be moved."	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.	"This is simply a nicety for compiler developers..."	temporaries do:		[:temp|		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:			[temp name: temp definingScope remoteTempNodeName]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:36'!nilReadBeforeWrittenTemps	| visitor readBeforeWritten |	self accept: (visitor := OptimizedBlockLocalTempReadBeforeWrittenVisitor new).	readBeforeWritten := visitor readBeforeWritten.	temporaries reverseDo:		[:temp|		((readBeforeWritten includes: temp)		 and: [temp isRemote not]) ifTrue:			[statements addFirst: (AssignmentNode new variable: temp value: NodeNil)]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:30'!noteOptimizedIn: anOptimizedMessageNode	optimized := true.	optimizedMessageNode := anOptimizedMessageNode! !!BlockNode commentStamp: '<historical>' prior: 0!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/20/2010 13:33'!drawOn: aCanvas	"aCanvas fillRectangle: self bounds color: Color red" "for debugging"! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:22'!setDefaultColors! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:21'!setInverseColors! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'ar 6/23/2010 17:09'!addEdgeGrips	"Add resizers along the four edges of the receiver"	self		addMorphBack: (TopGripMorph new target: self;position: self position).	self		addMorphBack: (BottomGripMorph new target: self;position: self position).	self		addMorphBack: (RightGripMorph new target: self;position: self position).	self		addMorphBack: (LeftGripMorph new target: self;position: self position).! !!BottomGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:37'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!BottomGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!BottomGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 1 corner: 1 @ 1)		offsets: (0 @ self defaultHeight negated corner: 0@ 0)! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!ptName	^#bottom! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!resizeCursor	^ Cursor resizeForEdge: #top! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:40'!emitCodeForValue: stack encoder: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].		 encoder genPushConsArray: elements size.		 stack			pop: elements size;			push: 1.		 ^self].	^emitNode emitCodeForValue: stack encoder: encoder! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:22'!sizeCodeForValue: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])		  + (encoder sizePushConsArray: elements size)].	emitNode := elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^emitNode sizeCodeForValue: encoder! !!BraceNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitBraceNode: self! !!Browser methodsFor: 'class functions' stamp: 'eem 8/12/2009 11:52'!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection,	 except do NOT clobber or override any selectors already understood by the instances of the selected class"	self selectedClassOrMetaClass ifNotNil:		[:aClass| | cr |		cr := String with: Character cr.		aClass instVarNames do: 			[:aName | | newMessage setter |			(aClass canUnderstand: aName asSymbol) ifFalse:				[newMessage :=					aName, cr,					'	"Answer the value of ', aName, '"', cr, cr,					'	^ ', aName.				aClass compile: newMessage classified: #accessing notifying: nil].			(aClass canUnderstand: (setter := aName, ':') asSymbol) ifFalse:				[newMessage :=					setter, ' anObject', cr,					'	"Set the value of ', aName, '"', cr, cr,						(aClass settersReturnValue ifTrue: ['	^'] ifFalse: ['	']),						aName, ' := anObject'.				aClass compile: newMessage classified: #accessing notifying: nil]]]! !!Browser methodsFor: 'class list' stamp: 'eem 5/14/2008 17:58'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className currentMessageCategoryName currentMessageName |	currentMessageCategoryName := [self selectedMessageCategoryName]										on: Error										do: [:ex| ex return: nil].	currentMessageName := [self selectedMessageName]								on: Error								do: [:ex| ex return: nil].	classListIndex := anInteger.	self setClassOrganizer.	"Try to reselect the category and/or selector if the new class has them."	messageCategoryListIndex := self messageCategoryList										indexOf: currentMessageCategoryName										ifAbsent: [0].	messageListIndex := messageCategoryListIndex = 0							ifTrue: [0]							ifFalse: [self messageList										indexOf: currentMessageName										ifAbsent: [0]].	messageListIndex ~= 0 ifTrue:		[self editSelection: #editMessage] ifFalse:	[messageCategoryListIndex ~= 0 ifTrue:		[self editSelection: #newMessage] ifFalse:	[self classCommentIndicated		ifTrue: []		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])]]].	contents := nil.	self selectedClass isNil		ifFalse: [className := self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:53'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!Browser methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 19:06'!labelString	| label |	label := self selectedClass				ifNil: [ self defaultBrowserTitle ]				ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].	(multiWindowState notNil	 and: [multiWindowState models size > 1]) ifTrue:		[label := (multiWindowState models indexOf: self) printString, '. ', label].	^label! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 15:50'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	"Example:		Browser newOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0.0@0.0 corner: 0.5@0.08) -> [self buildClassListSingletonWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0 width: 0.5 bottomFraction: max) -> [self buildMessageCategoryListWith: builder].		(self topConstantHeightFrame: self buttonHeight fromLeft: 0.5 width: 0.5) -> [self buildSwitchesWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0.5 width: 0.5 bottomFraction: max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:52'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!exploreMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod explore]! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!inspectMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod inspect]! !!Browser methodsFor: 'message functions' stamp: 'eem 6/29/2010 17:07'!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	(self menuHook: aMenu named: #messageListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('inst var refs...'			browseInstVarRefs)			('inst var defs...'			browseInstVarDefs)			('class var refs...'			browseClassVarRefs)			('class variables'			browseClassVariables)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			('explore method'			exploreMethod)			('inspect method'			inspectMethod)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'system category functions' stamp: 'eem 7/1/2010 10:39'!findClass	"Search for a class by name."	| pattern foundClass |	(multiWindowState notNil	 or: [self okToChange]) ifFalse:		[^self classNotFound].	pattern := UIManager default request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^self classNotFound].	foundClass := Utilities classFromPattern: pattern withCaption: ''.	foundClass ifNil: [^self classNotFound].	(self selectedClass notNil	 and: [multiWindowState notNil	 "Can only support multi-window if original window has all the right panes."	 and: [multiWindowState prototype isHierarchy not]]) ifTrue:		[(self classList includes: foundClass name)			ifTrue: [multiWindowState copyWindow]			ifFalse: [multiWindowState addNewWindow]]. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:29'!buildClassListSingletonWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classListSingleton; 		getIndex: #indexIsOne; 		setIndex: #indexIsOne:; 		menu: #classListMenu:shifted; 		keyPress: #classListKey:from:.	^listSpec! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:30'!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:shifted:; 		keyPress: #classListKey:from:.	Preferences browseWithDragNDrop 		ifTrue:[listSpec dragItem: #dragFromClassList:].	^listSpec! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 21:44'!arrowKey: aChar from: view	"Intercept Apple-Digit to select panes"	| index |	(aChar isDigit	 and: [multiWindowState notNil]) ifTrue:	 	[index := aChar asciiValue - $0 asciiValue.		index = 0 ifTrue: [index := 10].		^index <= multiWindowState models size			ifTrue: [multiWindowState selectWindowIndex: index]			ifFalse: [self changed: #flash]].	^super arrowKey: aChar from: view! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:36'!classHierarchy	| behavior newBrowser |	(behavior := self selectedClassOrMetaClass) isNil ifTrue:		[^self].	(self isPackage "PackageBrowser pains can't support a hierarchy browser; not sure why."	 or: [multiWindowState isNil]) ifTrue:		[^super classHierarchy].	(newBrowser := HierarchyBrowser new initHierarchyForClass: behavior)		messageCategoryListIndex: messageCategoryListIndex;		messageListIndex: messageListIndex;		editSelection: editSelection.	multiWindowState addWindow: newBrowser! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self selectedClass			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[s print: self selectedClass.				 self metaClassIndicated ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy']].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:23'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'className:')			ifNil: [(getarg value: 'restoreToCategory:')					ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]					ifNotNil: [:categoryName| s nextPutAll: categoryName]]			ifNotNil:				[:className|				s nextPutAll: className.				(getarg value: 'meta:') ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy'].				(getarg value: 'selector:')					ifNil: [(getarg value: 'protocol:') ifNotNil:							[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]					ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 17:34'!okToClose	^super okToClose	  and: [multiWindowState isNil or: [multiWindowState okToClose]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 20:20'!restoreMultiWindowState: aMessage	"Restore the state after a multi-window switch.."	aMessage sentTo: self! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:28'!restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self systemCategoryListIndex: (self systemCategoryList indexOf: category).	self classListIndex: (self classListIndexOf: className).	self metaClassIndicated: metaBool.	self messageCategoryListIndex: (self messageCategoryList indexOf: protocol).	self messageListIndex: (self messageList indexOf: selector).	editSelection := editMode.	self		contentsChanged;		decorateButtons! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:23'!saveMultiWindowState	^Message		selector: #restoreToCategory:className:protocol:selector:mode:meta:		arguments: {	self selectedSystemCategoryName.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!Browser class methodsFor: 'instance creation' stamp: 'eem 7/1/2010 11:44'!openBrowserView: aBrowserView label: aString 	"Schedule aBrowserView, labelling the view aString."(aBrowserView isKindOf: ToolBuilderSpec) ifTrue:[	(self canUseMultiWindowBrowsers	 and: [self useMultiWindowBrowsers]) ifTrue:		[aBrowserView multiWindowStyle: #labelButton].	ToolBuilder open: aBrowserView label: aString.] ifFalse:[	aBrowserView isMorph		ifTrue:  [(aBrowserView setLabel: aString) openInWorld]		ifFalse: [aBrowserView label: aString.				aBrowserView minimumSize: 300 @ 200.				aBrowserView subViews do: [:each | each controller].				aBrowserView controller open].].	^ aBrowserView model! !!Browser class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	^true! !!ButtonStub methodsFor: 'simulating' stamp: 'cwp 7/14/2006 11:09'!isEnabled	enabled ifNil: [enabled := spec model perform: spec enabled].	^ enabled! !!ByteArray methodsFor: 'testing' stamp: 'eem 6/4/2010 17:55'!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^self class == ByteArray! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:24'!becomeCached	"The receiver is already cached."	^self! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:21'!becomeUncached	self become: (BlockClosure 					outerContext: outerContext					startpc: startpc					numArgs: numArgs					copiedValues: self)! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:24'!once	^cachedValue! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:17'!value	^cachedValue! !!CachedBlockClosure methodsFor: 'initialize-release' stamp: 'eem 7/22/2010 12:16'!outerContext: aContext startpc: aStartpc numArgs: argCount cachedValue: aValue copiedValues: anArrayOrNil	cachedValue := aValue.	super outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil! !!CachedBlockClosure commentStamp: 'eem 7/22/2010 12:34' prior: 0!I'm a BlockClosure with an added instance variable for storing the once upon a time result of evaluating myself when I was simple BlockClosure. This is triggered by sending #once to a normal BlockClosure. Future sends of once will simply return this value rather than evaluate myself. When sent value, I revert back to a BlockClosure.  Originally by Travis Griggs, from whom we copy this idea with thanks.Instance Variables	cachedValue	<Object>cachedValue	- result of having sent value to myself when i was just a BlockClosure!!Canvas methodsFor: 'initialization' stamp: 'ar 6/17/2010 16:43'!finish: allDamage	"If there are any pending operations on the receiver complete them. 	Do not return before all modifications have taken effect."	^self finish! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:41'!emitCodeForValue: stack encoder: encoder	receiver emitCodeForValue: stack encoder: encoder.	1 to: messages size - 1 do: 		[:i | 		encoder genDup.		stack push: 1.		(messages at: i) emitCodeForValue: stack encoder: encoder.		encoder genPop.		stack pop: 1].	messages last emitCodeForValue: stack encoder: encoder! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:39'!sizeCodeForValue: encoder	| size |	size := (receiver sizeCodeForValue: encoder)			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)).	messages do: [:aMessage | size := size + (aMessage sizeCodeForValue: encoder)].	^size! !!CascadeNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitCascadeNode: self! !!Categorizer commentStamp: 'nice 5/6/2010 21:10' prior: 0!A Categorizer goal is to classify the elements of a collection into categories.It is typically used to classify methods of class into categories (also named protocols in this case).Instance Variables	categoryArray:		<SequenceableCollection of: Object>	categoryStops:		<SequenceableCollection of: Integer>	elementArray:		<SequenceableCollection of: Object>categoryArray	- holds the list of categories.	A category could be any Object but is generally a String or Symbol.	Categories should be unique (categoryArray asSet size = categoryArray size)categoryStops	- holds the index of last element belonging to each category.	There should be a category stop for each category (categoryStops size = categoryArray size).	The categoryStops should be sorted (categoryStops sorted = categoryStops).	A category stop equal to its predecessor (= 0 for the first category stop) denotes an empty category.elementArray	- holds the elements to be classified. The elements are sorted by category.Class variables	Default is the default category used to classify yet unclassified methods of a class	NullCategory is the category to be displayed in a Browser for a class having no method.!!ChangeList methodsFor: 'menu actions' stamp: 'eem 6/29/2010 17:58'!changeListMenu: aMenu	"Fill aMenu up so that it comprises the primary changelist-browser menu"	aMenu addTitle: 'change list'.	aMenu addStayUpItemSpecial.	aMenu addList: #(	('fileIn selections'							fileInSelections						'import the selected items into the image')	('fileOut selections...	'						fileOutSelections						'create a new file containing the selected items')	-	('compare to current'						compareToCurrentVersion			'open a separate window which shows the text differences between the on-file version and the in-image version.' )	('toggle diffing (D)'							toggleDiffing						'start or stop showing diffs in the code pane.')	-	('select conflicts with any changeset'		selectAllConflicts					'select methods in the file which also occur in any change-set in the system')	('select conflicts with current changeset'	selectConflicts						'select methods in the file which also occur in the current change-set')	('select conflicts with...'						selectConflictsWith					'allows you to designate a file or change-set against which to check for code conflicts.')	-	('select unchanged definitions'				selectUnchangedDefinitions			'select class definitions, class comments and methods in the file whose in-image versions are the same as their in-file counterparts' )	('select unchanged methods'					selectUnchangedMethods				'select methods in the file whose in-image versions are the same as their in-file counterparts' )	('select new methods'						selectNewMethods					'select methods in the file that do not current occur in the image')	('select methods for this class'				selectMethodsForThisClass			'select all methods in the file that belong to the currently-selected class')	('select methods for extant classes'			selectMethodsForExtantClasses		'select all methods in the file that belong to a class that exists in the image')	('select changes with contents matching'		selectContentsMatching				'select all changes in the file whose text includes a pattern')	-	('select all (a)'								selectAll								'select all the items in the list')	('deselect all'								deselectAll							'deselect all the items in the list')	('invert selections'							invertSelections						'select every item that is not currently selected, and deselect every item that *is* currently selected')	-	('browse all versions of single selection'			browseVersions		'open a version browser showing the versions of the currently selected method')	('browse all versions of selections'			browseAllVersionsOfSelections		'open a version browser showing all the versions of all the selected methods')	('browse current versions of selections'		browseCurrentVersionsOfSelections	'open a message-list browser showing the current (in-image) counterparts of the selected methods')	('destroy current methods of selections'		destroyCurrentCodeOfSelections		'remove (*destroy*) the in-image counterparts of all selected methods')	-	('remove doIts'								removeDoIts							'remove all items that are doIts rather than methods')	('remove older versions'						removeOlderMethodVersions			'remove all but the most recent versions of methods in the list')	('remove up-to-date versions'				removeExistingMethodVersions		'remove all items whose code is the same as the counterpart in-image code')	('remove selected items'						removeSelections					'remove the selected items from the change-list')	('remove unselected items'					removeNonSelections					'remove all the items not currently selected from the change-list')).	^ aMenu! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/18/2009 15:21'!selectContentsMatching	| pattern |	pattern := UIManager default request: 'pattern to match'.	pattern isEmpty ifTrue: [^self].	^Cursor execute showWhile:		[self selectSuchThat: ((pattern includesAnyOf: '?*')								ifTrue: [[ :change | pattern match: change string]]								ifFalse: [[ :change | change string includesSubString: pattern]])]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 8/18/2009 13:41'!selectMethodsForExtantClasses	^self selectSuchThat:		[ :change |		Smalltalk hasClassNamed: change methodClassName]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 7/22/2010 13:40'!selectUnchangedDefinitions	"Selects all recognizable definitions for which there is already a definition in the current image, whose source is exactly the same."	| change class tokens |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put: false.		(change type = #method		 and: [(class := change methodClass) notNil		 and: [class includesSelector: change methodSelector]]) ifTrue:			[listSelections				at: i				put: change string withBlanksCondensed					= (class sourceCodeAt: change methodSelector) asString withBlanksCondensed].		(change type == #classComment		and: [(class := change commentClass) notNil]) ifTrue:			[listSelections at: i put: change string = class comment asString].		change type == #doIt ifTrue:			[tokens := Scanner new scanTokens: change string.			 ((tokens select:				[:substr| #(subclass: variableSubclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3			 and: [(class := Smalltalk at: tokens third ifAbsent: []) notNil			 and: [class isBehavior]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class definition withBlanksCondensed].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #instanceVariableNames:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) notNil			 and: [class isBehavior]]]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class class definition withBlanksCondensed].			(tokens size = 3			 and: [tokens second == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class includesSelector: tokens third) not]]]]) ifTrue:				[listSelections at: i put: true].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class class includesSelector: tokens fourth) not]]]]]) ifTrue:				[listSelections at: i put: true]]]].	self changed: #allSelections! !!ChangeList methodsFor: 'scanning' stamp: 'eem 7/17/2008 15:50'!scanCategory  	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp anIndex |	itemPosition := file position.	item := file nextChunk.	((item includesSubString: 'commentStamp:')	or: [(item includesSubString: 'methodsFor:')	or: [item endsWith: 'reorganize']]) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 50)].	tokens := Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp := ''.		anIndex := tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp := tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].	tokens second == #commentStamp:		ifTrue:			[stamp := tokens third.			self addItem:					(ChangeRecord new file: file position: file position type: #classComment									class: tokens first category: nil meta: false stamp: stamp)					text: 'class comment for ' , tokens first, 						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).			file nextChunk.			^ file skipStyleChunk].	self assert: tokens last == #reorganize.	self addItem:		(ChangeRecord new			file: file position: file position type: #reorganize			class: tokens first category: nil meta: false stamp: stamp)		text: 'organization for ' , tokens first, (tokens second == #class ifTrue: [' class'] ifFalse: ['']).	file nextChunk! !!ChangeList methodsFor: 'scanning' stamp: 'eem 1/28/2009 16:39'!scanCategory: category class: class meta: meta stamp: stamp	| itemPosition method selector |	[itemPosition := file position.	method := file nextChunk.	file skipStyleChunk.	method size > 0]						"done when double terminators"		whileTrue:		[self addItem: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: category meta: meta stamp: stamp)			text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, ((selector := (Smalltalk at: class ifAbsent: [Object]) parserClass new parseSelector: method) isNil					ifTrue: ['unparsableSelector']					ifFalse: [selector])				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !!ChangeList methodsFor: 'viewing access' stamp: 'eem 5/22/2007 10:40'!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange := changeList at: listIndex.	 (aChange type == #method	 and: [(aClass := aChange methodClass) notNil	 and: [aClass includesSelector: aChange methodSelector]]) ifTrue:		[^Utilities			methodDiffFor: aChange text			class: aClass			selector: aChange methodSelector			prettyDiffs: self showingPrettyDiffs].	aChange type == #doIt ifTrue:		[| tokens |		 tokens := Scanner new scanTokens: aChange string.		 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3		  and: [(aClass := Smalltalk at: tokens third ifAbsent: []) notNil		  and: [aClass isBehavior]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass definition to: aChange string].		(tokens size = 4		 and: [tokens second == #class		 and: [tokens third == #instanceVariableNames:		 and: [(aClass := Smalltalk at: tokens first ifAbsent: []) notNil		 and: [aClass isBehavior]]]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass class definition to: aChange string]].	(aChange type == #classComment	and: [(aClass := aChange commentClass) notNil]) ifTrue:		[^TextDiffBuilder buildDisplayPatchFrom: aClass comment asString to: aChange string].	^(changeList at: listIndex) text! !!ChangeRecord methodsFor: 'access' stamp: 'eem 4/23/2007 10:37'!commentClass 	| commentClass |	type == #classComment ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	commentClass := Smalltalk at: class asSymbol.	^meta ifTrue: [commentClass class]		ifFalse: [commentClass]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 5/18/2010 20:25'!fileIndex	SourceFiles withIndexDo: [:sf :i| sf name = file name ifTrue: [^i]].	^nil! !!ChangeRecord methodsFor: 'access' stamp: 'eem 8/14/2010 20:35'!methodClass	| methodClassName methodClass |	(#(method #classComment) includes: type) ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk globals includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass := Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 9/6/2009 13:06'!methodClassName	| text tokens |	(class isNil	and: [type = #doIt	and: [((text := self text) includes: $.) not "exclude multi-statement doits"	and: [(tokens := Scanner new scanTokens: text) size >= 4	and: [tokens first isSymbol	and: [tokens first isKeyword not	and: [tokens first first canBeGlobalVarInitial	and: [tokens includes: #instanceVariableNames:]]]]]]]) ifTrue:		["Could be a class definition.			Class definitions start with Superclass blahSubclass: #ClassName			Metaclass definitions start with ClassName class instanceVariableNames:"		 (tokens second isSymbol		  and: [tokens second isKeyword		  and: [tokens third isSymbol		  and: [tokens third isKeyword not		  and: [(2 to: tokens size by: 2) allSatisfy: [:i| (tokens at: i) isKeyword]]]]]) ifTrue:			[^tokens third].		 (tokens size = 4		  and: [tokens second = #class		  and: [tokens third = #instanceVariableNames:		  and: [tokens last isString]]]) ifTrue:			[^tokens first]].	^class! !!ChangeRecord methodsFor: 'initialization' stamp: 'cmm 7/2/2010 18:26'!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := self methodClass.				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[Utilities noteMethodSubmission: aSelector forClass: cls]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					Utilities noteMethodSubmission: #Comment forClass: cls ].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 8/9/2010 10:47'!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	Cursor write showWhile: [ | internalStream |			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(UIManager default chooseFrom: #('Ignore' 'Browse slips')				 	title: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:21'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"		^ String streamContents:		[:s | | line author s2 ps intName date |		intName := self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps := self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 := ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date := s2 nextLine.			s2 match: 'Author:'; skipSeparators.  author := s2 nextLine.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line := s2 nextLine.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!ChangesOrganizer commentStamp: 'cbr 7/27/2010 19:17' prior: 0!I manage ChangeSets in the system. See the protocols on my class side.For an example of what I can do, select the following line in a Workspace and print it.ChangesOrganizer allChangeSetNames!!Character methodsFor: 'printing' stamp: 'eem 5/21/2010 11:11'!hex	^value printStringBase: 16! !!CharacterBlock commentStamp: 'mtf 5/15/2010 12:44' prior: 0!I describe the location of one character displayed on the screen. My instances are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the information I store stale.text (Text): The text where my character is fromstringIndex (Integer): The index of my character in the text, starting from 1textLine (TextLine): The displayed line my character is onorigin (Point): The top-left corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0corner (Point): The bottom-right corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0!!CharacterScanner methodsFor: 'scanning' stamp: 'cmm 6/12/2010 11:52'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: (stopIndex min: sourceString size) in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := EncodedCharSet scanSelectorAt: startEncoding.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stops with: kernDelta).	].		^ stops endOfRun! !!ClassBuilder methodsFor: 'private' stamp: 'ar 6/14/2010 22:06'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		ProtoObject Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext BlockClosure		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'MarcusDenker 3/5/2010 14:33'!methodsInCategory: aName 	"Answer a list of the methods of the receiver that are in category named aName"		| aColl |	aColl := Set withAll: (aName = ClassOrganizer allCategory			ifTrue: [self organization allMethodSelectors]			ifFalse: [self organization listAtCategoryNamed: aName]).	^ aColl asArray sort! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:50'!decompiledSourceIntoContents	"For backwards compatibility."	^self  decompiledSourceIntoContentsWithTempNames: (Sensor leftShiftDown not) ! !!CodeHolder methodsFor: 'message list' stamp: 'eem 5/18/2010 14:11'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new									parse: method getSourceFromFile asString									in: class									notifying: nil)										generate: CompiledMethodTrailer defaultMethodTrailer;										schematicTempNamesString.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !!CodeHolder methodsFor: 'message list' stamp: 'topa 7/14/2010 16:47'!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	(class isNil or: [selector isNil]) ifTrue: [^'missing'].	sourceString := class ultimateSourceCodeAt: selector ifAbsent: [^'error'].	self validateMessageSource: sourceString forSelector: selector inClass: class.	(#(#prettyPrint #prettyDiffs) 		includes: contentsSymbol) 			ifTrue: 				[sourceString := class prettyPrinterClass 							format: sourceString							in: class							notifying: nil].	self showingAnyKindOfDiffs 		ifTrue: [sourceString := self diffFromPriorSourceFor: sourceString].	^sourceString! !!CodeHolder methodsFor: 'message list' stamp: 'topa 7/14/2010 16:46'!validateMessageSource: sourceString forSelector: aSelector inClass: theClass	"Check whether there is evidence that method source is invalid"	(theClass parserClass new parseSelector: sourceString asString) = aSelector		ifFalse: [self informPossiblyCorruptSource].! !!CodeHolder methodsFor: 'misc' stamp: 'topa 7/14/2010 16:35'!informPossiblyCorruptSource	| sourcesName |	sourcesName := FileDirectory localNameFor: SmalltalkImage current sourcesName.	self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.(Occasionally, the source code for a method may legitimatelystart with a non-alphabetic character -- for example, Behaviormethod #formalHeaderPartsFor:.  In such rare cases, you canhappily disregard this warning.)'! !!CodeHolder methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 19:02'!multiWindowState: aSavedMultiWindowState	multiWindowState := aSavedMultiWindowState! !!CodeHolder commentStamp: '<historical>' prior: 0!An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	"This is a hook to allow browsers to control whether to respond to the muli-window preference.	 Currenty CodeHolder cannot usefully use multi-windows, but may be able to do so in the future."	^false! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 11:43'!useMultiWindowBrowsers	<preference: 'Multi-window browsers'		category: 'browsing'		description: 'When enabled, the browser uses a multi-window to conserve real-estate.  e.g. enable then click in the window label of a browser.'		type: #Boolean>	^MultiWindowBrowsers ifNil: [false]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 6/30/2010 21:37'!useMultiWindowBrowsers: aBoolean	MultiWindowBrowsers := aBoolean! !!CodeLoader commentStamp: 'hjh 4/22/2010 12:58' prior: 0!CodeLoader provides a simple facility for loading code from the network.CodeLoader has a very specific purpose, primarily for loading Etoys projects. It is not meant to be used for anything else. Use Installer for general purposes.Examples:	| loader |	loader := CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!!Collection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:33'!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!Collection methodsFor: 'enumerating' stamp: 'eem 1/11/2009 14:11'!fold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]"	| firstValue nextValue |	firstValue := nextValue := Object new. "something that can't be in the receiver"	self do:		[:each |		nextValue := firstValue == nextValue						ifTrue: [each]						ifFalse: [binaryBlock value: nextValue value: each]].	^nextValue == firstValue		ifTrue: [self errorEmptyCollection]		ifFalse: [nextValue]! !!Collection methodsFor: 'enumerating' stamp: 'ar 5/4/2010 08:40'!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	| first nextValue |	self emptyCheck.	first := true.	self do:[:each|		first ifTrue:[nextValue := each. first := false]			ifFalse:[nextValue := binaryBlock value: nextValue value: each]].	^nextValue! !!Collection methodsFor: 'math functions' stamp: 'ar 5/4/2010 08:38'!sum	"Compute the sum of all the elements in the receiver"	^self reduce:[:a :b| a + b]! !!Color methodsFor: 'transformations' stamp: 'jcg 7/12/2010 18:29'!duller	"Answer a darker, desaturated color.  If the original color isn't very saturated, desaturate it by less (otherwise will just end up with grey)."	| sat adjust |	(sat := self saturation) > 0.3		ifTrue: [adjust := -0.1]		ifFalse: [adjust := 0.1 - sat max: 0.0].	^ self adjustSaturation: adjust brightness: -0.1! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:21'!parseCompositionMappingFrom: stream"	self halt.	self parseCompositionMapping"	| line fieldEnd point fieldStart compositions toNumber diacritical result |	toNumber := [:quad | ('16r', quad) asNumber].	Compositions := IdentityDictionary new: 2048.	Decompositions := IdentityDictionary new: 2048.	Diacriticals := IdentitySet new: 2048.	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.		2 to: 6 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		compositions := line copyFrom: fieldStart to: fieldEnd - 1.		(compositions size > 0 and: [compositions first ~= $<]) ifTrue: [			compositions := compositions substrings collect: toNumber.			compositions size > 1 ifTrue: [				diacritical := compositions first.				Diacriticals add: diacritical.				result := compositions second.				(Decompositions includesKey: point) ifTrue: [					self error: 'should not happen'.				] ifFalse: [					Decompositions at: point put: (Array with: diacritical with: result).				].				(Compositions includesKey: diacritical) ifTrue: [					(Compositions at: diacritical) at: result put: point.				] ifFalse: [					Compositions at: diacritical						put: (IdentityDictionary new at: result put: point; yourself).				].			].		].	].! !!CommentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	^aVisitor visitCommentNode: self! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 8/12/2010 13:52'!decompileWithTemps	"Return the decompiled parse tree that represents self, but get the temp names	 by compiling the sourcecode..."	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	(self fileIndex > 0 and: [(SourceFiles at: self fileIndex) isNil]) ifTrue: [			"Emergency or no source file -- decompile without temp names "			^self decompile.	].	^((self decompilerClass new withTempNames: self methodNode schematicTempNamesString)						decompile: selector						in: class						method: self)! !!CompiledMethod methodsFor: 'decompiling' stamp: 'hmm 4/16/2010 10:48'!methodNode	"Return the parse tree that represents self. If parsing fails, decompile the method."	| aClass source |	aClass := self methodClass.	source := self				getSourceFor: (self selector ifNil: [self defaultSelector])				in: aClass.	^[(aClass parserClass new		encoderClass: (self isBlueBookCompiled						ifTrue: [EncoderForV3]						ifFalse: [EncoderForV3PlusClosures]);		parse: source class: aClass)			sourceText: source;			yourself]		on: SyntaxErrorNotification		do: [:ex | ex return: self decompile].! !!Compiler methodsFor: 'public access' stamp: 'ar 9/27/2005 19:20'!compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	self from: textOrStream		class: aClass		classified: aCategory 		context: nil		notifying: aRequestor.	^self		translate: sourceStream		noPattern: false		ifFail: failBlock! !!Compiler methodsFor: 'public access' stamp: 'eem 7/2/2010 09:54'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into	 a method. If aContext is not nil, the text can refer to temporaries in that	 context (the Debugger uses this). If aRequestor is not nil, then it will receive	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 	 compiled method is invoked from here via withArgs:executeMethod:, hence	 the system no longer creates Doit method litter on errors."	| methodNode method value toLog itsSelection itsSelectionString |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail: [^failBlock value].	method := self interactive				ifTrue: [methodNode generateWithTempNames]				ifFalse: [methodNode generate].	value := receiver				withArgs: (context ifNil: [#()] ifNotNil: [{context}])				executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  			and:[(itsSelection := requestor selection) notNil			and:[(itsSelectionString := itsSelection asString) isEmptyOrNil not]])				ifTrue:[itsSelectionString]				ifFalse:[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext].	^ value! !!Compiler methodsFor: 'public access' stamp: 'eem 8/14/2010 20:23'!from: textOrStream class: aClass classified: aCategory context: aContext notifying: req	sourceStream := (textOrStream isKindOf: PositionableStream)						ifTrue: [textOrStream]						ifFalse: [ReadStream on: textOrStream asString].	class := aClass.	context := aContext.	requestor := req.	category := aCategory! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/12/2010 11:07'!canComputDefaultLineHeight	^ rightMargin notNil! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/13/2010 20:50'!canComputeDefaultLineHeight	^ rightMargin notNil! !!ContextPart methodsFor: 'private' stamp: 'eem 5/23/2010 14:13'!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod := aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	theMethod flushCache.	selector flushCache.	^aReceiver perform: selector withArguments: arguments! !!ContextPart methodsFor: 'private-exceptions' stamp: 'mtf 6/3/2010 09:36'!rearmHandlerDuring: aBlock	"Sent to handler (on:do:) contexts only. Makes me re-entrant for the duration of aBlock. Only works in a closure-enabled image"	^ [self tempAt: 3 put: true. aBlock value]		ensure: [self tempAt: 3 put: false]! !!ControlManager methodsFor: 'scheduling' stamp: 'nice 6/11/2010 21:50'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'nice 6/11/2010 21:50'!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers := OrderedCollection new.	labels := String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:44'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList := aString lines asArray.	anArrayOrNil		ifNil: [linesArray := #()]		ifNotNil: [linesArray := anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font := aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:50'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray := labelList lines]		ifFalse: [labelArray := labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'cmm 6/15/2010 15:14'!= aDateAndTime 	self == aDateAndTime ifTrue: [ ^ true ].	(aDateAndTime isKindOf: self class) ifFalse: [ ^ false ].	^ self offset = aDateAndTime offset		ifTrue: [ self hasEqualTicks: aDateAndTime ]		ifFalse: [ self asUTC ticks = aDateAndTime asUTC ticks ]! !!Debugger methodsFor: 'accessing' stamp: 'abc 2/12/2010 15:02'!debuggerMap	^self selectedContext debuggerMap! !!Debugger commentStamp: '<historical>' prior: 0!I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !!Debugger class methodsFor: 'opening' stamp: 'eem 7/26/2010 15:51'!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller errorWasInUIProcess block |	Smalltalk isMorphic		ifTrue: [errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: process]		ifFalse: [controller := ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController]].	block := [ 		[	| debugger |			debugger := self new process: process controller: controller context: context.			Smalltalk isMorphic				ifTrue: ["schedule debugger in deferred UI message to address redraw						problems after opening a debugger e.g. from the testrunner."					"WorldState addDeferredUIMessage: ["bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]]				ifFalse: ["deferred UI message would require special controller in MVC"					bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]].			debugger errorWasInUIProcess: errorWasInUIProcess.			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].			Smalltalk isMorphic				ifFalse: [ScheduledControllers searchForActiveController "needed since openNoTerminate (see debugger #open...) does not set up activeControllerProcess if activeProcess (this fork) is not the current activeControllerProcess (see #scheduled:from:)"].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	self ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess.	Project current addDeferredUIMessage: block.	process suspend! !!Debugger class methodsFor: 'private' stamp: 'eem 7/26/2010 18:01'!ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess	| sema |	errorWasInUIProcess ifTrue:		[^self].	self interruptUIProcessIfBlockedOnErrorInBackgroundProcess ifFalse:		[^self].	"Only interrupt the UI if it is unresponsive (and so is doing something that needs	 interrupting).  Test using addDeferredUIMessage: to see if it is running UI activities."	sema := Semaphore new.	Project current addDeferredUIMessage: [sema signal].	(sema waitTimeoutMSecs: 100) ifTrue:		[[Project current interruptName: 'Interrupt from Background Error'] fork]	"| s |	s := Semaphore new.	[self assert: 0 > 1000. s signal] fork.	s wait"! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:52'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess	<preference: 'Interrupt UI process on background error'		category: 'debug'		description: 'When enabled, the debugger will interrupt the UI process if an error occurs in a background process and the UI process is blocked.'		type: #Boolean>	^InterruptUIProcessIfBlockedOnErrorInBackgroundProcess ifNil: [false]! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:53'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess: aBoolean	InterruptUIProcessIfBlockedOnErrorInBackgroundProcess := aBoolean! !!Decompiler methodsFor: 'control' stamp: 'eem 8/12/2010 13:25'!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| startpc savedTemps savedTempVarCount savedNumLocalTemps	  jump blockArgs blockTemps blockTempsOffset block |	savedTemps := tempVars.	savedTempVarCount := tempVarCount.	savedNumLocalTemps := numLocalTemps.	jump := blockSize + (startpc := pc).	numLocalTemps := BlockLocalTempCounter tempCountForBlockAt: pc - 4 in: method.	blockTempsOffset := numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: pc])		ifTrue:			[tempVars := blockStartsToTempVars at: pc]		ifFalse:			[blockArgs := (1 to: numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	tempVarCount := tempVarCount + numArgs + numLocalTemps.	block := self blockTo: jump.	stack addLast: ((constructor						codeArguments: (tempVars copyFrom: 1 to: numArgs)						temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)						block: block)							pc: startpc;							yourself).	tempVars := savedTemps.	tempVarCount := savedTempVarCount.	numLocalTemps := savedNumLocalTemps! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/12/2010 13:51'!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	| copiedValues |	self sawClosureBytecode.	copiedValues := ((1 to: numCopied) collect: [:ign| stack removeLast]) reversed.	self doClosureCopyCopiedValues: copiedValues numArgs: numArgs blockSize: blockSize! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/12/2010 13:46'!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home methodClass) == #unknown ifTrue: [^ nil].	aBlock isClosure ifTrue:		[(methodNode := method decompileWithTemps)			ifNil: [^nil]			ifNotNil: [methodNode nodesDo: [:node| node pc = aBlock startpc ifTrue: [^node]]].		 ^self error: 'cannot find block node matching aBlock'].	constructor := self constructorForMethod: aBlock method.		self withTempNames: method methodNode tempNames.	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock endPC.	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super method: method pc: startpc - 5.	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 8/15/2010 16:56'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries |	selectorNode := self codeSelector: selector code: nil.	tempVars := vars.	visibleTemps := OrderedCollection new.	invisibleTemps := OrderedCollection new.	tempVars do: [:t|				   ((t isIndirectTempVector or: [t scope >= 0])						ifTrue: [visibleTemps]						ifFalse: [invisibleTemps]) addLast: t].	arguments := visibleTemps copyFrom: 1 to: nArgs.	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.	block		arguments: arguments;		temporaries: temporaries.	blockNode := MethodNode new		selector: selectorNode		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (EncoderForV3PlusClosures new initScopeAndLiteralTables					temps: visibleTemps, invisibleTemps					literals: literalValues					class: class)		primitive: primitive		properties: method properties copy.	blockNode properties method: blockNode.	^blockNode! !!DependentsArray methodsFor: 'enumerating' stamp: 'ul 6/18/2010 23:31'!select: aBlock 	"Refer to the comment in Collection|select:."	| basicSize newSelf size selection |	basicSize := self basicSize.	newSelf := self species new: basicSize.	size := 0.	1 to: basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :dep |			(aBlock value: dep) ifTrue: [				newSelf basicAt: (size := size+1) put: dep ] ] ].	selection := self species new: size.	selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.	^selection! !!Dictionary methodsFor: 'removing' stamp: 'eem 10/28/2008 11:14'!unreferencedKeys	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"	^'Scanning for references . . .' 		displayProgressAt: Sensor cursorPoint		from: 0		to: Smalltalk classNames size * 2		during: 			[:bar | | currentClass n associations referencedAssociations |			currentClass := nil.			n := 0.			associations := self associations asIdentitySet.			referencedAssociations := IdentitySet new: associations size.			self systemNavigation allSelect:				[:m|				m methodClass ~~ currentClass ifTrue:					[currentClass := m methodClass.					 bar value: (n := n + 1)].				m literalsDo:					[:l|					(l isVariableBinding and: [associations includes: l]) ifTrue:						[referencedAssociations add: l]].				false].			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !!Duration class methodsFor: 'squeak protocol' stamp: 'ul 4/28/2010 09:44'!milliSeconds: milliCount 		^self		seconds: (milliCount quo: 1000)		nanoSeconds: (milliCount rem: 1000) * NanosInMillisecond! !!EUCTextConverter methodsFor: 'conversion' stamp: 'ul 5/26/2010 04:00'!nextFromStream: aStream	| character1 character2 offset value1 value2 nonUnicodeChar |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext ifNil: [^ nil].	character1 asciiValue <= 127 ifTrue: [^ character1].	character2 := aStream basicNext ifNil: [^ nil].	offset := 16rA1.	value1 := character1 asciiValue - offset.	value2 := character2 asciiValue - offset.	(value1 < 0 or: [value1 > 93]) ifTrue: [^ nil].	(value2 < 0 or: [value2 > 93]) ifTrue: [^ nil].	nonUnicodeChar := Character leadingChar: self leadingChar code: value1 * 94 + value2.	^ Character leadingChar: self languageEnvironment leadingChar code: nonUnicodeChar asUnicode.! !!Editor methodsFor: 'private' stamp: 'cmm 7/3/2010 15:56'!moveCursor: directionBlock forward: forward specialBlock: specialBlock 	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	^ self		moveCursor: directionBlock		forward: forward		specialBlock: specialBlock		select: sensor leftShiftDown! !!Editor methodsFor: 'private' stamp: 'cmm 7/3/2010 15:55'!moveCursor: directionBlock forward: forward specialBlock: specialBlock select: shouldSelect	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| indices newPosition |	indices := self setIndices: shouldSelect forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition := specialBlock value: newPosition].	sensor keyboard.	shouldSelect		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!Editor commentStamp: '<historical>' prior: 0!New text editors.TextEditor provides most of the functionality that used to be in TextMorphEditor. This class is no longer a Controller!!SmalltalkEditor is has Smalltalk code specific features.SimpleEditor provides basic functionality for single line text editing. It does not handle fonts and styles, aligning and Smalltalk utilities. It handles one single line.CellStyleEditor allows entering alphabetic characters using only number keys, like most cell phones do.!!Editor class methodsFor: 'preferences' stamp: 'cmm 4/19/2010 20:58'!blinkingCursor	<preference: 'Blinking Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor will blink.'		type: #Boolean>	^ BlinkingCursor ifNil: [ true ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 15:57'!blinkingCursor: aBoolean	BlinkingCursor := aBoolean! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor	<preference: 'Dumbbell-shaped Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor assumes the shape of a dumbbell, otherwise a vertical bar..'		type: #Boolean>	^ DumbbellCursor ifNil: [ false ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor: aBoolean	DumbbellCursor := aBoolean! !!Encoder methodsFor: 'encoding' stamp: 'eem 5/16/2010 17:33'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable					at: name					ifAbsent: 						[(self lookupInPools: name 							ifFound: [:assoc | varNode := self global: assoc name: name])							ifTrue: [varNode]							ifFalse: [^action value]].	range ifNotNil:		[name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]].	(varNode isTemp and: [varNode scope < 0]) ifTrue:		[^OutOfScopeNotification signal			ifTrue: [action value]			ifFalse: [self notify: 'out of scope']].	^varNode! !!Encoder methodsFor: 'encoding' stamp: 'eem 8/15/2010 08:29'!lookupVariable: name ifAbsent: aBlock	"Answer the binding of name in the scope table or aBlock's vaue if none.	 Do not bind and do not lookup in pools.  Used for correction, explanation etc"	^scopeTable at: name ifAbsent: aBlock! !!Encoder methodsFor: 'results' stamp: 'eem 8/13/2010 16:51'!undeclaredTemps 	^(scopeTable select: [:var | var isVariableNode and: [var isUndeclared]]) values! !!Encoder methodsFor: 'temps' stamp: 'eem 8/14/2010 19:35'!newUndeclaredTemp: name	^UndeclaredVariableNode new name: name! !!Encoder methodsFor: 'private' stamp: 'eem 8/13/2010 16:06'!bindUndeclaredTemp: name	^scopeTable at: name put: (self newUndeclaredTemp: name)! !!Encoder methodsFor: 'private' stamp: 'Lukas Renggli 11/2/2009 00:29'!name: name key: key class: leafNodeClass type: type set: dict 	^dict at: key		ifAbsentPut: 			[leafNodeClass new 				name: name				key: key				index: nil				type: type]! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23'!readFrom: aStream	"Private"	| header |	header := aStream nextLine.	(header = 'Event Tape v1 BINARY') ifTrue:[^aStream fileInObjectAndCode].	(header = 'Event Tape v1 ASCII') ifTrue:[^self readFromV1: aStream].	"V0 had no header so guess"	aStream reset.	header first isDigit ifFalse:[^self convertV0Tape: (aStream fileInObjectAndCode)].	^self convertV0Tape: (self readFromV0: aStream).! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23'!readFromV0: aStream	^Array streamContents:[:tStream | | evt line t lineStream |		[aStream atEnd] whileFalse:			[line := aStream nextLine.			line isEmpty "Some MW tapes have an empty record at the end"				ifFalse: [lineStream := ReadStream on: line.						t := Integer readFrom: lineStream.						[lineStream peek isLetter] whileFalse: [lineStream next].						evt := MorphicEvent readFromObsolete: lineStream.						tStream nextPut: t -> evt]]].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:24'!readFromV1: aStream	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:[			tStream nextPut: (MorphicEvent readFromString: aStream nextLine)]]! !!Exception methodsFor: 'handling' stamp: 'mtf 6/3/2010 09:42'!rearmHandlerDuring: aBlock"Make the current error handler re-entrant while it is running aBlock. Only works in a closure-enabled image"	^ handlerContext rearmHandlerDuring: aBlock! !!ExceptionsTest methodsFor: 'as yet unclassified' stamp: 'mtf 6/2/2010 15:51'!testHandlerReentrancy	| callingOrder |	"Handlers are not re-entrant by default, so inner is not activated twice"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex pass]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sio'.	"Now make inner re-entrant"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex rearmHandlerDuring: [ex pass]]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sioi'.! !!FFT methodsFor: 'bulk processing' stamp: 'ul 8/3/2010 15:43'!transformDataFrom: anIndexableCollection startingAt: index	"Forward transform a block of real data taken from from the given indexable collection starting at the given index. Answer a block of values representing the normalized magnitudes of the frequency components."	| j real imag out |	j := 0.	index to: index + n - 1 do: [:i |		realData at: (j := j + 1) put: (anIndexableCollection at: i)].	realData *= window.	imagData := FloatArray new: n.	self transformForward: true.	"compute the magnitudes of the complex results"	"note: the results are in bottom half; the upper half is just its mirror image"	real := realData copyFrom: 1 to: (n / 2).	imag := imagData copyFrom: 1 to: (n / 2).	out := (real * real) + (imag * imag).	1 to: out size do: [:i | out at: i put: (out at: i) sqrt].	^ out! !!FFT methodsFor: 'transforming' stamp: 'ul 8/3/2010 15:43'!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i |	<primitive: 'primitiveFFTTransformData' module: 'FFTPlugin'>	self permuteData.	1 to: nu do:		[:level |		lev := 1 bitShift: level.		lev1 := lev // 2.		1 to: lev1 do:			[:j |			theta := j-1 * (n // lev).   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < (n//4)  "Compute U, the complex multiplier for each level"				ifTrue:					[realU := sinTable at: sinTable size - theta.					imagU := sinTable at: theta + 1]				ifFalse:					[realU := (sinTable at: theta - (n//4) + 1) negated.					imagU := sinTable at: (n//2) - theta + 1].			forward ifFalse: [imagU := imagU negated]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i := j.			[i <= n] whileTrue:				[ip := i + lev1.				realT := ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT := ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: i) - realT.				imagData at: ip put: (imagData at: i) - imagT.				realData at: i put: (realData at: i) + realT.				imagData at: i put: (imagData at: i) + imagT.				i := i + lev]]].	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !!FieldNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitFieldNode: self! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	rcvrNode emitCodeForValue: stack encoder: encoder.	fieldDef accessKey ifNotNil:[		super emitCodeForValue: stack encoder: encoder.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForStore: stack encoder: encoder	fieldDef accessKey ifNil:[		writeNode emitCode: stack args: 1 encoder: encoder super: false.	] ifNotNil:[		writeNode emitCode: stack args: 2 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:18'!emitCodeForStorePop: stack encoder: encoder	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	fieldDef accessKey ifNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 0 encoder: encoder super: false.	] ifNotNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		super emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 1 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeCodeForValue: encoder) + 			(writeNode sizeCode: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) +			(writeNode sizeCode: encoder args: 2 super: false)! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:17'!sizeCodeForStorePop: encoder	^(self sizeCodeForStore: encoder) + encoder sizePop! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 1 super: false)! !!FileDirectory methodsFor: 'private' stamp: 'mtf 6/1/2010 18:47'!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	^Array new: 200 streamContents: [:stream |		self directoryContentsFor: fullPath do: [:ea | stream nextPut: ea]].! !!FileDirectory methodsFor: 'private' stamp: 'mtf 6/1/2010 18:46'!directoryContentsFor: fullPath do: aBlock"Do aBlock for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	| f entryArray index |	f := fullPath asVmPathName.	index := 1.	[(entryArray := self primLookupEntryIn: f index: index) == nil] whileFalse: [		#badDirectoryPath = entryArray ifTrue: [			^(InvalidDirectoryError pathName: pathName) signal].		index := index + 1.		aBlock value: (DirectoryEntry fromArray: entryArray directory: self) convertFromSystemName]! !!FileDirectory methodsFor: 'utilities' stamp: 'ar 8/9/2010 10:44'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file."	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st).		] ifFalse: [			extension := (FileDirectory dot, FileStream cs).		].		converter := MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension := (FileDirectory dot, FileStream cs "multiCs").		].		converter := UTF8TextConverter new.	].	fileName := useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	fileName := self checkName: fileName fixErrors: true.	f := self newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !!FileList methodsFor: 'file list' stamp: 'cmm 6/20/2010 16:35'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := self isGraphicsFileSelected		ifTrue: [#needToGetGraphic]		ifFalse: [#needToGetBrief]..	self 		changed: #fileListIndex ;		changed: #contents ;		changed: #labelString.	self updateButtonRow! !!FileList methodsFor: 'file list menu' stamp: 'cao 4/26/2010 09:36'!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| services maybeLine extraLines |	shifted ifTrue:		[^ aMenu addList: StringHolder shiftedYellowButtonMenuItems].	fileName ifNotNil:		[services := OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine := services size.		(FileStream sourceFileSuffixes includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines := OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:30'!labelString	^ directory		ifNil: [ 'File List' ]		ifNotNil:			[ fileName				ifNil: [ directory fullName ]				ifNotNil: [ directory fullNameFor: fileName ] ]! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:34'!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName := aStream localName.	pattern := '*'.	listIndex := 1.  "pretend a file is selected"	aStream close.	brevityState := #needToGetBrief.	self 		changed: #contents ; 		changed: #labelString! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:58'!availableGraphicsExtent	self dependents do: [:each |		((each isKindOf: PluggableTextMorph) and: [each getTextSelector == #contents]) ifTrue: [^each innerBounds extent - (6@22)]].	^nil! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 12:47'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #graphic ifTrue: [^ contents].	brevityState == #needToGetGraphic ifTrue: [^self readGraphicContents].		brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	(TextConverter allEncodingNames includes: brevityState) 		ifTrue: [ ^self readContentsAsEncoding: brevityState].	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:22'!defaultContents	contents := list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState := #FileList.	^ contents! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 13:08'!isGraphicsFileSelected	^fileName notNil and: [((self itemsForFile: self fullName) detect: [:each | each provider == Form and: [each selector == #importImage:]] ifNone: []) notNil]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 20:45'!readGraphicContents	| form maxExtent ext |	form := Form fromFileNamed: self fullName.	maxExtent := lastGraphicsExtent := self availableGraphicsExtent.	ext := form extent.	(maxExtent notNil and: [form extent <= maxExtent]) ifFalse: [		form := form magnify: form boundingBox by: (maxExtent x / form width min: maxExtent y / form height) asPoint smoothing: 3].	contents :=  ('Image extent: ', ext printString) asText,				(String with: Character cr),				(Text string: ' '					attribute: (TextFontReference toFont: 						(FormSetFont new							fromFormArray: (Array with: form)							asciiStart: Character space asInteger							ascent: form height))).	brevityState := #graphic.	^contents! !!FileList methodsFor: 'private' stamp: 'cmm 6/20/2010 16:33'!resort: newMode 	"Re-sort the list of files."	| name |	listIndex > 0 ifTrue: [ name := self fileNameFromFormattedItem: (list at: listIndex) ].	sortMode := newMode.	self pattern: pattern.	name ifNotNil:		[ fileName := name.		listIndex := list findFirst:			[ : item | (self fileNameFromFormattedItem: item) = name ].		self			 changed: #fileListIndex ;			 changed: #labelString ].	listIndex = 0 ifTrue: [ self changed: #contents ].	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:02'!step	| ext |	brevityState = #graphic ifTrue: [		ext := self availableGraphicsExtent.		ext = lastGraphicsExtent ifFalse: [			lastGraphicsExtent := ext.			brevityState := #needToGetGraphic.			self changed: #contents]]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:03'!stepTimeIn: aWindow	^500! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:56'!wantsSteps	^true! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 20:48'!buildFileListWith: builder	| buttons listSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttons := self buildButtonPaneWith: builder.	buttons frame: (self topConstantHeightFrame: self buttonHeight fromLeft: 0 width: 1).	top children add: buttons.		listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fileList; 		getIndex: #fileListIndex; 		setIndex: #fileListIndex:; 		menu: #fileListMenu:; 		keyPress: nil;		frame: (self frameOffsetFromTop: self buttonHeight + 4 fromLeft: 0 width: 1 bottomFraction: 1);		color: Color white.	top children add: listSpec.	^top.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 16:20'!buildWith: builder	"FileList open"	| windowSpec window |	windowSpec := 	self buildWindowWith: builder specs: {		(0@0 corner: 1@0.06) -> [self buildPatternInputWith: builder].		(0.25@0.06 corner: 1@0.5) -> [self buildFileListWith: builder].		(0@0.06 corner: 0.25@1) -> [self buildDirectoryTreeWith: builder].		(0.25@0.5 corner: 1@1) -> [self buildContentPaneWith: builder].	}.	window := builder build: windowSpec.	self changed: #selectedPath.	^window! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 4/30/2010 14:53'!buttonHeight	^Preferences standardButtonFont height + 12! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 23:00'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 22:56'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!FileList commentStamp: 'nk 11/26/2002 11:52' prior: 0!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.The FileList now provides a registration mechanism to which any tools the filelist uses ***MUST*** register.  This way it is possible to dynamically load or unload a new tool and have the FileList automatically updated.  This change supports a decomposition of Squeak and removes a problem with dead reference to classes after a major shrink.Tools should implement the following methods (look for implementors in the image):#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)#services (all provided services, to be displayed in full list)These methods both return a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.Tools must register with the FileList calling the class method #registerFileReader: when they load. They also must call #unregisterFileReader: when they unload.There is a testSuite called FileListTest that presents some examples. Stef (I do not like really this distinction passing always a file list could be better)Old Comments: FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileList2 class methodsFor: 'modal dialogs' stamp: 'ul 2/22/2010 22:28'!modalFolderSelector: aDir	| window fileModel |	window := self morphicViewFolderSelector: aDir.	fileModel := window model.	window openInWorld: self currentWorld extent: 300@400.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!FileStream class methodsFor: 'file reader services' stamp: 'ar 8/9/2010 10:46'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file. 	Uses ChangeSet defaultChangeSetDirectory for consistency."	^(ChangeSet defaultChangeSetDirectory)		writeSourceCodeFrom: aStream 		baseName: baseName 		isSt: stOrCsFlag 		useHtml: useHtml! !!FileStream class methodsFor: 'instance creation' stamp: 'eem 6/4/2010 15:10'!detectFile: aBlock do: anotherBlock	^aBlock value		ifNil: [nil]      	ifNotNil: [:file| [anotherBlock value: file] ensure: [file close]]! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:48'!absPrintExactlyOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version guarantees that the printed representation exactly represents my value	by using exact integer arithmetic."	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significand := self significandAsInteger.	roundingIncludesLimits := significand even.	exp := (self exponent - 52) max: MinValLogBase2.	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[significand ~= 16r10000000000000				ifTrue:					[r := significand bitShift: 1 + exp.					s := 2.					mPlus := mMinus := 1 bitShift: exp]				ifFalse:					[r := significand bitShift: 2 + exp.					s := 4.					mPlus := 2 * (mMinus := 1 bitShift: exp)]]		ifFalse:			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])				ifTrue:					[r := significand bitShift: 1.					s := 1 bitShift: 1 - exp.					mPlus := mMinus := 1]				ifFalse:					[r := significand bitShift: 2.					s := 1 bitShift: 2 - exp.					mPlus := 2.					mMinus := 1]].	baseExpEstimate >= 0		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]		ifFalse:			[scale := base raisedToInteger: baseExpEstimate negated.			r := r * scale.			mPlus := mPlus * scale.			mMinus := mMinus * scale].	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[r := r * base.			mPlus := mPlus * base.			mMinus := mMinus * base].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	slowbit := 1 - s lowBit .	shead := s bitShift: slowbit.	[d := (r bitShift: slowbit) // shead.	r := r - (d * s).	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * base.		mPlus := mPlus * base.		mMinus := mMinus * base.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:32'!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s * (fBase raisedToInteger: baseExpEstimate - 1).					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]				ifFalse:					[s := s * (fBase raisedToInteger: baseExpEstimate)]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index 	"Avoid primitive in Object>>at:"	^self basicAt: index! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index put: value 	"Avoid primitive in Object>>at:put:"	^self basicAt: index put: value! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:34'!basicAt: index	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 38 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index].	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:35'!basicAt: index put: value	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 39 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index put: value].	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 8/10/2007 16:58'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := (aDisplayTransform globalBoundsToLocal: innerRect) truncated.	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; cellSize: cellSize; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 5/28/2010 21:01'!ln	"This function is defined because super ln might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal ln negated].	self <= 0 ifTrue: [self error: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	int := self integerPart.	^int ln + (self / int) ln! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 6/12/2010 00:40'!log	"This function is defined because super log might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal log negated].	self <= 0 ifTrue: [self error: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	int := self integerPart.	^int log + (self / int) log! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block."	^effectNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^effectNode emitCodeForEffect: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	^valueNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28'!sizeCodeForBlockValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForValue: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:27'!sizeCodeForEffect: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForEffect: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28'!sizeCodeForValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	valueNode := MessageNode new		receiver: receiver		selector: #futureSend:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^valueNode sizeCodeForValue: encoder! !!GZipSurrogateStream commentStamp: 'nice 3/24/2010 07:36' prior: 0!A pseudo stream that allows SmartRefStream to write directly to a gzipped file. There are some peculiarities of the project exporting process that require:1. We ignore #close since the file is closed and may be reopened to continue writing. We implement #reallyClose for when we know that all writing is over.2. We use a BitBlt to write WordArrayForSegment objects. Bit of a hack, but there it is.| fileStream wa |wa := WordArrayForSegment new: 30000.1 to: wa size do: [ :i | wa at: i put: i].fileStream := GZipSurrogateStream newFileNamed: 'xxx3.gz' inDirectory: FileDirectory default.fileStream nextPutAll: 'this is a test'.fileStream nextPutAll: wa.fileStream reallyClose.!!HTTPSocket commentStamp: 'ar 7/10/2010 14:05' prior: 0!HTTPSockets is a facade for handling common HTTP requests. It provides a minimal implementation of the HTTP protocol, but can be extended by third party clients that register themselves as #httpRequestHandler (see class-side protocol).A third-party request handler needs to implement the single method	#httpRequest:url:headers:content:response:in a way that is compatible with the baseline implementation in HTTPSocket.!!HTTPSocket class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 07:17'!defaultPort	"default port to connect on"	^80! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'ar 7/10/2010 13:59'!initialize	"HTTPSocket initialize"	HTTPPort := 80.	self httpProxyServer: nil.	HTTPBlabEmail := ''.  "	'From: somebody@no.where', CrLf	"	HTTPProxyCredentials := ''.	ExternalSettings registerClient: self.	self removeHTTPProxyPreferences.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/12/2010 18:54'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	args ifNotNil: [		urlString := urlString, (self argString: args) 	].	^(self httpRequestHandler) 		httpRequest: 'GET' url: urlString headers:(			(mimeType ifNil:[''] ifNotNil:['Accept: ', mimeType, String crlf]),			'Accept: text/html', String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString		) content: nil response: nil.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:21'!httpGet: url args: args user: user passwd: passwd	"Upload the contents of the stream to a file on the server.	WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization result |	authorization := (user , ':' , passwd) base64Encoded.	result := self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	^result! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:52'!httpPost: url content: postData type: contentType accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	^(self httpRequestHandler) 		httpRequest: 'POST' url: urlString headers:(			'Accept: ', mimeType, String crlf,			'Accept: text/html', String crlf,			'Content-Type: ', contentType, String crlf,			'Content-Length: ', (postData ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString "extra user request. Authorization"		) content: (postData ifNil:['']) response: nil! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 2/25/2010 15:49'!httpPostDocument: url  args: args accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| argString  |	args ifNotNil: [		argString := self argString: args.		argString first = $? ifTrue: [argString := argString allButFirst].	].	^self httpPost: url 			content: argString 			type: 'application/x-www-form-urlencoded' 			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:31'!httpPostMultipart: url args: argsDict accept: mimeType request: requestString	" do multipart/form-data encoding rather than x-www-urlencoded "	| mimeBorder argsStream |	mimeBorder := '----squeak-georgia-tech-', Time millisecondClockValue printString, '-csl-cool-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value | | fieldValue |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, String crlf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: multipart/form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', String crlf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: String crlf, String crlf, fieldValue, String crlf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	^self httpPost: url 			content: argsStream contents			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:30'!httpPostToSuperSwiki: url args: argsDict accept: mimeType request: requestString	| mimeBorder argString |	mimeBorder := '---------SuperSwiki',Time millisecondClockValue printString,'-----'.	argString := String streamContents: [ :strm |		strm nextPutAll: mimeBorder, String crlf.		argsDict associationsDo: [:assoc |			assoc value do: [ :value |				strm					nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"';					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: value;					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: mimeBorder;					nextPutAll: String crlf.			]		].	].	^self httpPost: url 			content: argString 			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:23'!httpPost: url args: args user: user passwd: passwd	"WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization |	authorization := (user , ':' , passwd) base64Encoded.	^self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:53'!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server		WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| urlString resp header |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	resp := (self httpRequestHandler) 		httpRequest: 'PUT' url: urlString headers:(			'Authorization: Basic ', (user, ':', passwd) base64Encoded, String crlf,			'Accept: */*', String crlf,			'Content-Type: application/octet-stream', String crlf,			'Content-Length: ', (contents ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail		) content: contents response:[:rr| header := rr].	^resp isString ifTrue:[header, resp] ifFalse:[header, resp content]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:53'!httpRequest: method url: urlString headers: hdrs content: contentOrNil response: responseBlock	"Sends an HTTP request to the server. Returns a MIMEDocument if successful,	a string indicating the error otherwise. If a response block is provided, the	response is fed into into so that the sender can see all the headers."	| index serverAndPort server port rawUrl stream resp code headers 	  contentLength contentType contentStream |	(urlString beginsWith: 'http://') ifFalse:[self error: 'Not a http url'].	"Extract server, port, and url"	index := urlString indexOf: $/ startingAt: 8 ifAbsent:[urlString size+1]. "past http://"	serverAndPort := urlString copyFrom: 8 to: index-1.	server := serverAndPort copyUpTo: $:.	port := ((serverAndPort copyAfter: $:) ifEmpty:['80']) asNumber.	"Prepare the request URI"	rawUrl := urlString copyFrom: index to: urlString size.	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].	rawUrl := rawUrl encodeForHTTPWithTextEncoding: 'utf-8' 				conditionBlock: [:c | c isSafeForHTTP or:['/;&=\?' includes: c]].	"Check for proxy"	(self shouldUseProxy: server) ifTrue:[		self httpProxyServer ifNotEmpty:[			rawUrl := 'http://', serverAndPort, rawUrl. "per RFC 2616"			server := self httpProxyServer.			port := self httpProxyPort.		].	].	"Fire off the request"	stream := SocketStream openConnectionToHostNamed: server port: port.	stream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: 'HTTP/1.0'; crlf.	stream nextPutAll: 'Host: ', serverAndPort; crlf.	stream nextPutAll: 'Connection: close'; crlf.	stream nextPutAll: 'User-Agent: ', self userAgentString; crlf.	stream nextPutAll: hdrs.	stream crlf.	contentOrNil ifNotNil:[		"Upload request content"		contentStream := contentOrNil readStream.		[contentStream atEnd] whileFalse:[			(HTTPProgress new) total: contentOrNil size; 				amount: contentStream position; signal: 'Uploading...'.			stream nextPutAll: (contentStream next: 4096).			stream flush.		].	].	stream flush.	"Read the response"	resp := stream upToAll: String crlfcrlf.	"Extract the response code"	code := ((resp copyUpTo: String cr) findTokens: ' ') second asNumber.	"And the response headers"	headers := Dictionary new.	resp lines allButFirst allButLast do:[:nextLine|		headers at: (nextLine copyUpTo: $:) asLowercase 			put: (nextLine copyAfter: $:) withBlanksTrimmed.	].	"Read response content"	contentLength := headers at: 'content-length' ifAbsent:[nil].	contentType := headers at: 'content-type' ifAbsent:['application/octet-stream'].	"Fixme - Provide HTTProgress"	contentLength 		ifNil:[contentStream := WriteStream with: stream upToEnd]		ifNotNil:[			contentLength := contentLength asNumber.			contentStream := (String new: contentLength) writeStream. 			[contentStream position < contentLength] whileTrue:[				contentStream nextPutAll: 					(stream next: (contentLength - contentStream position min: 4096)).				(HTTPProgress new) total: contentLength; 					amount: contentStream position; signal: 'Downloading...'.			].		].	stream close.	responseBlock ifNotNil:[responseBlock value: resp].	^(code between: 200 and: 299) 		ifTrue:[MIMEDocument contentType: contentType 				content: contentStream contents url: urlString]		ifFalse:[resp asString, contentStream contents].! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42'!httpProxyPort	"answer the httpProxyPort"	<preference: 'HTTP Proxy Port'		category: 'HTTP Proxy'		description: 'HTTP Proxy Port'		type: #Number>	^HTTPProxyPort ifNil:[80]! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42'!httpProxyPort: aPortNumber	"Set the proxy port"	HTTPProxyPort := aPortNumber.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42'!httpProxyServer	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	<preference: 'HTTP Proxy Server'		category: 'HTTP Proxy'		description: 'HTTP Proxy Server. Leave blank if you don''t want to use a Proxy'		type: #String>	^HTTPProxyServer ifNil:['']! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:43'!httpProxyServer: aString	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	HTTPProxyServer := aString.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 7/10/2010 14:01'!removeHTTPProxyPreferences	" This method will remove the old HTTP Proxy preferences. "	(Preferences valueOfPreference: #httpProxyServer) ifNotNil:[		HTTPProxyServer := Preferences valueOfPreference: #httpProxyServer.		Preferences removePreference: #httpProxyServer.	].	(Preferences valueOfPreference: #httpProxyPort) ifNotNil:[		HTTPProxyPort := Preferences valueOfPreference: #httpProxyPort.		Preferences removePreference: #httpProxyPort.	].! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:34'!httpRequestHandler	"Answer the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket. If no handler is registered, answer the receiver"	^HTTPRequestHandler ifNil:[self]! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:35'!httpRequestHandler: anObject	"Set the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket."	HTTPRequestHandler := anObject! !!HaloMorph methodsFor: 'event handling' stamp: 'bf 6/24/2010 15:40'!mouseMove: evt	"Drag our target around or resize it"	growingOrRotating		ifTrue: [			| oldExtent newExtent newPosition |			newExtent := originalExtent + (evt position - positionOffset * 2).			(newExtent x > 1 and: [newExtent y > 1])				ifTrue: [					oldExtent := target extent.					target setExtentFromHalo: newExtent.					newPosition := target position - (target extent - oldExtent // 2).					target setConstrainedPosition: newPosition hangOut: true]]		ifFalse: [			| thePoint |			thePoint := target point: (evt position - positionOffset) from: owner.			target setConstrainedPosition: thePoint hangOut: true.		]! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:56'!dragTarget: event	"Begin dragging the target"	| thePoint |	event controlKeyPressed ifTrue: [^self growTarget: event].	growingOrRotating := false.	thePoint := target point: event position - positionOffset from: owner.	target setConstrainedPosition: thePoint hangOut: true.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:44'!growTarget: event	"Begin resizing the target"	growingOrRotating := true.	positionOffset := event position.	originalExtent := target extent.	self removeAllHandlesBut: nil.	event hand newMouseFocus: self.	event hand addMouseListener: self. "add handles back on mouse-up"! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:26'!doDupOrMakeSibling: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *not* pressed, or make a sibling if shift key *is* pressed"	^ (evt shiftPressed and: [target couldMakeSibling])		ifTrue:			[dupHandle color: Color green muchDarker.			self doMakeSibling: evt with: dupHandle]		ifFalse:			[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:28'!doMakeSiblingOrDup: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *is* pressed, or make a sibling if shift key *not* pressed"	^ (evt shiftPressed or: [target couldMakeSibling not])		ifFalse:			[self doMakeSibling: evt with: dupHandle]		ifTrue:			[dupHandle color: Color green.			self doDup: evt with: dupHandle]! !!HandMorph methodsFor: 'cursor' stamp: 'ar 6/17/2010 17:01'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset 	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	temporaryCursorOffset 		ifNotNil: [bounds := bounds translateBy: temporaryCursorOffset negated].	cursorOrNil isNil 		ifTrue: [temporaryCursor := temporaryCursorOffset := hardwareCursor := nil]		ifFalse: 			[temporaryCursor := cursorOrNil asCursorForm.			temporaryCursorOffset := temporaryCursor offset - hotSpotOffset.			(cursorOrNil isKindOf: Cursor) ifTrue: [hardwareCursor := cursorOrNil]].	bounds := self cursorBounds.	self		userInitials: userInitials andPicture: self userPicture;		layoutChanged;		changed;		showHardwareCursor: (temporaryCursor isNil).! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 17:00'!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ (submorphs anySatisfy: [ :ea | ea visible ])			or: [ (temporaryCursor notNil and: [hardwareCursor isNil])				or: [ self hasUserInformation ]]])		ifTrue: [			"using the software cursor; hide the hardware one"			self showHardwareCursor: false.			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:28'!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged := false.	savedPatch ifNotNil: 			[aCanvas drawImage: savedPatch at: savedPatch offset.			self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"			submorphs notEmpty ifTrue: [^self].			(temporaryCursor notNil and: [hardwareCursor isNil]) ifTrue: [^self].			"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset 						extent: savedPatch extent + self shadowOffset)				from: self.			self showHardwareCursor: true.			savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:52'!showHardwareCursor: aBool	"Show/hide the current hardware cursor as indicated."	| cursor |	cursor :=  hardwareCursor ifNil:[aBool ifTrue:[Cursor normal] ifFalse:[Cursor blank]].	Sensor currentCursor == cursor ifFalse: [cursor show].! !!HashedCollection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:38'!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."		anInteger < 1 ifTrue: [ ^newObject ].	^self add: newObject "I can only store an object once."	! !!HashedCollection methodsFor: 'private' stamp: 'ul 4/12/2010 22:53'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: tally * 4 // 3.	self growTo: newCapacity! !!HashedCollection commentStamp: 'ul 4/12/2010 22:37' prior: 0!I am an abstract collection of objects that implement hash and equality in a consitent way. This means that whenever two objects are equal, their hashes have to be equal too. If two objects are equal then I can only store one of them. Hashes are expected to be integers (preferably SmallIntegers). I also expect that the objects contained by me do not change their hashes. If that happens, hash invariants have to be re-established, which can be done by #rehash.Since I'm abstract, no instances of me should exist. My subclasses should implement #scanFor:, #fixCollisionsFrom: and #noCheckNoGrowFillFrom:.Instance Variables	array:		<ArrayedCollection> (typically Array or WeakArray)	tally:		<Integer> (non-negative)array	- An array whose size is a prime number, it's non-nil elements are the elements of the collection, and whose nil elements are empty slots. There is always at least one nil. In fact I try to keep my "load" at 75% or less so that hashing will work well.tally	- The number of elements in the collection. The array size is always greater than this.Implementation details:I implement a hash table which uses open addressing with linear probing as the method of collision resolution. Searching for an element or a free slot for an element is done by #scanFor: which should return the index of the slot in array corresponding to it's argument. When an element is removed #fixCollisionsFrom: should rehash all elements in array between the original index of the removed element, wrapping around after the last slot until reaching an empty slot. My maximum load factor (75%) is hardcoded in #atNewIndex:put:, so it can only be changed by overriding that method. When my load factor reaches this limit I replace my array with a larger one (see #grow) ensuring that my load factor will be less than or equal to 50%. The new array is filled by #noCheckNoGrowFillFrom: which should use #scanForEmptySlotFor: instead of #scanFor: for better performance. I do not shrink.!!HashedCollection class methodsFor: 'sizing' stamp: 'ul 4/7/2010 00:17'!goodPrimes	"Answer a sorted array of prime numbers less than one billion that make good	hash table sizes. Should be expanded as needed.  See comments below code"		^#(		5 11 17 23 31 43 59 79 107 149 199 269 359 479 641 857 1151 1549 2069		2237 2423 2617 2797 2999 3167 3359 3539 3727 3911		4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853		8783 9601 10243 10867 11549 12239 12919 13679 14293 15013 15731		17569 19051 20443 21767 23159 24611 25847 27397 28571 30047 31397		35771 38201 40841 43973 46633 48989 51631 54371 57349 60139 62969		70589 76091 80347 85843 90697 95791 101051 106261 111143 115777 120691 126311		140863 150523 160969 170557 181243 190717 201653 211891 221251 232591 242873 251443		282089 300869 321949 341227 362353 383681 401411 422927 443231 464951 482033 504011		562621 605779 647659 681607 723623 763307 808261 844709 886163 926623 967229 1014617		1121987 1201469 1268789 1345651 1429531 1492177 1577839 1651547 1722601 1800377 1878623 1942141 2028401		2242727 2399581 2559173 2686813 2836357 3005579 3144971 3283993 3460133 3582923 3757093 3903769 4061261		4455361 4783837 5068529 5418079 5680243 6000023 6292981 6611497 6884641 7211599 7514189 7798313 8077189		9031853 9612721 10226107 10745291 11338417 11939203 12567671 13212697 13816333 14337529 14938571 15595673 16147291		17851577 18993941 20180239 21228533 22375079 23450491 24635579 25683871 26850101 27921689 29090911 30153841 31292507 32467307		35817611 37983761 40234253 42457253 44750177 46957969 49175831 51442639 53726417 55954637 58126987 60365939 62666977 64826669		71582779 76039231 80534381 84995153 89500331 93956777 98470819 102879613 107400389 111856841 116365721 120819287 125246581 129732203		143163379 152076289 161031319 169981667 179000669 187913573 196826447 205826729 214748357 223713691 232679021 241591901 250504801 259470131		285162679 301939921 318717121 335494331 352271573 369148753 385926017 402603193 419480419 436157621 453034849 469712051 486589307 503366497 520043707 		570475349 603929813 637584271 671138659 704693081 738247541 771801929 805356457 838910803 872365267 905919671 939574117 973128521 1006682977 1040137411 		1073741833)"The above primes past 2069 were chosen carefully so that they do not interact badly with 1664525 (used by hashMultiply), and so that gcd(p, (256^k) +/- a) = 1, for 0<a<=32 and 0<k<=8.  See Knuth's TAOCP for details.""The above primes also try to map the values of ((0 to: 4095) collect: [ :each | each << 18 \\ prime ]) sort to an equidistant sequence of numbers. This helps to avoid the collision of chains in identity-based hashed collections. To do that  they were chosen to return a low value when the following block is evaluated with them as argument: [ :prime |	| slots cost optimalDistance previous |	slots := Array new: 4097.	0 to: 4095 do: [ :ea | slots at: ea + 1 put: ea *  262144 \\ prime ].	slots at: 4097 put: prime.	slots sort.	cost := 0.	optimalDistance := prime // 4096.	2 to: 4097 do: [ :index |		| newCost |		newCost := optimalDistance - ((slots at: index) - (slots at: index - 1)).		newCost > cost ifTrue: [ cost := newCost ] ].	cost ]."! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAll	"HashedCollection compactAll"				self allSubclassesDo: #compactAllInstances! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAllInstances	"Do not use #allInstancesDo: because compact may create new instances."	self allInstances do: #compact! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'topa 5/4/2010 14:30'!privateInitializeFromText: aString 	| remainder ind specifiedSchemeName |	remainder := aString.	schemeName ifNil: 			[specifiedSchemeName := Url schemeNameForString: remainder.			specifiedSchemeName ifNotNil: 					[schemeName := specifiedSchemeName.					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].			schemeName ifNil: 					["assume HTTP"					schemeName := 'http']].	"remove leading // if it's there"	(remainder beginsWith: '//') 		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].	"get the query"	ind := remainder indexOf: $?.	ind > 0 		ifTrue: 			[query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the authority"	ind := remainder indexOf: $/.	ind > 0 		ifTrue: 			[ind = 1 				ifTrue: [authority := '']				ifFalse: 					[authority := remainder copyFrom: 1 to: ind - 1.					remainder := remainder copyFrom: ind + 1 to: remainder size]]		ifFalse: 			[authority := remainder.			remainder := ''].	"extract the username+password"	(authority includes: $@) 		ifTrue: 			[username := authority copyUpTo: $@.			authority := authority copyFrom: (authority indexOf: $@) + 1						to: authority size.			(username includes: $:) 				ifTrue: 					[password := (username copyFrom: (username indexOf: $:) + 1 to: username size) unescapePercents.					username := username copyUpTo: $:].			username := username unescapePercents].	"Extract the port"	(authority includes: $:) 		ifTrue: 			[| lastColonIndex portString |			lastColonIndex := authority findLast: [:c | c = $:].			portString := authority copyFrom: lastColonIndex + 1 to: authority size.			portString isAllDigits 				ifTrue: 					[port := Integer readFromString: portString.					(port > 65535) ifTrue: [self error: 'Invalid port number'].					 authority := authority copyFrom: 1 to: lastColonIndex - 1]				ifFalse:[self error: 'Invalid port number']].	"get the path"	path := self privateParsePath: remainder relativeTo: #() .! !!HierarchicalUrl methodsFor: 'printing' stamp: 'topa 5/5/2010 13:47'!printOn: aStream	aStream nextPutAll: self schemeName.	aStream nextPutAll: '://'.	self username ifNotNil: [		aStream nextPutAll: self username encodeForHTTP.		self password ifNotNil: [			aStream nextPutAll: ':'.			aStream nextPutAll: self password encodeForHTTP].		aStream nextPutAll: '@' ].	aStream nextPutAll: self authority.	port ifNotNil: [aStream nextPut: $:; print: port].	path do: [ :pathElem |		aStream nextPut: $/.		aStream nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		aStream nextPut: $?.		aStream nextPutAll: self query. ].	self fragment isNil ifFalse: [		aStream nextPut: $#.		aStream nextPutAll: self fragment encodeForHTTP. ].! !!HierarchyBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^true! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:32'!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	inSeg := true.	[object := object nextObject.  		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			object isBlock ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	hashedCollections do: #rehash. "our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:33'!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.  Do this by discovering classes that need a startUp message sent to each instance, and sending it.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg noStartUpNeeded startUps cls msg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	noStartUpNeeded := IdentitySet new.	"classes that don't have a per-instance startUp message"	startUps := IdentityDictionary new.	"class -> MessageSend of a startUp message"	inSeg := true.	[object := object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class]].			inSeg ifTrue: [				(noStartUpNeeded includes: object class) ifFalse: [					cls := object class.					(msg := startUps at: cls ifAbsent: [nil]) ifNil: [						msg := cls startUpFrom: self.	"a Message, if we need to swap bytes this time"						msg ifNil: [noStartUpNeeded add: cls]							ifNotNil: [startUps at: cls put: msg]].					msg ifNotNil: [msg sentTo: object]]]]. 		object == 0] whileFalse.	hashedCollections do: #rehash.	"our purpose"	^ receiverClasses	"our secondary job"! !!InflateStream commentStamp: 'nice 3/24/2010 07:37' prior: 0!This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"For more information see the above mentioned RFC 1951 which can for instance be found at	http://www.leo.org/pub/comp/doc/standards/rfc/index.htmlHuffman Tree Implementation Notes:===========================================The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):	table := initialTable.	bitsNeeded := high 8 bits of (table at: 1).		"Determine initial bits"	table := initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"	[bits := fetch next bitsNeeded bits.			"Grab the bits"	value := table at: bits.						"Lookup the value"	value has high 8 bit set] whileTrue:[		"Check if it's leaf"		table := initialTable + (low 16 bits of value).	"No - compute new sub table start"		bitsNeeded := high 8 bit of value].		"Compute additional number of bits needed"	^value!!Inspector methodsFor: 'menu commands' stamp: 'mtf 4/25/2008 14:17'!explorePointers	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	PointerExplorer new openExplorerFor: self selection! !!InstanceVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitInstanceVariableNode: self! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:05'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVar: index.	stack pop: 1! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVar: index! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingBytecode	"Answer the bytecode of the following bytecode (different to nextByte)."	^self method at: self followingPc! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingPc	"Answer the pc of the following bytecode."	^self nextPc: (self method at: pc)! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:43'!scanFor: scanBlock	"Answer the index of the first bytecode for which scanBlock	 answers true when supplied with that bytecode."	| method end byte |	method := self method.	end := method endPC.	[pc <= end] whileTrue: 		[(scanBlock value: (byte := method at: pc)) ifTrue:			[^true].		 pc := self nextPc: byte].	^false! !!InstructionStream methodsFor: 'private' stamp: 'eem 8/13/2010 11:38'!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	| type |	type := currentByte // 16.	^type = 8 "extensions"				ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: currentByte \\ 16 + 1)]				ifFalse: [type = 10 "long jumps"							ifTrue: [pc + 2]							ifFalse: [pc + 1]]! !!Integer methodsFor: 'converting' stamp: 'MarcusDenker 12/2/2009 12:54'!asFraction	"Answer a Fraction that represents the value of the receiver."	^Fraction numerator: self denominator: 1! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 5/28/2010 21:25'!ln	"This function is defined because super ln might overflow."	| res h |	self <= 0 ifTrue: [self error: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	h := self highBit.	^2 ln * h + (self / (1 << h)) asFloat ln! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 6/12/2010 00:40'!log	"This function is defined because super log might overflow."	| res h |	self <= 0 ifTrue: [self error: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	h := self highBit.	^2 log * h + (self / (1 << h)) asFloat log! !!Integer methodsFor: 'printing' stamp: 'eem 5/21/2010 11:06'!hex	"Print the receiver as hex, prefixed with 16r.  DO NOT CHANGE THIS!!  The Cog VMMaker depends on this.	 Consider using any of		printStringHex		printStringBase: 16		printStringBase: 16 length: 8 padded: true		storeStringHex		storeStringBase: 16		storeStringBase: 16 length: 11 padded: true"	^self storeStringBase: 16! !!LazyListMorph methodsFor: 'drawing' stamp: 'mha 4/27/2010 09:33'!drawBackgroundForMulti: row on: aCanvas 	"shade the background paler, if this row is selected, but not the current selected row"	| selectionDrawBounds thisColor |	thisColor := selectedRow = row		ifTrue: [ self class listSelectionColor twiceDarker ]		ifFalse: [ self class listSelectionColor ].	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas		fillRectangle: selectionDrawBounds		color: thisColor! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	^self! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:25'!emitCodeForLoad: stack encoder: encoder	"Default is to do nothing.	 Subclasses may need to override."! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:24'!sizeCodeForLoad: encoder	"Default is to do nothing.	 Subclasses may need to override."	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:10'!sizeCodeForValue: encoder	self subclassResponsibility! !!LedCharacterMorph commentStamp: 'cbr 7/27/2010 18:47' prior: 0!I represent a character to be displayed on an LedMorph; I am a peer to LedDigitMorph. The char 36 is SPACE.I can live outside of LedMorphs, however. If you'd like to play with me, evaluate the following line:LedCharacterMorph new char: $e; openInWorld!!LeftGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:41'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!LeftGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:27'!defaultWidth	^ 5! !!LeftGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!LeftGripMorph methodsFor: 'accessing' stamp: 'ar 6/23/2010 16:51'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 0 @ 1)		offsets: (0 @ 0 negated corner: self defaultWidth @ 0)! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!ptName	^#left! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!resizeCursor	^ Cursor resizeForEdge: #left! !!Lexicon methodsFor: 'senders' stamp: 'nice 3/24/2010 23:21'!navigateToASender	"Present the user with a list of senders of the currently-selected 	message, and navigate to the chosen one"	| selectorSet chosen aSelector |	aSelector := self selectedMessageName.	selectorSet := Set new.	(self systemNavigation allCallsOn: aSelector)		do: [:anItem | selectorSet add: anItem methodSymbol].	selectorSet := selectorSet				select: [:sel | currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass].	selectorSet size = 0		ifTrue: [^ Beeper beep].	self okToChange		ifFalse: [^ self].	chosen := UIManager default chooseFrom: selectorSet asSortedArray values: selectorSet asSortedArray.	chosen isEmptyOrNil		ifFalse: [self displaySelector: chosen]! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:19'!emitCodeForValue: stack encoder: encoder	stack push: 1.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 encoder genPushSpecialLiteral: specialLiteral])		ifFalse:			[encoder genPushLiteral: index]! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:03'!sizeCodeForValue: encoder	self reserve: encoder.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizePushSpecialLiteral: specialLiteral])		ifFalse:			[^encoder sizePushLiteral: index]! !!LiteralNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitLiteralNode: self! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:44'!emitCodeForLoad: stack encoder: encoder	writeNode ifNotNil:		[encoder genPushLiteral: index.		 stack push: 1]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:43'!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:09'!emitCodeForStorePop: stack encoder: encoder	writeNode ifNil:		[stack pop: 1.		 ^encoder genStorePopLiteralVar: index].	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:17'!emitCodeForValue: stack encoder: encoder	^readNode		ifNil: [stack push: 1.			encoder genPushLiteralVar: index]		ifNotNil: [readNode emitCodeForValue: stack encoder: encoder]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:26'!sizeCodeForLoad: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [encoder sizePushLiteral: index]		ifFalse: [0]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:27'!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^writeNode sizeCode: encoder args: 1 super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2010 08:55'!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:58'!sizeCodeForValue: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialReadBinding]) 		ifFalse:			[^encoder sizePushLiteralVar: index].	readNode := MessageNode new 		receiver: (encoder encodeLiteral: key)		selector: (encoder encodeSelector: #value)		arguments: #()		precedence: #value precedence.	^readNode sizeCodeForValue: encoder! !!LiteralVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitLiteralVariableNode: self! !!LiteralVariableNode methodsFor: 'testing' stamp: 'eem 5/20/2010 09:12'!assignmentCheck: encoder at: location	^(key isVariableBinding and: [key canAssign not])		ifTrue: [location]		ifFalse: [-1]! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:32'!definitionAndCommentString	^ String streamContents: [:stream |		self printDefinitionOn: stream.		stream cr; cr.		self printCommentOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 21:36'!printCommentOn: stream	stream		nextPut: $";		nextPutAll: self comment asString;		nextPut: $"! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:33'!source	^ self definitionAndCommentString! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 6/24/2010 10:32'!fileOutMessage	"Put a description of the selected message on a file"	| fileName |	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].		 ^self].	items isEmpty ifTrue:		[^self].	fileName := UIManager default request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		items do:			[:patchOp|			patchOp definition isMethodDefinition ifTrue:				[(patchOp definition actualClass notNil				  and: [patchOp definition actualClass includesSelector: patchOp definition selector])					ifTrue:						[patchOp definition actualClass							printMethodChunk: patchOp definition selector							withPreamble: true							on: internalStream							moveSource: false							toFile: nil]					ifFalse:						[internalStream nextChunkPut: patchOp definition className, ' removeSelector: ', patchOp definition selector printString]].			patchOp definition isClassDefinition ifTrue:				[patchOp definition actualClass					ifNotNil:						[internalStream nextChunkPut: patchOp definition actualClass definition.						 patchOp definition comment ifNotNil:							[patchOp definition actualClass organization								putCommentOnFile: internalStream								numbered: 1								moveSource: false								forClass: patchOp definition actualClass]]					ifNil:						[internalStream nextChunkPut: patchOp definition className, ' removeFromSystem']]].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 10/27/2008 17:07'!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName	ifNil: [items notEmpty ifTrue:		[aMenu addList:#(('fileOut (o)'					fileOutMessage))]]	ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCConfiguration commentStamp: 'dtl 5/10/2010 23:03' prior: 0!An MCConfiguration specifies the configuration of a set of related Monticello packages. It maintains an ordered list of package versions and a list of repositories in which the packages may be found.An MCConfiguration may be filed out for storage as an array specification, and new instances can be created from a stored array specification.!!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 21:11'!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 20:56'!repositoryMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add repository...' addRepository)).	self selectedRepository ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove repository' removeRepository))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'dtl 5/10/2010 21:01'!removeRepository	repositoryIndex > 0		ifTrue: [self repositories removeAt: repositoryIndex.			repositoryIndex := 0.			self changed: #repositoryList]! !!MCConfigurationBrowser commentStamp: 'dtl 5/10/2010 21:48' prior: 0!A MCConfigurationBrowser displays an MCConfiguration, and edits the configuration to add or remove package dependencies and repository specifications. It allows a configuration to be stored in a repository or posted to an update stream.!!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:51'!notifyList	(self allFileNames includes: 'notify') ifFalse: [^ #()].	^ self readStreamForFileNamed: 'notify' do:		[:s |		s upToEnd lines]! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'topa 5/3/2010 11:26'!refresh	| packageNames |	packageNames := Set new.	packageList := nil.	versions := repository readableFileNames collect: [ :each | | name |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each | | latest |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor | | av |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCHttpRepository methodsFor: 'required' stamp: 'ar 7/21/2010 19:53'!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self displayProgress: 'Uploading ', aString during:[		response := HTTPSocket					httpPut: stream contents					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	].	"More robust handling of HTTP responses. Instead of enumerating	all possible return codes and http versions, do a quick parse"	(response beginsWith: 'HTTP/') ifTrue:[		"Looks like an HTTP header, not some error message"		statusLine := response copyUpTo: Character cr.		code := [(statusLine findTokens: ' ') second asInteger] on: Error do:[].	].	(code isInteger and:[code between: 200 and: 299]) 		ifFalse:[self error: response].! !!MCMcmReader commentStamp: 'dtl 5/10/2010 22:22' prior: 0!A MCMcmReader creates an MCConfiguration by reading an array specification from a stream.!!MCMcmUpdater commentStamp: 'dtl 5/10/2010 23:22' prior: 0!MCMcmUpdater provides utility methods for updating Monticello packages from Monticello configurations.When Monticello configurations are stored in a repository, MCMcmUpdater acts as an update stream. It first ensures that each configuration map has been loaded in sequence, then updates the last configuration map to the most recent version for each specified package, and finally loads these versions to produce a fully updated configuration. !!MCMcmWriter commentStamp: 'dtl 5/10/2010 22:20' prior: 0!An MCMcmWriter stores an MCConfiguration on a stream in the form of an array specification.!!MCMczReader methodsFor: 'as yet unclassified' stamp: 'bf 4/18/2010 18:38'!extractInfoFrom: dict	^MCWorkingCopy infoFromDictionary: dict cache: self infoCache! !!MCPackage methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33'!packageInfo	^ PackageInfo named: name! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:15'!registerForNotifications	Smalltalk		at: #SystemChangeNotifier		ifPresent:			[:cls|			cls uniqueInstance noMoreNotificationsFor: self.			self reregisterForNotificationsWith: cls uniqueInstance]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:14'!reregisterForNotificationsWith: aSystemChangeNotifier	aSystemChangeNotifier		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:! !!MCPackageManager class methodsFor: 'cleanup' stamp: 'ar 6/16/2010 19:56'!flushObsoletePackageInfos	"Flush any and all PackageInfos that are not associated with an MCPackageManager."	| pkgNames |	pkgNames := self allManagers collect:[:wcs| wcs packageName] as: Set.	PackageOrganizer default flushObsoletePackages:[:p|		p class isObsolete or:[(pkgNames includes: p packageName) not].	].! !!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'hmm 4/16/2010 22:07'!allClassNames	^ (items 		select: [:ea | (ea isOrganizationDefinition | ea isScriptDefinition) not] 		thenCollect: [:ea | ea className]) asSet.! !!MCVersionInfo methodsFor: 'converting' stamp: 'bf 4/18/2010 23:25'!asDictionary	^ Dictionary new		at: #name put: name;		at: #id put: id asString;		at: #message put: message;		at: #date put: date;		at: #time put: time;		at: #author put: author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'bf 4/19/2010 00:39'!infoFromDictionary: aDictionary cache: cache	| id |	id := (aDictionary at: #id) asString.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name ifAbsent: [''])			id: (UUID fromString: id)			message: (aDictionary at: #message ifAbsent: [''])			date: ([Date fromString: (aDictionary at: #date)] ifError: [nil])			time: ([Time fromString: (aDictionary at: #time)] ifError: [nil])			author: (aDictionary at: #author ifAbsent: [''])			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors ifAbsent: []) cache: cache)			stepChildren: (self ancestorsFromArray: (aDictionary at: #stepChildren ifAbsent: []) cache: cache)]! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'eem 7/3/2009 11:21'!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	self updateInstVars.	"Temporary conversion code -- remove later"	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.	Smalltalk addToStartUpList: self! !!MCWorkingCopy class methodsFor: 'system startup' stamp: 'eem 7/3/2009 11:34'!startUp: resuming	"Ensure Monticello is receiving system change notifications."	resuming ifTrue:		[Smalltalk			at: #SystemChangeNotifier			ifPresent: [:scn| self reregisterForNotificationsWith: scn uniqueInstance]]! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'nice 6/11/2010 21:52'!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j |	menu := self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString := aPopupMenu labelString.	items := labelString asString lines.	labelString isText ifTrue:		["Pass along text emphasis if present"		j := 1.		items := items collect:			[:item | | emphasis |			j := labelString asString findString: item startingAt: j.			emphasis := TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines := aPopupMenu lineArray.	lines ifNil: [lines := #()].	menu cancelValue: 0.	menu defaultTarget: menu.	selections := (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) selector: #selectMVCItem: argument: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !!MailMessage methodsFor: 'parsing' stamp: 'nice 6/11/2010 21:26'!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	^aStream nextLine! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 6/19/2008 09:36'!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVarLong: index.	stack pop: 1! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57'!sizeCodeForStore: encoder	^encoder sizeStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53'!sizeCodeForValue: encoder	^encoder sizePushInstVarLong: index! !!MenuMorph methodsFor: 'construction' stamp: 'nice 6/11/2010 21:52'!labels: labelList lines: linesArray selections: selectionsArray 	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelArray := (labelList isString) 				ifTrue: [labelList lines]				ifFalse: [labelList]. 	1 to: labelArray size		do: 			[:i | 			self add: (labelArray at: i) action: (selectionsArray at: i).			(linesArray includes: i) ifTrue: [self addLine]]! !!MenuStub methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2006 10:43'!click: aString	| item |	item := self items detect: [:ea | ea label = aString] ifNone: [^ self].	item action isSymbol		ifTrue: [self model perform: item action]		ifFalse: [item action value]! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForStorePop: stack encoder: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self emitCodeForEffect: stack encoder: encoder! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self sizeCodeForEffect: encoder! !!MessageNames methodsFor: 'search' stamp: 'eem 1/27/2009 10:15'!computeSelectorListFromSearchString	"Compute selector list from search string"	searchString := searchString asString copyWithout: $ . "?dubious?"	selectorList := Cursor wait showWhile:					[| sorted |					sorted := SortedCollection sortBlock:  [:x :y | x asLowercase <= y asLowercase].					(searchString findBetweenSubStrs: ';') do:						[:selPat| | raw n m |						selPat size > 0 ifTrue:							[(selPat first = $" and: [selPat last = $" and: [selPat size > 2]])								ifTrue:									[Symbol hasInterned: (selPat copyFrom: 2 to: selPat size - 1) ifTrue: [:sym| sorted add: sym]]								ifFalse:									[raw := (((n := selPat occurrencesOf: $*) > 0)										    | ((m := selPat occurrencesOf:  $#) > 0)										and: [selPat size > (n + m)])											ifTrue: [Symbol selectorsMatching: selPat]											ifFalse: [Symbol selectorsContaining: selPat].									sorted addAll: raw]]].					sorted asArray].	^selectorList! !!MessageNames methodsFor: 'selection' stamp: 'eem 6/18/2008 03:10'!selectedMessageName	^selectorListIndex = 0 ifFalse: [selectorList at: selectorListIndex]! !!MessageNames methodsFor: 'selection' stamp: 'fbs 3/31/2010 16:31'!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ messageListIndex = 0		ifTrue: [self selectorList at: selectorListIndex ifAbsent: [nil]]		ifFalse: [self messageList at: messageListIndex ifAbsent: [nil]].! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:47'!buildSearchPaneWith: builder	| buttonFrame buttonSpec textFrame textSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttonFrame := LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.3 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	textFrame := LayoutFrame new		leftFraction: 0.3 offset: 1;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	buttonSpec := builder pluggableActionButtonSpec new.	buttonSpec 		model: self;		label: 'Search';		action: [self doSearchFrom: searchPane];		frame: buttonFrame.	top children add: buttonSpec.		textSpec := builder pluggableInputFieldSpec new.	textSpec 		model: self;		name: #search;		getText: #searchString; 		setText: #searchString:notifying:;		frame: textFrame.	top children add: textSpec.	^top! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/23/2010 10:29'!buildWith: builder	"ToolBuilder open: MessageNames new"	| searchPaneHeight windowSpec max result |	searchPaneHeight := self buttonHeight.	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	windowSpec := self buildWindowWith: builder specs: {		(self topConstantHeightFrame: searchPaneHeight fromLeft: 0 width: 0.5) -> [self buildSearchPaneWith: builder].		(self selectorListFrame: max fromTop: searchPaneHeight) -> [self buildSelectorListWith: builder].		(0.5@0.0 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	searchPane := builder widgetAt: #search.	^result! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:44'!selectorListFrame: max fromTop: topOffset	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: topOffset;		rightFraction: 0.5 offset: 0;		bottomFraction: max offset: 0.! !!MessageNames methodsFor: 'class list' stamp: 'fbs 3/31/2010 22:46'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	messageListIndex > 0 ifTrue: [		^ self setClassAndSelectorIn: [:c :s | ^c]].	(selectorListIndex isNil not and: [selectorListIndex > 0]) ifTrue: [^Smalltalk classNamed: (self selectorList at: selectorListIndex)].		^ nil.	! !!MessageNode methodsFor: 'code generation' stamp: 'eem 9/29/2008 14:45'!emitCodeForCase: stack encoder: encoder value: forValue	| braceNode sizeStream allReturn |	forValue ifFalse:		[^super emitCodeForEffect: stack encoder: encoder].	braceNode := arguments first.	sizeStream := ReadStream on: sizes.	receiver emitCodeForValue: stack encoder: encoder.	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last | | thenSize elseSize |		thenSize := sizeStream next.		elseSize := sizeStream next.		last ifFalse: [encoder genDup. stack push: 1].		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.		equalNode emitCode: stack args: 1 encoder: encoder.		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.		last ifFalse: [encoder genPop. stack pop: 1].		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse:			[self emitCodeForJump: elseSize encoder: encoder.			 allReturn := false].		(last and: [allReturn]) ifTrue:			[self emitCodeForJump: elseSize encoder: encoder]].	arguments size = 2		ifTrue:			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"		ifFalse:			[NodeSelf emitCodeForValue: stack encoder: encoder.			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23'!emitCodeForEffect: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: false]		ifFalse: 			[super emitCodeForEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:12'!emitCodeForIf: stack encoder: encoder value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize := sizes at: 1.	elseSize := sizes at: 2.	(forValue not and: [elseSize * thenSize > 0]) ifTrue:		"Two-armed IFs forEffect share a single pop"		[^super emitCodeForEffect: stack encoder: encoder].	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	receiver emitCodeForValue: stack encoder: encoder.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.			pc := encoder methodStreamPosition.			thenExpr emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not ifTrue:				"...not ifTrue: avoids using ifFalse: alone during this compile)"				"Elide jump over else after a return"				[self emitCodeForJump: elseSize encoder: encoder].			elseExpr emitCodeForEvaluatedValue: stack encoder: encoder]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					thenExpr emitCodeForEvaluatedEffect: stack encoder: encoder]				ifFalse:					[self emitCodeForBranchOn: true dist: elseSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					elseExpr emitCodeForEvaluatedEffect: stack encoder: encoder]]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:28'!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:31'!emitCodeForToDo: stack encoder: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].	initStmt emitCodeForEffect: stack encoder: encoder.	test emitCodeForValue: stack encoder: encoder.	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.	pc := encoder methodStreamPosition.	block emitCodeForEvaluatedEffect: stack encoder: encoder.	incStmt emitCodeForEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23'!emitCodeForValue: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitCodeForValue: stack encoder: encoder].			arguments do: [:argument | argument emitCodeForValue: stack encoder: encoder].			pc := encoder methodStreamPosition + 1. "debug pc is first byte of the send, i.e. the next byte".			selector				emitCode: stack				args: arguments size				encoder: encoder				super: receiver == NodeSuper]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:36'!emitCodeForWhile: stack encoder: encoder value: forValue 	"L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := sizes at: 1.	loopSize := sizes at: 2.	cond emitCodeForEvaluatedValue: stack encoder: encoder.	self emitCodeForBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"	pc := encoder methodStreamPosition.	stmt emitCodeForEvaluatedEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'nice 12/27/2009 03:11'!sizeCodeForCase: encoder value: forValue	| braceNode sizeIndex elseSize allReturn |	forValue not ifTrue:		[^super sizeCodeForEffect: encoder].	equalNode := encoder encodeSelector: #=.	braceNode := arguments first.	sizes := Array new: 2 * braceNode numElements.	sizeIndex := sizes size.	elseSize := arguments size = 2		ifTrue:			[arguments last sizeCodeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode := encoder encodeSelector: #caseError.			 (NodeSelf sizeCodeForValue: encoder)			 + (caseErrorNode sizeCode: encoder args: 0 super: false)]. "self caseError"	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last |		valueNode returns ifFalse: [allReturn := false]].	braceNode casesReverseDo:		[:keyNode :valueNode :last | | thenSize |		sizes at: sizeIndex put: elseSize.		thenSize := valueNode sizeCodeForEvaluatedValue: encoder.		last ifFalse: [thenSize := thenSize + encoder sizePop].		valueNode returns ifFalse: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		(last and: [allReturn]) ifTrue: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize := elseSize + encoder sizeDup].		elseSize := elseSize					+ (keyNode sizeCodeForEvaluatedValue: encoder)					+ (equalNode sizeCode: encoder args: 1 super: false)					+ (self sizeCode: encoder forBranchOn: false dist: thenSize)					+ thenSize.		sizeIndex := sizeIndex - 2].	^(receiver sizeCodeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22'!sizeCodeForEffect: encoder	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeCodeForEffect: encoder! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:15'!sizeCodeForIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	(forValue	 or: [(thenExpr isJust: NodeNil)	 or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^super sizeCodeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize := elseExpr sizeCodeForEvaluatedValue: encoder.			thenSize := (thenExpr sizeCodeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeCode: encoder forJump: elseSize]).			branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize := 0.					thenSize := thenExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]				ifFalse:					[thenSize := 0.					elseSize := elseExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: true dist: elseSize]].	sizes := Array with: thenSize with: elseSize.	^(receiver sizeCodeForValue: encoder)	+ branchSize + thenSize + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:57'!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector key == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector key == theSelector 					dist: theSize)				+ theSize]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:09'!sizeCodeForToDo: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize initSize limitInit |	block := arguments at: 3.	initStmt := arguments at: 4.	test := arguments at: 5.	incStmt := arguments at: 6.	limitInit := arguments at: 7.	initSize := initStmt sizeCodeForEffect: encoder.	limitInit == nil ifFalse:		[initSize := initSize + (limitInit sizeCodeForEffect: encoder)].	blockSize := (block sizeCodeForEvaluatedEffect: encoder)			+ (incStmt sizeCodeForEffect: encoder)			+ (encoder sizeJumpLong: -1).	loopSize := (test sizeCodeForValue: encoder)			+ (self sizeCode: encoder forBranchOn: false dist: blockSize)			+ blockSize.	sizes := Array with: blockSize with: loopSize.	^initSize	+ loopSize	+ (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22'!sizeCodeForValue: encoder	| total |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector := selector copy "only necess for splOops"].	total := selector sizeCode: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total := total + (receiver sizeCodeForValue: encoder)].	sizes := arguments collect: 					[:arg | | argSize | 					argSize := arg sizeCodeForValue: encoder.					total := total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:00'!sizeCodeForWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).	branchSize := self					sizeCode: encoder					forBranchOn: selector key == #whileFalse:  "Btp for whileFalse"					dist: stmtSize.	loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.	sizes := Array with: stmtSize with: loopSize.	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:33'!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:32'!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifTrue:		[((caseNode blockAssociationCheck: encoder)		  and: [arguments size = 1			    or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder]]) ifFalse:			[^false].		 caseNode elements do:			[:messageNode|			messageNode receiver noteOptimizedIn: self.			messageNode arguments first noteOptimizedIn: self].		 arguments size = 2 ifTrue:			[arguments last noteOptimizedIn: self].		 ^true].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not]) ifTrue:		[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19'!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18'!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:31'!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment := encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit := arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:17'!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).		 receiver noteOptimizedIn: self.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimizedIn: self.			arguments first noteOptimizedIn: self.			true]! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitMessageNode: self! !!MessageNode commentStamp: '<historical>' prior: 0!I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.!!MessageNode class methodsFor: 'class initialization' stamp: 'eem 8/15/2010 10:22'!initialize		"MessageNode initialize"	MacroSelectors := 		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers := 		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters := 		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:).	MacroSizers := 		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:			sizeCodeForToDo:value: sizeCodeForToDo:value:			sizeCodeForCase:value: sizeCodeForCase:value:			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:).	MacroPrinters := 		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04'!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay time0 |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[true] whileTrue: [			| observedProcess startTime |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"			SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |				gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04'!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess := Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[ true ] whileTrue: [			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |			gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0 ]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04'!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [			[				| startTime |				startTime := Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess 						ifTrue: [ observedProcess ]						ifFalse: [ nil ])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |		gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].	time := Time millisecondClockValue - time0! !!MethodContext methodsFor: 'initialize-release' stamp: 'eem 9/10/2009 15:49'!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	closureOrNil		ifNotNil:			[pc := closureOrNil startpc.			self stackp: closureOrNil numArgs + closureOrNil numCopiedValues.			1 to: closureOrNil numCopiedValues do:				[:i | self tempAt: closureOrNil numArgs + i put: (closureOrNil at: i)]]		ifNil:			[pc := method initialPC.			self stackp: method numTemps.			method numArgs+1 to: method numTemps do:				[:i | self tempAt: i put: nil]]! !!MethodContext methodsFor: 'system simulation' stamp: 'eem 7/2/2010 10:26'!pushArgs: args "<Array>" from: sendr "<ContextPart>" 	"Helps simulate action of the value primitive for closures.	 This is used by ContextPart>>runSimulated:contextAtEachStep:"	closureOrNil		ifNil: [self error: 'context needs a closure!!']		ifNotNil:			["See BlockClosure>>asContextWithSender:"			 stackp ~= (closureOrNil numArgs + closureOrNil numCopiedValues) ifTrue:				[self error: 'stack pointer is incorrect!!'].].	1 to: closureOrNil numArgs do:		[:i| self at: i put: (args at: i)].	sender := sendr! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 6/18/2010 21:38'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	^(array at: (self scanFor: key)) 		ifNil: [ aBlock value ]		ifNotNil: [ :value | key -> value ]! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:04'!compact	"Make sure that I have the highest possible load factor (at least 50%)."		self become: self compactWithoutBecome! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:05'!compactWithoutBecome	"Return a copy of self which has the highest possible load factor (at least 50%)."		| newSelf |	newSelf := self class new: self size.	self keysAndValuesDo: [ :key :value |		newSelf at: key put: value ].	^newSelf! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:48'!compactAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #compactWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:49'!rehashAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #rehashWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodNode methodsFor: 'code generation' stamp: 'eem 7/14/2010 11:28'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is arbitrary but is typically either the reference	 to the source code that is stored with every CompiledMethod, or an	 encoding of the method's temporary names."	| primErrNode blkSize nLits literals stack method |	self generate: trailer ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primErrNode					ifNil: [0]					ifNotNil: [primErrNode sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).	method := CompiledMethod				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments,											  temporaries,											  (primErrNode												ifNil: [#()]												ifNotNil: [{primErrNode}]).									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].	stack position: method numTemps.	block emitCodeForEvaluatedValue: stack encoder: encoder.	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!MethodNode methodsFor: 'code generation' stamp: 'Igor.Stasenko 12/20/2009 06:16'!generateWithTempNames	"Answer a CompiledMethod with temps names encoded in trailer"	^ self generate: (CompiledMethodTrailer new tempNames: self schematicTempNamesString).! !!MethodNode methodsFor: 'code generation' stamp: 'eem 11/29/2008 18:53'!properties	^properties! !!MethodNode methodsFor: 'printing' stamp: 'eem 8/15/2010 10:36'!printWithClosureAnalysisOn: aStream 	self ensureClosureAnalysisDone.	precedence = 1		ifTrue: 			[(self selector includesSubString: '()/')				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).						arguments							do: [:arg| aStream nextPutAll: arg key]							separatedBy: [aStream nextPutAll: ', '].						aStream nextPut: $)]				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				arg printDefinitionForClosureAnalysisOn: aStream.				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			 self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1; nextPut: $|.			temporaries do: [:temp | 				aStream space.				temp printDefinitionForClosureAnalysisOn: aStream].			aStream space; nextPut: $|].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitMethodNode: self! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 15:27'!addLocalsToPool: locals "<Set of: TempVariableNode>"	localsPool isNil ifTrue:		[localsPool := IdentitySet new].	localsPool addAll: locals! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2008 10:04'!ensureClosureAnalysisDone	block blockExtent ifNil:		[temporaries := block analyseArguments: arguments temporaries: temporaries rootNode: self]! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 13:43'!locationCounter	^locationCounter! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:27'!noteBlockEntry: aBlock	"Evaluate aBlock with the numbering for the block entry."	locationCounter isNil ifTrue:		[locationCounter := -1].	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 12:12'!noteBlockExit: aBlock	"Evaluate aBlock with the numbering for the block exit."	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:07'!referencedValuesWithinBlockExtent: anInterval 	^(localsPool select:		[:temp|		 temp isReferencedWithinBlockExtent: anInterval]) collect:			[:temp|			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:59'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	^encoder blockExtentsToTempsMap ifNil:		[| methNode |		methNode := encoder classEncoding parserClass new						encoderClass: encoder class;						parse: (sourceText ifNil: [self decompileString])						class: self methodClass.		"As a side effect generate: creates data needed for the map."		methNode generate.		methNode encoder blockExtentsToTempsMap]! !!MethodNode methodsFor: 'debugger support' stamp: 'eem 7/1/2009 13:45'!hasGeneratedMethod	^encoder hasGeneratedMethod! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:58'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occur	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with the schematicTempNamesString."	encoder hasGeneratedMethod ifFalse:		["create the encoder's blockExtentsToLoals map, except if the method is quick		  in which case it has no temps."		(self generate) isQuick ifTrue:			[^'']].	^encoder schematicTempNamesString! !!MethodNode commentStamp: 'eem 8/15/2010 10:49' prior: 0!I am the root of the parse tree..Instance Variables	arguments:			<SequenceableCollection>	block:				<BlockNode>	encoder:			<BytecodeEncoder>	localsPool:			<IdentitySet>	locationCounter:	<Integer>	precedence:		<Integer>	primitive:			<Integer>	properties:			<AdditionalMethodState|nil>	selectorOrFalse:	<Object>	sourceText:		<String|Text>	temporaries:		<SequenceableCollection>arguments	- the collection of parsed or decompiled method argumentsblock	- the BlockNode holding the method's statementsencoder	- the object that comprises the copiler's scope table, literal pool and back-end bytecode generatorlocalsPool	- a set used to determine the set of copied values for each block in the methodlocationCounter	- an integer used to mark block scopes for the purposes of the closure transformation.  See BlockNode>>#analyseArguments:temporaries:rootNode:precedence	- the precedence of the method's selector (see Symbol>>precedence)primitive	- if non-zero this is the integer code of the method's primitiveproperties	- the object used to accumulate method properties (a.k.a. pragmas)selectorOrFalse	- the method's selector or false if this is a doitsourceText	- the source test from which the method was compiledtemporaries	- the collection of parsed or decompiled method temporaries!!MethodReference methodsFor: 'queries' stamp: 'eem 5/25/2010 17:56'!selector	^methodSymbol! !!Morph methodsFor: 'events-processing' stamp: 'bf 6/24/2010 13:15'!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	(anEvent controlKeyPressed			and: [anEvent blueButtonChanged not				and: [Preferences cmdGesturesEnabled]])		ifTrue: [^ self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].		"this mouse down could be the start of a gesture, or the end of a gesture focus"	(self isGestureStart: anEvent)		ifTrue: [^ self gestureStart: anEvent].	self mouseDown: anEvent.	Preferences maintainHalos		ifFalse:[ anEvent hand removeHaloFromClick: anEvent on: self ].	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!Morph methodsFor: 'menus' stamp: 'cmm 8/2/2010 18:20'!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsUsing:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsUsing:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetPoint) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !!Morph class methodsFor: 'new-morph participation' stamp: 'ar 7/21/2010 20:03'!partName: aName categories: aList documentation: aDoc sampleImageForm: aForm	"Answer a DescriptionForPartsBin which will represent a launch of a new instance of my class via the #newStandAlone protocol sent to my class. Use the category-list and documentation provided.  This variant allows an overriding image form to be provided, useful in cases where we don't want to launch a sample instance just to get the form"	| descr |	descr := DescriptionForPartsBin new		formalName: aName		categoryList: aList		documentation: aDoc		globalReceiverSymbol: self name		nativitySelector: #newStandAlone.	descr sampleImageForm: aForm.	^ descr! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'fbs 5/2/2010 15:31'!buildPluggableList: aSpec	| widget listClass getIndex setIndex |	aSpec getSelected ifNil:[		listClass := self listClass.		getIndex := aSpec getIndex.		setIndex := aSpec setIndex.	] ifNotNil:[		listClass := self listByItemClass.		getIndex := aSpec getSelected.		setIndex := aSpec setSelected.	].	widget := listClass on: aSpec model				list: aSpec list				selected: getIndex				changeSelected: setIndex				menu: aSpec menu				keystroke: aSpec keyPress.	self register: widget id: aSpec name.	widget getListElementSelector: aSpec listItem.	widget getListSizeSelector: aSpec listSize.	widget doubleClickSelector: aSpec doubleClick.	widget dragItemSelector: aSpec dragItem.	widget dropItemSelector: aSpec dropItem.	widget wantsDropSelector: aSpec dropAccept.	widget autoDeselect: aSpec autoDeselect.	widget keystrokePreviewSelector: aSpec keystrokePreview.	aSpec color isNil ifFalse: [widget color: aSpec color].	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	panes ifNotNil:[		aSpec list ifNotNil:[panes add: aSpec list].	].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'eem 6/30/2010 15:52'!buildPluggableWindow: aSpec	| widget children |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec multiWindowStyle) new.	self register: widget id: aSpec name.	widget model: aSpec model.	aSpec label ifNotNil:		[:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	children := aSpec children.	children isSymbol ifTrue:[		widget getChildrenSelector: children.		widget update: children.		children := #().	].	widget closeWindowSelector: aSpec closeAction.	panes := OrderedCollection new.	self buildAll: children in: widget.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: (aSpec extent ifNil:[widget initialExtent])		world: self currentWorld).	widget setUpdatablePanesFrom: panes.	^widget! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'eem 6/30/2010 11:44'!windowClassFor: multiWindowStyle	^multiWindowStyle		caseOf:		{	[nil]				->	[PluggableSystemWindow].			[#labelButton]	->	[PluggableSystemWindowWithLabelButton] }		otherwise:				[PluggableSystemWindowWithLabelButton]! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 7/22/2010 14:27'!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	"By default, don't style in UIManager edit: requests"	window model		shouldStyle: false;		acceptContents:  aText;		acceptAction: anAction.	^window.! !!MorphicUIManager commentStamp: 'dtl 5/2/2010 16:07' prior: 0!MorphicUIManager is a UIManager that implements user interface requests for a Morphic user interface.!!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:13'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:03'!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08'!basicUpTo: delim	^ super upTo: delim.! !!MultiWindowLabelButtonMorph methodsFor: 'drawing' stamp: 'eem 5/6/2008 13:24'!drawOn: aCanvas 	"Be invisible."! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 17:03'!performAction	"Override to interpret the actionSelector as a menu accessor and to activate that menu."	actionSelector ifNotNil:		[(model perform: actionSelector) ifNotNil:			[:menu|			menu				invokeModalAt: self position - (0@5)				in: ActiveWorld				allowKeyboard: Preferences menuKeyboardControl]]! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState	"Answer the value of savedMultiWindowState"	^ savedMultiWindowState! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState: anObject	"Set the value of savedMultiWindowState"	savedMultiWindowState := anObject! !!MultiWindowLabelButtonMorph commentStamp: 'eem 6/30/2010 16:13' prior: 0!A MultiWindowLabelButtonMorph is  a means of implementing tabbed windows.  It cooperates with PluggableSystemWindowWithButton to provide a drop-down menu of windows when clicking in the window label.  It requires the model to create a suitable sub-instance of SavedMultiWindowState for inactive windows.  To specify multi-windows use the multiWindowStyle: setter to customize a PluggableWindowSpec.Instance Variables	savedMultiWindowState:		<SavedMultiWindowState>savedMultiWindowState	- the sequence of models in a multi-window.!!NewArrayNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitNewArrayNode: self! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58'!emitCodeForValue: stack encoder: encoder	encoder genPushNewArray: numElements.	stack push: 1! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58'!sizeCodeForValue: encoder	^encoder sizePushNewArray: numElements! !!NewParagraph methodsFor: 'access' stamp: 'cmm 4/5/2010 16:24'!caretWidth	^ Editor dumbbellCursor		ifTrue: [ 2 ]		ifFalse: [ 0 ]! !!Number methodsFor: 'truncation and round off' stamp: 'wiz 3/1/2007 20:17'!roundDownTo: aNumber 	"Answer the next multiple of aNumber toward negative infinity that is nearest the 	receiver."	^(self/aNumber) floor * aNumber! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 4/2/2010 20:25'!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!Object methodsFor: 'updating' stamp: 'eem 6/15/2008 16:02'!okToClose	"Allows a controller to ask this of any model"	^self okToChange! !!Object methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^false! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:41'!explorePointers	"Open a PointerExplorer on the current selection"	PointerExplorer new openExplorerFor: self object! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:40'!genericMenu: aMenu 	"Borrow a menu from my inspector"	| insideObject menu parentObject |	currentSelection		ifNil: [menu := aMenu.			menu				add: '*nothing selected*'				target: self				selector: #yourself]		ifNotNil: [insideObject := self object.			parentObject := self parentObject.			inspector				ifNil: [inspector := Inspector new].			inspector inspect: parentObject;				 object: insideObject.			aMenu defaultTarget: inspector.			inspector fieldListMenu: aMenu.			aMenu items				do: [:i | (#(#inspectSelection #exploreSelection #referencesToSelection #defsOfSelection #objectReferencesToSelection #chasePointers #explorePointers) includes: i selector)						ifTrue: [i target: self]].			aMenu addLine;				add: 'monitor changes'				target: self				selector: #monitor:				argument: currentSelection].	monitorList isEmptyOrNil		ifFalse: [aMenu addLine;				add: 'stop monitoring all'				target: self				selector: #stopMonitoring].	^ aMenu! !!ObjectFinalizer commentStamp: 'jcg 4/27/2010 01:01' prior: 0!Represents an action that is to be taken when a target object (not referenced by the ObjectFinalizer) is garbage-collected.!!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'initialize-release' stamp: 'eem 9/5/2009 21:03'!initialize	inOptimizedBlock := false! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'accessing' stamp: 'eem 9/8/2008 14:30'!readBeforeWritten	^readBeforeWritten ifNil: [IdentitySet new]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:28'!visitAssignmentNode: anAssignmentNode	anAssignmentNode value accept: self.	anAssignmentNode variable isTemp		ifTrue:			[written ifNil: [written := IdentitySet new].			 written add: anAssignmentNode variable]		ifFalse:			[anAssignmentNode variable accept: self]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:09'!visitBlockNode: aBlockNode	| savedWritten |	"If we're in the optimized block in one side of an optimized ifTrue:ifFalse: et al	 leave it to the enclosing visitMessageNode: activation to handle merging written."	inOptimizedBlock ifTrue:		[^super visitBlockNode: aBlockNode].	"If we're not then don't update written because without evaluating the guard(s)	 we can't tell if the block is evaluated or not, and we must avoid false positives."	savedWritten := written copy.	super visitBlockNode: aBlockNode.	written := savedWritten! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:03'!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector key]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/8/2008 14:43'!visitTempVariableNode: aTempVariableNode	(aTempVariableNode isArg	 or: [written notNil		and: [written includes: aTempVariableNode]]) ifTrue:		[^self].	readBeforeWritten ifNil:		[readBeforeWritten := IdentitySet new].	readBeforeWritten add: aTempVariableNode! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor commentStamp: '<historical>' prior: 0!Answer the set of temporary variables that are read before they are written in the visited parse tree.  Used by the compiler to detect those block-local temporaries of blocks in optimized loops that require nilling to prevent a value from a previous iteration persisting into a subsequent one.!!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtFirst	"Add new empty slots to the front of array, while keeping the empty slots at the end."	| newArray newFirstIndex newLastIndex |	newArray := Array new: (array size * 2 max: 1).	newFirstIndex := newArray size - array size + firstIndex.	newLastIndex := newFirstIndex + lastIndex - firstIndex.	newArray 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array := newArray.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtLast	"Add new empty slots to the end of array, while keeping the empty slots at the front."	| newArray |	newArray := Array new: (array size * 2 max: 1).	newArray 		replaceFrom: firstIndex		to: lastIndex		with: array		startingAt: firstIndex.	array := newArray! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42'!makeRoomAtFirst	"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= array size ifTrue: [ ^self growAtFirst ].	tally = 0 ifTrue: [ ^self resetTo: array size + 1 ].	newFirstIndex := array size // 2 + 1.	newLastIndex := newFirstIndex - firstIndex + lastIndex.	0 to: tally - 1 do: [ :offset |		array at: newLastIndex - offset put: (array at: lastIndex - offset) ].	array from: firstIndex to: newFirstIndex - 1 put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42'!makeRoomAtLast	"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].	tally = 0 ifTrue: [ ^self resetTo: 1 ].	newLastIndex := lastIndex // 2.	newFirstIndex := newLastIndex - lastIndex + firstIndex.	array 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array from: newLastIndex + 1 to: lastIndex put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:20'!reset	self resetTo: 1! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jmv 4/15/2010 10:18'!processTransparencyChunk	| red green blue |	"Transcript show: '  TRANSPARENCY ',chunk printString."	colorType = 0 ifTrue: [		transparentPixelValue := chunk unsignedShortAt: 1 bigEndian: true.		palette at: transparentPixelValue put: Color transparent.		^self	].	colorType = 2 ifTrue: [		red := chunk at: 2.		green := chunk at: 2.		blue := chunk at: 2.		transparentPixelValue := 16rFF00 + red << 8 + green << 8 + blue.		^self	].	colorType = 3 ifTrue: [		chunk withIndexDo: [ :alpha :index |			palette at: index put: ((palette at: index) alpha: alpha/255)		].		^self	].! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'jmv 4/15/2010 10:19'!grayColorsFor: d	"return a color table for a gray image"	palette := Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^  palette		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 85.0 / 255.0).		palette at: 3 put: (Color gray: 170.0 / 255.0).		palette at: 4 put: Color white.		^ palette		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ul 4/28/2010 11:22'!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| base bits |	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This Smalltalk version might be easier to understand than the others below."	base := y * form width * bitsPerChannel // 32 + 1.	bits := form bits.	0 to: thisScanline size - 1 // 4 do: [ :i |		| ii word |		ii := i * 4.		"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 		is to make use of faster arithmetic bytecodes, but not of slow largeintegers."		word :=			(((thisScanline at: ii + 1) * 256 + 			(thisScanline at: ii + 2) * 256 + 			(thisScanline at: ii + 3)) bitShift: 8) bitOr: 			(thisScanline at: ii + 4).		bits at: base + i put: word ].			"This interesting technique (By Andreas Raab) is faster for very large images, but might be slower for small ones"	"^self copyPixelsGrayWeirdBitBltHack: y ".	"It uses the following method:	PNGReadWriter >> copyPixelsGrayWeirdBitBltHack: y 	""Handle non-interlaced black and white color mode (colorType = 0)	By Andreas Raab""		| source dest cmap |	source := Form extent: 1 @ (thisScanline size // 4) depth: 32 bits: thisScanline.	dest := Form extent: 1 @ (form bits size) depth: 32 bits: form bits.	cmap := Smalltalk isLittleEndian		ifTrue:[ColorMap 					shifts: #(-24 -8 8 24) 					masks: #(16rFF000000 16r00FF0000 16r0000FF00 16r000000FF)].	(BitBlt toForm: dest)		sourceForm: source;		destX: 0 destY: (y * form width*bitsPerChannel//32) width: 1 height: (form width+31*bitsPerChannel//32);		colorMap: cmap;		combinationRule: 3;		copyBits."			"This interesting technique  (By Yoshiki Ohshima) is faster for very large images, but might be slower for small ones"	"form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32)".	"It uses the following method:	BitMap >> copyFromByteArray2: byteArray to: i	""This method should work with either byte orderings""	| myHack byteHack |	myHack := Form new hackBits: self.	byteHack := Form new hackBits: byteArray.	Smalltalk  isLittleEndian ifTrue: [byteHack swapEndianness].	byteHack displayOn: myHack at:  0@i"! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11'!test1"PNGReadWriter test1"	| d0 d1 fileInfo book d2 f |	Debugging := true.	1 = 1 ifTrue: [		book := BookMorph new.		book setProperty: #transitionSpec toValue: {'silence'. #none. #none}.	].	d0 := FileDirectory default.	d1 := d0 directoryNamed: 'PngSuite Folder'.	d2 := d0 directoryNamed: 'BIG PNG'.	{d0. d1. d2}.		"keep compiler quiet""==citrus_none_sub.pngcitrus_adm7_adap.pngcitrus_adm7_aver.pngcitrus_adm7_non.pngcitrus_adm7_paeth.pngpngs-img-ie5mac.png=="	fileInfo := {		d2. {'citrus_adm7_adap.png'}.		"d1. d1 fileNames."	}.	fileInfo pairsDo: [ :dir :fileNames |		fileNames do: [ :each | | error data t |			Transcript cr; show: each.			data := (dir fileNamed: each) contentsOfEntireFile.			error := ''.			MessageTally spyOn: [				t := [ | result |					result := self createAFormFrom: data.					f_ result first.					error := result second.				] timeToRun.].			self insertMorph: f asMorph named: each into: book.			Transcript show: each,'  ',data size printString,' = ',t printString,' ms',error; cr.		].	].	book ifNotNil: [book openInWorld].	Debugging := false.! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 16:39'!nextImage	"read one image"	| data p |	first ifNil:[		first := false.		data := stream contentsOfEntireFile.		stream := (RWBinaryOrTextStream with: data) reset.	]	ifNotNil:[		type < 4 ifTrue:[			self error:'Plain PBM, PGM or PPM have only one image'		].	].	stream ascii.	p := stream next.	type := (stream next) asInteger - 48.	(p = $P and:[type > 0 and:[type < 8]]) ifFalse:[		self error:'Not a PNM file'	].	type = 7 ifTrue:[		self readHeaderPAM	]	ifFalse: [		self readHeader	].	type caseOf: {		[1] 	->	[^self readPlainBW].		[2] 	->	[^self readPlainGray].		[3] 	->	[^self readPlainRGB].		[4] 	->	[^self readBWreverse: false].		[5] 	->	[^self readGray].		[6] 	->	[^self readRGB].		[7] 	->	[	"PAM"					(tupleType asUppercase) caseOf: {						['BLACKANDWHITE'] 		-> [^self readBWreverse: true].						['GRAYSCALE'] 			-> [^self readGray].						['RGB'] 					-> [^self readRGB].						['RGB_ALPHA'] 			-> [^self error:'Not implemented'].						['GRAYSCALE_ALPHA'] 	-> [^self error:'Not implemented'].					} otherwise: [^self readData].				]	}! !!PackageInfo methodsFor: 'testing' stamp: 'bf 4/19/2010 02:54'!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!PackageOrganizer methodsFor: 'registering' stamp: 'ar 6/16/2010 19:57'!flushObsoletePackages: aBlock	"Flush all packages considered obsolete by evaluating the argument block."	packages keys do:[:key|		(aBlock value: (packages at: key)) ifTrue:[packages removeKey: key].	].	self changed: #packages; changed: #packageNames.! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'eem 7/1/2010 10:22'!labelString	^self package		ifNil: [super labelString]		ifNotNil:			[:pkg| | label |			label := self defaultBrowserTitle, ': ', pkg, (self selectedClass														ifNil: ['']														ifNotNil: [' ', self selectedClass printString]).			(multiWindowState notNil			 and: [multiWindowState models size > 1]) ifTrue:				[label := (multiWindowState models indexOf: self) printString, '. ', label].			label]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^true! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:36'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self package			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 self selectedClass					ifNil: [self selectedSystemCategoryName							ifNil: [s nextPutAll: pkg]							ifNotNil: [:cat| s nextPutAll: cat]]					ifNotNil:						[:class|						 s nextPutAll: pkg; space; print: class.						 self metaClassIndicated ifTrue:							[s nextPutAll: ' class']]].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:31'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'restoreToPackage:')			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 s nextPutAll: pkg.				(getarg value: 'className:')					ifNil: [(getarg value: 'category:') ifNotNil:							[:categoryName| s nextPut: $-; nextPutAll: categoryName]]					ifNotNil:						[:className|						s space; nextPutAll: className.						(getarg value: 'meta:') ifTrue:							[s nextPutAll: ' class'].						  self isHierarchy ifTrue:							[s space; nextPutAll: ' Hierarchy'].						(getarg value: 'selector:')							ifNil: [(getarg value: 'protocol:') ifNotNil:									[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]							ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24'!restoreToPackage: packageNameOrNil category: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self packageListIndex: (self packageList indexOf: packageNameOrNil).	super restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24'!saveMultiWindowState	^Message		selector: #restoreToPackage:category:className:protocol:selector:mode:meta:		arguments: {	self package.						self systemCategoryList at: systemCategoryListIndex ifAbsent: [].						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!ParagraphEditor methodsFor: 'explain' stamp: 'eem 8/14/2010 11:15'!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block"	^self emitCodeForValue: stack encoder: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:37'!emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder	stack pop: 1.	dist = 0 ifTrue: [^encoder genPop].	condition		ifTrue: [encoder genBranchPopTrue: dist]		ifFalse: [encoder genBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38'!emitCodeForEffect: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genPop.	stack pop: 1! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:39'!emitCodeForJump: dist encoder: encoder	dist = 0 ifFalse: [encoder genJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38'!emitCodeForReturn: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genReturnTop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13'!sizeCode: encoder forBranchOn: condition dist: dist	dist = 0 ifTrue: [^encoder sizePop].	^condition		ifTrue: [encoder sizeBranchPopTrue: dist]		ifFalse: [encoder sizeBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:52'!sizeCode: encoder forJump: dist	^dist = 0 ifTrue: [0] ifFalse: [encoder sizeJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeCodeForValue: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:53'!sizeCodeForEffect: encoder	^(self sizeCodeForValue: encoder) + encoder sizePop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:57'!sizeCodeForReturn: encoder	^(self sizeCodeForValue: encoder) + encoder sizeReturnTop! !!ParseNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33'!accept: aVisitor	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.	 All such implementations under ParseNode should answer the result of the dispatch, e.g.		^aVisitor visitBlockNode: self"	^self subclassResponsibility! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 20:08'!visitMessageNode: aMessageNode	aMessageNode receiver accept: self.	"receiver notNil ifTrue: ''receiver is nil for cascades''		[receiver accept: self]."	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode! !!Parser methodsFor: 'error correction' stamp: 'jcg 6/23/2010 11:46'!correctVariable: proposedVariable interval: spot 	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding := requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	action := UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!Parser methodsFor: 'error correction' stamp: 'eem 7/6/2010 15:07'!declareClassVar: name	| sym class |	sym := name asSymbol.	class := encoder classEncoding.	class := class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	Smalltalk logChange: class definition.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Parser methodsFor: 'error correction' stamp: 'eem 5/6/2010 21:14'!declareInstVar: name	"Declare an instance variable.  Since the variable will get added after any existing	 inst vars its index is the instSize."	encoder classEncoding addInstVarName: name.	Smalltalk logChange: encoder classEncoding definition.	^InstanceVariableNode new name: name index: encoder classEncoding instSize		! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:35'!declareTemp: name at: levelTag	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^(encoder bindUndeclaredTemp: name)		tag: levelTag;		yourself! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 19:34'!declareTempAndPaste: name	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^encoder bindUndeclaredTemp: name! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:37'!declareUndeclaredTemps: methodNode	"Declare any undeclared temps, declaring them at the smallest enclosing scope."	| undeclared userSelection blocksToVars |	(undeclared := encoder undeclaredTemps) isEmpty ifTrue:		[^self].	userSelection := requestor selectionInterval.	blocksToVars := IdentityDictionary new.	undeclared do:		[:var|		(blocksToVars			at: (var tag == #method					ifTrue: [methodNode block]					ifFalse: [methodNode accept: (VariableScopeFinder new ofVariable: var)])			ifAbsentPut: [SortedCollection new]) add: var name].	(blocksToVars removeKey: methodNode block ifAbsent: []) ifNotNil:		[:rootVars|		rootVars do: [:varName| self pasteTempAtMethodLevel: varName]].	(blocksToVars keys sorted: [:a :b| a tempsMark < b tempsMark]) do:		[:block| | decl |		decl := (blocksToVars at: block) reduce: [:a :b| a, ' ', b].		block temporaries isEmpty			ifTrue:				[self substituteWord: ' | ', decl, ' |'					wordInterval: (block tempsMark + 1 to: block tempsMark)					offset: requestorOffset]			ifFalse:				[self substituteWord: decl, ' '					wordInterval: (block tempsMark to: block tempsMark - 1)					offset: requestorOffset]].	requestor selectInvisiblyFrom: userSelection first to: userSelection last + requestorOffset.	ReparseAfterSourceEditing signal! !!Parser methodsFor: 'error correction' stamp: 'eem 8/13/2010 19:34'!pasteTempAtMethodLevel: name	| insertion delta theTextString characterBeforeMark |	theTextString := requestor text string.	characterBeforeMark := theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion := name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion := ' ', insertion].		delta := 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion := '| ' , name , ' |',String cr.		delta := 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion := insertion , String tab.			delta := delta + 1.	"the tab"		].	].	tempsMark := tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta! !!Parser methodsFor: 'error correction' stamp: 'eem 8/15/2010 08:56'!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str madeChanges | 	madeChanges := false.	str := requestor text asString.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp | | start end |		(UnusedVariable name: temp) ifTrue:			[(encoder lookupVariable: temp ifAbsent: []) isUndefTemp				ifTrue:					[end := tempsMark.					["Beginning at right temp marker..."					start := end - temp size + 1.					end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]						whileFalse:							["Search left for the unused temp"							end := requestor nextTokenFrom: end direction: -1].					end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start := start-1].						requestor correctFrom: start to: end with: ''.						str := str copyReplaceFrom: start to: end with: ''. 						madeChanges := true.						tempsMark := tempsMark - (end-start+1)]]				ifFalse:					[self inform:'You''ll first have to remove the\statement where it''s stored into' withCRs]]].	madeChanges ifTrue: [ReparseAfterSourceEditing signal]! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 10:32'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presumed interactive) receiver.	 Update requestorOffset based on the delta size and answer the updated offset."	requestor correctFrom: spot first + o to: spot last + o with: correctWord.	requestorOffset := requestorOffset + correctWord size - spot size.	^o + correctWord size - spot size! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 16:48'!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode := self newMethodNode comment: messageComment.	methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties.	self interactive ifTrue:		[self declareUndeclaredTemps: methodNode.		 self removeUnusedTemps].	^methodNode! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35'!temporariesIn: methodSelector	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance in: methodSelector)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 15:57'!temporaryBlockVariablesFor: aBlockNode	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse:		"There are't any temporary variables."		[aBlockNode tempsMark: prevMark + requestorOffset.		 ^#()].	variables := OrderedCollection new.	[hereType == #word] whileTrue:		[variables addLast: (encoder bindBlockTemp: self advance within: aBlockNode)].	(self match: #verticalBar) ifFalse:		[^self expected: 'Vertical bar'].	aBlockNode tempsMark: prevMark + requestorOffset.	^variables! !!Parser methodsFor: 'primitives' stamp: 'ar 5/24/2010 20:41'!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == #')'] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(args position = self properties selector numArgs) ifFalse:[		^self expected: 'Matching number of arguments'	].	(self matchToken:#')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn| | fn |		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addPragma: (Pragma keyword: #primitive: arguments: #(120)).	^true! !!Parser methodsFor: 'public access' stamp: 'eem 8/16/2010 18:08'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p subSelection |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 subSelection := req notNil and: [req selectionInterval = (p + 1 to: p + s size)].	 self encoder init: class context: ctxt notifying: self.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := subSelection							ifTrue:								[ReadStream									on: requestor text string									from: requestor selectionInterval first									to: requestor selectionInterval last]							ifFalse:								[ReadStream on: requestor text string]].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !!Password methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:52'!serverPasswords	"Get the server passwords off the disk and decode them. The file 'sqk.info' must be in some folder that Squeak thinks is special (vm folder, or default directory).  (Note: This code works even if you are running with no system sources file.)"	| sfile |	(sfile := FileDirectory lookInUsualPlaces: 'sqk.info') ifNil: [^ nil].		"If not there, Caller will ask user for password"		"If you don't have this file, and you really do want to release an update, 		 contact Ted Kaehler."	^ (self decode: (sfile contentsOfEntireFile)) lines! !!PasteUpMorph methodsFor: 'change reporting' stamp: 'ar 6/17/2010 17:28'!invalidRect: damageRect from: aMorph	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [worldState recordDamagedRect: damageRect].	^super invalidRect: damageRect from: aMorph! !!PasteUpMorph methodsFor: 'project state' stamp: 'ar 6/17/2010 20:00'!canvas: aCanvas	"Set this world's canvas"	worldState canvas: aCanvas.! !!PasteUpMorph methodsFor: '*Tools' stamp: 'cmm 6/13/2010 20:41'!defaultDesktopCommandKeyTriplets	"Answer a list of triplets of the form		<key> <receiver> <selector>   [+ optional fourth element, a <description> for use in desktop-command-key-help]that will provide the default desktop command key handlers.  If the selector takes an argument, that argument will be the command-key event"	| noviceKeys expertKeys |	noviceKeys := {		{ $o.	ActiveWorld.						#activateObjectsTool.						'Activate the "Objects Tool"'}.		{ $r.	ActiveWorld.						#restoreMorphicDisplay.					'Redraw the screen'}.				{ $z.	self.								#undoOrRedoCommand.					'Undo or redo the last undoable command'}.		{ $F.	Project current.					#toggleFlapsSuppressed.					'Toggle the display of flaps'}.		{ $N.	self.								#toggleClassicNavigatorIfAppropriate.	'Show/Hide the classic Navigator, if appropriate'}.		{ $M.	self.								#toggleShowWorldMainDockingBar.		'Show/Hide the Main Docking Bar'}.	}.	Preferences noviceMode			ifTrue:[^ noviceKeys].	expertKeys := {		{ $b.	SystemBrowser.					#defaultOpenBrowser.						'Open a new System Browser'}.		{ $k.	StringHolder.					#open.										'Open a new, blank Workspace'}.		{ $m.	self.								#putUpNewMorphMenu.					'Put up the "New Morph" menu'}.		{ $t.	self.	 							#findATranscript:.							'Make a System Transcript visible'}.		{ $w.	SystemWindow.					#closeTopWindow.							'Close the topmost window'}.		{ $C.	self.								#findAChangeSorter:.						'Make a Change Sorter visible'}.		{ $L.	self.								#findAFileList:.								'Make a File List visible'}.		{ $P.	self.								#findAPreferencesPanel:.					'Activate the Preferences tool'}.		{ $R.	Utilities. 								#browseRecentSubmissions.		'Make a Recent Submissions browser visible'}.		{ $W.	self. 								#findAMessageNamesWindow:.			'Make a MessageNames tool visible'}.		{ $Z.	ChangeList. 						#browseRecentLog.							'Browse recently-logged changes'}.		{ $\.	SystemWindow. 					#sendTopWindowToBack.					'Send the top window to the back'}.	}.	^ noviceKeys, expertKeys! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'tfel 4/16/2010 09:34'!drawOn: aCanvas 	| cc gradient borderColor |	cc := self color.	cc isTransparent ifTrue:[cc := Color gray: 0.9].	self enabled ifFalse:[cc := Color lightGray].	cc brightness > 0.9 ifTrue:[cc := cc adjustBrightness: 0.9 - cc brightness].	showSelectionFeedback ifTrue:[		borderColor := cc muchDarker.		gradient := GradientFillStyle ramp: {			0.0 -> cc muchDarker.			0.1-> (cc adjustBrightness: -0.2).			0.5 -> cc.			0.9-> (cc adjustBrightness: -0.1).			1 -> cc muchDarker.		}.	] ifFalse:[		borderColor := Color lightGray.		gradient := GradientFillStyle ramp: {			0.0 -> Color white.			0.1-> (cc adjustBrightness: 0.05).			0.6 -> (cc darker).		}	].	gradient origin: bounds topLeft.	gradient direction: 0@self height.	^ self class roundedButtonCorners		ifTrue: [aCanvas 				frameAndFillRoundRect: bounds 				radius: 8 				fillStyle: gradient 				borderWidth: 1 				borderColor: borderColor]		ifFalse: [aCanvas 				frameAndFillRectangle: self innerBounds 				fillColor: gradient asColor 				borderWidth: 1 				borderColor: borderColor darker;				fillRectangle: (self innerBounds insetBy: 1) 				fillStyle: gradient]! !!PluggableButtonSpec commentStamp: 'ar 2/11/2005 21:57' prior: 0!A button, both for firing as well as used in radio-button style (e.g., carrying a selection).Instance variables:	action	<Symbol>	The action to perform when the button is fired.	label	<Symbol|String>	The selector for retrieving the button's label or label directly.	state	<Symbol>	The selector for retrieving the button's selection state.	enabled	<Symbo>		The selector for retrieving the button's enabled state.	color	<Symbo>		The selector for retrieving the button color.	help	<String>		The balloon help for the button.!!PluggableSystemWindowWithLabelButton methodsFor: 'resize/collapse' stamp: 'eem 5/6/2008 12:58'!adjustExtraButton	labelButton ifNil: [^self].	labelButton		position: self innerBounds topLeft + (20 @ -3);		extent: self innerBounds extent * (0.4@1)! !!PluggableSystemWindowWithLabelButton methodsFor: 'geometry' stamp: 'eem 5/6/2008 10:45'!extent: newExtent	super extent: newExtent.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton methodsFor: 'events' stamp: 'eem 6/30/2010 16:47'!mouseDown: evt	| wasInactive |	wasInactive := TopWindow ~~ self.	self valueOfProperty: #clickPoint ifPresentDo: 		[:firstClick |		(labelButton containsPoint: evt cursorPoint) ifTrue:			[^labelButton mouseDown: evt]].	super mouseDown: evt.	(wasInactive	 and: [model windowActiveOnFirstClick not	 and: [labelButton containsPoint: evt cursorPoint]]) ifTrue:		[^labelButton mouseDown: evt]! !!PluggableSystemWindowWithLabelButton methodsFor: 'top window' stamp: 'eem 5/6/2008 11:39'!passivate	super passivate.	self removeProperty: #clickPoint! !!PluggableSystemWindowWithLabelButton methodsFor: 'accessing' stamp: 'eem 6/30/2010 18:56'!savedMultiWindowState: aSavedMultiWindowState	labelButton := MultiWindowLabelButtonMorph						on: aSavedMultiWindowState						getState: nil						action: #selectWindowsMenu.	labelButton		triggerOnMouseDown: true;		savedMultiWindowState: aSavedMultiWindowState.	labelButton		layoutFrame: (LayoutFrame "i.e. in the left 40% of the title bar"						fractions: (0@0 corner: 0.4@0)						offsets: (20@ -20 corner: 0@0));		hResizing: #spaceFill;		vResizing: #spaceFill.	self addMorphFront: labelButton.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton commentStamp: 'eem 6/29/2010 19:02' prior: 0!A PluggableSystemWindowWithLabelButton provides the pull-down menu of browser panes in the multi-pane browser.Instance Variables	labelButton:		<BrowserPaneButtonMorph>labelButton	- the labelButton is a hack to hold onto the panes of a multi-paned browser so that an inst var doesn't have to be added to the Browser hierarchy.!!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48'!extent: newExtent	bounds extent = newExtent ifTrue: [^ self].	super extent: (newExtent max: 36@16).	self setScrollDeltas! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 10:17'!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph notNil ifTrue:		["the current selection gets munged by resetting the extent, so store it"		tempSelection := self selectionInterval.				"don't reset it if it's not active"		tempSelection = (Interval from: 1 to: 0) 						ifTrue: [retractableScrollBar							ifTrue:[ ^ self]].		self extent: self extent.		self setSelection: tempSelection].	super resetExtent.! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48'!resizeScroller	"Also needs to resize the text morph"	super resizeScroller.	textMorph ifNotNil:		[textMorph extent: (self innerBounds width-6)@self height].! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'ar 6/17/2010 19:52'!accept 	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	ok := self acceptTextInModel.	ok==true ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNil:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok ifTrue: "(don't bother if there was an error during compile)"		[(model respondsTo: #updateCodePaneIfNeeded) 			ifTrue: [model updateCodePaneIfNeeded].		WorldState addDeferredUIMessage:			[self currentHand newKeyboardFocus: textMorph.			scroller offset: saveScrollerOffset.			self setScrollDeltas.			selectionInterval := saveSelection. "restore prior selection"			self selectFrom: saveSelection first to: saveSelection last]]]			on: Error do: []! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:56'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [self text]! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 21:05'!unacceptedEditState: stateOrNil	stateOrNil		ifNotNil:			[self setText: stateOrNil.			 hasUnacceptedEdits := true "setText: clears hasUnacceptedEdits, so must do this post setText:"]		ifNil: [hasUnacceptedEdits := false]! !!PluggableTextSpec commentStamp: 'ar 2/11/2005 21:58' prior: 0!A text editor.Instance variables:	getText	<Symbol>	The selector to retrieve the text.	setText	<Symbol>	The selector to set the text.	selection <Symbol>	The selector to retrieve the text selection.	menu	<Symbol>	The selector to offer (to retrieve?) the context menu.	color	 <Symbol>	The selector to retrieve the background color.!!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color	"Answer the selector for retrieving the button's color"	^color! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color: aSymbol	"Indicate the selector for retrieving the button's color"	color := aSymbol! !!PluggableWidgetSpec commentStamp: 'ar 2/9/2005 18:40' prior: 0!The abstract superclass for all widgets.Instance variables:	model	<Object>	The object the various requests should be directed to.	frame	<Rectangle> The associated layout frame for this object (if any).!!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:12'!isDialog	^isDialog ifNil: [false]! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 7/1/2010 11:31'!multiWindowStyle	"Answer the value of multiWindowStyle, a Symbol or nil"	^multiWindowStyle! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:44'!multiWindowStyle: aSymbol	"Set the value of multiWindowStyle, one of #labelButton or #tabbed"	multiWindowStyle := aSymbol! !!PluggableWindowSpec commentStamp: '<historical>' prior: 0!A common window. Expects to see change/update notifications when the label should change.Instance variables:	label	<String|Symbol> The selector under which to retrieve the label or the label directly	extent	<Point>	The (initial) extent of the window.	closeAction		<Symbol>	The action to perform when the window is closed.!!Point methodsFor: 'point functions' stamp: 'wiz 8/6/2007 20:33'!fourDirections	"Return vertices for a square centered at 0 asPoint with the receiver as first corner.	Returns the four rotation of the reciever in counter clockwise order with the reciever 	appearing last. "	^ Array with: self leftRotated			with: self negated			with: self rightRotated			with: self 		! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 03:32'!leftRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #left centerAt: 0 asPoint .Compare to transposed and normal. "	^y  @x negated! !!Point methodsFor: 'point functions' stamp: 'wiz 7/28/2007 20:50'!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise.	For the zero point return a normal of  -1@0   ."	| n d |		n := y negated @ x.	(d := (n x * n x + (n y * n y))) = 0 ifTrue: [ ^  -1 @0  ] .	^n / d sqrt! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 02:33'!rightRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #right centerAt: 0 asPoint .Compare to transposed and normal. "	^y negated @x! !!Point methodsFor: 'point functions' stamp: 'wiz 8/1/2007 16:53'!sign^ (x sign @ y sign) .! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'nice 6/11/2010 21:53'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch := Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch := ch asCharacter asLowercase.	labels := labelString lines.	occurences := 0.	1 + selection to: selection + labels size do:		[:index |		| i | i := index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences := occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'nice 6/11/2010 21:53'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'cmm 6/15/2010 15:07'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := (allLabels copyFrom: from to: to) asOrderedCollection.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PostscriptCanvas methodsFor: 'private' stamp: 'cmm 6/21/2010 14:31'!setColor: color 	(color notNil and: [ currentColor ~= color ]) ifTrue:		[ target write: color asColor.		currentColor := color ]! !!Preferences class methodsFor: 'fonts' stamp: 'ar 7/21/2010 20:13'!restoreFontsAfter: aBlock	"Restore the currently chosen set of standard fonts after 	evaluating aBlock. Used for tests that modify the default fonts."	| standardDefaultTextFont standardListFont standardEToysFont standardMenuFont 	windowTitleFont standardBalloonHelpFont standardCodeFont standardButtonFont |	standardDefaultTextFont := Preferences standardDefaultTextFont.	standardListFont := Preferences standardListFont.	standardEToysFont := Preferences standardEToysFont.	standardMenuFont := Preferences standardMenuFont.	windowTitleFont := Preferences windowTitleFont.	standardBalloonHelpFont := Preferences standardBalloonHelpFont.	standardCodeFont := Preferences standardCodeFont.	standardButtonFont := Preferences standardButtonFont.	^aBlock ensure: [		Preferences setSystemFontTo: standardDefaultTextFont.		Preferences setListFontTo: standardListFont.		Preferences setEToysFontTo: standardEToysFont.		Preferences setMenuFontTo: standardMenuFont.		Preferences setWindowTitleFontTo: windowTitleFont.		Preferences setBalloonHelpFontTo: standardBalloonHelpFont.		Preferences setCodeFontTo: standardCodeFont.		Preferences setButtonFontTo: standardButtonFont.	].! !!Preferences class methodsFor: 'initialization' stamp: 'ul 5/22/2010 01:34'!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class 		compileSilently: (			'{1} ^self valueOfFlag: {2} ifAbsent: [ {3} ]'				format: {					aPreference name asString.					aPreference name asSymbol printString.					aPreference defaultValue storeString }) 		classified: '*autogenerated - standard queries'! !!Preferences class methodsFor: 'personalization' stamp: 'ul 5/22/2010 01:33'!compileHardCodedPref: prefName enable: aBoolean	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"	self class 		compileSilently: (			'{1} ^{2}'				format: {					prefName asString.					aBoolean storeString })		classified: '*autogenerated - hard-coded prefs'.	"Preferences compileHardCodedPref: #testing enable: false"! !!Preferences class methodsFor: 'reacting to change' stamp: 'ar 7/21/2010 20:20'!displaySizeChanged	self flag: #todo.	"only change font on small-land image"	self smallLandFonts.	self tinyDisplay		ifTrue: [self enable: #scrollBarsNarrow]		ifFalse: [self disable: #scrollBarsNarrow].	self tinyDisplay 		ifTrue:[self disable: #biggerHandles] 		ifFalse:[self enable: #biggerHandles]! !!Preferences class methodsFor: 'standard queries' stamp: 'sbw 4/24/2010 10:16'!annotationPanes	^ self		valueOfFlag: #annotationPanes		ifAbsent: [true]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22'!installUniformWindowColors	"Install the factory-provided uniform window colors for all tools"	"Preferences installUniformWindowColors"	self installWindowColorsVia: [:aQuad | self uniformWindowColor]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22'!uniformWindowColor	^Color veryVeryLightGray! !!Project methodsFor: 'accessing' stamp: 'dtl 5/2/2010 19:09'!uiManager	"Answer the manager that provides user interface services for this project "	^ uiManager		ifNil: [uiManager := Smalltalk						at: #UIManager						ifPresent: [:mgr | uiManager := mgr getDefault]]! !!Project methodsFor: 'menu messages' stamp: 'cbr 5/1/2010 01:53'!toggleFullScreen	"Toggle between full screen and windowed mode."	self lastScreenModeSelected		ifTrue: [ self fullScreenOff ]		ifFalse: [ self fullScreenOn ]! !!Project commentStamp: 'cbr 7/27/2010 21:36' prior: 0!A Project stores the state of a complete Squeak desktop, includingthe windows, and the currently active changeSet.  A project knows whoits parent project is.  When you change projects, whether by enteringor exiting, the screen state of the project being exited is saved inthat project.A project is retained by its view in the parent world.  It iseffectively named by the name of its changeSet, which can be changedeither by renaming in a changeSorter, or by editing the label of itsview from the parent project.As the site of major context switch, Projects are the locus ofswapping between the old MVC and the new Morphic worlds.  Thedistinction is based on whether the variable 'world' contains aWorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Projectnamed: 'xxx') exportSegment, or choose 'store project on file...'.Projects may be loaded from a server and stored back.  Storing on aserver never overwrites;  it always makes a new version.  A projectremembers the url of where it lives in urlList.  The list is lengthone, for now.  The url may point to a local disk instead of a server.All projects that the user looks at are cached in the Squeakletfolder.  Sorted by server.  The cache holds the most recent versiononly.When a project is loaded into Squeak, its objects are converted tothe current version.  There are three levels of conversion.  First,each object is converted from raw bits to an object in its oldformat.  Then it is sent some or all of these messages:	comeFullyUpOnReload: smartRefStream  		Used tore-discover an object that already exists in this image, such as aresource, global variable, Character, or Symbol.  (sent to objects inoutPointers)	convertToCurrentVersion: varDict refStream: smartRefStrm		fill in fields that have been added to a class sincethe object was stored.  Used to set the extra inst var to a defaultvalue.  Or, return a new object of a different class.  (sent toobjects that changed instance variables)	fixUponLoad: aProject refStream: smartRefStrm	change the object due to conventions that have changed on theproject level.  (sent to all objects in the incoming project)Here is the calling sequence for storing out a Project:Project saveAsProject storeOnServerProject storeOnServerWithProgressInfoProject storeOnServerInnardsProject exportSegmentFileName:directory:Project exportSegmentWithChangeSet:fileName:directory:ImageSegment writeForExportWithSources:inDirectory:changeSet:!!ProjectLauncher methodsFor: 'running' stamp: 'ar 6/21/2010 20:33'!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (Smalltalk documentPath) ifNil:[''].			scriptName := scriptName convertFromSystemString.			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[					"Allow for ../dir/scriptName arguments"					scriptName := (FileDirectory default uri 						resolveRelativeURI: scriptName) asString]].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!ProjectLoading class methodsFor: 'loading' stamp: 'ul 4/28/2010 12:35'!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to berepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList proj trusted localDir projStream archive mgrprojectsToBeDeleted baseChangeSet enterRestricted substituteFontnumberOfFontSubstitutes exceptions |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enterproject'.		"the hard part is over"		^self inform:'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,' translated	].	ProgressNotification signal: '2:fileSizeDetermined',preStream size printString.	preStream isZipArchive		ifTrue:[	archive := ZipArchive new readFrom: preStream.				projStream := selfprojectStreamFromArchive: archive]		ifFalse:[projStream := preStream].	trusted := SecurityManager default positionToSecureContentsOf:projStream.	trusted ifFalse:		[enterRestricted := (preStream isTypeHTTP or:[aFileName isNil])			ifTrue: [Preferences securityChecksEnabled]			ifFalse: [Preferences standaloneSecurityChecksEnabled].		enterRestricted			ifTrue: [SecurityManager default enterRestrictedMode				ifFalse:					[preStream close.					^ self]]].	localDir := Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) binary				nextPutAll: preStream contents;				close.		].	].	morphOrList := projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet := ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	substituteFont := Preferences standardEToysFont copy.	numberOfFontSubstitutes := 0.	exceptions := Set new.	[[morphOrList := morphOrList fileInObjectAndCodeForProject]		on: FontSubstitutionDuringLoading do: [ :ex |				exceptions add: ex.				numberOfFontSubstitutes :=numberOfFontSubstitutes + 1.				ex resume: substituteFont ]]			ensure: [ ChangeSet  newChanges: baseChangeSet].	mgr := ResourceManager new initializeFrom: ResourceCollector current.	mgr fixJISX0208Resource.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName:aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj := morphOrList arrayOfRoots			detect: [:mm | mm isKindOf: Project]			ifNone: [^self inform: 'No project found inthis file'].		proj projectParameters at: #substitutedFont put: (			numberOfFontSubstitutes > 0				ifTrue: [substituteFont]				ifFalse: [#none]).		proj projectParameters at: #MultiSymbolInWrongPlace put: false.			"Yoshiki did not put MultiSymbols intooutPointers in older images!!"		morphOrList arrayOfRoots do: [:obj |			obj fixUponLoad: proj seg: morphOrList "imageSegment"].		(proj projectParameters at: #MultiSymbolInWrongPlace) ifTrue: [			morphOrList arrayOfRoots do: [:obj | (objisKindOf: HashedCollection) ifTrue: [obj rehash]]].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		proj setParent: Project current.		projectsToBeDeleted := OrderedCollection new.		existingView ifNil: [			ChangeSet allChangeSets add: proj changeSet.			Project current openProject: proj.				"Note: in MVC we get no further than the above"		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSet allChangeSets add: proj changeSet.		Project current projectParameters			at: #deleteWhenEnteringNewProject			ifPresent: [ :ignored |				projectsToBeDeleted add: Project current.				Project current removeParameter:#deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters				at: #projectsToBeDeleted				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	Project current openViewAndEnter: morphOrList! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:38'!bottomBoundary	"Answert the bottommost x position the receiver could be moved."	| splitter morphs |	splitter := self splitterBelow.	morphs := self commonNeighbours: rightOrBottom with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect bottom]				ifFalse: [owner innerBounds bottom]]		ifNotNil: [splitter top])		- (self minimumHeightOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:37'!topBoundary	"Answer the topmost x position the receiver could be moved to."	| splitter morphs |	splitter := self splitterAbove.	morphs := self commonNeighbours: leftOrTop with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect top]				ifFalse: [owner innerBounds top]]		ifNotNil: [splitter bottom])		+ (self minimumHeightOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'displaying' stamp: 'ar 6/23/2010 16:35'!handleSize	^ self class splitterWidth @ 30! !!ProtoObject methodsFor: 'system primitives' stamp: 'mtf 8/15/2008 17:19'!instVarsInclude: anObject"Answers true if anObject is among my named or indexed instance variables, and false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/8/2010 18:26'!standardSize	^ StandardSize! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/9/2010 15:12'!standardSize: extent	StandardSize := extent! !!Rectangle methodsFor: 'testing' stamp: 'nice 6/20/2010 21:32'!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin := aRectangle origin.	rCorner := aRectangle corner.	rCorner x <= origin x	ifTrue: [^ false].	rCorner y <= origin y	ifTrue: [^ false].	rOrigin x >= corner x	ifTrue: [^ false].	rOrigin y >= corner y	ifTrue: [^ false]."None of the two rectangle shall be empty"	corner x <= origin x	ifTrue: [^ false].	corner y <= origin y	ifTrue: [^ false].	rCorner x <= rOrigin x	ifTrue: [^ false].	rCorner y <= rOrigin y	ifTrue: [^ false].	^ true! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 21:27'!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	| futureOrigin futureCorner |	direction == #horizontal		ifTrue:			[futureOrigin := self topRight.			futureCorner := self bottomLeft]		ifFalse: [direction == #vertical			ifTrue:				[futureOrigin := self bottomLeft.				futureCorner := self topRight]			ifFalse: [self error: 'unrecognizable direction']].	^ (futureOrigin flipBy: direction centerAt: aPoint)		corner: (futureCorner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 22:01'!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	| futureOrigin futureCorner |	direction == #pi		ifTrue:			[futureOrigin := self corner.			futureCorner := self origin]		ifFalse: [direction == #left			ifTrue:				[futureOrigin := self topRight.				futureCorner := self bottomLeft]			ifFalse: [direction == #right				ifTrue:					[futureOrigin := self bottomLeft.					futureCorner := self topRight]				ifFalse: [self error: 'unrecognizable direction']]].	^ (futureOrigin rotateBy: direction centerAt: aPoint)		corner: (futureCorner rotateBy: direction centerAt: aPoint)! !!Rectangle commentStamp: 'nice 7/25/2010 14:56' prior: 0!I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.Note 1: only rectangles parallel to reference frame (Screen) can be represented by this class.Note 2: the Rectangle is represented by two extremities of one diagonal. By convention, it must be the diagonal:	from rectangle origin (the point having smallest coordinates in reference frame),	to rectangle corner (the point having largest coordinates in reference frame).Note 3: Screen coordinates conventions are:	x is horizontal axis, zero at left border, oriented toward right;	y is vertical axis, zero at top border, oriented toward bottom.This corresponds to the latin convention for writing text from left to right and top to bottom.Note 4: the Rectangle extent is obtained by subtracting rectangle origin to rectangle corner coordinates.If this leads to a negative width (extent x coordinate) and/or a negative height (extent y coordinate), then the Rectangle is degenerated and considered empty.Instance variables:	origin	<Point> the coordinates of corner having smallest coordinates (top left in Screen coordinates)	corner	<Point> the coordinates of corner having largest coordinates (bottom right in Screen coordinates)!!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06'!startTransmittingEvents	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06'!startTransmittingEventsTo: remoteAddr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	remoteAddress := remoteAddr.	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!RemoteTempVectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitRemoteTempVectorNode: self! !!ResourceManager class methodsFor: 'resource caching' stamp: 'nice 6/11/2010 21:27'!reloadCachedResources	"ResourceManager reloadCachedResources"	"Reload cached resources from the disk"	| fd files stream url localName storeBack archiveName |	CachedResources := Dictionary new.	LocalizedExternalResources := nil.	fd := Project squeakletDirectory.	files := fd fileNames asSet.	stream := [fd readOnlyFileNamed: self resourceCacheName]				on: FileDoesNotExistException 				do:[:ex| fd forceNewFileNamed: self resourceCacheName].	stream size < 50000 ifTrue:[stream := ReadStream on: stream contentsOfEntireFile].	storeBack := false.	[stream atEnd] whileFalse:[		url := stream nextLine.			localName := stream nextLine.		(localName beginsWith: 'zip://') ifTrue:[			archiveName := localName copyFrom: 7 to: localName size.			(files includes: archiveName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true].		] ifFalse:[			(files includes: localName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true]		].	].	stream close.	storeBack ifTrue:[		stream := fd forceNewFileNamed: self resourceCacheName.		CachedResources keysAndValuesDo:[:urlString :cacheLocs|			cacheLocs do:[:cacheLoc|				stream nextPutAll: urlString; cr.				stream nextPutAll: cacheLoc; cr].		].		stream close.	].! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40'!emitCodeForReturn: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40'!emitCodeForValue: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForReturn: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35'!accept: aVisitor	^aVisitor visitReturnNode: self! !!RightGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:39'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!RightGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultWidth	^ 5! !!RightGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (1 @ 0 corner: 1 @ 1)		offsets: (self defaultWidth negated @ self defaultHeight negated corner: 0@ 0)! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!ptName	^#right! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!resizeCursor	^ Cursor resizeForEdge: #right! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreAssignments	^nil! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreSelectors	^nil! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:15'!nextChar	sourcePosition := sourcePosition + 1.	^source at: sourcePosition ifAbsent: $ ! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 19:29'!scanIdentifier	| c start |	start := sourcePosition.	[(c := self nextChar) isAlphaNumeric or: [c == $_ and: [self allowUnderscoreSelectors]]] whileTrue.	(c == $: and: [(self isSelectorCharacter: self peekChar) not]) 		ifTrue: [self nextChar].	currentToken := source copyFrom: start to: sourcePosition - 1.	currentTokenSourcePosition := start! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:27'!scanNext	self scanWhitespace.	currentTokenFirst := self currentChar.	currentTokenFirst 		ifNil: [" end of input "			currentTokenFirst := $ .			currentTokenSourcePosition := nil.			currentToken := nil.			^nil].	currentTokenFirst isDigit ifTrue: [^self scanNumber].	currentTokenFirst isLetter ifTrue: [^self scanIdentifier].	^self scanBinary! !!SHParserST80 methodsFor: 'token testing' stamp: 'laza 4/28/2010 17:51'!isAssignment	^self isAnsiAssignment or: [self allowUnderscoreAssignments and: [currentToken = '_']]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22'!parse: isAMethod 	"Parse the receiver's text. If isAMethod is true    then treat text as a method, if false as an    expression with no message pattern"	self initializeInstanceVariables.	sourcePosition := 1.	arguments := Dictionary new.	temporaries := Dictionary new.	blockDepth := bracketDepth := 0.	ranges		ifNil: [ranges := OrderedCollection new: 100]		ifNotNil: [ranges reset].	errorBlock := [^false].	[self scanNext.	isAMethod 		ifTrue: [			self parseMessagePattern.			self parsePragmaSequence].	self parseMethodTemporaries.	isAMethod ifTrue: [self parsePragmaSequence].	self parseStatementList.	currentToken ifNotNil: [self error]]		ensure:[errorBlock := nil].	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22'!parseBinary 	| binary type |	self parseUnary.	[self isBinary] 		whileTrue: [			binary := currentToken.			type := #binary.			(binary isEmpty or:[(Symbol lookup: binary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: binary skipping: nil)						ifNil: [#undefinedBinary]						ifNotNil:[#incompleteBinary]].				self scanPast: type. 				self parseTerm.            	self parseUnary]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22'!parseKeyword     | keyword rangeIndices |    self parseBinary.	keyword := ''.	rangeIndices := #().	[    		[self isKeyword]        		whileTrue: [				keyword := keyword, currentToken. 				self rangeType: #keyword.				"remember where this keyword token is in ranges"				rangeIndices := rangeIndices copyWith: ranges size.				self scanNext.				self parseTerm.				self parseBinary ]	] ensure: [ | type |		"do this in an ensure so that it happens even if the errorBlock evaluates before getting here"		"patch up the keyword tokens, so that incomplete and undefined ones look different"		(keyword isEmpty or:[(Symbol lookup: keyword) notNil])			ifFalse:[				type := (Symbol thatStartsCaseSensitive: keyword skipping: nil)					ifNil: [#undefinedKeyword]					ifNotNil:[#incompleteKeyword].				rangeIndices do: [:i | (ranges at: i) type: type]]]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 22:50'!parsePrimitive	self scanNext.	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: [			currentTokenFirst == $'				ifTrue: [ self parseString ]				ifFalse: [					currentTokenFirst == $#						ifTrue: [ self parseSymbol ]						ifFalse: [ self error ] ].			currentToken = 'module:' 				ifTrue: [					self scanPast: #module.					currentTokenFirst == $'						ifTrue: [ self parseString ]						ifFalse: [							currentTokenFirst == $#								ifTrue: [ self parseSymbol ]								ifFalse: [ self error ] ] ] ].	self failUnless: currentTokenFirst == $>.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:24'!parseString	| first c answer last |	first := sourcePosition.	answer := ''.		[(c := self currentChar)		ifNil: [			self rangeType: #unfinishedString start: first - 1 end: source size.			self error	": 'unfinished string'"].	(c == $' 			ifFalse: [answer := answer copyWith: c. true] 		ifTrue: [false]	) or: [		self peekChar == $' 			ifTrue: [				sourcePosition := sourcePosition + 1.				answer := answer copyWith: $'.				true]			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #string start: first - 1 end: last.	^answer! !!SHParserST80 methodsFor: 'parse' stamp: 'laza 4/29/2010 16:18'!parseSymbolIdentifier	| c start end |	c := self currentChar.	self failUnless: (c isLetter or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]).	start := sourcePosition.		[c := self nextChar.	c isAlphaNumeric or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]] whileTrue.	end := sourcePosition - 1.	c := source copyFrom: start - 1 to: end.	self scanPast: #symbol start: start - 1 end: end.	^c! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26'!parseSymbolString	| first c last |	first := sourcePosition.	self nextChar.	[(c := self currentChar) 		ifNil: [			self rangeType: #unfinishedString start: first end: source size.			self error	": 'unfinished string'"].	c ~~ $' or: [		self peekChar == $' 			ifTrue: [sourcePosition := sourcePosition + 1.true] 			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #stringSymbol start: first - 1 end: last! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26'!parseUnary	| unary type |	    [self isName]        whileTrue: [			unary := currentToken.			type := #unary.			(unary isEmpty or:[(Symbol lookup: unary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: unary skipping: nil)						ifNil: [#undefinedUnary]						ifNotNil:[#incompleteUnary]].			self scanPast: type]! !!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:07'!allowUnderscoreAssignments	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreAssignments])		ifNil: [Scanner prefAllowUnderscoreAssignments]! !!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:04'!allowUnderscoreSelectors	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreSelectors])		ifNil: [Scanner prefAllowUnderscoreSelectors]! !!SHTextStyler methodsFor: 'private' stamp: 'ul 4/28/2010 20:27'!monitor	^monitor ifNil: [monitor := Monitor new]! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:26'!testTestTimeout	self should:[(Delay forSeconds: 6) wait] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:43'!testTestTimeoutLoop	<timeout: 1>	self should:[[true] whileTrue.] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:25'!testTestTimeoutTag	<timeout: 1>	self should:[(Delay forSeconds: 3) wait] raise: TestFailure.! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:14'!addNewWindow	self addWindow: prototype clone! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 19:01'!addWindow: aModel	aModel multiWindowState: self.	self assert: models size = modelStates size.	models := models					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: aModel).	modelStates := modelStates					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: self emptyEditState).	self assert: models size = modelStates size.	self selectWindowIndex: (currentModelIndex = 0 ifTrue: [currentModelIndex := 1] ifFalse: [currentModelIndex + 1]).	self assert: models size = modelStates size.	1 to: models size do:		[:idx|		self assert: (idx = currentModelIndex					or: [(modelStates at: idx) isArray and: [(modelStates at: idx) size = 2]])]! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:10'!copyWindow	self addWindow: (models at: currentModelIndex) copy breakDependents! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 21:15'!removeCurrentWindow	"Remove the current pane."	| deletedIndex |	self assert: models size > 1.	self assert: models size = modelStates size.	(models at: currentModelIndex) okToChange ifFalse:		[^self].	deletedIndex := currentModelIndex.	self selectWindowIndex: (currentModelIndex = 1								ifTrue: [currentModelIndex + 1]								ifFalse: [currentModelIndex - 1]).	models := models copyWithoutIndex: deletedIndex.	modelStates :=  modelStates copyWithoutIndex: deletedIndex.	currentModelIndex > deletedIndex ifTrue:		[currentModelIndex := currentModelIndex - 1].	(models at: currentModelIndex) changed: #relabel! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 8/11/2010 13:27'!selectWindowsMenu	| menu currentItem |	menu := MenuMorph new defaultTarget: self.	models withIndexDo:		[:model :index| | modelLabel |		modelLabel := index = currentModelIndex							ifTrue: [model multiWindowName]							ifFalse: [model multiWindowNameForState: (modelStates at: index) first].		models size > 1 ifTrue:			[modelLabel := index printString, '. ', modelLabel].		menu			add: (index = currentModelIndex					ifTrue: [Text string: modelLabel attribute: TextEmphasis bold]					ifFalse:						[((modelStates at: index) last anySatisfy: [:editState| editState notNil])							ifTrue: [Text string: modelLabel attribute: TextColor red]							ifFalse: [modelLabel]])			target: self			selector: #selectWindowIndex:			argument: index.		index = currentModelIndex ifTrue:			[currentItem := menu lastItem]].	menu		addLine;		add: 'new window' target: self selector: #addNewWindow;		add: 'copy this window' target: self selector: #copyWindow;		add: 'remove this window' target: self selector: #removeCurrentWindow.	models size <= 1 ifTrue:		[menu lastItem isEnabled: false].	menu selectItem: currentItem event: nil.	^menu! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 15:01'!currentModelIndex	^currentModelIndex! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 21:07'!emptyEditState	^#(nil ())! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 19:03'!models	^models! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 7/1/2010 10:40'!prototype	^prototype! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!editState	| textState |	textState := WeakIdentityKeyDictionary new.	modelDependents do:		[:dep|		dep canHaveUnacceptedEdits ifTrue:			[textState at: dep put: dep unacceptedEditState]].	^textState! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!restoreEditState: aWeakDictionary	aWeakDictionary keysAndValuesDo:		[:depOrNil :unacceptedEditState|		depOrNil ifNotNil:			[depOrNil unacceptedEditState: unacceptedEditState]]! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 21:09'!selectWindowIndex: index	| currentModel newModel newModelState |	index = currentModelIndex ifTrue: [^self].	currentModel := models at: currentModelIndex.	newModel := models at: index.	modelDependents addAll: currentModel dependents.	modelStates at: currentModelIndex put: { currentModel saveMultiWindowState. self editState }.	"the become makes things confusing.  currentModel will end up being newModel and vice verce"	models swap: currentModelIndex with: index.	currentModel become: newModel.	currentModel := models at: currentModelIndex.	newModel := models at: index.	newModel myDependents: (DependentsArray withAll: modelDependents asArray).	currentModel myDependents: nil.	"Change currentModelIndex before restoreMultiWIndowState: so label index is shown correctly"	currentModelIndex := index.	newModelState := modelStates at: index.	newModelState first ifNotNil: "emptyState has nil for savedModelState.  Don;t restore state for a new window"		[:savedModelState| newModel restoreMultiWindowState: savedModelState].	self restoreEditState: newModelState last.	modelStates at: index put: nil.	newModel changed: #relabel! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 15:12'!initialize	models := OrderedCollection new.	modelStates := OrderedCollection new.	modelDependents := IdentitySet new.	currentModelIndex := 0! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 18:42'!on: aModel	prototype := aModel clone.	self addWindow: aModel! !!SavedMultiWindowState methodsFor: 'testing' stamp: 'eem 6/30/2010 22:11'!okToClose	"Answer if the unaccepted edit states are void.  If they are not then	 offer to select a window with non-empty unaccepted edit state."	modelStates withIndexDo:		[:savedState :index|		savedState ifNotNil:			[(savedState last anySatisfy: [:editState| editState notNil]) ifTrue:				[(PopUpMenu					confirm: 'One or more windows have unsaved changes.'					trueChoice: 'Close Anyway'					falseChoice: 'Select Unsaved') ifTrue: [^true].				 self selectWindowIndex: index.				 ^false]]].	^true! !!SavedMultiWindowState commentStamp: 'eem 6/30/2010 15:45' prior: 0!A SavedMultiWindowState is a collection of states of inactive windows for a multi-window tool ui where one can select between multiple copies of a tool sharing a single system window, each tol having its own state.  It manages switching between windows, swapping unaccepted edit state (e.g. in text views) as it does so.Instance Variables	currentModelIndex:		<Integer>	modelDependents:		<IdentitySet>	modelStates:			<OrderedCollection of: (Array													with: modelState <Object>													with: unacceptedEditStates <WeakIdentityKeyDictionary>) >	models:					<OrderedCollection of: Model>currentModelIndex	- index into models and modelStates of current window selectionmodelDependents	- set of all dependentsmodelStates	- the pairs of model-specific selection state and widget-specfic unaccepted edit state for each unselected/inactive windowmodels	- the models for each window!!SavedMultiWindowState class methodsFor: 'instance creation' stamp: 'eem 6/30/2010 13:46'!on: aModel	^self new on: aModel! !!Scanner methodsFor: 'expression types' stamp: 'eem 7/2/2010 10:07'!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment notNil ifTrue:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark notNil ifTrue:		[(token == #- 		  and: [(self typeTableAt: hereChar) = #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType = #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType = #word or: [tokenType = #keyword or: [tokenType = #colon]])				ifTrue: 					[self scanLitWord.					 token = #true ifTrue: [token := true].					 token = #false ifTrue: [token := false].					 token = #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(self typeTableAt: hereChar) = #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken.	true] whileTrue! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 7/25/2010 12:23'!xIllegal	"An illegal character was encountered"	self notify: 'Illegal character (char code ' , hereChar charCode , ' ' , hereChar charCode storeStringHex , ')' at: mark! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nice 8/19/2010 14:08'!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	| tokens |	contents := aString.	classList := #().  classListIndex := 0.	selectorIndex := 0.	tokens := contents asString findTokens: ' .'.	selectorList := Cursor wait showWhile: [		tokens size = 1 			ifTrue: [(Symbol selectorsContaining: contents asString) asArray				sort: [:x :y | x asLowercase <= y asLowercase]]			ifFalse: [self quickList]].	"find selectors from a single example of data"	self changed: #messageList.	self changed: #classList.	^ true! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCode: stack args: nArgs encoder: encoder	self emitCode: stack		args: nArgs		encoder: encoder		super: false! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:47'!emitCode: stack args: nArgs encoder: encoder super: supered	stack pop: nArgs.	^supered		ifTrue:			[encoder genSendSuper: index numArgs: nArgs]		ifFalse:			[encoder				genSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForEffect: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForValue: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:15'!sizeCode: encoder args: nArgs super: supered	self reserve: encoder.	^supered		ifTrue:			[code < Send "i.e. its a special selector" ifTrue:				[code := self code: (index := encoder sharableLitIndex: key) type: 5].			 encoder sizeSendSuper: index numArgs: nArgs]		ifFalse:			[self flag: #yuck. "special selector sends cause this problem"			 encoder				sizeSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForEffect: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!sizeCodeForValue: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitSelectorNode: self! !!SequenceableCollection methodsFor: 'copying' stamp: 'eem 2/10/2009 11:44'!copyUpThrough: anElement 	"Answer all elements up to and including anObject. If there	is no such object, answer a copy of the receiver."	^self first: (self indexOf: anElement ifAbsent: [^ self copy])! !!SimpleButtonMorph commentStamp: 'ul 7/22/2010 04:30' prior: 0!I am labeled, rectangular morph which allows the user to click me. I can be configured to send my "target" the message "actionSelector" with "arguments" when I am clicked. I may have a label, implemented as a StringMorph.Example:	SimpleButtonMorph new		target: Beeper;		label: 'Beep!!';		actionSelector: #beep; 		openInWorldStructure:instance var 	Type		Description target 			Object 		The Object to notify upon a click actionSelector 	Symbol 		The message to send to Target (#messageName) arguments 		Array 		Arguments to send with #actionSelection (optional) actWhen 		Symbol 		When to take action: may be #buttonUp (default), #buttonDown,								#whilePressed, or #startDrag oldColor 		Color 		Used to restore color after click Another example: a button which quits the image without saving it.	SimpleButtonMorph new		target: Smalltalk;		label: 'quit';		actionSelector: #snapshot:andQuit:;		arguments: (Array with: false with: true); 		openInWorld!!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:09'!erasePixelsOfColor: aColor 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	| newBounds |	originalForm		mapColor: aColor		to: Color transparent.	newBounds := originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: newBounds)! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:19'!erasePixelsUsing: evt 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	self rememberedColor "color to erase"		ifNil: [ ^ self ]		ifNotNilDo:			[ : chosenColor | self erasePixelsOfColor: chosenColor ]! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:15'!recolorPixelsOfColor: originalColor with: newColor	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| d newForm map |	d := originalForm depth.	newForm := Form extent: originalForm extent depth: d.	map := (Color cachedColormapFrom: d to: d) copy.	map at: (originalColor indexInMap: map) put: (newColor pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:18'!recolorPixelsUsing: evt 	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| originalColor newColor |	self inform: 'choose the color you want to replace' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	"color to replace"	originalColor := self rememberedColor ifNil: [ ^ self ].	self inform: 'now choose the color you want to replace it with' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: originalColor		hand: evt hand.	"new color"	newColor := self rememberedColor ifNil: [ ^ self ].	self		recolorPixelsOfColor: originalColor		with: newColor! !!SmalltalkEditor methodsFor: 'private' stamp: 'cmm 4/4/2010 20:41'!methodArgument: anInteger 	^ (ReadStream on: self text asString) nextLine		ifNil: [ String empty ]		ifNotNilDo:			[ : line | 			line substrings				at: 2 * anInteger				ifAbsent: [ String empty ] ]! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26'!cleanUp: aggressive except: exclusions	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	^self cleanUp: aggressive except: exclusions confirming: aggressive! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26'!cleanUp: aggressive except: exclusions confirming: aBool	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	| classes |	aBool ifTrue:[		"Give the user a chance to bail"		(self confirm: 'Cleanup will destroy projects, change sets and more.Are you sure you want to proceed?') ifFalse:[^self].	].	"Find all classes implementing #cleanUp or cleanUp:"	classes := Smalltalk allClasses select:[:aClass| 		(aClass class includesSelector: #cleanUp) 			or:[aClass class includesSelector: #cleanUp:]	].	"Leave out the classes in the exclusion set"	classes := classes reject:[:aClass| exclusions includes: aClass].	"Arrange classes in superclass order, superclasses before subclasses.	This will ensure that specific cleanup (like MethodDictionary compaction)	will run after generic superclass cleanup (HashedCollection rehashing).	Otherwise generic superclass cleanup might undo specific one (in this	case rehashing will undo a good bit of MD compaction)."	classes := ChangeSet superclassOrder: classes.	"Run the cleanup code"	classes 		do:[:aClass| aClass cleanUp: aggressive]		displayingProgress:[:aClass| 'Cleaning up in ', aClass name].! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'ar 6/14/2010 22:05'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'nice 6/11/2010 21:28'!vmStatisticsShortString	"Convenience item for access to recent statistics only"	"StringHolderView open: (StringHolder new contents: SmalltalkImage current vmStatisticsShortString)		label: 'VM Recent Statistics'"	^ (ReadStream on: self vmStatisticsReportString) upToAll: 'Since'; nextLine; upToEnd! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'edc 7/25/2010 08:25'!unloadAllKnownPackages	"Unload all packages we know how to unload and reload"	" SmalltalkImage current unloadAllKnownPackages"	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	"World removeAllMorphs."PackageList new packages select: [:ea | ea packageName beginsWith: 'Configuration'] thenDo:[:any|  (MCPackage named:  any packageName ) unload  ] .PackageList new packages select: [:ea | '*Tests*'  match:  ea packageName]    thenDo:[:any|  (MCPackage named:  any packageName ) unload  ] .	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC' 		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols''Tests' 'SUnitGUI'	) do:[:pkgName| (MCPackage named: pkgName) unload].	"Traits use custom unload"	"Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits]."	"Post-unload cleanup"		SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	Smalltalk forgetDoIts.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.! !!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ul 4/28/2010 11:38'!keyAtValue: value	"Answer the key that is the external name for the argument, value. If	there is none, answer nil."	self deprecated: 'Use Smalltalk globals'.	^globals keyAtValue: value! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:44'!flagInterpretedMethods: aBoolean	"The Cog VM can be instructed to set the flag bit of CompiledMethods that	 it executes but will only interpret.  This can be used e.g. to profile startup.	 See CompiledMethod>>#flag & CompiledMethod>>#clearFlag.  	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 2) + (aBoolean ifTrue: [2] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:43'!isRunningCog	"Returns true if we're running on a Cog VM (JIT or StackInterpreter)	 (vmParameterAt: 42 is the number of stack pages)"	^[(self vmParameterAt: 42) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:41'!isRunningCogit	"Returns true if we're running on the Cog JIT	 (vmParameterAt: 46 is the size of the machine code zone)"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:23'!processHasThreadIdInstVar: aBoolean	"The threaded VM needs to know if the 4th inst var of Process	 is threadId which it uses to control process-to-thread binding.	 This flag persists across snapshots, stored in the image header."	aBoolean ifTrue: [self assert: (Process instVarNames at: 4) ='threadId'].	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 1) + (aBoolean ifTrue: [1] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:51'!processPreemptionYields	"Answer whether the VM causes a process to yield on process preemption,	 i.e. to put a preempted process at the back of its run queue.  If the parameter	 is unavailable (non-Cog VMs) or bit 2 (4) is 0 then preemption yields."	^(([self vmParameterAt: 48]			on: Error			do: [:ex| ^true]) allMask: 4) not! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:26'!processPreemptionYields: aBoolean	"The Cog VM can be instructed not to yield on process preemption,	 i.e. not to put a preempted process at the back of its run queue.  By	 default preempting a process causes it to yield (Blue Book semantics)	 which can have unfortunate effects.	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 4) + (aBoolean ifTrue: [0] ifFalse: [4])! !!SmalltalkImage methodsFor: 'special objects' stamp: 'ar 6/20/2010 16:20'!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: nil. "Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray	! !!SmalltalkImage methodsFor: 'accessing' stamp: 'ul 4/18/2010 22:22'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	^globals at: key ifPresentAndInMemory: aBlock! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:45'!image	"Answer the object to query about the current object memory and execution environment."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:47'!imageFormatVersion	"Answer an integer identifying the type of image. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required). This invokes an optional primitive	that may not be available on all virtual machines."	"Smalltalk image imageFormatVersion"	<primitive: 'primitiveImageFormatVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.	^''! !!SmalltalkImage methodsFor: 'image' stamp: 'md 5/16/2006 12:34'!version	"Answer the version of this release."	^SystemVersion current version! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 1/4/2010 21:40'!wordSize	"Answer the size in bytes of an object pointer or word in the object memory.	The value does not change for a given image, but may be modified by a SystemTracer	when converting the image to another format. The value is cached in WordSize to	avoid the performance overhead of repeatedly consulting the VM."	"Smalltalk wordSize"	^ WordSize ifNil: [WordSize := [SmalltalkImage current vmParameterAt: 40] on: Error do: [4]]! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:38'!interpreterSourceVersion	"Answer a string corresponding to the version of the interpreter source.	This represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator, as distinct	from the external platform source code, typically written in C and managed	separately for each platform. An optional primitive is invoked that may not	be available on all virtual machines."	"Smalltalk vm interpreterSourceVersion"	<primitive: 'primitiveInterpreterSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveInterpreterSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!platformSourceVersion	"Answer a string corresponding to the version of the external platform source	code, typically written in C and managed separately for each platform. This	invokes an optional primitive that may not be available on all virtual machines."	"Smalltalk vm platformSourceVersion"	<primitive: 'primitivePlatformSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitivePlatformSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!versionLabel	"Answer a string corresponding to the version of virtual machine. This	represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator,  in	addition to the external platform source code, typically written in C and	managed separately for each platform.		This invokes an optional primitive that may not be available on all virtual	machines. See also vmVersion, which answers a string identifying the image	from which virtual machine sources were generated."	"Smalltalk vm versionLabel"	<primitive: 'primitiveVMVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveVMVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:15'!vm	"Answer the object to query about virtual machine."		^self! !!SocketStream methodsFor: 'control' stamp: 'ar 7/24/2010 14:48'!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	((outNextToWrite > 1) and: [socket isOtherEndClosed not])		ifTrue: [			[self sendData: outBuffer count: outNextToWrite - 1]				on: ConnectionTimedOut				do: [:ex | shouldSignal ifFalse: ["swallow"]].			outNextToWrite := 1]! !!SocketStream methodsFor: 'control' stamp: 'ar 8/5/2010 12:23'!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self isConnected and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !!SocketStream methodsFor: 'initialize-release' stamp: 'ar 7/24/2010 15:13'!destroy	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."	socket ifNotNil:[socket destroy]! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upTo: aCharacterOrByte	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of anObject in the receiver. If  anObject is not in the collection, answer the entire rest of the receiver."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upTo: aCharacterOrByte limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upTo: aCharacterOrByte limit: nBytes	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"	| index result searchedSoFar |	"Look in the current inBuffer first"	index := inBuffer indexOf: aCharacterOrByte startingAt: lastRead + 1.	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: 1.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	"We only get recentlyRead = 0 in the case of a non-signaling socket close."	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset."		index := inBuffer indexOf: aCharacterOrByte						startingAt: (lastRead + searchedSoFar + 1).		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:48'!upToAll: aStringOrByteArray	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upToAll: aStringOrByteArray limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upToAll: aStringOrByteArray limit: nBytes	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"	| index sz result searchedSoFar |	sz := aStringOrByteArray size.	"Look in the current inBuffer first"	index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: lastRead - sz + 2.	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: sz.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset and 		backs up sz - 1 so that we can catch any borderline hits."		index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/5/2010 12:23'!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself.		NOTE: Does not honour timeouts if shouldSignal is false!!"	[[self isConnected] whileTrue: [self receiveData]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream out' stamp: 'ar 7/24/2010 14:48'!nextPutAllFlush: aCollection	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self flush. "first flush pending stuff, then directly send"	socket isOtherEndClosed ifFalse: [		[self sendData: toPut count: toPut size]			on: ConnectionTimedOut			do: [:ex | shouldSignal ifFalse: ["swallow"]]]! !!SocketStream methodsFor: 'testing' stamp: 'ar 7/24/2010 14:50'!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we check the socket for data. If it claims to have data available to read, we try to read some once and recursively call this method again. If something really was available it is now in the inBuffer. This is because there has been spurious dataAvailable when there really is no data to get.	Note: Some subclasses (such as SecureSocketStream) rely on the behavior here since even though data may be available in the underlying socket, it may not result in any output (yet)." 	self isInBufferEmpty ifFalse: [^true].	^socket dataAvailable		ifFalse: [false]		ifTrue: [self receiveAvailableData; isDataAvailable]! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!receiveAvailableData	"Receive available data (as much as fits in the inBuffer) but not waiting for more to arrive. Return the position in the buffer where the new data starts, regardless if anything was read, see #adjustInBuffer."		recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:03'!receiveData	"Receive data. Signal exceptions and timeouts depending on #shouldSignal and #shouldTimeout. Return the position in the buffer where the new data starts, regardless if anything was read."	socket		waitForDataFor: self timeout		ifClosed: [self shouldSignal 			ifTrue:[ConnectionClosed signal: 'Connection closed while waiting for data.']]		ifTimedOut: [self shouldTimeout			ifTrue:[ConnectionTimedOut signal: 'Data receive timed out.']].	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!receiveDataIfAvailable	"Deprecated. Use #receiveAvailableData instead"	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!receiveDataInto: buffer startingAt: index.	"Read data from the underlying socket. This method may be overridden by subclasses wanting to control incoming traffic for other purposes like encryption or statistics."	^socket  receiveAvailableDataInto: buffer startingAt: index.! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!sendData: buffer count: n	"Sends outgoing data directly on the underlying socket."	^socket sendData: buffer count: n! !!SpaceTally methodsFor: 'fileOut' stamp: 'nice 6/11/2010 21:28'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f := FileStream readOnlyFileNamed: fileName1.	coll1 := OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: f nextLine].	f close.	f := FileStream readOnlyFileNamed: fileName2.	coll2 := OrderedCollection new.	[f atEnd] whileFalse:		[item := f nextLine.		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SparseXTable methodsFor: 'accessing' stamp: 'nice 7/10/2010 23:49'!tableFor: code	| div |	div := code // 65536.	^xTables at: div ifAbsentPut:		[Array new: 65536 withAll: 0].! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/24/2010 02:51'!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [					sourceStream skip: -1.					^ self expected: 'an integer greater than 1 as valid radix'].			self peekSignIsMinus				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:11'!bookName 	^'Squeak'! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:30'!icon	(self name = #SqueakHelp) ifTrue: [^HelpIcons iconNamed: #squeakIcon].	^nil! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:16'!bookName 	^'License'! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'mha 5/2/2010 17:26'!pages	^#(licenseChange officialLicense)! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'hjh 4/29/2010 16:48'!licenseChange	^HelpTopic 		title: 'License has changed with 4.0'		contents: 'On 23 September 1996, Apple Computer Inc. released Squeak V1.1 under the "Squeak License" (SqL).On May 8, 2006 Apple agreed to relicense original Squeak V1.1 under the Apple Public Source License.On October 12, 2006 Apple granted permission to relicense under Apache license 2.0.In 2006, VPRI began to collect "Distribution Agreements" for all contributors to Squeak since V1.1 up to V3.8, asking them to relicense their contributions, which were originally licensed under SqL, to the MIT license. This was a great effort on behalf of many and VPRI has 100s of signed documents agreeing to this.Do you want to contribute source to Squeak?All new contributions since 4.0 must be under the MIT license. When you make your code available, please state explicitly in some form such as the description on a web site or email announcement that your contribution is under the MIT license. (It doesn''t have to be exclusive; you can release it under difference licenses at the same time.)Have you contributed source to Squeak? If you believe you have, but have not sent in an agreement to allow your submission(s) to be licensed under the MIT license then please see http://netjam.org/squeak/contributors. There you can find a list of known contributors and a PDF of the agreement with instructions. The snail mail address is found in the agreement PDF file.Also there are a few people for which we are lacking full contact information. If you think you can help please also visit the link above and see if you can identify any of the unknown developer initials or any of the developers for whom we do not have a current email address.' ! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'mha 5/2/2010 17:35'!officialLicense	^HelpTopic 		title: 'Official License - 4.0'		contents: 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2010 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:13'!bookName 	^'Squeak Project'! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:15'!pages	^#(introduction )! !!SqueakProjectHelp class methodsFor: 'pages' stamp: 'tbn 3/5/2010 22:01'!introduction	^HelpTopic		title: 'Welcome'		icon: (HelpIcons iconNamed: #squeakIcon)		contents:'WELCOMESqueak is a modern, open source, full-featured implementation of the powerful Smalltalk programming language and environment. Squeak is highly-portable - even its virtual machine is written entirely in Smalltalk making it easy to debug, analyze, and change. Squeak is the vehicle for a wide range of projects from multimedia applications, educational platforms to commercial web application development.'! !!SqueakToolsHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:08'!basicDevelopmentTools	^HelpTopic 		title: 'Basic Development Tools'		contents: 'Smalltalk environments have some of the best user interfaces for programmers ever devised. Those who have programmed in Lisp under Emacs have some idea, but Smalltalk is even better.		You should learn these basic tools thoroughly:- Workspace- Transcript- Browser- Inspector- File List- Change Sorter- Debugger- Method Finder		'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 22:59'!bookName 	^'Tools'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:08'!pages	^#(basicDevelopmentTools)! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:14'!bookName	^'Transcript'! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:16'!pages	^# (transcript)! !!SqueakToolsTranscriptHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:16'!transcript	^HelpTopic 		title: 'The Transcript window'		contents: 'The Transcript window is often used for logging or printing results from text only code. To open the Transcript use TheWorldMenu and choose ''open...''. Then choose ''Transcript''.You can also type   Transcript openin a Workspace and doIt.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:06'!bookName 	^'Workspace'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:11'!pages	^#(workspace openWorkspace saveWorkspace)! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:10'!openWorkspace	^HelpTopic 		title: 'Open a Workspace'		contents: 'You can open a Workspace window, by doing any one of the following:		- Using a keyboard while pointing at an empty part of the Squeak wind, alt-k (in Windows, cmd-k in Mac)- Open up a World Menu, select "open..." action. From the open menu, select "workspace (k)- Click on the Tools Flap. When it comes out, click on the Workspace icon and drag it out. (Click on the Tools Flap to close it back up.).'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:13'!saveWorkspace	^HelpTopic 		title: 'Saving Workspace to a File'		contents: 'You can save the text content of a Workspace to a file by choosing the workspace menu (from within the workspace), then ''more...'', then ''save contents to file...''.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:09'!workspace	^HelpTopic 		title: 'What is a Workspace'		contents: 'A Workspace is a window used as a scratchpad area where fragments of Smalltalk code can be entered, stored, edited, and evaluated. To open a workspace window in Squeak, one possibility is to bring up the World menu, select "open...", and then select "workspace". You can then type in any Smalltalk code inside the workspace window and execute it or inspect it.'! !!SqueakTutorials class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:33'!bookName 	^'Tutorials'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:34'!bookName 	^'XML'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:35'!pages	^# (dataRetrieval)! !!SqueakTutorialsOnXML class methodsFor: 'pages' stamp: 'it 5/4/2010 20:12'!dataRetrieval	^HelpTopic 		title: 'Retrieving XML data'		contents: 'Retrieving data from XML documents is simple and easy in Squeak Smalltalk. This tutorial demonstrates the fundamentals with a straightforward approach where code can be tested right away either here or in a Workspace window. The beauty of Squeak Smalltalk resides in the possibility to evaluate, inspect, print and debug code anywhere and this window is no different. This tutorial demonstrates how to...	* retrieve an XML document from the World Wide Web	* instantiate an XML document class	* inspect and understand the content of an XML document	* retrieve and display values from specific XML tagsRetrieve an XML document from the World Wide WebThere are many manners to retrieve data from the World Wide Web in Squeak Smalltalk. HTTPClient is among them and allows to download files in all simplicity. Select the following code snippet and inspect it (press alt-i). An Inspect window will open with the document loaded in memory. The result is a MIMEDocument object.	HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.TIP: Select HTTPClient and browse it (press alt-b) to open a System Browser window on its class. HTTPClient does not have instance methods but it has class methods. Click on class to see class methods.Instantiate an XML DocumentAn instance of MIMEDocument will not allow to retrieve XML data in a comprehensive manner because it does not understand the nature of XML. For this reason, it is necessary to parse the content of MIMEDocument using XMLDOMParser. XMLDOMParser>>parseDocumentFrom: requires a stream as a parameter and ReadStream will be used for this purpose. The following code snippet instantiates an XMLDocument using the content of the downloaded file.	| doc |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).Inspect and understand the content of an XML documentXML is a flexible document format and it is necessary to understand how each given XML file is structured in order to properly search, retrieve and manipulate data. Inspecting values is critical in a dynamic programming language and environment, such as Squeak Smalltalk. Select the previous code snippet and inspect it (press alt-i).Unfortunately, the Inspect window does not reveal a lot about the XML structure of the downloaded file. Select the previous code snippet once again and explore it (press alt and the capital letter i). An Explorer window will open with a tree outline on the instance of XMLDocument.The Inspect and Explorer windows tell a lot about an XMLDocument. The sections are instance variables and their values are displayed aside. In the Explorer window, unfold elementsAndContents. Unfold other sections as deemed necessary to understand the XML format and the data available.The gibberish coding is about to become clear. Open a Browser window from the world menu and right click in the first pane, select find class (press alt-f) and type XMLDocument to search for its class, or select the class name and browse it (press alt-b). However, it is suggested to read more about XMLParser and XMLParserTest first. Retrieve and display values from specific XML tagsThe downloaded XML file contains a list of items which are denoted by the tag name "item". The Explorer window revealed the content of interest is located at the array index 1 of the elementsAndContents, which can be accessed through XMLDocument>>root.TIP: Some XML documents have additional components contained within its file, such as XMLPI (XML Processing Instructions). For this reason, the root may lead to this rather than the data which will be indexed at 2 or more. It is necessary to use XMLNodeWithElements>>elements, e.g. (xml elements at: 2), in order to access subsequent data.The following code snippet will display items in a Transcript window. Open a Transcript window using the world menu before selecting and executing the code. Select the code snippet and execute it (press alt-d).	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript show: (e asString); cr.		].An XML item looks like this:	<item>	<title>HelpSystem-Core-tbn.46.mcz</title>	<link>http://source.squeak.org/trunk.html</link>	<description>throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)</description>	<pubDate>Sun, 02 May 2010 20:23:49 +0000</pubDate>	<author>Torsten Bergmann &lt;Torsten.Bergmann@astares.de&gt;</author>	<category>The Trunk</category>	<enclosure length="27288" type="application/x-monticello" url="http://source.squeak.org/trunk/HelpSystem-Core-tbn.46.mcz"/> 	<guid isPermaLink="false"/> </item>The following code snippet uses information learned, retrieves each comment and displays them in a Transcript window. Notice an author can have a nil value and is handled accordingly.	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript 			show: ''Date: '', ((e firstTagNamed: #pubDate) contentString); cr;			show: ''Title: '', ((e firstTagNamed: #title) contentString); cr;			show: ''Author: '', 				(((e firstTagNamed: #author) notNil)					ifTrue: [(e firstTagNamed: #author) contentString]					ifFalse: ['''']); cr;			show: ''Description: '', ((e firstTagNamed: #description) contentString); cr; cr.			].An item will now look like:	Date: Sun, 02 May 2010 20:23:49 +0000	Title: HelpSystem-Core-tbn.46.mcz	Author: Torsten Bergmann <Torsten.Bergmann@astares.de>	Description: throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)'! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:13'!upTo: delimiter	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOf: delimiter startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:14'!upToAnyOf: delimiters do: aBlock	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					| result |					result := collection copyFrom: position + 1 to: (position := pos) - 1 .					aBlock value: (collection at: position).					^result ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOfAnyOf: delimiters startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue.		bytesRead = 0 ifFalse: [			aBlock value: (buffer at: pos) ] ]! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29'!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f := FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens := f nextLine  findTokens: ' '.	iRect := Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent := iRect top.	descent := iRect bottom negated.		tempGlyphs := Form extent: (maxWidth*257) @ self height.	xTable := (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii := -1.	[charLine := self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p := f position.		rectLine := f nextLine.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens := rectLine findTokens: ' '.					left := (tokens at: 5) asNumber. right := (tokens at: 8) asNumber]			ifFalse: [left := right := 0. f position: p].		width:= (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii := 256].		('x''*' match: charLine) ifTrue:			[ascii := Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm := Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line := f nextLine.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm := charForm deepCopy]				ifFalse:				[minAscii := minAscii min: ascii.				maxAscii := maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii := ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs := Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable := xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap := nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29'!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line := file nextLine.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!StrikeFont methodsFor: 'make arrows' stamp: 'sps 10/15/2003 17:06'!makeAssignArrow"Replace the underline character with an arrow for this font"	| arrowForm arrowCanvas arrowY arrowLeft arrowRight arrowHeadLength |	arrowForm := (self characterFormAt: $_) copy.	arrowCanvas := arrowForm getCanvas.	arrowCanvas fillColor: Color white.	arrowY := arrowForm height // 2.	arrowLeft := 0. 	arrowRight := arrowForm width - 2.	arrowHeadLength := (arrowRight - arrowLeft) * 2 // 5.	"Draw the lines"	arrowCanvas line: (arrowLeft@arrowY) to: (arrowRight@arrowY) color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY - arrowHeadLength)) 		color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY + arrowHeadLength)) 		color: Color black.	"Replace the glyph"	self characterFormAt: $_ put: arrowForm.! !!String methodsFor: 'accessing' stamp: 'nice 6/11/2010 21:44'!lines	"Answer an array of lines composing this receiver without the line ending delimiters."	^Array new: (self size // 60 max: 16) streamContents: [:lines |		self linesDo: [:aLine | lines nextPut: aLine]]! !!String methodsFor: 'converting' stamp: 'ar 7/15/2010 17:13'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end | | lineStart |				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [endWithoutDelimiters + 1]) min: endWithoutDelimiters.				[| lineStop lineEnd spacePosition |				lineEnd := 0.				spacePosition := lineStart.				lineStop := (lineStart + aNumber - 1) min: endWithoutDelimiters.				[spacePosition <= lineStop] whileTrue:[					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [endWithoutDelimiters+1].					spacePosition <= (lineStop+1) ifTrue:[lineEnd := spacePosition].				].				lineEnd = 0					ifTrue: ["no space - split arbitrarily"						lineEnd := lineStart + aNumber - 1 min: endWithoutDelimiters.						stream nextPutAll: (self copyFrom: lineStart to: lineEnd).						lineStart := lineEnd + 1]					ifFalse: ["split before space"						stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).						"eliminate conscutive spaces at split"						lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd + 1 ifAbsent: [endWithoutDelimiters + 1] ].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: endWithoutDelimiters + 1 to: end) ] ]! !!String methodsFor: '*sound-synthesis' stamp: 'wiz 4/28/2010 16:01'!asSound	"Return a sound. Either from the sound library via SampleSound or	else the Beeper default"	^ SampledSound		soundNamed: self		ifAbsent: [Beeper default]! !!StringHolder class methodsFor: 'instance creation' stamp: 'fbs 4/28/2010 18:53'!open	^ (Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:53'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [displayContents text]! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:55'!unacceptedEditState: stateOrNil	(hasUnacceptedEdits := stateOrNil notNil) ifTrue:		[self editString: stateOrNil]! !!Symbol class methodsFor: 'access' stamp: 'eem 12/21/2008 12:18'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	(aString first isLetter or: [aString first isDigit]) ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'eem 5/22/2008 12:56'!selectorsMatching: aStringPattern	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.	 Does return symbols that begin with a capital letter."	| selectorList |	selectorList := OrderedCollection new.	aStringPattern isEmpty ifTrue: [^selectorList].	self allSymbolTablesDo:		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"		[:each | each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]	"Symbol selectorsMatching: 'parse:*'"! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 4/13/2010 00:00'!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols with 25% free space."	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable capacity.	SymbolTable compact.	^(oldSize - SymbolTable capacity) printString, ' slot(s) reclaimed'! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'eem 7/2/2010 17:20'!flushClassNameCache	"Smalltalk flushClassNameCache"	"Force recomputation of the cached list of class names."	cachedClassNames := nil! !!SystemDictionary methodsFor: 'compatibility' stamp: 'ul 4/28/2010 11:45'!hasSpecialSelector: aLiteral ifTrueSetByte: aBlock	self deprecated: 'Use Smalltalk'.	^Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: aBlock! !!SystemDictionary methodsFor: 'removing' stamp: 'eem 5/19/2010 15:35'!removeKey: key ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in	the receiver, answer the result of evaluating aBlock. Otherwise, answer	the value externally named by key."	self flushClassNameCache.	^super removeKey: key ifAbsent: aBlock! !!SystemNavigation methodsFor: 'browse' stamp: 'dtl 8/1/2010 10:12'!browseMyChanges	"Browse only the changes (in the changes file) by the current author."	"SystemNavigation default browseMyChanges"	self browseAllSelect: [ :method |       method fileIndex > 1 "only look at changes file"               and: [ method timeStamp beginsWith: Utilities authorInitials ]]! !!SystemOrganizer class methodsFor: 'class initialization' stamp: 'spd 5/19/2010 15:54'!default	"I have a global instance, SystemOrganization.  In case someone stumbles upon my class, and does not know about the global, it can be accessed from here, too."  ^ SystemOrganization.! !!SystemWindow methodsFor: 'initialization' stamp: 'ar 6/23/2010 17:13'!addCornerGrips	"When enabled via preference, also add edge grips"	super addCornerGrips.	self class resizeAlongEdges ifTrue:[self addEdgeGrips].! !!SystemWindow methodsFor: 'open/close' stamp: 'eem 5/23/2008 13:17'!delete	| thisWorld sketchEditor aPaintBox |	self mustNotClose ifTrue: [^self].	model okToClose ifFalse: [^self].	thisWorld := self world.	sketchEditor := self extantSketchEditor.	self isFlexed		ifTrue: [owner delete]		ifFalse: [super delete].	model windowIsClosing; release.	model := nil.	sketchEditor ifNotNil:		[sketchEditor deleteSelfAndSubordinates.		 (thisWorld notNil 		  and: [(aPaintBox := thisWorld paintBoxOrNil) notNil]) ifTrue:			[aPaintBox delete]].			SystemWindow noteTopWindowIn: thisWorld! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'cmm 6/20/2010 16:54'!collapseOrExpand	"Collapse or expand the window, depending on existing state"	| cf |	isCollapsed		ifTrue: 			["Expand -- restore panes to morphics structure"			isCollapsed := false.			self activate.  "Bring to frint first"			Preferences collapseWindowsInPlace				ifTrue: 					[fullFrame := fullFrame align: fullFrame topLeft with: self getBoundsWithFlex topLeft]				ifFalse:					[collapsedFrame := self getBoundsWithFlex].			collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse this window'].			self setBoundsWithFlex: fullFrame.			paneMorphs reverseDo: 					[:m |  self addMorph: m unlock.					self world startSteppingSubmorphsOf: m].			self addPaneSplitters]		ifFalse: 			["Collapse -- remove panes from morphics structure"			isCollapsed := true.			fullFrame := self getBoundsWithFlex.			"First save latest fullFrame"			paneMorphs do: [:m | m delete; releaseCachedState].			self removePaneSplitters.			self removeCornerGrips.			model modelSleep.			cf := self getCollapsedFrame.			(collapsedFrame isNil and: [Preferences collapseWindowsInPlace not]) ifTrue:				[collapsedFrame := cf].			self setBoundsWithFlex: cf.			collapseBox ifNotNil: [collapseBox setBalloonText: 'expand this window'].			expandBox ifNotNil: [expandBox setBalloonText: 'expand to full screen'].			self sendToBack].	self layoutChanged! !!SystemWindow commentStamp: '<historical>' prior: 0!SystemWindow is the Morphic equivalent of StandardSystemView -- a labelled container for rectangular views, with iconic facilities for close, collapse/expand, and resizing.The attribute onlyActiveOnTop, if set to true (and any call to activate will set this), determines that only the top member of a collection of such windows on the screen shall be active.  To be not active means that a mouse click in any region will only result in bringing the window to the top and then making it active.!!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:12'!resizeAlongEdges	<preference: 'Resize Windows along edges'		category: 'Morphic'		description: 'When true, windows can be resized along their edges as well as the corners'		type: #Boolean>	^ResizeAlongEdges ifNil:[true]! !!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:13'!resizeAlongEdges: aBool	"Preference setter"	ResizeAlongEdges := aBool! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 8/14/2010 11:02'!isDeclaredAtMethodLevel	"For the explainer."	^scope = 0! !!TempVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitTempVariableNode: self! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:22'!emitCodeForLoad: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53'!emitCodeForStore: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStoreInto: self stack: stack encoder: encoder].	encoder genStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:54'!emitCodeForStorePop: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStorePopInto: self stack: stack encoder: encoder].	encoder genStorePopTemp: index.	stack pop: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53'!emitCodeForValue: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForValueOf: self stack: stack encoder: encoder].	encoder genPushTemp: index.	stack push: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:23'!sizeCodeForLoad: encoder	^remoteNode isNil		ifTrue: [0]		ifFalse: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStore: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStoreInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52'!sizeCodeForStorePop: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStorePopInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStorePopTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:51'!sizeCodeForValue: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForValueOf: self encoder: encoder].	self reserve: encoder.	^encoder sizePushTemp: index! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:26'!defaultTimeout	"Answer the default timeout to use for tests in this test case.	The timeout is a value in seconds."	^5 "seconds"! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 13:10'!timeout: seconds	"The timeout for a test should normally be set with a method annotation.	However, for tests that are expected to run in images that do not support	method annotations, the value may be set by setting the value from the	#setUp method (i.e. prior to running the test method)."	timeout := seconds! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:26'!timeoutForSetUp	"Answer the timeout to use for setUp"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^self defaultTimeout! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:07'!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^timeout ifNil: [self defaultTimeout]! !!TestCase methodsFor: 'running' stamp: 'dtl 6/6/2010 15:10'!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout: [self setUp]		after: self timeoutForSetUp.	self timeout: [self performTest]		after: self timeoutForTest]		ensure: [self tearDown]! !!TestCase methodsFor: 'running' stamp: 'ar 7/9/2010 11:31'!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error, Halt do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !!TestCase commentStamp: '<historical>' prior: 0!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!!TextComposer methodsFor: 'as yet unclassified' stamp: 'cmm 6/13/2010 20:50'!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	defaultLineHeight := scanner canComputeDefaultLineHeight		ifTrue: [ scanner computeDefaultLineHeight ]		ifFalse: [ theTextStyle lineGrid. ].	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!TextEditor methodsFor: 'menu messages' stamp: 'cmm 5/25/2010 12:59'!prettyPrint: decorated 	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	selectedClass := model selectedClassOrMetaClass.	selectedClass ifNil: [ ^ morph flash ].	newText := selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[ self			deselect ;			selectInvisiblyFrom: 1			to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: self text size + 1 ]! !!TextEditor methodsFor: 'editing keys' stamp: 'cmm 7/2/2010 19:01'!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([{"''' indexOf: char ifAbsent: [ ^true ].	left := '([{"''' at: which.	right := ')]}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])			and: [ (text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !!TextEditor methodsFor: 'typing support' stamp: 'cmm 7/3/2010 16:12'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys openers closers result |	((char == Character cr) and: [morph acceptOnCR])		ifTrue: [			sensor keyboard.  "Gobble cr -- probably unnecessary."			self closeTypeIn.			^ true].	self clearParens.  	char asciiValue = 13 ifTrue: [		sensor controlKeyPressed ifTrue: [			^ self normalCharacter: typeAheadStream ].		sensor leftShiftDown ifTrue: [			^ self lf: typeAheadStream ].		sensor commandKeyPressed ifTrue: [			^ self crlf: typeAheadStream ].		^ self crWithIndent: typeAheadStream ].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue: [				self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [				self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue: [			^ self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	openers := '([{'.  closers := ')]}'.	(closers includes: char) ifTrue: [self blinkPrevParen].	result := self normalCharacter: typeAheadStream.	(self class autoEnclose and: [ openers includes: char ])		ifTrue: 			[ typeAheadStream nextPut: (closers at: (openers indexOf: char)).			self insertTypeAhead: typeAheadStream.			self moveCursor: [ : position | position-1 ] forward: false specialBlock: [ : pos | "no special behavior" ] select: false ].	^ result! !!TextEditor methodsFor: 'explain' stamp: 'eem 8/14/2010 11:15'!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !!TextEditor commentStamp: '<historical>' prior: 0!See comment in Editor.My instances edit Text, this is, they support multiple lines and TextAttributes.They have no specific facilities for editing Smalltalk code. Those are found in SmalltalkEditor.!!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:18'!autoEnclose	<preference: 'Auto Enclose'		category: 'Morphic'		description: 'When true, typing an opening parenthesis, bracket or square-bracket will also add its corresponding closing character in front of the cursor.'		type: #Boolean>	^ AutoEnclose ifNil: [ false ]! !!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:17'!autoEnclose: aBoolean	AutoEnclose := aBoolean! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'cmm 7/2/2010 19:00'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.				"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.			"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.		"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.		"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.				"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.				"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.				"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.				"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"				'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmds := #($a #selectAll: $c #copySelection: $e #exchange: $f #find: $g #findAgain: $h #setSearchString: $k #offerFontMenu: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).	1 to: cmds size		by: 2		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions := cmdMap! !!TextMorph methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58'!keyboardFocusChange: aBoolean 	| w |	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"].			Editor blinkingCursor ifTrue: [ self startBlinking ].	] ifFalse:["A hand has clicked elsewhere..."		(w := self world) ifNotNil:[			w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].			"Release control unless some hand is still holding on"			self releaseEditor].		self stopBlinking.	].! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58'!keyboardFocusChange: aBoolean 	"rr 3/21/2004 22:55 : removed the #ifFalse: branch, 	which was responsible of the deselection of text when the 	paragraph lost focus. This way selection works in a more standard 	way, and this permits the menu keyboard control to be really effective"	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."		self hasFocus ifFalse: [self editor	"Forces install"].		Editor blinkingCursor ifTrue: [self startBlinking].	] ifFalse:[		self stopBlinking.	].	self changed.! !!TextOnCurve methodsFor: 'display' stamp: 'bf 6/17/2010 19:19'!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| warp lineRect lineCanvas backgroundColor lineForm leftInRun sourceQuad maxExtent |	"most of these temps are initialized lazily and need to be at the method level - do not move into the block below!!"	warp := nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may not have to display at all."				maxExtent := lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm := Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect := lineForm boundingBox.				leftInRun := 0.				backgroundColor := (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp := (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas := lineForm getCanvas].			sourceQuad := destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun := displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'ar 8/6/2010 23:45'!menusOn: aDockingBar 	self 		squeakMenuOn: aDockingBar;		projectsMenuOn: aDockingBar;		toolsMenuOn: aDockingBar;		appsMenuOn: aDockingBar;		extrasMenuOn: aDockingBar;		windowsMenuOn: aDockingBar;		helpMenuOn: aDockingBar.	aDockingBar addSpacer.	self		searchBarOn: aDockingBar;		clockOn: aDockingBar! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'cbr 5/1/2010 01:47'!projectsMenuOn: aDockingBar	aDockingBar addItem: [ :item |		item			contents: 'Projects' translated;			addSubMenu: [ :menu | 				self					newProjectMenuItemOn: menu;					saveProjectMenuItemOn: menu;					loadProjectMenuItemOn: menu;					previousProjectMenuItemOn: menu;					jumpToProjectMenuItemOn: menu;					toggleFullScreenMenuItemOn: menu ] ]! !!TheWorldMainDockingBar methodsFor: 'private' stamp: 'laza 4/26/2010 10:31'!colorIcon: aColor	"Guess if 'uniform window colors' are used and avoid all icons to be just gray"	(aColor = Preferences uniformWindowColor or: [Preferences tinyDisplay]) ifTrue: [ ^nil ].	^(aColor iconOrThumbnailOfSize: 14)		borderWidth: 3 color: Preferences menuColor muchDarker;		borderWidth: 2 color: Color transparent! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'cbr 5/1/2010 01:42'!toggleFullScreenMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Toggle Full Screen' translated;			help: 'Switch back and forth from full screen mode' translated;			icon: MenuIcons smallFullScreenIcon;			target: Project current;			selector: #toggleFullScreen ]! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 4/26/2010 10:57'!listWindowsOn: menu	| windows |	windows := SortedCollection sortBlock: [:winA :winB |		winA model name = winB model name			ifTrue: [winA label < winB label]			ifFalse: [winA model name < winB model name]].	windows addAll: self allVisibleWindows.	windows ifEmpty: [ 		menu addItem: [ :item | 			item				contents: 'No Windows' translated;				isEnabled: false ] ].	windows do: [ :each |		menu addItem: [ :item |			item 				contents: (self windowMenuItemLabelFor: each);				icon: (self colorIcon: each model defaultBackgroundColor);				target: each;				selector: #comeToFront;				subMenuUpdater: self				selector: #windowMenuFor:on:				arguments: { each };				action: [ each activateAndForceLabelToShow; expand ] ] ].! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'dcorking 5/6/2010 13:59'!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WASqueakServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 29 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'eem 6/24/2010 21:51'!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk classNamed: #HelpBrowser) ifNotNil: 					[:classHelpBrowser|					menu addLine.					menu addItem: [ :item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: classHelpBrowser;							selector: #open ] ].			]].! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'hjh 4/21/2010 18:40'!showWelcomeText: aSelector label: labelString in: bounds	"Show a welcome text. Linked in here so that the text can be edited	by changing the acceptBlock below."	| acceptBlock window |	"Change the following to allow editing the text"	true ifTrue:[		acceptBlock := [:text|			self class				compile: aSelector,'	^', (String streamContents:[:s| s nextChunkPutWithStyle: text]) storeString, ' readStream nextChunkText'				classified: (self class organization categoryOfElement: aSelector).		].	].	window := UIManager default 		edit: (self perform: aSelector)		label: labelString		accept: acceptBlock.	window bounds: bounds.! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'spd 5/24/2010 19:19'!squeakUserInterface	^'The Squeak UI has some unusual elements that you may not have seen before.  Here is a brief introduction to those elements:ProjectsA project is an entire Squeak desktop full of windows.  Projects can be used to change quickly from one task to another.  An inactive project is represented by a project window, which shows a thumbnail of its state.  Project windows are actually more like doors than windows, since you can enter the project just by clicking on them.  You can create a new project by choosing ''open...project'' from the screen menu.  To exit a project (and return to its parent project), choose ''previous project'' from the screen menu.  Each project maintains its own set of windows and other information.Morphic HalosIn a morphic project, pressing cmd-click (Mac) or alt-click (Windows) on a graphical object (e.g. a window) will surround it with a constellation of colored circles.  These are called "halo handles."  Additional clicks will cycle through the halos for the other graphical objects in the nesting structure.  If you hold down the Shift key while cmd/alt-clicking, the nested morphs will be traversed from innermost outward.  Clicking without the cmd/alt key will dismiss the halo.  While the halo is up, letting the cursor linger over one of the halo handles for a few seconds will cause a balloon to pop up with the name of that handle.  Three useful handles are the top-left "X" handle (delete), the bottom-right yellow handle (resize), and the brown handle (slide the object within its containing object).  Halos allow complex graphical objects to be explored - or even disassembled (using the black halo handle).  Usually no harm results from taking apart an object; you can just discard the pieces and create a new one.FlapsTo enable Flaps, click on the desktop to show the world menu, choose the "Flaps..." menu and "show shared tags". Tabs labeled "Squeak", "Tools", "Supplies", etc., will appear along the edges of the Squeak desktop.  Click on any tab to open the corresponding flap.  Drag a tab to resize the flap and to relocate the tab.  Bring up the halo on any tab and click on its menu handle to be presented with many options relating to the flap.  Use the "Flaps..." menu, reached via the desktop menu, to control which flaps are visible and for other flap-related options and assistance.Parts BinsYou can obtain new objects in many ways.  The "Objects Catalog" (choose "objects'' from the world menu or open the objects flap) and several of the standard flaps (e.g. "Tools" and "Supplies") serve as "Parts Bins" the for new objects.  Drag any icon you see in a Parts Bin and a fresh copy of the kind of object it represents will appear "in your hand"; click to deposit the new object anywhere you wish.  You can also add your own objects to any of the flaps - just drag your object over the tab, wait for the flap to pop open, then drop the object at the desired position in the flap.!!]style[(123 9 663 13 991 5 579 10 589),bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:40'!appsMenuOn: aDockingBar	"Create a menu with the registered apps"	aDockingBar addItem: [ :item |		item			contents: 'Apps' translated;			subMenuUpdater: self			selector: #listAppsOn: ]! !!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:44'!listAppsOn: menu	"Update the apps list in the menu"	| args |	TheWorldMenu registeredOpenCommands do:[:spec|		args := spec second.		menu addItem: [ :item |			item				contents: spec first translated;				target: args first;				selector: args second].	].! !!TheWorldMenu methodsFor: 'action' stamp: 'ar 8/2/2010 20:51'!saveScreenshot	"Make a screenshot of the world and save it to a file"	SampledSound playSoundNamed: 'camera'.	PNGReadWriter putForm: myWorld imageForm onFileNamed:		(FileDirectory default nextNameFor: 'SqueakScreen' extension:'png').! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 8/2/2010 20:51'!addPrintAndDebug: menu	Preferences simpleMenus ifFalse: [		self			fillIn: menu			from: {				{ 'make screenshot'. {self. #saveScreenshot}. 'makes a screenshot and saves it to disk'}.				"{ 'print PS to file...'. { self. #printWorldOnFile }. 'write the world into a postscript file' }."				{ 'debug...'. { self. #debugDo }. 'a menu of debugging items' }			} ]! !!TheWorldMenu methodsFor: 'construction' stamp: 'cmm 6/13/2010 20:39'!changesMenu        "Build the changes menu for the world."        | menu |        menu := self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { ChangeSet current . #verboseFileOut}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSet . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { self  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions (R)' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.			nil.                { 'recently logged changes...' . { self . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        ^ menu! !!Time class methodsFor: 'clock' stamp: 'dtl 8/14/2010 15:25'!primMicrosecondClock	"Answer the number of microseconds since the microsecond clock	was last reset or rolled over. Answer zero if the primitive fails."	<primitive: 'primitiveMicrosecondClock'>	^ 0! !!Time class methodsFor: 'clock' stamp: 'dtl 8/14/2010 14:53'!primUtcWithOffset	"Answer an array with UTC microseconds since the Posix epoch and	the current seconds offset from GMT in the local time zone."	<primitive: 'primitiveUtcWithOffset'>	^ { 0 . 0 }! !!TopGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:22'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!TopGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!TopGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:31'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ -40  corner: 0@ 0)! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!ptName	^#top! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!resizeCursor	^ Cursor resizeForEdge: #top! !!UIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 0!UIManager is a dispatcher for various user interface requests, such as menu and dialog interactions. An instance of UIManager is associated with each Project to implement the appropriate functions for Morphic, MVC or other user interfaces.!!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:54'!default	^ Project current uiManager! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:52'!getDefault	"Ensure that a more specific manager can always be made by subclassing	a tool builder and implementing a more specific way of reacting to	#isActiveManager. For example, a BobsUIManager can subclass	MorphicUIManager and (if enabled, say Preferences useBobsUI) will	be considered before the parent (generic MorphicUIManager)."	^ (self allSubclasses		detect: [:any | any isActiveManager				and: [any subclasses						noneSatisfy: [:sub | sub isActiveManager]]]		ifNone: [])		ifNotNilDo: [:mgrClass | mgrClass new]! !!UTF16TextConverter methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 6/7/2010 15:04'!useLittleEndian: aBoolean	aBoolean = self useLittleEndian ifFalse: [self swapLatin1EncodingByteOrder].	useLittleEndian := aBoolean.! !!UTF16TextConverter methodsFor: 'private' stamp: 'HenrikSperreJohansen 6/7/2010 15:04'!swapLatin1EncodingByteOrder	latin1Encodings := latin1Encodings collect: [:each | each reverse]! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 5/26/2010 02:20'!nextFromStream: aStream	| character value1 value2 unicode value3 value4 |	aStream isBinary ifTrue: [ ^aStream basicNext ].	character := aStream basicNext ifNil: [ ^nil ].	value1 := character asciiValue.	value1 <= 127 ifTrue: [ ^character ]. "1-byte character" 	"at least 2-byte character"	character := aStream basicNext ifNil: [ ^self errorMalformedInput ].	value2 := character asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63) ].	"at least 3-byte character"	character := aStream basicNext ifNil: [ ^self errorMalformedInput ].	value3 := character asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63) ].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte character"		character := aStream basicNext ifNil: [ ^self errorMalformedInput ].		value4 := character asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63) ].	unicode ifNil: [ ^self errorMalformedInput ].	unicode > 16r10FFFD ifTrue: [ ^self errorMalformedInput ].	unicode = 16rFEFF ifTrue: [ ^self nextFromStream: aStream ].	^ Unicode value: unicode.! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'eem 8/17/2010 16:35'!openMenuIn: aBlock 	| alternatives labels actions lines caption choice |	alternatives := parser possibleVariablesFor: name.	labels := OrderedCollection new.	actions := OrderedCollection new.	lines := OrderedCollection new.	name first isLowercase 		ifTrue: 			[labels add: 'declare method temp'.			actions add: [parser declareTemp: name at: #method].			labels add: 'declare block-local temp'.			actions add: [parser declareTemp: name at: #block].			labels add: 'declare instance'.			actions add: [parser declareInstVar: name]]		ifFalse: 			[labels add: 'define new class'.			actions add: [parser defineClass: name].			labels add: 'declare global'.			actions add: [parser declareGlobal: name].			parser canDeclareClassVariable 				ifTrue: 					[labels add: 'declare class variable'.					actions add: [parser declareClassVar: name]]].	lines add: labels size.	alternatives do: 		[:each | 		labels add: each.		actions add: [parser substituteVariable: each atInterval: interval]].	lines add: labels size.	labels add: 'cancel'.	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !!UndeclaredVariableNode methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:51'!accept: aVisitor	^aVisitor visitUndeclaredVariableNode: self! !!UndeclaredVariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^true! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	^tag! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag: anObject	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	tag := anObject! !!Unicode commentStamp: 'yo 10/19/2004 20:44' prior: 0!This class holds the entry points for the utility functions around characters.!!Unicode class methodsFor: 'class methods' stamp: 'nice 6/11/2010 21:29'!parseUnicodeDataFrom: stream"	self halt.	self parseUnicodeDataFile"	| line fieldEnd point fieldStart toNumber generalCategory decimalProperty |	toNumber := [:quad | ('16r', quad) asNumber].	GeneralCategory := SparseLargeTable new: 16rE0080 chunkSize: 1024 arrayClass: Array base: 1 defaultValue:  'Cn'.	DecimalProperty := SparseLargeTable new: 16rE0080 chunkSize: 32 arrayClass: Array base: 1 defaultValue: -1.	16r3400 to: 16r4DB5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16r4E00 to: 16r9FA5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16rAC00 to: 16rD7FF do: [:i | GeneralCategory at: i+1 put: 'Lo'].	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := toNumber value: (line copyFrom: 1 to: fieldEnd - 1).		point > 16rE007F ifTrue: [			GeneralCategory zapDefaultOnlyEntries.			DecimalProperty zapDefaultOnlyEntries.			^ self].		2 to: 3 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		generalCategory := line copyFrom: fieldStart to: fieldEnd - 1.		GeneralCategory at: point+1 put: generalCategory.		generalCategory = 'Nd' ifTrue: [			4 to: 7 do: [:i |				fieldStart := fieldEnd + 1.				fieldEnd := line indexOf: $; startingAt: fieldStart.			].			decimalProperty :=  line copyFrom: fieldStart to: fieldEnd - 1.			DecimalProperty at: point+1 put: decimalProperty asNumber.		].	].	GeneralCategory zapDefaultOnlyEntries.	DecimalProperty zapDefaultOnlyEntries.! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:47'!initializeCaseMappings	"Unicode initializeCaseMappings"	ToCasefold := IdentityDictionary new.	ToUpper := IdentityDictionary new.	ToLower := IdentityDictionary new.	UIManager default informUserDuring: [:bar|		| stream |		bar value: 'Downloading Unicode data'.		stream := HTTPClient httpGet: 'http://www.unicode.org/Public/UNIDATA/CaseFolding.txt'.		(stream isKindOf: RWBinaryOrTextStream) ifFalse:[^self error: 'Download failed'].		stream reset.		bar value: 'Updating Case Mappings'.		self parseCaseMappingFrom: stream.	].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:49'!parseCaseMappingFrom: stream	"Parse the Unicode casing mappings from the given stream.	Handle only the simple mappings"	"		Unicode initializeCaseMappings.	"	ToCasefold := IdentityDictionary new: 2048.	ToUpper := IdentityDictionary new: 2048.	ToLower := IdentityDictionary new: 2048.	[stream atEnd] whileFalse:[		| fields line srcCode dstCode |		line := stream nextLine copyUpTo: $#.		fields := line withBlanksTrimmed findTokens: $;.		(fields size > 2 and: [#('C' 'S') includes: (fields at: 2) withBlanksTrimmed]) ifTrue:[			srcCode := Integer readFrom: (fields at: 1) withBlanksTrimmed base: 16.			dstCode := Integer readFrom: (fields at: 3) withBlanksTrimmed base: 16.			ToCasefold at: srcCode put: dstCode.		].	].	ToCasefold keysAndValuesDo:		[:k :v |		(self isUppercase: (self value: k))			ifTrue:				["In most cases, uppercase letter are folded to lower case"				ToUpper at: v put: k.				ToLower at: k put: v].		(self isLowercase: (self value: k))			ifTrue:				["In a few cases, two lower case letters are folded to the same lower case.				We must find an upper case letter folded to the same letter"				| up |				up := ToCasefold keys detect: [:e | (self isUppercase: (self value: e)) and: [(ToCasefold at: e) = v]] ifNone: [nil].				up ifNotNil: [ToUpper at: k put: up]]].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:00'!toCasefold: aWideString	"Transform a Wide String into fold case.	This is to enable case insensitive conversion."		^aWideString collect: [:e |		(ToCasefold at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:11'!toLowercase: aWideString	"Transform a Wide String into lowercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToLower at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:08'!toUppercase: aWideString	"Transform a Wide String into uppercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToUpper at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:up | self value: up]]! !!UnixFileDirectory methodsFor: 'file names' stamp: 'eem 6/2/2010 09:38'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName |	fName := super checkName: aFileName fixErrors: fixing.	(fName includes: self class pathNameDelimiter) ifFalse:		[^fName].	^fixing		ifTrue: [fName copyReplaceAll: (String with: self class pathNameDelimiter) with: '#']		ifFalse: [self error:'Invalid file name']! !!Utilities class methodsFor: 'common requests' stamp: 'nice 6/11/2010 21:55'!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].		strings := CommonRequestStrings contents.	normalItemCount := strings asString lineCount.	aMenu := UIManager default 		chooseFrom: (strings asString lines copyWith: 'edit this menu')		lines: (Array with: normalItemCount).	index := aMenu startUp.	index == 0 ifTrue: [^ self].	reply := aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result := self evaluate: reply in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'fetching updates' stamp: 'nice 6/11/2010 21:30'!parseListContents: listContents	| sections vers strm line fileNames |	"Parse the contents of updates.list into {{vers. {fileNames*}}*}, and return it."	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	vers := nil.	strm := ReadStream on: listContents.	[strm atEnd] whileFalse:		[line := strm nextLine.		line size > 0 ifTrue:			[line first = $#				ifTrue: [vers ifNotNil: [sections addLast: {vers. fileNames asArray}].						"Start a new section"						vers := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	vers ifNotNil: [sections addLast: {vers. fileNames asArray}].	^ sections asArray" TEST: | list |list := Utilities parseListContents: (FileStream oldFileNamed: 'updates.list') contentsOfEntireFile.list = (Utilities parseListContents: (String streamContents: [:s | Utilities writeList: list toStream: s]))	ifFalse: [self error: 'test failed']	ifTrue: [self inform: 'test OK']"! !!Utilities class methodsFor: 'fetching updates' stamp: 'ar 5/7/2010 20:50'!updateFromServer	"Update the image by loading all pending updates from the server."	| config |	"Flush all caches. If a previous download failed this is often helpful"	MCFileBasedRepository flushAllCaches.	config := MCMcmUpdater updateFromDefaultRepository.	config ifNil: [^self inform: 'Unable to retrieve updates from remote repository.' translated].	self setSystemVersionFromConfig: config.	self inform: ('Update completed.Current update number: ' translated, SystemVersion current highestUpdate).! !!Utilities class methodsFor: 'miscellaneous' stamp: 'nice 6/11/2010 21:30'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict := Dictionary new.	report := ReadWriteStream on: ''.	f := FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f := FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className := items first.			newInstCount := items third asNumber.			newSpace := items fourth asNumber.			oldPair := instCountDict at: className ifAbsent: [nil].			oldInstCount := oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace := oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'support windows' stamp: 'spd 5/24/2010 20:23'!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 10000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.Preferences editAnnotations.Flaps reinstateDefaultFlaps. Preferences resetCategoryInfo(FileStream oldFileNamed: 'Lives of the Wolves') edit.(FileStream oldFileNamed: 'tuesdayFixes.cs') fileInChangeList browseFile: 'myChanges.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode in mvc""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspect.Utilities storeTextWindowContentsToFileNamed: 'TextWindows'Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'ScriptingSystem resetStandardPartsBin.ScheduledControllers screenController openMorphicConstructionWorld.ScheduledControllers screenController openMorphicWorld.SystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[SystemNavigation default allCallsOn: #asOop].MessageTally spyOn: [SystemNavigation default allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52'!emitCodeForLoad: stack encoder: encoder	"Do nothing"! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41'!emitCodeForReturn: stack encoder: encoder	encoder		if: code		isSpecialLiteralForReturn:			[:specialLiteral|			"short returns"			 encoder genReturnSpecialLiteral: specialLiteral.			 stack push: 1 "doesnt seem right".			 ^self].	(self code = LdSelf or: [self code = LdSuper]) ifTrue: 		["short returns"		 encoder genReturnReceiver.		 stack push: 1 "doesnt seem right".		 ^self].	super emitCodeForReturn: stack encoder: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08'!emitCodeForStore: stack encoder: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41'!emitCodeForStorePop: stack encoder: encoder	self type ~= 1 ifTrue:		[self halt].	encoder genStorePopInstVar: index.	stack pop: 1! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07'!emitCodeForValue: stack encoder: encoder	stack push: 1.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder genPushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder genPushReceiver].	code = LdThisContext ifTrue:		[^encoder genPushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder genPushInstVar: index! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:58'!sizeCodeForReturn: encoder	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizeReturnSpecialLiteral: specialLiteral].	(self code = LdSelf or: [self code = LdSuper]) ifTrue:		[^encoder sizeReturnReceiver].	^super sizeCodeForReturn: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStore: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09'!sizeCodeForStorePop: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:54'!sizeCodeForValue: encoder	self reserve: encoder.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral| "i.e. the pseudo-variables nil true & false"			 ^encoder sizePushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder sizePushReceiver].	code = LdThisContext ifTrue:		[^encoder sizePushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder sizePushInstVar: index! !!VariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^false! !!VariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34'!accept: aVisitor	^aVisitor visitVariableNode: self! !!VariableScopeFinder methodsFor: 'private' stamp: 'eem 8/12/2010 16:50'!enclosingNodeFor: enumerator of: rootNode	"Answer the minimum enclosing root node for aVariabe or nil if none.	 If the variable is accessed in more than one subnode then the rootNode is the	 enclosing node, otherwise it is which ever single subnode node that includes it, if any.	 enumerator applies its argument to all relevant subnodes of rootNode."	| enclosingNodeOrNil |	enclosingNodeOrNil := nil.	enumerator value:		[:subnode|		(subnode accept: self) ifNotNil:			[:enclosingNode|			enclosingNodeOrNil := enclosingNodeOrNil										ifNil: [enclosingNode]										ifNotNil: [rootNode]]].	^enclosingNodeOrNil! !!VariableScopeFinder methodsFor: 'initialize-release' stamp: 'eem 8/12/2010 16:18'!ofVariable: aVariableNode	theVariable := aVariableNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:51'!visitAssignmentNode: anAssignmentNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then anAssignmentNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock								value: anAssignmentNode value;								value: anAssignmentNode variable]		of: anAssignmentNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBlockNode: aBlockNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one statement then aBlockNode is the	 enclosing node, otherwise it is which ever single block node that includes it, if any."	^(self enclosingNodeFor: [:aBlock| aBlockNode statements do: aBlock] of: aBlockNode) ifNotNil:		[:aNode|		aNode isBlockNode ifTrue: [aNode] ifFalse: [aBlockNode]]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBraceNode: aBraceNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aBraceNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock| aBraceNode elements do: aBlock]		of: aBraceNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/16/2010 18:02'!visitCascadeNode: aCascadeNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aCascadeNode receiver.							aCascadeNode messages do:								[:msg| msg argumentsInEvaluationOrder do: aBlock]]		of: aCascadeNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitCommentNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitFieldNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:55'!visitFutureNode: aFutureNode	^aFutureNode receiver accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitInstanceVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitLiteralNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:03'!visitLiteralVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:07'!visitMessageNode: aMessageNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aMessageNode receiver.							aMessageNode argumentsInEvaluationOrder do: aBlock]		of: aMessageNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:00'!visitMethodNode: aMethodNode	^aMethodNode block accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitNewArrayNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitRemoteTempVectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:01'!visitReturnNode: aReturnNode	^aReturnNode expr accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitSelectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitTempVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode	^theVariable name = aVariableNode name ifTrue: [theVariable]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:06'!visitVariableNode: aVariableNode	^nil! !!VariableScopeFinder commentStamp: 'eem 8/14/2010 19:45' prior: 0!A VariableScopeFinder is used to find the minimum enclosing scope of a variable in a method.  This is used when auto-declaring temporaries to find the smallest enclosing block in which to declare the temp.Instance Variables	theVariable:		<VariableNode>theVariable	- the varable whose scope is to be determined!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 6/12/2010 18:38'!finalizeValues	"Remove and finalize all elements which have nil key"		|  cleanUpAfterRemove |	tally = 0 ifTrue: [ ^self ].	cleanUpAfterRemove := false.	1 to: array size do: [ :index |		(array at: index) 			ifNil: [ cleanUpAfterRemove := false ]			ifNotNil: [ :element |				element key					ifNil: [						finalizer ifNotNil: [ finalizer value: element value ].						array at: index put: nil.						tally := tally - 1.						cleanUpAfterRemove := true ]					ifNotNil: [ :key |						cleanUpAfterRemove ifTrue: [							| newIndex |							(newIndex := self scanFor: key) = index ifFalse: [								array 									at: newIndex put: element;									at: index put: nil ] ] ] ] ].	cleanUpAfterRemove ifTrue: [ "Continue rehashing at the front of array"		self fixCollisionsFrom: array size ]					! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!WeakRegistry methodsFor: 'finalization' stamp: 'ul 6/15/2010 11:17'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."		| collectedExecutors |	self protected: [ 		valueDictionary finalizeValues.		collectedExecutors := executors.		executors := nil ].	collectedExecutors ifNotNil: [		collectedExecutors do: #finalize ]! !!WeakRegistry methodsFor: 'initialize' stamp: 'ul 6/15/2010 11:17'!installFinalizer	valueDictionary finalizer: [ :executor |		(executors ifNil: [ executors := OrderedCollection new ]) add: executor ]! !!WeakRegistry methodsFor: 'copying' stamp: 'ul 6/15/2010 11:21'!postCopy	self protected: [ "Uses the original accessLock"		accessLock := Semaphore forMutualExclusion.		valueDictionary := valueDictionary copy.		valueDictionary associationsDo: [ :each |			each value class == ObjectFinalizerCollection 				ifTrue: [ each value: each value copy ] ].		executors := executors copy.		self installFinalizer ]! !!WeakRegistry commentStamp: '<historical>' prior: 0!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakSet methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!Workspace methodsFor: 'accessing' stamp: 'fbs 4/28/2010 21:48'!contents: textOrString	super contents: textOrString.	self changed: #contents.! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:16'!bindingOf: aString 	mustDeclareVariables ifTrue: [^ nil].	"I want to have workspace that force the user to declare  	variables. Still subclasses may want to do something else"	bindings ifNil: [self initializeBindings].	(bindings includesKey: aString) ifFalse: [		| val |		val := self lookupInPools: aString.		val 			ifNotNil: [				"Caveat: since we're not inserting the pool's Association into				 the dictionary, assigning a new value to the variable will only				 affect the one Workspace (i.e. you can't assign to a variable in a				 SharedPool)."				bindings at: aString put: val]			ifNil: [aString first isUppercase					ifTrue: [^nil]					ifFalse: [bindings at: aString put: nil]]	].	^ bindings associationAt: aString! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:00'!lookupInPools: aString 	"Iterate through all of the lookup pools to find a match for the specified name."	LookupPools ifNil: [^nil].	LookupPools do: [:pool | (pool bindingOf: aString) ifNotNil: [:assoc | ^assoc value]].	^nil! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 4/21/2010 21:23'!shouldStyle: aBool	"If true, contents will by rendered w/ syntax-highlighting"	shouldStyle := aBool! !!Workspace commentStamp: 'ls 10/14/2003 12:13' prior: 0!A Workspace is a text area plus a lot of support for executable code.  It is a great place to execute top-level commands to compute something useful, and it is a great place to develop bits of a program before those bits get put into class methods.To open a new workspace, execute:	Workspace openA workspace can have its own variables, called "workspace variables", to hold intermediate results.  For example, if you type into a workspace "x := 5" and do-it, then later you could type in "y := x * 2" and y would become 10.Additionally, in Morphic, a workspace can gain access to morphs that are on the screen.  If acceptDroppedMorphss is turned on, then whenever a morph is dropped on the workspace, a variable will be created which references that morph.  This functionality is toggled with the window-wide menu of a workspace.The instance variables of this class are:	bindings  -  holds the workspace variables for this workspace	acceptDroppedMorphss - whether dropped morphs should create new variables!!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!addLookupPool: sharedPool	"Add a SharedPool that bindings should be looked up in."	LookupPools ifNil: [LookupPools := IdentitySet new].	LookupPools add: sharedPool! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 11:08'!clearLookupPools	LookupPools := nil.! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!removeLookupPool: sharedPool	"Workspaces should no longer look up bindings in the specified SharedPool."	LookupPools ifNil: [^self].	LookupPools remove: sharedPool ifAbsent: [].! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 19:51'!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode handsToDraw allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	canvas roundCornersOf: aWorld during:[ | handDamageRects worldDamageRects |		worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage := worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish: allDamage.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 16:04'!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	remoteServer ifNotNil:[		self assuredCanvas.		^true].	properDisplay := canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	].	^ true! !!XBMReadWriter methodsFor: 'private' stamp: 'nk 7/16/2003 18:17'!readHeader	"Set width and height, and position stream at start of bytes"	| number setwidth setheight fieldName |	setwidth := setheight := false.		[((stream atEnd) or: [setwidth and: [setheight]])]		whileFalse: [	  	self skipCComments.		(stream nextMatchAll: '#define ') ifFalse: [^ false].		(stream skipTo: $_) ifFalse: [^ false].		fieldName := String streamContents:			[:source |			[(stream atEnd) or: [ stream peek isSeparator ]]				whileFalse: [ source nextPut: stream next]].	  	(fieldName = 'width') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setwidth _true].	  		width := number.].		(fieldName = 'height') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setheight := true].			height := number.			].		].	(setwidth & setheight) ifFalse: [^ false].	^ stream skipTo: ${! !!XMLParserTest methodsFor: 'tests' stamp: 'ar 8/10/2010 13:25'!testPrintElements	| node |	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo/>'.	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123"/>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo>Hello World</foo>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123">Hello World</foo>'.! !!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 4/14/2010 19:50'!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection byteAt: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 10:38'!lastModTime	"Return my last modification date/time stamp,	converted to Squeak seconds"	^self dosToSqueakTime: lastModFileDateTime! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 11:08'!setLastModFileDateTimeFrom: aSmalltalkTime	lastModFileDateTime := self squeakToDosTime: aSmalltalkTime! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 10:39'!dosToSqueakTime: dt	"DOS years start at 1980, so add 1980."	| year mon mday hour min sec date time |	year := (( dt bitShift: -25 ) bitAnd: 16r7F ).	mon := (( dt bitShift: -21 ) bitAnd: 16r0F ).	mday := (( dt bitShift: -16 ) bitAnd: 16r1F ).	date := Date newDay: mday month: mon year: year+1980.	hour := (( dt bitShift: -11 ) bitAnd: 16r1F ).	min := (( dt bitShift: -5 ) bitAnd: 16r3F ).	sec := (( dt bitShift: 1 ) bitAnd: 16r3E ).	time := ((( hour * 60 ) + min ) * 60 ) + sec.	^date asSeconds + time	! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 11:00'!squeakToDosTime: secs	| dosTime dateTime |	dateTime := Time dateAndTimeFromSeconds: secs.	dosTime := (dateTime second seconds) bitShift: -1.	dosTime := dosTime + ((dateTime second minutes) bitShift: 5).	dosTime := dosTime + ((dateTime second hours) bitShift: 11).	dosTime := dosTime + ((dateTime first dayOfMonth) bitShift: 16).	dosTime := dosTime + ((dateTime first monthIndex) bitShift: 21).	dosTime := dosTime + (((dateTime first year) - 1980) bitShift: 25).	^dosTime! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 8/10/2010 13:15'!writeDataTo: aStream	"Copy my (possibly inflated or deflated) data to the given stream.	This might do compression, decompression, or straight copying, depending	on the values of compressionMethod and desiredCompressionMethod"	"Note: Do not shortcut this method if uncompressedSize = 0. Even in this case	data may be produced by the compressor (i.e., '' zipped size > 0) and must	be stored in the file or else other utilities will treat the zip file as corrupt."	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])		ifTrue: [ ^self compressDataTo: aStream ].	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])		ifTrue: [ ^self uncompressDataTo: aStream ].	self copyDataTo: aStream.! !!ZipArchiveTests methodsFor: 'tests' stamp: 'ar 8/11/2010 20:45'!testDate29Feb2000	"Ensure that dates with leap years don't screw up in the conversion"	| archive mbr theDate |	theDate := Date year: 2000 month: 2 day: 29.	archive := ZipArchive new.	mbr := archive addDeflateString:'foo' as: 'bar'.	mbr setLastModFileDateTimeFrom: theDate asSeconds.	self shouldnt:[mbr lastModTime] raise: Error.	self assert: (Date fromSeconds: mbr lastModTime) = theDate.! !Smalltalk condenseChanges!----QUIT----{23 August 2010 . 10:37:44 am} SqueakCore4.2-10382-alpha.image priorSource: 489495!