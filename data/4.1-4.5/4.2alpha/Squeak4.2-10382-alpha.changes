'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 17 April 2010 at 5:22:05 pm'!----STARTUP----{17 April 2010 . 5:21:54 pm} as C:\Squeak\4.0\4.1-final\Squeak4.1.image!Smalltalk appendChangesTo: 'SqueakV41.sources'.!----QUIT----{17 April 2010 . 5:22:11 pm} Squeak4.1.image priorSource: 89!----STARTUP----{24 May 2010 . 8:07:26 pm} as C:\Squeak\4.2\Squeak4.1.image!----SNAPSHOT----{24 May 2010 . 8:08:14 pm} Squeak4.2.image priorSource: 229!!HashedCollection commentStamp: 'ul 4/12/2010 22:37' prior: 0!I am an abstract collection of objects that implement hash and equality in a consitent way. This means that whenever two objects are equal, their hashes have to be equal too. If two objects are equal then I can only store one of them. Hashes are expected to be integers (preferably SmallIntegers). I also expect that the objects contained by me do not change their hashes. If that happens, hash invariants have to be re-established, which can be done by #rehash.Since I'm abstract, no instances of me should exist. My subclasses should implement #scanFor:, #fixCollisionsFrom: and #noCheckNoGrowFillFrom:.Instance Variables	array:		<ArrayedCollection> (typically Array or WeakArray)	tally:		<Integer> (non-negative)array	- An array whose size is a prime number, it's non-nil elements are the elements of the collection, and whose nil elements are empty slots. There is always at least one nil. In fact I try to keep my "load" at 75% or less so that hashing will work well.tally	- The number of elements in the collection. The array size is always greater than this.Implementation details:I implement a hash table which uses open addressing with linear probing as the method of collision resolution. Searching for an element or a free slot for an element is done by #scanFor: which should return the index of the slot in array corresponding to it's argument. When an element is removed #fixCollisionsFrom: should rehash all elements in array between the original index of the removed element, wrapping around after the last slot until reaching an empty slot. My maximum load factor (75%) is hardcoded in #atNewIndex:put:, so it can only be changed by overriding that method. When my load factor reaches this limit I replace my array with a larger one (see #grow) ensuring that my load factor will be less than or equal to 50%. The new array is filled by #noCheckNoGrowFillFrom: which should use #scanForEmptySlotFor: instead of #scanFor: for better performance. I do not shrink.!!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!Collection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:33' prior: 18816249!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAll	"HashedCollection compactAll"				self allSubclassesDo: #compactAllInstances! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAllInstances	"Do not use #allInstancesDo: because compact may create new instances."	self allInstances do: #compact! !!HashedCollection class methodsFor: 'sizing' stamp: 'ul 4/7/2010 00:17' prior: 55063414!goodPrimes	"Answer a sorted array of prime numbers less than one billion that make good	hash table sizes. Should be expanded as needed.  See comments below code"		^#(		5 11 17 23 31 43 59 79 107 149 199 269 359 479 641 857 1151 1549 2069		2237 2423 2617 2797 2999 3167 3359 3539 3727 3911		4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853		8783 9601 10243 10867 11549 12239 12919 13679 14293 15013 15731		17569 19051 20443 21767 23159 24611 25847 27397 28571 30047 31397		35771 38201 40841 43973 46633 48989 51631 54371 57349 60139 62969		70589 76091 80347 85843 90697 95791 101051 106261 111143 115777 120691 126311		140863 150523 160969 170557 181243 190717 201653 211891 221251 232591 242873 251443		282089 300869 321949 341227 362353 383681 401411 422927 443231 464951 482033 504011		562621 605779 647659 681607 723623 763307 808261 844709 886163 926623 967229 1014617		1121987 1201469 1268789 1345651 1429531 1492177 1577839 1651547 1722601 1800377 1878623 1942141 2028401		2242727 2399581 2559173 2686813 2836357 3005579 3144971 3283993 3460133 3582923 3757093 3903769 4061261		4455361 4783837 5068529 5418079 5680243 6000023 6292981 6611497 6884641 7211599 7514189 7798313 8077189		9031853 9612721 10226107 10745291 11338417 11939203 12567671 13212697 13816333 14337529 14938571 15595673 16147291		17851577 18993941 20180239 21228533 22375079 23450491 24635579 25683871 26850101 27921689 29090911 30153841 31292507 32467307		35817611 37983761 40234253 42457253 44750177 46957969 49175831 51442639 53726417 55954637 58126987 60365939 62666977 64826669		71582779 76039231 80534381 84995153 89500331 93956777 98470819 102879613 107400389 111856841 116365721 120819287 125246581 129732203		143163379 152076289 161031319 169981667 179000669 187913573 196826447 205826729 214748357 223713691 232679021 241591901 250504801 259470131		285162679 301939921 318717121 335494331 352271573 369148753 385926017 402603193 419480419 436157621 453034849 469712051 486589307 503366497 520043707 		570475349 603929813 637584271 671138659 704693081 738247541 771801929 805356457 838910803 872365267 905919671 939574117 973128521 1006682977 1040137411 		1073741833)"The above primes past 2069 were chosen carefully so that they do not interact badly with 1664525 (used by hashMultiply), and so that gcd(p, (256^k) +/- a) = 1, for 0<a<=32 and 0<k<=8.  See Knuth's TAOCP for details.""The above primes also try to map the values of ((0 to: 4095) collect: [ :each | each << 18 \\ prime ]) sort to an equidistant sequence of numbers. This helps to avoid the collision of chains in identity-based hashed collections. To do that  they were chosen to return a low value when the following block is evaluated with them as argument: [ :prime |	| slots cost optimalDistance previous |	slots := Array new: 4097.	0 to: 4095 do: [ :ea | slots at: ea + 1 put: ea *  262144 \\ prime ].	slots at: 4097 put: prime.	slots sort.	cost := 0.	optimalDistance := prime // 4096.	2 to: 4097 do: [ :index |		| newCost |		newCost := optimalDistance - ((slots at: index) - (slots at: index - 1)).		newCost > cost ifTrue: [ cost := newCost ] ].	cost ]."! !!HashedCollection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:38' prior: 53647096!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."		anInteger < 1 ifTrue: [ ^newObject ].	^self add: newObject "I can only store an object once."	! !!HashedCollection methodsFor: 'private' stamp: 'ul 4/12/2010 22:53'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: tally * 4 // 3.	self growTo: newCapacity! !!WeakSet methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 4/13/2010 00:00' prior: 30357901!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols with 25% free space."	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable capacity.	SymbolTable compact.	^(oldSize - SymbolTable capacity) printString, ' slot(s) reclaimed'! !KeyedIdentitySet class removeSelector: #goodPrimes!WeakIdentityKeyDictionary class removeSelector: #goodPrimes!IdentitySet class removeSelector: #goodPrimes!IdentityDictionary class removeSelector: #goodPrimes!"Collections"!!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 4/7/2010 00:18' prior: 58761579!testPrimes: primes	| badPrimes |	badPrimes := #(3 5 71 139 479 5861 277421). "These primes are less than the hashMultiply constant (1664525) and 1664525 \\ prime is close to 0 (mod prime). The following snippet reproduces these numbers: 	| hashMultiplyConstant |	hashMultiplyConstant := 1 hashMultiply.	(Integer primesUpTo: hashMultiplyConstant) select: [ :each |		| remainder |		remainder := hashMultiplyConstant \\ each.		remainder <= 1 or: [ remainder + 1 = each ] ]."	self assert: primes isSorted.	primes do: [ :each |		self assert: each isPrime.		self deny: (each > 2069 and: [ badPrimes includes: each ]) ].	self assert: (		primes select: [ :p |			| result |			result := false.			p > 2069 ifTrue: [			1 to: 8 do: [ :k |				1 to: 32 do: [ :a |					(p gcd: (256 raisedTo: k) + a) = 1 ifFalse: [						result := true ].					(p gcd: (256 raisedTo: k) - a) = 1 ifFalse: [						result := true ] ] ] ].			result ]) isEmpty.! !HashedCollectionTest removeSelector: #testGoodPrimesForIdentityBasedHashedCollections!"CollectionsTests"!!MCMczReader methodsFor: 'as yet unclassified' stamp: 'bf 4/18/2010 18:38' prior: 22938947!extractInfoFrom: dict	^MCWorkingCopy infoFromDictionary: dict cache: self infoCache! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'bf 4/19/2010 00:39' prior: 23215403!infoFromDictionary: aDictionary cache: cache	| id |	id := (aDictionary at: #id) asString.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name ifAbsent: [''])			id: (UUID fromString: id)			message: (aDictionary at: #message ifAbsent: [''])			date: ([Date fromString: (aDictionary at: #date)] ifError: [nil])			time: ([Time fromString: (aDictionary at: #time)] ifError: [nil])			author: (aDictionary at: #author ifAbsent: [''])			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors ifAbsent: []) cache: cache)			stepChildren: (self ancestorsFromArray: (aDictionary at: #stepChildren ifAbsent: []) cache: cache)]! !!MCVersionInfo methodsFor: 'converting' stamp: 'bf 4/18/2010 23:25' prior: 23175569!asDictionary	^ Dictionary new		at: #name put: name;		at: #id put: id asString;		at: #message put: message;		at: #date put: date;		at: #time put: time;		at: #author put: author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !"Monticello"!!BlockContextTest methodsFor: 'running' stamp: 'md 9/6/2005 19:56' prior: 50431957!setUp	super setUp.	aBlockContext := [100@100 corner: 200@200].	contextOfaBlockContext := thisContext.! !!BehaviorTest methodsFor: 'tests' stamp: 'md 2/18/2006 16:42' prior: 17365994!testBinding	self assert: Object binding value = Object.	self assert: Object binding key = #Object.		self assert: Object class binding value = Object class.		"returns nil for Metaclasses... like Encoder>>#associationFor:"		self assert: Object class binding key = nil.! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13' prior: 53956757!testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #EmbeddedSourceQCompress ).	self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).	code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer sourceCode: code.	self assert: (trailer kind == #EmbeddedSourceZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13' prior: 53957691!testEmbeddingTempNames	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer tempNames: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #TempsNamesQCompress ).	self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).		code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer tempNames: code.	self assert: (trailer kind == #TempsNamesZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:17' prior: 53958613!testEncodingNoTrailer	| trailer |		trailer := CompiledMethodTrailer new.		"by default it should be a no-trailer"		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:14' prior: 53959109!testEncodingSourcePointer	| trailer |		trailer := CompiledMethodTrailer new.		CompiledMethod allInstancesDo: [:method | | ptr |		trailer method: method.		self assert: ( (ptr := method sourcePointer) == trailer sourcePointer).		"the last bytecode index must be at 0"		ptr ~= 0 ifTrue: [			self assert: (method endPC = trailer endPC) ].	 ].! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15' prior: 53959564!testEncodingVarLengthSourcePointer	| trailer newTrailer |		trailer := CompiledMethodTrailer new.		trailer sourcePointer: 1.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourcePointer = 1).		trailer sourcePointer: 16r100000000000000.	newTrailer := trailer testEncoding.	self assert: (newTrailer sourcePointer = 16r100000000000000).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15' prior: 53960108!testSourceByIdentifierEncoding	| trailer id |		trailer := CompiledMethodTrailer new.		id := UUID new asString.	trailer sourceIdentifier: id.		self assert: (trailer kind == #SourceByStringIdentifier ).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceByStringIdentifier ).	self assert: (trailer sourceIdentifier = id).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:49' prior: 53960643!testSourceBySelectorEncoding	| trailer |		trailer := CompiledMethodTrailer new.		trailer setSourceBySelector.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CategorizerTest methodsFor: 'running' stamp: 'mtf 9/10/2007 10:10' prior: 18074036!setUp	categorizer := Categorizer defaultList: #(a b c d e).	categorizer classifyAll: #(a b c) under: 'abc'.	categorizer addCategory: 'unreal'.! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17' prior: 18074267!testClassifyNewElementNewCategory	categorizer classify: #f under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')(''nice'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:18' prior: 18074541!testClassifyNewElementOldCategory	categorizer classify: #f under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17' prior: 18074806!testClassifyOldElementNewCategory	categorizer classify: #e under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'')(''nice'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:54' prior: 18075078!testClassifyOldElementOldCategory	categorizer classify: #e under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:22' prior: 18075341!testDefaultCategoryIsTransient	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	categorizer classifyAll: #(d e) under: #abc.	self assert: categorizer printString ='(''abc'' a b c d e)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 15:15' prior: 18075669!testNullCategory	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	| aCategorizer |	aCategorizer := Categorizer defaultList: #().	self assert: aCategorizer printString ='(''as yet unclassified'')'.	self assert: aCategorizer categories = #('no messages').	aCategorizer classify: #a under: #b.	self assert: aCategorizer printString ='(''b'' a)'.	self assert: aCategorizer categories = #(b).! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57' prior: 18076194!testRemoveEmptyCategory	categorizer removeCategory: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:55' prior: 18076430!testRemoveExistingElement	categorizer removeElement: #a.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59' prior: 18076673!testRemoveNonEmptyCategory	self should: [categorizer removeCategory: #abc] raise: Error.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59' prior: 18076950!testRemoveNonExistingCategory	categorizer removeCategory: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57' prior: 18077203!testRemoveNonExistingElement	categorizer removeElement: #f.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 14:49' prior: 18077451!testRemoveThenRename	categorizer removeCategory: #unreal.	categorizer renameCategory: #abc toBe: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''unreal'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:14' prior: 18077736!testUnchanged	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !"KernelTests"!!SmalltalkImage methodsFor: 'accessing' stamp: 'ul 4/18/2010 22:22'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	^globals at: key ifPresentAndInMemory: aBlock! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:45'!image	"Answer the object to query about the current object memory and execution environment."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:47'!imageFormatVersion	"Answer an integer identifying the type of image. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required). This invokes an optional primitive	that may not be available on all virtual machines."	"Smalltalk image imageFormatVersion"	<primitive: 'primitiveImageFormatVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:38'!interpreterSourceVersion	"Answer a string corresponding to the version of the interpreter source.	This represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator, as distinct	from the external platform source code, typically written in C and managed	separately for each platform. An optional primitive is invoked that may not	be available on all virtual machines."	"Smalltalk vm interpreterSourceVersion"	<primitive: 'primitiveInterpreterSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveInterpreterSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!platformSourceVersion	"Answer a string corresponding to the version of the external platform source	code, typically written in C and managed separately for each platform. This	invokes an optional primitive that may not be available on all virtual machines."	"Smalltalk vm platformSourceVersion"	<primitive: 'primitivePlatformSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitivePlatformSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'image' stamp: 'md 5/16/2006 12:34' prior: 58536670!version	"Answer the version of this release."	^SystemVersion current version! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!versionLabel	"Answer a string corresponding to the version of virtual machine. This	represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator,  in	addition to the external platform source code, typically written in C and	managed separately for each platform.		This invokes an optional primitive that may not be available on all virtual	machines. See also vmVersion, which answers a string identifying the image	from which virtual machine sources were generated."	"Smalltalk vm versionLabel"	<primitive: 'primitiveVMVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveVMVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:15'!vm	"Answer the object to query about virtual machine."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 1/4/2010 21:40' prior: 58537225!wordSize	"Answer the size in bytes of an object pointer or word in the object memory.	The value does not change for a given image, but may be modified by a SystemTracer	when converting the image to another format. The value is cached in WordSize to	avoid the performance overhead of repeatedly consulting the VM."	"Smalltalk wordSize"	^ WordSize ifNil: [WordSize := [SmalltalkImage current vmParameterAt: 40] on: Error do: [4]]! !"System"!!SMLoaderPlus commentStamp: 'btr 12/1/2006 15:16' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance). It uses ToolBuilder to construct its window. You can open one with:	SMLoaderPlus openInstance Variables	categoriesToFilterIds:		<OrderedCollection> The set of categories to filter the packages list.	filters:				<OrderedCollection> The set of filters to apply to the packages list.	map:				<SMSqueakMap> The model SqueakMap.	packagesList:		<OrderedCollection> The list of packages from the map.	selectedCategory:	<SMCategory> The current category.	selectedItem:			<SMPackage> The selected package or release.	window:			<PluggableSystemWindow> The window, held only so we can reOpen.!!SMLoaderCategoricalPlus commentStamp: 'btr 12/4/2006 15:47' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategoricalPlus open!!SMLoader commentStamp: 'btr 11/30/2006 18:00' prior: 27913009!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance).You can open one with:	SMLoader open!!SMLoaderCategorical commentStamp: 'btr 12/1/2006 15:16' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategorical open!!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifPresent: [:tb |		(TheWorldMenu respondsTo: #registerOpenCommand:)			ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:50'!buildFancyWith: aBuilder	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildNotInstalledPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ (horizDivide / 2)); yourself);				add: ((self buildInstalledPackagesListWith: builder)					frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	self setUpdatablePanesFrom: #(#installedPackageList #notInstalledPackageList ).	currentPackageList := #notInstalled.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:56'!buildInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #installedPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:52'!buildNotInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #notInstalledPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:55'!buildWith: aBuilder	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)));				add: ((self buildPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide));				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1)); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList	^currentPackageList! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:55'!defaultLabel	^ 'Categorical ' , super defaultLabel! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:52'!installedPackageList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!installedPackagesListIndex	^ self currentPackageList = #installed		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!isOn	^false! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:53'!notInstalledPackageList	^self packageList reject: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!notInstalledPackagesListIndex	^ self currentPackageList = #notInstalled		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:03'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategoricalPlus methodsFor: 'private' stamp: 'btr 12/1/2006 17:53'!noteChanged	self changed: #installedPackageList.	self changed: #notInstalledPackageList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:34'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderPlus class methodsFor: 'parts bin' stamp: 'btr 11/22/2006 15:02'!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47'!initialize	"Hook us up in the world menu."		"self initialize"	Smalltalk at: #ToolBuilder ifPresent: [:tb |		self registerInFlapsRegistry.		(Preferences windowColorFor: #SMLoader) = Color white "not set"			ifTrue: [ Preferences setWindowColorFor: #SMLoader to: (Color colorFrom: self windowColorSpecification brightColor) ].		 (TheWorldMenu respondsTo: #registerOpenCommand:)	         ifTrue: [| oldCmds |				oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].				oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].			TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!initializedInstance	^ (ToolBuilder open: self new) extent: 400@400! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!newStandAlone	^ ToolBuilder open: self new! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:13'!open	"Create and open a SqueakMap Loader."		"SMLoaderPlus open"	^ (Smalltalk at: #ToolBuilder) open: self new! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:21'!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^ (Smalltalk at: #ToolBuilder) open: (self newOn: aSqueakMap)! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:18'!prototypicalToolWindow	^ ToolBuilder open: self new; applyModelExtent; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:02'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoaderPlus class methodsFor: 'window color' stamp: 'btr 11/22/2006 15:02'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 16:11'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := map isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(map directory directoryEntryFor: map lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:43'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease				ifNil: [^ nil].	dir := item isPackage				ifTrue: [map cache directoryForPackage: item]				ifFalse: [map cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir.	"withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildButtonBarWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self commandSpecs select: [ :spec | spec fourth includes: #all]				thenCollect: [ :spec |					aBuilder pluggableActionButtonSpec new						model: self;						label: spec first;						action: spec second;						help: spec third;						enabled: ((spec fourth includes: #item) ifTrue: [#hasSelectedItem]);						yourself]);		name: #buttonBar;		yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildCategoriesListWith: aBuilder 	"Create the hierarchical list holding the category tree."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #categoryList;		 getSelectedPath: #selectedCategoryPath;		 getChildren: #categoryChildren:;		 hasChildren: #categoryHasChildren:;		 setSelected: #selectedCategory:;		 menu: #categoriesMenu:;		 label: #categoryLabel:;		 autoDeselect: true;		 wantsDrop: true;		 name: #categoriesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagePaneWith: aBuilder	"Create the text area to the right in the loader."	^ aBuilder pluggableTextSpec new model: self; getText: #itemDescription; name: #packagePane; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagesListWith: aBuilder 	"Create the hierarchical list holding the packages and releases."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #packageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 name: #packagesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildSearchPaneWith: aBuilder	^ aBuilder pluggableInputFieldSpec new model: self;		selection: #searchSelection;		getText: #searchText; setText: #findPackage:notifying:; name: #search; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:54'!buildWith: aBuilder 	"Create the package loader window."	| buttonBarHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	vertDivide := 0.6.	horizDivide := 0.3.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;					 label: #label;					 children: (OrderedCollection new						add: ((self buildButtonBarWith: builder)							frame: (0 @ 0 corner: 1 @ buttonBarHeight));						add: ((self buildSearchPaneWith: builder)							frame: (0 @ buttonBarHeight corner: horizDivide @ (buttonBarHeight * 2)));						add: ((self buildPackagesListWith: builder)							frame: (0 @ (buttonBarHeight * 2) corner: horizDivide @ vertDivide));						add: ((self buildCategoriesListWith: builder)							frame: (0 @ vertDivide corner: horizDivide @ 1));						add: ((self buildPackagePaneWith: builder)								frame: (horizDivide @ buttonBarHeight corner: 1 @ 1));						 yourself);					 yourself).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[UIManager default informUser: 'Caching ' , release asString during: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!categoryChildren: aCategory	^ aCategory subCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!categoryHasChildren: aCategory	^ aCategory hasSubCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:46'!categoryLabel: aCategory	^ aCategory name! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryList	"Create the category list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (map categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/22/2006 15:02'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:01'!commandSpecFor: selector	^ self commandSpecs detect: [:spec | spec second = selector]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:00'!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (conf8irming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!defaultLabel	^ 'SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[UIManager default informUser: 'Downloading ' , release asString during: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterAutoInstall	^[:package | package isInstallable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterAvailable	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterInstalled	^[:package | package isInstalled]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterNotUptoDate	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterPublished	^[:package | package isPublished]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterSafelyAvailable	^[:package | package isSafelyAvailable]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/30/2006 21:07'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically') #('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.') #('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.') #('Installed packages' #filterInstalled 'Display only packages that are installed.') #('Published packages' #filterPublished 'Display only packages that have at least one published release.') ) asOrderedCollection.	categoriesToFilterIds		do: [:catId | specs add: {'Packages in ' , (map object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filters	^filters! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/24/2006 13:49'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or	description. "	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty		ifTrue: [^ self].	descriptions := self packageList collect: [:e | e description].	index + 1		to: list size		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	"wrap around"	1		to: index		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 18:36'!hasSelectedItem	^ self selectedPackageOrRelease notNil! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by versions: (installed -> latest).If there is no arrow, your installed version of the package is the latest.Bold packages and releases have been installed.The checkbox menu items modify which packages you''ll see.Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.Comment on a package by emailing the author or the squeak list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/2726' asUrl]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 05:28'!initialExtent	^500@400! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:53'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease installer |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	installer := SMInstaller forPackageRelease: aRelease.	[UIManager default informUser: 'Downloading ' , aRelease asString during:		[installer download].	UIManager default informUser: 'Installing ' , aRelease asString during: [		installer install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!itemChildren: anItem 	^ anItem isPackage		ifTrue: [anItem releases]		ifFalse: [#()]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 19:56'!itemDescription	^ self selectedPackageOrRelease		ifNil: ['<No package selected>']		ifNotNilDo: [:item | item fullDescription]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!itemHasChildren: anItem 	^ anItem isPackage and: [anItem releases notEmpty]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!itemLabel: anItem 	| label |	label := anItem isPackage				ifTrue: [anItem name						, (anItem versionLabel								ifEmpty: ['']								ifNotEmptyDo: [:lbl | ' (' , anItem versionLabel , ')'])]				ifFalse: [anItem smartVersion].	^ anItem isInstalled		ifTrue: [label asText allBold]		ifFalse: [label]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/24/2006 17:17'!label	^ self		labelForShown: (packagesList				ifNil: [self packageList])! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!labelForShown: packagesShown	"Update the label of the window."	^ self defaultLabel , ' (',		(packagesShown size < map packages size ifTrue: [packagesShown size printString,		' shown out of '] ifFalse: ['']) , map packages size printString, ' packages)'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:31'!loadUpdates	[UIManager default informUser: 'Loading Updates' during: [		map loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/24/2006 14:05'!noteChanged	filters		ifNil: [^ self reOpen].	map		ifNotNil: [packagesList := nil.			selectedCategory := nil.			self changed: #categoryList.			self changed: #packageList.			self changed: #packagesListIndex.			"update my selection"			self contentsChanged]! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'btr 11/22/2006 16:11'!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list |	list := packagesList ifNil: [packagesList := self packageListCalculated].	selectedCategory ifNotNil: [		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageListCalculated	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	^ self packages select: [:p |		filters allSatisfy: [:currFilter |			currFilter isSymbol				ifTrue: [(self perform: currFilter) value: p]				ifFalse: [self package: p filteredByCategory: (map object: currFilter)]]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!packageNameList	^ self packageList collect: [:e | e name]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:30'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: (self commandSpecFor: #installPackageRelease)].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: (self commandSpecFor: #browseCacheDirectory)].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: (self commandSpecFor: #cachePackageReleaseAndOfferToCopy).		choices add: (self commandSpecFor: #downloadPackageRelease)].	choices add: (self commandSpecFor: #emailPackageMaintainers).	^ choices! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 16:11'!packages	"We request the packages as sorted by name by default."	^map packagesByName asArray! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex	^ self packageList indexOf: self selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex: anObject 	self		selectedItem: (anObject = 0				ifFalse: [self packageList at: anObject])! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:45'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	^ (self respondsTo: selector)		ifTrue: [self perform: selector]		ifFalse: [super perform: selector orSendTo: otherTarget]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	window delete.	(Smalltalk at: self class name) open! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchSelection	"Selects all of the default search text so that a type-in overwrites it."	^ {1. self searchText size}! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchText	"A dummy default search text so that the field describes its purpose."	^ 'Search packages'! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedCategory	"Return selected category."	^ selectedCategory! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:37'!selectedCategory: anSMCategory 	"Change the selected category."	selectedCategory := anSMCategory.	selectedCategory		ifNotNil: [(selectedCategory objects includes: self selectedItem)			ifFalse: [self selectedItem: nil]].	self changed: #selectedCategory.	self changed: #packageList! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:52'!selectedCategoryPath	"Return selected category's path."	| path |	path := #().	selectedCategory		ifNotNil: [selectedCategory parent				ifNotNilDo: [:p | path := path copyWith: p].			path := path copyWith: selectedCategory].	^ path		collect: [:cat | self categoryLabel: cat]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedItem	^ selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:27'!selectedItem: anItem	"This == workaround protects us from recursion since ToolBuilder's tree widgets will always tell us that the selection has been updated when we tell it that the selection path has been updated. Cleaner solutions invited."	anItem == selectedItem ifFalse: [		selectedItem := anItem.		self changed: #selectedItemPath.		self changed: #itemDescription.		self changed: #hasSelectedItem]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:16'!selectedItemPath	| path |	path := #().	(selectedItem isKindOf: SMPackageRelease)		ifTrue: [path := path copyWith: selectedItem package].	selectedItem		ifNotNil: [path := path copyWith: selectedItem].	^ path! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:03'!selectedPackageOrRelease	"Return selected package or package release."	^ selectedItem! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!updateLabel: packagesShown	"Update the label of the window."	window ifNotNilDo: [:w | w setLabel: (self labelForShown: packagesShown)]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during: [				map upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackagesConfirm: confirmEach 	"Tries to upgrade all installed packages to the latest published release for	this version of Squeak. If confirmEach is true we ask for every	upgrade. "	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty		ifTrue: [^ self inform: 'All ' , installed size printString , ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty		ifTrue: [^ self inform: 'None of the ' , old size printString , ' old packages of the ' , installed size printString , ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size		ifTrue: ['Of the ' , old size printString , ' old packages only ' , toUpgrade size printString , ' can be upgraded.The following packages will not be upgraded:'						, (String								streamContents: [:s | (old removeAll: toUpgrade;										 yourself)										do: [:p | s nextPutAll: p nameWithVersionLabel;												 cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info , 'About to upgrade the following packages:'				, (String						streamContents: [:s | toUpgrade								do: [:p | s nextPutAll: p nameWithVersionLabel;										 cr]]) , 'Proceed?')		ifTrue: [myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during:					[confirmEach						ifTrue: [map								upgradeOldPackagesConfirmBlock: [:p | self confirm: 'Upgrade ' , p installedRelease packageNameWithVersion , ' to ' , (p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName , '?']]						ifFalse: [map upgradeOldPackages].					self inform: toUpgrade size printString , ' packages successfully processed.'.					myRelease = self installedReleaseOfMe						ifTrue: [self noteChanged]						ifFalse: [self reOpen]]]				on: Error				do: [:ex | self informException: ex msg: ('Error occurred when upgrading old packages:\' , ex messageText , '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMPackageWrapper methodsFor: 'comparing' stamp: 'dvf 9/21/2003 16:25' prior: 27998626!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMPackageWrapper methodsFor: 'converting' stamp: 'btr 11/22/2006 00:54' prior: 27998778!asString	| string |	string := item name, ' (', item versionLabel, ')'.	item isInstalled ifTrue: [string := string asText allBold].	"(string includesSubString: '->') ifTrue: [string := string asText color: Color green]."	^ string! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'dvf 10/14/2003 18:58' prior: 27998902!contents	^item releases reversed collect: [:e | SMPackageReleaseWrapper with: e]! !!SMPackageWrapper methodsFor: 'testing' stamp: 'dvf 9/21/2003 16:25' prior: 27999070!hash	^self withoutListWrapper hash! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:55'!help	^ 'This shows all packages with their releases that should be displayed according the current filter.'! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString! !!SMPackageWrapper methodsFor: 'printing' stamp: 'dvf 9/21/2003 16:22' prior: 27999192!printOn: aStream	aStream nextPutAll: 'wrapper for: ', item printString! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 27849043!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMCategoryWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 18:53' prior: 27849195!asString	^ item name , ' (' , self numberOfObjects printString , ')'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:35' prior: 27849301!category	^item! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 21:02' prior: 27849402!contents	^ item subCategories		collect: [:n | self class with: n model: n]! !!SMCategoryWrapper methodsFor: 'model access' stamp: 'btr 11/30/2006 21:02'!getList	^ Array		with: (self class with: self contents model: model)! !!SMCategoryWrapper methodsFor: 'testing' stamp: 'btr 11/30/2006 18:53'!hasContents	^ item hasSubCategories! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 27849700!hash	^self withoutListWrapper hash! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:56'!help	^ 'The categories are structured in a tree. Packages and package releases belong to several categories. You can add one or more categories as filters and enable them in the menu.'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'BJP 11/22/2002 14:17'!model	^model! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:53'!numberOfObjects"	| total |	total _ 0.	model allCategoriesDo: [:c |		total _ total + c objects size].	^total"	^item objects size! !!SMPackageReleaseWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 21:30' prior: 27997393!asString	"Show installed releases with a trailing asterisk."	| string |	string := item smartVersion.	"Older SMBase versions don't have isInstalled.'"	(item respondsTo: #isInstalled) ifTrue:		[item isInstalled ifTrue: [string := (string , ' *') asText allBold]].	^ string! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 17:14'!contents	^ #()! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString	! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47' prior: 27944626!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifAbsent: [self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white				ifTrue: ["not set"					Preferences						setWindowColorFor: #SMLoader						to: (Color colorFrom: self windowColorSpecification brightColor)].			(TheWorldMenu respondsTo: #registerOpenCommand:)				ifTrue: [| oldCmds |					oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].					oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].					TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52' prior: 27945298!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:08' prior: 54331069!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:15' prior: 27927912!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease ifNil: [^ nil].	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:52'!buildButtonBar	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	self buttonSpecs do: [:spec |		btn := self buildButtonNamed: spec first helpText: spec third action: spec second.		aRow addMorphBack: btn]		separatedBy: [aRow addTransparentSpacerOfSize: 3@0].	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:27'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 19:04' prior: 27928394!buildMorphicCategoriesList	"Create the hierarchical list holding the category tree."	| list |	list := (SimpleHierarchicalListMorph				on: self				list: #categoryWrapperList				selected: #selectedCategoryWrapper				changeSelected: #selectedCategoryWrapper:				menu: #categoriesMenu:				keystroke: nil) autoDeselect: true;				 enableDrag: false;				 enableDrop: true;				 yourself.	list setBalloonText: 'The categories are structured in a tree. Packages and package releases belong to several categories.You can add one or more categories as filters and enable them in the menu.'.	"list scroller submorphs do:[:each| list expandAll: each]."	list adjustSubmorphPositions.	^ list! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:22' prior: 27929139!buildMorphicPackagesList	"Create the hierarchical list holding the packages and releases."	^(SimpleHierarchicalListMorph 		on: self		list: #packageWrapperList		selected: #selectedItemWrapper		changeSelected: #selectedItemWrapper:		menu: #packagesMenu:		keystroke: nil)		autoDeselect: false;		enableDrag: false;		enableDrop: true;		setBalloonText: 'This shows all packages with their releases that should be displayed according the current filter.';		yourself! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:13'!buildPackageButtonBar	| aRow |	"Somewhat patterned after IRCe's buttonRow method."	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'gk 5/5/2006 02:05' prior: 27929686!buildPackagePane	"Create the text area to the right in the loader."	| ptm |	ptm := PluggableTextMorph 		on: self 		text: #contents		accept: nil		readSelection: nil "#packageSelection "		menu: nil.	ptm setBalloonText: 'This is where the selected package or package release is displayed.'.	ptm lock.	^ptm! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:08' prior: 27930070!buildSearchPane	"Cribbed from MessageNames>>inMorphicWindowWithInitialSearchString:"	| typeInView searchButton typeInPane |	typeInView := PluggableTextMorph				on: self				text: nil				accept: #findPackage:notifying:				readSelection: nil				menu: nil.	typeInView acceptOnCR: true;		 vResizing: #spaceFill;		 hResizing: #spaceFill;		 setTextMorphToSelectAllOnMouseEnter;		 askBeforeDiscardingEdits: false;		 setProperty: #alwaysAccept toValue: true.	(typeInView respondsTo: #hideScrollBarsIndefinitely)		ifTrue: [typeInView hideScrollBarsIndefinitely]		ifFalse: [typeInView hideScrollBarIndefinitely].	searchButton := SimpleButtonMorph new target: typeInView;				 color: Color white;				 label: 'Search';				 actionSelector: #accept;				 arguments: #(); yourself.	typeInPane := AlignmentMorph newRow.	typeInPane vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 listDirection: #leftToRight;		 addMorphFront: searchButton;		 addTransparentSpacerOfSize: 6 @ 0;		 addMorphBack: typeInView;		 setBalloonText: 'Type into the pane, then press Search (or hit RETURN) to visit the next package matching what you typed.'.	^ typeInPane! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:24'!buttonSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.')		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.')		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.')		('Update' loadUpdates 'Update the package index from the servers.')		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).')		('Help' help 'What is this?'))! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:11' prior: 27936393!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01' prior: 27933585!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (model categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list		collect: [:cat | SMCategoryWrapper with: cat model: self]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 27913226!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 17:30' prior: 27930584!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.3.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0.0 @ 0.0 corner: 1.0 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0.0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (0.0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0.0 @ horizDivide corner: vertDivide @ 1.0).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1.0 @ 1.0).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self! !!SMLoader methodsFor: 'interface' stamp: 'gk 7/12/2004 11:14' prior: 27931214!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:01'!defaultLabel	^'SqueakMap Package Loader'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:14' prior: 27917579!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoader methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 00:14' prior: 27923782!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('Installed packages' #filterInstalled 'Display only packages that are installed.')	#('Published packages' #filterPublished 'Display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'Packages in ', (model object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 19:27' prior: 27918212!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or description."	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty ifTrue: [^self].	descriptions := self packageWrapperList collect: [:e | e withoutListWrapper description].	index + 1 to: list size		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	"wrap around"	1 to: index		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:05' prior: 27937041!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:48' prior: 27931447!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://minnow.cc.gatech.edu/squeak/2726' asUrl]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:13' prior: 27918874!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoader methodsFor: 'actions' stamp: 'mist 8/17/2005 13:56'!installPackageWithDependents: package	| myRelease |	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		package installWithDependencies.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'initialization' stamp: 'gk 4/5/2005 21:17' prior: 27932588!openAsMorph	"Open the loader as a Morphic window."	"SMLoader new openAsMorph"		^self createWindow openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45' prior: 27934165!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				(filters ifNil: [#()]) allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNotNil:		[selectedCategory := selectedCategoryWrapper category.		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/22/2006 14:30' prior: 27937451!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: self buttonSpecs first].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: self buttonSpecs third].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: #('Copy from cache' #cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' ).		choices add: #('Force download into cache' #downloadPackageRelease 'Force a download of the selected release into the cache.' )].	choices add: self buttonSpecs second.	^ choices! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:56' prior: 27913703!packagesListIndex: anObject 	self		selectedItemWrapper: (anObject ifNotNil: [anObject = 0				ifFalse: [self packageWrapperList at: anObject]])! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/5/2005 21:43' prior: 27932888!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/26/2006 23:22' prior: 27941030!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	self delete.	(Smalltalk at: self class name) open! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 19:17' prior: 27913904!selectedCategory	"Return selected category."	^selectedCategoryWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'accessing' stamp: 'btr 12/1/2006 15:51' prior: 27914233!selectedCategoryWrapper: aWrapper	selectedCategoryWrapper := aWrapper.	(aWrapper notNil and:		[aWrapper withoutListWrapper objects includes: selectedItemWrapper withoutListWrapper])		ifFalse: [self selectedItemWrapper: nil].	self changed: #selectedCategoryWrapper.	self changed: #packageWrapperList.! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/22/2006 19:13' prior: 27914590!selectedItemWrapper: aWrapper	selectedItemWrapper := aWrapper.	self changed: #selectedItemWrapper.	self contentsChanged! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:10' prior: 27941340!selectedPackageOrRelease	"Return selected package or package release."	^self selectedItemWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:02' prior: 27935346!updateLabel: packagesShown	"Update the label of the window."	self setLabel: self defaultLabel , ' (',			(packagesShown size < model packages size ifTrue: [packagesShown size printString,			' shown out of '] ifFalse: ['']) , model packages size printString, ' packages)'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 21:03' prior: 27921197!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:03' prior: 27941568!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifAbsent: [	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #installedPackageNameList		selected: #installedPackagesListIndex		changeSelected: #installedPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicNotInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #notInstalledPackageNameList		selected: #notInstalledPackagesListIndex		changeSelected: #notInstalledPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createFancyWindow	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicNotInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (horizDivide / 2)).	self addMorph: (self buildMorphicInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setUpdatablePanesFrom: #(#installedPackageNameList #notInstalledPackageNameList ).	currentPackageList := #notInstalled.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 17:27'!currentPackageList	^currentPackageList! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'btr 11/30/2006 17:44'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!defaultLabel	^ 'SqueakMap Categorical Package Loader'! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!installedPackageNameList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!installedPackagesListIndex	self currentPackageList = #installed		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 15:09'!isOn	^false! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!notInstalledPackageNameList	^self packageList select: [:e | e isInstalled not]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!notInstalledPackagesListIndex	self currentPackageList = #notInstalled		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategorical methodsFor: 'private' stamp: 'btr 11/30/2006 20:21'!noteChanged	self changed: #installedPackageNameList.	self changed: #notInstalledPackageNameList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !SMLoader removeSelector: #paneColorOld!SMLoader removeSelector: #addPackagesTo:at:plus:!"SMLoader"!!HashedCollectionIntegrityTest methodsFor: 'as yet unclassified' stamp: 'ul 4/13/2010 00:19'!testCapacity	| inconsistentCollections |	inconsistentCollections := HashedCollection allSubInstances reject: [ :each |		each class == MethodDictionary "MethodDictionary is the only HashedCollection which doesn't have prime array size"			ifTrue: [ each capacity isPowerOfTwo ]			ifFalse: [ each capacity isPrime ] ].	self assert: inconsistentCollections isEmpty! !"Tests"!HashedCollection class removeSelector: #goodPrimesForIdentityBasedHashedCollections!"Collections"!!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 4/14/2010 19:50' prior: 33397485!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection byteAt: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !"Compression"!!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'hmm 4/16/2010 22:07' prior: 23076302!allClassNames	^ (items 		select: [:ea | (ea isOrganizationDefinition | ea isScriptDefinition) not] 		thenCollect: [:ea | ea className]) asSet.! !"Monticello"!!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:48' prior: 58240485!compactAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #compactWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:49' prior: 55067225!rehashAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #rehashWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:04'!compact	"Make sure that I have the highest possible load factor (at least 50%)."		self become: self compactWithoutBecome! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:05'!compactWithoutBecome	"Return a copy of self which has the highest possible load factor (at least 50%)."		| newSelf |	newSelf := self class new: self size.	self keysAndValuesDo: [ :key :value |		newSelf at: key put: value ].	^newSelf! !!Duration class methodsFor: 'squeak protocol' stamp: 'ul 4/28/2010 09:44' prior: 59189810!milliSeconds: milliCount 		^self		seconds: (milliCount quo: 1000)		nanoSeconds: (milliCount rem: 1000) * NanosInMillisecond! !!StringHolder class methodsFor: 'instance creation' stamp: 'fbs 4/28/2010 18:53' prior: 54905196!open	^ (Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!CompiledMethod methodsFor: 'decompiling' stamp: 'hmm 4/16/2010 10:48' prior: 50758861!methodNode	"Return the parse tree that represents self. If parsing fails, decompile the method."	| aClass source |	aClass := self methodClass.	source := self				getSourceFor: (self selector ifNil: [self defaultSelector])				in: aClass.	^[(aClass parserClass new		encoderClass: (self isBlueBookCompiled						ifTrue: [EncoderForV3]						ifFalse: [EncoderForV3PlusClosures]);		parse: source class: aClass)			sourceText: source;			yourself]		on: SyntaxErrorNotification		do: [:ex | ex return: self decompile].! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:48' prior: 53338498!absPrintExactlyOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version guarantees that the printed representation exactly represents my value	by using exact integer arithmetic."	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significand := self significandAsInteger.	roundingIncludesLimits := significand even.	exp := (self exponent - 52) max: MinValLogBase2.	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[significand ~= 16r10000000000000				ifTrue:					[r := significand bitShift: 1 + exp.					s := 2.					mPlus := mMinus := 1 bitShift: exp]				ifFalse:					[r := significand bitShift: 2 + exp.					s := 4.					mPlus := 2 * (mMinus := 1 bitShift: exp)]]		ifFalse:			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])				ifTrue:					[r := significand bitShift: 1.					s := 1 bitShift: 1 - exp.					mPlus := mMinus := 1]				ifFalse:					[r := significand bitShift: 2.					s := 1 bitShift: 2 - exp.					mPlus := 2.					mMinus := 1]].	baseExpEstimate >= 0		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]		ifFalse:			[scale := base raisedToInteger: baseExpEstimate negated.			r := r * scale.			mPlus := mPlus * scale.			mMinus := mMinus * scale].	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[r := r * base.			mPlus := mPlus * base.			mMinus := mMinus * base].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	slowbit := 1 - s lowBit .	shead := s bitShift: slowbit.	[d := (r bitShift: slowbit) // shead.	r := r - (d * s).	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * base.		mPlus := mPlus * base.		mMinus := mMinus * base.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:32' prior: 51138013!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s * (fBase raisedToInteger: baseExpEstimate - 1).					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]				ifFalse:					[s := s * (fBase raisedToInteger: baseExpEstimate)]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 4/28/2010 12:29' prior: 54648421!compress	"Compact the method dictionary of the receiver."	self methodDict compact! !MethodDictionary removeSelector: #compactCopyFrom:!"Kernel"!!OptimizedBlockLocalTempReadBeforeWrittenVisitor commentStamp: '<historical>' prior: 0!Answer the set of temporary variables that are read before they are written in the visited parse tree.  Used by the compiler to detect those block-local temporaries of blocks in optimized loops that require nilling to prevent a value from a previous iteration persisting into a subsequent one.!!BlockNode commentStamp: '<historical>' prior: 59231160!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'initialize-release' stamp: 'eem 9/5/2009 21:03'!initialize	inOptimizedBlock := false! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'accessing' stamp: 'eem 9/8/2008 14:30'!readBeforeWritten	^readBeforeWritten ifNil: [IdentitySet new]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:28'!visitAssignmentNode: anAssignmentNode	anAssignmentNode value accept: self.	anAssignmentNode variable isTemp		ifTrue:			[written ifNil: [written := IdentitySet new].			 written add: anAssignmentNode variable]		ifFalse:			[anAssignmentNode variable accept: self]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:09'!visitBlockNode: aBlockNode	| savedWritten |	"If we're in the optimized block in one side of an optimized ifTrue:ifFalse: et al	 leave it to the enclosing visitMessageNode: activation to handle merging written."	inOptimizedBlock ifTrue:		[^super visitBlockNode: aBlockNode].	"If we're not then don't update written because without evaluating the guard(s)	 we can't tell if the block is evaluated or not, and we must avoid false positives."	savedWritten := written copy.	super visitBlockNode: aBlockNode.	written := savedWritten! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:03'!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector key]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/8/2008 14:43'!visitTempVariableNode: aTempVariableNode	(aTempVariableNode isArg	 or: [written notNil		and: [written includes: aTempVariableNode]]) ifTrue:		[^self].	readBeforeWritten ifNil:		[readBeforeWritten := IdentitySet new].	readBeforeWritten add: aTempVariableNode! !!LiteralNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51562187!accept: aVisitor	^aVisitor visitLiteralNode: self! !!SelectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52462316!accept: aVisitor	^aVisitor visitSelectorNode: self! !!VariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 53106854!accept: aVisitor	^aVisitor visitVariableNode: self! !!InstanceVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51430081!accept: aVisitor	^aVisitor visitInstanceVariableNode: self! !!FieldNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51111193!accept: aVisitor	^aVisitor visitFieldNode: self! !!AssignmentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 33548097!accept: aVisitor	^aVisitor visitAssignmentNode: self! !!RemoteTempVectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52334181!accept: aVisitor	^aVisitor visitRemoteTempVectorNode: self! !!LiteralVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51566588!accept: aVisitor	^aVisitor visitLiteralVariableNode: self! !!NewArrayNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51916378!accept: aVisitor	^aVisitor visitNewArrayNode: self! !!CommentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50736685!accept: aVisitor	^aVisitor visitCommentNode: self! !!CascadeNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50569061!accept: aVisitor	^aVisitor visitCascadeNode: self! !!BlockNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50443783!accept: aVisitor	^aVisitor visitBlockNode: self! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 19:23' prior: 50444587!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	| effectiveScope blockStart |	effectiveScope := optimized						ifTrue: [actualScopeIfOptimized := scopeBlock]						ifFalse: [self].	arguments ifNotNil:		[arguments do: [:temp| temp definingScope: self]].	temporaries ifNotNil:		[temporaries do: [:temp| temp definingScope: self]].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockEntry:			[:entryNumber|			 blockExtent := (blockStart := entryNumber) to: 0]].	"Need to enumerate a copy because closure analysis can add a statement	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."	statements copy do:		[:statement|		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].	optimized		ifTrue: "if optimized loop need to add nils for any temps read before written"			[optimizedMessageNode isOptimizedLoop ifTrue:				[self nilReadBeforeWrittenTemps]]		ifFalse: "if optimized this isn't an actual scope"			[rootNode noteBlockExit:				[:exitNumber|				 blockExtent := blockStart to: exitNumber]].	"Now that the analysis is done move any temps that need to be moved."	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.	"This is simply a nicety for compiler developers..."	temporaries do:		[:temp|		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:			[temp name: temp definingScope remoteTempNodeName]]! !!BlockNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:05' prior: 17572883!emitForEvaluatedValue: stack on: aStream	self emitExceptLast: stack on: aStream.	statements last emitForBlockValue: stack on: aStream.! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:36'!nilReadBeforeWrittenTemps	| visitor readBeforeWritten |	self accept: (visitor := OptimizedBlockLocalTempReadBeforeWrittenVisitor new).	readBeforeWritten := visitor readBeforeWritten.	temporaries reverseDo:		[:temp|		((readBeforeWritten includes: temp)		 and: [temp isRemote not]) ifTrue:			[statements addFirst: (AssignmentNode new variable: temp value: NodeNil)]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:30'!noteOptimizedIn: anOptimizedMessageNode	optimized := true.	optimizedMessageNode := anOptimizedMessageNode! !!BlockNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:04' prior: 17574191!sizeForEvaluatedValue: encoder	^(self sizeExceptLast: encoder)		+ (statements last sizeForBlockValue: encoder)! !!ParseNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 52065009!accept: aVisitor	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.	 All such implementations under ParseNode should answer the result of the dispatch, e.g.		^aVisitor visitBlockNode: self"	^self subclassResponsibility! !!ParseNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 17:57'!emitForBlockValue: stack on: aStream	"Generate code for evaluating the last statement in a block"	^self emitForValue: stack on: aStream! !!ParseNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 17:56'!sizeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeForValue: encoder! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51659869!accept: aVisitor	^aVisitor visitMessageNode: self! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:33' prior: 51636522!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:32' prior: 51668475!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifTrue:		[((caseNode blockAssociationCheck: encoder)		  and: [arguments size = 1			    or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder]]) ifFalse:			[^false].		 caseNode elements do:			[:messageNode|			messageNode receiver noteOptimizedIn: self.			messageNode arguments first noteOptimizedIn: self].		 arguments size = 2 ifTrue:			[arguments last noteOptimizedIn: self].		 ^true].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not]) ifTrue:		[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51637527!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51658193!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51642266!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18' prior: 51676424!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51679950!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51630388!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51678537!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18' prior: 51632638!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:31' prior: 51669258!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment := encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit := arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:17' prior: 51635034!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).		 receiver noteOptimizedIn: self.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimizedIn: self.			arguments first noteOptimizedIn: self.			true]! !!ReturnNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 52349447!accept: aVisitor	^aVisitor visitReturnNode: self! !!MethodNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51730971!accept: aVisitor	^aVisitor visitMethodNode: self! !!BraceNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50521748!accept: aVisitor	^aVisitor visitBraceNode: self! !!TempVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52840973!accept: aVisitor	^aVisitor visitTempVariableNode: self! !!Encoder methodsFor: 'encoding' stamp: 'eem 9/3/2009 10:50' prior: 50998649!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode := self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [^action value]].	range ifNotNil: [		name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !BlockNode removeSelector: #noteOptimized!"Compiler"!!StandardViewer methodsFor: 'initialization' stamp: 'ar 4/23/2010 16:53' prior: 29917444!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	"Initialize the receiver to be a look inside the given Player.  The categoryInfo, if present, describes which categories should be present in it, in which order"	scriptedPlayer := aPlayer.	self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1.	self color: self standardViewerColor.	self addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean.	categoryInfo isEmptyOrNil		ifFalse:  "Reincarnating an pre-existing list"			[categoryInfo do:				[:aCat | self addCategoryViewerFor: aCat]]		ifTrue:  "starting fresh"			[self addSearchPane. 			self addCategoryViewer.			self addCategoryViewer.			(scriptedPlayer isPlayerLike and: [scriptedPlayer costume isMemberOf: KedamaMorph]) ifTrue: [self addCategoryViewer].		].! !"EToys"!!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:13' prior: 57366653!upTo: delimiter	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOf: delimiter startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:14' prior: 53809967!upToAnyOf: delimiters do: aBlock	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					| result |					result := collection copyFrom: position + 1 to: (position := pos) - 1 .					aBlock value: (collection at: position).					^result ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOfAnyOf: delimiters startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue.		bytesRead = 0 ifFalse: [			aBlock value: (buffer at: pos) ] ]! !"Files"!!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ul 4/28/2010 11:22' prior: 52007447!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| base bits |	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This Smalltalk version might be easier to understand than the others below."	base := y * form width * bitsPerChannel // 32 + 1.	bits := form bits.	0 to: thisScanline size - 1 // 4 do: [ :i |		| ii word |		ii := i * 4.		"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 		is to make use of faster arithmetic bytecodes, but not of slow largeintegers."		word :=			(((thisScanline at: ii + 1) * 256 + 			(thisScanline at: ii + 2) * 256 + 			(thisScanline at: ii + 3)) bitShift: 8) bitOr: 			(thisScanline at: ii + 4).		bits at: base + i put: word ].			"This interesting technique (By Andreas Raab) is faster for very large images, but might be slower for small ones"	"^self copyPixelsGrayWeirdBitBltHack: y ".	"It uses the following method:	PNGReadWriter >> copyPixelsGrayWeirdBitBltHack: y 	""Handle non-interlaced black and white color mode (colorType = 0)	By Andreas Raab""		| source dest cmap |	source := Form extent: 1 @ (thisScanline size // 4) depth: 32 bits: thisScanline.	dest := Form extent: 1 @ (form bits size) depth: 32 bits: form bits.	cmap := Smalltalk isLittleEndian		ifTrue:[ColorMap 					shifts: #(-24 -8 8 24) 					masks: #(16rFF000000 16r00FF0000 16r0000FF00 16r000000FF)].	(BitBlt toForm: dest)		sourceForm: source;		destX: 0 destY: (y * form width*bitsPerChannel//32) width: 1 height: (form width+31*bitsPerChannel//32);		colorMap: cmap;		combinationRule: 3;		copyBits."			"This interesting technique  (By Yoshiki Ohshima) is faster for very large images, but might be slower for small ones"	"form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32)".	"It uses the following method:	BitMap >> copyFromByteArray2: byteArray to: i	""This method should work with either byte orderings""	| myHack byteHack |	myHack := Form new hackBits: self.	byteHack := Form new hackBits: byteArray.	Smalltalk  isLittleEndian ifTrue: [byteHack swapEndianness].	byteHack displayOn: myHack at:  0@i"! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'jmv 4/15/2010 10:19' prior: 52000090!grayColorsFor: d	"return a color table for a gray image"	palette := Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^  palette		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 85.0 / 255.0).		palette at: 3 put: (Color gray: 170.0 / 255.0).		palette at: 4 put: Color white.		^ palette		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jmv 4/15/2010 10:18' prior: 52016987!processTransparencyChunk	| red green blue |	"Transcript show: '  TRANSPARENCY ',chunk printString."	colorType = 0 ifTrue: [		transparentPixelValue := chunk unsignedShortAt: 1 bigEndian: true.		palette at: transparentPixelValue put: Color transparent.		^self	].	colorType = 2 ifTrue: [		red := chunk at: 2.		green := chunk at: 2.		blue := chunk at: 2.		transparentPixelValue := 16rFF00 + red << 8 + green << 8 + blue.		^self	].	colorType = 3 ifTrue: [		chunk withIndexDo: [ :alpha :index |			palette at: index put: ((palette at: index) alpha: alpha/255)		].		^self	].! !"Graphics"!!RectangleTest methodsFor: 'tests' stamp: 'wiz 4/29/2010 02:10'!testRoundingAfterHalfPixelTranslation	"A rectangle right on the cusp of rounding changes shape if origin and	corner are in differenct quadrants"	"self debug: #testRoundingAfterHalfPixelTranslation"	| trouble noTrouble |	trouble := 10 negated asPoint rect: 10 asPoint.	noTrouble := trouble translateBy: 15.		10 timesRepeat: [trouble := (trouble translateBy: 0.5) rounded].	10 timesRepeat: [noTrouble := (noTrouble translateBy: 0.5) rounded].		self assert: trouble extent = noTrouble extent! !"GraphicsTests"!!DurationTest methodsFor: 'testing' stamp: 'ul 4/28/2010 09:57' prior: 19913678!testMilliSeconds	#(		"argument (milliseconds)	seconds	nanoseconds"		(5							0			5000000)		(1005						1			5000000)		(-5							0			-5000000)		(-1005						-1			-5000000)		(1234567					1234		567000000)		(-1234567					-1234		-567000000)			) do: [ :each |		| duration |		duration := Duration milliSeconds: each first.		self assert: duration asSeconds = each second.		self assert: duration nanoSeconds = each third ]! !"KernelTests"!!ObjectFinalizer commentStamp: 'jcg 4/27/2010 01:01' prior: 0!Represents an action that is to be taken when a target object (not referenced by the ObjectFinalizer) is garbage-collected.!!CodeLoader commentStamp: 'hjh 4/22/2010 12:58' prior: 59244840!CodeLoader provides a simple facility for loading code from the network.CodeLoader has a very specific purpose, primarily for loading Etoys projects. It is not meant to be used for anything else. Use Installer for general purposes.Examples:	| loader |	loader := CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ul 4/28/2010 11:38'!keyAtValue: value	"Answer the key that is the external name for the argument, value. If	there is none, answer nil."	self deprecated: 'Use Smalltalk globals'.	^globals keyAtValue: value! !!ProjectLoading class methodsFor: 'loading' stamp: 'ul 4/28/2010 12:35' prior: 55884567!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to berepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList proj trusted localDir projStream archive mgrprojectsToBeDeleted baseChangeSet enterRestricted substituteFontnumberOfFontSubstitutes exceptions |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enterproject'.		"the hard part is over"		^self inform:'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,' translated	].	ProgressNotification signal: '2:fileSizeDetermined',preStream size printString.	preStream isZipArchive		ifTrue:[	archive := ZipArchive new readFrom: preStream.				projStream := selfprojectStreamFromArchive: archive]		ifFalse:[projStream := preStream].	trusted := SecurityManager default positionToSecureContentsOf:projStream.	trusted ifFalse:		[enterRestricted := (preStream isTypeHTTP or:[aFileName isNil])			ifTrue: [Preferences securityChecksEnabled]			ifFalse: [Preferences standaloneSecurityChecksEnabled].		enterRestricted			ifTrue: [SecurityManager default enterRestrictedMode				ifFalse:					[preStream close.					^ self]]].	localDir := Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) binary				nextPutAll: preStream contents;				close.		].	].	morphOrList := projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet := ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	substituteFont := Preferences standardEToysFont copy.	numberOfFontSubstitutes := 0.	exceptions := Set new.	[[morphOrList := morphOrList fileInObjectAndCodeForProject]		on: FontSubstitutionDuringLoading do: [ :ex |				exceptions add: ex.				numberOfFontSubstitutes :=numberOfFontSubstitutes + 1.				ex resume: substituteFont ]]			ensure: [ ChangeSet  newChanges: baseChangeSet].	mgr := ResourceManager new initializeFrom: ResourceCollector current.	mgr fixJISX0208Resource.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName:aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj := morphOrList arrayOfRoots			detect: [:mm | mm isKindOf: Project]			ifNone: [^self inform: 'No project found inthis file'].		proj projectParameters at: #substitutedFont put: (			numberOfFontSubstitutes > 0				ifTrue: [substituteFont]				ifFalse: [#none]).		proj projectParameters at: #MultiSymbolInWrongPlace put: false.			"Yoshiki did not put MultiSymbols intooutPointers in older images!!"		morphOrList arrayOfRoots do: [:obj |			obj fixUponLoad: proj seg: morphOrList "imageSegment"].		(proj projectParameters at: #MultiSymbolInWrongPlace) ifTrue: [			morphOrList arrayOfRoots do: [:obj | (objisKindOf: HashedCollection) ifTrue: [obj rehash]]].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		proj setParent: Project current.		projectsToBeDeleted := OrderedCollection new.		existingView ifNil: [			ChangeSet allChangeSets add: proj changeSet.			Project current openProject: proj.				"Note: in MVC we get no further than the above"		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSet allChangeSets add: proj changeSet.		Project current projectParameters			at: #deleteWhenEnteringNewProject			ifPresent: [ :ignored |				projectsToBeDeleted add: Project current.				Project current removeParameter:#deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters				at: #projectsToBeDeleted				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	Project current openViewAndEnter: morphOrList! !!Preferences class methodsFor: 'standard queries' stamp: 'sbw 4/24/2010 10:16' prior: 0!annotationPanes	^ self		valueOfFlag: #annotationPanes		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!browserWindowColor	^ self		valueOfFlag: #browserWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 0.6]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!changeListWindowColor	^ self		valueOfFlag: #changeListWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!changeSorterWindowColor	^ self		valueOfFlag: #changeSorterWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!classCommentVersionsBrowserWindowColor	^ self		valueOfFlag: #classCommentVersionsBrowserWindowColor		ifAbsent: [Color				r: 0.769				g: 0.653				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!debuggerWindowColor	^ self		valueOfFlag: #debuggerWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 0.8]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!defaultWindowColor	^ self		valueOfFlag: #defaultWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!dualChangeSorterWindowColor	^ self		valueOfFlag: #dualChangeSorterWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!fileContentsBrowserWindowColor	^ self		valueOfFlag: #fileContentsBrowserWindowColor		ifAbsent: [Color				r: 0.8				g: 0.8				b: 0.5]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!fileListWindowColor	^ self		valueOfFlag: #fileListWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 1.0]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22' prior: 59046404!installUniformWindowColors	"Install the factory-provided uniform window colors for all tools"	"Preferences installUniformWindowColors"	self installWindowColorsVia: [:aQuad | self uniformWindowColor]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!instanceBrowserWindowColor	^ self		valueOfFlag: #instanceBrowserWindowColor		ifAbsent: [Color				r: 0.806				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!lexiconWindowColor	^ self		valueOfFlag: #lexiconWindowColor		ifAbsent: [Color				r: 0.878				g: 1.0				b: 0.878]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!messageListWindowColor	^ self		valueOfFlag: #messageListWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!messageNamesWindowColor	^ self		valueOfFlag: #messageNamesWindowColor		ifAbsent: [Color				r: 0.645				g: 1.0				b: 0.452]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!methodFinderWindowColor	^ self		valueOfFlag: #methodFinderWindowColor		ifAbsent: [Color				r: 0.4				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!monticelloToolWindowColor	^ self		valueOfFlag: #monticelloToolWindowColor		ifAbsent: [Color				r: 0.627				g: 0.69				b: 0.976]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!packageBrowserWindowColor	^ self		valueOfFlag: #packageBrowserWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 0.6]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!packageLoaderWindowColor	^ self		valueOfFlag: #packageLoaderWindowColor		ifAbsent: [Color				r: 0.9				g: 0.9				b: 0.781]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!preferenceBrowserWindowColor	^ self		valueOfFlag: #preferenceBrowserWindowColor		ifAbsent: [Color				r: 0.645				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!testRunnerWindowColor	^ self		valueOfFlag: #testRunnerWindowColor		ifAbsent: [Color				r: 1.0				g: 0.6				b: 0.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!transcriptWindowColor	^ self		valueOfFlag: #transcriptWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 0.4]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22'!uniformWindowColor	^Color veryVeryLightGray! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!versionsBrowserWindowColor	^ self		valueOfFlag: #versionsBrowserWindowColor		ifAbsent: [Color				r: 0.869				g: 0.753				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!workspaceWindowColor	^ self		valueOfFlag: #workspaceWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 0.8]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:32' prior: 51385600!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	inSeg := true.	[object := object nextObject.  		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			object isBlock ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	hashedCollections do: #rehash. "our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:33' prior: 51365564!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.  Do this by discovering classes that need a startUp message sent to each instance, and sending it.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg noStartUpNeeded startUps cls msg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	noStartUpNeeded := IdentitySet new.	"classes that don't have a per-instance startUp message"	startUps := IdentityDictionary new.	"class -> MessageSend of a startUp message"	inSeg := true.	[object := object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class]].			inSeg ifTrue: [				(noStartUpNeeded includes: object class) ifFalse: [					cls := object class.					(msg := startUps at: cls ifAbsent: [nil]) ifNil: [						msg := cls startUpFrom: self.	"a Message, if we need to swap bytes this time"						msg ifNil: [noStartUpNeeded add: cls]							ifNotNil: [startUps at: cls put: msg]].					msg ifNotNil: [msg sentTo: object]]]]. 		object == 0] whileFalse.	hashedCollections do: #rehash.	"our purpose"	^ receiverClasses	"our secondary job"! !!SystemDictionary methodsFor: 'compatibility' stamp: 'ul 4/28/2010 11:45'!hasSpecialSelector: aLiteral ifTrueSetByte: aBlock	self deprecated: 'Use Smalltalk'.	^Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: aBlock! !"System"!!Editor commentStamp: '<historical>' prior: 59290227!New text editors.TextEditor provides most of the functionality that used to be in TextMorphEditor. This class is no longer a Controller!!SmalltalkEditor is has Smalltalk code specific features.SimpleEditor provides basic functionality for single line text editing. It does not handle fonts and styles, aligning and Smalltalk utilities. It handles one single line.CellStyleEditor allows entering alphabetic characters using only number keys, like most cell phones do.!!TheWorldMainDockingBar methodsFor: 'private' stamp: 'laza 4/26/2010 10:31' prior: 53724739!colorIcon: aColor	"Guess if 'uniform window colors' are used and avoid all icons to be just gray"	(aColor = Preferences uniformWindowColor or: [Preferences tinyDisplay]) ifTrue: [ ^nil ].	^(aColor iconOrThumbnailOfSize: 14)		borderWidth: 3 color: Preferences menuColor muchDarker;		borderWidth: 2 color: Color transparent! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 4/26/2010 12:23'!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''Morphic-Kernel'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."HelpSystem: http://www.squeaksource.com/HelpSystem.html"(Installer squeaksource project: ''HelpSystem'')	install: ''HelpSystem-Core'';	install: ''HelpSystem-Tests'';	install: ''Metacello-Help'';	install: ''Pharo-Project-Help'';	install: ''Squeak-Project-Help''.(Smalltalk at: #HelpBrowser) open."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WASqueakServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(194 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 57 12 12 1 8 1 12 3 8 1 17 3 8 1 18 3 8 1 16 3 8 1 20 3 8 1 21 13 3 1 12 2 4 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 29 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'mha 5/2/2010 16:00' prior: 59194233!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk at: #HelpBrowser) ifNotNil: [					menu addLine.					menu addItem: [ :item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: (Smalltalk at: #HelpBrowser);							selector: #open ] ].			]].! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 4/26/2010 10:57' prior: 58412388!listWindowsOn: menu	| windows |	windows := SortedCollection sortBlock: [:winA :winB |		winA model name = winB model name			ifTrue: [winA label < winB label]			ifFalse: [winA model name < winB model name]].	windows addAll: self allVisibleWindows.	windows ifEmpty: [ 		menu addItem: [ :item | 			item				contents: 'No Windows' translated;				isEnabled: false ] ].	windows do: [ :each |		menu addItem: [ :item |			item 				contents: (self windowMenuItemLabelFor: each);				icon: (self colorIcon: each model defaultBackgroundColor);				target: each;				selector: #comeToFront;				subMenuUpdater: self				selector: #windowMenuFor:on:				arguments: { each };				action: [ each activateAndForceLabelToShow; expand ] ] ].! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'hjh 4/21/2010 18:40' prior: 59197577!showWelcomeText: aSelector label: labelString in: bounds	"Show a welcome text. Linked in here so that the text can be edited	by changing the acceptBlock below."	| acceptBlock window |	"Change the following to allow editing the text"	true ifTrue:[		acceptBlock := [:text|			self class				compile: aSelector,'	^', (String streamContents:[:s| s nextChunkPutWithStyle: text]) storeString, ' readStream nextChunkText'				classified: (self class organization categoryOfElement: aSelector).		].	].	window := UIManager default 		edit: (self perform: aSelector)		label: labelString		accept: acceptBlock.	window bounds: bounds.! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/19/2010 20:58'!blinkingCursor	<preference: 'Blinking Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor will blink.'		type: #Boolean>	^ BlinkingCursor ifNil: [ true ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 15:57'!blinkingCursor: aBoolean	BlinkingCursor := aBoolean! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor	<preference: 'Dumbbell-shaped Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor assumes the shape of a dumbbell, otherwise a vertical bar..'		type: #Boolean>	^ DumbbellCursor ifNil: [ false ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor: aBoolean	DumbbellCursor := aBoolean! !!TextMorph methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58' prior: 52937182!keyboardFocusChange: aBoolean 	| w |	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"].			Editor blinkingCursor ifTrue: [ self startBlinking ].	] ifFalse:["A hand has clicked elsewhere..."		(w := self world) ifNotNil:[			w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].			"Release control unless some hand is still holding on"			self releaseEditor].		self stopBlinking.	].! !!LazyListMorph methodsFor: 'drawing' stamp: 'mha 4/27/2010 09:33' prior: 59214813!drawBackgroundForMulti: row on: aCanvas 	"shade the background paler, if this row is selected, but not the current selected row"	| selectionDrawBounds thisColor |	thisColor := selectedRow = row		ifTrue: [ self class listSelectionColor twiceDarker ]		ifFalse: [ self class listSelectionColor ].	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas		fillRectangle: selectionDrawBounds		color: thisColor! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:38' prior: 58964342!bottomBoundary	"Answert the bottommost x position the receiver could be moved."	| splitter morphs |	splitter := self splitterBelow.	morphs := self commonNeighbours: rightOrBottom with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect bottom]				ifFalse: [owner innerBounds bottom]]		ifNotNil: [splitter top])		- (self minimumHeightOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:37' prior: 58961894!topBoundary	"Answer the topmost x position the receiver could be moved to."	| splitter morphs |	splitter := self splitterAbove.	morphs := self commonNeighbours: leftOrTop with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect top]				ifFalse: [owner innerBounds top]]		ifNotNil: [splitter bottom])		+ (self minimumHeightOf: morphs)! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'tfel 4/16/2010 09:34' prior: 58988661!drawOn: aCanvas 	| cc gradient borderColor |	cc := self color.	cc isTransparent ifTrue:[cc := Color gray: 0.9].	self enabled ifFalse:[cc := Color lightGray].	cc brightness > 0.9 ifTrue:[cc := cc adjustBrightness: 0.9 - cc brightness].	showSelectionFeedback ifTrue:[		borderColor := cc muchDarker.		gradient := GradientFillStyle ramp: {			0.0 -> cc muchDarker.			0.1-> (cc adjustBrightness: -0.2).			0.5 -> cc.			0.9-> (cc adjustBrightness: -0.1).			1 -> cc muchDarker.		}.	] ifFalse:[		borderColor := Color lightGray.		gradient := GradientFillStyle ramp: {			0.0 -> Color white.			0.1-> (cc adjustBrightness: 0.05).			0.6 -> (cc darker).		}	].	gradient origin: bounds topLeft.	gradient direction: 0@self height.	^ self class roundedButtonCorners		ifTrue: [aCanvas 				frameAndFillRoundRect: bounds 				radius: 8 				fillStyle: gradient 				borderWidth: 1 				borderColor: borderColor]		ifFalse: [aCanvas 				frameAndFillRectangle: self innerBounds 				fillColor: gradient asColor 				borderWidth: 1 				borderColor: borderColor darker;				fillRectangle: (self innerBounds insetBy: 1) 				fillStyle: gradient]! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58' prior: 52961433!keyboardFocusChange: aBoolean 	"rr 3/21/2004 22:55 : removed the #ifFalse: branch, 	which was responsible of the deselection of text when the 	paragraph lost focus. This way selection works in a more standard 	way, and this permits the menu keyboard control to be really effective"	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."		self hasFocus ifFalse: [self editor	"Forces install"].		Editor blinkingCursor ifTrue: [self startBlinking].	] ifFalse:[		self stopBlinking.	].	self changed.! !!NewParagraph methodsFor: 'access' stamp: 'cmm 4/5/2010 16:24' prior: 51924537!caretWidth	^ Editor dumbbellCursor		ifTrue: [ 2 ]		ifFalse: [ 0 ]! !!SmalltalkEditor methodsFor: 'private' stamp: 'cmm 4/4/2010 20:41' prior: 58007098!methodArgument: anInteger 	^ (ReadStream on: self text asString) nextLine		ifNil: [ String empty ]		ifNotNilDo:			[ : line | 			line substrings				at: 2 * anInteger				ifAbsent: [ String empty ] ]! !"Morphic"!!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08' prior: 57724509!basicUpTo: delim	^ super upTo: delim.! !"Multilingual"!!TestURI methodsFor: 'running file' stamp: 'ar 4/12/2010 21:38'!testDirWithHash	"Tests proper escaping of directories with hash mark"	| uriDir origPath origDir dirURI |	origPath := FileDirectory default pathName, '#123'.	origDir := FileDirectory on: origPath.	self assert: origDir pathName = origPath.	dirURI := origDir uri.	uriDir := FileDirectory uri: dirURI.	self assert: origDir fullName = uriDir fullName.! !"NetworkTests"!!PackageInfo methodsFor: 'testing' stamp: 'bf 4/19/2010 02:54' prior: 54301517!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !"PackageInfo-Base"!!String methodsFor: '*sound-synthesis' stamp: 'wiz 4/28/2010 16:01'!asSound	"Return a sound. Either from the sound library via SampleSound or	else the Beeper default"	^ SampledSound		soundNamed: self		ifAbsent: [Beeper default]! !"Sound"!!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ul 5/2/2010 12:32' prior: 24591721!findWindowInWorldLabeled: aLabel	^World submorphs		detect: [ :each |			(each isKindOf: SystemWindow)				and: [ each label = aLabel ] ]		ifNone: nil.! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'jcg 4/15/2010 16:27'!testFileTruncation	"Ensure that nextChunkPut:/nextChunk works properly on a caching file"	| file |	file := nil.	[			file := FileDirectory default forceNewFileNamed: 'TruncationTest.txt'.		file nextPutAll: '1234567890'.	] ensure: [file close].	[		file := FileDirectory default oldFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234567890'].		file truncate: 4.	] ensure: [file close].	[		file := FileDirectory default readOnlyFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234'].	] ensure: [		file close.		FileDirectory default deleteFileNamed: file name ifAbsent:[]	].! !"Tests"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'ul 5/2/2010 12:34' prior: 59218373!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	window model		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!FileList commentStamp: 'nk 11/26/2002 11:52' prior: 59304739!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.The FileList now provides a registration mechanism to which any tools the filelist uses ***MUST*** register.  This way it is possible to dynamically load or unload a new tool and have the FileList automatically updated.  This change supports a decomposition of Squeak and removes a problem with dead reference to classes after a major shrink.Tools should implement the following methods (look for implementors in the image):#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)#services (all provided services, to be displayed in full list)These methods both return a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.Tools must register with the FileList calling the class method #registerFileReader: when they load. They also must call #unregisterFileReader: when they unload.There is a testSuite called FileListTest that presents some examples. Stef (I do not like really this distinction passing always a file list could be better)Old Comments: FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!Workspace methodsFor: 'accessing' stamp: 'fbs 4/28/2010 21:48'!contents: textOrString	super contents: textOrString.	self changed: #contents.! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 4/21/2010 21:23'!shouldStyle: aBool	"If true, contents will by rendered w/ syntax-highlighting"	shouldStyle := aBool! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:47' prior: 51626697!buildSearchPaneWith: builder	| buttonFrame buttonSpec textFrame textSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttonFrame := LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.3 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	textFrame := LayoutFrame new		leftFraction: 0.3 offset: 1;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	buttonSpec := builder pluggableActionButtonSpec new.	buttonSpec 		model: self;		label: 'Search';		action: [self doSearchFrom: searchPane];		frame: buttonFrame.	top children add: buttonSpec.		textSpec := builder pluggableInputFieldSpec new.	textSpec 		model: self;		name: #search;		getText: #searchString; 		setText: #searchString:notifying:;		frame: textFrame.	top children add: textSpec.	^top! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/23/2010 10:29' prior: 51627142!buildWith: builder	"ToolBuilder open: MessageNames new"	| searchPaneHeight windowSpec max result |	searchPaneHeight := self buttonHeight.	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	windowSpec := self buildWindowWith: builder specs: {		(self topConstantHeightFrame: searchPaneHeight fromLeft: 0 width: 0.5) -> [self buildSearchPaneWith: builder].		(self selectorListFrame: max fromTop: searchPaneHeight) -> [self buildSelectorListWith: builder].		(0.5@0.0 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	searchPane := builder widgetAt: #search.	^result! !!MessageNames methodsFor: 'class list' stamp: 'fbs 3/31/2010 22:46'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	messageListIndex > 0 ifTrue: [		^ self setClassAndSelectorIn: [:c :s | ^c]].	(selectorListIndex isNil not and: [selectorListIndex > 0]) ifTrue: [^Smalltalk classNamed: (self selectorList at: selectorListIndex)].		^ nil.	! !!MessageNames methodsFor: 'selection' stamp: 'fbs 3/31/2010 16:31' prior: 23706644!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ messageListIndex = 0		ifTrue: [self selectorList at: selectorListIndex ifAbsent: [nil]]		ifFalse: [self messageList at: messageListIndex ifAbsent: [nil]].! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:44'!selectorListFrame: max fromTop: topOffset	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: topOffset;		rightFraction: 0.5 offset: 0;		bottomFraction: max offset: 0.! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:58'!availableGraphicsExtent	self dependents do: [:each |		((each isKindOf: PluggableTextMorph) and: [each getTextSelector == #contents]) ifTrue: [^each innerBounds extent - (6@22)]].	^nil! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 12:47' prior: 57782322!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #graphic ifTrue: [^ contents].	brevityState == #needToGetGraphic ifTrue: [^self readGraphicContents].		brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	(TextConverter allEncodingNames includes: brevityState) 		ifTrue: [ ^self readContentsAsEncoding: brevityState].	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'file list menu' stamp: 'cao 4/26/2010 09:36' prior: 57911104!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| services maybeLine extraLines |	shifted ifTrue:		[^ aMenu addList: StringHolder shiftedYellowButtonMenuItems].	fileName ifNotNil:		[services := OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine := services size.		(FileStream sourceFileSuffixes includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines := OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!FileList methodsFor: 'file list' stamp: 'hmm 4/27/2010 13:09' prior: 57786840!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := self isGraphicsFileSelected		ifTrue: [#needToGetGraphic]		ifFalse: [#needToGetBrief]..	self changed: #fileListIndex.	self changed: #contents.	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 13:08'!isGraphicsFileSelected	^fileName notNil and: [((self itemsForFile: self fullName) detect: [:each | each provider == Form and: [each selector == #importImage:]] ifNone: []) notNil]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 20:45'!readGraphicContents	| form maxExtent ext |	form := Form fromFileNamed: self fullName.	maxExtent := lastGraphicsExtent := self availableGraphicsExtent.	ext := form extent.	(maxExtent notNil and: [form extent <= maxExtent]) ifFalse: [		form := form magnify: form boundingBox by: (maxExtent x / form width min: maxExtent y / form height) asPoint smoothing: 3].	contents :=  ('Image extent: ', ext printString) asText,				(String with: Character cr),				(Text string: ' '					attribute: (TextFontReference toFont: 						(FormSetFont new							fromFormArray: (Array with: form)							asciiStart: Character space asInteger							ascent: form height))).	brevityState := #graphic.	^contents! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:02'!step	| ext |	brevityState = #graphic ifTrue: [		ext := self availableGraphicsExtent.		ext = lastGraphicsExtent ifFalse: [			lastGraphicsExtent := ext.			brevityState := #needToGetGraphic.			self changed: #contents]]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:03'!stepTimeIn: aWindow	^500! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:56'!wantsSteps	^true! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:29' prior: 50538558!buildClassListSingletonWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classListSingleton; 		getIndex: #indexIsOne; 		setIndex: #indexIsOne:; 		menu: #classListMenu:shifted; 		keyPress: #classListKey:from:.	^listSpec! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:30' prior: 50530267!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:shifted:; 		keyPress: #classListKey:from:.	Preferences browseWithDragNDrop 		ifTrue:[listSpec dragItem: #dragFromClassList:].	^listSpec! !!Browser methodsFor: 'class functions' stamp: 'cmm 4/23/2010 17:03' prior: 54374919!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"	| aClass |	(aClass := self selectedClassOrMetaClass) ifNotNil:		[aClass instVarNames do: 			[:aName |				| newMessage setter |				(aClass canUnderstand: aName asSymbol)					ifFalse:						[newMessage := aName, '	^', aName.						aClass compile: newMessage classified: 'accessing' notifying: nil].				(aClass canUnderstand: (setter := aName, ':') asSymbol)					ifFalse:						[newMessage := setter, ' anObject	', aName, ' := anObject'.						aClass compile: newMessage classified: 'accessing' notifying: nil]]]! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:53'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 15:50' prior: 50535675!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	"Example:		Browser newOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0.0@0.0 corner: 0.5@0.08) -> [self buildClassListSingletonWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0 width: 0.5 bottomFraction: max) -> [self buildMessageCategoryListWith: builder].		(self topConstantHeightFrame: self buttonHeight fromLeft: 0.5 width: 0.5) -> [self buildSwitchesWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0.5 width: 0.5 bottomFraction: max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:52'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !"Tools"!!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:07'!allowUnderscoreAssignments	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreAssignments])		ifNil: [Scanner prefAllowUnderscoreAssignments]! !!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:04'!allowUnderscoreSelectors	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreSelectors])		ifNil: [Scanner prefAllowUnderscoreSelectors]! !!SHParserST80 methodsFor: 'token testing' stamp: 'laza 4/28/2010 17:51' prior: 52377778!isAssignment	^self isAnsiAssignment or: [self allowUnderscoreAssignments and: [currentToken = '_']]! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:15' prior: 52364496!nextChar	sourcePosition := sourcePosition + 1.	^source at: sourcePosition ifAbsent: $ ! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 52371083!parse: isAMethod 	"Parse the receiver's text. If isAMethod is true    then treat text as a method, if false as an    expression with no message pattern"	self initializeInstanceVariables.	sourcePosition := 1.	arguments := Dictionary new.	temporaries := Dictionary new.	blockDepth := bracketDepth := 0.	ranges		ifNil: [ranges := OrderedCollection new: 100]		ifNotNil: [ranges reset].	errorBlock := [^false].	[self scanNext.	isAMethod 		ifTrue: [			self parseMessagePattern.			self parsePragmaSequence].	self parseMethodTemporaries.	isAMethod ifTrue: [self parsePragmaSequence].	self parseStatementList.	currentToken ifNotNil: [self error]]		ensure:[errorBlock := nil].	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 52383846!parseBinary 	| binary type |	self parseUnary.	[self isBinary] 		whileTrue: [			binary := currentToken.			type := #binary.			(binary isEmpty or:[(Symbol lookup: binary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: binary skipping: nil)						ifNil: [#undefinedBinary]						ifNotNil:[#incompleteBinary]].				self scanPast: type. 				self parseTerm.            	self parseUnary]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 54459800!parseKeyword     | keyword rangeIndices |    self parseBinary.	keyword := ''.	rangeIndices := #().	[    		[self isKeyword]        		whileTrue: [				keyword := keyword, currentToken. 				self rangeType: #keyword.				"remember where this keyword token is in ranges"				rangeIndices := rangeIndices copyWith: ranges size.				self scanNext.				self parseTerm.				self parseBinary ]	] ensure: [ | type |		"do this in an ensure so that it happens even if the errorBlock evaluates before getting here"		"patch up the keyword tokens, so that incomplete and undefined ones look different"		(keyword isEmpty or:[(Symbol lookup: keyword) notNil])			ifFalse:[				type := (Symbol thatStartsCaseSensitive: keyword skipping: nil)					ifNil: [#undefinedKeyword]					ifNotNil:[#incompleteKeyword].				rangeIndices do: [:i | (ranges at: i) type: type]]]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 22:50' prior: 52379595!parsePrimitive	self scanNext.	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: [			currentTokenFirst == $'				ifTrue: [ self parseString ]				ifFalse: [					currentTokenFirst == $#						ifTrue: [ self parseSymbol ]						ifFalse: [ self error ] ].			currentToken = 'module:' 				ifTrue: [					self scanPast: #module.					currentTokenFirst == $'						ifTrue: [ self parseString ]						ifFalse: [							currentTokenFirst == $#								ifTrue: [ self parseSymbol ]								ifFalse: [ self error ] ] ] ].	self failUnless: currentTokenFirst == $>.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:24' prior: 52389009!parseString	| first c answer last |	first := sourcePosition.	answer := ''.		[(c := self currentChar)		ifNil: [			self rangeType: #unfinishedString start: first - 1 end: source size.			self error	": 'unfinished string'"].	(c == $' 			ifFalse: [answer := answer copyWith: c. true] 		ifTrue: [false]	) or: [		self peekChar == $' 			ifTrue: [				sourcePosition := sourcePosition + 1.				answer := answer copyWith: $'.				true]			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #string start: first - 1 end: last.	^answer! !!SHParserST80 methodsFor: 'parse' stamp: 'laza 4/29/2010 16:18' prior: 52362002!parseSymbolIdentifier	| c start end |	c := self currentChar.	self failUnless: (c isLetter or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]).	start := sourcePosition.		[c := self nextChar.	c isAlphaNumeric or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]] whileTrue.	end := sourcePosition - 1.	c := source copyFrom: start - 1 to: end.	self scanPast: #symbol start: start - 1 end: end.	^c! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26' prior: 52378939!parseSymbolString	| first c last |	first := sourcePosition.	self nextChar.	[(c := self currentChar) 		ifNil: [			self rangeType: #unfinishedString start: first end: source size.			self error	": 'unfinished string'"].	c ~~ $' or: [		self peekChar == $' 			ifTrue: [sourcePosition := sourcePosition + 1.true] 			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #stringSymbol start: first - 1 end: last! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26' prior: 52387010!parseUnary	| unary type |	    [self isName]        whileTrue: [			unary := currentToken.			type := #unary.			(unary isEmpty or:[(Symbol lookup: unary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: unary skipping: nil)						ifNil: [#undefinedUnary]						ifNotNil:[#incompleteUnary]].			self scanPast: type]! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 19:29' prior: 52385928!scanIdentifier	| c start |	start := sourcePosition.	[(c := self nextChar) isAlphaNumeric or: [c == $_ and: [self allowUnderscoreSelectors]]] whileTrue.	(c == $: and: [(self isSelectorCharacter: self peekChar) not]) 		ifTrue: [self nextChar].	currentToken := source copyFrom: start to: sourcePosition - 1.	currentTokenSourcePosition := start! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:27' prior: 52374752!scanNext	self scanWhitespace.	currentTokenFirst := self currentChar.	currentTokenFirst 		ifNil: [" end of input "			currentTokenFirst := $ .			currentTokenSourcePosition := nil.			currentToken := nil.			^nil].	currentTokenFirst isDigit ifTrue: [^self scanNumber].	currentTokenFirst isLetter ifTrue: [^self scanIdentifier].	^self scanBinary! !!SHTextStyler methodsFor: 'private' stamp: 'ul 4/28/2010 20:27' prior: 52391465!monitor	^monitor ifNil: [monitor := Monitor new]! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreAssignments	^nil! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreSelectors	^nil! !"ShoutCore"!!HelpTopicListItemWrapper commentStamp: 'tbn 3/8/2010 09:30' prior: 0!This class implements a list item wrapper for help topics.Instance Variables!!CustomHelp commentStamp: 'tbn 3/29/2010 13:23' prior: 0!This is a common superclass for custom help. Subclasses of this class are automatically included into the system help.By default the informations provided on the receiver class are converted into help topics by a specific builder - here the CustomHelpHelpBuilder. Note that you can provide an own custom builder by overriding the #builder method!!HelpOnHelp commentStamp: 'tbn 2/12/2010 14:27' prior: 0!Welcome to Pharo Smalltalk Help System!!HelpAPIDocumentation commentStamp: 'tbn 4/30/2010 15:12' prior: 0!This class represents the browsable package API help for the help system.Instance Variables!!HelpBrowser commentStamp: 'tbn 3/8/2010 09:33' prior: 0!A HelpBrowser is used to display a hierarchy of help topics and their contents.Instance Variables	rootTopic: 		<HelpTopic>	window:			<StandardWindow>	 	treeMorph:		<PluggableTreeMorph>	contentMorph:		<Morph>			rootTopic	- xxxxxwindow	- xxxxxtreeMorph 	- xxxxxcontentMorph 	- xxxxx!!HelpBuilder commentStamp: 'tbn 2/12/2010 14:54' prior: 0!This is an utility class that builds the books for a help system.Instance Variables	rootTopics:		<OrderedCollection>rootTopics	- a collection of books !!ClassAPIHelpBuilder commentStamp: 'tbn 4/30/2010 15:37' prior: 0!A builder to build the API Help for a classInstance Variables	addMethods:		<Boolean>	addSubclasses:		<Boolean>	subclassesAsSeparateTopic:		<Boolean>addMethods	- When true the builder will include method helpaddSubclasses	- When true the builder will recursively go through and add subclassessubclassesAsSeparateTopic	- xxxxx!!CustomHelpHelpBuilder commentStamp: 'tbn 3/29/2010 13:30' prior: 0!This builder builds help topics from a help topic description (which is typically storedin a class). The help topic description object has to understand the following messages:  #bookName - should return the name of the help book  #icon - should return the icon of the help book  #key - should return a unique key to identify the book  #pages - should return an array of method selectors to call to get the books pages!!HelpIcons commentStamp: 'tbn 3/8/2010 09:29' prior: 0!This class is used to store help icons for the help browser. Typically one implements a method returning a 12x12 Form instance whichshould not be called directly.Since the class provides an internal icon cache (so the icons can be reused without creating too many new instances) the icons should be accessed using the #iconNamed: message with the method selector as argument.To create a form from an icon file stored on disk you can use the following code:   | image stream |	image := ColorForm fromFileNamed: '/path/to/icon.png'.	stream := WriteStream with: String new.	image storeOn: stream.	stream contents inspect.!!HelpTopic commentStamp: 'tbn 3/29/2010 14:53' prior: 0!A HelpTopic provides content information that can be used as a help to the user.It can be labeled with a title, identified using an (optional) unique key and marked with an (optional) icon.Help topics form a hierarchy since any topic is able to have zero or moresubtopics. Instance Variables	contents:		<Object>      The help topic contents	icon:			<Form|nil>	   An optional icon for the topic	key:			<String|nil>    An optional unique key	subtopics:	      <Collection>  A collection of subtopics	title:			<String>        The titlecontents	- The help topic contents - typically containing the help topics informationicon	- An optional icon for the topickey	- An optional unique key which can be used to identify the topic. subtopics	- A collection of subtopics. 	  By default the subtopics are not sorted, so the insertion order is used. 	  If necessary it is possible to sort the subtopics by title.title	- A meaninful title for the help topic!!SystemHelp commentStamp: 'tbn 4/30/2010 15:33' prior: 0!This class defines Help for the system in front of you.It defines the default contents when you open a help browser.So "HelpBrowser open" is the same as "HelpBrowser openOn: SystemHelp".!!SystemReference commentStamp: 'tbn 4/30/2010 15:35' prior: 0!This class defines the full reference help for the system.(contents for the full API Help).Just run "HelpBrowser openOn: SystemReference".!!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:25'!asString	"Returns a string used as a label"		^item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!balloonText	"Returns a string used for fly by help"		^self item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!contents	"Returns subnodes (if any)"	 	item hasSubtopics ifFalse: [^#()].		^(item subtopics) collect: [ :each | 		HelpTopicListItemWrapper with: each	].! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:27'!highlightingColor	"Returns the text color when the receiver is selected in a list."	^Color blue  ! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:55'!icon	"Either return the icon for the given topic"		| symbol |	item icon notNil ifTrue: [^item icon].	symbol := item hasSubtopics 					 ifTrue: [#bookIcon] 			  		 ifFalse: [#pageIcon].	^HelpIcons iconNamed: symbol! !!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:26'!accept: aSelector title: title contents: text	"Accept edited text. Compile it into a HelpTopic"	| code |	code := String streamContents:[:s|		s nextPutAll: aSelector.		s crtab; nextPutAll: '"This method was automatically generated. Edit it using:"'.		s crtab; nextPutAll: '"', self name,' edit: ', aSelector storeString,'"'.		s crtab; nextPutAll: '^HelpTopic'.		s crtab: 2; nextPutAll: 'title: ', title storeString.		s crtab: 2; nextPutAll: 'contents: '.		s cr; nextPutAll: (String streamContents:[:c| c nextChunkPutWithStyle: text]) storeString.		s nextPutAll:' readStream nextChunkText'.	].	self class 		compile: code		classified: ((self class organization categoryOfElement: aSelector) ifNil:['pages']).! !!CustomHelp class methodsFor: 'converting' stamp: 'tbn 3/29/2010 13:17'!asHelpTopic	"Convert the receiver to a help topic"		^self builder buildHelpTopicFrom: self! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!bookName	"Returns the name of the custom help book"		^'Help'! !!CustomHelp class methodsFor: 'defaults' stamp: 'tbn 3/29/2010 13:24'!builder	"Returns the builder that is used to build the given help book from the receiver. You can override this method	 in a subclass to provide an own builder".		^CustomHelpHelpBuilder! !!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:24'!edit: aSelector	"Open a Workspace on the text in the given selector.	When accepted, compile the result as a help topic."	| topic window |	topic := (self respondsTo: aSelector) 			ifTrue:[self perform: aSelector]			ifFalse:[HelpTopic title: 'Untitled' contents: 'Please edit this topic. To change the topic title, edit the window label.'].	window := UIManager default		edit: topic contents		label: topic title		accept: [:text| self accept: aSelector title: window label contents: text].! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!icon	"Returns an icon used for displaying the custom help book"		^HelpIcons iconNamed: #bookIcon! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:18'!key	"Returns a unique key identifying the receiver in the help system"		^''! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!pages 	"Returns a collection of method selectors to return the pages of the custom help book"			^#()! !!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:50'!bookName	^'API Documentation'! !!HelpAPIDocumentation class methodsFor: 'defaults' stamp: 'tbn 3/11/2010 23:57'!builder	^PackageAPIHelpBuilder! !!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/11/2010 23:55'!packages	^#('HelpSystem-Core-Model' 'HelpSystem-Core-Utilities' 'HelpSystem-Core-UI')! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:47'!bookName	^'Implementation'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:59'!overview	^HelpTopic 		title: 'Overview'		contents:		'THE IMPLEMENTATIONThe help system typically consists of help books including one or more pages. A book or page is therefore a "topic of interest"  providing contents for help to a user. A topic has a title and an icon and is able to have subtopics forming a hierarchy of topics. This simple model is reflected in the class HelpTopic.Since this model forms a hierarchical structure of help topics there is a browser with a tree to display the help contents. This browser is implemented in class HelpBrowser.You can open this browser programmatically using:   HelpBrowser open' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page1	^HelpTopic 		title: '1. Simple help topics'		contents: 'The help browser usually operates on a hierarchy of help topics with one help topic at the root level. Evaluate the following expression in a workspace to contruct a simple help topic and open it as a root topic in the help browser.				|root|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.									HelpBrowser openOn: root				Note that the help browser displays the contents of our topic in the right page and uses the topics title as the title for the help browser window.			'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page2	^HelpTopic 		title: '2. Forming a hierarchy'		contents: 'To form a hierarchy we just have to add new subtopics on our root topic.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 			title: ''My second subtopic''			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:10'!page3	^HelpTopic 		title: '3. Adding icons'		contents: 'If you dont like the default icon you can add own custom icons to the topics. See the class HelpIcons for more details.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 		     			title: ''My second subtopic''			 icon: (HelpIcons iconNamed: #packageIcon)			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 15:01'!page4	^HelpTopic 		title: '4. Own help objects'		contents:		'You can open this help browser directly on an instance of HelpTopic, but it is more common to open it on any object that understands the message #asHelpTopic.So you can write for instance:   HelpBrowser openOn: Integeropening a short API help/system reference on the Integer class.The above expression is the short form for:   HelpBrowser openOn: (SystemReference forClass: Integer)If you want you can include the subclasses:   HelpBrowser openOn: (SystemReference hierarchyFor: Integer)or even methods   HelpBrowser openOn: (SystemReference hierarchyWithMethodsFor: Integer)You can browse the whole system reference documentation using:    HelpBrowser openOn: SystemReferenceBut these are only a few examples what we can extract from the system. However - the major goal is NOT an API browser, the idea is to provide a simple architecture to provide browsable help contents depending on the context. For instance it should also be possibleto use the help system to provide end user help on any commercialapplication that is written with the Smalltalk system.' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 19:23'!page5	^HelpTopic 		title: '5. Help sources'		contents:		'Since the underlying model is very simple you can easily fill it with nearly any information from different sources. Try this:|topic day url sub|topic := HelpTopic named: ''Last week on Squeak IRC''.0 to: 7 do: [:index |	day := (Date today subtractDays: index) printFormat: #(3 2 1 $. 1 2 2).	url := ''http://tunes.org/~nef/logs/squeak/'' , day.	sub := HelpTopic 			title: day contents: (HTTPLoader default retrieveContentsFor: url) contents.	topic addSubtopic: sub.].HelpBrowser openOn: topic  ' ! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 19:21'!pages	^#(overview page1 page2 page3 page4 page5)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:06'!bookName	^'Custom help from code'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:52'!overview	^HelpTopic		title: 'Overview'		contents:		'OVERVIEW	The help system allows you to provide own books and help texts. You can open the help browser on any object that is able to understand #asHelpTopic.This method returns the root node of the displayed topic hierarchy:      HelpBrowser openOn: myObjectTypically the object does not convert itself to a help topic structure, usually it dispatches to a builder (see HelpBuilder and subclasses) who does all this. 	A much more convenient and reproducable way is to implement custom help classes. This allows you to implement and manage your help texts using the standard development and code management tools. These custom help classes are subclasses of "CustomHelp" and are automatically included into the standard help browser. '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 23:57'!pages	^#(overview step1 step2 step3 step4 step5)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step1	^HelpTopic 		title: 'Step 1 - Create a class for the book'		contents:		'STEP 1 - CREATE A CLASS FOR THE BOOK		There is a predefined class CustomHelp which you have to subclass for a custom help book to show up as a book in the Help browser:	  CustomHelp subclass: #MyAppHelp    	instanceVariableNames: ''''	  classVariableNames: ''''	  poolDictionaries: ''''	  category: ''MyApp-Help'' Class methods on this class can reflect pages and if you want to provide nested help books just subclass your own help class to form a hierarchy. Any new subclass of MyAppHelp will then be a new book in your hierarchy.The class category used should end with "-Help" so it is easy to recognize that it includes the help support of your project.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step2	^HelpTopic		title: 'Step 2 - Provide a book name'		contents:	'STEP 2 - PROVIDE A BOOK NAME	Now implement the class method #bookName to return the name of your help book.   bookName	    ^''My App help''	By implementing this method the system knows how you would like to name your book and uses the given string as a label in the HelpBrowser later.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:41'!step3	^HelpTopic		title: 'Step 3 - Implement pages using methods'		contents:	'STEP 3 - IMPLEMENT PAGES USING METHODS Implement a page by defining a method that returns an instance of HelpPage defining a page title and a help text displayed in the help browser.      firstPage     	    ^HelpTopic	           title: ''First Page''                  contents: ''Hello world''Define a new method for each page of your book. Please group the pages in a method category called "pages".You can also define an icon for the specific page:     secondPage     	    ^HelpTopic	           title: ''Second Page''     	           icon: (HelpIcons iconNamed: #packageIcon)                 contents: ''More to come''Note: =====Later we may add support for better help contents than just plain text (markup descriptions, active morphs, ...)  '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:41'!step4	^HelpTopic		title: 'Step 4 - Defining the page order'		contents:	'STEP 4 - DEFINING THE PAGE ORDER By implementing the class method #pages you return a collection of method selectors to define the order in which the pages appear in your book:      pages     	    ^#(firstPage secondPage)'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/28/2010 22:56'!step5	^HelpTopic		title: 'Step 5 - Test your help'		contents:	'STEP 5 - TEST YOUR HELP	By using              HelpBrowser open '! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:21'!bookName	^'Help on Help'! !!HelpOnHelp class methodsFor: 'pages' stamp: 'hjh 4/21/2010 16:59'!introduction	"This method was automatically generated. Edit it using:"	"HelpOnHelp edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'WELCOME TO THE HELP SYSTEMThe help system is a simple user interface to display help contents to the user. It can be accessed from the world menu using "Tools" -> "Help Browser" or by evaluating ''HelpBrowser open'' in a workspace.There is a predefined mechanism allowing you to have help contents stored as source code using methods in specific help provider classes. This allows to manage the help texts using the standard development tools. But this is only one possible representation.Yes, this is a good solution.!!' readStream nextChunkText! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:56'!key	^'HelpOnHelp'! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:48'!pages	^#(introduction)! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'hjh 4/21/2010 11:06'!defaultHelpBrowser	^self ! !!HelpBrowser class methodsFor: 'class initialization' stamp: 'mha 5/2/2010 15:51'!initialize	"Initializes the receiver class" 	self isPharo11		ifFalse: [ TheWorldMenu registerOpenCommand: {'Help Browser'. {self. #open}}. ].			"self open"! !!HelpBrowser class methodsFor: 'private' stamp: 'tbn 3/29/2010 12:32'!isPharo11	"Return true if we are in Pharo 1.1."		^(SystemVersion current version includesSubString: '1.1')! !!HelpBrowser class methodsFor: 'private' stamp: 'tbn 3/29/2010 12:46'!isSqueak	"Return true if we are in Squeak"		^(SystemVersion current version includesSubString: 'Squeak')! !!HelpBrowser class methodsFor: 'world menu' stamp: 'tbn 3/28/2010 21:12'!menuCommandOn: aBuilder 	<worldMenu> 	(aBuilder item: #'Help Browser')		parent: #Tools;		action:[self open]; 		icon: (HelpIcons iconNamed: #bookIcon)! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 4/22/2010 17:01'!open	^self defaultHelpBrowser openOn: SystemHelp! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 3/8/2010 08:50'!openOn: aHelpTopic	"Open the receiver on the given help topic or any other object that can be transformed into	 a help topic by sending #asHelpTopic."		^(self new)		rootTopic: aHelpTopic asHelpTopic;		open;		yourself! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 2/12/2010 12:57'!close	window notNil ifTrue: [window delete]! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 3/5/2010 22:27'!defaultRoot	^CustomHelp! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 4/30/2010 12:39'!defaultViewerClass	 	^PluggableTextMorph! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 3/29/2010 12:42'!initWindow		self class isSqueak 		ifTrue: [self initWindowInSqueak ]		ifFalse: [self initWindowInPharo ]! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 4/30/2010 12:40'!initWindowInPharo	| toolbar dock|	window := (Smalltalk at: #StandardWindow) new.	window model: self.		window title: 'Help Browser'.	toolbar := window newToolbar: {window			newButtonFor: self			getState: nil			action: #refresh			arguments: nil			getEnabled: nil			labelForm: (HelpIcons iconNamed: #refreshIcon)			help: 'Refresh' translated.			}.				dock := window newToolDockingBar.		dock addMorphBack: toolbar.	window			addMorph: dock			fullFrame: (LayoutFrame fractions: (0@0 corner: 1@0) offsets: (0@0 corner: 0 @ dock minExtent y)).	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window 		addMorph: treeMorph 		fullFrame: (LayoutFrame fractions: (0@0 corner: 0.3@1) offsets: (0@dock minExtent y corner: 0 @ 0)).	"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph fullFrame: (LayoutFrame fractions: (0.3@0 corner: 1@1) offsets: (0@dock minExtent y corner: 0 @ 0)).	 	 ! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 4/30/2010 12:39'!initWindowInSqueak	window := SystemWindow labelled: 'Help Browser'.	window model: self.	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph frame: (0@0 corner: 0.3@1).		"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph frame: (0.3@0 corner: 1@1).					! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:39'!initialize 	super initialize. 	self initWindow. ! !!HelpBrowser methodsFor: 'events' stamp: 'tbn 3/8/2010 15:17'!onItemClicked: anItem	anItem isNil ifTrue: [^contentMorph setText: rootTopic contents].	contentMorph setText: anItem contents! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 3/3/2010 23:32'!open	 	"Open the receivers window" 	self refresh.		window openInWorld.	 ! !!HelpBrowser methodsFor: 'actions' stamp: 'tbn 3/29/2010 12:44'!refresh	|items|	window setLabel: rootTopic title.	items := rootTopic subtopics collect: [:each | HelpTopicListItemWrapper with: each ].	treeMorph list: items.	contentMorph setText: rootTopic contents! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:56'!rootTopic	^rootTopic! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:11'!rootTopic: aHelpTopic	rootTopic := aHelpTopic. 	self refresh ! !!ClassAPIHelpBuilder class methodsFor: 'building' stamp: 'tbn 3/11/2010 23:39'!buildHierarchicalHelpTopicFrom: aClass withSubclasses: aBoolean withMethods: anotherBoolean	"Start building from the given class"		^(self new)		addSubclasses: aBoolean;		addMethods: anotherBoolean;		rootToBuildFrom: aClass;		build;		topicToBuild ! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods	^ addMethods! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods: anObject	addMethods := anObject! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses	^ addSubclasses! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses: anObject	addSubclasses := anObject! !!ClassAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:39'!build	| instanceSide classSide |	topicToBuild := (HelpTopic named: rootToBuildFrom name).	topicToBuild icon: (HelpIcons iconNamed: #pageIcon).	topicToBuild contents: rootToBuildFrom comment.		addMethods ifTrue: [ self buildSubnodesForMethods ].	addSubclasses	 ifTrue: [ self buildSubnodesForSubclasses ].	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 4/22/2010 09:26'!buildMethodTopicsOn: topic for: aClass	|stream comments methodComment|	stream := String new writeStream.	aClass selectors asSortedCollection do:			[:selector | 					  stream 				 nextPutAll: aClass name;			    nextPutAll: '>>';			  	 nextPutAll: selector asString;				 cr.					  comments := aClass commentsAt: selector.			  methodComment := (comments size = 0)									ifTrue: [ 'Method has no comment.' ]									ifFalse: [ comments first ].												  stream nextPutAll: methodComment;cr;cr.	].	topic contents: stream contents.		! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/8/2010 16:56'!buildSubclassTopicFor: aSubclass	 	^(self class new) 			rootToBuildFrom: aSubclass;			addSubclasses: addSubclasses;			addMethods: addMethods;			subclassesAsSeparateTopic: subclassesAsSeparateTopic;			build;			topicToBuild 	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForMethods	| instanceSide classSide |	instanceSide := HelpTopic named: 'Instance side'.	classSide := HelpTopic named: 'Class side'.	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topicToBuild 		addSubtopic: instanceSide;		addSubtopic: classSide.	self buildMethodTopicsOn: instanceSide for: rootToBuildFrom.		self buildMethodTopicsOn: classSide for: rootToBuildFrom class.	! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForSubclasses	| topic |	rootToBuildFrom subclasses isEmpty ifTrue: [^self].	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topic := subclassesAsSeparateTopic 				ifTrue: [topicToBuild addSubtopic: (HelpTopic named: 'Subclasses')]				ifFalse: [topicToBuild ].	rootToBuildFrom subclasses 		do: [:subclass | topic addSubtopic: (self buildSubclassTopicFor: subclass)].	topic sortSubtopicsByTitle.	! !!ClassAPIHelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 16:37'!initialize	"Initializes the receiver"		super initialize.	addSubclasses := false.	addMethods := true.	subclassesAsSeparateTopic := true.! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic	^ subclassesAsSeparateTopic! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic: anObject	subclassesAsSeparateTopic := anObject! !!CustomHelpHelpBuilder methodsFor: 'building' stamp: 'tbn 3/6/2010 00:28'!build	"Start building a help topic from a code description"		topicToBuild := self createTopicFrom: rootToBuildFrom ! !!CustomHelpHelpBuilder methodsFor: 'private' stamp: 'tbn 3/8/2010 09:17'!createTopicFrom: aDescription	"Create a topic from a description stored on a class"		|topic page method pragma   |	topic := HelpTopic named: aDescription bookName.	topic key: aDescription key.	topic icon: aDescription icon.		aDescription pages do: [:pageSelector|		page := aDescription perform: pageSelector.	 		topic addSubtopic: page.	].		aDescription subclasses do: [:subclass |		topic subtopics add: subclass asHelpTopic ].	^topic! !!HelpBuilder class methodsFor: 'building' stamp: 'tbn 3/5/2010 23:25'!buildHelpTopicFrom: aHelpTopicDescription	"Start building from the given help topic description"		^(self new)		rootToBuildFrom: aHelpTopicDescription;		build;		topicToBuild ! !!HelpBuilder methodsFor: 'building' stamp: 'tbn 3/3/2010 22:55'!build	self subclassResponsibility ! !!HelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:12'!initialize 	"Initializes the receiver"		super initialize.	topicToBuild := self topicClass new.	 ! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:53'!rootToBuildFrom: anObject	rootToBuildFrom := anObject! !!HelpBuilder methodsFor: 'private accessing' stamp: 'tbn 3/5/2010 23:13'!topicClass	^HelpTopic! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:15'!topicToBuild	^topicToBuild! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!build 	|pTopic|	topicToBuild := (HelpTopic named: rootToBuildFrom bookName).	rootToBuildFrom packages do: [:package|		pTopic := HelpTopic named: package.		topicToBuild addSubtopic: pTopic.		self buildPackageTopic: pTopic.			]! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!buildPackageTopic: pTopic 	| classTopic classes |	classes := (PackageInfo named: pTopic title) classes asSortedCollection: [:cl1 :cl2 | cl1 name < cl2 name].	classes	   do: [:aClass| 		classTopic := ClassAPIHelpBuilder buildHierarchicalHelpTopicFrom: aClass withSubclasses: false withMethods: true.		pTopic addSubtopic: classTopic	]! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 23:53'!blankIcon	^Form extent: 12 @ 1 depth:8! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:17'!bookIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 284817913 552924404 0 0 0 0 0 0 0 0 0 817149108 3747766882 4287730065 2679749049 549766340 0 0 0 0 0 0 1086110908 4016202338 4287137928 4288914339 4288914339 4289111718 3216290996 1086505666 0 0 0 816754350 4014952271 4287137928 4289309097 4289769648 4289111718 4288453788 4288453788 4288453788 2947658161 0 814846353 4283782485 4287072135 4288059030 4288059030 4288387995 4289243304 4289309097 4287927444 4287598479 2411050421 1081900156 4283585106 4286611584 4287532686 4287532686 4287466893 4287466893 4287401100 4287401100 4287401100 4288716960 2946868645 3211290728 4288651167 4287269514 4287006342 4287006342 4287006342 4286940549 4286940549 4287203721 4289177511 3483213213 281725642 2677183122 4293190884 4292861919 4289177511 4286874756 4286611584 4286611584 4287006342 4289638062 4020084125 549042617 0 282054607 2677643673 4289572269 4293256677 4292796126 4288980132 4287137928 4290164406 4020215711 816754350 0 0 0 0 551082200 2677643673 4289572269 4293256677 4292401368 4289177511 1085584564 0 0 0 0 0 0 0 551213786 2677643673 4288651167 1623244992 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:54'!iconNamed: aSymbol	^self icons at: aSymbol ifAbsentPut: [self perform: aSymbol]! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:55'!icons	Icons isNil ifTrue: [Icons := Dictionary new].	^Icons! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/6/2010 01:23'!packageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 1075649821 3744937783 3208395836 807016986 0 0 0 0 0 0 537857807 2939368243 4283256141 4284045657 4284572001 4284111450 2671524924 269488144 0 0 0 2150575919 4014820685 4284111450 4284374622 4284769380 4285098345 4285295724 4286216826 4017057647 1883456323 0 1076505130 4283848278 4284769380 4284966759 4285624689 4285690482 4285887861 4286611584 4287269514 4287861651 4287269514 1074597133 1076965681 4283914071 4283848278 4285953654 4286216826 4286414205 4286940549 4287466893 4287335307 4286808963 4286743170 1074399754 1077163060 4284637794 4284045657 4284835173 4285887861 4287269514 4287335307 4286282619 4286216826 4286874756 4287006342 1074465547 1077294646 4284835173 4284703587 4285361517 4285624689 4286414205 4285624689 4286085240 4286677377 4287269514 4287401100 1074465547 1077426232 4285098345 4285032552 4286019447 4285822068 4286743170 4286348412 4286677377 4287203721 4287730065 4287795858 1074531340 1077492025 4285229931 4285427310 4286808963 4286216826 4287137928 4287072135 4287401100 4287795858 4288256409 4288190616 1074531340 269356558 2672051268 4285493103 4287598479 4286940549 4287532686 4287795858 4287993237 4288387995 4287006342 2404668500 268501249 0 0 1075912993 3479726184 4287598479 4287927444 4288453788 4287993237 2943118444 539371046 0 0 0 0 0 0 1615086660 4017781370 3749148535 1078347334 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:18'!pageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 221196079 1366981242 1366915449 1366915449 1366849656 1366783863 1128876361 33554432 0 0 0 0 726552142 4294309365 4294243572 4294111986 4294046193 4293914607 4292861919 2843705215 319885585 0 0 0 726551886 4294177779 4294111986 4293980400 4293914607 4293848814 4293717228 4292138196 3734147730 269619730 0 0 726486349 4294046193 4293980400 4293914607 4293783021 4293717228 4293585642 4293454056 4291085508 639705377 0 0 726420557 4293980400 4293848814 4293783021 4293651435 4293585642 4293519849 4293388263 4292993505 640034342 0 0 726420556 4293848814 4293717228 4293651435 4293585642 4293454056 4293388263 4293256677 4293190884 623322919 0 0 726354764 4293717228 4293651435 4293519849 4293454056 4293322470 4293256677 4293125091 4293059298 623257126 0 0 726354507 4293585642 4293519849 4293388263 4293322470 4293190884 4293125091 4293059298 4292993505 623191333 0 0 726288970 4293454056 4293388263 4293256677 4293190884 4293125091 4292993505 4292993505 4292993505 623191333 0 0 726223178 4293322470 4293256677 4293190884 4293059298 4292993505 4292993505 4292993505 4292993505 623191333 0 0 726223177 4293256677 4293125091 4293059298 4292993505 4292993505 4292993505 4292993505 4292993505 623191333 0 0 490092087 3080033685 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 454629657 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 00:47'!refreshIcon	^(Form		extent: 16@16		depth: 32		fromArray: #( 0 0 0 0 0 0 0 895969127 526080859 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1884706390 4168710521 2288675434 271330348 0 0 0 0 0 0 0 0 0 828465505 2609087363 3615917702 4269439610 4285887861 4285624689 3899156584 1766607948 67569415 0 0 0 0 0 50529027 2306242166 4237069452 4286940549 4286611584 4286282619 4285887861 4285558896 4285229931 4268189543 2235514687 0 0 0 0 0 2590862701 4287598479 4287269514 4270097540 3329652342 3312217196 4285887861 4285558896 3345179491 1011567435 0 0 0 0 0 1263423054 4287532686 4287532686 3867378563 1096835168 0 1885166941 3681579120 1549227863 50923785 0 0 0 0 0 0 3061545851 4287795858 4236937866 811951461 0 0 641547581 137441585 0 0 0 0 0 0 0 34936085 4102720138 4287795858 3011016824 0 0 0 0 0 0 0 0 0 0 0 0 272317243 4287861651 4287795858 2489607268 0 0 0 0 0 0 0 0 68095759 0 0 0 204682035 4287730065 4287795858 2658432116 0 0 0 0 0 0 0 34014983 3965146967 4283979864 3125694030 0 0 3767044232 4287795858 3884287365 137244206 0 0 0 0 0 0 1129863256 4284769380 4284506208 2739423304 0 0 2189459584 4287795858 4287532686 2541123190 16843009 0 0 0 0 305805882 3597166696 4284703587 4250885983 910114623 0 0 273698896 3834218889 4287532686 4287335307 3094442353 1094532413 101255433 286199567 1582124365 3731318631 4284966759 4284703587 2689946965 0 0 0 0 879126118 3985082247 4287269514 4286940549 4286611584 4285624689 4285558896 4285624689 4285229931 4284966759 3227212635 220998700 0 0 0 0 0 509698401 2977659771 4286743170 4286545791 4286282619 4285887861 4285558896 4100417383 2170116441 103295016 0 0 0 0 0 0 0 0 575820370 1734895720 2121298032 2037017194 1448564567 255013683 0 0 0 0 0)	offset: 0@0)! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!named: aString	"Create a new instance with given title and empty contents"		^(self new)		title: aString;		yourself! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle contents: aText	"Create a new instance with given title and content"		^(self new)		title: aTitle;		contents: aText;		yourself.		! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle icon: anIcon contents: aText	"Create a new instance with given title, icon and content"		^(self new)		title: aTitle;		icon: anIcon;		contents: aText;		yourself.		! !!HelpTopic methodsFor: 'comparing' stamp: 'tbn 3/8/2010 09:11'!<= anotherHelpTopic	"Use sorting by title as the default sort order"		^self title <= anotherHelpTopic title ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:40'!addSubtopic: aTopic	"Adds the given topic to the receivers collection of subtopics"		self subtopics add: aTopic.	^aTopic! !!HelpTopic methodsFor: 'conversion' stamp: 'tbn 3/8/2010 09:09'!asHelpTopic 	"Converts the receiver to a help topic"		^self! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents	"Returns the receivers contents"		^ contents! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents: anObject	"Sets the receivers contents to the given object" 			contents := anObject! !!HelpTopic methodsFor: 'defaults' stamp: 'tbn 3/5/2010 21:31'!defaultTitle	"Returns the receivers default title"		^'Unnamed Topic'	! !!HelpTopic methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:23'!hasSubtopics 	"Returns true if the receiver has subtopics, false otherwise"		^self subtopics notEmpty ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!icon  	"Returns the receivers icon"		^icon! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!icon: aSymbol	"Sets the receivers icon"		icon := aSymbol ! !!HelpTopic methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 08:44'!initialize 	"Initializes the receiver"		super initialize.	self title: self defaultTitle.	self contents: ''.	self key: '' ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key 		"Returns a unique key identifying the receiver in the help system"				^key! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key: aUniqueKey	"Sets a unique key identifying the receiver in the help system"				key := aUniqueKey ! !!HelpTopic methodsFor: 'operating' stamp: 'tbn 3/8/2010 09:12'!sortSubtopicsByTitle	"Sort the subtopics by title"		subtopics := SortedCollection withAll: self subtopics  ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:21'!subtopics 	"Returns the receivers list of subtopics"		subtopics isNil ifTrue: [subtopics := OrderedCollection new].	^subtopics! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!subtopics: aCollection 	"Sets the receivers subtopics"		subtopics := aCollection ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title	"Returns the receivers title"		^ title! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title: anObject	"Sets the receivers title"		title := anObject! !!SystemHelp class methodsFor: 'conversion' stamp: 'tbn 3/8/2010 08:52'!asHelpTopic 	|topic helpOnHelp sortedTopics |	topic := CustomHelp asHelpTopic.	topic sortSubtopicsByTitle.	helpOnHelp := topic subtopics detect: [:t | t key = 'HelpOnHelp'] ifNone: [self error: 'Help for the help system is removed'].	sortedTopics := topic subtopics.	sortedTopics remove: helpOnHelp.	sortedTopics addLast: helpOnHelp.	topic subtopics: sortedTopics.	^topic.! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:01'!all	"HelpBrowser openOn: self all "		^(ClassAPIHelpBuilder new)		rootToBuildFrom: ProtoObject;		addSubclasses: true;		addMethods: true;		subclassesAsSeparateTopic: false;		build;		topicToBuild 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:04'!asHelpTopic 	"HelpBrowser openOn: SystemReference"		^self hierarchyFor: ProtoObject 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/11/2010 23:41'!forClass: aClass	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := ClassAPIHelpBuilder buildHelpTopicFrom: aClass.	root addSubtopic: topic.	^root! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:21'!hierarchyFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: false;					subclassesAsSeparateTopic: false;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:23'!hierarchyWithMethodsFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: true;					subclassesAsSeparateTopic: true;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!Class methodsFor: '*HelpSystem-Core' stamp: 'tbn 3/11/2010 23:42'!asHelpTopic	^SystemReference forClass: self! !"HelpSystem-Core"!!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:33'!testDefaultBuilding	|topic|	topic := ClassAPIHelpBuilder 				buildHelpTopicFrom: Integer.				 	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:32'!testMethodsButNoSubclasses	|topic|	topic := ClassAPIHelpBuilder 				buildHierarchicalHelpTopicFrom: Integer 				withSubclasses: false 				withMethods: true.	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!HelpBrowserTest methodsFor: 'accessing' stamp: 'tbn 3/2/2010 23:21'!defaulTestClass	^HelpBrowser! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 3/2/2010 23:20'!testOpen	|block|	block := [		|browser|		browser := self defaulTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Exception		! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 4/8/2010 12:05'!testRegistration	"there is no world menu in 1.1."      HelpBrowser isPharo11 ifTrue: [^self].	TheWorldMenu registeredOpenCommands detect: [:each | each first = 'Help Browser'] ifNone: [self fail].	! !!HelpIconsTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:23'!defaultTestClass 	^HelpIcons! !!HelpIconsTest methodsFor: 'testing' stamp: 'tbn 3/3/2010 00:50'!testIconCaching	 	| first second |	#(bookIcon pageIcon refreshIcon) do: [:iconSymbol |		first := self defaultTestClass iconNamed: iconSymbol.		second := self defaultTestClass iconNamed: iconSymbol.			self assert: first notNil.		self assert: first == second.	]	! !!HelpTopicListItemWrapperTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 13:16'!defaultTestClass 	^HelpTopicListItemWrapper 	! !!HelpTopicListItemWrapperTest methodsFor: 'testing' stamp: 'tbn 3/5/2010 21:46'!testDisplayLabel	|instance|	instance := self defaultTestClass with: (HelpTopic named: 'My Topic').	self assert: instance asString = 'My Topic'	! !!HelpTopicTest methodsFor: 'accessing' stamp: 'tbn 3/5/2010 21:47'!defaultTestClass	^HelpTopic ! !!HelpTopicTest methodsFor: 'running' stamp: 'tbn 3/5/2010 21:49'!setUp	super setUp.	topic := self defaultTestClass new.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:44'!testAddingSubtopic	|subtopic returned|	subtopic := self defaultTestClass named: 'Subtopic'.	returned := topic addSubtopic: subtopic.	self assert: returned == subtopic.	self assert: (topic subtopics includes: subtopic) ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:07'!testInitialization	self assert: topic title = 'Unnamed Topic'.	self assert: topic key isEmpty.	self assert: topic contents isEmpty ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testInstanceCreation	|instance|	instance := self defaultTestClass named: 'My Topic'.	self assert: instance title = 'My Topic'.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testSortOrder	|a b c sorted |	a := self defaultTestClass named: 'A'.	b := self defaultTestClass named: 'B'.	c := self defaultTestClass named: 'C'.	sorted := (OrderedCollection with: b with: c with: a) asSortedCollection.	self assert: sorted first = a.	self assert: sorted last = c.	! !"HelpSystem-Tests"!!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:11'!bookName 	^'Squeak'! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:30'!icon	(self name = #SqueakHelp) ifTrue: [^HelpIcons iconNamed: #squeakIcon].	^nil! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:16'!bookName 	^'License'! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'hjh 4/29/2010 16:48'!licenseChange	^HelpTopic 		title: 'License has changed with 4.0'		contents: 'On 23 September 1996, Apple Computer Inc. released Squeak V1.1 under the "Squeak License" (SqL).On May 8, 2006 Apple agreed to relicense original Squeak V1.1 under the Apple Public Source License.On October 12, 2006 Apple granted permission to relicense under Apache license 2.0.In 2006, VPRI began to collect "Distribution Agreements" for all contributors to Squeak since V1.1 up to V3.8, asking them to relicense their contributions, which were originally licensed under SqL, to the MIT license. This was a great effort on behalf of many and VPRI has 100s of signed documents agreeing to this.Do you want to contribute source to Squeak?All new contributions since 4.0 must be under the MIT license. When you make your code available, please state explicitly in some form such as the description on a web site or email announcement that your contribution is under the MIT license. (It doesn''t have to be exclusive; you can release it under difference licenses at the same time.)Have you contributed source to Squeak? If you believe you have, but have not sent in an agreement to allow your submission(s) to be licensed under the MIT license then please see http://netjam.org/squeak/contributors. There you can find a list of known contributors and a PDF of the agreement with instructions. The snail mail address is found in the agreement PDF file.Also there are a few people for which we are lacking full contact information. If you think you can help please also visit the link above and see if you can identify any of the unknown developer initials or any of the developers for whom we do not have a current email address.' ! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'mha 5/2/2010 17:35'!officialLicense	^HelpTopic 		title: 'Official License - 4.0'		contents: 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2010 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'mha 5/2/2010 17:26'!pages	^#(licenseChange officialLicense)! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:13'!bookName 	^'Squeak Project'! !!SqueakProjectHelp class methodsFor: 'pages' stamp: 'tbn 3/5/2010 22:01'!introduction	^HelpTopic		title: 'Welcome'		icon: (HelpIcons iconNamed: #squeakIcon)		contents:'WELCOMESqueak is a modern, open source, full-featured implementation of the powerful Smalltalk programming language and environment. Squeak is highly-portable - even its virtual machine is written entirely in Smalltalk making it easy to debug, analyze, and change. Squeak is the vehicle for a wide range of projects from multimedia applications, educational platforms to commercial web application development.'! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:15'!pages	^#(introduction )! !!HelpIcons class methodsFor: '*help-squeak-project' stamp: 'mha 5/2/2010 20:58'!squeakIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 75398782 26843545 0 0 1159996452 1378823983 338044454 0 0 0 0 455682345 1295266868 1126376227 0 0 1040582150 0 1328097577 0 0 0 23488102 1277502757 0 1076834095 0 0 1075781407 0 287647013 472854319 0 0 471472666 204089898 0 1092756002 0 0 1041963803 36909875 0 1880232466 454761243 287515427 1342572038 0 104939841 974460181 0 0 270080281 354690084 86846765 3674539269 1394219546 1611599631 3557427722 86123042 388244516 204287277 0 26843545 605558808 1025055001 1008014613 1159141143 522264865 739710743 1159141143 571083274 570820102 188891714 0 942550574 1411391520 1143021857 1312241463 1428563494 3205040393 3708159494 1663576104 1511067921 1579887403 1629758500 958472481 656679972 439563059 1294608938 839913488 739644950 172246084 221459251 840900383 1075978786 1209933342 724512559 707077413 0 0 0 0 0 0 0 0 0 0 38488907 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !"Help-Squeak-Project"!!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtFirst	"Add new empty slots to the front of array, while keeping the empty slots at the end."	| newArray newFirstIndex newLastIndex |	newArray := Array new: (array size * 2 max: 1).	newFirstIndex := newArray size - array size + firstIndex.	newLastIndex := newFirstIndex + lastIndex - firstIndex.	newArray 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array := newArray.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtLast	"Add new empty slots to the end of array, while keeping the empty slots at the front."	| newArray |	newArray := Array new: (array size * 2 max: 1).	newArray 		replaceFrom: firstIndex		to: lastIndex		with: array		startingAt: firstIndex.	array := newArray! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42' prior: 25258393!makeRoomAtFirst	"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= array size ifTrue: [ ^self growAtFirst ].	tally = 0 ifTrue: [ ^self resetTo: array size + 1 ].	newFirstIndex := array size // 2 + 1.	newLastIndex := newFirstIndex - firstIndex + lastIndex.	0 to: tally - 1 do: [ :offset |		array at: newLastIndex - offset put: (array at: lastIndex - offset) ].	array from: firstIndex to: newFirstIndex - 1 put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42' prior: 25258899!makeRoomAtLast	"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].	tally = 0 ifTrue: [ ^self resetTo: 1 ].	newLastIndex := lastIndex // 2.	newFirstIndex := newLastIndex - lastIndex + firstIndex.	array 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array from: newLastIndex + 1 to: lastIndex put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:20' prior: 25259891!reset	self resetTo: 1! !!Collection methodsFor: 'enumerating' stamp: 'ar 5/4/2010 08:40'!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	| first nextValue |	self emptyCheck.	first := true.	self do:[:each|		first ifTrue:[nextValue := each. first := false]			ifFalse:[nextValue := binaryBlock value: nextValue value: each]].	^nextValue! !!Collection methodsFor: 'math functions' stamp: 'ar 5/4/2010 08:38' prior: 18835941!sum	"Compute the sum of all the elements in the receiver"	^self reduce:[:a :b| a + b]! !OrderedCollection removeSelector: #growSize!OrderedCollection removeSelector: #grow!"Collections"!!WeakSetTest methodsFor: 'tests' stamp: 'ul 5/3/2010 20:13'!testDoAfter	| input weakSet array |	input := (1 to: 11) collect: [ :each | each asString asSymbol ]. "Some symbols might be garbage collected without this variable"	weakSet := WeakSet withAll: input.	array := weakSet asArray. "Assume that the elements will have the same order as the internal array of the weakset"	0 to: array size do: [ :index |		| element result |		element := array at: index ifAbsent: nil.		result := Array new: weakSet size - index streamContents: [ :stream |			weakSet				do: [ :each | stream nextPut: each ]				after: element ].		self assert: result sort = (array allButFirst: index) sort ]! !!WeakSetTest methodsFor: 'tests' stamp: 'ul 11/20/2009 22:53' prior: 53697582!testIncludes	| weakSet transientFakeNilObject |	weakSet := WeakSet new.	#(true nil 1) do: [ :each |		self deny: (weakSet includes: each) ].	weakSet add: true.	self assert: (weakSet includes: true).	weakSet remove: true.	self deny: (weakSet includes: true).	transientFakeNilObject := ((1 to: 1000) detect: [ :each | each asString hash - nil hash \\ weakSet capacity = 0 ]) asString. "this string will occupy the same slot as nil would"	weakSet add: transientFakeNilObject.	transientFakeNilObject := transientFakeNilObject copy.	Smalltalk garbageCollect. "get rid of transientFakeNilObject"	self deny: (weakSet includes: transientFakeNilObject).	self deny: (weakSet includes: nil)			! !!CollectionTest methodsFor: 'tests' stamp: 'ar 5/4/2010 08:52'!testReduce	"self run: #testReduce"	| array set bag |	array := Array with: 1 with: 2 with: 3.	self assert: (array reduce:[:a :b| a + b]) = 6.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = 6.	array := Array with: Color red with: Color green with: Color blue.	self assert: (array reduce:[:a :b| a + b]) = Color white.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = Color white.	array := Array with: 1 with: 1 with: 1.	self assert: (array reduce:[:a :b| a + b]) = 3.	bag := array asBag.	self assert: (bag reduce:[:a :b| a + b]) = 3.! !!WeakFinalizersTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 22:15'!testNewFinalizationSupported	| list item |	list := WeakFinalizationList new.			item := WeakFinalizerItem new list: list object: Object new executor: nil.		self assert: (list first isNil).	self assert: (item object notNil).		Smalltalk garbageCollect.		self assert: (item object isNil).	self assert: (list first == item).	self assert: (list first next == nil).! !"CollectionsTests"!!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'topa 5/3/2010 11:26' prior: 54545818!refresh	| packageNames |	packageNames := Set new.	packageList := nil.	versions := repository readableFileNames collect: [ :each | | name |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each | | latest |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor | | av |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:32'!definitionAndCommentString	^ String streamContents: [:stream |		self printDefinitionOn: stream.		stream cr; cr.		self printCommentOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 21:36'!printCommentOn: stream	stream		nextPut: $";		nextPutAll: self comment asString;		nextPut: $"! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:33' prior: 22807306!source	^ self definitionAndCommentString! !"Monticello"!!Categorizer commentStamp: 'nice 5/6/2010 21:10' prior: 0!A Categorizer goal is to classify the elements of a collection into categories.It is typically used to classify methods of class into categories (also named protocols in this case).Instance Variables	categoryArray:		<SequenceableCollection of: Object>	categoryStops:		<SequenceableCollection of: Integer>	elementArray:		<SequenceableCollection of: Object>categoryArray	- holds the list of categories.	A category could be any Object but is generally a String or Symbol.	Categories should be unique (categoryArray asSet size = categoryArray size)categoryStops	- holds the index of last element belonging to each category.	There should be a category stop for each category (categoryStops size = categoryArray size).	The categoryStops should be sorted (categoryStops sorted = categoryStops).	A category stop equal to its predecessor (= 0 for the first category stop) denotes an empty category.elementArray	- holds the elements to be classified. The elements are sorted by category.Class variables	Default is the default category used to classify yet unclassified methods of a class	NullCategory is the category to be displayed in a Browser for a class having no method.!!NumberParser methodsFor: 'parsing-public' stamp: 'nice 4/2/2010 20:25' prior: 57942725!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!Number methodsFor: 'truncation and round off' stamp: 'wiz 3/1/2007 20:17'!roundDownTo: aNumber 	"Answer the next multiple of aNumber toward negative infinity that is nearest the 	receiver."	^(self/aNumber) floor * aNumber! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/24/2010 02:51' prior: 57953109!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [					sourceStream skip: -1.					^ self expected: 'an integer greater than 1 as valid radix'].			self peekSignIsMinus				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !"Kernel"!!Encoder methodsFor: 'encoding' stamp: 'eem 5/16/2010 17:33' prior: 33688294!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable					at: name					ifAbsent: 						[(self lookupInPools: name 							ifFound: [:assoc | varNode := self global: assoc name: name])							ifTrue: [varNode]							ifFalse: [^action value]].	range ifNotNil:		[name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]].	(varNode isTemp and: [varNode scope < 0]) ifTrue:		[^OutOfScopeNotification signal			ifTrue: [action value]			ifFalse: [self notify: 'out of scope']].	^varNode! !!LiteralVariableNode methodsFor: 'testing' stamp: 'eem 5/20/2010 09:12'!assignmentCheck: encoder at: location	^(key isVariableBinding and: [key canAssign not])		ifTrue: [location]		ifFalse: [-1]! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2010 08:55' prior: 51566743!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !"Compiler"!!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!isolatedCodePaneForClass: aClass selector: aSelector	"Answer a MethodMorph on the given class and selector"	| aCodePane aMethodHolder |	aMethodHolder := self new.	aMethodHolder methodClass: aClass methodSelector: aSelector.	aCodePane := MethodMorph on: aMethodHolder text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aMethodHolder addDependent: aCodePane.	aCodePane borderWidth: 2; color: Color white.	aCodePane scrollBarOnLeft: false.	aCodePane width: 300.	^ aCodePane! !!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!makeIsolatedCodePaneForClass: aClass selector: aSelector	"Create, and place in the morphic Hand, an isolated code pane bearing source code for the given class and selector"	(self isolatedCodePaneForClass: aClass selector: aSelector) openInHand! !"EToys"!!CharacterBlock commentStamp: 'mtf 5/15/2010 12:44' prior: 18447774!I describe the location of one character displayed on the screen. My instances are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the information I store stale.text (Text): The text where my character is fromstringIndex (Integer): The index of my character in the text, starting from 1textLine (TextLine): The displayed line my character is onorigin (Point): The top-left corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0corner (Point): The bottom-right corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0!"Graphics"!!MCMcmWriter commentStamp: 'dtl 5/10/2010 22:20' prior: 0!An MCMcmWriter stores an MCConfiguration on a stream in the form of an array specification.!!MCConfiguration commentStamp: 'dtl 5/10/2010 23:03' prior: 0!An MCConfiguration specifies the configuration of a set of related Monticello packages. It maintains an ordered list of package versions and a list of repositories in which the packages may be found.An MCConfiguration may be filed out for storage as an array specification, and new instances can be created from a stored array specification.!!MCMcmUpdater commentStamp: 'dtl 5/10/2010 23:22' prior: 0!MCMcmUpdater provides utility methods for updating Monticello packages from Monticello configurations.When Monticello configurations are stored in a repository, MCMcmUpdater acts as an update stream. It first ensures that each configuration map has been loaded in sequence, then updates the last configuration map to the most recent version for each specified package, and finally loads these versions to produce a fully updated configuration. !!MCConfigurationBrowser commentStamp: 'dtl 5/10/2010 21:48' prior: 0!A MCConfigurationBrowser displays an MCConfiguration, and edits the configuration to add or remove package dependencies and repository specifications. It allows a configuration to be stored in a repository or posted to an update stream.!!MCMcmReader commentStamp: 'dtl 5/10/2010 22:22' prior: 0!A MCMcmReader creates an MCConfiguration by reading an array specification from a stream.!!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 21:11' prior: 22854648!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'dtl 5/10/2010 21:01'!removeRepository	repositoryIndex > 0		ifTrue: [self repositories removeAt: repositoryIndex.			repositoryIndex := 0.			self changed: #repositoryList]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 20:56' prior: 22856503!repositoryMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add repository...' addRepository)).	self selectedRepository ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove repository' removeRepository))].	^aMenu! !"MonticelloConfigurations"!!Project commentStamp: 'tk 12/2/2004 12:38' prior: 59386593!A Project stores the state of a complete Squeak desktop, includingthe windows, and the currently active changeSet.  A project knows whoits parent project is.  When you change projects, whether by enteringor exiting, the screen state of the project being exited is saved inthat project.A project is retained by its view in the parent world.  It iseffectively named by the name of its changeSet, which can be changedeither by renaming in a changeSorter, or by editing the label of itsview from the parent project.As the site of major context switch, Projects are the locus ofswapping between the old MVC and the new Morphic worlds.  Thedistinction is based on whether the variable 'world' contains aWorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Projectnamed: 'xxx') exportSegment, or choose 'store project on file...'.Projects may be loaded from a server and stored back.  Storing on aserver never overwrites;  it always makes a new version.  A projectremembers the url of where it lives in urlList.  The list is lengthone, for now.  The url may point to a local disk instead of a server.All projects that the user looks at, are cached in the Squeakletfolder.  Sorted by server.  The cache holds the most recent versiononly.When a project is loaded into Squeak, its objects are converted tothe current version.  There are three levels of conversion.  First,each object is converted from raw bits to an object in its oldformat.  Then it is sent some or all of these messages:	comeFullyUpOnReload: smartRefStream  		Used tore-discover an object that already exists in this image, such as aresource, global variable, Character, or Symbol.  (sent to objects inoutPointers)	convertToCurrentVersion: varDict refStream: smartRefStrm		fill in fields that have been added to a class sincethe object was stored.  Used to set the extra inst var to a defaultvalue.  Or, return a new object of a different class.  (sent toobjects that changed instance variables)	fixUponLoad: aProject refStream: smartRefStrm	change the object due to conventions that have changed on theproject level.  (sent to all objects in the incoming project)Here is the calling sequence for storing out a Project:Project saveAsProject storeOnServerProject storeOnServerWithProgressInfoProject storeOnServerInnardsProject exportSegmentFileName:directory:Project exportSegmentWithChangeSet:fileName:directory:ImageSegment writeForExportWithSources:inDirectory:changeSet:---------Isolation (not used any more)When you accept a method, the entire system feels the change, exceptprojects that are "isolated".  In an isolated project, all new globalvariables (including new classes) arestored in the project-localenvironment, and all changes to preexisting classes are revoked whenyou leave the project.  When you enter another project, thatproject's changes are invoked.  Invocation and revocation are handledefficiently by swapping pointers.  To make a project be isolated,choose 'isolate changes of this project' from the 'changes...'section of the screen menu.  You can use an isolated project formaking dangerous change to a system, and you can get out if itcrashes.  A foreign application can have the separate environment itwants.  Also, you can freeze part of the system for a demo that youdon't want to disturb.  An isolated project shares methods with allsubprojects inside it, unless they are isolated themselves.   Eachisolated project is the head of a tree of projects with which itshares all methods.You may 'assert' all changes ever made in the current project to takeeffect above this project.  This amounts to exporting all the globalsin the current environment, and zapping the revocation lists to thatthe current state of the world will remain in force upon exit fromthis project.[Later: A project may be 'frozen'.  Asserts do not apply to it afterthat.  (Great for demos.)  You should be informed when an assert wasblocked in a frozen project.]Class definitions are layered by the isolation mechanism.  You areonly allowed to change the shape of a class in projects that liewithin its isolation scope.  All versions of the methods arerecompiled, in all projects.  If you remove an inst var that is inuse in an isolated project, it will become an Undeclared global.  Itis best not to remove an inst var when it is being used in anotherisolated project. [If we recompile them all, why can't we diagnosethe problem before allowing the change??]Senders and Implementors do not see versions of a method in isolatedprojects.  [again, we might want to make this possible at a cost].When you ask for versions of a method, you will not get the historyin other isolated projects.Moving methods and classes between changeSets, and merging changeSetshas no effect on which methods are in force.  But, when you look at achangeSet from a different isolated project, the methods will containcode that is not in force.  A changeSet is just a list of methodnames, and does not keep separate copies of any code.When finer grained assertion is needed, use the method (aProjectassertClass: aClass from: thisProject warn: warnConflicts).How isolated changes work: The first time a class changes, store itsMethodDictionary object.  Keep parallel arrays of associations toClasses and MethodDictionaries.  Traverse these and install them whenyou enter an "ioslated project".  When you leave, store thisproject's own MethodDictionaries there.	To do an assert, we must discover which methods changed here,and which changed only in the project we are asserting into.  Thereis one copy of the 'virgin' method dictionaries in the system.  It isalways being temporarily stored by the currently inForce isolatedproject.isolatedHead - true for the top project, and for each isolatedproject.  false or nil for any subproject that shares all methodswith its parent project.inForce -  true if my methods are installed now.  false if I amdormant. [is this equivalent to self == Project Current?]classArray - list of associations to classesmethodDictArray - the method dictionaries of those classes before westarted changing methods.  They hang onto the originalcompiledMethods.  (If this project is dormant, it contains the methoddictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - No longer used.When you want to save a project in export format from within thatvery project, it gets tricky.  We set two flags in parentProject,exit to it, and let parentProject write the project.ProjectViewMorph in parentProject checks in its step method, does thestore, clears the flags, and reenters the subProject.!!Utilities class methodsFor: 'support windows' stamp: 'spd 5/24/2010 20:23' prior: 32903560!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 10000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.Preferences editAnnotations.Flaps reinstateDefaultFlaps. Preferences resetCategoryInfo(FileStream oldFileNamed: 'Lives of the Wolves') edit.(FileStream oldFileNamed: 'tuesdayFixes.cs') fileInChangeList browseFile: 'myChanges.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode in mvc""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspect.Utilities storeTextWindowContentsToFileNamed: 'TextWindows'Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'ScriptingSystem resetStandardPartsBin.ScheduledControllers screenController openMorphicConstructionWorld.ScheduledControllers screenController openMorphicWorld.SystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[SystemNavigation default allCallsOn: #asOop].MessageTally spyOn: [SystemNavigation default allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: 'fetching updates' stamp: 'ar 5/7/2010 20:50' prior: 59191674!updateFromServer	"Update the image by loading all pending updates from the server."	| config |	"Flush all caches. If a previous download failed this is often helpful"	MCFileBasedRepository flushAllCaches.	config := MCMcmUpdater updateFromDefaultRepository.	config ifNil: [^self inform: 'Unable to retrieve updates from remote repository.' translated].	self setSystemVersionFromConfig: config.	self inform: ('Update completed.Current update number: ' translated, SystemVersion current highestUpdate).! !!Project methodsFor: 'menu messages' stamp: 'cbr 5/1/2010 01:53'!toggleFullScreen	"Toggle between full screen and windowed mode."	self lastScreenModeSelected		ifTrue: [ self fullScreenOff ]		ifFalse: [ self fullScreenOn ]! !!Project methodsFor: 'accessing' stamp: 'dtl 5/2/2010 19:09'!uiManager	"Answer the manager that provides user interface services for this project "	^ uiManager		ifNil: [uiManager := Smalltalk						at: #UIManager						ifPresent: [:mgr | uiManager := mgr getDefault]]! !!Preferences class methodsFor: 'initialization' stamp: 'ul 5/22/2010 01:34' prior: 26889133!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class 		compileSilently: (			'{1} ^self valueOfFlag: {2} ifAbsent: [ {3} ]'				format: {					aPreference name asString.					aPreference name asSymbol printString.					aPreference defaultValue storeString }) 		classified: '*autogenerated - standard queries'! !!Preferences class methodsFor: 'personalization' stamp: 'ul 5/22/2010 01:33' prior: 26916280!compileHardCodedPref: prefName enable: aBoolean	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"	self class 		compileSilently: (			'{1} ^{2}'				format: {					prefName asString.					aBoolean storeString })		classified: '*autogenerated - hard-coded prefs'.	"Preferences compileHardCodedPref: #testing enable: false"! !!SystemOrganizer class methodsFor: 'class initialization' stamp: 'spd 5/19/2010 15:54'!default	"I have a global instance, SystemOrganization.  In case someone stumbles upon my class, and does not know about the global, it can be accessed from here, too."  ^ SystemOrganization.! !Preferences class removeSelector: #useFormsInPaintBox!"System"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'dcorking 5/6/2010 13:59' prior: 33713033!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WASqueakServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 29 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'cbr 5/1/2010 01:47' prior: 53728504!projectsMenuOn: aDockingBar	aDockingBar addItem: [ :item |		item			contents: 'Projects' translated;			addSubMenu: [ :menu | 				self					newProjectMenuItemOn: menu;					saveProjectMenuItemOn: menu;					loadProjectMenuItemOn: menu;					previousProjectMenuItemOn: menu;					jumpToProjectMenuItemOn: menu;					toggleFullScreenMenuItemOn: menu ] ]! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'spd 5/24/2010 19:19' prior: 59199720!squeakUserInterface	^'The Squeak UI has some unusual elements that you may not have seen before.  Here is a brief introduction to those elements:ProjectsA project is an entire Squeak desktop full of windows.  Projects can be used to change quickly from one task to another.  An inactive project is represented by a project window, which shows a thumbnail of its state.  Project windows are actually more like doors than windows, since you can enter the project just by clicking on them.  You can create a new project by choosing ''open...project'' from the screen menu.  To exit a project (and return to its parent project), choose ''previous project'' from the screen menu.  Each project maintains its own set of windows and other information.Morphic HalosIn a morphic project, pressing cmd-click (Mac) or alt-click (Windows) on a graphical object (e.g. a window) will surround it with a constellation of colored circles.  These are called "halo handles."  Additional clicks will cycle through the halos for the other graphical objects in the nesting structure.  If you hold down the Shift key while cmd/alt-clicking, the nested morphs will be traversed from innermost outward.  Clicking without the cmd/alt key will dismiss the halo.  While the halo is up, letting the cursor linger over one of the halo handles for a few seconds will cause a balloon to pop up with the name of that handle.  Three useful handles are the top-left "X" handle (delete), the bottom-right yellow handle (resize), and the brown handle (slide the object within its containing object).  Halos allow complex graphical objects to be explored - or even disassembled (using the black halo handle).  Usually no harm results from taking apart an object; you can just discard the pieces and create a new one.FlapsTo enable Flaps, click on the desktop to show the world menu, choose the "Flaps..." menu and "show shared tags". Tabs labeled "Squeak", "Tools", "Supplies", etc., will appear along the edges of the Squeak desktop.  Click on any tab to open the corresponding flap.  Drag a tab to resize the flap and to relocate the tab.  Bring up the halo on any tab and click on its menu handle to be presented with many options relating to the flap.  Use the "Flaps..." menu, reached via the desktop menu, to control which flaps are visible and for other flap-related options and assistance.Parts BinsYou can obtain new objects in many ways.  The "Objects Catalog" (choose "objects'' from the world menu or open the objects flap) and several of the standard flaps (e.g. "Tools" and "Supplies") serve as "Parts Bins" the for new objects.  Drag any icon you see in a Parts Bin and a fresh copy of the kind of object it represents will appear "in your hand"; click to deposit the new object anywhere you wish.  You can also add your own objects to any of the flaps - just drag your object over the tab, wait for the flap to pop open, then drop the object at the desired position in the flap.!!]style[(123 9 663 13 991 5 579 10 589),bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'cbr 5/1/2010 01:42'!toggleFullScreenMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Toggle Full Screen' translated;			help: 'Switch back and forth from full screen mode' translated;			icon: MenuIcons smallFullScreenIcon;			target: Project current;			selector: #toggleFullScreen ]! !"Morphic"!!HierarchicalUrl methodsFor: 'printing' stamp: 'topa 5/5/2010 13:47' prior: 21557419!printOn: aStream	aStream nextPutAll: self schemeName.	aStream nextPutAll: '://'.	self username ifNotNil: [		aStream nextPutAll: self username encodeForHTTP.		self password ifNotNil: [			aStream nextPutAll: ':'.			aStream nextPutAll: self password encodeForHTTP].		aStream nextPutAll: '@' ].	aStream nextPutAll: self authority.	port ifNotNil: [aStream nextPut: $:; print: port].	path do: [ :pathElem |		aStream nextPut: $/.		aStream nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		aStream nextPut: $?.		aStream nextPutAll: self query. ].	self fragment isNil ifFalse: [		aStream nextPut: $#.		aStream nextPutAll: self fragment encodeForHTTP. ].! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'topa 5/4/2010 14:30' prior: 51344189!privateInitializeFromText: aString 	| remainder ind specifiedSchemeName |	remainder := aString.	schemeName ifNil: 			[specifiedSchemeName := Url schemeNameForString: remainder.			specifiedSchemeName ifNotNil: 					[schemeName := specifiedSchemeName.					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].			schemeName ifNil: 					["assume HTTP"					schemeName := 'http']].	"remove leading // if it's there"	(remainder beginsWith: '//') 		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].	"get the query"	ind := remainder indexOf: $?.	ind > 0 		ifTrue: 			[query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the authority"	ind := remainder indexOf: $/.	ind > 0 		ifTrue: 			[ind = 1 				ifTrue: [authority := '']				ifFalse: 					[authority := remainder copyFrom: 1 to: ind - 1.					remainder := remainder copyFrom: ind + 1 to: remainder size]]		ifFalse: 			[authority := remainder.			remainder := ''].	"extract the username+password"	(authority includes: $@) 		ifTrue: 			[username := authority copyUpTo: $@.			authority := authority copyFrom: (authority indexOf: $@) + 1						to: authority size.			(username includes: $:) 				ifTrue: 					[password := (username copyFrom: (username indexOf: $:) + 1 to: username size) unescapePercents.					username := username copyUpTo: $:].			username := username unescapePercents].	"Extract the port"	(authority includes: $:) 		ifTrue: 			[| lastColonIndex portString |			lastColonIndex := authority findLast: [:c | c = $:].			portString := authority copyFrom: lastColonIndex + 1 to: authority size.			portString isAllDigits 				ifTrue: 					[port := Integer readFromString: portString.					(port > 65535) ifTrue: [self error: 'Invalid port number'].					 authority := authority copyFrom: 1 to: lastColonIndex - 1]				ifFalse:[self error: 'Invalid port number']].	"get the path"	path := self privateParsePath: remainder relativeTo: #() .! !"Network"!!UrlTest methodsFor: 'tests' stamp: 'topa 5/4/2010 14:33'!testUsernamePasswordEncoded	"Sometimes, weird usernames or passwords are necessary in 	applications, and, thus, we might receive them in a Url.	The @ and the : ar the kind of critical ones.	"	#(	"('user' 'pword' 'host' port 'path')"		('Fürst Pückler' 'leckerEis' 'cottbus.brandenburg' 80 'mein/Zuhause')		('Jeannde.d''Arc' 'jaiunesécret' 'orleans' 8080 'une/deux/trois')		('HaXor@roxor:fnac' 'my~Pa$§wert' 'cbase' 42 'do/not_try')	) do: [:urlParts | |theUrl|		theUrl := ('http://{1}:{2}@{3}:{4}/{5}' format: {			(urlParts at: 1) encodeForHTTP. 	(urlParts at: 2) encodeForHTTP.			urlParts at: 3. urlParts at: 4. urlParts at: 5.		}) asUrl.		self 			should: [theUrl schemeName = 'http'];			should: [theUrl username = (urlParts at: 1)];			should: [theUrl password = (urlParts at: 2)];			should: [theUrl authority = (urlParts at: 3)];			should: [theUrl port = (urlParts at: 4)];			should: [theUrl path first = ((urlParts at: 5) copyUpTo: $/)]].! !!UrlTest methodsFor: 'tests' stamp: 'topa 5/5/2010 13:50'!testUsernamePasswordPrintingEncoded	#(	'http://F%C3%BCrst%20P%C3%BCckler:leckerEis@cottbus.brandenburg:80/mein/Zuhause'		'http://Jeannde.d%27Arc:jaiunes%C3%A9cret@orleans:8080/une/deux/trois' 		'http://HaXor%40roxor%3Afnac:my%7EPa%24%C2%A7wert@cbase:42/do/not_try'	) do: [ :urlText |		self should: [ urlText = urlText asUrl asString ] ].! !"NetworkTests"!!SMLoader class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56' prior: 27945877!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[self new createWindow; applyModelExtent; yourself]		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56' prior: 33589283!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[(ToolBuilder open: self new) applyModelExtent; yourself] 		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !"SMLoader"!!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:26'!testTestTimeout	self should:[(Delay forSeconds: 6) wait] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:43'!testTestTimeoutLoop	<timeout: 1>	self should:[[true] whileTrue.] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:25'!testTestTimeoutTag	<timeout: 1>	self should:[(Delay forSeconds: 3) wait] raise: TestFailure.! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:26'!defaultTimeout	"Answer the default timeout to use for tests in this test case.	The timeout is a value in seconds."	^5 "seconds"! !!TestCase methodsFor: 'running' stamp: 'ar 5/11/2010 19:58' prior: 31103806!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout:[		self setUp.		self performTest	] after: self timeoutForTest] ensure:[self tearDown].! !!TestCase methodsFor: 'running' stamp: 'ar 5/12/2010 19:33'!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:44'!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^self defaultTimeout! !"SUnit"!!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingColors	"self run: #testSummingColors"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each) sum = each) 	].! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingToTen	"self run: #testSummingToTen"	| cases |	cases :={ 		{ 1 . 2 . 3 . 4 }.		{ 2.0 . 2.0 . 2.0 . 2.0 . 2.0  }.		{ 2/5 . 5/2 . 5/2 . 3/5 . 4 } 	} .	cases do: [ :each |		self assert: (each  sum = 10 )	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:43'!testSummingToWhite	"self run: #testSummingToWhite"	| cases |	cases := { 		{ Color black . Color white }.		{ Color red . Color green. Color blue }.		{ Color gray . Color gray }.		{ Color cyan. Color magenta. Color yellow }.		{ Color cyan. Color magenta.  }.		{  Color magenta. Color yellow }.		{ Color cyan.  Color yellow }.		{ Color cyan. Color red }.		{ Color green .Color magenta.  }.		{ Color blue. Color yellow }.	} .	cases do: [ :each |		self assert: (each  sum = Color white) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:44'!testSummingWithBlack	"self run: #testSummingWithBlack"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each with: Color black) sum = each) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:45'!testSummingWithWhite	"self run: #testSummingWithWhite"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	} .	cases do: [ :each |		self assert: ((Array with: Color white with: each ) sum = Color white) 	] .! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalDirectly	"	SystemOrganizerTest run: #testAccessGlobalDirectly	"		self assert: (SystemOrganization isKindOf: SystemOrganizer).					"It really lives in Smalltalk (another global)"	self assert: ((Smalltalk at: #SystemOrganization) == SystemOrganization).! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalThroughClass	"	SystemOrganizerTest run: #testAccessGlobalThroughClass	"			"In case someone stumbles upon the SystemOrganizer class, and does not know	about the SystemNavigation global, it can be accessed from there, too."	self assert: (SystemOrganizer default == SystemOrganization).! !!ClosureTests methodsFor: 'testing-while' stamp: 'eem 5/22/2010 09:35'!testWhileWithTempIsNil	| index |	index := 0.	[ index < 5 ] whileTrue: [		| temp |		collection add: temp.		temp := index := index + 1. 		collection add: temp].	self assertValues: #(nil 1 nil 2 nil 3 nil 4 nil 5)! !!LocaleTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:24' prior: 57142788!testLocaleChanged	"self debug: #testLocaleChanged"	"LanguageEnvironment >> startUp is called from Prject >> localeChanged"	<timeout: 60> "takes quite a while"	Project current updateLocaleDependents.	self assert: (ActiveHand instVarNamed: 'keyboardInterpreter') isNil.	self assert: (Clipboard default instVarNamed: 'interpreter') isNil.	Locale switchToID: (LocaleID isoLanguage: 'ja').	self assert: Preferences useFormsInPaintBox.	Locale switchToID: (LocaleID isoLanguage: 'en').	self assert: Preferences useFormsInPaintBox not.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:54' prior: 57220949!testDoubleRepeatedMerge	| base motherA1 motherA2 motherB1 motherB2 inst |	<timeout: 30> "takes a little longer"	base := self snapshot.	self change: #a toReturn: 'a1'.	motherA1 :=  self snapshot.	self change: #c toReturn: 'c1'.	motherA2 :=  self snapshot.			self load: base.	self change: #b toReturn: 'b1'.	motherB1 :=  self snapshot.	self change: #d toReturn: 'd1'.	motherB2 :=  self snapshot.		self load: base.	self merge: motherA1.	self merge: motherB1.	self change: #a toReturn: 'a2'.	self change: #b toReturn: 'b2'.	self snapshot.	self shouldnt: [self merge: motherA2] raise: Error.	self shouldnt: [self merge: motherB2] raise: Error.		inst := self mockInstanceA.	self assert: inst a = 'a2'.	self assert: inst b = 'b2'.	self assert: inst c = 'c1'.	self assert: inst d = 'd1'.	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:53' prior: 57223286!testRepeatedMerge	| base mother1 mother2 inst |	<timeout: 30> "takes a little longer"	base :=  self snapshot.	self change: #one toReturn: 2.	mother1 :=  self snapshot.	self change: #two toReturn: 3.	mother2 :=  self snapshot.			self load: base.	self change: #truth toReturn: false.	self snapshot.	inst := self mockInstanceA.	self assert: inst one = 1.	self assert: inst two = 2.		self merge: mother1.	self assert: inst one = 2.	self assert: inst two = 2.			self change: #one toReturn: 7.	self assert: inst one = 7.	self assert: inst two = 2.		self shouldnt: [self merge: mother2] raise: Error.	self assert: inst one = 7.	self assert: inst two = 3.! !!DecompilerTests methodsFor: 'utilities' stamp: 'ar 5/10/2010 20:17'!defaultTimeout	"Decompiler takes a long time"	^30 "seconds"! !!MCFileInTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:53' prior: 57160248!testStWriter	<timeout: 30> "takes a little longer"	self		assertFileOutFrom: MCStWriter		canBeFiledInWith: [stream fileIn].! !"Tests"!!PluggableWidgetSpec commentStamp: 'ar 2/9/2005 18:40' prior: 26547561!The abstract superclass for all widgets.Instance variables:	model	<Object>	The object the various requests should be directed to.	frame	<Rectangle> The associated layout frame for this object (if any).!!PluggableButtonSpec commentStamp: 'ar 2/11/2005 21:57' prior: 59370783!A button, both for firing as well as used in radio-button style (e.g., carrying a selection).Instance variables:	action	<Symbol>	The action to perform when the button is fired.	label	<Symbol|String>	The selector for retrieving the button's label or label directly.	state	<Symbol>	The selector for retrieving the button's selection state.	enabled	<Symbo>		The selector for retrieving the button's enabled state.	color	<Symbo>		The selector for retrieving the button color.	help	<String>		The balloon help for the button.!!PluggableTextSpec commentStamp: 'ar 2/11/2005 21:58' prior: 59375756!A text editor.Instance variables:	getText	<Symbol>	The selector to retrieve the text.	setText	<Symbol>	The selector to set the text.	selection <Symbol>	The selector to retrieve the text selection.	menu	<Symbol>	The selector to offer (to retrieve?) the context menu.	color	 <Symbol>	The selector to retrieve the background color.!!UIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 32533887!UIManager is a dispatcher for various user interface requests, such as menu and dialog interactions. An instance of UIManager is associated with each Project to implement the appropriate functions for Morphic, MVC or other user interfaces.!!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color	"Answer the selector for retrieving the button's color"	^color! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color: aSymbol	"Indicate the selector for retrieving the button's color"	color := aSymbol! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:54' prior: 32541199!default	^ Project current uiManager! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:52'!getDefault	"Ensure that a more specific manager can always be made by subclassing	a tool builder and implementing a more specific way of reacting to	#isActiveManager. For example, a BobsUIManager can subclass	MorphicUIManager and (if enabled, say Preferences useBobsUI) will	be considered before the parent (generic MorphicUIManager)."	^ (self allSubclasses		detect: [:any | any isActiveManager				and: [any subclasses						noneSatisfy: [:sub | sub isActiveManager]]]		ifNone: [])		ifNotNilDo: [:mgrClass | mgrClass new]! !PluggableTextSpec removeSelector: #color:!PluggableTextSpec removeSelector: #color!PluggableButtonSpec removeSelector: #color:!PluggableButtonSpec removeSelector: #color!UIManager class removeSelector: #default:!"ToolBuilder-Kernel"!!MVCUIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 23337692!MVCUIManager is a UIManager that implements user interface requests for an MVC user interface.!"ToolBuilder-MVC"!!MorphicUIManager commentStamp: 'dtl 5/2/2010 16:07' prior: 24593982!MorphicUIManager is a UIManager that implements user interface requests for a Morphic user interface.!!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'fbs 5/2/2010 15:31' prior: 58753986!buildPluggableList: aSpec	| widget listClass getIndex setIndex |	aSpec getSelected ifNil:[		listClass := self listClass.		getIndex := aSpec getIndex.		setIndex := aSpec setIndex.	] ifNotNil:[		listClass := self listByItemClass.		getIndex := aSpec getSelected.		setIndex := aSpec setSelected.	].	widget := listClass on: aSpec model				list: aSpec list				selected: getIndex				changeSelected: setIndex				menu: aSpec menu				keystroke: aSpec keyPress.	self register: widget id: aSpec name.	widget getListElementSelector: aSpec listItem.	widget getListSizeSelector: aSpec listSize.	widget doubleClickSelector: aSpec doubleClick.	widget dragItemSelector: aSpec dragItem.	widget dropItemSelector: aSpec dropItem.	widget wantsDropSelector: aSpec dropAccept.	widget autoDeselect: aSpec autoDeselect.	widget keystrokePreviewSelector: aSpec keystrokePreview.	aSpec color isNil ifFalse: [widget color: aSpec color].	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	panes ifNotNil:[		aSpec list ifNotNil:[panes add: aSpec list].	].	^widget! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 5/4/2010 12:55' prior: 33732384!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	window model		shouldStyle: false;		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 20:48' prior: 57780504!buildFileListWith: builder	| buttons listSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttons := self buildButtonPaneWith: builder.	buttons frame: (self topConstantHeightFrame: self buttonHeight fromLeft: 0 width: 1).	top children add: buttons.		listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fileList; 		getIndex: #fileListIndex; 		setIndex: #fileListIndex:; 		menu: #fileListMenu:; 		keyPress: nil;		frame: (self frameOffsetFromTop: self buttonHeight + 4 fromLeft: 0 width: 1 bottomFraction: 1);		color: Color white.	top children add: listSpec.	^top.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 16:20' prior: 57781075!buildWith: builder	"FileList open"	| windowSpec window |	windowSpec := 	self buildWindowWith: builder specs: {		(0@0 corner: 1@0.06) -> [self buildPatternInputWith: builder].		(0.25@0.06 corner: 1@0.5) -> [self buildFileListWith: builder].		(0@0.06 corner: 0.25@1) -> [self buildDirectoryTreeWith: builder].		(0.25@0.5 corner: 1@1) -> [self buildContentPaneWith: builder].	}.	window := builder build: windowSpec.	self changed: #selectedPath.	^window! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 4/30/2010 14:53'!buttonHeight	^Preferences standardButtonFont height + 12! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 23:00'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 22:56'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:50' prior: 18762661!decompiledSourceIntoContents	"For backwards compatibility."	^self  decompiledSourceIntoContentsWithTempNames: (Sensor leftShiftDown not) ! !!CodeHolder methodsFor: 'message list' stamp: 'eem 5/18/2010 14:11'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new									parse: method getSourceFromFile asString									in: class									notifying: nil)										generate: CompiledMethodTrailer defaultMethodTrailer;										schematicTempNamesString.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !"Tools"!!HelpBrowser commentStamp: 'tbn 3/8/2010 09:33' prior: 33755727!A HelpBrowser is used to display a hierarchy of help topics and their contents.Instance Variables	rootTopic: 		<HelpTopic>	window:			<StandardWindow>	 	treeMorph:		<PluggableTreeMorph>	contentMorph:		<Morph>			rootTopic	- xxxxxwindow	- xxxxxtreeMorph 	- xxxxxcontentMorph 	- xxxxx!!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:37' prior: 33773237!defaultHelpBrowser	DefaultHelpBrowser isNil ifTrue: [DefaultHelpBrowser := self].	^DefaultHelpBrowser	! !!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:42'!defaultHelpBrowser: aClass	"Use a new help browser implementation"		DefaultHelpBrowser := aClass	! !!HelpBrowser class methodsFor: 'class initialization' stamp: 'tbn 5/2/2010 22:20' prior: 33773350!initialize	"Initializes the receiver class" 	 TheWorldMenu registerOpenCommand: {'Help Browser'. {self. #open}}. ! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 5/3/2010 18:37' prior: 33774194!open	^self openOn: SystemHelp! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 5/3/2010 18:36' prior: 33774327!openOn: aHelpTopic	"Open the receiver on the given help topic or any other object that can be transformed into	 a help topic by sending #asHelpTopic."		^(self defaultHelpBrowser new)		rootTopic: aHelpTopic asHelpTopic;		open;		yourself! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 5/2/2010 22:20' prior: 33774942!initWindow	window := SystemWindow labelled: 'Help Browser'.	window model: self.	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph frame: (0@0 corner: 0.3@1).		"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph frame: (0.3@0 corner: 1@1).					! !HelpBrowser removeSelector: #initWindowInSqueak!HelpBrowser removeSelector: #initWindowInPharo!HelpBrowser class removeSelector: #menuCommandOn:!HelpBrowser class removeSelector: #isSqueak!HelpBrowser class removeSelector: #isPharo11!"HelpSystem-Core"!!AdvancedHelpBrowserDummy commentStamp: 'tbn 5/3/2010 19:30' prior: 0!This is a dummy for a custom Help browser that can be registered as a replacement for the HelpBrowser class.Instance Variables	rootTopic:		<HelpTopic>rootTopic	- The root help topic!!AdvancedHelpBrowserDummy methodsFor: 'initialize-release' stamp: 'tbn 5/3/2010 19:34'!initialize	isOpen := false! !!AdvancedHelpBrowserDummy methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:32'!isOpen	^isOpen! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:32'!open	isOpen := true! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic	^rootTopic! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic: aTopic	rootTopic := aTopic! !!HelpBrowserTest methodsFor: 'accessing' stamp: 'tbn 5/3/2010 19:35'!defaultTestClass	^HelpBrowser! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 20:22'!testDefaultHelpBrowser		| current replacement instance |	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement. 	  instance := self defaultTestClass open.	  self assert: instance rootTopic notNil.	  self assert: instance isOpen.	] ensure: [ self defaultTestClass defaultHelpBrowser: current ]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:28'!testDefaultHelpBrowserIsReplacable		| current replacement instance |	"save the one that is registered"	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement.	  	  instance := self defaultTestClass open.	  	] ensure: [		self defaultTestClass defaultHelpBrowser: current	]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 18:43'!testLazyDefaultHelpBrowser		self assert: self defaultTestClass defaultHelpBrowser notNil! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:35' prior: 33796513!testOpen	|block|	block := [		|browser|		browser := self defaultTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Exception		! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/2/2010 22:20' prior: 33796755!testRegistration	        	TheWorldMenu registeredOpenCommands detect: [:each | each first = 'Help Browser'] ifNone: [self fail].	! !HelpBrowserTest removeSelector: #defaulTestClass!"HelpSystem-Tests"!!SqueakToolsHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:08'!basicDevelopmentTools	^HelpTopic 		title: 'Basic Development Tools'		contents: 'Smalltalk environments have some of the best user interfaces for programmers ever devised. Those who have programmed in Lisp under Emacs have some idea, but Smalltalk is even better.		You should learn these basic tools thoroughly:- Workspace- Transcript- Browser- Inspector- File List- Change Sorter- Debugger- Method Finder		'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 22:59'!bookName 	^'Tools'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:08'!pages	^#(basicDevelopmentTools)! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:14'!bookName	^'Transcript'! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:16'!pages	^# (transcript)! !!SqueakToolsTranscriptHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:16'!transcript	^HelpTopic 		title: 'The Transcript window'		contents: 'The Transcript window is often used for logging or printing results from text only code. To open the Transcript use TheWorldMenu and choose ''open...''. Then choose ''Transcript''.You can also type   Transcript openin a Workspace and doIt.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:06'!bookName 	^'Workspace'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:10'!openWorkspace	^HelpTopic 		title: 'Open a Workspace'		contents: 'You can open a Workspace window, by doing any one of the following:		- Using a keyboard while pointing at an empty part of the Squeak wind, alt-k (in Windows, cmd-k in Mac)- Open up a World Menu, select "open..." action. From the open menu, select "workspace (k)- Click on the Tools Flap. When it comes out, click on the Workspace icon and drag it out. (Click on the Tools Flap to close it back up.).'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:11'!pages	^#(workspace openWorkspace saveWorkspace)! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:13'!saveWorkspace	^HelpTopic 		title: 'Saving Workspace to a File'		contents: 'You can save the text content of a Workspace to a file by choosing the workspace menu (from within the workspace), then ''more...'', then ''save contents to file...''.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:09'!workspace	^HelpTopic 		title: 'What is a Workspace'		contents: 'A Workspace is a window used as a scratchpad area where fragments of Smalltalk code can be entered, stored, edited, and evaluated. To open a workspace window in Squeak, one possibility is to bring up the World menu, select "open...", and then select "workspace". You can then type in any Smalltalk code inside the workspace window and execute it or inspect it.'! !!SqueakTutorials class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:33'!bookName 	^'Tutorials'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:34'!bookName 	^'XML'! !!SqueakTutorialsOnXML class methodsFor: 'pages' stamp: 'it 5/4/2010 20:12'!dataRetrieval	^HelpTopic 		title: 'Retrieving XML data'		contents: 'Retrieving data from XML documents is simple and easy in Squeak Smalltalk. This tutorial demonstrates the fundamentals with a straightforward approach where code can be tested right away either here or in a Workspace window. The beauty of Squeak Smalltalk resides in the possibility to evaluate, inspect, print and debug code anywhere and this window is no different. This tutorial demonstrates how to...	* retrieve an XML document from the World Wide Web	* instantiate an XML document class	* inspect and understand the content of an XML document	* retrieve and display values from specific XML tagsRetrieve an XML document from the World Wide WebThere are many manners to retrieve data from the World Wide Web in Squeak Smalltalk. HTTPClient is among them and allows to download files in all simplicity. Select the following code snippet and inspect it (press alt-i). An Inspect window will open with the document loaded in memory. The result is a MIMEDocument object.	HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.TIP: Select HTTPClient and browse it (press alt-b) to open a System Browser window on its class. HTTPClient does not have instance methods but it has class methods. Click on class to see class methods.Instantiate an XML DocumentAn instance of MIMEDocument will not allow to retrieve XML data in a comprehensive manner because it does not understand the nature of XML. For this reason, it is necessary to parse the content of MIMEDocument using XMLDOMParser. XMLDOMParser>>parseDocumentFrom: requires a stream as a parameter and ReadStream will be used for this purpose. The following code snippet instantiates an XMLDocument using the content of the downloaded file.	| doc |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).Inspect and understand the content of an XML documentXML is a flexible document format and it is necessary to understand how each given XML file is structured in order to properly search, retrieve and manipulate data. Inspecting values is critical in a dynamic programming language and environment, such as Squeak Smalltalk. Select the previous code snippet and inspect it (press alt-i).Unfortunately, the Inspect window does not reveal a lot about the XML structure of the downloaded file. Select the previous code snippet once again and explore it (press alt and the capital letter i). An Explorer window will open with a tree outline on the instance of XMLDocument.The Inspect and Explorer windows tell a lot about an XMLDocument. The sections are instance variables and their values are displayed aside. In the Explorer window, unfold elementsAndContents. Unfold other sections as deemed necessary to understand the XML format and the data available.The gibberish coding is about to become clear. Open a Browser window from the world menu and right click in the first pane, select find class (press alt-f) and type XMLDocument to search for its class, or select the class name and browse it (press alt-b). However, it is suggested to read more about XMLParser and XMLParserTest first. Retrieve and display values from specific XML tagsThe downloaded XML file contains a list of items which are denoted by the tag name "item". The Explorer window revealed the content of interest is located at the array index 1 of the elementsAndContents, which can be accessed through XMLDocument>>root.TIP: Some XML documents have additional components contained within its file, such as XMLPI (XML Processing Instructions). For this reason, the root may lead to this rather than the data which will be indexed at 2 or more. It is necessary to use XMLNodeWithElements>>elements, e.g. (xml elements at: 2), in order to access subsequent data.The following code snippet will display items in a Transcript window. Open a Transcript window using the world menu before selecting and executing the code. Select the code snippet and execute it (press alt-d).	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript show: (e asString); cr.		].An XML item looks like this:	<item>	<title>HelpSystem-Core-tbn.46.mcz</title>	<link>http://source.squeak.org/trunk.html</link>	<description>throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)</description>	<pubDate>Sun, 02 May 2010 20:23:49 +0000</pubDate>	<author>Torsten Bergmann &lt;Torsten.Bergmann@astares.de&gt;</author>	<category>The Trunk</category>	<enclosure length="27288" type="application/x-monticello" url="http://source.squeak.org/trunk/HelpSystem-Core-tbn.46.mcz"/> 	<guid isPermaLink="false"/> </item>The following code snippet uses information learned, retrieves each comment and displays them in a Transcript window. Notice an author can have a nil value and is handled accordingly.	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript 			show: ''Date: '', ((e firstTagNamed: #pubDate) contentString); cr;			show: ''Title: '', ((e firstTagNamed: #title) contentString); cr;			show: ''Author: '', 				(((e firstTagNamed: #author) notNil)					ifTrue: [(e firstTagNamed: #author) contentString]					ifFalse: ['''']); cr;			show: ''Description: '', ((e firstTagNamed: #description) contentString); cr; cr.			].An item will now look like:	Date: Sun, 02 May 2010 20:23:49 +0000	Title: HelpSystem-Core-tbn.46.mcz	Author: Torsten Bergmann <Torsten.Bergmann@astares.de>	Description: throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:35'!pages	^# (dataRetrieval)! !"Help-Squeak-Project"!!ContextPart methodsFor: 'private' stamp: 'eem 5/23/2010 14:13' prior: 50837502!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod := aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	theMethod flushCache.	selector flushCache.	^aReceiver perform: selector withArguments: arguments! !"Kernel"!!Parser methodsFor: 'primitives' stamp: 'ar 5/24/2010 20:41' prior: 54010073!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == #')'] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(args position = self properties selector numArgs) ifFalse:[		^self expected: 'Matching number of arguments'	].	(self matchToken:#')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn| | fn |		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addPragma: (Pragma keyword: #primitive: arguments: #(120)).	^true! !"Compiler"!SystemVersion setVersion!Smalltalk cleanUp: true.!----SNAPSHOT----{24 May 2010 . 8:51:58 pm} Squeak4.2-10160-alpha.image priorSource: 382!Smalltalk cleanUp: true!----SNAPSHOT----{24 May 2010 . 8:52:41 pm} Squeak4.2-10160-alpha.image priorSource: 326247!----QUIT/NOSAVE----{24 May 2010 . 8:52:46 pm} Squeak4.2-10160-alpha.image priorSource: 326363!!WeakRegistry commentStamp: '<historical>' prior: 59463178!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!----STARTUP----{19 August 2010 . 7:05:44 pm} as /Users/casey/Desktop/Squeak4.2-10160-alpha/Squeak4.2-10160-alpha.image!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 6/12/2010 18:38' prior: 58027016!finalizeValues	"Remove and finalize all elements which have nil key"		|  cleanUpAfterRemove |	tally = 0 ifTrue: [ ^self ].	cleanUpAfterRemove := false.	1 to: array size do: [ :index |		(array at: index) 			ifNil: [ cleanUpAfterRemove := false ]			ifNotNil: [ :element |				element key					ifNil: [						finalizer ifNotNil: [ finalizer value: element value ].						array at: index put: nil.						tally := tally - 1.						cleanUpAfterRemove := true ]					ifNotNil: [ :key |						cleanUpAfterRemove ifTrue: [							| newIndex |							(newIndex := self scanFor: key) = index ifFalse: [								array 									at: newIndex put: element;									at: index put: nil ] ] ] ] ].	cleanUpAfterRemove ifTrue: [ "Continue rehashing at the front of array"		self fixCollisionsFrom: array size ]					! !!WeakRegistry methodsFor: 'finalization' stamp: 'ul 6/15/2010 11:17' prior: 58127066!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."		| collectedExecutors |	self protected: [ 		valueDictionary finalizeValues.		collectedExecutors := executors.		executors := nil ].	collectedExecutors ifNotNil: [		collectedExecutors do: #finalize ]! !!WeakRegistry methodsFor: 'initialize' stamp: 'ul 6/15/2010 11:17' prior: 58121165!installFinalizer	valueDictionary finalizer: [ :executor |		(executors ifNil: [ executors := OrderedCollection new ]) add: executor ]! !!WeakRegistry methodsFor: 'copying' stamp: 'ul 6/15/2010 11:21' prior: 58237893!postCopy	self protected: [ "Uses the original accessLock"		accessLock := Semaphore forMutualExclusion.		valueDictionary := valueDictionary copy.		valueDictionary associationsDo: [ :each |			each value class == ObjectFinalizerCollection 				ifTrue: [ each value: each value copy ] ].		executors := executors copy.		self installFinalizer ]! !!ByteArray methodsFor: 'testing' stamp: 'eem 6/4/2010 17:55' prior: 53694752!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^self class == ByteArray! !!Dictionary methodsFor: 'removing' stamp: 'eem 10/28/2008 11:14' prior: 53983438!unreferencedKeys	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"	^'Scanning for references . . .' 		displayProgressAt: Sensor cursorPoint		from: 0		to: Smalltalk classNames size * 2		during: 			[:bar | | currentClass n associations referencedAssociations |			currentClass := nil.			n := 0.			associations := self associations asIdentitySet.			referencedAssociations := IdentitySet new: associations size.			self systemNavigation allSelect:				[:m|				m methodClass ~~ currentClass ifTrue:					[currentClass := m methodClass.					 bar value: (n := n + 1)].				m literalsDo:					[:l|					(l isVariableBinding and: [associations includes: l]) ifTrue:						[referencedAssociations add: l]].				false].			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !!String methodsFor: 'accessing' stamp: 'nice 6/11/2010 21:44'!lines	"Answer an array of lines composing this receiver without the line ending delimiters."	^Array new: (self size // 60 max: 16) streamContents: [:lines |		self linesDo: [:aLine | lines nextPut: aLine]]! !!Symbol class methodsFor: 'access' stamp: 'eem 12/21/2008 12:18' prior: 55054271!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	(aString first isLetter or: [aString first isDigit]) ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'eem 5/22/2008 12:56'!selectorsMatching: aStringPattern	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.	 Does return symbols that begin with a capital letter."	| selectorList |	selectorList := OrderedCollection new.	aStringPattern isEmpty ifTrue: [^selectorList].	self allSymbolTablesDo:		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"		[:each | each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]	"Symbol selectorsMatching: 'parse:*'"! !"Collections"!!WeakIdentityKeyDictionaryTest methodsFor: 'coverage' stamp: 'ul 6/12/2010 21:14'!classToBeTested 	^WeakIdentityKeyDictionary! !!WeakIdentityKeyDictionaryTest methodsFor: 'tests' stamp: 'ul 6/12/2010 21:14'!testFinalizeValuesWhenLastChainContinuesAtFront	| objectWithHashModulo dictionary capacity a b c |	objectWithHashModulo := [ :requestedHash :modulo |		| object |		[ 			object := Object new.			object hash \\ modulo = requestedHash ] whileFalse.		object ].	dictionary := self classToBeTested new.	capacity := dictionary capacity.	a := objectWithHashModulo value: capacity - 2 value: capacity.	dictionary at: a put: 1.	b := objectWithHashModulo value: capacity - 1 value: capacity.	dictionary at: b put: 2.	c := objectWithHashModulo value: capacity - 2 value: capacity.	dictionary at: c put: 3.	self assert: dictionary capacity = capacity.	self assert: (dictionary array at: capacity - 1) key == a.	self assert: (dictionary array at: capacity) key == b.	self assert: (dictionary array at: 1) key == c.	a := nil.	Smalltalk garbageCollect.	dictionary finalizeValues.	self assert: (dictionary includesKey: b).	self assert: (dictionary includesKey: c).	self assert: dictionary slowSize = 2.! !!ByteArrayTest methodsFor: 'hex tests' stamp: 'nice 6/5/2010 10:06'!testIsLiteral	self assert: #[122 43 213 7] isLiteral description: 'ByteArray instances are literal'.	self deny: thisContext method isLiteral description: 'ByteArray sub instances are not literal'! !"CollectionsTests"!!GZipSurrogateStream commentStamp: 'nice 3/24/2010 07:36' prior: 21233596!A pseudo stream that allows SmartRefStream to write directly to a gzipped file. There are some peculiarities of the project exporting process that require:1. We ignore #close since the file is closed and may be reopened to continue writing. We implement #reallyClose for when we know that all writing is over.2. We use a BitBlt to write WordArrayForSegment objects. Bit of a hack, but there it is.| fileStream wa |wa := WordArrayForSegment new: 30000.1 to: wa size do: [ :i | wa at: i put: i].fileStream := GZipSurrogateStream newFileNamed: 'xxx3.gz' inDirectory: FileDirectory default.fileStream nextPutAll: 'this is a test'.fileStream nextPutAll: wa.fileStream reallyClose.!!InflateStream commentStamp: 'nice 3/24/2010 07:37' prior: 59325048!This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"For more information see the above mentioned RFC 1951 which can for instance be found at	http://www.leo.org/pub/comp/doc/standards/rfc/index.htmlHuffman Tree Implementation Notes:===========================================The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):	table := initialTable.	bitsNeeded := high 8 bits of (table at: 1).		"Determine initial bits"	table := initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"	[bits := fetch next bitsNeeded bits.			"Grab the bits"	value := table at: bits.						"Lookup the value"	value has high 8 bit set] whileTrue:[		"Check if it's leaf"		table := initialTable + (low 16 bits of value).	"No - compute new sub table start"		bitsNeeded := high 8 bit of value].		"Compute additional number of bits needed"	^value!"Compression"!!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'eem 7/3/2009 11:21' prior: 23215906!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	self updateInstVars.	"Temporary conversion code -- remove later"	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.	Smalltalk addToStartUpList: self! !!MCWorkingCopy class methodsFor: 'system startup' stamp: 'eem 7/3/2009 11:34'!startUp: resuming	"Ensure Monticello is receiving system change notifications."	resuming ifTrue:		[Smalltalk			at: #SystemChangeNotifier			ifPresent: [:scn| self reregisterForNotificationsWith: scn uniqueInstance]]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:51' prior: 22897247!notifyList	(self allFileNames includes: 'notify') ifFalse: [^ #()].	^ self readStreamForFileNamed: 'notify' do:		[:s |		s upToEnd lines]! !!MCPackageManager class methodsFor: 'cleanup' stamp: 'ar 6/16/2010 19:56'!flushObsoletePackageInfos	"Flush any and all PackageInfos that are not associated with an MCPackageManager."	| pkgNames |	pkgNames := self allManagers collect:[:wcs| wcs packageName] as: Set.	PackageOrganizer default flushObsoletePackages:[:p|		p class isObsolete or:[(pkgNames includes: p packageName) not].	].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:15' prior: 23015540!registerForNotifications	Smalltalk		at: #SystemChangeNotifier		ifPresent:			[:cls|			cls uniqueInstance noMoreNotificationsFor: self.			self reregisterForNotificationsWith: cls uniqueInstance]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:14'!reregisterForNotificationsWith: aSystemChangeNotifier	aSystemChangeNotifier		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 6/24/2010 10:32' prior: 22829118!fileOutMessage	"Put a description of the selected message on a file"	| fileName |	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].		 ^self].	items isEmpty ifTrue:		[^self].	fileName := UIManager default request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		items do:			[:patchOp|			patchOp definition isMethodDefinition ifTrue:				[(patchOp definition actualClass notNil				  and: [patchOp definition actualClass includesSelector: patchOp definition selector])					ifTrue:						[patchOp definition actualClass							printMethodChunk: patchOp definition selector							withPreamble: true							on: internalStream							moveSource: false							toFile: nil]					ifFalse:						[internalStream nextChunkPut: patchOp definition className, ' removeSelector: ', patchOp definition selector printString]].			patchOp definition isClassDefinition ifTrue:				[patchOp definition actualClass					ifNotNil:						[internalStream nextChunkPut: patchOp definition actualClass definition.						 patchOp definition comment ifNotNil:							[patchOp definition actualClass organization								putCommentOnFile: internalStream								numbered: 1								moveSource: false								forClass: patchOp definition actualClass]]					ifNil:						[internalStream nextChunkPut: patchOp definition className, ' removeFromSystem']]].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 10/27/2008 17:07' prior: 22830489!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName	ifNil: [items notEmpty ifTrue:		[aMenu addList:#(('fileOut (o)'					fileOutMessage))]]	ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCPackage methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33' prior: 22996559!packageInfo	^ PackageInfo named: name! !"Monticello"!!ClassBuilder methodsFor: 'private' stamp: 'ar 6/14/2010 22:06' prior: 50642796!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		ProtoObject Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext BlockClosure		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 6/18/2010 21:38'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	^(array at: (self scanFor: key)) 		ifNil: [ aBlock value ]		ifNotNil: [ :value | key -> value ]! !!Object methodsFor: 'updating' stamp: 'eem 6/15/2008 16:02'!okToClose	"Allows a controller to ask this of any model"	^self okToChange! !!DependentsArray methodsFor: 'enumerating' stamp: 'ul 6/18/2010 23:31' prior: 53636324!select: aBlock 	"Refer to the comment in Collection|select:."	| basicSize newSelf size selection |	basicSize := self basicSize.	newSelf := self species new: basicSize.	size := 0.	1 to: basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :dep |			(aBlock value: dep) ifTrue: [				newSelf basicAt: (size := size+1) put: dep ] ] ].	selection := self species new: size.	selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.	^selection! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'cmm 6/15/2010 15:14' prior: 54046483!= aDateAndTime 	self == aDateAndTime ifTrue: [ ^ true ].	(aDateAndTime isKindOf: self class) ifFalse: [ ^ false ].	^ self offset = aDateAndTime offset		ifTrue: [ self hasEqualTicks: aDateAndTime ]		ifFalse: [ self asUTC ticks = aDateAndTime asUTC ticks ]! !!Behavior methodsFor: 'testing' stamp: 'mtf 6/3/2010 11:03'!sourceMatchesBytecodeAt: selector	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false otherwise. Implemented to detect an error where Monticello did not recompile sources when the class shape changed"	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a method which turned a selector and class into a CompiledMethod, without  installing it into the methodDictionary"	| method trailer methodNode |	method := self compiledMethodAt: selector.	trailer := method trailer.	methodNode := self compilerClass new				compile: (self sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ false].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ (methodNode generate: trailer) = method! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 5/28/2010 21:01'!ln	"This function is defined because super ln might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal ln negated].	self <= 0 ifTrue: [self error: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	int := self integerPart.	^int ln + (self / int) ln! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 6/12/2010 00:40'!log	"This function is defined because super log might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal log negated].	self <= 0 ifTrue: [self error: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	int := self integerPart.	^int log + (self / int) log! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index 	"Avoid primitive in Object>>at:"	^self basicAt: index! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index put: value 	"Avoid primitive in Object>>at:put:"	^self basicAt: index put: value! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:34'!basicAt: index	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 38 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index].	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:35'!basicAt: index put: value	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 39 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index put: value].	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!MethodContext methodsFor: 'initialize-release' stamp: 'eem 9/10/2009 15:49' prior: 51687884!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	closureOrNil		ifNotNil:			[pc := closureOrNil startpc.			self stackp: closureOrNil numArgs + closureOrNil numCopiedValues.			1 to: closureOrNil numCopiedValues do:				[:i | self tempAt: closureOrNil numArgs + i put: (closureOrNil at: i)]]		ifNil:			[pc := method initialPC.			self stackp: method numTemps.			method numArgs+1 to: method numTemps do:				[:i | self tempAt: i put: nil]]! !!ContextPart methodsFor: 'private-exceptions' stamp: 'mtf 6/3/2010 09:36'!rearmHandlerDuring: aBlock	"Sent to handler (on:do:) contexts only. Makes me re-entrant for the duration of aBlock. Only works in a closure-enabled image"	^ [self tempAt: 3 put: true. aBlock value]		ensure: [self tempAt: 3 put: false]! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'MarcusDenker 3/5/2010 14:33'!methodsInCategory: aName 	"Answer a list of the methods of the receiver that are in category named aName"		| aColl |	aColl := Set withAll: (aName = ClassOrganizer allCategory			ifTrue: [self organization allMethodSelectors]			ifFalse: [self organization listAtCategoryNamed: aName]).	^ aColl asArray sort! !!Integer methodsFor: 'converting' stamp: 'MarcusDenker 12/2/2009 12:54' prior: 21992032!asFraction	"Answer a Fraction that represents the value of the receiver."	^Fraction numerator: self denominator: 1! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 5/28/2010 21:25'!ln	"This function is defined because super ln might overflow."	| res h |	self <= 0 ifTrue: [self error: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	h := self highBit.	^2 ln * h + (self / (1 << h)) asFloat ln! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 6/12/2010 00:40'!log	"This function is defined because super log might overflow."	| res h |	self <= 0 ifTrue: [self error: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	h := self highBit.	^2 log * h + (self / (1 << h)) asFloat log! !!ProtoObject methodsFor: 'system primitives' stamp: 'mtf 8/15/2008 17:19'!instVarsInclude: anObject"Answers true if anObject is among my named or indexed instance variables, and false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !LargePositiveInteger removeSelector: #~=!LargePositiveInteger removeSelector: #bitXor:!LargePositiveInteger removeSelector: #bitShift:!LargePositiveInteger removeSelector: #bitOr:!LargePositiveInteger removeSelector: #bitAnd:!LargePositiveInteger removeSelector: #=!TranslatedMethod class removeSelector: #initialize!Smalltalk removeClassNamed: #TranslatedMethod!PseudoContext removeSelector: #nextObject!PseudoContext removeSelector: #isPseudoContext!PseudoContext class removeSelector: #initialize!PseudoContext class removeSelector: #definition!PseudoContext class removeSelector: #contextCacheDepth:!PseudoContext class removeSelector: #contextCacheDepth!Smalltalk removeClassNamed: #PseudoContext!"Kernel"!!Parser methodsFor: 'error correction' stamp: 'jcg 6/23/2010 11:46' prior: 52083421!correctVariable: proposedVariable interval: spot 	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding := requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	action := UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!Decompiler methodsFor: 'public access' stamp: 'ar 5/27/2010 21:35' prior: 53211074!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home source |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home methodClass) == #unknown ifTrue: [^ nil].	constructor := self constructorForMethod: aBlock method.	self withTempNames: (method tempNamesString ifNil:[	method fileIndex ~~ 0 ifTrue: "got any source code?"		[source := [method getSourceFromFile]						on: Error						do: [:ex | ^ nil].		 methodNode := [homeClass compilerClass new								parse: source								in: homeClass								notifying: nil]							on: SyntaxErrorNotification							do: [:ex | ^ nil].		methodNode schematicTempNamesString]]).	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock isClosure				ifTrue: [(method at: startpc - 2) * 256					  + (method at: startpc - 1) + startpc - 1]				ifFalse:					[(method at: startpc - 2) \\ 16 - 4 * 256					+ (method at: startpc - 1) + startpc - 1].	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super		method: method		pc: (aBlock isClosure ifTrue: [startpc - 4] ifFalse: [startpc - 5]).	aBlock isClosure ifTrue:		[numLocalTemps := #decompileBlock: "Get pushClosureCopy... to hack fake temps for copied values"].	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!Encoder methodsFor: 'private' stamp: 'Lukas Renggli 11/2/2009 00:29' prior: 50999617!name: name key: key class: leafNodeClass type: type set: dict 	^dict at: key		ifAbsentPut: 			[leafNodeClass new 				name: name				key: key				index: nil				type: type]! !"Compiler"!!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'nice 6/11/2010 21:58' prior: 57364115!parseEToyUserListFrom: urlString	| url userString userList |	urlString ifNil:[^nil].	url := urlString asUrl.	userString := ["Note: We need to prevent going through the plugin API 	when retrieving a local (file) URL, since the plugin API	(correctly) rejects file:// downloads."		Cursor wait showWhile:[			(url hasRemoteContents) ifTrue:[				"Go through the browser (if present)"				(HTTPClient httpGet: url asString) contents.			] ifFalse:[				"Go grab it directly"				url retrieveContents contents.			].		].	] on: Error do:[nil].	userString ifNil:[^nil].	userList := userString lines collect: [:each| each withBlanksTrimmed].	userList := userList reject:[:any| any isEmpty].	(userList first = '##user list##') ifFalse:[^nil].	userList := userList copyFrom: 2 to: userList size.	^userList! !"EToys"!!Exception methodsFor: 'handling' stamp: 'mtf 6/3/2010 09:42'!rearmHandlerDuring: aBlock"Make the current error handler re-entrant while it is running aBlock. Only works in a closure-enabled image"	^ handlerContext rearmHandlerDuring: aBlock! !!ExceptionsTest methodsFor: 'as yet unclassified' stamp: 'mtf 6/2/2010 15:51'!testHandlerReentrancy	| callingOrder |	"Handlers are not re-entrant by default, so inner is not activated twice"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex pass]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sio'.	"Now make inner re-entrant"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex rearmHandlerDuring: [ex pass]]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sioi'.! !"Exceptions"!!FileDirectory methodsFor: 'private' stamp: 'mtf 6/1/2010 18:47' prior: 58807732!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	^Array new: 200 streamContents: [:stream |		self directoryContentsFor: fullPath do: [:ea | stream nextPut: ea]].! !!FileDirectory methodsFor: 'private' stamp: 'mtf 6/1/2010 18:46'!directoryContentsFor: fullPath do: aBlock"Do aBlock for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	| f entryArray index |	f := fullPath asVmPathName.	index := 1.	[(entryArray := self primLookupEntryIn: f index: index) == nil] whileFalse: [		#badDirectoryPath = entryArray ifTrue: [			^(InvalidDirectoryError pathName: pathName) signal].		index := index + 1.		aBlock value: (DirectoryEntry fromArray: entryArray directory: self) convertFromSystemName]! !"Files"!!XBMReadWriter methodsFor: 'private' stamp: 'nk 7/16/2003 18:17' prior: 33301630!readHeader	"Set width and height, and position stream at start of bytes"	| number setwidth setheight fieldName |	setwidth := setheight := false.		[((stream atEnd) or: [setwidth and: [setheight]])]		whileFalse: [	  	self skipCComments.		(stream nextMatchAll: '#define ') ifFalse: [^ false].		(stream skipTo: $_) ifFalse: [^ false].		fieldName := String streamContents:			[:source |			[(stream atEnd) or: [ stream peek isSeparator ]]				whileFalse: [ source nextPut: stream next]].	  	(fieldName = 'width') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setwidth _true].	  		width := number.].		(fieldName = 'height') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setheight := true].			height := number.			].		].	(setwidth & setheight) ifFalse: [^ false].	^ stream skipTo: ${! !!StrikeFont methodsFor: 'make arrows' stamp: 'sps 10/15/2003 17:06' prior: 30048599!makeAssignArrow"Replace the underline character with an arrow for this font"	| arrowForm arrowCanvas arrowY arrowLeft arrowRight arrowHeadLength |	arrowForm := (self characterFormAt: $_) copy.	arrowCanvas := arrowForm getCanvas.	arrowCanvas fillColor: Color white.	arrowY := arrowForm height // 2.	arrowLeft := 0. 	arrowRight := arrowForm width - 2.	arrowHeadLength := (arrowRight - arrowLeft) * 2 // 5.	"Draw the lines"	arrowCanvas line: (arrowLeft@arrowY) to: (arrowRight@arrowY) color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY - arrowHeadLength)) 		color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY + arrowHeadLength)) 		color: Color black.	"Replace the glyph"	self characterFormAt: $_ put: arrowForm.! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29' prior: 52653164!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f := FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens := f nextLine  findTokens: ' '.	iRect := Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent := iRect top.	descent := iRect bottom negated.		tempGlyphs := Form extent: (maxWidth*257) @ self height.	xTable := (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii := -1.	[charLine := self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p := f position.		rectLine := f nextLine.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens := rectLine findTokens: ' '.					left := (tokens at: 5) asNumber. right := (tokens at: 8) asNumber]			ifFalse: [left := right := 0. f position: p].		width:= (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii := 256].		('x''*' match: charLine) ifTrue:			[ascii := Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm := Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line := f nextLine.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm := charForm deepCopy]				ifFalse:				[minAscii := minAscii min: ascii.				maxAscii := maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii := ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs := Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable := xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap := nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29' prior: 52675328!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line := file nextLine.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!BDFFontReader methodsFor: 'reading' stamp: 'nice 6/11/2010 21:32' prior: 17129428!getLine	^file nextLine! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35' prior: 17129534!read	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width blt lastAscii pointSize ret stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	charsNum > 256 ifTrue: [		"it should be 94x94 charset, and should be fixed width font"		strikeWidth := 94*94*maxWidth.		maxAscii := 94*94.		minAscii := 0.		xTable := XTableForFixedFont new.		xTable maxAscii: 94*94.		xTable width: maxWidth.	] ifFalse: [		xTable := (Array new: 258) atAllPut: 0.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	lastAscii := 0.		charsNum > 256 ifTrue: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			encoding := ((encoding // 256) - 33) * 94 + ((encoding \\ 256) - 33).			blt copy: ((encoding * maxWidth)@0 extent: maxWidth@height)				from: 0@0 in: form.		].	] ifFalse: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].			blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))					extent: (bbx at: 1)@(bbx at: 2))				from: 0@0 in: form.			xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).			lastAscii := encoding.		]	].	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35' prior: 17132760!readChars	| strikeWidth ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width pointSize stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	^ chars.! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11' prior: 55012029!test1"PNGReadWriter test1"	| d0 d1 fileInfo book d2 f |	Debugging := true.	1 = 1 ifTrue: [		book := BookMorph new.		book setProperty: #transitionSpec toValue: {'silence'. #none. #none}.	].	d0 := FileDirectory default.	d1 := d0 directoryNamed: 'PngSuite Folder'.	d2 := d0 directoryNamed: 'BIG PNG'.	{d0. d1. d2}.		"keep compiler quiet""==citrus_none_sub.pngcitrus_adm7_adap.pngcitrus_adm7_aver.pngcitrus_adm7_non.pngcitrus_adm7_paeth.pngpngs-img-ie5mac.png=="	fileInfo := {		d2. {'citrus_adm7_adap.png'}.		"d1. d1 fileNames."	}.	fileInfo pairsDo: [ :dir :fileNames |		fileNames do: [ :each | | error data t |			Transcript cr; show: each.			data := (dir fileNamed: each) contentsOfEntireFile.			error := ''.			MessageTally spyOn: [				t := [ | result |					result := self createAFormFrom: data.					f_ result first.					error := result second.				] timeToRun.].			self insertMorph: f asMorph named: each into: book.			Transcript show: each,'  ',data size printString,' = ',t printString,' ms',error; cr.		].	].	book ifNotNil: [book openInWorld].	Debugging := false.! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/12/2010 11:07'!canComputDefaultLineHeight	^ rightMargin notNil! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/13/2010 20:50'!canComputeDefaultLineHeight	^ rightMargin notNil! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 16:39' prior: 25391930!nextImage	"read one image"	| data p |	first ifNil:[		first := false.		data := stream contentsOfEntireFile.		stream := (RWBinaryOrTextStream with: data) reset.	]	ifNotNil:[		type < 4 ifTrue:[			self error:'Plain PBM, PGM or PPM have only one image'		].	].	stream ascii.	p := stream next.	type := (stream next) asInteger - 48.	(p = $P and:[type > 0 and:[type < 8]]) ifFalse:[		self error:'Not a PNM file'	].	type = 7 ifTrue:[		self readHeaderPAM	]	ifFalse: [		self readHeader	].	type caseOf: {		[1] 	->	[^self readPlainBW].		[2] 	->	[^self readPlainGray].		[3] 	->	[^self readPlainRGB].		[4] 	->	[^self readBWreverse: false].		[5] 	->	[^self readGray].		[6] 	->	[^self readRGB].		[7] 	->	[	"PAM"					(tupleType asUppercase) caseOf: {						['BLACKANDWHITE'] 		-> [^self readBWreverse: true].						['GRAYSCALE'] 			-> [^self readGray].						['RGB'] 					-> [^self readRGB].						['RGB_ALPHA'] 			-> [^self error:'Not implemented'].						['GRAYSCALE_ALPHA'] 	-> [^self error:'Not implemented'].					} otherwise: [^self readData].				]	}! !!BitBlt class methodsFor: 'benchmarks' stamp: 'nice 6/11/2010 21:32' prior: 54835129!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log := WriteStream on: String new.	old := ReadStream on: before.	new := ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine := old nextLine.		newLine := new nextLine.		(oldLine includes: Character tab) ifTrue:[			oldLine := ReadStream on: oldLine.			newLine := ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal := Integer readFrom: oldLine.				newVal := Integer readFrom: newLine.				improvement := oldVal asFloat / newVal asFloat roundTo: 0.01.				Transcript show: improvement printString; tab; tab.				log print: improvement; tab; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!CharacterScanner methodsFor: 'scanning' stamp: 'cmm 6/12/2010 11:52' prior: 58295101!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: (stopIndex min: sourceString size) in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := EncodedCharSet scanSelectorAt: startEncoding.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stops with: kernDelta).	].		^ stops endOfRun! !"Graphics"!!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:19'!testArea	| r1 empty |	r1 := 0@0 extent: 10@20.	self assert: r1 area = (10*20).	self assert: (r1 translateBy: -20@10) area = (10*20) description: 'translation preserves area'.		empty := 10@20 corner: 0@0.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.	empty := 10@0 corner: 0@20.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.	empty := 0@20 corner: 10@0.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:59'!testCenter	| r1 c |	r1 := 0@0 extent: 10@20.	c := r1 center.	self assert: (r1 containsPoint: c) description: 'the center is inside the rectangle'.	self assert: (r1 topLeft dist: c) = (r1 bottomRight dist: c).	self assert: (r1 bottomLeft dist: c) = (r1 topRight dist: c).	self assert: (r1 topLeft dist: c) = (r1 bottomLeft dist: c).	self assert: (r1 translateBy: -20@10) center = (c translateBy: -20@10) description: 'the center is translated with the rectangle'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 23:00'!testCenterEmpty	| r1 c |	r1 := 30@10 corner: 10@20.	c := r1 center.	self deny: (r1 containsPoint: c) description: 'An empty rectangle does not contain any point.'.	self assert: (r1 topLeft dist: c) = (r1 bottomRight dist: c).	self assert: (r1 bottomLeft dist: c) = (r1 topRight dist: c).	self assert: (r1 topLeft dist: c) = (r1 bottomLeft dist: c).	self assert: (r1 translateBy: -20@10) center = (c translateBy: -20@10) description: 'the center is translated with the rectangle'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:33'!testFlip	| r1 c r1Horiz r1Vert |	r1 := 30@10 extent: 10@20.	c := 5@5.	r1Horiz := r1 flipBy: #horizontal centerAt: c.	r1Vert := r1 flipBy: #vertical centerAt: c.	self assert: r1 area = r1Horiz area description: 'flip preserves area'.	self assert: r1 area = r1Vert area description: 'flip preserves area'.		self assert: r1 extent = r1Horiz extent description: 'flip preserves extent'.	self assert: r1 extent = r1Vert extent description: 'flip preserves extent'.		self assert:  (r1 flipBy: #horizontal centerAt: r1 center) = r1.	self assert:  (r1 flipBy: #vertical centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:33'!testFlipEmpty	| r1 c r1Horiz r1Vert |	r1 := 30@10 corner: 10@20.	c := 5@5.	r1Horiz := r1 flipBy: #horizontal centerAt: c.	r1Vert := r1 flipBy: #vertical centerAt: c.		self assert: r1 area = r1Horiz area description: 'flip preserves area'.	self assert: r1 area = r1Vert area description: 'flip preserves area'.		self assert: r1 extent = r1Horiz extent description: 'flip preserves extent'.	self assert: r1 extent = r1Vert extent description: 'flip preserves extent'.		self assert:  (r1 flipBy: #horizontal centerAt: r1 center) = r1.	self assert:  (r1 flipBy: #vertical centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 23:04'!testIntersectionEmpty	| rect1 empty1 empty2 |	rect1 := 10@10 corner: 40@40.	empty1 := 50@50 corner: 0@0.	empty2 := 30@30 corner: 20@20.	self		deny: (rect1 intersects: empty1);		deny: (rect1 intersects: empty2);		deny: (empty1 intersects: rect1);		deny: (empty2 intersects: rect1);		deny: (empty1 intersects: empty2);		deny: (empty2 intersects: empty1).! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:29'!testRotate	| r1 c r1Left r1Right r1Pi |	r1 := 30@10 extent: 10@20.	c := 5@5.	r1Left := r1 rotateBy: #left centerAt: c.	r1Right := r1 rotateBy: #right centerAt: c.	r1Pi := r1 rotateBy: #pi centerAt: c.		self assert: r1 area = r1Left area description: 'rotation preserves area'.	self assert: r1 area = r1Right area description: 'rotation preserves area'.	self assert: r1 area = r1Pi area description: 'rotation preserves area'.		self assert: r1 extent transposed = r1Left extent.	self assert: r1 extent transposed = r1Right extent.	self assert: r1 extent = r1Pi extent.		self assert:  (r1 rotateBy: #pi centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:29'!testRotateEmpty	| r1 c r1Left r1Right r1Pi |	r1 := 30@10 corner: 10@20.	c := 5@5.	r1Left := r1 rotateBy: #left centerAt: c.	r1Right := r1 rotateBy: #right centerAt: c.	r1Pi := r1 rotateBy: #pi centerAt: c.		self assert: r1 area = r1Left area description: 'rotation preserves area'.	self assert: r1 area = r1Right area description: 'rotation preserves area'.	self assert: r1 area = r1Pi area description: 'rotation preserves area'.		self assert: r1 extent transposed = r1Left extent.	self assert: r1 extent transposed = r1Right extent.	self assert: r1 extent = r1Pi extent.		self assert:  (r1 rotateBy: #pi centerAt: r1 center) = r1! !"GraphicsTests"!!InstallerUpdateStream methodsFor: 'updates' stamp: 'nice 6/11/2010 21:25' prior: 57654784!parseUpdateListContents: listContentString	"Parse the contents of an updates.list into {{releaseTag. {fileNames*}}*}, and return it."	| sections releaseTag strm line fileNames |	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	releaseTag := nil.	strm := ReadStream on: listContentString.	[strm atEnd] whileFalse:		[line := strm nextLine.		line size > 0 ifTrue:			[line first = $#				ifTrue: [releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].						releaseTag := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].	^ sections asArray! !"Installer-Core"!!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19' prior: 19502300!testEpoch	self assert: aDateAndTime =  '1901-01-01T00:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19' prior: 19506189!testNoon	self assert: aDateAndTime noon = '1901-01-01T12:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20' prior: 19506473!testOffset	self assert: aDateAndTime offset =  '0:00:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '1901-01-01T00:00:00+12:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20' prior: 19509479!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:12:00:00') =  '1901-01-01T12:00:00+12:00' asDateAndTime! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:35'!testLn	self assert: ((1/100) ln closeTo: -2 * 10 ln).	self assert: (((2 raisedTo: Float emax + 11)/3) ln closeTo: (Float emax + 11)*2 ln - 3 ln) description: 'Fraction>>ln should not overflow'.	self assert: ((3/(2 raisedTo: Float precision - Float emin)) ln closeTo: (Float emin - Float precision)*2 ln + 3 ln) description: 'Fraction>>ln should not underflow'! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:37'!testLog	self assert: ((1/100) log closeTo: -2).	self assert: (((2 raisedTo: Float emax + 11)/3) log closeTo: (Float emax + 11)*2 log - 3 log) description: 'Fraction>>log should not overflow'.	self assert: ((3/(2 raisedTo: Float precision - Float emin)) log closeTo: (Float emin - Float precision)*2 log + 3 log) description: 'Fraction>>log should not underflow'! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21' prior: 19518172!testMidnight	self assert: aDateAndTime midnight =  '2004-02-29T00:00:00+00:00' asDateAndTime.	self deny: aDateAndTime midnight =  '2004-02-29T00:00:00+02:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21' prior: 19519063!testNoon	self assert: aDateAndTime noon =  '2004-02-29T12:00:00+00:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21' prior: 19519213!testOffset	self assert: aDateAndTime offset =  '0:02:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '2004-02-29T13:33:00+12:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:22' prior: 19520535!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:02:00:00') =  '2004-02-29T13:33:00+02:00' asDateAndTime! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 5/28/2010 21:28'!testLn	self assert: (100 ln closeTo: 10 ln*2).	self assert: ((2 raisedTo: Float emax + 3) ln closeTo: 2 ln*(Float emax + 3)) description: 'Integer>>ln should not overflow'! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:37'!testLog	self assert: (100 log closeTo: 2).	self assert: ((2 raisedTo: Float emax + 3) log closeTo: 2 log*(Float emax + 3)) description: 'Integer>>log should not overflow'! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'cmm 6/14/2010 17:23' prior: 19525736!testReadFromself assert: ('-1199-01-05T20:33:14.321-05:00' asDateAndTime printString = '-1199-01-05T20:33:14.321-05:00').self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').self assert: (' 2002-05-16T17:20' asDateAndTime printString = '2002-05-16T17:20:00+00:00').self assert: ('2002-05-16T17:20:45' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime = '2002-05-16T17:20:45-02:34' asDateAndTime).self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime = '2002-05-16T17:20:45+00:00' asDateAndTime).self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime = '1997-04-26T01:02:03+01:02:3' asDateAndTime)! !"KernelTests"!!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04' prior: 58063563!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay time0 |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[true] whileTrue: [			| observedProcess startTime |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"			SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |				gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04' prior: 58065045!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess := Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[ true ] whileTrue: [			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |			gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0 ]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04' prior: 58066632!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [			[				| startTime |				startTime := Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess 						ifTrue: [ observedProcess ]						ifFalse: [ nil ])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |		gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].	time := Time millisecondClockValue - time0! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:21' prior: 54160291!summaryStringDelta: delta	"Answer the string summarizing this changeSet"		^ String streamContents:		[:s | | line author s2 ps intName date |		intName := self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps := self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 := ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date := s2 nextLine.			s2 match: 'Author:'; skipSeparators.  author := s2 nextLine.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line := s2 nextLine.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/8/2010 18:26'!standardSize	^ StandardSize! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/9/2010 15:12'!standardSize: extent	StandardSize := extent! !!ProjectLauncher methodsFor: 'running' stamp: 'ar 6/21/2010 20:33' prior: 58616709!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (Smalltalk documentPath) ifNil:[''].			scriptName := scriptName convertFromSystemString.			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[					"Allow for ../dir/scriptName arguments"					scriptName := (FileDirectory default uri 						resolveRelativeURI: scriptName) asString]].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!Utilities class methodsFor: 'miscellaneous' stamp: 'nice 6/11/2010 21:30' prior: 55315920!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict := Dictionary new.	report := ReadWriteStream on: ''.	f := FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f := FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className := items first.			newInstCount := items third asNumber.			newSpace := items fourth asNumber.			oldPair := instCountDict at: className ifAbsent: [nil].			oldInstCount := oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace := oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'common requests' stamp: 'nice 6/11/2010 21:55' prior: 55312656!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].		strings := CommonRequestStrings contents.	normalItemCount := strings asString lineCount.	aMenu := UIManager default 		chooseFrom: (strings asString lines copyWith: 'edit this menu')		lines: (Array with: normalItemCount).	index := aMenu startUp.	index == 0 ifTrue: [^ self].	reply := aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result := self evaluate: reply in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'fetching updates' stamp: 'nice 6/11/2010 21:30' prior: 55284392!parseListContents: listContents	| sections vers strm line fileNames |	"Parse the contents of updates.list into {{vers. {fileNames*}}*}, and return it."	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	vers := nil.	strm := ReadStream on: listContents.	[strm atEnd] whileFalse:		[line := strm nextLine.		line size > 0 ifTrue:			[line first = $#				ifTrue: [vers ifNotNil: [sections addLast: {vers. fileNames asArray}].						"Start a new section"						vers := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	vers ifNotNil: [sections addLast: {vers. fileNames asArray}].	^ sections asArray" TEST: | list |list := Utilities parseListContents: (FileStream oldFileNamed: 'updates.list') contentsOfEntireFile.list = (Utilities parseListContents: (String streamContents: [:s | Utilities writeList: list toStream: s]))	ifFalse: [self error: 'test failed']	ifTrue: [self inform: 'test OK']"! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26' prior: 58497610!cleanUp: aggressive except: exclusions	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	^self cleanUp: aggressive except: exclusions confirming: aggressive! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26'!cleanUp: aggressive except: exclusions confirming: aBool	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	| classes |	aBool ifTrue:[		"Give the user a chance to bail"		(self confirm: 'Cleanup will destroy projects, change sets and more.Are you sure you want to proceed?') ifFalse:[^self].	].	"Find all classes implementing #cleanUp or cleanUp:"	classes := Smalltalk allClasses select:[:aClass| 		(aClass class includesSelector: #cleanUp) 			or:[aClass class includesSelector: #cleanUp:]	].	"Leave out the classes in the exclusion set"	classes := classes reject:[:aClass| exclusions includes: aClass].	"Arrange classes in superclass order, superclasses before subclasses.	This will ensure that specific cleanup (like MethodDictionary compaction)	will run after generic superclass cleanup (HashedCollection rehashing).	Otherwise generic superclass cleanup might undo specific one (in this	case rehashing will undo a good bit of MD compaction)."	classes := ChangeSet superclassOrder: classes.	"Run the cleanup code"	classes 		do:[:aClass| aClass cleanUp: aggressive]		displayingProgress:[:aClass| 'Cleaning up in ', aClass name].! !!SmalltalkImage methodsFor: 'vm' stamp: 'ar 6/21/2010 20:25'!isRunningCog	"Returns true if we're running Cog"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'special objects' stamp: 'ar 6/20/2010 16:20' prior: 58519841!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: nil. "Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray	! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ar 6/16/2010 19:54' prior: 58601462!unloadAllKnownPackages	"Unload all packages we know how to unload and reload"	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	World removeAllMorphs.	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 'Installer-Core'		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC' 'ST80'		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols' 'XML-Parser' 'Tests' 'SUnitGUI'	) do:[:pkgName| (MCPackage named: pkgName) unload].	"Traits use custom unload"	Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits].	"Post-unload cleanup"	MCWorkingCopy flushObsoletePackageInfos.	SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	Smalltalk forgetDoIts.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.	MorphicProject defaultFill: (Color gray: 0.9).	World color: (Color gray: 0.9).! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'ar 6/14/2010 22:05' prior: 58472485!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'nice 6/11/2010 21:28' prior: 29355087!vmStatisticsShortString	"Convenience item for access to recent statistics only"	"StringHolderView open: (StringHolder new contents: SmalltalkImage current vmStatisticsShortString)		label: 'VM Recent Statistics'"	^ (ReadStream on: self vmStatisticsReportString) upToAll: 'Since'; nextLine; upToEnd! !!ResourceManager class methodsFor: 'resource caching' stamp: 'nice 6/11/2010 21:27' prior: 55906828!reloadCachedResources	"ResourceManager reloadCachedResources"	"Reload cached resources from the disk"	| fd files stream url localName storeBack archiveName |	CachedResources := Dictionary new.	LocalizedExternalResources := nil.	fd := Project squeakletDirectory.	files := fd fileNames asSet.	stream := [fd readOnlyFileNamed: self resourceCacheName]				on: FileDoesNotExistException 				do:[:ex| fd forceNewFileNamed: self resourceCacheName].	stream size < 50000 ifTrue:[stream := ReadStream on: stream contentsOfEntireFile].	storeBack := false.	[stream atEnd] whileFalse:[		url := stream nextLine.			localName := stream nextLine.		(localName beginsWith: 'zip://') ifTrue:[			archiveName := localName copyFrom: 7 to: localName size.			(files includes: archiveName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true].		] ifFalse:[			(files includes: localName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true]		].	].	stream close.	storeBack ifTrue:[		stream := fd forceNewFileNamed: self resourceCacheName.		CachedResources keysAndValuesDo:[:urlString :cacheLocs|			cacheLocs do:[:cacheLoc|				stream nextPutAll: urlString; cr.				stream nextPutAll: cacheLoc; cr].		].		stream close.	].! !!SpaceTally methodsFor: 'fileOut' stamp: 'nice 6/11/2010 21:28' prior: 52633485!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f := FileStream readOnlyFileNamed: fileName1.	coll1 := OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: f nextLine].	f close.	f := FileStream readOnlyFileNamed: fileName2.	coll2 := OrderedCollection new.	[f atEnd] whileFalse:		[item := f nextLine.		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!ChangeRecord methodsFor: 'access' stamp: 'eem 4/23/2007 10:37'!commentClass 	| commentClass |	type == #classComment ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	commentClass := Smalltalk at: class asSymbol.	^meta ifTrue: [commentClass class]		ifFalse: [commentClass]! !!ChangeRecord methodsFor: 'initialization' stamp: 'eem 7/17/2008 17:19' prior: 54084293!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := Smalltalk at: class asSymbol.				 cls := meta ifTrue: [cls class] ifFalse: [cls].				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[Utilities noteMethodSubmission: aSelector forClass: cls]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					Utilities noteMethodSubmission: #Comment forClass: cls ].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 5/18/2010 20:25' prior: 18207825!fileIndex	SourceFiles withIndexDo: [:sf :i| sf name = file name ifTrue: [^i]].	^nil! !!ChangeRecord methodsFor: 'access' stamp: 'cmm 6/21/2010 13:28' prior: 58574648!methodClass	| methodClassName methodClass |	type == #method ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk globals includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass := Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 9/6/2009 13:06' prior: 18209491!methodClassName	| text tokens |	(class isNil	and: [type = #doIt	and: [((text := self text) includes: $.) not "exclude multi-statement doits"	and: [(tokens := Scanner new scanTokens: text) size >= 4	and: [tokens first isSymbol	and: [tokens first isKeyword not	and: [tokens first first canBeGlobalVarInitial	and: [tokens includes: #instanceVariableNames:]]]]]]]) ifTrue:		["Could be a class definition.			Class definitions start with Superclass blahSubclass: #ClassName			Metaclass definitions start with ClassName class instanceVariableNames:"		 (tokens second isSymbol		  and: [tokens second isKeyword		  and: [tokens third isSymbol		  and: [tokens third isKeyword not		  and: [(2 to: tokens size by: 2) allSatisfy: [:i| (tokens at: i) isKeyword]]]]]) ifTrue:			[^tokens third].		 (tokens size = 4		  and: [tokens second = #class		  and: [tokens third = #instanceVariableNames:		  and: [tokens last isString]]]) ifTrue:			[^tokens first]].	^class! !Preferences class removeSelector: #workspaceWindowColor!Preferences class removeSelector: #versionsBrowserWindowColor!Preferences class removeSelector: #transcriptWindowColor!Preferences class removeSelector: #testRunnerWindowColor!Preferences class removeSelector: #preferenceBrowserWindowColor!Preferences class removeSelector: #packageLoaderWindowColor!Preferences class removeSelector: #packageBrowserWindowColor!Preferences class removeSelector: #monticelloToolWindowColor!Preferences class removeSelector: #methodFinderWindowColor!Preferences class removeSelector: #messageNamesWindowColor!Preferences class removeSelector: #messageListWindowColor!Preferences class removeSelector: #lexiconWindowColor!Preferences class removeSelector: #instanceBrowserWindowColor!Preferences class removeSelector: #fileListWindowColor!Preferences class removeSelector: #fileContentsBrowserWindowColor!Preferences class removeSelector: #dualChangeSorterWindowColor!Preferences class removeSelector: #defaultWindowColor!Preferences class removeSelector: #debuggerWindowColor!Preferences class removeSelector: #classCommentVersionsBrowserWindowColor!Preferences class removeSelector: #changeSorterWindowColor!Preferences class removeSelector: #changeListWindowColor!Preferences class removeSelector: #browserWindowColor!"System"!!PluggableSystemWindowWithLabelButton commentStamp: 'eem 6/29/2010 19:02' prior: 0!A PluggableSystemWindowWithLabelButton provides the pull-down menu of browser panes in the multi-pane browser.Instance Variables	labelButton:		<BrowserPaneButtonMorph>labelButton	- the labelButton is a hack to hold onto the panes of a multi-paned browser so that an inst var doesn't have to be added to the Browser hierarchy.!!SystemWindow commentStamp: '<historical>' prior: 59440910!SystemWindow is the Morphic equivalent of StandardSystemView -- a labelled container for rectangular views, with iconic facilities for close, collapse/expand, and resizing.The attribute onlyActiveOnTop, if set to true (and any call to activate will set this), determines that only the top member of a collection of such windows on the screen shall be active.  To be not active means that a mouse click in any region will only result in bringing the window to the top and then making it active.!!MultiWindowLabelButtonMorph commentStamp: 'eem 6/30/2010 16:13' prior: 0!A MultiWindowLabelButtonMorph is  a means of implementing tabbed windows.  It cooperates with PluggableSystemWindowWithButton to provide a drop-down menu of windows when clicking in the window label.  It requires the model to create a suitable sub-instance of SavedMultiWindowState for inactive windows.  To specify multi-windows use the multiWindowStyle: setter to customize a PluggableWindowSpec.Instance Variables	savedMultiWindowState:		<SavedMultiWindowState>savedMultiWindowState	- the sequence of models in a multi-window.!!MenuMorph methodsFor: 'construction' stamp: 'nice 6/11/2010 21:52' prior: 23650369!labels: labelList lines: linesArray selections: selectionsArray 	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelArray := (labelList isString) 				ifTrue: [labelList lines]				ifFalse: [labelList]. 	1 to: labelArray size		do: 			[:i | 			self add: (labelArray at: i) action: (selectionsArray at: i).			(linesArray includes: i) ifTrue: [self addLine]]! !!Canvas methodsFor: 'initialization' stamp: 'ar 6/17/2010 16:43'!finish: allDamage	"If there are any pending operations on the receiver complete them. 	Do not return before all modifications have taken effect."	^self finish! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'eem 6/24/2010 21:51' prior: 33718761!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk classNamed: #HelpBrowser) ifNotNil: 					[:classHelpBrowser|					menu addLine.					menu addItem: [ :item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: classHelpBrowser;							selector: #open ] ].			]].! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'nice 6/11/2010 21:52' prior: 58178093!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j |	menu := self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString := aPopupMenu labelString.	items := labelString asString lines.	labelString isText ifTrue:		["Pass along text emphasis if present"		j := 1.		items := items collect:			[:item | | emphasis |			j := labelString asString findString: item startingAt: j.			emphasis := TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines := aPopupMenu lineArray.	lines ifNil: [lines := #()].	menu cancelValue: 0.	menu defaultTarget: menu.	selections := (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) selector: #selectMVCItem: argument: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !!ProportionalSplitterMorph methodsFor: 'displaying' stamp: 'ar 6/23/2010 16:35' prior: 58957096!handleSize	^ self class splitterWidth @ 30! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 17:00' prior: 21481566!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ (submorphs anySatisfy: [ :ea | ea visible ])			or: [ (temporaryCursor notNil and: [hardwareCursor isNil])				or: [ self hasUserInformation ]]])		ifTrue: [			"using the software cursor; hide the hardware one"			self showHardwareCursor: false.			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:28' prior: 21484016!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged := false.	savedPatch ifNotNil: 			[aCanvas drawImage: savedPatch at: savedPatch offset.			self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"			submorphs notEmpty ifTrue: [^self].			(temporaryCursor notNil and: [hardwareCursor isNil]) ifTrue: [^self].			"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset 						extent: savedPatch extent + self shadowOffset)				from: self.			self showHardwareCursor: true.			savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:52'!showHardwareCursor: aBool	"Show/hide the current hardware cursor as indicated."	| cursor |	cursor :=  hardwareCursor ifNil:[aBool ifTrue:[Cursor normal] ifFalse:[Cursor blank]].	Sensor currentCursor == cursor ifFalse: [cursor show].! !!HandMorph methodsFor: 'cursor' stamp: 'ar 6/17/2010 17:01' prior: 21474240!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset 	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	temporaryCursorOffset 		ifNotNil: [bounds := bounds translateBy: temporaryCursorOffset negated].	cursorOrNil isNil 		ifTrue: [temporaryCursor := temporaryCursorOffset := hardwareCursor := nil]		ifFalse: 			[temporaryCursor := cursorOrNil asCursorForm.			temporaryCursorOffset := temporaryCursor offset - hotSpotOffset.			(cursorOrNil isKindOf: Cursor) ifTrue: [hardwareCursor := cursorOrNil]].	bounds := self cursorBounds.	self		userInitials: userInitials andPicture: self userPicture;		layoutChanged;		changed;		showHardwareCursor: (temporaryCursor isNil).! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 19:51' prior: 54590543!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode handsToDraw allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	canvas roundCornersOf: aWorld during:[ | handDamageRects worldDamageRects |		worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage := worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish: allDamage.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 16:04' prior: 53154502!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	remoteServer ifNotNil:[		self assuredCanvas.		^true].	properDisplay := canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	].	^ true! !!Morph methodsFor: 'events-processing' stamp: 'bf 6/24/2010 13:15' prior: 24159366!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	(anEvent controlKeyPressed			and: [anEvent blueButtonChanged not				and: [Preferences cmdGesturesEnabled]])		ifTrue: [^ self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].		"this mouse down could be the start of a gesture, or the end of a gesture focus"	(self isGestureStart: anEvent)		ifTrue: [^ self gestureStart: anEvent].	self mouseDown: anEvent.	Preferences maintainHalos		ifFalse:[ anEvent hand removeHaloFromClick: anEvent on: self ].	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 8/10/2007 16:58' prior: 51237360!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := (aDisplayTransform globalBoundsToLocal: innerRect) truncated.	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; cellSize: cellSize; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!PasteUpMorph methodsFor: 'project state' stamp: 'ar 6/17/2010 20:00'!canvas: aCanvas	"Set this world's canvas"	worldState canvas: aCanvas.! !!PasteUpMorph methodsFor: 'change reporting' stamp: 'ar 6/17/2010 17:28' prior: 25784325!invalidRect: damageRect from: aMorph	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [worldState recordDamagedRect: damageRect].	^super invalidRect: damageRect from: aMorph! !!PluggableSystemWindowWithLabelButton methodsFor: 'resize/collapse' stamp: 'eem 5/6/2008 12:58'!adjustExtraButton	labelButton ifNil: [^self].	labelButton		position: self innerBounds topLeft + (20 @ -3);		extent: self innerBounds extent * (0.4@1)! !!PluggableSystemWindowWithLabelButton methodsFor: 'geometry' stamp: 'eem 5/6/2008 10:45'!extent: newExtent	super extent: newExtent.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton methodsFor: 'events' stamp: 'eem 6/30/2010 16:47'!mouseDown: evt	| wasInactive |	wasInactive := TopWindow ~~ self.	self valueOfProperty: #clickPoint ifPresentDo: 		[:firstClick |		(labelButton containsPoint: evt cursorPoint) ifTrue:			[^labelButton mouseDown: evt]].	super mouseDown: evt.	(wasInactive	 and: [model windowActiveOnFirstClick not	 and: [labelButton containsPoint: evt cursorPoint]]) ifTrue:		[^labelButton mouseDown: evt]! !!PluggableSystemWindowWithLabelButton methodsFor: 'top window' stamp: 'eem 5/6/2008 11:39'!passivate	super passivate.	self removeProperty: #clickPoint! !!PluggableSystemWindowWithLabelButton methodsFor: 'accessing' stamp: 'eem 6/30/2010 18:56'!savedMultiWindowState: aSavedMultiWindowState	labelButton := MultiWindowLabelButtonMorph						on: aSavedMultiWindowState						getState: nil						action: #selectWindowsMenu.	labelButton		triggerOnMouseDown: true;		savedMultiWindowState: aSavedMultiWindowState.	labelButton		layoutFrame: (LayoutFrame "i.e. in the left 40% of the title bar"						fractions: (0@0 corner: 0.4@0)						offsets: (20@ -20 corner: 0@0));		hResizing: #spaceFill;		vResizing: #spaceFill.	self addMorphFront: labelButton.	self adjustExtraButton! !!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:12'!resizeAlongEdges	<preference: 'Resize Windows along edges'		category: 'Morphic'		description: 'When true, windows can be resized along their edges as well as the corners'		type: #Boolean>	^ResizeAlongEdges ifNil:[true]! !!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:13'!resizeAlongEdges: aBool	"Preference setter"	ResizeAlongEdges := aBool! !!SystemWindow methodsFor: 'initialization' stamp: 'ar 6/23/2010 17:13'!addCornerGrips	"When enabled via preference, also add edge grips"	super addCornerGrips.	self class resizeAlongEdges ifTrue:[self addEdgeGrips].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'cmm 6/20/2010 16:54' prior: 52764322!collapseOrExpand	"Collapse or expand the window, depending on existing state"	| cf |	isCollapsed		ifTrue: 			["Expand -- restore panes to morphics structure"			isCollapsed := false.			self activate.  "Bring to frint first"			Preferences collapseWindowsInPlace				ifTrue: 					[fullFrame := fullFrame align: fullFrame topLeft with: self getBoundsWithFlex topLeft]				ifFalse:					[collapsedFrame := self getBoundsWithFlex].			collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse this window'].			self setBoundsWithFlex: fullFrame.			paneMorphs reverseDo: 					[:m |  self addMorph: m unlock.					self world startSteppingSubmorphsOf: m].			self addPaneSplitters]		ifFalse: 			["Collapse -- remove panes from morphics structure"			isCollapsed := true.			fullFrame := self getBoundsWithFlex.			"First save latest fullFrame"			paneMorphs do: [:m | m delete; releaseCachedState].			self removePaneSplitters.			self removeCornerGrips.			model modelSleep.			cf := self getCollapsedFrame.			(collapsedFrame isNil and: [Preferences collapseWindowsInPlace not]) ifTrue:				[collapsedFrame := cf].			self setBoundsWithFlex: cf.			collapseBox ifNotNil: [collapseBox setBalloonText: 'expand this window'].			expandBox ifNotNil: [expandBox setBalloonText: 'expand to full screen'].			self sendToBack].	self layoutChanged! !!SystemWindow methodsFor: 'open/close' stamp: 'eem 5/23/2008 13:17' prior: 52758255!delete	| thisWorld sketchEditor aPaintBox |	self mustNotClose ifTrue: [^self].	model okToClose ifFalse: [^self].	thisWorld := self world.	sketchEditor := self extantSketchEditor.	self isFlexed		ifTrue: [owner delete]		ifFalse: [super delete].	model windowIsClosing; release.	model := nil.	sketchEditor ifNotNil:		[sketchEditor deleteSelfAndSubordinates.		 (thisWorld notNil 		  and: [(aPaintBox := thisWorld paintBoxOrNil) notNil]) ifTrue:			[aPaintBox delete]].			SystemWindow noteTopWindowIn: thisWorld! !!TheWorldMenu methodsFor: 'construction' stamp: 'cmm 6/13/2010 20:39' prior: 53553284!changesMenu        "Build the changes menu for the world."        | menu |        menu := self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { ChangeSet current . #verboseFileOut}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSet . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { self  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions (R)' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.			nil.                { 'recently logged changes...' . { self . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        ^ menu! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'ar 6/23/2010 17:09'!addEdgeGrips	"Add resizers along the four edges of the receiver"	self		addMorphBack: (TopGripMorph new target: self;position: self position).	self		addMorphBack: (BottomGripMorph new target: self;position: self position).	self		addMorphBack: (RightGripMorph new target: self;position: self position).	self		addMorphBack: (LeftGripMorph new target: self;position: self position).! !!TextEditor methodsFor: 'menu messages' stamp: 'cmm 5/25/2010 12:59' prior: 58414502!prettyPrint: decorated 	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	selectedClass := model selectedClassOrMetaClass.	selectedClass ifNil: [ ^ morph flash ].	newText := selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[ self			deselect ;			selectInvisiblyFrom: 1			to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: self text size + 1 ]! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/20/2010 13:33'!drawOn: aCanvas	"aCanvas fillRectangle: self bounds color: Color red" "for debugging"! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:22'!setDefaultColors! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:21'!setInverseColors! !!BottomGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:37'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!BottomGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 1 corner: 1 @ 1)		offsets: (0 @ self defaultHeight negated corner: 0@ 0)! !!BottomGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!ptName	^#bottom! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!resizeCursor	^ Cursor resizeForEdge: #top! !!LeftGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:41'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!LeftGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:27'!defaultWidth	^ 5! !!LeftGripMorph methodsFor: 'accessing' stamp: 'ar 6/23/2010 16:51'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 0 @ 1)		offsets: (0 @ 0 negated corner: self defaultWidth @ 0)! !!LeftGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!ptName	^#left! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!resizeCursor	^ Cursor resizeForEdge: #left! !!RightGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:39'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!RightGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultWidth	^ 5! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (1 @ 0 corner: 1 @ 1)		offsets: (self defaultWidth negated @ self defaultHeight negated corner: 0@ 0)! !!RightGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!ptName	^#right! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!resizeCursor	^ Cursor resizeForEdge: #right! !!TopGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:22'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!TopGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:31'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ -40  corner: 0@ 0)! !!TopGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!ptName	^#top! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!resizeCursor	^ Cursor resizeForEdge: #top! !!BalloonCanvas methodsFor: 'drawing' stamp: 'jcg 11/17/2008 17:03' prior: 17206097!line: pt1 to: pt2 width: w color: c	"Draw a line from pt1 to: pt2"	(aaLevel == 1 and: [self ifNoTransformWithIn:(pt1 rect: pt2)])		ifTrue:[^super line: pt1 to: pt2 width: w color: c].	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:56' prior: 51317036!dragTarget: event	"Begin dragging the target"	| thePoint |	event controlKeyPressed ifTrue: [^self growTarget: event].	growingOrRotating := false.	thePoint := target point: event position - positionOffset from: owner.	target setConstrainedPosition: thePoint hangOut: true.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:44'!growTarget: event	"Begin resizing the target"	growingOrRotating := true.	positionOffset := event position.	originalExtent := target extent.	self removeAllHandlesBut: nil.	event hand newMouseFocus: self.	event hand addMouseListener: self. "add handles back on mouse-up"! !!HaloMorph methodsFor: 'event handling' stamp: 'bf 6/24/2010 15:40' prior: 51319462!mouseMove: evt	"Drag our target around or resize it"	growingOrRotating		ifTrue: [			| oldExtent newExtent newPosition |			newExtent := originalExtent + (evt position - positionOffset * 2).			(newExtent x > 1 and: [newExtent y > 1])				ifTrue: [					oldExtent := target extent.					target setExtentFromHalo: newExtent.					newPosition := target position - (target extent - oldExtent // 2).					target setConstrainedPosition: newPosition hangOut: true]]		ifFalse: [			| thePoint |			thePoint := target point: (evt position - positionOffset) from: owner.			target setConstrainedPosition: thePoint hangOut: true.		]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'ar 6/17/2010 19:52' prior: 56624449!accept 	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	ok := self acceptTextInModel.	ok==true ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNil:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok ifTrue: "(don't bother if there was an error during compile)"		[(model respondsTo: #updateCodePaneIfNeeded) 			ifTrue: [model updateCodePaneIfNeeded].		WorldState addDeferredUIMessage:			[self currentHand newKeyboardFocus: textMorph.			scroller offset: saveScrollerOffset.			self setScrollDeltas.			selectionInterval := saveSelection. "restore prior selection"			self selectFrom: saveSelection first to: saveSelection last]]]			on: Error do: []! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48' prior: 26493780!extent: newExtent	bounds extent = newExtent ifTrue: [^ self].	super extent: (newExtent max: 36@16).	self setScrollDeltas! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 10:17' prior: 56621260!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph notNil ifTrue:		["the current selection gets munged by resetting the extent, so store it"		tempSelection := self selectionInterval.				"don't reset it if it's not active"		tempSelection = (Interval from: 1 to: 0) 						ifTrue: [retractableScrollBar							ifTrue:[ ^ self]].		self extent: self extent.		self setSelection: tempSelection].	super resetExtent.! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48'!resizeScroller	"Also needs to resize the text morph"	super resizeScroller.	textMorph ifNotNil:		[textMorph extent: (self innerBounds width-6)@self height].! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'cmm 6/13/2010 20:50' prior: 52882537!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	defaultLineHeight := scanner canComputeDefaultLineHeight		ifTrue: [ scanner computeDefaultLineHeight ]		ifFalse: [ theTextStyle lineGrid. ].	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!MultiWindowLabelButtonMorph methodsFor: 'drawing' stamp: 'eem 5/6/2008 13:24'!drawOn: aCanvas 	"Be invisible."! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 17:03'!performAction	"Override to interpret the actionSelector as a menu accessor and to activate that menu."	actionSelector ifNotNil:		[(model perform: actionSelector) ifNotNil:			[:menu|			menu				invokeModalAt: self position - (0@5)				in: ActiveWorld				allowKeyboard: Preferences menuKeyboardControl]]! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState	"Answer the value of savedMultiWindowState"	^ savedMultiWindowState! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState: anObject	"Set the value of savedMultiWindowState"	savedMultiWindowState := anObject! !"Morphic"!!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 5/26/2010 02:20' prior: 59040175!nextFromStream: aStream	| character value1 value2 unicode value3 value4 |	aStream isBinary ifTrue: [ ^aStream basicNext ].	character := aStream basicNext ifNil: [ ^nil ].	value1 := character asciiValue.	value1 <= 127 ifTrue: [ ^character ]. "1-byte character" 	"at least 2-byte character"	character := aStream basicNext ifNil: [ ^self errorMalformedInput ].	value2 := character asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63) ].	"at least 3-byte character"	character := aStream basicNext ifNil: [ ^self errorMalformedInput ].	value3 := character asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63) ].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte character"		character := aStream basicNext ifNil: [ ^self errorMalformedInput ].		value4 := character asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63) ].	unicode ifNil: [ ^self errorMalformedInput ].	unicode > 16r10FFFD ifTrue: [ ^self errorMalformedInput ].	unicode = 16rFEFF ifTrue: [ ^self nextFromStream: aStream ].	^ Unicode value: unicode.! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:03' prior: 51905758!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!EUCTextConverter methodsFor: 'conversion' stamp: 'ul 5/26/2010 04:00' prior: 53383015!nextFromStream: aStream	| character1 character2 offset value1 value2 nonUnicodeChar |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext ifNil: [^ nil].	character1 asciiValue <= 127 ifTrue: [^ character1].	character2 := aStream basicNext ifNil: [^ nil].	offset := 16rA1.	value1 := character1 asciiValue - offset.	value2 := character2 asciiValue - offset.	(value1 < 0 or: [value1 > 93]) ifTrue: [^ nil].	(value2 < 0 or: [value2 > 93]) ifTrue: [^ nil].	nonUnicodeChar := Character leadingChar: self leadingChar code: value1 * 94 + value2.	^ Character leadingChar: self languageEnvironment leadingChar code: nonUnicodeChar asUnicode.! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:21' prior: 56354756!parseCompositionMappingFrom: stream"	self halt.	self parseCompositionMapping"	| line fieldEnd point fieldStart compositions toNumber diacritical result |	toNumber := [:quad | ('16r', quad) asNumber].	Compositions := IdentityDictionary new: 2048.	Decompositions := IdentityDictionary new: 2048.	Diacriticals := IdentitySet new: 2048.	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.		2 to: 6 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		compositions := line copyFrom: fieldStart to: fieldEnd - 1.		(compositions size > 0 and: [compositions first ~= $<]) ifTrue: [			compositions := compositions substrings collect: toNumber.			compositions size > 1 ifTrue: [				diacritical := compositions first.				Diacriticals add: diacritical.				result := compositions second.				(Decompositions includesKey: point) ifTrue: [					self error: 'should not happen'.				] ifFalse: [					Decompositions at: point put: (Array with: diacritical with: result).				].				(Compositions includesKey: diacritical) ifTrue: [					(Compositions at: diacritical) at: result put: point.				] ifFalse: [					Compositions at: diacritical						put: (IdentityDictionary new at: result put: point; yourself).				].			].		].	].! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:13' prior: 51899223!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!Unicode class methodsFor: 'class methods' stamp: 'nice 6/11/2010 21:29' prior: 56350120!parseUnicodeDataFrom: stream"	self halt.	self parseUnicodeDataFile"	| line fieldEnd point fieldStart toNumber generalCategory decimalProperty |	toNumber := [:quad | ('16r', quad) asNumber].	GeneralCategory := SparseLargeTable new: 16rE0080 chunkSize: 1024 arrayClass: Array base: 1 defaultValue:  'Cn'.	DecimalProperty := SparseLargeTable new: 16rE0080 chunkSize: 32 arrayClass: Array base: 1 defaultValue: -1.	16r3400 to: 16r4DB5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16r4E00 to: 16r9FA5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16rAC00 to: 16rD7FF do: [:i | GeneralCategory at: i+1 put: 'Lo'].	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := toNumber value: (line copyFrom: 1 to: fieldEnd - 1).		point > 16rE007F ifTrue: [			GeneralCategory zapDefaultOnlyEntries.			DecimalProperty zapDefaultOnlyEntries.			^ self].		2 to: 3 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		generalCategory := line copyFrom: fieldStart to: fieldEnd - 1.		GeneralCategory at: point+1 put: generalCategory.		generalCategory = 'Nd' ifTrue: [			4 to: 7 do: [:i |				fieldStart := fieldEnd + 1.				fieldEnd := line indexOf: $; startingAt: fieldStart.			].			decimalProperty :=  line copyFrom: fieldStart to: fieldEnd - 1.			DecimalProperty at: point+1 put: decimalProperty asNumber.		].	].	GeneralCategory zapDefaultOnlyEntries.	DecimalProperty zapDefaultOnlyEntries.! !"Multilingual"!!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23' prior: 51069272!readFrom: aStream	"Private"	| header |	header := aStream nextLine.	(header = 'Event Tape v1 BINARY') ifTrue:[^aStream fileInObjectAndCode].	(header = 'Event Tape v1 ASCII') ifTrue:[^self readFromV1: aStream].	"V0 had no header so guess"	aStream reset.	header first isDigit ifFalse:[^self convertV0Tape: (aStream fileInObjectAndCode)].	^self convertV0Tape: (self readFromV0: aStream).! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23' prior: 54183309!readFromV0: aStream	^Array streamContents:[:tStream | | evt line t lineStream |		[aStream atEnd] whileFalse:			[line := aStream nextLine.			line isEmpty "Some MW tapes have an empty record at the end"				ifFalse: [lineStream := ReadStream on: line.						t := Integer readFrom: lineStream.						[lineStream peek isLetter] whileFalse: [lineStream next].						evt := MorphicEvent readFromObsolete: lineStream.						tStream nextPut: t -> evt]]].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:24' prior: 51072021!readFromV1: aStream	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:[			tStream nextPut: (MorphicEvent readFromString: aStream nextLine)]]! !!PostscriptCanvas methodsFor: 'private' stamp: 'cmm 6/21/2010 14:31' prior: 52210791!setColor: color 	(color notNil and: [ currentColor ~= color ]) ifTrue:		[ target write: color asColor.		currentColor := color ]! !!TextOnCurve methodsFor: 'display' stamp: 'bf 6/17/2010 19:19' prior: 54242838!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| warp lineRect lineCanvas backgroundColor lineForm leftInRun sourceQuad maxExtent |	"most of these temps are initialized lazily and need to be at the method level - do not move into the block below!!"	warp := nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may not have to display at all."				maxExtent := lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm := Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect := lineForm boundingBox.				leftInRun := 0.				backgroundColor := (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp := (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas := lineForm getCanvas].			sourceQuad := destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun := displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !"MorphicExtras"!!TextAnchorTest methodsFor: 'initialize-release' stamp: 'cmm 6/12/2010 22:46'!testBeginWithAnAnchor	| text morph model |	text := Text streamContents:		[ : stream | stream			 nextPutAll:			(Text				string: (String value: 1)				attributes: {TextAnchor new anchoredMorph: Morph new. 					TextColor color: Color transparent}) ;			 nextPutAll: ' should be able to begin with an embedded object. ' ].	model := text -> nil.	morph := PluggableTextMorph		on: model		text: #key		accept: nil.	[ morph openInWorld ] ensure: [ morph delete ]! !"MorphicTests"!!MailMessage methodsFor: 'parsing' stamp: 'nice 6/11/2010 21:26' prior: 23410053!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	^aStream nextLine! !!Password methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:52' prior: 52103862!serverPasswords	"Get the server passwords off the disk and decode them. The file 'sqk.info' must be in some folder that Squeak thinks is special (vm folder, or default directory).  (Note: This code works even if you are running with no system sources file.)"	| sfile |	(sfile := FileDirectory lookInUsualPlaces: 'sqk.info') ifNil: [^ nil].		"If not there, Caller will ask user for password"		"If you don't have this file, and you really do want to release an update, 		 contact Ted Kaehler."	^ (self decode: (sfile contentsOfEntireFile)) lines! !"Network"!!PackageOrganizer methodsFor: 'registering' stamp: 'ar 6/16/2010 19:57'!flushObsoletePackages: aBlock	"Flush all packages considered obsolete by evaluating the argument block."	packages keys do:[:key|		(aBlock value: (packages at: key)) ifTrue:[packages removeKey: key].	].	self changed: #packages; changed: #packageNames.! !"PackageInfo-Base"!!Lexicon methodsFor: 'senders' stamp: 'nice 3/24/2010 23:21' prior: 56983634!navigateToASender	"Present the user with a list of senders of the currently-selected 	message, and navigate to the chosen one"	| selectorSet chosen aSelector |	aSelector := self selectedMessageName.	selectorSet := Set new.	(self systemNavigation allCallsOn: aSelector)		do: [:anItem | selectorSet add: anItem methodSymbol].	selectorSet := selectorSet				select: [:sel | currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass].	selectorSet size = 0		ifTrue: [^ Beeper beep].	self okToChange		ifFalse: [^ self].	chosen := UIManager default chooseFrom: selectorSet asSortedArray values: selectorSet asSortedArray.	chosen isEmptyOrNil		ifFalse: [self displaySelector: chosen]! !"Protocols"!!ControlManager methodsFor: 'scheduling' stamp: 'nice 6/11/2010 21:50' prior: 19310059!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'nice 6/11/2010 21:50' prior: 19315513!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers := OrderedCollection new.	labels := String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !"ST80"!!TestCase commentStamp: '<historical>' prior: 59442070!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!!TestCase methodsFor: 'running' stamp: 'dtl 6/6/2010 15:10' prior: 33847651!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout: [self setUp]		after: self timeoutForSetUp.	self timeout: [self performTest]		after: self timeoutForTest]		ensure: [self tearDown]! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 13:10'!timeout: seconds	"The timeout for a test should normally be set with a method annotation.	However, for tests that are expected to run in images that do not support	method annotations, the value may be set by setting the value from the	#setUp method (i.e. prior to running the test method)."	timeout := seconds! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:26'!timeoutForSetUp	"Answer the timeout to use for setUp"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^self defaultTimeout! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:07' prior: 33848995!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^timeout ifNil: [self defaultTimeout]! !"SUnit"!!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26'!expectedFailures	"Does crash VM with Cog"	^Smalltalk isRunningCog		ifTrue:[#(testAddNumbers testDNU testAnswer42)]		ifFalse:[#()]! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26' prior: 31119020!testAddNumbers 	"self debug: #testAddNumbers"	"Does crash VM with Cog"	Smalltalk isRunningCog ifTrue:[^self assert: false].	"md: I had to comment out the error... did strange things"	self class addSelector: #add:with: withMethod: ObjectsAsMethodsExample new.	self assert: (self add: 3 with: 4) = 7.	"self assert: (self perform: #add:with: withArguments: #(3 4)) = 7. "	self class basicRemoveSelector: #add:with:.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26' prior: 31119448!testAnswer42 	"Does crash VM with Cog"	Smalltalk isRunningCog ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: ObjectsAsMethodsExample new.	self assert: self answer42 = 42.	self class basicRemoveSelector: #answer42.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26' prior: 31119704!testDNU 	"Does crash VM with Cog"	Smalltalk isRunningCog ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: AbstractObjectsAsMethod new.	self should: [self answer42] raise: MessageNotUnderstood.	self class basicRemoveSelector: #answer42.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 5/27/2010 14:01'!testBlockDoitDecompilation	"Tests that decompile of a doit block with remote vars executes correcly"	"Tests that decompilation of a Block, when 'method' of block is equivalent to that compiled by a DoIt, preserves the temp names "		|blockSourceStream methodNode compiledMethod block decompiledBlock|	blockSourceStream := '|x y| [:a :b | x := a. y := b. x + y]' readStream.	methodNode := nil class evaluatorClass new 						from: blockSourceStream class: nil class context: nil notifying: nil;						translate: blockSourceStream noPattern: true ifFail: [nil].	compiledMethod := methodNode generateWithTempNames.	block := nil withArgs: #() executeMethod: compiledMethod.		self shouldnt: [decompiledBlock := block decompile] raise: Error.	self assert: '{[:a :b | x := a.	y := b.	x + y]}' equals: decompiledBlock printString! !"Tests"!!PluggableWindowSpec commentStamp: '<historical>' prior: 59378233!A common window. Expects to see change/update notifications when the label should change.Instance variables:	label	<String|Symbol> The selector under which to retrieve the label or the label directly	extent	<Point>	The (initial) extent of the window.	closeAction		<Symbol>	The action to perform when the window is closed.!!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:12' prior: 57472537!isDialog	^isDialog ifNil: [false]! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 7/1/2010 11:31'!multiWindowStyle	"Answer the value of multiWindowStyle, a Symbol or nil"	^multiWindowStyle! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:44'!multiWindowStyle: aSymbol	"Set the value of multiWindowStyle, one of #labelButton or #tabbed"	multiWindowStyle := aSymbol! !"ToolBuilder-Kernel"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'eem 7/1/2010 14:41' prior: 33859479!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	"By default, don't style in UIManager edit: requests"	window model		shouldStyle: false;		acceptAction: anAction;		acceptContents:  aText.	^window.! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'eem 6/30/2010 15:52' prior: 57481831!buildPluggableWindow: aSpec	| widget children |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec multiWindowStyle) new.	self register: widget id: aSpec name.	widget model: aSpec model.	aSpec label ifNotNil:		[:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	children := aSpec children.	children isSymbol ifTrue:[		widget getChildrenSelector: children.		widget update: children.		children := #().	].	widget closeWindowSelector: aSpec closeAction.	panes := OrderedCollection new.	self buildAll: children in: widget.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: (aSpec extent ifNil:[widget initialExtent])		world: self currentWorld).	widget setUpdatablePanesFrom: panes.	^widget! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'eem 6/30/2010 11:44'!windowClassFor: multiWindowStyle	^multiWindowStyle		caseOf:		{	[nil]				->	[PluggableSystemWindow].			[#labelButton]	->	[PluggableSystemWindowWithLabelButton] }		otherwise:				[PluggableSystemWindowWithLabelButton]! !"ToolBuilder-Morphic"!!ButtonStub methodsFor: 'simulating' stamp: 'cwp 7/14/2006 11:09' prior: 17918654!isEnabled	enabled ifNil: [enabled := spec model perform: spec enabled].	^ enabled! !!MenuStub methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2006 10:43' prior: 23688972!click: aString	| item |	item := self items detect: [:ea | ea label = aString] ifNone: [^ self].	item action isSymbol		ifTrue: [self model perform: item action]		ifFalse: [item action value]! !"ToolBuilder-SUnit"!!CodeHolder commentStamp: '<historical>' prior: 59244581!An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!Workspace commentStamp: 'ls 10/14/2003 12:13' prior: 59465141!A Workspace is a text area plus a lot of support for executable code.  It is a great place to execute top-level commands to compute something useful, and it is a great place to develop bits of a program before those bits get put into class methods.To open a new workspace, execute:	Workspace openA workspace can have its own variables, called "workspace variables", to hold intermediate results.  For example, if you type into a workspace "x := 5" and do-it, then later you could type in "y := x * 2" and y would become 10.Additionally, in Morphic, a workspace can gain access to morphs that are on the screen.  If acceptDroppedMorphss is turned on, then whenever a morph is dropped on the workspace, a variable will be created which references that morph.  This functionality is toggled with the window-wide menu of a workspace.The instance variables of this class are:	bindings  -  holds the workspace variables for this workspace	acceptDroppedMorphss - whether dropped morphs should create new variables!!SavedMultiWindowState commentStamp: 'eem 6/30/2010 15:45' prior: 0!A SavedMultiWindowState is a collection of states of inactive windows for a multi-window tool ui where one can select between multiple copies of a tool sharing a single system window, each tol having its own state.  It manages switching between windows, swapping unaccepted edit state (e.g. in text views) as it does so.Instance Variables	currentModelIndex:		<Integer>	modelDependents:		<IdentitySet>	modelStates:			<OrderedCollection of: (Array													with: modelState <Object>													with: unacceptedEditStates <WeakIdentityKeyDictionary>) >	models:					<OrderedCollection of: Model>currentModelIndex	- index into models and modelStates of current window selectionmodelDependents	- set of all dependentsmodelStates	- the pairs of model-specific selection state and widget-specfic unaccepted edit state for each unselected/inactive windowmodels	- the models for each window!!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:44' prior: 57747073!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList := aString lines asArray.	anArrayOrNil		ifNil: [linesArray := #()]		ifNotNil: [linesArray := anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font := aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:50' prior: 57747814!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray := labelList lines]		ifFalse: [labelArray := labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:53'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [displayContents text]! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:55'!unacceptedEditState: stateOrNil	(hasUnacceptedEdits := stateOrNil notNil) ifTrue:		[self editString: stateOrNil]! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:56'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [self text]! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 21:05'!unacceptedEditState: stateOrNil	stateOrNil		ifNotNil:			[self setText: stateOrNil.			 hasUnacceptedEdits := true "setText: clears hasUnacceptedEdits, so must do this post setText:"]		ifNil: [hasUnacceptedEdits := false]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	"This is a hook to allow browsers to control whether to respond to the muli-window preference.	 Currenty CodeHolder cannot usefully use multi-windows, but may be able to do so in the future."	^false! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 11:43'!useMultiWindowBrowsers	<preference: 'Multi-window browsers'		category: 'browsing'		description: 'When enabled, the browser uses a multi-window to conserve real-estate.  e.g. enable then click in the window label of a browser.'		type: #Boolean>	^MultiWindowBrowsers ifNil: [false]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 6/30/2010 21:37'!useMultiWindowBrowsers: aBoolean	MultiWindowBrowsers := aBoolean! !!CodeHolder methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 19:02'!multiWindowState: aSavedMultiWindowState	multiWindowState := aSavedMultiWindowState! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!addLookupPool: sharedPool	"Add a SharedPool that bindings should be looked up in."	LookupPools ifNil: [LookupPools := IdentitySet new].	LookupPools add: sharedPool! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 11:08'!clearLookupPools	LookupPools := nil.! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!removeLookupPool: sharedPool	"Workspaces should no longer look up bindings in the specified SharedPool."	LookupPools ifNil: [^self].	LookupPools remove: sharedPool ifAbsent: [].! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:16' prior: 33229320!bindingOf: aString 	mustDeclareVariables ifTrue: [^ nil].	"I want to have workspace that force the user to declare  	variables. Still subclasses may want to do something else"	bindings ifNil: [self initializeBindings].	(bindings includesKey: aString) ifFalse: [		| val |		val := self lookupInPools: aString.		val 			ifNotNil: [				"Caveat: since we're not inserting the pool's Association into				 the dictionary, assigning a new value to the variable will only				 affect the one Workspace (i.e. you can't assign to a variable in a				 SharedPool)."				bindings at: aString put: val]			ifNil: [aString first isUppercase					ifTrue: [^nil]					ifFalse: [bindings at: aString put: nil]]	].	^ bindings associationAt: aString! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:00'!lookupInPools: aString 	"Iterate through all of the lookup pools to find a match for the specified name."	LookupPools ifNil: [^nil].	LookupPools do: [:pool | (pool bindingOf: aString) ifNotNil: [:assoc | ^assoc value]].	^nil! !!HierarchyBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^true! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'nice 6/11/2010 21:53' prior: 57502443!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch := Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch := ch asCharacter asLowercase.	labels := labelString lines.	occurences := 0.	1 + selection to: selection + labels size do:		[:index |		| i | i := index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences := occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'nice 6/11/2010 21:53' prior: 57506461!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'cmm 6/15/2010 15:07' prior: 57507899!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := (allLabels copyFrom: from to: to) asOrderedCollection.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!Object methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^false! !!SavedMultiWindowState class methodsFor: 'instance creation' stamp: 'eem 6/30/2010 13:46'!on: aModel	^self new on: aModel! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:14'!addNewWindow	self addWindow: prototype clone! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 19:01'!addWindow: aModel	aModel multiWindowState: self.	self assert: models size = modelStates size.	models := models					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: aModel).	modelStates := modelStates					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: self emptyEditState).	self assert: models size = modelStates size.	self selectWindowIndex: (currentModelIndex = 0 ifTrue: [currentModelIndex := 1] ifFalse: [currentModelIndex + 1]).	self assert: models size = modelStates size.	1 to: models size do:		[:idx|		self assert: (idx = currentModelIndex					or: [(modelStates at: idx) isArray and: [(modelStates at: idx) size = 2]])]! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:10'!copyWindow	self addWindow: (models at: currentModelIndex) copy breakDependents! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 15:01'!currentModelIndex	^currentModelIndex! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!editState	| textState |	textState := WeakIdentityKeyDictionary new.	modelDependents do:		[:dep|		dep canHaveUnacceptedEdits ifTrue:			[textState at: dep put: dep unacceptedEditState]].	^textState! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 21:07'!emptyEditState	^#(nil ())! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 15:12'!initialize	models := OrderedCollection new.	modelStates := OrderedCollection new.	modelDependents := IdentitySet new.	currentModelIndex := 0! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 19:03'!models	^models! !!SavedMultiWindowState methodsFor: 'testing' stamp: 'eem 6/30/2010 22:11'!okToClose	"Answer if the unaccepted edit states are void.  If they are not then	 offer to select a window with non-empty unaccepted edit state."	modelStates withIndexDo:		[:savedState :index|		savedState ifNotNil:			[(savedState last anySatisfy: [:editState| editState notNil]) ifTrue:				[(PopUpMenu					confirm: 'One or more windows have unsaved changes.'					trueChoice: 'Close Anyway'					falseChoice: 'Select Unsaved') ifTrue: [^true].				 self selectWindowIndex: index.				 ^false]]].	^true! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 18:42'!on: aModel	prototype := aModel clone.	self addWindow: aModel! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 7/1/2010 10:40'!prototype	^prototype! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 21:15'!removeCurrentWindow	"Remove the current pane."	| deletedIndex |	self assert: models size > 1.	self assert: models size = modelStates size.	(models at: currentModelIndex) okToChange ifFalse:		[^self].	deletedIndex := currentModelIndex.	self selectWindowIndex: (currentModelIndex = 1								ifTrue: [currentModelIndex + 1]								ifFalse: [currentModelIndex - 1]).	models := models copyWithoutIndex: deletedIndex.	modelStates :=  modelStates copyWithoutIndex: deletedIndex.	currentModelIndex > deletedIndex ifTrue:		[currentModelIndex := currentModelIndex - 1].	(models at: currentModelIndex) changed: #relabel! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!restoreEditState: aWeakDictionary	aWeakDictionary keysAndValuesDo:		[:depOrNil :unacceptedEditState|		depOrNil ifNotNil:			[depOrNil unacceptedEditState: unacceptedEditState]]! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 21:09'!selectWindowIndex: index	| currentModel newModel newModelState |	index = currentModelIndex ifTrue: [^self].	currentModel := models at: currentModelIndex.	newModel := models at: index.	modelDependents addAll: currentModel dependents.	modelStates at: currentModelIndex put: { currentModel saveMultiWindowState. self editState }.	"the become makes things confusing.  currentModel will end up being newModel and vice verce"	models swap: currentModelIndex with: index.	currentModel become: newModel.	currentModel := models at: currentModelIndex.	newModel := models at: index.	newModel myDependents: (DependentsArray withAll: modelDependents asArray).	currentModel myDependents: nil.	"Change currentModelIndex before restoreMultiWIndowState: so label index is shown correctly"	currentModelIndex := index.	newModelState := modelStates at: index.	newModelState first ifNotNil: "emptyState has nil for savedModelState.  Don;t restore state for a new window"		[:savedModelState| newModel restoreMultiWindowState: savedModelState].	self restoreEditState: newModelState last.	modelStates at: index put: nil.	newModel changed: #relabel! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 18:30'!selectWindowsMenu	| menu currentItem |	menu := MenuMorph new defaultTarget: self.	models withIndexDo:		[:model :index| | entry |		entry := models size > 1					ifTrue: [index printString, '. ', model multiWindowName]					ifFalse: [model multiWindowName].		menu			add: (index = currentModelIndex					ifTrue: [Text string: entry attribute: TextEmphasis bold]					ifFalse:						[((modelStates at: index) last anySatisfy: [:editState| editState notNil])							ifTrue: [Text string: entry attribute: TextColor red]							ifFalse: [entry]])			target: self			selector: #selectWindowIndex:			argument: index.		index = currentModelIndex ifTrue:			[currentItem := menu lastItem]].	menu		addLine;		add: 'new window' target: self selector: #addNewWindow;		add: 'copy this window' target: self selector: #copyWindow;		add: 'remove this window' target: self selector: #removeCurrentWindow.	models size <= 1 ifTrue:		[menu lastItem isEnabled: false].	menu selectItem: currentItem event: nil.	^menu! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^true! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'eem 7/1/2010 10:22'!labelString	^self package		ifNil: [super labelString]		ifNotNil:			[:pkg| | label |			label := self defaultBrowserTitle, ': ', pkg, (self selectedClass														ifNil: ['']														ifNotNil: [' ', self selectedClass printString]).			(multiWindowState notNil			 and: [multiWindowState models size > 1]) ifTrue:				[label := (multiWindowState models indexOf: self) printString, '. ', label].			label]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:26'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self package			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 s nextPutAll: pkg; space.				 self selectedClass ifNotNil: [:class| s print: class].				 self metaClassIndicated ifTrue:					[s nextPutAll: ' class']].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:13'!restoreToPackage: packageNameOrNil category: category className: className protocol: protocol selector: selector mode: editMode	self packageListIndex: (self packageList indexOf: packageNameOrNil).	super restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:11'!saveMultiWindowState	^Message		selector: #restoreToPackage:category:className:protocol:selector:mode:		arguments: {	self package.						self systemCategoryList at: systemCategoryListIndex ifAbsent: [].						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						editSelection }! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:22' prior: 57783595!defaultContents	contents := list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState := #FileList.	^ contents! !!FileList methodsFor: 'file list' stamp: 'cmm 6/20/2010 16:35' prior: 33741793!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := self isGraphicsFileSelected		ifTrue: [#needToGetGraphic]		ifFalse: [#needToGetBrief]..	self 		changed: #fileListIndex ;		changed: #contents ;		changed: #labelString.	self updateButtonRow! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:30' prior: 57793282!labelString	^ directory		ifNil: [ 'File List' ]		ifNotNil:			[ fileName				ifNil: [ directory fullName ]				ifNotNil: [ directory fullNameFor: fileName ] ]! !!FileList methodsFor: 'private' stamp: 'cmm 6/20/2010 16:33' prior: 57806785!resort: newMode 	"Re-sort the list of files."	| name |	listIndex > 0 ifTrue: [ name := self fileNameFromFormattedItem: (list at: listIndex) ].	sortMode := newMode.	self pattern: pattern.	name ifNotNil:		[ fileName := name.		listIndex := list findFirst:			[ : item | (self fileNameFromFormattedItem: item) = name ].		self			 changed: #fileListIndex ;			 changed: #labelString ].	listIndex = 0 ifTrue: [ self changed: #contents ].	self updateButtonRow! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:34' prior: 57814436!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName := aStream localName.	pattern := '*'.	listIndex := 1.  "pretend a file is selected"	aStream close.	brevityState := #needToGetBrief.	self 		changed: #contents ; 		changed: #labelString! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 6/29/2010 17:58' prior: 58264274!changeListMenu: aMenu	"Fill aMenu up so that it comprises the primary changelist-browser menu"	aMenu addTitle: 'change list'.	aMenu addStayUpItemSpecial.	aMenu addList: #(	('fileIn selections'							fileInSelections						'import the selected items into the image')	('fileOut selections...	'						fileOutSelections						'create a new file containing the selected items')	-	('compare to current'						compareToCurrentVersion			'open a separate window which shows the text differences between the on-file version and the in-image version.' )	('toggle diffing (D)'							toggleDiffing						'start or stop showing diffs in the code pane.')	-	('select conflicts with any changeset'		selectAllConflicts					'select methods in the file which also occur in any change-set in the system')	('select conflicts with current changeset'	selectConflicts						'select methods in the file which also occur in the current change-set')	('select conflicts with...'						selectConflictsWith					'allows you to designate a file or change-set against which to check for code conflicts.')	-	('select unchanged definitions'				selectUnchangedDefinitions			'select class definitions, class comments and methods in the file whose in-image versions are the same as their in-file counterparts' )	('select unchanged methods'					selectUnchangedMethods				'select methods in the file whose in-image versions are the same as their in-file counterparts' )	('select new methods'						selectNewMethods					'select methods in the file that do not current occur in the image')	('select methods for this class'				selectMethodsForThisClass			'select all methods in the file that belong to the currently-selected class')	('select methods for extant classes'			selectMethodsForExtantClasses		'select all methods in the file that belong to a class that exists in the image')	('select changes with contents matching'		selectContentsMatching				'select all changes in the file whose text includes a pattern')	-	('select all (a)'								selectAll								'select all the items in the list')	('deselect all'								deselectAll							'deselect all the items in the list')	('invert selections'							invertSelections						'select every item that is not currently selected, and deselect every item that *is* currently selected')	-	('browse all versions of single selection'			browseVersions		'open a version browser showing the versions of the currently selected method')	('browse all versions of selections'			browseAllVersionsOfSelections		'open a version browser showing all the versions of all the selected methods')	('browse current versions of selections'		browseCurrentVersionsOfSelections	'open a message-list browser showing the current (in-image) counterparts of the selected methods')	('destroy current methods of selections'		destroyCurrentCodeOfSelections		'remove (*destroy*) the in-image counterparts of all selected methods')	-	('remove doIts'								removeDoIts							'remove all items that are doIts rather than methods')	('remove older versions'						removeOlderMethodVersions			'remove all but the most recent versions of methods in the list')	('remove up-to-date versions'				removeExistingMethodVersions		'remove all items whose code is the same as the counterpart in-image code')	('remove selected items'						removeSelections					'remove the selected items from the change-list')	('remove unselected items'					removeNonSelections					'remove all the items not currently selected from the change-list')).	^ aMenu! !!ChangeList methodsFor: 'viewing access' stamp: 'eem 5/22/2007 10:40' prior: 18187944!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange := changeList at: listIndex.	 (aChange type == #method	 and: [(aClass := aChange methodClass) notNil	 and: [aClass includesSelector: aChange methodSelector]]) ifTrue:		[^Utilities			methodDiffFor: aChange text			class: aClass			selector: aChange methodSelector			prettyDiffs: self showingPrettyDiffs].	aChange type == #doIt ifTrue:		[| tokens |		 tokens := Scanner new scanTokens: aChange string.		 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3		  and: [(aClass := Smalltalk at: tokens third ifAbsent: []) notNil		  and: [aClass isBehavior]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass definition to: aChange string].		(tokens size = 4		 and: [tokens second == #class		 and: [tokens third == #instanceVariableNames:		 and: [(aClass := Smalltalk at: tokens first ifAbsent: []) notNil		 and: [aClass isBehavior]]]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass class definition to: aChange string]].	(aChange type == #classComment	and: [(aClass := aChange commentClass) notNil]) ifTrue:		[^TextDiffBuilder buildDisplayPatchFrom: aClass comment asString to: aChange string].	^(changeList at: listIndex) text! !!ChangeList methodsFor: 'scanning' stamp: 'eem 7/17/2008 15:50' prior: 18181436!scanCategory  	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp anIndex |	itemPosition := file position.	item := file nextChunk.	((item includesSubString: 'commentStamp:')	or: [(item includesSubString: 'methodsFor:')	or: [item endsWith: 'reorganize']]) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 50)].	tokens := Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp := ''.		anIndex := tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp := tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].	tokens second == #commentStamp:		ifTrue:			[stamp := tokens third.			self addItem:					(ChangeRecord new file: file position: file position type: #classComment									class: tokens first category: nil meta: false stamp: stamp)					text: 'class comment for ' , tokens first, 						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).			file nextChunk.			^ file skipStyleChunk].	self assert: tokens last == #reorganize.	self addItem:		(ChangeRecord new			file: file position: file position type: #reorganize			class: tokens first category: nil meta: false stamp: stamp)		text: 'organization for ' , tokens first, (tokens second == #class ifTrue: [' class'] ifFalse: ['']).	file nextChunk! !!ChangeList methodsFor: 'scanning' stamp: 'eem 1/28/2009 16:39' prior: 18182918!scanCategory: category class: class meta: meta stamp: stamp	| itemPosition method selector |	[itemPosition := file position.	method := file nextChunk.	file skipStyleChunk.	method size > 0]						"done when double terminators"		whileTrue:		[self addItem: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: category meta: meta stamp: stamp)			text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, ((selector := (Smalltalk at: class ifAbsent: [Object]) parserClass new parseSelector: method) isNil					ifTrue: ['unparsableSelector']					ifFalse: [selector])				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/18/2009 15:21'!selectContentsMatching	| pattern |	pattern := UIManager default request: 'pattern to match'.	pattern isEmpty ifTrue: [^self].	^Cursor execute showWhile:		[self selectSuchThat: ((pattern includesAnyOf: '?*')								ifTrue: [[ :change | pattern match: change string]]								ifFalse: [[ :change | change string includesSubString: pattern]])]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 8/18/2009 13:41'!selectMethodsForExtantClasses	^self selectSuchThat:		[ :change |		Smalltalk hasClassNamed: change methodClassName]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/28/2009 16:36'!selectUnchangedDefinitions	"Selects all recognizable definitions for which there is already a definition in the current image, whose source is exactly the same."	| change class tokens |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put: false.		(change type = #method		 and: [(class := change methodClass) notNil		 and: [class includesSelector: change methodSelector]]) ifTrue:			[listSelections				at: i				put: change string withBlanksCondensed					= (class sourceCodeAt: change methodSelector) asString withBlanksCondensed].		(change type == #classComment		and: [(class := change commentClass) notNil]) ifTrue:			[listSelections at: i put: change string = class comment asString].		change type == #doIt ifTrue:			[tokens := Scanner new scanTokens: change string.			 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3			 and: [(class := Smalltalk at: tokens third ifAbsent: []) notNil			 and: [class isBehavior]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class definition withBlanksCondensed].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #instanceVariableNames:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) notNil			 and: [class isBehavior]]]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class class definition withBlanksCondensed].			(tokens size = 3			 and: [tokens second == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class includesSelector: tokens third) not]]]]) ifTrue:				[listSelections at: i put: true].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class class includesSelector: tokens fourth) not]]]]]) ifTrue:				[listSelections at: i put: true]]]].	self changed: #allSelections! !!MessageNames methodsFor: 'search' stamp: 'eem 1/27/2009 10:15' prior: 54379351!computeSelectorListFromSearchString	"Compute selector list from search string"	searchString := searchString asString copyWithout: $ . "?dubious?"	selectorList := Cursor wait showWhile:					[| sorted |					sorted := SortedCollection sortBlock:  [:x :y | x asLowercase <= y asLowercase].					(searchString findBetweenSubStrs: ';') do:						[:selPat| | raw n m |						selPat size > 0 ifTrue:							[(selPat first = $" and: [selPat last = $" and: [selPat size > 2]])								ifTrue:									[Symbol hasInterned: (selPat copyFrom: 2 to: selPat size - 1) ifTrue: [:sym| sorted add: sym]]								ifFalse:									[raw := (((n := selPat occurrencesOf: $*) > 0)										    | ((m := selPat occurrencesOf:  $#) > 0)										and: [selPat size > (n + m)])											ifTrue: [Symbol selectorsMatching: selPat]											ifFalse: [Symbol selectorsContaining: selPat].									sorted addAll: raw]]].					sorted asArray].	^selectorList! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'ul 2/22/2010 22:28' prior: 58107237!modalFolderSelector: aDir	| window fileModel |	window := self morphicViewFolderSelector: aDir.	fileModel := window model.	window openInWorld: self currentWorld extent: 300@400.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!Behavior methodsFor: '*Tools-Browser-accessors' stamp: 'eem 8/12/2009 11:45'!settersReturnValue	"Determine whether the browser's createInstVarAccessors code will generate	 setters that answer self (the default here) or the value set.  Classes that want	 to answer the value set (e.g. VMStructType) override."	^false! !!Inspector methodsFor: 'menu commands' stamp: 'mtf 4/25/2008 14:17' prior: 21871856!explorePointers	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	PointerExplorer new openExplorerFor: self selection! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:41'!explorePointers	"Open a PointerExplorer on the current selection"	PointerExplorer new openExplorerFor: self object! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:40' prior: 25065726!genericMenu: aMenu 	"Borrow a menu from my inspector"	| insideObject menu parentObject |	currentSelection		ifNil: [menu := aMenu.			menu				add: '*nothing selected*'				target: self				selector: #yourself]		ifNotNil: [insideObject := self object.			parentObject := self parentObject.			inspector				ifNil: [inspector := Inspector new].			inspector inspect: parentObject;				 object: insideObject.			aMenu defaultTarget: inspector.			inspector fieldListMenu: aMenu.			aMenu items				do: [:i | (#(#inspectSelection #exploreSelection #referencesToSelection #defsOfSelection #objectReferencesToSelection #chasePointers #explorePointers) includes: i selector)						ifTrue: [i target: self]].			aMenu addLine;				add: 'monitor changes'				target: self				selector: #monitor:				argument: currentSelection].	monitorList isEmptyOrNil		ifFalse: [aMenu addLine;				add: 'stop monitoring all'				target: self				selector: #stopMonitoring].	^ aMenu! !!Browser class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	^true! !!Browser class methodsFor: 'instance creation' stamp: 'eem 7/1/2010 11:44' prior: 54909931!openBrowserView: aBrowserView label: aString 	"Schedule aBrowserView, labelling the view aString."(aBrowserView isKindOf: ToolBuilderSpec) ifTrue:[	(self canUseMultiWindowBrowsers	 and: [self useMultiWindowBrowsers]) ifTrue:		[aBrowserView multiWindowStyle: #labelButton].	ToolBuilder open: aBrowserView label: aString.] ifFalse:[	aBrowserView isMorph		ifTrue:  [(aBrowserView setLabel: aString) openInWorld]		ifFalse: [aBrowserView label: aString.				aBrowserView minimumSize: 300 @ 200.				aBrowserView subViews do: [:each | each controller].				aBrowserView controller open].].	^ aBrowserView model! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 21:44'!arrowKey: aChar from: view	"Intercept Apple-Digit to select panes"	| index |	(aChar isDigit	 and: [multiWindowState notNil]) ifTrue:	 	[index := aChar asciiValue - $0 asciiValue.		index = 0 ifTrue: [index := 10].		^index <= multiWindowState models size			ifTrue: [multiWindowState selectWindowIndex: index]			ifFalse: [self changed: #flash]].	^super arrowKey: aChar from: view! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:36'!classHierarchy	| behavior newBrowser |	(behavior := self selectedClassOrMetaClass) isNil ifTrue:		[^self].	(self isPackage "PackageBrowser pains can't support a hierarchy browser; not sure why."	 or: [multiWindowState isNil]) ifTrue:		[^super classHierarchy].	(newBrowser := HierarchyBrowser new initHierarchyForClass: behavior)		messageCategoryListIndex: messageCategoryListIndex;		messageListIndex: messageListIndex;		editSelection: editSelection.	multiWindowState addWindow: newBrowser! !!Browser methodsFor: 'class list' stamp: 'eem 5/14/2008 17:58' prior: 17783226!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className currentMessageCategoryName currentMessageName |	currentMessageCategoryName := [self selectedMessageCategoryName]										on: Error										do: [:ex| ex return: nil].	currentMessageName := [self selectedMessageName]								on: Error								do: [:ex| ex return: nil].	classListIndex := anInteger.	self setClassOrganizer.	"Try to reselect the category and/or selector if the new class has them."	messageCategoryListIndex := self messageCategoryList										indexOf: currentMessageCategoryName										ifAbsent: [0].	messageListIndex := messageCategoryListIndex = 0							ifTrue: [0]							ifFalse: [self messageList										indexOf: currentMessageName										ifAbsent: [0]].	messageListIndex ~= 0 ifTrue:		[self editSelection: #editMessage] ifFalse:	[messageCategoryListIndex ~= 0 ifTrue:		[self editSelection: #newMessage] ifFalse:	[self classCommentIndicated		ifTrue: []		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])]]].	contents := nil.	self selectedClass isNil		ifFalse: [className := self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'eem 8/12/2009 11:52' prior: 33745191!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection,	 except do NOT clobber or override any selectors already understood by the instances of the selected class"	self selectedClassOrMetaClass ifNotNil:		[:aClass| | cr |		cr := String with: Character cr.		aClass instVarNames do: 			[:aName | | newMessage setter |			(aClass canUnderstand: aName asSymbol) ifFalse:				[newMessage :=					aName, cr,					'	"Answer the value of ', aName, '"', cr, cr,					'	^ ', aName.				aClass compile: newMessage classified: #accessing notifying: nil].			(aClass canUnderstand: (setter := aName, ':') asSymbol) ifFalse:				[newMessage :=					setter, ' anObject', cr,					'	"Set the value of ', aName, '"', cr, cr,						(aClass settersReturnValue ifTrue: ['	^'] ifFalse: ['	']),						aName, ' := anObject'.				aClass compile: newMessage classified: #accessing notifying: nil]]]! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!exploreMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod explore]! !!Browser methodsFor: 'system category functions' stamp: 'eem 7/1/2010 10:39' prior: 17867486!findClass	"Search for a class by name."	| pattern foundClass |	(multiWindowState notNil	 or: [self okToChange]) ifFalse:		[^self classNotFound].	pattern := UIManager default request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^self classNotFound].	foundClass := Utilities classFromPattern: pattern withCaption: ''.	foundClass ifNil: [^self classNotFound].	(self selectedClass notNil	 and: [multiWindowState notNil	 "Can only support multi-window if original window has all the right panes."	 and: [multiWindowState prototype isHierarchy not]]) ifTrue:		[(self classList includes: foundClass name)			ifTrue: [multiWindowState copyWindow]			ifFalse: [multiWindowState addNewWindow]]. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!inspectMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod inspect]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^false! !!Browser methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 19:06' prior: 17809768!labelString	| label |	label := self selectedClass				ifNil: [ self defaultBrowserTitle ]				ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].	(multiWindowState notNil	 and: [multiWindowState models size > 1]) ifTrue:		[label := (multiWindowState models indexOf: self) printString, '. ', label].	^label! !!Browser methodsFor: 'message functions' stamp: 'eem 6/29/2010 17:07' prior: 56954722!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	(self menuHook: aMenu named: #messageListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('inst var refs...'			browseInstVarRefs)			('inst var defs...'			browseInstVarDefs)			('class var refs...'			browseClassVarRefs)			('class variables'			browseClassVariables)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			('explore method'			exploreMethod)			('inspect method'			inspectMethod)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self selectedClass			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[s print: self selectedClass.				 self metaClassIndicated ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy']].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 17:34'!okToClose	^super okToClose	  and: [multiWindowState isNil or: [multiWindowState okToClose]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 20:20'!restoreMultiWindowState: aMessage	"Restore the state after a multi-window switch.."	aMessage sentTo: self! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 21:12'!restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode	self systemCategoryListIndex: (self systemCategoryList indexOf: category).	self classListIndex: (self classListIndexOf: className).	self messageCategoryListIndex: (self messageCategoryList indexOf: protocol).	self messageListIndex: (self messageList indexOf: selector).	editSelection := editMode.	self		contentsChanged;		decorateButtons! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 20:11'!saveMultiWindowState	^Message		selector: #restoreToCategory:className:protocol:selector:mode:		arguments: {	self selectedSystemCategoryName.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						editSelection }! !!PasteUpMorph methodsFor: '*Tools' stamp: 'cmm 6/13/2010 20:41' prior: 25950778!defaultDesktopCommandKeyTriplets	"Answer a list of triplets of the form		<key> <receiver> <selector>   [+ optional fourth element, a <description> for use in desktop-command-key-help]that will provide the default desktop command key handlers.  If the selector takes an argument, that argument will be the command-key event"	| noviceKeys expertKeys |	noviceKeys := {		{ $o.	ActiveWorld.						#activateObjectsTool.						'Activate the "Objects Tool"'}.		{ $r.	ActiveWorld.						#restoreMorphicDisplay.					'Redraw the screen'}.				{ $z.	self.								#undoOrRedoCommand.					'Undo or redo the last undoable command'}.		{ $F.	Project current.					#toggleFlapsSuppressed.					'Toggle the display of flaps'}.		{ $N.	self.								#toggleClassicNavigatorIfAppropriate.	'Show/Hide the classic Navigator, if appropriate'}.		{ $M.	self.								#toggleShowWorldMainDockingBar.		'Show/Hide the Main Docking Bar'}.	}.	Preferences noviceMode			ifTrue:[^ noviceKeys].	expertKeys := {		{ $b.	SystemBrowser.					#defaultOpenBrowser.						'Open a new System Browser'}.		{ $k.	StringHolder.					#open.										'Open a new, blank Workspace'}.		{ $m.	self.								#putUpNewMorphMenu.					'Put up the "New Morph" menu'}.		{ $t.	self.	 							#findATranscript:.							'Make a System Transcript visible'}.		{ $w.	SystemWindow.					#closeTopWindow.							'Close the topmost window'}.		{ $C.	self.								#findAChangeSorter:.						'Make a Change Sorter visible'}.		{ $L.	self.								#findAFileList:.								'Make a File List visible'}.		{ $P.	self.								#findAPreferencesPanel:.					'Activate the Preferences tool'}.		{ $R.	Utilities. 								#browseRecentSubmissions.		'Make a Recent Submissions browser visible'}.		{ $W.	self. 								#findAMessageNamesWindow:.			'Make a MessageNames tool visible'}.		{ $Z.	ChangeList. 						#browseRecentLog.							'Browse recently-logged changes'}.		{ $\.	SystemWindow. 					#sendTopWindowToBack.					'Send the top window to the back'}.	}.	^ noviceKeys, expertKeys! !"Tools"!!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mtf 6/2/2010 21:17'!removeElement: element	"Used to purge certain elements from a document after parsing."	self elements remove: element ifAbsent: []! !"XML-Parser"!!MethodContext methodsFor: 'system simulation' stamp: 'eem 7/2/2010 10:26' prior: 51688740!pushArgs: args "<Array>" from: sendr "<ContextPart>" 	"Helps simulate action of the value primitive for closures.	 This is used by ContextPart>>runSimulated:contextAtEachStep:"	closureOrNil		ifNil: [self error: 'context needs a closure!!']		ifNotNil:			["See BlockClosure>>asContextWithSender:"			 stackp ~= (closureOrNil numArgs + closureOrNil numCopiedValues) ifTrue:				[self error: 'stack pointer is incorrect!!'].].	1 to: closureOrNil numArgs do:		[:i| self at: i put: (args at: i)].	sender := sendr! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/1/2010 19:30' prior: 50411308!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^((MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc) privRefresh! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 11:50' prior: 50401628!value	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the copied values to the activation as its copied	 temps. Primitive. Essential."	<primitive: 201>	| newContext |	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:21' prior: 50402359!value: firstArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the argument and copied values to the activation	 as its argument and copied temps. Primitive. Essential."	<primitive: 202>	| newContext |	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22' prior: 50405069!value: firstArg value: secondArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 203>	| newContext |	numArgs ~= 2 ifTrue:		[self numArgsError: 2].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22' prior: 50412448!value: firstArg value: secondArg value: thirdArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 204>	| newContext |	numArgs ~= 3 ifTrue:		[self numArgsError: 3].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:31' prior: 50406404!value: firstArg value: secondArg value: thirdArg value: fourthArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 205>	| newContext |	numArgs ~= 4 ifTrue:		[self numArgsError: 4].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			newContext at: 4 put: fourthArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:29' prior: 50407714!valueWithArguments: anArray	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments in an anArray and copied values to	 the activation as its arguments and copied temps. Primitive. Essential."	<primitive: 206>	| newContext |	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			1 to: numArgs do:				[:i| newContext at: i put: (anArray at: i)].			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !"Kernel"!!FileStream class methodsFor: 'instance creation' stamp: 'eem 6/4/2010 15:10' prior: 20696661!detectFile: aBlock do: anotherBlock	^aBlock value		ifNil: [nil]      	ifNotNil: [:file| [anotherBlock value: file] ensure: [file close]]! !!FileStream class methodsFor: 'file reader services' stamp: 'eem 6/2/2010 09:42' prior: 20695524!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st).		] ifFalse: [			extension := (FileDirectory dot, FileStream cs).		].		converter := MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension := (FileDirectory dot, FileStream cs "multiCs").		].		converter := UTF8TextConverter new.	].	fileName := useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	fileName := FileDirectory default checkName: fileName fixErrors: true.	f := FileStream newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !!UnixFileDirectory methodsFor: 'file names' stamp: 'eem 6/2/2010 09:38'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName |	fName := super checkName: aFileName fixErrors: fixing.	(fName includes: self class pathNameDelimiter) ifFalse:		[^fName].	^fixing		ifTrue: [fName copyReplaceAll: (String with: self class pathNameDelimiter) with: '#']		ifFalse: [self error:'Invalid file name']! !"Files"!!Point methodsFor: 'printing' stamp: 'sw 9/27/2001 17:26' prior: 58335229!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Point methodsFor: 'point functions' stamp: 'wiz 8/6/2007 20:33'!fourDirections	"Return vertices for a square centered at 0 asPoint with the receiver as first corner.	Returns the four rotation of the reciever in counter clockwise order with the reciever 	appearing last. "	^ Array with: self leftRotated			with: self negated			with: self rightRotated			with: self 		! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 03:32'!leftRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #left centerAt: 0 asPoint .Compare to transposed and normal. "	^y  @x negated! !!Point methodsFor: 'point functions' stamp: 'wiz 7/28/2007 20:50' prior: 52177949!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise.	For the zero point return a normal of  -1@0   ."	| n d |		n _ y negated @ x.	(d := (n x * n x + (n y * n y))) = 0 ifTrue: [ ^  -1 @0  ] .	^n / d sqrt! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 02:33'!rightRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #right centerAt: 0 asPoint .Compare to transposed and normal. "	^y negated @x! !!Point methodsFor: 'point functions' stamp: 'wiz 8/1/2007 16:53'!sign^ (x sign @ y sign) .! !"Graphics"!!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 20:35'!testBasicFourDirections" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples results rejects |self assert:  (0 asPoint fourDirections) = (Array new: 4 withAll: 0 asPoint) . samples := 0 asPoint eightNeighbors  .results :=  { {0@-1 . -1@0 . 0@1 . 1@0}  . {1@-1 . -1@-1 . -1@1 . 1@1}   . {1@0 . 0@-1 . -1@0 . 0@1}   . {1@1 . 1@-1 . -1@-1 . -1@1}   . {0@1 . 1@0 . 0@-1 . -1@0}   . {-1@1 . 1@1 . 1@-1 . -1@-1}   . {-1@0 . 0@1 . 1@0 . 0@-1}   . {-1@-1 . -1@1 . 1@1 . 1@-1} } .rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections = (results at: each) ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 19:07'!testFourDirectionsInvarients" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples  rejects |samples := 0 asPoint eightNeighbors  .rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections last = ( samples  at: each) ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 20:32'!testFourDirectionsRotationInvarients" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples  rejects |samples := 0 asPoint eightNeighbors  .rejects :=(1 to: samples size ) reject: [ :each | | answer  |		(answer :=  (samples at: each) fourDirections ) .		(1 to: 4) allSatisfy: [ :eachDirIndex | 			( answer atWrap: eachDirIndex)  leftRotated					 = (( answer atWrap: eachDirIndex + 1) )  ] ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 18:24'!testNormal" quick check of results for #normal."| samples rejects results |samples :=0 asPoint eightNeighbors , (Array with: 0 asPoint) .results :=  { 0.0@1.0 . -0.707106781186547@0.707106781186547 . -1.0@0.0 . -0.707106781186547@-0.707106781186547 . 0.0@-1.0 . 0.707106781186547@-0.707106781186547 . 1.0@0.0 . 0.707106781186547@0.707106781186547 . -1@0} .rejects := (1 to: samples size ) reject: [ :each | ((samples at: each) normal - (results at: each)) abs  < 1e-15 asPoint ] .self assert: ( rejects isEmpty ) . ! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 18:48'!testNormal2" quick check of results for #normal.differs from the other testNormal in the way that the difference is measured."| samples rejects results differences |samples :=0 asPoint eightNeighbors , (Array with: 0 asPoint) .results :=  { 0.0@1.0 . -0.707106781186547@0.707106781186547 . -1.0@0.0 . -0.707106781186547@-0.707106781186547 . 0.0@-1.0 . 0.707106781186547@-0.707106781186547 . 1.0@0.0 . 0.707106781186547@0.707106781186547 . -1@0} .differences :=samples with: results collect: [ :each :eachResult |	each normal - eachResult ] .rejects := differences reject: [ :each | 	(each x closeTo: 0.0) and: [each y closeTo: 0.0] ] .self assert: ( rejects isEmpty ) . ! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 17:02'!testRotations" Here we are testing rightRotated and leftRotated which are new.Because there is really no coverage for point functions this also serves as a tests of sorts for rotateBy:CenterAt:"| samples |samples :=0 asPoint eightNeighbors , (Array with: 0 asPoint) .self assert: (samples allSatisfy: [ :each |	each rightRotated leftRotated = each ] ) .self assert: (samples allSatisfy: [ :each |	each rightRotated  = (each rotateBy: #right centerAt: 0 asPoint)] ) .self assert: (samples allSatisfy: [ :each |	each leftRotated  = (each rotateBy: #left centerAt: 0 asPoint ) ] ) .self assert: (samples allSatisfy: [ :each |	each negated  = (each rotateBy: #pi centerAt: 0 asPoint ) ] ) .self assert: (samples allSatisfy: [ :each | 	each leftRotated leftRotated leftRotated leftRotated = each ]) .self assert: (samples allSatisfy: [ :each |	each rightRotated rightRotated rightRotated rightRotated  = each ] ) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 18:38'!testSign | samples results rejects |samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .self shouldnt: [ results :=				samples collect: [ :each | each sign ] ]	raise: Error .	rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) = (results at: each) ] .self assert: ( rejects isEmpty) ! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 17:22'!testZeroPointNormal"old: normal of zero point raised divide by zero error.new: normal of zero point returns a direction right rotated from zero points direction."self shouldnt: [ (0 asPoint normal bearingToPoint: 0 asPoint) = 90 ] raise: Error.  ! !"GraphicsTests"!!ChangeRecord methodsFor: 'initialization' stamp: 'cmm 7/2/2010 18:26' prior: 33967283!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := self methodClass.				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[Utilities noteMethodSubmission: aSelector forClass: cls]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					Utilities noteMethodSubmission: #Comment forClass: cls ].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'eem 7/2/2010 17:20' prior: 58578468!flushClassNameCache	"Smalltalk flushClassNameCache"	"Force recomputation of the cached list of class names."	cachedClassNames := nil! !!SystemDictionary methodsFor: 'removing' stamp: 'eem 5/19/2010 15:35'!removeKey: key ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in	the receiver, answer the result of evaluating aBlock. Otherwise, answer	the value externally named by key."	self flushClassNameCache.	^super removeKey: key ifAbsent: aBlock! !"System"!!TextEditor commentStamp: '<historical>' prior: 59444043!See comment in Editor.My instances edit Text, this is, they support multiple lines and TextAttributes.They have no specific facilities for editing Smalltalk code. Those are found in SmalltalkEditor.!!Editor methodsFor: 'private' stamp: 'cmm 7/3/2010 15:56' prior: 57259462!moveCursor: directionBlock forward: forward specialBlock: specialBlock 	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	^ self		moveCursor: directionBlock		forward: forward		specialBlock: specialBlock		select: sensor leftShiftDown! !!Editor methodsFor: 'private' stamp: 'cmm 7/3/2010 15:55'!moveCursor: directionBlock forward: forward specialBlock: specialBlock select: shouldSelect	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| indices newPosition |	indices := self setIndices: shouldSelect forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition := specialBlock value: newPosition].	sensor keyboard.	shouldSelect		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:18'!autoEnclose	<preference: 'Auto Enclose'		category: 'Morphic'		description: 'When true, typing an opening parenthesis, bracket or square-bracket will also add its corresponding closing character in front of the cursor.'		type: #Boolean>	^ AutoEnclose ifNil: [ false ]! !!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:17'!autoEnclose: aBoolean	AutoEnclose := aBoolean! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'cmm 7/2/2010 19:00' prior: 56425262!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.				"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.			"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.		"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.		"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.				"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.				"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.				"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.				"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"				'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmds := #($a #selectAll: $c #copySelection: $e #exchange: $f #find: $g #findAgain: $h #setSearchString: $k #offerFontMenu: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).	1 to: cmds size		by: 2		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions := cmdMap! !!TextEditor methodsFor: 'typing support' stamp: 'cmm 7/3/2010 16:12' prior: 57283772!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys openers closers result |	((char == Character cr) and: [morph acceptOnCR])		ifTrue: [			sensor keyboard.  "Gobble cr -- probably unnecessary."			self closeTypeIn.			^ true].	self clearParens.  	char asciiValue = 13 ifTrue: [		sensor controlKeyPressed ifTrue: [			^ self normalCharacter: typeAheadStream ].		sensor leftShiftDown ifTrue: [			^ self lf: typeAheadStream ].		sensor commandKeyPressed ifTrue: [			^ self crlf: typeAheadStream ].		^ self crWithIndent: typeAheadStream ].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue: [				self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [				self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue: [			^ self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	openers := '([{'.  closers := ')]}'.	(closers includes: char) ifTrue: [self blinkPrevParen].	result := self normalCharacter: typeAheadStream.	(self class autoEnclose and: [ openers includes: char ])		ifTrue: 			[ typeAheadStream nextPut: (closers at: (openers indexOf: char)).			self insertTypeAhead: typeAheadStream.			self moveCursor: [ : position | position-1 ] forward: false specialBlock: [ : pos | "no special behavior" ] select: false ].	^ result! !!TextEditor methodsFor: 'editing keys' stamp: 'cmm 7/2/2010 19:01' prior: 57286011!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([{"''' indexOf: char ifAbsent: [ ^true ].	left := '([{"''' at: which.	right := ')]}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])			and: [ (text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !"Morphic"!!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06' prior: 52326729!startTransmittingEvents	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06' prior: 52328069!startTransmittingEventsTo: remoteAddr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	remoteAddress := remoteAddr.	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !"MorphicExtras"!!HTTPSocket commentStamp: 'ar 7/10/2010 14:05' prior: 59316211!HTTPSockets is a facade for handling common HTTP requests. It provides a minimal implementation of the HTTP protocol, but can be extended by third party clients that register themselves as #httpRequestHandler (see class-side protocol).A third-party request handler needs to implement the single method	#httpRequest:url:headers:content:response:in a way that is compatible with the baseline implementation in HTTPSocket.!!HTTPSocket class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 07:17' prior: 21401861!defaultPort	"default port to connect on"	^80! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:21' prior: 55841808!httpGet: url args: args user: user passwd: passwd	"Upload the contents of the stream to a file on the server.	WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization result |	authorization := (user , ':' , passwd) base64Encoded.	result := self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	^result! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:36' prior: 57424081!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	args ifNotNil: [		urlString := urlString, (self argString: args) 	].	^(self httpRequestHandler) 		httpRequest: 'GET' url: urlString headers:(			(mimeType ifNil:[''] ifNotNil:['Accept: ', mimeType, String crlf]),			'Accept: text/html', String crlf,			HTTPBlabEmail,			requestString		) content: nil response: nil.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:23' prior: 55849681!httpPost: url args: args user: user passwd: passwd	"WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization |	authorization := (user , ':' , passwd) base64Encoded.	^self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:52'!httpPost: url content: postData type: contentType accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	^(self httpRequestHandler) 		httpRequest: 'POST' url: urlString headers:(			'Accept: ', mimeType, String crlf,			'Accept: text/html', String crlf,			'Content-Type: ', contentType, String crlf,			'Content-Length: ', (postData ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString "extra user request. Authorization"		) content: (postData ifNil:['']) response: nil! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 2/25/2010 15:49' prior: 55852168!httpPostDocument: url  args: args accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| argString  |	args ifNotNil: [		argString := self argString: args.		argString first = $? ifTrue: [argString := argString allButFirst].	].	^self httpPost: url 			content: argString 			type: 'application/x-www-form-urlencoded' 			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:31' prior: 55835558!httpPostMultipart: url args: argsDict accept: mimeType request: requestString	" do multipart/form-data encoding rather than x-www-urlencoded "	| mimeBorder argsStream |	mimeBorder := '----squeak-georgia-tech-', Time millisecondClockValue printString, '-csl-cool-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value | | fieldValue |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, String crlf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: multipart/form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', String crlf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: String crlf, String crlf, fieldValue, String crlf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	^self httpPost: url 			content: argsStream contents			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:30' prior: 21394126!httpPostToSuperSwiki: url args: argsDict accept: mimeType request: requestString	| mimeBorder argString |	mimeBorder := '---------SuperSwiki',Time millisecondClockValue printString,'-----'.	argString := String streamContents: [ :strm |		strm nextPutAll: mimeBorder, String crlf.		argsDict associationsDo: [:assoc |			assoc value do: [ :value |				strm					nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"';					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: value;					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: mimeBorder;					nextPutAll: String crlf.			]		].	].	^self httpPost: url 			content: argString 			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42' prior: 21403989!httpProxyPort	"answer the httpProxyPort"	<preference: 'HTTP Proxy Port'		category: 'HTTP Proxy'		description: 'HTTP Proxy Port'		type: #Number>	^HTTPProxyPort ifNil:[80]! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42' prior: 21404195!httpProxyPort: aPortNumber	"Set the proxy port"	HTTPProxyPort := aPortNumber.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42' prior: 21404402!httpProxyServer	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	<preference: 'HTTP Proxy Server'		category: 'HTTP Proxy'		description: 'HTTP Proxy Server. Leave blank if you don''t want to use a Proxy'		type: #String>	^HTTPProxyServer ifNil:['']! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:43' prior: 55842822!httpProxyServer: aString	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	HTTPProxyServer := aString.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:53' prior: 55843926!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server		WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| urlString resp header |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	resp := (self httpRequestHandler) 		httpRequest: 'PUT' url: urlString headers:(			'Authorization: Basic ', (user, ':', passwd) base64Encoded, String crlf,			'Accept: */*', String crlf,			'Content-Type: application/octet-stream', String crlf,			'Content-Length: ', (contents ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail		) content: contents response:[:rr| header := rr].	^resp isString ifTrue:[header, resp] ifFalse:[header, resp content]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:53'!httpRequest: method url: urlString headers: hdrs content: contentOrNil response: responseBlock	"Sends an HTTP request to the server. Returns a MIMEDocument if successful,	a string indicating the error otherwise. If a response block is provided, the	response is fed into into so that the sender can see all the headers."	| index serverAndPort server port rawUrl stream resp code headers 	  contentLength contentType contentStream |	(urlString beginsWith: 'http://') ifFalse:[self error: 'Not a http url'].	"Extract server, port, and url"	index := urlString indexOf: $/ startingAt: 8 ifAbsent:[urlString size+1]. "past http://"	serverAndPort := urlString copyFrom: 8 to: index-1.	server := serverAndPort copyUpTo: $:.	port := ((serverAndPort copyAfter: $:) ifEmpty:['80']) asNumber.	"Prepare the request URI"	rawUrl := urlString copyFrom: index to: urlString size.	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].	rawUrl := rawUrl encodeForHTTPWithTextEncoding: 'utf-8' 				conditionBlock: [:c | c isSafeForHTTP or:['/;&=\?' includes: c]].	"Check for proxy"	(self shouldUseProxy: server) ifTrue:[		self httpProxyServer ifNotEmpty:[			rawUrl := 'http://', serverAndPort, rawUrl. "per RFC 2616"			server := self httpProxyServer.			port := self httpProxyPort.		].	].	"Fire off the request"	stream := SocketStream openConnectionToHostNamed: server port: port.	stream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: 'HTTP/1.0'; crlf.	stream nextPutAll: 'Host: ', serverAndPort; crlf.	stream nextPutAll: 'Connection: close'; crlf.	stream nextPutAll: 'User-Agent: ', self userAgentString; crlf.	stream nextPutAll: hdrs.	stream crlf.	contentOrNil ifNotNil:[		"Upload request content"		contentStream := contentOrNil readStream.		[contentStream atEnd] whileFalse:[			(HTTPProgress new) total: contentOrNil size; 				amount: contentStream position; signal: 'Uploading...'.			stream nextPutAll: (contentStream next: 4096).			stream flush.		].	].	stream flush.	"Read the response"	resp := stream upToAll: String crlfcrlf.	"Extract the response code"	code := ((resp copyUpTo: String cr) findTokens: ' ') second asNumber.	"And the response headers"	headers := Dictionary new.	resp lines allButFirst allButLast do:[:nextLine|		headers at: (nextLine copyUpTo: $:) asLowercase 			put: (nextLine copyAfter: $:) withBlanksTrimmed.	].	"Read response content"	contentLength := headers at: 'content-length' ifAbsent:[nil].	contentType := headers at: 'content-type' ifAbsent:['application/octet-stream'].	"Fixme - Provide HTTProgress"	contentLength 		ifNil:[contentStream := WriteStream with: stream upToEnd]		ifNotNil:[			contentLength := contentLength asNumber.			contentStream := (String new: contentLength) writeStream. 			[contentStream position < contentLength] whileTrue:[				contentStream nextPutAll: 					(stream next: (contentLength - contentStream position min: 4096)).				(HTTPProgress new) total: contentLength; 					amount: contentStream position; signal: 'Downloading...'.			].		].	stream close.	responseBlock ifNotNil:[responseBlock value: resp].	^(code between: 200 and: 299) 		ifTrue:[MIMEDocument contentType: contentType 				content: contentStream contents url: urlString]		ifFalse:[resp asString, contentStream contents].! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:34'!httpRequestHandler	"Answer the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket. If no handler is registered, answer the receiver"	^HTTPRequestHandler ifNil:[self]! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:35'!httpRequestHandler: anObject	"Set the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket."	HTTPRequestHandler := anObject! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'ar 7/10/2010 13:59' prior: 21374448!initialize	"HTTPSocket initialize"	HTTPPort := 80.	self httpProxyServer: nil.	HTTPBlabEmail := ''.  "	'From: somebody@no.where', CrLf	"	HTTPProxyCredentials := ''.	ExternalSettings registerClient: self.	self removeHTTPProxyPreferences.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 7/10/2010 14:01'!removeHTTPProxyPreferences	" This method will remove the old HTTP Proxy preferences. "	(Preferences valueOfPreference: #httpProxyServer) ifNotNil:[		HTTPProxyServer := Preferences valueOfPreference: #httpProxyServer.		Preferences removePreference: #httpProxyServer.	].	(Preferences valueOfPreference: #httpProxyPort) ifNotNil:[		HTTPProxyPort := Preferences valueOfPreference: #httpProxyPort.		Preferences removePreference: #httpProxyPort.	].! !HTTPSocket removeSelector: #sendDataWithProgress:!HTTPSocket removeSelector: #sendCommandWithProgress:!HTTPSocket removeSelector: #responseCode!HTTPSocket removeSelector: #redirect!HTTPSocket removeSelector: #logToTranscript!HTTPSocket removeSelector: #header:!HTTPSocket removeSelector: #getRestOfBuffer:totalLength:!HTTPSocket removeSelector: #getRestOfBuffer:!HTTPSocket removeSelector: #getResponseUpTo:ignoring:!HTTPSocket removeSelector: #getResponseUpTo:!HTTPSocket removeSelector: #getHeader:default:!HTTPSocket removeSelector: #getHeader:!HTTPSocket removeSelector: #contentsLength:!HTTPSocket removeSelector: #contentType:!HTTPSocket removeSelector: #contentType!HTTPSocket class removeSelector: #retry:asking:ifGiveUp:!HTTPSocket class removeSelector: #proxyTestingComment!HTTPSocket class removeSelector: #md5Hash:!HTTPSocket class removeSelector: #ip:port:urlPath:!HTTPSocket class removeSelector: #initHTTPSocket:wait:ifError:!HTTPSocket class removeSelector: #initHTTPSocket:ifError:!HTTPSocket class removeSelector: #expandUrl:ip:port:!HTTPSocket class removeSelector: #digestFrom:method:url:user:password:!HTTPSocket class removeSelector: #digestFor:method:url:user:password:!HTTPSocket class removeSelector: #checkHTTPProxyPreferences!HTTPSocket class removeSelector: #argStringUnencoded:!HTTPSocket class removeSelector: #addHTTPProxyPreferences!OldSocket removeSelector: #writeSemaphore!OldSocket removeSelector: #waitForSendDoneUntil:!OldSocket removeSelector: #waitForDisconnectionUntil:!OldSocket removeSelector: #waitForDataUntil:!OldSocket removeSelector: #waitForConnectionUntil:!OldSocket removeSelector: #waitForAcceptUntil:!OldSocket removeSelector: #unregister!OldSocket removeSelector: #statusString!OldSocket removeSelector: #socketHandle!OldSocket removeSelector: #socketError!OldSocket removeSelector: #setPort:!OldSocket removeSelector: #setPeer:port:!OldSocket removeSelector: #setOption:value:!OldSocket removeSelector: #sendUDPData:toHost:port:!OldSocket removeSelector: #sendSomeData:startIndex:count:!OldSocket removeSelector: #sendSomeData:startIndex:!OldSocket removeSelector: #sendSomeData:!OldSocket removeSelector: #sendDone!OldSocket removeSelector: #sendData:toHost:port:!OldSocket removeSelector: #sendData:count:!OldSocket removeSelector: #sendData:!OldSocket removeSelector: #semaphore!OldSocket removeSelector: #remotePort!OldSocket removeSelector: #remoteAddress!OldSocket removeSelector: #register!OldSocket removeSelector: #receiveUDPDataInto:!OldSocket removeSelector: #receiveDataInto:fromHost:port:!OldSocket removeSelector: #receiveDataInto:!OldSocket removeSelector: #readSemaphore!OldSocket removeSelector: #readInto:startingAt:!OldSocket removeSelector: #printOn:!OldSocket removeSelector: #primitiveOnlySupportsOneSemaphore!OldSocket removeSelector: #primSocketSendDone:!OldSocket removeSelector: #primSocketRemotePort:!OldSocket removeSelector: #primSocketRemoteAddress:!OldSocket removeSelector: #primSocketReceiveDataAvailable:!OldSocket removeSelector: #primSocketLocalPort:!OldSocket removeSelector: #primSocketLocalAddress:!OldSocket removeSelector: #primSocketError:!OldSocket removeSelector: #primSocketDestroyGently:!OldSocket removeSelector: #primSocketDestroy:!OldSocket removeSelector: #primSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex:!OldSocket removeSelector: #primSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex:!OldSocket removeSelector: #primSocketConnectionStatus:!OldSocket removeSelector: #primSocketCloseConnection:!OldSocket removeSelector: #primSocketAbortConnection:!OldSocket removeSelector: #primSocket:setPort:!OldSocket removeSelector: #primSocket:setOption:value:!OldSocket removeSelector: #primSocket:sendUDPData:toHost:port:startIndex:count:!OldSocket removeSelector: #primSocket:sendData:startIndex:count:!OldSocket removeSelector: #primSocket:receiveUDPDataInto:startingAt:count:!OldSocket removeSelector: #primSocket:receiveDataInto:startingAt:count:!OldSocket removeSelector: #primSocket:listenOn:backlogSize:interface:!OldSocket removeSelector: #primSocket:listenOn:backlogSize:!OldSocket removeSelector: #primSocket:listenOn:!OldSocket removeSelector: #primSocket:getOption:!OldSocket removeSelector: #primSocket:connectTo:port:!OldSocket removeSelector: #primAcceptFrom:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex:!OldSocket removeSelector: #primAcceptFrom:receiveBufferSize:sendBufSize:semaIndex:!OldSocket removeSelector: #port!OldSocket removeSelector: #peerName!OldSocket removeSelector: #localPort!OldSocket removeSelector: #localAddress!OldSocket removeSelector: #listenOn:backlogSize:interface:!OldSocket removeSelector: #listenOn:backlogSize:!OldSocket removeSelector: #listenOn:!OldSocket removeSelector: #isWaitingForConnection!OldSocket removeSelector: #isValid!OldSocket removeSelector: #isUnconnectedOrInvalid!OldSocket removeSelector: #isUnconnected!OldSocket removeSelector: #isThisEndClosed!OldSocket removeSelector: #isOtherEndClosed!OldSocket removeSelector: #isConnected!OldSocket removeSelector: #initialize:!OldSocket removeSelector: #getResponseNoLF!OldSocket removeSelector: #getOption:!OldSocket removeSelector: #getData!OldSocket removeSelector: #finalize!OldSocket removeSelector: #disconnect!OldSocket removeSelector: #discardReceivedData!OldSocket removeSelector: #destroy!OldSocket removeSelector: #dataAvailable!OldSocket removeSelector: #connectTo:port:!OldSocket removeSelector: #closeAndDestroy:!OldSocket removeSelector: #closeAndDestroy!OldSocket removeSelector: #close!OldSocket removeSelector: #address!OldSocket removeSelector: #acceptFrom:!OldSocket removeSelector: #accept!OldSocket class removeSelector: #wildcardPort!OldSocket class removeSelector: #wildcardAddress!OldSocket class removeSelector: #unregister:!OldSocket class removeSelector: #udpCreateIfFail:!OldSocket class removeSelector: #timeTestUDP3!OldSocket class removeSelector: #timeTestUDP2!OldSocket class removeSelector: #timeTestUDP!OldSocket class removeSelector: #timeTest!OldSocket class removeSelector: #tcpCreateIfFail:!OldSocket class removeSelector: #standardDeadline!OldSocket class removeSelector: #remoteTestSinkTCP!OldSocket class removeSelector: #remoteTestServerUDP2!OldSocket class removeSelector: #remoteTestServerUDP!OldSocket class removeSelector: #remoteTestServerTCPUsingAccept!OldSocket class removeSelector: #remoteTestServerTCPOpenClosePutGet!OldSocket class removeSelector: #remoteTestServerTCPOpenClose1000!OldSocket class removeSelector: #remoteTestServerTCP!OldSocket class removeSelector: #remoteTestClientUDP!OldSocket class removeSelector: #remoteTestClientTCPOpenClosePutGet!OldSocket class removeSelector: #remoteTestClientTCPOpenClose1000!OldSocket class removeSelector: #remoteTestClientTCP!OldSocket class removeSelector: #registryThreshold:!OldSocket class removeSelector: #registryThreshold!OldSocket class removeSelector: #registry!OldSocket class removeSelector: #register:!OldSocket class removeSelector: #pingPortsOn:!OldSocket class removeSelector: #pingPorts:on:timeOutSecs:!OldSocket class removeSelector: #ping:!OldSocket class removeSelector: #newUDP!OldSocket class removeSelector: #newTCP!OldSocket class removeSelector: #new!OldSocket class removeSelector: #nameForWellKnownTCPPort:!OldSocket class removeSelector: #initializeNetworkIfFail:!OldSocket class removeSelector: #initializeNetwork!OldSocket class removeSelector: #initialize!OldSocket class removeSelector: #ensureNetworkConnected!OldSocket class removeSelector: #deadlineSecs:!OldSocket class removeSelector: #deadServer:!OldSocket class removeSelector: #deadServer!OldSocket class removeSelector: #createIfFail:!OldSocket class removeSelector: #clientServerTestUDP2!OldSocket class removeSelector: #clientServerTestUDP!OldSocket class removeSelector: #acceptFrom:!OldSimpleClientSocket removeSelector: #waitForDataQueryingUserEvery:!OldSimpleClientSocket removeSelector: #sendCommand:!OldSimpleClientSocket removeSelector: #getResponseShowing:!OldSimpleClientSocket removeSelector: #getResponse!OldSimpleClientSocket removeSelector: #getMultilineResponseShowing:!OldSimpleClientSocket removeSelector: #getMultilineResponse!OldSimpleClientSocket removeSelector: #displayString:!OldSimpleClientSocket class removeSelector: #timeTest!OldSimpleClientSocket class removeSelector: #simpleDateString:!OldSimpleClientSocket class removeSelector: #sensorStateString!OldSimpleClientSocket class removeSelector: #remoteCursorTest!OldSimpleClientSocket class removeSelector: #remoteCursorReceiver!OldSimpleClientSocket class removeSelector: #popTest!OldSimpleClientSocket class removeSelector: #parseSensorStateString:!OldSimpleClientSocket class removeSelector: #parseNTTPMsgList:!OldSimpleClientSocket class removeSelector: #parseIntegerList:!OldSimpleClientSocket class removeSelector: #parseHeaderList:!OldSimpleClientSocket class removeSelector: #nntpTest!OldSimpleClientSocket class removeSelector: #initialize!OldSimpleClientSocket class removeSelector: #httpTestHost:port:url:!OldSimpleClientSocket class removeSelector: #forkingRemoteCursorSender!OldSimpleClientSocket class removeSelector: #finger:!OldSimpleClientSocket class removeSelector: #extractDateFromAndSubjectFromHeader:!OldSimpleClientSocket class removeSelector: #crLf!Smalltalk removeClassNamed: #OldSimpleClientSocket!Smalltalk removeClassNamed: #OldSocket!Preferences class removeSelector: #httpProxyServer!Preferences class removeSelector: #httpProxyPort!"Network"!!TestCase methodsFor: 'running' stamp: 'ar 7/9/2010 11:31' prior: 33847888!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error, Halt do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !"SUnit"!!DecompilerTests methodsFor: 'utilities' stamp: 'ar 7/10/2010 13:06' prior: 59170886!decompilerFailures	"here is the list of failures: DNU resulting in trying to decompile the following methods"	^ #((AdditionalMethodState at:ifAbsent:)		(AdditionalMethodState at:ifAbsentPut:)		(AdditionalMethodState at:put:)		(AdditionalMethodState hasLiteralSuchThat:)		(AdditionalMethodState hasLiteralThorough:)		(AdditionalMethodState includesProperty:)		(AdditionalMethodState keysAndValuesDo:)		(AdditionalMethodState pragmas)		(AdditionalMethodState properties)		(AdditionalMethodState propertyKeysAndValuesDo:)		(AdditionalMethodState propertyValueAt:ifAbsent:)		(AdditionalMethodState removeKey:ifAbsent:)		(AdditionalMethodState setMethod:)		(BalloonEngineSimulation circleCosTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		 (BalloonEngineSimulation circleSinTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		(BlockNode emitCodeExceptLast:encoder:)		(BlockNode sizeCodeExceptLast:)		(Categorizer changeFromCategorySpecs:)		(Categorizer elementCategoryDict)		(ChatNotes storeAIFFOnFile:)		(ClosureTests testToDoInsideTemp)		(Command veryDeepFixupWith:)		(CompiledMethod =)		(CompiledMethod allEmbeddedBlockMethods)		(CompiledMethod embeddedBlockMethods)		(CompiledMethod getPreambleFrom:at:)		(CompiledMethod hasLiteralSuchThat:)		(CompiledMethod hasLiteralThorough:)		(CompiledMethod sameTraitCodeAs:)		(Date printOn:)		(DependencyBrowser computePackageDependencies:)		(EventSensor eventTickler)		(Float printPaddedWith:to:)		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(Form preMultiplyAlpha)		(FTPClient getDataInto:)		 (GeniePlugin primSameClassAbsoluteStrokeDistanceMyPoints:otherPoints:myVectors:otherVectors:mySquaredLengths:otherSquaredLengths:myAngles:otherAngles:maxSizeAndReferenceFlag:rowBase:rowInsertRemove:rowInsertRemoveCount: "Cannot compile -- stack including temps is too deep")		(GZipReadStream on:from:to:)		(GraphMorph drawDataOn:)		(HttpUrl checkAuthorization:retry:)		(Integer asBytesDescription)		(IntegerTest testNumberOfDigits)		(IntegerTest testPrintStringBase)		(JPEGReadWriter decodeBlockInto:component:dcTable:acTable:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(MessageTally treePrintOn:tabs:thisTab:total:totalTime:tallyExact:orThreshold:)		(MessageTrace selectAllBetweenAnchorAnd:)		(MethodPragmaTest testCompileCharacter)		(MultiByteBinaryOrTextStream next:)		(MultiByteFileStream next:)		(MVCProject textWindows)		(MVCToolBuilder setLayout:in:)		(NewParagraph selectionRectsFrom:to:)		(PackageDependencyTest testPackage:dependsExactlyOn:)		(PasteUpMorph dropFiles:)		(Player veryDeepFixupWith:)		(PluggableTabButtonMorph calculateArcLengths)		(PluggableTabButtonMorph drawTabOn:)		(PluckedSound reset)		(PNGReadWriter copyPixelsGray:)		(PNGReadWriter processInterlaced)		(PNMReadWriter nextPutRGB:)		(PNMReadWriter nextPutBW:reverse:)		(PNMReadWriter readBWreverse:)		(PNMReadWriter readGray)		(PNMReadWriter readPlainRGB)		(PNMReadWriter writeHeader:)		(PointTest testTheta)		(PopUpMenu readKeyboard)		(PostscriptCanvas outlineQuadraticBezierShape:)		(QPickable2D pick:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(QUsersPane userEntryCompare:to:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(RelativeInstructionPrinter print:)		(RemoteHandMorph appendNewDataToReceiveBuffer)		(ScaledDecimalTest testConvertFromFraction)		(SHMCClassDefinition allInstVarNames)		(SHMCClassDefinition withAllSuperclasses)		(ShortIntegerArray writeOn:)		(SHParserST80 isBinary)		(StandardScriptingSystem holderWithAlphabet)		(StrikeFontSet displayStringR2L:on:from:to:at:kern:)		(String howManyMatch:)		(String keywords)		(StringTest testWthNoLineLongerThan)		(SyntaxMorph replaceKeyWord:menuItem:)		(SyntaxMorph replaceSel:menuItem:)		(TextDiffBuilder lcsFor:and:)		(TextURL actOnClickFor:)		(TShaderProgram vertexStrings) "foo ifTrue: []. => foo. => ."		(TShaderProgram fragmentStrings) "foo ifTrue: []. => foo. => ."		(TTContourConstruction segmentsDo:) "out of scope variable"		(TTCFontReader processCharacterMappingTable:)		(TTFileDescription getGlyphFlagsFrom:size:)		(TTFileDescription processCharacterMappingTable:)		(TTFontReader getGlyphFlagsFrom:size:)		(TTFontReader processCharacterMappingTable:)		(TTFontReader processHorizontalMetricsTable:length:)		(TWindow zoomWindow:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(WaveEditor showEnvelope)		(WeakSet scanForLoadedSymbol:)		"(PNMReadWriter nextImage) (Collection #ifEmpty:ifNotEmpty:) (Collection #ifEmpty:) (Collection #ifNotEmpty:ifEmpty:) (Text #alignmentAt:ifAbsent:) (ObjectWithDocumentation propertyAt:ifAbsent:)")! !"Tests"!!MessageNames methodsFor: 'selection' stamp: 'eem 6/18/2008 03:10'!selectedMessageName	^selectorListIndex = 0 ifFalse: [selectorList at: selectorListIndex]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:28'!restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self systemCategoryListIndex: (self systemCategoryList indexOf: category).	self classListIndex: (self classListIndexOf: className).	self metaClassIndicated: metaBool.	self messageCategoryListIndex: (self messageCategoryList indexOf: protocol).	self messageListIndex: (self messageList indexOf: selector).	editSelection := editMode.	self		contentsChanged;		decorateButtons! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:23' prior: 34073507!saveMultiWindowState	^Message		selector: #restoreToCategory:className:protocol:selector:mode:meta:		arguments: {	self selectedSystemCategoryName.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24'!restoreToPackage: packageNameOrNil category: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self packageListIndex: (self packageList indexOf: packageNameOrNil).	super restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24' prior: 34047186!saveMultiWindowState	^Message		selector: #restoreToPackage:category:className:protocol:selector:mode:meta:		arguments: {	self package.						self systemCategoryList at: systemCategoryListIndex ifAbsent: [].						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !PackagePaneBrowser removeSelector: #restoreToPackage:category:className:protocol:selector:mode:!Browser removeSelector: #restoreToCategory:className:protocol:selector:mode:!"Tools"!!Collection methodsFor: 'enumerating' stamp: 'eem 1/11/2009 14:11'!fold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]"	| firstValue nextValue |	firstValue := nextValue := Object new. "something that can't be in the receiver"	self do:		[:each |		nextValue := firstValue == nextValue						ifTrue: [each]						ifFalse: [binaryBlock value: nextValue value: each]].	^nextValue == firstValue		ifTrue: [self errorEmptyCollection]		ifFalse: [nextValue]! !!Character methodsFor: 'printing' stamp: 'eem 5/21/2010 11:11' prior: 18434657!hex	^value printStringBase: 16! !!SequenceableCollection methodsFor: 'copying' stamp: 'eem 2/10/2009 11:44'!copyUpThrough: anElement 	"Answer all elements up to and including anObject. If there	is no such object, answer a copy of the receiver."	^self first: (self indexOf: anElement ifAbsent: [^ self copy])! !!String methodsFor: 'converting' stamp: 'ar 7/15/2010 17:13' prior: 57349222!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end | | lineStart |				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [endWithoutDelimiters + 1]) min: endWithoutDelimiters.				[| lineStop lineEnd spacePosition |				lineEnd := 0.				spacePosition := lineStart.				lineStop := (lineStart + aNumber - 1) min: endWithoutDelimiters.				[spacePosition <= lineStop] whileTrue:[					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [endWithoutDelimiters+1].					spacePosition <= (lineStop+1) ifTrue:[lineEnd := spacePosition].				].				lineEnd = 0					ifTrue: ["no space - split arbitrarily"						lineEnd := lineStart + aNumber - 1 min: endWithoutDelimiters.						stream nextPutAll: (self copyFrom: lineStart to: lineEnd).						lineStart := lineEnd + 1]					ifFalse: ["split before space"						stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).						"eliminate conscutive spaces at split"						lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd + 1 ifAbsent: [endWithoutDelimiters + 1] ].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: endWithoutDelimiters + 1 to: end) ] ]! !"Collections"!!StringTest methodsFor: 'tests - converting' stamp: 'ar 7/15/2010 17:14' prior: 57355437!testWithNoLineLongerThan	"self run: #testWithNoLineLongerThan"	self assert: ('Hello World' withNoLineLongerThan: 5) = ('Hello', String cr, 'World').	self shouldnt:[('Hello', String cr, String cr,'World') withNoLineLongerThan: 5] raise: Error.	self assert: ('Sample text to line break at some point' withNoLineLongerThan:  28)		= ('Sample text to line break at', String cr, 'some point').	self assert: ('Sample text', String cr, 'to line break', String cr, 'at some point' withNoLineLongerThan:  28)		= ('Sample text', String cr, 'to line break', String cr, 'at some point').! !"CollectionsTests"!!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 10:39'!dosToSqueakTime: dt	"DOS years start at 1980, so add 1980."	| year mon mday hour min sec date time |	year := (( dt bitShift: -25 ) bitAnd: 16r7F ).	mon := (( dt bitShift: -21 ) bitAnd: 16r0F ).	mday := (( dt bitShift: -16 ) bitAnd: 16r1F ).	date := Date newDay: mday month: mon year: year+1980.	hour := (( dt bitShift: -11 ) bitAnd: 16r1F ).	min := (( dt bitShift: -5 ) bitAnd: 16r3F ).	sec := (( dt bitShift: 1 ) bitAnd: 16r3E ).	time := ((( hour * 60 ) + min ) * 60 ) + sec.	^date asSeconds + time	! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 10:38' prior: 33416759!lastModTime	"Return my last modification date/time stamp,	converted to Squeak seconds"	^self dosToSqueakTime: lastModFileDateTime! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 11:08' prior: 33417394!setLastModFileDateTimeFrom: aSmalltalkTime	lastModFileDateTime := self squeakToDosTime: aSmalltalkTime! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 11:00'!squeakToDosTime: secs	| dosTime dateTime |	dateTime := Time dateAndTimeFromSeconds: secs.	dosTime := (dateTime second seconds) bitShift: -1.	dosTime := dosTime + ((dateTime second minutes) bitShift: 5).	dosTime := dosTime + ((dateTime second hours) bitShift: 11).	dosTime := dosTime + ((dateTime first dayOfMonth) bitShift: 16).	dosTime := dosTime + ((dateTime first monthIndex) bitShift: 21).	dosTime := dosTime + (((dateTime first year) - 1980) bitShift: 25).	^dosTime! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 8/10/2010 13:15' prior: 33431506!writeDataTo: aStream	"Copy my (possibly inflated or deflated) data to the given stream.	This might do compression, decompression, or straight copying, depending	on the values of compressionMethod and desiredCompressionMethod"	"Note: Do not shortcut this method if uncompressedSize = 0. Even in this case	data may be produced by the compressor (i.e., '' zipped size > 0) and must	be stored in the file or else other utilities will treat the zip file as corrupt."	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])		ifTrue: [ ^self compressDataTo: aStream ].	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])		ifTrue: [ ^self uncompressDataTo: aStream ].	self copyDataTo: aStream.! !!ZipArchiveTests methodsFor: 'tests' stamp: 'ar 8/11/2010 20:45'!testDate29Feb2000	"Ensure that dates with leap years don't screw up in the conversion"	| archive mbr theDate |	theDate := Date year: 2000 month: 2 day: 29.	archive := ZipArchive new.	mbr := archive addDeflateString:'foo' as: 'bar'.	mbr setLastModFileDateTimeFrom: theDate asSeconds.	self shouldnt:[mbr lastModTime] raise: Error.	self assert: (Date fromSeconds: mbr lastModTime) = theDate.! !ZipArchiveMember removeSelector: #unixToSqueakTime:!ZipArchiveMember removeSelector: #unixToDosTime:!ZipArchiveMember removeSelector: #dosToUnixTime:!"Compression"!!MCHttpRepository methodsFor: 'required' stamp: 'ar 7/21/2010 19:53' prior: 54759713!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self displayProgress: 'Uploading ', aString during:[		response := HTTPSocket					httpPut: stream contents					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	].	"More robust handling of HTTP responses. Instead of enumerating	all possible return codes and http versions, do a quick parse"	(response beginsWith: 'HTTP/') ifTrue:[		"Looks like an HTTP header, not some error message"		statusLine := response copyUpTo: Character cr.		code := [(statusLine findTokens: ' ') second asInteger] on: Error do:[].	].	(code isInteger and:[code between: 200 and: 299]) 		ifFalse:[self error: response].! !"Monticello"!!CachedBlockClosure commentStamp: 'eem 7/22/2010 12:34' prior: 0!I'm a BlockClosure with an added instance variable for storing the once upon a time result of evaluating myself when I was simple BlockClosure. This is triggered by sending #once to a normal BlockClosure. Future sends of once will simply return this value rather than evaluate myself. When sent value, I revert back to a BlockClosure.  Originally by Travis Griggs, from whom we copy this idea with thanks.Instance Variables	cachedValue	<Object>cachedValue	- result of having sent value to myself when i was just a BlockClosure!!Time class methodsFor: 'clock' stamp: 'dtl 8/14/2010 15:25'!primMicrosecondClock	"Answer the number of microseconds since the microsecond clock	was last reset or rolled over. Answer zero if the primitive fails."	<primitive: 'primitiveMicrosecondClock'>	^ 0! !!Time class methodsFor: 'clock' stamp: 'dtl 8/14/2010 14:53'!primUtcWithOffset	"Answer an array with UTC microseconds since the Posix epoch and	the current seconds offset from GMT in the local time zone."	<primitive: 'primitiveUtcWithOffset'>	^ { 0 . 0 }! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:23'!becomeCached	self become: ((CachedBlockClosure new: self size)						outerContext: outerContext						startpc: startpc						numArgs: numArgs						cachedValue: self value						copiedValues: self)! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:19'!becomeUncached	"The receiver is already uncached."	^self! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:52'!once	"Answer and remember my value, answering exactly the same object in any further sends	 of once or value until I become uncached.  This allows one to intern values with the idiom		myResourceMethod			^[expression] once.	 The expression will be evaluated once and its result returned for any subsequent evaluations.	 Originally by Travis Griggs, from whom we copy this idea with thanks."	numArgs ~= 0 ifTrue:		[self error: 'once should only be used with niladic blocks'].	self becomeCached.	^self once! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:24'!becomeCached	"The receiver is already cached."	^self! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:21'!becomeUncached	self become: (BlockClosure 					outerContext: outerContext					startpc: startpc					numArgs: numArgs					copiedValues: self)! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:24'!once	^cachedValue! !!CachedBlockClosure methodsFor: 'initialize-release' stamp: 'eem 7/22/2010 12:16'!outerContext: aContext startpc: aStartpc numArgs: argCount cachedValue: aValue copiedValues: anArrayOrNil	cachedValue := aValue.	super outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:17'!value	^cachedValue! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingBytecode	"Answer the bytecode of the following bytecode (different to nextByte)."	^self method at: self followingPc! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingPc	"Answer the pc of the following bytecode."	^self nextPc: (self method at: pc)! !!InstructionStream methodsFor: 'private' stamp: 'eem 8/13/2010 11:38'!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	| type |	type := currentByte // 16.	^type = 8 "extensions"				ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: currentByte \\ 16 + 1)]				ifFalse: [type = 10 "long jumps"							ifTrue: [pc + 2]							ifFalse: [pc + 1]]! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:43' prior: 51439508!scanFor: scanBlock	"Answer the index of the first bytecode for which scanBlock	 answers true when supplied with that bytecode."	| method end byte |	method := self method.	end := method endPC.	[pc <= end] whileTrue: 		[(scanBlock value: (byte := method at: pc)) ifTrue:			[^true].		 pc := self nextPc: byte].	^false! !!Integer methodsFor: 'printing' stamp: 'eem 5/21/2010 11:06' prior: 21998699!hex	"Print the receiver as hex, prefixed with 16r.  DO NOT CHANGE THIS!!  The Cog VMMaker depends on this.	 Consider using any of		printStringHex		printStringBase: 16		printStringBase: 16 length: 8 padded: true		storeStringHex		storeStringBase: 16		storeStringBase: 16 length: 11 padded: true"	^self storeStringBase: 16! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 8/12/2010 13:52' prior: 19056689!decompileWithTemps	"Return the decompiled parse tree that represents self, but get the temp names	 by compiling the sourcecode..."	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	(self fileIndex > 0 and: [(SourceFiles at: self fileIndex) isNil]) ifTrue: [			"Emergency or no source file -- decompile without temp names "			^self decompile.	].	^((self decompilerClass new withTempNames: self methodNode schematicTempNamesString)						decompile: selector						in: class						method: self)! !"Kernel"!!VariableScopeFinder commentStamp: 'eem 8/14/2010 19:45' prior: 0!A VariableScopeFinder is used to find the minimum enclosing scope of a variable in a method.  This is used when auto-declaring temporaries to find the smallest enclosing block in which to declare the temp.Instance Variables	theVariable:		<VariableNode>theVariable	- the varable whose scope is to be determined!!BlockNode commentStamp: '<historical>' prior: 33669985!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!MessageNode commentStamp: '<historical>' prior: 59343427!I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.!!MethodNode commentStamp: 'eem 8/15/2010 10:49' prior: 59353244!I am the root of the parse tree..Instance Variables	arguments:			<SequenceableCollection>	block:				<BlockNode>	encoder:			<BytecodeEncoder>	localsPool:			<IdentitySet>	locationCounter:	<Integer>	precedence:		<Integer>	primitive:			<Integer>	properties:			<AdditionalMethodState|nil>	selectorOrFalse:	<Object>	sourceText:		<String|Text>	temporaries:		<SequenceableCollection>arguments	- the collection of parsed or decompiled method argumentsblock	- the BlockNode holding the method's statementsencoder	- the object that comprises the copiler's scope table, literal pool and back-end bytecode generatorlocalsPool	- a set used to determine the set of copied values for each block in the methodlocationCounter	- an integer used to mark block scopes for the purposes of the closure transformation.  See BlockNode>>#analyseArguments:temporaries:rootNode:precedence	- the precedence of the method's selector (see Symbol>>precedence)primitive	- if non-zero this is the integer code of the method's primitiveproperties	- the object used to accumulate method properties (a.k.a. pragmas)selectorOrFalse	- the method's selector or false if this is a doitsourceText	- the source test from which the method was compiledtemporaries	- the collection of parsed or decompiled method temporaries!!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 20:08' prior: 52074955!visitMessageNode: aMessageNode	aMessageNode receiver accept: self.	"receiver notNil ifTrue: ''receiver is nil for cascades''		[receiver accept: self]."	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode! !!VariableScopeFinder methodsFor: 'private' stamp: 'eem 8/12/2010 16:50'!enclosingNodeFor: enumerator of: rootNode	"Answer the minimum enclosing root node for aVariabe or nil if none.	 If the variable is accessed in more than one subnode then the rootNode is the	 enclosing node, otherwise it is which ever single subnode node that includes it, if any.	 enumerator applies its argument to all relevant subnodes of rootNode."	| enclosingNodeOrNil |	enclosingNodeOrNil := nil.	enumerator value:		[:subnode|		(subnode accept: self) ifNotNil:			[:enclosingNode|			enclosingNodeOrNil := enclosingNodeOrNil										ifNil: [enclosingNode]										ifNotNil: [rootNode]]].	^enclosingNodeOrNil! !!VariableScopeFinder methodsFor: 'initialize-release' stamp: 'eem 8/12/2010 16:18'!ofVariable: aVariableNode	theVariable := aVariableNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:51'!visitAssignmentNode: anAssignmentNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then anAssignmentNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock								value: anAssignmentNode value;								value: anAssignmentNode variable]		of: anAssignmentNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBlockNode: aBlockNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one statement then aBlockNode is the	 enclosing node, otherwise it is which ever single block node that includes it, if any."	^(self enclosingNodeFor: [:aBlock| aBlockNode statements do: aBlock] of: aBlockNode) ifNotNil:		[:aNode|		aNode isBlockNode ifTrue: [aNode] ifFalse: [aBlockNode]]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBraceNode: aBraceNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aBraceNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock| aBraceNode elements do: aBlock]		of: aBraceNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/16/2010 18:02'!visitCascadeNode: aCascadeNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aCascadeNode receiver.							aCascadeNode messages do:								[:msg| msg argumentsInEvaluationOrder do: aBlock]]		of: aCascadeNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitCommentNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitFieldNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:55'!visitFutureNode: aFutureNode	^aFutureNode receiver accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitInstanceVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitLiteralNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:03'!visitLiteralVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:07'!visitMessageNode: aMessageNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aMessageNode receiver.							aMessageNode argumentsInEvaluationOrder do: aBlock]		of: aMessageNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:00'!visitMethodNode: aMethodNode	^aMethodNode block accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitNewArrayNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitRemoteTempVectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:01'!visitReturnNode: aReturnNode	^aReturnNode expr accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitSelectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitTempVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode	^theVariable name = aVariableNode name ifTrue: [theVariable]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:06'!visitVariableNode: aVariableNode	^nil! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51552175!emitCodeForEffect: stack encoder: encoder	^self! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:25' prior: 51549757!emitCodeForLoad: stack encoder: encoder	"Default is to do nothing.	 Subclasses may need to override."! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51552568!sizeCodeForEffect: encoder	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:24' prior: 51550149!sizeCodeForLoad: encoder	"Default is to do nothing.	 Subclasses may need to override."	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:10' prior: 51553184!sizeCodeForValue: encoder	self subclassResponsibility! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:19' prior: 51562326!emitCodeForValue: stack encoder: encoder	stack push: 1.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 encoder genPushSpecialLiteral: specialLiteral])		ifFalse:			[encoder genPushLiteral: index]! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:03' prior: 51562996!sizeCodeForValue: encoder	self reserve: encoder.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizePushSpecialLiteral: specialLiteral])		ifFalse:			[^encoder sizePushLiteral: index]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52458608!emitCode: stack args: nArgs encoder: encoder	self emitCode: stack		args: nArgs		encoder: encoder		super: false! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:47' prior: 52458959!emitCode: stack args: nArgs encoder: encoder super: supered	stack pop: nArgs.	^supered		ifTrue:			[encoder genSendSuper: index numArgs: nArgs]		ifFalse:			[encoder				genSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52461103!emitCodeForEffect: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52462600!emitCodeForValue: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:15' prior: 52460344!sizeCode: encoder args: nArgs super: supered	self reserve: encoder.	^supered		ifTrue:			[code < Send "i.e. its a special selector" ifTrue:				[code := self code: (index := encoder sharableLitIndex: key) type: 5].			 encoder sizeSendSuper: index numArgs: nArgs]		ifFalse:			[self flag: #yuck. "special selector sends cause this problem"			 encoder				sizeSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52462457!sizeCodeForEffect: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52458466!sizeCodeForValue: encoder	self shouldNotImplement! !!UndeclaredVariableNode methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:51'!accept: aVisitor	^aVisitor visitUndeclaredVariableNode: self! !!UndeclaredVariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^true! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	^tag! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag: anObject	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	tag := anObject! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53104834!emitCodeForLoad: stack encoder: encoder	"Do nothing"! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41' prior: 53109491!emitCodeForReturn: stack encoder: encoder	encoder		if: code		isSpecialLiteralForReturn:			[:specialLiteral|			"short returns"			 encoder genReturnSpecialLiteral: specialLiteral.			 stack push: 1 "doesnt seem right".			 ^self].	(self code = LdSelf or: [self code = LdSuper]) ifTrue: 		["short returns"		 encoder genReturnReceiver.		 stack push: 1 "doesnt seem right".		 ^self].	super emitCodeForReturn: stack encoder: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 53112316!emitCodeForStore: stack encoder: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41' prior: 53106995!emitCodeForStorePop: stack encoder: encoder	self type ~= 1 ifTrue:		[self halt].	encoder genStorePopInstVar: index.	stack pop: 1! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07' prior: 53113225!emitCodeForValue: stack encoder: encoder	stack push: 1.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder genPushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder genPushReceiver].	code = LdThisContext ifTrue:		[^encoder genPushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder genPushInstVar: index! !!VariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^false! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:58' prior: 53112637!sizeCodeForReturn: encoder	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizeReturnSpecialLiteral: specialLiteral].	(self code = LdSelf or: [self code = LdSuper]) ifTrue:		[^encoder sizeReturnReceiver].	^super sizeCodeForReturn: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09' prior: 53105612!sizeCodeForStore: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09' prior: 53112172!sizeCodeForStorePop: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:54' prior: 53107813!sizeCodeForValue: encoder	self reserve: encoder.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral| "i.e. the pseudo-variables nil true & false"			 ^encoder sizePushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder sizePushReceiver].	code = LdThisContext ifTrue:		[^encoder sizePushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder sizePushInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51430402!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:05' prior: 51430573!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVar: index.	stack pop: 1! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51430765!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57' prior: 51429943!sizeCodeForStore: encoder	^encoder sizeStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07' prior: 51430238!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53' prior: 51430952!sizeCodeForValue: encoder	^encoder sizePushInstVar: index! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51110966!emitCodeForEffect: stack encoder: encoder! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51108318!emitCodeForLoad: stack encoder: encoder	rcvrNode emitCodeForValue: stack encoder: encoder.	fieldDef accessKey ifNotNil:[		super emitCodeForValue: stack encoder: encoder.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51111688!emitCodeForStore: stack encoder: encoder	fieldDef accessKey ifNil:[		writeNode emitCode: stack args: 1 encoder: encoder super: false.	] ifNotNil:[		writeNode emitCode: stack args: 2 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:18' prior: 51111996!emitCodeForStorePop: stack encoder: encoder	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51112488!emitCodeForValue: stack encoder: encoder	fieldDef accessKey ifNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 0 encoder: encoder super: false.	] ifNotNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		super emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 1 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51111095!sizeCodeForEffect: encoder	^0! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51109339!sizeCodeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeCodeForValue: encoder) + 			(writeNode sizeCode: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) +			(writeNode sizeCode: encoder args: 2 super: false)! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:17' prior: 51111519!sizeCodeForStorePop: encoder	^(self sizeCodeForStore: encoder) + encoder sizePop! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51113121!sizeCodeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 1 super: false)! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27' prior: 33547565!emitCodeForEffect: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStorePop: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27' prior: 33549094!emitCodeForValue: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStore: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16' prior: 33548242!sizeCodeForEffect: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStorePop: encoder)! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16' prior: 33549711!sizeCodeForValue: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStore: encoder)! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/12/2010 13:46' prior: 33908884!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home methodClass) == #unknown ifTrue: [^ nil].	aBlock isClosure ifTrue:		[(methodNode := method decompileWithTemps)			ifNil: [^nil]			ifNotNil: [methodNode nodesDo: [:node| node pc = aBlock startpc ifTrue: [^node]]].		 ^self error: 'cannot find block node matching aBlock'].	constructor := self constructorForMethod: aBlock method.		self withTempNames: method methodNode tempNames.	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock endPC.	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super method: method pc: startpc - 5.	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!Decompiler methodsFor: 'control' stamp: 'eem 8/12/2010 13:25' prior: 50903238!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| startpc savedTemps savedTempVarCount savedNumLocalTemps	  jump blockArgs blockTemps blockTempsOffset block |	savedTemps := tempVars.	savedTempVarCount := tempVarCount.	savedNumLocalTemps := numLocalTemps.	jump := blockSize + (startpc := pc).	numLocalTemps := BlockLocalTempCounter tempCountForBlockAt: pc - 4 in: method.	blockTempsOffset := numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: pc])		ifTrue:			[tempVars := blockStartsToTempVars at: pc]		ifFalse:			[blockArgs := (1 to: numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	tempVarCount := tempVarCount + numArgs + numLocalTemps.	block := self blockTo: jump.	stack addLast: ((constructor						codeArguments: (tempVars copyFrom: 1 to: numArgs)						temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)						block: block)							pc: startpc;							yourself).	tempVars := savedTemps.	tempVarCount := savedTempVarCount.	numLocalTemps := savedNumLocalTemps! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/12/2010 13:51' prior: 50907292!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	| copiedValues |	self sawClosureBytecode.	copiedValues := ((1 to: numCopied) collect: [:ign| stack removeLast]) reversed.	self doClosureCopyCopiedValues: copiedValues numArgs: numArgs blockSize: blockSize! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:44' prior: 51563596!emitCodeForLoad: stack encoder: encoder	writeNode ifNotNil:		[encoder genPushLiteral: index.		 stack push: 1]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:43' prior: 51567069!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:09' prior: 51567688!emitCodeForStorePop: stack encoder: encoder	writeNode ifNil:		[stack pop: 1.		 ^encoder genStorePopLiteralVar: index].	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:17' prior: 51567987!emitCodeForValue: stack encoder: encoder	^readNode		ifNil: [stack push: 1.			encoder genPushLiteralVar: index]		ifNotNil: [readNode emitCodeForValue: stack encoder: encoder]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:26' prior: 51564699!sizeCodeForLoad: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [encoder sizePushLiteral: index]		ifFalse: [0]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:27' prior: 51564887!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^writeNode sizeCode: encoder args: 1 super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2010 08:55' prior: 33817317!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:58' prior: 51568428!sizeCodeForValue: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialReadBinding]) 		ifFalse:			[^encoder sizePushLiteralVar: index].	readNode := MessageNode new 		receiver: (encoder encodeLiteral: key)		selector: (encoder encodeSelector: #value)		arguments: #()		precedence: #value precedence.	^readNode sizeCodeForValue: encoder! !!Parser methodsFor: 'error correction' stamp: 'eem 7/6/2010 15:07' prior: 52094356!declareClassVar: name	| sym class |	sym := name asSymbol.	class := encoder classEncoding.	class := class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	Smalltalk logChange: class definition.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Parser methodsFor: 'error correction' stamp: 'eem 5/6/2010 21:14' prior: 52081547!declareInstVar: name	"Declare an instance variable.  Since the variable will get added after any existing	 inst vars its index is the instSize."	encoder classEncoding addInstVarName: name.	Smalltalk logChange: encoder classEncoding definition.	^InstanceVariableNode new name: name index: encoder classEncoding instSize		! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:35'!declareTemp: name at: levelTag	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^(encoder bindUndeclaredTemp: name)		tag: levelTag;		yourself! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 19:34' prior: 52098032!declareTempAndPaste: name	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^encoder bindUndeclaredTemp: name! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:37'!declareUndeclaredTemps: methodNode	"Declare any undeclared temps, declaring them at the smallest enclosing scope."	| undeclared userSelection blocksToVars |	(undeclared := encoder undeclaredTemps) isEmpty ifTrue:		[^self].	userSelection := requestor selectionInterval.	blocksToVars := IdentityDictionary new.	undeclared do:		[:var|		(blocksToVars			at: (var tag == #method					ifTrue: [methodNode block]					ifFalse: [methodNode accept: (VariableScopeFinder new ofVariable: var)])			ifAbsentPut: [SortedCollection new]) add: var name].	(blocksToVars removeKey: methodNode block ifAbsent: []) ifNotNil:		[:rootVars|		rootVars do: [:varName| self pasteTempAtMethodLevel: varName]].	(blocksToVars keys sorted: [:a :b| a tempsMark < b tempsMark]) do:		[:block| | decl |		decl := (blocksToVars at: block) reduce: [:a :b| a, ' ', b].		block temporaries isEmpty			ifTrue:				[self substituteWord: ' | ', decl, ' |'					wordInterval: (block tempsMark + 1 to: block tempsMark)					offset: requestorOffset]			ifFalse:				[self substituteWord: decl, ' '					wordInterval: (block tempsMark to: block tempsMark - 1)					offset: requestorOffset]].	requestor selectInvisiblyFrom: userSelection first to: userSelection last + requestorOffset.	ReparseAfterSourceEditing signal! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 16:48' prior: 58135859!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode := self newMethodNode comment: messageComment.	methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties.	self interactive ifTrue:		[self declareUndeclaredTemps: methodNode.		 self removeUnusedTemps].	^methodNode! !!Parser methodsFor: 'public access' stamp: 'eem 8/16/2010 18:08' prior: 58137920!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p subSelection |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 subSelection := req notNil and: [req selectionInterval = (p + 1 to: p + s size)].	 self encoder init: class context: ctxt notifying: self.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := subSelection							ifTrue:								[ReadStream									on: requestor text string									from: requestor selectionInterval first									to: requestor selectionInterval last]							ifFalse:								[ReadStream on: requestor text string]].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !!Parser methodsFor: 'error correction' stamp: 'eem 8/13/2010 19:34'!pasteTempAtMethodLevel: name	| insertion delta theTextString characterBeforeMark |	theTextString := requestor text string.	characterBeforeMark := theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion := name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion := ' ', insertion].		delta := 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion := '| ' , name , ' |',String cr.		delta := 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion := insertion , String tab.			delta := delta + 1.	"the tab"		].	].	tempsMark := tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta! !!Parser methodsFor: 'error correction' stamp: 'eem 8/15/2010 08:56' prior: 54012081!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str madeChanges | 	madeChanges := false.	str := requestor text asString.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp | | start end |		(UnusedVariable name: temp) ifTrue:			[(encoder lookupVariable: temp ifAbsent: []) isUndefTemp				ifTrue:					[end := tempsMark.					["Beginning at right temp marker..."					start := end - temp size + 1.					end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]						whileFalse:							["Search left for the unused temp"							end := requestor nextTokenFrom: end direction: -1].					end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start := start-1].						requestor correctFrom: start to: end with: ''.						str := str copyReplaceFrom: start to: end with: ''. 						madeChanges := true.						tempsMark := tempsMark - (end-start+1)]]				ifFalse:					[self inform:'You''ll first have to remove the\statement where it''s stored into' withCRs]]].	madeChanges ifTrue: [ReparseAfterSourceEditing signal]! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 10:32' prior: 52101384!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presumed interactive) receiver.	 Update requestorOffset based on the delta size and answer the updated offset."	requestor correctFrom: spot first + o to: spot last + o with: correctWord.	requestorOffset := requestorOffset + correctWord size - spot size.	^o + correctWord size - spot size! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35' prior: 52088916!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35' prior: 52090927!temporariesIn: methodSelector	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance in: methodSelector)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 15:57' prior: 52077730!temporaryBlockVariablesFor: aBlockNode	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse:		"There are't any temporary variables."		[aBlockNode tempsMark: prevMark + requestorOffset.		 ^#()].	variables := OrderedCollection new.	[hereType == #word] whileTrue:		[variables addLast: (encoder bindBlockTemp: self advance within: aBlockNode)].	(self match: #verticalBar) ifFalse:		[^self expected: 'Vertical bar'].	aBlockNode tempsMark: prevMark + requestorOffset.	^variables! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51621449!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 6/19/2008 09:36' prior: 51621636!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVarLong: index.	stack pop: 1! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51621844!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57' prior: 51621095!sizeCodeForStore: encoder	^encoder sizeStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07' prior: 51621269!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53' prior: 51622047!sizeCodeForValue: encoder	^encoder sizePushInstVarLong: index! !!Compiler methodsFor: 'public access' stamp: 'ar 9/27/2005 19:20' prior: 19116591!compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	self from: textOrStream		class: aClass		classified: aCategory 		context: nil		notifying: aRequestor.	^self		translate: sourceStream		noPattern: false		ifFail: failBlock! !!Compiler methodsFor: 'public access' stamp: 'eem 7/2/2010 09:54' prior: 53973015!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into	 a method. If aContext is not nil, the text can refer to temporaries in that	 context (the Debugger uses this). If aRequestor is not nil, then it will receive	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 	 compiled method is invoked from here via withArgs:executeMethod:, hence	 the system no longer creates Doit method litter on errors."	| methodNode method value toLog itsSelection itsSelectionString |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail: [^failBlock value].	method := self interactive				ifTrue: [methodNode generateWithTempNames]				ifFalse: [methodNode generate].	value := receiver				withArgs: (context ifNil: [#()] ifNotNil: [{context}])				executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  			and:[(itsSelection := requestor selection) notNil			and:[(itsSelectionString := itsSelection asString) isEmptyOrNil not]])				ifTrue:[itsSelectionString]				ifFalse:[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext].	^ value! !!Compiler methodsFor: 'public access' stamp: 'eem 8/14/2010 20:23' prior: 50779925!from: textOrStream class: aClass classified: aCategory context: aContext notifying: req	sourceStream := (textOrStream isKindOf: PositionableStream)						ifTrue: [textOrStream]						ifFalse: [ReadStream on: textOrStream asString].	class := aClass.	context := aContext.	requestor := req.	category := aCategory! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58' prior: 51916787!emitCodeForValue: stack encoder: encoder	encoder genPushNewArray: numElements.	stack push: 1! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58' prior: 51917069!sizeCodeForValue: encoder	^encoder sizePushNewArray: numElements! !!Scanner methodsFor: 'expression types' stamp: 'eem 7/2/2010 10:07' prior: 53392053!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment notNil ifTrue:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark notNil ifTrue:		[(token == #- 		  and: [(self typeTableAt: hereChar) = #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType = #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType = #word or: [tokenType = #keyword or: [tokenType = #colon]])				ifTrue: 					[self scanLitWord.					 token = #true ifTrue: [token := true].					 token = #false ifTrue: [token := false].					 token = #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(self typeTableAt: hereChar) = #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken.	true] whileTrue! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 7/25/2010 12:23' prior: 53393807!xIllegal	"An illegal character was encountered"	self notify: 'Illegal character (char code ' , hereChar charCode , ' ' , hereChar charCode storeStringHex , ')' at: mark! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:41' prior: 50569842!emitCodeForValue: stack encoder: encoder	receiver emitCodeForValue: stack encoder: encoder.	1 to: messages size - 1 do: 		[:i | 		encoder genDup.		stack push: 1.		(messages at: i) emitCodeForValue: stack encoder: encoder.		encoder genPop.		stack pop: 1].	messages last emitCodeForValue: stack encoder: encoder! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:39' prior: 50570250!sizeCodeForValue: encoder	| size |	size := (receiver sizeCodeForValue: encoder)			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)).	messages do: [:aMessage | size := size + (aMessage sizeCodeForValue: encoder)].	^size! !!BlockNode methodsFor: 'code generation' stamp: 'eem 6/2/2008 13:29' prior: 50469704!emitCodeExceptLast: stack encoder: encoder	| position nextToLast |	position := stack position.	nextToLast := statements size - 1.	1 to: nextToLast do:		[:i | | statement |		statement := statements at: i.		statement emitCodeForEffect: stack encoder: encoder.		self assert: stack position = position].! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:28' prior: 50441069!emitCodeForEvaluatedEffect: stack encoder: encoder	| position |	position := stack position.	self returns		ifTrue: 			[self emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1]		ifFalse: 			[self emitCodeExceptLast: stack encoder: encoder.			statements last emitCodeForEffect: stack encoder: encoder].	self assert: stack position = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:36' prior: 50447264!emitCodeForEvaluatedValue: stack encoder: encoder	| position |	position := stack position.	self emitCodeExceptLast: stack encoder: encoder.	statements last emitCodeForBlockValue: stack encoder: encoder.	self assert: stack position - 1 = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55' prior: 50454333!emitCodeForValue: stack encoder: encoder	self generateAsClosure ifTrue:		[^self emitCodeForClosureValue: stack encoder: encoder].	encoder genPushThisContext.	stack push: 1.	nArgsNode emitCodeForValue: stack encoder: encoder.	remoteCopyNode		emitCode: stack		args: 1		encoder: encoder.	"Force a two byte jump."	encoder genJumpLong: size.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitCodeForStorePop: stack encoder: encoder].	self emitCodeForEvaluatedValue: stack encoder: encoder.	self returns ifFalse:		[encoder genReturnTopToCaller.		pc := encoder methodStreamPosition].	stack pop: 1! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/29/2008 15:21' prior: 50455290!sizeCodeExceptLast: encoder	| codeSize |	codeSize := 0.	1 to: statements size - 1 do: 		[:i | | statement |		 statement := statements at: i.		 codeSize := codeSize + (statement sizeCodeForEffect: encoder)].	^codeSize! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13' prior: 50447760!sizeCodeForEvaluatedEffect: encoder	^self returns		ifTrue: [self sizeCodeForEvaluatedValue: encoder]		ifFalse: [(self sizeCodeExceptLast: encoder)				+ (statements last sizeCodeForEffect: encoder)]! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 50467762!sizeCodeForEvaluatedValue: encoder	^(self sizeCodeExceptLast: encoder)		+ (statements last sizeCodeForBlockValue: encoder)! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55' prior: 50462928!sizeCodeForValue: encoder	self generateAsClosure ifTrue:		[^self sizeCodeForClosureValue: encoder].	nArgsNode := encoder encodeLiteral: arguments size.	remoteCopyNode := encoder encodeSelector: #blockCopy:.	size := self sizeCodeForEvaluatedValue: encoder.	self returns ifFalse:		[size := size + encoder sizeReturnTopToCaller]. "endBlock"	arguments := arguments collect:  "Chance to prepare debugger remote temps"						[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size := size + (arg sizeCodeForStorePop: encoder)].	^encoder sizePushThisContext	 + (nArgsNode sizeCodeForValue: encoder) 	 + (remoteCopyNode sizeCode: encoder args: 1 super: false)	 + (encoder sizeJumpLong: size)	 + size! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark	^tempsMark! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark: anInteger	tempsMark := anInteger! !!MessageNode class methodsFor: 'class initialization' stamp: 'eem 8/15/2010 10:22' prior: 55928326!initialize		"MessageNode initialize"	MacroSelectors := 		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers := 		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters := 		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:).	MacroSizers := 		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:			sizeCodeForToDo:value: sizeCodeForToDo:value:			sizeCodeForCase:value: sizeCodeForCase:value:			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:).	MacroPrinters := 		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !!MessageNode methodsFor: 'code generation' stamp: 'eem 9/29/2008 14:45' prior: 51652863!emitCodeForCase: stack encoder: encoder value: forValue	| braceNode sizeStream allReturn |	forValue ifFalse:		[^super emitCodeForEffect: stack encoder: encoder].	braceNode := arguments first.	sizeStream := ReadStream on: sizes.	receiver emitCodeForValue: stack encoder: encoder.	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last | | thenSize elseSize |		thenSize := sizeStream next.		elseSize := sizeStream next.		last ifFalse: [encoder genDup. stack push: 1].		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.		equalNode emitCode: stack args: 1 encoder: encoder.		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.		last ifFalse: [encoder genPop. stack pop: 1].		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse:			[self emitCodeForJump: elseSize encoder: encoder.			 allReturn := false].		(last and: [allReturn]) ifTrue:			[self emitCodeForJump: elseSize encoder: encoder]].	arguments size = 2		ifTrue:			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"		ifFalse:			[NodeSelf emitCodeForValue: stack encoder: encoder.			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23' prior: 51635767!emitCodeForEffect: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: false]		ifFalse: 			[super emitCodeForEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:12' prior: 51663950!emitCodeForIf: stack encoder: encoder value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize := sizes at: 1.	elseSize := sizes at: 2.	(forValue not and: [elseSize * thenSize > 0]) ifTrue:		"Two-armed IFs forEffect share a single pop"		[^super emitCodeForEffect: stack encoder: encoder].	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	receiver emitCodeForValue: stack encoder: encoder.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.			pc := encoder methodStreamPosition.			thenExpr emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not ifTrue:				"...not ifTrue: avoids using ifFalse: alone during this compile)"				"Elide jump over else after a return"				[self emitCodeForJump: elseSize encoder: encoder].			elseExpr emitCodeForEvaluatedValue: stack encoder: encoder]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					thenExpr emitCodeForEvaluatedEffect: stack encoder: encoder]				ifFalse:					[self emitCodeForBranchOn: true dist: elseSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					elseExpr emitCodeForEvaluatedEffect: stack encoder: encoder]]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:28' prior: 51667642!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:31' prior: 51630709!emitCodeForToDo: stack encoder: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].	initStmt emitCodeForEffect: stack encoder: encoder.	test emitCodeForValue: stack encoder: encoder.	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.	pc := encoder methodStreamPosition.	block emitCodeForEvaluatedEffect: stack encoder: encoder.	incStmt emitCodeForEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23' prior: 51666291!emitCodeForValue: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitCodeForValue: stack encoder: encoder].			arguments do: [:argument | argument emitCodeForValue: stack encoder: encoder].			pc := encoder methodStreamPosition + 1. "debug pc is first byte of the send, i.e. the next byte".			selector				emitCode: stack				args: arguments size				encoder: encoder				super: receiver == NodeSuper]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:36' prior: 51677780!emitCodeForWhile: stack encoder: encoder value: forValue 	"L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := sizes at: 1.	loopSize := sizes at: 2.	cond emitCodeForEvaluatedValue: stack encoder: encoder.	self emitCodeForBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"	pc := encoder methodStreamPosition.	stmt emitCodeForEvaluatedEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'nice 12/27/2009 03:11' prior: 54015765!sizeCodeForCase: encoder value: forValue	| braceNode sizeIndex elseSize allReturn |	forValue not ifTrue:		[^super sizeCodeForEffect: encoder].	equalNode := encoder encodeSelector: #=.	braceNode := arguments first.	sizes := Array new: 2 * braceNode numElements.	sizeIndex := sizes size.	elseSize := arguments size = 2		ifTrue:			[arguments last sizeCodeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode := encoder encodeSelector: #caseError.			 (NodeSelf sizeCodeForValue: encoder)			 + (caseErrorNode sizeCode: encoder args: 0 super: false)]. "self caseError"	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last |		valueNode returns ifFalse: [allReturn := false]].	braceNode casesReverseDo:		[:keyNode :valueNode :last | | thenSize |		sizes at: sizeIndex put: elseSize.		thenSize := valueNode sizeCodeForEvaluatedValue: encoder.		last ifFalse: [thenSize := thenSize + encoder sizePop].		valueNode returns ifFalse: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		(last and: [allReturn]) ifTrue: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize := elseSize + encoder sizeDup].		elseSize := elseSize					+ (keyNode sizeCodeForEvaluatedValue: encoder)					+ (equalNode sizeCode: encoder args: 1 super: false)					+ (self sizeCode: encoder forBranchOn: false dist: thenSize)					+ thenSize.		sizeIndex := sizeIndex - 2].	^(receiver sizeCodeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22' prior: 51636259!sizeCodeForEffect: encoder	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeCodeForEffect: encoder! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:15' prior: 51654401!sizeCodeForIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	(forValue	 or: [(thenExpr isJust: NodeNil)	 or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^super sizeCodeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize := elseExpr sizeCodeForEvaluatedValue: encoder.			thenSize := (thenExpr sizeCodeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeCode: encoder forJump: elseSize]).			branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize := 0.					thenSize := thenExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]				ifFalse:					[thenSize := 0.					elseSize := elseExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: true dist: elseSize]].	sizes := Array with: thenSize with: elseSize.	^(receiver sizeCodeForValue: encoder)	+ branchSize + thenSize + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:57' prior: 51648771!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector key == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector key == theSelector 					dist: theSize)				+ theSize]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:09' prior: 51638274!sizeCodeForToDo: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize initSize limitInit |	block := arguments at: 3.	initStmt := arguments at: 4.	test := arguments at: 5.	incStmt := arguments at: 6.	limitInit := arguments at: 7.	initSize := initStmt sizeCodeForEffect: encoder.	limitInit == nil ifFalse:		[initSize := initSize + (limitInit sizeCodeForEffect: encoder)].	blockSize := (block sizeCodeForEvaluatedEffect: encoder)			+ (incStmt sizeCodeForEffect: encoder)			+ (encoder sizeJumpLong: -1).	loopSize := (test sizeCodeForValue: encoder)			+ (self sizeCode: encoder forBranchOn: false dist: blockSize)			+ blockSize.	sizes := Array with: blockSize with: loopSize.	^initSize	+ loopSize	+ (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22' prior: 54017583!sizeCodeForValue: encoder	| total |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector := selector copy "only necess for splOops"].	total := selector sizeCode: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total := total + (receiver sizeCodeForValue: encoder)].	sizes := arguments collect: 					[:arg | | argSize | 					argSize := arg sizeCodeForValue: encoder.					total := total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:00' prior: 51674780!sizeCodeForWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).	branchSize := self					sizeCode: encoder					forBranchOn: selector key == #whileFalse:  "Btp for whileFalse"					dist: stmtSize.	loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.	sizes := Array with: stmtSize with: loopSize.	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 15:27'!addLocalsToPool: locals "<Set of: TempVariableNode>"	localsPool isNil ifTrue:		[localsPool := IdentitySet new].	localsPool addAll: locals! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:59'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	^encoder blockExtentsToTempsMap ifNil:		[| methNode |		methNode := encoder classEncoding parserClass new						encoderClass: encoder class;						parse: (sourceText ifNil: [self decompileString])						class: self methodClass.		"As a side effect generate: creates data needed for the map."		methNode generate.		methNode encoder blockExtentsToTempsMap]! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2008 10:04'!ensureClosureAnalysisDone	block blockExtent ifNil:		[temporaries := block analyseArguments: arguments temporaries: temporaries rootNode: self]! !!MethodNode methodsFor: 'code generation' stamp: 'eem 7/14/2010 11:28' prior: 51733588!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is arbitrary but is typically either the reference	 to the source code that is stored with every CompiledMethod, or an	 encoding of the method's temporary names."	| primErrNode blkSize nLits literals stack method |	self generate: trailer ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primErrNode					ifNil: [0]					ifNotNil: [primErrNode sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).	method := CompiledMethod				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments,											  temporaries,											  (primErrNode												ifNil: [#()]												ifNotNil: [{primErrNode}]).									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].	stack position: method numTemps.	block emitCodeForEvaluatedValue: stack encoder: encoder.	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!MethodNode methodsFor: 'code generation' stamp: 'Igor.Stasenko 12/20/2009 06:16'!generateWithTempNames	"Answer a CompiledMethod with temps names encoded in trailer"	^ self generate: (CompiledMethodTrailer new tempNames: self schematicTempNamesString).! !!MethodNode methodsFor: 'debugger support' stamp: 'eem 7/1/2009 13:45'!hasGeneratedMethod	^encoder hasGeneratedMethod! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 13:43'!locationCounter	^locationCounter! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:27'!noteBlockEntry: aBlock	"Evaluate aBlock with the numbering for the block entry."	locationCounter isNil ifTrue:		[locationCounter := -1].	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 12:12'!noteBlockExit: aBlock	"Evaluate aBlock with the numbering for the block exit."	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'printing' stamp: 'eem 8/15/2010 10:36' prior: 51737263!printWithClosureAnalysisOn: aStream 	self ensureClosureAnalysisDone.	precedence = 1		ifTrue: 			[(self selector includesSubString: '()/')				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).						arguments							do: [:arg| aStream nextPutAll: arg key]							separatedBy: [aStream nextPutAll: ', '].						aStream nextPut: $)]				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				arg printDefinitionForClosureAnalysisOn: aStream.				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			 self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1; nextPut: $|.			temporaries do: [:temp | 				aStream space.				temp printDefinitionForClosureAnalysisOn: aStream].			aStream space; nextPut: $|].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'code generation' stamp: 'eem 11/29/2008 18:53' prior: 23938335!properties	^properties! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:07'!referencedValuesWithinBlockExtent: anInterval 	^(localsPool select:		[:temp|		 temp isReferencedWithinBlockExtent: anInterval]) collect:			[:temp|			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:58'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occur	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with the schematicTempNamesString."	encoder hasGeneratedMethod ifFalse:		["create the encoder's blockExtentsToLoals map, except if the method is quick		  in which case it has no temps."		(self generate) isQuick ifTrue:			[^'']].	^encoder schematicTempNamesString! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52069998!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block"	^self emitCodeForValue: stack encoder: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:37' prior: 52069268!emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder	stack pop: 1.	dist = 0 ifTrue: [^encoder genPop].	condition		ifTrue: [encoder genBranchPopTrue: dist]		ifFalse: [encoder genBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38' prior: 52066326!emitCodeForEffect: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genPop.	stack pop: 1! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:39' prior: 52066948!emitCodeForJump: dist encoder: encoder	dist = 0 ifFalse: [encoder genJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38' prior: 52066037!emitCodeForReturn: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genReturnTop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13' prior: 52064750!sizeCode: encoder forBranchOn: condition dist: dist	dist = 0 ifTrue: [^encoder sizePop].	^condition		ifTrue: [encoder sizeBranchPopTrue: dist]		ifFalse: [encoder sizeBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:52' prior: 52067685!sizeCode: encoder forJump: dist	^dist = 0 ifTrue: [0] ifFalse: [encoder sizeJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52067118!sizeCodeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeCodeForValue: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:53' prior: 52066535!sizeCodeForEffect: encoder	^(self sizeCodeForValue: encoder) + encoder sizePop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:57' prior: 52069824!sizeCodeForReturn: encoder	^(self sizeCodeForValue: encoder) + encoder sizeReturnTop! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'eem 8/17/2010 16:35' prior: 58108085!openMenuIn: aBlock 	| alternatives labels actions lines caption choice |	alternatives := parser possibleVariablesFor: name.	labels := OrderedCollection new.	actions := OrderedCollection new.	lines := OrderedCollection new.	name first isLowercase 		ifTrue: 			[labels add: 'declare method temp'.			actions add: [parser declareTemp: name at: #method].			labels add: 'declare block-local temp'.			actions add: [parser declareTemp: name at: #block].			labels add: 'declare instance'.			actions add: [parser declareInstVar: name]]		ifFalse: 			[labels add: 'define new class'.			actions add: [parser defineClass: name].			labels add: 'declare global'.			actions add: [parser declareGlobal: name].			parser canDeclareClassVariable 				ifTrue: 					[labels add: 'declare class variable'.					actions add: [parser declareClassVar: name]]].	lines add: labels size.	alternatives do: 		[:each | 		labels add: each.		actions add: [parser substituteVariable: each atInterval: interval]].	lines add: labels size.	labels add: 'cancel'.	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51625745!emitCodeForStorePop: stack encoder: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self emitCodeForEffect: stack encoder: encoder! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51625450!sizeCodeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self sizeCodeForEffect: encoder! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40' prior: 52350839!emitCodeForReturn: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40' prior: 52350373!emitCodeForValue: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52349584!sizeCodeForReturn: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52348629!sizeCodeForValue: encoder	^expr sizeCodeForReturn: encoder! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 8/15/2010 16:56' prior: 50913929!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries |	selectorNode := self codeSelector: selector code: nil.	tempVars := vars.	visibleTemps := OrderedCollection new.	invisibleTemps := OrderedCollection new.	tempVars do: [:t|				   ((t isIndirectTempVector or: [t scope >= 0])						ifTrue: [visibleTemps]						ifFalse: [invisibleTemps]) addLast: t].	arguments := visibleTemps copyFrom: 1 to: nArgs.	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.	block		arguments: arguments;		temporaries: temporaries.	blockNode := MethodNode new		selector: selectorNode		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (EncoderForV3PlusClosures new initScopeAndLiteralTables					temps: visibleTemps, invisibleTemps					literals: literalValues					class: class)		primitive: primitive		properties: method properties copy.	blockNode properties method: blockNode.	^blockNode! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53916457!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block."	^effectNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53916708!emitCodeForEffect: stack encoder: encoder	^effectNode emitCodeForEffect: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53916893!emitCodeForValue: stack encoder: encoder	^valueNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28' prior: 53918505!sizeCodeForBlockValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForValue: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:27' prior: 53919232!sizeCodeForEffect: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForEffect: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28' prior: 53919956!sizeCodeForValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	valueNode := MessageNode new		receiver: receiver		selector: #futureSend:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^valueNode sizeCodeForValue: encoder! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:40' prior: 50522406!emitCodeForValue: stack encoder: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].		 encoder genPushConsArray: elements size.		 stack			pop: elements size;			push: 1.		 ^self].	^emitNode emitCodeForValue: stack encoder: encoder! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:22' prior: 50516994!sizeCodeForValue: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])		  + (encoder sizePushConsArray: elements size)].	emitNode := elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^emitNode sizeCodeForValue: encoder! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:22' prior: 52837966!emitCodeForLoad: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53' prior: 52847480!emitCodeForStore: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStoreInto: self stack: stack encoder: encoder].	encoder genStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:54' prior: 52841122!emitCodeForStorePop: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStorePopInto: self stack: stack encoder: encoder].	encoder genStorePopTemp: index.	stack pop: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53' prior: 52848137!emitCodeForValue: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForValueOf: self stack: stack encoder: encoder].	encoder genPushTemp: index.	stack push: 1! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 8/14/2010 11:02'!isDeclaredAtMethodLevel	"For the explainer."	^scope = 0! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:23' prior: 52845581!sizeCodeForLoad: encoder	^remoteNode isNil		ifTrue: [0]		ifFalse: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52' prior: 52838556!sizeCodeForStore: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStoreInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52' prior: 52847865!sizeCodeForStorePop: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStorePopInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStorePopTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:51' prior: 52844047!sizeCodeForValue: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForValueOf: self encoder: encoder].	self reserve: encoder.	^encoder sizePushTemp: index! !!Encoder methodsFor: 'private' stamp: 'eem 8/13/2010 16:06'!bindUndeclaredTemp: name	^scopeTable at: name put: (self newUndeclaredTemp: name)! !!Encoder methodsFor: 'encoding' stamp: 'eem 8/15/2010 08:29'!lookupVariable: name ifAbsent: aBlock	"Answer the binding of name in the scope table or aBlock's vaue if none.	 Do not bind and do not lookup in pools.  Used for correction, explanation etc"	^scopeTable at: name ifAbsent: aBlock! !!Encoder methodsFor: 'temps' stamp: 'eem 8/14/2010 19:35'!newUndeclaredTemp: name	^UndeclaredVariableNode new name: name! !!Encoder methodsFor: 'results' stamp: 'eem 8/13/2010 16:51'!undeclaredTemps 	^(scopeTable select: [:var | var isVariableNode and: [var isUndeclared]]) values! !BytecodeAgnosticMethodNode removeSelector: #schematicTempNamesString!BytecodeAgnosticMethodNode removeSelector: #referencedValuesWithinBlockExtent:!BytecodeAgnosticMethodNode removeSelector: #printWithClosureAnalysisOn:!BytecodeAgnosticMethodNode removeSelector: #noteBlockExit:!BytecodeAgnosticMethodNode removeSelector: #noteBlockEntry:!BytecodeAgnosticMethodNode removeSelector: #locationCounter!BytecodeAgnosticMethodNode removeSelector: #hasGeneratedMethod!BytecodeAgnosticMethodNode removeSelector: #generateWithTempNames!BytecodeAgnosticMethodNode removeSelector: #generate:!BytecodeAgnosticMethodNode removeSelector: #ensureClosureAnalysisDone!BytecodeAgnosticMethodNode removeSelector: #blockExtentsToTempsMap!BytecodeAgnosticMethodNode removeSelector: #addLocalsToPool:!Smalltalk removeClassNamed: #BytecodeAgnosticMethodNode!CascadeNode removeSelector: #sizeForValue:!CascadeNode removeSelector: #emitForValue:on:!MessageNode removeSelector: #sizeWhile:value:!MessageNode removeSelector: #sizeToDo:value:!MessageNode removeSelector: #sizeIfNil:value:!MessageNode removeSelector: #sizeIf:value:!MessageNode removeSelector: #sizeForValue:!MessageNode removeSelector: #sizeForEffect:!MessageNode removeSelector: #sizeCase:value:!MessageNode removeSelector: #emitWhile:on:value:!MessageNode removeSelector: #emitToDo:on:value:!MessageNode removeSelector: #emitIfNil:on:value:!MessageNode removeSelector: #emitIf:on:value:!MessageNode removeSelector: #emitForValue:on:!MessageNode removeSelector: #emitForEffect:on:!MessageNode removeSelector: #emitCase:on:value:!FutureNode removeSelector: #sizeForValue:!FutureNode removeSelector: #sizeForEffect:!FutureNode removeSelector: #sizeForBlockValue:!FutureNode removeSelector: #emitForValue:on:!FutureNode removeSelector: #emitForEffect:on:!FutureNode removeSelector: #emitForBlockValue:on:!TempVariableNode removeSelector: #cleanUpForRegeneration!BraceNode removeSelector: #sizeForValue:!BraceNode removeSelector: #emitForValue:on:!BytecodeEncoder removeSelector: #schematicTempNamesOn:blockExtents:fromIndex:!BytecodeEncoder removeSelector: #methodNodeClass!LeafNode removeSelector: #sizeForValue:!LeafNode removeSelector: #sizeForEffect:!LeafNode removeSelector: #emitLong:on:!LeafNode removeSelector: #emitForEffect:on:!LiteralVariableNode removeSelector: #sizeForValue:!LiteralVariableNode removeSelector: #sizeForStorePop:!LiteralVariableNode removeSelector: #sizeForStore:!LiteralVariableNode removeSelector: #emitStorePop:on:!LiteralVariableNode removeSelector: #emitStore:on:!LiteralVariableNode removeSelector: #emitLoad:on:!LiteralVariableNode removeSelector: #emitForValue:on:!AssignmentNode removeSelector: #sizeForValue:!AssignmentNode removeSelector: #sizeForEffect:!AssignmentNode removeSelector: #emitForValue:on:!AssignmentNode removeSelector: #emitForEffect:on:!SelectorNode removeSelector: #size:args:super:!SelectorNode removeSelector: #emit:args:on:super:!SelectorNode removeSelector: #emit:args:on:!BlockNode removeSelector: #sizeForValue:!BlockNode removeSelector: #sizeForEvaluatedValue:!BlockNode removeSelector: #sizeForEvaluatedEffect:!BlockNode removeSelector: #sizeExceptLast:!BlockNode removeSelector: #emitForValue:on:!BlockNode removeSelector: #emitForEvaluatedValue:on:!BlockNode removeSelector: #emitForEvaluatedEffect:on:!BlockNode removeSelector: #emitExceptLast:on:!VariableNode removeSelector: #sizeForStorePop:!VariableNode removeSelector: #sizeForStore:!VariableNode removeSelector: #sizeForReturn:!VariableNode removeSelector: #emitStorePop:on:!VariableNode removeSelector: #emitStore:on:!VariableNode removeSelector: #emitLoad:on:!VariableNode removeSelector: #emitForValue:on:!VariableNode removeSelector: #emitForReturn:on:!ReturnNode removeSelector: #sizeForValue:!ReturnNode removeSelector: #sizeForReturn:!ReturnNode removeSelector: #emitForValue:on:!ReturnNode removeSelector: #emitForReturn:on:!FieldNode removeSelector: #sizeForValue:!FieldNode removeSelector: #sizeForStorePop:!FieldNode removeSelector: #sizeForStore:!FieldNode removeSelector: #sizeForEffect:!FieldNode removeSelector: #emitStorePop:on:!FieldNode removeSelector: #emitStore:on:!FieldNode removeSelector: #emitLoad:on:!FieldNode removeSelector: #emitForValue:on:!FieldNode removeSelector: #emitForEffect:on:!ParseNode removeSelector: #sizeShortOrLong:!ParseNode removeSelector: #sizeJump:!ParseNode removeSelector: #sizeForReturn:!ParseNode removeSelector: #sizeForEffect:!ParseNode removeSelector: #sizeForBlockValue:!ParseNode removeSelector: #sizeBranchOn:dist:!ParseNode removeSelector: #emitShortOrLong:code:on:!ParseNode removeSelector: #emitLong:code:on:!ParseNode removeSelector: #emitJump:on:!ParseNode removeSelector: #emitForReturn:on:!ParseNode removeSelector: #emitForEffect:on:!ParseNode removeSelector: #emitForBlockValue:on:!ParseNode removeSelector: #emitBranchOn:dist:pop:on:!LiteralNode removeSelector: #emitForValue:on:!"Compiler"!!Point methodsFor: '*Etoys-tiles' stamp: 'ar 7/21/2010 20:02' prior: 34083620!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Player methodsFor: 'sound' stamp: 'ar 7/21/2010 20:06' prior: 26247887!getConePosition	"Note: Performance hacked to allow real-time sound. Assumes costume is a SpeakerMorph."	^ costume renderedMorph conePosition! !!Player methodsFor: 'sound' stamp: 'ar 7/21/2010 20:06' prior: 26248094!setConePosition: aNumber	"Note: Performance hacked to allow real-time sound. Assumes costume is a SpeakerMorph."	costume renderedMorph conePosition: aNumber.! !!BasicTypeTest methodsFor: 'tests' stamp: 'ar 7/21/2010 19:47'!testBasicType		self assert: (true basicType = #Boolean).	self assert: (false basicType = #Boolean).! !!TileMorphTest methodsFor: 'testing' stamp: 'tak 12/5/2004 18:58' prior: 53018044!testArrowAction	"self debug: #testArrowAction"	| dummy tile |	dummy := Morph new.	tile := TileMorph new setOperator: '+'.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '-'.	tile := TileMorph new setOperator: '<'.	dummy addMorph: tile.	tile arrowAction: 1.	"Because receiver is not tile"	self assert: tile codeString = '='.	tile := true newTileMorphRepresentative.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '(false)'.! !!TileMorphTest methodsFor: 'testing' stamp: 'tak 12/5/2004 18:58' prior: 53017486!testAssignmentTile	"self debug: #testAssignmentTile"	| player viewer tile phrase |	player := Morph new assuredPlayer.	viewer := CategoryViewer new invisiblySetPlayer: player.	viewer  makeSetter: #(#getX #Number) event: nil from: player costume.	phrase := ActiveHand firstSubmorph.	ActiveHand removeAllMorphs.	tile := phrase submorphs second.	self assert: tile codeString = 'setX: '.	tile arrowAction: 1.	self assert: tile codeString = 'setX: self getX + '.! !!TileMorphTest methodsFor: 'testing' stamp: 'ar 7/21/2010 19:48'!testNewTileMorphRepresentative		self assert: (nil newTileMorphRepresentative class =  UndescribedTile).	self assert: (false newTileMorphRepresentative isKindOf: TileMorph).	self assert: (false newTileMorphRepresentative literal = false).	self assert: (true newTileMorphRepresentative literal = true).! !!TileMorphTest methodsFor: 'testing' stamp: 'tlk 5/6/2006 16:35' prior: 53017184!testSoundTile	"self debug: #testSoundTile"	| tile dummy |	dummy := Morph new.	tile := SoundTile new literal: 'croak'.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '(''horn'')'.	! !Morph class removeSelector: #partName:categories:documentation:sampleImageForm:!HaloMorph removeSelector: #doMakeSiblingOrDup:with:!HaloMorph removeSelector: #doDupOrMakeSibling:with:!"EToys"!!FileStream class methodsFor: 'file reader services' stamp: 'ar 8/9/2010 10:46' prior: 34082090!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file. 	Uses ChangeSet defaultChangeSetDirectory for consistency."	^(ChangeSet defaultChangeSetDirectory)		writeSourceCodeFrom: aStream 		baseName: baseName 		isSt: stOrCsFlag 		useHtml: useHtml! !!FileDirectory methodsFor: 'utilities' stamp: 'ar 8/9/2010 10:44'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file."	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st).		] ifFalse: [			extension := (FileDirectory dot, FileStream cs).		].		converter := MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension := (FileDirectory dot, FileStream cs "multiCs").		].		converter := UTF8TextConverter new.	].	fileName := useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	fileName := self checkName: fileName fixErrors: true.	f := self newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !"Files"!!Rectangle commentStamp: 'nice 7/25/2010 14:56' prior: 27545885!I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.Note 1: only rectangles parallel to reference frame (Screen) can be represented by this class.Note 2: the Rectangle is represented by two extremities of one diagonal. By convention, it must be the diagonal:	from rectangle origin (the point having smallest coordinates in reference frame),	to rectangle corner (the point having largest coordinates in reference frame).Note 3: Screen coordinates conventions are:	x is horizontal axis, zero at left border, oriented toward right;	y is vertical axis, zero at top border, oriented toward bottom.This corresponds to the latin convention for writing text from left to right and top to bottom.Note 4: the Rectangle extent is obtained by subtracting rectangle origin to rectangle corner coordinates.If this leads to a negative width (extent x coordinate) and/or a negative height (extent y coordinate), then the Rectangle is degenerated and considered empty.Instance variables:	origin	<Point> the coordinates of corner having smallest coordinates (top left in Screen coordinates)	corner	<Point> the coordinates of corner having largest coordinates (bottom right in Screen coordinates)!!Color methodsFor: 'transformations' stamp: 'jcg 7/12/2010 18:29' prior: 53213026!duller	"Answer a darker, desaturated color.  If the original color isn't very saturated, desaturate it by less (otherwise will just end up with grey)."	| sat adjust |	(sat := self saturation) > 0.3		ifTrue: [adjust := -0.1]		ifFalse: [adjust := 0.1 - sat max: 0.0].	^ self adjustSaturation: adjust brightness: -0.1! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 21:27' prior: 27567474!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	| futureOrigin futureCorner |	direction == #horizontal		ifTrue:			[futureOrigin := self topRight.			futureCorner := self bottomLeft]		ifFalse: [direction == #vertical			ifTrue:				[futureOrigin := self bottomLeft.				futureCorner := self topRight]			ifFalse: [self error: 'unrecognizable direction']].	^ (futureOrigin flipBy: direction centerAt: aPoint)		corner: (futureCorner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'testing' stamp: 'nice 6/20/2010 21:32' prior: 52271353!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin := aRectangle origin.	rCorner := aRectangle corner.	rCorner x <= origin x	ifTrue: [^ false].	rCorner y <= origin y	ifTrue: [^ false].	rOrigin x >= corner x	ifTrue: [^ false].	rOrigin y >= corner y	ifTrue: [^ false]."None of the two rectangle shall be empty"	corner x <= origin x	ifTrue: [^ false].	corner y <= origin y	ifTrue: [^ false].	rCorner x <= rOrigin x	ifTrue: [^ false].	rCorner y <= rOrigin y	ifTrue: [^ false].	^ true! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 22:01' prior: 27570080!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	| futureOrigin futureCorner |	direction == #pi		ifTrue:			[futureOrigin := self corner.			futureCorner := self origin]		ifFalse: [direction == #left			ifTrue:				[futureOrigin := self topRight.				futureCorner := self bottomLeft]			ifFalse: [direction == #right				ifTrue:					[futureOrigin := self bottomLeft.					futureCorner := self topRight]				ifFalse: [self error: 'unrecognizable direction']]].	^ (futureOrigin rotateBy: direction centerAt: aPoint)		corner: (futureCorner rotateBy: direction centerAt: aPoint)! !!Point methodsFor: 'point functions' stamp: 'wiz 7/28/2007 20:50' prior: 34084395!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise.	For the zero point return a normal of  -1@0   ."	| n d |		n := y negated @ x.	(d := (n x * n x + (n y * n y))) = 0 ifTrue: [ ^  -1 @0  ] .	^n / d sqrt! !"Graphics"!!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:50' prior: 34085041!testBasicFourDirections	"fourDirections returns the four rotation of the receiver in counter clockwise order with the receiver appearing last. "	| samples results rejects |	self assert:  (0 asPoint fourDirections) = (Array new: 4 withAll: 0 asPoint) . 	samples := 0 asPoint eightNeighbors  .	results := {		{ 0 @ -1 . 	-1 @  0 . 	 0 @  1 . 	 1 @  0}.		{ 1 @ -1 . 	-1 @ -1 . 	-1 @  1 . 	 1 @  1}.		{ 1 @  0 . 	 0 @ -1 . 	-1 @  0 . 	 0 @  1}.		{ 1 @  1 . 	 1 @ -1 . 	-1 @ -1 . 	-1 @  1}.		{ 0 @  1 . 	 1 @  0 . 	 0 @ -1 . 	-1 @  0}.		{-1 @  1 . 	 1 @  1 . 	 1 @ -1 . 	-1 @ -1}.		{-1 @  0 . 	 0 @  1 . 	 1 @  0 . 	 0 @ -1}.		{-1 @ -1 . 	-1 @  1 . 	 1 @  1 . 	 1 @ -1} } .	rejects := (1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections = (results at: each) ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'tests - testing' stamp: 'nice 7/24/2010 18:43' prior: 26578741!testBearingToPoint	self assert: (0 @ 0 bearingToPoint: 0 @ 0) = 0.	self assert: (0 @ 0 bearingToPoint: 0 @ -1) = 0.	self assert: (0 @ 0 bearingToPoint: 1 @ 0) = 90.	self assert: (0 @ 0 bearingToPoint: 0 @ 1) = 180.	self assert: (0 @ 0 bearingToPoint: -1 @ 0) = 270.	self assert: (0 @ 0 bearingToPoint: 1 @ 1) = 135.	self assert: (0 @ 0 bearingToPoint: 0.01 @ 0) = 90.	self assert: (0 @ 0 bearingToPoint: -2 @ -3) = 326.	self assert: (0 @ 0 bearingToPoint: -0 @ 0) = 0.		self assert: (-2 @ -3 bearingToPoint: 0 @ 0) = 146.! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:52' prior: 34086878!testNormal	"quick check of results for #normal."	| samples rejects results |	samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .	results :=  		{ 0.0 @ 1.0 .		-0.707106781186547 @ 0.707106781186547 .		-1.0 @ 0.0 .		-0.707106781186547 @ -0.707106781186547 .		0.0 @ -1.0 .		0.707106781186547 @ -0.707106781186547 .		1.0 @ 0.0 .		0.707106781186547 @ 0.707106781186547 .		-1 @ 0} .	rejects := (1 to: samples size ) reject:		[ :each | ((samples at: each) normal - (results at: each)) abs  < 1e-15 asPoint ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:54' prior: 34087497!testNormal2	"quick check of results for #normal.	differs from the other testNormal in the way that the difference is measured."	| samples rejects results differences |	samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .	results := 		{ 0.0 @ 1.0 .		-0.707106781186547 @ 0.707106781186547 .		-1.0 @ 0.0 .		-0.707106781186547 @ -0.707106781186547 .		0.0 @ -1.0 .		0.707106781186547 @ -0.707106781186547 .		1.0 @ 0.0 .		0.707106781186547 @ 0.707106781186547 .		-1 @ 0} .	differences := samples with: results collect: [ :each :eachResult |		each normal - eachResult ] .	rejects := differences reject: [ :each | 		(each x closeTo: 0.0) and: [each y closeTo: 0.0] ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:44' prior: 26579508!testTheta      | result dir tan x y |	self assert: ((0 @ 1) theta - 90.0 degreesToRadians) abs < 1e-15.	self assert: ((0 @ -1) theta - 270.0 degreesToRadians) abs < 1e-15.	" See code of old and new theta"	x := 1.0 . y := -1.0.	tan := y  / x .	dir := tan arcTan.      result :=  360.0 degreesToRadians + dir.      self assert: ((x @ y) theta - result) abs < 1e-15.	x := -1.0. "Don't reuse old results when you want numeric precision!!"	tan := y  / x .	dir := tan arcTan.      result :=  180.0 degreesToRadians + dir.      self assert: ((x @ y) theta - result) abs < 1e-15.	! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 7/24/2010 18:45' prior: 25366936!drawStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1 @ 1 corner: aForm extent - 15) fillColor: Color red borderWidth: 3 borderColor: Color green.	canvas fillOval: (aForm boundingBox topRight - (15 @ -5) extent: 20 @ 20) color: Color blue borderWidth: 1 borderColor: Color white.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32 @ 32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 7/24/2010 18:45' prior: 25367460!drawTransparentStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1 @ 1 corner: aForm extent - 15) fillColor: (Color red alpha: 0.25) borderWidth: 3 borderColor: (Color green alpha: 0.5).	canvas fillOval: (aForm boundingBox topRight - (15 @ -5) extent: 20 @ 20) color: (Color white alpha: 0.75) borderWidth: 1 borderColor: Color blue.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32 @ 32 depth: 16)) display"! !"GraphicsTests"!!FractionTest methodsFor: 'tests - printing' stamp: 'nice 7/24/2010 18:43' prior: 21179342!testFractionPrinting	self assert: (353/359) printString = '(353/359)'.	self assert: ((2/3) printStringBase: 2) = '(10/11)'.	self assert: ((2/3) storeStringBase: 2) = '(2r10/2r11)'.	self assert: ((5/7) printStringBase: 3) = '(12/21)'.	self assert: ((5/7) storeStringBase: 3) = '(3r12/3r21)'.	self assert: ((11/13) printStringBase: 4) = '(23/31)'.	self assert: ((11/13) storeStringBase: 4) = '(4r23/4r31)'.	self assert: ((17/19) printStringBase: 5) = '(32/34)'.	self assert: ((17/19) storeStringBase: 5) = '(5r32/5r34)'.	self assert: ((23/29) printStringBase: 6) = '(35/45)'.	self assert: ((23/29) storeStringBase: 6) = '(6r35/6r45)'.	self assert: ((31/37) printStringBase: 7) = '(43/52)'.	self assert: ((31/37) storeStringBase: 7) = '(7r43/7r52)'.	self assert: ((41/43) printStringBase: 8) = '(51/53)'.	self assert: ((41/43) storeStringBase: 8) = '(8r51/8r53)'.	self assert: ((47/53) printStringBase: 9) = '(52/58)'.	self assert: ((47/53) storeStringBase: 9) = '(9r52/9r58)'.	self assert: ((59/61) printStringBase: 10) = '(59/61)'.	self assert: ((59/61) storeStringBase: 10) = '(59/61)'.	self assert: ((67/71) printStringBase: 11) = '(61/65)'.	self assert: ((67/71) storeStringBase: 11) = '(11r61/11r65)'.	self assert: ((73/79) printStringBase: 12) = '(61/67)'.	self assert: ((73/79) storeStringBase: 12) = '(12r61/12r67)'.	self assert: ((83/89) printStringBase: 13) = '(65/6B)'.	self assert: ((83/89) storeStringBase: 13) = '(13r65/13r6B)'.	self assert: ((97/101) printStringBase: 14) = '(6D/73)'.	self assert: ((97/101) storeStringBase: 14) = '(14r6D/14r73)'.	self assert: ((103/107) printStringBase: 15) = '(6D/72)'.	self assert: ((103/107) storeStringBase: 15) = '(15r6D/15r72)'.	self assert: ((109/113) printStringBase: 16) = '(6D/71)'.	self assert: ((109/113) storeStringBase: 16) = '(16r6D/16r71)'.	self assert: ((127/131) printStringBase: 17) = '(78/7C)'.	self assert: ((127/131) storeStringBase: 17) = '(17r78/17r7C)'.	self assert: ((137/139) printStringBase: 18) = '(7B/7D)'.	self assert: ((137/139) storeStringBase: 18) = '(18r7B/18r7D)'.	self assert: ((149/151) printStringBase: 19) = '(7G/7I)'.	self assert: ((149/151) storeStringBase: 19) = '(19r7G/19r7I)'.	self assert: ((157/163) printStringBase: 20) = '(7H/83)'.	self assert: ((157/163) storeStringBase: 20) = '(20r7H/20r83)'.	self assert: ((167/173) printStringBase: 21) = '(7K/85)'.	self assert: ((167/173) storeStringBase: 21) = '(21r7K/21r85)'.	self assert: ((179/181) printStringBase: 22) = '(83/85)'.	self assert: ((179/181) storeStringBase: 22) = '(22r83/22r85)'.	self assert: ((191/193) printStringBase: 23) = '(87/89)'.	self assert: ((191/193) storeStringBase: 23) = '(23r87/23r89)'.	self assert: ((197/199) printStringBase: 24) = '(85/87)'.	self assert: ((197/199) storeStringBase: 24) = '(24r85/24r87)'.	self assert: ((211/223) printStringBase: 25) = '(8B/8N)'.	self assert: ((211/223) storeStringBase: 25) = '(25r8B/25r8N)'.	self assert: ((227/229) printStringBase: 26) = '(8J/8L)'.	self assert: ((227/229) storeStringBase: 26) = '(26r8J/26r8L)'.	self assert: ((233/239) printStringBase: 27) = '(8H/8N)'.	self assert: ((233/239) storeStringBase: 27) = '(27r8H/27r8N)'.	self assert: ((241/251) printStringBase: 28) = '(8H/8R)'.	self assert: ((241/251) storeStringBase: 28) = '(28r8H/28r8R)'.	self assert: ((257/263) printStringBase: 29) = '(8P/92)'.	self assert: ((257/263) storeStringBase: 29) = '(29r8P/29r92)'.	self assert: ((269/271) printStringBase: 30) = '(8T/91)'.	self assert: ((269/271) storeStringBase: 30) = '(30r8T/30r91)'.	self assert: ((277/281) printStringBase: 31) = '(8T/92)'.	self assert: ((277/281) storeStringBase: 31) = '(31r8T/31r92)'.	self assert: ((283/293) printStringBase: 32) = '(8R/95)'.	self assert: ((283/293) storeStringBase: 32) = '(32r8R/32r95)'.	self assert: ((307/311) printStringBase: 33) = '(9A/9E)'.	self assert: ((307/311) storeStringBase: 33) = '(33r9A/33r9E)'.	self assert: ((313/317) printStringBase: 34) = '(97/9B)'.	self assert: ((313/317) storeStringBase: 34) = '(34r97/34r9B)'.	self assert: ((331/337) printStringBase: 35) = '(9G/9M)'.	self assert: ((331/337) storeStringBase: 35) = '(35r9G/35r9M)'.	self assert: ((347/349) printStringBase: 36) = '(9N/9P)'.	self assert: ((347/349) storeStringBase: 36) = '(36r9N/36r9P)'.	self assert: ((-2/3) printStringBase: 2) = '(-10/11)'.	self assert: ((-2/3) storeStringBase: 2) = '(-2r10/2r11)'.	self assert: ((5 / -7) printStringBase: 3) = '(-12/21)'.	self assert: ((5 / -7) storeStringBase: 3) = '(-3r12/3r21)'.! !!MethodContextTest methodsFor: 'private' stamp: 'HenrikSperreJohansen 6/11/2010 21:18'!privRestartTest	"This tests may loop endlessly if incorrect, so call it from another method testing it does not time out"	|a firstTimeThrough |	firstTimeThrough := true.	a := 10.		self assert: 30 equals: [|b| 		self assert: 10 == a .		self assert: nil == b.		b := a + 20. 		firstTimeThrough ifTrue: [			firstTimeThrough := false.			thisContext restart.].		b] value! !!MethodContextTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 6/11/2010 21:19'!testRestart	self should: [self privRestartTest] notTakeMoreThan: 0.1 second! !UndefinedObjectTest removeSelector: #testNewTileMorphRepresentative!BooleanTest removeSelector: #testNewTileMorphRepresentative!BooleanTest removeSelector: #testBasicType!"KernelTests"!!Project commentStamp: 'cbr 7/27/2010 21:36' prior: 33821982!A Project stores the state of a complete Squeak desktop, includingthe windows, and the currently active changeSet.  A project knows whoits parent project is.  When you change projects, whether by enteringor exiting, the screen state of the project being exited is saved inthat project.A project is retained by its view in the parent world.  It iseffectively named by the name of its changeSet, which can be changedeither by renaming in a changeSorter, or by editing the label of itsview from the parent project.As the site of major context switch, Projects are the locus ofswapping between the old MVC and the new Morphic worlds.  Thedistinction is based on whether the variable 'world' contains aWorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Projectnamed: 'xxx') exportSegment, or choose 'store project on file...'.Projects may be loaded from a server and stored back.  Storing on aserver never overwrites;  it always makes a new version.  A projectremembers the url of where it lives in urlList.  The list is lengthone, for now.  The url may point to a local disk instead of a server.All projects that the user looks at are cached in the Squeakletfolder.  Sorted by server.  The cache holds the most recent versiononly.When a project is loaded into Squeak, its objects are converted tothe current version.  There are three levels of conversion.  First,each object is converted from raw bits to an object in its oldformat.  Then it is sent some or all of these messages:	comeFullyUpOnReload: smartRefStream  		Used tore-discover an object that already exists in this image, such as aresource, global variable, Character, or Symbol.  (sent to objects inoutPointers)	convertToCurrentVersion: varDict refStream: smartRefStrm		fill in fields that have been added to a class sincethe object was stored.  Used to set the extra inst var to a defaultvalue.  Or, return a new object of a different class.  (sent toobjects that changed instance variables)	fixUponLoad: aProject refStream: smartRefStrm	change the object due to conventions that have changed on theproject level.  (sent to all objects in the incoming project)Here is the calling sequence for storing out a Project:Project saveAsProject storeOnServerProject storeOnServerWithProgressInfoProject storeOnServerInnardsProject exportSegmentFileName:directory:Project exportSegmentWithChangeSet:fileName:directory:ImageSegment writeForExportWithSources:inDirectory:changeSet:!!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:44'!flagInterpretedMethods: aBoolean	"The Cog VM can be instructed to set the flag bit of CompiledMethods that	 it executes but will only interpret.  This can be used e.g. to profile startup.	 See CompiledMethod>>#flag & CompiledMethod>>#clearFlag.  	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 2) + (aBoolean ifTrue: [2] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:43' prior: 33951420!isRunningCog	"Returns true if we're running on a Cog VM (JIT or StackInterpreter)	 (vmParameterAt: 42 is the number of stack pages)"	^[(self vmParameterAt: 42) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:41'!isRunningCogit	"Returns true if we're running on the Cog JIT	 (vmParameterAt: 46 is the size of the machine code zone)"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:23'!processHasThreadIdInstVar: aBoolean	"The threaded VM needs to know if the 4th inst var of Process	 is threadId which it uses to control process-to-thread binding.	 This flag persists across snapshots, stored in the image header."	aBoolean ifTrue: [self assert: (Process instVarNames at: 4) ='threadId'].	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 1) + (aBoolean ifTrue: [1] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:51'!processPreemptionYields	"Answer whether the VM causes a process to yield on process preemption,	 i.e. to put a preempted process at the back of its run queue.  If the parameter	 is unavailable (non-Cog VMs) or bit 2 (4) is 0 then preemption yields."	^(([self vmParameterAt: 48]			on: Error			do: [:ex| ^true]) allMask: 4) not! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:26'!processPreemptionYields: aBoolean	"The Cog VM can be instructed not to yield on process preemption,	 i.e. not to put a preempted process at the back of its run queue.  By	 default preempting a process causes it to yield (Blue Book semantics)	 which can have unfortunate effects.	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 4) + (aBoolean ifTrue: [0] ifFalse: [4])! !!MethodReference methodsFor: 'queries' stamp: 'eem 5/25/2010 17:56'!selector	^methodSymbol! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 8/9/2010 10:47' prior: 54154921!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	Cursor write showWhile: [ | internalStream |			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(UIManager default chooseFrom: #('Ignore' 'Browse slips')				 	title: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 8/14/2010 20:35' prior: 33968499!methodClass	| methodClassName methodClass |	(#(method #classComment) includes: type) ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk globals includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass := Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!SystemNavigation methodsFor: 'browse' stamp: 'dtl 8/1/2010 10:12'!browseMyChanges	"Browse only the changes (in the changes file) by the current author."	"SystemNavigation default browseMyChanges"	self browseAllSelect: [ :method |       method fileIndex > 1 "only look at changes file"               and: [ method timeStamp beginsWith: Utilities authorInitials ]]! !!Preferences class methodsFor: 'reacting to change' stamp: 'ar 7/21/2010 20:20' prior: 26931806!displaySizeChanged	self flag: #todo.	"only change font on small-land image"	self smallLandFonts.	self tinyDisplay		ifTrue: [self enable: #scrollBarsNarrow]		ifFalse: [self disable: #scrollBarsNarrow].	self tinyDisplay 		ifTrue:[self disable: #biggerHandles] 		ifFalse:[self enable: #biggerHandles]! !!Preferences class methodsFor: 'fonts' stamp: 'ar 7/21/2010 20:13'!restoreFontsAfter: aBlock	"Restore the currently chosen set of standard fonts after 	evaluating aBlock. Used for tests that modify the default fonts."	| standardDefaultTextFont standardListFont standardEToysFont standardMenuFont 	windowTitleFont standardBalloonHelpFont standardCodeFont standardButtonFont |	standardDefaultTextFont := Preferences standardDefaultTextFont.	standardListFont := Preferences standardListFont.	standardEToysFont := Preferences standardEToysFont.	standardMenuFont := Preferences standardMenuFont.	windowTitleFont := Preferences windowTitleFont.	standardBalloonHelpFont := Preferences standardBalloonHelpFont.	standardCodeFont := Preferences standardCodeFont.	standardButtonFont := Preferences standardButtonFont.	^aBlock ensure: [		Preferences setSystemFontTo: standardDefaultTextFont.		Preferences setListFontTo: standardListFont.		Preferences setEToysFontTo: standardEToysFont.		Preferences setMenuFontTo: standardMenuFont.		Preferences setWindowTitleFontTo: windowTitleFont.		Preferences setBalloonHelpFontTo: standardBalloonHelpFont.		Preferences setCodeFontTo: standardCodeFont.		Preferences setButtonFontTo: standardButtonFont.	].! !!SimpleButtonMorph commentStamp: 'ul 7/22/2010 04:30' prior: 29085281!I am labeled, rectangular morph which allows the user to click me. I can be configured to send my "target" the message "actionSelector" with "arguments" when I am clicked. I may have a label, implemented as a StringMorph.Example:	SimpleButtonMorph new		target: Beeper;		label: 'Beep!!';		actionSelector: #beep; 		openInWorldStructure:instance var 	Type		Description target 			Object 		The Object to notify upon a click actionSelector 	Symbol 		The message to send to Target (#messageName) arguments 		Array 		Arguments to send with #actionSelection (optional) actWhen 		Symbol 		When to take action: may be #buttonUp (default), #buttonDown,								#whilePressed, or #startDrag oldColor 		Color 		Used to restore color after click Another example: a button which quits the image without saving it.	SimpleButtonMorph new		target: Smalltalk;		label: 'quit';		actionSelector: #snapshot:andQuit:;		arguments: (Array with: false with: true); 		openInWorld!!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:40'!appsMenuOn: aDockingBar	"Create a menu with the registered apps"	aDockingBar addItem: [ :item |		item			contents: 'Apps' translated;			subMenuUpdater: self			selector: #listAppsOn: ]! !!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:44'!listAppsOn: menu	"Update the apps list in the menu"	| args |	TheWorldMenu registeredOpenCommands do:[:spec|		args := spec second.		menu addItem: [ :item |			item				contents: spec first translated;				target: args first;				selector: args second].	].! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'ar 8/6/2010 23:45' prior: 59056125!menusOn: aDockingBar 	self 		squeakMenuOn: aDockingBar;		projectsMenuOn: aDockingBar;		toolsMenuOn: aDockingBar;		appsMenuOn: aDockingBar;		extrasMenuOn: aDockingBar;		windowsMenuOn: aDockingBar;		helpMenuOn: aDockingBar.	aDockingBar addSpacer.	self		searchBarOn: aDockingBar;		clockOn: aDockingBar! !!TextEditor methodsFor: 'explain' stamp: 'eem 8/14/2010 11:15' prior: 57293992!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:09' prior: 52549432!erasePixelsOfColor: aColor 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	| newBounds |	originalForm		mapColor: aColor		to: Color transparent.	newBounds := originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: newBounds)! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:19'!erasePixelsUsing: evt 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	self rememberedColor "color to erase"		ifNil: [ ^ self ]		ifNotNilDo:			[ : chosenColor | self erasePixelsOfColor: chosenColor ]! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:15'!recolorPixelsOfColor: originalColor with: newColor	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| d newForm map |	d := originalForm depth.	newForm := Form extent: originalForm extent depth: d.	map := (Color cachedColormapFrom: d to: d) copy.	map at: (originalColor indexInMap: map) put: (newColor pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:18'!recolorPixelsUsing: evt 	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| originalColor newColor |	self inform: 'choose the color you want to replace' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	"color to replace"	originalColor := self rememberedColor ifNil: [ ^ self ].	self inform: 'now choose the color you want to replace it with' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: originalColor		hand: evt hand.	"new color"	newColor := self rememberedColor ifNil: [ ^ self ].	self		recolorPixelsOfColor: originalColor		with: newColor! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 8/2/2010 20:51' prior: 52991136!addPrintAndDebug: menu	Preferences simpleMenus ifFalse: [		self			fillIn: menu			from: {				{ 'make screenshot'. {self. #saveScreenshot}. 'makes a screenshot and saves it to disk'}.				"{ 'print PS to file...'. { self. #printWorldOnFile }. 'write the world into a postscript file' }."				{ 'debug...'. { self. #debugDo }. 'a menu of debugging items' }			} ]! !!TheWorldMenu methodsFor: 'action' stamp: 'ar 8/2/2010 20:51'!saveScreenshot	"Make a screenshot of the world and save it to a file"	SampledSound playSoundNamed: 'camera'.	PNGReadWriter putForm: myWorld imageForm onFileNamed:		(FileDirectory default nextNameFor: 'SqueakScreen' extension:'png').! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:26'!doDupOrMakeSibling: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *not* pressed, or make a sibling if shift key *is* pressed"	^ (evt shiftPressed and: [target couldMakeSibling])		ifTrue:			[dupHandle color: Color green muchDarker.			self doMakeSibling: evt with: dupHandle]		ifFalse:			[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:28'!doMakeSiblingOrDup: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *is* pressed, or make a sibling if shift key *not* pressed"	^ (evt shiftPressed or: [target couldMakeSibling not])		ifFalse:			[self doMakeSibling: evt with: dupHandle]		ifTrue:			[dupHandle color: Color green.			self doDup: evt with: dupHandle]! !!Morph class methodsFor: 'new-morph participation' stamp: 'ar 7/21/2010 20:03'!partName: aName categories: aList documentation: aDoc sampleImageForm: aForm	"Answer a DescriptionForPartsBin which will represent a launch of a new instance of my class via the #newStandAlone protocol sent to my class. Use the category-list and documentation provided.  This variant allows an overriding image form to be provided, useful in cases where we don't want to launch a sample instance just to get the form"	| descr |	descr := DescriptionForPartsBin new		formalName: aName		categoryList: aList		documentation: aDoc		globalReceiverSymbol: self name		nativitySelector: #newStandAlone.	descr sampleImageForm: aForm.	^ descr! !!Morph methodsFor: 'menus' stamp: 'cmm 8/2/2010 18:20' prior: 24277159!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsUsing:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsUsing:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetPoint) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !SketchMorph removeSelector: #recolorPixelsOfColor:!"Morphic"!!Unicode commentStamp: 'yo 10/19/2004 20:44' prior: 59456444!This class holds the entry points for the utility functions around characters.!!SparseXTable methodsFor: 'accessing' stamp: 'nice 7/10/2010 23:49' prior: 57452504!tableFor: code	| div |	div := code // 65536.	^xTables at: div ifAbsentPut:		[Array new: 65536 withAll: 0].! !!UTF16TextConverter methodsFor: 'private' stamp: 'HenrikSperreJohansen 6/7/2010 15:04'!swapLatin1EncodingByteOrder	latin1Encodings := latin1Encodings collect: [:each | each reverse]! !!UTF16TextConverter methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 6/7/2010 15:04' prior: 53388927!useLittleEndian: aBoolean	aBoolean = self useLittleEndian ifFalse: [self swapLatin1EncodingByteOrder].	useLittleEndian := aBoolean.! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:47'!initializeCaseMappings	"Unicode initializeCaseMappings"	ToCasefold := IdentityDictionary new.	ToUpper := IdentityDictionary new.	ToLower := IdentityDictionary new.	UIManager default informUserDuring: [:bar|		| stream |		bar value: 'Downloading Unicode data'.		stream := HTTPClient httpGet: 'http://www.unicode.org/Public/UNIDATA/CaseFolding.txt'.		(stream isKindOf: RWBinaryOrTextStream) ifFalse:[^self error: 'Download failed'].		stream reset.		bar value: 'Updating Case Mappings'.		self parseCaseMappingFrom: stream.	].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:49'!parseCaseMappingFrom: stream	"Parse the Unicode casing mappings from the given stream.	Handle only the simple mappings"	"		Unicode initializeCaseMappings.	"	ToCasefold := IdentityDictionary new: 2048.	ToUpper := IdentityDictionary new: 2048.	ToLower := IdentityDictionary new: 2048.	[stream atEnd] whileFalse:[		| fields line srcCode dstCode |		line := stream nextLine copyUpTo: $#.		fields := line withBlanksTrimmed findTokens: $;.		(fields size > 2 and: [#('C' 'S') includes: (fields at: 2) withBlanksTrimmed]) ifTrue:[			srcCode := Integer readFrom: (fields at: 1) withBlanksTrimmed base: 16.			dstCode := Integer readFrom: (fields at: 3) withBlanksTrimmed base: 16.			ToCasefold at: srcCode put: dstCode.		].	].	ToCasefold keysAndValuesDo:		[:k :v |		(self isUppercase: (self value: k))			ifTrue:				["In most cases, uppercase letter are folded to lower case"				ToUpper at: v put: k.				ToLower at: k put: v].		(self isLowercase: (self value: k))			ifTrue:				["In a few cases, two lower case letters are folded to the same lower case.				We must find an upper case letter folded to the same letter"				| up |				up := ToCasefold keys detect: [:e | (self isUppercase: (self value: e)) and: [(ToCasefold at: e) = v]] ifNone: [nil].				up ifNotNil: [ToUpper at: k put: up]]].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:00'!toCasefold: aWideString	"Transform a Wide String into fold case.	This is to enable case insensitive conversion."		^aWideString collect: [:e |		(ToCasefold at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:11'!toLowercase: aWideString	"Transform a Wide String into lowercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToLower at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:08'!toUppercase: aWideString	"Transform a Wide String into uppercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToUpper at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:up | self value: up]]! !"Multilingual"!!LedCharacterMorph commentStamp: 'cbr 7/27/2010 18:47' prior: 59337038!I represent a character to be displayed on an LedMorph; I am a peer to LedDigitMorph. The char 36 is SPACE.I can live outside of LedMorphs, however. If you'd like to play with me, evaluate the following line:LedCharacterMorph new char: $e; openInWorld!"MorphicExtras"!MorphTest removeSelector: #testOverlapAnyUnscriptedPlayer!MorphTest removeSelector: #testOverlapAnyScriptedPlayer!MorphTest removeSelector: #testOverlapAnyDeletedPlayer!MorphTest removeSelector: #testOverlapAny!!UTF16TextConverterTest methodsFor: 'testing' stamp: 'HenrikSperreJohansen 6/7/2010 15:03'!testByteOrders	|converter originalText bytes decodedText |	originalText := 'test'.	converter := UTF16TextConverter new.		"Default (ie useLittleEndian instvar nil)"	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		"Little-endian"	converter useLittleEndian: true.	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		"Big-endian"	converter useLittleEndian: false.	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		! !"MultilingualTests"!!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/12/2010 18:54' prior: 34101734!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	args ifNotNil: [		urlString := urlString, (self argString: args) 	].	^(self httpRequestHandler) 		httpRequest: 'GET' url: urlString headers:(			(mimeType ifNil:[''] ifNotNil:['Accept: ', mimeType, String crlf]),			'Accept: text/html', String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString		) content: nil response: nil.! !!SocketStream methodsFor: 'initialize-release' stamp: 'ar 7/24/2010 15:13'!destroy	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."	socket ifNotNil:[socket destroy]! !!SocketStream methodsFor: 'control' stamp: 'ar 7/24/2010 14:48' prior: 52619090!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	((outNextToWrite > 1) and: [socket isOtherEndClosed not])		ifTrue: [			[self sendData: outBuffer count: outNextToWrite - 1]				on: ConnectionTimedOut				do: [:ex | shouldSignal ifFalse: ["swallow"]].			outNextToWrite := 1]! !!SocketStream methodsFor: 'testing' stamp: 'ar 7/24/2010 14:50' prior: 29500464!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we check the socket for data. If it claims to have data available to read, we try to read some once and recursively call this method again. If something really was available it is now in the inBuffer. This is because there has been spurious dataAvailable when there really is no data to get.	Note: Some subclasses (such as SecureSocketStream) rely on the behavior here since even though data may be available in the underlying socket, it may not result in any output (yet)." 	self isInBufferEmpty ifFalse: [^true].	^socket dataAvailable		ifFalse: [false]		ifTrue: [self receiveAvailableData; isDataAvailable]! !!SocketStream methodsFor: 'stream out' stamp: 'ar 7/24/2010 14:48' prior: 52611609!nextPutAllFlush: aCollection	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self flush. "first flush pending stuff, then directly send"	socket isOtherEndClosed ifFalse: [		[self sendData: toPut count: toPut size]			on: ConnectionTimedOut			do: [:ex | shouldSignal ifFalse: ["swallow"]]]! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07' prior: 52610836!receiveAvailableData	"Receive available data (as much as fits in the inBuffer) but not waiting for more to arrive. Return the position in the buffer where the new data starts, regardless if anything was read, see #adjustInBuffer."		recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:03' prior: 29504781!receiveData	"Receive data. Signal exceptions and timeouts depending on #shouldSignal and #shouldTimeout. Return the position in the buffer where the new data starts, regardless if anything was read."	socket		waitForDataFor: self timeout		ifClosed: [self shouldSignal 			ifTrue:[ConnectionClosed signal: 'Connection closed while waiting for data.']]		ifTimedOut: [self shouldTimeout			ifTrue:[ConnectionTimedOut signal: 'Data receive timed out.']].	^self receiveAvailableData! !!SocketStream methodsFor: 'control' stamp: 'ar 8/5/2010 12:23' prior: 29486984!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self isConnected and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50' prior: 52617013!receiveDataIfAvailable	"Deprecated. Use #receiveAvailableData instead"	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!receiveDataInto: buffer startingAt: index.	"Read data from the underlying socket. This method may be overridden by subclasses wanting to control incoming traffic for other purposes like encryption or statistics."	^socket  receiveAvailableDataInto: buffer startingAt: index.! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!sendData: buffer count: n	"Sends outgoing data directly on the underlying socket."	^socket sendData: buffer count: n! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50' prior: 52619519!upTo: aCharacterOrByte	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of anObject in the receiver. If  anObject is not in the collection, answer the entire rest of the receiver."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upTo: aCharacterOrByte limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upTo: aCharacterOrByte limit: nBytes	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"	| index result searchedSoFar |	"Look in the current inBuffer first"	index := inBuffer indexOf: aCharacterOrByte startingAt: lastRead + 1.	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: 1.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	"We only get recentlyRead = 0 in the case of a non-signaling socket close."	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset."		index := inBuffer indexOf: aCharacterOrByte						startingAt: (lastRead + searchedSoFar + 1).		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:48' prior: 52614582!upToAll: aStringOrByteArray	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upToAll: aStringOrByteArray limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upToAll: aStringOrByteArray limit: nBytes	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"	| index sz result searchedSoFar |	sz := aStringOrByteArray size.	"Look in the current inBuffer first"	index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: lastRead - sz + 2.	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: sz.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset and 		backs up sz - 1 so that we can catch any borderline hits."		index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/5/2010 12:23' prior: 29497260!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself.		NOTE: Does not honour timeouts if shouldSignal is false!!"	[[self isConnected] whileTrue: [self receiveData]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !"Network"!!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 18:10'!setUp	| listener clientSocket serverSocket |	listener := Socket newTCP.	[listener listenOn: 0 backlogSize: 4.	clientSocket := Socket newTCP.	clientSocket connectTo: #[127 0 0 1] port: listener localPort.	clientSocket waitForConnectionFor: 1.	self assert: clientSocket isConnected.	serverSocket := listener waitForAcceptFor: 1.	self assert: serverSocket isConnected.	] ensure:[listener destroy].	clientStream := SocketStream on: clientSocket.	serverStream := SocketStream on: serverSocket.! !!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 17:59'!tearDown	clientStream ifNotNil:[clientStream destroy].	serverStream ifNotNil:[serverStream destroy].! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoClose	"Ensure that #next:into: will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoCloseNonSignaling	"Ensure that #next:into: will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpTo	"Tests correct behavior of #upTo:"	clientStream nextPutAll:'A line of text', String cr, 'with more text'; flush.	self assert: (serverStream upTo: Character cr) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String cr; flush] fork.	self assert: (serverStream upTo: Character cr) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upTo: Character cr] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upTo: Character cr] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:29'!testUpToAll	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text', String crlf, 'with more text'; flush.	self assert: (serverStream upToAll: String crlf) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String crlf; flush] fork.	self assert: (serverStream upToAll: String crlf) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:02'!testUpToAllAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upToAll: String crlf] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:26'!testUpToAllAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upToAll: String crlf] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:48'!testUpToAllLimit	"Tests correct behavior of #upToAll:limit:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upToAll: String crlf limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:11'!testUpToAllTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upToAll: String crlf] raise: ConnectionTimedOut.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testUpToEndClose	"Ensure that #upToEnd will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testUpToEndCloseNonSignaling	"Ensure that #upToEnd will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:49'!testUpToMax	"Tests correct behavior of #upToAll:max:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upTo: Character cr limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upTo: Character cr] raise: ConnectionTimedOut.! !"NetworkTests"!!ParagraphEditor methodsFor: 'explain' stamp: 'eem 8/14/2010 11:15' prior: 53527614!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !"ST80"!!FFT methodsFor: 'bulk processing' stamp: 'ul 8/3/2010 15:43' prior: 20330288!transformDataFrom: anIndexableCollection startingAt: index	"Forward transform a block of real data taken from from the given indexable collection starting at the given index. Answer a block of values representing the normalized magnitudes of the frequency components."	| j real imag out |	j := 0.	index to: index + n - 1 do: [:i |		realData at: (j := j + 1) put: (anIndexableCollection at: i)].	realData *= window.	imagData := FloatArray new: n.	self transformForward: true.	"compute the magnitudes of the complex results"	"note: the results are in bottom half; the upper half is just its mirror image"	real := realData copyFrom: 1 to: (n / 2).	imag := imagData copyFrom: 1 to: (n / 2).	out := (real * real) + (imag * imag).	1 to: out size do: [:i | out at: i put: (out at: i) sqrt].	^ out! !!FFT methodsFor: 'transforming' stamp: 'ul 8/3/2010 15:43' prior: 20336130!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i |	<primitive: 'primitiveFFTTransformData' module: 'FFTPlugin'>	self permuteData.	1 to: nu do:		[:level |		lev := 1 bitShift: level.		lev1 := lev // 2.		1 to: lev1 do:			[:j |			theta := j-1 * (n // lev).   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < (n//4)  "Compute U, the complex multiplier for each level"				ifTrue:					[realU := sinTable at: sinTable size - theta.					imagU := sinTable at: theta + 1]				ifFalse:					[realU := (sinTable at: theta - (n//4) + 1) negated.					imagU := sinTable at: (n//2) - theta + 1].			forward ifFalse: [imagU := imagU negated]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i := j.			[i <= n] whileTrue:				[ip := i + lev1.				realT := ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT := ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: i) - realT.				imagData at: ip put: (imagData at: i) - imagT.				realData at: i put: (realData at: i) + realT.				imagData at: i put: (imagData at: i) + imagT.				i := i + lev]]].	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !"Sound"!!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'ar 7/21/2010 20:13' prior: 22448460!testIsFontAvailable	"self new testIsFontAvailable"	"self run: #testIsFontAvailable"	| oldPref |	oldPref := Preferences valueOfPreference: #tinyDisplay.	Preferences restoreFontsAfter:[	[Preferences enable: #tinyDisplay .	self 		shouldnt:[(LanguageEnvironment localeID: 'en' ) isFontAvailable] 		raise: Error.	] ensure: [Preferences setPreference: #tinyDisplay toValue: oldPref].	].! !!HexTest methodsFor: 'as yet unclassified' stamp: 'eem 5/21/2010 11:12' prior: 21544180!testIntegerHex	| result |	result := 15 asInteger hex.	self assert: result = '16rF'.	result := 0 asInteger hex.	self assert: result = '16r0'.	result := 255 asInteger hex.	self assert: result = '16rFF'.	result := 90 asInteger hex.	self assert: result = '16r5A'! !!MirrorPrimitiveTests methodsFor: 'testing' stamp: 'eem 7/6/2010 20:44' prior: 57226887!expectedFailures	^Smalltalk isRunningCog		ifTrue: [#()]		ifFalse: [#(testMirrorAt testMirrorEqEq testMirrorInstVarAt testMirrorPerform testMirrorSize)]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:33'!testOptimizedBlockLocalNilling1	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 3 do: [:i| | j |		self assert: j isNil.		j := i + 1.		self assert: j isNil not]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:32'!testOptimizedBlockLocalNilling2	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 6 do: [:i| | j k |		self assert: j isNil.		self assert: k isNil.		i even			ifTrue: [j := i + 2]			ifFalse: [k := i + 1].		self assert: (j isNil or: [k isNil]).		self assert: (j isNil not or: [k isNil not])]! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:42' prior: 34021280!expectedFailures	"Does crash VM with Cog"	^Smalltalk isRunningCogit		ifTrue:[#(testAddNumbers testDNU testAnswer42)]		ifFalse:[#()]! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43' prior: 34021519!testAddNumbers 	"self debug: #testAddNumbers"	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	"md: I had to comment out the error... did strange things"	self class addSelector: #add:with: withMethod: ObjectsAsMethodsExample new.	self assert: (self add: 3 with: 4) = 7.	"self assert: (self perform: #add:with: withArguments: #(3 4)) = 7. "	self class basicRemoveSelector: #add:with:.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43' prior: 34022046!testAnswer42 	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: ObjectsAsMethodsExample new.	self assert: self answer42 = 42.	self class basicRemoveSelector: #answer42.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43' prior: 34022400!testDNU 	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: AbstractObjectsAsMethod new.	self should: [self answer42] raise: MessageNotUnderstood.	self class basicRemoveSelector: #answer42.! !!LocaleTest methodsFor: 'testing' stamp: 'ar 7/21/2010 20:14' prior: 57142235!testIsFontAvailable	"self debug: #testIsFontAvailable"	Preferences restoreFontsAfter:[		(Locale isoLanguage: 'ja') languageEnvironment removeFonts.		self assert: (Locale isoLanguage: 'en') languageEnvironment isFontAvailable.		"Next test should fail after installing Japanese font"		self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable not.		(Locale isoLanguage: 'ja') languageEnvironment installFont.		self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable.	].! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ar 7/22/2010 19:44'!testUIManagerNoAcceptInitially	"Ensure that UIManager does not invoke the accept: action initially."	| accepted window |	accepted := false.	window := UIManager default edit: Text new label: 'Test' accept: [:val| accepted := true].	window delete.	self deny: accepted.! !!StandardSystemFontsTest methodsFor: 'testing' stamp: 'ar 7/21/2010 20:14' prior: 59167794!testRestoreDefaultFonts	Preferences restoreFontsAfter: [		Preferences restoreDefaultFonts.		self assert: #standardDefaultTextFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardListFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardFlapFont familyName: 'Accushi' pointSize: 12.		self assert: #standardEToysFont familyName: 'BitstreamVeraSans' pointSize: 9.		self assert: #standardMenuFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #windowTitleFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardBalloonHelpFont familyName: 'Accujen' pointSize: 9.		self assert: #standardCodeFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardButtonFont familyName: 'BitstreamVeraSansMono' pointSize: 9]! !StandardSystemFontsTest removeSelector: #saveStandardSystemFontsDuring:!DecompilerTests removeSelector: #expectedFailures!"Tests"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 7/22/2010 14:27' prior: 34024621!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	"By default, don't style in UIManager edit: requests"	window model		shouldStyle: false;		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!Debugger commentStamp: '<historical>' prior: 59270384!I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !!ChangesOrganizer commentStamp: 'cbr 7/27/2010 19:17' prior: 59239452!I manage ChangeSets in the system. See the protocols on my class side.For an example of what I can do, select the following line in a Workspace and print it.ChangesOrganizer allChangeSetNames!!ChangeList methodsFor: 'menu actions' stamp: 'eem 7/22/2010 13:40' prior: 34058687!selectUnchangedDefinitions	"Selects all recognizable definitions for which there is already a definition in the current image, whose source is exactly the same."	| change class tokens |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put: false.		(change type = #method		 and: [(class := change methodClass) notNil		 and: [class includesSelector: change methodSelector]]) ifTrue:			[listSelections				at: i				put: change string withBlanksCondensed					= (class sourceCodeAt: change methodSelector) asString withBlanksCondensed].		(change type == #classComment		and: [(class := change commentClass) notNil]) ifTrue:			[listSelections at: i put: change string = class comment asString].		change type == #doIt ifTrue:			[tokens := Scanner new scanTokens: change string.			 ((tokens select:				[:substr| #(subclass: variableSubclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3			 and: [(class := Smalltalk at: tokens third ifAbsent: []) notNil			 and: [class isBehavior]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class definition withBlanksCondensed].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #instanceVariableNames:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) notNil			 and: [class isBehavior]]]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class class definition withBlanksCondensed].			(tokens size = 3			 and: [tokens second == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class includesSelector: tokens third) not]]]]) ifTrue:				[listSelections at: i put: true].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class class includesSelector: tokens fourth) not]]]]]) ifTrue:				[listSelections at: i put: true]]]].	self changed: #allSelections! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:36' prior: 34046085!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self package			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 self selectedClass					ifNil: [self selectedSystemCategoryName							ifNil: [s nextPutAll: pkg]							ifNotNil: [:cat| s nextPutAll: cat]]					ifNotNil:						[:class|						 s nextPutAll: pkg; space; print: class.						 self metaClassIndicated ifTrue:							[s nextPutAll: ' class']]].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:31'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'restoreToPackage:')			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 s nextPutAll: pkg.				(getarg value: 'className:')					ifNil: [(getarg value: 'category:') ifNotNil:							[:categoryName| s nextPut: $-; nextPutAll: categoryName]]					ifNotNil:						[:className|						s space; nextPutAll: className.						(getarg value: 'meta:') ifTrue:							[s nextPutAll: ' class'].						  self isHierarchy ifTrue:							[s space; nextPutAll: ' Hierarchy'].						(getarg value: 'selector:')							ifNil: [(getarg value: 'protocol:') ifNotNil:									[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]							ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:23'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'className:')			ifNil: [(getarg value: 'restoreToCategory:')					ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]					ifNotNil: [:categoryName| s nextPutAll: categoryName]]			ifNotNil:				[:className|				s nextPutAll: className.				(getarg value: 'meta:') ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy'].				(getarg value: 'selector:')					ifNil: [(getarg value: 'protocol:') ifNotNil:							[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]					ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nice 8/19/2010 14:08' prior: 54384128!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	| tokens |	contents := aString.	classList := #().  classListIndex := 0.	selectorIndex := 0.	tokens := contents asString findTokens: ' .'.	selectorList := Cursor wait showWhile: [		tokens size = 1 			ifTrue: [(Symbol selectorsContaining: contents asString) asArray				sort: [:x :y | x asLowercase <= y asLowercase]]			ifFalse: [self quickList]].	"find selectors from a single example of data"	self changed: #messageList.	self changed: #classList.	^ true! !!CodeHolder methodsFor: 'misc' stamp: 'topa 7/14/2010 16:35'!informPossiblyCorruptSource	| sourcesName |	sourcesName := FileDirectory localNameFor: SmalltalkImage current sourcesName.	self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.(Occasionally, the source code for a method may legitimatelystart with a non-alphabetic character -- for example, Behaviormethod #formalHeaderPartsFor:.  In such rare cases, you canhappily disregard this warning.)'! !!CodeHolder methodsFor: 'message list' stamp: 'topa 7/14/2010 16:47' prior: 50670096!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	(class isNil or: [selector isNil]) ifTrue: [^'missing'].	sourceString := class ultimateSourceCodeAt: selector ifAbsent: [^'error'].	self validateMessageSource: sourceString forSelector: selector inClass: class.	(#(#prettyPrint #prettyDiffs) 		includes: contentsSymbol) 			ifTrue: 				[sourceString := class prettyPrinterClass 							format: sourceString							in: class							notifying: nil].	self showingAnyKindOfDiffs 		ifTrue: [sourceString := self diffFromPriorSourceFor: sourceString].	^sourceString! !!CodeHolder methodsFor: 'message list' stamp: 'topa 7/14/2010 16:46'!validateMessageSource: sourceString forSelector: aSelector inClass: theClass	"Check whether there is evidence that method source is invalid"	(theClass parserClass new parseSelector: sourceString asString) = aSelector		ifFalse: [self informPossiblyCorruptSource].! !!Debugger class methodsFor: 'private' stamp: 'eem 7/26/2010 18:01'!ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess	| sema |	errorWasInUIProcess ifTrue:		[^self].	self interruptUIProcessIfBlockedOnErrorInBackgroundProcess ifFalse:		[^self].	"Only interrupt the UI if it is unresponsive (and so is doing something that needs	 interrupting).  Test using addDeferredUIMessage: to see if it is running UI activities."	sema := Semaphore new.	Project current addDeferredUIMessage: [sema signal].	(sema waitTimeoutMSecs: 100) ifTrue:		[[Project current interruptName: 'Interrupt from Background Error'] fork]	"| s |	s := Semaphore new.	[self assert: 0 > 1000. s signal] fork.	s wait"! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:52'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess	<preference: 'Interrupt UI process on background error'		category: 'debug'		description: 'When enabled, the debugger will interrupt the UI process if an error occurs in a background process and the UI process is blocked.'		type: #Boolean>	^InterruptUIProcessIfBlockedOnErrorInBackgroundProcess ifNil: [false]! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:53'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess: aBoolean	InterruptUIProcessIfBlockedOnErrorInBackgroundProcess := aBoolean! !!Debugger class methodsFor: 'opening' stamp: 'eem 7/26/2010 15:51' prior: 19607647!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller errorWasInUIProcess block |	Smalltalk isMorphic		ifTrue: [errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: process]		ifFalse: [controller := ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController]].	block := [ 		[	| debugger |			debugger := self new process: process controller: controller context: context.			Smalltalk isMorphic				ifTrue: ["schedule debugger in deferred UI message to address redraw						problems after opening a debugger e.g. from the testrunner."					"WorldState addDeferredUIMessage: ["bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]]				ifFalse: ["deferred UI message would require special controller in MVC"					bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]].			debugger errorWasInUIProcess: errorWasInUIProcess.			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].			Smalltalk isMorphic				ifFalse: [ScheduledControllers searchForActiveController "needed since openNoTerminate (see debugger #open...) does not set up activeControllerProcess if activeProcess (this fork) is not the current activeControllerProcess (see #scheduled:from:)"].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	self ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess.	Project current addDeferredUIMessage: block.	process suspend! !!Debugger methodsFor: 'accessing' stamp: 'abc 2/12/2010 15:02' prior: 53617029!debuggerMap	^self selectedContext debuggerMap! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 8/11/2010 13:27' prior: 34044380!selectWindowsMenu	| menu currentItem |	menu := MenuMorph new defaultTarget: self.	models withIndexDo:		[:model :index| | modelLabel |		modelLabel := index = currentModelIndex							ifTrue: [model multiWindowName]							ifFalse: [model multiWindowNameForState: (modelStates at: index) first].		models size > 1 ifTrue:			[modelLabel := index printString, '. ', modelLabel].		menu			add: (index = currentModelIndex					ifTrue: [Text string: modelLabel attribute: TextEmphasis bold]					ifFalse:						[((modelStates at: index) last anySatisfy: [:editState| editState notNil])							ifTrue: [Text string: modelLabel attribute: TextColor red]							ifFalse: [modelLabel]])			target: self			selector: #selectWindowIndex:			argument: index.		index = currentModelIndex ifTrue:			[currentItem := menu lastItem]].	menu		addLine;		add: 'new window' target: self selector: #addNewWindow;		add: 'copy this window' target: self selector: #copyWindow;		add: 'remove this window' target: self selector: #removeCurrentWindow.	models size <= 1 ifTrue:		[menu lastItem isEnabled: false].	menu selectItem: currentItem event: nil.	^menu! !CodeHolder removeSelector: #validateMessageSource:forSelector:!"Tools"!!XMLElement methodsFor: 'testing' stamp: 'ar 8/10/2010 13:19' prior: 54448258!isEmpty	"Answer true if the receiver is empty"	^self elementsAndContents isEmpty! !!XMLElement methodsFor: 'printing' stamp: 'ar 8/10/2010 13:21' prior: 54448700!printXMLOn: writer	"Print the receiver in XML form"	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self elementsAndContentsDo: [:content | content printXMLOn: writer].			writer endTag: self name]! !!XMLParserTest methodsFor: 'tests' stamp: 'ar 8/10/2010 13:25'!testPrintElements	| node |	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo/>'.	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123"/>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo>Hello World</foo>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123">Hello World</foo>'.! !"XML-Parser"!!HelpBrowser methodsFor: 'stepping' stamp: 'tbn 8/19/2010 09:47'!step	 "Do nothing when the window dispatches stepping back to the model"! !"HelpSystem-Core"!----SNAPSHOT----{19 August 2010 . 7:11:15 pm} Squeak4.2-10160-alpha.image priorSource: 326363!----STARTUP----{19 August 2010 . 7:36:35 pm} as /Users/casey/Desktop/Squeak4.2-10160-alpha/Squeak4.2-10160-alpha.image!----SNAPSHOT----{19 August 2010 . 7:37:29 pm} Squeak4.2-10382-alpha.image priorSource: 763601!----QUIT/NOSAVE----{19 August 2010 . 7:37:44 pm} Squeak4.2-10382-alpha.image priorSource: 763819!