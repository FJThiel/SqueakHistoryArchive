'From Squeak4.1 of 17 April 2010 [latest update: #9957] on 17 April 2010 at 5:22:05 pm'!----STARTUP----{17 April 2010 . 5:21:54 pm} as C:\Squeak\4.0\4.1-final\Squeak4.1.image!Smalltalk appendChangesTo: 'SqueakV41.sources'.!----QUIT----{17 April 2010 . 5:22:11 pm} Squeak4.1.image priorSource: 89!----STARTUP----{24 May 2010 . 8:07:26 pm} as C:\Squeak\4.2\Squeak4.1.image!----SNAPSHOT----{24 May 2010 . 8:08:14 pm} Squeak4.2.image priorSource: 229!!HashedCollection commentStamp: 'ul 4/12/2010 22:37' prior: 0!I am an abstract collection of objects that implement hash and equality in a consitent way. This means that whenever two objects are equal, their hashes have to be equal too. If two objects are equal then I can only store one of them. Hashes are expected to be integers (preferably SmallIntegers). I also expect that the objects contained by me do not change their hashes. If that happens, hash invariants have to be re-established, which can be done by #rehash.Since I'm abstract, no instances of me should exist. My subclasses should implement #scanFor:, #fixCollisionsFrom: and #noCheckNoGrowFillFrom:.Instance Variables	array:		<ArrayedCollection> (typically Array or WeakArray)	tally:		<Integer> (non-negative)array	- An array whose size is a prime number, it's non-nil elements are the elements of the collection, and whose nil elements are empty slots. There is always at least one nil. In fact I try to keep my "load" at 75% or less so that hashing will work well.tally	- The number of elements in the collection. The array size is always greater than this.Implementation details:I implement a hash table which uses open addressing with linear probing as the method of collision resolution. Searching for an element or a free slot for an element is done by #scanFor: which should return the index of the slot in array corresponding to it's argument. When an element is removed #fixCollisionsFrom: should rehash all elements in array between the original index of the removed element, wrapping around after the last slot until reaching an empty slot. My maximum load factor (75%) is hardcoded in #atNewIndex:put:, so it can only be changed by overriding that method. When my load factor reaches this limit I replace my array with a larger one (see #grow) ensuring that my load factor will be less than or equal to 50%. The new array is filled by #noCheckNoGrowFillFrom: which should use #scanForEmptySlotFor: instead of #scanFor: for better performance. I do not shrink.!!WeakKeyDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!Collection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:33' prior: 18816249!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."	anInteger timesRepeat: [self add: newObject].	^ newObject! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAll	"HashedCollection compactAll"				self allSubclassesDo: #compactAllInstances! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 4/12/2010 23:49'!compactAllInstances	"Do not use #allInstancesDo: because compact may create new instances."	self allInstances do: #compact! !!HashedCollection class methodsFor: 'sizing' stamp: 'ul 4/7/2010 00:17' prior: 55063414!goodPrimes	"Answer a sorted array of prime numbers less than one billion that make good	hash table sizes. Should be expanded as needed.  See comments below code"		^#(		5 11 17 23 31 43 59 79 107 149 199 269 359 479 641 857 1151 1549 2069		2237 2423 2617 2797 2999 3167 3359 3539 3727 3911		4441 4787 5119 5471 5801 6143 6521 6827 7177 7517 7853		8783 9601 10243 10867 11549 12239 12919 13679 14293 15013 15731		17569 19051 20443 21767 23159 24611 25847 27397 28571 30047 31397		35771 38201 40841 43973 46633 48989 51631 54371 57349 60139 62969		70589 76091 80347 85843 90697 95791 101051 106261 111143 115777 120691 126311		140863 150523 160969 170557 181243 190717 201653 211891 221251 232591 242873 251443		282089 300869 321949 341227 362353 383681 401411 422927 443231 464951 482033 504011		562621 605779 647659 681607 723623 763307 808261 844709 886163 926623 967229 1014617		1121987 1201469 1268789 1345651 1429531 1492177 1577839 1651547 1722601 1800377 1878623 1942141 2028401		2242727 2399581 2559173 2686813 2836357 3005579 3144971 3283993 3460133 3582923 3757093 3903769 4061261		4455361 4783837 5068529 5418079 5680243 6000023 6292981 6611497 6884641 7211599 7514189 7798313 8077189		9031853 9612721 10226107 10745291 11338417 11939203 12567671 13212697 13816333 14337529 14938571 15595673 16147291		17851577 18993941 20180239 21228533 22375079 23450491 24635579 25683871 26850101 27921689 29090911 30153841 31292507 32467307		35817611 37983761 40234253 42457253 44750177 46957969 49175831 51442639 53726417 55954637 58126987 60365939 62666977 64826669		71582779 76039231 80534381 84995153 89500331 93956777 98470819 102879613 107400389 111856841 116365721 120819287 125246581 129732203		143163379 152076289 161031319 169981667 179000669 187913573 196826447 205826729 214748357 223713691 232679021 241591901 250504801 259470131		285162679 301939921 318717121 335494331 352271573 369148753 385926017 402603193 419480419 436157621 453034849 469712051 486589307 503366497 520043707 		570475349 603929813 637584271 671138659 704693081 738247541 771801929 805356457 838910803 872365267 905919671 939574117 973128521 1006682977 1040137411 		1073741833)"The above primes past 2069 were chosen carefully so that they do not interact badly with 1664525 (used by hashMultiply), and so that gcd(p, (256^k) +/- a) = 1, for 0<a<=32 and 0<k<=8.  See Knuth's TAOCP for details.""The above primes also try to map the values of ((0 to: 4095) collect: [ :each | each << 18 \\ prime ]) sort to an equidistant sequence of numbers. This helps to avoid the collision of chains in identity-based hashed collections. To do that  they were chosen to return a low value when the following block is evaluated with them as argument: [ :prime |	| slots cost optimalDistance previous |	slots := Array new: 4097.	0 to: 4095 do: [ :ea | slots at: ea + 1 put: ea *  262144 \\ prime ].	slots at: 4097 put: prime.	slots sort.	cost := 0.	optimalDistance := prime // 4096.	2 to: 4097 do: [ :index |		| newCost |		newCost := optimalDistance - ((slots at: index) - (slots at: index - 1)).		newCost > cost ifTrue: [ cost := newCost ] ].	cost ]."! !!HashedCollection methodsFor: 'adding' stamp: 'ul 4/12/2010 22:38' prior: 53647096!add: newObject withOccurrences: anInteger	"Add newObject anInteger times to the receiver. Do nothing if anInteger is less than one. Answer newObject."		anInteger < 1 ifTrue: [ ^newObject ].	^self add: newObject "I can only store an object once."	! !!HashedCollection methodsFor: 'private' stamp: 'ul 4/12/2010 22:53'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: tally * 4 // 3.	self growTo: newCapacity! !!WeakSet methodsFor: 'private' stamp: 'ul 4/12/2010 22:59'!compact	"Reduce the size of array so that the load factor will be ~75%."		| newCapacity |	newCapacity := self class goodPrimeAtLeast: self slowSize * 4 // 3.	self growTo: newCapacity! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 4/13/2010 00:00' prior: 30357901!compactSymbolTable	"Reduce the size of the symbol table so that it holds all existing symbols with 25% free space."	| oldSize |	Smalltalk garbageCollect.	oldSize := SymbolTable capacity.	SymbolTable compact.	^(oldSize - SymbolTable capacity) printString, ' slot(s) reclaimed'! !KeyedIdentitySet class removeSelector: #goodPrimes!WeakIdentityKeyDictionary class removeSelector: #goodPrimes!IdentitySet class removeSelector: #goodPrimes!IdentityDictionary class removeSelector: #goodPrimes!"Collections"!!HashedCollectionTest methodsFor: 'test - class - sizing' stamp: 'ul 4/7/2010 00:18' prior: 58761579!testPrimes: primes	| badPrimes |	badPrimes := #(3 5 71 139 479 5861 277421). "These primes are less than the hashMultiply constant (1664525) and 1664525 \\ prime is close to 0 (mod prime). The following snippet reproduces these numbers: 	| hashMultiplyConstant |	hashMultiplyConstant := 1 hashMultiply.	(Integer primesUpTo: hashMultiplyConstant) select: [ :each |		| remainder |		remainder := hashMultiplyConstant \\ each.		remainder <= 1 or: [ remainder + 1 = each ] ]."	self assert: primes isSorted.	primes do: [ :each |		self assert: each isPrime.		self deny: (each > 2069 and: [ badPrimes includes: each ]) ].	self assert: (		primes select: [ :p |			| result |			result := false.			p > 2069 ifTrue: [			1 to: 8 do: [ :k |				1 to: 32 do: [ :a |					(p gcd: (256 raisedTo: k) + a) = 1 ifFalse: [						result := true ].					(p gcd: (256 raisedTo: k) - a) = 1 ifFalse: [						result := true ] ] ] ].			result ]) isEmpty.! !HashedCollectionTest removeSelector: #testGoodPrimesForIdentityBasedHashedCollections!"CollectionsTests"!!MCMczReader methodsFor: 'as yet unclassified' stamp: 'bf 4/18/2010 18:38' prior: 22938947!extractInfoFrom: dict	^MCWorkingCopy infoFromDictionary: dict cache: self infoCache! !!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'bf 4/19/2010 00:39' prior: 23215403!infoFromDictionary: aDictionary cache: cache	| id |	id := (aDictionary at: #id) asString.	^ cache at: id ifAbsentPut:		[MCVersionInfo			name: (aDictionary at: #name ifAbsent: [''])			id: (UUID fromString: id)			message: (aDictionary at: #message ifAbsent: [''])			date: ([Date fromString: (aDictionary at: #date)] ifError: [nil])			time: ([Time fromString: (aDictionary at: #time)] ifError: [nil])			author: (aDictionary at: #author ifAbsent: [''])			ancestors: (self ancestorsFromArray: (aDictionary at: #ancestors ifAbsent: []) cache: cache)			stepChildren: (self ancestorsFromArray: (aDictionary at: #stepChildren ifAbsent: []) cache: cache)]! !!MCVersionInfo methodsFor: 'converting' stamp: 'bf 4/18/2010 23:25' prior: 23175569!asDictionary	^ Dictionary new		at: #name put: name;		at: #id put: id asString;		at: #message put: message;		at: #date put: date;		at: #time put: time;		at: #author put: author;		at: #ancestors put: (self ancestors collect: [:a | a asDictionary]);		yourself! !"Monticello"!!BlockContextTest methodsFor: 'running' stamp: 'md 9/6/2005 19:56' prior: 50431957!setUp	super setUp.	aBlockContext := [100@100 corner: 200@200].	contextOfaBlockContext := thisContext.! !!BehaviorTest methodsFor: 'tests' stamp: 'md 2/18/2006 16:42' prior: 17365994!testBinding	self assert: Object binding value = Object.	self assert: Object binding key = #Object.		self assert: Object class binding value = Object class.		"returns nil for Metaclasses... like Encoder>>#associationFor:"		self assert: Object class binding key = nil.! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13' prior: 53956757!testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #EmbeddedSourceQCompress ).	self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).	code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer sourceCode: code.	self assert: (trailer kind == #EmbeddedSourceZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:13' prior: 53957691!testEmbeddingTempNames	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		code := 'foo'.	trailer tempNames: code.	newTrailer := trailer testEncoding.		self assert: (trailer kind == #TempsNamesQCompress ).	self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).		code := 'testEmbeddingSourceCode	| trailer newTrailer code |		trailer := CompiledMethodTrailer new.		trailer sourceCode: code.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourceCode = code).'.	trailer tempNames: code.	self assert: (trailer kind == #TempsNamesZip ).	newTrailer := trailer testEncoding.		self assert: (newTrailer tempNames = code).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:17' prior: 53958613!testEncodingNoTrailer	| trailer |		trailer := CompiledMethodTrailer new.		"by default it should be a no-trailer"		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #NoTrailer ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:14' prior: 53959109!testEncodingSourcePointer	| trailer |		trailer := CompiledMethodTrailer new.		CompiledMethod allInstancesDo: [:method | | ptr |		trailer method: method.		self assert: ( (ptr := method sourcePointer) == trailer sourcePointer).		"the last bytecode index must be at 0"		ptr ~= 0 ifTrue: [			self assert: (method endPC = trailer endPC) ].	 ].! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15' prior: 53959564!testEncodingVarLengthSourcePointer	| trailer newTrailer |		trailer := CompiledMethodTrailer new.		trailer sourcePointer: 1.	newTrailer := trailer testEncoding.		self assert: (newTrailer sourcePointer = 1).		trailer sourcePointer: 16r100000000000000.	newTrailer := trailer testEncoding.	self assert: (newTrailer sourcePointer = 16r100000000000000).	"the last bytecode index must be at 0"	self assert: (newTrailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:15' prior: 53960108!testSourceByIdentifierEncoding	| trailer id |		trailer := CompiledMethodTrailer new.		id := UUID new asString.	trailer sourceIdentifier: id.		self assert: (trailer kind == #SourceByStringIdentifier ).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceByStringIdentifier ).	self assert: (trailer sourceIdentifier = id).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CompledMethodTrailerTest methodsFor: 'testing' stamp: 'Igor.Stasenko 12/13/2009 21:49' prior: 53960643!testSourceBySelectorEncoding	| trailer |		trailer := CompiledMethodTrailer new.		trailer setSourceBySelector.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).		trailer := trailer testEncoding.		self assert: (trailer kind == #SourceBySelector ).	self assert: (trailer size = 1).	"the last bytecode index must be at 0"	self assert: (trailer endPC = 0).! !!CategorizerTest methodsFor: 'running' stamp: 'mtf 9/10/2007 10:10' prior: 18074036!setUp	categorizer := Categorizer defaultList: #(a b c d e).	categorizer classifyAll: #(a b c) under: 'abc'.	categorizer addCategory: 'unreal'.! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17' prior: 18074267!testClassifyNewElementNewCategory	categorizer classify: #f under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')(''nice'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:18' prior: 18074541!testClassifyNewElementOldCategory	categorizer classify: #f under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'' f)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:17' prior: 18074806!testClassifyOldElementNewCategory	categorizer classify: #e under: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'')(''nice'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:54' prior: 18075078!testClassifyOldElementOldCategory	categorizer classify: #e under: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d)(''abc'' a b c)(''unreal'' e)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:22' prior: 18075341!testDefaultCategoryIsTransient	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	categorizer classifyAll: #(d e) under: #abc.	self assert: categorizer printString ='(''abc'' a b c d e)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 15:15' prior: 18075669!testNullCategory	"Test that category 'as yet unclassified' disapears when all it's elements are removed'"	| aCategorizer |	aCategorizer := Categorizer defaultList: #().	self assert: aCategorizer printString ='(''as yet unclassified'')'.	self assert: aCategorizer categories = #('no messages').	aCategorizer classify: #a under: #b.	self assert: aCategorizer printString ='(''b'' a)'.	self assert: aCategorizer categories = #(b).! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57' prior: 18076194!testRemoveEmptyCategory	categorizer removeCategory: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:55' prior: 18076430!testRemoveExistingElement	categorizer removeElement: #a.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59' prior: 18076673!testRemoveNonEmptyCategory	self should: [categorizer removeCategory: #abc] raise: Error.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:59' prior: 18076950!testRemoveNonExistingCategory	categorizer removeCategory: #nice.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 12:57' prior: 18077203!testRemoveNonExistingElement	categorizer removeElement: #f.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/11/2007 14:49' prior: 18077451!testRemoveThenRename	categorizer removeCategory: #unreal.	categorizer renameCategory: #abc toBe: #unreal.	self assert: categorizer printString ='(''as yet unclassified'' d e)(''unreal'' a b c)'! !!CategorizerTest methodsFor: 'testing' stamp: 'mtf 9/10/2007 10:14' prior: 18077736!testUnchanged	self assert: categorizer printString ='(''as yet unclassified'' d e)(''abc'' a b c)(''unreal'')'! !"KernelTests"!!SmalltalkImage methodsFor: 'accessing' stamp: 'ul 4/18/2010 22:22'!at: key ifPresentAndInMemory: aBlock	"Lookup the given key in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	^globals at: key ifPresentAndInMemory: aBlock! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:45'!image	"Answer the object to query about the current object memory and execution environment."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 4/11/2010 11:47'!imageFormatVersion	"Answer an integer identifying the type of image. The image version number may	identify the format of the image (e.g. 32 or 64-bit word size) or specific requirements	of the image (e.g. block closure support required). This invokes an optional primitive	that may not be available on all virtual machines."	"Smalltalk image imageFormatVersion"	<primitive: 'primitiveImageFormatVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveImageFormatVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:38'!interpreterSourceVersion	"Answer a string corresponding to the version of the interpreter source.	This represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator, as distinct	from the external platform source code, typically written in C and managed	separately for each platform. An optional primitive is invoked that may not	be available on all virtual machines."	"Smalltalk vm interpreterSourceVersion"	<primitive: 'primitiveInterpreterSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveInterpreterSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!platformSourceVersion	"Answer a string corresponding to the version of the external platform source	code, typically written in C and managed separately for each platform. This	invokes an optional primitive that may not be available on all virtual machines."	"Smalltalk vm platformSourceVersion"	<primitive: 'primitivePlatformSourceVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitivePlatformSourceVersion' translated.	^''! !!SmalltalkImage methodsFor: 'image' stamp: 'md 5/16/2006 12:34' prior: 58536670!version	"Answer the version of this release."	^SystemVersion current version! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:39'!versionLabel	"Answer a string corresponding to the version of virtual machine. This	represents the version level of the Smalltalk source code (interpreter	and various plugins) that is translated to C by a CCodeGenerator,  in	addition to the external platform source code, typically written in C and	managed separately for each platform.		This invokes an optional primitive that may not be available on all virtual	machines. See also vmVersion, which answers a string identifying the image	from which virtual machine sources were generated."	"Smalltalk vm versionLabel"	<primitive: 'primitiveVMVersion'>	self notify: 'This virtual machine does not support the optional primitive #primitiveVMVersion' translated.	^''! !!SmalltalkImage methodsFor: 'vm' stamp: 'dtl 4/11/2010 11:15'!vm	"Answer the object to query about virtual machine."		^self! !!SmalltalkImage methodsFor: 'image' stamp: 'dtl 1/4/2010 21:40' prior: 58537225!wordSize	"Answer the size in bytes of an object pointer or word in the object memory.	The value does not change for a given image, but may be modified by a SystemTracer	when converting the image to another format. The value is cached in WordSize to	avoid the performance overhead of repeatedly consulting the VM."	"Smalltalk wordSize"	^ WordSize ifNil: [WordSize := [SmalltalkImage current vmParameterAt: 40] on: Error do: [4]]! !"System"!!SMLoaderPlus commentStamp: 'btr 12/1/2006 15:16' prior: 0!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance). It uses ToolBuilder to construct its window. You can open one with:	SMLoaderPlus openInstance Variables	categoriesToFilterIds:		<OrderedCollection> The set of categories to filter the packages list.	filters:				<OrderedCollection> The set of filters to apply to the packages list.	map:				<SMSqueakMap> The model SqueakMap.	packagesList:		<OrderedCollection> The list of packages from the map.	selectedCategory:	<SMCategory> The current category.	selectedItem:			<SMPackage> The selected package or release.	window:			<PluggableSystemWindow> The window, held only so we can reOpen.!!SMLoaderCategoricalPlus commentStamp: 'btr 12/4/2006 15:47' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategoricalPlus open!!SMLoader commentStamp: 'btr 11/30/2006 18:00' prior: 27913009!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance).You can open one with:	SMLoader open!!SMLoaderCategorical commentStamp: 'btr 12/1/2006 15:16' prior: 0!A variant package loader that uses a more-or-less standard Smalltalk-80 browser perspective of selecting categories in one pane and then selecting items within in the next pane.You can open one with:	SMLoaderCategorical open!!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifPresent: [:tb |		(TheWorldMenu respondsTo: #registerOpenCommand:)			ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategoricalPlus class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 17:34'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:50'!buildFancyWith: aBuilder	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)); yourself);				add: ((self buildNotInstalledPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ (horizDivide / 2)); yourself);				add: ((self buildInstalledPackagesListWith: builder)					frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide); yourself);				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1); yourself); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	self setUpdatablePanesFrom: #(#installedPackageList #notInstalledPackageList ).	currentPackageList := #notInstalled.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:56'!buildInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #installedPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 17:52'!buildNotInstalledPackagesListWith: aBuilder	^ aBuilder pluggableTreeSpec new model: self;		 roots: #notInstalledPackageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 yourself! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:55'!buildWith: aBuilder	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;				label: #label;				children: (OrderedCollection new add:				((self buildButtonBarWith: builder)					frame: (0 @ 0 corner: 1 @ buttonBarHeight); yourself);				add: ((self buildCategoriesListWith: builder)					frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide); yourself);				add: ((self buildSearchPaneWith: builder)					frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)));				add: ((self buildPackagesListWith: builder)					frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide));				add: ((self buildPackagePaneWith: builder)					frame: (0 @ horizDivide corner: 1 @ 1)); yourself)).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList	^currentPackageList! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:55'!defaultLabel	^ 'Categorical ' , super defaultLabel! !!SMLoaderCategoricalPlus methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:52'!installedPackageList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!installedPackagesListIndex	^ self currentPackageList = #installed		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 17:34'!isOn	^false! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:53'!notInstalledPackageList	^self packageList reject: [:e | e isInstalled]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:02'!notInstalledPackagesListIndex	^ self currentPackageList = #notInstalled		ifTrue: [self packagesListIndex]		ifFalse: [0]! !!SMLoaderCategoricalPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 18:03'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategoricalPlus methodsFor: 'private' stamp: 'btr 12/1/2006 17:53'!noteChanged	self changed: #installedPackageList.	self changed: #notInstalledPackageList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategoricalPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 17:34'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !!SMLoaderPlus class methodsFor: 'parts bin' stamp: 'btr 11/22/2006 15:02'!descriptionForPartsBin	^self partName: 'Package Loader'		categories: #(Tools)		documentation: 'SqueakMap UI'! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47'!initialize	"Hook us up in the world menu."		"self initialize"	Smalltalk at: #ToolBuilder ifPresent: [:tb |		self registerInFlapsRegistry.		(Preferences windowColorFor: #SMLoader) = Color white "not set"			ifTrue: [ Preferences setWindowColorFor: #SMLoader to: (Color colorFrom: self windowColorSpecification brightColor) ].		 (TheWorldMenu respondsTo: #registerOpenCommand:)	         ifTrue: [| oldCmds |				oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].				oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].			TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!initializedInstance	^ (ToolBuilder open: self new) extent: 400@400! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!new	"Create a SqueakMap loader on the default map."	^self newOn: SMSqueakMap default! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/22/2006 15:02'!newOn: aMap	"Create a SqueakMap loader on given map."	^super new on: aMap; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:16'!newStandAlone	^ ToolBuilder open: self new! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:13'!open	"Create and open a SqueakMap Loader."		"SMLoaderPlus open"	^ (Smalltalk at: #ToolBuilder) open: self new! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoaderPlus class methodsFor: 'instance creation' stamp: 'btr 11/23/2006 11:21'!openOn: aSqueakMap	"Create and open a SqueakMap Loader on a given map."	"self openOn: SqueakMap default"	^ (Smalltalk at: #ToolBuilder) open: (self newOn: aSqueakMap)! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:18'!prototypicalToolWindow	^ ToolBuilder open: self new; applyModelExtent; yourself! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'btr 11/22/2006 15:02'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry."	self environment		at: #Flaps		ifPresent: [:cl | (cl respondsTo: #registerQuad:forFlapNamed:)				ifTrue: [cl registerQuad: #(#SMLoader #prototypicalToolWindow 'Package Loader' 'The SqueakMap Package Loader' ) forFlapNamed: 'Tools']]! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:50'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoaderPlus class methodsFor: 'window color' stamp: 'btr 11/22/2006 15:02'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference."	^WindowColorSpec		classSymbol: self name		wording: 'Package Loader'		brightColor: Color yellow muchLighter duller		pastelColor: Color yellow veryMuchLighter duller		helpMessage: 'The SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!addSelectedCategoryAsFilter	"Add a new filter that filters on the currently selected category.	Make it enabled as default."	categoriesToFilterIds add: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 16:11'!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := map isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(map directory directoryEntryFor: map lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:43'!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease				ifNil: [^ nil].	dir := item isPackage				ifTrue: [map cache directoryForPackage: item]				ifFalse: [map cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir.	"withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildButtonBarWith: aBuilder	^ aBuilder pluggablePanelSpec new		model: self;		layout: #horizontal;		children: (self commandSpecs select: [ :spec | spec fourth includes: #all]				thenCollect: [ :spec |					aBuilder pluggableActionButtonSpec new						model: self;						label: spec first;						action: spec second;						help: spec third;						enabled: ((spec fourth includes: #item) ifTrue: [#hasSelectedItem]);						yourself]);		name: #buttonBar;		yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:56'!buildCategoriesListWith: aBuilder 	"Create the hierarchical list holding the category tree."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #categoryList;		 getSelectedPath: #selectedCategoryPath;		 getChildren: #categoryChildren:;		 hasChildren: #categoryHasChildren:;		 setSelected: #selectedCategory:;		 menu: #categoriesMenu:;		 label: #categoryLabel:;		 autoDeselect: true;		 wantsDrop: true;		 name: #categoriesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagePaneWith: aBuilder	"Create the text area to the right in the loader."	^ aBuilder pluggableTextSpec new model: self; getText: #itemDescription; name: #packagePane; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildPackagesListWith: aBuilder 	"Create the hierarchical list holding the packages and releases."	^ aBuilder pluggableTreeSpec new model: self;		 roots: #packageList;		 getSelectedPath: #selectedItemPath;		 setSelected: #selectedItem:;		 menu: #packagesMenu:;		 label: #itemLabel:;		 getChildren: #itemChildren:;		 hasChildren: #itemHasChildren:;		 autoDeselect: true;		 wantsDrop: true;		 name: #packagesList;		 yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:57'!buildSearchPaneWith: aBuilder	^ aBuilder pluggableInputFieldSpec new model: self;		selection: #searchSelection;		getText: #searchText; setText: #findPackage:notifying:; name: #search; yourself! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 06:54'!buildWith: aBuilder 	"Create the package loader window."	| buttonBarHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	vertDivide := 0.6.	horizDivide := 0.3.	builder := aBuilder.	window := builder build: (builder pluggableWindowSpec new model: self;					 label: #label;					 children: (OrderedCollection new						add: ((self buildButtonBarWith: builder)							frame: (0 @ 0 corner: 1 @ buttonBarHeight));						add: ((self buildSearchPaneWith: builder)							frame: (0 @ buttonBarHeight corner: horizDivide @ (buttonBarHeight * 2)));						add: ((self buildPackagesListWith: builder)							frame: (0 @ (buttonBarHeight * 2) corner: horizDivide @ vertDivide));						add: ((self buildCategoriesListWith: builder)							frame: (0 @ vertDivide corner: horizDivide @ 1));						add: ((self buildPackagePaneWith: builder)								frame: (horizDivide @ buttonBarHeight corner: 1 @ 1));						 yourself);					 yourself).	window on: #mouseEnter send: #paneTransition: to: window.	window on: #mouseLeave send: #paneTransition: to: window.	window extent: self initialExtent.	^ window! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!cachePackageReleaseAndOfferToCopy	"Cache package release, then offer to copy it somewhere.	Answer the chosen file's location after copy,	or the cache location if no directory was chosen."	| release installer newDir newName newFile oldFile oldName |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	installer := SMInstaller forPackageRelease: release.	[UIManager default informUser: 'Caching ' , release asString during: [installer cache]] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs.		^nil ].	installer isCached ifFalse: [self inform: 'Download failed, see transcript for details'. ^nil].	oldName := installer fullFileName.	newDir := FileList2 modalFolderSelector: installer directory.	newDir ifNil: [ ^oldName ].	newDir = installer directory ifTrue: [ ^oldName ].	newName := newDir fullNameFor: installer fileName.	newFile := FileStream newFileNamed: newName.	newFile ifNil: [ ^oldName ].	newFile binary.	oldFile := FileStream readOnlyFileNamed: oldName.	oldFile ifNil: [ ^nil ].	oldFile binary.	[[ newDir copyFile: oldFile toFile: newFile ] ensure: [ oldFile close. newFile close ]] on: Error do: [ :ex | ^oldName ].	^newName! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categoriesMenu: aMenu 	"Answer the categories-list menu."	self selectedCategory 		ifNotNil: [aMenu addList: self categorySpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!categoryChildren: aCategory	^ aCategory subCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!categoryHasChildren: aCategory	^ aCategory hasSubCategories! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:46'!categoryLabel: aCategory	^ aCategory name! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01'!categoryList	"Create the category list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (map categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/22/2006 15:02'!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:01'!commandSpecFor: selector	^ self commandSpecs detect: [:spec | spec second = selector]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:00'!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (conf8irming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/22/2006 15:02'!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!defaultLabel	^ 'SqueakMap Package Loader'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:38'!downloadPackageRelease	"Force a download of the selected package release into the cache."	| release |	release := self selectedPackageOrRelease.	release isPackageRelease ifFalse: [ self error: 'Should be a package release!!'].	[UIManager default informUser: 'Downloading ' , release asString during: [		(SMInstaller forPackageRelease: release) download]	] on: Error do: [:ex |		| msg | 		msg := ex messageText ifNil: [ex asString].		self informException: ex msg: ('Error occurred during download:\', msg, '\') withCRs]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterAdd: anObject	self changeFilters: (self filters copyWith: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterAutoInstall	^[:package | package isInstallable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterAvailable	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterInstalled	^[:package | package isInstalled]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterNotInstalledYet	^[:package | package isInstalled not]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:42'!filterNotUptoDate	^[:package | package isAvailable]! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 11/22/2006 15:02'!filterPublished	^[:package | package isPublished]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filterRemove: anObject	self changeFilters: (self filters copyWithout: anObject)! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterSafelyAvailable	^[:package | package isSafelyAvailable]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/30/2006 21:07'!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically') #('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.') #('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.') #('Installed packages' #filterInstalled 'Display only packages that are installed.') #('Published packages' #filterPublished 'Display only packages that have at least one published release.') ) asOrderedCollection.	categoriesToFilterIds		do: [:catId | specs add: {'Packages in ' , (map object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoaderPlus methodsFor: 'filters' stamp: 'btr 12/1/2006 01:43'!filterVersion	"Ignore spaces in the version string, they're sometimes spurious.	Not used anymore."	^[:package | package categories anySatisfy:  		[:cat | (cat name, '*') match: (Smalltalk version copyWithout: $ ) ]]! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!filters	^filters! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/24/2006 13:49'!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or	description. "	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty		ifTrue: [^ self].	descriptions := self packageList collect: [:e | e description].	index + 1		to: list size		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	"wrap around"	1		to: index		do: [:i | (((list at: i)						includesSubstring: match						caseSensitive: false)					or: [(descriptions at: i)							includesSubstring: match							caseSensitive: false])				ifTrue: [^ self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 18:36'!hasSelectedItem	^ self selectedPackageOrRelease notNil! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by versions: (installed -> latest).If there is no arrow, your installed version of the package is the latest.Bold packages and releases have been installed.The checkbox menu items modify which packages you''ll see.Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.Comment on a package by emailing the author or the squeak list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/2726' asUrl]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!informException: ex msg: msg 	"Tell the user that an error has occurred.	Offer to open debug notifier."	(self confirm: msg, 'Would you like to open a debugger?')		ifTrue: [ex pass]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/5/2006 05:28'!initialExtent	^500@400! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:53'!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease installer |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	installer := SMInstaller forPackageRelease: aRelease.	[UIManager default informUser: 'Downloading ' , aRelease asString during:		[installer download].	UIManager default informUser: 'Installing ' , aRelease asString during: [		installer install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 15:02'!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:44'!itemChildren: anItem 	^ anItem isPackage		ifTrue: [anItem releases]		ifFalse: [#()]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 19:56'!itemDescription	^ self selectedPackageOrRelease		ifNil: ['<No package selected>']		ifNotNilDo: [:item | item fullDescription]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:45'!itemHasChildren: anItem 	^ anItem isPackage and: [anItem releases notEmpty]! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:44'!itemLabel: anItem 	| label |	label := anItem isPackage				ifTrue: [anItem name						, (anItem versionLabel								ifEmpty: ['']								ifNotEmptyDo: [:lbl | ' (' , anItem versionLabel , ')'])]				ifFalse: [anItem smartVersion].	^ anItem isInstalled		ifTrue: [label asText allBold]		ifFalse: [label]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 11/24/2006 17:17'!label	^ self		labelForShown: (packagesList				ifNil: [self packageList])! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!labelForFilter: aFilterSymbol 	^(self filterSpecs detect: [:fs | fs second = aFilterSymbol]) first! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!labelForShown: packagesShown	"Update the label of the window."	^ self defaultLabel , ' (',		(packagesShown size < map packages size ifTrue: [packagesShown size printString,		' shown out of '] ifFalse: ['']) , map packages size printString, ' packages)'! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!listInPasteBuffer	"Useful when talking with people etc.	Uses the map to produce a nice String."	Clipboard clipboardText:		(String streamContents: [:s |			packagesList do: [:p |				s nextPutAll: p nameWithVersionLabel; cr ]]) asText! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:31'!loadUpdates	[UIManager default informUser: 'Loading Updates' during: [		map loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/24/2006 14:05'!noteChanged	filters		ifNil: [^ self reOpen].	map		ifNotNil: [packagesList := nil.			selectedCategory := nil.			self changed: #categoryList.			self changed: #packageList.			self changed: #packagesListIndex.			"update my selection"			self contentsChanged]! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'btr 11/22/2006 16:11'!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!package: aPackage filteredByCategory: aCategory	"Answer true if the package should be shown	if we filter on <aCategory>. It should be shown	if itself or any of its releases has the category."	| releases |	releases := aPackage releases.	^(aPackage hasCategoryOrSubCategoryOf: aCategory) or: [			releases anySatisfy: [:rel |				rel hasCategoryOrSubCategoryOf: aCategory]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list |	list := packagesList ifNil: [packagesList := self packageListCalculated].	selectedCategory ifNotNil: [		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^ list! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:49'!packageListCalculated	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	^ self packages select: [:p |		filters allSatisfy: [:currFilter |			currFilter isSymbol				ifTrue: [(self perform: currFilter) value: p]				ifFalse: [self package: p filteredByCategory: (map object: currFilter)]]]! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!packageNameList	^ self packageList collect: [:e | e name]! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 18:30'!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: (self commandSpecFor: #installPackageRelease)].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: (self commandSpecFor: #browseCacheDirectory)].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: (self commandSpecFor: #cachePackageReleaseAndOfferToCopy).		choices add: (self commandSpecFor: #downloadPackageRelease)].	choices add: (self commandSpecFor: #emailPackageMaintainers).	^ choices! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/22/2006 16:11'!packages	"We request the packages as sorted by name by default."	^map packagesByName asArray! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex	^ self packageList indexOf: self selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:01'!packagesListIndex: anObject 	self		selectedItem: (anObject = 0				ifFalse: [self packageList at: anObject])! !!SMLoaderPlus methodsFor: 'menus' stamp: 'btr 11/22/2006 15:02'!packagesMenu: aMenu 	"Answer the packages-list menu."	self selectedPackageOrRelease 		ifNotNil: [aMenu addList: self packageSpecificOptions; addLine].	aMenu addList: self generalOptions.	self addFiltersToMenu: aMenu.	^aMenu! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 12/1/2006 01:45'!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	^ (self respondsTo: selector)		ifTrue: [self perform: selector]		ifFalse: [super perform: selector orSendTo: otherTarget]! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 11/26/2006 23:22'!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	window delete.	(Smalltalk at: self class name) open! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeCategoryFilters	"Remove all category filters."	categoriesToFilterIds := OrderedCollection new! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!removeSelectedCategoryAsFilter	"Remove the filter that filters on the currently selected category."	categoriesToFilterIds remove: self selectedCategory id! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!saveFiltersAsDefault	"Save the current filters as default so that they	are selected the next time the loader is opened."	DefaultFilters := filters copy.	DefaultCategoriesToFilterIds := categoriesToFilterIds copy! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchSelection	"Selects all of the default search text so that a type-in overwrites it."	^ {1. self searchText size}! !!SMLoaderPlus methodsFor: 'interface' stamp: 'btr 11/24/2006 14:35'!searchText	"A dummy default search text so that the field describes its purpose."	^ 'Search packages'! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedCategory	"Return selected category."	^ selectedCategory! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:37'!selectedCategory: anSMCategory 	"Change the selected category."	selectedCategory := anSMCategory.	selectedCategory		ifNotNil: [(selectedCategory objects includes: self selectedItem)			ifFalse: [self selectedItem: nil]].	self changed: #selectedCategory.	self changed: #packageList! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:52'!selectedCategoryPath	"Return selected category's path."	| path |	path := #().	selectedCategory		ifNotNil: [selectedCategory parent				ifNotNilDo: [:p | path := path copyWith: p].			path := path copyWith: selectedCategory].	^ path		collect: [:cat | self categoryLabel: cat]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:02'!selectedItem	^ selectedItem! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:27'!selectedItem: anItem	"This == workaround protects us from recursion since ToolBuilder's tree widgets will always tell us that the selection has been updated when we tell it that the selection path has been updated. Cleaner solutions invited."	anItem == selectedItem ifFalse: [		selectedItem := anItem.		self changed: #selectedItemPath.		self changed: #itemDescription.		self changed: #hasSelectedItem]! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 12/1/2006 16:16'!selectedItemPath	| path |	path := #().	(selectedItem isKindOf: SMPackageRelease)		ifTrue: [path := path copyWith: selectedItem package].	selectedItem		ifNotNil: [path := path copyWith: selectedItem].	^ path! !!SMLoaderPlus methodsFor: 'accessing' stamp: 'btr 11/24/2006 14:03'!selectedPackageOrRelease	"Return selected package or package release."	^ selectedItem! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!showFilterString: aFilterSymbol 	^(self stateForFilter: aFilterSymbol), (self labelForFilter: aFilterSymbol)! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!stateForFilter: aFilterSymbol 	^(self filters includes: aFilterSymbol) ifTrue: ['<yes>'] ifFalse: ['<no>']! !!SMLoaderPlus methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 15:02'!toggleFilterState: aFilterSymbol 	^(self filters includes: (aFilterSymbol)) 		ifTrue: [self filterRemove: aFilterSymbol]		ifFalse: [self filterAdd: aFilterSymbol]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!uncheckFilters	"Uncheck all filters."		filters := OrderedCollection new.	self noteChanged! !!SMLoaderPlus methodsFor: 'lists' stamp: 'btr 12/1/2006 01:50'!updateLabel: packagesShown	"Update the label of the window."	window ifNotNilDo: [:w | w setLabel: (self labelForShown: packagesShown)]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during: [				map upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. Confirms on each upgrade."	^ self upgradeInstalledPackagesConfirm: true! !!SMLoaderPlus methodsFor: 'private' stamp: 'btr 12/1/2006 01:29'!upgradeInstalledPackagesConfirm: confirmEach 	"Tries to upgrade all installed packages to the latest published release for	this version of Squeak. If confirmEach is true we ask for every	upgrade. "	| installed old myRelease toUpgrade info |	installed := map installedPackages.	old := map oldPackages.	old isEmpty		ifTrue: [^ self inform: 'All ' , installed size printString , ' installed packages are up to date.'].	toUpgrade := map upgradeableAndOldPackages.	toUpgrade isEmpty		ifTrue: [^ self inform: 'None of the ' , old size printString , ' old packages of the ' , installed size printString , ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size		ifTrue: ['Of the ' , old size printString , ' old packages only ' , toUpgrade size printString , ' can be upgraded.The following packages will not be upgraded:'						, (String								streamContents: [:s | (old removeAll: toUpgrade;										 yourself)										do: [:p | s nextPutAll: p nameWithVersionLabel;												 cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info , 'About to upgrade the following packages:'				, (String						streamContents: [:s | toUpgrade								do: [:p | s nextPutAll: p nameWithVersionLabel;										 cr]]) , 'Proceed?')		ifTrue: [myRelease := self installedReleaseOfMe.			[UIManager default informUser: 'Upgrading Installed Packages' during:					[confirmEach						ifTrue: [map								upgradeOldPackagesConfirmBlock: [:p | self confirm: 'Upgrade ' , p installedRelease packageNameWithVersion , ' to ' , (p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName , '?']]						ifFalse: [map upgradeOldPackages].					self inform: toUpgrade size printString , ' packages successfully processed.'.					myRelease = self installedReleaseOfMe						ifTrue: [self noteChanged]						ifFalse: [self reOpen]]]				on: Error				do: [:ex | self informException: ex msg: ('Error occurred when upgrading old packages:\' , ex messageText , '\') withCRs]]! !!SMLoaderPlus methodsFor: 'actions' stamp: 'btr 11/22/2006 15:02'!upgradeInstalledPackagesNoConfirm	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. No confirmation on each upgrade."	^ self upgradeInstalledPackagesConfirm: false! !!SMPackageWrapper methodsFor: 'comparing' stamp: 'dvf 9/21/2003 16:25' prior: 27998626!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMPackageWrapper methodsFor: 'converting' stamp: 'btr 11/22/2006 00:54' prior: 27998778!asString	| string |	string := item name, ' (', item versionLabel, ')'.	item isInstalled ifTrue: [string := string asText allBold].	"(string includesSubString: '->') ifTrue: [string := string asText color: Color green]."	^ string! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'dvf 10/14/2003 18:58' prior: 27998902!contents	^item releases reversed collect: [:e | SMPackageReleaseWrapper with: e]! !!SMPackageWrapper methodsFor: 'testing' stamp: 'dvf 9/21/2003 16:25' prior: 27999070!hash	^self withoutListWrapper hash! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:55'!help	^ 'This shows all packages with their releases that should be displayed according the current filter.'! !!SMPackageWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString! !!SMPackageWrapper methodsFor: 'printing' stamp: 'dvf 9/21/2003 16:22' prior: 27999192!printOn: aStream	aStream nextPutAll: 'wrapper for: ', item printString! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 27849043!= anObject	^self withoutListWrapper = anObject withoutListWrapper! !!SMCategoryWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 18:53' prior: 27849195!asString	^ item name , ' (' , self numberOfObjects printString , ')'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'ar 2/9/2004 02:35' prior: 27849301!category	^item! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 21:02' prior: 27849402!contents	^ item subCategories		collect: [:n | self class with: n model: n]! !!SMCategoryWrapper methodsFor: 'model access' stamp: 'btr 11/30/2006 21:02'!getList	^ Array		with: (self class with: self contents model: model)! !!SMCategoryWrapper methodsFor: 'testing' stamp: 'btr 11/30/2006 18:53'!hasContents	^ item hasSubCategories! !!SMCategoryWrapper methodsFor: 'comparing' stamp: 'ar 2/9/2004 02:13' prior: 27849700!hash	^self withoutListWrapper hash! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:56'!help	^ 'The categories are structured in a tree. Packages and package releases belong to several categories. You can add one or more categories as filters and enable them in the menu.'! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'BJP 11/22/2002 14:17'!model	^model! !!SMCategoryWrapper methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:53'!numberOfObjects"	| total |	total _ 0.	model allCategoriesDo: [:c |		total _ total + c objects size].	^total"	^item objects size! !!SMPackageReleaseWrapper methodsFor: 'converting' stamp: 'btr 11/30/2006 21:30' prior: 27997393!asString	"Show installed releases with a trailing asterisk."	| string |	string := item smartVersion.	"Older SMBase versions don't have isInstalled.'"	(item respondsTo: #isInstalled) ifTrue:		[item isInstalled ifTrue: [string := (string , ' *') asText allBold]].	^ string! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 17:14'!contents	^ #()! !!SMPackageReleaseWrapper methodsFor: 'accessing' stamp: 'btr 11/22/2006 16:49'!label	^ self asString	! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 12/1/2006 15:47' prior: 27944626!initialize	"Hook us up in the world menu."	"self initialize"	Smalltalk		at: #ToolBuilder		ifAbsent: [self registerInFlapsRegistry.			(Preferences windowColorFor: #SMLoader) = Color white				ifTrue: ["not set"					Preferences						setWindowColorFor: #SMLoader						to: (Color colorFrom: self windowColorSpecification brightColor)].			(TheWorldMenu respondsTo: #registerOpenCommand:)				ifTrue: [| oldCmds |					oldCmds := TheWorldMenu registry select: [:cmd | cmd first includesSubString: 'Package Loader'].					oldCmds do: [:cmd | TheWorldMenu unregisterOpenCommand: cmd first].					TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]].	DefaultFilters := OrderedCollection new.	DefaultCategoriesToFilterIds := OrderedCollection new! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52'!openMenuString	^ 'SqueakMap Catalog'! !!SMLoader class methodsFor: 'class initialization' stamp: 'btr 11/30/2006 21:52' prior: 27945298!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:08' prior: 54331069!addFiltersToMenu: aMenu	| filterSymbol help |	self filterSpecs do: [:filterArray | 		filterSymbol := filterArray second.		help := filterArray third.		aMenu addUpdating: #showFilterString: target: self selector: #toggleFilterState: argumentList: (Array with: filterSymbol).		aMenu balloonTextForLastItem: help].	aMenu addLine;		addList: #(('Clear all filters' uncheckFilters 'Unchecks all filters to list all packages'))	! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:15' prior: 27927912!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease ifNil: [^ nil].	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:52'!buildButtonBar	| aRow btn |	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	self buttonSpecs do: [:spec |		btn := self buildButtonNamed: spec first helpText: spec third action: spec second.		aRow addMorphBack: btn]		separatedBy: [aRow addTransparentSpacerOfSize: 3@0].	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 01:27'!buildButtonNamed: labelText helpText: balloon action: action	| btn |	btn := PluggableButtonMorph on: self getState: nil action: action.	btn color: Color transparent;		hResizing: #shrinkWrap;		vResizing: #spaceFill;		label: labelText;		setBalloonText: balloon;		onColor: Color transparent offColor: Color transparent.	^ btn! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 19:04' prior: 27928394!buildMorphicCategoriesList	"Create the hierarchical list holding the category tree."	| list |	list := (SimpleHierarchicalListMorph				on: self				list: #categoryWrapperList				selected: #selectedCategoryWrapper				changeSelected: #selectedCategoryWrapper:				menu: #categoriesMenu:				keystroke: nil) autoDeselect: true;				 enableDrag: false;				 enableDrop: true;				 yourself.	list setBalloonText: 'The categories are structured in a tree. Packages and package releases belong to several categories.You can add one or more categories as filters and enable them in the menu.'.	"list scroller submorphs do:[:each| list expandAll: each]."	list adjustSubmorphPositions.	^ list! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:22' prior: 27929139!buildMorphicPackagesList	"Create the hierarchical list holding the packages and releases."	^(SimpleHierarchicalListMorph 		on: self		list: #packageWrapperList		selected: #selectedItemWrapper		changeSelected: #selectedItemWrapper:		menu: #packagesMenu:		keystroke: nil)		autoDeselect: false;		enableDrag: false;		enableDrop: true;		setBalloonText: 'This shows all packages with their releases that should be displayed according the current filter.';		yourself! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:13'!buildPackageButtonBar	| aRow |	"Somewhat patterned after IRCe's buttonRow method."	aRow := AlignmentMorph newRow beSticky.	aRow color: Color transparent;		clipSubmorphs: true.	^ aRow! !!SMLoader methodsFor: 'interface' stamp: 'gk 5/5/2006 02:05' prior: 27929686!buildPackagePane	"Create the text area to the right in the loader."	| ptm |	ptm := PluggableTextMorph 		on: self 		text: #contents		accept: nil		readSelection: nil "#packageSelection "		menu: nil.	ptm setBalloonText: 'This is where the selected package or package release is displayed.'.	ptm lock.	^ptm! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 21:08' prior: 27930070!buildSearchPane	"Cribbed from MessageNames>>inMorphicWindowWithInitialSearchString:"	| typeInView searchButton typeInPane |	typeInView := PluggableTextMorph				on: self				text: nil				accept: #findPackage:notifying:				readSelection: nil				menu: nil.	typeInView acceptOnCR: true;		 vResizing: #spaceFill;		 hResizing: #spaceFill;		 setTextMorphToSelectAllOnMouseEnter;		 askBeforeDiscardingEdits: false;		 setProperty: #alwaysAccept toValue: true.	(typeInView respondsTo: #hideScrollBarsIndefinitely)		ifTrue: [typeInView hideScrollBarsIndefinitely]		ifFalse: [typeInView hideScrollBarIndefinitely].	searchButton := SimpleButtonMorph new target: typeInView;				 color: Color white;				 label: 'Search';				 actionSelector: #accept;				 arguments: #(); yourself.	typeInPane := AlignmentMorph newRow.	typeInPane vResizing: #shrinkWrap;		 hResizing: #shrinkWrap;		 listDirection: #leftToRight;		 addMorphFront: searchButton;		 addTransparentSpacerOfSize: 6 @ 0;		 addMorphBack: typeInView;		 setBalloonText: 'Type into the pane, then press Search (or hit RETURN) to visit the next package matching what you typed.'.	^ typeInPane! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 14:24'!buttonSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.')		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.')		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.')		('Update' loadUpdates 'Update the package index from the servers.')		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).')		('Help' help 'What is this?'))! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:11' prior: 27936393!categorySpecificOptions	| choices |	choices := OrderedCollection new.	(categoriesToFilterIds includes: self selectedCategory id)		ifTrue: [			choices add: #('Remove filter' #removeSelectedCategoryAsFilter 'Remove the filter for the selected category.')]		ifFalse: [			choices add: #('Add as filter' #addSelectedCategoryAsFilter 'Add the selection as a filter to hide unrelated packages.')].	categoriesToFilterIds isEmpty ifFalse: [		choices add: #('Remove all filters' #removeCategoryFilters 'Remove all category filters.')].	^ choices! !!SMLoader methodsFor: 'lists' stamp: 'btr 11/30/2006 21:01' prior: 27933585!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	| list first |	list := (model categories				select: [:each | each parent isNil]) asArray				sort: [:c1 :c2 | c1 name <= c2 name].	first := list				detect: [:any | any name = 'Squeak versions']				ifNone: [].	first		ifNotNil: [list := list copyWithout: first.			list := {first} , list].	^ list		collect: [:cat | SMCategoryWrapper with: cat model: self]! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/10/2004 15:45' prior: 27913226!changeFilters: anObject 	"Update my selection."	| oldItem index |	oldItem := self selectedPackageOrRelease.	filters := anObject.	self packagesListIndex: ((index := self packageList indexOf: oldItem) 				ifNil: [0]				ifNotNil: [index]).	self noteChanged! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/30/2006 17:30' prior: 27930584!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.3.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0.0 @ 0.0 corner: 1.0 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0.0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (0.0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0.0 @ horizDivide corner: vertDivide @ 1.0).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1.0 @ 1.0).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self! !!SMLoader methodsFor: 'interface' stamp: 'gk 7/12/2004 11:14' prior: 27931214!defaultButtonPaneHeight	"Answer the user's preferred default height for new button panes."	^ Preferences parameterAt: #defaultButtonPaneHeight ifAbsentPut: [25]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:01'!defaultLabel	^'SqueakMap Package Loader'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:14' prior: 27917579!emailPackageMaintainers	"Send mail to package owner and co-maintainers."	| item package toAddresses |	item := self selectedPackageOrRelease ifNil: [^ nil].	package := item isPackageRelease ifTrue: [item package] ifFalse: [item].	"(this logic should be moved to MailMessage as soon as it can handle multiple To: addresses)"	toAddresses := '<', package owner email, '>'.	package maintainers ifNotNil: [		package maintainers do: [:maintainer |			toAddresses := toAddresses, ', <', maintainer email, '>']].	SMUtilities sendMailTo: toAddresses regardingPackageRelease: item! !!SMLoader methodsFor: 'filter utilities' stamp: 'btr 11/22/2006 00:14' prior: 27923782!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('Auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('New available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('New safely-available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('Installed packages' #filterInstalled 'Display only packages that are installed.')	#('Published packages' #filterPublished 'Display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'Packages in ', (model object: catId) name. catId. 'Display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 19:27' prior: 27918212!findPackage: aString notifying: aView 	"Search and select a package with the given (sub) string in the name or description."	| index list match descriptions |	match := aString asString asLowercase.	index := self packagesListIndex.	list := self packageNameList.	list isEmpty ifTrue: [^self].	descriptions := self packageWrapperList collect: [:e | e withoutListWrapper description].	index + 1 to: list size		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	"wrap around"	1 to: index		do: 			[:i | 			(((list at: i) includesSubstring: match caseSensitive: false) or:				[(descriptions at: i) includesSubstring: match caseSensitive: false])				ifTrue: [^self packagesListIndex: i]].	self inform: 'No package matching ' , aString asString! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/21/2006 16:05' prior: 27937041!generalOptions	^#( #('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm)		#('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm)		#('Put list in paste buffer' listInPasteBuffer)		#('Save filters as default' saveFiltersAsDefault)		#- )! !!SMLoader methodsFor: 'interface' stamp: 'btr 11/22/2006 00:48' prior: 27931447!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://minnow.cc.gatech.edu/squeak/2726' asUrl]! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/22/2006 01:13' prior: 27918874!installPackageRelease	"Install selected package or release.	The cache is used."	| item release |	item := self selectedPackageOrRelease ifNil: [^ nil].	item isPackageRelease		ifTrue: [			(item isPublished or: [self confirm: 'Selected release is not published yet, install anyway?'])				ifTrue: [^self installPackageRelease: item]]		ifFalse: [			release := item lastPublishedReleaseForCurrentSystemVersion.			release ifNil: [				(self confirm: 'The package has no published release for your Squeak version, try releases for any Squeak version?')					ifTrue: [						release := item lastPublishedRelease.						release ifNil: [							(self confirm: 'The package has no published release at all, take the latest of the unpublished releases?')								ifTrue: [release := item lastRelease]]]].			release ifNotNil: [^self installPackageRelease: release]]! !!SMLoader methodsFor: 'actions' stamp: 'mist 8/17/2005 13:56'!installPackageWithDependents: package	| myRelease |	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		package installWithDependencies.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'initialization' stamp: 'gk 4/5/2005 21:17' prior: 27932588!openAsMorph	"Open the loader as a Morphic window."	"SMLoader new openAsMorph"		^self createWindow openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45' prior: 27934165!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				(filters ifNil: [#()]) allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNotNil:		[selectedCategory := selectedCategoryWrapper category.		list := list select: [:each | self package: each filteredByCategory: selectedCategory]].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'menus' stamp: 'btr 11/22/2006 14:30' prior: 27937451!packageSpecificOptions	| choices packageOrRelease |	packageOrRelease := self selectedPackageOrRelease.	choices := OrderedCollection new.	packageOrRelease isInstallable ifTrue: [		choices add: self buttonSpecs first].	(packageOrRelease isDownloadable and: [packageOrRelease isCached]) ifTrue: [		choices add: self buttonSpecs third].	(packageOrRelease isPackageRelease and: [packageOrRelease isDownloadable]) ifTrue: [		choices add: #('Copy from cache' #cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' ).		choices add: #('Force download into cache' #downloadPackageRelease 'Force a download of the selected release into the cache.' )].	choices add: self buttonSpecs second.	^ choices! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 18:56' prior: 27913703!packagesListIndex: anObject 	self		selectedItemWrapper: (anObject ifNotNil: [anObject = 0				ifFalse: [self packageWrapperList at: anObject]])! !!SMLoader methodsFor: 'interface' stamp: 'gk 4/5/2005 21:43' prior: 27932888!perform: selector orSendTo: otherTarget 	"Selector was just chosen from a menu by a user. If can respond, then  	perform it on myself. If not, send it to otherTarget, presumably the  	editPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/26/2006 23:22' prior: 27941030!reOpen	"Close this package loader, probably because it has been updated,	and open a new one."	self inform: 'This package loader has been upgraded and will be closed and reopened to avoid strange side effects.'.	self delete.	(Smalltalk at: self class name) open! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/30/2006 19:17' prior: 27913904!selectedCategory	"Return selected category."	^selectedCategoryWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'accessing' stamp: 'btr 12/1/2006 15:51' prior: 27914233!selectedCategoryWrapper: aWrapper	selectedCategoryWrapper := aWrapper.	(aWrapper notNil and:		[aWrapper withoutListWrapper objects includes: selectedItemWrapper withoutListWrapper])		ifFalse: [self selectedItemWrapper: nil].	self changed: #selectedCategoryWrapper.	self changed: #packageWrapperList.! !!SMLoader methodsFor: 'accessing' stamp: 'btr 11/22/2006 19:13' prior: 27914590!selectedItemWrapper: aWrapper	selectedItemWrapper := aWrapper.	self changed: #selectedItemWrapper.	self contentsChanged! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:10' prior: 27941340!selectedPackageOrRelease	"Return selected package or package release."	^self selectedItemWrapper ifNotNilDo: [:w | w withoutListWrapper]! !!SMLoader methodsFor: 'interface' stamp: 'btr 12/1/2006 02:02' prior: 27935346!updateLabel: packagesShown	"Update the label of the window."	self setLabel: self defaultLabel , ' (',			(packagesShown size < model packages size ifTrue: [packagesShown size printString,			' shown out of '] ifFalse: ['']) , model packages size printString, ' packages)'! !!SMLoader methodsFor: 'actions' stamp: 'btr 11/30/2006 21:03' prior: 27921197!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'btr 11/30/2006 21:03' prior: 27941568!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	info := old size < toUpgrade size ifTrue: [		'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: ['All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 12/1/2006 18:06'!initialize	Smalltalk at: #ToolBuilder ifAbsent: [	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu registerOpenCommand: {self openMenuString. {self. #open}}]]! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!openMenuString	^ 'SqueakMap Categories'! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!removeFromSystem	(TheWorldMenu respondsTo: #registerOpenCommand:)		ifTrue: [TheWorldMenu unregisterOpenCommand: self openMenuString].	self removeFromSystem: true! !!SMLoaderCategorical class methodsFor: 'menu registration' stamp: 'btr 11/30/2006 21:51'!unload	(TheWorldMenu respondsTo: #registerOpenCommand:) ifTrue: 		[TheWorldMenu unregisterOpenCommand: self openMenuString].! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #installedPackageNameList		selected: #installedPackagesListIndex		changeSelected: #installedPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 11/30/2006 18:58'!buildMorphicNotInstalledPackagesList	| list |	(list := PluggableListMorph new)		on: self		list: #notInstalledPackageNameList		selected: #notInstalledPackagesListIndex		changeSelected: #notInstalledPackagesListIndex:		menu: #packagesMenu:		keystroke: #packagesListKey:from:.	^ list! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createFancyWindow	"Creates a variant of the window where the package pane is split between installed and uninstalled packages."	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ searchHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ (buttonBarHeight + searchHeight) corner: vertDivide @ horizDivide).	self addMorph: (self buildMorphicNotInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (horizDivide / 2)).	self addMorph: (self buildMorphicInstalledPackagesList borderWidth: 0)		frame: (vertDivide @ (horizDivide / 2) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setUpdatablePanesFrom: #(#installedPackageNameList #notInstalledPackageNameList ).	currentPackageList := #notInstalled.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!createWindow	| buttonBarHeight searchHeight vertDivide horizDivide |	buttonBarHeight := 0.07.	searchHeight := 0.07.	vertDivide := 0.5.	horizDivide := 0.6.	self addMorph: (self buildButtonBar borderWidth: 0)		frame: (0 @ 0 corner: 1 @ buttonBarHeight).	self addMorph: (self buildMorphicCategoriesList borderWidth: 0)		frame: (0 @ buttonBarHeight corner: vertDivide @ horizDivide).	self addMorph: (self buildSearchPane borderWidth: 0)		frame: (vertDivide @ buttonBarHeight corner: 1 @ (buttonBarHeight + searchHeight)).	self addMorph: (self buildMorphicPackagesList borderWidth: 0)		frame: (vertDivide @ (buttonBarHeight + searchHeight) corner: 1 @ horizDivide).	self addMorph: (self buildPackagePane borderWidth: 0)		frame: (0 @ horizDivide corner: 1 @ 1).	self on: #mouseEnter send: #paneTransition: to: self.	self on: #mouseLeave send: #paneTransition: to: self.	self setLabel: self defaultLabel! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 17:27'!currentPackageList	^currentPackageList! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'btr 11/30/2006 17:44'!currentPackageList: aSymbol	currentPackageList := aSymbol.	self changed: #installButtonLabel.! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:56'!defaultLabel	^ 'SqueakMap Categorical Package Loader'! !!SMLoaderCategorical methodsFor: 'interface' stamp: 'btr 12/4/2006 15:58'!installButtonLabel	^ self currentPackageList = #notInstalled		ifTrue: ['Install the above package']		ifFalse: ['Remove the above package']! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!installedPackageNameList	^self packageList select: [:e | e isInstalled]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!installedPackagesListIndex	self currentPackageList = #installed		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!installedPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #installed		ifTrue: [self currentPackageList: #installed.			self changed: #currentPackageList].	self noteChanged! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 15:09'!isOn	^false! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 11/30/2006 20:20'!notInstalledPackageNameList	^self packageList select: [:e | e isInstalled not]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 13:58'!notInstalledPackagesListIndex	self currentPackageList = #notInstalled		ifTrue: [^ self packagesListIndex]		ifFalse: [^ 0]! !!SMLoaderCategorical methodsFor: 'accessing' stamp: 'BJP 11/25/2002 14:35'!notInstalledPackagesListIndex: anObject 	packagesListIndex := anObject.	self currentPackageList ~= #notInstalled ifTrue:		[self currentPackageList: #notInstalled.		 self changed: #currentPackageList].	self changed: #packagesListIndex.	"update my selection"	self noteChanged.	self contentsChanged! !!SMLoaderCategorical methodsFor: 'private' stamp: 'btr 11/30/2006 20:21'!noteChanged	self changed: #installedPackageNameList.	self changed: #notInstalledPackageNameList.	super noteChanged."	self changed: #packageNameList.	self changed: #packagesListIndex.	self changed: #categoriesForPackage.	self contentsChanged."! !!SMLoaderCategorical methodsFor: 'lists' stamp: 'btr 12/1/2006 16:45'!packageList	^ self packages		select: [:e | (e categories					anySatisfy: [:cat | cat = self selectedCategory])				and: [(filters ifNil: [#()])						allSatisfy: [:currFilter | (self perform: currFilter)								value: e]]]! !SMLoader removeSelector: #paneColorOld!SMLoader removeSelector: #addPackagesTo:at:plus:!"SMLoader"!!HashedCollectionIntegrityTest methodsFor: 'as yet unclassified' stamp: 'ul 4/13/2010 00:19'!testCapacity	| inconsistentCollections |	inconsistentCollections := HashedCollection allSubInstances reject: [ :each |		each class == MethodDictionary "MethodDictionary is the only HashedCollection which doesn't have prime array size"			ifTrue: [ each capacity isPowerOfTwo ]			ifFalse: [ each capacity isPrime ] ].	self assert: inconsistentCollections isEmpty! !"Tests"!HashedCollection class removeSelector: #goodPrimesForIdentityBasedHashedCollections!"Collections"!!ZLibWriteStream class methodsFor: 'crc' stamp: 'ar 4/14/2010 19:50' prior: 33397485!updateAdler32: adler from: start to: stop in: aCollection	"Update crc using the Adler32 checksum technique from RFC1950""        unsigned long s1 = adler & 0xffff;        unsigned long s2 = (adler >> 16) & 0xffff;        int n;        for (n = 0; n < len; n++) {          s1 = (s1 + buf[n]) % BASE;          s2 = (s2 + s1)     % BASE;        }        return (s2 << 16) + s1;"	| s1 s2 |	<primitive: 'primitiveUpdateAdler32' module: 'ZipPlugin'>	s1 := adler bitAnd: 16rFFFF.	s2 := (adler bitShift: -16) bitAnd: 16rFFFF.	start to: stop do: [ :n | | b |		b := aCollection byteAt: n.		s1 := (s1 + b) \\ 65521.		s2 := (s2 + s1) \\ 65521. ].	^(s2 bitShift: 16) + s1! !"Compression"!!MCSnapshotBrowser methodsFor: 'accessing' stamp: 'hmm 4/16/2010 22:07' prior: 23076302!allClassNames	^ (items 		select: [:ea | (ea isOrganizationDefinition | ea isScriptDefinition) not] 		thenCollect: [:ea | ea className]) asSet.! !"Monticello"!!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:48' prior: 58240485!compactAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #compactWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 4/12/2010 23:49' prior: 55067225!rehashAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: #rehashWithoutBecome.	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:04'!compact	"Make sure that I have the highest possible load factor (at least 50%)."		self become: self compactWithoutBecome! !!MethodDictionary methodsFor: 'private' stamp: 'ul 4/12/2010 23:05'!compactWithoutBecome	"Return a copy of self which has the highest possible load factor (at least 50%)."		| newSelf |	newSelf := self class new: self size.	self keysAndValuesDo: [ :key :value |		newSelf at: key put: value ].	^newSelf! !!Duration class methodsFor: 'squeak protocol' stamp: 'ul 4/28/2010 09:44' prior: 59189810!milliSeconds: milliCount 		^self		seconds: (milliCount quo: 1000)		nanoSeconds: (milliCount rem: 1000) * NanosInMillisecond! !!StringHolder class methodsFor: 'instance creation' stamp: 'fbs 4/28/2010 18:53' prior: 54905196!open	^ (Smalltalk at: #Workspace ifAbsent:[self]) new openLabel: 'Workspace'		"Not to be confused with our own class var 'Workspace'"! !!CompiledMethod methodsFor: 'decompiling' stamp: 'hmm 4/16/2010 10:48' prior: 50758861!methodNode	"Return the parse tree that represents self. If parsing fails, decompile the method."	| aClass source |	aClass := self methodClass.	source := self				getSourceFor: (self selector ifNil: [self defaultSelector])				in: aClass.	^[(aClass parserClass new		encoderClass: (self isBlueBookCompiled						ifTrue: [EncoderForV3]						ifFalse: [EncoderForV3PlusClosures]);		parse: source class: aClass)			sourceText: source;			yourself]		on: SyntaxErrorNotification		do: [:ex | ex return: self decompile].! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:48' prior: 53338498!absPrintExactlyOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version guarantees that the printed representation exactly represents my value	by using exact integer arithmetic."	| significand exp baseExpEstimate r s mPlus mMinus scale roundingIncludesLimits d tc1 tc2 fixedFormat decPointCount slowbit shead |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significand := self significandAsInteger.	roundingIncludesLimits := significand even.	exp := (self exponent - 52) max: MinValLogBase2.	baseExpEstimate := (self exponent * base asFloat reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[significand ~= 16r10000000000000				ifTrue:					[r := significand bitShift: 1 + exp.					s := 2.					mPlus := mMinus := 1 bitShift: exp]				ifFalse:					[r := significand bitShift: 2 + exp.					s := 4.					mPlus := 2 * (mMinus := 1 bitShift: exp)]]		ifFalse:			[(exp = MinValLogBase2 or: [significand ~= 16r10000000000000])				ifTrue:					[r := significand bitShift: 1.					s := 1 bitShift: 1 - exp.					mPlus := mMinus := 1]				ifFalse:					[r := significand bitShift: 2.					s := 1 bitShift: 2 - exp.					mPlus := 2.					mMinus := 1]].	baseExpEstimate >= 0		ifTrue: [s := s * (base raisedToInteger: baseExpEstimate)]		ifFalse:			[scale := base raisedToInteger: baseExpEstimate negated.			r := r * scale.			mPlus := mPlus * scale.			mMinus := mMinus * scale].	((r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[r := r * base.			mPlus := mPlus * base.			mMinus := mMinus * base].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	slowbit := 1 - s lowBit .	shead := s bitShift: slowbit.	[d := (r bitShift: slowbit) // shead.	r := r - (d * s).	(tc1 := (r > mMinus) not and: [roundingIncludesLimits or: [r < mMinus]]) |	(tc2 := (r + mPlus < s) not and: [roundingIncludesLimits or: [r + mPlus > s]])] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * base.		mPlus := mPlus * base.		mMinus := mMinus * base.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[(tc1 not or: [r * 2 >= s]) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Float methodsFor: 'printing' stamp: 'nice 4/20/2010 22:32' prior: 51138013!absPrintOn: aStream base: base	"Print my value on a stream in the given base.  Assumes that my value is strictly	positive; negative numbers, zero, and NaNs have already been handled elsewhere.	Based upon the algorithm outlined in:	Robert G. Burger and R. Kent Dybvig	Printing Floating Point Numbers Quickly and Accurately	ACM SIGPLAN 1996 Conference on Programming Language Design and Implementation	June 1996.	This version performs all calculations with Floats instead of LargeIntegers, and loses	about 3 lsbs of accuracy compared to an exact conversion."	| significantBits fBase exp baseExpEstimate r s mPlus mMinus scale d tc1 tc2 fixedFormat decPointCount |	self isInfinite ifTrue: [aStream nextPutAll: 'Infinity'. ^ self].	significantBits := 50.  "approximately 3 lsb's of accuracy loss during conversion"	fBase := base asFloat.	exp := self exponent.	baseExpEstimate := (exp * fBase reciprocalLogBase2 - 1.0e-10) ceiling.	exp >= 0		ifTrue:			[r := self.			s := 1.0.			mPlus := 1.0 timesTwoPower: exp - significantBits.			mMinus := self significand ~= 1.0 ifTrue: [mPlus] ifFalse: [mPlus / 2.0]]		ifFalse:			[r := self timesTwoPower: significantBits.			s := 1.0 timesTwoPower:  significantBits.			mMinus := 1.0 timesTwoPower: (exp max: -1024).			mPlus :=				(exp = MinValLogBase2) | (self significand ~= 1.0)					ifTrue: [mMinus]					ifFalse: [mMinus * 2.0]].	baseExpEstimate >= 0		ifTrue:			[exp = 1023				ifTrue:   "scale down to prevent overflow to Infinity during conversion"					[r := r / fBase.					s := s * (fBase raisedToInteger: baseExpEstimate - 1).					mPlus := mPlus / fBase.					mMinus := mMinus / fBase]				ifFalse:					[s := s * (fBase raisedToInteger: baseExpEstimate)]]		ifFalse:			[exp < -1023				ifTrue:   "scale up to prevent denorm reciprocals overflowing to Infinity"					[d := (53 * fBase reciprocalLogBase2 - 1.0e-10) ceiling.					scale := fBase raisedToInteger: d.					r := r * scale.					mPlus := mPlus * scale.					mMinus := mMinus * scale.					scale := fBase raisedToInteger: (baseExpEstimate + d) negated]				ifFalse:				[scale := fBase raisedToInteger: baseExpEstimate negated].			s := s / scale].	(r + mPlus >= s)		ifTrue: [baseExpEstimate := baseExpEstimate + 1]		ifFalse:			[s := s / fBase].	(fixedFormat := baseExpEstimate between: -3 and: 6)		ifTrue:			[decPointCount := baseExpEstimate.			baseExpEstimate <= 0				ifTrue: [aStream nextPutAll: ('0.000000' truncateTo: 2 - baseExpEstimate)]]		ifFalse:			[decPointCount := 1].	[d := (r / s) truncated.	r := r - (d * s).	(tc1 := r <= mMinus) | (tc2 := r + mPlus >= s)] whileFalse:		[aStream nextPut: (Character digitValue: d).		r := r * fBase.		mPlus := mPlus * fBase.		mMinus := mMinus * fBase.		decPointCount := decPointCount - 1.		decPointCount = 0 ifTrue: [aStream nextPut: $.]].	tc2 ifTrue:		[tc1 not | (tc1 & (r*2.0 >= s)) ifTrue: [d := d + 1]].	aStream nextPut: (Character digitValue: d).	decPointCount > 0		ifTrue:		[decPointCount - 1 to: 1 by: -1 do: [:i | aStream nextPut: $0].		aStream nextPutAll: '.0'].	fixedFormat ifFalse:		[aStream nextPut: $e.		aStream nextPutAll: (baseExpEstimate - 1) printString]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 4/28/2010 12:29' prior: 54648421!compress	"Compact the method dictionary of the receiver."	self methodDict compact! !MethodDictionary removeSelector: #compactCopyFrom:!"Kernel"!!OptimizedBlockLocalTempReadBeforeWrittenVisitor commentStamp: '<historical>' prior: 0!Answer the set of temporary variables that are read before they are written in the visited parse tree.  Used by the compiler to detect those block-local temporaries of blocks in optimized loops that require nilling to prevent a value from a previous iteration persisting into a subsequent one.!!BlockNode commentStamp: '<historical>' prior: 59231160!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'initialize-release' stamp: 'eem 9/5/2009 21:03'!initialize	inOptimizedBlock := false! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'accessing' stamp: 'eem 9/8/2008 14:30'!readBeforeWritten	^readBeforeWritten ifNil: [IdentitySet new]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/10/2008 15:28'!visitAssignmentNode: anAssignmentNode	anAssignmentNode value accept: self.	anAssignmentNode variable isTemp		ifTrue:			[written ifNil: [written := IdentitySet new].			 written add: anAssignmentNode variable]		ifFalse:			[anAssignmentNode variable accept: self]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:09'!visitBlockNode: aBlockNode	| savedWritten |	"If we're in the optimized block in one side of an optimized ifTrue:ifFalse: et al	 leave it to the enclosing visitMessageNode: activation to handle merging written."	inOptimizedBlock ifTrue:		[^super visitBlockNode: aBlockNode].	"If we're not then don't update written because without evaluating the guard(s)	 we can't tell if the block is evaluated or not, and we must avoid false positives."	savedWritten := written copy.	super visitBlockNode: aBlockNode.	written := savedWritten! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 22:03'!visitMessageNode: aMessageNode	| savedWritten writtenPostFirstArm |	(aMessageNode isOptimized	 and: [#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: aMessageNode selector key]) ifFalse:		[^super visitMessageNode: aMessageNode].	aMessageNode receiver accept: self.	aMessageNode selector accept: self.	savedWritten := written copy.	aMessageNode argumentsInEvaluationOrder		do: [:argument|			argument isBlockNode				ifTrue: [| savedIOB |					savedIOB := inOptimizedBlock.					inOptimizedBlock := true.					[argument accept: self]						ensure: [inOptimizedBlock := savedIOB]]				ifFalse: [argument accept: self]]		separatedBy:			[writtenPostFirstArm := written.			 written := savedWritten].	(written notNil	 and: [writtenPostFirstArm notNil]) ifTrue:		[written := written intersection: writtenPostFirstArm]! !!OptimizedBlockLocalTempReadBeforeWrittenVisitor methodsFor: 'visiting' stamp: 'eem 9/8/2008 14:43'!visitTempVariableNode: aTempVariableNode	(aTempVariableNode isArg	 or: [written notNil		and: [written includes: aTempVariableNode]]) ifTrue:		[^self].	readBeforeWritten ifNil:		[readBeforeWritten := IdentitySet new].	readBeforeWritten add: aTempVariableNode! !!LiteralNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51562187!accept: aVisitor	^aVisitor visitLiteralNode: self! !!SelectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52462316!accept: aVisitor	^aVisitor visitSelectorNode: self! !!VariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 53106854!accept: aVisitor	^aVisitor visitVariableNode: self! !!InstanceVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51430081!accept: aVisitor	^aVisitor visitInstanceVariableNode: self! !!FieldNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51111193!accept: aVisitor	^aVisitor visitFieldNode: self! !!AssignmentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 33548097!accept: aVisitor	^aVisitor visitAssignmentNode: self! !!RemoteTempVectorNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52334181!accept: aVisitor	^aVisitor visitRemoteTempVectorNode: self! !!LiteralVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 51566588!accept: aVisitor	^aVisitor visitLiteralVariableNode: self! !!NewArrayNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51916378!accept: aVisitor	^aVisitor visitNewArrayNode: self! !!CommentNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50736685!accept: aVisitor	^aVisitor visitCommentNode: self! !!CascadeNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50569061!accept: aVisitor	^aVisitor visitCascadeNode: self! !!BlockNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50443783!accept: aVisitor	^aVisitor visitBlockNode: self! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 19:23' prior: 50444587!analyseTempsWithin: scopeBlock "<BlockNode>" rootNode: rootNode "<MethodNode>" assignmentPools: assignmentPools "<Dictionary>"	| effectiveScope blockStart |	effectiveScope := optimized						ifTrue: [actualScopeIfOptimized := scopeBlock]						ifFalse: [self].	arguments ifNotNil:		[arguments do: [:temp| temp definingScope: self]].	temporaries ifNotNil:		[temporaries do: [:temp| temp definingScope: self]].	optimized ifFalse: "if optimized this isn't an actual scope"		[rootNode noteBlockEntry:			[:entryNumber|			 blockExtent := (blockStart := entryNumber) to: 0]].	"Need to enumerate a copy because closure analysis can add a statement	 via ifHasRemoteTempNodeEnsureInitializationStatementExists:."	statements copy do:		[:statement|		 statement analyseTempsWithin: effectiveScope rootNode: rootNode assignmentPools: assignmentPools].	optimized		ifTrue: "if optimized loop need to add nils for any temps read before written"			[optimizedMessageNode isOptimizedLoop ifTrue:				[self nilReadBeforeWrittenTemps]]		ifFalse: "if optimized this isn't an actual scope"			[rootNode noteBlockExit:				[:exitNumber|				 blockExtent := blockStart to: exitNumber]].	"Now that the analysis is done move any temps that need to be moved."	self postNumberingProcessTempsWithin: effectiveScope rootNode: rootNode.	"This is simply a nicety for compiler developers..."	temporaries do:		[:temp|		(temp isIndirectTempVector and: [temp name includes: $?]) ifTrue:			[temp name: temp definingScope remoteTempNodeName]]! !!BlockNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:05' prior: 17572883!emitForEvaluatedValue: stack on: aStream	self emitExceptLast: stack on: aStream.	statements last emitForBlockValue: stack on: aStream.! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:36'!nilReadBeforeWrittenTemps	| visitor readBeforeWritten |	self accept: (visitor := OptimizedBlockLocalTempReadBeforeWrittenVisitor new).	readBeforeWritten := visitor readBeforeWritten.	temporaries reverseDo:		[:temp|		((readBeforeWritten includes: temp)		 and: [temp isRemote not]) ifTrue:			[statements addFirst: (AssignmentNode new variable: temp value: NodeNil)]]! !!BlockNode methodsFor: 'code generation (closures)' stamp: 'eem 9/6/2009 13:30'!noteOptimizedIn: anOptimizedMessageNode	optimized := true.	optimizedMessageNode := anOptimizedMessageNode! !!BlockNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 18:04' prior: 17574191!sizeForEvaluatedValue: encoder	^(self sizeExceptLast: encoder)		+ (statements last sizeForBlockValue: encoder)! !!ParseNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 52065009!accept: aVisitor	"Accept a visitor by double-dispatching to a type-specific method on the visitor, e.g. visitBlockNode:.	 All such implementations under ParseNode should answer the result of the dispatch, e.g.		^aVisitor visitBlockNode: self"	^self subclassResponsibility! !!ParseNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 17:57'!emitForBlockValue: stack on: aStream	"Generate code for evaluating the last statement in a block"	^self emitForValue: stack on: aStream! !!ParseNode methodsFor: 'code generation' stamp: 'ar 10/2/2007 17:56'!sizeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeForValue: encoder! !!MessageNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51659869!accept: aVisitor	^aVisitor visitMessageNode: self! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:33' prior: 51636522!transformAnd: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeFalse) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:32' prior: 51668475!transformCase: encoder	| caseNode |	caseNode := arguments first.	(caseNode isMemberOf: BraceNode) ifTrue:		[((caseNode blockAssociationCheck: encoder)		  and: [arguments size = 1			    or: [self checkBlock: arguments last as: 'otherwise arg' from: encoder]]) ifFalse:			[^false].		 caseNode elements do:			[:messageNode|			messageNode receiver noteOptimizedIn: self.			messageNode arguments first noteOptimizedIn: self].		 arguments size = 2 ifTrue:			[arguments last noteOptimizedIn: self].		 ^true].	(caseNode canBeSpecialArgument and: [(caseNode isMemberOf: BlockNode) not]) ifTrue:		[^false]. "caseOf: variable"	^encoder notify: 'caseOf: argument must be a brace construct or a variable'! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51637527!transformIfFalse: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse:			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51658193!transformIfFalseIfTrue: encoder	^(self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'True arg' from: encoder)	   and: [selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.			arguments swap: 1 with: 2.			arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:19' prior: 51642266!transformIfNil: encoder	"vb: Removed the original transformBoolean: which amounds to a test we perform in each of the branches below."	(MacroSelectors at: special) = #ifNotNil: ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder maxArgs: 1) ifFalse:			[^false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector := SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments := Array						with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self)						with: (arguments first noteOptimizedIn: self).		(self transform: encoder) ifFalse:			[self error: 'compiler logic error'].		^true].	(self checkBlock: arguments first as: 'ifNil arg' from: encoder) ifFalse:		[^false].	arguments first noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18' prior: 51676424!transformIfNilIfNotNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 2.	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)	  and: [self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51679950!transformIfNotNilIfNil: encoder	"vb: Changed to support one-argument ifNotNil: branch. In the 1-arg case we	 transform the receiver to		(var := receiver)	 which is further transformed to		(var := receiver) == nil ifTrue: .... ifFalse: ...	 This does not allow the block variable to shadow an existing temp, but it's no different	 from how to:do: is done."	| ifNotNilArg |	ifNotNilArg := arguments at: 1.	((self checkBlock: ifNotNilArg as: 'NotNil arg' from: encoder maxArgs: 1)	  and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder]) ifFalse:		[^false].	ifNotNilArg numberOfArguments = 1 ifTrue:		[receiver := AssignmentNode new						variable: ifNotNilArg firstArgument						value: receiver].	selector := SelectorNode new key: #ifTrue:ifFalse: code: #macro.	receiver := MessageNode new					receiver: receiver					selector: #==					arguments: (Array with: NodeNil)					precedence: 2					from: encoder.	arguments swap: 1 with: 2.	arguments do: [:arg| arg noteOptimizedIn: self].	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51630388!transformIfTrue: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((arguments at: 1) noteOptimizedIn: self)					with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:30' prior: 51678537!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)	   and: [(self checkBlock: (arguments at: 2) as: 'False arg' from: encoder)	   and: [arguments do: [:arg| arg noteOptimizedIn: self].			true]]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:18' prior: 51632638!transformOr: encoder	(self transformBoolean: encoder)		ifTrue: 			[arguments := 				Array 					with: ((BlockNode withJust: NodeTrue) noteOptimizedIn: self)					with: ((arguments at: 1) noteOptimizedIn: self).			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 13:31' prior: 51669258!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment := encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit := arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/6/2009 19:17' prior: 51635034!transformWhile: encoder	(self checkBlock: receiver as: 'receiver' from: encoder) ifFalse:		[^false].	arguments size = 0 ifTrue:  "transform bodyless form to body form"		[selector := SelectorNode new						key: (special = 10 ifTrue: [#whileTrue:] ifFalse: [#whileFalse:])						code: #macro.		 arguments := Array with: ((BlockNode withJust: NodeNil) noteOptimizedIn: self).		 receiver noteOptimizedIn: self.		 ^true].	^(self transformBoolean: encoder)	   and: [receiver noteOptimizedIn: self.			arguments first noteOptimizedIn: self.			true]! !!ReturnNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 52349447!accept: aVisitor	^aVisitor visitReturnNode: self! !!MethodNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:35' prior: 51730971!accept: aVisitor	^aVisitor visitMethodNode: self! !!BraceNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:33' prior: 50521748!accept: aVisitor	^aVisitor visitBraceNode: self! !!TempVariableNode methodsFor: 'visiting' stamp: 'eem 9/6/2009 12:34' prior: 52840973!accept: aVisitor	^aVisitor visitTempVariableNode: self! !!Encoder methodsFor: 'encoding' stamp: 'eem 9/3/2009 10:50' prior: 50998649!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode := self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [^action value]].	range ifNotNil: [		name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]. ].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [		OutOfScopeNotification signal ifFalse: [ ^self notify: 'out of scope'].	].	^ varNode! !BlockNode removeSelector: #noteOptimized!"Compiler"!!StandardViewer methodsFor: 'initialization' stamp: 'ar 4/23/2010 16:53' prior: 29917444!initializeFor: aPlayer barHeight: anInteger includeDismissButton: aBoolean showCategories: categoryInfo	"Initialize the receiver to be a look inside the given Player.  The categoryInfo, if present, describes which categories should be present in it, in which order"	scriptedPlayer := aPlayer.	self listDirection: #topToBottom;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		borderWidth: 1.	self color: self standardViewerColor.	self addHeaderMorphWithBarHeight: anInteger includeDismissButton: aBoolean.	categoryInfo isEmptyOrNil		ifFalse:  "Reincarnating an pre-existing list"			[categoryInfo do:				[:aCat | self addCategoryViewerFor: aCat]]		ifTrue:  "starting fresh"			[self addSearchPane. 			self addCategoryViewer.			self addCategoryViewer.			(scriptedPlayer isPlayerLike and: [scriptedPlayer costume isMemberOf: KedamaMorph]) ifTrue: [self addCategoryViewer].		].! !"EToys"!!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:13' prior: 57366653!upTo: delimiter	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOf: delimiter startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 3/31/2010 04:14' prior: 53809967!upToAnyOf: delimiters do: aBlock	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					| result |					result := collection copyFrom: position + 1 to: (position := pos) - 1 .					aBlock value: (collection at: position).					^result ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOfAnyOf: delimiters startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					self skip: pos - bytesRead.					false "Found the delimiter." ] ] whileTrue.		bytesRead = 0 ifFalse: [			aBlock value: (buffer at: pos) ] ]! !"Files"!!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ul 4/28/2010 11:22' prior: 52007447!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| base bits |	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This Smalltalk version might be easier to understand than the others below."	base := y * form width * bitsPerChannel // 32 + 1.	bits := form bits.	0 to: thisScanline size - 1 // 4 do: [ :i |		| ii word |		ii := i * 4.		"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 		is to make use of faster arithmetic bytecodes, but not of slow largeintegers."		word :=			(((thisScanline at: ii + 1) * 256 + 			(thisScanline at: ii + 2) * 256 + 			(thisScanline at: ii + 3)) bitShift: 8) bitOr: 			(thisScanline at: ii + 4).		bits at: base + i put: word ].			"This interesting technique (By Andreas Raab) is faster for very large images, but might be slower for small ones"	"^self copyPixelsGrayWeirdBitBltHack: y ".	"It uses the following method:	PNGReadWriter >> copyPixelsGrayWeirdBitBltHack: y 	""Handle non-interlaced black and white color mode (colorType = 0)	By Andreas Raab""		| source dest cmap |	source := Form extent: 1 @ (thisScanline size // 4) depth: 32 bits: thisScanline.	dest := Form extent: 1 @ (form bits size) depth: 32 bits: form bits.	cmap := Smalltalk isLittleEndian		ifTrue:[ColorMap 					shifts: #(-24 -8 8 24) 					masks: #(16rFF000000 16r00FF0000 16r0000FF00 16r000000FF)].	(BitBlt toForm: dest)		sourceForm: source;		destX: 0 destY: (y * form width*bitsPerChannel//32) width: 1 height: (form width+31*bitsPerChannel//32);		colorMap: cmap;		combinationRule: 3;		copyBits."			"This interesting technique  (By Yoshiki Ohshima) is faster for very large images, but might be slower for small ones"	"form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32)".	"It uses the following method:	BitMap >> copyFromByteArray2: byteArray to: i	""This method should work with either byte orderings""	| myHack byteHack |	myHack := Form new hackBits: self.	byteHack := Form new hackBits: byteArray.	Smalltalk  isLittleEndian ifTrue: [byteHack swapEndianness].	byteHack displayOn: myHack at:  0@i"! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'jmv 4/15/2010 10:19' prior: 52000090!grayColorsFor: d	"return a color table for a gray image"	palette := Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^  palette		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 85.0 / 255.0).		palette at: 3 put: (Color gray: 170.0 / 255.0).		palette at: 4 put: Color white.		^ palette		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jmv 4/15/2010 10:18' prior: 52016987!processTransparencyChunk	| red green blue |	"Transcript show: '  TRANSPARENCY ',chunk printString."	colorType = 0 ifTrue: [		transparentPixelValue := chunk unsignedShortAt: 1 bigEndian: true.		palette at: transparentPixelValue put: Color transparent.		^self	].	colorType = 2 ifTrue: [		red := chunk at: 2.		green := chunk at: 2.		blue := chunk at: 2.		transparentPixelValue := 16rFF00 + red << 8 + green << 8 + blue.		^self	].	colorType = 3 ifTrue: [		chunk withIndexDo: [ :alpha :index |			palette at: index put: ((palette at: index) alpha: alpha/255)		].		^self	].! !"Graphics"!!RectangleTest methodsFor: 'tests' stamp: 'wiz 4/29/2010 02:10'!testRoundingAfterHalfPixelTranslation	"A rectangle right on the cusp of rounding changes shape if origin and	corner are in differenct quadrants"	"self debug: #testRoundingAfterHalfPixelTranslation"	| trouble noTrouble |	trouble := 10 negated asPoint rect: 10 asPoint.	noTrouble := trouble translateBy: 15.		10 timesRepeat: [trouble := (trouble translateBy: 0.5) rounded].	10 timesRepeat: [noTrouble := (noTrouble translateBy: 0.5) rounded].		self assert: trouble extent = noTrouble extent! !"GraphicsTests"!!DurationTest methodsFor: 'testing' stamp: 'ul 4/28/2010 09:57' prior: 19913678!testMilliSeconds	#(		"argument (milliseconds)	seconds	nanoseconds"		(5							0			5000000)		(1005						1			5000000)		(-5							0			-5000000)		(-1005						-1			-5000000)		(1234567					1234		567000000)		(-1234567					-1234		-567000000)			) do: [ :each |		| duration |		duration := Duration milliSeconds: each first.		self assert: duration asSeconds = each second.		self assert: duration nanoSeconds = each third ]! !"KernelTests"!!ObjectFinalizer commentStamp: 'jcg 4/27/2010 01:01' prior: 0!Represents an action that is to be taken when a target object (not referenced by the ObjectFinalizer) is garbage-collected.!!CodeLoader commentStamp: 'hjh 4/22/2010 12:58' prior: 59244840!CodeLoader provides a simple facility for loading code from the network.CodeLoader has a very specific purpose, primarily for loading Etoys projects. It is not meant to be used for anything else. Use Installer for general purposes.Examples:	| loader |	loader := CodeLoader new.	loader baseURL:'http://isgwww.cs.uni-magdeburg.de/~raab/test/'.	loader localCache: #('.cache' 'source').	"Sources and segments can be loaded in parallel"	loader loadSourceFiles: #('file1.st' 'file2.st.gz').	loader localCache: #('.cache' 'segments').	loader loadSegments: #('is1.extseg' 'is2.extseg.gz').	"Install sources first - will wait until the files are actually loaded"	loader installSourceFiles.	"And then the segments"	loader installSegments.!!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ul 4/28/2010 11:38'!keyAtValue: value	"Answer the key that is the external name for the argument, value. If	there is none, answer nil."	self deprecated: 'Use Smalltalk globals'.	^globals keyAtValue: value! !!ProjectLoading class methodsFor: 'loading' stamp: 'ul 4/28/2010 12:35' prior: 55884567!openName: aFileName stream: preStream fromDirectory: aDirectoryOrNilwithProjectView: existingView	"Reconstitute a Morph from the selected file, presumed to berepresent a Morph saved via the SmartRefStream mechanism, and open itin an appropriate Morphic world."   	| morphOrList proj trusted localDir projStream archive mgrprojectsToBeDeleted baseChangeSet enterRestricted substituteFontnumberOfFontSubstitutes exceptions |	(preStream isNil or: [preStream size = 0]) ifTrue: [		ProgressNotification  signal: '9999 about to enterproject'.		"the hard part is over"		^self inform:'It looks like a problem occurred whilegetting this project. It may be temporary,so you may want to try again,' translated	].	ProgressNotification signal: '2:fileSizeDetermined',preStream size printString.	preStream isZipArchive		ifTrue:[	archive := ZipArchive new readFrom: preStream.				projStream := selfprojectStreamFromArchive: archive]		ifFalse:[projStream := preStream].	trusted := SecurityManager default positionToSecureContentsOf:projStream.	trusted ifFalse:		[enterRestricted := (preStream isTypeHTTP or:[aFileName isNil])			ifTrue: [Preferences securityChecksEnabled]			ifFalse: [Preferences standaloneSecurityChecksEnabled].		enterRestricted			ifTrue: [SecurityManager default enterRestrictedMode				ifFalse:					[preStream close.					^ self]]].	localDir := Project squeakletDirectory.	aFileName ifNotNil: [		(aDirectoryOrNil isNil or: [aDirectoryOrNil pathName~= localDir pathName]) ifTrue: [			localDir deleteFileNamed: aFileName.			(localDir fileNamed: aFileName) binary				nextPutAll: preStream contents;				close.		].	].	morphOrList := projStream asUnZippedStream.	preStream sleep.		"if ftp, let the connection close"	ProgressNotification  signal: '3:unzipped'.	ResourceCollector current: ResourceCollector new.	baseChangeSet := ChangeSet current.	self useTempChangeSet.		"named zzTemp"	"The actual reading happens here"	substituteFont := Preferences standardEToysFont copy.	numberOfFontSubstitutes := 0.	exceptions := Set new.	[[morphOrList := morphOrList fileInObjectAndCodeForProject]		on: FontSubstitutionDuringLoading do: [ :ex |				exceptions add: ex.				numberOfFontSubstitutes :=numberOfFontSubstitutes + 1.				ex resume: substituteFont ]]			ensure: [ ChangeSet  newChanges: baseChangeSet].	mgr := ResourceManager new initializeFrom: ResourceCollector current.	mgr fixJISX0208Resource.	mgr registerUnloadedResources.	archive ifNotNil:[mgr preLoadFromArchive: archive cacheName:aFileName].	(preStream respondsTo: #close) ifTrue:[preStream close].	ResourceCollector current: nil.	ProgressNotification  signal: '4:filedIn'.	ProgressNotification  signal: '9999 about to enter project'.		"the hard part is over"	(morphOrList isKindOf: ImageSegment) ifTrue: [		proj := morphOrList arrayOfRoots			detect: [:mm | mm isKindOf: Project]			ifNone: [^self inform: 'No project found inthis file'].		proj projectParameters at: #substitutedFont put: (			numberOfFontSubstitutes > 0				ifTrue: [substituteFont]				ifFalse: [#none]).		proj projectParameters at: #MultiSymbolInWrongPlace put: false.			"Yoshiki did not put MultiSymbols intooutPointers in older images!!"		morphOrList arrayOfRoots do: [:obj |			obj fixUponLoad: proj seg: morphOrList "imageSegment"].		(proj projectParameters at: #MultiSymbolInWrongPlace) ifTrue: [			morphOrList arrayOfRoots do: [:obj | (objisKindOf: HashedCollection) ifTrue: [obj rehash]]].		proj resourceManager: mgr.		"proj versionFrom: preStream."		proj lastDirectory: aDirectoryOrNil.		proj setParent: Project current.		projectsToBeDeleted := OrderedCollection new.		existingView ifNil: [			ChangeSet allChangeSets add: proj changeSet.			Project current openProject: proj.				"Note: in MVC we get no further than the above"		] ifNotNil: [			(existingView project isKindOf: DiskProxy) ifFalse: [				existingView project changeSet name: ChangeSet defaultName.				projectsToBeDeleted add: existingView project.			].			(existingView owner isSystemWindow) ifTrue: [				existingView owner model: proj			].			existingView project: proj.		].		ChangeSet allChangeSets add: proj changeSet.		Project current projectParameters			at: #deleteWhenEnteringNewProject			ifPresent: [ :ignored |				projectsToBeDeleted add: Project current.				Project current removeParameter:#deleteWhenEnteringNewProject.			].		projectsToBeDeleted isEmpty ifFalse: [			proj projectParameters				at: #projectsToBeDeleted				put: projectsToBeDeleted.		].		^ ProjectEntryNotification signal: proj	].	Project current openViewAndEnter: morphOrList! !!Preferences class methodsFor: 'standard queries' stamp: 'sbw 4/24/2010 10:16' prior: 0!annotationPanes	^ self		valueOfFlag: #annotationPanes		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!browserWindowColor	^ self		valueOfFlag: #browserWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 0.6]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!changeListWindowColor	^ self		valueOfFlag: #changeListWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!changeSorterWindowColor	^ self		valueOfFlag: #changeSorterWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!classCommentVersionsBrowserWindowColor	^ self		valueOfFlag: #classCommentVersionsBrowserWindowColor		ifAbsent: [Color				r: 0.769				g: 0.653				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!debuggerWindowColor	^ self		valueOfFlag: #debuggerWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 0.8]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!defaultWindowColor	^ self		valueOfFlag: #defaultWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!dualChangeSorterWindowColor	^ self		valueOfFlag: #dualChangeSorterWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!fileContentsBrowserWindowColor	^ self		valueOfFlag: #fileContentsBrowserWindowColor		ifAbsent: [Color				r: 0.8				g: 0.8				b: 0.5]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!fileListWindowColor	^ self		valueOfFlag: #fileListWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 1.0]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22' prior: 59046404!installUniformWindowColors	"Install the factory-provided uniform window colors for all tools"	"Preferences installUniformWindowColors"	self installWindowColorsVia: [:aQuad | self uniformWindowColor]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!instanceBrowserWindowColor	^ self		valueOfFlag: #instanceBrowserWindowColor		ifAbsent: [Color				r: 0.806				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!lexiconWindowColor	^ self		valueOfFlag: #lexiconWindowColor		ifAbsent: [Color				r: 0.878				g: 1.0				b: 0.878]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!messageListWindowColor	^ self		valueOfFlag: #messageListWindowColor		ifAbsent: [Color				r: 0.8				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!messageNamesWindowColor	^ self		valueOfFlag: #messageNamesWindowColor		ifAbsent: [Color				r: 0.645				g: 1.0				b: 0.452]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!methodFinderWindowColor	^ self		valueOfFlag: #methodFinderWindowColor		ifAbsent: [Color				r: 0.4				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!monticelloToolWindowColor	^ self		valueOfFlag: #monticelloToolWindowColor		ifAbsent: [Color				r: 0.627				g: 0.69				b: 0.976]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!packageBrowserWindowColor	^ self		valueOfFlag: #packageBrowserWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 0.6]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!packageLoaderWindowColor	^ self		valueOfFlag: #packageLoaderWindowColor		ifAbsent: [Color				r: 0.9				g: 0.9				b: 0.781]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!preferenceBrowserWindowColor	^ self		valueOfFlag: #preferenceBrowserWindowColor		ifAbsent: [Color				r: 0.645				g: 1.0				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!testRunnerWindowColor	^ self		valueOfFlag: #testRunnerWindowColor		ifAbsent: [Color				r: 1.0				g: 0.6				b: 0.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!transcriptWindowColor	^ self		valueOfFlag: #transcriptWindowColor		ifAbsent: [Color				r: 1.0				g: 0.8				b: 0.4]! !!Preferences class methodsFor: 'window colors' stamp: 'laza 4/26/2010 10:22'!uniformWindowColor	^Color veryVeryLightGray! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!versionsBrowserWindowColor	^ self		valueOfFlag: #versionsBrowserWindowColor		ifAbsent: [Color				r: 0.869				g: 0.753				b: 1.0]! !!Preferences class methodsFor: 'standard queries' stamp: '' prior: 0!workspaceWindowColor	^ self		valueOfFlag: #workspaceWindowColor		ifAbsent: [Color				r: 1.0				g: 1.0				b: 0.8]! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:32' prior: 51385600!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	inSeg := true.	[object := object nextObject.  		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			object isBlock ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	hashedCollections do: #rehash. "our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 4/28/2010 12:33' prior: 51365564!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.  Do this by discovering classes that need a startUp message sent to each instance, and sending it.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg noStartUpNeeded startUps cls msg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	noStartUpNeeded := IdentitySet new.	"classes that don't have a per-instance startUp message"	startUps := IdentityDictionary new.	"class -> MessageSend of a startUp message"	inSeg := true.	[object := object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class]].			inSeg ifTrue: [				(noStartUpNeeded includes: object class) ifFalse: [					cls := object class.					(msg := startUps at: cls ifAbsent: [nil]) ifNil: [						msg := cls startUpFrom: self.	"a Message, if we need to swap bytes this time"						msg ifNil: [noStartUpNeeded add: cls]							ifNotNil: [startUps at: cls put: msg]].					msg ifNotNil: [msg sentTo: object]]]]. 		object == 0] whileFalse.	hashedCollections do: #rehash.	"our purpose"	^ receiverClasses	"our secondary job"! !!SystemDictionary methodsFor: 'compatibility' stamp: 'ul 4/28/2010 11:45'!hasSpecialSelector: aLiteral ifTrueSetByte: aBlock	self deprecated: 'Use Smalltalk'.	^Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: aBlock! !"System"!!Editor commentStamp: '<historical>' prior: 59290227!New text editors.TextEditor provides most of the functionality that used to be in TextMorphEditor. This class is no longer a Controller!!SmalltalkEditor is has Smalltalk code specific features.SimpleEditor provides basic functionality for single line text editing. It does not handle fonts and styles, aligning and Smalltalk utilities. It handles one single line.CellStyleEditor allows entering alphabetic characters using only number keys, like most cell phones do.!!TheWorldMainDockingBar methodsFor: 'private' stamp: 'laza 4/26/2010 10:31' prior: 53724739!colorIcon: aColor	"Guess if 'uniform window colors' are used and avoid all icons to be just gray"	(aColor = Preferences uniformWindowColor or: [Preferences tinyDisplay]) ifTrue: [ ^nil ].	^(aColor iconOrThumbnailOfSize: 14)		borderWidth: 3 color: Preferences menuColor muchDarker;		borderWidth: 2 color: Color transparent! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 4/26/2010 12:23'!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''Morphic-Kernel'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."HelpSystem: http://www.squeaksource.com/HelpSystem.html"(Installer squeaksource project: ''HelpSystem'')	install: ''HelpSystem-Core'';	install: ''HelpSystem-Tests'';	install: ''Metacello-Help'';	install: ''Pharo-Project-Help'';	install: ''Squeak-Project-Help''.(Smalltalk at: #HelpBrowser) open."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WASqueakServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(194 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 57 12 12 1 8 1 12 3 8 1 17 3 8 1 18 3 8 1 16 3 8 1 20 3 8 1 21 13 3 1 12 2 4 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 29 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000127127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'mha 5/2/2010 16:00' prior: 59194233!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk at: #HelpBrowser) ifNotNil: [					menu addLine.					menu addItem: [ :item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: (Smalltalk at: #HelpBrowser);							selector: #open ] ].			]].! !!TheWorldMainDockingBar methodsFor: 'submenu - windows' stamp: 'laza 4/26/2010 10:57' prior: 58412388!listWindowsOn: menu	| windows |	windows := SortedCollection sortBlock: [:winA :winB |		winA model name = winB model name			ifTrue: [winA label < winB label]			ifFalse: [winA model name < winB model name]].	windows addAll: self allVisibleWindows.	windows ifEmpty: [ 		menu addItem: [ :item | 			item				contents: 'No Windows' translated;				isEnabled: false ] ].	windows do: [ :each |		menu addItem: [ :item |			item 				contents: (self windowMenuItemLabelFor: each);				icon: (self colorIcon: each model defaultBackgroundColor);				target: each;				selector: #comeToFront;				subMenuUpdater: self				selector: #windowMenuFor:on:				arguments: { each };				action: [ each activateAndForceLabelToShow; expand ] ] ].! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'hjh 4/21/2010 18:40' prior: 59197577!showWelcomeText: aSelector label: labelString in: bounds	"Show a welcome text. Linked in here so that the text can be edited	by changing the acceptBlock below."	| acceptBlock window |	"Change the following to allow editing the text"	true ifTrue:[		acceptBlock := [:text|			self class				compile: aSelector,'	^', (String streamContents:[:s| s nextChunkPutWithStyle: text]) storeString, ' readStream nextChunkText'				classified: (self class organization categoryOfElement: aSelector).		].	].	window := UIManager default 		edit: (self perform: aSelector)		label: labelString		accept: acceptBlock.	window bounds: bounds.! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/19/2010 20:58'!blinkingCursor	<preference: 'Blinking Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor will blink.'		type: #Boolean>	^ BlinkingCursor ifNil: [ true ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 15:57'!blinkingCursor: aBoolean	BlinkingCursor := aBoolean! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor	<preference: 'Dumbbell-shaped Text Cursor'		category: 'Morphic'		description: 'When true, the text cursor assumes the shape of a dumbbell, otherwise a vertical bar..'		type: #Boolean>	^ DumbbellCursor ifNil: [ false ]! !!Editor class methodsFor: 'preferences' stamp: 'cmm 4/5/2010 16:23'!dumbbellCursor: aBoolean	DumbbellCursor := aBoolean! !!TextMorph methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58' prior: 52937182!keyboardFocusChange: aBoolean 	| w |	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."			self hasFocus ifFalse: [self editor	"Forces install"].			Editor blinkingCursor ifTrue: [ self startBlinking ].	] ifFalse:["A hand has clicked elsewhere..."		(w := self world) ifNotNil:[			w handsDo: [:h | h keyboardFocus == self ifTrue: [^self]].			"Release control unless some hand is still holding on"			self releaseEditor].		self stopBlinking.	].! !!LazyListMorph methodsFor: 'drawing' stamp: 'mha 4/27/2010 09:33' prior: 59214813!drawBackgroundForMulti: row on: aCanvas 	"shade the background paler, if this row is selected, but not the current selected row"	| selectionDrawBounds thisColor |	thisColor := selectedRow = row		ifTrue: [ self class listSelectionColor twiceDarker ]		ifFalse: [ self class listSelectionColor ].	selectionDrawBounds := self drawBoundsForRow: row.	selectionDrawBounds := selectionDrawBounds intersect: self bounds.	aCanvas		fillRectangle: selectionDrawBounds		color: thisColor! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:38' prior: 58964342!bottomBoundary	"Answert the bottommost x position the receiver could be moved."	| splitter morphs |	splitter := self splitterBelow.	morphs := self commonNeighbours: rightOrBottom with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect bottom]				ifFalse: [owner innerBounds bottom]]		ifNotNil: [splitter top])		- (self minimumHeightOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'spfa 4/20/2010 22:37' prior: 58961894!topBoundary	"Answer the topmost x position the receiver could be moved to."	| splitter morphs |	splitter := self splitterAbove.	morphs := self commonNeighbours: leftOrTop with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect top]				ifFalse: [owner innerBounds top]]		ifNotNil: [splitter bottom])		+ (self minimumHeightOf: morphs)! !!PluggableButtonMorph methodsFor: 'drawing' stamp: 'tfel 4/16/2010 09:34' prior: 58988661!drawOn: aCanvas 	| cc gradient borderColor |	cc := self color.	cc isTransparent ifTrue:[cc := Color gray: 0.9].	self enabled ifFalse:[cc := Color lightGray].	cc brightness > 0.9 ifTrue:[cc := cc adjustBrightness: 0.9 - cc brightness].	showSelectionFeedback ifTrue:[		borderColor := cc muchDarker.		gradient := GradientFillStyle ramp: {			0.0 -> cc muchDarker.			0.1-> (cc adjustBrightness: -0.2).			0.5 -> cc.			0.9-> (cc adjustBrightness: -0.1).			1 -> cc muchDarker.		}.	] ifFalse:[		borderColor := Color lightGray.		gradient := GradientFillStyle ramp: {			0.0 -> Color white.			0.1-> (cc adjustBrightness: 0.05).			0.6 -> (cc darker).		}	].	gradient origin: bounds topLeft.	gradient direction: 0@self height.	^ self class roundedButtonCorners		ifTrue: [aCanvas 				frameAndFillRoundRect: bounds 				radius: 8 				fillStyle: gradient 				borderWidth: 1 				borderColor: borderColor]		ifFalse: [aCanvas 				frameAndFillRectangle: self innerBounds 				fillColor: gradient asColor 				borderWidth: 1 				borderColor: borderColor darker;				fillRectangle: (self innerBounds insetBy: 1) 				fillStyle: gradient]! !!TextMorphForEditView methodsFor: 'event handling' stamp: 'cmm 4/5/2010 15:58' prior: 52961433!keyboardFocusChange: aBoolean 	"rr 3/21/2004 22:55 : removed the #ifFalse: branch, 	which was responsible of the deselection of text when the 	paragraph lost focus. This way selection works in a more standard 	way, and this permits the menu keyboard control to be really effective"	paragraph isNil ifFalse:[paragraph focused: aBoolean].	aBoolean ifTrue:["A hand is wanting to send us characters..."		self hasFocus ifFalse: [self editor	"Forces install"].		Editor blinkingCursor ifTrue: [self startBlinking].	] ifFalse:[		self stopBlinking.	].	self changed.! !!NewParagraph methodsFor: 'access' stamp: 'cmm 4/5/2010 16:24' prior: 51924537!caretWidth	^ Editor dumbbellCursor		ifTrue: [ 2 ]		ifFalse: [ 0 ]! !!SmalltalkEditor methodsFor: 'private' stamp: 'cmm 4/4/2010 20:41' prior: 58007098!methodArgument: anInteger 	^ (ReadStream on: self text asString) nextLine		ifNil: [ String empty ]		ifNotNilDo:			[ : line | 			line substrings				at: 2 * anInteger				ifAbsent: [ String empty ] ]! !"Morphic"!!MultiByteFileStream methodsFor: 'private basic' stamp: 'yo 8/28/2002 11:08' prior: 57724509!basicUpTo: delim	^ super upTo: delim.! !"Multilingual"!!TestURI methodsFor: 'running file' stamp: 'ar 4/12/2010 21:38'!testDirWithHash	"Tests proper escaping of directories with hash mark"	| uriDir origPath origDir dirURI |	origPath := FileDirectory default pathName, '#123'.	origDir := FileDirectory on: origPath.	self assert: origDir pathName = origPath.	dirURI := origDir uri.	uriDir := FileDirectory uri: dirURI.	self assert: origDir fullName = uriDir fullName.! !"NetworkTests"!!PackageInfo methodsFor: 'testing' stamp: 'bf 4/19/2010 02:54' prior: 54301517!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex == 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !"PackageInfo-Base"!!String methodsFor: '*sound-synthesis' stamp: 'wiz 4/28/2010 16:01'!asSound	"Return a sound. Either from the sound library via SampleSound or	else the Beeper default"	^ SampledSound		soundNamed: self		ifAbsent: [Beeper default]! !"Sound"!!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ul 5/2/2010 12:32' prior: 24591721!findWindowInWorldLabeled: aLabel	^World submorphs		detect: [ :each |			(each isKindOf: SystemWindow)				and: [ each label = aLabel ] ]		ifNone: nil.! !!FileStreamTest methodsFor: 'as yet unclassified' stamp: 'jcg 4/15/2010 16:27'!testFileTruncation	"Ensure that nextChunkPut:/nextChunk works properly on a caching file"	| file |	file := nil.	[			file := FileDirectory default forceNewFileNamed: 'TruncationTest.txt'.		file nextPutAll: '1234567890'.	] ensure: [file close].	[		file := FileDirectory default oldFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234567890'].		file truncate: 4.	] ensure: [file close].	[		file := FileDirectory default readOnlyFileNamed: 'TruncationTest.txt'.		self should: [file contents = '1234'].	] ensure: [		file close.		FileDirectory default deleteFileNamed: file name ifAbsent:[]	].! !"Tests"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'ul 5/2/2010 12:34' prior: 59218373!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	window model		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!FileList commentStamp: 'nk 11/26/2002 11:52' prior: 59304739!I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.The FileList now provides a registration mechanism to which any tools the filelist uses ***MUST*** register.  This way it is possible to dynamically load or unload a new tool and have the FileList automatically updated.  This change supports a decomposition of Squeak and removes a problem with dead reference to classes after a major shrink.Tools should implement the following methods (look for implementors in the image):#fileReaderServicesForFile:suffix: (appropriate services for given file, takes a file name and a lowercased suffix)#services (all provided services, to be displayed in full list)These methods both return a collection of SimpleServiceEntry instances.  These contain a class, a menu label and a method selector having one argument.  They may also provide separate button labels and description.The argument to the specified method will be a string representing the full name of a file when one is selected or the file list itself when there is no selected file.Tools must register with the FileList calling the class method #registerFileReader: when they load. They also must call #unregisterFileReader: when they unload.There is a testSuite called FileListTest that presents some examples. Stef (I do not like really this distinction passing always a file list could be better)Old Comments: FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!Workspace methodsFor: 'accessing' stamp: 'fbs 4/28/2010 21:48'!contents: textOrString	super contents: textOrString.	self changed: #contents.! !!Workspace methodsFor: 'code pane menu' stamp: 'ar 4/21/2010 21:23'!shouldStyle: aBool	"If true, contents will by rendered w/ syntax-highlighting"	shouldStyle := aBool! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:47' prior: 51626697!buildSearchPaneWith: builder	| buttonFrame buttonSpec textFrame textSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttonFrame := LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.3 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	textFrame := LayoutFrame new		leftFraction: 0.3 offset: 1;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0;		yourself.	buttonSpec := builder pluggableActionButtonSpec new.	buttonSpec 		model: self;		label: 'Search';		action: [self doSearchFrom: searchPane];		frame: buttonFrame.	top children add: buttonSpec.		textSpec := builder pluggableInputFieldSpec new.	textSpec 		model: self;		name: #search;		getText: #searchString; 		setText: #searchString:notifying:;		frame: textFrame.	top children add: textSpec.	^top! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/23/2010 10:29' prior: 51627142!buildWith: builder	"ToolBuilder open: MessageNames new"	| searchPaneHeight windowSpec max result |	searchPaneHeight := self buttonHeight.	max := self wantsOptionalButtons ifTrue:[0.42] ifFalse:[0.5].	windowSpec := self buildWindowWith: builder specs: {		(self topConstantHeightFrame: searchPaneHeight fromLeft: 0 width: 0.5) -> [self buildSearchPaneWith: builder].		(self selectorListFrame: max fromTop: searchPaneHeight) -> [self buildSelectorListWith: builder].		(0.5@0.0 corner: 1.0@max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}.	result := builder build: windowSpec.	searchPane := builder widgetAt: #search.	^result! !!MessageNames methodsFor: 'class list' stamp: 'fbs 3/31/2010 22:46'!selectedClassOrMetaClass	"Answer the currently selected class (or metaclass)."	messageListIndex > 0 ifTrue: [		^ self setClassAndSelectorIn: [:c :s | ^c]].	(selectorListIndex isNil not and: [selectorListIndex > 0]) ifTrue: [^Smalltalk classNamed: (self selectorList at: selectorListIndex)].		^ nil.	! !!MessageNames methodsFor: 'selection' stamp: 'fbs 3/31/2010 16:31' prior: 23706644!selection	"Answer the item in the list that is currently selected, or nil if no selection is present"	^ messageListIndex = 0		ifTrue: [self selectorList at: selectorListIndex ifAbsent: [nil]]		ifFalse: [self messageList at: messageListIndex ifAbsent: [nil]].! !!MessageNames methodsFor: 'toolbuilder' stamp: 'fbs 4/22/2010 21:44'!selectorListFrame: max fromTop: topOffset	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: topOffset;		rightFraction: 0.5 offset: 0;		bottomFraction: max offset: 0.! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:58'!availableGraphicsExtent	self dependents do: [:each |		((each isKindOf: PluggableTextMorph) and: [each getTextSelector == #contents]) ifTrue: [^each innerBounds extent - (6@22)]].	^nil! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 12:47' prior: 57782322!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #graphic ifTrue: [^ contents].	brevityState == #needToGetGraphic ifTrue: [^self readGraphicContents].		brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	(TextConverter allEncodingNames includes: brevityState) 		ifTrue: [ ^self readContentsAsEncoding: brevityState].	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'file list menu' stamp: 'cao 4/26/2010 09:36' prior: 57911104!fileContentsMenu: aMenu shifted: shifted	"Construct aMenu to have items appropriate for the file browser's code pane, given the shift state provided"	| services maybeLine extraLines |	shifted ifTrue:		[^ aMenu addList: StringHolder shiftedYellowButtonMenuItems].	fileName ifNotNil:		[services := OrderedCollection new.		(#(briefHex briefFile needToGetBriefHex needToGetBrief) includes: brevityState) ifTrue:			[services add: self serviceGet].		(#(fullHex briefHex needToGetFullHex needToGetBriefHex) includes: brevityState) ifFalse:			[services add: self serviceGetHex].		(#(needToGetShiftJIS needToGetEUCJP needToGetCNGB needToGetEUCKR needToGetUTF8) includes: brevityState) ifFalse:			[services add: self serviceGetEncodedText].		maybeLine := services size.		(FileStream sourceFileSuffixes includes: self suffixOfSelectedFile) ifTrue:			[services addAll:				(self servicesFromSelectorSpecs:					#(fileIntoNewChangeSet: fileIn: browseChangesFile: browseFile:))].		extraLines := OrderedCollection new.		maybeLine > 0 ifTrue: [extraLines add: maybeLine].		services size > maybeLine ifTrue: [extraLines add: services size].		aMenu 			addServices: services			for: self fullName			extraLines: extraLines].	aMenu addList: {			{'find...(f)' translated.		#find}.			{'find again (g)' translated.		#findAgain}.			{'set search string (h)' translated.	#setSearchString}.			#-.			{'do again (j)' translated.		#again}.			{'undo (z)' translated.			#undo}.			#-.			{'copy (c)' translated.			#copySelection}.			{'cut (x)' translated.			#cut}.			{'paste (v)' translated.		#paste}.			{'paste...' translated.			#pasteRecent}.			#-.			{'do it (d)' translated.		#doIt}.			{'print it (p)' translated.		#printIt}.			{'inspect it (i)' translated.		#inspectIt}.			{'fileIn selection (G)' translated.	#fileItIn}.			#-.			{'accept (s)' translated.		#accept}.			{'cancel (l)' translated.		#cancel}.			#-.			{'more...' translated.			#shiftedYellowButtonActivity}}.	^ aMenu! !!FileList methodsFor: 'file list' stamp: 'hmm 4/27/2010 13:09' prior: 57786840!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := self isGraphicsFileSelected		ifTrue: [#needToGetGraphic]		ifFalse: [#needToGetBrief]..	self changed: #fileListIndex.	self changed: #contents.	self updateButtonRow! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 13:08'!isGraphicsFileSelected	^fileName notNil and: [((self itemsForFile: self fullName) detect: [:each | each provider == Form and: [each selector == #importImage:]] ifNone: []) notNil]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 20:45'!readGraphicContents	| form maxExtent ext |	form := Form fromFileNamed: self fullName.	maxExtent := lastGraphicsExtent := self availableGraphicsExtent.	ext := form extent.	(maxExtent notNil and: [form extent <= maxExtent]) ifFalse: [		form := form magnify: form boundingBox by: (maxExtent x / form width min: maxExtent y / form height) asPoint smoothing: 3].	contents :=  ('Image extent: ', ext printString) asText,				(String with: Character cr),				(Text string: ' '					attribute: (TextFontReference toFont: 						(FormSetFont new							fromFormArray: (Array with: form)							asciiStart: Character space asInteger							ascent: form height))).	brevityState := #graphic.	^contents! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:02'!step	| ext |	brevityState = #graphic ifTrue: [		ext := self availableGraphicsExtent.		ext = lastGraphicsExtent ifFalse: [			lastGraphicsExtent := ext.			brevityState := #needToGetGraphic.			self changed: #contents]]! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 17:03'!stepTimeIn: aWindow	^500! !!FileList methodsFor: 'private' stamp: 'hmm 4/27/2010 16:56'!wantsSteps	^true! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:29' prior: 50538558!buildClassListSingletonWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classListSingleton; 		getIndex: #indexIsOne; 		setIndex: #indexIsOne:; 		menu: #classListMenu:shifted; 		keyPress: #classListKey:from:.	^listSpec! !!Browser methodsFor: 'toolbuilder' stamp: 'cao 4/26/2010 10:30' prior: 50530267!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:shifted:; 		keyPress: #classListKey:from:.	Preferences browseWithDragNDrop 		ifTrue:[listSpec dragItem: #dragFromClassList:].	^listSpec! !!Browser methodsFor: 'class functions' stamp: 'cmm 4/23/2010 17:03' prior: 54374919!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection, except do NOT clobber or override any selectors already understood by the instances of the selected class"	| aClass |	(aClass := self selectedClassOrMetaClass) ifNotNil:		[aClass instVarNames do: 			[:aName |				| newMessage setter |				(aClass canUnderstand: aName asSymbol)					ifFalse:						[newMessage := aName, '	^', aName.						aClass compile: newMessage classified: 'accessing' notifying: nil].				(aClass canUnderstand: (setter := aName, ':') asSymbol)					ifFalse:						[newMessage := setter, ' anObject	', aName, ' := anObject'.						aClass compile: newMessage classified: 'accessing' notifying: nil]]]! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:53'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 15:50' prior: 50535675!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	"Example:		Browser newOnClass: Browser.	"	| builder max |	builder := ToolBuilder default.	max := self wantsOptionalButtons ifTrue:[0.32] ifFalse:[0.4].	^self buildWindowWith: builder specs: {		(0.0@0.0 corner: 0.5@0.08) -> [self buildClassListSingletonWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0 width: 0.5 bottomFraction: max) -> [self buildMessageCategoryListWith: builder].		(self topConstantHeightFrame: self buttonHeight fromLeft: 0.5 width: 0.5) -> [self buildSwitchesWith: builder].		(self frameOffsetFromTop: self buttonHeight fromLeft: 0.5 width: 0.5 bottomFraction: max) -> [self buildMessageListWith: builder].		(0@max corner: 1@1) -> [self buildCodePaneWith: builder].	}! !!Browser methodsFor: 'initialize-release' stamp: 'fbs 4/22/2010 14:52'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !"Tools"!!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:07'!allowUnderscoreAssignments	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreAssignments])		ifNil: [Scanner prefAllowUnderscoreAssignments]! !!SHParserST80 methodsFor: 'private' stamp: 'laza 4/28/2010 18:04'!allowUnderscoreSelectors	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreSelectors])		ifNil: [Scanner prefAllowUnderscoreSelectors]! !!SHParserST80 methodsFor: 'token testing' stamp: 'laza 4/28/2010 17:51' prior: 52377778!isAssignment	^self isAnsiAssignment or: [self allowUnderscoreAssignments and: [currentToken = '_']]! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:15' prior: 52364496!nextChar	sourcePosition := sourcePosition + 1.	^source at: sourcePosition ifAbsent: $ ! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 52371083!parse: isAMethod 	"Parse the receiver's text. If isAMethod is true    then treat text as a method, if false as an    expression with no message pattern"	self initializeInstanceVariables.	sourcePosition := 1.	arguments := Dictionary new.	temporaries := Dictionary new.	blockDepth := bracketDepth := 0.	ranges		ifNil: [ranges := OrderedCollection new: 100]		ifNotNil: [ranges reset].	errorBlock := [^false].	[self scanNext.	isAMethod 		ifTrue: [			self parseMessagePattern.			self parsePragmaSequence].	self parseMethodTemporaries.	isAMethod ifTrue: [self parsePragmaSequence].	self parseStatementList.	currentToken ifNotNil: [self error]]		ensure:[errorBlock := nil].	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 52383846!parseBinary 	| binary type |	self parseUnary.	[self isBinary] 		whileTrue: [			binary := currentToken.			type := #binary.			(binary isEmpty or:[(Symbol lookup: binary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: binary skipping: nil)						ifNil: [#undefinedBinary]						ifNotNil:[#incompleteBinary]].				self scanPast: type. 				self parseTerm.            	self parseUnary]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:22' prior: 54459800!parseKeyword     | keyword rangeIndices |    self parseBinary.	keyword := ''.	rangeIndices := #().	[    		[self isKeyword]        		whileTrue: [				keyword := keyword, currentToken. 				self rangeType: #keyword.				"remember where this keyword token is in ranges"				rangeIndices := rangeIndices copyWith: ranges size.				self scanNext.				self parseTerm.				self parseBinary ]	] ensure: [ | type |		"do this in an ensure so that it happens even if the errorBlock evaluates before getting here"		"patch up the keyword tokens, so that incomplete and undefined ones look different"		(keyword isEmpty or:[(Symbol lookup: keyword) notNil])			ifFalse:[				type := (Symbol thatStartsCaseSensitive: keyword skipping: nil)					ifNil: [#undefinedKeyword]					ifNotNil:[#incompleteKeyword].				rangeIndices do: [:i | (ranges at: i) type: type]]]! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 22:50' prior: 52379595!parsePrimitive	self scanNext.	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: [			currentTokenFirst == $'				ifTrue: [ self parseString ]				ifFalse: [					currentTokenFirst == $#						ifTrue: [ self parseSymbol ]						ifFalse: [ self error ] ].			currentToken = 'module:' 				ifTrue: [					self scanPast: #module.					currentTokenFirst == $'						ifTrue: [ self parseString ]						ifFalse: [							currentTokenFirst == $#								ifTrue: [ self parseSymbol ]								ifFalse: [ self error ] ] ] ].	self failUnless: currentTokenFirst == $>.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:24' prior: 52389009!parseString	| first c answer last |	first := sourcePosition.	answer := ''.		[(c := self currentChar)		ifNil: [			self rangeType: #unfinishedString start: first - 1 end: source size.			self error	": 'unfinished string'"].	(c == $' 			ifFalse: [answer := answer copyWith: c. true] 		ifTrue: [false]	) or: [		self peekChar == $' 			ifTrue: [				sourcePosition := sourcePosition + 1.				answer := answer copyWith: $'.				true]			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #string start: first - 1 end: last.	^answer! !!SHParserST80 methodsFor: 'parse' stamp: 'laza 4/29/2010 16:18' prior: 52362002!parseSymbolIdentifier	| c start end |	c := self currentChar.	self failUnless: (c isLetter or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]).	start := sourcePosition.		[c := self nextChar.	c isAlphaNumeric or: [c == $: or: [c == $_ and: [self allowUnderscoreSelectors]]]] whileTrue.	end := sourcePosition - 1.	c := source copyFrom: start - 1 to: end.	self scanPast: #symbol start: start - 1 end: end.	^c! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26' prior: 52378939!parseSymbolString	| first c last |	first := sourcePosition.	self nextChar.	[(c := self currentChar) 		ifNil: [			self rangeType: #unfinishedString start: first end: source size.			self error	": 'unfinished string'"].	c ~~ $' or: [		self peekChar == $' 			ifTrue: [sourcePosition := sourcePosition + 1.true] 			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #stringSymbol start: first - 1 end: last! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 4/28/2010 20:26' prior: 52387010!parseUnary	| unary type |	    [self isName]        whileTrue: [			unary := currentToken.			type := #unary.			(unary isEmpty or:[(Symbol lookup: unary) notNil])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: unary skipping: nil)						ifNil: [#undefinedUnary]						ifNotNil:[#incompleteUnary]].			self scanPast: type]! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 19:29' prior: 52385928!scanIdentifier	| c start |	start := sourcePosition.	[(c := self nextChar) isAlphaNumeric or: [c == $_ and: [self allowUnderscoreSelectors]]] whileTrue.	(c == $: and: [(self isSelectorCharacter: self peekChar) not]) 		ifTrue: [self nextChar].	currentToken := source copyFrom: start to: sourcePosition - 1.	currentTokenSourcePosition := start! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 4/28/2010 20:27' prior: 52374752!scanNext	self scanWhitespace.	currentTokenFirst := self currentChar.	currentTokenFirst 		ifNil: [" end of input "			currentTokenFirst := $ .			currentTokenSourcePosition := nil.			currentToken := nil.			^nil].	currentTokenFirst isDigit ifTrue: [^self scanNumber].	currentTokenFirst isLetter ifTrue: [^self scanIdentifier].	^self scanBinary! !!SHTextStyler methodsFor: 'private' stamp: 'ul 4/28/2010 20:27' prior: 52391465!monitor	^monitor ifNil: [monitor := Monitor new]! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreAssignments	^nil! !!SHMCClassDefinition methodsFor: 'act like a class' stamp: 'ul 4/29/2010 12:34'!allowUnderscoreSelectors	^nil! !"ShoutCore"!!HelpTopicListItemWrapper commentStamp: 'tbn 3/8/2010 09:30' prior: 0!This class implements a list item wrapper for help topics.Instance Variables!!CustomHelp commentStamp: 'tbn 3/29/2010 13:23' prior: 0!This is a common superclass for custom help. Subclasses of this class are automatically included into the system help.By default the informations provided on the receiver class are converted into help topics by a specific builder - here the CustomHelpHelpBuilder. Note that you can provide an own custom builder by overriding the #builder method!!HelpOnHelp commentStamp: 'tbn 2/12/2010 14:27' prior: 0!Welcome to Pharo Smalltalk Help System!!HelpAPIDocumentation commentStamp: 'tbn 4/30/2010 15:12' prior: 0!This class represents the browsable package API help for the help system.Instance Variables!!HelpBrowser commentStamp: 'tbn 3/8/2010 09:33' prior: 0!A HelpBrowser is used to display a hierarchy of help topics and their contents.Instance Variables	rootTopic: 		<HelpTopic>	window:			<StandardWindow>	 	treeMorph:		<PluggableTreeMorph>	contentMorph:		<Morph>			rootTopic	- xxxxxwindow	- xxxxxtreeMorph 	- xxxxxcontentMorph 	- xxxxx!!HelpBuilder commentStamp: 'tbn 2/12/2010 14:54' prior: 0!This is an utility class that builds the books for a help system.Instance Variables	rootTopics:		<OrderedCollection>rootTopics	- a collection of books !!ClassAPIHelpBuilder commentStamp: 'tbn 4/30/2010 15:37' prior: 0!A builder to build the API Help for a classInstance Variables	addMethods:		<Boolean>	addSubclasses:		<Boolean>	subclassesAsSeparateTopic:		<Boolean>addMethods	- When true the builder will include method helpaddSubclasses	- When true the builder will recursively go through and add subclassessubclassesAsSeparateTopic	- xxxxx!!CustomHelpHelpBuilder commentStamp: 'tbn 3/29/2010 13:30' prior: 0!This builder builds help topics from a help topic description (which is typically storedin a class). The help topic description object has to understand the following messages:  #bookName - should return the name of the help book  #icon - should return the icon of the help book  #key - should return a unique key to identify the book  #pages - should return an array of method selectors to call to get the books pages!!HelpIcons commentStamp: 'tbn 3/8/2010 09:29' prior: 0!This class is used to store help icons for the help browser. Typically one implements a method returning a 12x12 Form instance whichshould not be called directly.Since the class provides an internal icon cache (so the icons can be reused without creating too many new instances) the icons should be accessed using the #iconNamed: message with the method selector as argument.To create a form from an icon file stored on disk you can use the following code:   | image stream |	image := ColorForm fromFileNamed: '/path/to/icon.png'.	stream := WriteStream with: String new.	image storeOn: stream.	stream contents inspect.!!HelpTopic commentStamp: 'tbn 3/29/2010 14:53' prior: 0!A HelpTopic provides content information that can be used as a help to the user.It can be labeled with a title, identified using an (optional) unique key and marked with an (optional) icon.Help topics form a hierarchy since any topic is able to have zero or moresubtopics. Instance Variables	contents:		<Object>      The help topic contents	icon:			<Form|nil>	   An optional icon for the topic	key:			<String|nil>    An optional unique key	subtopics:	      <Collection>  A collection of subtopics	title:			<String>        The titlecontents	- The help topic contents - typically containing the help topics informationicon	- An optional icon for the topickey	- An optional unique key which can be used to identify the topic. subtopics	- A collection of subtopics. 	  By default the subtopics are not sorted, so the insertion order is used. 	  If necessary it is possible to sort the subtopics by title.title	- A meaninful title for the help topic!!SystemHelp commentStamp: 'tbn 4/30/2010 15:33' prior: 0!This class defines Help for the system in front of you.It defines the default contents when you open a help browser.So "HelpBrowser open" is the same as "HelpBrowser openOn: SystemHelp".!!SystemReference commentStamp: 'tbn 4/30/2010 15:35' prior: 0!This class defines the full reference help for the system.(contents for the full API Help).Just run "HelpBrowser openOn: SystemReference".!!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:25'!asString	"Returns a string used as a label"		^item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!balloonText	"Returns a string used for fly by help"		^self item title! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:26'!contents	"Returns subnodes (if any)"	 	item hasSubtopics ifFalse: [^#()].		^(item subtopics) collect: [ :each | 		HelpTopicListItemWrapper with: each	].! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/8/2010 17:27'!highlightingColor	"Returns the text color when the receiver is selected in a list."	^Color blue  ! !!HelpTopicListItemWrapper methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:55'!icon	"Either return the icon for the given topic"		| symbol |	item icon notNil ifTrue: [^item icon].	symbol := item hasSubtopics 					 ifTrue: [#bookIcon] 			  		 ifFalse: [#pageIcon].	^HelpIcons iconNamed: symbol! !!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:26'!accept: aSelector title: title contents: text	"Accept edited text. Compile it into a HelpTopic"	| code |	code := String streamContents:[:s|		s nextPutAll: aSelector.		s crtab; nextPutAll: '"This method was automatically generated. Edit it using:"'.		s crtab; nextPutAll: '"', self name,' edit: ', aSelector storeString,'"'.		s crtab; nextPutAll: '^HelpTopic'.		s crtab: 2; nextPutAll: 'title: ', title storeString.		s crtab: 2; nextPutAll: 'contents: '.		s cr; nextPutAll: (String streamContents:[:c| c nextChunkPutWithStyle: text]) storeString.		s nextPutAll:' readStream nextChunkText'.	].	self class 		compile: code		classified: ((self class organization categoryOfElement: aSelector) ifNil:['pages']).! !!CustomHelp class methodsFor: 'converting' stamp: 'tbn 3/29/2010 13:17'!asHelpTopic	"Convert the receiver to a help topic"		^self builder buildHelpTopicFrom: self! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!bookName	"Returns the name of the custom help book"		^'Help'! !!CustomHelp class methodsFor: 'defaults' stamp: 'tbn 3/29/2010 13:24'!builder	"Returns the builder that is used to build the given help book from the receiver. You can override this method	 in a subclass to provide an own builder".		^CustomHelpHelpBuilder! !!CustomHelp class methodsFor: 'editing' stamp: 'ar 4/20/2010 23:24'!edit: aSelector	"Open a Workspace on the text in the given selector.	When accepted, compile the result as a help topic."	| topic window |	topic := (self respondsTo: aSelector) 			ifTrue:[self perform: aSelector]			ifFalse:[HelpTopic title: 'Untitled' contents: 'Please edit this topic. To change the topic title, edit the window label.'].	window := UIManager default		edit: topic contents		label: topic title		accept: [:text| self accept: aSelector title: window label contents: text].! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!icon	"Returns an icon used for displaying the custom help book"		^HelpIcons iconNamed: #bookIcon! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:18'!key	"Returns a unique key identifying the receiver in the help system"		^''! !!CustomHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 13:20'!pages 	"Returns a collection of method selectors to return the pages of the custom help book"			^#()! !!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:50'!bookName	^'API Documentation'! !!HelpAPIDocumentation class methodsFor: 'defaults' stamp: 'tbn 3/11/2010 23:57'!builder	^PackageAPIHelpBuilder! !!HelpAPIDocumentation class methodsFor: 'accessing' stamp: 'tbn 3/11/2010 23:55'!packages	^#('HelpSystem-Core-Model' 'HelpSystem-Core-Utilities' 'HelpSystem-Core-UI')! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:47'!bookName	^'Implementation'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:59'!overview	^HelpTopic 		title: 'Overview'		contents:		'THE IMPLEMENTATIONThe help system typically consists of help books including one or more pages. A book or page is therefore a "topic of interest"  providing contents for help to a user. A topic has a title and an icon and is able to have subtopics forming a hierarchy of topics. This simple model is reflected in the class HelpTopic.Since this model forms a hierarchical structure of help topics there is a browser with a tree to display the help contents. This browser is implemented in class HelpBrowser.You can open this browser programmatically using:   HelpBrowser open' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page1	^HelpTopic 		title: '1. Simple help topics'		contents: 'The help browser usually operates on a hierarchy of help topics with one help topic at the root level. Evaluate the following expression in a workspace to contruct a simple help topic and open it as a root topic in the help browser.				|root|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.									HelpBrowser openOn: root				Note that the help browser displays the contents of our topic in the right page and uses the topics title as the title for the help browser window.			'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:03'!page2	^HelpTopic 		title: '2. Forming a hierarchy'		contents: 'To form a hierarchy we just have to add new subtopics on our root topic.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 			title: ''My second subtopic''			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 14:10'!page3	^HelpTopic 		title: '3. Adding icons'		contents: 'If you dont like the default icon you can add own custom icons to the topics. See the class HelpIcons for more details.				|root sub1 sub2|		root := HelpTopic 			title: ''My first topic''			contents: ''A simple topic of interest''.				sub1 := HelpTopic 			title: ''My first subtopic''			contents: ''First subsection''.				sub2 := HelpTopic 		     			title: ''My second subtopic''			 icon: (HelpIcons iconNamed: #packageIcon)			contents: ''Second subsection''.				root 			addSubtopic: sub1; 			addSubtopic: sub2.		HelpBrowser openOn: root				'! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 15:01'!page4	^HelpTopic 		title: '4. Own help objects'		contents:		'You can open this help browser directly on an instance of HelpTopic, but it is more common to open it on any object that understands the message #asHelpTopic.So you can write for instance:   HelpBrowser openOn: Integeropening a short API help/system reference on the Integer class.The above expression is the short form for:   HelpBrowser openOn: (SystemReference forClass: Integer)If you want you can include the subclasses:   HelpBrowser openOn: (SystemReference hierarchyFor: Integer)or even methods   HelpBrowser openOn: (SystemReference hierarchyWithMethodsFor: Integer)You can browse the whole system reference documentation using:    HelpBrowser openOn: SystemReferenceBut these are only a few examples what we can extract from the system. However - the major goal is NOT an API browser, the idea is to provide a simple architecture to provide browsable help contents depending on the context. For instance it should also be possibleto use the help system to provide end user help on any commercialapplication that is written with the Smalltalk system.' ! !!HelpHowToHelpTopics class methodsFor: 'pages' stamp: 'tbn 3/29/2010 19:23'!page5	^HelpTopic 		title: '5. Help sources'		contents:		'Since the underlying model is very simple you can easily fill it with nearly any information from different sources. Try this:|topic day url sub|topic := HelpTopic named: ''Last week on Squeak IRC''.0 to: 7 do: [:index |	day := (Date today subtractDays: index) printFormat: #(3 2 1 $. 1 2 2).	url := ''http://tunes.org/~nef/logs/squeak/'' , day.	sub := HelpTopic 			title: day contents: (HTTPLoader default retrieveContentsFor: url) contents.	topic addSubtopic: sub.].HelpBrowser openOn: topic  ' ! !!HelpHowToHelpTopics class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 19:21'!pages	^#(overview page1 page2 page3 page4 page5)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:06'!bookName	^'Custom help from code'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:52'!overview	^HelpTopic		title: 'Overview'		contents:		'OVERVIEW	The help system allows you to provide own books and help texts. You can open the help browser on any object that is able to understand #asHelpTopic.This method returns the root node of the displayed topic hierarchy:      HelpBrowser openOn: myObjectTypically the object does not convert itself to a help topic structure, usually it dispatches to a builder (see HelpBuilder and subclasses) who does all this. 	A much more convenient and reproducable way is to implement custom help classes. This allows you to implement and manage your help texts using the standard development and code management tools. These custom help classes are subclasses of "CustomHelp" and are automatically included into the standard help browser. '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 23:57'!pages	^#(overview step1 step2 step3 step4 step5)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step1	^HelpTopic 		title: 'Step 1 - Create a class for the book'		contents:		'STEP 1 - CREATE A CLASS FOR THE BOOK		There is a predefined class CustomHelp which you have to subclass for a custom help book to show up as a book in the Help browser:	  CustomHelp subclass: #MyAppHelp    	instanceVariableNames: ''''	  classVariableNames: ''''	  poolDictionaries: ''''	  category: ''MyApp-Help'' Class methods on this class can reflect pages and if you want to provide nested help books just subclass your own help class to form a hierarchy. Any new subclass of MyAppHelp will then be a new book in your hierarchy.The class category used should end with "-Help" so it is easy to recognize that it includes the help support of your project.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:36'!step2	^HelpTopic		title: 'Step 2 - Provide a book name'		contents:	'STEP 2 - PROVIDE A BOOK NAME	Now implement the class method #bookName to return the name of your help book.   bookName	    ^''My App help''	By implementing this method the system knows how you would like to name your book and uses the given string as a label in the HelpBrowser later.'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/29/2010 13:41'!step3	^HelpTopic		title: 'Step 3 - Implement pages using methods'		contents:	'STEP 3 - IMPLEMENT PAGES USING METHODS Implement a page by defining a method that returns an instance of HelpPage defining a page title and a help text displayed in the help browser.      firstPage     	    ^HelpTopic	           title: ''First Page''                  contents: ''Hello world''Define a new method for each page of your book. Please group the pages in a method category called "pages".You can also define an icon for the specific page:     secondPage     	    ^HelpTopic	           title: ''Second Page''     	           icon: (HelpIcons iconNamed: #packageIcon)                 contents: ''More to come''Note: =====Later we may add support for better help contents than just plain text (markup descriptions, active morphs, ...)  '! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/5/2010 21:41'!step4	^HelpTopic		title: 'Step 4 - Defining the page order'		contents:	'STEP 4 - DEFINING THE PAGE ORDER By implementing the class method #pages you return a collection of method selectors to define the order in which the pages appear in your book:      pages     	    ^#(firstPage secondPage)'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 3/28/2010 22:56'!step5	^HelpTopic		title: 'Step 5 - Test your help'		contents:	'STEP 5 - TEST YOUR HELP	By using              HelpBrowser open '! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:21'!bookName	^'Help on Help'! !!HelpOnHelp class methodsFor: 'pages' stamp: 'hjh 4/21/2010 16:59'!introduction	"This method was automatically generated. Edit it using:"	"HelpOnHelp edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'WELCOME TO THE HELP SYSTEMThe help system is a simple user interface to display help contents to the user. It can be accessed from the world menu using "Tools" -> "Help Browser" or by evaluating ''HelpBrowser open'' in a workspace.There is a predefined mechanism allowing you to have help contents stored as source code using methods in specific help provider classes. This allows to manage the help texts using the standard development tools. But this is only one possible representation.Yes, this is a good solution.!!' readStream nextChunkText! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:56'!key	^'HelpOnHelp'! !!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 3/29/2010 14:48'!pages	^#(introduction)! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'hjh 4/21/2010 11:06'!defaultHelpBrowser	^self ! !!HelpBrowser class methodsFor: 'class initialization' stamp: 'mha 5/2/2010 15:51'!initialize	"Initializes the receiver class" 	self isPharo11		ifFalse: [ TheWorldMenu registerOpenCommand: {'Help Browser'. {self. #open}}. ].			"self open"! !!HelpBrowser class methodsFor: 'private' stamp: 'tbn 3/29/2010 12:32'!isPharo11	"Return true if we are in Pharo 1.1."		^(SystemVersion current version includesSubString: '1.1')! !!HelpBrowser class methodsFor: 'private' stamp: 'tbn 3/29/2010 12:46'!isSqueak	"Return true if we are in Squeak"		^(SystemVersion current version includesSubString: 'Squeak')! !!HelpBrowser class methodsFor: 'world menu' stamp: 'tbn 3/28/2010 21:12'!menuCommandOn: aBuilder 	<worldMenu> 	(aBuilder item: #'Help Browser')		parent: #Tools;		action:[self open]; 		icon: (HelpIcons iconNamed: #bookIcon)! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 4/22/2010 17:01'!open	^self defaultHelpBrowser openOn: SystemHelp! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 3/8/2010 08:50'!openOn: aHelpTopic	"Open the receiver on the given help topic or any other object that can be transformed into	 a help topic by sending #asHelpTopic."		^(self new)		rootTopic: aHelpTopic asHelpTopic;		open;		yourself! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 2/12/2010 12:57'!close	window notNil ifTrue: [window delete]! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 3/5/2010 22:27'!defaultRoot	^CustomHelp! !!HelpBrowser methodsFor: 'defaults' stamp: 'tbn 4/30/2010 12:39'!defaultViewerClass	 	^PluggableTextMorph! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 3/29/2010 12:42'!initWindow		self class isSqueak 		ifTrue: [self initWindowInSqueak ]		ifFalse: [self initWindowInPharo ]! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 4/30/2010 12:40'!initWindowInPharo	| toolbar dock|	window := (Smalltalk at: #StandardWindow) new.	window model: self.		window title: 'Help Browser'.	toolbar := window newToolbar: {window			newButtonFor: self			getState: nil			action: #refresh			arguments: nil			getEnabled: nil			labelForm: (HelpIcons iconNamed: #refreshIcon)			help: 'Refresh' translated.			}.				dock := window newToolDockingBar.		dock addMorphBack: toolbar.	window			addMorph: dock			fullFrame: (LayoutFrame fractions: (0@0 corner: 1@0) offsets: (0@0 corner: 0 @ dock minExtent y)).	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window 		addMorph: treeMorph 		fullFrame: (LayoutFrame fractions: (0@0 corner: 0.3@1) offsets: (0@dock minExtent y corner: 0 @ 0)).	"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph fullFrame: (LayoutFrame fractions: (0.3@0 corner: 1@1) offsets: (0@dock minExtent y corner: 0 @ 0)).	 	 ! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 4/30/2010 12:39'!initWindowInSqueak	window := SystemWindow labelled: 'Help Browser'.	window model: self.	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph frame: (0@0 corner: 0.3@1).		"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph frame: (0.3@0 corner: 1@1).					! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:39'!initialize 	super initialize. 	self initWindow. ! !!HelpBrowser methodsFor: 'events' stamp: 'tbn 3/8/2010 15:17'!onItemClicked: anItem	anItem isNil ifTrue: [^contentMorph setText: rootTopic contents].	contentMorph setText: anItem contents! !!HelpBrowser methodsFor: 'ui' stamp: 'tbn 3/3/2010 23:32'!open	 	"Open the receivers window" 	self refresh.		window openInWorld.	 ! !!HelpBrowser methodsFor: 'actions' stamp: 'tbn 3/29/2010 12:44'!refresh	|items|	window setLabel: rootTopic title.	items := rootTopic subtopics collect: [:each | HelpTopicListItemWrapper with: each ].	treeMorph list: items.	contentMorph setText: rootTopic contents! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/5/2010 22:56'!rootTopic	^rootTopic! !!HelpBrowser methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:11'!rootTopic: aHelpTopic	rootTopic := aHelpTopic. 	self refresh ! !!ClassAPIHelpBuilder class methodsFor: 'building' stamp: 'tbn 3/11/2010 23:39'!buildHierarchicalHelpTopicFrom: aClass withSubclasses: aBoolean withMethods: anotherBoolean	"Start building from the given class"		^(self new)		addSubclasses: aBoolean;		addMethods: anotherBoolean;		rootToBuildFrom: aClass;		build;		topicToBuild ! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods	^ addMethods! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:26'!addMethods: anObject	addMethods := anObject! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses	^ addSubclasses! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:02'!addSubclasses: anObject	addSubclasses := anObject! !!ClassAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:39'!build	| instanceSide classSide |	topicToBuild := (HelpTopic named: rootToBuildFrom name).	topicToBuild icon: (HelpIcons iconNamed: #pageIcon).	topicToBuild contents: rootToBuildFrom comment.		addMethods ifTrue: [ self buildSubnodesForMethods ].	addSubclasses	 ifTrue: [ self buildSubnodesForSubclasses ].	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 4/22/2010 09:26'!buildMethodTopicsOn: topic for: aClass	|stream comments methodComment|	stream := String new writeStream.	aClass selectors asSortedCollection do:			[:selector | 					  stream 				 nextPutAll: aClass name;			    nextPutAll: '>>';			  	 nextPutAll: selector asString;				 cr.					  comments := aClass commentsAt: selector.			  methodComment := (comments size = 0)									ifTrue: [ 'Method has no comment.' ]									ifFalse: [ comments first ].												  stream nextPutAll: methodComment;cr;cr.	].	topic contents: stream contents.		! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/8/2010 16:56'!buildSubclassTopicFor: aSubclass	 	^(self class new) 			rootToBuildFrom: aSubclass;			addSubclasses: addSubclasses;			addMethods: addMethods;			subclassesAsSeparateTopic: subclassesAsSeparateTopic;			build;			topicToBuild 	 ! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForMethods	| instanceSide classSide |	instanceSide := HelpTopic named: 'Instance side'.	classSide := HelpTopic named: 'Class side'.	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topicToBuild 		addSubtopic: instanceSide;		addSubtopic: classSide.	self buildMethodTopicsOn: instanceSide for: rootToBuildFrom.		self buildMethodTopicsOn: classSide for: rootToBuildFrom class.	! !!ClassAPIHelpBuilder methodsFor: 'private building' stamp: 'tbn 3/23/2010 21:40'!buildSubnodesForSubclasses	| topic |	rootToBuildFrom subclasses isEmpty ifTrue: [^self].	topicToBuild icon: (HelpIcons iconNamed: #bookIcon).	topic := subclassesAsSeparateTopic 				ifTrue: [topicToBuild addSubtopic: (HelpTopic named: 'Subclasses')]				ifFalse: [topicToBuild ].	rootToBuildFrom subclasses 		do: [:subclass | topic addSubtopic: (self buildSubclassTopicFor: subclass)].	topic sortSubtopicsByTitle.	! !!ClassAPIHelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 16:37'!initialize	"Initializes the receiver"		super initialize.	addSubclasses := false.	addMethods := true.	subclassesAsSeparateTopic := true.! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic	^ subclassesAsSeparateTopic! !!ClassAPIHelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:45'!subclassesAsSeparateTopic: anObject	subclassesAsSeparateTopic := anObject! !!CustomHelpHelpBuilder methodsFor: 'building' stamp: 'tbn 3/6/2010 00:28'!build	"Start building a help topic from a code description"		topicToBuild := self createTopicFrom: rootToBuildFrom ! !!CustomHelpHelpBuilder methodsFor: 'private' stamp: 'tbn 3/8/2010 09:17'!createTopicFrom: aDescription	"Create a topic from a description stored on a class"		|topic page method pragma   |	topic := HelpTopic named: aDescription bookName.	topic key: aDescription key.	topic icon: aDescription icon.		aDescription pages do: [:pageSelector|		page := aDescription perform: pageSelector.	 		topic addSubtopic: page.	].		aDescription subclasses do: [:subclass |		topic subtopics add: subclass asHelpTopic ].	^topic! !!HelpBuilder class methodsFor: 'building' stamp: 'tbn 3/5/2010 23:25'!buildHelpTopicFrom: aHelpTopicDescription	"Start building from the given help topic description"		^(self new)		rootToBuildFrom: aHelpTopicDescription;		build;		topicToBuild ! !!HelpBuilder methodsFor: 'building' stamp: 'tbn 3/3/2010 22:55'!build	self subclassResponsibility ! !!HelpBuilder methodsFor: 'initialize-release' stamp: 'tbn 3/5/2010 23:12'!initialize 	"Initializes the receiver"		super initialize.	topicToBuild := self topicClass new.	 ! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:53'!rootToBuildFrom: anObject	rootToBuildFrom := anObject! !!HelpBuilder methodsFor: 'private accessing' stamp: 'tbn 3/5/2010 23:13'!topicClass	^HelpTopic! !!HelpBuilder methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:15'!topicToBuild	^topicToBuild! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!build 	|pTopic|	topicToBuild := (HelpTopic named: rootToBuildFrom bookName).	rootToBuildFrom packages do: [:package|		pTopic := HelpTopic named: package.		topicToBuild addSubtopic: pTopic.		self buildPackageTopic: pTopic.			]! !!PackageAPIHelpBuilder methodsFor: 'building' stamp: 'tbn 3/23/2010 21:28'!buildPackageTopic: pTopic 	| classTopic classes |	classes := (PackageInfo named: pTopic title) classes asSortedCollection: [:cl1 :cl2 | cl1 name < cl2 name].	classes	   do: [:aClass| 		classTopic := ClassAPIHelpBuilder buildHierarchicalHelpTopicFrom: aClass withSubclasses: false withMethods: true.		pTopic addSubtopic: classTopic	]! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 23:53'!blankIcon	^Form extent: 12 @ 1 depth:8! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:17'!bookIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 284817913 552924404 0 0 0 0 0 0 0 0 0 817149108 3747766882 4287730065 2679749049 549766340 0 0 0 0 0 0 1086110908 4016202338 4287137928 4288914339 4288914339 4289111718 3216290996 1086505666 0 0 0 816754350 4014952271 4287137928 4289309097 4289769648 4289111718 4288453788 4288453788 4288453788 2947658161 0 814846353 4283782485 4287072135 4288059030 4288059030 4288387995 4289243304 4289309097 4287927444 4287598479 2411050421 1081900156 4283585106 4286611584 4287532686 4287532686 4287466893 4287466893 4287401100 4287401100 4287401100 4288716960 2946868645 3211290728 4288651167 4287269514 4287006342 4287006342 4287006342 4286940549 4286940549 4287203721 4289177511 3483213213 281725642 2677183122 4293190884 4292861919 4289177511 4286874756 4286611584 4286611584 4287006342 4289638062 4020084125 549042617 0 282054607 2677643673 4289572269 4293256677 4292796126 4288980132 4287137928 4290164406 4020215711 816754350 0 0 0 0 551082200 2677643673 4289572269 4293256677 4292401368 4289177511 1085584564 0 0 0 0 0 0 0 551213786 2677643673 4288651167 1623244992 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:54'!iconNamed: aSymbol	^self icons at: aSymbol ifAbsentPut: [self perform: aSymbol]! !!HelpIcons class methodsFor: 'accessing' stamp: 'tbn 2/12/2010 15:55'!icons	Icons isNil ifTrue: [Icons := Dictionary new].	^Icons! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/6/2010 01:23'!packageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 1075649821 3744937783 3208395836 807016986 0 0 0 0 0 0 537857807 2939368243 4283256141 4284045657 4284572001 4284111450 2671524924 269488144 0 0 0 2150575919 4014820685 4284111450 4284374622 4284769380 4285098345 4285295724 4286216826 4017057647 1883456323 0 1076505130 4283848278 4284769380 4284966759 4285624689 4285690482 4285887861 4286611584 4287269514 4287861651 4287269514 1074597133 1076965681 4283914071 4283848278 4285953654 4286216826 4286414205 4286940549 4287466893 4287335307 4286808963 4286743170 1074399754 1077163060 4284637794 4284045657 4284835173 4285887861 4287269514 4287335307 4286282619 4286216826 4286874756 4287006342 1074465547 1077294646 4284835173 4284703587 4285361517 4285624689 4286414205 4285624689 4286085240 4286677377 4287269514 4287401100 1074465547 1077426232 4285098345 4285032552 4286019447 4285822068 4286743170 4286348412 4286677377 4287203721 4287730065 4287795858 1074531340 1077492025 4285229931 4285427310 4286808963 4286216826 4287137928 4287072135 4287401100 4287795858 4288256409 4288190616 1074531340 269356558 2672051268 4285493103 4287598479 4286940549 4287532686 4287795858 4287993237 4288387995 4287006342 2404668500 268501249 0 0 1075912993 3479726184 4287598479 4287927444 4288453788 4287993237 2943118444 539371046 0 0 0 0 0 0 1615086660 4017781370 3749148535 1078347334 0 0 0 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 2/12/2010 14:18'!pageIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 221196079 1366981242 1366915449 1366915449 1366849656 1366783863 1128876361 33554432 0 0 0 0 726552142 4294309365 4294243572 4294111986 4294046193 4293914607 4292861919 2843705215 319885585 0 0 0 726551886 4294177779 4294111986 4293980400 4293914607 4293848814 4293717228 4292138196 3734147730 269619730 0 0 726486349 4294046193 4293980400 4293914607 4293783021 4293717228 4293585642 4293454056 4291085508 639705377 0 0 726420557 4293980400 4293848814 4293783021 4293651435 4293585642 4293519849 4293388263 4292993505 640034342 0 0 726420556 4293848814 4293717228 4293651435 4293585642 4293454056 4293388263 4293256677 4293190884 623322919 0 0 726354764 4293717228 4293651435 4293519849 4293454056 4293322470 4293256677 4293125091 4293059298 623257126 0 0 726354507 4293585642 4293519849 4293388263 4293322470 4293190884 4293125091 4293059298 4292993505 623191333 0 0 726288970 4293454056 4293388263 4293256677 4293190884 4293125091 4292993505 4292993505 4292993505 623191333 0 0 726223178 4293322470 4293256677 4293190884 4293059298 4292993505 4292993505 4292993505 4292993505 623191333 0 0 726223177 4293256677 4293125091 4293059298 4292993505 4292993505 4292993505 4292993505 4292993505 623191333 0 0 490092087 3080033685 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 3079967892 454629657 0)	offset: 0@0)! !!HelpIcons class methodsFor: 'private icons' stamp: 'tbn 3/3/2010 00:47'!refreshIcon	^(Form		extent: 16@16		depth: 32		fromArray: #( 0 0 0 0 0 0 0 895969127 526080859 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1884706390 4168710521 2288675434 271330348 0 0 0 0 0 0 0 0 0 828465505 2609087363 3615917702 4269439610 4285887861 4285624689 3899156584 1766607948 67569415 0 0 0 0 0 50529027 2306242166 4237069452 4286940549 4286611584 4286282619 4285887861 4285558896 4285229931 4268189543 2235514687 0 0 0 0 0 2590862701 4287598479 4287269514 4270097540 3329652342 3312217196 4285887861 4285558896 3345179491 1011567435 0 0 0 0 0 1263423054 4287532686 4287532686 3867378563 1096835168 0 1885166941 3681579120 1549227863 50923785 0 0 0 0 0 0 3061545851 4287795858 4236937866 811951461 0 0 641547581 137441585 0 0 0 0 0 0 0 34936085 4102720138 4287795858 3011016824 0 0 0 0 0 0 0 0 0 0 0 0 272317243 4287861651 4287795858 2489607268 0 0 0 0 0 0 0 0 68095759 0 0 0 204682035 4287730065 4287795858 2658432116 0 0 0 0 0 0 0 34014983 3965146967 4283979864 3125694030 0 0 3767044232 4287795858 3884287365 137244206 0 0 0 0 0 0 1129863256 4284769380 4284506208 2739423304 0 0 2189459584 4287795858 4287532686 2541123190 16843009 0 0 0 0 305805882 3597166696 4284703587 4250885983 910114623 0 0 273698896 3834218889 4287532686 4287335307 3094442353 1094532413 101255433 286199567 1582124365 3731318631 4284966759 4284703587 2689946965 0 0 0 0 879126118 3985082247 4287269514 4286940549 4286611584 4285624689 4285558896 4285624689 4285229931 4284966759 3227212635 220998700 0 0 0 0 0 509698401 2977659771 4286743170 4286545791 4286282619 4285887861 4285558896 4100417383 2170116441 103295016 0 0 0 0 0 0 0 0 575820370 1734895720 2121298032 2037017194 1448564567 255013683 0 0 0 0 0)	offset: 0@0)! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!named: aString	"Create a new instance with given title and empty contents"		^(self new)		title: aString;		yourself! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle contents: aText	"Create a new instance with given title and content"		^(self new)		title: aTitle;		contents: aText;		yourself.		! !!HelpTopic class methodsFor: 'instance creation' stamp: 'tbn 3/29/2010 13:16'!title: aTitle icon: anIcon contents: aText	"Create a new instance with given title, icon and content"		^(self new)		title: aTitle;		icon: anIcon;		contents: aText;		yourself.		! !!HelpTopic methodsFor: 'comparing' stamp: 'tbn 3/8/2010 09:11'!<= anotherHelpTopic	"Use sorting by title as the default sort order"		^self title <= anotherHelpTopic title ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/8/2010 16:40'!addSubtopic: aTopic	"Adds the given topic to the receivers collection of subtopics"		self subtopics add: aTopic.	^aTopic! !!HelpTopic methodsFor: 'conversion' stamp: 'tbn 3/8/2010 09:09'!asHelpTopic 	"Converts the receiver to a help topic"		^self! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents	"Returns the receivers contents"		^ contents! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!contents: anObject	"Sets the receivers contents to the given object" 			contents := anObject! !!HelpTopic methodsFor: 'defaults' stamp: 'tbn 3/5/2010 21:31'!defaultTitle	"Returns the receivers default title"		^'Unnamed Topic'	! !!HelpTopic methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:23'!hasSubtopics 	"Returns true if the receiver has subtopics, false otherwise"		^self subtopics notEmpty ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:19'!icon  	"Returns the receivers icon"		^icon! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!icon: aSymbol	"Sets the receivers icon"		icon := aSymbol ! !!HelpTopic methodsFor: 'initialize-release' stamp: 'tbn 3/8/2010 08:44'!initialize 	"Initializes the receiver"		super initialize.	self title: self defaultTitle.	self contents: ''.	self key: '' ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key 		"Returns a unique key identifying the receiver in the help system"				^key! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:20'!key: aUniqueKey	"Sets a unique key identifying the receiver in the help system"				key := aUniqueKey ! !!HelpTopic methodsFor: 'operating' stamp: 'tbn 3/8/2010 09:12'!sortSubtopicsByTitle	"Sort the subtopics by title"		subtopics := SortedCollection withAll: self subtopics  ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:21'!subtopics 	"Returns the receivers list of subtopics"		subtopics isNil ifTrue: [subtopics := OrderedCollection new].	^subtopics! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!subtopics: aCollection 	"Sets the receivers subtopics"		subtopics := aCollection ! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title	"Returns the receivers title"		^ title! !!HelpTopic methodsFor: 'accessing' stamp: 'tbn 3/6/2010 00:22'!title: anObject	"Sets the receivers title"		title := anObject! !!SystemHelp class methodsFor: 'conversion' stamp: 'tbn 3/8/2010 08:52'!asHelpTopic 	|topic helpOnHelp sortedTopics |	topic := CustomHelp asHelpTopic.	topic sortSubtopicsByTitle.	helpOnHelp := topic subtopics detect: [:t | t key = 'HelpOnHelp'] ifNone: [self error: 'Help for the help system is removed'].	sortedTopics := topic subtopics.	sortedTopics remove: helpOnHelp.	sortedTopics addLast: helpOnHelp.	topic subtopics: sortedTopics.	^topic.! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:01'!all	"HelpBrowser openOn: self all "		^(ClassAPIHelpBuilder new)		rootToBuildFrom: ProtoObject;		addSubclasses: true;		addMethods: true;		subclassesAsSeparateTopic: false;		build;		topicToBuild 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:04'!asHelpTopic 	"HelpBrowser openOn: SystemReference"		^self hierarchyFor: ProtoObject 	 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/11/2010 23:41'!forClass: aClass	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := ClassAPIHelpBuilder buildHelpTopicFrom: aClass.	root addSubtopic: topic.	^root! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:21'!hierarchyFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: false;					subclassesAsSeparateTopic: false;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!SystemReference class methodsFor: 'help topic creation' stamp: 'tbn 3/8/2010 17:23'!hierarchyWithMethodsFor: aClass	 	|root topic |	root := HelpTopic named: 'System reference for ', aClass name.	topic := (ClassAPIHelpBuilder new)					rootToBuildFrom: aClass;					addSubclasses: true;					addMethods: true;					subclassesAsSeparateTopic: true;					build;					topicToBuild.	root addSubtopic: topic.	^root					 		 ! !!Class methodsFor: '*HelpSystem-Core' stamp: 'tbn 3/11/2010 23:42'!asHelpTopic	^SystemReference forClass: self! !"HelpSystem-Core"!!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:33'!testDefaultBuilding	|topic|	topic := ClassAPIHelpBuilder 				buildHelpTopicFrom: Integer.				 	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!ClassAPIHelpBuilderTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:32'!testMethodsButNoSubclasses	|topic|	topic := ClassAPIHelpBuilder 				buildHierarchicalHelpTopicFrom: Integer 				withSubclasses: false 				withMethods: true.	self assert: topic subtopics size = 2.	self assert: topic subtopics first title = 'Instance side'.	self assert: topic subtopics last title = 'Class side'  ! !!HelpBrowserTest methodsFor: 'accessing' stamp: 'tbn 3/2/2010 23:21'!defaulTestClass	^HelpBrowser! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 3/2/2010 23:20'!testOpen	|block|	block := [		|browser|		browser := self defaulTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Exception		! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 4/8/2010 12:05'!testRegistration	"there is no world menu in 1.1."      HelpBrowser isPharo11 ifTrue: [^self].	TheWorldMenu registeredOpenCommands detect: [:each | each first = 'Help Browser'] ifNone: [self fail].	! !!HelpIconsTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 14:23'!defaultTestClass 	^HelpIcons! !!HelpIconsTest methodsFor: 'testing' stamp: 'tbn 3/3/2010 00:50'!testIconCaching	 	| first second |	#(bookIcon pageIcon refreshIcon) do: [:iconSymbol |		first := self defaultTestClass iconNamed: iconSymbol.		second := self defaultTestClass iconNamed: iconSymbol.			self assert: first notNil.		self assert: first == second.	]	! !!HelpTopicListItemWrapperTest methodsFor: 'accessing' stamp: 'tbn 2/12/2010 13:16'!defaultTestClass 	^HelpTopicListItemWrapper 	! !!HelpTopicListItemWrapperTest methodsFor: 'testing' stamp: 'tbn 3/5/2010 21:46'!testDisplayLabel	|instance|	instance := self defaultTestClass with: (HelpTopic named: 'My Topic').	self assert: instance asString = 'My Topic'	! !!HelpTopicTest methodsFor: 'accessing' stamp: 'tbn 3/5/2010 21:47'!defaultTestClass	^HelpTopic ! !!HelpTopicTest methodsFor: 'running' stamp: 'tbn 3/5/2010 21:49'!setUp	super setUp.	topic := self defaultTestClass new.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/8/2010 16:44'!testAddingSubtopic	|subtopic returned|	subtopic := self defaultTestClass named: 'Subtopic'.	returned := topic addSubtopic: subtopic.	self assert: returned == subtopic.	self assert: (topic subtopics includes: subtopic) ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:07'!testInitialization	self assert: topic title = 'Unnamed Topic'.	self assert: topic key isEmpty.	self assert: topic contents isEmpty ! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testInstanceCreation	|instance|	instance := self defaultTestClass named: 'My Topic'.	self assert: instance title = 'My Topic'.! !!HelpTopicTest methodsFor: 'testing' stamp: 'tbn 3/6/2010 00:06'!testSortOrder	|a b c sorted |	a := self defaultTestClass named: 'A'.	b := self defaultTestClass named: 'B'.	c := self defaultTestClass named: 'C'.	sorted := (OrderedCollection with: b with: c with: a) asSortedCollection.	self assert: sorted first = a.	self assert: sorted last = c.	! !"HelpSystem-Tests"!!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:11'!bookName 	^'Squeak'! !!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 3/5/2010 23:30'!icon	(self name = #SqueakHelp) ifTrue: [^HelpIcons iconNamed: #squeakIcon].	^nil! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:16'!bookName 	^'License'! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'hjh 4/29/2010 16:48'!licenseChange	^HelpTopic 		title: 'License has changed with 4.0'		contents: 'On 23 September 1996, Apple Computer Inc. released Squeak V1.1 under the "Squeak License" (SqL).On May 8, 2006 Apple agreed to relicense original Squeak V1.1 under the Apple Public Source License.On October 12, 2006 Apple granted permission to relicense under Apache license 2.0.In 2006, VPRI began to collect "Distribution Agreements" for all contributors to Squeak since V1.1 up to V3.8, asking them to relicense their contributions, which were originally licensed under SqL, to the MIT license. This was a great effort on behalf of many and VPRI has 100s of signed documents agreeing to this.Do you want to contribute source to Squeak?All new contributions since 4.0 must be under the MIT license. When you make your code available, please state explicitly in some form such as the description on a web site or email announcement that your contribution is under the MIT license. (It doesn''t have to be exclusive; you can release it under difference licenses at the same time.)Have you contributed source to Squeak? If you believe you have, but have not sent in an agreement to allow your submission(s) to be licensed under the MIT license then please see http://netjam.org/squeak/contributors. There you can find a list of known contributors and a PDF of the agreement with instructions. The snail mail address is found in the agreement PDF file.Also there are a few people for which we are lacking full contact information. If you think you can help please also visit the link above and see if you can identify any of the unknown developer initials or any of the developers for whom we do not have a current email address.' ! !!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'mha 5/2/2010 17:35'!officialLicense	^HelpTopic 		title: 'Official License - 4.0'		contents: 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2010 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !!SqueakLicenseHelp class methodsFor: 'accessing' stamp: 'mha 5/2/2010 17:26'!pages	^#(licenseChange officialLicense)! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:13'!bookName 	^'Squeak Project'! !!SqueakProjectHelp class methodsFor: 'pages' stamp: 'tbn 3/5/2010 22:01'!introduction	^HelpTopic		title: 'Welcome'		icon: (HelpIcons iconNamed: #squeakIcon)		contents:'WELCOMESqueak is a modern, open source, full-featured implementation of the powerful Smalltalk programming language and environment. Squeak is highly-portable - even its virtual machine is written entirely in Smalltalk making it easy to debug, analyze, and change. Squeak is the vehicle for a wide range of projects from multimedia applications, educational platforms to commercial web application development.'! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 2/19/2010 14:15'!pages	^#(introduction )! !!HelpIcons class methodsFor: '*help-squeak-project' stamp: 'mha 5/2/2010 20:58'!squeakIcon	^(Form	extent: 12@12	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 75398782 26843545 0 0 1159996452 1378823983 338044454 0 0 0 0 455682345 1295266868 1126376227 0 0 1040582150 0 1328097577 0 0 0 23488102 1277502757 0 1076834095 0 0 1075781407 0 287647013 472854319 0 0 471472666 204089898 0 1092756002 0 0 1041963803 36909875 0 1880232466 454761243 287515427 1342572038 0 104939841 974460181 0 0 270080281 354690084 86846765 3674539269 1394219546 1611599631 3557427722 86123042 388244516 204287277 0 26843545 605558808 1025055001 1008014613 1159141143 522264865 739710743 1159141143 571083274 570820102 188891714 0 942550574 1411391520 1143021857 1312241463 1428563494 3205040393 3708159494 1663576104 1511067921 1579887403 1629758500 958472481 656679972 439563059 1294608938 839913488 739644950 172246084 221459251 840900383 1075978786 1209933342 724512559 707077413 0 0 0 0 0 0 0 0 0 0 38488907 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: 0@0)! !"Help-Squeak-Project"!!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtFirst	"Add new empty slots to the front of array, while keeping the empty slots at the end."	| newArray newFirstIndex newLastIndex |	newArray := Array new: (array size * 2 max: 1).	newFirstIndex := newArray size - array size + firstIndex.	newLastIndex := newFirstIndex + lastIndex - firstIndex.	newArray 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array := newArray.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 17:29'!growAtLast	"Add new empty slots to the end of array, while keeping the empty slots at the front."	| newArray |	newArray := Array new: (array size * 2 max: 1).	newArray 		replaceFrom: firstIndex		to: lastIndex		with: array		startingAt: firstIndex.	array := newArray! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42' prior: 25258393!makeRoomAtFirst	"Make some empty slots at the front of the array. If we have more than 50% free space, then just move the elements, so that the first 50% of the slots are free, otherwise add new free slots to the front by growing. Precondition: firstIndex = 1"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= array size ifTrue: [ ^self growAtFirst ].	tally = 0 ifTrue: [ ^self resetTo: array size + 1 ].	newFirstIndex := array size // 2 + 1.	newLastIndex := newFirstIndex - firstIndex + lastIndex.	0 to: tally - 1 do: [ :offset |		array at: newLastIndex - offset put: (array at: lastIndex - offset) ].	array from: firstIndex to: newFirstIndex - 1 put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:42' prior: 25258899!makeRoomAtLast	"Make some empty slots at the end of the array. If we have more than 50% free space, then just move the elements, so that the last 50% of the slots are free, otherwise add new free slots to the end by growing. Precondition: lastIndex = array size"		| tally newFirstIndex newLastIndex |	tally := self size.	tally * 2 >= lastIndex ifTrue: [ ^self growAtLast ].	tally = 0 ifTrue: [ ^self resetTo: 1 ].	newLastIndex := lastIndex // 2.	newFirstIndex := newLastIndex - lastIndex + firstIndex.	array 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array from: newLastIndex + 1 to: lastIndex put: nil.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'ul 5/10/2010 13:20' prior: 25259891!reset	self resetTo: 1! !!Collection methodsFor: 'enumerating' stamp: 'ar 5/4/2010 08:40'!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	| first nextValue |	self emptyCheck.	first := true.	self do:[:each|		first ifTrue:[nextValue := each. first := false]			ifFalse:[nextValue := binaryBlock value: nextValue value: each]].	^nextValue! !!Collection methodsFor: 'math functions' stamp: 'ar 5/4/2010 08:38' prior: 18835941!sum	"Compute the sum of all the elements in the receiver"	^self reduce:[:a :b| a + b]! !OrderedCollection removeSelector: #growSize!OrderedCollection removeSelector: #grow!"Collections"!!WeakSetTest methodsFor: 'tests' stamp: 'ul 5/3/2010 20:13'!testDoAfter	| input weakSet array |	input := (1 to: 11) collect: [ :each | each asString asSymbol ]. "Some symbols might be garbage collected without this variable"	weakSet := WeakSet withAll: input.	array := weakSet asArray. "Assume that the elements will have the same order as the internal array of the weakset"	0 to: array size do: [ :index |		| element result |		element := array at: index ifAbsent: nil.		result := Array new: weakSet size - index streamContents: [ :stream |			weakSet				do: [ :each | stream nextPut: each ]				after: element ].		self assert: result sort = (array allButFirst: index) sort ]! !!WeakSetTest methodsFor: 'tests' stamp: 'ul 11/20/2009 22:53' prior: 53697582!testIncludes	| weakSet transientFakeNilObject |	weakSet := WeakSet new.	#(true nil 1) do: [ :each |		self deny: (weakSet includes: each) ].	weakSet add: true.	self assert: (weakSet includes: true).	weakSet remove: true.	self deny: (weakSet includes: true).	transientFakeNilObject := ((1 to: 1000) detect: [ :each | each asString hash - nil hash \\ weakSet capacity = 0 ]) asString. "this string will occupy the same slot as nil would"	weakSet add: transientFakeNilObject.	transientFakeNilObject := transientFakeNilObject copy.	Smalltalk garbageCollect. "get rid of transientFakeNilObject"	self deny: (weakSet includes: transientFakeNilObject).	self deny: (weakSet includes: nil)			! !!CollectionTest methodsFor: 'tests' stamp: 'ar 5/4/2010 08:52'!testReduce	"self run: #testReduce"	| array set bag |	array := Array with: 1 with: 2 with: 3.	self assert: (array reduce:[:a :b| a + b]) = 6.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = 6.	array := Array with: Color red with: Color green with: Color blue.	self assert: (array reduce:[:a :b| a + b]) = Color white.	set := array asSet.	self assert: (set reduce:[:a :b| a + b]) = Color white.	array := Array with: 1 with: 1 with: 1.	self assert: (array reduce:[:a :b| a + b]) = 3.	bag := array asBag.	self assert: (bag reduce:[:a :b| a + b]) = 3.! !!WeakFinalizersTest methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 22:15'!testNewFinalizationSupported	| list item |	list := WeakFinalizationList new.			item := WeakFinalizerItem new list: list object: Object new executor: nil.		self assert: (list first isNil).	self assert: (item object notNil).		Smalltalk garbageCollect.		self assert: (item object isNil).	self assert: (list first == item).	self assert: (list first next == nil).! !"CollectionsTests"!!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'topa 5/3/2010 11:26' prior: 54545818!refresh	| packageNames |	packageNames := Set new.	packageList := nil.	versions := repository readableFileNames collect: [ :each | | name |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: ((name copyAfterLast: $-) copyAfter: $.) asInteger	"version"					with: each]].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each | | latest |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor | | av |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:32'!definitionAndCommentString	^ String streamContents: [:stream |		self printDefinitionOn: stream.		stream cr; cr.		self printCommentOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 21:36'!printCommentOn: stream	stream		nextPut: $";		nextPutAll: self comment asString;		nextPut: $"! !!MCClassDefinition methodsFor: 'printing' stamp: 'dtl 5/5/2010 20:33' prior: 22807306!source	^ self definitionAndCommentString! !"Monticello"!!Categorizer commentStamp: 'nice 5/6/2010 21:10' prior: 0!A Categorizer goal is to classify the elements of a collection into categories.It is typically used to classify methods of class into categories (also named protocols in this case).Instance Variables	categoryArray:		<SequenceableCollection of: Object>	categoryStops:		<SequenceableCollection of: Integer>	elementArray:		<SequenceableCollection of: Object>categoryArray	- holds the list of categories.	A category could be any Object but is generally a String or Symbol.	Categories should be unique (categoryArray asSet size = categoryArray size)categoryStops	- holds the index of last element belonging to each category.	There should be a category stop for each category (categoryStops size = categoryArray size).	The categoryStops should be sorted (categoryStops sorted = categoryStops).	A category stop equal to its predecessor (= 0 for the first category stop) denotes an empty category.elementArray	- holds the elements to be classified. The elements are sorted by category.Class variables	Default is the default category used to classify yet unclassified methods of a class	NullCategory is the category to be displayed in a Browser for a class having no method.!!NumberParser methodsFor: 'parsing-public' stamp: 'nice 4/2/2010 20:25' prior: 57942725!nextIntegerBase: aRadix	"Form an integer with following digits.	Fail if no digit found"		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerBase: aRadix.	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!Number methodsFor: 'truncation and round off' stamp: 'wiz 3/1/2007 20:17'!roundDownTo: aNumber 	"Answer the next multiple of aNumber toward negative infinity that is nearest the 	receiver."	^(self/aNumber) floor * aNumber! !!SqNumberParser methodsFor: 'parsing-public' stamp: 'nice 2/24/2010 02:51' prior: 57953109!nextNumber	"main method for reading a number.	This one can read Float Integer and ScaledDecimal"		| numberOfTrailingZeroInIntegerPart |	base := 10.	neg := self peekSignIsMinus.	integerPart := self nextUnsignedIntegerOrNilBase: base.	integerPart ifNil: [		"This is not a regular number beginning with a digit		It is time to check for exceptional condition NaN and Infinity"		^self readNamedFloatOrFail].	numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero.	(sourceStream peekFor: $r)		ifTrue: ["<base>r<integer>"			(base := integerPart) < 2				ifTrue: [					sourceStream skip: -1.					^ self expected: 'an integer greater than 1 as valid radix'].			self peekSignIsMinus				ifTrue: [neg := neg not].			integerPart := self nextUnsignedIntegerBase: base.			numberOfTrailingZeroInIntegerPart := nDigits - lastNonZero].	^ (sourceStream peekFor: $.)		ifTrue: [self readNumberWithFractionPartNumberOfTrailingZeroInIntegerPart: numberOfTrailingZeroInIntegerPart]		ifFalse: [self makeIntegerOrScaledInteger]! !"Kernel"!!Encoder methodsFor: 'encoding' stamp: 'eem 5/16/2010 17:33' prior: 33688294!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode := scopeTable					at: name					ifAbsent: 						[(self lookupInPools: name 							ifFound: [:assoc | varNode := self global: assoc name: name])							ifTrue: [varNode]							ifFalse: [^action value]].	range ifNotNil:		[name first canBeGlobalVarInitial ifTrue:			[globalSourceRanges addLast: { name. range. false }]].	(varNode isTemp and: [varNode scope < 0]) ifTrue:		[^OutOfScopeNotification signal			ifTrue: [action value]			ifFalse: [self notify: 'out of scope']].	^varNode! !!LiteralVariableNode methodsFor: 'testing' stamp: 'eem 5/20/2010 09:12'!assignmentCheck: encoder at: location	^(key isVariableBinding and: [key canAssign not])		ifTrue: [location]		ifFalse: [-1]! !!LiteralVariableNode methodsFor: 'code generation (new scheme)' stamp: 'eem 5/20/2010 08:55' prior: 51566743!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !"Compiler"!!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!isolatedCodePaneForClass: aClass selector: aSelector	"Answer a MethodMorph on the given class and selector"	| aCodePane aMethodHolder |	aMethodHolder := self new.	aMethodHolder methodClass: aClass methodSelector: aSelector.	aCodePane := MethodMorph on: aMethodHolder text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aMethodHolder addDependent: aCodePane.	aCodePane borderWidth: 2; color: Color white.	aCodePane scrollBarOnLeft: false.	aCodePane width: 300.	^ aCodePane! !!MethodHolder class methodsFor: '*Etoys' stamp: 'ar 5/20/2010 19:56'!makeIsolatedCodePaneForClass: aClass selector: aSelector	"Create, and place in the morphic Hand, an isolated code pane bearing source code for the given class and selector"	(self isolatedCodePaneForClass: aClass selector: aSelector) openInHand! !"EToys"!!CharacterBlock commentStamp: 'mtf 5/15/2010 12:44' prior: 18447774!I describe the location of one character displayed on the screen. My instances are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the information I store stale.text (Text): The text where my character is fromstringIndex (Integer): The index of my character in the text, starting from 1textLine (TextLine): The displayed line my character is onorigin (Point): The top-left corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0corner (Point): The bottom-right corner of the area allocated for displaying my		character's glyph, in pixels, counting right then down from the		top-left corner of the text display area, and starting from 0@0!"Graphics"!!MCMcmWriter commentStamp: 'dtl 5/10/2010 22:20' prior: 0!An MCMcmWriter stores an MCConfiguration on a stream in the form of an array specification.!!MCConfiguration commentStamp: 'dtl 5/10/2010 23:03' prior: 0!An MCConfiguration specifies the configuration of a set of related Monticello packages. It maintains an ordered list of package versions and a list of repositories in which the packages may be found.An MCConfiguration may be filed out for storage as an array specification, and new instances can be created from a stored array specification.!!MCMcmUpdater commentStamp: 'dtl 5/10/2010 23:22' prior: 0!MCMcmUpdater provides utility methods for updating Monticello packages from Monticello configurations.When Monticello configurations are stored in a repository, MCMcmUpdater acts as an update stream. It first ensures that each configuration map has been loaded in sequence, then updates the last configuration map to the most recent version for each specified package, and finally loads these versions to produce a fully updated configuration. !!MCConfigurationBrowser commentStamp: 'dtl 5/10/2010 21:48' prior: 0!A MCConfigurationBrowser displays an MCConfiguration, and edits the configuration to add or remove package dependencies and repository specifications. It allows a configuration to be stored in a repository or posted to an update stream.!!MCMcmReader commentStamp: 'dtl 5/10/2010 22:22' prior: 0!A MCMcmReader creates an MCConfiguration by reading an array specification from a stream.!!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 21:11' prior: 22854648!dependencyMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add dependency...' addDependency)).	self selectedDependency ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove dependency' remove))].	^aMenu! !!MCConfigurationBrowser methodsFor: 'repositories' stamp: 'dtl 5/10/2010 21:01'!removeRepository	repositoryIndex > 0		ifTrue: [self repositories removeAt: repositoryIndex.			repositoryIndex := 0.			self changed: #repositoryList]! !!MCConfigurationBrowser methodsFor: 'morphic ui' stamp: 'dtl 5/10/2010 20:56' prior: 22856503!repositoryMenu: aMenu	self fillMenu: aMenu fromSpecs: #(('add repository...' addRepository)).	self selectedRepository ifNotNil: [		self fillMenu: aMenu fromSpecs: #(('remove repository' removeRepository))].	^aMenu! !"MonticelloConfigurations"!!Project commentStamp: 'tk 12/2/2004 12:38' prior: 59386593!A Project stores the state of a complete Squeak desktop, includingthe windows, and the currently active changeSet.  A project knows whoits parent project is.  When you change projects, whether by enteringor exiting, the screen state of the project being exited is saved inthat project.A project is retained by its view in the parent world.  It iseffectively named by the name of its changeSet, which can be changedeither by renaming in a changeSorter, or by editing the label of itsview from the parent project.As the site of major context switch, Projects are the locus ofswapping between the old MVC and the new Morphic worlds.  Thedistinction is based on whether the variable 'world' contains aWorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Projectnamed: 'xxx') exportSegment, or choose 'store project on file...'.Projects may be loaded from a server and stored back.  Storing on aserver never overwrites;  it always makes a new version.  A projectremembers the url of where it lives in urlList.  The list is lengthone, for now.  The url may point to a local disk instead of a server.All projects that the user looks at, are cached in the Squeakletfolder.  Sorted by server.  The cache holds the most recent versiononly.When a project is loaded into Squeak, its objects are converted tothe current version.  There are three levels of conversion.  First,each object is converted from raw bits to an object in its oldformat.  Then it is sent some or all of these messages:	comeFullyUpOnReload: smartRefStream  		Used tore-discover an object that already exists in this image, such as aresource, global variable, Character, or Symbol.  (sent to objects inoutPointers)	convertToCurrentVersion: varDict refStream: smartRefStrm		fill in fields that have been added to a class sincethe object was stored.  Used to set the extra inst var to a defaultvalue.  Or, return a new object of a different class.  (sent toobjects that changed instance variables)	fixUponLoad: aProject refStream: smartRefStrm	change the object due to conventions that have changed on theproject level.  (sent to all objects in the incoming project)Here is the calling sequence for storing out a Project:Project saveAsProject storeOnServerProject storeOnServerWithProgressInfoProject storeOnServerInnardsProject exportSegmentFileName:directory:Project exportSegmentWithChangeSet:fileName:directory:ImageSegment writeForExportWithSources:inDirectory:changeSet:---------Isolation (not used any more)When you accept a method, the entire system feels the change, exceptprojects that are "isolated".  In an isolated project, all new globalvariables (including new classes) arestored in the project-localenvironment, and all changes to preexisting classes are revoked whenyou leave the project.  When you enter another project, thatproject's changes are invoked.  Invocation and revocation are handledefficiently by swapping pointers.  To make a project be isolated,choose 'isolate changes of this project' from the 'changes...'section of the screen menu.  You can use an isolated project formaking dangerous change to a system, and you can get out if itcrashes.  A foreign application can have the separate environment itwants.  Also, you can freeze part of the system for a demo that youdon't want to disturb.  An isolated project shares methods with allsubprojects inside it, unless they are isolated themselves.   Eachisolated project is the head of a tree of projects with which itshares all methods.You may 'assert' all changes ever made in the current project to takeeffect above this project.  This amounts to exporting all the globalsin the current environment, and zapping the revocation lists to thatthe current state of the world will remain in force upon exit fromthis project.[Later: A project may be 'frozen'.  Asserts do not apply to it afterthat.  (Great for demos.)  You should be informed when an assert wasblocked in a frozen project.]Class definitions are layered by the isolation mechanism.  You areonly allowed to change the shape of a class in projects that liewithin its isolation scope.  All versions of the methods arerecompiled, in all projects.  If you remove an inst var that is inuse in an isolated project, it will become an Undeclared global.  Itis best not to remove an inst var when it is being used in anotherisolated project. [If we recompile them all, why can't we diagnosethe problem before allowing the change??]Senders and Implementors do not see versions of a method in isolatedprojects.  [again, we might want to make this possible at a cost].When you ask for versions of a method, you will not get the historyin other isolated projects.Moving methods and classes between changeSets, and merging changeSetshas no effect on which methods are in force.  But, when you look at achangeSet from a different isolated project, the methods will containcode that is not in force.  A changeSet is just a list of methodnames, and does not keep separate copies of any code.When finer grained assertion is needed, use the method (aProjectassertClass: aClass from: thisProject warn: warnConflicts).How isolated changes work: The first time a class changes, store itsMethodDictionary object.  Keep parallel arrays of associations toClasses and MethodDictionaries.  Traverse these and install them whenyou enter an "ioslated project".  When you leave, store thisproject's own MethodDictionaries there.	To do an assert, we must discover which methods changed here,and which changed only in the project we are asserting into.  Thereis one copy of the 'virgin' method dictionaries in the system.  It isalways being temporarily stored by the currently inForce isolatedproject.isolatedHead - true for the top project, and for each isolatedproject.  false or nil for any subproject that shares all methodswith its parent project.inForce -  true if my methods are installed now.  false if I amdormant. [is this equivalent to self == Project Current?]classArray - list of associations to classesmethodDictArray - the method dictionaries of those classes before westarted changing methods.  They hang onto the originalcompiledMethods.  (If this project is dormant, it contains the methoddictionaries of those classes as they will be here, in this project).orgArray - the class organizations of the classes in classArray.UsingIsolation (class variable) - No longer used.When you want to save a project in export format from within thatvery project, it gets tricky.  We set two flags in parentProject,exit to it, and let parentProject write the project.ProjectViewMorph in parentProject checks in its step method, does thestore, clears the flags, and reenters the subProject.!!Utilities class methodsFor: 'support windows' stamp: 'spd 5/24/2010 20:23' prior: 32903560!standardWorkspaceContents	^ self class firstCommentAt: #standardWorkspaceContents	"Smalltalk recover: 10000.ChangeList browseRecentLog.ChangeList browseRecent: 2000.Preferences editAnnotations.Flaps reinstateDefaultFlaps. Preferences resetCategoryInfo(FileStream oldFileNamed: 'Lives of the Wolves') edit.(FileStream oldFileNamed: 'tuesdayFixes.cs') fileInChangeList browseFile: 'myChanges.st'TextStyle default fontAt: 7 put: (StrikeFont new readMacFontHex: 'Cairo 18')StandardSystemView browseAllAccessesTo: 'maximumSize'.StandardSystemView doCacheBits  ""restore fast windows mode in mvc""Symbol selectorsContaining: 'rsCon'.Smalltalk browseMethodsWhoseNamesContain: 'screen'.Browser newOnClass: Utilities.Browser fullOnClass: SystemDictionary.FormView allInstances inspect.StandardSystemView someInstance inspect.Utilities storeTextWindowContentsToFileNamed: 'TextWindows'Utilities reconstructTextWindowsFromFileNamed: 'TextWindows'ScriptingSystem resetStandardPartsBin.ScheduledControllers screenController openMorphicConstructionWorld.ScheduledControllers screenController openMorphicWorld.SystemOrganization categoryOfElement: #Controller. ParagraphEditor organization categoryOfElement: #changeEmphasis.Cursor wait showWhile: [Sensor waitButton].Smalltalk bytesLeft asStringWithCommas.Symbol instanceCount. Time millisecondsToRun:	[SystemNavigation default allCallsOn: #asOop].MessageTally spyOn: [SystemNavigation default allCallsOn: #asOop].""Utilities openStandardWorkspace"! !!Utilities class methodsFor: 'fetching updates' stamp: 'ar 5/7/2010 20:50' prior: 59191674!updateFromServer	"Update the image by loading all pending updates from the server."	| config |	"Flush all caches. If a previous download failed this is often helpful"	MCFileBasedRepository flushAllCaches.	config := MCMcmUpdater updateFromDefaultRepository.	config ifNil: [^self inform: 'Unable to retrieve updates from remote repository.' translated].	self setSystemVersionFromConfig: config.	self inform: ('Update completed.Current update number: ' translated, SystemVersion current highestUpdate).! !!Project methodsFor: 'menu messages' stamp: 'cbr 5/1/2010 01:53'!toggleFullScreen	"Toggle between full screen and windowed mode."	self lastScreenModeSelected		ifTrue: [ self fullScreenOff ]		ifFalse: [ self fullScreenOn ]! !!Project methodsFor: 'accessing' stamp: 'dtl 5/2/2010 19:09'!uiManager	"Answer the manager that provides user interface services for this project "	^ uiManager		ifNil: [uiManager := Smalltalk						at: #UIManager						ifPresent: [:mgr | uiManager := mgr getDefault]]! !!Preferences class methodsFor: 'initialization' stamp: 'ul 5/22/2010 01:34' prior: 26889133!compileAccessMethodForPreference: aPreference	"Compile an accessor method for the given preference"	self class 		compileSilently: (			'{1} ^self valueOfFlag: {2} ifAbsent: [ {3} ]'				format: {					aPreference name asString.					aPreference name asSymbol printString.					aPreference defaultValue storeString }) 		classified: '*autogenerated - standard queries'! !!Preferences class methodsFor: 'personalization' stamp: 'ul 5/22/2010 01:33' prior: 26916280!compileHardCodedPref: prefName enable: aBoolean	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"	self class 		compileSilently: (			'{1} ^{2}'				format: {					prefName asString.					aBoolean storeString })		classified: '*autogenerated - hard-coded prefs'.	"Preferences compileHardCodedPref: #testing enable: false"! !!SystemOrganizer class methodsFor: 'class initialization' stamp: 'spd 5/19/2010 15:54'!default	"I have a global instance, SystemOrganization.  In case someone stumbles upon my class, and does not know about the global, it can be accessed from here, too."  ^ SystemOrganization.! !Preferences class removeSelector: #useFormsInPaintBox!"System"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'dcorking 5/6/2010 13:59' prior: 33713033!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WASqueakServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 29 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000126126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000126126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'cbr 5/1/2010 01:47' prior: 53728504!projectsMenuOn: aDockingBar	aDockingBar addItem: [ :item |		item			contents: 'Projects' translated;			addSubMenu: [ :menu | 				self					newProjectMenuItemOn: menu;					saveProjectMenuItemOn: menu;					loadProjectMenuItemOn: menu;					previousProjectMenuItemOn: menu;					jumpToProjectMenuItemOn: menu;					toggleFullScreenMenuItemOn: menu ] ]! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'spd 5/24/2010 19:19' prior: 59199720!squeakUserInterface	^'The Squeak UI has some unusual elements that you may not have seen before.  Here is a brief introduction to those elements:ProjectsA project is an entire Squeak desktop full of windows.  Projects can be used to change quickly from one task to another.  An inactive project is represented by a project window, which shows a thumbnail of its state.  Project windows are actually more like doors than windows, since you can enter the project just by clicking on them.  You can create a new project by choosing ''open...project'' from the screen menu.  To exit a project (and return to its parent project), choose ''previous project'' from the screen menu.  Each project maintains its own set of windows and other information.Morphic HalosIn a morphic project, pressing cmd-click (Mac) or alt-click (Windows) on a graphical object (e.g. a window) will surround it with a constellation of colored circles.  These are called "halo handles."  Additional clicks will cycle through the halos for the other graphical objects in the nesting structure.  If you hold down the Shift key while cmd/alt-clicking, the nested morphs will be traversed from innermost outward.  Clicking without the cmd/alt key will dismiss the halo.  While the halo is up, letting the cursor linger over one of the halo handles for a few seconds will cause a balloon to pop up with the name of that handle.  Three useful handles are the top-left "X" handle (delete), the bottom-right yellow handle (resize), and the brown handle (slide the object within its containing object).  Halos allow complex graphical objects to be explored - or even disassembled (using the black halo handle).  Usually no harm results from taking apart an object; you can just discard the pieces and create a new one.FlapsTo enable Flaps, click on the desktop to show the world menu, choose the "Flaps..." menu and "show shared tags". Tabs labeled "Squeak", "Tools", "Supplies", etc., will appear along the edges of the Squeak desktop.  Click on any tab to open the corresponding flap.  Drag a tab to resize the flap and to relocate the tab.  Bring up the halo on any tab and click on its menu handle to be presented with many options relating to the flap.  Use the "Flaps..." menu, reached via the desktop menu, to control which flaps are visible and for other flap-related options and assistance.Parts BinsYou can obtain new objects in many ways.  The "Objects Catalog" (choose "objects'' from the world menu or open the objects flap) and several of the standard flaps (e.g. "Tools" and "Supplies") serve as "Parts Bins" the for new objects.  Drag any icon you see in a Parts Bin and a fresh copy of the kind of object it represents will appear "in your hand"; click to deposit the new object anywhere you wish.  You can also add your own objects to any of the flaps - just drag your object over the tab, wait for the flap to pop open, then drop the object at the desired position in the flap.!!]style[(123 9 663 13 991 5 579 10 589),bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'cbr 5/1/2010 01:42'!toggleFullScreenMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Toggle Full Screen' translated;			help: 'Switch back and forth from full screen mode' translated;			icon: MenuIcons smallFullScreenIcon;			target: Project current;			selector: #toggleFullScreen ]! !"Morphic"!!HierarchicalUrl methodsFor: 'printing' stamp: 'topa 5/5/2010 13:47' prior: 21557419!printOn: aStream	aStream nextPutAll: self schemeName.	aStream nextPutAll: '://'.	self username ifNotNil: [		aStream nextPutAll: self username encodeForHTTP.		self password ifNotNil: [			aStream nextPutAll: ':'.			aStream nextPutAll: self password encodeForHTTP].		aStream nextPutAll: '@' ].	aStream nextPutAll: self authority.	port ifNotNil: [aStream nextPut: $:; print: port].	path do: [ :pathElem |		aStream nextPut: $/.		aStream nextPutAll: pathElem encodeForHTTP. ].	self query isNil ifFalse: [ 		aStream nextPut: $?.		aStream nextPutAll: self query. ].	self fragment isNil ifFalse: [		aStream nextPut: $#.		aStream nextPutAll: self fragment encodeForHTTP. ].! !!HierarchicalUrl methodsFor: 'parsing' stamp: 'topa 5/4/2010 14:30' prior: 51344189!privateInitializeFromText: aString 	| remainder ind specifiedSchemeName |	remainder := aString.	schemeName ifNil: 			[specifiedSchemeName := Url schemeNameForString: remainder.			specifiedSchemeName ifNotNil: 					[schemeName := specifiedSchemeName.					remainder := remainder copyFrom: schemeName size + 2 to: remainder size].			schemeName ifNil: 					["assume HTTP"					schemeName := 'http']].	"remove leading // if it's there"	(remainder beginsWith: '//') 		ifTrue: [remainder := remainder copyFrom: 3 to: remainder size].	"get the query"	ind := remainder indexOf: $?.	ind > 0 		ifTrue: 			[query := remainder copyFrom: ind + 1 to: remainder size.			remainder := remainder copyFrom: 1 to: ind - 1].	"get the authority"	ind := remainder indexOf: $/.	ind > 0 		ifTrue: 			[ind = 1 				ifTrue: [authority := '']				ifFalse: 					[authority := remainder copyFrom: 1 to: ind - 1.					remainder := remainder copyFrom: ind + 1 to: remainder size]]		ifFalse: 			[authority := remainder.			remainder := ''].	"extract the username+password"	(authority includes: $@) 		ifTrue: 			[username := authority copyUpTo: $@.			authority := authority copyFrom: (authority indexOf: $@) + 1						to: authority size.			(username includes: $:) 				ifTrue: 					[password := (username copyFrom: (username indexOf: $:) + 1 to: username size) unescapePercents.					username := username copyUpTo: $:].			username := username unescapePercents].	"Extract the port"	(authority includes: $:) 		ifTrue: 			[| lastColonIndex portString |			lastColonIndex := authority findLast: [:c | c = $:].			portString := authority copyFrom: lastColonIndex + 1 to: authority size.			portString isAllDigits 				ifTrue: 					[port := Integer readFromString: portString.					(port > 65535) ifTrue: [self error: 'Invalid port number'].					 authority := authority copyFrom: 1 to: lastColonIndex - 1]				ifFalse:[self error: 'Invalid port number']].	"get the path"	path := self privateParsePath: remainder relativeTo: #() .! !"Network"!!UrlTest methodsFor: 'tests' stamp: 'topa 5/4/2010 14:33'!testUsernamePasswordEncoded	"Sometimes, weird usernames or passwords are necessary in 	applications, and, thus, we might receive them in a Url.	The @ and the : ar the kind of critical ones.	"	#(	"('user' 'pword' 'host' port 'path')"		('Fürst Pückler' 'leckerEis' 'cottbus.brandenburg' 80 'mein/Zuhause')		('Jeannde.d''Arc' 'jaiunesécret' 'orleans' 8080 'une/deux/trois')		('HaXor@roxor:fnac' 'my~Pa$§wert' 'cbase' 42 'do/not_try')	) do: [:urlParts | |theUrl|		theUrl := ('http://{1}:{2}@{3}:{4}/{5}' format: {			(urlParts at: 1) encodeForHTTP. 	(urlParts at: 2) encodeForHTTP.			urlParts at: 3. urlParts at: 4. urlParts at: 5.		}) asUrl.		self 			should: [theUrl schemeName = 'http'];			should: [theUrl username = (urlParts at: 1)];			should: [theUrl password = (urlParts at: 2)];			should: [theUrl authority = (urlParts at: 3)];			should: [theUrl port = (urlParts at: 4)];			should: [theUrl path first = ((urlParts at: 5) copyUpTo: $/)]].! !!UrlTest methodsFor: 'tests' stamp: 'topa 5/5/2010 13:50'!testUsernamePasswordPrintingEncoded	#(	'http://F%C3%BCrst%20P%C3%BCckler:leckerEis@cottbus.brandenburg:80/mein/Zuhause'		'http://Jeannde.d%27Arc:jaiunes%C3%A9cret@orleans:8080/une/deux/trois' 		'http://HaXor%40roxor%3Afnac:my%7EPa%24%C2%A7wert@cbase:42/do/not_try'	) do: [ :urlText |		self should: [ urlText = urlText asUrl asString ] ].! !"NetworkTests"!!SMLoader class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56' prior: 27945877!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[self new createWindow; applyModelExtent; yourself]		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !!SMLoaderPlus class methodsFor: 'new-morph participation' stamp: 'ar 5/10/2010 20:56' prior: 33589283!prototypicalToolWindow	"Do not update when creating a prototype window (used by flaps etc)"	^[(ToolBuilder open: self new) applyModelExtent; yourself] 		valueSupplyingAnswers:{ {'*map on disk*'. false}}! !"SMLoader"!!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:26'!testTestTimeout	self should:[(Delay forSeconds: 6) wait] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:43'!testTestTimeoutLoop	<timeout: 1>	self should:[[true] whileTrue.] raise: TestFailure.! !!SUnitTest methodsFor: 'testing' stamp: 'ar 5/10/2010 18:25'!testTestTimeoutTag	<timeout: 1>	self should:[(Delay forSeconds: 3) wait] raise: TestFailure.! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:26'!defaultTimeout	"Answer the default timeout to use for tests in this test case.	The timeout is a value in seconds."	^5 "seconds"! !!TestCase methodsFor: 'running' stamp: 'ar 5/11/2010 19:58' prior: 31103806!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout:[		self setUp.		self performTest	] after: self timeoutForTest] ensure:[self tearDown].! !!TestCase methodsFor: 'running' stamp: 'ar 5/12/2010 19:33'!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !!TestCase methodsFor: 'accessing' stamp: 'ar 5/10/2010 18:44'!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^self defaultTimeout! !"SUnit"!!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingColors	"self run: #testSummingColors"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each) sum = each) 	].! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:42'!testSummingToTen	"self run: #testSummingToTen"	| cases |	cases :={ 		{ 1 . 2 . 3 . 4 }.		{ 2.0 . 2.0 . 2.0 . 2.0 . 2.0  }.		{ 2/5 . 5/2 . 5/2 . 3/5 . 4 } 	} .	cases do: [ :each |		self assert: (each  sum = 10 )	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:43'!testSummingToWhite	"self run: #testSummingToWhite"	| cases |	cases := { 		{ Color black . Color white }.		{ Color red . Color green. Color blue }.		{ Color gray . Color gray }.		{ Color cyan. Color magenta. Color yellow }.		{ Color cyan. Color magenta.  }.		{  Color magenta. Color yellow }.		{ Color cyan.  Color yellow }.		{ Color cyan. Color red }.		{ Color green .Color magenta.  }.		{ Color blue. Color yellow }.	} .	cases do: [ :each |		self assert: (each  sum = Color white) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:44'!testSummingWithBlack	"self run: #testSummingWithBlack"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	}.	cases do: [ :each |		self assert: ((Array with: each with: Color black) sum = each) 	] .! !!SumBugs methodsFor: 'as yet unclassified' stamp: 'ar 5/4/2010 08:45'!testSummingWithWhite	"self run: #testSummingWithWhite"	| cases |	cases := { 		Color black.		Color red.		Color green.		Color blue.		Color cyan.		Color magenta.		Color yellow.		Color white.	} .	cases do: [ :each |		self assert: ((Array with: Color white with: each ) sum = Color white) 	] .! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalDirectly	"	SystemOrganizerTest run: #testAccessGlobalDirectly	"		self assert: (SystemOrganization isKindOf: SystemOrganizer).					"It really lives in Smalltalk (another global)"	self assert: ((Smalltalk at: #SystemOrganization) == SystemOrganization).! !!SystemOrganizerTest methodsFor: 'tests' stamp: 'spd 5/19/2010 15:53'!testAccessGlobalThroughClass	"	SystemOrganizerTest run: #testAccessGlobalThroughClass	"			"In case someone stumbles upon the SystemOrganizer class, and does not know	about the SystemNavigation global, it can be accessed from there, too."	self assert: (SystemOrganizer default == SystemOrganization).! !!ClosureTests methodsFor: 'testing-while' stamp: 'eem 5/22/2010 09:35'!testWhileWithTempIsNil	| index |	index := 0.	[ index < 5 ] whileTrue: [		| temp |		collection add: temp.		temp := index := index + 1. 		collection add: temp].	self assertValues: #(nil 1 nil 2 nil 3 nil 4 nil 5)! !!LocaleTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:24' prior: 57142788!testLocaleChanged	"self debug: #testLocaleChanged"	"LanguageEnvironment >> startUp is called from Prject >> localeChanged"	<timeout: 60> "takes quite a while"	Project current updateLocaleDependents.	self assert: (ActiveHand instVarNamed: 'keyboardInterpreter') isNil.	self assert: (Clipboard default instVarNamed: 'interpreter') isNil.	Locale switchToID: (LocaleID isoLanguage: 'ja').	self assert: Preferences useFormsInPaintBox.	Locale switchToID: (LocaleID isoLanguage: 'en').	self assert: Preferences useFormsInPaintBox not.! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:54' prior: 57220949!testDoubleRepeatedMerge	| base motherA1 motherA2 motherB1 motherB2 inst |	<timeout: 30> "takes a little longer"	base := self snapshot.	self change: #a toReturn: 'a1'.	motherA1 :=  self snapshot.	self change: #c toReturn: 'c1'.	motherA2 :=  self snapshot.			self load: base.	self change: #b toReturn: 'b1'.	motherB1 :=  self snapshot.	self change: #d toReturn: 'd1'.	motherB2 :=  self snapshot.		self load: base.	self merge: motherA1.	self merge: motherB1.	self change: #a toReturn: 'a2'.	self change: #b toReturn: 'b2'.	self snapshot.	self shouldnt: [self merge: motherA2] raise: Error.	self shouldnt: [self merge: motherB2] raise: Error.		inst := self mockInstanceA.	self assert: inst a = 'a2'.	self assert: inst b = 'b2'.	self assert: inst c = 'c1'.	self assert: inst d = 'd1'.	! !!MCWorkingCopyTest methodsFor: 'tests' stamp: 'ar 5/10/2010 20:53' prior: 57223286!testRepeatedMerge	| base mother1 mother2 inst |	<timeout: 30> "takes a little longer"	base :=  self snapshot.	self change: #one toReturn: 2.	mother1 :=  self snapshot.	self change: #two toReturn: 3.	mother2 :=  self snapshot.			self load: base.	self change: #truth toReturn: false.	self snapshot.	inst := self mockInstanceA.	self assert: inst one = 1.	self assert: inst two = 2.		self merge: mother1.	self assert: inst one = 2.	self assert: inst two = 2.			self change: #one toReturn: 7.	self assert: inst one = 7.	self assert: inst two = 2.		self shouldnt: [self merge: mother2] raise: Error.	self assert: inst one = 7.	self assert: inst two = 3.! !!DecompilerTests methodsFor: 'utilities' stamp: 'ar 5/10/2010 20:17'!defaultTimeout	"Decompiler takes a long time"	^30 "seconds"! !!MCFileInTest methodsFor: 'testing' stamp: 'ar 5/10/2010 20:53' prior: 57160248!testStWriter	<timeout: 30> "takes a little longer"	self		assertFileOutFrom: MCStWriter		canBeFiledInWith: [stream fileIn].! !"Tests"!!PluggableWidgetSpec commentStamp: 'ar 2/9/2005 18:40' prior: 26547561!The abstract superclass for all widgets.Instance variables:	model	<Object>	The object the various requests should be directed to.	frame	<Rectangle> The associated layout frame for this object (if any).!!PluggableButtonSpec commentStamp: 'ar 2/11/2005 21:57' prior: 59370783!A button, both for firing as well as used in radio-button style (e.g., carrying a selection).Instance variables:	action	<Symbol>	The action to perform when the button is fired.	label	<Symbol|String>	The selector for retrieving the button's label or label directly.	state	<Symbol>	The selector for retrieving the button's selection state.	enabled	<Symbo>		The selector for retrieving the button's enabled state.	color	<Symbo>		The selector for retrieving the button color.	help	<String>		The balloon help for the button.!!PluggableTextSpec commentStamp: 'ar 2/11/2005 21:58' prior: 59375756!A text editor.Instance variables:	getText	<Symbol>	The selector to retrieve the text.	setText	<Symbol>	The selector to set the text.	selection <Symbol>	The selector to retrieve the text selection.	menu	<Symbol>	The selector to offer (to retrieve?) the context menu.	color	 <Symbol>	The selector to retrieve the background color.!!UIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 32533887!UIManager is a dispatcher for various user interface requests, such as menu and dialog interactions. An instance of UIManager is associated with each Project to implement the appropriate functions for Morphic, MVC or other user interfaces.!!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color	"Answer the selector for retrieving the button's color"	^color! !!PluggableWidgetSpec methodsFor: 'accessing' stamp: 'ar 5/5/2010 22:35'!color: aSymbol	"Indicate the selector for retrieving the button's color"	color := aSymbol! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:54' prior: 32541199!default	^ Project current uiManager! !!UIManager class methodsFor: 'class initialization' stamp: 'dtl 5/2/2010 15:52'!getDefault	"Ensure that a more specific manager can always be made by subclassing	a tool builder and implementing a more specific way of reacting to	#isActiveManager. For example, a BobsUIManager can subclass	MorphicUIManager and (if enabled, say Preferences useBobsUI) will	be considered before the parent (generic MorphicUIManager)."	^ (self allSubclasses		detect: [:any | any isActiveManager				and: [any subclasses						noneSatisfy: [:sub | sub isActiveManager]]]		ifNone: [])		ifNotNilDo: [:mgrClass | mgrClass new]! !PluggableTextSpec removeSelector: #color:!PluggableTextSpec removeSelector: #color!PluggableButtonSpec removeSelector: #color:!PluggableButtonSpec removeSelector: #color!UIManager class removeSelector: #default:!"ToolBuilder-Kernel"!!MVCUIManager commentStamp: 'dtl 5/2/2010 16:06' prior: 23337692!MVCUIManager is a UIManager that implements user interface requests for an MVC user interface.!"ToolBuilder-MVC"!!MorphicUIManager commentStamp: 'dtl 5/2/2010 16:07' prior: 24593982!MorphicUIManager is a UIManager that implements user interface requests for a Morphic user interface.!!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'fbs 5/2/2010 15:31' prior: 58753986!buildPluggableList: aSpec	| widget listClass getIndex setIndex |	aSpec getSelected ifNil:[		listClass := self listClass.		getIndex := aSpec getIndex.		setIndex := aSpec setIndex.	] ifNotNil:[		listClass := self listByItemClass.		getIndex := aSpec getSelected.		setIndex := aSpec setSelected.	].	widget := listClass on: aSpec model				list: aSpec list				selected: getIndex				changeSelected: setIndex				menu: aSpec menu				keystroke: aSpec keyPress.	self register: widget id: aSpec name.	widget getListElementSelector: aSpec listItem.	widget getListSizeSelector: aSpec listSize.	widget doubleClickSelector: aSpec doubleClick.	widget dragItemSelector: aSpec dragItem.	widget dropItemSelector: aSpec dropItem.	widget wantsDropSelector: aSpec dropAccept.	widget autoDeselect: aSpec autoDeselect.	widget keystrokePreviewSelector: aSpec keystrokePreview.	aSpec color isNil ifFalse: [widget color: aSpec color].	self buildHelpFor: widget spec: aSpec. 	self setFrame: aSpec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	panes ifNotNil:[		aSpec list ifNotNil:[panes add: aSpec list].	].	^widget! !!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 5/4/2010 12:55' prior: 33732384!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	window model		shouldStyle: false;		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 20:48' prior: 57780504!buildFileListWith: builder	| buttons listSpec top |	top := builder pluggablePanelSpec new.	top children: OrderedCollection new.		buttons := self buildButtonPaneWith: builder.	buttons frame: (self topConstantHeightFrame: self buttonHeight fromLeft: 0 width: 1).	top children add: buttons.		listSpec := builder pluggableListSpec new.	listSpec 		model: self;		list: #fileList; 		getIndex: #fileListIndex; 		setIndex: #fileListIndex:; 		menu: #fileListMenu:; 		keyPress: nil;		frame: (self frameOffsetFromTop: self buttonHeight + 4 fromLeft: 0 width: 1 bottomFraction: 1);		color: Color white.	top children add: listSpec.	^top.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/2/2010 16:20' prior: 57781075!buildWith: builder	"FileList open"	| windowSpec window |	windowSpec := 	self buildWindowWith: builder specs: {		(0@0 corner: 1@0.06) -> [self buildPatternInputWith: builder].		(0.25@0.06 corner: 1@0.5) -> [self buildFileListWith: builder].		(0@0.06 corner: 0.25@1) -> [self buildDirectoryTreeWith: builder].		(0.25@0.5 corner: 1@1) -> [self buildContentPaneWith: builder].	}.	window := builder build: windowSpec.	self changed: #selectedPath.	^window! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 4/30/2010 14:53'!buttonHeight	^Preferences standardButtonFont height + 12! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 23:00'!frameOffsetFromTop: height fromLeft: leftFraction width: rightFraction bottomFraction: bottomFraction	^LayoutFrame new		topFraction: 0 offset: height;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: bottomFraction offset: 0;		yourself.! !!FileList methodsFor: 'toolbuilder' stamp: 'fbs 5/1/2010 22:56'!topConstantHeightFrame: height fromLeft: leftFraction width: rightFraction	^LayoutFrame new		topFraction: 0 offset: 0;		leftFraction: leftFraction offset: 0;		rightFraction: (leftFraction + rightFraction) offset: 0;		bottomFraction: 0 offset: height;		yourself.! !!CodeHolder methodsFor: 'message list' stamp: 'nk 6/19/2004 16:50' prior: 18762661!decompiledSourceIntoContents	"For backwards compatibility."	^self  decompiledSourceIntoContentsWithTempNames: (Sensor leftShiftDown not) ! !!CodeHolder methodsFor: 'message list' stamp: 'eem 5/18/2010 14:11'!decompiledSourceIntoContentsWithTempNames: showTempNames 	"Obtain a source string by decompiling the method's code, and place 	that source string into my contents.	Also return the string.	Get temps from source file if showTempNames is true."	| tempNames class selector method |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	"Was method deleted while in another project?"	method := class compiledMethodAt: selector ifAbsent: [^ ''].	currentCompiledMethod := method.	(showTempNames not			or: [method fileIndex > 0					and: [(SourceFiles at: method fileIndex) isNil]])		ifTrue: [			"Emergency or no source file -- decompile without temp names "			contents := (class decompilerClass new						decompile: selector						in: class						method: method) decompileString]		ifFalse: [tempNames := (class compilerClass new									parse: method getSourceFromFile asString									in: class									notifying: nil)										generate: CompiledMethodTrailer defaultMethodTrailer;										schematicTempNamesString.			contents := ((class decompilerClass new withTempNames: tempNames)						decompile: selector						in: class						method: method) decompileString].	contents := contents asText makeSelectorBoldIn: class.	^ contents copy! !"Tools"!!HelpBrowser commentStamp: 'tbn 3/8/2010 09:33' prior: 33755727!A HelpBrowser is used to display a hierarchy of help topics and their contents.Instance Variables	rootTopic: 		<HelpTopic>	window:			<StandardWindow>	 	treeMorph:		<PluggableTreeMorph>	contentMorph:		<Morph>			rootTopic	- xxxxxwindow	- xxxxxtreeMorph 	- xxxxxcontentMorph 	- xxxxx!!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:37' prior: 33773237!defaultHelpBrowser	DefaultHelpBrowser isNil ifTrue: [DefaultHelpBrowser := self].	^DefaultHelpBrowser	! !!HelpBrowser class methodsFor: 'accessing' stamp: 'tbn 5/3/2010 18:42'!defaultHelpBrowser: aClass	"Use a new help browser implementation"		DefaultHelpBrowser := aClass	! !!HelpBrowser class methodsFor: 'class initialization' stamp: 'tbn 5/2/2010 22:20' prior: 33773350!initialize	"Initializes the receiver class" 	 TheWorldMenu registerOpenCommand: {'Help Browser'. {self. #open}}. ! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 5/3/2010 18:37' prior: 33774194!open	^self openOn: SystemHelp! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 5/3/2010 18:36' prior: 33774327!openOn: aHelpTopic	"Open the receiver on the given help topic or any other object that can be transformed into	 a help topic by sending #asHelpTopic."		^(self defaultHelpBrowser new)		rootTopic: aHelpTopic asHelpTopic;		open;		yourself! !!HelpBrowser methodsFor: 'initialize-release' stamp: 'tbn 5/2/2010 22:20' prior: 33774942!initWindow	window := SystemWindow labelled: 'Help Browser'.	window model: self.	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph model: self; setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph frame: (0@0 corner: 0.3@1).		"Text"	contentMorph := self defaultViewerClass on: self 			text: nil accept: nil			readSelection: nil menu: nil.	window addMorph: contentMorph frame: (0.3@0 corner: 1@1).					! !HelpBrowser removeSelector: #initWindowInSqueak!HelpBrowser removeSelector: #initWindowInPharo!HelpBrowser class removeSelector: #menuCommandOn:!HelpBrowser class removeSelector: #isSqueak!HelpBrowser class removeSelector: #isPharo11!"HelpSystem-Core"!!AdvancedHelpBrowserDummy commentStamp: 'tbn 5/3/2010 19:30' prior: 0!This is a dummy for a custom Help browser that can be registered as a replacement for the HelpBrowser class.Instance Variables	rootTopic:		<HelpTopic>rootTopic	- The root help topic!!AdvancedHelpBrowserDummy methodsFor: 'initialize-release' stamp: 'tbn 5/3/2010 19:34'!initialize	isOpen := false! !!AdvancedHelpBrowserDummy methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:32'!isOpen	^isOpen! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:32'!open	isOpen := true! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic	^rootTopic! !!AdvancedHelpBrowserDummy methodsFor: 'mocking' stamp: 'tbn 5/3/2010 19:33'!rootTopic: aTopic	rootTopic := aTopic! !!HelpBrowserTest methodsFor: 'accessing' stamp: 'tbn 5/3/2010 19:35'!defaultTestClass	^HelpBrowser! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 20:22'!testDefaultHelpBrowser		| current replacement instance |	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement. 	  instance := self defaultTestClass open.	  self assert: instance rootTopic notNil.	  self assert: instance isOpen.	] ensure: [ self defaultTestClass defaultHelpBrowser: current ]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:28'!testDefaultHelpBrowserIsReplacable		| current replacement instance |	"save the one that is registered"	current := self defaultTestClass defaultHelpBrowser.	replacement := AdvancedHelpBrowserDummy.	[	  self defaultTestClass defaultHelpBrowser: replacement.	  self assert: self defaultTestClass defaultHelpBrowser == replacement.	  	  instance := self defaultTestClass open.	  	] ensure: [		self defaultTestClass defaultHelpBrowser: current	]	 ! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 18:43'!testLazyDefaultHelpBrowser		self assert: self defaultTestClass defaultHelpBrowser notNil! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/3/2010 19:35' prior: 33796513!testOpen	|block|	block := [		|browser|		browser := self defaultTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Exception		! !!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 5/2/2010 22:20' prior: 33796755!testRegistration	        	TheWorldMenu registeredOpenCommands detect: [:each | each first = 'Help Browser'] ifNone: [self fail].	! !HelpBrowserTest removeSelector: #defaulTestClass!"HelpSystem-Tests"!!SqueakToolsHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:08'!basicDevelopmentTools	^HelpTopic 		title: 'Basic Development Tools'		contents: 'Smalltalk environments have some of the best user interfaces for programmers ever devised. Those who have programmed in Lisp under Emacs have some idea, but Smalltalk is even better.		You should learn these basic tools thoroughly:- Workspace- Transcript- Browser- Inspector- File List- Change Sorter- Debugger- Method Finder		'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 22:59'!bookName 	^'Tools'! !!SqueakToolsHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:08'!pages	^#(basicDevelopmentTools)! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:14'!bookName	^'Transcript'! !!SqueakToolsTranscriptHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:16'!pages	^# (transcript)! !!SqueakToolsTranscriptHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:16'!transcript	^HelpTopic 		title: 'The Transcript window'		contents: 'The Transcript window is often used for logging or printing results from text only code. To open the Transcript use TheWorldMenu and choose ''open...''. Then choose ''Transcript''.You can also type   Transcript openin a Workspace and doIt.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:06'!bookName 	^'Workspace'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:10'!openWorkspace	^HelpTopic 		title: 'Open a Workspace'		contents: 'You can open a Workspace window, by doing any one of the following:		- Using a keyboard while pointing at an empty part of the Squeak wind, alt-k (in Windows, cmd-k in Mac)- Open up a World Menu, select "open..." action. From the open menu, select "workspace (k)- Click on the Tools Flap. When it comes out, click on the Workspace icon and drag it out. (Click on the Tools Flap to close it back up.).'! !!SqueakToolsWorkspaceHelp class methodsFor: 'accessing' stamp: 'tbn 5/2/2010 23:11'!pages	^#(workspace openWorkspace saveWorkspace)! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:13'!saveWorkspace	^HelpTopic 		title: 'Saving Workspace to a File'		contents: 'You can save the text content of a Workspace to a file by choosing the workspace menu (from within the workspace), then ''more...'', then ''save contents to file...''.'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'tbn 5/2/2010 23:09'!workspace	^HelpTopic 		title: 'What is a Workspace'		contents: 'A Workspace is a window used as a scratchpad area where fragments of Smalltalk code can be entered, stored, edited, and evaluated. To open a workspace window in Squeak, one possibility is to bring up the World menu, select "open...", and then select "workspace". You can then type in any Smalltalk code inside the workspace window and execute it or inspect it.'! !!SqueakTutorials class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:33'!bookName 	^'Tutorials'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:34'!bookName 	^'XML'! !!SqueakTutorialsOnXML class methodsFor: 'pages' stamp: 'it 5/4/2010 20:12'!dataRetrieval	^HelpTopic 		title: 'Retrieving XML data'		contents: 'Retrieving data from XML documents is simple and easy in Squeak Smalltalk. This tutorial demonstrates the fundamentals with a straightforward approach where code can be tested right away either here or in a Workspace window. The beauty of Squeak Smalltalk resides in the possibility to evaluate, inspect, print and debug code anywhere and this window is no different. This tutorial demonstrates how to...	* retrieve an XML document from the World Wide Web	* instantiate an XML document class	* inspect and understand the content of an XML document	* retrieve and display values from specific XML tagsRetrieve an XML document from the World Wide WebThere are many manners to retrieve data from the World Wide Web in Squeak Smalltalk. HTTPClient is among them and allows to download files in all simplicity. Select the following code snippet and inspect it (press alt-i). An Inspect window will open with the document loaded in memory. The result is a MIMEDocument object.	HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.TIP: Select HTTPClient and browse it (press alt-b) to open a System Browser window on its class. HTTPClient does not have instance methods but it has class methods. Click on class to see class methods.Instantiate an XML DocumentAn instance of MIMEDocument will not allow to retrieve XML data in a comprehensive manner because it does not understand the nature of XML. For this reason, it is necessary to parse the content of MIMEDocument using XMLDOMParser. XMLDOMParser>>parseDocumentFrom: requires a stream as a parameter and ReadStream will be used for this purpose. The following code snippet instantiates an XMLDocument using the content of the downloaded file.	| doc |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).Inspect and understand the content of an XML documentXML is a flexible document format and it is necessary to understand how each given XML file is structured in order to properly search, retrieve and manipulate data. Inspecting values is critical in a dynamic programming language and environment, such as Squeak Smalltalk. Select the previous code snippet and inspect it (press alt-i).Unfortunately, the Inspect window does not reveal a lot about the XML structure of the downloaded file. Select the previous code snippet once again and explore it (press alt and the capital letter i). An Explorer window will open with a tree outline on the instance of XMLDocument.The Inspect and Explorer windows tell a lot about an XMLDocument. The sections are instance variables and their values are displayed aside. In the Explorer window, unfold elementsAndContents. Unfold other sections as deemed necessary to understand the XML format and the data available.The gibberish coding is about to become clear. Open a Browser window from the world menu and right click in the first pane, select find class (press alt-f) and type XMLDocument to search for its class, or select the class name and browse it (press alt-b). However, it is suggested to read more about XMLParser and XMLParserTest first. Retrieve and display values from specific XML tagsThe downloaded XML file contains a list of items which are denoted by the tag name "item". The Explorer window revealed the content of interest is located at the array index 1 of the elementsAndContents, which can be accessed through XMLDocument>>root.TIP: Some XML documents have additional components contained within its file, such as XMLPI (XML Processing Instructions). For this reason, the root may lead to this rather than the data which will be indexed at 2 or more. It is necessary to use XMLNodeWithElements>>elements, e.g. (xml elements at: 2), in order to access subsequent data.The following code snippet will display items in a Transcript window. Open a Transcript window using the world menu before selecting and executing the code. Select the code snippet and execute it (press alt-d).	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript show: (e asString); cr.		].An XML item looks like this:	<item>	<title>HelpSystem-Core-tbn.46.mcz</title>	<link>http://source.squeak.org/trunk.html</link>	<description>throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)</description>	<pubDate>Sun, 02 May 2010 20:23:49 +0000</pubDate>	<author>Torsten Bergmann &lt;Torsten.Bergmann@astares.de&gt;</author>	<category>The Trunk</category>	<enclosure length="27288" type="application/x-monticello" url="http://source.squeak.org/trunk/HelpSystem-Core-tbn.46.mcz"/> 	<guid isPermaLink="false"/> </item>The following code snippet uses information learned, retrieves each comment and displays them in a Transcript window. Notice an author can have a nil value and is handled accordingly.	| doc xml |	doc := HTTPClient httpGetDocument: ''http://source.squeak.org/trunk/feed.rss''.	xml := XMLDOMParser parseDocumentFrom: (ReadStream on: (doc content)).	xml root tagsNamed: #item do: [:e |		Transcript 			show: ''Date: '', ((e firstTagNamed: #pubDate) contentString); cr;			show: ''Title: '', ((e firstTagNamed: #title) contentString); cr;			show: ''Author: '', 				(((e firstTagNamed: #author) notNil)					ifTrue: [(e firstTagNamed: #author) contentString]					ifFalse: ['''']); cr;			show: ''Description: '', ((e firstTagNamed: #description) contentString); cr; cr.			].An item will now look like:	Date: Sun, 02 May 2010 20:23:49 +0000	Title: HelpSystem-Core-tbn.46.mcz	Author: Torsten Bergmann <Torsten.Bergmann@astares.de>	Description: throw out pharo specific stuff since we are now integrated in squeak (and pharo too where squeak specific stuff was removed)'! !!SqueakTutorialsOnXML class methodsFor: 'accessing' stamp: 'it 5/4/2010 04:35'!pages	^# (dataRetrieval)! !"Help-Squeak-Project"!!ContextPart methodsFor: 'private' stamp: 'eem 5/23/2010 14:13' prior: 50837502!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector := #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod := aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec := theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	theMethod flushCache.	selector flushCache.	^aReceiver perform: selector withArguments: arguments! !"Kernel"!!Parser methodsFor: 'primitives' stamp: 'ar 5/24/2010 20:41' prior: 54010073!externalFunctionDeclaration	"Parse the function declaration for a call to an external library."	| descriptorClass callType retType externalName args argType module |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[nil].	descriptorClass == nil ifTrue:[^false].	callType := descriptorClass callingConventionFor: here.	callType == nil ifTrue:[^false].	"Parse return type"	self advance.	retType := self externalType: descriptorClass.	retType == nil ifTrue:[^self expected:'return type'].	"Parse function name or index"	externalName := here.	(self match: #string) 		ifTrue:[externalName := externalName asSymbol]		ifFalse:[(self match:#number) ifFalse:[^self expected:'function name or index']].	(self matchToken: #'(') ifFalse:[^self expected:'argument list'].	args := WriteStream on: Array new.	[here == #')'] whileFalse:[		argType := self externalType: descriptorClass.		argType == nil ifTrue:[^self expected:'argument'].		argType isVoid & argType isPointerType not ifFalse:[args nextPut: argType].	].	(args position = self properties selector numArgs) ifFalse:[		^self expected: 'Matching number of arguments'	].	(self matchToken:#')') ifFalse:[^self expected:')'].	(self matchToken: 'module:') ifTrue:[		module := here.		(self match: #string) ifFalse:[^self expected: 'String'].		module := module asSymbol].	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn| | fn |		fn := xfn name: externalName 				module: module 				callType: callType				returnType: retType				argumentTypes: args contents.		self allocateLiteral: fn.	].	self addPragma: (Pragma keyword: #primitive: arguments: #(120)).	^true! !"Compiler"!SystemVersion setVersion!Smalltalk cleanUp: true.!----SNAPSHOT----{24 May 2010 . 8:51:58 pm} Squeak4.2-10160-alpha.image priorSource: 382!Smalltalk cleanUp: true!----SNAPSHOT----{24 May 2010 . 8:52:41 pm} Squeak4.2-10160-alpha.image priorSource: 326247!----QUIT/NOSAVE----{24 May 2010 . 8:52:46 pm} Squeak4.2-10160-alpha.image priorSource: 326363!!WeakRegistry commentStamp: '<historical>' prior: 59463178!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!----STARTUP----{19 August 2010 . 7:05:44 pm} as /Users/casey/Desktop/Squeak4.2-10160-alpha/Squeak4.2-10160-alpha.image!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ul 6/12/2010 18:38' prior: 58027016!finalizeValues	"Remove and finalize all elements which have nil key"		|  cleanUpAfterRemove |	tally = 0 ifTrue: [ ^self ].	cleanUpAfterRemove := false.	1 to: array size do: [ :index |		(array at: index) 			ifNil: [ cleanUpAfterRemove := false ]			ifNotNil: [ :element |				element key					ifNil: [						finalizer ifNotNil: [ finalizer value: element value ].						array at: index put: nil.						tally := tally - 1.						cleanUpAfterRemove := true ]					ifNotNil: [ :key |						cleanUpAfterRemove ifTrue: [							| newIndex |							(newIndex := self scanFor: key) = index ifFalse: [								array 									at: newIndex put: element;									at: index put: nil ] ] ] ] ].	cleanUpAfterRemove ifTrue: [ "Continue rehashing at the front of array"		self fixCollisionsFrom: array size ]					! !!WeakRegistry methodsFor: 'finalization' stamp: 'ul 6/15/2010 11:17' prior: 58127066!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."		| collectedExecutors |	self protected: [ 		valueDictionary finalizeValues.		collectedExecutors := executors.		executors := nil ].	collectedExecutors ifNotNil: [		collectedExecutors do: #finalize ]! !!WeakRegistry methodsFor: 'initialize' stamp: 'ul 6/15/2010 11:17' prior: 58121165!installFinalizer	valueDictionary finalizer: [ :executor |		(executors ifNil: [ executors := OrderedCollection new ]) add: executor ]! !!WeakRegistry methodsFor: 'copying' stamp: 'ul 6/15/2010 11:21' prior: 58237893!postCopy	self protected: [ "Uses the original accessLock"		accessLock := Semaphore forMutualExclusion.		valueDictionary := valueDictionary copy.		valueDictionary associationsDo: [ :each |			each value class == ObjectFinalizerCollection 				ifTrue: [ each value: each value copy ] ].		executors := executors copy.		self installFinalizer ]! !!ByteArray methodsFor: 'testing' stamp: 'eem 6/4/2010 17:55' prior: 53694752!isLiteral	"so that #(1 #[1 2 3] 5) prints itself"	^self class == ByteArray! !!Dictionary methodsFor: 'removing' stamp: 'eem 10/28/2008 11:14' prior: 53983438!unreferencedKeys	"| uk | (Time millisecondsToRun: [uk := TextConstants unreferencedKeys]) -> uk"	^'Scanning for references . . .' 		displayProgressAt: Sensor cursorPoint		from: 0		to: Smalltalk classNames size * 2		during: 			[:bar | | currentClass n associations referencedAssociations |			currentClass := nil.			n := 0.			associations := self associations asIdentitySet.			referencedAssociations := IdentitySet new: associations size.			self systemNavigation allSelect:				[:m|				m methodClass ~~ currentClass ifTrue:					[currentClass := m methodClass.					 bar value: (n := n + 1)].				m literalsDo:					[:l|					(l isVariableBinding and: [associations includes: l]) ifTrue:						[referencedAssociations add: l]].				false].			((associations reject: [:assoc | referencedAssociations includes: assoc]) collect: [:assoc| assoc key]) asSet]! !!String methodsFor: 'accessing' stamp: 'nice 6/11/2010 21:44'!lines	"Answer an array of lines composing this receiver without the line ending delimiters."	^Array new: (self size // 60 max: 16) streamContents: [:lines |		self linesDo: [:aLine | lines nextPut: aLine]]! !!Symbol class methodsFor: 'access' stamp: 'eem 12/21/2008 12:18' prior: 55054271!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	(aString first isLetter or: [aString first isDigit]) ifFalse:		[			aString size == 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol class methodsFor: 'access' stamp: 'eem 5/22/2008 12:56'!selectorsMatching: aStringPattern	"Answer a list of selectors that match aStringPattern within them. Case-insensitive.	 Does return symbols that begin with a capital letter."	| selectorList |	selectorList := OrderedCollection new.	aStringPattern isEmpty ifTrue: [^selectorList].	self allSymbolTablesDo:		[:each | (aStringPattern match: each) ifTrue: [selectorList add: each]].	^selectorList reject: "reject non-selectors, but keep ones that begin with an uppercase"		[:each | each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]	"Symbol selectorsMatching: 'parse:*'"! !"Collections"!!WeakIdentityKeyDictionaryTest methodsFor: 'coverage' stamp: 'ul 6/12/2010 21:14'!classToBeTested 	^WeakIdentityKeyDictionary! !!WeakIdentityKeyDictionaryTest methodsFor: 'tests' stamp: 'ul 6/12/2010 21:14'!testFinalizeValuesWhenLastChainContinuesAtFront	| objectWithHashModulo dictionary capacity a b c |	objectWithHashModulo := [ :requestedHash :modulo |		| object |		[ 			object := Object new.			object hash \\ modulo = requestedHash ] whileFalse.		object ].	dictionary := self classToBeTested new.	capacity := dictionary capacity.	a := objectWithHashModulo value: capacity - 2 value: capacity.	dictionary at: a put: 1.	b := objectWithHashModulo value: capacity - 1 value: capacity.	dictionary at: b put: 2.	c := objectWithHashModulo value: capacity - 2 value: capacity.	dictionary at: c put: 3.	self assert: dictionary capacity = capacity.	self assert: (dictionary array at: capacity - 1) key == a.	self assert: (dictionary array at: capacity) key == b.	self assert: (dictionary array at: 1) key == c.	a := nil.	Smalltalk garbageCollect.	dictionary finalizeValues.	self assert: (dictionary includesKey: b).	self assert: (dictionary includesKey: c).	self assert: dictionary slowSize = 2.! !!ByteArrayTest methodsFor: 'hex tests' stamp: 'nice 6/5/2010 10:06'!testIsLiteral	self assert: #[122 43 213 7] isLiteral description: 'ByteArray instances are literal'.	self deny: thisContext method isLiteral description: 'ByteArray sub instances are not literal'! !"CollectionsTests"!!GZipSurrogateStream commentStamp: 'nice 3/24/2010 07:36' prior: 21233596!A pseudo stream that allows SmartRefStream to write directly to a gzipped file. There are some peculiarities of the project exporting process that require:1. We ignore #close since the file is closed and may be reopened to continue writing. We implement #reallyClose for when we know that all writing is over.2. We use a BitBlt to write WordArrayForSegment objects. Bit of a hack, but there it is.| fileStream wa |wa := WordArrayForSegment new: 30000.1 to: wa size do: [ :i | wa at: i put: i].fileStream := GZipSurrogateStream newFileNamed: 'xxx3.gz' inDirectory: FileDirectory default.fileStream nextPutAll: 'this is a test'.fileStream nextPutAll: wa.fileStream reallyClose.!!InflateStream commentStamp: 'nice 3/24/2010 07:37' prior: 59325048!This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"For more information see the above mentioned RFC 1951 which can for instance be found at	http://www.leo.org/pub/comp/doc/standards/rfc/index.htmlHuffman Tree Implementation Notes:===========================================The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):	table := initialTable.	bitsNeeded := high 8 bits of (table at: 1).		"Determine initial bits"	table := initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"	[bits := fetch next bitsNeeded bits.			"Grab the bits"	value := table at: bits.						"Lookup the value"	value has high 8 bit set] whileTrue:[		"Check if it's leaf"		table := initialTable + (low 16 bits of value).	"No - compute new sub table start"		bitsNeeded := high 8 bit of value].		"Compute additional number of bits needed"	^value!"Compression"!!MCWorkingCopy class methodsFor: 'as yet unclassified' stamp: 'eem 7/3/2009 11:21' prior: 23215906!initialize	Smalltalk 		at: #MczInstaller		ifPresent: [:installer | self adoptVersionInfoFrom: installer].	self updateInstVars.	"Temporary conversion code -- remove later"	registry ifNotNil:[registry rehash]. "changed #="	self allInstancesDo:[:each| "moved notifications"		Smalltalk at: #SystemChangeNotifier ifPresent:[:cls|			cls uniqueInstance noMoreNotificationsFor: each.		].	].	self registerForNotifications.	Smalltalk addToStartUpList: self! !!MCWorkingCopy class methodsFor: 'system startup' stamp: 'eem 7/3/2009 11:34'!startUp: resuming	"Ensure Monticello is receiving system change notifications."	resuming ifTrue:		[Smalltalk			at: #SystemChangeNotifier			ifPresent: [:scn| self reregisterForNotificationsWith: scn uniqueInstance]]! !!MCFileBasedRepository methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:51' prior: 22897247!notifyList	(self allFileNames includes: 'notify') ifFalse: [^ #()].	^ self readStreamForFileNamed: 'notify' do:		[:s |		s upToEnd lines]! !!MCPackageManager class methodsFor: 'cleanup' stamp: 'ar 6/16/2010 19:56'!flushObsoletePackageInfos	"Flush any and all PackageInfos that are not associated with an MCPackageManager."	| pkgNames |	pkgNames := self allManagers collect:[:wcs| wcs packageName] as: Set.	PackageOrganizer default flushObsoletePackages:[:p|		p class isObsolete or:[(pkgNames includes: p packageName) not].	].! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:15' prior: 23015540!registerForNotifications	Smalltalk		at: #SystemChangeNotifier		ifPresent:			[:cls|			cls uniqueInstance noMoreNotificationsFor: self.			self reregisterForNotificationsWith: cls uniqueInstance]! !!MCPackageManager class methodsFor: 'system changes' stamp: 'eem 7/3/2009 11:14'!reregisterForNotificationsWith: aSystemChangeNotifier	aSystemChangeNotifier		notify: self ofSystemChangesOfItem: #class change: #Added using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Modified using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Renamed using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Commented using: #classModified:;		notify: self ofSystemChangesOfItem: #class change: #Recategorized using: #classMoved:;		notify: self ofSystemChangesOfItem: #class change: #Removed using: #classRemoved:;		notify: self ofSystemChangesOfItem: #method change: #Added using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Modified using: #methodModified:;		notify: self ofSystemChangesOfItem: #method change: #Recategorized using: #methodMoved:;		notify: self ofSystemChangesOfItem: #method change: #Removed using: #methodRemoved:! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 6/24/2010 10:32' prior: 22829118!fileOutMessage	"Put a description of the selected message on a file"	| fileName |	self selectedMessageName ifNotNil:		[Cursor write showWhile:			[self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].		 ^self].	items isEmpty ifTrue:		[^self].	fileName := UIManager default request: 'File out on which file?' initialAnswer: 'methods'.	Cursor write showWhile:		[| internalStream |		internalStream := WriteStream on: (String new: 1000).		internalStream header; timeStamp.		items do:			[:patchOp|			patchOp definition isMethodDefinition ifTrue:				[(patchOp definition actualClass notNil				  and: [patchOp definition actualClass includesSelector: patchOp definition selector])					ifTrue:						[patchOp definition actualClass							printMethodChunk: patchOp definition selector							withPreamble: true							on: internalStream							moveSource: false							toFile: nil]					ifFalse:						[internalStream nextChunkPut: patchOp definition className, ' removeSelector: ', patchOp definition selector printString]].			patchOp definition isClassDefinition ifTrue:				[patchOp definition actualClass					ifNotNil:						[internalStream nextChunkPut: patchOp definition actualClass definition.						 patchOp definition comment ifNotNil:							[patchOp definition actualClass organization								putCommentOnFile: internalStream								numbered: 1								moveSource: false								forClass: patchOp definition actualClass]]					ifNil:						[internalStream nextChunkPut: patchOp definition className, ' removeFromSystem']]].		FileStream writeSourceCodeFrom: internalStream baseName: fileName isSt: true useHtml: false]! !!MCCodeTool methodsFor: 'menus' stamp: 'eem 10/27/2008 17:07' prior: 22830489!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName	ifNil: [items notEmpty ifTrue:		[aMenu addList:#(('fileOut (o)'					fileOutMessage))]]	ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCPackage methodsFor: 'accessing' stamp: 'ab 7/7/2003 13:33' prior: 22996559!packageInfo	^ PackageInfo named: name! !"Monticello"!!ClassBuilder methodsFor: 'private' stamp: 'ar 6/14/2010 22:06' prior: 50642796!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		ProtoObject Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext BlockClosure		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!MethodDictionary methodsFor: 'accessing' stamp: 'ul 6/18/2010 21:38'!associationAt: key ifAbsent: aBlock 	"Answer the association with the given key.	If key is not found, return the result of evaluating aBlock."	^(array at: (self scanFor: key)) 		ifNil: [ aBlock value ]		ifNotNil: [ :value | key -> value ]! !!Object methodsFor: 'updating' stamp: 'eem 6/15/2008 16:02'!okToClose	"Allows a controller to ask this of any model"	^self okToChange! !!DependentsArray methodsFor: 'enumerating' stamp: 'ul 6/18/2010 23:31' prior: 53636324!select: aBlock 	"Refer to the comment in Collection|select:."	| basicSize newSelf size selection |	basicSize := self basicSize.	newSelf := self species new: basicSize.	size := 0.	1 to: basicSize do: [ :i |		(self basicAt: i) ifNotNil: [ :dep |			(aBlock value: dep) ifTrue: [				newSelf basicAt: (size := size+1) put: dep ] ] ].	selection := self species new: size.	selection basicReplaceFrom: 1 to: size with: newSelf startingAt: 1.	^selection! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'cmm 6/15/2010 15:14' prior: 54046483!= aDateAndTime 	self == aDateAndTime ifTrue: [ ^ true ].	(aDateAndTime isKindOf: self class) ifFalse: [ ^ false ].	^ self offset = aDateAndTime offset		ifTrue: [ self hasEqualTicks: aDateAndTime ]		ifFalse: [ self asUTC ticks = aDateAndTime asUTC ticks ]! !!Behavior methodsFor: 'testing' stamp: 'mtf 6/3/2010 11:03'!sourceMatchesBytecodeAt: selector	"Answers true if the source code at the selector compiles to the bytecode at the selector, and false otherwise. Implemented to detect an error where Monticello did not recompile sources when the class shape changed"	"This code was copied from #recompile:from:, with few changes. Several methods would benefit from a method which turned a selector and class into a CompiledMethod, without  installing it into the methodDictionary"	| method trailer methodNode |	method := self compiledMethodAt: selector.	trailer := method trailer.	methodNode := self compilerClass new				compile: (self sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ false].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	^ (methodNode generate: trailer) = method! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 5/28/2010 21:01'!ln	"This function is defined because super ln might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal ln negated].	self <= 0 ifTrue: [self error: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	int := self integerPart.	^int ln + (self / int) ln! !!Fraction methodsFor: 'mathematical functions' stamp: 'nice 6/12/2010 00:40'!log	"This function is defined because super log might overflow.	Note that < 1 is tested before converting to float in order to avoid precision loss due to gradual underflow."	| res int |	self < 1 ifTrue: [^self reciprocal log negated].	self <= 0 ifTrue: [self error: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	int := self integerPart.	^int log + (self / int) log! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index 	"Avoid primitive in Object>>at:"	^self basicAt: index! !!Float methodsFor: 'accessing' stamp: 'ar 6/20/2010 14:28'!at: index put: value 	"Avoid primitive in Object>>at:put:"	^self basicAt: index put: value! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:34'!basicAt: index	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. Do not override in a subclass. See 	Object documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 38 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index].	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Float methodsFor: 'accessing' stamp: 'eem 4/20/2009 09:35'!basicAt: index put: value	"Primitive. Assumes receiver is indexable. Store the second argument 	value in the indexable element of the receiver indicated by index. Fail 	if the index is not an Integer or is out of bounds. Or fail if the value is 	not of the right type for this kind of collection. Answer the value that 	was stored. Essential. Do not override in a subclass. See Object 	documentation whatIsAPrimitive.	This version of basicAt: is specifically for floats, answering the most significant	word for index 1 and the least significant word for index 2.  This alows the VM	to store floats in whatever order it chooses while it appears to the image that	they are always in big-endian/PowerPC order."	<primitive: 39 error: ec>	ec == nil ifTrue: "primitive not implemented; floats are in big-endian/PowerPC order."		[^super basicAt: index put: value].	index isInteger		ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!MethodContext methodsFor: 'initialize-release' stamp: 'eem 9/10/2009 15:49' prior: 51687884!privRefresh	"Reinitialize the receiver so that it is in the state it was at its creation."	closureOrNil		ifNotNil:			[pc := closureOrNil startpc.			self stackp: closureOrNil numArgs + closureOrNil numCopiedValues.			1 to: closureOrNil numCopiedValues do:				[:i | self tempAt: closureOrNil numArgs + i put: (closureOrNil at: i)]]		ifNil:			[pc := method initialPC.			self stackp: method numTemps.			method numArgs+1 to: method numTemps do:				[:i | self tempAt: i put: nil]]! !!ContextPart methodsFor: 'private-exceptions' stamp: 'mtf 6/3/2010 09:36'!rearmHandlerDuring: aBlock	"Sent to handler (on:do:) contexts only. Makes me re-entrant for the duration of aBlock. Only works in a closure-enabled image"	^ [self tempAt: 3 put: true. aBlock value]		ensure: [self tempAt: 3 put: false]! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'MarcusDenker 3/5/2010 14:33'!methodsInCategory: aName 	"Answer a list of the methods of the receiver that are in category named aName"		| aColl |	aColl := Set withAll: (aName = ClassOrganizer allCategory			ifTrue: [self organization allMethodSelectors]			ifFalse: [self organization listAtCategoryNamed: aName]).	^ aColl asArray sort! !!Integer methodsFor: 'converting' stamp: 'MarcusDenker 12/2/2009 12:54' prior: 21992032!asFraction	"Answer a Fraction that represents the value of the receiver."	^Fraction numerator: self denominator: 1! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 5/28/2010 21:25'!ln	"This function is defined because super ln might overflow."	| res h |	self <= 0 ifTrue: [self error: 'ln is only defined for x > 0'].	res := super ln.	res isFinite ifTrue: [^res].	h := self highBit.	^2 ln * h + (self / (1 << h)) asFloat ln! !!Integer methodsFor: 'mathematical functions' stamp: 'nice 6/12/2010 00:40'!log	"This function is defined because super log might overflow."	| res h |	self <= 0 ifTrue: [self error: 'log is only defined for x > 0'].	res := super log.	res isFinite ifTrue: [^res].	h := self highBit.	^2 log * h + (self / (1 << h)) asFloat log! !!ProtoObject methodsFor: 'system primitives' stamp: 'mtf 8/15/2008 17:19'!instVarsInclude: anObject"Answers true if anObject is among my named or indexed instance variables, and false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !LargePositiveInteger removeSelector: #~=!LargePositiveInteger removeSelector: #bitXor:!LargePositiveInteger removeSelector: #bitShift:!LargePositiveInteger removeSelector: #bitOr:!LargePositiveInteger removeSelector: #bitAnd:!LargePositiveInteger removeSelector: #=!TranslatedMethod class removeSelector: #initialize!Smalltalk removeClassNamed: #TranslatedMethod!PseudoContext removeSelector: #nextObject!PseudoContext removeSelector: #isPseudoContext!PseudoContext class removeSelector: #initialize!PseudoContext class removeSelector: #definition!PseudoContext class removeSelector: #contextCacheDepth:!PseudoContext class removeSelector: #contextCacheDepth!Smalltalk removeClassNamed: #PseudoContext!"Kernel"!!Parser methodsFor: 'error correction' stamp: 'jcg 6/23/2010 11:46' prior: 52083421!correctVariable: proposedVariable interval: spot 	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps or inst-vars, and uppercase variables as Globals or 	ClassVars, depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable.	rr 3/4/2004 10:26 : adds the option to define a new class. "	"Check if this is an i-var, that has been corrected already (ugly)"	"Display the pop-up menu"	| binding userSelection action |	(encoder classEncoding instVarNames includes: proposedVariable) ifTrue: 		[^InstanceVariableNode new 			name: proposedVariable			index: (encoder classEncoding allInstVarNames indexOf: proposedVariable)].	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^encoder undeclared: proposedVariable].	"First check to see if the requestor knows anything about the variable"	(binding := requestor bindingOf: proposedVariable)		ifNotNil: [^encoder global: binding name: proposedVariable].	userSelection := requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	"Build the menu with alternatives"	action := UndeclaredVariable 				signalFor: self				name: proposedVariable				inRange: spot.	action ifNil: [^self fail].	"Execute the selected action"	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	^action value! !!Decompiler methodsFor: 'public access' stamp: 'ar 5/27/2010 21:35' prior: 53211074!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home source |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home methodClass) == #unknown ifTrue: [^ nil].	constructor := self constructorForMethod: aBlock method.	self withTempNames: (method tempNamesString ifNil:[	method fileIndex ~~ 0 ifTrue: "got any source code?"		[source := [method getSourceFromFile]						on: Error						do: [:ex | ^ nil].		 methodNode := [homeClass compilerClass new								parse: source								in: homeClass								notifying: nil]							on: SyntaxErrorNotification							do: [:ex | ^ nil].		methodNode schematicTempNamesString]]).	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock isClosure				ifTrue: [(method at: startpc - 2) * 256					  + (method at: startpc - 1) + startpc - 1]				ifFalse:					[(method at: startpc - 2) \\ 16 - 4 * 256					+ (method at: startpc - 1) + startpc - 1].	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super		method: method		pc: (aBlock isClosure ifTrue: [startpc - 4] ifFalse: [startpc - 5]).	aBlock isClosure ifTrue:		[numLocalTemps := #decompileBlock: "Get pushClosureCopy... to hack fake temps for copied values"].	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!Encoder methodsFor: 'private' stamp: 'Lukas Renggli 11/2/2009 00:29' prior: 50999617!name: name key: key class: leafNodeClass type: type set: dict 	^dict at: key		ifAbsentPut: 			[leafNodeClass new 				name: name				key: key				index: nil				type: type]! !"Compiler"!!ServerDirectory class methodsFor: '*eToys-school support' stamp: 'nice 6/11/2010 21:58' prior: 57364115!parseEToyUserListFrom: urlString	| url userString userList |	urlString ifNil:[^nil].	url := urlString asUrl.	userString := ["Note: We need to prevent going through the plugin API 	when retrieving a local (file) URL, since the plugin API	(correctly) rejects file:// downloads."		Cursor wait showWhile:[			(url hasRemoteContents) ifTrue:[				"Go through the browser (if present)"				(HTTPClient httpGet: url asString) contents.			] ifFalse:[				"Go grab it directly"				url retrieveContents contents.			].		].	] on: Error do:[nil].	userString ifNil:[^nil].	userList := userString lines collect: [:each| each withBlanksTrimmed].	userList := userList reject:[:any| any isEmpty].	(userList first = '##user list##') ifFalse:[^nil].	userList := userList copyFrom: 2 to: userList size.	^userList! !"EToys"!!Exception methodsFor: 'handling' stamp: 'mtf 6/3/2010 09:42'!rearmHandlerDuring: aBlock"Make the current error handler re-entrant while it is running aBlock. Only works in a closure-enabled image"	^ handlerContext rearmHandlerDuring: aBlock! !!ExceptionsTest methodsFor: 'as yet unclassified' stamp: 'mtf 6/2/2010 15:51'!testHandlerReentrancy	| callingOrder |	"Handlers are not re-entrant by default, so inner is not activated twice"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex pass]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sio'.	"Now make inner re-entrant"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex rearmHandlerDuring: [ex pass]]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sioi'.! !"Exceptions"!!FileDirectory methodsFor: 'private' stamp: 'mtf 6/1/2010 18:47' prior: 58807732!directoryContentsFor: fullPath	"Return a collection of directory entries for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryContentsFor: ''"	^Array new: 200 streamContents: [:stream |		self directoryContentsFor: fullPath do: [:ea | stream nextPut: ea]].! !!FileDirectory methodsFor: 'private' stamp: 'mtf 6/1/2010 18:46'!directoryContentsFor: fullPath do: aBlock"Do aBlock for the files and directories in the directory with the given path. See primLookupEntryIn:index: for further details."	| f entryArray index |	f := fullPath asVmPathName.	index := 1.	[(entryArray := self primLookupEntryIn: f index: index) == nil] whileFalse: [		#badDirectoryPath = entryArray ifTrue: [			^(InvalidDirectoryError pathName: pathName) signal].		index := index + 1.		aBlock value: (DirectoryEntry fromArray: entryArray directory: self) convertFromSystemName]! !"Files"!!XBMReadWriter methodsFor: 'private' stamp: 'nk 7/16/2003 18:17' prior: 33301630!readHeader	"Set width and height, and position stream at start of bytes"	| number setwidth setheight fieldName |	setwidth := setheight := false.		[((stream atEnd) or: [setwidth and: [setheight]])]		whileFalse: [	  	self skipCComments.		(stream nextMatchAll: '#define ') ifFalse: [^ false].		(stream skipTo: $_) ifFalse: [^ false].		fieldName := String streamContents:			[:source |			[(stream atEnd) or: [ stream peek isSeparator ]]				whileFalse: [ source nextPut: stream next]].	  	(fieldName = 'width') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setwidth _true].	  		width := number.].		(fieldName = 'height') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setheight := true].			height := number.			].		].	(setwidth & setheight) ifFalse: [^ false].	^ stream skipTo: ${! !!StrikeFont methodsFor: 'make arrows' stamp: 'sps 10/15/2003 17:06' prior: 30048599!makeAssignArrow"Replace the underline character with an arrow for this font"	| arrowForm arrowCanvas arrowY arrowLeft arrowRight arrowHeadLength |	arrowForm := (self characterFormAt: $_) copy.	arrowCanvas := arrowForm getCanvas.	arrowCanvas fillColor: Color white.	arrowY := arrowForm height // 2.	arrowLeft := 0. 	arrowRight := arrowForm width - 2.	arrowHeadLength := (arrowRight - arrowLeft) * 2 // 5.	"Draw the lines"	arrowCanvas line: (arrowLeft@arrowY) to: (arrowRight@arrowY) color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY - arrowHeadLength)) 		color: Color black.	arrowCanvas 		line: (arrowLeft@arrowY) 		to: ((arrowLeft + arrowHeadLength)@(arrowY + arrowHeadLength)) 		color: Color black.	"Replace the glyph"	self characterFormAt: $_ put: arrowForm.! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29' prior: 52653164!readFromBitFont: fileName	"This builds a StrikeFont instance by reading the data file format	produced by BitFont, a widely available font conversion utility	written by Peter DiCamillo at Brown University"	"StrikeFont new readFromBitFont: 'Palatino10.BF' "	| f lastAscii charLine width ascii charForm line missingForm tempGlyphs iRect p rectLine left tokens right |	f := FileStream readOnlyFileNamed: fileName.	self readBFHeaderFrom: f.	"NOTE: if font has been scaled (and in any case),	the REAL bitmap dimensions come after the header."	self restOfLine: 'Extent information for entire font' from: f.	"Parse the following line (including mispelling!!)"	"Image rectange: left = -2, right = 8, bottom = -2, top = 7"	tokens := f nextLine  findTokens: ' '.	iRect := Rectangle left: (tokens at: 5) asNumber right: (tokens at: 8) asNumber				top: (tokens at: 14) asNumber bottom: (tokens at: 11) asNumber.	ascent := iRect top.	descent := iRect bottom negated.		tempGlyphs := Form extent: (maxWidth*257) @ self height.	xTable := (Array new: 258) atAllPut: 0.	xTable at: 1 put: 0.	"Read character forms and blt into tempGlyphs"	lastAscii := -1.	[charLine := self restOfLine: 'Character: ' from: f.	charLine == nil ifFalse:		[p := f position.		rectLine := f nextLine.		(rectLine beginsWith: 'Image rectange: left = ')			ifTrue: [tokens := rectLine findTokens: ' '.					left := (tokens at: 5) asNumber. right := (tokens at: 8) asNumber]			ifFalse: [left := right := 0. f position: p].		width:= (self restOfLine: 'Width (final pen position) = ' from: f) asNumber - left					max: (right-left+1).		(charLine beginsWith: 'Missing character') ifTrue: [ascii := 256].		('x''*' match: charLine) ifTrue:			[ascii := Number readFrom: (charLine copyFrom: 3 to: 4) asUppercase base: 16].		charForm := Form extent: width@self height.		('*[all blank]' match: charLine) ifFalse:			[self restOfLine: '  +' from: f.			1 to: self height do:				[:y | line := f nextLine.				4 to: (width + 3 min: line size + iRect left - left) do:					[:x | (line at: x - iRect left + left) = $*						ifTrue: [charForm pixelValueAt: (x-4)@(y-1) put: 1]]]]].	charLine == nil]		whileFalse:			[self displayChar: ascii form: charForm.			ascii = 256				ifTrue: [missingForm := charForm deepCopy]				ifFalse:				[minAscii := minAscii min: ascii.				maxAscii := maxAscii max: ascii.				lastAscii+1 to: ascii-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].				tempGlyphs copy: ((xTable at: ascii+1)@0										extent: charForm extent)							from: 0@0 in: charForm rule: Form over.				xTable at: ascii+2 put: (xTable at: ascii+1) + width.				lastAscii := ascii]].	f close.	lastAscii+1 to: maxAscii+1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].	missingForm == nil ifFalse:		[tempGlyphs copy: missingForm boundingBox from: missingForm				to: (xTable at: maxAscii+2)@0 rule: Form over.		xTable at: maxAscii+3 put: (xTable at: maxAscii+2) + missingForm width].	glyphs := Form extent: (xTable at: maxAscii+3) @ self height.	glyphs copy: glyphs boundingBox from: 0@0 in: tempGlyphs rule: Form over.	xTable := xTable copyFrom: 1 to: maxAscii+3.	characterToGlyphMap := nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'nice 6/11/2010 21:29' prior: 52675328!restOfLine: leadString from: file	"Utility method to assist reading of BitFont data files"	| line |	[line := file nextLine.	line size < leadString size or: [leadString ~= (line copyFrom: 1 to: leadString size)]]	whileTrue: [file atEnd ifTrue: [^ nil]].	^ line copyFrom: leadString size+1 to: line size! !!BDFFontReader methodsFor: 'reading' stamp: 'nice 6/11/2010 21:32' prior: 17129428!getLine	^file nextLine! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35' prior: 17129534!read	| xTable strikeWidth glyphs ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width blt lastAscii pointSize ret stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	charsNum := chars size. "undefined encodings make this different"	charsNum > 256 ifTrue: [		"it should be 94x94 charset, and should be fixed width font"		strikeWidth := 94*94*maxWidth.		maxAscii := 94*94.		minAscii := 0.		xTable := XTableForFixedFont new.		xTable maxAscii: 94*94.		xTable width: maxWidth.	] ifFalse: [		xTable := (Array new: 258) atAllPut: 0.	].	glyphs := Form extent: strikeWidth@height.	blt := BitBlt toForm: glyphs.	lastAscii := 0.		charsNum > 256 ifTrue: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			encoding := ((encoding // 256) - 33) * 94 + ((encoding \\ 256) - 33).			blt copy: ((encoding * maxWidth)@0 extent: maxWidth@height)				from: 0@0 in: form.		].	] ifFalse: [		1 to: charsNum do: [:i |			stream := ReadStream on: (chars at: i).			form := stream next.			encoding := stream next.			bbx := stream next.			lastAscii+1 to: encoding-1 do: [:a | xTable at: a+2 put: (xTable at: a+1)].			blt copy: (((xTable at: encoding+1)@(ascent - (bbx at: 2) - (bbx at: 4)))					extent: (bbx at: 1)@(bbx at: 2))				from: 0@0 in: form.			xTable at: encoding+2 put: (xTable at: encoding+1)+(bbx at: 1).			lastAscii := encoding.		]	].	ret := Array new: 8.	ret at: 1 put: xTable.	ret at: 2 put: glyphs.	ret at: 3 put: minAscii.	ret at: 4 put: maxAscii.	ret at: 5 put: maxWidth.	ret at: 6 put: ascent.	ret at: 7 put: descent.	ret at: 8 put: pointSize.	^ret." ^{xTable. glyphs. minAscii. maxAscii. maxWidth. ascent. descent. pointSize}"! !!BDFFontReader methodsFor: 'reading' stamp: 'ar 10/25/2005 00:35' prior: 17132760!readChars	| strikeWidth ascent descent minAscii maxAscii maxWidth chars charsNum height form encoding bbx array width pointSize stream |	form := encoding := bbx := nil.	self readAttributes.	height := Integer readFromString: ((properties at: #FONTBOUNDINGBOX) at: 2).	ascent := Integer readFromString: (properties at: 'FONT_ASCENT' asSymbol) first.	descent := Integer readFromString: (properties at: 'FONT_DESCENT' asSymbol) first.	pointSize := (Integer readFromString: (properties at: 'POINT_SIZE' asSymbol) first) // 10.		maxWidth := 0.	minAscii := 9999.	strikeWidth := 0.	maxAscii := 0.	charsNum := Integer readFromString: (properties at: #CHARS) first.	chars := Set new: charsNum.	1 to: charsNum do: [:i |		array := self readOneCharacter.		stream := ReadStream on: array.		form := stream next.		encoding := stream next.		bbx := stream next.		form ifNotNil: [			width := bbx at: 1.			maxWidth := maxWidth max: width.			minAscii := minAscii min: encoding.			maxAscii := maxAscii max: encoding.			strikeWidth := strikeWidth + width.			chars add: array.		].	].	chars := chars asSortedCollection: [:x :y | (x at: 2) <= (y at: 2)].	^ chars.! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'nice 12/27/2009 03:11' prior: 55012029!test1"PNGReadWriter test1"	| d0 d1 fileInfo book d2 f |	Debugging := true.	1 = 1 ifTrue: [		book := BookMorph new.		book setProperty: #transitionSpec toValue: {'silence'. #none. #none}.	].	d0 := FileDirectory default.	d1 := d0 directoryNamed: 'PngSuite Folder'.	d2 := d0 directoryNamed: 'BIG PNG'.	{d0. d1. d2}.		"keep compiler quiet""==citrus_none_sub.pngcitrus_adm7_adap.pngcitrus_adm7_aver.pngcitrus_adm7_non.pngcitrus_adm7_paeth.pngpngs-img-ie5mac.png=="	fileInfo := {		d2. {'citrus_adm7_adap.png'}.		"d1. d1 fileNames."	}.	fileInfo pairsDo: [ :dir :fileNames |		fileNames do: [ :each | | error data t |			Transcript cr; show: each.			data := (dir fileNamed: each) contentsOfEntireFile.			error := ''.			MessageTally spyOn: [				t := [ | result |					result := self createAFormFrom: data.					f_ result first.					error := result second.				] timeToRun.].			self insertMorph: f asMorph named: each into: book.			Transcript show: each,'  ',data size printString,' = ',t printString,' ms',error; cr.		].	].	book ifNotNil: [book openInWorld].	Debugging := false.! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/12/2010 11:07'!canComputDefaultLineHeight	^ rightMargin notNil! !!CompositionScanner methodsFor: 'testing' stamp: 'cmm 6/13/2010 20:50'!canComputeDefaultLineHeight	^ rightMargin notNil! !!PNMReadWriter methodsFor: 'reading' stamp: 'jdr 10/16/2003 16:39' prior: 25391930!nextImage	"read one image"	| data p |	first ifNil:[		first := false.		data := stream contentsOfEntireFile.		stream := (RWBinaryOrTextStream with: data) reset.	]	ifNotNil:[		type < 4 ifTrue:[			self error:'Plain PBM, PGM or PPM have only one image'		].	].	stream ascii.	p := stream next.	type := (stream next) asInteger - 48.	(p = $P and:[type > 0 and:[type < 8]]) ifFalse:[		self error:'Not a PNM file'	].	type = 7 ifTrue:[		self readHeaderPAM	]	ifFalse: [		self readHeader	].	type caseOf: {		[1] 	->	[^self readPlainBW].		[2] 	->	[^self readPlainGray].		[3] 	->	[^self readPlainRGB].		[4] 	->	[^self readBWreverse: false].		[5] 	->	[^self readGray].		[6] 	->	[^self readRGB].		[7] 	->	[	"PAM"					(tupleType asUppercase) caseOf: {						['BLACKANDWHITE'] 		-> [^self readBWreverse: true].						['GRAYSCALE'] 			-> [^self readGray].						['RGB'] 					-> [^self readRGB].						['RGB_ALPHA'] 			-> [^self error:'Not implemented'].						['GRAYSCALE_ALPHA'] 	-> [^self error:'Not implemented'].					} otherwise: [^self readData].				]	}! !!BitBlt class methodsFor: 'benchmarks' stamp: 'nice 6/11/2010 21:32' prior: 54835129!benchDiffsFrom: before to: afterwards	"Given two outputs of BitBlt>>benchmark show the relative improvements."	| old new log oldLine newLine oldVal newVal improvement |	log := WriteStream on: String new.	old := ReadStream on: before.	new := ReadStream on: afterwards.	[old atEnd or:[new atEnd]] whileFalse:[		oldLine := old nextLine.		newLine := new nextLine.		(oldLine includes: Character tab) ifTrue:[			oldLine := ReadStream on: oldLine.			newLine := ReadStream on: newLine.			Transcript cr; show: (oldLine upTo: Character tab); tab.			log cr; nextPutAll: (newLine upTo: Character tab); tab.			[oldLine skipSeparators. newLine skipSeparators.			oldLine atEnd] whileFalse:[				oldVal := Integer readFrom: oldLine.				newVal := Integer readFrom: newLine.				improvement := oldVal asFloat / newVal asFloat roundTo: 0.01.				Transcript show: improvement printString; tab; tab.				log print: improvement; tab; tab].		] ifFalse:[			Transcript cr; show: oldLine.			log cr; nextPutAll: oldLine.		].	].	^log contents! !!CharacterScanner methodsFor: 'scanning' stamp: 'cmm 6/12/2010 11:52' prior: 58295101!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	| startEncoding selector |	(sourceString isByteString) ifTrue: [^ self basicScanCharactersFrom: startIndex to: (stopIndex min: sourceString size) in: sourceString rightX: rightX stopConditions: stops kern: kernDelta.].	(sourceString isWideString) ifTrue: [		startIndex > stopIndex ifTrue: [lastIndex := stopIndex. ^ stops endOfRun].		startEncoding :=  (sourceString at: startIndex) leadingChar.		selector := EncodedCharSet scanSelectorAt: startEncoding.		^ self perform: selector withArguments: (Array with: startIndex with: stopIndex with: sourceString with: rightX with: stops with: kernDelta).	].		^ stops endOfRun! !"Graphics"!!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:19'!testArea	| r1 empty |	r1 := 0@0 extent: 10@20.	self assert: r1 area = (10*20).	self assert: (r1 translateBy: -20@10) area = (10*20) description: 'translation preserves area'.		empty := 10@20 corner: 0@0.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.	empty := 10@0 corner: 0@20.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.	empty := 0@20 corner: 10@0.	self assert: empty area = 0 description: 'the area of an empty rectangle is null'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:59'!testCenter	| r1 c |	r1 := 0@0 extent: 10@20.	c := r1 center.	self assert: (r1 containsPoint: c) description: 'the center is inside the rectangle'.	self assert: (r1 topLeft dist: c) = (r1 bottomRight dist: c).	self assert: (r1 bottomLeft dist: c) = (r1 topRight dist: c).	self assert: (r1 topLeft dist: c) = (r1 bottomLeft dist: c).	self assert: (r1 translateBy: -20@10) center = (c translateBy: -20@10) description: 'the center is translated with the rectangle'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 23:00'!testCenterEmpty	| r1 c |	r1 := 30@10 corner: 10@20.	c := r1 center.	self deny: (r1 containsPoint: c) description: 'An empty rectangle does not contain any point.'.	self assert: (r1 topLeft dist: c) = (r1 bottomRight dist: c).	self assert: (r1 bottomLeft dist: c) = (r1 topRight dist: c).	self assert: (r1 topLeft dist: c) = (r1 bottomLeft dist: c).	self assert: (r1 translateBy: -20@10) center = (c translateBy: -20@10) description: 'the center is translated with the rectangle'.! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:33'!testFlip	| r1 c r1Horiz r1Vert |	r1 := 30@10 extent: 10@20.	c := 5@5.	r1Horiz := r1 flipBy: #horizontal centerAt: c.	r1Vert := r1 flipBy: #vertical centerAt: c.	self assert: r1 area = r1Horiz area description: 'flip preserves area'.	self assert: r1 area = r1Vert area description: 'flip preserves area'.		self assert: r1 extent = r1Horiz extent description: 'flip preserves extent'.	self assert: r1 extent = r1Vert extent description: 'flip preserves extent'.		self assert:  (r1 flipBy: #horizontal centerAt: r1 center) = r1.	self assert:  (r1 flipBy: #vertical centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:33'!testFlipEmpty	| r1 c r1Horiz r1Vert |	r1 := 30@10 corner: 10@20.	c := 5@5.	r1Horiz := r1 flipBy: #horizontal centerAt: c.	r1Vert := r1 flipBy: #vertical centerAt: c.		self assert: r1 area = r1Horiz area description: 'flip preserves area'.	self assert: r1 area = r1Vert area description: 'flip preserves area'.		self assert: r1 extent = r1Horiz extent description: 'flip preserves extent'.	self assert: r1 extent = r1Vert extent description: 'flip preserves extent'.		self assert:  (r1 flipBy: #horizontal centerAt: r1 center) = r1.	self assert:  (r1 flipBy: #vertical centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 23:04'!testIntersectionEmpty	| rect1 empty1 empty2 |	rect1 := 10@10 corner: 40@40.	empty1 := 50@50 corner: 0@0.	empty2 := 30@30 corner: 20@20.	self		deny: (rect1 intersects: empty1);		deny: (rect1 intersects: empty2);		deny: (empty1 intersects: rect1);		deny: (empty2 intersects: rect1);		deny: (empty1 intersects: empty2);		deny: (empty2 intersects: empty1).! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:29'!testRotate	| r1 c r1Left r1Right r1Pi |	r1 := 30@10 extent: 10@20.	c := 5@5.	r1Left := r1 rotateBy: #left centerAt: c.	r1Right := r1 rotateBy: #right centerAt: c.	r1Pi := r1 rotateBy: #pi centerAt: c.		self assert: r1 area = r1Left area description: 'rotation preserves area'.	self assert: r1 area = r1Right area description: 'rotation preserves area'.	self assert: r1 area = r1Pi area description: 'rotation preserves area'.		self assert: r1 extent transposed = r1Left extent.	self assert: r1 extent transposed = r1Right extent.	self assert: r1 extent = r1Pi extent.		self assert:  (r1 rotateBy: #pi centerAt: r1 center) = r1! !!RectangleTest methodsFor: 'testing' stamp: 'nice 6/20/2010 22:29'!testRotateEmpty	| r1 c r1Left r1Right r1Pi |	r1 := 30@10 corner: 10@20.	c := 5@5.	r1Left := r1 rotateBy: #left centerAt: c.	r1Right := r1 rotateBy: #right centerAt: c.	r1Pi := r1 rotateBy: #pi centerAt: c.		self assert: r1 area = r1Left area description: 'rotation preserves area'.	self assert: r1 area = r1Right area description: 'rotation preserves area'.	self assert: r1 area = r1Pi area description: 'rotation preserves area'.		self assert: r1 extent transposed = r1Left extent.	self assert: r1 extent transposed = r1Right extent.	self assert: r1 extent = r1Pi extent.		self assert:  (r1 rotateBy: #pi centerAt: r1 center) = r1! !"GraphicsTests"!!InstallerUpdateStream methodsFor: 'updates' stamp: 'nice 6/11/2010 21:25' prior: 57654784!parseUpdateListContents: listContentString	"Parse the contents of an updates.list into {{releaseTag. {fileNames*}}*}, and return it."	| sections releaseTag strm line fileNames |	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	releaseTag := nil.	strm := ReadStream on: listContentString.	[strm atEnd] whileFalse:		[line := strm nextLine.		line size > 0 ifTrue:			[line first = $#				ifTrue: [releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].						releaseTag := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	releaseTag ifNotNil: [sections addLast: {releaseTag. fileNames asArray}].	^ sections asArray! !"Installer-Core"!!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19' prior: 19502300!testEpoch	self assert: aDateAndTime =  '1901-01-01T00:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:19' prior: 19506189!testNoon	self assert: aDateAndTime noon = '1901-01-01T12:00:00+00:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20' prior: 19506473!testOffset	self assert: aDateAndTime offset =  '0:00:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '1901-01-01T00:00:00+12:00' asDateAndTime! !!DateAndTimeEpochTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:20' prior: 19509479!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:12:00:00') =  '1901-01-01T12:00:00+12:00' asDateAndTime! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:35'!testLn	self assert: ((1/100) ln closeTo: -2 * 10 ln).	self assert: (((2 raisedTo: Float emax + 11)/3) ln closeTo: (Float emax + 11)*2 ln - 3 ln) description: 'Fraction>>ln should not overflow'.	self assert: ((3/(2 raisedTo: Float precision - Float emin)) ln closeTo: (Float emin - Float precision)*2 ln + 3 ln) description: 'Fraction>>ln should not underflow'! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:37'!testLog	self assert: ((1/100) log closeTo: -2).	self assert: (((2 raisedTo: Float emax + 11)/3) log closeTo: (Float emax + 11)*2 log - 3 log) description: 'Fraction>>log should not overflow'.	self assert: ((3/(2 raisedTo: Float precision - Float emin)) log closeTo: (Float emin - Float precision)*2 log + 3 log) description: 'Fraction>>log should not underflow'! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21' prior: 19518172!testMidnight	self assert: aDateAndTime midnight =  '2004-02-29T00:00:00+00:00' asDateAndTime.	self deny: aDateAndTime midnight =  '2004-02-29T00:00:00+02:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21' prior: 19519063!testNoon	self assert: aDateAndTime noon =  '2004-02-29T12:00:00+00:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:21' prior: 19519213!testOffset	self assert: aDateAndTime offset =  '0:02:00:00' asDuration.     self assert: (aDateAndTime offset: '0:12:00:00') =  '2004-02-29T13:33:00+12:00' asDateAndTime! !!DateAndTimeLeapTest methodsFor: 'testing' stamp: 'cmm 6/14/2010 17:22' prior: 19520535!testUtcOffset     self assert: (aDateAndTime utcOffset: '0:02:00:00') =  '2004-02-29T13:33:00+02:00' asDateAndTime! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 5/28/2010 21:28'!testLn	self assert: (100 ln closeTo: 10 ln*2).	self assert: ((2 raisedTo: Float emax + 3) ln closeTo: 2 ln*(Float emax + 3)) description: 'Integer>>ln should not overflow'! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 6/12/2010 00:37'!testLog	self assert: (100 log closeTo: 2).	self assert: ((2 raisedTo: Float emax + 3) log closeTo: 2 log*(Float emax + 3)) description: 'Integer>>log should not overflow'! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'cmm 6/14/2010 17:23' prior: 19525736!testReadFromself assert: ('-1199-01-05T20:33:14.321-05:00' asDateAndTime printString = '-1199-01-05T20:33:14.321-05:00').self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').self assert: (' 2002-05-16T17:20' asDateAndTime printString = '2002-05-16T17:20:00+00:00').self assert: ('2002-05-16T17:20:45' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime = '2002-05-16T17:20:45-02:34' asDateAndTime).self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime = '2002-05-16T17:20:45+00:00' asDateAndTime).self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime = '1997-04-26T01:02:03+01:02:3' asDateAndTime)! !"KernelTests"!!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04' prior: 58063563!spyAllEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy all the system processes"	| myDelay time0 |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[true] whileTrue: [			| observedProcess startTime |			startTime := Time millisecondClockValue.			myDelay wait.			observedProcess := Processor preemptedProcess.			self				tally: observedProcess suspendedContext				in: observedProcess				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"			SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |				gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04' prior: 58065045!spyEvery: millisecs on: aBlock	"Create a spy and spy on the given block at the specified rate."	"Spy only on the active process (in which aBlock is run)"	| myDelay time0 observedProcess |	aBlock isBlock		ifFalse: [ self error: 'spy needs a block here' ].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	observedProcess := Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [		[ true ] whileTrue: [			| startTime |			startTime := Time millisecondClockValue.			myDelay wait.			self				tally: Processor preemptedProcess suspendedContext				in: (observedProcess == Processor preemptedProcess ifTrue: [observedProcess] ifFalse: [nil])				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	^ aBlock ensure: [		"cancel the probe and return the value"		"Could have already been terminated. See #terminateTimerProcess"		Timer ifNotNil: [			Timer terminate.			Timer := nil ].		"Collect gc statistics"		SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |			gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].		time := Time millisecondClockValue - time0 ]! !!MessageTally methodsFor: 'initialize-release' stamp: 'ul 6/21/2010 03:04' prior: 58066632!spyEvery: millisecs onProcess: aProcess forMilliseconds: msecDuration 	"Create a spy and spy on the given process at the specified rate."	| myDelay time0 endTime observedProcess sem |	(aProcess isKindOf: Process)		ifFalse: [self error: 'spy needs a Process here'].	self class: aProcess suspendedContext receiver class method: aProcess suspendedContext method.	"set up the probe"	observedProcess := aProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	endTime := time0 + msecDuration.	sem := Semaphore new.	gcStats := SmalltalkImage current getVMParameters.	Timer ifNotNil: [ self error: 'it seems a tally is already running' ].	Timer := [			[				| startTime |				startTime := Time millisecondClockValue.				myDelay wait.				self					tally: Processor preemptedProcess suspendedContext					in: (observedProcess == Processor preemptedProcess 						ifTrue: [ observedProcess ]						ifFalse: [ nil ])					"tally can be > 1 if ran a long primitive"					by: (Time millisecondClockValue - startTime) // millisecs.				startTime < endTime			] whileTrue.			sem signal.		] newProcess.	Timer priority: Processor timingPriority-1.		"activate the probe and evaluate the block"	Timer resume.	"activate the probe and wait for it to finish"	sem wait.	"Collect gc statistics"	SmalltalkImage current getVMParameters keysAndValuesDo: [ :idx :gcVal |		gcVal ifNotNil: [ gcStats at: idx put: (gcVal - (gcStats at: idx)) ] ].	time := Time millisecondClockValue - time0! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:21' prior: 54160291!summaryStringDelta: delta	"Answer the string summarizing this changeSet"		^ String streamContents:		[:s | | line author s2 ps intName date |		intName := self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps := self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 := ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date := s2 nextLine.			s2 match: 'Author:'; skipSeparators.  author := s2 nextLine.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line := s2 nextLine.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/8/2010 18:26'!standardSize	^ StandardSize! !!RealEstateAgent class methodsFor: 'accessing' stamp: 'cmm 6/9/2010 15:12'!standardSize: extent	StandardSize := extent! !!ProjectLauncher methodsFor: 'running' stamp: 'ar 6/21/2010 20:33' prior: 58616709!startUpAfterLogin	| scriptName loader isUrl |	self setupFlaps.	Preferences readDocumentAtStartup ifTrue: [		HTTPClient isRunningInBrowser ifTrue:[			self setupFromParameters.			scriptName := self parameterAt: 'src'.			CodeLoader defaultBaseURL: (self parameterAt: 'Base').		] ifFalse:[			scriptName := (Smalltalk documentPath) ifNil:[''].			scriptName := scriptName convertFromSystemString.			scriptName isEmpty ifFalse:[				"figure out if script name is a URL by itself"				isUrl := (scriptName asLowercase beginsWith:'http://') or:[						(scriptName asLowercase beginsWith:'file://') or:[						(scriptName asLowercase beginsWith:'ftp://')]].				isUrl ifFalse:[					"Allow for ../dir/scriptName arguments"					scriptName := (FileDirectory default uri 						resolveRelativeURI: scriptName) asString]].		]. ]	ifFalse: [ scriptName := '' ].	scriptName isEmptyOrNil		ifTrue:[^Preferences eToyFriendly ifTrue: [self currentWorld addGlobalFlaps]].	loader := CodeLoader new.	loader loadSourceFiles: (Array with: scriptName).	(scriptName asLowercase endsWith: '.pr') 		ifTrue:[self installProjectFrom: loader]		ifFalse:[loader installSourceFiles].! !!Utilities class methodsFor: 'miscellaneous' stamp: 'nice 6/11/2010 21:30' prior: 55315920!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict := Dictionary new.	report := ReadWriteStream on: ''.	f := FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f := FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className := items first.			newInstCount := items third asNumber.			newSpace := items fourth asNumber.			oldPair := instCountDict at: className ifAbsent: [nil].			oldInstCount := oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace := oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'common requests' stamp: 'nice 6/11/2010 21:55' prior: 55312656!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].		strings := CommonRequestStrings contents.	normalItemCount := strings asString lineCount.	aMenu := UIManager default 		chooseFrom: (strings asString lines copyWith: 'edit this menu')		lines: (Array with: normalItemCount).	index := aMenu startUp.	index == 0 ifTrue: [^ self].	reply := aMenu labelString lineNumber: index.	reply size == 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result := self evaluate: reply in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'fetching updates' stamp: 'nice 6/11/2010 21:30' prior: 55284392!parseListContents: listContents	| sections vers strm line fileNames |	"Parse the contents of updates.list into {{vers. {fileNames*}}*}, and return it."	sections := OrderedCollection new.	fileNames := OrderedCollection new: 1000.	vers := nil.	strm := ReadStream on: listContents.	[strm atEnd] whileFalse:		[line := strm nextLine.		line size > 0 ifTrue:			[line first = $#				ifTrue: [vers ifNotNil: [sections addLast: {vers. fileNames asArray}].						"Start a new section"						vers := line allButFirst.						fileNames resetTo: 1]				ifFalse: [line first = $* ifFalse: [fileNames addLast: line]]]].	vers ifNotNil: [sections addLast: {vers. fileNames asArray}].	^ sections asArray" TEST: | list |list := Utilities parseListContents: (FileStream oldFileNamed: 'updates.list') contentsOfEntireFile.list = (Utilities parseListContents: (String streamContents: [:s | Utilities writeList: list toStream: s]))	ifFalse: [self error: 'test failed']	ifTrue: [self inform: 'test OK']"! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26' prior: 58497610!cleanUp: aggressive except: exclusions	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	^self cleanUp: aggressive except: exclusions confirming: aggressive! !!SmalltalkImage methodsFor: 'housekeeping' stamp: 'ar 6/16/2010 18:26'!cleanUp: aggressive except: exclusions confirming: aBool	"Clean up. When aggressive is true, this will destroy projects, change sets, etc.	Leave out any classes specifically listed in exclusions."	"Smalltalk cleanUp: true except: {Project. ChangeSet}"	| classes |	aBool ifTrue:[		"Give the user a chance to bail"		(self confirm: 'Cleanup will destroy projects, change sets and more.Are you sure you want to proceed?') ifFalse:[^self].	].	"Find all classes implementing #cleanUp or cleanUp:"	classes := Smalltalk allClasses select:[:aClass| 		(aClass class includesSelector: #cleanUp) 			or:[aClass class includesSelector: #cleanUp:]	].	"Leave out the classes in the exclusion set"	classes := classes reject:[:aClass| exclusions includes: aClass].	"Arrange classes in superclass order, superclasses before subclasses.	This will ensure that specific cleanup (like MethodDictionary compaction)	will run after generic superclass cleanup (HashedCollection rehashing).	Otherwise generic superclass cleanup might undo specific one (in this	case rehashing will undo a good bit of MD compaction)."	classes := ChangeSet superclassOrder: classes.	"Run the cleanup code"	classes 		do:[:aClass| aClass cleanUp: aggressive]		displayingProgress:[:aClass| 'Cleaning up in ', aClass name].! !!SmalltalkImage methodsFor: 'vm' stamp: 'ar 6/21/2010 20:25'!isRunningCog	"Returns true if we're running Cog"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'special objects' stamp: 'ar 6/20/2010 16:20' prior: 58519841!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: nil. "Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizer ifAbsent: []).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray	! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'ar 6/16/2010 19:54' prior: 58601462!unloadAllKnownPackages	"Unload all packages we know how to unload and reload"	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	World removeAllMorphs.	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 'Installer-Core'		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC' 'ST80'		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols' 'XML-Parser' 'Tests' 'SUnitGUI'	) do:[:pkgName| (MCPackage named: pkgName) unload].	"Traits use custom unload"	Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits].	"Post-unload cleanup"	MCWorkingCopy flushObsoletePackageInfos.	SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	Smalltalk forgetDoIts.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.	MorphicProject defaultFill: (Color gray: 0.9).	World color: (Color gray: 0.9).! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'ar 6/14/2010 22:05' prior: 58472485!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		SmalltalkImage current vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime upTime2 fullGCs2 fullGCTime2 incrGCs2 incrGCTime2 tenureCount2 str |	params := self getVMParameters.	oldSpaceEnd			:= params at: 1.	youngSpaceEnd		:= params at: 2.	memoryEnd			:= params at: 3.	fullGCs				:= params at: 7.	fullGCTime			:= params at: 8.	incrGCs				:= params at: 9.	incrGCTime			:= params at: 10.	tenureCount			:= params at: 11.	upTime := Time millisecondClockValue.	str := WriteStream on: (String new: 1000).	str	nextPutAll: 'uptime			';		print: (upTime / 1000 / 60 // 60); nextPut: $h;		print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;		print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr.	str	nextPutAll: 'memory			';		nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.	str	nextPutAll:	'	old			';		nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	young		';		nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	used		';		nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';		print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: '	free		';		nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';		print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.	str	nextPutAll: 'GCs				';		nextPutAll: (fullGCs + incrGCs) asStringWithCommas.	fullGCs + incrGCs > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); 			nextPutAll: 'ms between GCs)'	].	str cr.	str	nextPutAll: '	full			';		print: fullGCs; nextPutAll: ' totalling '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs; nextPutAll: ' totalling '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime / upTime * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount asStringWithCommas.	tenureCount = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.LastStats ifNil: [LastStats := Array new: 6]ifNotNil: [	upTime2 := upTime - (LastStats at: 1).	fullGCs2 := fullGCs - (LastStats at: 2).	fullGCTime2 := fullGCTime - (LastStats at: 3).	incrGCs2 := incrGCs - (LastStats at: 4).	incrGCTime2 := incrGCTime - (LastStats at: 5).	tenureCount2 := tenureCount - (LastStats at: 6).	str	nextPutAll: self textMarkerForShortReport ;		nextPutAll: (fullGCs2 + incrGCs2) asStringWithCommas.	fullGCs2 + incrGCs2 > 0 ifTrue: [		str			nextPutAll: ' ('; 			print: ((upTime2 / (fullGCs2 + incrGCs2)) roundTo: 1); 			nextPutAll: 'ms between GCs)'.	].	str cr.	str	nextPutAll: '	uptime		'; print: ((upTime2 / 1000.0) roundTo: 0.1); nextPutAll: 's'; cr.	str	nextPutAll: '	full			';		print: fullGCs2; nextPutAll: ' totalling '; nextPutAll: fullGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((fullGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime)'.	fullGCs2 = 0 ifFalse:		[str	nextPutAll: ', avg '; print: ((fullGCTime2 / fullGCs2) roundTo: 1.0); nextPutAll: 'ms'].	str	cr.	str	nextPutAll: '	incr		';		print: incrGCs2; nextPutAll: ' totalling '; nextPutAll: incrGCTime2 asStringWithCommas; nextPutAll: 'ms (';		print: ((incrGCTime2 / upTime2 * 100) roundTo: 1.0);		nextPutAll: '% uptime), avg '.	incrGCs2 > 0 ifTrue: [		 str print: ((incrGCTime2 / incrGCs2) roundTo: 1.0); nextPutAll: 'ms'	].	str cr.	str	nextPutAll: '	tenures		';		nextPutAll: tenureCount2 asStringWithCommas.	tenureCount2 = 0 ifFalse:		[str nextPutAll: ' (avg '; print: (incrGCs2 / tenureCount2) asInteger; nextPutAll: ' GCs/tenure)'].	str	cr.].	LastStats at: 1 put: upTime.	LastStats at: 2 put: fullGCs.	LastStats at: 3 put: fullGCTime.	LastStats at: 4 put: incrGCs.	LastStats at: 5 put: incrGCTime.	LastStats at: 6 put: tenureCount.	^ str contents! !!SmalltalkImage methodsFor: 'vm statistics' stamp: 'nice 6/11/2010 21:28' prior: 29355087!vmStatisticsShortString	"Convenience item for access to recent statistics only"	"StringHolderView open: (StringHolder new contents: SmalltalkImage current vmStatisticsShortString)		label: 'VM Recent Statistics'"	^ (ReadStream on: self vmStatisticsReportString) upToAll: 'Since'; nextLine; upToEnd! !!ResourceManager class methodsFor: 'resource caching' stamp: 'nice 6/11/2010 21:27' prior: 55906828!reloadCachedResources	"ResourceManager reloadCachedResources"	"Reload cached resources from the disk"	| fd files stream url localName storeBack archiveName |	CachedResources := Dictionary new.	LocalizedExternalResources := nil.	fd := Project squeakletDirectory.	files := fd fileNames asSet.	stream := [fd readOnlyFileNamed: self resourceCacheName]				on: FileDoesNotExistException 				do:[:ex| fd forceNewFileNamed: self resourceCacheName].	stream size < 50000 ifTrue:[stream := ReadStream on: stream contentsOfEntireFile].	storeBack := false.	[stream atEnd] whileFalse:[		url := stream nextLine.			localName := stream nextLine.		(localName beginsWith: 'zip://') ifTrue:[			archiveName := localName copyFrom: 7 to: localName size.			(files includes: archiveName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true].		] ifFalse:[			(files includes: localName) 				ifTrue:[self addCacheLocation: localName for: url]				ifFalse:[storeBack := true]		].	].	stream close.	storeBack ifTrue:[		stream := fd forceNewFileNamed: self resourceCacheName.		CachedResources keysAndValuesDo:[:urlString :cacheLocs|			cacheLocs do:[:cacheLoc|				stream nextPutAll: urlString; cr.				stream nextPutAll: cacheLoc; cr].		].		stream close.	].! !!SpaceTally methodsFor: 'fileOut' stamp: 'nice 6/11/2010 21:28' prior: 52633485!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		SpaceTally new printSpaceAnalysis: 0 on: 'STspace.text2'.		SpaceTally new printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f := FileStream readOnlyFileNamed: fileName1.	coll1 := OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: f nextLine].	f close.	f := FileStream readOnlyFileNamed: fileName2.	coll2 := OrderedCollection new.	[f atEnd] whileFalse:		[item := f nextLine.		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!ChangeRecord methodsFor: 'access' stamp: 'eem 4/23/2007 10:37'!commentClass 	| commentClass |	type == #classComment ifFalse: [^ nil].	(Smalltalk includesKey: class asSymbol) ifFalse: [^ nil].	commentClass := Smalltalk at: class asSymbol.	^meta ifTrue: [commentClass class]		ifFalse: [commentClass]! !!ChangeRecord methodsFor: 'initialization' stamp: 'eem 7/17/2008 17:19' prior: 54084293!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := Smalltalk at: class asSymbol.				 cls := meta ifTrue: [cls class] ifFalse: [cls].				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[Utilities noteMethodSubmission: aSelector forClass: cls]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					Utilities noteMethodSubmission: #Comment forClass: cls ].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 5/18/2010 20:25' prior: 18207825!fileIndex	SourceFiles withIndexDo: [:sf :i| sf name = file name ifTrue: [^i]].	^nil! !!ChangeRecord methodsFor: 'access' stamp: 'cmm 6/21/2010 13:28' prior: 58574648!methodClass	| methodClassName methodClass |	type == #method ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk globals includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass := Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 9/6/2009 13:06' prior: 18209491!methodClassName	| text tokens |	(class isNil	and: [type = #doIt	and: [((text := self text) includes: $.) not "exclude multi-statement doits"	and: [(tokens := Scanner new scanTokens: text) size >= 4	and: [tokens first isSymbol	and: [tokens first isKeyword not	and: [tokens first first canBeGlobalVarInitial	and: [tokens includes: #instanceVariableNames:]]]]]]]) ifTrue:		["Could be a class definition.			Class definitions start with Superclass blahSubclass: #ClassName			Metaclass definitions start with ClassName class instanceVariableNames:"		 (tokens second isSymbol		  and: [tokens second isKeyword		  and: [tokens third isSymbol		  and: [tokens third isKeyword not		  and: [(2 to: tokens size by: 2) allSatisfy: [:i| (tokens at: i) isKeyword]]]]]) ifTrue:			[^tokens third].		 (tokens size = 4		  and: [tokens second = #class		  and: [tokens third = #instanceVariableNames:		  and: [tokens last isString]]]) ifTrue:			[^tokens first]].	^class! !Preferences class removeSelector: #workspaceWindowColor!Preferences class removeSelector: #versionsBrowserWindowColor!Preferences class removeSelector: #transcriptWindowColor!Preferences class removeSelector: #testRunnerWindowColor!Preferences class removeSelector: #preferenceBrowserWindowColor!Preferences class removeSelector: #packageLoaderWindowColor!Preferences class removeSelector: #packageBrowserWindowColor!Preferences class removeSelector: #monticelloToolWindowColor!Preferences class removeSelector: #methodFinderWindowColor!Preferences class removeSelector: #messageNamesWindowColor!Preferences class removeSelector: #messageListWindowColor!Preferences class removeSelector: #lexiconWindowColor!Preferences class removeSelector: #instanceBrowserWindowColor!Preferences class removeSelector: #fileListWindowColor!Preferences class removeSelector: #fileContentsBrowserWindowColor!Preferences class removeSelector: #dualChangeSorterWindowColor!Preferences class removeSelector: #defaultWindowColor!Preferences class removeSelector: #debuggerWindowColor!Preferences class removeSelector: #classCommentVersionsBrowserWindowColor!Preferences class removeSelector: #changeSorterWindowColor!Preferences class removeSelector: #changeListWindowColor!Preferences class removeSelector: #browserWindowColor!"System"!!PluggableSystemWindowWithLabelButton commentStamp: 'eem 6/29/2010 19:02' prior: 0!A PluggableSystemWindowWithLabelButton provides the pull-down menu of browser panes in the multi-pane browser.Instance Variables	labelButton:		<BrowserPaneButtonMorph>labelButton	- the labelButton is a hack to hold onto the panes of a multi-paned browser so that an inst var doesn't have to be added to the Browser hierarchy.!!SystemWindow commentStamp: '<historical>' prior: 59440910!SystemWindow is the Morphic equivalent of StandardSystemView -- a labelled container for rectangular views, with iconic facilities for close, collapse/expand, and resizing.The attribute onlyActiveOnTop, if set to true (and any call to activate will set this), determines that only the top member of a collection of such windows on the screen shall be active.  To be not active means that a mouse click in any region will only result in bringing the window to the top and then making it active.!!MultiWindowLabelButtonMorph commentStamp: 'eem 6/30/2010 16:13' prior: 0!A MultiWindowLabelButtonMorph is  a means of implementing tabbed windows.  It cooperates with PluggableSystemWindowWithButton to provide a drop-down menu of windows when clicking in the window label.  It requires the model to create a suitable sub-instance of SavedMultiWindowState for inactive windows.  To specify multi-windows use the multiWindowStyle: setter to customize a PluggableWindowSpec.Instance Variables	savedMultiWindowState:		<SavedMultiWindowState>savedMultiWindowState	- the sequence of models in a multi-window.!!MenuMorph methodsFor: 'construction' stamp: 'nice 6/11/2010 21:52' prior: 23650369!labels: labelList lines: linesArray selections: selectionsArray 	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelArray := (labelList isString) 				ifTrue: [labelList lines]				ifFalse: [labelList]. 	1 to: labelArray size		do: 			[:i | 			self add: (labelArray at: i) action: (selectionsArray at: i).			(linesArray includes: i) ifTrue: [self addLine]]! !!Canvas methodsFor: 'initialization' stamp: 'ar 6/17/2010 16:43'!finish: allDamage	"If there are any pending operations on the receiver complete them. 	Do not return before all modifications have taken effect."	^self finish! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'eem 6/24/2010 21:51' prior: 33718761!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk classNamed: #HelpBrowser) ifNotNil: 					[:classHelpBrowser|					menu addLine.					menu addItem: [ :item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: classHelpBrowser;							selector: #open ] ].			]].! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'nice 6/11/2010 21:52' prior: 58178093!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j |	menu := self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString := aPopupMenu labelString.	items := labelString asString lines.	labelString isText ifTrue:		["Pass along text emphasis if present"		j := 1.		items := items collect:			[:item | | emphasis |			j := labelString asString findString: item startingAt: j.			emphasis := TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines := aPopupMenu lineArray.	lines ifNil: [lines := #()].	menu cancelValue: 0.	menu defaultTarget: menu.	selections := (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) selector: #selectMVCItem: argument: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !!ProportionalSplitterMorph methodsFor: 'displaying' stamp: 'ar 6/23/2010 16:35' prior: 58957096!handleSize	^ self class splitterWidth @ 30! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 17:00' prior: 21481566!needsToBeDrawn	"Return true if this hand must be drawn explicitely instead of being drawn via the hardware cursor. This is the case if it (a) it is a remote hand, (b) it is showing a temporary cursor, or (c) it is not empty and there are any visible submorphs. If using the software cursor, ensure that the hardware cursor is hidden."	"Details:  Return true if this hand has a saved patch to ensure that is is processed by the world. This saved patch will be deleted after one final display pass when it becomes possible to start using the hardware cursor again. This trick gives us one last display cycle to allow us to remove the software cursor and shadow from the display."	(savedPatch notNil		or: [ (submorphs anySatisfy: [ :ea | ea visible ])			or: [ (temporaryCursor notNil and: [hardwareCursor isNil])				or: [ self hasUserInformation ]]])		ifTrue: [			"using the software cursor; hide the hardware one"			self showHardwareCursor: false.			^ true].	^ false! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:28' prior: 21484016!restoreSavedPatchOn: aCanvas 	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged := false.	savedPatch ifNotNil: 			[aCanvas drawImage: savedPatch at: savedPatch offset.			self hasUserInformation ifTrue: [^self].	"cannot use hw cursor if so"			submorphs notEmpty ifTrue: [^self].			(temporaryCursor notNil and: [hardwareCursor isNil]) ifTrue: [^self].			"Make the transition to using hardware cursor. Clear savedPatch and		 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset 						extent: savedPatch extent + self shadowOffset)				from: self.			self showHardwareCursor: true.			savedPatch := nil]! !!HandMorph methodsFor: 'drawing' stamp: 'ar 6/17/2010 16:52'!showHardwareCursor: aBool	"Show/hide the current hardware cursor as indicated."	| cursor |	cursor :=  hardwareCursor ifNil:[aBool ifTrue:[Cursor normal] ifFalse:[Cursor blank]].	Sensor currentCursor == cursor ifFalse: [cursor show].! !!HandMorph methodsFor: 'cursor' stamp: 'ar 6/17/2010 17:01' prior: 21474240!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset 	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	temporaryCursorOffset 		ifNotNil: [bounds := bounds translateBy: temporaryCursorOffset negated].	cursorOrNil isNil 		ifTrue: [temporaryCursor := temporaryCursorOffset := hardwareCursor := nil]		ifFalse: 			[temporaryCursor := cursorOrNil asCursorForm.			temporaryCursorOffset := temporaryCursor offset - hotSpotOffset.			(cursorOrNil isKindOf: Cursor) ifTrue: [hardwareCursor := cursorOrNil]].	bounds := self cursorBounds.	self		userInitials: userInitials andPicture: self userPicture;		layoutChanged;		changed;		showHardwareCursor: (temporaryCursor isNil).! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 19:51' prior: 54590543!displayWorld: aWorld submorphs: submorphs	"Update this world's display."	| deferredUpdateMode handsToDraw allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	self checkIfUpdateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode := self doDeferredUpdatingFor: aWorld.	deferredUpdateMode ifFalse: [self assuredCanvas].	canvas roundCornersOf: aWorld during:[ | handDamageRects worldDamageRects |		worldDamageRects := self drawWorld: aWorld submorphs: submorphs invalidAreasOn: canvas.  "repair world's damage on canvas"		"self handsDo:[:h| h noticeDamageRects: worldDamageRects]."		handsToDraw := self selectHandsToDrawForDamage: worldDamageRects.		handDamageRects := handsToDraw collect: [:h | h savePatchFrom: canvas].		allDamage := worldDamageRects, handDamageRects.		handsToDraw reverseDo: [:h | canvas fullDrawMorph: h].  "draw hands onto world canvas"	].	"*make this true to flash damaged areas for testing*"	Preferences debugShowDamage ifTrue: [aWorld flashRects: allDamage color: Color black].	canvas finish: allDamage.	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [self forceDamageToScreen: allDamage]		ifFalse: [canvas showAt: aWorld viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!WorldState methodsFor: 'update cycle' stamp: 'ar 6/17/2010 16:04' prior: 53154502!doDeferredUpdatingFor: aWorld        "If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	| properDisplay |	PasteUpMorph disableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	remoteServer ifNotNil:[		self assuredCanvas.		^true].	properDisplay := canvas notNil and: [canvas form == Display].	aWorld == World ifTrue: [  "this world fills the entire Display"		properDisplay ifFalse: [			aWorld viewBox: Display boundingBox.    "do first since it may clear canvas"			self canvas: (Display getCanvas copyClipRect: Display boundingBox).		]	].	^ true! !!Morph methodsFor: 'events-processing' stamp: 'bf 6/24/2010 13:15' prior: 24159366!handleMouseDown: anEvent	"System level event handling."	anEvent wasHandled ifTrue:[^self]. "not interested"	anEvent hand removePendingBalloonFor: self.	anEvent hand removePendingHaloFor: self.	anEvent wasHandled: true.	(anEvent controlKeyPressed			and: [anEvent blueButtonChanged not				and: [Preferences cmdGesturesEnabled]])		ifTrue: [^ self invokeMetaMenu: anEvent].	"Make me modal during mouse transitions"	anEvent hand newMouseFocus: self event: anEvent.	anEvent blueButtonChanged ifTrue:[^self blueButtonDown: anEvent].		"this mouse down could be the start of a gesture, or the end of a gesture focus"	(self isGestureStart: anEvent)		ifTrue: [^ self gestureStart: anEvent].	self mouseDown: anEvent.	Preferences maintainHalos		ifFalse:[ anEvent hand removeHaloFromClick: anEvent on: self ].	(self handlesMouseStillDown: anEvent) ifTrue:[		self startStepping: #handleMouseStillDown: 			at: Time millisecondClockValue + self mouseStillDownThreshold			arguments: {anEvent copy resetHandlerFields}			stepTime: self mouseStillDownStepRate ].! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 8/10/2007 16:58' prior: 51237360!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect := aClipRect.	patchRect := (aDisplayTransform globalBoundsToLocal: innerRect) truncated.	sourceQuad := (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp := self warpFrom: sourceQuad toRect: innerRect.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start := (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas := self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; cellSize: cellSize; warpBits.		warp sourceForm: nil.  subCanvas := nil "release space for next loop"]! !!PasteUpMorph methodsFor: 'project state' stamp: 'ar 6/17/2010 20:00'!canvas: aCanvas	"Set this world's canvas"	worldState canvas: aCanvas.! !!PasteUpMorph methodsFor: 'change reporting' stamp: 'ar 6/17/2010 17:28' prior: 25784325!invalidRect: damageRect from: aMorph	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [worldState recordDamagedRect: damageRect].	^super invalidRect: damageRect from: aMorph! !!PluggableSystemWindowWithLabelButton methodsFor: 'resize/collapse' stamp: 'eem 5/6/2008 12:58'!adjustExtraButton	labelButton ifNil: [^self].	labelButton		position: self innerBounds topLeft + (20 @ -3);		extent: self innerBounds extent * (0.4@1)! !!PluggableSystemWindowWithLabelButton methodsFor: 'geometry' stamp: 'eem 5/6/2008 10:45'!extent: newExtent	super extent: newExtent.	self adjustExtraButton! !!PluggableSystemWindowWithLabelButton methodsFor: 'events' stamp: 'eem 6/30/2010 16:47'!mouseDown: evt	| wasInactive |	wasInactive := TopWindow ~~ self.	self valueOfProperty: #clickPoint ifPresentDo: 		[:firstClick |		(labelButton containsPoint: evt cursorPoint) ifTrue:			[^labelButton mouseDown: evt]].	super mouseDown: evt.	(wasInactive	 and: [model windowActiveOnFirstClick not	 and: [labelButton containsPoint: evt cursorPoint]]) ifTrue:		[^labelButton mouseDown: evt]! !!PluggableSystemWindowWithLabelButton methodsFor: 'top window' stamp: 'eem 5/6/2008 11:39'!passivate	super passivate.	self removeProperty: #clickPoint! !!PluggableSystemWindowWithLabelButton methodsFor: 'accessing' stamp: 'eem 6/30/2010 18:56'!savedMultiWindowState: aSavedMultiWindowState	labelButton := MultiWindowLabelButtonMorph						on: aSavedMultiWindowState						getState: nil						action: #selectWindowsMenu.	labelButton		triggerOnMouseDown: true;		savedMultiWindowState: aSavedMultiWindowState.	labelButton		layoutFrame: (LayoutFrame "i.e. in the left 40% of the title bar"						fractions: (0@0 corner: 0.4@0)						offsets: (20@ -20 corner: 0@0));		hResizing: #spaceFill;		vResizing: #spaceFill.	self addMorphFront: labelButton.	self adjustExtraButton! !!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:12'!resizeAlongEdges	<preference: 'Resize Windows along edges'		category: 'Morphic'		description: 'When true, windows can be resized along their edges as well as the corners'		type: #Boolean>	^ResizeAlongEdges ifNil:[true]! !!SystemWindow class methodsFor: 'preferences' stamp: 'ar 6/23/2010 17:13'!resizeAlongEdges: aBool	"Preference setter"	ResizeAlongEdges := aBool! !!SystemWindow methodsFor: 'initialization' stamp: 'ar 6/23/2010 17:13'!addCornerGrips	"When enabled via preference, also add edge grips"	super addCornerGrips.	self class resizeAlongEdges ifTrue:[self addEdgeGrips].! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'cmm 6/20/2010 16:54' prior: 52764322!collapseOrExpand	"Collapse or expand the window, depending on existing state"	| cf |	isCollapsed		ifTrue: 			["Expand -- restore panes to morphics structure"			isCollapsed := false.			self activate.  "Bring to frint first"			Preferences collapseWindowsInPlace				ifTrue: 					[fullFrame := fullFrame align: fullFrame topLeft with: self getBoundsWithFlex topLeft]				ifFalse:					[collapsedFrame := self getBoundsWithFlex].			collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse this window'].			self setBoundsWithFlex: fullFrame.			paneMorphs reverseDo: 					[:m |  self addMorph: m unlock.					self world startSteppingSubmorphsOf: m].			self addPaneSplitters]		ifFalse: 			["Collapse -- remove panes from morphics structure"			isCollapsed := true.			fullFrame := self getBoundsWithFlex.			"First save latest fullFrame"			paneMorphs do: [:m | m delete; releaseCachedState].			self removePaneSplitters.			self removeCornerGrips.			model modelSleep.			cf := self getCollapsedFrame.			(collapsedFrame isNil and: [Preferences collapseWindowsInPlace not]) ifTrue:				[collapsedFrame := cf].			self setBoundsWithFlex: cf.			collapseBox ifNotNil: [collapseBox setBalloonText: 'expand this window'].			expandBox ifNotNil: [expandBox setBalloonText: 'expand to full screen'].			self sendToBack].	self layoutChanged! !!SystemWindow methodsFor: 'open/close' stamp: 'eem 5/23/2008 13:17' prior: 52758255!delete	| thisWorld sketchEditor aPaintBox |	self mustNotClose ifTrue: [^self].	model okToClose ifFalse: [^self].	thisWorld := self world.	sketchEditor := self extantSketchEditor.	self isFlexed		ifTrue: [owner delete]		ifFalse: [super delete].	model windowIsClosing; release.	model := nil.	sketchEditor ifNotNil:		[sketchEditor deleteSelfAndSubordinates.		 (thisWorld notNil 		  and: [(aPaintBox := thisWorld paintBoxOrNil) notNil]) ifTrue:			[aPaintBox delete]].			SystemWindow noteTopWindowIn: thisWorld! !!TheWorldMenu methodsFor: 'construction' stamp: 'cmm 6/13/2010 20:39' prior: 53553284!changesMenu        "Build the changes menu for the world."        | menu |        menu := self menu: 'changes...'.        self fillIn: menu from: {                { 'file out current change set' . { ChangeSet current . #verboseFileOut}.                                'Write the current change set out to a file whose name reflects the change set name and the current date & time.'}.                { 'create new change set...' . { ChangeSet . #newChangeSet}. 'Create a new change set and make it the current one.'}.                { 'browse changed methods' . { ChangeSet  . #browseChangedMessages}.  'Open a message-list browser showing all methods in the current change set'}.                { 'check change set for slips' . { self  . #lookForSlips}.                                'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'}.                nil.                { 'simple change sorter' . {self. #openChangeSorter1}.  'Open a 3-paned changed-set viewing tool'}.                { 'dual change sorter' . {self. #openChangeSorter2}.                                'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'}.               { 'find a change sorter (C)' . { #myWorld . #findAChangeSorter: }. 'Brings an open change sorter to the front, creating one if necessary, and makes it the active window'}.                nil.                { 'browse recent submissions (R)' . { Utilities . #browseRecentSubmissions}.                                'Open a new recent-submissions browser.  A recent-submissions browser is a message-list browser that shows the most recent methods that have been submitted.  If you submit changes within that browser, it will keep up-to-date, always showing the most recent submissions.'}.			nil.                { 'recently logged changes...' . { self . #browseRecentLog}.'Open a change-list browser on the latter part of the changes log.  You can use this browser to recover logged changes which were not saved in your image, in the event of a crash or other interruption.'}.                { 'recent log file...' . { Smalltalk . #writeRecentToFile}.                                'Create a file holding the logged changes (going as far back as you wish), and open a window on that file.'}.                nil.                { 'save world as morph file' . {self. #saveWorldInFile}. 'Save a file that, when reloaded, reconstitutes the current World.'}.                nil.        }.        ^ menu! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'ar 6/23/2010 17:09'!addEdgeGrips	"Add resizers along the four edges of the receiver"	self		addMorphBack: (TopGripMorph new target: self;position: self position).	self		addMorphBack: (BottomGripMorph new target: self;position: self position).	self		addMorphBack: (RightGripMorph new target: self;position: self position).	self		addMorphBack: (LeftGripMorph new target: self;position: self position).! !!TextEditor methodsFor: 'menu messages' stamp: 'cmm 5/25/2010 12:59' prior: 58414502!prettyPrint: decorated 	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	selectedClass := model selectedClassOrMetaClass.	selectedClass ifNil: [ ^ morph flash ].	newText := selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[ self			deselect ;			selectInvisiblyFrom: 1			to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: self text size + 1 ]! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/20/2010 13:33'!drawOn: aCanvas	"aCanvas fillRectangle: self bounds color: Color red" "for debugging"! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:22'!setDefaultColors! !!BorderGripMorph methodsFor: 'as yet unclassified' stamp: 'spfa 4/19/2010 22:21'!setInverseColors! !!BottomGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:37'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!BottomGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 1 corner: 1 @ 1)		offsets: (0 @ self defaultHeight negated corner: 0@ 0)! !!BottomGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!ptName	^#bottom! !!BottomGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:37'!resizeCursor	^ Cursor resizeForEdge: #top! !!LeftGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:41'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!LeftGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:27'!defaultWidth	^ 5! !!LeftGripMorph methodsFor: 'accessing' stamp: 'ar 6/23/2010 16:51'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 0 @ 1)		offsets: (0 @ 0 negated corner: self defaultWidth @ 0)! !!LeftGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!ptName	^#left! !!LeftGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:41'!resizeCursor	^ Cursor resizeForEdge: #left! !!RightGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:39'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!RightGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultWidth	^ 5! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:32'!gripLayoutFrame	^ LayoutFrame		fractions: (1 @ 0 corner: 1 @ 1)		offsets: (self defaultWidth negated @ self defaultHeight negated corner: 0@ 0)! !!RightGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self vResizing: #spaceFill.! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!ptName	^#right! !!RightGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:40'!resizeCursor	^ Cursor resizeForEdge: #right! !!TopGripMorph methodsFor: 'target resize' stamp: 'spfa 8/15/2009 11:22'!apply: delta 	| oldBounds |	oldBounds := target bounds.	target		bounds: (oldBounds origin + (delta x @ 0) corner: oldBounds corner + (0 @ delta y))! !!TopGripMorph methodsFor: 'initialize' stamp: 'spfa 4/20/2010 13:28'!defaultHeight	^ 5! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 4/20/2010 13:31'!gripLayoutFrame	^ LayoutFrame		fractions: (0 @ 0 corner: 1 @ 0)		offsets: (0 @ -40  corner: 0@ 0)! !!TopGripMorph methodsFor: 'initialize' stamp: 'ar 6/23/2010 17:01'!initialize	super initialize.	self hResizing: #spaceFill.! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!ptName	^#top! !!TopGripMorph methodsFor: 'accessing' stamp: 'spfa 8/15/2009 11:23'!resizeCursor	^ Cursor resizeForEdge: #top! !!BalloonCanvas methodsFor: 'drawing' stamp: 'jcg 11/17/2008 17:03' prior: 17206097!line: pt1 to: pt2 width: w color: c	"Draw a line from pt1 to: pt2"	(aaLevel == 1 and: [self ifNoTransformWithIn:(pt1 rect: pt2)])		ifTrue:[^super line: pt1 to: pt2 width: w color: c].	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:56' prior: 51317036!dragTarget: event	"Begin dragging the target"	| thePoint |	event controlKeyPressed ifTrue: [^self growTarget: event].	growingOrRotating := false.	thePoint := target point: event position - positionOffset from: owner.	target setConstrainedPosition: thePoint hangOut: true.	event hand newMouseFocus: self.! !!HaloMorph methodsFor: 'events' stamp: 'bf 6/24/2010 14:44'!growTarget: event	"Begin resizing the target"	growingOrRotating := true.	positionOffset := event position.	originalExtent := target extent.	self removeAllHandlesBut: nil.	event hand newMouseFocus: self.	event hand addMouseListener: self. "add handles back on mouse-up"! !!HaloMorph methodsFor: 'event handling' stamp: 'bf 6/24/2010 15:40' prior: 51319462!mouseMove: evt	"Drag our target around or resize it"	growingOrRotating		ifTrue: [			| oldExtent newExtent newPosition |			newExtent := originalExtent + (evt position - positionOffset * 2).			(newExtent x > 1 and: [newExtent y > 1])				ifTrue: [					oldExtent := target extent.					target setExtentFromHalo: newExtent.					newPosition := target position - (target extent - oldExtent // 2).					target setConstrainedPosition: newPosition hangOut: true]]		ifFalse: [			| thePoint |			thePoint := target point: (evt position - positionOffset) from: owner.			target setConstrainedPosition: thePoint hangOut: true.		]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'ar 6/17/2010 19:52' prior: 56624449!accept 	"Inform the model of text to be accepted, and return true if OK."	| ok saveSelection saveScrollerOffset |"sps 8/13/2001 22:41: save selection and scroll info"	saveSelection := self selectionInterval copy.	saveScrollerOffset := scroller offset copy.	(self canDiscardEdits and: [(self hasProperty: #alwaysAccept) not])		ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method may have beenchanged elsewhere since you startedediting it here.  Accept anyway?' translated) ifFalse: [^ self flash]].	ok := self acceptTextInModel.	ok==true ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false.		(model dependents detect: [:dep | (dep isKindOf: PluggableTextMorph) and: [dep getTextSelector == #annotation]] ifNone: [nil]) ifNotNil:			[:aPane | model changed: #annotation]].	"sps 8/13/2001 22:41: restore selection and scroll info"	["During the step for the browser, updateCodePaneIfNeeded is called, and 		invariably resets the contents of the codeholding PluggableTextMorph		at that time, resetting the cursor position and scroller in the process.		The following line forces that update without waiting for the step, 		then restores the cursor and scrollbar"	ok ifTrue: "(don't bother if there was an error during compile)"		[(model respondsTo: #updateCodePaneIfNeeded) 			ifTrue: [model updateCodePaneIfNeeded].		WorldState addDeferredUIMessage:			[self currentHand newKeyboardFocus: textMorph.			scroller offset: saveScrollerOffset.			self setScrollDeltas.			selectionInterval := saveSelection. "restore prior selection"			self selectFrom: saveSelection first to: saveSelection last]]]			on: Error do: []! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48' prior: 26493780!extent: newExtent	bounds extent = newExtent ifTrue: [^ self].	super extent: (newExtent max: 36@16).	self setScrollDeltas! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 10:17' prior: 56621260!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph notNil ifTrue:		["the current selection gets munged by resetting the extent, so store it"		tempSelection := self selectionInterval.				"don't reset it if it's not active"		tempSelection = (Interval from: 1 to: 0) 						ifTrue: [retractableScrollBar							ifTrue:[ ^ self]].		self extent: self extent.		self setSelection: tempSelection].	super resetExtent.! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'ar 6/15/2010 20:48'!resizeScroller	"Also needs to resize the text morph"	super resizeScroller.	textMorph ifNotNil:		[textMorph extent: (self innerBounds width-6)@self height].! !!TextComposer methodsFor: 'as yet unclassified' stamp: 'cmm 6/13/2010 20:50' prior: 52882537!composeLinesFrom: argStart to: argStop delta: argDelta into: argLinesCollection priorLines: argPriorLines atY: argStartY textStyle: argTextStyle text: argText container: argContainer wantsColumnBreaks: argWantsColumnBreaks	wantsColumnBreaks := argWantsColumnBreaks.	lines := argLinesCollection.	theTextStyle := argTextStyle.	theText := argText.	theContainer := argContainer.	deltaCharIndex := argDelta.	currCharIndex := startCharIndex := argStart.	stopCharIndex := argStop.	prevLines := argPriorLines.	currentY := argStartY.	maxRightX := theContainer left.	possibleSlide := stopCharIndex < theText size and: [theContainer isMemberOf: Rectangle].	nowSliding := false.	prevIndex := 1.	scanner := CompositionScanner new text: theText textStyle: theTextStyle.	scanner wantsColumnBreaks: wantsColumnBreaks.	defaultLineHeight := scanner canComputeDefaultLineHeight		ifTrue: [ scanner computeDefaultLineHeight ]		ifFalse: [ theTextStyle lineGrid. ].	isFirstLine := true.	self composeAllLines.	isFirstLine ifTrue: ["No space in container or empty text"		self 			addNullLineWithIndex: startCharIndex			andRectangle: (theContainer topLeft extent: 0@defaultLineHeight)	] ifFalse: [		self fixupLastLineIfCR	].	^{lines asArray. maxRightX}! !!MultiWindowLabelButtonMorph methodsFor: 'drawing' stamp: 'eem 5/6/2008 13:24'!drawOn: aCanvas 	"Be invisible."! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 17:03'!performAction	"Override to interpret the actionSelector as a menu accessor and to activate that menu."	actionSelector ifNotNil:		[(model perform: actionSelector) ifNotNil:			[:menu|			menu				invokeModalAt: self position - (0@5)				in: ActiveWorld				allowKeyboard: Preferences menuKeyboardControl]]! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState	"Answer the value of savedMultiWindowState"	^ savedMultiWindowState! !!MultiWindowLabelButtonMorph methodsFor: 'accessing' stamp: 'eem 6/30/2010 16:09'!savedMultiWindowState: anObject	"Set the value of savedMultiWindowState"	savedMultiWindowState := anObject! !"Morphic"!!UTF8TextConverter methodsFor: 'conversion' stamp: 'ul 5/26/2010 02:20' prior: 59040175!nextFromStream: aStream	| character value1 value2 unicode value3 value4 |	aStream isBinary ifTrue: [ ^aStream basicNext ].	character := aStream basicNext ifNil: [ ^nil ].	value1 := character asciiValue.	value1 <= 127 ifTrue: [ ^character ]. "1-byte character" 	"at least 2-byte character"	character := aStream basicNext ifNil: [ ^self errorMalformedInput ].	value2 := character asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63) ].	"at least 3-byte character"	character := aStream basicNext ifNil: [ ^self errorMalformedInput ].	value3 := character asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63) ].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte character"		character := aStream basicNext ifNil: [ ^self errorMalformedInput ].		value4 := character asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63) ].	unicode ifNil: [ ^self errorMalformedInput ].	unicode > 16r10FFFD ifTrue: [ ^self errorMalformedInput ].	unicode = 16rFEFF ifTrue: [ ^self nextFromStream: aStream ].	^ Unicode value: unicode.! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:03' prior: 51905758!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!EUCTextConverter methodsFor: 'conversion' stamp: 'ul 5/26/2010 04:00' prior: 53383015!nextFromStream: aStream	| character1 character2 offset value1 value2 nonUnicodeChar |	aStream isBinary ifTrue: [^ aStream basicNext].	character1 := aStream basicNext ifNil: [^ nil].	character1 asciiValue <= 127 ifTrue: [^ character1].	character2 := aStream basicNext ifNil: [^ nil].	offset := 16rA1.	value1 := character1 asciiValue - offset.	value2 := character2 asciiValue - offset.	(value1 < 0 or: [value1 > 93]) ifTrue: [^ nil].	(value2 < 0 or: [value2 > 93]) ifTrue: [^ nil].	nonUnicodeChar := Character leadingChar: self leadingChar code: value1 * 94 + value2.	^ Character leadingChar: self languageEnvironment leadingChar code: nonUnicodeChar asUnicode.! !!CombinedChar class methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:21' prior: 56354756!parseCompositionMappingFrom: stream"	self halt.	self parseCompositionMapping"	| line fieldEnd point fieldStart compositions toNumber diacritical result |	toNumber := [:quad | ('16r', quad) asNumber].	Compositions := IdentityDictionary new: 2048.	Decompositions := IdentityDictionary new: 2048.	Diacriticals := IdentitySet new: 2048.	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := ('16r', (line copyFrom: 1 to: fieldEnd - 1)) asNumber.		2 to: 6 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		compositions := line copyFrom: fieldStart to: fieldEnd - 1.		(compositions size > 0 and: [compositions first ~= $<]) ifTrue: [			compositions := compositions substrings collect: toNumber.			compositions size > 1 ifTrue: [				diacritical := compositions first.				Diacriticals add: diacritical.				result := compositions second.				(Decompositions includesKey: point) ifTrue: [					self error: 'should not happen'.				] ifFalse: [					Decompositions at: point put: (Array with: diacritical with: result).				].				(Compositions includesKey: diacritical) ifTrue: [					(Compositions at: diacritical) at: result put: point.				] ifFalse: [					Compositions at: diacritical						put: (IdentityDictionary new at: result put: point; yourself).				].			].		].	].! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 5/26/2010 04:13' prior: 51899223!peekFor: item 	| next state |	"self atEnd ifTrue: [^ false]. -- SFStream will give nil"	state := converter saveStateOf: self.	(next := self next) ifNil: [^ false].	item = next ifTrue: [^ true].	converter restoreStateOf: self with: state.	^ false.! !!Unicode class methodsFor: 'class methods' stamp: 'nice 6/11/2010 21:29' prior: 56350120!parseUnicodeDataFrom: stream"	self halt.	self parseUnicodeDataFile"	| line fieldEnd point fieldStart toNumber generalCategory decimalProperty |	toNumber := [:quad | ('16r', quad) asNumber].	GeneralCategory := SparseLargeTable new: 16rE0080 chunkSize: 1024 arrayClass: Array base: 1 defaultValue:  'Cn'.	DecimalProperty := SparseLargeTable new: 16rE0080 chunkSize: 32 arrayClass: Array base: 1 defaultValue: -1.	16r3400 to: 16r4DB5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16r4E00 to: 16r9FA5 do: [:i | GeneralCategory at: i+1 put: 'Lo'].	16rAC00 to: 16rD7FF do: [:i | GeneralCategory at: i+1 put: 'Lo'].	[(line := stream nextLine) size > 0] whileTrue: [		fieldEnd := line indexOf: $; startingAt: 1.		point := toNumber value: (line copyFrom: 1 to: fieldEnd - 1).		point > 16rE007F ifTrue: [			GeneralCategory zapDefaultOnlyEntries.			DecimalProperty zapDefaultOnlyEntries.			^ self].		2 to: 3 do: [:i |			fieldStart := fieldEnd + 1.			fieldEnd := line indexOf: $; startingAt: fieldStart.		].		generalCategory := line copyFrom: fieldStart to: fieldEnd - 1.		GeneralCategory at: point+1 put: generalCategory.		generalCategory = 'Nd' ifTrue: [			4 to: 7 do: [:i |				fieldStart := fieldEnd + 1.				fieldEnd := line indexOf: $; startingAt: fieldStart.			].			decimalProperty :=  line copyFrom: fieldStart to: fieldEnd - 1.			DecimalProperty at: point+1 put: decimalProperty asNumber.		].	].	GeneralCategory zapDefaultOnlyEntries.	DecimalProperty zapDefaultOnlyEntries.! !"Multilingual"!!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23' prior: 51069272!readFrom: aStream	"Private"	| header |	header := aStream nextLine.	(header = 'Event Tape v1 BINARY') ifTrue:[^aStream fileInObjectAndCode].	(header = 'Event Tape v1 ASCII') ifTrue:[^self readFromV1: aStream].	"V0 had no header so guess"	aStream reset.	header first isDigit ifFalse:[^self convertV0Tape: (aStream fileInObjectAndCode)].	^self convertV0Tape: (self readFromV0: aStream).! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:23' prior: 54183309!readFromV0: aStream	^Array streamContents:[:tStream | | evt line t lineStream |		[aStream atEnd] whileFalse:			[line := aStream nextLine.			line isEmpty "Some MW tapes have an empty record at the end"				ifFalse: [lineStream := ReadStream on: line.						t := Integer readFrom: lineStream.						[lineStream peek isLetter] whileFalse: [lineStream next].						evt := MorphicEvent readFromObsolete: lineStream.						tStream nextPut: t -> evt]]].! !!EventRecorderMorph methodsFor: 'fileIn/Out' stamp: 'nice 6/11/2010 21:24' prior: 51072021!readFromV1: aStream	^Array streamContents:[:tStream |		[aStream atEnd] whileFalse:[			tStream nextPut: (MorphicEvent readFromString: aStream nextLine)]]! !!PostscriptCanvas methodsFor: 'private' stamp: 'cmm 6/21/2010 14:31' prior: 52210791!setColor: color 	(color notNil and: [ currentColor ~= color ]) ifTrue:		[ target write: color asColor.		currentColor := color ]! !!TextOnCurve methodsFor: 'display' stamp: 'bf 6/17/2010 19:19' prior: 54242838!displayOn: aCanvas using: displayScanner at: somePosition	"Send all visible lines to the displayScanner for display"	| warp lineRect lineCanvas backgroundColor lineForm leftInRun sourceQuad maxExtent |	"most of these temps are initialized lazily and need to be at the method level - do not move into the block below!!"	warp := nil.	self textSegmentsDo:		[:line :destRect :segStart :segAngle |		false ifTrue:			["Show the dest rects for debugging..."			aCanvas frameRectangle: destRect width: 1 color: Color black].		(aCanvas isVisible: destRect) ifTrue:			[warp ifNil:				["Lazy initialization because may not have to display at all."				maxExtent := lines inject: lines first rectangle extent 					into: [:maxWid :lin | maxWid max: lin rectangle extent].				lineForm := Form extent: maxExtent depth: aCanvas depth.				displayScanner setDestForm: lineForm.				lineRect := lineForm boundingBox.				leftInRun := 0.				backgroundColor := (curve borderWidth > 10							ifTrue: [curve color]							ifFalse: [curve owner isHandMorph									ifTrue: [curve owner owner color]									ifFalse: [curve owner color]]) dominantColor.				warp := (aCanvas warpFrom: lineRect corners toRect: lineRect)						cellSize: 2;  "installs a colormap if smoothing > 1"						sourceForm: lineForm.				warp colorMap: (self warpMapForDepth: aCanvas depth									withTransparentFor: backgroundColor).				lineCanvas := lineForm getCanvas].			sourceQuad := destRect innerCorners collect:				[:p | self pointInLine: line forDestPoint: p						segStart: segStart segAngle: segAngle].			lineForm fill: lineForm boundingBox fillColor: backgroundColor.			self displaySelectionInLine: line on: lineCanvas.			leftInRun := displayScanner displayLine: line offset: 0@0 leftInRun: leftInRun.			warp sourceQuad: sourceQuad destRect: (destRect translateBy: aCanvas origin).			warp warpBits]].! !"MorphicExtras"!!TextAnchorTest methodsFor: 'initialize-release' stamp: 'cmm 6/12/2010 22:46'!testBeginWithAnAnchor	| text morph model |	text := Text streamContents:		[ : stream | stream			 nextPutAll:			(Text				string: (String value: 1)				attributes: {TextAnchor new anchoredMorph: Morph new. 					TextColor color: Color transparent}) ;			 nextPutAll: ' should be able to begin with an embedded object. ' ].	model := text -> nil.	morph := PluggableTextMorph		on: model		text: #key		accept: nil.	[ morph openInWorld ] ensure: [ morph delete ]! !"MorphicTests"!!MailMessage methodsFor: 'parsing' stamp: 'nice 6/11/2010 21:26' prior: 23410053!readStringLineFrom: aStream 	"Read and answer the next line from the given stream. Consume the carriage return but do not append it to the string."	^aStream nextLine! !!Password methodsFor: 'as yet unclassified' stamp: 'nice 6/11/2010 21:52' prior: 52103862!serverPasswords	"Get the server passwords off the disk and decode them. The file 'sqk.info' must be in some folder that Squeak thinks is special (vm folder, or default directory).  (Note: This code works even if you are running with no system sources file.)"	| sfile |	(sfile := FileDirectory lookInUsualPlaces: 'sqk.info') ifNil: [^ nil].		"If not there, Caller will ask user for password"		"If you don't have this file, and you really do want to release an update, 		 contact Ted Kaehler."	^ (self decode: (sfile contentsOfEntireFile)) lines! !"Network"!!PackageOrganizer methodsFor: 'registering' stamp: 'ar 6/16/2010 19:57'!flushObsoletePackages: aBlock	"Flush all packages considered obsolete by evaluating the argument block."	packages keys do:[:key|		(aBlock value: (packages at: key)) ifTrue:[packages removeKey: key].	].	self changed: #packages; changed: #packageNames.! !"PackageInfo-Base"!!Lexicon methodsFor: 'senders' stamp: 'nice 3/24/2010 23:21' prior: 56983634!navigateToASender	"Present the user with a list of senders of the currently-selected 	message, and navigate to the chosen one"	| selectorSet chosen aSelector |	aSelector := self selectedMessageName.	selectorSet := Set new.	(self systemNavigation allCallsOn: aSelector)		do: [:anItem | selectorSet add: anItem methodSymbol].	selectorSet := selectorSet				select: [:sel | currentVocabulary						includesSelector: sel						forInstance: self targetObject						ofClass: targetClass						limitClass: limitClass].	selectorSet size = 0		ifTrue: [^ Beeper beep].	self okToChange		ifFalse: [^ self].	chosen := UIManager default chooseFrom: selectorSet asSortedArray values: selectorSet asSortedArray.	chosen isEmptyOrNil		ifFalse: [self displaySelector: chosen]! !"Protocols"!!ControlManager methodsFor: 'scheduling' stamp: 'nice 6/11/2010 21:50' prior: 19310059!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'nice 6/11/2010 21:50' prior: 19315513!windowFromUser	"Present a menu of window titles, and returns the StandardSystemController belonging to the one that gets chosen, or nil if none"	| controllers labels index |	controllers := OrderedCollection new.	labels := String streamContents:		[:strm |		scheduledControllers do:			[:controller | controller == screenController ifFalse:				[controllers addLast: controller.				strm nextPutAll: (controller view label contractTo: 40); cr]].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	^ index > 0		ifTrue:			[controllers at: index]		ifFalse:			[nil]! !"ST80"!!TestCase commentStamp: '<historical>' prior: 59442070!A TestCase is a Command representing the future running of a test case. Create one with the class method #selector: aSymbol, passing the name of the method to be run when the test case runs.When you discover a new fixture, subclass TestCase, declare instance variables for the objects in the fixture, override #setUp to initialize the variables, and possibly override# tearDown to deallocate any external resources allocated in #setUp.When you are writing a test case method, send #assert: aBoolean when you want to check for an expected value. For example, you might say "self assert: socket isOpen" to test whether or not a socket is open at a point in a test.!!TestCase methodsFor: 'running' stamp: 'dtl 6/6/2010 15:10' prior: 33847651!runCase	"Run this TestCase. Time out if the test takes too long."	[self timeout: [self setUp]		after: self timeoutForSetUp.	self timeout: [self performTest]		after: self timeoutForTest]		ensure: [self tearDown]! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 13:10'!timeout: seconds	"The timeout for a test should normally be set with a method annotation.	However, for tests that are expected to run in images that do not support	method annotations, the value may be set by setting the value from the	#setUp method (i.e. prior to running the test method)."	timeout := seconds! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:26'!timeoutForSetUp	"Answer the timeout to use for setUp"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^self defaultTimeout! !!TestCase methodsFor: 'accessing' stamp: 'dtl 6/6/2010 15:07' prior: 33848995!timeoutForTest	"Answer the timeout to use for this test"	| method |	method := self class lookupSelector: testSelector asSymbol.	(method pragmaAt: #timeout:) ifNotNil:[:tag| ^tag arguments first].	^timeout ifNil: [self defaultTimeout]! !"SUnit"!!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26'!expectedFailures	"Does crash VM with Cog"	^Smalltalk isRunningCog		ifTrue:[#(testAddNumbers testDNU testAnswer42)]		ifFalse:[#()]! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26' prior: 31119020!testAddNumbers 	"self debug: #testAddNumbers"	"Does crash VM with Cog"	Smalltalk isRunningCog ifTrue:[^self assert: false].	"md: I had to comment out the error... did strange things"	self class addSelector: #add:with: withMethod: ObjectsAsMethodsExample new.	self assert: (self add: 3 with: 4) = 7.	"self assert: (self perform: #add:with: withArguments: #(3 4)) = 7. "	self class basicRemoveSelector: #add:with:.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26' prior: 31119448!testAnswer42 	"Does crash VM with Cog"	Smalltalk isRunningCog ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: ObjectsAsMethodsExample new.	self assert: self answer42 = 42.	self class basicRemoveSelector: #answer42.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'ar 6/21/2010 20:26' prior: 31119704!testDNU 	"Does crash VM with Cog"	Smalltalk isRunningCog ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: AbstractObjectsAsMethod new.	self should: [self answer42] raise: MessageNotUnderstood.	self class basicRemoveSelector: #answer42.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 5/27/2010 14:01'!testBlockDoitDecompilation	"Tests that decompile of a doit block with remote vars executes correcly"	"Tests that decompilation of a Block, when 'method' of block is equivalent to that compiled by a DoIt, preserves the temp names "		|blockSourceStream methodNode compiledMethod block decompiledBlock|	blockSourceStream := '|x y| [:a :b | x := a. y := b. x + y]' readStream.	methodNode := nil class evaluatorClass new 						from: blockSourceStream class: nil class context: nil notifying: nil;						translate: blockSourceStream noPattern: true ifFail: [nil].	compiledMethod := methodNode generateWithTempNames.	block := nil withArgs: #() executeMethod: compiledMethod.		self shouldnt: [decompiledBlock := block decompile] raise: Error.	self assert: '{[:a :b | x := a.	y := b.	x + y]}' equals: decompiledBlock printString! !"Tests"!!PluggableWindowSpec commentStamp: '<historical>' prior: 59378233!A common window. Expects to see change/update notifications when the label should change.Instance variables:	label	<String|Symbol> The selector under which to retrieve the label or the label directly	extent	<Point>	The (initial) extent of the window.	closeAction		<Symbol>	The action to perform when the window is closed.!!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:12' prior: 57472537!isDialog	^isDialog ifNil: [false]! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 7/1/2010 11:31'!multiWindowStyle	"Answer the value of multiWindowStyle, a Symbol or nil"	^multiWindowStyle! !!PluggableWindowSpec methodsFor: 'accessing' stamp: 'eem 6/30/2010 11:44'!multiWindowStyle: aSymbol	"Set the value of multiWindowStyle, one of #labelButton or #tabbed"	multiWindowStyle := aSymbol! !"ToolBuilder-Kernel"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'eem 7/1/2010 14:41' prior: 33859479!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	"By default, don't style in UIManager edit: requests"	window model		shouldStyle: false;		acceptAction: anAction;		acceptContents:  aText.	^window.! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'eem 6/30/2010 15:52' prior: 57481831!buildPluggableWindow: aSpec	| widget children |	aSpec layout == #proportional ifFalse:[		"This needs to be implemented - probably by adding a single pane and then the rest"		^self error: 'Not implemented'.	].	widget := (self windowClassFor: aSpec multiWindowStyle) new.	self register: widget id: aSpec name.	widget model: aSpec model.	aSpec label ifNotNil:		[:label|		label isSymbol 			ifTrue:[widget getLabelSelector: label]			ifFalse:[widget setLabel: label]].	aSpec multiWindowStyle notNil ifTrue:		[widget savedMultiWindowState: (SavedMultiWindowState on: aSpec model)].	children := aSpec children.	children isSymbol ifTrue:[		widget getChildrenSelector: children.		widget update: children.		children := #().	].	widget closeWindowSelector: aSpec closeAction.	panes := OrderedCollection new.	self buildAll: children in: widget.	self buildHelpFor: widget spec: aSpec. 	widget bounds: (RealEstateAgent 		initialFrameFor: widget 		initialExtent: (aSpec extent ifNil:[widget initialExtent])		world: self currentWorld).	widget setUpdatablePanesFrom: panes.	^widget! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'eem 6/30/2010 11:44'!windowClassFor: multiWindowStyle	^multiWindowStyle		caseOf:		{	[nil]				->	[PluggableSystemWindow].			[#labelButton]	->	[PluggableSystemWindowWithLabelButton] }		otherwise:				[PluggableSystemWindowWithLabelButton]! !"ToolBuilder-Morphic"!!ButtonStub methodsFor: 'simulating' stamp: 'cwp 7/14/2006 11:09' prior: 17918654!isEnabled	enabled ifNil: [enabled := spec model perform: spec enabled].	^ enabled! !!MenuStub methodsFor: 'as yet unclassified' stamp: 'cwp 7/14/2006 10:43' prior: 23688972!click: aString	| item |	item := self items detect: [:ea | ea label = aString] ifNone: [^ self].	item action isSymbol		ifTrue: [self model perform: item action]		ifFalse: [item action value]! !"ToolBuilder-SUnit"!!CodeHolder commentStamp: '<historical>' prior: 59244581!An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!Workspace commentStamp: 'ls 10/14/2003 12:13' prior: 59465141!A Workspace is a text area plus a lot of support for executable code.  It is a great place to execute top-level commands to compute something useful, and it is a great place to develop bits of a program before those bits get put into class methods.To open a new workspace, execute:	Workspace openA workspace can have its own variables, called "workspace variables", to hold intermediate results.  For example, if you type into a workspace "x := 5" and do-it, then later you could type in "y := x * 2" and y would become 10.Additionally, in Morphic, a workspace can gain access to morphs that are on the screen.  If acceptDroppedMorphss is turned on, then whenever a morph is dropped on the workspace, a variable will be created which references that morph.  This functionality is toggled with the window-wide menu of a workspace.The instance variables of this class are:	bindings  -  holds the workspace variables for this workspace	acceptDroppedMorphss - whether dropped morphs should create new variables!!SavedMultiWindowState commentStamp: 'eem 6/30/2010 15:45' prior: 0!A SavedMultiWindowState is a collection of states of inactive windows for a multi-window tool ui where one can select between multiple copies of a tool sharing a single system window, each tol having its own state.  It manages switching between windows, swapping unaccepted edit state (e.g. in text views) as it does so.Instance Variables	currentModelIndex:		<Integer>	modelDependents:		<IdentitySet>	modelStates:			<OrderedCollection of: (Array													with: modelState <Object>													with: unacceptedEditStates <WeakIdentityKeyDictionary>) >	models:					<OrderedCollection of: Model>currentModelIndex	- index into models and modelStates of current window selectionmodelDependents	- set of all dependentsmodelStates	- the pairs of model-specific selection state and widget-specfic unaccepted edit state for each unselected/inactive windowmodels	- the models for each window!!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:44' prior: 57747073!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList := aString lines asArray.	anArrayOrNil		ifNil: [linesArray := #()]		ifNotNil: [linesArray := anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font := aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'nice 6/11/2010 21:50' prior: 57747814!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	labelList isString		ifTrue: [labelArray := labelList lines]		ifFalse: [labelArray := labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:53'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [displayContents text]! !!StringHolderView methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:55'!unacceptedEditState: stateOrNil	(hasUnacceptedEdits := stateOrNil notNil) ifTrue:		[self editString: stateOrNil]! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^true! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:56'!unacceptedEditState	^hasUnacceptedEdits ifTrue: [self text]! !!PluggableTextMorph methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 21:05'!unacceptedEditState: stateOrNil	stateOrNil		ifNotNil:			[self setText: stateOrNil.			 hasUnacceptedEdits := true "setText: clears hasUnacceptedEdits, so must do this post setText:"]		ifNil: [hasUnacceptedEdits := false]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	"This is a hook to allow browsers to control whether to respond to the muli-window preference.	 Currenty CodeHolder cannot usefully use multi-windows, but may be able to do so in the future."	^false! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 7/1/2010 11:43'!useMultiWindowBrowsers	<preference: 'Multi-window browsers'		category: 'browsing'		description: 'When enabled, the browser uses a multi-window to conserve real-estate.  e.g. enable then click in the window label of a browser.'		type: #Boolean>	^MultiWindowBrowsers ifNil: [false]! !!CodeHolder class methodsFor: 'preferences' stamp: 'eem 6/30/2010 21:37'!useMultiWindowBrowsers: aBoolean	MultiWindowBrowsers := aBoolean! !!CodeHolder methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 19:02'!multiWindowState: aSavedMultiWindowState	multiWindowState := aSavedMultiWindowState! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!addLookupPool: sharedPool	"Add a SharedPool that bindings should be looked up in."	LookupPools ifNil: [LookupPools := IdentitySet new].	LookupPools add: sharedPool! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 11:08'!clearLookupPools	LookupPools := nil.! !!Workspace class methodsFor: 'lookup pools' stamp: 'jcg 6/15/2010 15:21'!removeLookupPool: sharedPool	"Workspaces should no longer look up bindings in the specified SharedPool."	LookupPools ifNil: [^self].	LookupPools remove: sharedPool ifAbsent: [].! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:16' prior: 33229320!bindingOf: aString 	mustDeclareVariables ifTrue: [^ nil].	"I want to have workspace that force the user to declare  	variables. Still subclasses may want to do something else"	bindings ifNil: [self initializeBindings].	(bindings includesKey: aString) ifFalse: [		| val |		val := self lookupInPools: aString.		val 			ifNotNil: [				"Caveat: since we're not inserting the pool's Association into				 the dictionary, assigning a new value to the variable will only				 affect the one Workspace (i.e. you can't assign to a variable in a				 SharedPool)."				bindings at: aString put: val]			ifNil: [aString first isUppercase					ifTrue: [^nil]					ifFalse: [bindings at: aString put: nil]]	].	^ bindings associationAt: aString! !!Workspace methodsFor: 'binding' stamp: 'jcg 6/15/2010 15:00'!lookupInPools: aString 	"Iterate through all of the lookup pools to find a match for the specified name."	LookupPools ifNil: [^nil].	LookupPools do: [:pool | (pool bindingOf: aString) ifNotNil: [:assoc | ^assoc value]].	^nil! !!HierarchyBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^true! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'nice 6/11/2010 21:53' prior: 57502443!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch := Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch := ch asCharacter asLowercase.	labels := labelString lines.	occurences := 0.	1 + selection to: selection + labels size do:		[:index |		| i | i := index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences := occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'nice 6/11/2010 21:53' prior: 57506461!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'cmm 6/15/2010 15:07' prior: 57507899!startUpSegmented: segmentHeight withCaption: captionOrNil at: location allowKeyboard: aBoolean	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.  The boolean parameter indicates whether the menu should be given keyboard focus (if in morphic)""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString lines.	nLines := allLabels size.	lineArray ifNil: [lineArray := Array new].	nLinesPer := segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := (allLabels copyFrom: from to: to) asOrderedCollection.		subset add: (to = nLines ifTrue: ['start over...' translated] ifFalse: ['more...' translated])			before: subset first.		subLines := lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines := (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location allowKeyboard: aBoolean.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!Object methodsFor: '*Tools-multi-window support' stamp: 'eem 6/30/2010 14:23'!canHaveUnacceptedEdits	"Answer if the receiver is an object that can hold unaccepted edits (such as a text editor widget)"	^false! !!SavedMultiWindowState class methodsFor: 'instance creation' stamp: 'eem 6/30/2010 13:46'!on: aModel	^self new on: aModel! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:14'!addNewWindow	self addWindow: prototype clone! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 19:01'!addWindow: aModel	aModel multiWindowState: self.	self assert: models size = modelStates size.	models := models					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: aModel).	modelStates := modelStates					copyReplaceFrom: currentModelIndex + 1					to: currentModelIndex					with: (Array with: self emptyEditState).	self assert: models size = modelStates size.	self selectWindowIndex: (currentModelIndex = 0 ifTrue: [currentModelIndex := 1] ifFalse: [currentModelIndex + 1]).	self assert: models size = modelStates size.	1 to: models size do:		[:idx|		self assert: (idx = currentModelIndex					or: [(modelStates at: idx) isArray and: [(modelStates at: idx) size = 2]])]! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 17:10'!copyWindow	self addWindow: (models at: currentModelIndex) copy breakDependents! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 15:01'!currentModelIndex	^currentModelIndex! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!editState	| textState |	textState := WeakIdentityKeyDictionary new.	modelDependents do:		[:dep|		dep canHaveUnacceptedEdits ifTrue:			[textState at: dep put: dep unacceptedEditState]].	^textState! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 21:07'!emptyEditState	^#(nil ())! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 15:12'!initialize	models := OrderedCollection new.	modelStates := OrderedCollection new.	modelDependents := IdentitySet new.	currentModelIndex := 0! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 6/30/2010 19:03'!models	^models! !!SavedMultiWindowState methodsFor: 'testing' stamp: 'eem 6/30/2010 22:11'!okToClose	"Answer if the unaccepted edit states are void.  If they are not then	 offer to select a window with non-empty unaccepted edit state."	modelStates withIndexDo:		[:savedState :index|		savedState ifNotNil:			[(savedState last anySatisfy: [:editState| editState notNil]) ifTrue:				[(PopUpMenu					confirm: 'One or more windows have unsaved changes.'					trueChoice: 'Close Anyway'					falseChoice: 'Select Unsaved') ifTrue: [^true].				 self selectWindowIndex: index.				 ^false]]].	^true! !!SavedMultiWindowState methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 18:42'!on: aModel	prototype := aModel clone.	self addWindow: aModel! !!SavedMultiWindowState methodsFor: 'accessing' stamp: 'eem 7/1/2010 10:40'!prototype	^prototype! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 21:15'!removeCurrentWindow	"Remove the current pane."	| deletedIndex |	self assert: models size > 1.	self assert: models size = modelStates size.	(models at: currentModelIndex) okToChange ifFalse:		[^self].	deletedIndex := currentModelIndex.	self selectWindowIndex: (currentModelIndex = 1								ifTrue: [currentModelIndex + 1]								ifFalse: [currentModelIndex - 1]).	models := models copyWithoutIndex: deletedIndex.	modelStates :=  modelStates copyWithoutIndex: deletedIndex.	currentModelIndex > deletedIndex ifTrue:		[currentModelIndex := currentModelIndex - 1].	(models at: currentModelIndex) changed: #relabel! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 14:57'!restoreEditState: aWeakDictionary	aWeakDictionary keysAndValuesDo:		[:depOrNil :unacceptedEditState|		depOrNil ifNotNil:			[depOrNil unacceptedEditState: unacceptedEditState]]! !!SavedMultiWindowState methodsFor: 'selecting' stamp: 'eem 6/30/2010 21:09'!selectWindowIndex: index	| currentModel newModel newModelState |	index = currentModelIndex ifTrue: [^self].	currentModel := models at: currentModelIndex.	newModel := models at: index.	modelDependents addAll: currentModel dependents.	modelStates at: currentModelIndex put: { currentModel saveMultiWindowState. self editState }.	"the become makes things confusing.  currentModel will end up being newModel and vice verce"	models swap: currentModelIndex with: index.	currentModel become: newModel.	currentModel := models at: currentModelIndex.	newModel := models at: index.	newModel myDependents: (DependentsArray withAll: modelDependents asArray).	currentModel myDependents: nil.	"Change currentModelIndex before restoreMultiWIndowState: so label index is shown correctly"	currentModelIndex := index.	newModelState := modelStates at: index.	newModelState first ifNotNil: "emptyState has nil for savedModelState.  Don;t restore state for a new window"		[:savedModelState| newModel restoreMultiWindowState: savedModelState].	self restoreEditState: newModelState last.	modelStates at: index put: nil.	newModel changed: #relabel! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 6/30/2010 18:30'!selectWindowsMenu	| menu currentItem |	menu := MenuMorph new defaultTarget: self.	models withIndexDo:		[:model :index| | entry |		entry := models size > 1					ifTrue: [index printString, '. ', model multiWindowName]					ifFalse: [model multiWindowName].		menu			add: (index = currentModelIndex					ifTrue: [Text string: entry attribute: TextEmphasis bold]					ifFalse:						[((modelStates at: index) last anySatisfy: [:editState| editState notNil])							ifTrue: [Text string: entry attribute: TextColor red]							ifFalse: [entry]])			target: self			selector: #selectWindowIndex:			argument: index.		index = currentModelIndex ifTrue:			[currentItem := menu lastItem]].	menu		addLine;		add: 'new window' target: self selector: #addNewWindow;		add: 'copy this window' target: self selector: #copyWindow;		add: 'remove this window' target: self selector: #removeCurrentWindow.	models size <= 1 ifTrue:		[menu lastItem isEnabled: false].	menu selectItem: currentItem event: nil.	^menu! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^true! !!PackagePaneBrowser methodsFor: 'initialize-release' stamp: 'eem 7/1/2010 10:22'!labelString	^self package		ifNil: [super labelString]		ifNotNil:			[:pkg| | label |			label := self defaultBrowserTitle, ': ', pkg, (self selectedClass														ifNil: ['']														ifNotNil: [' ', self selectedClass printString]).			(multiWindowState notNil			 and: [multiWindowState models size > 1]) ifTrue:				[label := (multiWindowState models indexOf: self) printString, '. ', label].			label]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:26'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self package			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 s nextPutAll: pkg; space.				 self selectedClass ifNotNil: [:class| s print: class].				 self metaClassIndicated ifTrue:					[s nextPutAll: ' class']].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:13'!restoreToPackage: packageNameOrNil category: category className: className protocol: protocol selector: selector mode: editMode	self packageListIndex: (self packageList indexOf: packageNameOrNil).	super restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:11'!saveMultiWindowState	^Message		selector: #restoreToPackage:category:className:protocol:selector:mode:		arguments: {	self package.						self systemCategoryList at: systemCategoryListIndex ifAbsent: [].						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						editSelection }! !!FileList methodsFor: 'private' stamp: 'dgd 12/27/2003 12:22' prior: 57783595!defaultContents	contents := list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED' translated; cr.					s nextPutAll: '  -- Folder Summary --' translated; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState := #FileList.	^ contents! !!FileList methodsFor: 'file list' stamp: 'cmm 6/20/2010 16:35' prior: 33741793!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list at: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self directory: (ServerDirectory serverNamed: name allButFirst)]						ifFalse: [volListIndex = 1 ifTrue: [name := name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := self isGraphicsFileSelected		ifTrue: [#needToGetGraphic]		ifFalse: [#needToGetBrief]..	self 		changed: #fileListIndex ;		changed: #contents ;		changed: #labelString.	self updateButtonRow! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:30' prior: 57793282!labelString	^ directory		ifNil: [ 'File List' ]		ifNotNil:			[ fileName				ifNil: [ directory fullName ]				ifNotNil: [ directory fullNameFor: fileName ] ]! !!FileList methodsFor: 'private' stamp: 'cmm 6/20/2010 16:33' prior: 57806785!resort: newMode 	"Re-sort the list of files."	| name |	listIndex > 0 ifTrue: [ name := self fileNameFromFormattedItem: (list at: listIndex) ].	sortMode := newMode.	self pattern: pattern.	name ifNotNil:		[ fileName := name.		listIndex := list findFirst:			[ : item | (self fileNameFromFormattedItem: item) = name ].		self			 changed: #fileListIndex ;			 changed: #labelString ].	listIndex = 0 ifTrue: [ self changed: #contents ].	self updateButtonRow! !!FileList methodsFor: 'initialization' stamp: 'cmm 6/20/2010 16:34' prior: 57814436!setFileStream: aStream	"Used to initialize a spawned file editor.  Sets directory too."	self directory: aStream directory.	fileName := aStream localName.	pattern := '*'.	listIndex := 1.  "pretend a file is selected"	aStream close.	brevityState := #needToGetBrief.	self 		changed: #contents ; 		changed: #labelString! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 6/29/2010 17:58' prior: 58264274!changeListMenu: aMenu	"Fill aMenu up so that it comprises the primary changelist-browser menu"	aMenu addTitle: 'change list'.	aMenu addStayUpItemSpecial.	aMenu addList: #(	('fileIn selections'							fileInSelections						'import the selected items into the image')	('fileOut selections...	'						fileOutSelections						'create a new file containing the selected items')	-	('compare to current'						compareToCurrentVersion			'open a separate window which shows the text differences between the on-file version and the in-image version.' )	('toggle diffing (D)'							toggleDiffing						'start or stop showing diffs in the code pane.')	-	('select conflicts with any changeset'		selectAllConflicts					'select methods in the file which also occur in any change-set in the system')	('select conflicts with current changeset'	selectConflicts						'select methods in the file which also occur in the current change-set')	('select conflicts with...'						selectConflictsWith					'allows you to designate a file or change-set against which to check for code conflicts.')	-	('select unchanged definitions'				selectUnchangedDefinitions			'select class definitions, class comments and methods in the file whose in-image versions are the same as their in-file counterparts' )	('select unchanged methods'					selectUnchangedMethods				'select methods in the file whose in-image versions are the same as their in-file counterparts' )	('select new methods'						selectNewMethods					'select methods in the file that do not current occur in the image')	('select methods for this class'				selectMethodsForThisClass			'select all methods in the file that belong to the currently-selected class')	('select methods for extant classes'			selectMethodsForExtantClasses		'select all methods in the file that belong to a class that exists in the image')	('select changes with contents matching'		selectContentsMatching				'select all changes in the file whose text includes a pattern')	-	('select all (a)'								selectAll								'select all the items in the list')	('deselect all'								deselectAll							'deselect all the items in the list')	('invert selections'							invertSelections						'select every item that is not currently selected, and deselect every item that *is* currently selected')	-	('browse all versions of single selection'			browseVersions		'open a version browser showing the versions of the currently selected method')	('browse all versions of selections'			browseAllVersionsOfSelections		'open a version browser showing all the versions of all the selected methods')	('browse current versions of selections'		browseCurrentVersionsOfSelections	'open a message-list browser showing the current (in-image) counterparts of the selected methods')	('destroy current methods of selections'		destroyCurrentCodeOfSelections		'remove (*destroy*) the in-image counterparts of all selected methods')	-	('remove doIts'								removeDoIts							'remove all items that are doIts rather than methods')	('remove older versions'						removeOlderMethodVersions			'remove all but the most recent versions of methods in the list')	('remove up-to-date versions'				removeExistingMethodVersions		'remove all items whose code is the same as the counterpart in-image code')	('remove selected items'						removeSelections					'remove the selected items from the change-list')	('remove unselected items'					removeNonSelections					'remove all the items not currently selected from the change-list')).	^ aMenu! !!ChangeList methodsFor: 'viewing access' stamp: 'eem 5/22/2007 10:40' prior: 18187944!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange := changeList at: listIndex.	 (aChange type == #method	 and: [(aClass := aChange methodClass) notNil	 and: [aClass includesSelector: aChange methodSelector]]) ifTrue:		[^Utilities			methodDiffFor: aChange text			class: aClass			selector: aChange methodSelector			prettyDiffs: self showingPrettyDiffs].	aChange type == #doIt ifTrue:		[| tokens |		 tokens := Scanner new scanTokens: aChange string.		 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3		  and: [(aClass := Smalltalk at: tokens third ifAbsent: []) notNil		  and: [aClass isBehavior]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass definition to: aChange string].		(tokens size = 4		 and: [tokens second == #class		 and: [tokens third == #instanceVariableNames:		 and: [(aClass := Smalltalk at: tokens first ifAbsent: []) notNil		 and: [aClass isBehavior]]]]) ifTrue:			[^TextDiffBuilder buildDisplayPatchFrom: aClass class definition to: aChange string]].	(aChange type == #classComment	and: [(aClass := aChange commentClass) notNil]) ifTrue:		[^TextDiffBuilder buildDisplayPatchFrom: aClass comment asString to: aChange string].	^(changeList at: listIndex) text! !!ChangeList methodsFor: 'scanning' stamp: 'eem 7/17/2008 15:50' prior: 18181436!scanCategory  	"Scan anything that involves more than one chunk; method name is historical only"	| itemPosition item tokens stamp anIndex |	itemPosition := file position.	item := file nextChunk.	((item includesSubString: 'commentStamp:')	or: [(item includesSubString: 'methodsFor:')	or: [item endsWith: 'reorganize']]) ifFalse:		["Maybe a preamble, but not one we recognize; bail out with the preamble trick"		^ self addItem: (ChangeRecord new file: file position: itemPosition type: #preamble)				 text: ('preamble: ' , item contractTo: 50)].	tokens := Scanner new scanTokens: item.	tokens size >= 3 ifTrue:		[stamp := ''.		anIndex := tokens indexOf: #stamp: ifAbsent: [nil].		anIndex ifNotNil: [stamp := tokens at: (anIndex + 1)].		tokens second == #methodsFor:			ifTrue: [^ self scanCategory: tokens third class: tokens first							meta: false stamp: stamp].		tokens third == #methodsFor:			ifTrue: [^ self scanCategory: tokens fourth class: tokens first							meta: true stamp: stamp]].	tokens second == #commentStamp:		ifTrue:			[stamp := tokens third.			self addItem:					(ChangeRecord new file: file position: file position type: #classComment									class: tokens first category: nil meta: false stamp: stamp)					text: 'class comment for ' , tokens first, 						  (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp]).			file nextChunk.			^ file skipStyleChunk].	self assert: tokens last == #reorganize.	self addItem:		(ChangeRecord new			file: file position: file position type: #reorganize			class: tokens first category: nil meta: false stamp: stamp)		text: 'organization for ' , tokens first, (tokens second == #class ifTrue: [' class'] ifFalse: ['']).	file nextChunk! !!ChangeList methodsFor: 'scanning' stamp: 'eem 1/28/2009 16:39' prior: 18182918!scanCategory: category class: class meta: meta stamp: stamp	| itemPosition method selector |	[itemPosition := file position.	method := file nextChunk.	file skipStyleChunk.	method size > 0]						"done when double terminators"		whileTrue:		[self addItem: (ChangeRecord new file: file position: itemPosition type: #method							class: class category: category meta: meta stamp: stamp)			text: 'method: ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, ((selector := (Smalltalk at: class ifAbsent: [Object]) parserClass new parseSelector: method) isNil					ifTrue: ['unparsableSelector']					ifFalse: [selector])				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/18/2009 15:21'!selectContentsMatching	| pattern |	pattern := UIManager default request: 'pattern to match'.	pattern isEmpty ifTrue: [^self].	^Cursor execute showWhile:		[self selectSuchThat: ((pattern includesAnyOf: '?*')								ifTrue: [[ :change | pattern match: change string]]								ifFalse: [[ :change | change string includesSubString: pattern]])]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 8/18/2009 13:41'!selectMethodsForExtantClasses	^self selectSuchThat:		[ :change |		Smalltalk hasClassNamed: change methodClassName]! !!ChangeList methodsFor: 'menu actions' stamp: 'eem 1/28/2009 16:36'!selectUnchangedDefinitions	"Selects all recognizable definitions for which there is already a definition in the current image, whose source is exactly the same."	| change class tokens |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put: false.		(change type = #method		 and: [(class := change methodClass) notNil		 and: [class includesSelector: change methodSelector]]) ifTrue:			[listSelections				at: i				put: change string withBlanksCondensed					= (class sourceCodeAt: change methodSelector) asString withBlanksCondensed].		(change type == #classComment		and: [(class := change commentClass) notNil]) ifTrue:			[listSelections at: i put: change string = class comment asString].		change type == #doIt ifTrue:			[tokens := Scanner new scanTokens: change string.			 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3			 and: [(class := Smalltalk at: tokens third ifAbsent: []) notNil			 and: [class isBehavior]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class definition withBlanksCondensed].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #instanceVariableNames:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) notNil			 and: [class isBehavior]]]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class class definition withBlanksCondensed].			(tokens size = 3			 and: [tokens second == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class includesSelector: tokens third) not]]]]) ifTrue:				[listSelections at: i put: true].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class class includesSelector: tokens fourth) not]]]]]) ifTrue:				[listSelections at: i put: true]]]].	self changed: #allSelections! !!MessageNames methodsFor: 'search' stamp: 'eem 1/27/2009 10:15' prior: 54379351!computeSelectorListFromSearchString	"Compute selector list from search string"	searchString := searchString asString copyWithout: $ . "?dubious?"	selectorList := Cursor wait showWhile:					[| sorted |					sorted := SortedCollection sortBlock:  [:x :y | x asLowercase <= y asLowercase].					(searchString findBetweenSubStrs: ';') do:						[:selPat| | raw n m |						selPat size > 0 ifTrue:							[(selPat first = $" and: [selPat last = $" and: [selPat size > 2]])								ifTrue:									[Symbol hasInterned: (selPat copyFrom: 2 to: selPat size - 1) ifTrue: [:sym| sorted add: sym]]								ifFalse:									[raw := (((n := selPat occurrencesOf: $*) > 0)										    | ((m := selPat occurrencesOf:  $#) > 0)										and: [selPat size > (n + m)])											ifTrue: [Symbol selectorsMatching: selPat]											ifFalse: [Symbol selectorsContaining: selPat].									sorted addAll: raw]]].					sorted asArray].	^selectorList! !!FileList2 class methodsFor: 'modal dialogs' stamp: 'ul 2/22/2010 22:28' prior: 58107237!modalFolderSelector: aDir	| window fileModel |	window := self morphicViewFolderSelector: aDir.	fileModel := window model.	window openInWorld: self currentWorld extent: 300@400.	self modalLoopOn: window.	^fileModel getSelectedDirectory withoutListWrapper! !!Behavior methodsFor: '*Tools-Browser-accessors' stamp: 'eem 8/12/2009 11:45'!settersReturnValue	"Determine whether the browser's createInstVarAccessors code will generate	 setters that answer self (the default here) or the value set.  Classes that want	 to answer the value set (e.g. VMStructType) override."	^false! !!Inspector methodsFor: 'menu commands' stamp: 'mtf 4/25/2008 14:17' prior: 21871856!explorePointers	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	PointerExplorer new openExplorerFor: self selection! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:41'!explorePointers	"Open a PointerExplorer on the current selection"	PointerExplorer new openExplorerFor: self object! !!ObjectExplorer methodsFor: 'menus' stamp: 'mtf 4/25/2008 17:40' prior: 25065726!genericMenu: aMenu 	"Borrow a menu from my inspector"	| insideObject menu parentObject |	currentSelection		ifNil: [menu := aMenu.			menu				add: '*nothing selected*'				target: self				selector: #yourself]		ifNotNil: [insideObject := self object.			parentObject := self parentObject.			inspector				ifNil: [inspector := Inspector new].			inspector inspect: parentObject;				 object: insideObject.			aMenu defaultTarget: inspector.			inspector fieldListMenu: aMenu.			aMenu items				do: [:i | (#(#inspectSelection #exploreSelection #referencesToSelection #defsOfSelection #objectReferencesToSelection #chasePointers #explorePointers) includes: i selector)						ifTrue: [i target: self]].			aMenu addLine;				add: 'monitor changes'				target: self				selector: #monitor:				argument: currentSelection].	monitorList isEmptyOrNil		ifFalse: [aMenu addLine;				add: 'stop monitoring all'				target: self				selector: #stopMonitoring].	^ aMenu! !!Browser class methodsFor: 'preferences' stamp: 'eem 7/1/2010 09:24'!canUseMultiWindowBrowsers	^true! !!Browser class methodsFor: 'instance creation' stamp: 'eem 7/1/2010 11:44' prior: 54909931!openBrowserView: aBrowserView label: aString 	"Schedule aBrowserView, labelling the view aString."(aBrowserView isKindOf: ToolBuilderSpec) ifTrue:[	(self canUseMultiWindowBrowsers	 and: [self useMultiWindowBrowsers]) ifTrue:		[aBrowserView multiWindowStyle: #labelButton].	ToolBuilder open: aBrowserView label: aString.] ifFalse:[	aBrowserView isMorph		ifTrue:  [(aBrowserView setLabel: aString) openInWorld]		ifFalse: [aBrowserView label: aString.				aBrowserView minimumSize: 300 @ 200.				aBrowserView subViews do: [:each | each controller].				aBrowserView controller open].].	^ aBrowserView model! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 21:44'!arrowKey: aChar from: view	"Intercept Apple-Digit to select panes"	| index |	(aChar isDigit	 and: [multiWindowState notNil]) ifTrue:	 	[index := aChar asciiValue - $0 asciiValue.		index = 0 ifTrue: [index := 10].		^index <= multiWindowState models size			ifTrue: [multiWindowState selectWindowIndex: index]			ifFalse: [self changed: #flash]].	^super arrowKey: aChar from: view! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:36'!classHierarchy	| behavior newBrowser |	(behavior := self selectedClassOrMetaClass) isNil ifTrue:		[^self].	(self isPackage "PackageBrowser pains can't support a hierarchy browser; not sure why."	 or: [multiWindowState isNil]) ifTrue:		[^super classHierarchy].	(newBrowser := HierarchyBrowser new initHierarchyForClass: behavior)		messageCategoryListIndex: messageCategoryListIndex;		messageListIndex: messageListIndex;		editSelection: editSelection.	multiWindowState addWindow: newBrowser! !!Browser methodsFor: 'class list' stamp: 'eem 5/14/2008 17:58' prior: 17783226!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className currentMessageCategoryName currentMessageName |	currentMessageCategoryName := [self selectedMessageCategoryName]										on: Error										do: [:ex| ex return: nil].	currentMessageName := [self selectedMessageName]								on: Error								do: [:ex| ex return: nil].	classListIndex := anInteger.	self setClassOrganizer.	"Try to reselect the category and/or selector if the new class has them."	messageCategoryListIndex := self messageCategoryList										indexOf: currentMessageCategoryName										ifAbsent: [0].	messageListIndex := messageCategoryListIndex = 0							ifTrue: [0]							ifFalse: [self messageList										indexOf: currentMessageName										ifAbsent: [0]].	messageListIndex ~= 0 ifTrue:		[self editSelection: #editMessage] ifFalse:	[messageCategoryListIndex ~= 0 ifTrue:		[self editSelection: #newMessage] ifFalse:	[self classCommentIndicated		ifTrue: []		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])]]].	contents := nil.	self selectedClass isNil		ifFalse: [className := self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'eem 8/12/2009 11:52' prior: 33745191!createInstVarAccessors	"Create getters and setters for all inst vars defined at the level of the current class selection,	 except do NOT clobber or override any selectors already understood by the instances of the selected class"	self selectedClassOrMetaClass ifNotNil:		[:aClass| | cr |		cr := String with: Character cr.		aClass instVarNames do: 			[:aName | | newMessage setter |			(aClass canUnderstand: aName asSymbol) ifFalse:				[newMessage :=					aName, cr,					'	"Answer the value of ', aName, '"', cr, cr,					'	^ ', aName.				aClass compile: newMessage classified: #accessing notifying: nil].			(aClass canUnderstand: (setter := aName, ':') asSymbol) ifFalse:				[newMessage :=					setter, ' anObject', cr,					'	"Set the value of ', aName, '"', cr, cr,						(aClass settersReturnValue ifTrue: ['	^'] ifFalse: ['	']),						aName, ' := anObject'.				aClass compile: newMessage classified: #accessing notifying: nil]]]! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!exploreMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod explore]! !!Browser methodsFor: 'system category functions' stamp: 'eem 7/1/2010 10:39' prior: 17867486!findClass	"Search for a class by name."	| pattern foundClass |	(multiWindowState notNil	 or: [self okToChange]) ifFalse:		[^self classNotFound].	pattern := UIManager default request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^self classNotFound].	foundClass := Utilities classFromPattern: pattern withCaption: ''.	foundClass ifNil: [^self classNotFound].	(self selectedClass notNil	 and: [multiWindowState notNil	 "Can only support multi-window if original window has all the right panes."	 and: [multiWindowState prototype isHierarchy not]]) ifTrue:		[(self classList includes: foundClass name)			ifTrue: [multiWindowState copyWindow]			ifFalse: [multiWindowState addNewWindow]]. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!Browser methodsFor: 'message functions' stamp: 'eem 5/14/2008 12:50'!inspectMethod	currentCompiledMethod notNil ifTrue:		[currentCompiledMethod inspect]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!isHierarchy	^false! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:31'!isPackage	^false! !!Browser methodsFor: 'initialize-release' stamp: 'eem 6/30/2010 19:06' prior: 17809768!labelString	| label |	label := self selectedClass				ifNil: [ self defaultBrowserTitle ]				ifNotNil: [ self defaultBrowserTitle, ': ', self selectedClass printString ].	(multiWindowState notNil	 and: [multiWindowState models size > 1]) ifTrue:		[label := (multiWindowState models indexOf: self) printString, '. ', label].	^label! !!Browser methodsFor: 'message functions' stamp: 'eem 6/29/2010 17:07' prior: 56954722!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	(self menuHook: aMenu named: #messageListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('inst var refs...'			browseInstVarRefs)			('inst var defs...'			browseInstVarDefs)			('class var refs...'			browseClassVarRefs)			('class variables'			browseClassVariables)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			('explore method'			exploreMethod)			('inspect method'			inspectMethod)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/1/2010 10:30'!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self selectedClass			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[s print: self selectedClass.				 self metaClassIndicated ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy']].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 17:34'!okToClose	^super okToClose	  and: [multiWindowState isNil or: [multiWindowState okToClose]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 20:20'!restoreMultiWindowState: aMessage	"Restore the state after a multi-window switch.."	aMessage sentTo: self! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 21:12'!restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode	self systemCategoryListIndex: (self systemCategoryList indexOf: category).	self classListIndex: (self classListIndexOf: className).	self messageCategoryListIndex: (self messageCategoryList indexOf: protocol).	self messageListIndex: (self messageList indexOf: selector).	editSelection := editMode.	self		contentsChanged;		decorateButtons! !!Browser methodsFor: 'multi-window support' stamp: 'eem 6/30/2010 20:11'!saveMultiWindowState	^Message		selector: #restoreToCategory:className:protocol:selector:mode:		arguments: {	self selectedSystemCategoryName.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						editSelection }! !!PasteUpMorph methodsFor: '*Tools' stamp: 'cmm 6/13/2010 20:41' prior: 25950778!defaultDesktopCommandKeyTriplets	"Answer a list of triplets of the form		<key> <receiver> <selector>   [+ optional fourth element, a <description> for use in desktop-command-key-help]that will provide the default desktop command key handlers.  If the selector takes an argument, that argument will be the command-key event"	| noviceKeys expertKeys |	noviceKeys := {		{ $o.	ActiveWorld.						#activateObjectsTool.						'Activate the "Objects Tool"'}.		{ $r.	ActiveWorld.						#restoreMorphicDisplay.					'Redraw the screen'}.				{ $z.	self.								#undoOrRedoCommand.					'Undo or redo the last undoable command'}.		{ $F.	Project current.					#toggleFlapsSuppressed.					'Toggle the display of flaps'}.		{ $N.	self.								#toggleClassicNavigatorIfAppropriate.	'Show/Hide the classic Navigator, if appropriate'}.		{ $M.	self.								#toggleShowWorldMainDockingBar.		'Show/Hide the Main Docking Bar'}.	}.	Preferences noviceMode			ifTrue:[^ noviceKeys].	expertKeys := {		{ $b.	SystemBrowser.					#defaultOpenBrowser.						'Open a new System Browser'}.		{ $k.	StringHolder.					#open.										'Open a new, blank Workspace'}.		{ $m.	self.								#putUpNewMorphMenu.					'Put up the "New Morph" menu'}.		{ $t.	self.	 							#findATranscript:.							'Make a System Transcript visible'}.		{ $w.	SystemWindow.					#closeTopWindow.							'Close the topmost window'}.		{ $C.	self.								#findAChangeSorter:.						'Make a Change Sorter visible'}.		{ $L.	self.								#findAFileList:.								'Make a File List visible'}.		{ $P.	self.								#findAPreferencesPanel:.					'Activate the Preferences tool'}.		{ $R.	Utilities. 								#browseRecentSubmissions.		'Make a Recent Submissions browser visible'}.		{ $W.	self. 								#findAMessageNamesWindow:.			'Make a MessageNames tool visible'}.		{ $Z.	ChangeList. 						#browseRecentLog.							'Browse recently-logged changes'}.		{ $\.	SystemWindow. 					#sendTopWindowToBack.					'Send the top window to the back'}.	}.	^ noviceKeys, expertKeys! !"Tools"!!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mtf 6/2/2010 21:17'!removeElement: element	"Used to purge certain elements from a document after parsing."	self elements remove: element ifAbsent: []! !"XML-Parser"!!MethodContext methodsFor: 'system simulation' stamp: 'eem 7/2/2010 10:26' prior: 51688740!pushArgs: args "<Array>" from: sendr "<ContextPart>" 	"Helps simulate action of the value primitive for closures.	 This is used by ContextPart>>runSimulated:contextAtEachStep:"	closureOrNil		ifNil: [self error: 'context needs a closure!!']		ifNotNil:			["See BlockClosure>>asContextWithSender:"			 stackp ~= (closureOrNil numArgs + closureOrNil numCopiedValues) ifTrue:				[self error: 'stack pointer is incorrect!!'].].	1 to: closureOrNil numArgs do:		[:i| self at: i put: (args at: i)].	sender := sendr! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/1/2010 19:30' prior: 50411308!asContextWithSender: aContext	"Inner private support method for evaluation.  Do not use unless you know what you're doing."	^((MethodContext newForMethod: outerContext method)		setSender: aContext		receiver: outerContext receiver		method: outerContext method		closure: self		startpc: startpc) privRefresh! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 11:50' prior: 50401628!value	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the copied values to the activation as its copied	 temps. Primitive. Essential."	<primitive: 201>	| newContext |	numArgs ~= 0 ifTrue:		[self numArgsError: 0].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:21' prior: 50402359!value: firstArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the argument and copied values to the activation	 as its argument and copied temps. Primitive. Essential."	<primitive: 202>	| newContext |	numArgs ~= 1 ifTrue:		[self numArgsError: 1].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22' prior: 50405069!value: firstArg value: secondArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 203>	| newContext |	numArgs ~= 2 ifTrue:		[self numArgsError: 2].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/7/2010 10:22' prior: 50412448!value: firstArg value: secondArg value: thirdArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 204>	| newContext |	numArgs ~= 3 ifTrue:		[self numArgsError: 3].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:31' prior: 50406404!value: firstArg value: secondArg value: thirdArg value: fourthArg	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments and copied values to the activation	 as its arguments and copied temps. Primitive. Essential."	<primitive: 205>	| newContext |	numArgs ~= 4 ifTrue:		[self numArgsError: 4].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			newContext at: 1 put: firstArg.			newContext at: 2 put: secondArg.			newContext at: 3 put: thirdArg.			newContext at: 4 put: fourthArg.			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/2/2010 10:29' prior: 50407714!valueWithArguments: anArray	"Activate the receiver, creating a closure activation (MethodContext)	 whose closure is the receiver and whose caller is the sender of this	 message. Supply the arguments in an anArray and copied values to	 the activation as its arguments and copied temps. Primitive. Essential."	<primitive: 206>	| newContext |	numArgs ~= anArray size ifTrue:		[self numArgsError: anArray size].	false		ifTrue: "Old code to simulate the closure value primitive on VMs that lack it."			[newContext := self asContextWithSender: thisContext sender.			1 to: numArgs do:				[:i| newContext at: i put: (anArray at: i)].			thisContext privSender: newContext]		ifFalse: [self primitiveFailed]! !"Kernel"!!FileStream class methodsFor: 'instance creation' stamp: 'eem 6/4/2010 15:10' prior: 20696661!detectFile: aBlock do: anotherBlock	^aBlock value		ifNil: [nil]      	ifNotNil: [:file| [anotherBlock value: file] ensure: [file close]]! !!FileStream class methodsFor: 'file reader services' stamp: 'eem 6/2/2010 09:42' prior: 20695524!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st).		] ifFalse: [			extension := (FileDirectory dot, FileStream cs).		].		converter := MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension := (FileDirectory dot, FileStream cs "multiCs").		].		converter := UTF8TextConverter new.	].	fileName := useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	fileName := FileDirectory default checkName: fileName fixErrors: true.	f := FileStream newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !!UnixFileDirectory methodsFor: 'file names' stamp: 'eem 6/2/2010 09:38'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName |	fName := super checkName: aFileName fixErrors: fixing.	(fName includes: self class pathNameDelimiter) ifFalse:		[^fName].	^fixing		ifTrue: [fName copyReplaceAll: (String with: self class pathNameDelimiter) with: '#']		ifFalse: [self error:'Invalid file name']! !"Files"!!Point methodsFor: 'printing' stamp: 'sw 9/27/2001 17:26' prior: 58335229!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Point methodsFor: 'point functions' stamp: 'wiz 8/6/2007 20:33'!fourDirections	"Return vertices for a square centered at 0 asPoint with the receiver as first corner.	Returns the four rotation of the reciever in counter clockwise order with the reciever 	appearing last. "	^ Array with: self leftRotated			with: self negated			with: self rightRotated			with: self 		! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 03:32'!leftRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #left centerAt: 0 asPoint .Compare to transposed and normal. "	^y  @x negated! !!Point methodsFor: 'point functions' stamp: 'wiz 7/28/2007 20:50' prior: 52177949!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise.	For the zero point return a normal of  -1@0   ."	| n d |		n _ y negated @ x.	(d := (n x * n x + (n y * n y))) = 0 ifTrue: [ ^  -1 @0  ] .	^n / d sqrt! !!Point methodsFor: 'point functions' stamp: 'wiz 7/26/2007 02:33'!rightRotated"Return the reciever rotated 90 degrees.i.e. self rotateBy: #right centerAt: 0 asPoint .Compare to transposed and normal. "	^y negated @x! !!Point methodsFor: 'point functions' stamp: 'wiz 8/1/2007 16:53'!sign^ (x sign @ y sign) .! !"Graphics"!!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 20:35'!testBasicFourDirections" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples results rejects |self assert:  (0 asPoint fourDirections) = (Array new: 4 withAll: 0 asPoint) . samples := 0 asPoint eightNeighbors  .results :=  { {0@-1 . -1@0 . 0@1 . 1@0}  . {1@-1 . -1@-1 . -1@1 . 1@1}   . {1@0 . 0@-1 . -1@0 . 0@1}   . {1@1 . 1@-1 . -1@-1 . -1@1}   . {0@1 . 1@0 . 0@-1 . -1@0}   . {-1@1 . 1@1 . 1@-1 . -1@-1}   . {-1@0 . 0@1 . 1@0 . 0@-1}   . {-1@-1 . -1@1 . 1@1 . 1@-1} } .rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections = (results at: each) ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 19:07'!testFourDirectionsInvarients" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples  rejects |samples := 0 asPoint eightNeighbors  .rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections last = ( samples  at: each) ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 20:32'!testFourDirectionsRotationInvarients" fourDirections returns the four rotation of the reciever in counter clockwise order with the reciever appearing last. "| samples  rejects |samples := 0 asPoint eightNeighbors  .rejects :=(1 to: samples size ) reject: [ :each | | answer  |		(answer :=  (samples at: each) fourDirections ) .		(1 to: 4) allSatisfy: [ :eachDirIndex | 			( answer atWrap: eachDirIndex)  leftRotated					 = (( answer atWrap: eachDirIndex + 1) )  ] ] .self assert: ( rejects isEmpty) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 18:24'!testNormal" quick check of results for #normal."| samples rejects results |samples :=0 asPoint eightNeighbors , (Array with: 0 asPoint) .results :=  { 0.0@1.0 . -0.707106781186547@0.707106781186547 . -1.0@0.0 . -0.707106781186547@-0.707106781186547 . 0.0@-1.0 . 0.707106781186547@-0.707106781186547 . 1.0@0.0 . 0.707106781186547@0.707106781186547 . -1@0} .rejects := (1 to: samples size ) reject: [ :each | ((samples at: each) normal - (results at: each)) abs  < 1e-15 asPoint ] .self assert: ( rejects isEmpty ) . ! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 18:48'!testNormal2" quick check of results for #normal.differs from the other testNormal in the way that the difference is measured."| samples rejects results differences |samples :=0 asPoint eightNeighbors , (Array with: 0 asPoint) .results :=  { 0.0@1.0 . -0.707106781186547@0.707106781186547 . -1.0@0.0 . -0.707106781186547@-0.707106781186547 . 0.0@-1.0 . 0.707106781186547@-0.707106781186547 . 1.0@0.0 . 0.707106781186547@0.707106781186547 . -1@0} .differences :=samples with: results collect: [ :each :eachResult |	each normal - eachResult ] .rejects := differences reject: [ :each | 	(each x closeTo: 0.0) and: [each y closeTo: 0.0] ] .self assert: ( rejects isEmpty ) . ! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 17:02'!testRotations" Here we are testing rightRotated and leftRotated which are new.Because there is really no coverage for point functions this also serves as a tests of sorts for rotateBy:CenterAt:"| samples |samples :=0 asPoint eightNeighbors , (Array with: 0 asPoint) .self assert: (samples allSatisfy: [ :each |	each rightRotated leftRotated = each ] ) .self assert: (samples allSatisfy: [ :each |	each rightRotated  = (each rotateBy: #right centerAt: 0 asPoint)] ) .self assert: (samples allSatisfy: [ :each |	each leftRotated  = (each rotateBy: #left centerAt: 0 asPoint ) ] ) .self assert: (samples allSatisfy: [ :each |	each negated  = (each rotateBy: #pi centerAt: 0 asPoint ) ] ) .self assert: (samples allSatisfy: [ :each | 	each leftRotated leftRotated leftRotated leftRotated = each ]) .self assert: (samples allSatisfy: [ :each |	each rightRotated rightRotated rightRotated rightRotated  = each ] ) .! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 18:38'!testSign | samples results rejects |samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .self shouldnt: [ results :=				samples collect: [ :each | each sign ] ]	raise: Error .	rejects :=(1 to: samples size ) reject: [ :each |		 (samples at: each) = (results at: each) ] .self assert: ( rejects isEmpty) ! !!PointTest methodsFor: 'testing - testing' stamp: 'wiz 8/6/2007 17:22'!testZeroPointNormal"old: normal of zero point raised divide by zero error.new: normal of zero point returns a direction right rotated from zero points direction."self shouldnt: [ (0 asPoint normal bearingToPoint: 0 asPoint) = 90 ] raise: Error.  ! !"GraphicsTests"!!ChangeRecord methodsFor: 'initialization' stamp: 'cmm 7/2/2010 18:26' prior: 33967283!fileIn	"File the receiver in.  If I represent a method or a class-comment, file the method in and make a note of it in the recent-submissions list; if I represent a do-it, then, well, do it; if I represent a reorganization then get organized!!"	Cursor read showWhile:		[| s cls aSelector |		type == #doIt			ifTrue:				[((s := self string) beginsWith: '----') ifFalse: [Compiler evaluate: s]]			ifFalse:				[cls := self methodClass.				 type == #method ifTrue:					[cls compile: self text classified: category withStamp: stamp notifying: nil.					(aSelector := self methodSelector) ifNotNil:						[Utilities noteMethodSubmission: aSelector forClass: cls]].				 type == #classComment ifTrue:					[cls comment: self text stamp: stamp.					Utilities noteMethodSubmission: #Comment forClass: cls ].				 type == #reorganize ifTrue:					[cls organization changeFromString: self text]]]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'eem 7/2/2010 17:20' prior: 58578468!flushClassNameCache	"Smalltalk flushClassNameCache"	"Force recomputation of the cached list of class names."	cachedClassNames := nil! !!SystemDictionary methodsFor: 'removing' stamp: 'eem 5/19/2010 15:35'!removeKey: key ifAbsent: aBlock	"Remove key (and its associated value) from the receiver. If key is not in	the receiver, answer the result of evaluating aBlock. Otherwise, answer	the value externally named by key."	self flushClassNameCache.	^super removeKey: key ifAbsent: aBlock! !"System"!!TextEditor commentStamp: '<historical>' prior: 59444043!See comment in Editor.My instances edit Text, this is, they support multiple lines and TextAttributes.They have no specific facilities for editing Smalltalk code. Those are found in SmalltalkEditor.!!Editor methodsFor: 'private' stamp: 'cmm 7/3/2010 15:56' prior: 57259462!moveCursor: directionBlock forward: forward specialBlock: specialBlock 	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	^ self		moveCursor: directionBlock		forward: forward		specialBlock: specialBlock		select: sensor leftShiftDown! !!Editor methodsFor: 'private' stamp: 'cmm 7/3/2010 15:55'!moveCursor: directionBlock forward: forward specialBlock: specialBlock select: shouldSelect	"Private - Move cursor.	directionBlock is a one argument Block that computes the new Position from a given one.	specialBlock is a one argumentBlock that computes the new position from a given one under the alternate semantics.	Note that directionBlock always is evaluated first."	| indices newPosition |	indices := self setIndices: shouldSelect forward: forward.	newPosition := directionBlock value: (indices at: #moving).	(sensor commandKeyPressed or:[sensor controlKeyPressed])		ifTrue: [newPosition := specialBlock value: newPosition].	sensor keyboard.	shouldSelect		ifTrue: [self selectMark: (indices at: #fixed) point: newPosition - 1]		ifFalse: [self selectAt: newPosition]! !!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:18'!autoEnclose	<preference: 'Auto Enclose'		category: 'Morphic'		description: 'When true, typing an opening parenthesis, bracket or square-bracket will also add its corresponding closing character in front of the cursor.'		type: #Boolean>	^ AutoEnclose ifNil: [ false ]! !!TextEditor class methodsFor: 'accessing' stamp: 'cmm 7/3/2010 16:17'!autoEnclose: aBoolean	AutoEnclose := aBoolean! !!TextEditor class methodsFor: 'keyboard shortcut tables' stamp: 'cmm 7/2/2010 19:00' prior: 56425262!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key (or alt-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"TextEditor initialize"	| cmdMap cmds |	cmdMap := Array new: 256 withAll: #noop:.		"use temp in case of a crash"	cmdMap at: 1 + 1 put: #cursorHome:.				"home key"	cmdMap at: 4 + 1 put: #cursorEnd:.				"end key"	cmdMap at: 8 + 1 put: #backspace:.				"ctrl-H or delete key"	cmdMap at: 11 + 1 put: #cursorPageUp:.			"page up key"	cmdMap at: 12 + 1 put: #cursorPageDown:.		"page down key"	cmdMap at: 13 + 1 put: #crWithIndent:.			"cmd-Return"	cmdMap at: 27 + 1 put: #offerMenuFromEsc:.		"escape key"	cmdMap at: 28 + 1 put: #cursorLeft:.				"left arrow key"	cmdMap at: 29 + 1 put: #cursorRight:.				"right arrow key"	cmdMap at: 30 + 1 put: #cursorUp:.				"up arrow key"	cmdMap at: 31 + 1 put: #cursorDown:.				"down arrow key"	cmdMap at: 32 + 1 put: #selectWord:.				"space bar key"	cmdMap at: 127 + 1 put: #forwardDelete:.		"del key"				'0123456789-=' 		do: [:char | cmdMap at: char asciiValue + 1 put: #changeEmphasis:].			'([{''"<' do: [:char | cmdMap at: char asciiValue + 1 put: #enclose:].		cmds := #($a #selectAll: $c #copySelection: $e #exchange: $f #find: $g #findAgain: $h #setSearchString: $k #offerFontMenu: $u #align: $v #paste: $w #backWord: $x #cut: $y #swapChars: $z #undo:).	1 to: cmds size		by: 2		do: [:i | cmdMap at: (cmds at: i) asciiValue + 1 put: (cmds at: i + 1)].			cmdActions := cmdMap! !!TextEditor methodsFor: 'typing support' stamp: 'cmm 7/3/2010 16:12' prior: 57283772!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys openers closers result |	((char == Character cr) and: [morph acceptOnCR])		ifTrue: [			sensor keyboard.  "Gobble cr -- probably unnecessary."			self closeTypeIn.			^ true].	self clearParens.  	char asciiValue = 13 ifTrue: [		sensor controlKeyPressed ifTrue: [			^ self normalCharacter: typeAheadStream ].		sensor leftShiftDown ifTrue: [			^ self lf: typeAheadStream ].		sensor commandKeyPressed ifTrue: [			^ self crlf: typeAheadStream ].		^ self crWithIndent: typeAheadStream ].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue: [				self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [				self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue: [			^ self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	openers := '([{'.  closers := ')]}'.	(closers includes: char) ifTrue: [self blinkPrevParen].	result := self normalCharacter: typeAheadStream.	(self class autoEnclose and: [ openers includes: char ])		ifTrue: 			[ typeAheadStream nextPut: (closers at: (openers indexOf: char)).			self insertTypeAhead: typeAheadStream.			self moveCursor: [ : position | position-1 ] forward: false specialBlock: [ : pos | "no special behavior" ] select: false ].	^ result! !!TextEditor methodsFor: 'editing keys' stamp: 'cmm 7/2/2010 19:01' prior: 57286011!enclose: characterStream	"Insert or remove bracket characters around the current selection.	 Flushes typeahead."	| char left right startIndex stopIndex oldSelection which text |	char := sensor keyboard.	self closeTypeIn.	startIndex := self startIndex.	stopIndex := self stopIndex.	oldSelection := self selection.	which := '([{"''' indexOf: char ifAbsent: [ ^true ].	left := '([{"''' at: which.	right := ')]}"''' at: which.	text := paragraph text.	((startIndex > 1 and: [stopIndex <= text size])			and: [ (text at: startIndex-1) = left and: [(text at: stopIndex) = right]])		ifTrue: [			"already enclosed; strip off brackets"			self selectFrom: startIndex-1 to: stopIndex.			self replaceSelectionWith: oldSelection]		ifFalse: [			"not enclosed; enclose by matching brackets"			self replaceSelectionWith:				(Text string: (String with: left), oldSelection string, (String with: right) attributes: emphasisHere).			self selectFrom: startIndex+1 to: stopIndex].	^true! !"Morphic"!!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06' prior: 52326729!startTransmittingEvents	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !!RemoteHandMorph methodsFor: 'connections' stamp: 'ar 7/10/2010 13:06' prior: 52328069!startTransmittingEventsTo: remoteAddr	"Attempt to broadcast events from this hand to a remote hand on the host with the given address. This method just creates the new socket and initiates a connection; it does not wait for the other end to answer."	remoteAddress := remoteAddr.	(sendSocket notNil and:[sendSocket isConnected]) ifTrue:[^self].	Transcript		show: 'Connecting to remote WorldMorph at ';		show: (NetNameResolver stringFromAddress: self remoteHostAddress), ' ...'; cr.	sendSocket := Socket newTCP.	sendSocket connectTo: self remoteHostAddress port: 54323.	sendState := #opening.	owner primaryHand addEventListener: self.! !"MorphicExtras"!!HTTPSocket commentStamp: 'ar 7/10/2010 14:05' prior: 59316211!HTTPSockets is a facade for handling common HTTP requests. It provides a minimal implementation of the HTTP protocol, but can be extended by third party clients that register themselves as #httpRequestHandler (see class-side protocol).A third-party request handler needs to implement the single method	#httpRequest:url:headers:content:response:in a way that is compatible with the baseline implementation in HTTPSocket.!!HTTPSocket class methodsFor: 'class initialization' stamp: 'ls 9/17/1998 07:17' prior: 21401861!defaultPort	"default port to connect on"	^80! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:21' prior: 55841808!httpGet: url args: args user: user passwd: passwd	"Upload the contents of the stream to a file on the server.	WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization result |	authorization := (user , ':' , passwd) base64Encoded.	result := self 		httpGet: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf.	^result! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:36' prior: 57424081!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	args ifNotNil: [		urlString := urlString, (self argString: args) 	].	^(self httpRequestHandler) 		httpRequest: 'GET' url: urlString headers:(			(mimeType ifNil:[''] ifNotNil:['Accept: ', mimeType, String crlf]),			'Accept: text/html', String crlf,			HTTPBlabEmail,			requestString		) content: nil response: nil.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/27/2010 12:23' prior: 55849681!httpPost: url args: args user: user passwd: passwd	"WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| authorization |	authorization := (user , ':' , passwd) base64Encoded.	^self 		httpPostDocument: url args: args accept: '*/*' 		request: 'Authorization: Basic ' , authorization , String crlf! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:52'!httpPost: url content: postData type: contentType accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	^(self httpRequestHandler) 		httpRequest: 'POST' url: urlString headers:(			'Accept: ', mimeType, String crlf,			'Accept: text/html', String crlf,			'Content-Type: ', contentType, String crlf,			'Content-Length: ', (postData ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString "extra user request. Authorization"		) content: (postData ifNil:['']) response: nil! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 2/25/2010 15:49' prior: 55852168!httpPostDocument: url  args: args accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| argString  |	args ifNotNil: [		argString := self argString: args.		argString first = $? ifTrue: [argString := argString allButFirst].	].	^self httpPost: url 			content: argString 			type: 'application/x-www-form-urlencoded' 			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:31' prior: 55835558!httpPostMultipart: url args: argsDict accept: mimeType request: requestString	" do multipart/form-data encoding rather than x-www-urlencoded "	| mimeBorder argsStream |	mimeBorder := '----squeak-georgia-tech-', Time millisecondClockValue printString, '-csl-cool-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value | | fieldValue |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, String crlf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: multipart/form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', String crlf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: String crlf, String crlf, fieldValue, String crlf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	^self httpPost: url 			content: argsStream contents			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 6/17/2010 20:30' prior: 21394126!httpPostToSuperSwiki: url args: argsDict accept: mimeType request: requestString	| mimeBorder argString |	mimeBorder := '---------SuperSwiki',Time millisecondClockValue printString,'-----'.	argString := String streamContents: [ :strm |		strm nextPutAll: mimeBorder, String crlf.		argsDict associationsDo: [:assoc |			assoc value do: [ :value |				strm					nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"';					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: value;					nextPutAll: String crlf;					nextPutAll: String crlf;					nextPutAll: mimeBorder;					nextPutAll: String crlf.			]		].	].	^self httpPost: url 			content: argString 			type:  'multipart/form-data; boundary=', mimeBorder			accept: mimeType 			request: requestString! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42' prior: 21403989!httpProxyPort	"answer the httpProxyPort"	<preference: 'HTTP Proxy Port'		category: 'HTTP Proxy'		description: 'HTTP Proxy Port'		type: #Number>	^HTTPProxyPort ifNil:[80]! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42' prior: 21404195!httpProxyPort: aPortNumber	"Set the proxy port"	HTTPProxyPort := aPortNumber.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:42' prior: 21404402!httpProxyServer	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	<preference: 'HTTP Proxy Server'		category: 'HTTP Proxy'		description: 'HTTP Proxy Server. Leave blank if you don''t want to use a Proxy'		type: #String>	^HTTPProxyServer ifNil:['']! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 6/17/2010 20:43' prior: 55842822!httpProxyServer: aString	"answer the httpProxyServer. Take into account that as a Preference the Server might appear as an empty string but HTTPSocket expect it to be nil"	HTTPProxyServer := aString.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:53' prior: 55843926!httpPut: contents to: url user: user passwd: passwd	"Upload the contents of the stream to a file on the server		WARNING: This method will send a basic auth header proactively.	This is necessary to avoid breaking MC and SqueakSource since SS does not 	return a 401 when accessing a private (global no access) repository."	| urlString resp header |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	resp := (self httpRequestHandler) 		httpRequest: 'PUT' url: urlString headers:(			'Authorization: Basic ', (user, ':', passwd) base64Encoded, String crlf,			'Accept: */*', String crlf,			'Content-Type: application/octet-stream', String crlf,			'Content-Length: ', (contents ifNil:['']) size, String crlf,			HTTPProxyCredentials,			HTTPBlabEmail		) content: contents response:[:rr| header := rr].	^resp isString ifTrue:[header, resp] ifFalse:[header, resp content]! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/10/2010 13:53'!httpRequest: method url: urlString headers: hdrs content: contentOrNil response: responseBlock	"Sends an HTTP request to the server. Returns a MIMEDocument if successful,	a string indicating the error otherwise. If a response block is provided, the	response is fed into into so that the sender can see all the headers."	| index serverAndPort server port rawUrl stream resp code headers 	  contentLength contentType contentStream |	(urlString beginsWith: 'http://') ifFalse:[self error: 'Not a http url'].	"Extract server, port, and url"	index := urlString indexOf: $/ startingAt: 8 ifAbsent:[urlString size+1]. "past http://"	serverAndPort := urlString copyFrom: 8 to: index-1.	server := serverAndPort copyUpTo: $:.	port := ((serverAndPort copyAfter: $:) ifEmpty:['80']) asNumber.	"Prepare the request URI"	rawUrl := urlString copyFrom: index to: urlString size.	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].	rawUrl := rawUrl encodeForHTTPWithTextEncoding: 'utf-8' 				conditionBlock: [:c | c isSafeForHTTP or:['/;&=\?' includes: c]].	"Check for proxy"	(self shouldUseProxy: server) ifTrue:[		self httpProxyServer ifNotEmpty:[			rawUrl := 'http://', serverAndPort, rawUrl. "per RFC 2616"			server := self httpProxyServer.			port := self httpProxyPort.		].	].	"Fire off the request"	stream := SocketStream openConnectionToHostNamed: server port: port.	stream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: 'HTTP/1.0'; crlf.	stream nextPutAll: 'Host: ', serverAndPort; crlf.	stream nextPutAll: 'Connection: close'; crlf.	stream nextPutAll: 'User-Agent: ', self userAgentString; crlf.	stream nextPutAll: hdrs.	stream crlf.	contentOrNil ifNotNil:[		"Upload request content"		contentStream := contentOrNil readStream.		[contentStream atEnd] whileFalse:[			(HTTPProgress new) total: contentOrNil size; 				amount: contentStream position; signal: 'Uploading...'.			stream nextPutAll: (contentStream next: 4096).			stream flush.		].	].	stream flush.	"Read the response"	resp := stream upToAll: String crlfcrlf.	"Extract the response code"	code := ((resp copyUpTo: String cr) findTokens: ' ') second asNumber.	"And the response headers"	headers := Dictionary new.	resp lines allButFirst allButLast do:[:nextLine|		headers at: (nextLine copyUpTo: $:) asLowercase 			put: (nextLine copyAfter: $:) withBlanksTrimmed.	].	"Read response content"	contentLength := headers at: 'content-length' ifAbsent:[nil].	contentType := headers at: 'content-type' ifAbsent:['application/octet-stream'].	"Fixme - Provide HTTProgress"	contentLength 		ifNil:[contentStream := WriteStream with: stream upToEnd]		ifNotNil:[			contentLength := contentLength asNumber.			contentStream := (String new: contentLength) writeStream. 			[contentStream position < contentLength] whileTrue:[				contentStream nextPutAll: 					(stream next: (contentLength - contentStream position min: 4096)).				(HTTPProgress new) total: contentLength; 					amount: contentStream position; signal: 'Downloading...'.			].		].	stream close.	responseBlock ifNotNil:[responseBlock value: resp].	^(code between: 200 and: 299) 		ifTrue:[MIMEDocument contentType: contentType 				content: contentStream contents url: urlString]		ifFalse:[resp asString, contentStream contents].! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:34'!httpRequestHandler	"Answer the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket. If no handler is registered, answer the receiver"	^HTTPRequestHandler ifNil:[self]! !!HTTPSocket class methodsFor: 'handler' stamp: 'ar 7/10/2010 13:35'!httpRequestHandler: anObject	"Set the registered handler for http requests. The handler needs to implement 	#httpRequest:url:headers:content:response: compatible with the baseline version	in HTTPSocket."	HTTPRequestHandler := anObject! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'ar 7/10/2010 13:59' prior: 21374448!initialize	"HTTPSocket initialize"	HTTPPort := 80.	self httpProxyServer: nil.	HTTPBlabEmail := ''.  "	'From: somebody@no.where', CrLf	"	HTTPProxyCredentials := ''.	ExternalSettings registerClient: self.	self removeHTTPProxyPreferences.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ar 7/10/2010 14:01'!removeHTTPProxyPreferences	" This method will remove the old HTTP Proxy preferences. "	(Preferences valueOfPreference: #httpProxyServer) ifNotNil:[		HTTPProxyServer := Preferences valueOfPreference: #httpProxyServer.		Preferences removePreference: #httpProxyServer.	].	(Preferences valueOfPreference: #httpProxyPort) ifNotNil:[		HTTPProxyPort := Preferences valueOfPreference: #httpProxyPort.		Preferences removePreference: #httpProxyPort.	].! !HTTPSocket removeSelector: #sendDataWithProgress:!HTTPSocket removeSelector: #sendCommandWithProgress:!HTTPSocket removeSelector: #responseCode!HTTPSocket removeSelector: #redirect!HTTPSocket removeSelector: #logToTranscript!HTTPSocket removeSelector: #header:!HTTPSocket removeSelector: #getRestOfBuffer:totalLength:!HTTPSocket removeSelector: #getRestOfBuffer:!HTTPSocket removeSelector: #getResponseUpTo:ignoring:!HTTPSocket removeSelector: #getResponseUpTo:!HTTPSocket removeSelector: #getHeader:default:!HTTPSocket removeSelector: #getHeader:!HTTPSocket removeSelector: #contentsLength:!HTTPSocket removeSelector: #contentType:!HTTPSocket removeSelector: #contentType!HTTPSocket class removeSelector: #retry:asking:ifGiveUp:!HTTPSocket class removeSelector: #proxyTestingComment!HTTPSocket class removeSelector: #md5Hash:!HTTPSocket class removeSelector: #ip:port:urlPath:!HTTPSocket class removeSelector: #initHTTPSocket:wait:ifError:!HTTPSocket class removeSelector: #initHTTPSocket:ifError:!HTTPSocket class removeSelector: #expandUrl:ip:port:!HTTPSocket class removeSelector: #digestFrom:method:url:user:password:!HTTPSocket class removeSelector: #digestFor:method:url:user:password:!HTTPSocket class removeSelector: #checkHTTPProxyPreferences!HTTPSocket class removeSelector: #argStringUnencoded:!HTTPSocket class removeSelector: #addHTTPProxyPreferences!OldSocket removeSelector: #writeSemaphore!OldSocket removeSelector: #waitForSendDoneUntil:!OldSocket removeSelector: #waitForDisconnectionUntil:!OldSocket removeSelector: #waitForDataUntil:!OldSocket removeSelector: #waitForConnectionUntil:!OldSocket removeSelector: #waitForAcceptUntil:!OldSocket removeSelector: #unregister!OldSocket removeSelector: #statusString!OldSocket removeSelector: #socketHandle!OldSocket removeSelector: #socketError!OldSocket removeSelector: #setPort:!OldSocket removeSelector: #setPeer:port:!OldSocket removeSelector: #setOption:value:!OldSocket removeSelector: #sendUDPData:toHost:port:!OldSocket removeSelector: #sendSomeData:startIndex:count:!OldSocket removeSelector: #sendSomeData:startIndex:!OldSocket removeSelector: #sendSomeData:!OldSocket removeSelector: #sendDone!OldSocket removeSelector: #sendData:toHost:port:!OldSocket removeSelector: #sendData:count:!OldSocket removeSelector: #sendData:!OldSocket removeSelector: #semaphore!OldSocket removeSelector: #remotePort!OldSocket removeSelector: #remoteAddress!OldSocket removeSelector: #register!OldSocket removeSelector: #receiveUDPDataInto:!OldSocket removeSelector: #receiveDataInto:fromHost:port:!OldSocket removeSelector: #receiveDataInto:!OldSocket removeSelector: #readSemaphore!OldSocket removeSelector: #readInto:startingAt:!OldSocket removeSelector: #printOn:!OldSocket removeSelector: #primitiveOnlySupportsOneSemaphore!OldSocket removeSelector: #primSocketSendDone:!OldSocket removeSelector: #primSocketRemotePort:!OldSocket removeSelector: #primSocketRemoteAddress:!OldSocket removeSelector: #primSocketReceiveDataAvailable:!OldSocket removeSelector: #primSocketLocalPort:!OldSocket removeSelector: #primSocketLocalAddress:!OldSocket removeSelector: #primSocketError:!OldSocket removeSelector: #primSocketDestroyGently:!OldSocket removeSelector: #primSocketDestroy:!OldSocket removeSelector: #primSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex:!OldSocket removeSelector: #primSocketCreateNetwork:type:receiveBufferSize:sendBufSize:semaIndex:!OldSocket removeSelector: #primSocketConnectionStatus:!OldSocket removeSelector: #primSocketCloseConnection:!OldSocket removeSelector: #primSocketAbortConnection:!OldSocket removeSelector: #primSocket:setPort:!OldSocket removeSelector: #primSocket:setOption:value:!OldSocket removeSelector: #primSocket:sendUDPData:toHost:port:startIndex:count:!OldSocket removeSelector: #primSocket:sendData:startIndex:count:!OldSocket removeSelector: #primSocket:receiveUDPDataInto:startingAt:count:!OldSocket removeSelector: #primSocket:receiveDataInto:startingAt:count:!OldSocket removeSelector: #primSocket:listenOn:backlogSize:interface:!OldSocket removeSelector: #primSocket:listenOn:backlogSize:!OldSocket removeSelector: #primSocket:listenOn:!OldSocket removeSelector: #primSocket:getOption:!OldSocket removeSelector: #primSocket:connectTo:port:!OldSocket removeSelector: #primAcceptFrom:receiveBufferSize:sendBufSize:semaIndex:readSemaIndex:writeSemaIndex:!OldSocket removeSelector: #primAcceptFrom:receiveBufferSize:sendBufSize:semaIndex:!OldSocket removeSelector: #port!OldSocket removeSelector: #peerName!OldSocket removeSelector: #localPort!OldSocket removeSelector: #localAddress!OldSocket removeSelector: #listenOn:backlogSize:interface:!OldSocket removeSelector: #listenOn:backlogSize:!OldSocket removeSelector: #listenOn:!OldSocket removeSelector: #isWaitingForConnection!OldSocket removeSelector: #isValid!OldSocket removeSelector: #isUnconnectedOrInvalid!OldSocket removeSelector: #isUnconnected!OldSocket removeSelector: #isThisEndClosed!OldSocket removeSelector: #isOtherEndClosed!OldSocket removeSelector: #isConnected!OldSocket removeSelector: #initialize:!OldSocket removeSelector: #getResponseNoLF!OldSocket removeSelector: #getOption:!OldSocket removeSelector: #getData!OldSocket removeSelector: #finalize!OldSocket removeSelector: #disconnect!OldSocket removeSelector: #discardReceivedData!OldSocket removeSelector: #destroy!OldSocket removeSelector: #dataAvailable!OldSocket removeSelector: #connectTo:port:!OldSocket removeSelector: #closeAndDestroy:!OldSocket removeSelector: #closeAndDestroy!OldSocket removeSelector: #close!OldSocket removeSelector: #address!OldSocket removeSelector: #acceptFrom:!OldSocket removeSelector: #accept!OldSocket class removeSelector: #wildcardPort!OldSocket class removeSelector: #wildcardAddress!OldSocket class removeSelector: #unregister:!OldSocket class removeSelector: #udpCreateIfFail:!OldSocket class removeSelector: #timeTestUDP3!OldSocket class removeSelector: #timeTestUDP2!OldSocket class removeSelector: #timeTestUDP!OldSocket class removeSelector: #timeTest!OldSocket class removeSelector: #tcpCreateIfFail:!OldSocket class removeSelector: #standardDeadline!OldSocket class removeSelector: #remoteTestSinkTCP!OldSocket class removeSelector: #remoteTestServerUDP2!OldSocket class removeSelector: #remoteTestServerUDP!OldSocket class removeSelector: #remoteTestServerTCPUsingAccept!OldSocket class removeSelector: #remoteTestServerTCPOpenClosePutGet!OldSocket class removeSelector: #remoteTestServerTCPOpenClose1000!OldSocket class removeSelector: #remoteTestServerTCP!OldSocket class removeSelector: #remoteTestClientUDP!OldSocket class removeSelector: #remoteTestClientTCPOpenClosePutGet!OldSocket class removeSelector: #remoteTestClientTCPOpenClose1000!OldSocket class removeSelector: #remoteTestClientTCP!OldSocket class removeSelector: #registryThreshold:!OldSocket class removeSelector: #registryThreshold!OldSocket class removeSelector: #registry!OldSocket class removeSelector: #register:!OldSocket class removeSelector: #pingPortsOn:!OldSocket class removeSelector: #pingPorts:on:timeOutSecs:!OldSocket class removeSelector: #ping:!OldSocket class removeSelector: #newUDP!OldSocket class removeSelector: #newTCP!OldSocket class removeSelector: #new!OldSocket class removeSelector: #nameForWellKnownTCPPort:!OldSocket class removeSelector: #initializeNetworkIfFail:!OldSocket class removeSelector: #initializeNetwork!OldSocket class removeSelector: #initialize!OldSocket class removeSelector: #ensureNetworkConnected!OldSocket class removeSelector: #deadlineSecs:!OldSocket class removeSelector: #deadServer:!OldSocket class removeSelector: #deadServer!OldSocket class removeSelector: #createIfFail:!OldSocket class removeSelector: #clientServerTestUDP2!OldSocket class removeSelector: #clientServerTestUDP!OldSocket class removeSelector: #acceptFrom:!OldSimpleClientSocket removeSelector: #waitForDataQueryingUserEvery:!OldSimpleClientSocket removeSelector: #sendCommand:!OldSimpleClientSocket removeSelector: #getResponseShowing:!OldSimpleClientSocket removeSelector: #getResponse!OldSimpleClientSocket removeSelector: #getMultilineResponseShowing:!OldSimpleClientSocket removeSelector: #getMultilineResponse!OldSimpleClientSocket removeSelector: #displayString:!OldSimpleClientSocket class removeSelector: #timeTest!OldSimpleClientSocket class removeSelector: #simpleDateString:!OldSimpleClientSocket class removeSelector: #sensorStateString!OldSimpleClientSocket class removeSelector: #remoteCursorTest!OldSimpleClientSocket class removeSelector: #remoteCursorReceiver!OldSimpleClientSocket class removeSelector: #popTest!OldSimpleClientSocket class removeSelector: #parseSensorStateString:!OldSimpleClientSocket class removeSelector: #parseNTTPMsgList:!OldSimpleClientSocket class removeSelector: #parseIntegerList:!OldSimpleClientSocket class removeSelector: #parseHeaderList:!OldSimpleClientSocket class removeSelector: #nntpTest!OldSimpleClientSocket class removeSelector: #initialize!OldSimpleClientSocket class removeSelector: #httpTestHost:port:url:!OldSimpleClientSocket class removeSelector: #forkingRemoteCursorSender!OldSimpleClientSocket class removeSelector: #finger:!OldSimpleClientSocket class removeSelector: #extractDateFromAndSubjectFromHeader:!OldSimpleClientSocket class removeSelector: #crLf!Smalltalk removeClassNamed: #OldSimpleClientSocket!Smalltalk removeClassNamed: #OldSocket!Preferences class removeSelector: #httpProxyServer!Preferences class removeSelector: #httpProxyPort!"Network"!!TestCase methodsFor: 'running' stamp: 'ar 7/9/2010 11:31' prior: 33847888!timeout: aBlock after: seconds	"Evaluate the argument block. Time out if the evaluation is not	complete after the given number of seconds. Handle the situation	that a timeout may occur after a failure (during debug)"	| theProcess delay watchdog |	"the block will be executed in the current process"	theProcess := Processor activeProcess.	delay := Delay forSeconds: seconds.	"make a watchdog process"	watchdog := [		delay wait. 	"wait for timeout or completion"		theProcess ifNotNil:[ theProcess signalException: 			(TestFailure new messageText: 'Test timed out') ] 	] newProcess.	"Watchdog needs to run at high priority to do its job (but not at timing priority)"	watchdog priority: Processor timingPriority-1.	"catch the timeout signal"	watchdog resume.				"start up the watchdog"	^[aBlock on: TestFailure, Error, Halt do:[:ex|		theProcess := nil.		ex pass.	]] ensure:[							"evaluate the receiver"		theProcess := nil.				"it has completed, so ..."		delay delaySemaphore signal.	"arrange for the watchdog to exit"	]! !"SUnit"!!DecompilerTests methodsFor: 'utilities' stamp: 'ar 7/10/2010 13:06' prior: 59170886!decompilerFailures	"here is the list of failures: DNU resulting in trying to decompile the following methods"	^ #((AdditionalMethodState at:ifAbsent:)		(AdditionalMethodState at:ifAbsentPut:)		(AdditionalMethodState at:put:)		(AdditionalMethodState hasLiteralSuchThat:)		(AdditionalMethodState hasLiteralThorough:)		(AdditionalMethodState includesProperty:)		(AdditionalMethodState keysAndValuesDo:)		(AdditionalMethodState pragmas)		(AdditionalMethodState properties)		(AdditionalMethodState propertyKeysAndValuesDo:)		(AdditionalMethodState propertyValueAt:ifAbsent:)		(AdditionalMethodState removeKey:ifAbsent:)		(AdditionalMethodState setMethod:)		(BalloonEngineSimulation circleCosTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		 (BalloonEngineSimulation circleSinTable "-0.3826834323650903 => -0.38268343236509 or -0.3826834323650902")		(BlockNode emitCodeExceptLast:encoder:)		(BlockNode sizeCodeExceptLast:)		(Categorizer changeFromCategorySpecs:)		(Categorizer elementCategoryDict)		(ChatNotes storeAIFFOnFile:)		(ClosureTests testToDoInsideTemp)		(Command veryDeepFixupWith:)		(CompiledMethod =)		(CompiledMethod allEmbeddedBlockMethods)		(CompiledMethod embeddedBlockMethods)		(CompiledMethod getPreambleFrom:at:)		(CompiledMethod hasLiteralSuchThat:)		(CompiledMethod hasLiteralThorough:)		(CompiledMethod sameTraitCodeAs:)		(Date printOn:)		(DependencyBrowser computePackageDependencies:)		(EventSensor eventTickler)		(Float printPaddedWith:to:)		(FMSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(Form preMultiplyAlpha)		(FTPClient getDataInto:)		 (GeniePlugin primSameClassAbsoluteStrokeDistanceMyPoints:otherPoints:myVectors:otherVectors:mySquaredLengths:otherSquaredLengths:myAngles:otherAngles:maxSizeAndReferenceFlag:rowBase:rowInsertRemove:rowInsertRemoveCount: "Cannot compile -- stack including temps is too deep")		(GZipReadStream on:from:to:)		(GraphMorph drawDataOn:)		(HttpUrl checkAuthorization:retry:)		(Integer asBytesDescription)		(IntegerTest testNumberOfDigits)		(IntegerTest testPrintStringBase)		(JPEGReadWriter decodeBlockInto:component:dcTable:acTable:)		(LoopedSampledSound mixSampleCount:into:startingAt:leftVol:rightVol:)		(MessageTally treePrintOn:tabs:thisTab:total:totalTime:tallyExact:orThreshold:)		(MessageTrace selectAllBetweenAnchorAnd:)		(MethodPragmaTest testCompileCharacter)		(MultiByteBinaryOrTextStream next:)		(MultiByteFileStream next:)		(MVCProject textWindows)		(MVCToolBuilder setLayout:in:)		(NewParagraph selectionRectsFrom:to:)		(PackageDependencyTest testPackage:dependsExactlyOn:)		(PasteUpMorph dropFiles:)		(Player veryDeepFixupWith:)		(PluggableTabButtonMorph calculateArcLengths)		(PluggableTabButtonMorph drawTabOn:)		(PluckedSound reset)		(PNGReadWriter copyPixelsGray:)		(PNGReadWriter processInterlaced)		(PNMReadWriter nextPutRGB:)		(PNMReadWriter nextPutBW:reverse:)		(PNMReadWriter readBWreverse:)		(PNMReadWriter readGray)		(PNMReadWriter readPlainRGB)		(PNMReadWriter writeHeader:)		(PointTest testTheta)		(PopUpMenu readKeyboard)		(PostscriptCanvas outlineQuadraticBezierShape:)		(QPickable2D pick:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(QUsersPane userEntryCompare:to:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(RelativeInstructionPrinter print:)		(RemoteHandMorph appendNewDataToReceiveBuffer)		(ScaledDecimalTest testConvertFromFraction)		(SHMCClassDefinition allInstVarNames)		(SHMCClassDefinition withAllSuperclasses)		(ShortIntegerArray writeOn:)		(SHParserST80 isBinary)		(StandardScriptingSystem holderWithAlphabet)		(StrikeFontSet displayStringR2L:on:from:to:at:kern:)		(String howManyMatch:)		(String keywords)		(StringTest testWthNoLineLongerThan)		(SyntaxMorph replaceKeyWord:menuItem:)		(SyntaxMorph replaceSel:menuItem:)		(TextDiffBuilder lcsFor:and:)		(TextURL actOnClickFor:)		(TShaderProgram vertexStrings) "foo ifTrue: []. => foo. => ."		(TShaderProgram fragmentStrings) "foo ifTrue: []. => foo. => ."		(TTContourConstruction segmentsDo:) "out of scope variable"		(TTCFontReader processCharacterMappingTable:)		(TTFileDescription getGlyphFlagsFrom:size:)		(TTFileDescription processCharacterMappingTable:)		(TTFontReader getGlyphFlagsFrom:size:)		(TTFontReader processCharacterMappingTable:)		(TTFontReader processHorizontalMetricsTable:length:)		(TWindow zoomWindow:) "foo ifTrue: [^bar] ifFalse: [^baz]. ^huh?"		(WaveEditor showEnvelope)		(WeakSet scanForLoadedSymbol:)		"(PNMReadWriter nextImage) (Collection #ifEmpty:ifNotEmpty:) (Collection #ifEmpty:) (Collection #ifNotEmpty:ifEmpty:) (Text #alignmentAt:ifAbsent:) (ObjectWithDocumentation propertyAt:ifAbsent:)")! !"Tests"!!MessageNames methodsFor: 'selection' stamp: 'eem 6/18/2008 03:10'!selectedMessageName	^selectorListIndex = 0 ifFalse: [selectorList at: selectorListIndex]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:28'!restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self systemCategoryListIndex: (self systemCategoryList indexOf: category).	self classListIndex: (self classListIndexOf: className).	self metaClassIndicated: metaBool.	self messageCategoryListIndex: (self messageCategoryList indexOf: protocol).	self messageListIndex: (self messageList indexOf: selector).	editSelection := editMode.	self		contentsChanged;		decorateButtons! !!Browser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:23' prior: 34073507!saveMultiWindowState	^Message		selector: #restoreToCategory:className:protocol:selector:mode:meta:		arguments: {	self selectedSystemCategoryName.						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24'!restoreToPackage: packageNameOrNil category: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool	self packageListIndex: (self packageList indexOf: packageNameOrNil).	super restoreToCategory: category className: className protocol: protocol selector: selector mode: editMode meta: metaBool! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 7/6/2010 12:24' prior: 34047186!saveMultiWindowState	^Message		selector: #restoreToPackage:category:className:protocol:selector:mode:meta:		arguments: {	self package.						self systemCategoryList at: systemCategoryListIndex ifAbsent: [].						self selectedClassName.						self selectedMessageCategoryName.						self selectedMessageName.						self editSelection.						self metaClassIndicated }! !PackagePaneBrowser removeSelector: #restoreToPackage:category:className:protocol:selector:mode:!Browser removeSelector: #restoreToCategory:className:protocol:selector:mode:!"Tools"!!Collection methodsFor: 'enumerating' stamp: 'eem 1/11/2009 14:11'!fold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]"	| firstValue nextValue |	firstValue := nextValue := Object new. "something that can't be in the receiver"	self do:		[:each |		nextValue := firstValue == nextValue						ifTrue: [each]						ifFalse: [binaryBlock value: nextValue value: each]].	^nextValue == firstValue		ifTrue: [self errorEmptyCollection]		ifFalse: [nextValue]! !!Character methodsFor: 'printing' stamp: 'eem 5/21/2010 11:11' prior: 18434657!hex	^value printStringBase: 16! !!SequenceableCollection methodsFor: 'copying' stamp: 'eem 2/10/2009 11:44'!copyUpThrough: anElement 	"Answer all elements up to and including anObject. If there	is no such object, answer a copy of the receiver."	^self first: (self indexOf: anElement ifAbsent: [^ self copy])! !!String methodsFor: 'converting' stamp: 'ar 7/15/2010 17:13' prior: 57349222!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	^self class		new: self size * (aNumber + 1) // aNumber "provision for supplementary line breaks"		streamContents: [ :stream |			self lineIndicesDo: [ :start :endWithoutDelimiters :end | | lineStart |				lineStart := (self indexOfAnyOf: CSNonSeparators startingAt: start ifAbsent: [endWithoutDelimiters + 1]) min: endWithoutDelimiters.				[| lineStop lineEnd spacePosition |				lineEnd := 0.				spacePosition := lineStart.				lineStop := (lineStart + aNumber - 1) min: endWithoutDelimiters.				[spacePosition <= lineStop] whileTrue:[					spacePosition := self indexOfAnyOf: CSSeparators startingAt: spacePosition + 1 ifAbsent: [endWithoutDelimiters+1].					spacePosition <= (lineStop+1) ifTrue:[lineEnd := spacePosition].				].				lineEnd = 0					ifTrue: ["no space - split arbitrarily"						lineEnd := lineStart + aNumber - 1 min: endWithoutDelimiters.						stream nextPutAll: (self copyFrom: lineStart to: lineEnd).						lineStart := lineEnd + 1]					ifFalse: ["split before space"						stream nextPutAll: (self copyFrom: lineStart to: lineEnd - 1).						"eliminate conscutive spaces at split"						lineStart := self indexOfAnyOf: CSNonSeparators startingAt: lineEnd + 1 ifAbsent: [endWithoutDelimiters + 1] ].				lineStart <= endWithoutDelimiters ]					whileTrue: [stream cr].				stream nextPutAll: (self copyFrom: endWithoutDelimiters + 1 to: end) ] ]! !"Collections"!!StringTest methodsFor: 'tests - converting' stamp: 'ar 7/15/2010 17:14' prior: 57355437!testWithNoLineLongerThan	"self run: #testWithNoLineLongerThan"	self assert: ('Hello World' withNoLineLongerThan: 5) = ('Hello', String cr, 'World').	self shouldnt:[('Hello', String cr, String cr,'World') withNoLineLongerThan: 5] raise: Error.	self assert: ('Sample text to line break at some point' withNoLineLongerThan:  28)		= ('Sample text to line break at', String cr, 'some point').	self assert: ('Sample text', String cr, 'to line break', String cr, 'at some point' withNoLineLongerThan:  28)		= ('Sample text', String cr, 'to line break', String cr, 'at some point').! !"CollectionsTests"!!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 10:39'!dosToSqueakTime: dt	"DOS years start at 1980, so add 1980."	| year mon mday hour min sec date time |	year := (( dt bitShift: -25 ) bitAnd: 16r7F ).	mon := (( dt bitShift: -21 ) bitAnd: 16r0F ).	mday := (( dt bitShift: -16 ) bitAnd: 16r1F ).	date := Date newDay: mday month: mon year: year+1980.	hour := (( dt bitShift: -11 ) bitAnd: 16r1F ).	min := (( dt bitShift: -5 ) bitAnd: 16r3F ).	sec := (( dt bitShift: 1 ) bitAnd: 16r3E ).	time := ((( hour * 60 ) + min ) * 60 ) + sec.	^date asSeconds + time	! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 10:38' prior: 33416759!lastModTime	"Return my last modification date/time stamp,	converted to Squeak seconds"	^self dosToSqueakTime: lastModFileDateTime! !!ZipArchiveMember methodsFor: 'accessing' stamp: 'jdr 8/11/2010 11:08' prior: 33417394!setLastModFileDateTimeFrom: aSmalltalkTime	lastModFileDateTime := self squeakToDosTime: aSmalltalkTime! !!ZipArchiveMember methodsFor: 'private' stamp: 'jdr 8/11/2010 11:00'!squeakToDosTime: secs	| dosTime dateTime |	dateTime := Time dateAndTimeFromSeconds: secs.	dosTime := (dateTime second seconds) bitShift: -1.	dosTime := dosTime + ((dateTime second minutes) bitShift: 5).	dosTime := dosTime + ((dateTime second hours) bitShift: 11).	dosTime := dosTime + ((dateTime first dayOfMonth) bitShift: 16).	dosTime := dosTime + ((dateTime first monthIndex) bitShift: 21).	dosTime := dosTime + (((dateTime first year) - 1980) bitShift: 25).	^dosTime! !!ZipArchiveMember methodsFor: 'private-writing' stamp: 'ar 8/10/2010 13:15' prior: 33431506!writeDataTo: aStream	"Copy my (possibly inflated or deflated) data to the given stream.	This might do compression, decompression, or straight copying, depending	on the values of compressionMethod and desiredCompressionMethod"	"Note: Do not shortcut this method if uncompressedSize = 0. Even in this case	data may be produced by the compressor (i.e., '' zipped size > 0) and must	be stored in the file or else other utilities will treat the zip file as corrupt."	(compressionMethod = CompressionStored and: [ desiredCompressionMethod = CompressionDeflated ])		ifTrue: [ ^self compressDataTo: aStream ].	(compressionMethod = CompressionDeflated and: [ desiredCompressionMethod = CompressionStored ])		ifTrue: [ ^self uncompressDataTo: aStream ].	self copyDataTo: aStream.! !!ZipArchiveTests methodsFor: 'tests' stamp: 'ar 8/11/2010 20:45'!testDate29Feb2000	"Ensure that dates with leap years don't screw up in the conversion"	| archive mbr theDate |	theDate := Date year: 2000 month: 2 day: 29.	archive := ZipArchive new.	mbr := archive addDeflateString:'foo' as: 'bar'.	mbr setLastModFileDateTimeFrom: theDate asSeconds.	self shouldnt:[mbr lastModTime] raise: Error.	self assert: (Date fromSeconds: mbr lastModTime) = theDate.! !ZipArchiveMember removeSelector: #unixToSqueakTime:!ZipArchiveMember removeSelector: #unixToDosTime:!ZipArchiveMember removeSelector: #dosToUnixTime:!"Compression"!!MCHttpRepository methodsFor: 'required' stamp: 'ar 7/21/2010 19:53' prior: 54759713!writeStreamForFileNamed: aString replace: ignoreBoolean do: aBlock	| stream response statusLine code |	stream := RWBinaryOrTextStream on: String new.	aBlock value: stream.	self displayProgress: 'Uploading ', aString during:[		response := HTTPSocket					httpPut: stream contents					to: (self urlForFileNamed: aString)					user: self user					passwd: self password.	].	"More robust handling of HTTP responses. Instead of enumerating	all possible return codes and http versions, do a quick parse"	(response beginsWith: 'HTTP/') ifTrue:[		"Looks like an HTTP header, not some error message"		statusLine := response copyUpTo: Character cr.		code := [(statusLine findTokens: ' ') second asInteger] on: Error do:[].	].	(code isInteger and:[code between: 200 and: 299]) 		ifFalse:[self error: response].! !"Monticello"!!CachedBlockClosure commentStamp: 'eem 7/22/2010 12:34' prior: 0!I'm a BlockClosure with an added instance variable for storing the once upon a time result of evaluating myself when I was simple BlockClosure. This is triggered by sending #once to a normal BlockClosure. Future sends of once will simply return this value rather than evaluate myself. When sent value, I revert back to a BlockClosure.  Originally by Travis Griggs, from whom we copy this idea with thanks.Instance Variables	cachedValue	<Object>cachedValue	- result of having sent value to myself when i was just a BlockClosure!!Time class methodsFor: 'clock' stamp: 'dtl 8/14/2010 15:25'!primMicrosecondClock	"Answer the number of microseconds since the microsecond clock	was last reset or rolled over. Answer zero if the primitive fails."	<primitive: 'primitiveMicrosecondClock'>	^ 0! !!Time class methodsFor: 'clock' stamp: 'dtl 8/14/2010 14:53'!primUtcWithOffset	"Answer an array with UTC microseconds since the Posix epoch and	the current seconds offset from GMT in the local time zone."	<primitive: 'primitiveUtcWithOffset'>	^ { 0 . 0 }! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:23'!becomeCached	self become: ((CachedBlockClosure new: self size)						outerContext: outerContext						startpc: startpc						numArgs: numArgs						cachedValue: self value						copiedValues: self)! !!BlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:19'!becomeUncached	"The receiver is already uncached."	^self! !!BlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:52'!once	"Answer and remember my value, answering exactly the same object in any further sends	 of once or value until I become uncached.  This allows one to intern values with the idiom		myResourceMethod			^[expression] once.	 The expression will be evaluated once and its result returned for any subsequent evaluations.	 Originally by Travis Griggs, from whom we copy this idea with thanks."	numArgs ~= 0 ifTrue:		[self error: 'once should only be used with niladic blocks'].	self becomeCached.	^self once! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:24'!becomeCached	"The receiver is already cached."	^self! !!CachedBlockClosure methodsFor: 'private' stamp: 'eem 7/22/2010 12:21'!becomeUncached	self become: (BlockClosure 					outerContext: outerContext					startpc: startpc					numArgs: numArgs					copiedValues: self)! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:24'!once	^cachedValue! !!CachedBlockClosure methodsFor: 'initialize-release' stamp: 'eem 7/22/2010 12:16'!outerContext: aContext startpc: aStartpc numArgs: argCount cachedValue: aValue copiedValues: anArrayOrNil	cachedValue := aValue.	super outerContext: aContext startpc: aStartpc numArgs: argCount copiedValues: anArrayOrNil! !!CachedBlockClosure methodsFor: 'evaluating' stamp: 'eem 7/22/2010 12:17'!value	^cachedValue! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingBytecode	"Answer the bytecode of the following bytecode (different to nextByte)."	^self method at: self followingPc! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:45'!followingPc	"Answer the pc of the following bytecode."	^self nextPc: (self method at: pc)! !!InstructionStream methodsFor: 'private' stamp: 'eem 8/13/2010 11:38'!nextPc: currentByte	"Answer the pc of the next bytecode following the current one, given the current bytecode.."	| type |	type := currentByte // 16.	^type = 8 "extensions"				ifTrue: [pc + (#(2 2 2 2 3 2 2 1 1 1 2 1 3 3 3 4) at: currentByte \\ 16 + 1)]				ifFalse: [type = 10 "long jumps"							ifTrue: [pc + 2]							ifFalse: [pc + 1]]! !!InstructionStream methodsFor: 'scanning' stamp: 'eem 8/13/2010 11:43' prior: 51439508!scanFor: scanBlock	"Answer the index of the first bytecode for which scanBlock	 answers true when supplied with that bytecode."	| method end byte |	method := self method.	end := method endPC.	[pc <= end] whileTrue: 		[(scanBlock value: (byte := method at: pc)) ifTrue:			[^true].		 pc := self nextPc: byte].	^false! !!Integer methodsFor: 'printing' stamp: 'eem 5/21/2010 11:06' prior: 21998699!hex	"Print the receiver as hex, prefixed with 16r.  DO NOT CHANGE THIS!!  The Cog VMMaker depends on this.	 Consider using any of		printStringHex		printStringBase: 16		printStringBase: 16 length: 8 padded: true		storeStringHex		storeStringBase: 16		storeStringBase: 16 length: 11 padded: true"	^self storeStringBase: 16! !!CompiledMethod methodsFor: 'decompiling' stamp: 'eem 8/12/2010 13:52' prior: 19056689!decompileWithTemps	"Return the decompiled parse tree that represents self, but get the temp names	 by compiling the sourcecode..."	|  class selector |	class := self methodClass ifNil: [Object].	selector := self selector ifNil: [self defaultSelector].	(self fileIndex > 0 and: [(SourceFiles at: self fileIndex) isNil]) ifTrue: [			"Emergency or no source file -- decompile without temp names "			^self decompile.	].	^((self decompilerClass new withTempNames: self methodNode schematicTempNamesString)						decompile: selector						in: class						method: self)! !"Kernel"!!VariableScopeFinder commentStamp: 'eem 8/14/2010 19:45' prior: 0!A VariableScopeFinder is used to find the minimum enclosing scope of a variable in a method.  This is used when auto-declaring temporaries to find the smallest enclosing block in which to declare the temp.Instance Variables	theVariable:		<VariableNode>theVariable	- the varable whose scope is to be determined!!BlockNode commentStamp: '<historical>' prior: 33669985!I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!MessageNode commentStamp: '<historical>' prior: 59343427!I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.!!MethodNode commentStamp: 'eem 8/15/2010 10:49' prior: 59353244!I am the root of the parse tree..Instance Variables	arguments:			<SequenceableCollection>	block:				<BlockNode>	encoder:			<BytecodeEncoder>	localsPool:			<IdentitySet>	locationCounter:	<Integer>	precedence:		<Integer>	primitive:			<Integer>	properties:			<AdditionalMethodState|nil>	selectorOrFalse:	<Object>	sourceText:		<String|Text>	temporaries:		<SequenceableCollection>arguments	- the collection of parsed or decompiled method argumentsblock	- the BlockNode holding the method's statementsencoder	- the object that comprises the copiler's scope table, literal pool and back-end bytecode generatorlocalsPool	- a set used to determine the set of copied values for each block in the methodlocationCounter	- an integer used to mark block scopes for the purposes of the closure transformation.  See BlockNode>>#analyseArguments:temporaries:rootNode:precedence	- the precedence of the method's selector (see Symbol>>precedence)primitive	- if non-zero this is the integer code of the method's primitiveproperties	- the object used to accumulate method properties (a.k.a. pragmas)selectorOrFalse	- the method's selector or false if this is a doitsourceText	- the source test from which the method was compiledtemporaries	- the collection of parsed or decompiled method temporaries!!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 9/5/2009 20:08' prior: 52074955!visitMessageNode: aMessageNode	aMessageNode receiver accept: self.	"receiver notNil ifTrue: ''receiver is nil for cascades''		[receiver accept: self]."	aMessageNode selector accept: self.	aMessageNode argumentsInEvaluationOrder do:		[:argument| argument accept: self]! !!ParseNodeVisitor methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode! !!VariableScopeFinder methodsFor: 'private' stamp: 'eem 8/12/2010 16:50'!enclosingNodeFor: enumerator of: rootNode	"Answer the minimum enclosing root node for aVariabe or nil if none.	 If the variable is accessed in more than one subnode then the rootNode is the	 enclosing node, otherwise it is which ever single subnode node that includes it, if any.	 enumerator applies its argument to all relevant subnodes of rootNode."	| enclosingNodeOrNil |	enclosingNodeOrNil := nil.	enumerator value:		[:subnode|		(subnode accept: self) ifNotNil:			[:enclosingNode|			enclosingNodeOrNil := enclosingNodeOrNil										ifNil: [enclosingNode]										ifNotNil: [rootNode]]].	^enclosingNodeOrNil! !!VariableScopeFinder methodsFor: 'initialize-release' stamp: 'eem 8/12/2010 16:18'!ofVariable: aVariableNode	theVariable := aVariableNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:51'!visitAssignmentNode: anAssignmentNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then anAssignmentNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock								value: anAssignmentNode value;								value: anAssignmentNode variable]		of: anAssignmentNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBlockNode: aBlockNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one statement then aBlockNode is the	 enclosing node, otherwise it is which ever single block node that includes it, if any."	^(self enclosingNodeFor: [:aBlock| aBlockNode statements do: aBlock] of: aBlockNode) ifNotNil:		[:aNode|		aNode isBlockNode ifTrue: [aNode] ifFalse: [aBlockNode]]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:52'!visitBraceNode: aBraceNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aBraceNode	 is the enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock| aBraceNode elements do: aBlock]		of: aBraceNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/16/2010 18:02'!visitCascadeNode: aCascadeNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aCascadeNode receiver.							aCascadeNode messages do:								[:msg| msg argumentsInEvaluationOrder do: aBlock]]		of: aCascadeNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitCommentNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitFieldNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 16:55'!visitFutureNode: aFutureNode	^aFutureNode receiver accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitInstanceVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitLiteralNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:03'!visitLiteralVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:07'!visitMessageNode: aMessageNode	"Answer the minimum enclosing node for aVariabe or nil if none.	 If the variable is accessed in more than one subexpression then aMessageNode is the	 enclosing node, otherwise it is which ever single node that includes it, if any."	^self		enclosingNodeFor: [:aBlock|							aBlock value: aMessageNode receiver.							aMessageNode argumentsInEvaluationOrder do: aBlock]		of: aMessageNode! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:00'!visitMethodNode: aMethodNode	^aMethodNode block accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitNewArrayNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitRemoteTempVectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 17:01'!visitReturnNode: aReturnNode	^aReturnNode expr accept: self! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitSelectorNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 18:43'!visitTempVariableNode: aNode	^nil! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:50'!visitUndeclaredVariableNode: aVariableNode	^theVariable name = aVariableNode name ifTrue: [theVariable]! !!VariableScopeFinder methodsFor: 'visiting' stamp: 'eem 8/12/2010 19:06'!visitVariableNode: aVariableNode	^nil! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51552175!emitCodeForEffect: stack encoder: encoder	^self! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:25' prior: 51549757!emitCodeForLoad: stack encoder: encoder	"Default is to do nothing.	 Subclasses may need to override."! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51552568!sizeCodeForEffect: encoder	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:24' prior: 51550149!sizeCodeForLoad: encoder	"Default is to do nothing.	 Subclasses may need to override."	^0! !!LeafNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:10' prior: 51553184!sizeCodeForValue: encoder	self subclassResponsibility! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:19' prior: 51562326!emitCodeForValue: stack encoder: encoder	stack push: 1.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 encoder genPushSpecialLiteral: specialLiteral])		ifFalse:			[encoder genPushLiteral: index]! !!LiteralNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:03' prior: 51562996!sizeCodeForValue: encoder	self reserve: encoder.	(encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizePushSpecialLiteral: specialLiteral])		ifFalse:			[^encoder sizePushLiteral: index]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52458608!emitCode: stack args: nArgs encoder: encoder	self emitCode: stack		args: nArgs		encoder: encoder		super: false! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:47' prior: 52458959!emitCode: stack args: nArgs encoder: encoder super: supered	stack pop: nArgs.	^supered		ifTrue:			[encoder genSendSuper: index numArgs: nArgs]		ifFalse:			[encoder				genSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52461103!emitCodeForEffect: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52462600!emitCodeForValue: stack encoder: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:15' prior: 52460344!sizeCode: encoder args: nArgs super: supered	self reserve: encoder.	^supered		ifTrue:			[code < Send "i.e. its a special selector" ifTrue:				[code := self code: (index := encoder sharableLitIndex: key) type: 5].			 encoder sizeSendSuper: index numArgs: nArgs]		ifFalse:			[self flag: #yuck. "special selector sends cause this problem"			 encoder				sizeSend: (code < Send ifTrue: [code negated] ifFalse: [index])				numArgs: nArgs]! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52462457!sizeCodeForEffect: encoder	self shouldNotImplement! !!SelectorNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52458466!sizeCodeForValue: encoder	self shouldNotImplement! !!UndeclaredVariableNode methodsFor: 'visiting' stamp: 'eem 8/13/2010 16:51'!accept: aVisitor	^aVisitor visitUndeclaredVariableNode: self! !!UndeclaredVariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^true! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	^tag! !!UndeclaredVariableNode methodsFor: 'accessing' stamp: 'eem 8/17/2010 16:30'!tag: anObject	"Tag can be whatever one wants it to be; used by Parser to tag	  undeclared temps with the user's desired declaration level."	tag := anObject! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53104834!emitCodeForLoad: stack encoder: encoder	"Do nothing"! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41' prior: 53109491!emitCodeForReturn: stack encoder: encoder	encoder		if: code		isSpecialLiteralForReturn:			[:specialLiteral|			"short returns"			 encoder genReturnSpecialLiteral: specialLiteral.			 stack push: 1 "doesnt seem right".			 ^self].	(self code = LdSelf or: [self code = LdSuper]) ifTrue: 		["short returns"		 encoder genReturnReceiver.		 stack push: 1 "doesnt seem right".		 ^self].	super emitCodeForReturn: stack encoder: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 53112316!emitCodeForStore: stack encoder: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:41' prior: 53106995!emitCodeForStorePop: stack encoder: encoder	self type ~= 1 ifTrue:		[self halt].	encoder genStorePopInstVar: index.	stack pop: 1! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07' prior: 53113225!emitCodeForValue: stack encoder: encoder	stack push: 1.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder genPushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder genPushReceiver].	code = LdThisContext ifTrue:		[^encoder genPushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder genPushInstVar: index! !!VariableNode methodsFor: 'testing' stamp: 'eem 8/13/2010 15:34'!isUndeclared	^false! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:58' prior: 53112637!sizeCodeForReturn: encoder	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral|			 ^encoder sizeReturnSpecialLiteral: specialLiteral].	(self code = LdSelf or: [self code = LdSuper]) ifTrue:		[^encoder sizeReturnReceiver].	^super sizeCodeForReturn: encoder! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09' prior: 53105612!sizeCodeForStore: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:09' prior: 53112172!sizeCodeForStorePop: encoder	self shouldNotImplement! !!VariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:54' prior: 53107813!sizeCodeForValue: encoder	self reserve: encoder.	encoder		if: code		isSpecialLiteralForPush:			[:specialLiteral| "i.e. the pseudo-variables nil true & false"			 ^encoder sizePushSpecialLiteral: specialLiteral].	(code = LdSelf or: [code = LdSuper]) ifTrue:		[^encoder sizePushReceiver].	code = LdThisContext ifTrue:		[^encoder sizePushThisContext].	self flag: 'probably superfluous'.	self halt.	^encoder sizePushInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51430402!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:05' prior: 51430573!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVar: index.	stack pop: 1! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51430765!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57' prior: 51429943!sizeCodeForStore: encoder	^encoder sizeStoreInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07' prior: 51430238!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVar: index! !!InstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53' prior: 51430952!sizeCodeForValue: encoder	^encoder sizePushInstVar: index! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51110966!emitCodeForEffect: stack encoder: encoder! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51108318!emitCodeForLoad: stack encoder: encoder	rcvrNode emitCodeForValue: stack encoder: encoder.	fieldDef accessKey ifNotNil:[		super emitCodeForValue: stack encoder: encoder.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51111688!emitCodeForStore: stack encoder: encoder	fieldDef accessKey ifNil:[		writeNode emitCode: stack args: 1 encoder: encoder super: false.	] ifNotNil:[		writeNode emitCode: stack args: 2 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:18' prior: 51111996!emitCodeForStorePop: stack encoder: encoder	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51112488!emitCodeForValue: stack encoder: encoder	fieldDef accessKey ifNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 0 encoder: encoder super: false.	] ifNotNil:[		rcvrNode emitCodeForValue: stack encoder: encoder.		super emitCodeForValue: stack encoder: encoder.		readNode emitCode: stack args: 1 encoder: encoder super: false.	].! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51111095!sizeCodeForEffect: encoder	^0! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51109339!sizeCodeForStore: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		writeNode ifNil:[writeNode := encoder encodeSelector: fieldDef toSet].		^(rcvrNode sizeCodeForValue: encoder) + 			(writeNode sizeCode: encoder args: 1 super: false)		].	writeNode ifNil:[writeNode := encoder encodeSelector: #set:to:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) +			(writeNode sizeCode: encoder args: 2 super: false)! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:17' prior: 51111519!sizeCodeForStorePop: encoder	^(self sizeCodeForStore: encoder) + encoder sizePop! !!FieldNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51113121!sizeCodeForValue: encoder	rcvrNode ifNil:[self encodeReceiverOn: encoder].	fieldDef accessKey ifNil:[		readNode ifNil:[readNode := encoder encodeSelector: fieldDef toGet].		^(rcvrNode sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 0 super: false)	].	readNode ifNil:[readNode := encoder encodeSelector: #get:].	^(rcvrNode sizeCodeForValue: encoder) + 		(super sizeCodeForValue: encoder) + 			(readNode sizeCode: encoder args: 1 super: false)! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27' prior: 33547565!emitCodeForEffect: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStorePop: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 6/4/2008 11:27' prior: 33549094!emitCodeForValue: stack encoder: encoder	variable emitCodeForLoad: stack encoder: encoder.	value emitCodeForValue: stack encoder: encoder.	pc := encoder methodStreamPosition + 1. "debug pc is first byte of the store, i.e. the next byte".	variable emitCodeForStore: stack encoder: encoder! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16' prior: 33548242!sizeCodeForEffect: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStorePop: encoder)! !!AssignmentNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 15:16' prior: 33549711!sizeCodeForValue: encoder	^(variable sizeCodeForLoad: encoder)	+ (value sizeCodeForValue: encoder)	+ (variable sizeCodeForStore: encoder)! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/12/2010 13:46' prior: 33908884!decompileBlock: aBlock 	"Decompile aBlock, returning the result as a BlockNode.  	Show temp names from source if available."	"Decompiler new decompileBlock: [3 + 4]"	| startpc end homeClass blockNode methodNode home |	(home := aBlock home) ifNil: [^ nil].	method := home method.	(homeClass := home methodClass) == #unknown ifTrue: [^ nil].	aBlock isClosure ifTrue:		[(methodNode := method decompileWithTemps)			ifNil: [^nil]			ifNotNil: [methodNode nodesDo: [:node| node pc = aBlock startpc ifTrue: [^node]]].		 ^self error: 'cannot find block node matching aBlock'].	constructor := self constructorForMethod: aBlock method.		self withTempNames: method methodNode tempNames.	self initSymbols: homeClass.	startpc := aBlock startpc.	end := aBlock endPC.	stack := OrderedCollection new: method frameSize.	caseExits := OrderedCollection new.	statements := OrderedCollection new: 20.	super method: method pc: startpc - 5.	blockNode := self blockTo: end.	stack isEmpty ifFalse: [self error: 'stack not empty'].	^blockNode statements first! !!Decompiler methodsFor: 'control' stamp: 'eem 8/12/2010 13:25' prior: 50903238!doClosureCopyCopiedValues: blockCopiedValues numArgs: numArgs blockSize: blockSize	| startpc savedTemps savedTempVarCount savedNumLocalTemps	  jump blockArgs blockTemps blockTempsOffset block |	savedTemps := tempVars.	savedTempVarCount := tempVarCount.	savedNumLocalTemps := numLocalTemps.	jump := blockSize + (startpc := pc).	numLocalTemps := BlockLocalTempCounter tempCountForBlockAt: pc - 4 in: method.	blockTempsOffset := numArgs + blockCopiedValues size.	(blockStartsToTempVars notNil "implies we were intialized with temp names."	 and: [blockStartsToTempVars includesKey: pc])		ifTrue:			[tempVars := blockStartsToTempVars at: pc]		ifFalse:			[blockArgs := (1 to: numArgs) collect:							[:i| (constructor									codeTemp: i - 1									named: 't', (tempVarCount + i) printString)								  beBlockArg].			blockTemps := (1 to: numLocalTemps) collect:							[:i| constructor									codeTemp: i + blockTempsOffset - 1									named: 't', (tempVarCount + i + numArgs) printString].			tempVars := blockArgs, blockCopiedValues, blockTemps].	numLocalTemps timesRepeat:		[self interpretNextInstructionFor: self.		 stack removeLast].	tempVarCount := tempVarCount + numArgs + numLocalTemps.	block := self blockTo: jump.	stack addLast: ((constructor						codeArguments: (tempVars copyFrom: 1 to: numArgs)						temps: (tempVars copyFrom: blockTempsOffset + 1 to: blockTempsOffset + numLocalTemps)						block: block)							pc: startpc;							yourself).	tempVars := savedTemps.	tempVarCount := savedTempVarCount.	numLocalTemps := savedNumLocalTemps! !!Decompiler methodsFor: 'instruction decoding' stamp: 'eem 8/12/2010 13:51' prior: 50907292!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs blockSize: blockSize	| copiedValues |	self sawClosureBytecode.	copiedValues := ((1 to: numCopied) collect: [:ign| stack removeLast]) reversed.	self doClosureCopyCopiedValues: copiedValues numArgs: numArgs blockSize: blockSize! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:44' prior: 51563596!emitCodeForLoad: stack encoder: encoder	writeNode ifNotNil:		[encoder genPushLiteral: index.		 stack push: 1]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:43' prior: 51567069!emitCodeForStore: stack encoder: encoder	writeNode ifNil: [^encoder genStoreLiteralVar: index].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop	or use e.g. valueForStore:"	self flag: #bogus.	writeNode		emitCode: stack		args: 1		encoder: encoder		super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:09' prior: 51567688!emitCodeForStorePop: stack encoder: encoder	writeNode ifNil:		[stack pop: 1.		 ^encoder genStorePopLiteralVar: index].	self emitCodeForStore: stack encoder: encoder.	encoder genPop.	stack pop: 1.! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:17' prior: 51567987!emitCodeForValue: stack encoder: encoder	^readNode		ifNil: [stack push: 1.			encoder genPushLiteralVar: index]		ifNotNil: [readNode emitCodeForValue: stack encoder: encoder]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:26' prior: 51564699!sizeCodeForLoad: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [encoder sizePushLiteral: index]		ifFalse: [0]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 8/17/2010 22:27' prior: 51564887!sizeCodeForStore: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialWriteBinding]) ifFalse:		[^encoder sizeStoreLiteralVar: index].	code < 0 ifTrue:		[self flag: #dubious.		 self code: (self code: self index type: LdLitType)].	"THIS IS WRONG!!!! THE VALUE IS LOST FROM THE STACK!!!!	 The various value: methods on Association ReadOnlyVariableBinding	 etc _do not_ return the value assigned; they return the receiver."	"Should generate something more like		push expr		push lit		push temp (index of expr)		send value:		pop"	self flag: #bogus.	writeNode := encoder encodeSelector: #value:.	^writeNode sizeCode: encoder args: 1 super: false! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2010 08:55' prior: 33817317!sizeCodeForStorePop: encoder	self reserve: encoder.	^(key isVariableBinding and: [key isSpecialWriteBinding])		ifTrue: [(self sizeCodeForStore: encoder) + encoder sizePop]		ifFalse: [encoder sizeStorePopLiteralVar: index]! !!LiteralVariableNode methodsFor: 'code generation' stamp: 'nice 7/23/2010 23:58' prior: 51568428!sizeCodeForValue: encoder	self reserve: encoder.	(key isVariableBinding and: [key isSpecialReadBinding]) 		ifFalse:			[^encoder sizePushLiteralVar: index].	readNode := MessageNode new 		receiver: (encoder encodeLiteral: key)		selector: (encoder encodeSelector: #value)		arguments: #()		precedence: #value precedence.	^readNode sizeCodeForValue: encoder! !!Parser methodsFor: 'error correction' stamp: 'eem 7/6/2010 15:07' prior: 52094356!declareClassVar: name	| sym class |	sym := name asSymbol.	class := encoder classEncoding.	class := class theNonMetaClass.		"not the metaclass"	class addClassVarName: name.	Smalltalk logChange: class definition.	^ encoder global: (class classPool associationAt: sym)			name: sym! !!Parser methodsFor: 'error correction' stamp: 'eem 5/6/2010 21:14' prior: 52081547!declareInstVar: name	"Declare an instance variable.  Since the variable will get added after any existing	 inst vars its index is the instSize."	encoder classEncoding addInstVarName: name.	Smalltalk logChange: encoder classEncoding definition.	^InstanceVariableNode new name: name index: encoder classEncoding instSize		! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:35'!declareTemp: name at: levelTag	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^(encoder bindUndeclaredTemp: name)		tag: levelTag;		yourself! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 19:34' prior: 52098032!declareTempAndPaste: name	"Defer declaring the temp until the parse has completed.  This allows	 the parser to declare the temp in the minimum enclosing block instead	 of always at method level.  See Parser>>declareUndeclaredTemps:"	^encoder bindUndeclaredTemp: name! !!Parser methodsFor: 'error correction' stamp: 'eem 8/17/2010 16:37'!declareUndeclaredTemps: methodNode	"Declare any undeclared temps, declaring them at the smallest enclosing scope."	| undeclared userSelection blocksToVars |	(undeclared := encoder undeclaredTemps) isEmpty ifTrue:		[^self].	userSelection := requestor selectionInterval.	blocksToVars := IdentityDictionary new.	undeclared do:		[:var|		(blocksToVars			at: (var tag == #method					ifTrue: [methodNode block]					ifFalse: [methodNode accept: (VariableScopeFinder new ofVariable: var)])			ifAbsentPut: [SortedCollection new]) add: var name].	(blocksToVars removeKey: methodNode block ifAbsent: []) ifNotNil:		[:rootVars|		rootVars do: [:varName| self pasteTempAtMethodLevel: varName]].	(blocksToVars keys sorted: [:a :b| a tempsMark < b tempsMark]) do:		[:block| | decl |		decl := (blocksToVars at: block) reduce: [:a :b| a, ' ', b].		block temporaries isEmpty			ifTrue:				[self substituteWord: ' | ', decl, ' |'					wordInterval: (block tempsMark + 1 to: block tempsMark)					offset: requestorOffset]			ifFalse:				[self substituteWord: decl, ' '					wordInterval: (block tempsMark to: block tempsMark - 1)					offset: requestorOffset]].	requestor selectInvisiblyFrom: userSelection first to: userSelection last + requestorOffset.	ReparseAfterSourceEditing signal! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 16:48' prior: 58135859!method: doit context: ctxt 	" pattern [ | temporaries ] block => MethodNode."	| sap blk prim temps messageComment methodNode |	sap := self pattern: doit inContext: ctxt.	"sap={selector, arguments, precedence}"	self properties selector: (sap at: 1).	encoder selector: (sap at: 1).	(sap at: 2) do: [:argNode | argNode beMethodArg].	doit ifFalse: [self pragmaSequence].	temps := self temporaries.	messageComment := currentComment.	currentComment := nil.	doit ifFalse: [self pragmaSequence].	prim := self pragmaPrimitives.	self statements: #() innerBlock: doit.	blk := parseNode.	doit ifTrue: [blk returnLast]		ifFalse: [blk returnSelfIfNoOther: encoder].	hereType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode := self newMethodNode comment: messageComment.	methodNode		selector: (sap at: 1)		arguments: (sap at: 2)		precedence: (sap at: 3)		temporaries: temps		block: blk		encoder: encoder		primitive: prim		properties: properties.	self interactive ifTrue:		[self declareUndeclaredTemps: methodNode.		 self removeUnusedTemps].	^methodNode! !!Parser methodsFor: 'public access' stamp: 'eem 8/16/2010 18:08' prior: 58137920!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of	 a parse tree. Parsing is done with respect to the argument, class, to find	 instance, class, and pool variables; and with respect to the argument,	 ctxt, to find temporary variables. Errors in parsing are reported to the	 argument, req, if not nil; otherwise aBlock is evaluated. The argument	 noPattern is a Boolean that is true if the the sourceStream does not	 contain a method header (i.e., for DoIts)."	| methNode repeatNeeded myStream s p subSelection |	category := aCategory.	myStream := sourceStream.	[repeatNeeded := false.	 p := myStream position.	 s := myStream upToEnd.	 myStream position: p.	 subSelection := req notNil and: [req selectionInterval = (p + 1 to: p + s size)].	 self encoder init: class context: ctxt notifying: self.	 self init: myStream notifying: req failBlock: [^ aBlock value].	 doitFlag := noPattern.	 failBlock:= aBlock.	 [methNode := self					method: noPattern					context: ctxt] 		on: ReparseAfterSourceEditing 		do:	[ :ex |			repeatNeeded := true.			myStream := subSelection							ifTrue:								[ReadStream									on: requestor text string									from: requestor selectionInterval first									to: requestor selectionInterval last]							ifFalse:								[ReadStream on: requestor text string]].	 repeatNeeded] whileTrue:		[encoder := self encoder class new].	methNode sourceText: s.	^methNode! !!Parser methodsFor: 'error correction' stamp: 'eem 8/13/2010 19:34'!pasteTempAtMethodLevel: name	| insertion delta theTextString characterBeforeMark |	theTextString := requestor text string.	characterBeforeMark := theTextString at: tempsMark-1 ifAbsent: [$ ].	(theTextString at: tempsMark) = $| ifTrue: [  		"Paste it before the second vertical bar"		insertion := name, ' '.		characterBeforeMark isSeparator ifFalse: [insertion := ' ', insertion].		delta := 0.	] ifFalse: [		"No bars - insert some with CR, tab"		insertion := '| ' , name , ' |',String cr.		delta := 2.	"the bar and CR"		characterBeforeMark = Character tab ifTrue: [			insertion := insertion , String tab.			delta := delta + 1.	"the tab"		].	].	tempsMark := tempsMark +		(self substituteWord: insertion			wordInterval: (tempsMark to: tempsMark-1)			offset: 0) - delta! !!Parser methodsFor: 'error correction' stamp: 'eem 8/15/2010 08:56' prior: 54012081!removeUnusedTemps	"Scan for unused temp names, and prompt the user about the prospect of removing each one found"	| str madeChanges | 	madeChanges := false.	str := requestor text asString.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp | | start end |		(UnusedVariable name: temp) ifTrue:			[(encoder lookupVariable: temp ifAbsent: []) isUndefTemp				ifTrue:					[end := tempsMark.					["Beginning at right temp marker..."					start := end - temp size + 1.					end < temp size or: [temp = (str copyFrom: start to: end)							and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]						whileFalse:							["Search left for the unused temp"							end := requestor nextTokenFrom: end direction: -1].					end < temp size ifFalse:						[(str at: start-1) = $  ifTrue: [start := start-1].						requestor correctFrom: start to: end with: ''.						str := str copyReplaceFrom: start to: end with: ''. 						madeChanges := true.						tempsMark := tempsMark - (end-start+1)]]				ifFalse:					[self inform:'You''ll first have to remove the\statement where it''s stored into' withCRs]]].	madeChanges ifTrue: [ReparseAfterSourceEditing signal]! !!Parser methodsFor: 'error correction' stamp: 'eem 8/14/2010 10:32' prior: 52101384!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presumed interactive) receiver.	 Update requestorOffset based on the delta size and answer the updated offset."	requestor correctFrom: spot first + o to: spot last + o with: correctWord.	requestorOffset := requestorOffset + correctWord size - spot size.	^o + correctWord size - spot size! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35' prior: 52088916!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 10:35' prior: 52090927!temporariesIn: methodSelector	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue:			[tempsMark := self interactive								ifTrue: [requestor selectionInterval first]								ifFalse: [1].			^ #()].		tempsMark := hereMark	"formerly --> prevMark + prevToken".		tempsMark > 0 ifTrue:			[theActualText := source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark := tempsMark + 1]].			^ #()].	vars := OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance in: methodSelector)].	(self match: #verticalBar) ifTrue: 		[tempsMark := prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'eem 8/13/2010 15:57' prior: 52077730!temporaryBlockVariablesFor: aBlockNode	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse:		"There are't any temporary variables."		[aBlockNode tempsMark: prevMark + requestorOffset.		 ^#()].	variables := OrderedCollection new.	[hereType == #word] whileTrue:		[variables addLast: (encoder bindBlockTemp: self advance within: aBlockNode)].	(self match: #verticalBar) ifFalse:		[^self expected: 'Vertical bar'].	aBlockNode tempsMark: prevMark + requestorOffset.	^variables! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51621449!emitCodeForStore: stack encoder: encoder	encoder genStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 6/19/2008 09:36' prior: 51621636!emitCodeForStorePop: stack encoder: encoder	encoder genStorePopInstVarLong: index.	stack pop: 1! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:08' prior: 51621844!emitCodeForValue: stack encoder: encoder	stack push: 1.	^encoder genPushInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:57' prior: 51621095!sizeCodeForStore: encoder	^encoder sizeStoreInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 18:07' prior: 51621269!sizeCodeForStorePop: encoder	^encoder sizeStorePopInstVarLong: index! !!MaybeContextInstanceVariableNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:53' prior: 51622047!sizeCodeForValue: encoder	^encoder sizePushInstVarLong: index! !!Compiler methodsFor: 'public access' stamp: 'ar 9/27/2005 19:20' prior: 19116591!compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."	self from: textOrStream		class: aClass		classified: aCategory 		context: nil		notifying: aRequestor.	^self		translate: sourceStream		noPattern: false		ifFail: failBlock! !!Compiler methodsFor: 'public access' stamp: 'eem 7/2/2010 09:54' prior: 53973015!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into	 a method. If aContext is not nil, the text can refer to temporaries in that	 context (the Debugger uses this). If aRequestor is not nil, then it will receive	 a notify:at: message before the attempt to evaluate is aborted. Finally, the 	 compiled method is invoked from here via withArgs:executeMethod:, hence	 the system no longer creates Doit method litter on errors."	| methodNode method value toLog itsSelection itsSelectionString |	class := (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: true ifFail: [^failBlock value].	method := self interactive				ifTrue: [methodNode generateWithTempNames]				ifFalse: [methodNode generate].	value := receiver				withArgs: (context ifNil: [#()] ifNotNil: [{context}])				executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  			and:[(itsSelection := requestor selection) notNil			and:[(itsSelectionString := itsSelection asString) isEmptyOrNil not]])				ifTrue:[itsSelectionString]				ifFalse:[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext].	^ value! !!Compiler methodsFor: 'public access' stamp: 'eem 8/14/2010 20:23' prior: 50779925!from: textOrStream class: aClass classified: aCategory context: aContext notifying: req	sourceStream := (textOrStream isKindOf: PositionableStream)						ifTrue: [textOrStream]						ifFalse: [ReadStream on: textOrStream asString].	class := aClass.	context := aContext.	requestor := req.	category := aCategory! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58' prior: 51916787!emitCodeForValue: stack encoder: encoder	encoder genPushNewArray: numElements.	stack push: 1! !!NewArrayNode methodsFor: 'code generation' stamp: 'eem 5/25/2008 14:58' prior: 51917069!sizeCodeForValue: encoder	^encoder sizePushNewArray: numElements! !!Scanner methodsFor: 'expression types' stamp: 'eem 7/2/2010 10:07' prior: 53392053!scanAllTokenPositionsInto: aBlock	"Evaluate aBlock with the start and end positions of all separate non-white-space tokens, including comments."	| lastMark |	lastMark := 1.	[currentComment notNil ifTrue:		[currentComment do:			[:cmnt| | idx |			 idx := source originalContents indexOfSubCollection: cmnt startingAt: lastMark.			 (idx > 0 and: [idx < mark]) ifTrue:				[aBlock value: idx - 1 value: (lastMark := idx + cmnt size)]].		 currentComment := nil].	mark notNil ifTrue:		[(token == #- 		  and: [(self typeTableAt: hereChar) = #xDigit]) ifTrue:			[| savedMark |			 savedMark := mark.			 self scanToken.			 token := token negated.			 mark := savedMark].		"Compensate for the fact that the parser uses two character lookahead.  Normally we must		  remove the extra two characters.  But this mustn't happen for the last token at the end of stream."		 aBlock			value: mark			value: (source atEnd					ifTrue: [tokenType := #doIt. "to cause an immediate ^self" source position]					ifFalse: [source position - 2])].	 (tokenType = #rightParenthesis	  or: [tokenType == #doIt]) ifTrue:		[^self].	tokenType = #leftParenthesis		ifTrue: 			[self scanToken; scanAllTokenPositionsInto: aBlock]		ifFalse: 			[(tokenType = #word or: [tokenType = #keyword or: [tokenType = #colon]])				ifTrue: 					[self scanLitWord.					 token = #true ifTrue: [token := true].					 token = #false ifTrue: [token := false].					 token = #nil ifTrue: [token := nil]]				ifFalse:					[(token == #- 					  and: [(self typeTableAt: hereChar) = #xDigit])						ifTrue: 							[self scanToken.							 token := token negated]]].		self scanToken.	true] whileTrue! !!Scanner methodsFor: 'multi-character scans' stamp: 'nice 7/25/2010 12:23' prior: 53393807!xIllegal	"An illegal character was encountered"	self notify: 'Illegal character (char code ' , hereChar charCode , ' ' , hereChar charCode storeStringHex , ')' at: mark! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:41' prior: 50569842!emitCodeForValue: stack encoder: encoder	receiver emitCodeForValue: stack encoder: encoder.	1 to: messages size - 1 do: 		[:i | 		encoder genDup.		stack push: 1.		(messages at: i) emitCodeForValue: stack encoder: encoder.		encoder genPop.		stack pop: 1].	messages last emitCodeForValue: stack encoder: encoder! !!CascadeNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:39' prior: 50570250!sizeCodeForValue: encoder	| size |	size := (receiver sizeCodeForValue: encoder)			 + (messages size - 1 * (encoder sizeDup + encoder sizePop)).	messages do: [:aMessage | size := size + (aMessage sizeCodeForValue: encoder)].	^size! !!BlockNode methodsFor: 'code generation' stamp: 'eem 6/2/2008 13:29' prior: 50469704!emitCodeExceptLast: stack encoder: encoder	| position nextToLast |	position := stack position.	nextToLast := statements size - 1.	1 to: nextToLast do:		[:i | | statement |		statement := statements at: i.		statement emitCodeForEffect: stack encoder: encoder.		self assert: stack position = position].! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:28' prior: 50441069!emitCodeForEvaluatedEffect: stack encoder: encoder	| position |	position := stack position.	self returns		ifTrue: 			[self emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1]		ifFalse: 			[self emitCodeExceptLast: stack encoder: encoder.			statements last emitCodeForEffect: stack encoder: encoder].	self assert: stack position = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/21/2008 11:36' prior: 50447264!emitCodeForEvaluatedValue: stack encoder: encoder	| position |	position := stack position.	self emitCodeExceptLast: stack encoder: encoder.	statements last emitCodeForBlockValue: stack encoder: encoder.	self assert: stack position - 1 = position! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55' prior: 50454333!emitCodeForValue: stack encoder: encoder	self generateAsClosure ifTrue:		[^self emitCodeForClosureValue: stack encoder: encoder].	encoder genPushThisContext.	stack push: 1.	nArgsNode emitCodeForValue: stack encoder: encoder.	remoteCopyNode		emitCode: stack		args: 1		encoder: encoder.	"Force a two byte jump."	encoder genJumpLong: size.	stack push: arguments size.	arguments reverseDo: [:arg | arg emitCodeForStorePop: stack encoder: encoder].	self emitCodeForEvaluatedValue: stack encoder: encoder.	self returns ifFalse:		[encoder genReturnTopToCaller.		pc := encoder methodStreamPosition].	stack pop: 1! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/29/2008 15:21' prior: 50455290!sizeCodeExceptLast: encoder	| codeSize |	codeSize := 0.	1 to: statements size - 1 do: 		[:i | | statement |		 statement := statements at: i.		 codeSize := codeSize + (statement sizeCodeForEffect: encoder)].	^codeSize! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13' prior: 50447760!sizeCodeForEvaluatedEffect: encoder	^self returns		ifTrue: [self sizeCodeForEvaluatedValue: encoder]		ifFalse: [(self sizeCodeExceptLast: encoder)				+ (statements last sizeCodeForEffect: encoder)]! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 50467762!sizeCodeForEvaluatedValue: encoder	^(self sizeCodeExceptLast: encoder)		+ (statements last sizeCodeForBlockValue: encoder)! !!BlockNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:55' prior: 50462928!sizeCodeForValue: encoder	self generateAsClosure ifTrue:		[^self sizeCodeForClosureValue: encoder].	nArgsNode := encoder encodeLiteral: arguments size.	remoteCopyNode := encoder encodeSelector: #blockCopy:.	size := self sizeCodeForEvaluatedValue: encoder.	self returns ifFalse:		[size := size + encoder sizeReturnTopToCaller]. "endBlock"	arguments := arguments collect:  "Chance to prepare debugger remote temps"						[:arg | arg asStorableNode: encoder].	arguments do: [:arg | size := size + (arg sizeCodeForStorePop: encoder)].	^encoder sizePushThisContext	 + (nArgsNode sizeCodeForValue: encoder) 	 + (remoteCopyNode sizeCode: encoder args: 1 super: false)	 + (encoder sizeJumpLong: size)	 + size! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark	^tempsMark! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/13/2010 15:44'!tempsMark: anInteger	tempsMark := anInteger! !!MessageNode class methodsFor: 'class initialization' stamp: 'eem 8/15/2010 10:22' prior: 55928326!initialize		"MessageNode initialize"	MacroSelectors := 		#(	ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers := 		#(	transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters := 		#(	emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForWhile:encoder:value: emitCodeForWhile:encoder:value:			emitCodeForToDo:encoder:value: emitCodeForToDo:encoder:value:			emitCodeForCase:encoder:value: emitCodeForCase:encoder:value:			emitCodeForIfNil:encoder:value: emitCodeForIfNil:encoder:value:			emitCodeForIf:encoder:value: emitCodeForIf:encoder:value:).	MacroSizers := 		#(	sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForIf:value: sizeCodeForIf:value:			sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value: sizeCodeForWhile:value:			sizeCodeForToDo:value: sizeCodeForToDo:value:			sizeCodeForCase:value: sizeCodeForCase:value:			sizeCodeForIfNil:value: sizeCodeForIfNil:value: sizeCodeForIf:value: sizeCodeForIf:value:).	MacroPrinters := 		#(	printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !!MessageNode methodsFor: 'code generation' stamp: 'eem 9/29/2008 14:45' prior: 51652863!emitCodeForCase: stack encoder: encoder value: forValue	| braceNode sizeStream allReturn |	forValue ifFalse:		[^super emitCodeForEffect: stack encoder: encoder].	braceNode := arguments first.	sizeStream := ReadStream on: sizes.	receiver emitCodeForValue: stack encoder: encoder.	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last | | thenSize elseSize |		thenSize := sizeStream next.		elseSize := sizeStream next.		last ifFalse: [encoder genDup. stack push: 1].		keyNode emitCodeForEvaluatedValue: stack encoder: encoder.		equalNode emitCode: stack args: 1 encoder: encoder.		self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.		last ifFalse: [encoder genPop. stack pop: 1].		valueNode emitCodeForEvaluatedValue: stack encoder: encoder.		last ifTrue: [stack pop: 1].		valueNode returns ifFalse:			[self emitCodeForJump: elseSize encoder: encoder.			 allReturn := false].		(last and: [allReturn]) ifTrue:			[self emitCodeForJump: elseSize encoder: encoder]].	arguments size = 2		ifTrue:			[arguments last emitCodeForEvaluatedValue: stack encoder: encoder] "otherwise: [...]"		ifFalse:			[NodeSelf emitCodeForValue: stack encoder: encoder.			caseErrorNode emitCode: stack args: 0 encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23' prior: 51635767!emitCodeForEffect: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: false]		ifFalse: 			[super emitCodeForEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:12' prior: 51663950!emitCodeForIf: stack encoder: encoder value: forValue	| thenExpr thenSize elseExpr elseSize |	thenSize := sizes at: 1.	elseSize := sizes at: 2.	(forValue not and: [elseSize * thenSize > 0]) ifTrue:		"Two-armed IFs forEffect share a single pop"		[^super emitCodeForEffect: stack encoder: encoder].	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	receiver emitCodeForValue: stack encoder: encoder.	forValue		ifTrue:  "Code all forValue as two-armed"			[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.			pc := encoder methodStreamPosition.			thenExpr emitCodeForEvaluatedValue: stack encoder: encoder.			stack pop: 1.  "then and else alternate; they don't accumulate"			thenExpr returns not ifTrue:				"...not ifTrue: avoids using ifFalse: alone during this compile)"				"Elide jump over else after a return"				[self emitCodeForJump: elseSize encoder: encoder].			elseExpr emitCodeForEvaluatedValue: stack encoder: encoder]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[thenSize > 0				ifTrue:					[self emitCodeForBranchOn: false dist: thenSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					thenExpr emitCodeForEvaluatedEffect: stack encoder: encoder]				ifFalse:					[self emitCodeForBranchOn: true dist: elseSize pop: stack encoder: encoder.					pc := encoder methodStreamPosition.					elseExpr emitCodeForEvaluatedEffect: stack encoder: encoder]]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:28' prior: 51667642!emitCodeForIfNil: stack encoder: encoder value: forValue	| theNode theSize ifNotNilSelector |	theNode := arguments first.	theSize := sizes at: 1.	ifNotNilSelector := #ifNotNil:.	receiver emitCodeForValue: stack encoder: encoder.	forValue ifTrue: [encoder genDup. stack push: 1].	encoder genPushSpecialLiteral: nil. stack push: 1.	equalNode emitCode: stack args: 1 encoder: encoder.	self 		emitCodeForBranchOn: (selector key == ifNotNilSelector)		dist: theSize 		pop: stack 		encoder: encoder.	pc := encoder methodStreamPosition.	forValue 		ifTrue: 			[encoder genPop. stack pop: 1.			theNode emitCodeForEvaluatedValue: stack encoder: encoder]			ifFalse: [theNode emitCodeForEvaluatedEffect: stack encoder: encoder]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:31' prior: 51630709!emitCodeForToDo: stack encoder: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt limitInit test block incStmt blockSize |	initStmt := arguments at: 4.	limitInit := arguments at: 7.	test := arguments at: 5.	block := arguments at: 3.	incStmt := arguments at: 6.	blockSize := sizes at: 1.	loopSize := sizes at: 2.	limitInit == nil		ifFalse: [limitInit emitCodeForEffect: stack encoder: encoder].	initStmt emitCodeForEffect: stack encoder: encoder.	test emitCodeForValue: stack encoder: encoder.	self emitCodeForBranchOn: false dist: blockSize pop: stack encoder: encoder.	pc := encoder methodStreamPosition.	block emitCodeForEvaluatedEffect: stack encoder: encoder.	incStmt emitCodeForEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:23' prior: 51666291!emitCodeForValue: stack encoder: encoder	"For #ifTrue:ifFalse: and #whileTrue: / #whileFalse: style messages, the pc is set to the jump instruction, so that mustBeBoolean exceptions can be shown correctly."	special > 0		ifTrue: 			[pc := 0.			self perform: (MacroEmitters at: special) with: stack with: encoder with: true]		ifFalse: 			[receiver ~~ nil ifTrue: [receiver emitCodeForValue: stack encoder: encoder].			arguments do: [:argument | argument emitCodeForValue: stack encoder: encoder].			pc := encoder methodStreamPosition + 1. "debug pc is first byte of the send, i.e. the next byte".			selector				emitCode: stack				args: arguments size				encoder: encoder				super: receiver == NodeSuper]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:36' prior: 51677780!emitCodeForWhile: stack encoder: encoder value: forValue 	"L1: ... Bfp(L2)|Btp(L2) ... Jmp(L1) L2: "	| cond stmt stmtSize loopSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := sizes at: 1.	loopSize := sizes at: 2.	cond emitCodeForEvaluatedValue: stack encoder: encoder.	self emitCodeForBranchOn: (selector key == #whileFalse:)  "Bfp for whileTrue"					dist: stmtSize pop: stack encoder: encoder.   "Btp for whileFalse"	pc := encoder methodStreamPosition.	stmt emitCodeForEvaluatedEffect: stack encoder: encoder.	self emitCodeForJump: 0 - loopSize encoder: encoder.	forValue ifTrue: [encoder genPushSpecialLiteral: nil. stack push: 1]! !!MessageNode methodsFor: 'code generation' stamp: 'nice 12/27/2009 03:11' prior: 54015765!sizeCodeForCase: encoder value: forValue	| braceNode sizeIndex elseSize allReturn |	forValue not ifTrue:		[^super sizeCodeForEffect: encoder].	equalNode := encoder encodeSelector: #=.	braceNode := arguments first.	sizes := Array new: 2 * braceNode numElements.	sizeIndex := sizes size.	elseSize := arguments size = 2		ifTrue:			[arguments last sizeCodeForEvaluatedValue: encoder] "otherwise: [...]"		ifFalse:			[caseErrorNode := encoder encodeSelector: #caseError.			 (NodeSelf sizeCodeForValue: encoder)			 + (caseErrorNode sizeCode: encoder args: 0 super: false)]. "self caseError"	"There must be at least one branch around the otherwise/caseError	  so the decompiler can identify the end of the otherwise/caseError."	allReturn := true. "assume every case ends with a return"	braceNode casesForwardDo:		[:keyNode :valueNode :last |		valueNode returns ifFalse: [allReturn := false]].	braceNode casesReverseDo:		[:keyNode :valueNode :last | | thenSize |		sizes at: sizeIndex put: elseSize.		thenSize := valueNode sizeCodeForEvaluatedValue: encoder.		last ifFalse: [thenSize := thenSize + encoder sizePop].		valueNode returns ifFalse: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		(last and: [allReturn]) ifTrue: [thenSize := thenSize + (self sizeCode: encoder forJump: elseSize)].		sizes at: sizeIndex-1 put: thenSize.		last ifFalse: [elseSize := elseSize + encoder sizeDup].		elseSize := elseSize					+ (keyNode sizeCodeForEvaluatedValue: encoder)					+ (equalNode sizeCode: encoder args: 1 super: false)					+ (self sizeCode: encoder forBranchOn: false dist: thenSize)					+ thenSize.		sizeIndex := sizeIndex - 2].	^(receiver sizeCodeForValue: encoder) + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22' prior: 51636259!sizeCodeForEffect: encoder	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: false].	^super sizeCodeForEffect: encoder! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:15' prior: 51654401!sizeCodeForIf: encoder value: forValue	| thenExpr elseExpr branchSize thenSize elseSize |	thenExpr := arguments at: 1.	elseExpr := arguments at: 2.	(forValue	 or: [(thenExpr isJust: NodeNil)	 or: [elseExpr isJust: NodeNil]]) not			"(...not ifTrue: avoids using ifFalse: alone during this compile)"		ifTrue:  "Two-armed IFs forEffect share a single pop"			[^super sizeCodeForEffect: encoder].	forValue		ifTrue:  "Code all forValue as two-armed"			[elseSize := elseExpr sizeCodeForEvaluatedValue: encoder.			thenSize := (thenExpr sizeCodeForEvaluatedValue: encoder)					+ (thenExpr returns						ifTrue: [0]  "Elide jump over else after a return"						ifFalse: [self sizeCode: encoder forJump: elseSize]).			branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]		ifFalse:  "One arm is empty here (two-arms code forValue)"			[(elseExpr isJust: NodeNil)				ifTrue:					[elseSize := 0.					thenSize := thenExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: false dist: thenSize]				ifFalse:					[thenSize := 0.					elseSize := elseExpr sizeCodeForEvaluatedEffect: encoder.					branchSize := self sizeCode: encoder forBranchOn: true dist: elseSize]].	sizes := Array with: thenSize with: elseSize.	^(receiver sizeCodeForValue: encoder)	+ branchSize + thenSize + elseSize! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:57' prior: 51648771!sizeCodeForIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode := encoder encodeSelector: #==.	sizes := Array new: 1.	theNode := arguments first.	theSelector := #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize := (encoder sizePop + (theNode sizeCodeForEvaluatedValue: encoder))).			 ^(receiver sizeCodeForValue: encoder)			 + encoder sizeDup			 + (encoder sizePushSpecialLiteral: nil)			 + (equalNode sizeCode: encoder args: 1 super: false)			 + (self 					sizeCode: encoder forBranchOn: selector key == theSelector 					dist: theSize)			 + theSize]		ifFalse:			[sizes at: 1 put: (theSize := (theNode sizeCodeForEvaluatedEffect: encoder)).			 ^(receiver sizeCodeForValue: encoder)				+ (encoder sizePushSpecialLiteral: nil)				+ (equalNode sizeCode: encoder args: 1 super: false)				+ (self 					sizeCode: encoder					forBranchOn: selector key == theSelector 					dist: theSize)				+ theSize]! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/19/2008 15:09' prior: 51638274!sizeCodeForToDo: encoder value: forValue 	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| loopSize initStmt test block incStmt blockSize initSize limitInit |	block := arguments at: 3.	initStmt := arguments at: 4.	test := arguments at: 5.	incStmt := arguments at: 6.	limitInit := arguments at: 7.	initSize := initStmt sizeCodeForEffect: encoder.	limitInit == nil ifFalse:		[initSize := initSize + (limitInit sizeCodeForEffect: encoder)].	blockSize := (block sizeCodeForEvaluatedEffect: encoder)			+ (incStmt sizeCodeForEffect: encoder)			+ (encoder sizeJumpLong: -1).	loopSize := (test sizeCodeForValue: encoder)			+ (self sizeCode: encoder forBranchOn: false dist: blockSize)			+ blockSize.	sizes := Array with: blockSize with: loopSize.	^initSize	+ loopSize	+ (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MessageNode methodsFor: 'code generation' stamp: 'eem 8/15/2010 10:22' prior: 54017583!sizeCodeForValue: encoder	| total |	special > 0 		ifTrue: [^self perform: (MacroSizers at: special) with: encoder with: true].	receiver == NodeSuper		ifTrue: [selector := selector copy "only necess for splOops"].	total := selector sizeCode: encoder args: arguments size super: receiver == NodeSuper.	receiver == nil 		ifFalse: [total := total + (receiver sizeCodeForValue: encoder)].	sizes := arguments collect: 					[:arg | | argSize | 					argSize := arg sizeCodeForValue: encoder.					total := total + argSize.					argSize].	^total! !!MessageNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 10:00' prior: 51674780!sizeCodeForWhile: encoder value: forValue 	"L1: ... Bfp(L2) ... Jmp(L1) L2: nil (nil for value only);	justStmt, wholeLoop, justJump."	| cond stmt stmtSize loopSize branchSize |	cond := receiver.	stmt := arguments at: 1.	stmtSize := (stmt sizeCodeForEvaluatedEffect: encoder) + (encoder sizeJumpLong: 1).	branchSize := self					sizeCode: encoder					forBranchOn: selector key == #whileFalse:  "Btp for whileFalse"					dist: stmtSize.	loopSize := (cond sizeCodeForEvaluatedValue: encoder) + branchSize + stmtSize.	sizes := Array with: stmtSize with: loopSize.	^loopSize + (forValue ifTrue: [encoder sizePushSpecialLiteral: nil] ifFalse: [0])! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 15:27'!addLocalsToPool: locals "<Set of: TempVariableNode>"	localsPool isNil ifTrue:		[localsPool := IdentitySet new].	localsPool addAll: locals! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:59'!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	^encoder blockExtentsToTempsMap ifNil:		[| methNode |		methNode := encoder classEncoding parserClass new						encoderClass: encoder class;						parse: (sourceText ifNil: [self decompileString])						class: self methodClass.		"As a side effect generate: creates data needed for the map."		methNode generate.		methNode encoder blockExtentsToTempsMap]! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 7/24/2008 10:04'!ensureClosureAnalysisDone	block blockExtent ifNil:		[temporaries := block analyseArguments: arguments temporaries: temporaries rootNode: self]! !!MethodNode methodsFor: 'code generation' stamp: 'eem 7/14/2010 11:28' prior: 51733588!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod.	 The argument, trailer, is arbitrary but is typically either the reference	 to the source code that is stored with every CompiledMethod, or an	 encoding of the method's temporary names."	| primErrNode blkSize nLits literals stack method |	self generate: trailer ifQuick:			[:m |			  m	literalAt: 2 put: encoder associationForClass;				properties: properties.			^m].	primErrNode := self primitiveErrorVariableName ifNotNil:						[encoder fixTemp: self primitiveErrorVariableName].	encoder supportsClosureOpcodes ifTrue:		[self ensureClosureAnalysisDone.		 encoder rootNode: self. "this is for BlockNode>>sizeCodeForClosureValue:"].	blkSize := (block sizeCodeForEvaluatedValue: encoder)				+ (primErrNode					ifNil: [0]					ifNotNil: [primErrNode sizeCodeForStore: encoder "The VM relies on storeIntoTemp: (129)"]).	method := CompiledMethod				newBytes: blkSize				trailerBytes: trailer 				nArgs: arguments size				nTemps: (encoder supportsClosureOpcodes							ifTrue: [| locals |									locals := arguments,											  temporaries,											  (primErrNode												ifNil: [#()]												ifNotNil: [{primErrNode}]).									encoder										noteBlockExtent: block blockExtent										hasLocals: locals.									locals size]							ifFalse: [encoder maxTemp])				nStack: 0				nLits: (nLits := (literals := encoder allLiterals) size)				primitive: primitive.	nLits > 255 ifTrue:		[^self error: 'Too many literals referenced'].	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	encoder streamToMethod: method.	stack := ParseStack new init.	primErrNode ifNotNil: [primErrNode emitCodeForStore: stack encoder: encoder].	stack position: method numTemps.	block emitCodeForEvaluatedValue: stack encoder: encoder.	stack position ~= (method numTemps + 1) ifTrue:		[^self error: 'Compiler stack discrepancy'].	encoder methodStreamPosition ~= (method size - trailer size) ifTrue:		[^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size - method numTemps.	method properties: properties.	^method! !!MethodNode methodsFor: 'code generation' stamp: 'Igor.Stasenko 12/20/2009 06:16'!generateWithTempNames	"Answer a CompiledMethod with temps names encoded in trailer"	^ self generate: (CompiledMethodTrailer new tempNames: self schematicTempNamesString).! !!MethodNode methodsFor: 'debugger support' stamp: 'eem 7/1/2009 13:45'!hasGeneratedMethod	^encoder hasGeneratedMethod! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/20/2008 13:43'!locationCounter	^locationCounter! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/30/2008 11:27'!noteBlockEntry: aBlock	"Evaluate aBlock with the numbering for the block entry."	locationCounter isNil ifTrue:		[locationCounter := -1].	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 6/2/2008 12:12'!noteBlockExit: aBlock	"Evaluate aBlock with the numbering for the block exit."	aBlock value: locationCounter + 1.	locationCounter := locationCounter + 2! !!MethodNode methodsFor: 'printing' stamp: 'eem 8/15/2010 10:36' prior: 51737263!printWithClosureAnalysisOn: aStream 	self ensureClosureAnalysisDone.	precedence = 1		ifTrue: 			[(self selector includesSubString: '()/')				ifTrue: [aStream nextPutAll: (self selector copyUpTo: $)).						arguments							do: [:arg| aStream nextPutAll: arg key]							separatedBy: [aStream nextPutAll: ', '].						aStream nextPut: $)]				ifFalse: [aStream nextPutAll: self selector]]  "no node for method selector"		ifFalse: 			[self selector keywords with: arguments do: 				[:kwd :arg | 				aStream nextPutAll: kwd; space.				arg printDefinitionForClosureAnalysisOn: aStream.				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			 self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1; nextPut: $|.			temporaries do: [:temp | 				aStream space.				temp printDefinitionForClosureAnalysisOn: aStream].			aStream space; nextPut: $|].	primitive > 0 ifTrue:		[(primitive between: 255 and: 519) ifFalse:  "Dont decompile quick prims  e.g, ^ self or ^instVar"			[aStream crtab: 1.			 self printPrimitiveOn: aStream]].	self printPropertiesOn: aStream.	self printPragmasOn: aStream.	aStream crtab: 1.	block printWithClosureAnalysisStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'code generation' stamp: 'eem 11/29/2008 18:53' prior: 23938335!properties	^properties! !!MethodNode methodsFor: 'code generation (closures)' stamp: 'eem 5/29/2008 16:07'!referencedValuesWithinBlockExtent: anInterval 	^(localsPool select:		[:temp|		 temp isReferencedWithinBlockExtent: anInterval]) collect:			[:temp|			temp isRemote ifTrue: [temp remoteNode] ifFalse: [temp]]! !!MethodNode methodsFor: 'debugger support' stamp: 'Igor.Stasenko 12/20/2009 03:58'!schematicTempNamesString	"Answer the temp names for the current method node in a form that captures	 temp structure.  The temps at each method and block scope level occur	 space-separated, with any indirect temps enclosed in parentheses.  Each block	 level is enclosed in square brackets.  e.g.		'method level temps (indirect temp)[block args and temps (indirect)]'	 This representation can be reconstituted into a blockExtentsToTempsMap	 by a CompiledMethod that has been copied with the schematicTempNamesString."	encoder hasGeneratedMethod ifFalse:		["create the encoder's blockExtentsToLoals map, except if the method is quick		  in which case it has no temps."		(self generate) isQuick ifTrue:			[^'']].	^encoder schematicTempNamesString! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52069998!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block"	^self emitCodeForValue: stack encoder: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:37' prior: 52069268!emitCodeForBranchOn: condition dist: dist pop: stack encoder: encoder	stack pop: 1.	dist = 0 ifTrue: [^encoder genPop].	condition		ifTrue: [encoder genBranchPopTrue: dist]		ifFalse: [encoder genBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38' prior: 52066326!emitCodeForEffect: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genPop.	stack pop: 1! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:39' prior: 52066948!emitCodeForJump: dist encoder: encoder	dist = 0 ifFalse: [encoder genJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:38' prior: 52066037!emitCodeForReturn: stack encoder: encoder	self emitCodeForValue: stack encoder: encoder.	encoder genReturnTop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 17:13' prior: 52064750!sizeCode: encoder forBranchOn: condition dist: dist	dist = 0 ifTrue: [^encoder sizePop].	^condition		ifTrue: [encoder sizeBranchPopTrue: dist]		ifFalse: [encoder sizeBranchPopFalse: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/15/2008 09:52' prior: 52067685!sizeCode: encoder forJump: dist	^dist = 0 ifTrue: [0] ifFalse: [encoder sizeJump: dist]! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52067118!sizeCodeForBlockValue: encoder	"Answer the size for evaluating the last statement in a block"	^self sizeCodeForValue: encoder! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:53' prior: 52066535!sizeCodeForEffect: encoder	^(self sizeCodeForValue: encoder) + encoder sizePop! !!ParseNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:57' prior: 52069824!sizeCodeForReturn: encoder	^(self sizeCodeForValue: encoder) + encoder sizeReturnTop! !!UndeclaredVariable methodsFor: 'as yet unclassified' stamp: 'eem 8/17/2010 16:35' prior: 58108085!openMenuIn: aBlock 	| alternatives labels actions lines caption choice |	alternatives := parser possibleVariablesFor: name.	labels := OrderedCollection new.	actions := OrderedCollection new.	lines := OrderedCollection new.	name first isLowercase 		ifTrue: 			[labels add: 'declare method temp'.			actions add: [parser declareTemp: name at: #method].			labels add: 'declare block-local temp'.			actions add: [parser declareTemp: name at: #block].			labels add: 'declare instance'.			actions add: [parser declareInstVar: name]]		ifFalse: 			[labels add: 'define new class'.			actions add: [parser defineClass: name].			labels add: 'declare global'.			actions add: [parser declareGlobal: name].			parser canDeclareClassVariable 				ifTrue: 					[labels add: 'declare class variable'.					actions add: [parser declareClassVar: name]]].	lines add: labels size.	alternatives do: 		[:each | 		labels add: each.		actions add: [parser substituteVariable: each atInterval: interval]].	lines add: labels size.	labels add: 'cancel'.	caption := 'Unknown variable: ' , name , ' please correct, or cancel:'.	choice := aBlock value: labels value: lines value: caption.	self resume: (actions at: choice ifAbsent: [nil])! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51625745!emitCodeForStorePop: stack encoder: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self emitCodeForEffect: stack encoder: encoder! !!MessageAsTempNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 51625450!sizeCodeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^self sizeCodeForEffect: encoder! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40' prior: 52350839!emitCodeForReturn: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 16:40' prior: 52350373!emitCodeForValue: stack encoder: encoder	expr emitCodeForReturn: stack encoder: encoder.	pc := encoder methodStreamPosition! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52349584!sizeCodeForReturn: encoder	^expr sizeCodeForReturn: encoder! !!ReturnNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 52348629!sizeCodeForValue: encoder	^expr sizeCodeForReturn: encoder! !!DecompilerConstructorForClosures methodsFor: 'constructor' stamp: 'eem 8/15/2010 16:56' prior: 50913929!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| blockNode selectorNode visibleTemps invisibleTemps arguments temporaries |	selectorNode := self codeSelector: selector code: nil.	tempVars := vars.	visibleTemps := OrderedCollection new.	invisibleTemps := OrderedCollection new.	tempVars do: [:t|				   ((t isIndirectTempVector or: [t scope >= 0])						ifTrue: [visibleTemps]						ifFalse: [invisibleTemps]) addLast: t].	arguments := visibleTemps copyFrom: 1 to: nArgs.	temporaries := visibleTemps copyFrom: nArgs + 1 to: visibleTemps size.	block		arguments: arguments;		temporaries: temporaries.	blockNode := MethodNode new		selector: selectorNode		arguments: arguments		precedence: selector precedence		temporaries: temporaries		block: block		encoder: (EncoderForV3PlusClosures new initScopeAndLiteralTables					temps: visibleTemps, invisibleTemps					literals: literalValues					class: class)		primitive: primitive		properties: method properties copy.	blockNode properties method: blockNode.	^blockNode! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53916457!emitCodeForBlockValue: stack encoder: encoder	"Generate code for evaluating the last statement in a block."	^effectNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53916708!emitCodeForEffect: stack encoder: encoder	^effectNode emitCodeForEffect: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 5/14/2008 14:52' prior: 53916893!emitCodeForValue: stack encoder: encoder	^valueNode emitCodeForValue: stack encoder: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28' prior: 53918505!sizeCodeForBlockValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForValue: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:27' prior: 53919232!sizeCodeForEffect: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	effectNode := MessageNode new		receiver: receiver		selector: #futureDo:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^effectNode sizeCodeForEffect: encoder! !!FutureNode methodsFor: 'code generation' stamp: 'eem 7/18/2008 12:28' prior: 53919956!sizeCodeForValue: encoder	receiver == NodeSuper ifTrue: [^self error: 'Futures cannot send to future'].	(futureArgs isNil or: [futureSelector isNil]) ifTrue:		[^self error: 'Futures must be sent messages'].	encoder sharableLitIndex: originalSelector. "to find its senders"	futureDelta ifNil:[futureDelta := encoder encodeLiteral: 0].	valueNode := MessageNode new		receiver: receiver		selector: #futureSend:at:args:		arguments: (Array 			with: (encoder encodeLiteral: futureSelector) 			with: futureDelta			with: (BraceNode new elements: futureArgs))		precedence: 3 		from: encoder.	^valueNode sizeCodeForValue: encoder! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:40' prior: 50522406!emitCodeForValue: stack encoder: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[elements do: [:node| node emitCodeForValue: stack encoder: encoder].		 encoder genPushConsArray: elements size.		 stack			pop: elements size;			push: 1.		 ^self].	^emitNode emitCodeForValue: stack encoder: encoder! !!BraceNode methodsFor: 'code generation' stamp: 'eem 5/30/2008 17:22' prior: 50516994!sizeCodeForValue: encoder	(encoder supportsClosureOpcodes		"Hack; we have no way of knowing how much stack space is available"	 and: [elements size <= self maxElementsForConsArray]) ifTrue:		[^(elements inject: 0 into: [:sum :node| sum + (node sizeCodeForValue: encoder)])		  + (encoder sizePushConsArray: elements size)].	emitNode := elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^emitNode sizeCodeForValue: encoder! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:22' prior: 52837966!emitCodeForLoad: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[remoteNode emitCodeForLoadFor: self stack: stack encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53' prior: 52847480!emitCodeForStore: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStoreInto: self stack: stack encoder: encoder].	encoder genStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:54' prior: 52841122!emitCodeForStorePop: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForStorePopInto: self stack: stack encoder: encoder].	encoder genStorePopTemp: index.	stack pop: 1! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:53' prior: 52848137!emitCodeForValue: stack encoder: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode emitCodeForValueOf: self stack: stack encoder: encoder].	encoder genPushTemp: index.	stack push: 1! !!TempVariableNode methodsFor: 'testing' stamp: 'eem 8/14/2010 11:02'!isDeclaredAtMethodLevel	"For the explainer."	^scope = 0! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 16:23' prior: 52845581!sizeCodeForLoad: encoder	^remoteNode isNil		ifTrue: [0]		ifFalse: [remoteNode sizeCodeForLoadFor: self encoder: encoder]! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52' prior: 52838556!sizeCodeForStore: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStoreInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStoreTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:52' prior: 52847865!sizeCodeForStorePop: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForStorePopInto: self encoder: encoder].	self reserve: encoder.	^encoder sizeStorePopTemp: index! !!TempVariableNode methodsFor: 'code generation' stamp: 'eem 5/20/2008 14:51' prior: 52844047!sizeCodeForValue: encoder	remoteNode ~~ nil ifTrue:		[^remoteNode sizeCodeForValueOf: self encoder: encoder].	self reserve: encoder.	^encoder sizePushTemp: index! !!Encoder methodsFor: 'private' stamp: 'eem 8/13/2010 16:06'!bindUndeclaredTemp: name	^scopeTable at: name put: (self newUndeclaredTemp: name)! !!Encoder methodsFor: 'encoding' stamp: 'eem 8/15/2010 08:29'!lookupVariable: name ifAbsent: aBlock	"Answer the binding of name in the scope table or aBlock's vaue if none.	 Do not bind and do not lookup in pools.  Used for correction, explanation etc"	^scopeTable at: name ifAbsent: aBlock! !!Encoder methodsFor: 'temps' stamp: 'eem 8/14/2010 19:35'!newUndeclaredTemp: name	^UndeclaredVariableNode new name: name! !!Encoder methodsFor: 'results' stamp: 'eem 8/13/2010 16:51'!undeclaredTemps 	^(scopeTable select: [:var | var isVariableNode and: [var isUndeclared]]) values! !BytecodeAgnosticMethodNode removeSelector: #schematicTempNamesString!BytecodeAgnosticMethodNode removeSelector: #referencedValuesWithinBlockExtent:!BytecodeAgnosticMethodNode removeSelector: #printWithClosureAnalysisOn:!BytecodeAgnosticMethodNode removeSelector: #noteBlockExit:!BytecodeAgnosticMethodNode removeSelector: #noteBlockEntry:!BytecodeAgnosticMethodNode removeSelector: #locationCounter!BytecodeAgnosticMethodNode removeSelector: #hasGeneratedMethod!BytecodeAgnosticMethodNode removeSelector: #generateWithTempNames!BytecodeAgnosticMethodNode removeSelector: #generate:!BytecodeAgnosticMethodNode removeSelector: #ensureClosureAnalysisDone!BytecodeAgnosticMethodNode removeSelector: #blockExtentsToTempsMap!BytecodeAgnosticMethodNode removeSelector: #addLocalsToPool:!Smalltalk removeClassNamed: #BytecodeAgnosticMethodNode!CascadeNode removeSelector: #sizeForValue:!CascadeNode removeSelector: #emitForValue:on:!MessageNode removeSelector: #sizeWhile:value:!MessageNode removeSelector: #sizeToDo:value:!MessageNode removeSelector: #sizeIfNil:value:!MessageNode removeSelector: #sizeIf:value:!MessageNode removeSelector: #sizeForValue:!MessageNode removeSelector: #sizeForEffect:!MessageNode removeSelector: #sizeCase:value:!MessageNode removeSelector: #emitWhile:on:value:!MessageNode removeSelector: #emitToDo:on:value:!MessageNode removeSelector: #emitIfNil:on:value:!MessageNode removeSelector: #emitIf:on:value:!MessageNode removeSelector: #emitForValue:on:!MessageNode removeSelector: #emitForEffect:on:!MessageNode removeSelector: #emitCase:on:value:!FutureNode removeSelector: #sizeForValue:!FutureNode removeSelector: #sizeForEffect:!FutureNode removeSelector: #sizeForBlockValue:!FutureNode removeSelector: #emitForValue:on:!FutureNode removeSelector: #emitForEffect:on:!FutureNode removeSelector: #emitForBlockValue:on:!TempVariableNode removeSelector: #cleanUpForRegeneration!BraceNode removeSelector: #sizeForValue:!BraceNode removeSelector: #emitForValue:on:!BytecodeEncoder removeSelector: #schematicTempNamesOn:blockExtents:fromIndex:!BytecodeEncoder removeSelector: #methodNodeClass!LeafNode removeSelector: #sizeForValue:!LeafNode removeSelector: #sizeForEffect:!LeafNode removeSelector: #emitLong:on:!LeafNode removeSelector: #emitForEffect:on:!LiteralVariableNode removeSelector: #sizeForValue:!LiteralVariableNode removeSelector: #sizeForStorePop:!LiteralVariableNode removeSelector: #sizeForStore:!LiteralVariableNode removeSelector: #emitStorePop:on:!LiteralVariableNode removeSelector: #emitStore:on:!LiteralVariableNode removeSelector: #emitLoad:on:!LiteralVariableNode removeSelector: #emitForValue:on:!AssignmentNode removeSelector: #sizeForValue:!AssignmentNode removeSelector: #sizeForEffect:!AssignmentNode removeSelector: #emitForValue:on:!AssignmentNode removeSelector: #emitForEffect:on:!SelectorNode removeSelector: #size:args:super:!SelectorNode removeSelector: #emit:args:on:super:!SelectorNode removeSelector: #emit:args:on:!BlockNode removeSelector: #sizeForValue:!BlockNode removeSelector: #sizeForEvaluatedValue:!BlockNode removeSelector: #sizeForEvaluatedEffect:!BlockNode removeSelector: #sizeExceptLast:!BlockNode removeSelector: #emitForValue:on:!BlockNode removeSelector: #emitForEvaluatedValue:on:!BlockNode removeSelector: #emitForEvaluatedEffect:on:!BlockNode removeSelector: #emitExceptLast:on:!VariableNode removeSelector: #sizeForStorePop:!VariableNode removeSelector: #sizeForStore:!VariableNode removeSelector: #sizeForReturn:!VariableNode removeSelector: #emitStorePop:on:!VariableNode removeSelector: #emitStore:on:!VariableNode removeSelector: #emitLoad:on:!VariableNode removeSelector: #emitForValue:on:!VariableNode removeSelector: #emitForReturn:on:!ReturnNode removeSelector: #sizeForValue:!ReturnNode removeSelector: #sizeForReturn:!ReturnNode removeSelector: #emitForValue:on:!ReturnNode removeSelector: #emitForReturn:on:!FieldNode removeSelector: #sizeForValue:!FieldNode removeSelector: #sizeForStorePop:!FieldNode removeSelector: #sizeForStore:!FieldNode removeSelector: #sizeForEffect:!FieldNode removeSelector: #emitStorePop:on:!FieldNode removeSelector: #emitStore:on:!FieldNode removeSelector: #emitLoad:on:!FieldNode removeSelector: #emitForValue:on:!FieldNode removeSelector: #emitForEffect:on:!ParseNode removeSelector: #sizeShortOrLong:!ParseNode removeSelector: #sizeJump:!ParseNode removeSelector: #sizeForReturn:!ParseNode removeSelector: #sizeForEffect:!ParseNode removeSelector: #sizeForBlockValue:!ParseNode removeSelector: #sizeBranchOn:dist:!ParseNode removeSelector: #emitShortOrLong:code:on:!ParseNode removeSelector: #emitLong:code:on:!ParseNode removeSelector: #emitJump:on:!ParseNode removeSelector: #emitForReturn:on:!ParseNode removeSelector: #emitForEffect:on:!ParseNode removeSelector: #emitForBlockValue:on:!ParseNode removeSelector: #emitBranchOn:dist:pop:on:!LiteralNode removeSelector: #emitForValue:on:!"Compiler"!!Point methodsFor: '*Etoys-tiles' stamp: 'ar 7/21/2010 20:02' prior: 34083620!basicType	"Answer a symbol representing the inherent type of the receiver"	^ #Point! !!Player methodsFor: 'sound' stamp: 'ar 7/21/2010 20:06' prior: 26247887!getConePosition	"Note: Performance hacked to allow real-time sound. Assumes costume is a SpeakerMorph."	^ costume renderedMorph conePosition! !!Player methodsFor: 'sound' stamp: 'ar 7/21/2010 20:06' prior: 26248094!setConePosition: aNumber	"Note: Performance hacked to allow real-time sound. Assumes costume is a SpeakerMorph."	costume renderedMorph conePosition: aNumber.! !!BasicTypeTest methodsFor: 'tests' stamp: 'ar 7/21/2010 19:47'!testBasicType		self assert: (true basicType = #Boolean).	self assert: (false basicType = #Boolean).! !!TileMorphTest methodsFor: 'testing' stamp: 'tak 12/5/2004 18:58' prior: 53018044!testArrowAction	"self debug: #testArrowAction"	| dummy tile |	dummy := Morph new.	tile := TileMorph new setOperator: '+'.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '-'.	tile := TileMorph new setOperator: '<'.	dummy addMorph: tile.	tile arrowAction: 1.	"Because receiver is not tile"	self assert: tile codeString = '='.	tile := true newTileMorphRepresentative.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '(false)'.! !!TileMorphTest methodsFor: 'testing' stamp: 'tak 12/5/2004 18:58' prior: 53017486!testAssignmentTile	"self debug: #testAssignmentTile"	| player viewer tile phrase |	player := Morph new assuredPlayer.	viewer := CategoryViewer new invisiblySetPlayer: player.	viewer  makeSetter: #(#getX #Number) event: nil from: player costume.	phrase := ActiveHand firstSubmorph.	ActiveHand removeAllMorphs.	tile := phrase submorphs second.	self assert: tile codeString = 'setX: '.	tile arrowAction: 1.	self assert: tile codeString = 'setX: self getX + '.! !!TileMorphTest methodsFor: 'testing' stamp: 'ar 7/21/2010 19:48'!testNewTileMorphRepresentative		self assert: (nil newTileMorphRepresentative class =  UndescribedTile).	self assert: (false newTileMorphRepresentative isKindOf: TileMorph).	self assert: (false newTileMorphRepresentative literal = false).	self assert: (true newTileMorphRepresentative literal = true).! !!TileMorphTest methodsFor: 'testing' stamp: 'tlk 5/6/2006 16:35' prior: 53017184!testSoundTile	"self debug: #testSoundTile"	| tile dummy |	dummy := Morph new.	tile := SoundTile new literal: 'croak'.	dummy addMorph: tile.	tile arrowAction: 1.	self assert: tile codeString = '(''horn'')'.	! !Morph class removeSelector: #partName:categories:documentation:sampleImageForm:!HaloMorph removeSelector: #doMakeSiblingOrDup:with:!HaloMorph removeSelector: #doDupOrMakeSibling:with:!"EToys"!!FileStream class methodsFor: 'file reader services' stamp: 'ar 8/9/2010 10:46' prior: 34082090!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file. 	Uses ChangeSet defaultChangeSetDirectory for consistency."	^(ChangeSet defaultChangeSetDirectory)		writeSourceCodeFrom: aStream 		baseName: baseName 		isSt: stOrCsFlag 		useHtml: useHtml! !!FileDirectory methodsFor: 'utilities' stamp: 'ar 8/9/2010 10:44'!writeSourceCodeFrom: aStream baseName: baseName isSt: stOrCsFlag useHtml: useHtml	"Write the source code from aStream into a file."	| extension converter f fileName |	aStream contents isAsciiString ifTrue: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st).		] ifFalse: [			extension := (FileDirectory dot, FileStream cs).		].		converter := MacRomanTextConverter new.	] ifFalse: [		stOrCsFlag ifTrue: [			extension := (FileDirectory dot, FileStream st "multiSt").		] ifFalse: [			extension := (FileDirectory dot, FileStream cs "multiCs").		].		converter := UTF8TextConverter new.	].	fileName := useHtml ifTrue: [baseName, '.html'] ifFalse: [baseName, extension].	fileName := self checkName: fileName fixErrors: true.	f := self newFileNamed: fileName.	f ifNil: [^ self error: 'Cannot open file'].	(converter isMemberOf: UTF8TextConverter)		ifTrue: [f binary.			UTF8TextConverter writeBOMOn: f].	f text.	f converter: converter.	f nextPutAll: aStream contents.	f close.! !"Files"!!Rectangle commentStamp: 'nice 7/25/2010 14:56' prior: 27545885!I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.Note 1: only rectangles parallel to reference frame (Screen) can be represented by this class.Note 2: the Rectangle is represented by two extremities of one diagonal. By convention, it must be the diagonal:	from rectangle origin (the point having smallest coordinates in reference frame),	to rectangle corner (the point having largest coordinates in reference frame).Note 3: Screen coordinates conventions are:	x is horizontal axis, zero at left border, oriented toward right;	y is vertical axis, zero at top border, oriented toward bottom.This corresponds to the latin convention for writing text from left to right and top to bottom.Note 4: the Rectangle extent is obtained by subtracting rectangle origin to rectangle corner coordinates.If this leads to a negative width (extent x coordinate) and/or a negative height (extent y coordinate), then the Rectangle is degenerated and considered empty.Instance variables:	origin	<Point> the coordinates of corner having smallest coordinates (top left in Screen coordinates)	corner	<Point> the coordinates of corner having largest coordinates (bottom right in Screen coordinates)!!Color methodsFor: 'transformations' stamp: 'jcg 7/12/2010 18:29' prior: 53213026!duller	"Answer a darker, desaturated color.  If the original color isn't very saturated, desaturate it by less (otherwise will just end up with grey)."	| sat adjust |	(sat := self saturation) > 0.3		ifTrue: [adjust := -0.1]		ifFalse: [adjust := 0.1 - sat max: 0.0].	^ self adjustSaturation: adjust brightness: -0.1! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 21:27' prior: 27567474!flipBy: direction centerAt: aPoint 	"Return a copy flipped #vertical or #horizontal, about aPoint."	| futureOrigin futureCorner |	direction == #horizontal		ifTrue:			[futureOrigin := self topRight.			futureCorner := self bottomLeft]		ifFalse: [direction == #vertical			ifTrue:				[futureOrigin := self bottomLeft.				futureCorner := self topRight]			ifFalse: [self error: 'unrecognizable direction']].	^ (futureOrigin flipBy: direction centerAt: aPoint)		corner: (futureCorner flipBy: direction centerAt: aPoint)! !!Rectangle methodsFor: 'testing' stamp: 'nice 6/20/2010 21:32' prior: 52271353!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin := aRectangle origin.	rCorner := aRectangle corner.	rCorner x <= origin x	ifTrue: [^ false].	rCorner y <= origin y	ifTrue: [^ false].	rOrigin x >= corner x	ifTrue: [^ false].	rOrigin y >= corner y	ifTrue: [^ false]."None of the two rectangle shall be empty"	corner x <= origin x	ifTrue: [^ false].	corner y <= origin y	ifTrue: [^ false].	rCorner x <= rOrigin x	ifTrue: [^ false].	rCorner y <= rOrigin y	ifTrue: [^ false].	^ true! !!Rectangle methodsFor: 'transforming' stamp: 'nice 6/20/2010 22:01' prior: 27570080!rotateBy: direction centerAt: aPoint	"Return a copy rotated #right, #left, or #pi about aPoint"	| futureOrigin futureCorner |	direction == #pi		ifTrue:			[futureOrigin := self corner.			futureCorner := self origin]		ifFalse: [direction == #left			ifTrue:				[futureOrigin := self topRight.				futureCorner := self bottomLeft]			ifFalse: [direction == #right				ifTrue:					[futureOrigin := self bottomLeft.					futureCorner := self topRight]				ifFalse: [self error: 'unrecognizable direction']]].	^ (futureOrigin rotateBy: direction centerAt: aPoint)		corner: (futureCorner rotateBy: direction centerAt: aPoint)! !!Point methodsFor: 'point functions' stamp: 'wiz 7/28/2007 20:50' prior: 34084395!normal	"Answer a Point representing the unit vector rotated 90 deg clockwise.	For the zero point return a normal of  -1@0   ."	| n d |		n := y negated @ x.	(d := (n x * n x + (n y * n y))) = 0 ifTrue: [ ^  -1 @0  ] .	^n / d sqrt! !"Graphics"!!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:50' prior: 34085041!testBasicFourDirections	"fourDirections returns the four rotation of the receiver in counter clockwise order with the receiver appearing last. "	| samples results rejects |	self assert:  (0 asPoint fourDirections) = (Array new: 4 withAll: 0 asPoint) . 	samples := 0 asPoint eightNeighbors  .	results := {		{ 0 @ -1 . 	-1 @  0 . 	 0 @  1 . 	 1 @  0}.		{ 1 @ -1 . 	-1 @ -1 . 	-1 @  1 . 	 1 @  1}.		{ 1 @  0 . 	 0 @ -1 . 	-1 @  0 . 	 0 @  1}.		{ 1 @  1 . 	 1 @ -1 . 	-1 @ -1 . 	-1 @  1}.		{ 0 @  1 . 	 1 @  0 . 	 0 @ -1 . 	-1 @  0}.		{-1 @  1 . 	 1 @  1 . 	 1 @ -1 . 	-1 @ -1}.		{-1 @  0 . 	 0 @  1 . 	 1 @  0 . 	 0 @ -1}.		{-1 @ -1 . 	-1 @  1 . 	 1 @  1 . 	 1 @ -1} } .	rejects := (1 to: samples size ) reject: [ :each |		 (samples at: each) fourDirections = (results at: each) ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'tests - testing' stamp: 'nice 7/24/2010 18:43' prior: 26578741!testBearingToPoint	self assert: (0 @ 0 bearingToPoint: 0 @ 0) = 0.	self assert: (0 @ 0 bearingToPoint: 0 @ -1) = 0.	self assert: (0 @ 0 bearingToPoint: 1 @ 0) = 90.	self assert: (0 @ 0 bearingToPoint: 0 @ 1) = 180.	self assert: (0 @ 0 bearingToPoint: -1 @ 0) = 270.	self assert: (0 @ 0 bearingToPoint: 1 @ 1) = 135.	self assert: (0 @ 0 bearingToPoint: 0.01 @ 0) = 90.	self assert: (0 @ 0 bearingToPoint: -2 @ -3) = 326.	self assert: (0 @ 0 bearingToPoint: -0 @ 0) = 0.		self assert: (-2 @ -3 bearingToPoint: 0 @ 0) = 146.! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:52' prior: 34086878!testNormal	"quick check of results for #normal."	| samples rejects results |	samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .	results :=  		{ 0.0 @ 1.0 .		-0.707106781186547 @ 0.707106781186547 .		-1.0 @ 0.0 .		-0.707106781186547 @ -0.707106781186547 .		0.0 @ -1.0 .		0.707106781186547 @ -0.707106781186547 .		1.0 @ 0.0 .		0.707106781186547 @ 0.707106781186547 .		-1 @ 0} .	rejects := (1 to: samples size ) reject:		[ :each | ((samples at: each) normal - (results at: each)) abs  < 1e-15 asPoint ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:54' prior: 34087497!testNormal2	"quick check of results for #normal.	differs from the other testNormal in the way that the difference is measured."	| samples rejects results differences |	samples := 0 asPoint eightNeighbors , (Array with: 0 asPoint) .	results := 		{ 0.0 @ 1.0 .		-0.707106781186547 @ 0.707106781186547 .		-1.0 @ 0.0 .		-0.707106781186547 @ -0.707106781186547 .		0.0 @ -1.0 .		0.707106781186547 @ -0.707106781186547 .		1.0 @ 0.0 .		0.707106781186547 @ 0.707106781186547 .		-1 @ 0} .	differences := samples with: results collect: [ :each :eachResult |		each normal - eachResult ] .	rejects := differences reject: [ :each | 		(each x closeTo: 0.0) and: [each y closeTo: 0.0] ] .	self assert: rejects isEmpty! !!PointTest methodsFor: 'testing - testing' stamp: 'nice 7/24/2010 18:44' prior: 26579508!testTheta      | result dir tan x y |	self assert: ((0 @ 1) theta - 90.0 degreesToRadians) abs < 1e-15.	self assert: ((0 @ -1) theta - 270.0 degreesToRadians) abs < 1e-15.	" See code of old and new theta"	x := 1.0 . y := -1.0.	tan := y  / x .	dir := tan arcTan.      result :=  360.0 degreesToRadians + dir.      self assert: ((x @ y) theta - result) abs < 1e-15.	x := -1.0. "Don't reuse old results when you want numeric precision!!"	tan := y  / x .	dir := tan arcTan.      result :=  180.0 degreesToRadians + dir.      self assert: ((x @ y) theta - result) abs < 1e-15.	! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 7/24/2010 18:45' prior: 25366936!drawStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1 @ 1 corner: aForm extent - 15) fillColor: Color red borderWidth: 3 borderColor: Color green.	canvas fillOval: (aForm boundingBox topRight - (15 @ -5) extent: 20 @ 20) color: Color blue borderWidth: 1 borderColor: Color white.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32 @ 32 depth: 16)) display"! !!PNGReadWriterTest methodsFor: 'helpers' stamp: 'nice 7/24/2010 18:45' prior: 25367460!drawTransparentStuffOn: aForm	"Draw stuff on aForm. Avoid any symmetry."	| canvas |	canvas := FormCanvas on: aForm.	canvas frameAndFillRectangle: (1 @ 1 corner: aForm extent - 15) fillColor: (Color red alpha: 0.25) borderWidth: 3 borderColor: (Color green alpha: 0.5).	canvas fillOval: (aForm boundingBox topRight - (15 @ -5) extent: 20 @ 20) color: (Color white alpha: 0.75) borderWidth: 1 borderColor: Color blue.	^aForm	"(PNGReadWriterTest new drawStuffOn: (Form extent: 32 @ 32 depth: 16)) display"! !"GraphicsTests"!!FractionTest methodsFor: 'tests - printing' stamp: 'nice 7/24/2010 18:43' prior: 21179342!testFractionPrinting	self assert: (353/359) printString = '(353/359)'.	self assert: ((2/3) printStringBase: 2) = '(10/11)'.	self assert: ((2/3) storeStringBase: 2) = '(2r10/2r11)'.	self assert: ((5/7) printStringBase: 3) = '(12/21)'.	self assert: ((5/7) storeStringBase: 3) = '(3r12/3r21)'.	self assert: ((11/13) printStringBase: 4) = '(23/31)'.	self assert: ((11/13) storeStringBase: 4) = '(4r23/4r31)'.	self assert: ((17/19) printStringBase: 5) = '(32/34)'.	self assert: ((17/19) storeStringBase: 5) = '(5r32/5r34)'.	self assert: ((23/29) printStringBase: 6) = '(35/45)'.	self assert: ((23/29) storeStringBase: 6) = '(6r35/6r45)'.	self assert: ((31/37) printStringBase: 7) = '(43/52)'.	self assert: ((31/37) storeStringBase: 7) = '(7r43/7r52)'.	self assert: ((41/43) printStringBase: 8) = '(51/53)'.	self assert: ((41/43) storeStringBase: 8) = '(8r51/8r53)'.	self assert: ((47/53) printStringBase: 9) = '(52/58)'.	self assert: ((47/53) storeStringBase: 9) = '(9r52/9r58)'.	self assert: ((59/61) printStringBase: 10) = '(59/61)'.	self assert: ((59/61) storeStringBase: 10) = '(59/61)'.	self assert: ((67/71) printStringBase: 11) = '(61/65)'.	self assert: ((67/71) storeStringBase: 11) = '(11r61/11r65)'.	self assert: ((73/79) printStringBase: 12) = '(61/67)'.	self assert: ((73/79) storeStringBase: 12) = '(12r61/12r67)'.	self assert: ((83/89) printStringBase: 13) = '(65/6B)'.	self assert: ((83/89) storeStringBase: 13) = '(13r65/13r6B)'.	self assert: ((97/101) printStringBase: 14) = '(6D/73)'.	self assert: ((97/101) storeStringBase: 14) = '(14r6D/14r73)'.	self assert: ((103/107) printStringBase: 15) = '(6D/72)'.	self assert: ((103/107) storeStringBase: 15) = '(15r6D/15r72)'.	self assert: ((109/113) printStringBase: 16) = '(6D/71)'.	self assert: ((109/113) storeStringBase: 16) = '(16r6D/16r71)'.	self assert: ((127/131) printStringBase: 17) = '(78/7C)'.	self assert: ((127/131) storeStringBase: 17) = '(17r78/17r7C)'.	self assert: ((137/139) printStringBase: 18) = '(7B/7D)'.	self assert: ((137/139) storeStringBase: 18) = '(18r7B/18r7D)'.	self assert: ((149/151) printStringBase: 19) = '(7G/7I)'.	self assert: ((149/151) storeStringBase: 19) = '(19r7G/19r7I)'.	self assert: ((157/163) printStringBase: 20) = '(7H/83)'.	self assert: ((157/163) storeStringBase: 20) = '(20r7H/20r83)'.	self assert: ((167/173) printStringBase: 21) = '(7K/85)'.	self assert: ((167/173) storeStringBase: 21) = '(21r7K/21r85)'.	self assert: ((179/181) printStringBase: 22) = '(83/85)'.	self assert: ((179/181) storeStringBase: 22) = '(22r83/22r85)'.	self assert: ((191/193) printStringBase: 23) = '(87/89)'.	self assert: ((191/193) storeStringBase: 23) = '(23r87/23r89)'.	self assert: ((197/199) printStringBase: 24) = '(85/87)'.	self assert: ((197/199) storeStringBase: 24) = '(24r85/24r87)'.	self assert: ((211/223) printStringBase: 25) = '(8B/8N)'.	self assert: ((211/223) storeStringBase: 25) = '(25r8B/25r8N)'.	self assert: ((227/229) printStringBase: 26) = '(8J/8L)'.	self assert: ((227/229) storeStringBase: 26) = '(26r8J/26r8L)'.	self assert: ((233/239) printStringBase: 27) = '(8H/8N)'.	self assert: ((233/239) storeStringBase: 27) = '(27r8H/27r8N)'.	self assert: ((241/251) printStringBase: 28) = '(8H/8R)'.	self assert: ((241/251) storeStringBase: 28) = '(28r8H/28r8R)'.	self assert: ((257/263) printStringBase: 29) = '(8P/92)'.	self assert: ((257/263) storeStringBase: 29) = '(29r8P/29r92)'.	self assert: ((269/271) printStringBase: 30) = '(8T/91)'.	self assert: ((269/271) storeStringBase: 30) = '(30r8T/30r91)'.	self assert: ((277/281) printStringBase: 31) = '(8T/92)'.	self assert: ((277/281) storeStringBase: 31) = '(31r8T/31r92)'.	self assert: ((283/293) printStringBase: 32) = '(8R/95)'.	self assert: ((283/293) storeStringBase: 32) = '(32r8R/32r95)'.	self assert: ((307/311) printStringBase: 33) = '(9A/9E)'.	self assert: ((307/311) storeStringBase: 33) = '(33r9A/33r9E)'.	self assert: ((313/317) printStringBase: 34) = '(97/9B)'.	self assert: ((313/317) storeStringBase: 34) = '(34r97/34r9B)'.	self assert: ((331/337) printStringBase: 35) = '(9G/9M)'.	self assert: ((331/337) storeStringBase: 35) = '(35r9G/35r9M)'.	self assert: ((347/349) printStringBase: 36) = '(9N/9P)'.	self assert: ((347/349) storeStringBase: 36) = '(36r9N/36r9P)'.	self assert: ((-2/3) printStringBase: 2) = '(-10/11)'.	self assert: ((-2/3) storeStringBase: 2) = '(-2r10/2r11)'.	self assert: ((5 / -7) printStringBase: 3) = '(-12/21)'.	self assert: ((5 / -7) storeStringBase: 3) = '(-3r12/3r21)'.! !!MethodContextTest methodsFor: 'private' stamp: 'HenrikSperreJohansen 6/11/2010 21:18'!privRestartTest	"This tests may loop endlessly if incorrect, so call it from another method testing it does not time out"	|a firstTimeThrough |	firstTimeThrough := true.	a := 10.		self assert: 30 equals: [|b| 		self assert: 10 == a .		self assert: nil == b.		b := a + 20. 		firstTimeThrough ifTrue: [			firstTimeThrough := false.			thisContext restart.].		b] value! !!MethodContextTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 6/11/2010 21:19'!testRestart	self should: [self privRestartTest] notTakeMoreThan: 0.1 second! !UndefinedObjectTest removeSelector: #testNewTileMorphRepresentative!BooleanTest removeSelector: #testNewTileMorphRepresentative!BooleanTest removeSelector: #testBasicType!"KernelTests"!!Project commentStamp: 'cbr 7/27/2010 21:36' prior: 33821982!A Project stores the state of a complete Squeak desktop, includingthe windows, and the currently active changeSet.  A project knows whoits parent project is.  When you change projects, whether by enteringor exiting, the screen state of the project being exited is saved inthat project.A project is retained by its view in the parent world.  It iseffectively named by the name of its changeSet, which can be changedeither by renaming in a changeSorter, or by editing the label of itsview from the parent project.As the site of major context switch, Projects are the locus ofswapping between the old MVC and the new Morphic worlds.  Thedistinction is based on whether the variable 'world' contains aWorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.  (Projectnamed: 'xxx') exportSegment, or choose 'store project on file...'.Projects may be loaded from a server and stored back.  Storing on aserver never overwrites;  it always makes a new version.  A projectremembers the url of where it lives in urlList.  The list is lengthone, for now.  The url may point to a local disk instead of a server.All projects that the user looks at are cached in the Squeakletfolder.  Sorted by server.  The cache holds the most recent versiononly.When a project is loaded into Squeak, its objects are converted tothe current version.  There are three levels of conversion.  First,each object is converted from raw bits to an object in its oldformat.  Then it is sent some or all of these messages:	comeFullyUpOnReload: smartRefStream  		Used tore-discover an object that already exists in this image, such as aresource, global variable, Character, or Symbol.  (sent to objects inoutPointers)	convertToCurrentVersion: varDict refStream: smartRefStrm		fill in fields that have been added to a class sincethe object was stored.  Used to set the extra inst var to a defaultvalue.  Or, return a new object of a different class.  (sent toobjects that changed instance variables)	fixUponLoad: aProject refStream: smartRefStrm	change the object due to conventions that have changed on theproject level.  (sent to all objects in the incoming project)Here is the calling sequence for storing out a Project:Project saveAsProject storeOnServerProject storeOnServerWithProgressInfoProject storeOnServerInnardsProject exportSegmentFileName:directory:Project exportSegmentWithChangeSet:fileName:directory:ImageSegment writeForExportWithSources:inDirectory:changeSet:!!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:44'!flagInterpretedMethods: aBoolean	"The Cog VM can be instructed to set the flag bit of CompiledMethods that	 it executes but will only interpret.  This can be used e.g. to profile startup.	 See CompiledMethod>>#flag & CompiledMethod>>#clearFlag.  	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 2) + (aBoolean ifTrue: [2] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:43' prior: 33951420!isRunningCog	"Returns true if we're running on a Cog VM (JIT or StackInterpreter)	 (vmParameterAt: 42 is the number of stack pages)"	^[(self vmParameterAt: 42) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/6/2010 20:41'!isRunningCogit	"Returns true if we're running on the Cog JIT	 (vmParameterAt: 46 is the size of the machine code zone)"	^[(self vmParameterAt: 46) > 0] on: Error do:[:ex| ex return: false]! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:23'!processHasThreadIdInstVar: aBoolean	"The threaded VM needs to know if the 4th inst var of Process	 is threadId which it uses to control process-to-thread binding.	 This flag persists across snapshots, stored in the image header."	aBoolean ifTrue: [self assert: (Process instVarNames at: 4) ='threadId'].	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 1) + (aBoolean ifTrue: [1] ifFalse: [0])! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:51'!processPreemptionYields	"Answer whether the VM causes a process to yield on process preemption,	 i.e. to put a preempted process at the back of its run queue.  If the parameter	 is unavailable (non-Cog VMs) or bit 2 (4) is 0 then preemption yields."	^(([self vmParameterAt: 48]			on: Error			do: [:ex| ^true]) allMask: 4) not! !!SmalltalkImage methodsFor: 'system attributes' stamp: 'eem 7/22/2010 17:26'!processPreemptionYields: aBoolean	"The Cog VM can be instructed not to yield on process preemption,	 i.e. not to put a preempted process at the back of its run queue.  By	 default preempting a process causes it to yield (Blue Book semantics)	 which can have unfortunate effects.	 This flag persists across snapshots, stored in the image header."	self vmParameterAt: 48 put: ((self vmParameterAt: 48) bitClear: 4) + (aBoolean ifTrue: [0] ifFalse: [4])! !!MethodReference methodsFor: 'queries' stamp: 'eem 5/25/2010 17:56'!selector	^methodSymbol! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ar 8/9/2010 10:47' prior: 54154921!fileOut	"File out the receiver, to a file whose name is a function of the  	change-set name and either of the date & time or chosen to have a  	unique numeric tag, depending on the preference  	'changeSetVersionNumbers'"	| slips nameToUse |	self checkForConversionMethods.	ChangeSet promptForDefaultChangeSetDirectoryIfNecessary.	nameToUse := Preferences changeSetVersionNumbers				ifTrue: [self defaultChangeSetDirectory nextNameFor: self name extension: FileStream cs]				ifFalse: [self name , FileDirectory dot , Utilities dateTimeSuffix, FileDirectory dot , FileStream cs].	Cursor write showWhile: [ | internalStream |			internalStream := WriteStream on: (String new: 10000).			internalStream header; timeStamp.			self fileOutPreambleOn: internalStream.			self fileOutOn: internalStream.			self fileOutPostscriptOn: internalStream.			internalStream trailer.			FileStream writeSourceCodeFrom: internalStream baseName: (nameToUse copyFrom: 1 to: nameToUse size - 3) isSt: false useHtml: false.	].	Preferences checkForSlips		ifFalse: [^ self].	slips := self checkForSlips.	(slips size > 0			and: [(UIManager default chooseFrom: #('Ignore' 'Browse slips')				 	title: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?')					= 2])		ifTrue: [self systemNavigation browseMessageList: slips name: 'Possible slips in ' , name]! !!ChangeRecord methodsFor: 'access' stamp: 'eem 8/14/2010 20:35' prior: 33968499!methodClass	| methodClassName methodClass |	(#(method #classComment) includes: type) ifFalse: [ ^ nil ].	methodClassName := class subStrings		ifEmpty: [ ^ nil ]		ifNotEmptyDo:			[ : parts | parts first asSymbol ].	(Smalltalk globals includesKey: methodClassName) ifFalse: [ ^ nil ].	methodClass := Smalltalk at: methodClassName.	^ meta		ifTrue: [ methodClass class ]		ifFalse: [ methodClass ]! !!SystemNavigation methodsFor: 'browse' stamp: 'dtl 8/1/2010 10:12'!browseMyChanges	"Browse only the changes (in the changes file) by the current author."	"SystemNavigation default browseMyChanges"	self browseAllSelect: [ :method |       method fileIndex > 1 "only look at changes file"               and: [ method timeStamp beginsWith: Utilities authorInitials ]]! !!Preferences class methodsFor: 'reacting to change' stamp: 'ar 7/21/2010 20:20' prior: 26931806!displaySizeChanged	self flag: #todo.	"only change font on small-land image"	self smallLandFonts.	self tinyDisplay		ifTrue: [self enable: #scrollBarsNarrow]		ifFalse: [self disable: #scrollBarsNarrow].	self tinyDisplay 		ifTrue:[self disable: #biggerHandles] 		ifFalse:[self enable: #biggerHandles]! !!Preferences class methodsFor: 'fonts' stamp: 'ar 7/21/2010 20:13'!restoreFontsAfter: aBlock	"Restore the currently chosen set of standard fonts after 	evaluating aBlock. Used for tests that modify the default fonts."	| standardDefaultTextFont standardListFont standardEToysFont standardMenuFont 	windowTitleFont standardBalloonHelpFont standardCodeFont standardButtonFont |	standardDefaultTextFont := Preferences standardDefaultTextFont.	standardListFont := Preferences standardListFont.	standardEToysFont := Preferences standardEToysFont.	standardMenuFont := Preferences standardMenuFont.	windowTitleFont := Preferences windowTitleFont.	standardBalloonHelpFont := Preferences standardBalloonHelpFont.	standardCodeFont := Preferences standardCodeFont.	standardButtonFont := Preferences standardButtonFont.	^aBlock ensure: [		Preferences setSystemFontTo: standardDefaultTextFont.		Preferences setListFontTo: standardListFont.		Preferences setEToysFontTo: standardEToysFont.		Preferences setMenuFontTo: standardMenuFont.		Preferences setWindowTitleFontTo: windowTitleFont.		Preferences setBalloonHelpFontTo: standardBalloonHelpFont.		Preferences setCodeFontTo: standardCodeFont.		Preferences setButtonFontTo: standardButtonFont.	].! !!SimpleButtonMorph commentStamp: 'ul 7/22/2010 04:30' prior: 29085281!I am labeled, rectangular morph which allows the user to click me. I can be configured to send my "target" the message "actionSelector" with "arguments" when I am clicked. I may have a label, implemented as a StringMorph.Example:	SimpleButtonMorph new		target: Beeper;		label: 'Beep!!';		actionSelector: #beep; 		openInWorldStructure:instance var 	Type		Description target 			Object 		The Object to notify upon a click actionSelector 	Symbol 		The message to send to Target (#messageName) arguments 		Array 		Arguments to send with #actionSelection (optional) actWhen 		Symbol 		When to take action: may be #buttonUp (default), #buttonDown,								#whilePressed, or #startDrag oldColor 		Color 		Used to restore color after click Another example: a button which quits the image without saving it.	SimpleButtonMorph new		target: Smalltalk;		label: 'quit';		actionSelector: #snapshot:andQuit:;		arguments: (Array with: false with: true); 		openInWorld!!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:40'!appsMenuOn: aDockingBar	"Create a menu with the registered apps"	aDockingBar addItem: [ :item |		item			contents: 'Apps' translated;			subMenuUpdater: self			selector: #listAppsOn: ]! !!TheWorldMainDockingBar methodsFor: 'submenu - apps' stamp: 'ar 8/6/2010 23:44'!listAppsOn: menu	"Update the apps list in the menu"	| args |	TheWorldMenu registeredOpenCommands do:[:spec|		args := spec second.		menu addItem: [ :item |			item				contents: spec first translated;				target: args first;				selector: args second].	].! !!TheWorldMainDockingBar methodsFor: 'construction' stamp: 'ar 8/6/2010 23:45' prior: 59056125!menusOn: aDockingBar 	self 		squeakMenuOn: aDockingBar;		projectsMenuOn: aDockingBar;		toolsMenuOn: aDockingBar;		appsMenuOn: aDockingBar;		extrasMenuOn: aDockingBar;		windowsMenuOn: aDockingBar;		helpMenuOn: aDockingBar.	aDockingBar addSpacer.	self		searchBarOn: aDockingBar;		clockOn: aDockingBar! !!TextEditor methodsFor: 'explain' stamp: 'eem 8/14/2010 11:15' prior: 57293992!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:09' prior: 52549432!erasePixelsOfColor: aColor 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	| newBounds |	originalForm		mapColor: aColor		to: Color transparent.	newBounds := originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: newBounds)! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:19'!erasePixelsUsing: evt 	"Let the user specifiy a color such that all pixels of that color should be erased; then do the erasure"	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	self rememberedColor "color to erase"		ifNil: [ ^ self ]		ifNotNilDo:			[ : chosenColor | self erasePixelsOfColor: chosenColor ]! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:15'!recolorPixelsOfColor: originalColor with: newColor	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| d newForm map |	d := originalForm depth.	newForm := Form extent: originalForm extent depth: d.	map := (Color cachedColormapFrom: d to: d) copy.	map at: (originalColor indexInMap: map) put: (newColor pixelValueForDepth: d).	newForm copyBits: newForm boundingBox		from: originalForm at: 0@0		colorMap: map.	self form: newForm.! !!SketchMorph methodsFor: 'menu' stamp: 'cmm 8/2/2010 18:18'!recolorPixelsUsing: evt 	"Let the user select a color to be remapped, and then a color to map that color to, then carry it out."	| originalColor newColor |	self inform: 'choose the color you want to replace' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: nil		hand: evt hand.	"color to replace"	originalColor := self rememberedColor ifNil: [ ^ self ].	self inform: 'now choose the color you want to replace it with' translated.	self		changeColorTarget: self		selector: #rememberedColor:		originalColor: originalColor		hand: evt hand.	"new color"	newColor := self rememberedColor ifNil: [ ^ self ].	self		recolorPixelsOfColor: originalColor		with: newColor! !!TheWorldMenu methodsFor: 'construction' stamp: 'ar 8/2/2010 20:51' prior: 52991136!addPrintAndDebug: menu	Preferences simpleMenus ifFalse: [		self			fillIn: menu			from: {				{ 'make screenshot'. {self. #saveScreenshot}. 'makes a screenshot and saves it to disk'}.				"{ 'print PS to file...'. { self. #printWorldOnFile }. 'write the world into a postscript file' }."				{ 'debug...'. { self. #debugDo }. 'a menu of debugging items' }			} ]! !!TheWorldMenu methodsFor: 'action' stamp: 'ar 8/2/2010 20:51'!saveScreenshot	"Make a screenshot of the world and save it to a file"	SampledSound playSoundNamed: 'camera'.	PNGReadWriter putForm: myWorld imageForm onFileNamed:		(FileDirectory default nextNameFor: 'SqueakScreen' extension:'png').! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:26'!doDupOrMakeSibling: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *not* pressed, or make a sibling if shift key *is* pressed"	^ (evt shiftPressed and: [target couldMakeSibling])		ifTrue:			[dupHandle color: Color green muchDarker.			self doMakeSibling: evt with: dupHandle]		ifFalse:			[self doDup: evt with: dupHandle]! !!HaloMorph methodsFor: 'handles' stamp: 'sw 3/30/2005 04:28'!doMakeSiblingOrDup: evt with: dupHandle	"Ask hand to duplicate my target, if shift key *is* pressed, or make a sibling if shift key *not* pressed"	^ (evt shiftPressed or: [target couldMakeSibling not])		ifFalse:			[self doMakeSibling: evt with: dupHandle]		ifTrue:			[dupHandle color: Color green.			self doDup: evt with: dupHandle]! !!Morph class methodsFor: 'new-morph participation' stamp: 'ar 7/21/2010 20:03'!partName: aName categories: aList documentation: aDoc sampleImageForm: aForm	"Answer a DescriptionForPartsBin which will represent a launch of a new instance of my class via the #newStandAlone protocol sent to my class. Use the category-list and documentation provided.  This variant allows an overriding image form to be provided, useful in cases where we don't want to launch a sample instance just to get the form"	| descr |	descr := DescriptionForPartsBin new		formalName: aName		categoryList: aList		documentation: aDoc		globalReceiverSymbol: self name		nativitySelector: #newStandAlone.	descr sampleImageForm: aForm.	^ descr! !!Morph methodsFor: 'menus' stamp: 'cmm 8/2/2010 18:20' prior: 24277159!addPaintingItemsTo: aMenu hand: aHandMorph 	| subMenu movies |	subMenu := MenuMorph new defaultTarget: self.	subMenu add: 'repaint' translated action: #editDrawing.	subMenu add: 'set rotation center' translated action: #setRotationCenter.	subMenu add: 'reset forward-direction' translated		action: #resetForwardDirection.	subMenu add: 'set rotation style' translated action: #setRotationStyle.	subMenu add: 'erase pixels of color' translated		action: #erasePixelsUsing:.	subMenu add: 'recolor pixels of color' translated		action: #recolorPixelsUsing:.	subMenu add: 'reduce color palette' translated action: #reduceColorPalette:.	subMenu add: 'add a border around this shape...' translated		action: #addBorderToShape:.	movies := (self world rootMorphsAt: aHandMorph targetPoint) 				select: [:m | (m isKindOf: MovieMorph) or: [m isSketchMorph]].	movies size > 1 		ifTrue: 			[subMenu add: 'insert into movie' translated action: #insertIntoMovie:].	aMenu add: 'painting...' translated subMenu: subMenu! !SketchMorph removeSelector: #recolorPixelsOfColor:!"Morphic"!!Unicode commentStamp: 'yo 10/19/2004 20:44' prior: 59456444!This class holds the entry points for the utility functions around characters.!!SparseXTable methodsFor: 'accessing' stamp: 'nice 7/10/2010 23:49' prior: 57452504!tableFor: code	| div |	div := code // 65536.	^xTables at: div ifAbsentPut:		[Array new: 65536 withAll: 0].! !!UTF16TextConverter methodsFor: 'private' stamp: 'HenrikSperreJohansen 6/7/2010 15:04'!swapLatin1EncodingByteOrder	latin1Encodings := latin1Encodings collect: [:each | each reverse]! !!UTF16TextConverter methodsFor: 'accessing' stamp: 'HenrikSperreJohansen 6/7/2010 15:04' prior: 53388927!useLittleEndian: aBoolean	aBoolean = self useLittleEndian ifFalse: [self swapLatin1EncodingByteOrder].	useLittleEndian := aBoolean.! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:47'!initializeCaseMappings	"Unicode initializeCaseMappings"	ToCasefold := IdentityDictionary new.	ToUpper := IdentityDictionary new.	ToLower := IdentityDictionary new.	UIManager default informUserDuring: [:bar|		| stream |		bar value: 'Downloading Unicode data'.		stream := HTTPClient httpGet: 'http://www.unicode.org/Public/UNIDATA/CaseFolding.txt'.		(stream isKindOf: RWBinaryOrTextStream) ifFalse:[^self error: 'Download failed'].		stream reset.		bar value: 'Updating Case Mappings'.		self parseCaseMappingFrom: stream.	].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:49'!parseCaseMappingFrom: stream	"Parse the Unicode casing mappings from the given stream.	Handle only the simple mappings"	"		Unicode initializeCaseMappings.	"	ToCasefold := IdentityDictionary new: 2048.	ToUpper := IdentityDictionary new: 2048.	ToLower := IdentityDictionary new: 2048.	[stream atEnd] whileFalse:[		| fields line srcCode dstCode |		line := stream nextLine copyUpTo: $#.		fields := line withBlanksTrimmed findTokens: $;.		(fields size > 2 and: [#('C' 'S') includes: (fields at: 2) withBlanksTrimmed]) ifTrue:[			srcCode := Integer readFrom: (fields at: 1) withBlanksTrimmed base: 16.			dstCode := Integer readFrom: (fields at: 3) withBlanksTrimmed base: 16.			ToCasefold at: srcCode put: dstCode.		].	].	ToCasefold keysAndValuesDo:		[:k :v |		(self isUppercase: (self value: k))			ifTrue:				["In most cases, uppercase letter are folded to lower case"				ToUpper at: v put: k.				ToLower at: k put: v].		(self isLowercase: (self value: k))			ifTrue:				["In a few cases, two lower case letters are folded to the same lower case.				We must find an upper case letter folded to the same letter"				| up |				up := ToCasefold keys detect: [:e | (self isUppercase: (self value: e)) and: [(ToCasefold at: e) = v]] ifNone: [nil].				up ifNotNil: [ToUpper at: k put: up]]].! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 15:00'!toCasefold: aWideString	"Transform a Wide String into fold case.	This is to enable case insensitive conversion."		^aWideString collect: [:e |		(ToCasefold at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:11'!toLowercase: aWideString	"Transform a Wide String into lowercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToLower at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:low | self value: low]]! !!Unicode class methodsFor: 'casing' stamp: 'nice 7/14/2010 13:08'!toUppercase: aWideString	"Transform a Wide String into uppercase.	This does not handle special cases where number of characters could change.	The algorithm would work for ByteString, however it's far from the most efficient."		^aWideString collect: [:e |		(ToUpper at: e charCode ifAbsent: [nil])			ifNil: [e]			ifNotNil: [:up | self value: up]]! !"Multilingual"!!LedCharacterMorph commentStamp: 'cbr 7/27/2010 18:47' prior: 59337038!I represent a character to be displayed on an LedMorph; I am a peer to LedDigitMorph. The char 36 is SPACE.I can live outside of LedMorphs, however. If you'd like to play with me, evaluate the following line:LedCharacterMorph new char: $e; openInWorld!"MorphicExtras"!MorphTest removeSelector: #testOverlapAnyUnscriptedPlayer!MorphTest removeSelector: #testOverlapAnyScriptedPlayer!MorphTest removeSelector: #testOverlapAnyDeletedPlayer!MorphTest removeSelector: #testOverlapAny!!UTF16TextConverterTest methodsFor: 'testing' stamp: 'HenrikSperreJohansen 6/7/2010 15:03'!testByteOrders	|converter originalText bytes decodedText |	originalText := 'test'.	converter := UTF16TextConverter new.		"Default (ie useLittleEndian instvar nil)"	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		"Little-endian"	converter useLittleEndian: true.	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		"Big-endian"	converter useLittleEndian: false.	bytes := (originalText convertToWithConverter: converter).	decodedText := bytes convertFromWithConverter: converter.		self assert: originalText equals: decodedText.		! !"MultilingualTests"!!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 7/12/2010 18:54' prior: 34101734!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| urlString |	"Normalize the url"	urlString := (Url absoluteFromText: url) asString.	args ifNotNil: [		urlString := urlString, (self argString: args) 	].	^(self httpRequestHandler) 		httpRequest: 'GET' url: urlString headers:(			(mimeType ifNil:[''] ifNotNil:['Accept: ', mimeType, String crlf]),			'Accept: text/html', String crlf,			HTTPProxyCredentials,			HTTPBlabEmail,			requestString		) content: nil response: nil.! !!SocketStream methodsFor: 'initialize-release' stamp: 'ar 7/24/2010 15:13'!destroy	"Destroy the receiver and its underlying socket. Does not attempt to flush the output buffers. For a graceful close use SocketStream>>close instead."	socket ifNotNil:[socket destroy]! !!SocketStream methodsFor: 'control' stamp: 'ar 7/24/2010 14:48' prior: 52619090!flush	"If the other end is connected and we have something	to send, then we send it and reset the outBuffer."	((outNextToWrite > 1) and: [socket isOtherEndClosed not])		ifTrue: [			[self sendData: outBuffer count: outNextToWrite - 1]				on: ConnectionTimedOut				do: [:ex | shouldSignal ifFalse: ["swallow"]].			outNextToWrite := 1]! !!SocketStream methodsFor: 'testing' stamp: 'ar 7/24/2010 14:50' prior: 29500464!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we check the socket for data. If it claims to have data available to read, we try to read some once and recursively call this method again. If something really was available it is now in the inBuffer. This is because there has been spurious dataAvailable when there really is no data to get.	Note: Some subclasses (such as SecureSocketStream) rely on the behavior here since even though data may be available in the underlying socket, it may not result in any output (yet)." 	self isInBufferEmpty ifFalse: [^true].	^socket dataAvailable		ifFalse: [false]		ifTrue: [self receiveAvailableData; isDataAvailable]! !!SocketStream methodsFor: 'stream out' stamp: 'ar 7/24/2010 14:48' prior: 52611609!nextPutAllFlush: aCollection	"Put a String or a ByteArray onto the stream.	You can use this if you have very large data - it avoids	copying into the buffer (and avoids buffer growing)	and also flushes any other pending data first."	| toPut |	toPut := binary ifTrue: [aCollection asByteArray] ifFalse: [aCollection asString].	self flush. "first flush pending stuff, then directly send"	socket isOtherEndClosed ifFalse: [		[self sendData: toPut count: toPut size]			on: ConnectionTimedOut			do: [:ex | shouldSignal ifFalse: ["swallow"]]]! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07' prior: 52610836!receiveAvailableData	"Receive available data (as much as fits in the inBuffer) but not waiting for more to arrive. Return the position in the buffer where the new data starts, regardless if anything was read, see #adjustInBuffer."		recentlyRead := self receiveDataInto: inBuffer startingAt: inNextToWrite.	^self adjustInBuffer: recentlyRead! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:03' prior: 29504781!receiveData	"Receive data. Signal exceptions and timeouts depending on #shouldSignal and #shouldTimeout. Return the position in the buffer where the new data starts, regardless if anything was read."	socket		waitForDataFor: self timeout		ifClosed: [self shouldSignal 			ifTrue:[ConnectionClosed signal: 'Connection closed while waiting for data.']]		ifTimedOut: [self shouldTimeout			ifTrue:[ConnectionTimedOut signal: 'Data receive timed out.']].	^self receiveAvailableData! !!SocketStream methodsFor: 'control' stamp: 'ar 8/5/2010 12:23' prior: 29486984!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self isConnected and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50' prior: 52617013!receiveDataIfAvailable	"Deprecated. Use #receiveAvailableData instead"	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 15:07'!receiveDataInto: buffer startingAt: index.	"Read data from the underlying socket. This method may be overridden by subclasses wanting to control incoming traffic for other purposes like encryption or statistics."	^socket  receiveAvailableDataInto: buffer startingAt: index.! !!SocketStream methodsFor: 'private-socket' stamp: 'ar 7/24/2010 14:50'!sendData: buffer count: n	"Sends outgoing data directly on the underlying socket."	^socket sendData: buffer count: n! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50' prior: 52619519!upTo: aCharacterOrByte	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of anObject in the receiver. If  anObject is not in the collection, answer the entire rest of the receiver."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upTo: aCharacterOrByte limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upTo: aCharacterOrByte limit: nBytes	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"	| index result searchedSoFar |	"Look in the current inBuffer first"	index := inBuffer indexOf: aCharacterOrByte startingAt: lastRead + 1.	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: 1.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	"We only get recentlyRead = 0 in the case of a non-signaling socket close."	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset."		index := inBuffer indexOf: aCharacterOrByte						startingAt: (lastRead + searchedSoFar + 1).		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:48' prior: 52614582!upToAll: aStringOrByteArray	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	"Note: The 100k limit below is compatible with the previous version though arguably incorrect. If you need unbounded behavior either up the argument or provide nil in which case we'll read until we get it or run out of memory"	^self upToAll: aStringOrByteArray limit: 100000! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/2/2010 18:50'!upToAll: aStringOrByteArray limit: nBytes	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"	| index sz result searchedSoFar |	sz := aStringOrByteArray size.	"Look in the current inBuffer first"	index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: lastRead - sz + 2.	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: sz.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset and 		backs up sz - 1 so that we can catch any borderline hits."		index := inBuffer indexOfSubCollection: aStringOrByteArray						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/5/2010 12:23' prior: 29497260!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself.		NOTE: Does not honour timeouts if shouldSignal is false!!"	[[self isConnected] whileTrue: [self receiveData]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !"Network"!!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 18:10'!setUp	| listener clientSocket serverSocket |	listener := Socket newTCP.	[listener listenOn: 0 backlogSize: 4.	clientSocket := Socket newTCP.	clientSocket connectTo: #[127 0 0 1] port: listener localPort.	clientSocket waitForConnectionFor: 1.	self assert: clientSocket isConnected.	serverSocket := listener waitForAcceptFor: 1.	self assert: serverSocket isConnected.	] ensure:[listener destroy].	clientStream := SocketStream on: clientSocket.	serverStream := SocketStream on: serverSocket.! !!SocketStreamTest methodsFor: 'setup' stamp: 'ar 8/2/2010 17:59'!tearDown	clientStream ifNotNil:[clientStream destroy].	serverStream ifNotNil:[serverStream destroy].! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoClose	"Ensure that #next:into: will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testNextIntoCloseNonSignaling	"Ensure that #next:into: will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream next: 100 into: (String new: 100) startingAt: 1)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpTo	"Tests correct behavior of #upTo:"	clientStream nextPutAll:'A line of text', String cr, 'with more text'; flush.	self assert: (serverStream upTo: Character cr) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String cr; flush] fork.	self assert: (serverStream upTo: Character cr) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upTo: Character cr] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upTo: Character cr] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:29'!testUpToAll	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text', String crlf, 'with more text'; flush.	self assert: (serverStream upToAll: String crlf) = 'A line of text'.	[(Delay forSeconds: 1) wait.	clientStream nextPutAll: String crlf; flush] fork.	self assert: (serverStream upToAll: String crlf) = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:02'!testUpToAllAfterCloseNonSignaling	"Tests correct behavior of #upToAll"	| resp |	clientStream nextPutAll: 'A line of text'.	clientStream close.	serverStream shouldSignal: false.	self shouldnt: [resp := serverStream upToAll: String crlf] raise: ConnectionClosed.	self assert: resp = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:26'!testUpToAllAfterCloseSignaling	"Tests correct behavior of #upToAll"	clientStream nextPutAll:'A line of text'.	clientStream close.	self should: [serverStream upToAll: String crlf] raise: ConnectionClosed.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:48'!testUpToAllLimit	"Tests correct behavior of #upToAll:limit:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upToAll: String crlf limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:11'!testUpToAllTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upToAll: String crlf] raise: ConnectionTimedOut.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testUpToEndClose	"Ensure that #upToEnd will function properly when the connection is closed"	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd) 		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/5/2010 12:20'!testUpToEndCloseNonSignaling	"Ensure that #upToEnd will function properly when the connection is closed"	serverStream shouldSignal: false.	clientStream nextPutAll:'A line of text'; flush.	[(Delay forMilliseconds: 100) wait.	clientStream close] fork.	self assert: (serverStream upToEnd)		equals: 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:49'!testUpToMax	"Tests correct behavior of #upToAll:max:"	clientStream nextPutAll:'A line of text'; flush.	self assert: (serverStream upTo: Character cr limit: 5) = 'A line of text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/2/2010 18:32'!testUpToTimeout	"Tests correct behavior of #upToAll"	clientStream nextPutAll: 'A line of text'.	serverStream timeout: 1.	self should: [serverStream upTo: Character cr] raise: ConnectionTimedOut.! !"NetworkTests"!!ParagraphEditor methodsFor: 'explain' stamp: 'eem 8/14/2010 11:15' prior: 53527614!explainTemp: string 	"Is string the name of a temporary variable (method or block argument or temporary)?"	| selectedClass methodNode tempNode |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	model selectedMessageName ifNil: [^nil].	"not in a method"	selectedClass := model selectedClassOrMetaClass.	methodNode := selectedClass parserClass new parse: model selectedMessage class: selectedClass.	tempNode := methodNode encoder tempNodes detect: [:n| n name = string] ifNone: [^nil].	^(tempNode isArg		ifTrue: ['"is an argument to this ']		ifFalse: ['"is a temporary variable in this ']),	   (tempNode isDeclaredAtMethodLevel		ifTrue: ['method"']		ifFalse: ['block"'])! !"ST80"!!FFT methodsFor: 'bulk processing' stamp: 'ul 8/3/2010 15:43' prior: 20330288!transformDataFrom: anIndexableCollection startingAt: index	"Forward transform a block of real data taken from from the given indexable collection starting at the given index. Answer a block of values representing the normalized magnitudes of the frequency components."	| j real imag out |	j := 0.	index to: index + n - 1 do: [:i |		realData at: (j := j + 1) put: (anIndexableCollection at: i)].	realData *= window.	imagData := FloatArray new: n.	self transformForward: true.	"compute the magnitudes of the complex results"	"note: the results are in bottom half; the upper half is just its mirror image"	real := realData copyFrom: 1 to: (n / 2).	imag := imagData copyFrom: 1 to: (n / 2).	out := (real * real) + (imag * imag).	1 to: out size do: [:i | out at: i put: (out at: i) sqrt].	^ out! !!FFT methodsFor: 'transforming' stamp: 'ul 8/3/2010 15:43' prior: 20336130!transformForward: forward	| lev lev1 ip theta realU imagU realT imagT i |	<primitive: 'primitiveFFTTransformData' module: 'FFTPlugin'>	self permuteData.	1 to: nu do:		[:level |		lev := 1 bitShift: level.		lev1 := lev // 2.		1 to: lev1 do:			[:j |			theta := j-1 * (n // lev).   "pi * (j-1) / lev1 mapped onto 0..n/2"			theta < (n//4)  "Compute U, the complex multiplier for each level"				ifTrue:					[realU := sinTable at: sinTable size - theta.					imagU := sinTable at: theta + 1]				ifFalse:					[realU := (sinTable at: theta - (n//4) + 1) negated.					imagU := sinTable at: (n//2) - theta + 1].			forward ifFalse: [imagU := imagU negated]."			Here is the inner loop...			j to: n by: lev do:				[:i |   hand-transformed to whileTrue..."			i := j.			[i <= n] whileTrue:				[ip := i + lev1.				realT := ((realData at: ip) * realU) - ((imagData at: ip) * imagU).				imagT := ((realData at: ip) * imagU) + ((imagData at: ip) * realU).				realData at: ip put: (realData at: i) - realT.				imagData at: ip put: (imagData at: i) - imagT.				realData at: i put: (realData at: i) + realT.				imagData at: i put: (imagData at: i) + imagT.				i := i + lev]]].	forward ifFalse: [self scaleData]  "Reverse transform must scale to be an inverse"! !"Sound"!!LangEnvBugs methodsFor: 'as yet unclassified' stamp: 'ar 7/21/2010 20:13' prior: 22448460!testIsFontAvailable	"self new testIsFontAvailable"	"self run: #testIsFontAvailable"	| oldPref |	oldPref := Preferences valueOfPreference: #tinyDisplay.	Preferences restoreFontsAfter:[	[Preferences enable: #tinyDisplay .	self 		shouldnt:[(LanguageEnvironment localeID: 'en' ) isFontAvailable] 		raise: Error.	] ensure: [Preferences setPreference: #tinyDisplay toValue: oldPref].	].! !!HexTest methodsFor: 'as yet unclassified' stamp: 'eem 5/21/2010 11:12' prior: 21544180!testIntegerHex	| result |	result := 15 asInteger hex.	self assert: result = '16rF'.	result := 0 asInteger hex.	self assert: result = '16r0'.	result := 255 asInteger hex.	self assert: result = '16rFF'.	result := 90 asInteger hex.	self assert: result = '16r5A'! !!MirrorPrimitiveTests methodsFor: 'testing' stamp: 'eem 7/6/2010 20:44' prior: 57226887!expectedFailures	^Smalltalk isRunningCog		ifTrue: [#()]		ifFalse: [#(testMirrorAt testMirrorEqEq testMirrorInstVarAt testMirrorPerform testMirrorSize)]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:33'!testOptimizedBlockLocalNilling1	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 3 do: [:i| | j |		self assert: j isNil.		j := i + 1.		self assert: j isNil not]! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'eem 9/5/2009 17:32'!testOptimizedBlockLocalNilling2	"Whether a block is optimized or not a block-local temp	 should be nil at the start of each evaluation of the block."	1 to: 6 do: [:i| | j k |		self assert: j isNil.		self assert: k isNil.		i even			ifTrue: [j := i + 2]			ifFalse: [k := i + 1].		self assert: (j isNil or: [k isNil]).		self assert: (j isNil not or: [k isNil not])]! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:42' prior: 34021280!expectedFailures	"Does crash VM with Cog"	^Smalltalk isRunningCogit		ifTrue:[#(testAddNumbers testDNU testAnswer42)]		ifFalse:[#()]! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43' prior: 34021519!testAddNumbers 	"self debug: #testAddNumbers"	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	"md: I had to comment out the error... did strange things"	self class addSelector: #add:with: withMethod: ObjectsAsMethodsExample new.	self assert: (self add: 3 with: 4) = 7.	"self assert: (self perform: #add:with: withArguments: #(3 4)) = 7. "	self class basicRemoveSelector: #add:with:.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43' prior: 34022046!testAnswer42 	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: ObjectsAsMethodsExample new.	self assert: self answer42 = 42.	self class basicRemoveSelector: #answer42.! !!TestObjectsAsMethods methodsFor: 'as yet unclassified' stamp: 'eem 7/6/2010 20:43' prior: 34022400!testDNU 	"Does crash VM with Cog"	Smalltalk isRunningCogit ifTrue:[^self assert: false].	self class addSelector: #answer42 withMethod: AbstractObjectsAsMethod new.	self should: [self answer42] raise: MessageNotUnderstood.	self class basicRemoveSelector: #answer42.! !!LocaleTest methodsFor: 'testing' stamp: 'ar 7/21/2010 20:14' prior: 57142235!testIsFontAvailable	"self debug: #testIsFontAvailable"	Preferences restoreFontsAfter:[		(Locale isoLanguage: 'ja') languageEnvironment removeFonts.		self assert: (Locale isoLanguage: 'en') languageEnvironment isFontAvailable.		"Next test should fail after installing Japanese font"		self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable not.		(Locale isoLanguage: 'ja') languageEnvironment installFont.		self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable.	].! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'ar 7/22/2010 19:44'!testUIManagerNoAcceptInitially	"Ensure that UIManager does not invoke the accept: action initially."	| accepted window |	accepted := false.	window := UIManager default edit: Text new label: 'Test' accept: [:val| accepted := true].	window delete.	self deny: accepted.! !!StandardSystemFontsTest methodsFor: 'testing' stamp: 'ar 7/21/2010 20:14' prior: 59167794!testRestoreDefaultFonts	Preferences restoreFontsAfter: [		Preferences restoreDefaultFonts.		self assert: #standardDefaultTextFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardListFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardFlapFont familyName: 'Accushi' pointSize: 12.		self assert: #standardEToysFont familyName: 'BitstreamVeraSans' pointSize: 9.		self assert: #standardMenuFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #windowTitleFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardBalloonHelpFont familyName: 'Accujen' pointSize: 9.		self assert: #standardCodeFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardButtonFont familyName: 'BitstreamVeraSansMono' pointSize: 9]! !StandardSystemFontsTest removeSelector: #saveStandardSystemFontsDuring:!DecompilerTests removeSelector: #expectedFailures!"Tests"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'ar 7/22/2010 14:27' prior: 34024621!edit: aText label: labelString accept: anAction	"Open an editor on the given string/text"	| window |	window := Workspace open.	labelString ifNotNil: [ window setLabel: labelString ].	"By default, don't style in UIManager edit: requests"	window model		shouldStyle: false;		acceptContents:  aText;		acceptAction: anAction.	^window.! !"ToolBuilder-Morphic"!!Debugger commentStamp: '<historical>' prior: 59270384!I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !!ChangesOrganizer commentStamp: 'cbr 7/27/2010 19:17' prior: 59239452!I manage ChangeSets in the system. See the protocols on my class side.For an example of what I can do, select the following line in a Workspace and print it.ChangesOrganizer allChangeSetNames!!ChangeList methodsFor: 'menu actions' stamp: 'eem 7/22/2010 13:40' prior: 34058687!selectUnchangedDefinitions	"Selects all recognizable definitions for which there is already a definition in the current image, whose source is exactly the same."	| change class tokens |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | change := changeList at: i.		listSelections at: i put: false.		(change type = #method		 and: [(class := change methodClass) notNil		 and: [class includesSelector: change methodSelector]]) ifTrue:			[listSelections				at: i				put: change string withBlanksCondensed					= (class sourceCodeAt: change methodSelector) asString withBlanksCondensed].		(change type == #classComment		and: [(class := change commentClass) notNil]) ifTrue:			[listSelections at: i put: change string = class comment asString].		change type == #doIt ifTrue:			[tokens := Scanner new scanTokens: change string.			 ((tokens select:				[:substr| #(subclass: variableSubclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3			 and: [(class := Smalltalk at: tokens third ifAbsent: []) notNil			 and: [class isBehavior]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class definition withBlanksCondensed].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #instanceVariableNames:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) notNil			 and: [class isBehavior]]]]) ifTrue:				[listSelections					at: i					put: change string withBlanksCondensed						= class class definition withBlanksCondensed].			(tokens size = 3			 and: [tokens second == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class includesSelector: tokens third) not]]]]) ifTrue:				[listSelections at: i put: true].			(tokens size = 4			 and: [tokens second == #class			 and: [tokens third == #removeSelector:			 and: [(class := Smalltalk at: tokens first ifAbsent: []) isNil			 	or: [class isBehavior and: [(class class includesSelector: tokens fourth) not]]]]]) ifTrue:				[listSelections at: i put: true]]]].	self changed: #allSelections! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:36' prior: 34046085!multiWindowName	"Answer the string to display for the receiver in a multi-window."	^String streamContents:		[:s| | str |		self package			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 self selectedClass					ifNil: [self selectedSystemCategoryName							ifNil: [s nextPutAll: pkg]							ifNotNil: [:cat| s nextPutAll: cat]]					ifNotNil:						[:class|						 s nextPutAll: pkg; space; print: class.						 self metaClassIndicated ifTrue:							[s nextPutAll: ' class']]].		(str := self selectedMessageName) notNil			ifTrue: [s nextPutAll: '>>'; nextPutAll: str]			ifFalse:				[(str := self selectedMessageCategoryName) notNil					ifTrue: [s space; nextPut: ${; nextPutAll: str; nextPut: $}]]]! !!PackagePaneBrowser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:31'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'restoreToPackage:')			ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]			ifNotNil:				[:pkg|				 s nextPutAll: pkg.				(getarg value: 'className:')					ifNil: [(getarg value: 'category:') ifNotNil:							[:categoryName| s nextPut: $-; nextPutAll: categoryName]]					ifNotNil:						[:className|						s space; nextPutAll: className.						(getarg value: 'meta:') ifTrue:							[s nextPutAll: ' class'].						  self isHierarchy ifTrue:							[s space; nextPutAll: ' Hierarchy'].						(getarg value: 'selector:')							ifNil: [(getarg value: 'protocol:') ifNotNil:									[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]							ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]]! !!Browser methodsFor: 'multi-window support' stamp: 'eem 8/11/2010 13:23'!multiWindowNameForState: savedStateMessage	"Answer the string to display for the receiver in a multi-window."	| getarg |	getarg := [:keyword| savedStateMessage arguments at: (savedStateMessage selector keywords indexOf: keyword)].	^String streamContents:		[:s|		(getarg value: 'className:')			ifNil: [(getarg value: 'restoreToCategory:')					ifNil: [s nextPut: $a; space; nextPutAll: self defaultBrowserTitle]					ifNotNil: [:categoryName| s nextPutAll: categoryName]]			ifNotNil:				[:className|				s nextPutAll: className.				(getarg value: 'meta:') ifTrue:					[s nextPutAll: ' class'].				  self isHierarchy ifTrue:					[s space; nextPutAll: ' Hierarchy'].				(getarg value: 'selector:')					ifNil: [(getarg value: 'protocol:') ifNotNil:							[:protocol| s space; nextPut: ${; nextPutAll: protocol; nextPut: $}]]					ifNotNil: [:selector| s nextPutAll: '>>'; nextPutAll: selector]]]! !!SelectorBrowser methodsFor: 'as yet unclassified' stamp: 'nice 8/19/2010 14:08' prior: 54384128!contents: aString notifying: aController	"Take what the user typed and find all selectors containing it"	| tokens |	contents := aString.	classList := #().  classListIndex := 0.	selectorIndex := 0.	tokens := contents asString findTokens: ' .'.	selectorList := Cursor wait showWhile: [		tokens size = 1 			ifTrue: [(Symbol selectorsContaining: contents asString) asArray				sort: [:x :y | x asLowercase <= y asLowercase]]			ifFalse: [self quickList]].	"find selectors from a single example of data"	self changed: #messageList.	self changed: #classList.	^ true! !!CodeHolder methodsFor: 'misc' stamp: 'topa 7/14/2010 16:35'!informPossiblyCorruptSource	| sourcesName |	sourcesName := FileDirectory localNameFor: SmalltalkImage current sourcesName.	self inform: 'There may be a problem with your sources file!!The source code for every method should (usually) start with themethod selector but this is not the case with this method!! You mayproceed with caution but it is recommended that you get a new source file.This can happen if you download the "' , sourcesName  , '" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.(Occasionally, the source code for a method may legitimatelystart with a non-alphabetic character -- for example, Behaviormethod #formalHeaderPartsFor:.  In such rare cases, you canhappily disregard this warning.)'! !!CodeHolder methodsFor: 'message list' stamp: 'topa 7/14/2010 16:47' prior: 50670096!sourceStringPrettifiedAndDiffed	"Answer a copy of the source code for the selected message, transformed by diffing and pretty-printing exigencies"	| class selector sourceString |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	(class isNil or: [selector isNil]) ifTrue: [^'missing'].	sourceString := class ultimateSourceCodeAt: selector ifAbsent: [^'error'].	self validateMessageSource: sourceString forSelector: selector inClass: class.	(#(#prettyPrint #prettyDiffs) 		includes: contentsSymbol) 			ifTrue: 				[sourceString := class prettyPrinterClass 							format: sourceString							in: class							notifying: nil].	self showingAnyKindOfDiffs 		ifTrue: [sourceString := self diffFromPriorSourceFor: sourceString].	^sourceString! !!CodeHolder methodsFor: 'message list' stamp: 'topa 7/14/2010 16:46'!validateMessageSource: sourceString forSelector: aSelector inClass: theClass	"Check whether there is evidence that method source is invalid"	(theClass parserClass new parseSelector: sourceString asString) = aSelector		ifFalse: [self informPossiblyCorruptSource].! !!Debugger class methodsFor: 'private' stamp: 'eem 7/26/2010 18:01'!ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess	| sema |	errorWasInUIProcess ifTrue:		[^self].	self interruptUIProcessIfBlockedOnErrorInBackgroundProcess ifFalse:		[^self].	"Only interrupt the UI if it is unresponsive (and so is doing something that needs	 interrupting).  Test using addDeferredUIMessage: to see if it is running UI activities."	sema := Semaphore new.	Project current addDeferredUIMessage: [sema signal].	(sema waitTimeoutMSecs: 100) ifTrue:		[[Project current interruptName: 'Interrupt from Background Error'] fork]	"| s |	s := Semaphore new.	[self assert: 0 > 1000. s signal] fork.	s wait"! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:52'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess	<preference: 'Interrupt UI process on background error'		category: 'debug'		description: 'When enabled, the debugger will interrupt the UI process if an error occurs in a background process and the UI process is blocked.'		type: #Boolean>	^InterruptUIProcessIfBlockedOnErrorInBackgroundProcess ifNil: [false]! !!Debugger class methodsFor: 'preferences' stamp: 'eem 7/26/2010 15:53'!interruptUIProcessIfBlockedOnErrorInBackgroundProcess: aBoolean	InterruptUIProcessIfBlockedOnErrorInBackgroundProcess := aBoolean! !!Debugger class methodsFor: 'opening' stamp: 'eem 7/26/2010 15:51' prior: 19607647!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller errorWasInUIProcess block |	Smalltalk isMorphic		ifTrue: [errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: process]		ifFalse: [controller := ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController]].	block := [ 		[	| debugger |			debugger := self new process: process controller: controller context: context.			Smalltalk isMorphic				ifTrue: ["schedule debugger in deferred UI message to address redraw						problems after opening a debugger e.g. from the testrunner."					"WorldState addDeferredUIMessage: ["bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]]				ifFalse: ["deferred UI message would require special controller in MVC"					bool						ifTrue: [debugger openFullNoSuspendLabel: title]						ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title]].			debugger errorWasInUIProcess: errorWasInUIProcess.			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].			Smalltalk isMorphic				ifFalse: [ScheduledControllers searchForActiveController "needed since openNoTerminate (see debugger #open...) does not set up activeControllerProcess if activeProcess (this fork) is not the current activeControllerProcess (see #scheduled:from:)"].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	self ifPreferredInterruptUIProcessIfBlocked: errorWasInUIProcess.	Project current addDeferredUIMessage: block.	process suspend! !!Debugger methodsFor: 'accessing' stamp: 'abc 2/12/2010 15:02' prior: 53617029!debuggerMap	^self selectedContext debuggerMap! !!SavedMultiWindowState methodsFor: 'operations' stamp: 'eem 8/11/2010 13:27' prior: 34044380!selectWindowsMenu	| menu currentItem |	menu := MenuMorph new defaultTarget: self.	models withIndexDo:		[:model :index| | modelLabel |		modelLabel := index = currentModelIndex							ifTrue: [model multiWindowName]							ifFalse: [model multiWindowNameForState: (modelStates at: index) first].		models size > 1 ifTrue:			[modelLabel := index printString, '. ', modelLabel].		menu			add: (index = currentModelIndex					ifTrue: [Text string: modelLabel attribute: TextEmphasis bold]					ifFalse:						[((modelStates at: index) last anySatisfy: [:editState| editState notNil])							ifTrue: [Text string: modelLabel attribute: TextColor red]							ifFalse: [modelLabel]])			target: self			selector: #selectWindowIndex:			argument: index.		index = currentModelIndex ifTrue:			[currentItem := menu lastItem]].	menu		addLine;		add: 'new window' target: self selector: #addNewWindow;		add: 'copy this window' target: self selector: #copyWindow;		add: 'remove this window' target: self selector: #removeCurrentWindow.	models size <= 1 ifTrue:		[menu lastItem isEnabled: false].	menu selectItem: currentItem event: nil.	^menu! !CodeHolder removeSelector: #validateMessageSource:forSelector:!"Tools"!!XMLElement methodsFor: 'testing' stamp: 'ar 8/10/2010 13:19' prior: 54448258!isEmpty	"Answer true if the receiver is empty"	^self elementsAndContents isEmpty! !!XMLElement methodsFor: 'printing' stamp: 'ar 8/10/2010 13:21' prior: 54448700!printXMLOn: writer	"Print the receiver in XML form"	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self elementsAndContentsDo: [:content | content printXMLOn: writer].			writer endTag: self name]! !!XMLParserTest methodsFor: 'tests' stamp: 'ar 8/10/2010 13:25'!testPrintElements	| node |	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo/>'.	node:= (XMLElement new) name: 'foo';		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123"/>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary new);		yourself.	self assert: node asString withBlanksTrimmed = '<foo>Hello World</foo>'.	node:= (XMLElement new) name: 'foo';		addContent: (XMLStringNode string: 'Hello World'); 		setAttributes: (Dictionary newFromPairs: {'id'. '123'});		yourself.	self assert: node asString withBlanksTrimmed = '<foo id="123">Hello World</foo>'.! !"XML-Parser"!!HelpBrowser methodsFor: 'stepping' stamp: 'tbn 8/19/2010 09:47'!step	 "Do nothing when the window dispatches stepping back to the model"! !"HelpSystem-Core"!----SNAPSHOT----{19 August 2010 . 7:11:15 pm} Squeak4.2-10160-alpha.image priorSource: 326363!----STARTUP----{19 August 2010 . 7:36:35 pm} as /Users/casey/Desktop/Squeak4.2-10160-alpha/Squeak4.2-10160-alpha.image!----SNAPSHOT----{19 August 2010 . 7:37:29 pm} Squeak4.2-10382-alpha.image priorSource: 763601!----QUIT/NOSAVE----{19 August 2010 . 7:37:44 pm} Squeak4.2-10382-alpha.image priorSource: 763819!----STARTUP----{21 September 2010 . 7:02:20 pm} as /Users/casey/Desktop/Squeak4.2-10382-alpha/Squeak4.2-10382-alpha.image!!Heap methodsFor: 'enumerating' stamp: 'nice 8/21/2010 15:40'!collect: aBlock	^self collect: aBlock as: Array! !!Heap methodsFor: 'copying' stamp: 'nice 8/21/2010 15:53'!copyEmpty	"Answer a copy of the receiver without any of the receiver's elements."	^self class sortBlock: sortBlock! !!Heap methodsFor: 'enumerating' stamp: 'nice 8/21/2010 15:49'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true."	| newCollection |	newCollection := self copyEmpty.	self do:		[:each |		(aBlock value: each)			ifTrue: [newCollection add: each]].	^ newCollection! !Heap removeSelector: #species!"Collections"!!HeapTest methodsFor: 'testing' stamp: 'nice 8/21/2010 16:33'!testIfEqualIsTransitive	"This is http://bugs.squeak.org/view.php?id=6943"    | anArray heap1 heap2 |    anArray := #(1 2 3).    heap1 := Heap withAll: (1 to: 3) sortBlock: [:a :b | a < b].    heap2 := Heap withAll: (1 to: 3) sortBlock: [:a :b | b > a].    self		assert: (heap1 = anArray) & (heap2 = anArray) ==> (heap1 = heap2)		description: 'Heap equality should be transitive'! !!HeapTest methodsFor: 'basic tests' stamp: 'nice 8/21/2010 16:11' prior: 21543180!testSortBlock	"self run: #testSortBlock"	| heap |	heap := Heap withAll: #(1 3 5).	self assert: heap asArray = #(1 3 5).		heap sortBlock: [ :e1 :e2 | e1 >= e2 ].	self assert: heap asArray = #(5 3 1)! !IntervalTest removeSelector: #testEquals6!IntervalTest removeSelector: #testEquals5!"CollectionsTests"!!WeakMessageSend methodsFor: 'converting' stamp: 'jmv 5/13/2009 10:19' prior: 33145124!asMinimalRepresentation	^self isReceiverOrAnyArgumentGarbage		ifTrue: [ nil ]		ifFalse: [ self ]! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:21' prior: 33145298!value	^self valueOtherwise: []! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nice 8/22/2010 17:26'!valueOtherwise: aBlock	^ arguments		ifNil: [			self withEnsuredReceiverDo: [ :r | r perform: selector ] otherwise: [ aBlock value ]]		ifNotNil: [			self				withEnsuredReceiverAndArgumentsDo: [ :r :a |					r						perform: selector						withArguments: a ]				otherwise: [ aBlock value ]]! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:21' prior: 33145645!valueWithArguments: anArray	^ self valueWithArguments: anArray otherwise: []! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:12'!valueWithArguments: anArray otherwise: aBlock	| argsToUse |		"Safe to use, because they are built before ensureing receiver and args..."	argsToUse := self collectArguments: anArray.	^ self		withEnsuredReceiverAndArgumentsDo: [ :r :a |			r				perform: selector				withArguments: argsToUse ]		otherwise: [ aBlock value ]! !!WeakMessageSend methodsFor: 'private' stamp: 'jmv 5/14/2009 10:03'!withEnsuredReceiverAndArgumentsDo: aBlock otherwise: altBlock	"Grab real references to receiver and arguments. If they still exist, evaluate aBlock."	"Return if my receiver has gone away"	| r a |	r := self receiver.	r ifNil: [ ^altBlock value ].		"Make sure that my arguments haven't gone away"	a := Array withAll: arguments.	a with: shouldBeNil do: [ :arg :flag |		arg ifNil: [ flag ifFalse: [ ^altBlock value ]]	].	^aBlock value: r value: a! !!WeakMessageSend methodsFor: 'private' stamp: 'nice 8/22/2010 17:27'!withEnsuredReceiverDo: aBlock otherwise: altBlock	"Grab a real reference to receive. If still there, evaluate aBlock.	Use altBlock if my receiver has gone away."	^self receiver		ifNil: [ altBlock value ]		ifNotNil: [:r | aBlock value: r ]! !!WeakActionSequence methodsFor: 'converting' stamp: 'jmv 5/13/2009 10:20' prior: 33124129!asMinimalRepresentation	| valid |	valid := self reject: [:e | e isReceiverOrAnyArgumentGarbage ].	valid size = 0		ifTrue: [ ^nil ].	valid size = 1		ifTrue: [ ^valid first ].	^valid! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'nice 8/22/2010 21:05' prior: 33124370!value	"Answer the result of evaluating the elements of the receiver.	Actually, return just the last result."	^self inject: nil into: [ :previousAnswer :each | 		each valueOtherwise: [ previousAnswer ]].! !!WeakActionSequence methodsFor: 'evaluating' stamp: 'nice 8/22/2010 21:02' prior: 33124666!valueWithArguments: anArray	"Return the last result"	^self inject: nil into: [ :previousAnswer :each |		each valueWithArguments: anArray otherwise: [ previousAnswer ]]! !!Categorizer methodsFor: 'accessing' stamp: 'nice 8/19/2010 21:26' prior: 50571543!sortCategories	| privateCategories publicCategories newCategories |	privateCategories := self categories select:		[:one | (one findString: 'private' startingAt: 1 caseSensitive: false) = 1].	publicCategories := self categories copyWithoutAll: privateCategories.	newCategories := publicCategories asArray sort , privateCategories asArray sort.	self categories: newCategories! !!BlockClosure methodsFor: 'evaluating' stamp: 'ul 8/2/2010 19:40' prior: 50398415!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver, and normally return it's value.  If an error occurs, the errorHandlerBlock is evaluated, and it's value is instead returned.  The errorHandlerBlock must accept zero, one, or two parameters (the error message and the receiver)."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | 'huh?'].		[1 / 0] ifError: [:err :rcvr |			'ZeroDivide' = err				ifTrue: [Float infinity]				ifFalse: [self error: err]]"	^ self on: Error do: [:ex |		errorHandlerBlock cull: ex description cull: ex receiver ]! !!BlockClosure methodsFor: 'exceptions' stamp: 'ul 8/12/2010 00:07' prior: 50404114!onDNU: selector do: handleBlock	"Catch MessageNotUnderstood exceptions but only those of the given selector (DNU stands for doesNotUnderstand:)"	^ self on: MessageNotUnderstood do: [:exception |		exception message selector = selector			ifTrue: [handleBlock cull: exception]			ifFalse: [exception pass]	  ]! !!Object methodsFor: 'events-accessing' stamp: 'jmv 5/13/2009 10:14' prior: 24960894!actionForEvent: anEventSelector    "Answer the action to be evaluated when <anEventSelector> has been triggered."	^self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil]! !!Object methodsFor: 'events-accessing' stamp: 'nice 8/22/2010 20:57' prior: 24961232!actionForEvent: anEventSelectorifAbsent: anExceptionBlock    "Answer the action to be evaluated when <anEventSelector> has been triggered."	| actions |	actions := self actionMap		at: anEventSelector asSymbol		ifAbsent: [nil].	^actions ifNil: [anExceptionBlock value]! !!Object methodsFor: 'events-accessing' stamp: 'jmv 5/13/2009 10:16' prior: 24962452!setActionSequence: actionSequenceforEvent: anEventSelector	| action |	"This is a good time to compact the action sequence of old, garbage collected stuff."	action := actionSequence asMinimalRepresentation.	action		ifNil: [ self removeActionsForEvent: anEventSelector]		ifNotNil: [			self updateableActionMap				at: anEventSelector asSymbol				put: action]! !!MessageSend methodsFor: 'private' stamp: 'jmv 5/14/2009 09:54'!isReceiverOrAnyArgumentGarbage	^false! !!MessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:11'!valueOtherwise: aBlock	"Send the message and answer the return value"	^self value! !!MessageSend methodsFor: 'evaluating' stamp: 'jmv 5/14/2009 10:22'!valueWithArguments: anArray otherwise: aBlock	^ self valueWithArguments: anArray! !!Float methodsFor: 'arithmetic' stamp: 'nice 8/21/2010 22:31' prior: 20878637!abs	"This is faster than using Number abs and works for negativeZero."	self <= 0.0		ifTrue: [^ 0.0 - self]		ifFalse: [^ self]! !!ContextPart methodsFor: 'private-exceptions' stamp: 'ul 8/2/2010 19:37' prior: 50811097!handleSignal: exception	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."	| val |	(((self tempAt: 1) handles: exception) and: [self tempAt: 3]) ifFalse: [		^ self nextHandlerContext handleSignal: exception].	exception privHandlerContext: self contextTag.	self tempAt: 3 put: false.  "disable self while executing handle block"	val := [(self tempAt: 2) valueWithPossibleArgument: exception ]		ensure: [self tempAt: 3 put: true].	self return: val.  "return from self if not otherwise directed in handle block"! !!ClassDescription methodsFor: 'accessing method dictionary' stamp: 'nice 8/19/2010 16:32' prior: 54720589!allMethodCategoriesIntegratedThrough: mostGenericClass	"Answer a list of all the method categories of the receiver and all its superclasses, up through mostGenericClass"	| aColl |	aColl := OrderedCollection new.	self withAllSuperclasses do:		[:aClass |			(aClass includesBehavior: mostGenericClass)				ifTrue:	[aColl addAll: aClass organization categories]].	aColl remove: 'no messages' asSymbol ifAbsent: [].	^aColl asSet asArray sort: [:a :b | a asLowercase < b asLowercase]"ColorTileMorph allMethodCategoriesIntegratedThrough: TileMorph"! !!ProtoObject methodsFor: 'testing' stamp: 'ul 8/12/2010 00:04' prior: 52246958!ifNil: nilBlock ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!ProtoObject methodsFor: 'testing' stamp: 'ul 8/12/2010 00:04' prior: 52247178!ifNotNil: ifNotNilBlock	"Evaluate the block, unless I'm == nil (q.v.)"	^ ifNotNilBlock cull: self! !!ProtoObject methodsFor: 'testing' stamp: 'ul 8/12/2010 00:04' prior: 52246718!ifNotNil: ifNotNilBlock ifNil: nilBlock 	"If I got here, I am not nil, so evaluate the block ifNotNilBlock"	^ ifNotNilBlock cull: self! !"Kernel"!!BlockNode methodsFor: 'code generation (closures)' stamp: 'nice 8/19/2010 16:31' prior: 50452197!computeCopiedValues: rootNode	| referencedValues |	referencedValues := rootNode referencedValuesWithinBlockExtent: blockExtent.	^(referencedValues reject: [:temp| temp isDefinedWithinBlockExtent: blockExtent])		asArray sort: ParseNode tempSortBlock! !"Compiler"!!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'nice 8/19/2010 16:42' prior: 55229303!testAllMethodsOver: methodSize 	"MessageTally spyOn: [SyntaxMorph testAllMethodsOver: 600]"	"Add up the total layout area for syntax morphs representing all  	methods over the given size. This is a stress-test for SyntaxMorph  	layout. A small value for the total area is also a figure of merit in the  	presentation of Squeak source code in general."	"Results:  	#(69 600 180820874 103700) 11/4  	70% build morphs, 12% get source, 9% layout, 8% parse, 1% roundoff  	Folded wide receivers, don't center keywords any more.  	#(68 600 160033784 127727) 11/9  	76% build morphs, 8% get source, 8% layout, 8% parse, 0% roundoff  	Folded more messages, dropped extra vertical spacing in blocks.  	#(68 600 109141704 137308) 11/10  	79% build morphs, 6% get source, 8% layout, 7% parse  	Folded more messages, dropped extra horizontal spacing.  	#(68 600 106912968 132171) 11/10  	80% build morphs, ??% get source, 11% layout, 7% parse  	Unfolded keyword messages that will fit on one line.  	#(68 600 96497372 132153) 11/10  	81% build morphs, ??% get source, 8% layout, 8% parse  	After alignment rewrite...  	#(74 600 101082316 244799) 11/12  	76% build morphs, 4% get source, 15% layout, 5% parse  	After alignment rewrite...  	#(74 600 101250620 204972) 11/15  	74% build morphs, 6% get source, 13% layout, 7% parse  	"	| biggies stats area |	biggies := self systemNavigation 				allMethodsSelect: [:cm | cm size > methodSize].	stats := OrderedCollection new.	'Laying out all ' , biggies size printString , ' methods over ' , methodSize printString , ' bytes...'		displayProgressAt: Sensor cursorPoint		from: 1		to: biggies size		during: [:bar | biggies				withIndexDo: [:methodRef :i | | time | 					bar value: i.					Utilities						setClassAndSelectorFrom: methodRef						in: [:aClass :aSelector | | source | 							source := (aClass compiledMethodAt: aSelector) getSourceFromFile.							time := Time										millisecondsToRun: [ | tree morph |											tree := Compiler new														parse: source														in: aClass														notifying: nil.											morph := tree asMorphicSyntaxUsing: SyntaxMorph.											area := morph fullBounds area]].					stats add: {methodRef. area. time}]].	^ {{			biggies size.			methodSize.			stats detectSum: [:a | a second].			stats detectSum: [:a | a third]		}.		stats asArray sort: [:x :y | x third >= y third]}! !!EtoysPresenter methodsFor: 'intialize' stamp: 'nice 8/19/2010 16:39' prior: 56690806!allExtantPlayers	"The initial intent here was to produce a list of Player objects associated with any Morph in the tree beneath the receiver's associatedMorph.  whether it is the submorph tree or perhaps off on unseen bookPages.  We have for the moment moved away from that initial intent, and in the current version we only deliver up players associated with the submorph tree only.  <-- this note dates from 4/21/99Call #flushPlayerListCache; to force recomputation."	| fullList |	playerList ifNotNil:		[^ playerList].	fullList := associatedMorph allMorphs select: 		[:m | m player ~~ nil] thenCollect: [:m | m player].	fullList copy do:		[:aPlayer |			aPlayer class scripts do:				[:aScript |  aScript isTextuallyCoded ifFalse:					[aScript currentScriptEditor ifNotNil: [:ed |						| objectsReferredToByTiles |						objectsReferredToByTiles := ed allMorphs							select:								[:aMorph | (aMorph isKindOf: TileMorph) and: [aMorph type == #objRef]]							thenCollect:								[:aMorph | aMorph actualObject].						fullList addAll: objectsReferredToByTiles]]]].	^ playerList := fullList asSet asArray sort:			[:a :b | a externalName < b externalName]! !"EToys"!!StrikeFont class methodsFor: 'examples' stamp: 'nice 8/19/2010 16:35' prior: 55662345!readStrikeFont2Family: familyName fromDirectory: aDirectory	"StrikeFont readStrikeFont2Family: 'Lucida' fromDirectory: FileDirectory default"	"This utility reads all available .sf2 StrikeFont files for a given family from  	the current directory. It returns an Array, sorted by size, suitable for handing 	to TextStyle newFontArray: ."	"For this utility to work as is, the .sf2 files must be named 'familyNN.sf2'."	| fileNames strikeFonts |	fileNames := aDirectory fileNamesMatching: familyName , '##.sf2'.	strikeFonts := fileNames collect: [:fname | StrikeFont new readFromStrike2: fname].	strikeFonts do: [ :font | font reset ].	^strikeFonts asArray sort: [:a :b | a height < b height]."TextConstants at: #Lucida put: (TextStyle fontArray: (StrikeFont 	readStrikeFont2Family: 'Lucida'))."! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'nice 8/19/2010 16:36' prior: 52976533!addNewFontSize: pointSize	"Add a font in specified size to the array of fonts."	| f d newArray t isSet |	fontArray first emphasis ~= 0 ifTrue: [		t := TextConstants at: self fontArray first familyName asSymbol.		t fonts first emphasis = 0 ifTrue: [			^ t addNewFontSize: pointSize.		].	].	pointSize <= 0 ifTrue: [^ nil].	fontArray do: [:s |		s pointSize = pointSize ifTrue: [^ s].	].	(isSet := fontArray first isKindOf: TTCFontSet) 	ifTrue:[		| fonts |		fonts := fontArray first fontArray collect: [ :font |			| newFont |			(font isNil)			ifTrue: [newFont := nil]			ifFalse: [				newFont := (font ttcDescription size > 256)					ifTrue: [MultiTTCFont new initialize]					ifFalse: [TTCFont new initialize].				newFont ttcDescription: font ttcDescription.				newFont pixelSize: pointSize * 96 // 72.				font derivativeFonts notEmpty ifTrue: [font derivativeFonts do: [ :proto |					proto ifNotNil: [						d := proto class new initialize.						d ttcDescription: proto ttcDescription.						d pixelSize: newFont pixelSize.						newFont derivativeFont: d]]].				].			newFont].		f := TTCFontSet newFontArray: fonts]	ifFalse: [		f := fontArray first class new initialize: fontArray first.		f pointSize: pointSize.		fontArray first derivativeFonts do: [:proto |			proto ifNotNil: [				d := proto class new initialize: proto.				d pointSize: f pointSize.				f derivativeFont: d mainFont: proto.			].		].	].	newArray := (fontArray copyWith: f) asArray sort: [:a :b | a pointSize <= b pointSize].	self newFontArray: newArray.	isSet ifTrue: [		TTCFontSet register: newArray at: newArray first familyName asSymbol.	].	^ self fontOfPointSize: pointSize! !"Graphics"!!FloatTest methodsFor: 'zero behavior' stamp: 'nice 8/21/2010 22:29'!testNegativeZeroAbs	self assert: Float negativeZero abs sign positive description: 'the absolute value of a negative zero is zero'! !!FloatTest methodsFor: 'zero behavior' stamp: 'nice 8/21/2010 22:30'!testNegativeZeroSign	self assert: Float negativeZero sign = -1! !"KernelTests"!!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'nice 8/19/2010 16:35' prior: 52747662!orderedTraitsIn: category 	"Answer an OrderedCollection containing references to the traits in the 	category whose name is the argument, category (a string). The traits 	are ordered so they can be filed in."	| behaviors traits |	behaviors := (self listAtCategoryNamed: category asSymbol) 			collect: [:title | Smalltalk at: title].	traits := behaviors reject: [:each | each isBehavior].	^traits asArray sort: [:t1 :t2 |		(t2 traitComposition allTraits includes: t1)			or: [(t1 traitComposition allTraits includes: t2) not]]! !"System"!!WaveEditor methodsFor: 'other' stamp: 'nice 8/19/2010 21:27' prior: 33108605!findPossibleLoopStartsFrom: index 	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r := OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart := loopEnd + 1.	"Assumed to be a zero-crossing."	i := self zeroCrossingAfter: postLoopCycleStart 						+ (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength := i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i := self zeroCrossingAfter: postLoopCycleStart 						- (1.1 * postLoopCycleLength) asInteger.	cycleLength := postLoopCycleStart - i.	cycleCount := 1.	[cycleLength > 0] whileTrue: 			[err := self 						autoCorrolationBetween: i						and: postLoopCycleStart						length: postLoopCycleLength.			r add: (Array 						with: i						with: err						with: cycleCount						with: ((loopEnd - i) asFloat / self samplingRate roundTo: 0.01)).			oldI := i.			i := self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.			cycleLength := oldI - i.	"will be zero when start of data is encountered"			cycleCount := cycleCount + 1].	^r asArray sort: [:e1 :e2 | e1 second < e2 second]! !"MorphicExtras"!!EToyMultiChatMorph methodsFor: 'as yet unclassified' stamp: 'nice 8/19/2010 14:29' prior: 20007710!updateIPAddressField: newAddresses		targetIPAddresses := (		newAddresses copyWithout: NetNameResolver localAddressString	) asSet asArray sort.	(fields at: #ipAddress) contents: targetIPAddresses size printString,' people'.! !"Nebraska"!!UUID class methodsFor: '*smbase-macsafe' stamp: 'nice 8/21/2010 11:26' prior: 32644006!fromString36: aString	"Decode the UUID from a base 36 string using 0-9 and lowercase a-z.	This is the shortest representation still being able to work as	filenames etc since it does not depend on case nor characters	that might cause problems."	| object num |	object := self nilUUID.	num := Integer readFrom: aString asUppercase readStream base: 36.	1 to: 16 do: [:i | object at: i put: (num digitAt: i)].	^object! !"SMBase"!!SampledInstrument methodsFor: 'other' stamp: 'nice 8/19/2010 16:34' prior: 28103941!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r := IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ r asArray sort: [:n1 :n2 | n1 pitch < n2 pitch]! !"Sound"!!MethodContext methodsFor: '*Tools-Inspector' stamp: 'ar 8/19/2010 12:16'!inspectorClass	"Answer the class of the inspector to be used on the receiver.  Called by inspect; 	use basicInspect to get a normal (less useful) type of inspector."	^ ContextInspector! !!ContextInspector methodsFor: 'accessing' stamp: 'ar 8/19/2010 12:24'!fieldList	"Answer the base field list plus an abbreviated list of indices."	^ self baseFieldList , (object tempNames collect:[:t| '[',t,']'])! !!ContextInspector methodsFor: 'accessing' stamp: 'ar 8/19/2010 12:21'!selection	"The receiver has a list of variables of its inspected object.	One of these is selected. Answer the value of the selected variable."	| basicIndex |	selectionIndex = 0 ifTrue: [^ ''].	selectionIndex = 1 ifTrue: [^ object].	selectionIndex = 2 ifTrue: [^ object longPrintStringLimitedTo: 20000].	(selectionIndex - 2) <= object class instSize		ifTrue: [^ object instVarAt: selectionIndex - 2].	basicIndex := selectionIndex - 2 - object class instSize.	^object debuggerMap namedTempAt: basicIndex in: object! !!MessageSet methodsFor: 'message list' stamp: 'nice 8/19/2010 16:33' prior: 54367564!sortByDate	"Sort the message-list by date of time-stamp"	| assocs inOrder |	assocs := messageList collect:		[:aRef | | aDate aCompiledMethod |			aDate := aRef methodSymbol == #Comment				ifTrue:					[aRef actualClass organization dateCommentLastSubmitted]				ifFalse:					[aCompiledMethod := aRef actualClass compiledMethodAt: aRef methodSymbol ifAbsent: [nil].					aCompiledMethod ifNotNil: [aCompiledMethod dateMethodLastSubmitted]].			aRef -> (aDate ifNil: [Date fromString: '01/01/1996'])].  "The dawn of Squeak history"	inOrder := assocs asArray sort: [:a :b | a value < b value].	messageList := inOrder collect: [:assoc | assoc key].	self changed: #messageList! !"Tools"!!UUniverseBrowser methodsFor: 'package list' stamp: 'nice 8/19/2010 16:36' prior: 32662457!categories	^(self sortedPackages collect: [ :p | p category])		asSet asArray sort: [ :p1 :p2 | p1 asString < p2 asString]! !"Universes"!!SequenceableCollection methodsFor: '*Balloon' stamp: 'NS 5/30/2001 20:56' prior: 28844125!asPointArray	"Answer an PointArray whose elements are the elements of the receiver, in 	the same order."	| pointArray |	pointArray := PointArray new: self size.	1 to: self size do:[:i| pointArray at: i put: (self at: i)].	^pointArray! !!Bezier3Segment class methodsFor: 'examples' stamp: 'ar 9/1/2010 22:14' prior: 17389317!example2	"draws a cubic bezier on the screen"	| c canvas |	c := Bezier3Segment new				from: 0 @ 0				via: 0 @ 100				and: 100 @ 0				to: 100 @ 100.	canvas := Display getCanvas asBalloonCanvas	canvas aaLevel: 4.	canvas		drawBezier3Shape: c asPointArray		color: Color transparent		borderWidth: 1		borderColor: Color black! !"Balloon"!!SocketStream methodsFor: 'stream in' stamp: 'ar 8/22/2010 13:27' prior: 34283287!upTo: aCharacterOrByte limit: nBytes	"Return data up to, but not including given character or byte. If the character is not in the stream, or not found within nBytes answer the available contents of the stream"	| target index result searchedSoFar |	"Deal with ascii vs. binary"	self isBinary 		ifTrue:[target := aCharacterOrByte asInteger] 		ifFalse:[target := aCharacterOrByte asCharacter].	"Look in the current inBuffer first"	index := inBuffer indexOf: target startingAt: lastRead + 1 ifAbsent:[0].	(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: 1.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	"We only get recentlyRead = 0 in the case of a non-signaling socket close."	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset."		index := inBuffer indexOf: target						startingAt: (lastRead + searchedSoFar + 1)						ifAbsent:[0].		(index > 0 and: [(index + 1) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: 1.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!SocketStream methodsFor: 'stream in' stamp: 'ar 8/22/2010 13:32' prior: 34285182!upToAll: aStringOrByteArray limit: nBytes	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aStringOrByteArray. If aCollection is not in the stream, or not found within nBytes answer the available contents of the stream"	| index sz result searchedSoFar target |	"Deal with ascii vs. binary"	self isBinary		ifTrue:[target := aStringOrByteArray asByteArray]		ifFalse:[target := aStringOrByteArray asString].	sz := target size.	"Look in the current inBuffer first"	index := inBuffer indexOfSubCollection: target						startingAt: lastRead - sz + 2.	(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"		result := self nextInBuffer: index - lastRead - 1.		self skip: sz.		^ result	].	[searchedSoFar :=  self inBufferSize.	"Receive more data"	self receiveData.	recentlyRead > 0] whileTrue:[		"Data begins at lastRead + 1, we add searchedSoFar as offset and 		backs up sz - 1 so that we can catch any borderline hits."		index := inBuffer indexOfSubCollection: target						startingAt: (lastRead + searchedSoFar - sz + 2 max: 1).		(index > 0 and: [(index + sz) <= inNextToWrite]) ifTrue: ["found it"			result := self nextInBuffer: index - lastRead - 1.			self skip: sz.			^ result		].		"Check if we've exceeded the max. amount"		(nBytes notNil and:[inNextToWrite - lastRead > nBytes]) 			ifTrue:[^self nextAllInBuffer].	].	"not found and (non-signaling) connection was closed"	^self nextAllInBuffer! !!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24' prior: 29465858!register: anObject		^self registry add: anObject! !!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24' prior: 29466032!registry	^Registry ifNil: [ Registry := WeakRegistry new ]! !!Socket class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24' prior: 29466871!unregister: anObject		^self registry remove: anObject ifAbsent: nil! !!Url class methodsFor: 'parsing' stamp: 'ar 9/1/2010 00:28' prior: 32793367!urlClassForScheme: scheme	(scheme isNil or: [scheme = 'http']) ifTrue: [^HttpUrl].	scheme = 'https' ifTrue: [^HttpUrl].	scheme = 'ftp' ifTrue: [^FtpUrl].	scheme = 'file' ifTrue: [^FileUrl].	scheme = 'mailto' ifTrue: [^MailtoUrl].	scheme = 'browser' ifTrue: [^BrowserUrl].	^GenericUrl! !!String methodsFor: '*network-uuid' stamp: 'mw 1/30/2004 11:53' prior: 30147868!asAlphaNumeric: totalSize extraChars: additionallyAllowed mergeUID: minimalSizeOfRandomPart	"Generates a String with unique identifier ( UID ) qualities, the difference to a	 UUID is that its beginning is derived from the receiver, so that it has a meaning	 for a human reader.	 Answers a String of totalSize, which consists of 3 parts	 1.part: the beginning of the receiver only consisting of		a-z, A-Z, 0-9 and extraChars in Collection additionallyAllowed ( which can be nil )	 2.part: a single _	 3.part: a ( random ) UID of size >= minimalSizeOfRandomPart consisting of		a-z, A-Z, 0-9	 Starting letters are capitalized. 	 TotalSize must be at least 1.	 Exactly 1 occurrence of $_ is guaranteed ( unless additionallyAllowed includes $_ ).	 The random part has even for small sizes good UID qualitites for many practical purposes.	 If only lower- or uppercase letters are demanded, simply convert the answer with	 say #asLowercase. The probability of a duplicate will rise only moderately ( see below ).	 Example: 		size of random part = 10		in n generated UIDs the chance p of having non-unique UIDs is			n = 10000 ->  p < 1e-10		if answer is reduced to lowerCase: p < 1.4 e-8			n = 100000 -> p < 1e-8		at the bottom is a snippet for your own calculations  		Note: the calculated propabilites are theoretical,			for the actually used random generator they may be much worse"	| stream out sizeOfFirstPart index ascii ch skip array random |	totalSize > minimalSizeOfRandomPart 		ifFalse: [ self errorOutOfBounds ].	stream := ReadStream on: self.	out := WriteStream on: ( String new: totalSize ).	index := 0.	skip := true.	sizeOfFirstPart := totalSize - minimalSizeOfRandomPart - 1.	[ stream atEnd or: [ index >= sizeOfFirstPart ]]	whileFalse: [		((( ascii := ( ch := stream next ) asciiValue ) >= 65 and: [ ascii <= 90 ]) or: [			( ascii >= 97 and: [ ascii <= 122 ]) or: [			 			ch isDigit or: [			additionallyAllowed notNil and: [ additionallyAllowed includes: ch ]]]])		ifTrue: [			skip				ifTrue: [ out nextPut: ch asUppercase ]				ifFalse: [ out nextPut: ch ].			index := index + 1.			skip := false ]		ifFalse: [ skip := true ]].	out nextPut: $_.	array := Array new: 62.	1 to: 26 do: [ :i |		array at: i put: ( i + 64 ) asCharacter.		array at: i + 26 put: ( i + 96 ) asCharacter ].	53 to: 62 do: [ :i |		array at: i put: ( i - 5 ) asCharacter ].	random := UUIDGenerator default randomGenerator. 	totalSize - index - 1 timesRepeat: [		out nextPut: ( array atRandom: random )].	^out contents	"	calculation of probability p for failure of uniqueness in n UIDs		Note: if answer will be converted to upper or lower case replace 62 with 36	| n i p all |	all := 62 raisedTo: sizeOfRandomPart.	i := 1.	p := 0.0 .	n := 10000.	[ i <= n ]	whileTrue: [		p := p + (( i - 1 ) / all ).		i := i + 1 ].	p   	approximation formula: n squared / ( 62.0 raisedTo: sizeOfRandomPart ) / 2 	" 	"'Crop SketchMorphs and Grab Screen Rect to JPG' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10  	 			'CropSketchMorphsAndG_iOw94jquN6'	 'Monticello' 			asAlphaNumeric: 31 extraChars: nil mergeUID: 10    				'Monticello_kp6aV2l0IZK9uBULGOeG' 	 'version-', ( '1.1.2' replaceAll: $. with: $- )			asAlphaNumeric: 31 extraChars: #( $- ) mergeUID: 10    				'Version-1-1-2_kuz2tMg2xX9iRLDVR'"		! !!String methodsFor: '*network-url' stamp: 'yo 11/3/2004 19:24' prior: 30160917!asUrl	"convert to a Url"	"'http://www.cc.gatech.edu/' asUrl"	"msw://chaos.resnet.gatech.edu:9000/' asUrl"	^Url absoluteFromText: self! !!String methodsFor: '*network-url' stamp: 'yo 11/3/2004 19:24' prior: 30161121!asUrlRelativeTo: aUrl	^aUrl newFromRelativeText: self! !UrlArgumentList removeSelector: #associationsDo:!"Network"!!Dictionary commentStamp: 'nice 8/26/2010 22:30' prior: 59284901!A Dictionary is an unordered collection of values which are indexed by arbitrary keys.A Dictionary is accessed via #at: and #at:put: messages like a SequenceableCollection, but instead of being Integer, the keys can be any object that responds to =.		The = message is used to test for the existence of the key in the Dictionary.If the key is absent, #at:put: adds a new entry to the Dictionary.	(Dictionary new)		at: 'foo' put: 1;		at: 'bar' put: 8;		yourself.Each key is unique: storing another value with #at:put: at an already used key overwrites previously associated value.	(Dictionary new)		at: 'bar' put: 4;		at: 'bar' put: 8;		at: 'bar'.		The values are not necessarily unique, thus a Dictionary can also be seen as a sort of Bag with this respect.	(Dictionary new)		at: 'foo' put: 8;		at: 'bar' put: 8;		yourself.If the key is absent, #at: raises an Error. An alternate block of code can be executed and its value returned in this case using #at:ifAbsent:.See also #at:ifAbsentPut:.	(Dictionary new) at: 'foo' ifAbsent: [nil].Dictionary is implemented as a HashedCollection of Association (a value is associated to its key et vice et versa).Being a HashedCollection enables fast random access indexed by keys.Consequently, keys must respond to #hash (see super).BEWARE: as for every HashedCollection, it is better to not modify an object after it is used as a Dictionary key. The reason is that this might change the #hash code, making the Dictionary unable to find corresponding entry, or make two keys equal violating uniqueness. It's progammer responsibility to take care to not modify the keys, or eventually to send #rehash to the Dictionary if they ever happen to change.It is possible to grow or shrink a Dictionary using the messages #add: and #remove: with an Association parameter, however the prefered way to do so is using #at:put: and #removeKey:.BEWARE: as for super, space reserved in internal storage array can grow but never shrink.For conveniency, it is also possible to create a Dictionary out of a Collection of associations, as for example in:    {'foo' -> 1. 'bar' -> 8} as: Dictionary.    Dictionary withAll: {'foo' -> 1. 'bar' -> 8}.    Dictionary new addAll: {'foo' -> 1. 'bar' -> 8}; yourself.BEWARE: though a Sequence collection can be considered as a sequence of values with Integer keys (see #keysAndValuesDo: ), it cannot be converted into a Dictionary using these keys, and following message will fail:	#('foo' 'bar') as: Dictionary.Enumerating a Dictionary with #do: will only enumerate the values, not the keys.Remember, the order of evaluation is arbitrary and can change when you grow or shrink a Dictionary.    ({'foo' -> 1. 'bar' -> 8} as: Dictionary) do: [:each | Transcript cr; show: each printString].For enumerating keys and values, use #keysAndValuesDo:, or use #associationsDo: to enumerate the associations.#select: #reject: #collect: will operate on values while preserving the keys and thus answer a new Dictionary.    ({'foo' -> 1. 'bar' -> 8} as: Dictionary) collect: [:each | each squared].The keys and values of a Dictionary can be extracted by sending #keys and #values message.Though the keys are theoretically a Set and values a Bag, for efficiency reasons, these messages will both return an Array of keysand an Array of values. A neat feature is that these messages are preserving the arbitrary storage order - in other words, (aDictionary values at: 3) is the value associated to key (aDictionary keys at: 3).!!Set commentStamp: 'nice 8/26/2010 22:14' prior: 59413114!I represent a set of objects without duplicates.  I can hold anything that responds to#hash and #=, except for nil.  My instances will automatically grow, if necessary.Note that I rely on #=, not #==.  If you want a set using #==, use IdentitySet.Instance structure:  array	An array whose non-nil elements are the elements of the set,		and whose nil elements are empty slots.  There is always at least one nil.		In fact I try to keep my "load" at 75% or less so that hashing will work well.  tally	The number of elements in the set.  The array size is always greater than this.The core operation is #scanFor:, which either finds the position where anobject is stored in array, if it is present, or finds a suitable position holding nil, ifits argument is not present in array.I can include an UndefinedObject (nil) thanks to a special implementation using a wrapper (see message #asSetElement and class SetElement).Indeed, a nil entry in the storage array means vacuity, it cannot mean I contain nil.!!IdentitySet commentStamp: 'nice 8/26/2010 22:00' prior: 21647224!The same as a Set, except that items are compared using #== instead of #=.Almost any class named IdentityFoo is the same as Foo except for the way items are compared.  In Foo, #= is used, while in IdentityFoo, #== is used.  That is, identity collections will treat items as the same only if they have the same identity.For example, note that copies of a string are equal:	('abc' copy) = ('abc' copy)but they are not identical:	('abc' copy) == ('abc' copy)A regular Set will only include equal objects once:	| aSet |	aSet := Set new.	aSet add: 'abc' copy.	aSet add: 'abc' copy.	aSetAn IdentitySet will include multiple equal objects if they are not identical:	| aSet |	aSet := IdentitySet new.	aSet add: 'abc' copy.	aSet add: 'abc' copy.	aSet!!KeyedIdentitySet commentStamp: 'nice 8/26/2010 22:01' prior: 0!A KeyedIdentitySet is like a Bag, except that items are compared with #== instead of #= .See the comment of IdentitySet for more information.!!WeakArray commentStamp: '<historical>' prior: 59462610!WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!!SetElement commentStamp: 'nice 8/26/2010 22:21' prior: 0!A SetElement is a special wrapper used to handle addition of some special elements into Set.This is necessary mainly for storing an UndefinedObject in a Set, since nil is used in Set algorithm to designate free slots in internal storage.Instance Variables	enclosedElement:		<Object>enclosedElement	- the real element we wish to put into the set!!Dictionary methodsFor: 'adding' stamp: 'ar 8/24/2010 20:19' prior: 19699828!addAll: aCollection	"Include all the associations of aCollection as the receiver's elements. Answer 	aCollection. Any collection containing associations can be used as argument."	aCollection == self ifFalse: [		aCollection associationsDo: [:assoc| self add: assoc].	].	^aCollection! !!WeakArray class methodsFor: 'accessing' stamp: 'ul 8/27/2010 23:38' prior: 55043690!addWeakDependent: anObject	FinalizationLock		critical: [			| emptySlotIndex |			emptySlotIndex := FinalizationDependents 				identityIndexOf: nil				ifAbsent: [ 					| newIndex |					newIndex := FinalizationDependents size + 1.					"Grow linearly"					FinalizationDependents := FinalizationDependents grownBy: 10.					newIndex ].			FinalizationDependents at: emptySlotIndex put: anObject ]		ifError: [ :msg :rcvr | rcvr error: msg ]! !!WeakArray class methodsFor: 'accessing' stamp: 'ul 8/27/2010 23:28' prior: 33129235!isFinalizationSupported	"This method is only here for backwards compatibility, all closure VMs support finalization"		^true! !!WeakArray class methodsFor: 'accessing' stamp: 'ul 8/27/2010 23:25' prior: 33129932!removeWeakDependent: anObject	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'private' stamp: 'ul 8/27/2010 23:26' prior: 33131678!restartFinalizationProcess	"kill any old process, just in case"	FinalizationProcess		ifNotNil: [FinalizationProcess terminate.			FinalizationProcess := nil].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents ifNil: [FinalizationDependents := WeakArray new: 10].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess]		forkAt: Processor userInterruptPriority! !TextSqkPageLink removeSelector: #actOnClickFor:!TranscriptStream removeSelector: #openLabel:!TranscriptStream removeSelector: #open!TranscriptStream removeSelector: #codePaneMenu:shifted:!TranscriptStream removeSelector: #buildWith:!TranscriptStream class removeSelector: #windowColorSpecification!TranscriptStream class removeSelector: #openMorphicTranscript!TranscriptStream class removeSelector: #buildWith:!TextURL removeSelector: #actOnClickFor:!"Collections"!!DictionaryTest methodsFor: 'tests' stamp: 'ar 8/24/2010 20:16' prior: 19718347!testAddAll		| dict1 dict2 |	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict2 := Dictionary new.	dict2 at: #a put: 3 ; at: #c put: 4.	dict1 addAll: dict2.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.	dict1 := Dictionary new.	dict1 at: #a put:1 ; at: #b put: 2. 	dict1 addAll: {#a -> 3. #c -> 4}.	self assert: (dict1 at: #a) = 3.	self assert: (dict1 at: #b) = 2.	self assert: (dict1 at: #c) = 4.! !!DictionaryTest methodsFor: 'tests' stamp: 'ar 8/24/2010 20:17'!testWithAll		| dict1 dict2 |	dict1 := Dictionary withAll: {#a -> 1. #b -> 2}.	self assert: (dict1 at: #a) = 1.	self assert: (dict1 at: #b) = 2.	dict2 := Dictionary withAll: dict1.	self assert: (dict2 at: #a) = 1.	self assert: (dict2 at: #b) = 2.! !"CollectionsTests"!!Duration methodsFor: 'private' stamp: 'dtl 8/29/2010 11:31' prior: 50966158!seconds: secondCount nanoSeconds: nanoCount 	"Private - only used by Duration class"	seconds := secondCount.	nanos := nanoCount rounded.	"normalize if signs do not match"	[ nanos < 0 and: [ seconds > 0 ] ]		whileTrue: [ seconds := seconds - 1.			nanos := nanos + NanosInSecond ].	[ seconds < 0 and: [ nanos > 0 ] ]		whileTrue: [ seconds := seconds + 1.			nanos := nanos - NanosInSecond ]! !!WeakMessageSend methodsFor: 'evaluating' stamp: 'nice 8/22/2010 21:36' prior: 53141355!valueWithEnoughArguments: anArray	"call the selector with enough arguments from arguments and anArray"	^self		withEnsuredReceiverAndArgumentsDo: [ :r :a |			r				perform: selector				withArguments: a ]		withEnoughArguments: anArray		otherwise: [ ]! !!WeakMessageSend methodsFor: 'private' stamp: 'nice 8/22/2010 21:37'!withEnsuredReceiverAndArgumentsDo: aBlock withEnoughArguments: anArray otherwise: altBlock	"call the selector with enough arguments from arguments and anArray"	| r selfArgs enoughArgs |	r := self receiver.	r ifNil: [ ^altBlock value ].		selfArgs := self arguments.	selfArgs with: shouldBeNil do: [ :arg :flag |		arg ifNil: [ flag ifFalse: [ ^altBlock value ]]	].	enoughArgs := Array new: selector numArgs.	enoughArgs replaceFrom: 1		to: ( selfArgs size min: enoughArgs size)		with: selfArgs		startingAt: 1.	enoughArgs size > selfArgs size ifTrue: [		enoughArgs replaceFrom: selfArgs size + 1			to: (selfArgs size + anArray size min: enoughArgs size)			with: anArray			startingAt: 1.	].	^aBlock value: r value: enoughArgs! !!LargePositiveInteger methodsFor: 'printing' stamp: 'ul 8/23/2010 13:56' prior: 51540930!printOn: aStream base: b nDigits: n	"Append a representation of this number in base b on aStream using n digits.	In order to reduce cost of LargePositiveInteger ops, split the number of digts approximatily in two	Should be invoked with: 0 <= self < (b raisedToInteger: n)"		| halfPower half head tail |	n <= 1 ifTrue: [		n <= 0 ifTrue: [self error: 'Number of digits n should be > 0'].				"Note: this is to stop an infinite loop if one ever attempts to print with a huge base		This can happen because choice was to not hardcode any limit for base b		We let Character>>#digitValue: fail"		^aStream nextPut: (Character digitValue: self) ].	halfPower := n bitShift: -1.	half := b raisedToInteger: halfPower.	head := self quo: half.	tail := self - (head * half).	head printOn: aStream base: b nDigits: n - halfPower.	tail printOn: aStream base: b nDigits: halfPower! !WeakMessageSend removeSelector: #isValid!WeakMessageSend removeSelector: #ensureReceiverAndArguments!WeakMessageSend removeSelector: #ensureReceiver!WeakMessageSend removeSelector: #ensureArguments!MessageSend removeSelector: #isValid!Time class removeSelector: #primUtcWithOffset!"Kernel"!!ParseNodeEnumerator commentStamp: 'eem 8/31/2010 11:41' prior: 59364589!ParseNodeEnumerator implements ParseNode>>nodesDo:.  It can be used to enumerate an entire tree via	aParseNode accept: (ParseNodeEnumerator ofBlock: aBlock)or selectively, excluding the node and subnodes for which selectBlock answers false, via	aParseNode accept: (ParseNodeEnumerator							ofBlock: aBlock							select: selectBlock)Here's a doIt that generates and compiles the visiting methods:self superclass selectors do:	[:s|	self compile: (String streamContents:		[:str| | arg |		arg := 'a', (s allButFirst: 5) allButLast.		str nextPutAll: s, ' ', arg; crtab;			nextPutAll: '(theSelectBlock isNil or: [theSelectBlock value: '; nextPutAll: arg; nextPutAll: ']) ifFalse:'; crtab;			tab: 2; nextPutAll: '[^nil].'; crtab;			nextPutAll: 'theBlock value: '; nextPutAll: arg; nextPut: $.; crtab;			nextPutAll: '^super '; nextPutAll: s, ' ', arg])]!!Compiler methodsFor: 'private' stamp: 'eem 8/30/2010 17:57' prior: 50780337!format: aStream noPattern: noPattern ifFail: failBlock	^(self parser		parse: aStream		class: class		noPattern: noPattern		context: context		notifying: requestor		ifFail: [^failBlock value]) preen! !!Decompiler methodsFor: 'public access' stamp: 'eem 8/30/2010 17:57' prior: 50896691!decompile: aSelector in: aClass method: aMethod using: aConstructor	| block node |	constructor := aConstructor.	method := aMethod.	self initSymbols: aClass.  "create symbol tables"	method isQuick		ifTrue: [block := self quickMethod]		ifFalse: 			[stack := OrderedCollection new: method frameSize.			caseExits := OrderedCollection new.			statements := OrderedCollection new: 20.			numLocalTemps := 0.			super method: method pc: method initialPC.			"skip primitive error code store if necessary"			(method primitive ~= 0 and: [self willStore]) ifTrue:				[pc := pc + 2.				 tempVars := tempVars asOrderedCollection].			block := self blockTo: method endPC + 1.			stack isEmpty ifFalse: [self error: 'stack not empty']].	node := constructor				codeMethod: aSelector				block: block				tempVars: tempVars				primitive: method primitive				class: aClass.	method primitive > 0 ifTrue:		[node removeAndRenameLastTempIfErrorCode].	^node preen! !!ParseNode methodsFor: 'testing' stamp: 'eem 8/31/2010 11:34'!isOnlySubnodeOf: aSubtree "<ParseNode>" in: aParseTree "<ParseNode>"	"Answer if the receiver only occurs within aSubtree of aParseTree, not in the rest of aParseTree.	 Assumes that aSubtree is in fact a subnode of aParseTree."	| isSubnode |	isSubnode := false.	aSubtree accept: (ParseNodeEnumerator							ofBlock: [:node| node == self ifTrue: [isSubnode := true]]).	isSubnode ifFalse:		[^false].	aParseTree accept: (ParseNodeEnumerator							ofBlock: [:node| node == self ifTrue: [^false]]							select: [:node| node ~= aSubtree]).	^true! !!MethodNode methodsFor: 'converting' stamp: 'eem 8/31/2010 11:54'!preen	"Preen for pretty-printing and/or decompilation.	 i.e. post-process to cover up for inadequacies in both algorithms.	 Currently one case, hiding the assignment to the arg of an inlined block arg to ifNotNil:,		(var := expr) ifNil: [...] ifNotNil: [...]    =>    expr ifNil: [...] ifNotNil: [:var| ...]."	self preenLocalIfNotNilArg! !!MethodNode methodsFor: 'converting' stamp: 'eem 8/31/2010 12:36'!preenLocalIfNotNilArg	"Try and spot a (var := expr) ifNil: [...] ifNotNil: [...] where var is only used in the ifNotNil: block	 and convert it to expr ifNil: [...] ifNotNil: [:var| ...].  Deal both with the pretty-print case where	 the block already declares the variable and the decompile case where it does not."	| varsToHide |	varsToHide := Set new.	self nodesDo:		[:node| | variable |		(node isMessageNode		and: [node macroPrinter == #printIfNilNotNil:indent:		and: [node receiver isMessageNode		and: [node receiver selector key == #==		and: [node receiver receiver isAssignmentNode		and: [(variable := node receiver receiver variable) isTemp		and: [variable isRemote not		and: [variable isOnlySubnodeOf: node in: self]]]]]]]) ifTrue:			[node arguments last arguments isEmpty				ifTrue: [node arguments last arguments: { variable }.						varsToHide add: variable]				ifFalse: [self assert: node arguments last arguments asArray =  { variable }].			 node receiver receiver: node receiver receiver value]].	varsToHide notEmpty ifTrue:		[self nodesDo:			[:node|			((node == self or: [node isBlockNode])			and: [node temporaries anySatisfy: [:temp| varsToHide includes: temp]]) ifTrue:				[node temporaries: (node temporaries reject: [:temp| varsToHide includes: temp])]]]! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/31/2010 12:31' prior: 50469596!arguments	^arguments ifNil: [#()]! !!BlockNode methodsFor: 'accessing' stamp: 'eem 8/31/2010 12:30' prior: 50454220!temporaries	^temporaries ifNil: [#()]! !!ParseNodeEnumerator class methodsFor: 'instance creation' stamp: 'eem 8/31/2010 11:43'!ofBlock: aBlock select: selectBlock	^self new ofBlock: aBlock select: selectBlock! !!ParseNodeEnumerator methodsFor: 'initialize-release' stamp: 'eem 8/31/2010 11:24'!ofBlock: aBlock select: aSelectBlock	theBlock := aBlock.	theSelectBlock := aSelectBlock! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52070231!visitAssignmentNode: anAssignmentNode	(theSelectBlock isNil or: [theSelectBlock value: anAssignmentNode]) ifFalse:		[^nil].	theBlock value: anAssignmentNode.	^super visitAssignmentNode: anAssignmentNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52071703!visitBlockNode: aBlockNode	(theSelectBlock isNil or: [theSelectBlock value: aBlockNode]) ifFalse:		[^nil].	theBlock value: aBlockNode.	^super visitBlockNode: aBlockNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52071535!visitBraceNode: aBraceNode	(theSelectBlock isNil or: [theSelectBlock value: aBraceNode]) ifFalse:		[^nil].	theBlock value: aBraceNode.	^super visitBraceNode: aBraceNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52072844!visitCascadeNode: aCascadeNode	(theSelectBlock isNil or: [theSelectBlock value: aCascadeNode]) ifFalse:		[^nil].	theBlock value: aCascadeNode.	^super visitCascadeNode: aCascadeNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52072463!visitCommentNode: aCommentNode	(theSelectBlock isNil or: [theSelectBlock value: aCommentNode]) ifFalse:		[^nil].	theBlock value: aCommentNode.	^super visitCommentNode: aCommentNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52073368!visitFieldNode: aFieldNode	(theSelectBlock isNil or: [theSelectBlock value: aFieldNode]) ifFalse:		[^nil].	theBlock value: aFieldNode.	^super visitFieldNode: aFieldNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52071006!visitFutureNode: aFutureNode	(theSelectBlock isNil or: [theSelectBlock value: aFutureNode]) ifFalse:		[^nil].	theBlock value: aFutureNode.	^super visitFutureNode: aFutureNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52071871!visitInstanceVariableNode: anInstanceVariableNode	(theSelectBlock isNil or: [theSelectBlock value: anInstanceVariableNode]) ifFalse:		[^nil].	theBlock value: anInstanceVariableNode.	^super visitInstanceVariableNode: anInstanceVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52071179!visitLiteralNode: aLiteralNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralNode]) ifFalse:		[^nil].	theBlock value: aLiteralNode.	^super visitLiteralNode: aLiteralNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52073536!visitLiteralVariableNode: aLiteralVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aLiteralVariableNode]) ifFalse:		[^nil].	theBlock value: aLiteralVariableNode.	^super visitLiteralVariableNode: aLiteralVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52071357!visitMessageNode: aMessageNode	(theSelectBlock isNil or: [theSelectBlock value: aMessageNode]) ifFalse:		[^nil].	theBlock value: aMessageNode.	^super visitMessageNode: aMessageNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52070610!visitMessageNodeInCascade: aMessageNodeInCascade	(theSelectBlock isNil or: [theSelectBlock value: aMessageNodeInCascade]) ifFalse:		[^nil].	theBlock value: aMessageNodeInCascade.	^super visitMessageNodeInCascade: aMessageNodeInCascade! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52070833!visitMethodNode: aMethodNode	(theSelectBlock isNil or: [theSelectBlock value: aMethodNode]) ifFalse:		[^nil].	theBlock value: aMethodNode.	^super visitMethodNode: aMethodNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52072280!visitNewArrayNode: aNewArrayNode	(theSelectBlock isNil or: [theSelectBlock value: aNewArrayNode]) ifFalse:		[^nil].	theBlock value: aNewArrayNode.	^super visitNewArrayNode: aNewArrayNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52073022!visitRemoteTempVectorNode: aRemoteTempVectorNode	(theSelectBlock isNil or: [theSelectBlock value: aRemoteTempVectorNode]) ifFalse:		[^nil].	theBlock value: aRemoteTempVectorNode.	^super visitRemoteTempVectorNode: aRemoteTempVectorNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52073754!visitReturnNode: aReturnNode	(theSelectBlock isNil or: [theSelectBlock value: aReturnNode]) ifFalse:		[^nil].	theBlock value: aReturnNode.	^super visitReturnNode: aReturnNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52070427!visitSelectorNode: aSelectorNode	(theSelectBlock isNil or: [theSelectBlock value: aSelectorNode]) ifFalse:		[^nil].	theBlock value: aSelectorNode.	^super visitSelectorNode: aSelectorNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52072641!visitTempVariableNode: aTempVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aTempVariableNode]) ifFalse:		[^nil].	theBlock value: aTempVariableNode.	^super visitTempVariableNode: aTempVariableNode! !!ParseNodeEnumerator methodsFor: 'visiting' stamp: 'eem 8/31/2010 11:13' prior: 52072097!visitVariableNode: aVariableNode	(theSelectBlock isNil or: [theSelectBlock value: aVariableNode]) ifFalse:		[^nil].	theBlock value: aVariableNode.	^super visitVariableNode: aVariableNode! !ParseNode removeSelector: #optimizedBlockHoistTempsInto:!"Compiler"!CodeHolder removeSelector: #showingTiles!"EToys"!ExceptionsTest removeSelector: #testHandlerReentrancy!Smalltalk removeClassNamed: #ExceptionsTest!"Exceptions"!!StandardFileStream class methodsFor: 'file creation' stamp: 'nice 8/27/2010 21:45' prior: 29796703!forceNewFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened 	for writing on that file. If the file already exists, delete it without 	asking before creating the new file."	| dir localName fullName f |	fullName := self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: 			[f := self new open: fullName forWrite: true.			^ f				ifNil: ["Failed to open the file"					(FileDoesNotExistException fileName: fullName) signal]].	dir := FileDirectory forFileName: fullName.	localName := FileDirectory localNameFor: fullName.	dir		deleteFileNamed: localName		ifAbsent: [(CannotDeleteFileException new			messageText: 'Could not delete the old version of file ' , fullName) signal].	f := self new open: fullName forWrite: true.	^ f		ifNil: ["Failed to open the file"			(FileDoesNotExistException fileName: fullName) signal]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'jmv 3/2/2010 16:35' prior: 29799140!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	| fullName f |	fullName := self fullName: fileName.	f := self new open: fullName forWrite: false.	^ f		ifNil: ["File does not exist..."			((FileDoesNotExistException fileName: fullName) readOnly: true) signal].	"StandardFileStream readOnlyFileNamed: 'kjsd.txt' "! !!StandardFileStream class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24' prior: 29799604!register: anObject		^self registry add: anObject! !!StandardFileStream class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:24' prior: 29799790!registry		^Registry ifNil: [ Registry := WeakRegistry new ]! !!StandardFileStream class methodsFor: 'registry' stamp: 'ul 8/27/2010 23:25' prior: 29800692!unregister: anObject		^self registry remove: anObject ifAbsent: nil! !"Files"!!DurationTest methodsFor: 'testing' stamp: 'dtl 8/29/2010 11:25'!testNormalizeNanoSeconds	"Subtraction of two DateAndTime values may result in a request to	create a Duration with negative nanoseconds and positive seconds.	The resulting Duration should be normalized, otherwise its printString	will be invalid."	| d t1 t2 |	t1 := '2004-01-07T11:55:01+00:00' asDateAndTime. 	t2 := '2004-01-07T11:55:00.9+00:00' asDateAndTime.	d := t1 - t2. "100 millisecond difference"	self assert: d nanoSeconds > 0.	self assert: d seconds = 0.	self assert: d nanoSeconds = 100000000.	self assert: d asString = '0:00:00:00.1'.	"Verify that other combinations produces reasonable printString values"	self assert: (Duration seconds: 1 nanoSeconds: 100000000) printString = '0:00:00:01.1'.	self assert: (Duration seconds: -1 nanoSeconds: -100000000) printString = '-0:00:00:01.1'.	self assert: (Duration seconds: 1 nanoSeconds: -100000000) printString = '0:00:00:00.9'.	self assert: (Duration seconds: -1 nanoSeconds: 100000000) printString = '-0:00:00:00.9'! !"KernelTests"!!MCMcmUpdater commentStamp: 'cbc 8/26/2010 16:42' prior: 33820123!MCMcmUpdater provides utility methods for updating Monticello packages from Monticello configurations.When Monticello configurations are stored in a repository (or repositories), MCMcmUpdater acts as an update stream. It first ensures that each configuration map has been loaded in sequence, then updates the last configuration map to the most recent version for each specified package, and finally loads these versions to produce a fully updated configuration.Currently if a set of packages are unloaded from the image, using this class to reload them may cause problems, depending on what dependencies those classes have.  Success is not assured.  Removing packages via SmalltalkImage>>unloadAllKnownPackages will be successful, it flags the packages removed so that they are not loaded by this utility.If you wish to not have MCMcmUpdater update packages, there are two ways to handle this:1) To have MCMcmUpdater not update any packages not currently in the image set the UpdateMissingPackages preference to false:		MCMcmUpdater updateMissingPackages: false	Note that any new packages added to the repositories will not be picked up when this is turned off.2) To have MCMcmUpdater not update a specific package, evaluate		MCMcmUpdater disableUpdatesOfPackage: <packageName>Class Variables definitions:DefaultUpdateURL - String: the URL that will be checked by default for updates.  This would be set for a common standard location to check.LastUpdateMap - Dictionary of Integer: version number of the last loaded update map per repository.  Keeps track of the last configuration map, so that the utility will not have to run through the full history in the repositories each time you ask to update.SkipPackages - Set of Strings: names of packages to not update in MCMcmUpdater (empty by default).UpdateMissingPackages - Boolean: if true (default), new packages in the update config map will be loaded unless they are in SkipPackages.  If false, packages not currently loaded in the image will not be loaded by MCMcmUpdater.  (This can be dangerous if packages are split - use at your own risk).!!MCMcmUpdater class methodsFor: 'updating' stamp: 'cbc 8/25/2010 10:27'!disableUpdatesOfPackage: packageName	self skipPackages add: packageName! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'cbc 8/25/2010 10:29'!enableUpdatesForAllPackages	SkipPackages := Set new! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'cbc 8/25/2010 10:27'!enableUpdatesOfPackage: packageName	self skipPackages remove: packageName ifAbsent: [].! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'cbc 8/25/2010 08:14'!skipPackages	^SkipPackages ifNil: [SkipPackages := Set new]! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'cbc 8/25/2010 09:13' prior: 57254025!updateFromRepositories: repositoryUrls	"MCMcmUpdater updateFromRepositories: #(		'http://squeaksource.com/MCUpdateTest'	)"	| repos config |	Preferences enable: #upgradeIsMerge.	LastUpdateMap ifNil:[LastUpdateMap := Dictionary new].	"The list of repositories to consult in order"	repos := repositoryUrls collect:[:url| 		MCRepositoryGroup default repositories 			detect:[:r| r description = url]			ifNone:[ | r |				r := MCHttpRepository location: url user: '' password: ''.				MCRepositoryGroup default addRepository: r.				r]].	"The list of updates-author.version.mcm sorted by version"	repos do:[:r| r cacheAllFileNamesDuring:[		| minVersion updateList allNames |		updateList := SortedCollection new.		minVersion := LastUpdateMap at: r description ifAbsent:[0].		"Find all the updates-author.version.mcm files"		'Checking ', r description			displayProgressAt: Sensor cursorPoint			from: 0 to: 1 during:[:bar| 				bar value: 0.				allNames := r allFileNames.			].		allNames do:[:versionedName| | version base parts author type |			parts := versionedName findTokens: '.-'.			parts size = 4 ifTrue:[				base := parts at: 1.				author := parts at: 2.				version := [(parts at: 3) asNumber] on: Error do:[:ex| ex return: 0].				type := parts at: 4.			].			(base = 'update' and:[version >= minVersion and:[type = 'mcm']]) 				ifTrue:[updateList add: version -> versionedName]].				"Proceed only if there are updates available at all."		updateList ifNotEmpty: [			"Now process each update file. Check if we have all dependencies and if not,			load the entire configuration (this is mostly to skip older updates quickly)"			updateList do:[:assoc|				ProgressNotification signal: '' extra: 'Processing ', assoc value.				config := r versionFromFileNamed: assoc value.				"Skip packages that were specifically unloaded"				config dependencies: (config dependencies 					reject: [:dep| self skipPackages includes: dep package name]).				self updateMissingPackages ifFalse:[					"Skip packages that are not in the image"					config dependencies: (config dependencies 						select: [:dep| dep package hasWorkingCopy])].				(config dependencies allSatisfy:[:dep| dep isFulfilled]) 					ifFalse:[config upgrade].				LastUpdateMap at: r description put: assoc key.			] displayingProgress: 'Processing configurations'.			"We've loaded all the provided update configurations.			Use the latest configuration to update all the remaining packages."			config updateFromRepositories.			config upgrade.		]].	].	^config! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'ar 8/24/2010 20:03'!updateMissingPackages	"Whether to update missing (unloaded) packages"	<preference: 'Update missing package'		category: 'Monticello'		description: 'If true, missing (unloaded) packages will be loaded during the update process.'		type: #Boolean>	^UpdateMissingPackages ifNil:[true]! !!MCMcmUpdater class methodsFor: 'updating' stamp: 'ar 8/24/2010 20:04'!updateMissingPackages: aBool	"Whether to update missing (unloaded) packages"	UpdateMissingPackages := aBool.! !"MonticelloConfigurations"!!SystemNavigation commentStamp: 'mha 8/26/2010 09:02' prior: 30675278!I support the navigation of the system. I act as a facade but as I could require some stateor different way of navigating the system all my behavior are on the instance side.For example if you want to look at all methods you have written or changed in the current image doSystemNavigation new browseAllSelect: [ :method |       method fileIndex > 1 "only look at changes file"       and: [ method timeStamp beginsWith: 'your-initials-here' ] ].!!SecureHashAlgorithm class methodsFor: 'class initialization' stamp: 'nice 8/28/2010 22:39' prior: 55360142!initialize	"SecureHashAlgorithm initialize"	"For the curious, here's where these constants come from:	  #(2 3 5 10) collect: [:x | ((x sqrt / 4.0) * (2.0 raisedTo: 32)) truncated hex]"	K1 := ThirtyTwoBitRegister fromInteger: 16r5A827999.	K2 := ThirtyTwoBitRegister fromInteger: 16r6ED9EBA1.	K3 := ThirtyTwoBitRegister fromInteger: 16r8F1BBCDC.	K4 := ThirtyTwoBitRegister fromInteger: 16rCA62C1D6.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:43' prior: 52438278!expandedBlock: aByteArray	"Convert the given 64 byte buffer into 80 32-bit registers and answer the result." 	| out src v |	out := Array new: 80.	src := 1.	1 to: 16 do: [:i |		out at: i put: (ThirtyTwoBitRegister fromByteArray: aByteArray at: src).		src := src + 4].	17 to: 80 do: [:i |		v := (out at: i - 3) copy.		v	bitXor: (out at: i - 8);			bitXor: (out at: i - 14);			bitXor: (out at: i - 16);			leftRotateBy: 1.		out at: i put: v].	^ out! !!SecureHashAlgorithm methodsFor: 'public' stamp: 'nice 8/28/2010 22:40' prior: 52435342!hashInteger: aPositiveInteger seed: seedInteger	"Hash the given positive integer. The integer to be hashed should have 512 or fewer bits. This entry point is used in the production of random numbers"	| buffer dstIndex |	"Initialize totalA through totalE to their seed values."	totalA := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -128) bitAnd: 16rFFFFFFFF).	totalB := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -96) bitAnd: 16rFFFFFFFF).	totalC := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -64) bitAnd: 16rFFFFFFFF).	totalD := ThirtyTwoBitRegister		fromInteger: ((seedInteger bitShift: -32) bitAnd: 16rFFFFFFFF).	totalE := ThirtyTwoBitRegister		fromInteger: (seedInteger bitAnd: 16rFFFFFFFF).	self initializeTotalsArray.	"pad integer with zeros"	buffer := ByteArray new: 64.	dstIndex := 0.	aPositiveInteger digitLength to: 1 by: -1 do: [:i |		buffer at: (dstIndex := dstIndex + 1) put: (aPositiveInteger digitAt: i)].	"process that one block"	self processBuffer: buffer.	^ self finalHash! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:39' prior: 52434816!initializeTotals	"Initialize totalA through totalE to their seed values."	"total registers for use when primitives are absent"	totalA := ThirtyTwoBitRegister fromInteger: 16r67452301.	totalB := ThirtyTwoBitRegister fromInteger: 16rEFCDAB89.	totalC := ThirtyTwoBitRegister fromInteger: 16r98BADCFE.	totalD := ThirtyTwoBitRegister fromInteger: 16r10325476.	totalE := ThirtyTwoBitRegister fromInteger: 16rC3D2E1F0.	self initializeTotalsArray.! !!SecureHashAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 22:28' prior: 52438830!processBuffer: aByteArray	"Process given 64-byte buffer, accumulating the results in totalA through totalE."	| a b c d e w tmp |	self primHasSecureHashPrimitive		ifTrue: [^ self processBufferUsingPrimitives: aByteArray]		ifFalse: [totals := nil].	"initialize registers a through e from the current totals" 	a := totalA copy.	b := totalB copy.	c := totalC copy.	d := totalD copy.	e := totalE copy.	"expand and process the buffer"	w := self expandedBlock: aByteArray.	1 to: 80 do: [:i |		tmp := (a copy leftRotateBy: 5)			+= (self hashFunction: i of: b with: c with: d);			+= e;			+= (w at: i);			+= (self constantForStep: i).		e := d.		d := c.		c := b leftRotateBy: 30.		b := a.		a := tmp].	"add a through e into total accumulators"	totalA += a.	totalB += b.	totalC += c.	totalD += d.	totalE += e.! !!SmalltalkImage class methodsFor: 'class initialization' stamp: 'eem 8/31/2010 10:37' prior: 58600030!startUp	SystemChangeNotifier uniqueInstance notify: Smalltalk ofAllSystemChangesUsing: #event:! !!SmalltalkImage methodsFor: 'snapshot and quit' stamp: 'eem 8/31/2010 10:38' prior: 58518807!processShutDownList: quitting	"Send #shutDown to each class that needs to wrap up before a snapshot.	 Also void the endianness chace;  this can't safely be done on start-up because	 Smalltalk is too late in the start-up sequence."	EndianCache := nil.	self send: #shutDown: toClassesNamedIn: ShutDownList with: quitting! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'cbc 8/26/2010 16:26' prior: 33956874!unloadAllKnownPackages	"Unload all packages we know how to unload and reload"	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	World removeAllMorphs.	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 'Installer-Core'		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC' 'ST80'		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols' 'XML-Parser' 'Tests' 'SUnitGUI'	) do: [:pkgName| 			(MCPackage named: pkgName) unload.			MCMcmUpdater disableUpdatesOfPackage: pkgName.			].	"Traits use custom unload"	Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits].	"Post-unload cleanup"	MCWorkingCopy flushObsoletePackageInfos.	SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	Smalltalk forgetDoIts.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.	MorphicProject defaultFill: (Color gray: 0.9).	World color: (Color gray: 0.9).! !!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'nice 8/28/2010 22:42'!fromByteArray: aByteArray at: startIndex	"Answer a new instance whose initial contents is copied from next four bytes from aByteArray starting at startIndex..	Convention is Most Significant Byte first (aka big endian)."	^ self basicNew loadFrom: aByteArray at: startIndex! !!ThirtyTwoBitRegister class methodsFor: 'instance creation' stamp: 'nice 8/28/2010 22:38'!fromInteger: aPositiveInteger	"Answer a new instance whose initial contents is copied from aPositiveInteger.	It is required that aPositiveInteger has no more than 32 bits."	^ self basicNew load: aPositiveInteger! !!ThirtyTwoBitRegister methodsFor: 'accumulator ops' stamp: 'nice 8/28/2010 21:03' prior: 52998655!leftRotateBy: bits	"Rotate my contents left by the given number of bits, retaining exactly 32 bits."	"Details: Perform this operation with as little LargeInteger arithmetic as possible."	| bitCount s1 s2 newHi |	"ensure bitCount is in range [0..31]"	bitCount := bits \\ 32.	bitCount > 16		ifTrue: [			s1 := bitCount - 16.			s2 := s1 - 16.			newHi := ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			low := ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			hi := newHi]		ifFalse: [			s1 := bitCount.			s2 := s1 - 16.			newHi := ((hi bitShift: s1) bitAnd: 16rFFFF) bitOr: (low bitShift: s2).			low := ((low bitShift: s1) bitAnd: 16rFFFF) bitOr: (hi bitShift: s2).			hi := newHi]! !!ThirtyTwoBitRegister methodsFor: 'accessing' stamp: 'nice 8/28/2010 22:34' prior: 53000647!load: anInteger	"Set my contents to the value of given integer."	(anInteger positive and: [anInteger digitLength <= 4])		ifFalse: [self error: 'out of range: ', anInteger printString].	low := anInteger bitAnd: 16rFFFF.	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'nice 8/22/2010 17:47' prior: 53140572!valueStartingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Error so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Error."	| each answer |	answer := nil.	startIndex to: self size do: [:index |		each := self at: index.		[			answer := each valueOtherwise: [ answer ].		]			on: Halt , Error			do: [:exc | 				self valueStartingFrom: index + 1.				exc pass]].	^ answer! !!WeakActionSequenceTrappingErrors methodsFor: 'evaluating' stamp: 'nice 8/22/2010 17:48' prior: 53139705!valueWithArguments: anArray startingFrom: startIndex	"Do the same as my parent, but make sure that all actions that do not 	give errors are evaluated before resignaling the ones that gave errors 	(giving the chance to clients to handle them)."	"Note: I currently trap Halt,Error so that I am sure to get a Halt event in case of a Halt. This is being fixed in the exception system - when the fix is done it will be enough to capture only Error."	| each answer |	answer := nil.	startIndex to: self size do: [:index |		each := self at: index.		[			answer := each valueWithArguments: anArray otherwise: [ answer ].		]			on: Halt , Error			do: [:exc | 				self valueWithArguments: anArray startingFrom: index + 1.				exc pass]].	^ answer! !!WindowColorSpec class methodsFor: 'instance creation' stamp: 'sw 2/26/2002 13:40' prior: 33207580!classSymbol: sym wording: wrd brightColor: brCol pastelColor: paCol helpMessage: hlpMsg	"Answer a new instance of the receiver with the given slots filled in"	^ self new classSymbol: sym wording: wrd brightColor: brCol pastelColor: paCol helpMessage: hlpMsg! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 15:00' prior: 33206242!brightColor	"Answer the brightColor"	^ brightColor! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 14:59' prior: 33206367!classSymbol	"Answer the classSymbol"	^ classSymbol! !!WindowColorSpec methodsFor: 'initialization' stamp: 'sw 2/26/2002 13:39' prior: 53151454!classSymbol: sym wording: wrd brightColor: brCol pastelColor: paCol helpMessage: hlpMsg	"Initialize the receiver's instance variables"	classSymbol := sym.	wording := wrd.	brightColor := brCol.	pastelColor := paCol.	helpMessage := hlpMsg! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 15:00' prior: 33206492!helpMessage	"Answer the helpMessage"	^ helpMessage! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 15:00' prior: 33206617!pastelColor	"Answer the pastelColor"	^ pastelColor! !!WindowColorSpec methodsFor: 'printing' stamp: 'sw 4/21/2002 07:42' prior: 33207177!printOn: aStream	"Print the receiver on a stream"	super printOn: aStream.	classSymbol printOn: aStream. 	aStream nextPutAll: ' bright: ', brightColor printString, ' pastel: ', pastelColor printString! !!WindowColorSpec methodsFor: 'access' stamp: 'sw 2/26/2002 14:59' prior: 33206742!wording	"Answer the wording"	^ wording! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'nice 8/28/2010 21:16' prior: 50928812!inverseOf: x mod: n	"Answer the inverse of x modulus n. That is, the integer y such that (x * y) \\ n is 1. Both x and n must be positive, and it is assumed that x < n and that x and n are integers."	"Details: Use the extended Euclidean algorithm, Schneier, p. 247."	| v u u1 u2 u3 t1 t2 t3 tmp |	((x <= 0) or: [n <= 0]) ifTrue: [self error: 'x and n must be greater than zero'].	x >= n ifTrue: [self error: 'x must be < n'].	v := x.	u := n.	(x even and: [n even]) ifTrue: [self error: 'no inverse'].	u1 := 1. u2 := 0. u3 := u.	t1 := v. t2 := u - 1. t3 := v.	[	[u3 even ifTrue: [			((u1 odd) or: [u2 odd]) ifTrue: [				u1 := u1 + v.				u2 := u2 + u].			u1 := u1 bitShift: -1.			u2 := u2 bitShift: -1.			u3 := u3 bitShift: -1].		((t3 even) or: [u3 < t3]) ifTrue: [			tmp := u1. u1 := t1. t1 := tmp.			tmp := u2. u2 := t2. t2 := tmp.			tmp := u3. u3 := t3. t3 := tmp].		u3 even and: [u3 > 0]] whileTrue: ["loop while u3 is even"].		[((u1 < t1) or: [u2 < t2]) and: [u1 > 0]] whileTrue: [			u1 := u1 + v.			u2 := u2 + u].			u1 := u1 - t1.		u2 := u2 - t2.		u3 := u3 - t3.		t3 > 0] whileTrue: ["loop while t3 > 0"].	[u1 >= v and: [u2 >= u]] whileTrue: [		u1 := u1 - v.		u2 := u2 - u].	u3 = 1 ifFalse: [self error: 'no inverse'].	^ u - u2! !!DigitalSignatureAlgorithm methodsFor: 'large integer arithmetic' stamp: 'nice 8/28/2010 21:21' prior: 50923879!isProbablyPrime: p	"Answer true if p is prime with very high probability. Such a number is sometimes called an 'industrial grade prime'--a large number that is so extremely likely to be prime that it can assumed that it actually is prime for all practical purposes. This implementation uses the Rabin-Miller algorithm (Schneier, p. 159)."	| iterations factor pMinusOne b m r a j z couldBePrime |	iterations := 50.  "Note: The DSA spec requires >50 iterations; Schneier says 5 are enough (p. 260)"	"quick elimination: check for p divisible by a small prime"	SmallPrimes ifNil: [  "generate list of small primes > 2"		SmallPrimes := Integer primesUpTo: 2000.		SmallPrimes := SmallPrimes copyFrom: 2 to: SmallPrimes size].	factor := SmallPrimes detect: [:f | (p \\ f) = 0] ifNone: [nil].	factor ifNotNil: [^ p = factor].	pMinusOne := p - 1.	b := self logOfLargestPowerOfTwoDividing: pMinusOne.	m := pMinusOne bitShift: b negated.	"Assert: pMinusOne = m * (2 raisedTo: b) and m is odd"	Transcript show: '      Prime test pass '.	r := Random new.	1 to: iterations do: [:i |		Transcript show: i printString; space.		a := (r next * 16rFFFFFF) truncated.		j := 0.		z := (a raisedTo: m modulo: p) normalize.		couldBePrime := z = 1.		[couldBePrime] whileFalse: [			z = 1 ifTrue: [Transcript show: 'failed!!'; cr. ^ false].  "not prime"			z = pMinusOne				ifTrue: [couldBePrime := true]				ifFalse: [					(j := j + 1) < b						ifTrue: [z := (z * z) \\ p]						ifFalse: [Transcript show: 'failed!!'; cr. ^ false]]]].  "not prime"	Transcript show: 'passed!!'; cr.	^ true  "passed all tests; probably prime"! !!DigitalSignatureAlgorithm methodsFor: 'private' stamp: 'nice 8/28/2010 21:04' prior: 50932159!logOfLargestPowerOfTwoDividing: aPositiveInteger	"Answer the base-2 log of the largest power of two that divides the given integer. For example, the largest power of two that divides 24 is 8, whose log base-2 is 3. Do this efficiently even when the given number is a large integer. Assume that the given integer is > 0."	"DigitalSignatureAlgorithm new logOfLargestPowerOfTwoDividing: (32 * 3)"	^aPositiveInteger lowBit - 1! !"System"!!StringMorph methodsFor: 'menu' stamp: 'ul 8/23/2010 00:49' prior: 52714040!changeFont		| chooser originalFont |	originalFont := self fontToUse.	self openModal: (		Cursor wait showWhile: [			| window |			window := UIManager default 				chooseFont: 'Choose a Font' 				for: self 				setSelector: #font: 				getSelector: originalFont.			"We have to save the model here, because it will be gone when the window is closed."			chooser := window model. 			window ]).	originalFont = self fontToUse ifFalse: [		"Ensure that we restore the original font in case it was changed, but Cancel was clicked."		self font: (chooser result ifNil: [ originalFont ]) ]! !!PluggableTextMorph methodsFor: 'model access' stamp: 'jmv 3/2/2010 16:21' prior: 26510078!getSelection	"Answer the model's selection interval."	getSelectionSelector ifNil: [^1 to: 0].	"null selection"	^model perform: getSelectionSelector! !!PluggableTextMorph methodsFor: 'model access' stamp: 'jmv 3/2/2010 16:22' prior: 26510318!getText	"Retrieve the current model text"	| newText |	getTextSelector ifNil: [^Text new].	newText := model perform: getTextSelector.	newText ifNil: [^Text new].	^newText shallowCopy! !!PluggableListMorph methodsFor: 'events' stamp: 'jmv 3/2/2010 16:21' prior: 58705997!doubleClick: event	| index |	doubleClickSelector ifNil: [^super doubleClick: event].	index := self rowAtLocation: event position.	index = 0 ifTrue: [^super doubleClick: event].	"selectedMorph ifNil: [self setSelectedMorph: aMorph]."	^ self model perform: doubleClickSelector! !!PluggableListMorph methodsFor: 'model access' stamp: 'jmv 3/2/2010 16:21' prior: 26396901!getCurrentSelectionIndex	"Answer the index of the current selection."	getIndexSelector ifNil: [^0].	^model perform: getIndexSelector! !!Morph methodsFor: 'printing' stamp: 'jmv 3/2/2010 16:15' prior: 24332115!colorString: aColor 	aColor ifNil: [^'nil'].	Color colorNames 		do: [:colorName | aColor = (Color perform: colorName) ifTrue: [^'Color ' , colorName]].	^aColor storeString! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 3/2/2010 16:16' prior: 24128410!formerOwner: aMorphOrNil 	aMorphOrNil 		ifNil: [self removeProperty: #formerOwner]		ifNotNil: [self setProperty: #formerOwner toValue: aMorphOrNil]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jmv 3/2/2010 16:16' prior: 24128767!formerPosition: formerPosition 	formerPosition 		ifNil: [self removeProperty: #formerPosition]		ifNotNil: [self setProperty: #formerPosition toValue: formerPosition]! !!ScrollBar methodsFor: 'scroll timing' stamp: 'jmv 3/2/2010 16:29' prior: 28637730!waitForDelay1: delay1 delay2: delay2 	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll ifNil: [self resetTimer].	"Only needed for old instances"	now := Time millisecondClockValue.	(scrollDelay := currentScrollDelay) isNil 		ifTrue: [scrollDelay := delay1	"initial delay"].	currentScrollDelay := scrollDelay * 9 // 10 max: delay2.	"decrease the delay"	timeOfLastScroll := now.	^true! !!GrafPort methodsFor: 'copying' stamp: 'jmv 3/2/2010 16:02' prior: 21300030!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31]) 		ifTrue: [			self copyBitsTranslucent: (alpha ifNil: [255])]		ifFalse: [super copyBits]! !!TextMorph methodsFor: 'geometry' stamp: 'jmv 3/2/2010 16:42' prior: 31340084!privateMoveBy: delta 	super privateMoveBy: delta.	editor 		ifNil: [ paragraph ifNotNil: [paragraph moveBy: delta]]		ifNotNil: [ 			"When moving text with an active editor, save and restore all state."			paragraph moveBy: delta.			self installEditorToReplace: editor]! !!MenuMorph methodsFor: 'accessing' stamp: 'nice 8/27/2010 22:00' prior: 23633477!lastSelection	"Return the label of the last selected item or nil."	^selectedItem ifNotNil: [selectedItem selector]! !!PluggableButtonMorph methodsFor: 'private' stamp: 'jmv 3/2/2010 16:21' prior: 26313281!getModelState	"Answer the result of sending the receiver's model the getStateSelector message."	^ getStateSelector 		ifNil: [false]		ifNotNil: [model perform: getStateSelector]! !!HaloMorph methodsFor: 'geometry testing' stamp: 'jmv 3/2/2010 16:02' prior: 21421111!containsPoint: aPoint 	"This method is overridden so that, once up, the handles will stay up as long as the mouse is within the box that encloses all the handles even if it is not over any handle or over its owner."	^target		ifNil: [super containsPoint: aPoint] 		ifNotNil: [false]! !!MorphExtension methodsFor: 'accessing - other properties' stamp: 'jmv 7/28/2009 18:15' prior: 51866310!privateOtherProperties: anIdentityDictionary 	"private - change the receiver's otherProperties"	otherProperties := anIdentityDictionary ! !!PolygonMorph methodsFor: 'smoothing' stamp: 'jmv 3/2/2010 16:22' prior: 26635957!computeNextToEndPoints	| pointAfterFirst pointBeforeLast |	pointAfterFirst := nil.	self lineSegmentsDo: 			[:p1 :p2 | 			pointAfterFirst ifNil: [pointAfterFirst := p2 asIntegerPoint].			pointBeforeLast := p1 asIntegerPoint].	curveState at: 2 put: pointAfterFirst.	curveState at: 3 put: pointBeforeLast! !!TextEditor methodsFor: 'accessing' stamp: 'jmv 3/2/2010 17:20' prior: 57304452!replaceSelectionWith: aText	"Remember the selection text in UndoSelection.	 Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and PriorInterval.	 Set up undo to use UndoReplace."	beginTypeInBlock ifNotNil: [^self zapSelectionWith: aText]. "called from old code"	UndoSelection := self selection.	self zapSelectionWith: aText.	self undoer: #undoReplace! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jmv 3/2/2010 16:11' prior: 23606027!contentString: aString 	aString 		ifNil: [self removeProperty: #contentString]		ifNotNil: [self setProperty: #contentString toValue: aString]! !!TextURL methodsFor: '*Morphic' stamp: 'rbb 2/18/2005 09:24'!actOnClickFor: anObject	"Do what you can with this URL.  Later a web browser."	| response m |	(url beginsWith: 'sqPr://') ifTrue: [		ProjectLoading thumbnailFromUrl: (url copyFrom: 8 to: url size).		^self		"should not get here, but what the heck"	].	"if it's a web browser, tell it to jump"	anObject isWebBrowser		ifTrue: [anObject jumpToUrl: url. ^ true]		ifFalse: [((anObject respondsTo: #model) and: [anObject model isWebBrowser])				ifTrue: [anObject model jumpToUrl: url. ^ true]].		"if it's a morph, see if it is contained in a web browser"		(anObject isKindOf: Morph) ifTrue: [			m := anObject.			[ m ~= nil ] whileTrue: [				(m isWebBrowser) ifTrue: [					m  jumpToUrl: url.					^true ].				(m hasProperty: #webBrowserView) ifTrue: [					m model jumpToUrl: url.					^true ].				m := m owner. ]		].	"no browser in sight.  ask if we should start a new browser"	((self confirm: 'open a browser to view this URL?' translated) and: [WebBrowser default notNil]) ifTrue: [		WebBrowser default openOnUrl: url.		^ true ].	"couldn't display in a browser.  Offer to put up just the source"	response := (UIManager default 				chooseFrom: (Array with: 'View web page as source' translated									with: 'Cancel' translated)				title:  'Couldn''t find a web browser. View\page as source?' withCRs translated).	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !!PasteUpMorph methodsFor: 'structure' stamp: 'jmv 3/2/2010 16:10' prior: 25884968!world	worldState ifNil: [^super world].	^self! !!MorphicAlarm methodsFor: 'evaluating' stamp: 'jmv 3/2/2010 16:18' prior: 57430207!value: anArgument	| nArgs |	numArgs ifNil:[numArgs := selector numArgs].	nArgs := arguments ifNil:[0] ifNotNil:[arguments size].	nArgs = numArgs ifTrue:[		"Ignore extra argument"		^self value].	^arguments		ifNil: [ receiver perform: selector with: anArgument]		ifNotNil: [ receiver perform: selector withArguments: (arguments copyWith: anArgument)]! !!UTF8TextConverter commentStamp: '<historical>' prior: 59455539!Text converter for UTF-8.  Since the BOM is used to distinguish the MacRoman code and UTF-8 code, BOM is written for UTF-8 by #writeBOMOn: which is called by client.!!UTF8TextConverter class methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:11' prior: 59036298!decodeByteString: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream lastIndex nextIndex byte1 byte2 byte3 byte4 unicode |	lastIndex := 1.	(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0		ifTrue: [ ^aByteString ].	outStream := (String new: aByteString size) writeStream.	[		outStream next: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex.		byte1 := aByteString byteAt: nextIndex.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[	^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63)].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63)].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte2 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte3 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte3 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			byte4 := aByteString byteAt: (nextIndex := nextIndex + 1).			(byte4 bitAnd: 16rC0) = 16r80 ifFalse:[ ^self errorMalformedInput: aByteString ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63)].		unicode ifNil: [ ^self errorMalformedInput: aByteString ].		unicode = 16rFEFF ifFalse: [ "Skip byte order mark"			outStream nextPut: (Unicode value: unicode) ].		lastIndex := nextIndex + 1.		(nextIndex := ByteString findFirstInString: aByteString inSet: latin1Map startingAt: lastIndex) = 0 ] whileFalse.	^outStream 		next: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex;		contents! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."	self strictUtf8Conversions ifTrue:[		self error: 'Invalid utf8: ', aString	].	^aString! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions	"Preference setter for strict utf-8 conversions"	<preference: 'Strict utf8 conversions'		category: 'general' "should this be localization?"		description: 'If true, invalid utf-8 input will raise errors. If false, invalid utf-8 input will be allowed to pass through the conversion unchanged'		type: #Boolean>		^StrictUtf8Conversions ifNil:[true]! !!UTF8TextConverter class methodsFor: 'utilities' stamp: 'ar 9/1/2010 18:16'!strictUtf8Conversions: aBool	"Preference setter for strict utf-8 conversions"	StrictUtf8Conversions := aBool.! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21'!errorMalformedInput: aString	"Invalid UTF-8 input has been detected in the given string.	Raise an error if strict conversions are enabled, otherwise allow	the original string to be returned."		^self class errorMalformedInput: aString! !!UTF8TextConverter methodsFor: 'conversion' stamp: 'ar 9/1/2010 18:21' prior: 34005366!nextFromStream: aStream	| char1 value1 char2 value2 unicode char3 value3 char4 value4 |	aStream isBinary ifTrue: [^ aStream basicNext].	char1 := aStream basicNext.	char1 ifNil:[^ nil].	value1 := char1 asciiValue.	value1 <= 127 ifTrue: [		"1-byte char"		^ char1	].	"at least 2-byte char"	char2 := aStream basicNext.	char2 ifNil:[^self errorMalformedInput: (String with: char1)].	value2 := char2 asciiValue.	(value1 bitAnd: 16rE0) = 192 ifTrue: [		^ Unicode value: ((value1 bitAnd: 31) bitShift: 6) + (value2 bitAnd: 63).	].	"at least 3-byte char"	char3 := aStream basicNext.	char3 ifNil:[^self errorMalformedInput: (String with: char1 with: char2)].	value3 := char3 asciiValue.	(value1 bitAnd: 16rF0) = 224 ifTrue: [		unicode := ((value1 bitAnd: 15) bitShift: 12) + ((value2 bitAnd: 63) bitShift: 6)				+ (value3 bitAnd: 63).	].	(value1 bitAnd: 16rF8) = 240 ifTrue: [		"4-byte char"		char4 := aStream basicNext.		char4 ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].		value4 := char4 asciiValue.		unicode := ((value1 bitAnd: 16r7) bitShift: 18) +					((value2 bitAnd: 63) bitShift: 12) + 					((value3 bitAnd: 63) bitShift: 6) +					(value4 bitAnd: 63).	].	unicode ifNil:[^self errorMalformedInput: (String with: char1 with: char2 with: char3)].	unicode > 16r10FFFD ifTrue: [		^self errorMalformedInput: (String with: char1 with: char2 with: char3).	].		unicode = 16rFEFF ifTrue: [^ self nextFromStream: aStream].	^ Unicode value: unicode.! !UTF8TextConverter removeSelector: #errorMalformedInput!UTF8TextConverter class removeSelector: #errorMalformedInput!"Multilingual"!!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:30'!testLazyConversion	"Ensure the lazy conversions do what they should"	| strict result |	strict := UTF8TextConverter strictUtf8Conversions.	[UTF8TextConverter strictUtf8Conversions: false.	self shouldnt:[result := 'Grüß Gott' utf8ToSqueak ] raise: Error.	] ensure:[UTF8TextConverter strictUtf8Conversions: strict].	self assert: result = 'Grüß Gott'.! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:29'!testSqueakToUtf8	"Ensure proper encoding"	self assert: '' squeakToUtf8 equals: ''.	self assert: 'Hello World' squeakToUtf8 equals: 'Hello World'.	self assert: 'Grüß Gott' squeakToUtf8 asByteArray 		equals: #[71 114 195 188 195 159 32 71 111 116 116]! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:27'!testStrictConversion	"Ensure the strict conversions do what they should"	| strict |	strict := UTF8TextConverter strictUtf8Conversions.	[UTF8TextConverter strictUtf8Conversions: true.	self should:[ 'Grüß Gott' utf8ToSqueak ] raise: Error.	] ensure:[UTF8TextConverter strictUtf8Conversions: strict].! !!UTF8TextConverterTest methodsFor: 'tests' stamp: 'ar 9/1/2010 18:28'!testUtf8ToSqueak	"Ensure proper encoding"	self assert: '' utf8ToSqueak equals: ''.	self assert: 'Hello World' utf8ToSqueak equals: 'Hello World'.	self assert: #[71 114 195 188 195 159 32 71 111 116 116] asString utf8ToSqueak		equals: 'Grüß Gott'! !"MultilingualTests"!!HttpUrlTest methodsFor: 'as yet unclassified' stamp: 'ar 9/1/2010 00:31'!testHttps	self assert: 'https://encrypted.google.com' asUrl class == HttpUrl! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/22/2010 13:28'!testUpToAllAsciiVsBinary	"Tests correct behavior of #upToAll"	serverStream ascii.	clientStream nextPutAll:'A line of text', String crlf, 'with more text'; flush.	self assert: (serverStream upToAll: #[13 10]) = 'A line of text'.	serverStream binary.	clientStream nextPutAll: String crlf; flush.	self assert: (serverStream upToAll: String crlf) asString = 'with more text'.! !!SocketStreamTest methodsFor: 'stream protocol' stamp: 'ar 8/22/2010 13:28'!testUpToAsciiVsBinary	"Tests correct behavior of #upTo:"	serverStream ascii.	clientStream nextPutAll:'A line of text', String cr, 'with more text'; flush.	self assert: (serverStream upTo: 13) = 'A line of text'.	serverStream binary.	clientStream nextPutAll: String cr; flush.	self assert: (serverStream upTo: Character cr) asString = 'with more text'.! !"NetworkTests"!!ObjectWithDocumentation methodsFor: 'documentation' stamp: 'nice 8/27/2010 20:52' prior: 25121837!editDescription	"Allow the user to see and edit the documentation for this object"	| reply helpMessage |	helpMessage := self documentation ifNil: [String new].	reply := UIManager default				multiLineRequest: 'Kindly edit the description' translated				centerAt: Sensor cursorPoint				initialAnswer: helpMessage				answerHeight: 200.	reply isEmptyOrNil		ifFalse: [self documentation: reply]! !"Protocols"!!TestResource class methodsFor: 'accessing' stamp: 'nice 8/27/2010 18:02' prior: 31122770!current	^ current ifNil: [ current := self new]			! !!TestResource class methodsFor: 'Creation' stamp: 'nice 8/27/2010 18:02' prior: 31123063!reset	current ifNotNil: [:oldCurrent |		current := nil.		oldCurrent tearDown]! !!TestResource methodsFor: 'accessing' stamp: 'jmv 3/2/2010 16:40' prior: 31121337!description	^description ifNil: [ '' ]! !!TestResource methodsFor: 'accessing' stamp: 'jmv 3/2/2010 16:40' prior: 31121541!name	^name ifNil: [ self printString]! !!SUnitExtensionsTest methodsFor: 'accessing' stamp: 'nice 8/27/2010 21:01' prior: 28086301!stream	^stream ifNil: [stream := WriteStream on: String new]! !!TestSuite methodsFor: 'Accessing' stamp: 'nice 8/27/2010 17:59' prior: 31151324!resources	^ resources ifNil: [resources := self defaultResources]			! !!TestSuite methodsFor: 'Accessing' stamp: 'nice 8/27/2010 17:59' prior: 31151540!tests	^ tests ifNil: [tests := OrderedCollection new]			! !"SUnit"!!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:40' prior: 58617847!testBalloon	self testPackage: 'Balloon' dependsExactlyOn: #(		Kernel Collections Graphics System	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:41' prior: 58618032!testCollections	self testPackage: 'Collections' dependsExactlyOn: #(		Compiler		Kernel		Compression		Exceptions		Files		Graphics		Multilingual		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:42' prior: 58618826!testEtoys	self testPackage: 'EToys' dependsExactlyOn: #(		Balloon		Collections		Compiler		Exceptions		Files		Graphics		Kernel		Morphic		MorphicExtras		Network		Protocols		System		'ToolBuilder-Kernel'		Tools		SUnit	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:44' prior: 59168953!testSUnitGUI	self testPackage: 'SUnitGUI' dependsExactlyOn: #(		Collections		Graphics		Kernel		PackageInfo		SUnit		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:44' prior: 58625538!testShoutCore	self testPackage: 'ShoutCore' dependsExactlyOn: #(		Collections		Graphics		Kernel		Monticello		System		Compiler	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:46' prior: 58625738!testSound	self testPackage: 'Sound' dependsExactlyOn: #(		Collections		Balloon		Files		Graphics		Kernel		Morphic		MorphicExtras		Network		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/1/2010 22:46' prior: 58626393!testToolBuilder	self testPackage: 'ToolBuilder-Kernel' dependsExactlyOn: #(		Collections		Files		Graphics		Kernel		SUnit		System	).! !!ExceptionTests methodsFor: 'testing' stamp: 'ar 9/1/2010 22:43'!testHandlerReentrancy	| callingOrder |	"Handlers are not re-entrant by default, so inner is not activated twice"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex pass]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sio'.	"Now make inner re-entrant"	callingOrder := String streamContents: [:stream |		[[stream nextPut: $s. Notification signal]					"Inner handler"			on: Notification do: [:ex |				stream nextPut: $i.				ex rearmHandlerDuring: [ex pass]]]					"outer handler"			on: Notification do: [:ex |				stream nextPut: $o.				Notification signal]].			self assert: callingOrder = 'sioi'.! !"Tests"!!CodeHolder methodsFor: 'diffs' stamp: 'sw 2/3/2001 00:10'!showingTiles	"Answer whether the receiver is currently showing tiles"	^ contentsSymbol == #tiles! !!TranscriptStream class methodsFor: '*Tools' stamp: 'dtl 10/4/2009 23:44'!buildWith: aBuilder	^(Smalltalk at: #Transcript) buildWith: aBuilder! !!TranscriptStream class methodsFor: '*Tools' stamp: 'ar 8/7/2009 22:24'!openMorphicTranscript	"Have the current project's transcript open up as a morph"	^ToolBuilder open: self! !!TranscriptStream class methodsFor: '*Tools' stamp: 'sw 2/26/2002 14:46'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name wording: 'Transcript' brightColor: #lightOrange pastelColor: #paleOrange helpMessage: 'The system transcript'! !!TranscriptStream methodsFor: '*Tools' stamp: 'ar 2/11/2005 20:36'!buildWith: builder	| windowSpec textSpec |	windowSpec := builder pluggableWindowSpec new.	windowSpec model: self.	windowSpec label: 'Transcript'.	windowSpec children: OrderedCollection new.	textSpec := builder pluggableTextSpec new.	textSpec 		model: self;		menu: #codePaneMenu:shifted:;		frame: (0@0corner: 1@1).	windowSpec children add: textSpec.	^builder build: windowSpec! !!TranscriptStream methodsFor: '*Tools' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: '*Tools' stamp: 'mp 2/2/2010 20:36'!open	| openCount |	openCount := self countOpenTranscripts.	openCount = 0		ifTrue: [self openLabel: 'Transcript']		ifFalse: [self openLabel: 'Transcript #' , (openCount+1) printString]! !!TranscriptStream methodsFor: '*Tools' stamp: 'ar 8/7/2009 22:28'!openLabel: aString 	"Open a window on this transcriptStream"	^ToolBuilder open: self label: aString! !"Tools"!!Url commentStamp: '<historical>' prior: 32785903!A Uniform Resource Locator.  It specifies the location of a document on the Internet.  The base class is abstract; child classes break different types of URLs down in ways appropriate for that type.!!FileStream class methodsFor: '*network' stamp: 'stephaneducasse 2/4/2006 20:32' prior: 20689308!httpPostDocument: url args: argsDict	| argString |	argString := argsDict		ifNotNil: [argString := HTTPSocket argString: argsDict]		ifNil: [''].	^self post: argString url: url , argString ifError: [self halt]! !!FileStream class methodsFor: '*network' stamp: 'nice 12/27/2009 03:11' prior: 55069650!httpPostMultipart: url args: argsDict	| mimeBorder argsStream crLf resultStream result |	" do multipart/form-data encoding rather than x-www-urlencoded "	crLf := String crlf.	mimeBorder := '----squeak-', Time millisecondClockValue printString, '-stuff-----'.	"encode the arguments dictionary"	argsStream := WriteStream on: String new.	argsDict associationsDo: [:assoc |		assoc value do: [ :value | | fieldValue |		"print the boundary"		argsStream nextPutAll: '--', mimeBorder, crLf.		" check if it's a non-text field "		argsStream nextPutAll: 'Content-disposition: form-data; name="', assoc key, '"'.		(value isKindOf: MIMEDocument)			ifFalse: [fieldValue := value]			ifTrue: [argsStream nextPutAll: ' filename="', value url pathForFile, '"', crLf, 'Content-Type: ', value contentType.				fieldValue := (value content					ifNil: [(FileStream fileNamed: value url pathForFile) contentsOfEntireFile]					ifNotNil: [value content]) asString]." Transcript show: 'field=', key, '; value=', fieldValue; cr. "		argsStream nextPutAll: crLf, crLf, fieldValue, crLf.	]].	argsStream nextPutAll: '--', mimeBorder, '--'.	resultStream := self		post: 			('Content-type: multipart/form-data; boundary=', mimeBorder, crLf,			'Content-length: ', argsStream contents size printString, crLf, crLf, 			argsStream contents)		url: url ifError: [^'Error in post ' url asString].	"get the header of the reply"	result := resultStream upToEnd.	^MIMEDocument content: result! !!FileStream class methodsFor: '*network' stamp: 'mir 2/2/2001 14:23' prior: 20691173!post: data target: target url: url ifError: errorBlock	^self concreteStream new post: data target: target url: url ifError: errorBlock! !!FileStream class methodsFor: '*network' stamp: 'mir 2/2/2001 14:23' prior: 20691391!post: data url: url ifError: errorBlock	^self post: data target: nil url: url ifError: errorBlock! !!FileStream class methodsFor: '*network' stamp: 'stephaneducasse 2/4/2006 20:32' prior: 20691584!requestURL: url target: target	"FileStream requestURL:'http://isgwww.cs.uni-magdeburg.de/~raab' target: ':=blank' "	^self concreteStream new requestURL: url target: target! !!FileStream class methodsFor: '*network' stamp: '' prior: 20691812!requestURLStream: url	"FileStream requestURLStream:'http://isgwww.cs.uni-magdeburg.de/~raab'"	^self concreteStream new requestURLStream: url! !!FileStream class methodsFor: '*network' stamp: '' prior: 20692009!requestURLStream: url ifError: errorBlock	"FileStream requestURLStream:'http://isgwww.cs.uni-magdeburg.de/~raab'"	^self concreteStream new requestURLStream: url ifError: errorBlock! !!FileStream methodsFor: '*network-url' stamp: 'gk 2/10/2004 13:21' prior: 20683608!asUrl	"Convert my path into a file:// type url - a FileUrl."		^FileUrl pathParts: (self directory pathParts copyWith: self localName)! !!ImageReadWriter class methodsFor: '*network' stamp: 'nice 12/27/2009 03:11' prior: 55004018!formFromServerFile: fileName	"Answer a ColorForm stored on the file with the given name.  Meant to be called from during the getting of updates from the server.  That assures that (Utilities serverUrls) returns the right group of servers."	| urls |	urls := Utilities serverUrls collect:		[:url | url, fileName].  " fileName starts with: 'updates/'  "	urls do: [:aURL | | form doc |		(fileName findTokens: '.') last asLowercase = 'gif' ifTrue: [			form := HTTPSocket httpGif: aURL.			form = (ColorForm extent: 20@20 depth: 8) 				ifTrue: [self inform: 'The file ',aURL,' is ill formed.'].			^ form].		(fileName findTokens: '.') last asLowercase = 'bmp' ifTrue: [			doc := HTTPSocket httpGet: aURL accept: 'image/bmp'.			form := Form fromBMPFile: doc.			doc close.			form ifNil: [self inform: 'The file ',aURL,' is ill formed.'. ^ Form new]				ifNotNil: [^ form]].		self inform: 'File ', fileName, 'does not end with .gif or .bmp'].	self inform: 'That file not found on any server we know'.! !!Text methodsFor: '*network-url' stamp: 'ls 7/14/1998 03:17' prior: 31179685!asUrl	^self asString asUrl! !!Text methodsFor: '*network-url' stamp: 'ls 7/14/1998 03:20' prior: 31179777!asUrlRelativeTo: aUrl	^self asString asUrlRelativeTo: aUrl! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ar 9/4/2010 10:47' prior: 34109025!httpRequest: method url: urlString headers: hdrs content: contentOrNil response: responseBlock	"Sends an HTTP request to the server. Returns a MIMEDocument if successful,	a string indicating the error otherwise. If a response block is provided, the	response is fed into into so that the sender can see all the headers.	The url string is assumed to be properly escaped by the sender."	| index serverAndPort server port rawUrl stream resp code headers 	  contentLength contentType contentStream |	(urlString beginsWith: 'http://') ifFalse:[self error: 'Not a http url'].	"Extract server, port, and url"	index := urlString indexOf: $/ startingAt: 8 ifAbsent:[urlString size+1]. "past http://"	serverAndPort := urlString copyFrom: 8 to: index-1.	server := serverAndPort copyUpTo: $:.	port := ((serverAndPort copyAfter: $:) ifEmpty:['80']) asNumber.	"Prepare the request URI"	rawUrl := urlString copyFrom: index to: urlString size.	(rawUrl beginsWith: '/') ifFalse:[rawUrl := '/', rawUrl].	"Check for proxy"	(self shouldUseProxy: server) ifTrue:[		self httpProxyServer ifNotEmpty:[			rawUrl := 'http://', serverAndPort, rawUrl. "per RFC 2616"			server := self httpProxyServer.			port := self httpProxyPort.		].	].	"Fire off the request"	stream := SocketStream openConnectionToHostNamed: server port: port.	stream nextPutAll: method; space; nextPutAll: rawUrl; space; nextPutAll: 'HTTP/1.0'; crlf.	stream nextPutAll: 'Host: ', serverAndPort; crlf.	stream nextPutAll: 'Connection: close'; crlf.	stream nextPutAll: 'User-Agent: ', self userAgentString; crlf.	stream nextPutAll: hdrs.	stream crlf.	contentOrNil ifNotNil:[		"Upload request content"		contentStream := contentOrNil readStream.		[contentStream atEnd] whileFalse:[			(HTTPProgress new) total: contentOrNil size; 				amount: contentStream position; signal: 'Uploading...'.			stream nextPutAll: (contentStream next: 4096).			stream flush.		].	].	stream flush.	"Read the response"	resp := stream upToAll: String crlfcrlf.	"Extract the response code"	code := ((resp copyUpTo: String cr) findTokens: ' ') second asNumber.	"And the response headers"	headers := Dictionary new.	resp lines allButFirst allButLast do:[:nextLine|		headers at: (nextLine copyUpTo: $:) asLowercase 			put: (nextLine copyAfter: $:) withBlanksTrimmed.	].	"Read response content"	contentLength := headers at: 'content-length' ifAbsent:[nil].	contentType := headers at: 'content-type' ifAbsent:['application/octet-stream'].	"Fixme - Provide HTTProgress"	contentLength 		ifNil:[contentStream := WriteStream with: stream upToEnd]		ifNotNil:[			contentLength := contentLength asNumber.			contentStream := (String new: contentLength) writeStream. 			[contentStream position < contentLength] whileTrue:[				contentStream nextPutAll: 					(stream next: (contentLength - contentStream position min: 4096)).				(HTTPProgress new) total: contentLength; 					amount: contentStream position; signal: 'Downloading...'.			].		].	stream close.	responseBlock ifNotNil:[responseBlock value: resp].	^(code between: 200 and: 299) 		ifTrue:[MIMEDocument contentType: contentType 				content: contentStream contents url: urlString]		ifFalse:[resp asString, contentStream contents].! !!Url class methodsFor: 'class initialization' stamp: 'fbs 9/2/2010 12:55'!initialize	super initialize.	SchemeRegistry := Dictionary new.	SchemeRegistry		at: 'browser' put: BrowserUrl;		at: 'file' put: FileUrl;		at: 'ftp' put: FtpUrl;		at: 'http' put: HttpUrl;		at: 'https' put: HttpUrl;		at: 'mailto' put: MailtoUrl.! !!Url class methodsFor: 'class initialization' stamp: 'fbs 9/2/2010 12:55'!registerUrlClass: aClass forScheme: aString	SchemeRegistry at: aString put: aClass.! !!Url class methodsFor: 'parsing' stamp: 'fbs 9/2/2010 12:56' prior: 34345727!urlClassForScheme: scheme	^ SchemeRegistry at: scheme ifAbsent: [GenericUrl].! !!FileDirectory methodsFor: '*network-url' stamp: 'gk 2/10/2004 13:22' prior: 20473909!asUrl	"Convert my path into a file:// type url - a FileUrl."		^FileUrl pathParts: (self pathParts copyWith: '')! !!String methodsFor: '*network-url' stamp: 'ar 9/4/2010 11:23'!urlEncoded	"Encode the receiver, which is assumed to be URL, properly.	This method is specific to URLs in such that it will parse	the url and perform a semantically correct substitution, for example:	'http://squeak.org/name with space?and=value' encodeForHTTP.	=> 'http%3A%2F%2Fsqueak.org%2Fname%20with%20space%3Fand%3Dvalue'			'http://squeak.org/name with space?and=value' urlEncoded.	=> 'http://squeak.org/name%20with%20space?and=value"	^self asUrl asString! !"Network"!!FileStream methodsFor: '*Compression' stamp: 'ar 9/5/2010 08:55' prior: 54525658!viewGZipContents	"View the contents of a gzipped file"	| stringContents |	self binary.	stringContents := self contentsOfEntireFile.	stringContents := Cursor wait showWhile: [(GZipReadStream on: stringContents) upToEnd].	stringContents := stringContents asString withSqueakLineEndings.	UIManager default		edit: stringContents;		label: 'Decompressed contents of: ', self localName! !!StandardFileStream methodsFor: '*Compression' stamp: 'stephaneducasse 2/4/2006 20:32' prior: 29784283!compressFile	"Write a new file that has the data in me compressed in GZip format."	| zipped buffer |	self readOnly; binary.	zipped := self directory newFileNamed: (self name, FileDirectory dot, 'gz').	zipped binary; setFileTypeToObject.		"Type and Creator not to be text, so can be enclosed in an email"	zipped := GZipWriteStream on: zipped.	buffer := ByteArray new: 50000.	'Compressing ', self fullName displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during: [:bar |			[self atEnd] whileFalse: [				bar value: self position.				zipped nextPutAll: (self nextInto: buffer)].			zipped close.			self close].	^zipped! !!ReadWriteStream methodsFor: '*Compression' stamp: 'yo 7/16/2003 14:59' prior: 27509617!asUnZippedStream	| isGZip outputStream first strm archive which |	"Decompress this file if needed, and return a stream.  No file is written.  File extension may be .gz or anything else.  Also works on archives (.zip, .gZip)."	strm := self binary.	strm isZipArchive ifTrue: [		archive := ZipArchive new readFrom: strm.		which := archive members detect: [:any | any fileName asLowercase endsWith: '.ttf'] 								ifNone: [nil].		which ifNil: [archive close.					^ self error: 'Can''t find .ttf file in archive'].		strm := which contentStream.		archive close].	first := strm next.	isGZip := (strm next * 256 + first) = (GZipConstants gzipMagic).	strm skip: -2.	isGZip 		ifTrue: [outputStream := (MultiByteBinaryOrTextStream with:									(GZipReadStream on: strm) upToEnd) reset.				strm close]		ifFalse: [outputStream := strm].	^ outputStream! !!ReadWriteStream methodsFor: '*Compression' stamp: 'nk 8/21/2004 15:47' prior: 27515844!isZipArchive	"Determine if this appears to be a valid Zip archive"	| sig |	self binary.	sig := self next: 4.	self position: self position - 4. "rewind"	^ZipArchive validSignatures includes: sig! !!ZipArchive class methodsFor: 'constants' stamp: 'ar 9/6/2010 15:29' prior: 33409300!findEndOfCentralDirectoryFrom: stream	"Seek in the given stream to the end, then read backwards until we find the	signature of the central directory record. Leave the file positioned right	before the signature.	Answers the file position of the EOCD, or 0 if not found."	| data fileLength seekOffset pos maxOffset |	stream setToEnd.	fileLength := stream position.	"If the file length is less than 18 for the EOCD length plus 4 for the signature, we have a problem"	fileLength < 22 ifTrue: [^ self error: 'file is too short'].		seekOffset := 0.	pos := 0.	data := ByteArray new: 4100.	maxOffset := 40960 min: fileLength.	"limit search range to 40K"	[		seekOffset := (seekOffset + 4096) min: fileLength.		stream position: fileLength - seekOffset.		data := stream next: (4100 min: seekOffset) into: data startingAt: 1.		pos := self lastIndexOfPKSignature: EndOfCentralDirectorySignature in: data.		pos = 0 and: [seekOffset < maxOffset]	] whileTrue.	^ pos > 0		ifTrue: [ | newPos | stream position: (newPos := (stream position + pos - seekOffset - 1)). newPos]		ifFalse: [0]! !!ZipArchive class methodsFor: 'constants' stamp: 'ar 9/6/2010 15:28'!lastIndexOfPKSignature: aSignature in: data	"Answer the last index in data where aSignature (4 bytes long) occurs, or 0 if not found"	| a b c d |	a := aSignature first.	b := aSignature second.	c := aSignature third.	d := aSignature fourth.	(data size - 3) to: 1 by: -1 do: [ :i |		(((data at: i) = a)			and: [ ((data at: i + 1) = b)				and: [ ((data at: i + 2) = c)					and: [ ((data at: i + 3) = d) ]]])						ifTrue: [ ^i ]	].	^0! !!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:39' prior: 21242540!initialize	FileServices registerFileReader: self! !!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:39' prior: 21242678!unload	FileServices unregisterFileReader: self! !!PositionableStream methodsFor: '*Compression' stamp: 'ar 1/2/2000 15:32' prior: 26698527!asZLibReadStream	^ZLibReadStream on: collection from: position+1 to: readLimit! !!String methodsFor: '*Compression' stamp: 'yo 11/3/2004 19:24' prior: 30178708!unzipped	| magic1 magic2 |	magic1 := (self at: 1) asInteger.	magic2 := (self at: 2) asInteger.	(magic1 = 16r1F and:[magic2 = 16r8B]) ifFalse:[^self].	^(GZipReadStream on: self) upToEnd! !!String methodsFor: '*Compression' stamp: 'dgd 11/26/2005 21:19' prior: 30184675!zipped	| stream gzstream |	stream := RWBinaryOrTextStream on: String new.	gzstream := GZipWriteStream on: stream.	gzstream nextPutAll: self.	gzstream close.	stream reset.	^ stream contents.! !!GZipReadStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:39' prior: 21228916!unload	FileServices unregisterFileReader: self ! !"Compression"!String removeSelector: #lastIndexOfPKSignature:!ByteArray removeSelector: #lastIndexOfPKSignature:!"Collections"!!MCMenuSpec commentStamp: 'tfel 6/12/2010 14:57' prior: 0!A MCMenuSpec holds information to add menu entries to the monticello browser menus from external classes.Required is the entry string (#entry), the call target and the selector be called.An external class may use the MCWorkingCopyBrowser class>>addMenuSpec: method to add it's own menu entry to the monticello browser context menu.Note that MCMenuSpecs are compared via their menu entry string and if multiple MCMenuSpecs are added to the MCWorkingCopyBrowser, the last one takes precedence.!!MCMenuSpec methodsFor: 'comparing' stamp: 'tfel 6/12/2010 11:43'!= aMCMenuSpec	^ self class == aMCMenuSpec class and: [self entry = aMCMenuSpec entry].! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!entry	^entry! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!entry: anObject	entry := anObject! !!MCMenuSpec methodsFor: 'comparing' stamp: 'tfel 6/12/2010 11:42'!hash	^ self entry hash! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!selector	^selector! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!selector: anObject	selector := anObject! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!target	^target! !!MCMenuSpec methodsFor: 'accessing' stamp: 'tfel 6/12/2010 11:38'!target: anObject	target := anObject! !!MCWorkingCopyBrowser class methodsFor: 'hooks' stamp: 'tfel 6/12/2010 14:55'!addMenuSpec: aMCMenuSpec	"Register a context menu entry in the monticello browser from an external package.	 The MCWorkingCopyBrowser model is passed as argument."	self externalMenuEntries 		remove: aMCMenuSpec 		ifAbsent: ["Remove any previous entry with description string"];		add: aMCMenuSpec.! !!MCWorkingCopyBrowser class methodsFor: 'hooks' stamp: 'tfel 6/12/2010 11:44'!externalMenuEntries		ExternalMenuEntries ifNil: [ExternalMenuEntries := Set new].	^ ExternalMenuEntries! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'tfel 6/12/2010 13:47'!insertExternalMenuEntries: aMenu		self class externalMenuEntries ifNotEmpty: [		aMenu addLine.		self class externalMenuEntries do: [:each |			aMenu 				add: each entry 				target: each target				selector: each selector				argument: self]].! !!MCWorkingCopyBrowser methodsFor: 'morphic ui' stamp: 'tfel 6/12/2010 11:22' prior: 23231997!workingCopyListMenu: aMenu	workingCopy ifNil: [^ aMenu].	self fillMenu: aMenu fromSpecs:		#(('add required package' #addRequiredPackage)			('clear required packages' #clearRequiredPackages)			('browse package' #browseWorkingCopy)			('view changes' #viewChanges)			('view history' #viewHistory)			('recompile package' #recompilePackage)			('revert package...' #revertPackage)			('unload package' #unloadPackage)			('delete working copy' #deleteWorkingCopy)).	(Smalltalk includesKey: #SARMCPackageDumper) ifTrue: [		aMenu add: 'make SAR' target: self selector: #fileOutAsSAR	].	self insertExternalMenuEntries: aMenu.	^aMenu! !"Monticello"!!Month commentStamp: 'cbr 7/28/2010 18:11' prior: 24041091!I represent a month.For example, to get the number of days this month, you can evaluate the following expression:Month current daysInMonth!!Week commentStamp: 'cbr 7/28/2010 18:11' prior: 33165309!I represent a week.To find out what days of the week on which Squeak is fun, select the following expression, and print it:Week dayNames!!Year commentStamp: 'cbr 7/28/2010 18:10' prior: 59467077!I represent a year.Try me!! Select the following expression and print it:Year current daysInYear "Try me again next leap year!!"!!Integer methodsFor: 'arithmetic' stamp: 'nice 9/2/2010 21:29'!reciprocalModulo: n	"Answer an integer x such that (self * x) \\ n = 1, x > 0, x < n.	Raise an error if there is no such integer.	The algorithm is a non extended euclidean modular inversion called NINV.	It is described in this article:		'Using an RSA Accelerator for Modular Inversion'	by Martin Seysen. See http://www.iacr.org/archive/ches2005/017.pdf"	| u v f fPlusN b result result2 |	((self <= 0) or: [n <= 0]) ifTrue: [self error: 'self and n must be greater than zero'].	self >= n ifTrue: [self error: 'self must be < n'].	b := n highBit + 1.	f := 1 bitShift: b.	v := (self bitShift: b) + 1.	u := n bitShift: b.	fPlusN := f + n.	[v >= fPlusN] whileTrue:		[v := u \\\ (u := v)].	result := v - f.	(result2 := result + n) > 0		ifFalse: [self error: 'no inverse'].	^result positive		ifTrue: [result]		ifFalse: [result2]! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'spd 8/5/2010 09:17' prior: 57383492!readFrom: aStream	| offset date time ch |	date := Date readFrom: aStream.	[aStream peek isDigit]		whileFalse: [aStream next].	time := Time readFrom: aStream.	aStream atEnd		ifTrue: [ offset := self localOffset ]		ifFalse: [			ch := aStream next.			ch = $+ ifTrue: [ch := Character space].			offset := Duration fromString: ch asString, '0:', aStream upToEnd, ':0'].			^ self		year: date year		month: date monthIndex		day: date dayOfMonth		hour: time hour		minute: time minute		second: time second		nanoSecond: time nanoSecond		offset: offset	"	'-1199-01-05T20:33:14.321-05:00' asDateAndTime		' 2002-05-16T17:20:45.1+01:01' asDateAndTime		' 2002-05-16T17:20:45.02+01:01' asDateAndTime		' 2002-05-16T17:20:45.003+01:01' asDateAndTime		' 2002-05-16T17:20:45.0004+01:01' asDateAndTime  		' 2002-05-16T17:20:45.00005' asDateAndTime		' 2002-05-16T17:20:45.000006+01:01' asDateAndTime		' 2002-05-16T17:20:45.0000007+01:01' asDateAndTime		' 2002-05-16T17:20:45.00000008-01:01' asDateAndTime   		' 2002-05-16T17:20:45.000000009+01:01' asDateAndTime  		' 2002-05-16T17:20:45.0000000001+01:01' asDateAndTime   		' 2002-05-16T17:20' asDateAndTime		' 2002-05-16T17:20:45' asDateAndTime		' 2002-05-16T17:20:45+01:57' asDateAndTime 		' 2002-05-16T17:20:45-02:34' asDateAndTime 		' 2002-05-16T17:20:45+00:00' asDateAndTime		' 1997-04-26T01:02:03+01:02:3' asDateAndTime  	"! !Object removeSelector: #undoFromCapturedState:!Object removeSelector: #rememberUndoableAction:named:!Object removeSelector: #rememberCommand:!Object removeSelector: #refineUndoTarget:selector:arguments:in:!Object removeSelector: #refineRedoTarget:selector:arguments:in:!Object removeSelector: #redoFromCapturedState:!Object removeSelector: #purgeAllCommands!Object removeSelector: #propertyList!Object removeSelector: #openAsMorph!Object removeSelector: #descriptionForPartsBin!Object removeSelector: #commandHistory!Object removeSelector: #capturedState!Object removeSelector: #asTextMorph!Object removeSelector: #asStringMorph!Object removeSelector: #asMorph!Object removeSelector: #asDraggableMorph!"Kernel"!!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 16:09' prior: 20493100!eToyBaseFolderSpec	^ServerDirectory eToyBaseFolderSpecForFileDirectory: self! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 16:09' prior: 20493254!eToyBaseFolderSpec: aString	^ServerDirectory eToyBaseFolderSpecForFileDirectory: self put: aString! !!FileDirectory methodsFor: '*Etoys' stamp: 'stephaneducasse 2/4/2006 20:31' prior: 20493443!eToyUserList	| spec index fd list match |	spec := self eToyBaseFolderSpec. "something like 'U:\Squeak\users\*-Squeak'."	spec ifNil:[^ServerDirectory eToyUserListForFileDirectory: self].	"Compute list of users based on base folder spec"	index := spec indexOf: $*. "we really need one"	index = 0 ifTrue:[^ServerDirectory eToyUserListForFileDirectory: self].	fd := FileDirectory on: (FileDirectory dirPathFor: (spec copyFrom: 1 to: index)).	"reject all non-directories"	list := fd entries select:[:each| each isDirectory].	"reject all non-matching entries"	match := spec copyFrom: fd pathName size + 2 to: spec size.	list := list collect:[:each| each name].	list := list select:[:each| match match: each].	"extract the names (e.g., those positions that match '*')"	index := match indexOf: $*.	list := list collect:[:each|		each copyFrom: index to: each size - (match size - index)].	^list! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 15:41' prior: 20494423!eToyUserListUrl	^ServerDirectory eToyUserListUrlForFileDirectory: self! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 15:48' prior: 20494571!eToyUserListUrl: urlString	^ServerDirectory eToyUserListUrlForFileDirectory: self put: urlString.! !!FileDirectory methodsFor: '*Etoys' stamp: 'stephaneducasse 2/4/2006 20:31' prior: 20494759!eToyUserName: aString	"Set the default directory from the given user name"	| dirName |	dirName := self eToyBaseFolderSpec. "something like 'U:\Squeak\users\*-Squeak'"	dirName ifNil:[^self].	dirName := dirName copyReplaceAll:'*' with: aString."	dirName last = self class pathNameDelimiter ifFalse:[dirName := dirName, self slash].	FileDirectory setDefaultDirectoryFrom: dirName.	dirName := dirName copyFrom: 1 to: dirName size - 1."	pathName := FilePath pathName: dirName! !!FileDirectory methodsFor: '*Etoys' stamp: 'ar 9/5/2001 16:13' prior: 20495316!hasEToyUserList	^self eToyUserListUrl notNil or:[self eToyBaseFolderSpec notNil]! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 03:17' prior: 52141398!arrowHead	"Put an arrowhead on the previous pen stroke"	" | pen | pen := Pen new. 20 timesRepeat: [pen turn: 360//20; go: 20; arrowHead]."	penDown ifTrue:		[self arrowHeadFrom: (direction degreeCos @ direction degreeSin) * -40 + location 			to: location			arrowSpec: (Preferences parameterAt: #arrowSpec ifAbsent: [5 @ 4])]! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 02:29' prior: 52150109!arrowHeadForArrowSpec: anArrowSpec	"Put an arrowhead on the previous pen stroke""	 | pen aPoint |	aPoint := Point fromUser.	pen := Pen new.	20 timesRepeat: [pen turn: 360//20; go: 20; arrowHeadForArrowSpec: aPoint]."	penDown ifTrue:		[self arrowHeadFrom: (direction degreeCos @ direction degreeSin) * -40 + location 			to: location			arrowSpec: anArrowSpec]! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 02:25' prior: 52148853!arrowHeadFrom: prevPt to: newPt arrowSpec: anArrowSpec	"Put an arrowhead on the pen stroke from oldPt to newPt"	| pm af myColor finalPt delta |	myColor := self color.	delta := newPt - prevPt.	delta r <= 2 "pixels" ifTrue: [^ self].	finalPt := newPt + (Point r: sourceForm width degrees: delta degrees).	"in same direction"	pm := PolygonMorph vertices: (Array with: prevPt asIntegerPoint with: finalPt asIntegerPoint)  		color: myColor  "not used"		borderWidth: sourceForm width borderColor: myColor.	pm makeOpen; makeForwardArrow.	anArrowSpec ifNotNil: [pm arrowSpec: anArrowSpec].	af := pm arrowForms first.	"render it onto the destForm"	(FormCanvas on: destForm "Display") stencil: af at: af offset + (1@1)		color: myColor! !!Pen methodsFor: '*Etoys' stamp: 'sw 10/5/2002 02:11' prior: 52149672!arrowHeadFrom: prevPt to: newPt forPlayer: aPlayer	"Put an arrowhead on the pen stroke from oldPt to newPt"		| aSpec |	(aPlayer notNil and: [(aSpec := aPlayer costume renderedMorph valueOfProperty: #arrowSpec) notNil]) 		ifFalse:			[aSpec := Preferences parameterAt: #arrowSpec "may well be nil"].	self arrowHeadFrom: prevPt to: newPt arrowSpec: aSpec! !"EToys"!!DirectoryEntry methodsFor: 'services' stamp: 'ar 9/5/2010 08:51' prior: 58764195!services	"Answer the same collection of SimpleServiceEntry's accessed by the FileList."	^ FileServices itemsForFile: self fullName! !!FileStream class methodsFor: 'initialize-release' stamp: 'ar 9/5/2010 08:54' prior: 20696528!initialize	FileServices registerFileReader: self! !!FileStream class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 08:54' prior: 20692280!unload	FileServices unregisterFileReader: self ! !FileDirectory class removeSelector: #searchAllFilesForAString!FileStream removeSelector: #fileIntoNewChangeSet!FileStream removeSelector: #edit!"Files"!!TextStyle class methodsFor: 'mime file in/out' stamp: 'ar 9/5/2010 09:02' prior: 55350187!replaceFontsIn: oldFontArray with: newStyle	"	TextStyle replaceFontsIn: (TextStyle looseFontsFromFamily: #Accuny) with: (TextStyle named: #Accuny)	"	"Try to find corresponding fonts in newStyle and substitute them for the fonts in oldFontArray"	newStyle fontArray do: [ :newFont | newFont releaseCachedState ].	oldFontArray do: [ :oldFont | | newFont |		oldFont reset.		newFont := (newStyle fontOfPointSize: oldFont pointSize) emphasis: oldFont emphasis.		oldFont becomeForward: newFont ].	Smalltalk at: #StringMorph ifPresent:[:cls| cls allSubInstancesDo: [ :s | s layoutChanged]].	Smalltalk at: #TextMorph ifPresent:[:cls| cls allSubInstancesDo: [ :s | s layoutChanged]].	Smalltalk at: #SystemWindow ifPresent:[:cls| 		cls allInstancesDo: [ :w | [ w update: #relabel ] on: Error do: [ :ex | ] ]].	World ifNotNil: [ :w | w changed ].! !!Form class methodsFor: 'initialize-release' stamp: 'ar 9/5/2010 09:09' prior: 21087485!initialize	FileServices registerFileReader: self! !!Form class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:09' prior: 21075980!unload	FileServices unregisterFileReader: self ! !!StrikeFont class methodsFor: 'accessing' stamp: 'ar 9/6/2010 11:33' prior: 55426291!defaultSized: aNumber	| fonts f |	"This used to be the default textstyle, but it needs to be a StrikeFont and not a TTCFont and sometimes the default textstyle is a TTCFont.  So, we use a typical StrikeFont as the default fallback font."	fonts := (TextConstants at: #Accuny ifAbsent:[TextStyle default]) fontArray.	f := fonts first.	1 to: fonts size do: [:i |		aNumber > (fonts at: i) height ifTrue: [f := fonts at: i].	].	^f! !!BDFFontReader class methodsFor: 'resource download' stamp: 'ar 9/5/2010 09:08' prior: 56377424!downloadFonts  "BDFFontReader downloadFonts"	"Download a standard set of BDF sources from x.org.  	The combined size of these source files is around 1.2M; after conversion 	to .sf2 format they may be deleted."	| heads tails filenames baseUrl basePath |	heads := #( 'charR' 'courR' 'helvR' 'lubR' 'luRS' 'lutRS' 'ncenR' 'timR' ).	tails := #( '08' '10' '12' '14' '18' '24').	filenames := OrderedCollection new.	heads do: [:head |		filenames addAll: (tails collect: [:tail | head , tail , '.bdf'])	].	baseUrl := 'http://ftp.x.org/pub/R6.4/xc/fonts/bdf/75dpi/' asUrl.	basePath := baseUrl path.	filenames do: [:filename | | document f newPath newUrl |		newUrl := baseUrl clone.		newPath := OrderedCollection newFrom: basePath.		newPath addLast: filename.		newUrl path: newPath.		Utilities informUser: 'Fetching ' , filename during: 			[document := newUrl retrieveContents].		f := CrLfFileStream newFileNamed: filename.		f nextPutAll: document content.		f close.	].! !PNMReadWriter class removeSelector: #testMultiFile:!PNMReadWriter class removeSelector: #testFromString!PNMReadWriter class removeSelector: #testFromSEFile:!PNGReadWriter class removeSelector: #test1!PNGReadWriter class removeSelector: #createAFormFrom:!Form removeSelector: #morphEdit!Form removeSelector: #asMorph!"Graphics"!!Installer methodsFor: 'public interface' stamp: 'spd 9/6/2010 16:06' prior: 57592717!install: packageNameCollectionOrDetectBlock	"The parameter specifies the package to be installed in one of the following ways:		- By Name e.g. install: 'Kernel'		- Acceptable Versions e.g. install: #('Comet-lr' 'Comet-pmm') i.e. either of these		- Specific version e.g. install: 'Scriptaculous-lr.148'		- By Predicate e.g. install: [ :packageName | packageName beginsWith: 'Dynamic' ]"	self addPackage: packageNameCollectionOrDetectBlock.	self install! !"Installer-Core"!!IntegerTest methodsFor: 'testing - arithmetic' stamp: 'nice 9/6/2010 21:48'!testReciprocalModulo	1 to: 512 do: [:a |		a + 1 to: 512 do: [:b |			| c |			(a gcd: b) = 1				ifTrue:					[c := a reciprocalModulo: b.					self assert: (a * c) \\ b = 1]				ifFalse: [self should: [ a reciprocalModulo: b ] raise: Error]]].! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'nice 9/6/2010 21:51'!testReciprocalModulo	| large r |	large := 1 bitShift: 48.	r := Random seed: 46912151.	4691 timesRepeat:		[| a b c t |		a := (r nextInt: large) + 1.		b := (r nextInt: large) + 1.		a > b ifTrue: [t := a. a:= b. b := t].		(a gcd: b) = 1			ifTrue:				[c := a reciprocalModulo: b.				self assert: (a * c) \\ b = 1.]			ifFalse: [self should: [ a reciprocalModulo: b ] raise: Error]].! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'spd 8/5/2010 09:17'!testFromString	| fromString fromStringNoOffset |	fromString := DateAndTime fromString: '-1199-01-05T20:33:14.321-05:00'.	self assert: (fromString printString = '-1199-01-05T20:33:14.321-05:00').		"if no offset is provided, the local offset should be used"	fromStringNoOffset := DateAndTime fromString: '-1199-01-05T20:33:14.321'.	self assert: (fromStringNoOffset offset = DateAndTime localOffset).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'spd 8/5/2010 09:19' prior: 50876211!testPrintString	"(self new setTestSelector: #testPrintString) debug"	| dt dtNoOffset |	dt :=DateAndTime		year: 2004		month: 11		day: 2		hour: 14		minute: 3		second: 5		nanoSecond: 12345		offset: (Duration seconds: (5 * 3600)).	self assert: dt printString = '2004-11-02T14:03:05.000012345+05:00'.		self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').	self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  	self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).	self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').	self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime = '2002-05-16T17:20:45-02:34').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime = '2002-05-16T17:20:45+00:00').	self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime = '1997-04-26T01:02:03+01:02:3').	"When no offset is provided, the local one is used"	dtNoOffset := '2002-05-16T17:20' asDateAndTime.	self assert: (('2002-05-16T17:20:00*' match: dtNoOffset printString) and: [dtNoOffset offset = DateAndTime localOffset]).! !!DateAndTimeTest methodsFor: 'Tests' stamp: 'spd 8/5/2010 09:19' prior: 33937383!testReadFromself assert: ((DateAndTime readFrom: '-1199-01-05T20:33:14.321-05:00' readStream) printString = '-1199-01-05T20:33:14.321-05:00'). ! !"KernelTests"!!SmalltalkImage methodsFor: 'shrinking' stamp: 'ar 9/6/2010 11:34'!unloadFonts	"Smalltalk unloadFonts"	"Unloads all fonts except the style specified initially."	| fontName fontSize textStyle |	"Three good choices here:		* Atlanta 11: Absolutely minimal font.		* Accuny 10: A few extra sizes over Atlanta.		* Bitmap DejaVu Sans 9: Nicest fonts but relatively large.	"	fontName := #'Bitmap DejaVu Sans'.	fontSize := 9.	"Nuke everything other than the desired text style"	textStyle := TextStyle named: fontName.	TextStyle defaultFamilyNames do:[:styleName| 		TextConstants at: styleName put: textStyle	].	TextStyle actualTextStyles keys do:[:styleName| 		TextConstants removeKey: styleName	].	TextConstants at: fontName put: textStyle.	"Use it everywhere"	Preferences setDefaultFonts: {		{#setSystemFontTo:.		fontName.	fontSize}.		{#setListFontTo:.			fontName.	fontSize}.		{#setFlapsFontTo:.			fontName.	fontSize}.		{#setEToysFontTo:.			fontName.	fontSize}.		{#setEToysTitleFontTo:	.	fontName.	fontSize}.		{#setPaintBoxButtonFontTo:. fontName.	fontSize}.		{#setMenuFontTo:.			fontName.	fontSize}.		{#setWindowTitleFontTo:.	fontName.	fontSize}.		{#setBalloonHelpFontTo:.	fontName.	fontSize}.		{#setCodeFontTo:.			fontName.	fontSize}.		{#setButtonFontTo:.		fontName.	fontSize}.	}.	"Clean out afterwards"	Smalltalk at: #TextEditor ifPresent:[:aClass| aClass initialize].	Smalltalk at: #SmalltalkEditor ifPresent:[:aClass| aClass initialize].	Smalltalk at: #SystemProgressMorph ifPresent:[:aClass| aClass reset].	Smalltalk at: #TTCFont ifPresent:[:aClass| aClass registry removeAll].	Smalltalk at: #Flaps ifPresent:[:aClass | aClass disableGlobalFlaps: false].	Smalltalk at: #TTFontDescription ifPresent:[:aClass| aClass clearDefault].	Smalltalk at: #TTFontDescription ifPresent:[:aClass| aClass clearDescriptions].! !!SystemChangeNotifier methodsFor: 'system triggers' stamp: 'ar 9/5/2010 21:57' prior: 30554525!selector: selector recategorizedFrom: oldCategory to: newCategory inClass: aClass	self trigger: (RecategorizedEvent 				selector: selector				method: (aClass compiledMethodAt: selector ifAbsent: [nil])				protocol: newCategory				class: aClass				oldProtocol: oldCategory)! !!DefaultExternalDropHandler methodsFor: 'event handling' stamp: 'ar 9/5/2010 08:52' prior: 19652787!handle: dropStream in: pasteUp dropEvent: anEvent 	"the file was just droped, let's do our job"	| fileName services theOne chosen |	fileName := dropStream name.	services := self servicesForFileNamed: fileName.	"no service, default behavior"	services isEmpty 		ifTrue: [^UIManager default edit: dropStream contentsOfEntireFile].	chosen := self chooseServiceFrom: services.	chosen ifNotNil:[theOne performServiceFor: dropStream]! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:42'!allCallsOn: aSymbol localTo: aClass	"Answer a Set of MethodReferences for all the methods	 that call on aSymbol in, above or below the given class."	| aSet special byte enum |	aSet := Set new.	special := Smalltalk hasSpecialSelector: aSymbol ifTrueSetByte: [:b | byte := b].	enum := [:behavior|			(behavior whichSelectorsReferTo: aSymbol special: special byte: byte) do:				[:sel | aSet add: (MethodReference new setStandardClass: behavior  methodSymbol: sel)]].	aClass theNonMetaClass withAllSuperAndSubclassesDoGently: enum.		aClass theNonMetaClass class withAllSuperAndSubclassesDoGently: enum.	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:47'!allCallsOn: aLiteral localToPackage: packageNameOrInfo	"Answer a Set of MethodReferences for all the methods	 that call on aSymbol in the given package."	| aSet special byte |	aSet := Set new.	special := Smalltalk hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte := b].	Cursor wait showWhile:		[(self packageInfoFor: packageNameOrInfo) actualMethodsDo:			[:method |			((method hasLiteral: aLiteral) or: [special and: [method scanFor: byte]]) ifTrue:				[((aLiteral isVariableBinding) not					or: [method literals allButLast includes: aLiteral])						ifTrue: [aSet add: method methodReference]]].].	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:33'!allImplementorsOf: aSelector  localToPackage: packageNameOrInfo	"Answer a SortedCollection of all the methods that implement the message 	 aSelector in the given package."	| aSet |	aSet := Set new.	Cursor wait showWhile:		[(self packageInfoFor: packageNameOrInfo) actualMethodsDo:			[:m |			(m selector = aSelector) ifTrue:				[aSet add: m methodReference]]].	^aSet! !!SystemNavigation methodsFor: 'query' stamp: 'eem 8/30/2010 10:38'!allMethodsSelect: aBlock localToPackage: packageNameOrInfo	"Answer a SortedCollection of each method in the given package	 for which the evaluation of aBlock with the metnod answers true."	| aSet |	aSet := Set new.	Cursor wait showWhile:		[(self packageInfoFor: packageNameOrInfo) actualMethodsDo:			[:aMethod |			(aBlock value: aMethod) ifTrue:				[aSet add: aMethod methodReference]]].	^aSet! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:05' prior: 30676618!browseAllCallsOn: aLiteral 	"Create and schedule a message browser on each method that refers to 	aLiteral. For example, SystemNavigation new browseAllCallsOn: #open:label:."	self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self			browseMessageList: (self allCallsOn: aLiteral) asSortedCollection			name: label			autoSelect: autoSelect]! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:27' prior: 52732581!browseAllCallsOn: aLiteral from: aBehavior	"Create and schedule a Message Set browser for	 all the methods that call on aLiteral within aBehavior."	"self new browseAllCallsOn: #/ from: Number"	^self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self 			browseMessageList: (self  allCallsOn: aLiteral from: aBehavior)			name: label, ' from ', aBehavior name			autoSelect: autoSelect]	! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:15' prior: 30678139!browseAllCallsOn: aLiteral localTo: aClass	"Create and schedule a message browser on each method in or below the given class that refers to	aLiteral. For example, SystemNavigation new browseAllCallsOn: #open:label: localTo: CodeHolder."	aClass ifNil: [ ^self inform: 'no selected class' ].	self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self browseMessageList: (aClass allLocalCallsOn: aLiteral) asSortedCollection			name: label, ' local to ', aClass name			autoSelect: autoSelect]! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:16'!browseAllCallsOn: aLiteral localToPackage: packageNameOrInfo	"Create and schedule a message browser on each method in the given package	 that refers to aLiteral. For example,		SystemNavigation new browseAllCallsOn: #open:label: localToPackage: 'Tools'."	self headingAndAutoselectForLiteral: aLiteral do:		[:label :autoSelect|		self browseMessageList: (self allCallsOn: aLiteral localToPackage: packageNameOrInfo) asSortedCollection			name: label, ' local to package ', (self packageInfoFor: packageNameOrInfo) name			autoSelect: autoSelect]! !!SystemNavigation methodsFor: 'browse' stamp: 'eem 8/30/2010 11:13'!browseAllImplementorsOf: selector localToPackage: packageNameOrInfo	"Create and schedule a message browser on each method in the given package	that implements the message whose selector is the argument, selector. For example, 	SystemNavigation new browseAllImplementorsOf: #at:put: localToPackage: 'Collections'."	self browseMessageList: (self								allImplementorsOf: selector								localToPackage: packageNameOrInfo) asSortedCollection		name: 'Implementors of ' , selector,				' local to package ', (self packageInfoFor: packageNameOrInfo) name! !!SystemNavigation methodsFor: 'private' stamp: 'eem 8/30/2010 11:02'!headingAndAutoselectForLiteral: aLiteral do: binaryBlock	"Evaluate aBlock with either Users of ... or Senders of ... plus the auto-select string	 for the given literal.  aLiteral can be a Symbol, a VariableBinding or an arbitrary object."	| autoSelect |	^aLiteral isSymbol		ifTrue: [binaryBlock value: 'Senders of ', aLiteral value: aLiteral keywords first]		ifFalse:			[autoSelect := aLiteral isVariableBinding							ifTrue: [aLiteral key]							ifFalse: [aLiteral printString].			binaryBlock value: 'Users of ', autoSelect value: autoSelect]! !!SystemNavigation methodsFor: 'private' stamp: 'eem 8/30/2010 10:34'!packageInfoFor: packageInfoOrString	^packageInfoOrString isString		ifTrue: [PackageInfo named: packageInfoOrString]		ifFalse: [packageInfoOrString]! !!RecategorizedEvent class methodsFor: 'instance creation' stamp: 'ar 9/5/2010 21:56'!selector: aSelector method: aMethod protocol: prot class: aClass oldProtocol: oldName	^(self method: aMethod protocol: prot class: aClass) 		itemSelector: aSelector;		oldCategory: oldName;		yourself! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'nice 9/2/2010 21:48' prior: 50923162!computeSignatureForMessageHash: hash privateKey: privateKey	"Answer the digital signature of the given message hash using the given private key. A signature is a pair of large integers. The private key is an array of four large integers: (p, q, g, x)."	| p q g x r s k tmp |	p := privateKey first.	q := privateKey second.	g := privateKey third.	x := privateKey fourth.	r := s := 0.	[r = 0 or: [s = 0]] whileTrue: [		k := self nextRandom160 \\ q.		r := (g raisedTo: k modulo: p) \\ q.		tmp := (hash + (x * r)) \\ q.		s := ((k reciprocalModulo: q) * tmp) \\ q].	^ Array with: r with: s! !!DigitalSignatureAlgorithm methodsFor: 'public' stamp: 'nice 9/2/2010 21:48' prior: 50927902!verifySignature: aSignature ofMessageHash: hash publicKey: publicKey	"Answer true if the given signature is the authentic signature of the given message hash. That is, if the signature must have been computed using the private key set corresponding to the given public key. The public key is an array of four large integers: (p, q, g, y)."	| p q g y r s w u1 u2 v0 v |	p := publicKey first.	q := publicKey second.	g := publicKey third.	y := publicKey fourth.	r := aSignature first.	s := aSignature last.	((r > 0) and: [r < q]) ifFalse: [^ false].  "reject"	((s > 0) and: [s < q]) ifFalse: [^ false].  "reject"	w := s reciprocalModulo: q.	u1 := (hash * w) \\ q.	u2 := (r * w) \\ q.	v0 := (g raisedTo: u1 modulo: p) * (y raisedTo: u2 modulo: p).	v := ( v0 \\ p) \\ q.	^ v = r! !"System"!!Object methodsFor: '*morphic' stamp: 'ar 8/8/2009 12:01'!asDraggableMorph	"Converts the receiver into a Morph suitable for dragging"	^(StringMorph contents: (			(self respondsTo: #dragLabel) 				ifTrue:[self dragLabel] 				ifFalse:[self printString]))		color: Color white;		yourself! !!Object methodsFor: '*morphic' stamp: 'nk 2/26/2004 13:33'!asMorph	"Open a morph, as best one can, on the receiver"	^ self asStringMorph	"234 asMorph(ScriptingSystem formAtKey: #TinyMenu) asMorph'fred' asMorph"! !!Object methodsFor: '*morphic' stamp: 'nk 2/26/2004 13:35'!asStringMorph	"Open a StringMorph, as best one can, on the receiver"	^ self asStringOrText asStringMorph! !!Object methodsFor: '*morphic' stamp: 'nk 2/26/2004 13:35'!asTextMorph	"Open a TextMorph, as best one can, on the receiver"	^ TextMorph new contentsAsIs: self asStringOrText! !!Object methodsFor: '*morphic' stamp: 'sw 1/29/2002 21:45'!openAsMorph	"Open a morph, as best one can, on the receiver"	^ self asMorph openInHand"234 openAsMorph(ScriptingSystem formAtKey: #TinyMenu) openAsMorph'fred' openAsMorph"! !!Form methodsFor: '*Morphic' stamp: 'ar 11/7/1999 20:29'!asMorph	^ImageMorph new image: self! !Number removeSelector: #isNonZero!Object removeSelector: #isNonZero!"Morphic"!!TTCFont class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:18' prior: 30926222!initialize"	self initialize"	| tt |	self allSubInstancesDo:[:fnt| fnt flushCache].	GlyphCacheSize := 512.	GlyphCacheData := Array new: GlyphCacheSize.	GlyphCacheIndex := 0.	GlyphCacheReady := true.		tt := TTFontDescription default.	tt ifNotNil: [self newTextStyleFromTT: tt].	FileServices registerFileReader: self.	Smalltalk addToShutDownList: self.! !!TTCFont class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:18' prior: 30926995!unload	FileServices unregisterFileReader: self! !"Multilingual"!!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:32'!capturedState	"May be overridden in subclasses."	^ self shallowCopy! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:29'!commandHistory	"Return the command history for the receiver"	| w |	(w := self currentWorld) ifNotNil: [^ w commandHistory].	^ CommandHistory new. "won't really record anything but prevent breaking things"! !!Object methodsFor: '*MorphicExtras-PartsBin' stamp: 'sw 10/24/2001 16:34'!descriptionForPartsBin	"If the receiver is a member of a class that would like to be represented in a parts bin, answer the name by which it should be known, and a documentation string to be provided, for example, as balloon help.  When the 'nativitySelector' is sent to the 'globalReceiver', it is expected that some kind of Morph will result.  The parameters used in the implementation below are for documentation purposes only!!"	^ DescriptionForPartsBin		formalName: 'PutFormalNameHere'		categoryList: #(PutACategoryHere MaybePutAnotherCategoryHere)		documentation: 'Put the balloon help here'		globalReceiverSymbol: #PutAGlobalHere		nativitySelector: #PutASelectorHere! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 12/12/2000 15:01'!purgeAllCommands	"Purge all commands for this object"	Preferences useUndo ifFalse: [^ self]. "get out quickly"	self commandHistory purgeAllCommandsSuchThat: [:cmd | cmd undoTarget == self].! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/12/2000 08:15'!redoFromCapturedState: st 	"May be overridden in subclasses.  See also capturedState"	self undoFromCapturedState: st  "Simple cases are symmetric"! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'sw 11/16/2000 14:42'!refineRedoTarget: target selector: aSymbol arguments: arguments in: refineBlock 	"Any object can override this method to refine its redo specification"	^ refineBlock		value: target		value: aSymbol		value: arguments! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'sw 11/16/2000 14:42'!refineUndoTarget: target selector: aSymbol arguments: arguments in: refineBlock 	"Any object can override this method to refine its undo specification"	^ refineBlock		value: target		value: aSymbol		value: arguments! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:30'!rememberCommand: aCommand	"Remember the given command for undo"	Preferences useUndo ifFalse: [^ self]. "get out quickly"	^ self commandHistory rememberCommand: aCommand! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:30'!rememberUndoableAction: actionBlock named: caption	| cmd result |	cmd := Command new cmdWording: caption.	cmd undoTarget: self selector: #undoFromCapturedState: argument: self capturedState.	result := actionBlock value.	cmd redoTarget: self selector: #redoFromCapturedState: argument: self capturedState.	self rememberCommand: cmd.	^ result! !!Object methodsFor: '*MorphicExtras-Undo' stamp: 'di 9/11/2000 20:32'!undoFromCapturedState: st 	"May be overridden in subclasses.  See also capturedState"	self copyFrom: st! !!FatBitsPaint methodsFor: 'menu' stamp: 'ar 9/5/2010 09:06' prior: 20408301!editSelection       FatBitsPaint new openWith: (self selectionAsForm ifNil: [^ nil])! !"MorphicExtras"!!UrlTest methodsFor: 'tests' stamp: 'ar 9/4/2010 11:25'!testUrlEncoded	"Test the behavior of #urlEncoded"	self assert: 'http://squeak.org/name with space?and=value' urlEncoded		equals: 'http://squeak.org/name%20with%20space?and=value'.	self assert: 'http://squeak.org/name%20with%20space?and=value' urlEncoded		equals: 'http://squeak.org/name%20with%20space?and=value'.	self assert: 'http://squeak.org/name%with%space?and=value' urlEncoded		equals: 'http://squeak.org/name%25with%25space?and=value'.! !"NetworkTests"!!PackageInfo methodsFor: 'enumerating' stamp: 'eem 8/30/2010 10:28'!actualMethodsDo: aBlock	"Evaluate aBlock with the actual method objects in this package."	| enum |	self extensionMethods do:		[:mr|		aBlock value: mr compiledMethod].	enum := [:behavior|			behavior organization categories do:				[:cat|				(self isForeignClassExtension: cat) ifFalse:					[(behavior organization listAtCategoryNamed: cat) do:						[:s|						aBlock value: (behavior compiledMethodAt: s)]]]].	self classes do:		[:c| enum value: c; value: c classSide]		! !"PackageInfo-Base"!!ScorePlayerMorph class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:25' prior: 28239382!initialize	FileServices registerFileReader: self! !!ScorePlayerMorph class methodsFor: 'initialize-release' stamp: 'ar 9/5/2010 09:25' prior: 28240623!unload	FileServices unregisterFileReader: self ! !"Sound"!!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:32' prior: 34416986!testCollections	self testPackage: 'Collections' dependsExactlyOn: #(		Compiler		Kernel		Exceptions		Files		Graphics		Multilingual		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:32' prior: 58618560!testCompression	self testPackage: 'Compression' dependsExactlyOn: #(		Collections		Exceptions		Files		Graphics		Kernel		Multilingual		SUnit		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:33' prior: 58619325!testFiles	self testPackage: 'Files' dependsExactlyOn: #(		Collections		Compression		Exceptions		Graphics		Kernel		Multilingual		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:33' prior: 58619587!testGraphics	self testPackage: 'Graphics' dependsExactlyOn: #(		Collections		Compression		Exceptions		Files		Kernel		Morphic		Multilingual		System		'ToolBuilder-Kernel'		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:35' prior: 58620196!testKernel	self testPackage: 'Kernel' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		MorphicExtras		Multilingual		System		'ToolBuilder-Kernel'		Tools		Traits	).! !!PackageDependencyTest methodsFor: 'utilities' stamp: 'ar 9/5/2010 11:36' prior: 58622452!testPackage: pkgName dependsExactlyOn: pkgList	"Ensure that the package with the given name depends only on the packages in pkgList.	NOTE: If you use this for fixing dependencies, classDeps includes the classes	and users from the package(s) not declared as dependents. Basically, you need	to fix all the references in classDeps to make the test pass."	| classDeps pi pkgDeps |	classDeps := IdentityDictionary new.	pi := PackageOrganizer default packageNamed: pkgName ifAbsent:[^self]. "unloaded"	pi classes do:[:pkgClass| 		(classDeps at: (pkgClass superclass ifNil:[ProtoObject]) 			ifAbsentPut:[OrderedCollection new]) add: pkgClass name, ' superclass'.	].	pi methods do:[:mref| | cm |		cm := mref compiledMethod.		1 to: cm numLiterals do:[:i| | lit |			((lit := cm literalAt: i) isVariableBinding 				and:[lit value isBehavior]) ifTrue:[(classDeps at: lit value ifAbsentPut:[OrderedCollection new]) add: cm methodClass asString, '>>', cm selector]]].	pkgDeps := Dictionary new.	classDeps keys do:[:aClass| | pkg |		pkg := PackageOrganizer default packageOfClass: aClass ifNone:[nil].		pkg ifNil:[			Transcript cr; show: 'WARNING: No package for ', aClass.			(classDeps removeKey: aClass) do:[:each| Transcript crtab; show: each].		] ifNotNil:[			(pkgDeps at: pkg name ifAbsentPut:[OrderedCollection new]) add: aClass.		].	].	(pkgDeps removeKey: pkgName ifAbsent:[#()]) 		do:[:aClass| classDeps removeKey: aClass ifAbsent:[]].	pkgList do:[:pkg|		self assert: (pkgDeps includesKey: pkg)			description: pkgName, ' no longer depends on ', pkg.		(pkgDeps removeKey: pkg ifAbsent: [#()]) 			do:[:aClass| classDeps removeKey: aClass ifAbsent:[]].	].	classDeps keysAndValuesDo:[:class :deps|		Transcript cr; show: class name, ' dependencies:'.		deps do:[:each| Transcript crtab; show: each].	].	self assert: pkgDeps isEmpty		description: pkgName, ' now depends on ', pkgDeps.! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:35' prior: 34418068!testSound	self testPackage: 'Sound' dependsExactlyOn: #(		Collections		Balloon		Files		Graphics		Kernel		Morphic		MorphicExtras		Network		System		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'ar 9/5/2010 11:36' prior: 58627857!testTrueType	self testPackage: 'TrueType' dependsExactlyOn: #(		Collections		Balloon		Exceptions		Files		Graphics		Kernel		Morphic		Multilingual		System		'ToolBuilder-Kernel'	).! !"Tests"!!ArchiveViewer methodsFor: 'member operations' stamp: 'ar 9/2/2010 08:49' prior: 17015980!addMemberFromClipboard	| string newName |	self canAddMember ifFalse: [ ^self ].	string := Clipboard clipboardText asString.	newName := UIManager default		request: 'New name for member:'		initialAnswer: 'clipboardText'.	newName notEmpty ifTrue: [		(archive addString: string as: newName) desiredCompressionMethod: ZipArchive compressionDeflated.		self memberIndex: self members size.		self changed: #memberList.	]! !!ArchiveViewer methodsFor: 'archive operations' stamp: 'ar 9/2/2010 08:50' prior: 17000366!commentArchive	| newName |	archive ifNil: [ ^self ].	newName := UIManager default			request: 'New comment for archive:'			initialAnswer: archive zipFileComment.	archive zipFileComment: newName.! !!ArchiveViewer methodsFor: 'member operations' stamp: 'ar 9/2/2010 08:50' prior: 17017553!commentMember	| newName |	newName := UIManager default			request: 'New comment for member:'			initialAnswer: self selectedMember fileComment.	self selectedMember fileComment: newName.! !!ArchiveViewer methodsFor: 'member operations' stamp: 'ar 9/2/2010 08:50' prior: 17018918!renameMember	| newName |	self canRenameMember ifFalse: [ ^self ].	newName := UIManager default		request: 'New name for member:'		initialAnswer: self selectedMember fileName.	newName notEmpty ifTrue: [		self selectedMember fileName: newName.		self changed: #memberList	]! !!FileStream methodsFor: '*Tools-Changes' stamp: 'ar 9/6/2010 10:34'!fileIntoNewChangeSet	"File all of my contents into a new change set." 	self readOnly.	ChangesOrganizer newChangesFromStream: self named: self localName! !CodeHolder removeSelector: #regularDiffButton!CodeHolder removeSelector: #prettyDiffButton!CodeHolder removeSelector: #menuButton!CodeHolder removeSelector: #diffButton!CodeHolder removeSelector: #codePaneProvenanceButton!CodeHolder removeSelector: #addOptionalAnnotationsTo:at:plus:!"Tools"!!TTFontReader class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:38' prior: 30994992!initialize	"self initialize"	FileServices registerFileReader: self! !!TTFontReader class methodsFor: 'class initialization' stamp: 'ar 9/5/2010 09:38' prior: 30995707!unload	FileServices unregisterFileReader: self ! !"TrueType"!!HelpOnHelp class methodsFor: 'pages' stamp: 'sd 5/12/2010 23:12' prior: 33772251!introduction	"This method was automatically generated. Edit it using:"	"HelpOnHelp edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'WELCOME TO THE HELP SYSTEMThe help system is a simple user interface to display help contents to the user. It can be accessed from the world menu using "Tools" -> "Help Browser" or by evaluating ''HelpBrowser open'' in a workspace.There is a predefined mechanism allowing you to have help contents stored as source code using methods in specific help provider classes. This allows you to manage the help texts using the standard development tools. But this is only one possible representation.Yes, this is a good solution.!!' readStream nextChunkText! !"HelpSystem-Core"!!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'sd 5/12/2010 23:01' prior: 33869939!openWorkspace	^HelpTopic 		title: 'Open a Workspace'		contents: 'You can open a Workspace window in any of the following ways:		- Keyboard Shortcut: while pointing at an empty part of the Squeak window, press alt-k (in Windows) or cmd-k (on a Mac)- World Menu: select "Workspace"- Tools Flap: click on the Tools Flap. When it comes out, drag the Workspace icon out.- Doit: select inside the following quote and doit: "Workspace open"'! !!SqueakToolsWorkspaceHelp class methodsFor: 'pages' stamp: 'sd 5/12/2010 22:48' prior: 33870965!workspace	^HelpTopic 		title: 'What is a Workspace'		contents: 'A Workspace is a window used as a scratchpad area where fragments of Smalltalk code can be entered, stored, edited, and evaluated.'! !"Help-Squeak-Project"!!ZipArchiveTests methodsFor: 'tests' stamp: 'ar 9/16/2010 20:15'!testCreateWithRelativeNames	"Test creating a zip with a relative tree of files, so that the tree will	be created whereever the ."	| subdir zip |	subdir := FileDirectory default / '_test-zip-dir'.	self deny: subdir exists.	subdir assureExistence.	[ subdir		fileNamed: '_test-zip-file'		do: [ : stream | stream nextPutAll: 'file contents' ].	zip := ZipArchive new.	zip		addDirectory: subdir fullName		as: subdir localName.	zip			addFile: (subdir fullNameFor: '_test-zip-file')		as: '_test-zip-dir' , FileDirectory slash , '_test-zip-file'.	zip writeToFileNamed: (FileDirectory default fullNameFor: '_test.zip') ] 	ensure:[ 		zip close.		subdir ifNotNil: [ subdir recursiveDelete ].		FileDirectory default deleteFileNamed: '_test.zip'.	]! !!ZipDirectoryMember methodsFor: 'private' stamp: 'cmm 9/16/2010 18:59'!writeDataTo: aStream       "Write nothing. Directories have no contents to write."! !"Compression"!!ByteArray methodsFor: 'accessing' stamp: 'ul 9/12/2010 03:47'!indexOf: anInteger startingAt: start	(anInteger isInteger and: [		anInteger >= 0 and: [		anInteger <= 255 ] ]) ifFalse: [ ^0 ].	^ByteString indexOfAscii: anInteger inString: self startingAt: start! !!WeakSet methodsFor: 'public' stamp: 'ul 9/12/2010 03:37' prior: 57541171!do: aBlock after: anElement	| index endIndex |	tally = 0 ifTrue: [ ^self ].	anElement		ifNil: [ index := 0 ]		ifNotNil: [ 			index := self scanFor: anElement.			(array at: index) == flag ifTrue: [				index := 0 ] ].	endIndex := array size.	[ (index := index + 1) <= endIndex ] whileTrue: [		(array at: index) ifNotNil: [ :object |			object == flag ifFalse: [				aBlock value: object enclosedSetElement] ] ]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ul 9/12/2010 04:34'!indexOf: anElement startingAt: start	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer 0."	^self indexOf: anElement startingAt: start ifAbsent: 0! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:08' prior: 30218429!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	order == nil ifTrue: [		len1 := string1 size.		len2 := string2 size.		1 to: (len1 min: len2) do:[:i |			c1 := string1 basicAt: i.			c2 := string2 basicAt: i.			c1 = c2 ifFalse: [c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].		].		len1 = len2 ifTrue: [^ 2].		len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].	].	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:[:i |		c1 := string1 basicAt: i.		c2 := string2 basicAt: i.		c1 < 256 ifTrue: [c1 := order at: c1 + 1].		c2 < 256 ifTrue: [c2 := order at: c2 + 1].		c1 = c2 ifFalse:[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]].	].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:07' prior: 30219680!findFirstInString: aString inSet: inclusionMap startingAt: start	"Trivial, non-primitive version"		| i stringSize ascii more |	inclusionMap size ~= 256 ifTrue: [^ 0].	stringSize := aString size.	more := true.	i := start - 1.	[more and: [(i := i + 1) <= stringSize]] whileTrue: [		ascii := aString basicAt: i.		more := ascii < 256 ifTrue: [(inclusionMap at: ascii + 1) = 0] ifFalse: [true].	].	i > stringSize ifTrue: [^ 0].	^ i! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:06' prior: 30220201!indexOfAscii: anInteger inString: aString startingAt: start	"Trivial, non-primitive version"	start to: aString size do: [ :index |		(aString basicAt: index) = anInteger ifTrue: [ ^index ] ].	^0! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:02' prior: 30220512!stringHash: aString initialHash: speciesHash	| stringSize hash low |	stringSize := aString size.	hash := speciesHash bitAnd: 16r0FFFFFFF.	1 to: stringSize do: [ :pos |		hash := hash + (aString basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash // 16384) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF ].	^hash.! !!String class methodsFor: 'primitives' stamp: 'ul 9/12/2010 04:09' prior: 30220990!translate: aString from: start  to: stop  table: table	"Trivial, non-primitive version"	start to: stop do: [ :i |		| char |		(char := aString basicAt: i) < 256 ifTrue: [			aString at: i put: (table at: char+1) ] ].! !!Symbol class methodsFor: 'class initialization' stamp: 'ul 9/12/2010 03:25' prior: 30357696!allSymbolTablesDo: aBlock after: aSymbol	(NewSymbols includes: aSymbol) 		ifTrue: [			NewSymbols do: aBlock after: aSymbol.			SymbolTable do: aBlock after: aSymbol ]		ifFalse: [			SymbolTable do: aBlock after: aSymbol.			NewSymbols do: aBlock after: aSymbol ]	! !"Collections"!!MCMethodDefinition methodsFor: 'accessing' stamp: 'nice 9/22/2010 00:48' prior: 22962773!timeStamp	^ timeStamp ifNil: ['']! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:54' prior: 53866520!newVersion	^ (self requestVersionNameAndMessageWithSuggestion: self uniqueVersionName		initialMessage: self patchMessageSuggestion) ifNotNil:			[:pair |			self newVersionWithName: pair first				message: (self patchMessageStripped: pair last)].! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:31'!patchMessageChanges	| changes parentInfo parentSnapshot |	parentInfo := self ancestors		ifEmpty: [nil]		ifNotEmpty: [self ancestors first].	parentSnapshot := 	self findSnapshotWithVersionInfo: parentInfo.	changes := package snapshot patchRelativeToBase: parentSnapshot.	^ (MCPatchMessage new patch: changes) message! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 19:00'!patchMessageChangesDelimiter	^'=== text below is ignored ==='! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 19:04'!patchMessageChangesHeader	^ancestry summary, String cr,	'Added, Modified, Deleted',	(self ancestors ifEmpty: [''] ifNotEmpty: [' vs. ', self ancestors first name]), ':'! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:15'!patchMessageDefault	^ 'empty log message'! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:31'!patchMessageStripped: aString	| pos |	pos := aString findString: self patchMessageChangesDelimiter.	^ (pos > 0		ifTrue: [aString first: pos - 1]		ifFalse: [aString]) withBlanksTrimmed! !!MCWorkingCopy methodsFor: 'operations' stamp: 'bf 9/4/2010 18:35'!patchMessageSuggestion	^	self patchMessageDefault, String cr, String cr,		self patchMessageChangesDelimiter, String cr,		self patchMessageChangesHeader, String cr,		self patchMessageChanges! !!MCWorkingCopy methodsFor: 'private' stamp: 'bf 9/4/2010 15:29'!requestVersionNameAndMessageWithSuggestion: nameString initialMessage: msgString	^ (MCVersionNameAndMessageRequest new		suggestedName: nameString;		initialMessage: msgString		) signal! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 22:53' prior: 22947327!chooseLocal	self conflictSelectionDo:		[selection chooseLocal.		self changed: #text; changed: #list].	self selectNextUnresolvedConflict! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 22:38' prior: 22947514!chooseRemote	self conflictSelectionDo:		[selection chooseRemote.		self changed: #text; changed: #list].	self selectNextUnresolvedConflict! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 22:59' prior: 22947890!conflictSelectionDo: aBlock	self selectionIsConflicted		ifTrue: aBlock! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 22:57' prior: 22949052!innerButtonRow	^ self buttonRow:		#((Keep chooseRemote 'keep the selected change' )		  (Reject chooseLocal 'reject the selected change' ))! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 01:02'!methodListKey: aKeystroke from: aListMorph 	aKeystroke caseOf: {		[$k] -> [self chooseRemote].		[$r] -> [self chooseLocal]}		 otherwise: [super methodListKey: aKeystroke from: aListMorph ]! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/6/2010 23:09'!selectNextUnresolvedConflict	"Try and select the next unresolved conflict starting at current selection in the list, wrapping at beginning.	If there is no more unresolved conflict, then simply move to next non conflict item in the list.	This method makes assumption that conflicts are always sorted before non conflicts items."	(self findListMorph: #list)		ifNotNil:			[:aMorph |			| currentIndex nextUnresolvedIndex |			currentIndex := aMorph getCurrentSelectionIndex min: conflicts size.			nextUnresolvedIndex := (currentIndex + 1 to: currentIndex + conflicts size - 1)				detect:					[:i |					| nextItem |					((nextItem := conflicts atWrap: i) isKindOf: MCConflict)						and: [nextItem isResolved not]]				ifNone: [0].			nextUnresolvedIndex = 0				ifTrue: [items size > 1 ifTrue: [self selection: (aMorph getCurrentSelectionIndex max: conflicts size)  - conflicts size \\ items size + conflicts size + 1]]				ifFalse: [self selection: nextUnresolvedIndex - 1 \\ conflicts size + 1].].! !!MCMergeBrowser methodsFor: 'as yet unclassified' stamp: 'nice 9/22/2010 01:55' prior: 22949987!widgetSpecs	Preferences annotationPanes ifFalse: [ ^#(		((buttonRow) (0 0 1 0) (0 0 0 30))		((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from:) (0 0 1 0.4) (0 30 0 0))		((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30))		((textMorph: text) (0 0.4 1 1) (0 30 0 0))		)].	^ {		#((buttonRow) (0 0 1 0) (0 0 0 30)).		#((listMorph:selection:menu:keystroke: list selection methodListMenu: methodListKey:from:) (0 0 1 0.4) (0 30 0 0)).		#((innerButtonRow) (0 0.4 1 0.4) (0 0 0 30)).		{ #(textMorph: annotations). #(0 0.4 1 0.4). { 0. 30. 0. 30+self defaultAnnotationPaneHeight. }}.		{ #(textMorph: text). #(0 0.4 1 1). { 0. 30+self defaultAnnotationPaneHeight. 0. 0.}}	}! !!MCCodeTool methodsFor: 'menus' stamp: 'cmm 9/20/2010 13:59'!copyReference	"Copy the selected selector to the clipboard"	self selectedMessageName ifNotNilDo:		[ : selector | Clipboard clipboardText:			(self selectedClassOrMetaClass				ifNil: [ selector asString ]				ifNotNilDo: [ : cls | (cls >> selector) reference ]) ]! !!MCCodeTool methodsFor: 'menus' stamp: 'cmm 9/20/2010 17:29' prior: 33895824!methodListMenu: aMenu	"Build the menu for the selected method, if any."		self selectedMessageName	ifNil: [items notEmpty ifTrue:		[aMenu addList:#(('fileOut (o)'					fileOutMessage))]]	ifNotNil: [	aMenu addList:#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)			('copy reference'					copyReference)).		aMenu addList: #(			-			('browse senders (n)'						browseSendersOfMessages)			('browse implementors (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)		('change sets with this method'			findMethodInChangeSets)"		('x revert to previous version'				revertToPreviousVersion)"		('remove from current change set'		removeFromCurrentChanges)"		('x revert & remove from changes'		revertAndForget)"		('add to current change set'				adoptMessageInCurrentChangeset)"		('x copy up or copy down...'				copyUpOrCopyDown)""		('x remove method (x)'					removeMessage)"		"-"		).	]."	aMenu addList: #(			('x inst var refs...'						browseInstVarRefs)			('x inst var defs...'						browseInstVarDefs)			('x class var refs...'						browseClassVarRefs)			('x class variables'						browseClassVariables)			('x class refs (N)'							browseClassRefs)	)."	^ aMenu! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:48'!addDefinition: aDefinition	stream nextPutAll: 'A'; tab; nextPutAll: aDefinition summary; cr! !!MCPatchMessage methodsFor: 'accessing' stamp: 'bf 9/4/2010 16:29'!message	^stream contents! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:57'!modifyDefinition: oldDefinition to: newDefinition	stream nextPutAll: 'M'; tab; nextPutAll: newDefinition summary; cr! !!MCPatchMessage methodsFor: 'accessing' stamp: 'bf 9/4/2010 17:44'!patch: aPatch	stream ifNil: [stream := WriteStream on: (String new: 100)].	aPatch operations asSortedCollection		do: [:op | op applyTo: self]! !!MCPatchMessage methodsFor: 'patch operations' stamp: 'bf 9/4/2010 18:57'!removeDefinition: aDefinition	stream nextPutAll: 'D'; tab; nextPutAll: aDefinition summary; cr! !!MCTool methodsFor: 'morphic ui' stamp: 'nice 9/22/2010 02:03' prior: 23143785!defaultAnnotationPaneHeight 	"Answer the receiver's preferred default height for new annotation panes.	Since MC compares two annotations, reserve a bit less than a double the traditional height."	^ (Preferences parameterAt: #defaultAnnotationPaneHeight ifAbsentPut: [25]) * 5 // 3! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:38' prior: 23188894!defaultAction	^ MCSaveVersionDialog new		versionName: suggestion;		logMessage: initialMessage;		showModally! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:28'!initialMessage	^ initialMessage! !!MCVersionNameAndMessageRequest methodsFor: 'as yet unclassified' stamp: 'bf 9/4/2010 15:28'!initialMessage: aString	initialMessage := aString! !MCWorkingCopy removeSelector: #requestVersionNameAndMessageWithSuggestion:!"Monticello"!!BlockClosure methodsFor: 'evaluating' stamp: 'nice 9/10/2010 20:54' prior: 50399091!bench	"See how many times I can value in 5 seconds.  I'll answer a meaningful description."	| startTime endTime count roundTo3Digits |	roundTo3Digits := [:num |		| rounded lowDigit |		rounded := (num * 1000) rounded. "round to 1/1000"		lowDigit := (rounded numberOfDigitsInBase: 10) - 3. "keep only first 3 digits"		rounded := rounded roundTo:(10 raisedTo: lowDigit).		(lowDigit >= 3 or: [rounded \\ 1000 = 0]) "display fractional part only when needed"			ifTrue: [(rounded // 1000) asStringWithCommas]			ifFalse: [(rounded / 1000.0) printString]].	count := 0.	endTime := Time millisecondClockValue + 5000.	startTime := Time millisecondClockValue.	[ Time millisecondClockValue > endTime ] whileFalse: [ self value.  count := count + 1 ].	endTime := Time millisecondClockValue.	^count = 1		ifTrue: [ (roundTo3Digits value: (endTime - startTime) / 1000) , ' seconds.' ]		ifFalse:			[ (roundTo3Digits value: (count * 1000) / (endTime - startTime)) , ' per second.' ]! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:22'!isReceiverOrAnyArgumentGarbage	"For use in the when:evaluate: protocol, i.e.,		foo when: #bar evaluate:[self handleBar].."	^false! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:18'!valueOtherwise: aBlock	"Send the message and answer the return value"	^self value! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:18'!valueWithArguments: anArray otherwise: aBlock	^ self valueWithArguments: anArray! !!BlockClosure methodsFor: 'events-support' stamp: 'nice 9/21/2010 10:25'!valueWithEnoughArguments: anArray	"call me with enough arguments from anArray"	| args |	(anArray size == self numArgs)		ifTrue: [ ^self valueWithArguments: anArray ].	args := Array new: self numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self valueWithArguments: args! !!MethodDictionary methodsFor: 'accessing' stamp: 'mtf 8/15/2008 14:28' prior: 54062731!includesKey: aSymbol	"This override assumes that pointsTo is a fast primitive"	aSymbol ifNil: [^ false].	^ super instVarsInclude: aSymbol! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:38'!chasePointers	PointerFinder on: self! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 17:43'!explorePointers	PointerExplorer new openExplorerFor: self! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 16:28'!inboundPointers"Answers a collection of all objects in the system that point to myself"	^ self inboundPointersExcluding: #()! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:07'!inboundPointersExcluding: objectsToExclude"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"	| anObj pointers objectsToAlwaysExclude |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	pointers := OrderedCollection new: 1000.	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious	 method and block contexts out of the results"	anObj := self someObject.	[0 == anObj] whileFalse: [		anObj isInMemory			ifTrue: [((anObj instVarsInclude: self)				or: [anObj class == self])					ifTrue: [pointers add: anObj]].		anObj := anObj nextObject].	objectsToAlwaysExclude := {		pointers collector.		thisContext.		thisContext sender.		thisContext sender sender.		objectsToExclude.	}.	^ pointers removeAllSuchThat: [:ea |		(objectsToAlwaysExclude identityIncludes: ea)			or: [objectsToExclude identityIncludes: ea]]! !!Object methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:33'!outboundPointers"Answers a list of all objects I am causing not to be garbage-collected"	| collection |	collection := OrderedCollection new.	self outboundPointersDo: [:ea | collection add: ea].	^ collection! !!Object methodsFor: 'tracing' stamp: 'mtf 8/15/2008 15:34'!outboundPointersDo: aBlock"do aBlock for every object I point to, exactly how the garbage collector would. Adapted from PointerFinder >> #followObject:"	aBlock value: self class.	1 to: self class instSize do: [:i | aBlock value: (self instVarAt: i)].	1 to: self basicSize do: [:i | aBlock value: (self basicAt: i)].! !!NumberParser methodsFor: 'parsing-public' stamp: 'nice 8/27/2010 20:51' prior: 58101237!nextIntegerBase: aRadix ifFail: aBlock	"Form an integer with optional sign and following digits from sourceStream."		| isNeg value |	isNeg := self peekSignIsMinus.	value := self nextUnsignedIntegerOrNilBase: aRadix.	value ifNil: [^aBlock value].	^isNeg		ifTrue: [value negated]		ifFalse: [value]! !!TimeStamp methodsFor: 'squeak protocol' stamp: 'klc 9/12/2010 16:10'!asDateAndTime	"Answer the receiver as an instance of DateAndTime."	^ DateAndTime new setJdn: jdn seconds: seconds nano: nanos offset: offset! !!DateAndTime methodsFor: 'ansi protocol' stamp: 'klc 9/12/2010 15:29' prior: 33899222!= aDateAndTimeOrTimeStamp 	self == aDateAndTimeOrTimeStamp ifTrue: [ ^ true ].	((aDateAndTimeOrTimeStamp isKindOf: self class)		or: [aDateAndTimeOrTimeStamp isKindOf: DateAndTime orOf: TimeStamp])			ifFalse: [ ^ false ].	^ self offset = aDateAndTimeOrTimeStamp offset		ifTrue: [ self hasEqualTicks: aDateAndTimeOrTimeStamp ]		ifFalse: [ self asUTC ticks = aDateAndTimeOrTimeStamp asUTC ticks ]! !!DateAndTime methodsFor: 'squeak protocol' stamp: 'klc 9/12/2010 15:56' prior: 50870003!asDate	^ Date starting: self asDateAndTime! !!Number methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:16'!copySignTo: aNumber	"Return a number with same magnitude as aNumber and same sign as self."	^ self positive		ifTrue: [aNumber abs]		ifFalse: [aNumber abs negated].! !!Number methodsFor: 'mathematical functions' stamp: '' prior: 24888211!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0."	self > 0 ifTrue: [^1].	self < 0 ifTrue: [^-1].	^0! !!Number methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:24' prior: 24878037!sign: aNumber	"Return a Number with the same sign as aNumber and same magnitude as self."	^ aNumber copySignTo: self! !!Float methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:15'!copySignTo: aNumber	"Return a number with same magnitude as aNumber and same sign as self.	Implementation note: take care of Float negativeZero, which is considered as having a negative sign."	(self > 0 or: [(self at: 1) = 0])  ifTrue: [^ aNumber abs].	^aNumber abs negated! !!Float methodsFor: 'mathematical functions' stamp: 'jm 4/28/1998 01:10' prior: 20911696!sign	"Answer 1 if the receiver is greater than 0, -1 if less than 0, else 0.	Handle IEEE-754 negative-zero by reporting a sign of -1"	self > 0 ifTrue: [^ 1].	(self < 0 or: [((self at: 1) bitShift: -31) = 1]) ifTrue: [^ -1].	^ 0! !!Float methodsFor: 'mathematical functions' stamp: 'nice 9/21/2010 23:30'!sign: aNumber	"Return a Number with the same sign as aNumber and same magnitude as self.	Implementation is different from super to handle the special case of Float negativeZero."	(self = 0.0 and: [aNumber sign negative]) ifTrue: [^Float negativeZero].	^aNumber copySignTo: self! !!CompiledMethod methodsFor: 'tracing' stamp: 'mtf 8/19/2008 22:36'!outboundPointersDo: aBlock	| numLiterals |	aBlock value: self class.	numLiterals := self numLiterals.	1 to: numLiterals do: [:i | aBlock value: (self literalAt: i)]! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/20/2010 13:58' prior: 53315483!printOn: aStream 	"Overrides method inherited from the byte arrayed collection."	aStream nextPut: $(.	self printReferenceOn: aStream.	aStream space; nextPut: $".	self printNameOn: aStream.	aStream nextPut: $(;		 print: self identityHash;		 nextPut: $);		 nextPut: $";		 nextPut: $)! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/20/2010 13:58'!printReferenceOn: aStream 	"Print a string that can be used to access the currently installed method."	aStream print: self methodClass;		 nextPutAll: '>>';		 nextPutAll: self selector storeString! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/19/2010 16:32'!printSignatureOn: aStream 	"Print a string that can be used to access the currently installed method."	aStream print: self methodClass;		 nextPutAll: '>>';		 nextPutAll: self selector storeString! !!CompiledMethod methodsFor: 'printing' stamp: 'cmm 9/20/2010 13:59'!reference	^ String streamContents: [ : stream | self printReferenceOn: stream ]! !!ProtoObject methodsFor: 'tracing' stamp: 'mtf 8/15/2008 18:40' prior: 27400800!pointsTo: anObject"Answers true if I hold a reference to anObject, or false otherwise. Or stated another way:Answers true if the garbage collector would fail to collect anObject because I hold a reference to it, or false otherwise"	^ (self instVarsInclude: anObject)		or: [self class == anObject]! !BlockClosure removeSelector: #isValid!"Kernel"!!MessageNode methodsFor: 'macro transformations' stamp: 'eem 9/7/2010 14:56' prior: 33684857!transformToDo: encoder	" var := rcvr. L1: [var <= arg1] Bfp(L2) [block body. var := var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar myRange blockRange limitIsAssignedTo |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)	  and: [arguments last numberOfArguments = 1	  and: [arguments last firstArgument isVariableReference "As with debugger remote vars"]]) ifFalse:		[^false].	arguments size = 3		ifTrue: [increment := arguments at: 2.				(increment isConstantNumber				 and: [increment literalValue ~= 0]) ifFalse: [^false]]		ifFalse: [increment := encoder encodeLiteral: 1].	(limit := arguments at: 1) isVariableReference ifTrue:		[limitIsAssignedTo := false.		 arguments last nodesDo:			[:node|			(node isAssignmentNode and: [node variable = limit]) ifTrue:				[limitIsAssignedTo := true]].		 limitIsAssignedTo ifTrue:			[^false]].	arguments size < 3 ifTrue:   "transform to full form"		[selector := SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	myRange := encoder rawSourceRanges at: self ifAbsent: [1 to: 0].	block := arguments last.	blockRange := encoder rawSourceRanges at: block ifAbsent: [1 to: 0].	blockVar := block firstArgument.	initStmt := AssignmentNode new variable: blockVar value: receiver.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit := nil]		ifFalse:  "Need to store limit in a var"			[limit := encoder bindBlockArg: blockVar key, 'LimiT' within: block.			 limit scope: -2.  "Already done parsing block; flag so it won't print"			 block addArgument: limit.			 limitInit := AssignmentNode new							variable: limit							value: arguments first].	test := MessageNode new				receiver: blockVar				selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])				arguments: (Array with: limit)				precedence: precedence from: encoder				sourceRange: (myRange first to: blockRange first).	incStmt := AssignmentNode new				variable: blockVar				value: (MessageNode new							receiver: blockVar selector: #+							arguments: (Array with: increment)							precedence: precedence from: encoder)				from: encoder				sourceRange: (myRange last to: myRange last).	arguments := (Array with: limit with: increment with: block),					(Array with: initStmt with: test with: incStmt with: limitInit).	block noteOptimizedIn: self.	^true! !"Compiler"!!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 9/20/2010 05:10' prior: 33689988!upTo: delimiter	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOf: delimiter startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					^collection copyFrom: position + 1 to: (position := pos) - 1 ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOf: delimiter startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					collection 						ifNil: [ self skip: pos - bytesRead ]						ifNotNil: [							position := pos.							readLimit := bytesRead ].					false "Found the delimiter." ] ] whileTrue ]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ul 9/20/2010 05:01' prior: 33691143!upToAnyOf: delimiters do: aBlock	| pos |	collection ifNotNil: [		(position < readLimit and: [			(pos := collection indexOfAnyOf: delimiters startingAt: position + 1) <= readLimit and: [				pos > 0 ] ]) ifTrue: [					| result |					result := collection copyFrom: position + 1 to: (position := pos) - 1 .					aBlock value: (collection at: position).					^result ] ].	^self collectionSpecies streamContents: [ :stream |		| buffer bytesRead |		buffer := collection 			ifNil: [ self collectionSpecies new: 2000 ]			ifNotNil: [				position < readLimit ifTrue: [					stream next: readLimit - position putAll: collection startingAt: position + 1.					position := readLimit ].				collection ].		[			bytesRead := self readInto: buffer startingAt: 1 count: buffer size.			((pos := buffer indexOfAnyOf: delimiters startingAt: 1) = 0 or: [ pos > bytesRead ])				ifTrue: [ 					stream next: bytesRead putAll: buffer startingAt: 1.					bytesRead > 0 "Try again if we could read something last time." ]				ifFalse: [					stream next: pos - 1 putAll: buffer startingAt: 1.					collection 						ifNil: [ self skip: pos - bytesRead ]						ifNotNil: [							position := pos.							readLimit := bytesRead ].					false "Found the delimiter." ] ] whileTrue.		bytesRead = 0 ifFalse: [			aBlock value: (buffer at: pos) ] ]! !!FileDirectory methodsFor: 'file directory' stamp: 'bf 9/5/2010 00:02' prior: 20472619!assureExistence	"Make sure the current directory exists. If necessary, create all parts in between"	self exists ifFalse: [ 		self containingDirectory			assureExistence;			createDirectory: self localName]! !!FileDirectory methodsFor: 'file directory' stamp: 'bf 9/9/2010 12:37' prior: 20472874!assureExistenceOfPath: lPath	"Make sure the local directory exists. If necessary, create all parts in between"	| localPath |	localPath := lPath.	localPath isEmpty ifTrue: [ ^self ]. "Assumed to exist"	self assureExistence.	(self directoryExists: localPath) ifTrue: [^ self]. "exists"	self createDirectory: localPath! !"Files"!!DateAndTimeTest methodsFor: 'Tests' stamp: 'klc 9/9/2010 15:55' prior: 34453680!testPrintString	"(self new setTestSelector: #testPrintString) debug"	| dt dtNoOffset |	dt :=DateAndTime		year: 2004		month: 11		day: 2		hour: 14		minute: 3		second: 5		nanoSecond: 12345		offset: (Duration seconds: (5 * 3600)).	self assert: dt printString = '2004-11-02T14:03:05.000012345+05:00'.		self assert: ('2002-05-16T17:20:45.1+01:01' asDateAndTime printString = '2002-05-16T17:20:45.1+01:01').	self assert:	(' 2002-05-16T17:20:45.02+01:01' asDateAndTime printString = '2002-05-16T17:20:45.02+01:01').  	self assert:	('2002-05-16T17:20:45.000000009+01:01' asDateAndTime printString =  '2002-05-16T17:20:45.000000009+01:01').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime printString = '2002-05-16T17:20:45+00:00' ).	self assert: (' 2002-05-16T17:20:45+01:57' asDateAndTime printString = '2002-05-16T17:20:45+01:57').	self assert: (' 2002-05-16T17:20:45-02:34' asDateAndTime printString = '2002-05-16T17:20:45-02:34').	self assert: ('2002-05-16T17:20:45+00:00' asDateAndTime printString = '2002-05-16T17:20:45+00:00').	self assert: ('1997-04-26T01:02:03+01:02:3' asDateAndTime printString = '1997-04-26T01:02:03+01:02:3').	"When no offset is provided, the local one is used"	dtNoOffset := '2002-05-16T17:20' asDateAndTime.	self assert: (('2002-05-16T17:20:00*' match: dtNoOffset printString) and: [dtNoOffset offset = DateAndTime localOffset]).! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'nice 9/22/2010 01:18'!testNegativeZero	"This test ensure that -0.0 will produce a negativeZero"	| negativeZero |	negativeZero := Number readFrom: '-0.0' readStream.		"If it is a negative zero, it must behave like a negative zero... IEEE 754 tells how it should behave"	self deny: (negativeZero at: 1) = 0 description: 'In IEEE 754, a negative zero has its sign bit set to 1'..	self assert: negativeZero = 0 description: 'In IEEE 754, a negative zero cannot be distinguished from zero'.! !!TimespanTest methodsFor: 'testing' stamp: 'klc 9/10/2010 17:11' prior: 31771783!testEnd	self assert: aTimespan end + (Duration  nanoSeconds:1)  =  aDisjointTimespan start.	self assert: aTimespan end = (DateAndTime year: 2005 month: 1 day: 7 hour: 23 minute: 59 second: 59 nanoSecond: 999999999 offset: 0 hours)! !!ClassTest methodsFor: 'setup' stamp: 'nice 9/21/2010 11:58'!categoryNameForTemporaryClasses	"Answer the category where to classify temporarily created classes"		^'Dummy-Tests-Class'! !!ClassTest methodsFor: 'setup' stamp: 'nice 9/21/2010 12:04' prior: 18688328!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassTest methodsFor: 'setup' stamp: 'nice 9/21/2010 12:01' prior: 18688633!tearDown	self deleteClass.	self deleteRenamedClass.	(Smalltalk organization listAtCategoryNamed: self categoryNameForTemporaryClasses) isEmpty		ifTrue: [Smalltalk organization removeCategory: self categoryNameForTemporaryClasses]! !!FloatTest methodsFor: 'testing' stamp: 'nice 9/22/2010 00:10'!testSign	"Set up"	| negatives negz positives strictNegatives strictPositives zero |	strictPositives := {2. 2.5. Float infinity}.	strictNegatives := {-3. -3.25. Float infinity negated}.	zero := 0.0.	negz := Float negativeZero.	positives := strictPositives copyWith: zero.	negatives := strictNegatives copyWith: negz.		"The sign of non zeros"	strictPositives do: [:aPositive | self assert: aPositive sign = 1].	strictNegatives do: [:aNegative | self assert: aNegative sign = -1].		"The sign of zeros"	self assert: zero sign = 0.	self assert: negz sign = -1. "remark though that negz >= 0.0, and is thus considered positive... Weird"		"Test the copy sign functions"	positives do: [:aPositiveSign |		positives do: [:aPositive | 			self assert: (aPositive sign: aPositiveSign) = aPositive].		negatives do: [:aNegative | 			self assert: (aNegative sign: aPositiveSign) = aNegative negated].		(zero sign: aPositiveSign) sign = 0.		(negz sign: aPositiveSign) sign = 0].		negatives do: [:aNegativeSign |		positives do: [:aPositive | 			self assert: (aPositive sign: aNegativeSign) = aPositive negated].		negatives do: [:aNegative | 			self assert: (aNegative sign: aNegativeSign) = aNegative].		(zero sign: aNegativeSign) sign = -1.		(negz sign: aNegativeSign) sign = -1].! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:57'!categoryNameForTemporaryClasses	"Answer the category where to classify temporarily created classes"		^'Dummy-Tests-ClassBuilder'! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55' prior: 57973489!cleanup	subClass ifNotNil:[subClass removeFromSystem].	baseClass ifNotNil:[baseClass removeFromSystem].	(Smalltalk organization listAtCategoryNamed: self categoryNameForTemporaryClasses) isEmpty		ifTrue: [Smalltalk organization removeCategory: self categoryNameForTemporaryClasses]! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55' prior: 57973668!makeByteVariableSubclassOf: aClass	subClass := aClass variableByteSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55' prior: 57973952!makeIVarsSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: 'var3 var4'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55' prior: 57974226!makeNormalSubclassOf: aClass	subClass := aClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55' prior: 57974492!makeVariableSubclassOf: aClass	subClass := aClass variableSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55' prior: 57974769!makeWeakSubclassOf: aClass	subClass := aClass weakSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'utilities' stamp: 'nice 9/21/2010 11:55' prior: 57975037!makeWordVariableSubclassOf: aClass	subClass := aClass variableWordSubclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:55' prior: 57975550!testByteVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableByteSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56' prior: 57976719!testChangeToVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[		self shouldnt:[baseClass := Object variableSubclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56' prior: 57977312!testDuplicateClassVariableError	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: 'TestVar'		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self should:[		subClass := baseClass subclass: self subClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] raise: DuplicateVariableError.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'TestVar'.		ex resume.	].	self shouldnt:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: Error.	self should:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: DuplicateVariableError.	[baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: 'TestVar'			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'TestVar'.		ex resume.	].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56' prior: 57978904!testDuplicateInstanceVariableError	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self should:[		subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] raise: DuplicateVariableError.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'var'.		ex resume.	].	self shouldnt:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: ''			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: Error.	self should:[		baseClass := Object subclass: self baseClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] raise: DuplicateVariableError.	[baseClass := Object subclass: self baseClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses.	] on: DuplicateVariableError do:[:ex|		self assert: ex superclass == baseClass.		self assert: ex variable = 'var'.		ex resume.	].! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56' prior: 57980471!testMoveVarFromSubToSuperclass	| baseInst subInst |	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	subClass := baseClass subclass: self subClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	subClass compile: 'subGet ^var'.	subClass compile: 'subSet: v var := v'.	self assert:[baseClass instSize = 0].	self assert:[subClass instSize = 1].	baseInst := baseClass new.	subInst := subClass new.	subInst instVarAt: 1 put: 123.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst subGet) = 123.	[baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	] on: DuplicateVariableError do:[:ex| ex resume].	baseClass compile: 'superGet ^var'.	baseClass compile: 'superSet: v var := v'.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 2].	"the assumption here is that an existing value is propagated up"	self assert: (baseInst instVarAt: 1) = nil.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst instVarAt: 2) = 123.	"the assumption below is that the subclass binds to the local scope not	the outer one, which is in line with common name space approaches."	subInst superSet: 666.	subInst subSet: 321.	self assert: (subInst instVarAt: 1) = 666.	self assert: (subInst instVarAt: 2) = 321.	self assert: (subInst superGet) = 666.	self assert: (subInst subGet) = 321.	subClass := baseClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 1].	"the assumption here is that the current (subclass) value is propagated up"	self assert: (subInst instVarAt: 1) = 321.	self assert: (subInst subGet) = 321.! !!ClassBuilderTest methodsFor: 'testing - reshape' stamp: 'nice 9/21/2010 11:56' prior: 57982616!testMoveVarFromSuperToSubclass	| baseInst subInst |	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	baseClass compile: 'superGet ^var'.	baseClass compile: 'superSet: v var := v'.	subClass := baseClass subclass: self subClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	subClass compile: 'subGet ^var'.	subClass compile: 'subSet: v var := v'.	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 1].	baseInst := baseClass new.	subInst := subClass new.	baseInst instVarAt: 1 put: 42.	subInst instVarAt: 1 put: 123.	self assert: (baseInst instVarAt: 1) = 42.	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst subGet) = 123.	[subClass := baseClass subclass: self subClassName			instanceVariableNames: 'var'			classVariableNames: ''			poolDictionaries: ''			category: self categoryNameForTemporaryClasses	] on: DuplicateVariableError do:[:ex| ex resume].	self assert:[baseClass instSize = 1].	self assert:[subClass instSize = 2].	self assert: (baseInst instVarAt: 1) = 42.	"the assumption below is that for duplicate variables the values get duplicated too.	this isn't strictly necessary; what we really need is that the old var doesn't get 	nuked but it has some advantages when moving vars up the hierarchy"	self assert: (subInst instVarAt: 1) = 123.	self assert: (subInst instVarAt: 2) = 123.	self assert: (subInst superGet) = 123.	self assert: (subInst subGet) = 123.	"the assumption below is that the subclass binds to the local scope not	the outer one, which is in line with common name space approaches."	subInst superSet: 666.	subInst subSet: 321.	self assert: (subInst instVarAt: 1) = 666.	self assert: (subInst instVarAt: 2) = 321.	self assert: (subInst superGet) = 666.	self assert: (subInst subGet) = 321.	baseClass removeSelector: #superGet.	baseClass removeSelector: #superSet:.	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	self assert:[baseClass instSize = 0].	self assert:[subClass instSize = 1].	self assert: (subInst instVarAt: 1) = 321.	self assert: (subInst subGet) = 321.! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56' prior: 57985088!testSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert:(subClass isVariable).	self assert:(subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self shouldnt:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self assert: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56' prior: 57986893!testSubclassWithInstanceVariables	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object subclass: self baseClassName		instanceVariableNames: 'var1 var2'		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self deny: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56' prior: 57988398!testVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56' prior: 57989893!testWeakSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object weakSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	"pointer classes"	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeIVarsSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeVariableSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	self shouldnt:[self makeWeakSubclassOf: baseClass] raise: Error.	self assert: (subClass isPointers).	self assert: (subClass isVariable).	self assert: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWordVariableSubclassOf: baseClass] raise: Error.	] ensure:[self cleanup].! !!ClassBuilderTest methodsFor: 'testing - format' stamp: 'nice 9/21/2010 11:56' prior: 57991384!testWordVariableSubclass	"Ensure that the invariants for superclass/subclass format are preserved"	baseClass := Object variableWordSubclass: self baseClassName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: self categoryNameForTemporaryClasses.	[	self shouldnt:[self makeNormalSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	"pointer classes"	self should:[self makeIVarsSubclassOf: baseClass] raise: Error.	self should:[self makeVariableSubclassOf: baseClass] raise: Error.	self should:[self makeWeakSubclassOf: baseClass] raise: Error.	"bit classes"	self should:[self makeByteVariableSubclassOf: baseClass] raise: Error.	self shouldnt:[self makeWordVariableSubclassOf: baseClass] raise: Error.	self deny: (subClass isPointers).	self assert: (subClass isVariable).	self deny: (subClass isWeak).	self deny: (subClass isBytes).	subClass removeFromSystem.	] ensure:[self cleanup].! !"KernelTests"!!MailSender class methodsFor: 'settings' stamp: 'nice 8/27/2010 20:43' prior: 23425734!setUserName	"Change the user's email name for use in composing messages."	(UIManager default			request: 'What is your email address?\(This is the address other people will reply to you)' withCRs			initialAnswer: (UserName ifNil: [UserName := '']))		ifNotNil: [:answer | UserName := answer]! !!Project class methodsFor: 'utilities' stamp: 'fm 9/11/2010 01:15' prior: 54934514!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	self flag: #toRemove. "after restarting the user interrupt watcher process"	^ self current interruptName: labelString! !!Project methodsFor: 'scheduling' stamp: 'fm 9/11/2010 00:56' prior: 53736656!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	^ self subclassResponsibility! !!ActionSequence methodsFor: 'evaluating' stamp: 'nice 9/21/2010 09:32' prior: 16923580!value	"Evaluate the elements of the receiver and answer the result of last evaluation."	^self inject: nil into:		[:previousAnswer :each | each value]! !!ActionSequence methodsFor: 'evaluating' stamp: 'nice 9/21/2010 09:33' prior: 16923822!valueWithArguments: anArray	"Evaluate the elements of the receiver with provided arguments and answer the result of last evaluation."	^self inject: nil into:		[:previousAnswer :each | each valueWithArguments: anArray]! !!SpaceTallyItem methodsFor: 'printing' stamp: 'jmv 3/2/2010 16:34' prior: 29638261!printOn: aStream	analyzedClassName		ifNotNil: [ aStream nextPutAll: analyzedClassName asString]. 	aStream nextPutAll: ' ('.	codeSize		ifNotNil: [ aStream nextPutAll: 'code size: ' ;  nextPutAll: codeSize asString]. 	instanceCount		ifNotNil: [ aStream nextPutAll: ' instance count: ' ;  nextPutAll: instanceCount asString]. 	spaceForInstances		ifNotNil: [ aStream nextPutAll: ' space for instances: ' ;  nextPutAll: spaceForInstances asString]. 	aStream nextPut: $).	! !!EventManager methodsFor: 'accessing' stamp: 'nice 9/21/2010 10:23' prior: 20223146!updateableActionMap	^actionMap ifNil:		[actionMap := self createActionMap]! !!BreakpointManager class methodsFor: 'private' stamp: 'nice 8/27/2010 22:14' prior: 17752078!installed	^Installed ifNil: [Installed := IdentityDictionary new]! !!SimpleServiceEntry methodsFor: 'printing' stamp: 'jmv 3/2/2010 17:15' prior: 29150102!printOn: aStream	aStream nextPutAll: self class name; nextPutAll: ': ('.	self provider		ifNotNil: [ aStream nextPutAll: provider printString].	aStream nextPutAll: ' --- '. 	self selector		ifNotNil: [ aStream nextPutAll: selector asString].	aStream nextPut: $)! !!Beeper class methodsFor: 'customize' stamp: 'nice 8/27/2010 16:32' prior: 17312092!default	"When the default is not defined it is	initialized using #newDefault."	^ default ifNil: [ default := self newDefault ]! !!FileServices class methodsFor: 'accessing' stamp: 'nk 12/7/2002 12:52'!suffixOf: aName	"Answer the file extension of the given file"	^ aName		ifNil:			['']		ifNotNil:			[(FileDirectory extensionFor: aName) asLowercase]! !!SmalltalkImage methodsFor: 'dictionary access' stamp: 'ul 9/19/2010 22:19'!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a key that begins with aString, false otherwise"		^globals hasBindingThatBeginsWith: aString! !!PseudoClass methodsFor: 'class' stamp: 'nice 9/21/2010 10:35' prior: 27422044!comment	^self organization commentRemoteStr		ifNil: [ self name,' has not been commented in this file']		ifNotNil: [:rStr | rStr string]! !!PseudoClass methodsFor: 'testing' stamp: 'jmv 3/2/2010 16:24' prior: 27430792!hasChanges	self sourceCode isEmpty ifFalse:[^true].	self organization hasNoComment ifFalse:[^true].	definition ifNotNil: [ ^true].	metaClass ifNotNil: [ ^metaClass hasChanges].	^false! !!PseudoClass methodsFor: 'removing' stamp: 'jmv 3/2/2010 16:24' prior: 27429897!removeAllUnmodified	| stClass |	self exists ifFalse:[^self].	self removeUnmodifiedMethods: self selectors.	stClass := self realClass.	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].	(self hasComment and:[stClass comment asString = self commentString]) ifTrue:[ self classComment: nil].	metaClass ifNotNil: [ metaClass removeAllUnmodified]! !"System"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 9/16/2010 22:42' prior: 33833011!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."Omnibrowser"(Installer wiresong project: ''ob'')	    install: ''OmniBrowser'';	    install: ''OB-Morphic'';	    install: ''OB-Standard'';	    install: ''OB-Shout'';	    install: ''OB-SUnitIntegration''. "Refactoring engine and OB integration"(Installer ss project: ''rb'')	install: ''AST'';	install: ''Refactoring-Core'';	install: ''Refactoring-Spelling'';	project: ''Regex'';	install: ''VB-Regex''.(Installer wiresong project: ''ob'')	install: ''OB-Refactory'';	install: ''OB-Regex''."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WAPharoServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 13 12 8 1 8 1 4 7 8 1 13 7 8 1 12 7 8 1 13 7 8 1 10 7 8 1 21 4 39 12 2 1 8 1 4 3 8 1 5 3 8 1 18 3 8 1 22 3 8 1 7 3 8 1 10 13 8 1 8 1 4 3 8 1 14 3 8 1 10 3 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 28 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000125125,cblack;,c000125125,cblack;,c000000125,cblack;,c125000125,cblack;,c000125125,cblack;,c000125125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000125125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000125125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000125125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000125125,cblack;,c000125125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000125125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000125125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;!!' readStream nextChunkText! !!MorphicProject methodsFor: 'scheduling' stamp: 'fm 9/11/2010 00:54'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	^ self interruptName: labelString preemptedProcess: nil! !!Morph methodsFor: 'accessing' stamp: 'nice 8/28/2010 01:26' prior: 24062767!sticky: aBoolean 	"change the receiver's sticky property"	(extension isNil and: [aBoolean not]) ifTrue: [^ self].	self assureExtension sticky: aBoolean! !"Morphic"!!ControlManager methodsFor: 'scheduling' stamp: 'fm 9/11/2010 00:10' prior: 19311271!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	^ self interruptName: labelString preemptedProcess: activeControllerProcess! !!ControlManager methodsFor: 'scheduling' stamp: 'fm 9/11/2010 01:26' prior: 53194745!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the interrupted process with the given label. Make the Notifier the active controller."	theInterruptedProcess suspend.	(activeController ~~ nil and: [activeController ~~ screenController]) ifTrue: [		theInterruptedProcess == activeControllerProcess			ifTrue: [				"Carefully de-emphasis the current window."				activeController view topView deEmphasizeForDebugger]			ifFalse: [				activeController controlTerminate]].	"This will just scheduleNoTerminate the newly built controller"	Debugger			openInterrupt: labelString			onProcess: theInterruptedProcess.	self searchForActiveController! !!MVCProject methodsFor: 'utilities' stamp: 'fm 9/11/2010 00:55'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	^ ScheduledControllers interruptName: labelString! !!MVCProject methodsFor: 'utilities' stamp: 'fm 9/11/2010 00:22' prior: 53703159!interruptName: labelString preemptedProcess: theInterruptedProcess	"Create a Notifier on the active scheduling process with the given label."	^ ScheduledControllers interruptName: labelString preemptedProcess: theInterruptedProcess! !"ST80"!!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'TN 5/31/2005 00:54' prior: 29144410!portDescription: portNum	"Answer a string indicating the directionality of the given MIDI port."	"(0 to: SimpleMIDIPort primPortCount - 1) collect:		[:i | SimpleMIDIPort portDescription: i]"	| portName dir |	portName := (self primPortNameOf: portNum) convertFromSystemString.	dir := self primPortDirectionalityOf: portNum.	dir = 1 ifTrue: [^ portName, ' (in)'].	dir = 2 ifTrue: [^ portName, ' (out)'].	dir = 3 ifTrue: [^ portName, ' (in/out)'].	^ self error: 'unknown MIDI port directionality'! !!MIDIScore methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 10:05' prior: 23294272!initialize	super initialize.	tracks := #().	ambientTrack := Array new.	tempoMap := #().	ticksPerQuarterNote := 100.! !!AbstractSound methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 09:33' prior: 16863187!initialize	super initialize.	envelopes := #().	mSecsSinceStart := 0.	samplesUntilNextControl := 0.	scaledVol := (1.0 * ScaleFactor) rounded.	scaledVolIncr := 0.	scaledVolLimit := scaledVol.! !!AbstractSound methodsFor: 'file i/o' stamp: 'eem 6/11/2008 12:37' prior: 54337359!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."	| bufSize stereoBuffer reverseBytes |	self reset.	bufSize := (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"	stereoBuffer := SoundBuffer newStereoSampleCount: bufSize.	reverseBytes := bigEndianFlag ~= (SmalltalkImage current isBigEndian).	'Storing audio...'		displayProgressAt: Sensor cursorPoint		from: 0 to: samplesToStore during: [:bar | | remaining out |			remaining := samplesToStore.			[remaining > 0] whileTrue: [				bar value: samplesToStore - remaining.				stereoBuffer primFill: 0.  "clear the buffer"				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.				out := self isStereo						ifTrue: [stereoBuffer]						ifFalse: [stereoBuffer extractLeftChannel].				reverseBytes ifTrue: [out reverseEndianness].				(aBinaryStream isKindOf: StandardFileStream)					ifTrue: [  "optimization for files: write sound buffer directly to file"						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"					ifFalse: [  "for non-file streams:"						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].				remaining := remaining - bufSize]].! !!RandomEnvelope methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 10:17' prior: 27488185!initialize	super initialize.	rand := Random new.	lowLimit := 0.994.	highLimit := 1.006.	delta := 0.0002.	currValue := 1.0.	scale := 1.0.! !!SoundRecorder methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 11:05' prior: 29597041!initialize	"SoundRecorder new"	super initialize.	stereo := false.	samplingRate := 11025.	recordLevel := 0.5.	self initializeRecordingState.! !!MIDISynthChannel methodsFor: 'initialization' stamp: 'alain.plantec 5/28/2009 10:05' prior: 23303308!initialize	super initialize.	instrument := FMSound default.	muted := false.	masterVolume := 0.5.	channelVolume := 1.0.	pan := 0.5.	pitchBend := 0.0.	activeSounds := OrderedCollection new.! !!SampledInstrument methodsFor: 'accessing' stamp: 'alain.plantec 5/28/2009 10:19' prior: 28102342!initialize	super initialize.	sustainedThreshold := 0.15.	loudThreshold := 0.5.! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'alain.plantec 5/28/2009 10:05' prior: 23296631!initialize	super initialize.	midiParser := MIDIInputParser on: nil.	channels := (1 to: 16) collect: [:ch | MIDISynthChannel new initialize].! !"Sound"!!CompilerTest methodsFor: 'testing' stamp: 'nice 9/8/2010 00:27'!testToDoModifiesTheLimit	"This is a non regression test for http://bugs.squeak.org/view.php?id=7093.	When blocks writes into to:do: loop limit, optimization shall be carried with care."		self		shouldnt:			[ | n |			n := 2.			1 to: n do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n]		raise: Error.	self		assert: 			[ | n |			n := 2.			1 to: n do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n] value = 4.	self		assert: 			[ | n |			n := 2.			1 to: n by: 1 do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n] value = 4.	self		assert: 			[ | n inc |			n := 2.			inc := 1.			1 to: n by: inc do: [:i | (n := n+1)>10 ifTrue: [self error: 'Should not get here']].			n] value = 4! !!DecompilerTests methodsFor: 'initialize-release' stamp: 'nice 9/8/2010 00:52'!tearDown	self class removeSelector: #loopWithMovingLimit! !!DecompilerTests methodsFor: 'tests' stamp: 'nice 9/8/2010 01:10'!testDecompileLoopWithMovingLimit	"This is a non regression test for http://bugs.squeak.org/view.php?id=7093"		| decompiledCode sourceCode |	sourceCode := 'loopWithMovingLimit	"This loop might be decompiled as a to:do: but should not because it does modify its limit"	| n i |	n := 4.	i := 1.	[i <= n] whileTrue: [		n := n - 1.		i := i + 1].	^n'.	self		shouldnt: [self class compile: sourceCode]		raise: Error.	self assert: (self perform: #loopWithMovingLimit) = 2.	self		shouldnt: [decompiledCode := self class decompile: #loopWithMovingLimit]		raise: Error.	self		shouldnt: [self class compile: decompiledCode decompileString]		raise: Error.	self		assert: (self perform: #loopWithMovingLimit) = 2		description: 'result from decompiledCode should not differ from sourceCode'.! !"Tests"!!ToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 18:56'!openDebugger: aSpec	"Build and open a debugger from the given spec.	Answer the widget opened. Subclasses can override this	method if opening a debugger has specific requirements	different from opening other widgets." 	self open: aSpec! !!ToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 18:59'!openDebugger: aSpec label: aString	"Build and open a debugger from the given spec, labeling it appropriately.	Answer the widget opened. Subclasses can override this	method if opening a debugger has specific requirements	different from opening other widgets." 	self open: aSpec label: aString! !"ToolBuilder-Kernel"!!MVCToolBuilder class methodsFor: 'accessing' stamp: 'fm 9/8/2010 11:52' prior: 23333285!isActiveBuilder	"Answer whether I am the currently active builder"	"This is really a way of answering whether 'Smalltalk isMVC'"	ScheduledControllers ifNil:[^false].	^(ScheduledControllers activeControllerProcess ifNil:[^false]) isTerminated not! !!MVCToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 21:40'!openDebugger: anObject	"Build and open the object. Answer the widget opened."	| window |	window := self build: anObject.	window controller openNoTerminate.	^window! !!MVCToolBuilder methodsFor: 'opening' stamp: 'dtl 9/11/2010 21:40'!openDebugger: anObject label: aString	"Build an open the object, labeling it appropriately.  Answer the widget opened."	| window |	window := self build: anObject.	window label: aString.	window controller openNoTerminate.	^window! !"ToolBuilder-MVC"!!Debugger class methodsFor: 'opening' stamp: 'fm 9/9/2010 00:54' prior: 34312929!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller errorWasInUIProcess debugger |	Smalltalk isMorphic		ifTrue: [errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: process]		ifFalse: [			controller := ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController].			[			debugger := self new process: process controller: controller context: context.			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].			] on: Error do: [:ex |				self primitiveError: 					'Orginal error: ', 					title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'			]].	WorldState addDeferredUIMessage: [ 		"schedule debugger in deferred UI message to address redraw		problems after opening a debugger e.g. from the testrunner."		[			debugger := self new process: process controller: nil context: context.			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			debugger errorWasInUIProcess: errorWasInUIProcess.			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logError: title inContext: context to: 'SqueakDebug.log'].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	process suspend.! !!Debugger methodsFor: 'context stack menu' stamp: 'eem 9/7/2010 12:10' prior: 19552595!browseMessages	"Present a menu of all messages sent by the currently selected message.	Open a message set browser of all implementors of the message chosen.	Do nothing if no message is chosen."	contextStackIndex = 0 ifTrue: [^ self].	self withSelectorAndMessagesIn: currentCompiledMethod		evaluate: [:selector| self systemNavigation browseAllImplementorsOf: selector]! !!Debugger methodsFor: 'context stack menu' stamp: 'eem 9/7/2010 12:11' prior: 19552934!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all	messages sent by it.  Open a message set browser of all senders	of the message chosen."	contextStackIndex = 0 ifTrue: [^ self].	self withSelectorAndMessagesIn: currentCompiledMethod		evaluate: [:selector| self systemNavigation browseAllCallsOn: selector]! !!Debugger methodsFor: 'context stack menu' stamp: 'eem 9/7/2010 12:16' prior: 19553270!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	class := self selectedClassOrMetaClass.	selector := self selectedMessageName.	VersionsBrowser		browseVersionsOf: (class compiledMethodAt: selector									ifAbsent: [^self changed: #flash])		class: self selectedClass theNonMetaClass		meta: class isMeta		category: self selectedMessageCategoryName		selector: selector! !!Debugger methodsFor: 'initialize' stamp: 'dtl 9/11/2010 21:52' prior: 53609208!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| oldContextStackIndex |	oldContextStackIndex := contextStackIndex.	self expandStack. "Sets contextStackIndex to zero."	ToolBuilder default openDebugger: self label: aString.	self toggleContextStackIndex: oldContextStackIndex.! !!Debugger methodsFor: 'initialize' stamp: 'dtl 9/11/2010 21:38' prior: 53620259!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg builder spec |	Sensor flushKeyboard.	savedCursor := Sensor currentCursor.	Sensor currentCursor: Cursor normal.	(label beginsWith: 'Space is low')		ifTrue: [msg := self lowSpaceChoices, (msgString ifNil: [''])]		ifFalse: [msg := msgString].	builder := ToolBuilder default.	spec := self buildNotifierWith: builder label: label message: msg.	self expandStack.	builder openDebugger: spec.	errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: interruptedProcess.! !!StringHolder methodsFor: '*Tools' stamp: 'cmm 9/20/2010 13:59'!copyReference	"Copy the selected selector to the clipboard"	self selectedMessageName ifNotNilDo:		[ : selector | Clipboard clipboardText:			(self selectedClassOrMetaClass				ifNil: [ selector asString ]				ifNotNilDo: [ : cls | (cls >> selector) reference ]) ]! !!StringHolder methodsFor: '*Tools' stamp: 'eem 9/7/2010 12:04' prior: 30250406!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method |	(selector := self selectedMessageName) ifNil: [^ self].	method := (self selectedClassOrMetaClass ifNil: [^aBlock value: selector])				compiledMethodAt: selector				ifAbsent: [].	method isNil ifTrue: [^aBlock value: selector].	^self withSelectorAndMessagesIn: method evaluate: aBlock! !!StringHolder methodsFor: '*Tools' stamp: 'eem 9/7/2010 12:02'!withSelectorAndMessagesIn: aCompiledMethod evaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selectorOrNil litGetter messages |	selectorOrNil := aCompiledMethod selector.	messages := Preferences thoroughSenders					ifTrue:						[litGetter := [:set :l|										(l isSymbol and: [l size > 0 and: [l first isLowercase]]) ifTrue:											[set add: l].										l isArray ifTrue:											[l inject: set into: litGetter copy].										set].						aCompiledMethod allLiterals						, (aCompiledMethod pragmas collect: [:pragma| pragma keyword])							inject: aCompiledMethod messages into: litGetter copy]					ifFalse: [aCompiledMethod messages].	(messages isEmpty	"if no messages, use only selector"	or: [messages size == 1 and: [messages includes: selectorOrNil]]) ifTrue:		[^selectorOrNil ifNotNil: [aBlock value: selectorOrNil]].  "If only one item, there is no choice"	self systemNavigation 		showMenuOf: messages		withFirstItem: selectorOrNil		ifChosenDo: [:sel | aBlock value: sel]! !!Browser methodsFor: 'class functions' stamp: 'eem 7/27/2010 11:14' prior: 56567255!classListMenu: aMenu shifted: shifted	"Set up the menu to apply to the receiver's class list, honoring the #shifted boolean"	(self menuHook: aMenu named: #classListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue:[^ self shiftedClassListMenu: aMenu].	aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol (p)'		browseFullProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('find method...'				findMethod)		-		('more...'					offerShiftedClassListMenu)).	^ aMenu! !!Browser methodsFor: 'message functions' stamp: 'cmm 9/20/2010 13:48' prior: 34070662!messageListMenu: aMenu shifted: shifted 	"Answer the message-list menu"	(self menuHook: aMenu named: #messageListMenu shifted: shifted) ifTrue:[^aMenu].	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList: #(			('what to show...'			offerWhatToShowMenu)			('toggle break on entry'		toggleBreakOnEntry)			-			('browse full (b)' 			browseMethodFull)			('browse hierarchy (h)'			classHierarchy)			('browse method (O)'			openSingleMessageBrowser)			('browse protocol (p)'			browseFullProtocol)			-			('fileOut'				fileOutMessage)			('printOut'				printOutMessage)			('copy selector (c)'						copySelector)			('copy reference'						copyReference)			-			('senders of... (n)'			browseSendersOfMessages)			('implementors of... (m)'		browseMessages)			('inheritance (i)'			methodHierarchy)			('versions (v)'				browseVersions)			-			('inst var refs...'			browseInstVarRefs)			('inst var defs...'			browseInstVarDefs)			('class var refs...'			browseClassVarRefs)			('class variables'			browseClassVariables)			('class refs (N)'			browseClassRefs)			-			('remove method (x)'			removeMessage)			('explore method'			exploreMethod)			('inspect method'			inspectMethod)			-			('more...'				shiftedYellowButtonActivity)).	^ aMenu! !!RecentMessageSet methodsFor: 'message functions' stamp: 'cmm 9/20/2010 13:47' prior: 27533138!messageListMenu: aMenu shifted: shifted	"Answer the message-list menu"	shifted ifTrue: [^ self shiftedMessageListMenu: aMenu].	aMenu addList:#(			('what to show...'						offerWhatToShowMenu)			-			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			('browse protocol (p)'					browseFullProtocol)			-			('fileOut (o)'							fileOutMessage)			('printOut'								printOutMessage)			('copy selector (c)'						copySelector)			('copy reference'						copyReference)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			('remove from RecentSubmissions'		removeFromRecentSubmissions)			-			('more...'								shiftedYellowButtonActivity)).	^ aMenu! !Browser removeSelector: #findMethodWithWildcard!"Tools"!!HelpOnHelp class methodsFor: 'pages' stamp: 'tbn 9/21/2010 21:34' prior: 34478981!introduction	"This method was automatically generated. Edit it using:"	"HelpOnHelp edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'WELCOME TO THE HELP SYSTEMThe help system is a simple user interface to display help contents to the user. It can be accessed from the world menu using "Tools" -> "Help Browser" or by evaluating ''HelpBrowser open'' in a workspace.There is a predefined mechanism allowing you to have help contents stored as source code using methods in specific help provider classes. This allows you to manage the help texts using the standard development tools. But this is only one possible representation.!!' readStream nextChunkText! !!HelpBrowser class methodsFor: 'instance creation' stamp: 'tbn 9/20/2010 09:36' prior: 33864684!openOn: aHelpTopic        "Open the receiver on the given help topic or any other object that can be transformed into         a help topic by sending #asHelpTopic."                ^(self defaultHelpBrowser new)                rootTopic: aHelpTopic;                open;                yourself! !!HelpBrowser methodsFor: 'events' stamp: 'tbn 9/20/2010 09:55' prior: 33776898!onItemClicked: anItem	anItem isNil ifTrue: [^contentMorph setText: rootTopic asHelpTopic contents].	contentMorph setText: anItem contents! !!HelpBrowser methodsFor: 'actions' stamp: 'tbn 9/20/2010 09:38' prior: 33777234!refresh        |helpTopic items|        helpTopic := rootTopic asHelpTopic.        window setLabel: helpTopic title.        items := helpTopic subtopics collect: [:each | HelpTopicListItemWrapper with: each ].        treeMorph list: items.        contentMorph setText: helpTopic contents! !"HelpSystem-Core"!----QUIT----{21 September 2010 . 7:52:48 pm} Squeak4.2-10382-alpha.image priorSource: 763819!----STARTUP----{21 September 2010 . 7:53:40 pm} as /Users/casey/Desktop/Squeak4.2-10382-alpha/Squeak4.2-10382-alpha.image!Smalltalk cleanUp: false!----QUIT----{21 September 2010 . 7:56:51 pm} Squeak4.2-10382-alpha.image priorSource: 1011940!----STARTUP----{21 September 2010 . 7:57:45 pm} as /Users/casey/Desktop/Squeak4.2-10548-alpha/Squeak4.2-10382-alpha.image!----SNAPSHOT----{21 September 2010 . 7:58:12 pm} Squeak4.2-10548-alpha.image priorSource: 1012187!Smalltalk cleanUp: false!----QUIT----{21 September 2010 . 7:58:43 pm} Squeak4.2-10548-alpha.image priorSource: 1012408!!WeakFinalizationRegistry commentStamp: 'Igor.Stasenko 3/8/2010 23:04' prior: 0!This kind of WeakRegistry using a new VM feature,which allows a more robust finalization support.In contrast to old implementation, it doesn't spending linear time , checking what elements became garbage.!!WeakFinalizationList commentStamp: 'Igor.Stasenko 9/22/2010 21:09' prior: 0!IMPORTANT!!!!!!This class is a special object, recognized by VM.Its only purpose is to a) identify a special kind of objects who usually having a weak references but  also having an instance of me held by first non-weak fixed slot (instance variable).b) a 'first' instance variable points to the head of a list of items, reported by VM which has weak references which became garbage during last garbage collectionAt my class side, there are some public behavior, which is used by finalization process to detect if VM supports new finalization scheme or should use the old one.Weak registry using #hasNewFinalization for switching to correct finalization logic,depending on VM it currently runs on.!!WeakFinalizerItem commentStamp: 'Igor.Stasenko 9/22/2010 20:59' prior: 0!My instances is used by weak registry to hold a single weak referenceand executor(s).Once object, referenced weakly by my instance become garbage, a weak registry triggers its executionby sending #finalizeValues to my instance.Note, that a new VM finalization scheme does not implies to use this particular classin order to implement finalization scheme. VM refers only to WeakFinalizationList class. In this way, my class and its implementation can serve as an example for implementing various finalization actions, which may differ from this one, provided by default for use by weak registry.Once initialized, my instance should: - point to particular list (an instance of WeakFinalizationList), - next should be nil - executor or multiple executors initialized - weak reference slot should point to some object of interestAt the moment, when object, referenced weakly, become garbage, VM checks if its fist instance variable is an instance of WeakFinalizationList.If it so, then it adds a given object to this list, and also links the tail of list through 'next' instance variable. So, as a result of garbage collection, a list will contain all objects, which had weak references to garbage collected objects. It is a responsibility of application to manage the instances of WeakFinalizationList's , as well as clear this list before the next garbage collection.As a consequence of that you can: - use multiple different lists and manage them differently in order to react differently when some objects became garbage - you are not obliged to handle/clear the list(s) immediately after GC. You can clean up them periodically. - you can implement own kind of weak referencing object(s), which could use same finalization, provided by newer VMs.VM requires only that an object with weak reference having at least two instance variables,and its first instance variable points to instance of WeakFinalizationList. Everything else is optional.!----STARTUP----{13 December 2010 . 5:51:37 pm} as /Users/casey/Desktop/Zips/Squeak4.2-10548-alpha/Squeak4.2-10548-alpha.image!!WeakFinalizationRegistry class methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:22'!default	^Default ifNil:[Default := self new]! !!WeakFinalizationRegistry class methodsFor: 'migrating registry' stamp: 'ul 9/26/2010 02:47'!migrateOldRegistries	Smalltalk at: #WeakFinalizationRegistry ifAbsent: [ ^ self "already done" ].		Smalltalk recreateSpecialObjectsArray.	WeakArray restartFinalizationProcess.		Smalltalk garbageCollect; garbageCollect.		"leave no chance to interrupt migration"		Compiler evaluate: '	[ | old new oldClass newClass |		old := OrderedCollection new.		new := OrderedCollection new.		WeakRegistry allInstancesDo: [:registry | | newr |			old add: registry.			newr := WeakFinalizationRegistry basicNew initialize.			registry migrateTo: newr.			new add: newr ].		old asArray elementsForwardIdentityTo: new asArray.				oldClass := WeakRegistry.		newClass := WeakFinalizationRegistry.				Smalltalk forgetClass: newClass logged: false.		newClass superclass removeSubclass: newClass.		newClass setName: #WeakRegistry.		oldClass becomeForward: newClass.	] forkAt: Processor highestPriority.	'.! !!WeakFinalizationRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 3/8/2010 21:47'!new	| registry |	registry := super new.	WeakArray addWeakDependent: registry.	^registry! !!WeakFinalizationRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/25/2010 05:31'!new: n	^ self new! !!WeakFinalizationRegistry methodsFor: 'adding' stamp: 'Igor.Stasenko 3/8/2010 21:03'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."		^self add: anObject executor: anObject executor! !!WeakFinalizationRegistry methodsFor: 'adding' stamp: 'Igor.Stasenko 5/25/2010 05:30'!add: anObject executor: anExecutor	self protected: [ | finItem |		finItem := valueDictionary at: anObject ifAbsentPut: [			WeakFinalizerItem new list: list object: anObject ].		finItem add: anExecutor ].	^ anObject! !!WeakFinalizationRegistry methodsFor: 'enumerating' stamp: 'Igor.Stasenko 5/25/2010 05:11'!do: aBlock	^self protected: [		valueDictionary keysDo: aBlock.	].! !!WeakFinalizationRegistry methodsFor: 'finalization' stamp: 'Igor.Stasenko 9/22/2010 21:21'!finalizeValues	"Finalize any values, which happen to stocked in our list, due to some weak references become garbage"		| finalizer |	WeakFinalizationList hasNewFinalization ifFalse: [		self protected: [ valueDictionary finalizeValues ].		^ self ].	self protected: [ finalizer := list swapWithNil ].	"We don't need to protect a following loop from concurrent access,	because at the moment we're finalizing values, 	only we can access this list of finalizers, because valueDictionary already see them	as an unused slots, because they're associated with key == nil"		[ finalizer notNil ] whileTrue: [		| next |		next := finalizer next.		finalizer finalizeValues.		finalizer := next	].! !!WeakFinalizationRegistry methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/28/2010 05:12'!initialize	valueDictionary := WeakIdentityKeyDictionary new.	list := WeakFinalizationList new.	sema := Semaphore forMutualExclusion.	self installFinalizer.! !!WeakFinalizationRegistry methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/28/2010 05:11'!installFinalizer	valueDictionary finalizer: #finalizeValues! !!WeakFinalizationRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 3/8/2010 22:49'!keys	^ valueDictionary keys! !!WeakFinalizationRegistry methodsFor: 'copying' stamp: 'Igor.Stasenko 5/28/2010 05:16'!postCopy	"should we prohibit any attempts to copy receiver?"	self protected: [ | oldDict |		sema := Semaphore forMutualExclusion.		oldDict := valueDictionary.		list := WeakFinalizationList new.		valueDictionary := WeakIdentityKeyDictionary new.		self installFinalizer.			oldDict keysAndValuesDo: [:key :value |			valueDictionary at: key put: (value copyWithList: list)		].	]! !!WeakFinalizationRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:13'!printElementsOn: aStream	sema ifNil: [^super printElementsOn: aStream].	aStream nextPutAll: '(<this WeakRegistry is locked>)'! !!WeakFinalizationRegistry methodsFor: 'private' stamp: 'Igor.Stasenko 5/25/2010 05:34'!protected: aBlock	"Execute aBlock protected by the accessLock"	^ sema		critical: aBlock		ifError: [ :msg :rcvr |		rcvr error: msg ] ! !!WeakFinalizationRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:21'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."		oldObject ifNil: [ ^nil ].	^(self protected: [ valueDictionary removeKey: oldObject ifAbsent: nil ])		ifNil: [ exceptionBlock value ]! !!WeakFinalizationRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:16'!removeAll	"See super"		self protected:[		valueDictionary removeAll.	].! !!WeakFinalizationRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/25/2010 05:48'!size	^ self protected: [valueDictionary slowSize]! !!WeakFinalizationRegistry methodsFor: 'private' stamp: 'Igor.Stasenko 5/25/2010 05:35'!species	^Set! !!WeakFinalizationList class methodsFor: 'vm capability test' stamp: 'Igor.Stasenko 9/22/2010 20:19'!checkTestPair	HasNewFinalization := TestList swapWithNil notNil.! !!WeakFinalizationList class methodsFor: 'vm capability test' stamp: 'Igor.Stasenko 9/22/2010 20:18'!hasNewFinalization	^ HasNewFinalization == true! !!WeakFinalizationList class methodsFor: 'vm capability test' stamp: 'Igor.Stasenko 9/22/2010 20:18'!initTestPair	TestItem := WeakFinalizerItem new list: TestList object: Object new.! !!WeakFinalizationList class methodsFor: 'class initialization' stamp: 'Igor.Stasenko 9/22/2010 20:17'!initialize	TestList := self new.! !!WeakFinalizationList methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!first	^ first! !!WeakFinalizationList methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!swapWithNil	| head |	head := first.	first := nil.	^ head! !!WeakFinalizerItem class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 3/8/2010 21:00'!new	^ self basicNew: 1! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!add: newExecutor	executor 		ifNil: [ executor := newExecutor ]		ifNotNil: [			executor hasMultipleExecutors				ifTrue: [ executor add: newExecutor]				ifFalse: [ executor := ObjectFinalizerCollection with: executor with: newExecutor ]		]! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!clear	list := next := nil.! !!WeakFinalizerItem methodsFor: 'copying' stamp: 'Igor.Stasenko 9/22/2010 21:06'!copyWithList: aList	^ self copy list: aList! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!executor	^ executor! !!WeakFinalizerItem methodsFor: 'finalizing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!finalizeValues	" cleanup the receiver, so it could be reused "	| ex |	ex := executor.	executor := nil.	next := nil.	ex finalize.! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list	^ list! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list: aList	list := aList! !!WeakFinalizerItem methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list: weakFinalizationList object: anObject	self assert: (weakFinalizationList class == WeakFinalizationList).	list := weakFinalizationList.	self at: 1 put: anObject.! !!WeakFinalizerItem methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 9/22/2010 21:06'!list: weakFinalizationList object: anObject executor: anExecutor	self assert: (weakFinalizationList class == WeakFinalizationList).	list := weakFinalizationList.	self at: 1 put: anObject.	executor := anExecutor! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!next	^ next! !!WeakFinalizerItem methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:06'!object	^ self at: 1! !!WeakFinalizerItem methodsFor: 'copying' stamp: 'Igor.Stasenko 9/22/2010 21:06'!postCopy	executor hasMultipleFinalizers ifTrue: [ executor := executor copy ].! !!WeakRegistry methodsFor: 'migrating' stamp: 'Igor.Stasenko 9/22/2010 22:52'!migrateTo: newRegistry	self protected: [		valueDictionary keysDo: [ :key |			newRegistry add: key executor: (valueDictionary at: key).		]].! !"Collections"!!Object methodsFor: 'finalization' stamp: 'Igor.Stasenko 5/25/2010 04:59'!hasMultipleExecutors	"All objects, except ObjectFinalizerCollection instances should answer false to this message"	^ false! !"Kernel"!!DefaultExternalDropHandler methodsFor: 'event handling' stamp: 'spfa 9/22/2010 09:44' prior: 34457625!handle: dropStream in: pasteUp dropEvent: anEvent 	"the file was just droped, let's do our job"	| fileName services chosen |	fileName := dropStream name.	services := self servicesForFileNamed: fileName.	"no service, default behavior"	services isEmpty 		ifTrue: [^UIManager default edit: dropStream contentsOfEntireFile].	chosen := self chooseServiceFrom: services.	chosen ifNotNil:[chosen performServiceFor: dropStream]! !!SmalltalkImage methodsFor: 'special objects' stamp: 'Igor.Stasenko 9/21/2010 03:09' prior: 33951635!recreateSpecialObjectsArray	"Smalltalk recreateSpecialObjectsArray"		"To external package developers:	**** DO NOT OVERRIDE THIS METHOD.  *****	If you are writing a plugin and need additional special object(s) for your own use, 	use addGCRoot() function and use own, separate special objects registry "		"The Special Objects Array is an array of objects used by the Squeak virtual machine.	 Its contents are critical and accesses to it by the VM are unchecked, so don't even	 think of playing here unless you know what you are doing."	| newArray |	newArray := Array new: 56.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (self associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: ByteString.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk.	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18).	"(low space Semaphore)"	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil. "This is the process signalling low space."	"An array of the 32 selectors that are compiled as special bytecodes,	 paired alternately with the number of arguments each takes."	newArray at: 24 put: #(	#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1							#* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1							#at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0							#blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0 ).	"An array of the 255 Characters in ascii order.	 Cog inlines table into machine code at: prim so do not regenerate it."	newArray at: 25 put: (self specialObjectsArray at: 25).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30).	"(delay Semaphore)"	newArray at: 31 put: (self specialObjectsArray at: 31).	"(user interrupt Semaphore)"	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes (yeah, right)"	"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 36 put: (self specialObjectsArray at: 36). "Is the prototype MethodContext (unused by the VM)"	newArray at: 37 put: BlockClosure.	"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 38 put: (self specialObjectsArray at: 38). "Is the prototype BlockContext (unused by the VM)"	"array of objects referred to by external code"	newArray at: 39 put: (self specialObjectsArray at: 39).	"preserve external semaphores"	newArray at: 40 put: nil. "Reserved for Mutex in Cog VMs"	newArray at: 41 put: nil. "Reserved for a LinkedList instance for overlapped calls in CogMT"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil: [Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	 Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (self at: #ExternalAddress ifAbsent: []).	newArray at: 45 put: (self at: #ExternalStructure ifAbsent: []).	newArray at: 46 put: (self at: #ExternalData ifAbsent: []).	newArray at: 47 put: (self at: #ExternalFunction ifAbsent: []).	newArray at: 48 put: (self at: #ExternalLibrary ifAbsent: []).	newArray at: 49 put: #aboutToReturn:through:.	newArray at: 50 put: #run:with:in:.	"51 reserved for immutability message"	"newArray at: 51 put: #attemptToAssign:withIndex:."	newArray at: 52 put: #(nil "nil => generic error" #'bad receiver'							#'bad argument' #'bad index'							#'bad number of arguments'							#'inappropriate operation'  #'unsupported operation'							#'no modification' #'insufficient object memory'							#'insufficient C memory' #'not found' #'bad method'							#'internal error in named primitive machinery'							#'object may move').	"53 to 55 are for Alien"	newArray at: 53 put: (self at: #Alien ifAbsent: []).	newArray at: 54 put: #invokeCallback:stack:registers:jmpbuf:.	newArray at: 55 put: (self at: #UnsafeAlien ifAbsent: []).	"Weak reference finalization"	newArray at: 56 put: (self at: #WeakFinalizationList ifAbsent: []).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray	! !!ObjectFinalizerCollection methodsFor: 'testing' stamp: 'Igor.Stasenko 5/25/2010 04:58'!hasMultipleExecutors	^ true! !"System"!!ToolBuilder methodsFor: 'widgets optional' stamp: 'rww 9/11/2010 13:37'!buildPluggableDropDownList: spec	^self buildPluggableList: spec! !!ToolBuilder methodsFor: 'defaults' stamp: 'rww 9/11/2010 14:09'!pluggableDropDownListSpec	^PluggableDropDownListSpec! !!PluggableDropDownListSpec methodsFor: 'building' stamp: 'rww 9/11/2010 13:36'!buildWith: builder	^builder buildPluggableDropDownList: self! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!listSelector	"Answer the value of listSelector"	^ listSelector! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!listSelector: anObject	"Set the value of listSelector"	listSelector := anObject! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSelector	"Answer the value of selectionSelector"	^ selectionSelector! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSelector: anObject	"Set the value of selectionSelector"	selectionSelector := anObject! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSetter	"Answer the value of selectionSetter"	^ selectionSetter! !!PluggableDropDownListSpec methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:36'!selectionSetter: anObject	"Set the value of selectionSetter"	selectionSetter := anObject! !"ToolBuilder-Kernel"!!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'rww 9/11/2010 04:23'!buildPluggableCheckBox: spec	| widget label state action |	label := spec label.	state := spec state.	action := spec action.	widget := self checkBoxClass on: spec model				getState: (state isSymbol ifTrue:[state])				action: (action isSymbol ifTrue:[action])				label: (label isSymbol ifTrue:[label]).	self register: widget id: spec name.	widget installButton."	widget getColorSelector: spec color.	widget offColor: Color white..	self buildHelpFor: widget spec: spec. 	(label isSymbol or:[label == nil]) ifFalse:[widget label: label]."	self setFrame: spec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	^widget! !!MorphicToolBuilder methodsFor: 'pluggable widgets' stamp: 'rww 9/11/2010 14:15'!buildPluggableDropDownList: spec	| widget model listSelector selectionSelector selectionSetter |	model := spec model.	listSelector := spec listSelector.	selectionSelector := spec selectionSelector.	selectionSetter := spec selectionSetter.	widget := self dropDownListClass new		model: model;		listSelector: listSelector;		selectionSelector: selectionSelector;		selectionSetter: selectionSetter;		yourself.	self register: widget id: spec name.	widget installDropDownList.	self setFrame: spec frame in: widget.	parent ifNotNil:[self add: widget to: parent].	^widget! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'rww 9/11/2010 03:39'!checkBoxClass	^ PluggableCheckBoxMorph! !!MorphicToolBuilder methodsFor: 'widget classes' stamp: 'rww 9/11/2010 14:05'!dropDownListClass	^ PluggableDropDownListMorph! !!PluggableCheckBoxMorph class methodsFor: 'as yet unclassified' stamp: 'rww 9/11/2010 03:44'!on: anObject getState: getStateSel action: actionSel label: labelSel	^ self new		on: anObject		getState: getStateSel		action: actionSel		label: labelSel		menu: nil! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!actionSelector	"Answer the value of actionSelector"	^ actionSelector! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!actionSelector: anObject	"Set the value of actionSelector"	actionSelector := anObject! !!PluggableCheckBoxMorph methodsFor: 'installing' stamp: 'rww 9/11/2010 04:10'!basicPanel	^BorderedMorph new		beTransparent;		extent: 0@0;		borderWidth: 0;		layoutInset: 0;		cellInset: 0;		layoutPolicy: TableLayout new;		listCentering: #topLeft;		cellPositioning: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		yourself! !!PluggableCheckBoxMorph methodsFor: 'installing' stamp: 'rww 9/11/2010 04:10'!horizontalPanel	^self basicPanel		cellPositioning: #center;		listDirection: #leftToRight;		yourself.! !!PluggableCheckBoxMorph methodsFor: 'installing' stamp: 'rww 9/11/2010 03:36'!installButton	| aButton aLabel |	aButton := UpdatingThreePhaseButtonMorph checkBox		target: self model;		actionSelector: self actionSelector;		getSelector: self valueSelector;		yourself.	aLabel := (StringMorph contents: self label translated				font: (StrikeFont familyName: TextStyle defaultFont familyName							size: TextStyle defaultFont pointSize - 1)).	self addMorph: (self horizontalPanel		addMorphBack: aButton;		addMorphBack: aLabel;		yourself).! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!label	"Answer the value of label"	^ label! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!label: anObject	"Set the value of label"	label := anObject! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:38'!model	"Answer the value of model"	^ model.! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!model: anObject	"Set the value of model"	model := anObject! !!PluggableCheckBoxMorph methodsFor: 'initialization' stamp: 'rww 9/11/2010 03:45'!on: anObject getState: getStateSel action: actionSel label: labelSel menu: menuSel	self model: anObject.	self valueSelector: getStateSel.	self actionSelector: actionSel.	self label: (self model perform: labelSel).! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!valueSelector	"Answer the value of valueSelector"	^ valueSelector! !!PluggableCheckBoxMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 03:37'!valueSelector: anObject	"Set the value of valueSelector"	valueSelector := anObject! !!PluggableDropDownListMorph methodsFor: 'drawing' stamp: 'rww 9/11/2010 14:22'!basicPanel	^BorderedMorph new		beTransparent;		extent: 0@0;		borderWidth: 0;		layoutInset: 0;		cellInset: 0;		layoutPolicy: TableLayout new;		listCentering: #topLeft;		cellPositioning: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		yourself! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:34'!currentSelection	^ self model perform: selectionSelector! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:34'!currentSelection: obj	^ self model perform: selectionSetter with: obj! !!PluggableDropDownListMorph methodsFor: 'drawing' stamp: 'rww 9/11/2010 14:22'!horizontalPanel	^self basicPanel		cellPositioning: #center;		listDirection: #leftToRight;		yourself.! !!PluggableDropDownListMorph methodsFor: 'drawing' stamp: 'rww 9/11/2010 14:20'!installDropDownList	| aButton aLabel |	aButton := PluggableButtonMorph on: self model getState: nil action: nil.	aLabel := (StringMorph contents: self model currentRemoteVatId translated				font: (StrikeFont familyName: TextStyle defaultFont familyName							size: TextStyle defaultFont pointSize - 1)).	self addMorph: (self horizontalPanel		addMorphBack: aLabel;		addMorphBack: aButton;		yourself).! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:33'!list	"Answer the value of list"	^ self model perform: self listSelector.	! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!listSelector	"Answer the value of listSelector"	^ listSelector! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!listSelector: anObject	"Set the value of listSelector"	listSelector := anObject! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:33'!model	^ model! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!model: anObject	"Set the value of model"	model := anObject! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSelector	"Answer the value of selectionSelector"	^ selectionSelector! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSelector: anObject	"Set the value of selectionSelector"	selectionSelector := anObject! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSetter	"Answer the value of selectionSetter"	^ selectionSetter! !!PluggableDropDownListMorph methodsFor: 'accessing' stamp: 'rww 9/11/2010 13:32'!selectionSetter: anObject	"Set the value of selectionSetter"	selectionSetter := anObject! !"ToolBuilder-Morphic"!!WeakArray class methodsFor: 'private' stamp: 'Igor.Stasenko 9/22/2010 21:19' prior: 56550133!finalizationProcess	[true] whileTrue:		[ WeakFinalizationList initTestPair.		FinalizationSemaphore wait.		FinalizationLock critical:			[			WeakFinalizationList checkTestPair.			FinalizationDependents do:				[:weakDependent |				weakDependent ifNotNil:					[weakDependent finalizeValues]]]			ifError:			[:msg :rcvr | rcvr error: msg].		].! !"Collections"!!MIMEDocument methodsFor: 'testing' stamp: 'ls 4/30/2000 18:45' prior: 23309336!isMultipartAlternative	"whether the document is in a multipart format where the parts are alternates"	^ self contentType = 'multipart/alternative'! !!HierarchicalUrl methodsFor: 'copying' stamp: 'nice 10/2/2010 00:47'!postCopy	"Be sure not to share the path with the original"	super postCopy.	path := path copy! !!FileUrl methodsFor: 'copying' stamp: 'nice 10/2/2010 00:49'!postCopy	"Be sure not to share the path with the copy."	super postCopy.	path := path copy! !!ServerDirectory methodsFor: 'copying' stamp: 'nice 10/1/2010 23:22'!postCopy	super postCopy.	self urlObject: urlObject copy! !FileUrl removeSelector: #copy!ServerDirectory removeSelector: #copy!HierarchicalUrl removeSelector: #copy!"Network"!!Heap commentStamp: 'nice 9/30/2010 23:22' prior: 21529027!Class Heap implements a special data structure commonly referred to as 'heap' [ http://en.wikipedia.org/wiki/Heap_%28data_structure%29 ]A Heap is a kind of binary tree stored in a linear array - see details after the instance variables description.Heaps are good at handling priority queues because:1) greatest priority element according to the sort block will be stored in first position and thus accessed in O(1) operations2) worse time for inserting or removing an element is in O(log n) operations, where n is the size of the Heap	Insertion/Removal times are more efficient than above upper bound, provided that:	a) Elements are only removed at the beginning	b) Elements are added with arbitrary sort order.3) there is no need to fully sort the Heap, which makes it more efficient than a SortedCollectionThe heap can be fully sorted by sending the message #fullySort.Worse time for fully sorting the Heap is in O(n log n) operations, but this is rarely used a feature.Remind that the Heap does not fully sort the collection if you don't ask.Thus don't expect #do: and other iterators to enumerate elements according to the sortBlock order.Instance variables:	array		<Array>		The data repository	tally		<Integer>	The number of elements in the heap	sortBlock	<Block|nil>	A two-argument block defining the sort order,							or nil in which case the default sort order is								[:element1 :element2| element1 <= element2]	indexUpdateBlock 	<Block|nil> 							A two-argument block of the form [:data :index | ... ]							which allows an application object to keep track of its							index within the heap.  Useful for quick heap update							when object's sort value changes (for example, when an							object in a priority queue has its priority increased							by an external event, you don't want to have to search							through the whole heap to find the index before fixing							the heap).  No update occurs if nil.									The Heap can be viewed as a binary tree (every node in the tree has at most two children).The root is stored in first slot of internal array.The children are stored in next two slots.The children of children in next four slots.etc...For a node A of index i (1 based), the two children B1 and B2 are thus stored in indices (2*i) and (2*i+1).Of course, the children indices must be less than the tally otherwise they are considered inexistent.The Heap does arrange to preserve the following invariant:For any children B of a node A, A is sorted before B, in other words, (self sort: A before: B) = trueThis implies that the root is always the first element according to sort order.!!WeakRegistry commentStamp: 'ul 9/26/2010 02:51' prior: 34567145!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.This kind of WeakRegistry is using a new VM feature, which allows a more robust finalization support. In contrast to the old implementation, it doesn't spend linear time checking which elements became garbage.See also:	Object executor	Object actAsExecutor	Object finalize!!Heap methodsFor: 'accessing' stamp: 'nice 9/30/2010 23:27'!fullySort	"Fully sort the heap.	This method preserves the heap invariants and can thus be sent safely"	self privateReverseSort.	1 to: tally // 2 do: [:i | array swap: i with: 1 + tally - i]! !!Heap methodsFor: 'private' stamp: 'nice 9/30/2010 23:26'!privateReverseSort	"Arrange to have the array sorted in reverse order.	WARNING: this method breaks the heap invariants. It's up to the sender to restore them afterwards."	| oldTally |	oldTally := tally.	[tally > 1] whileTrue:		[array swap: 1 with: tally.		tally := tally - 1.		self downHeapSingle: 1].	tally := oldTally! !!WeakRegistry class methodsFor: 'accessing' stamp: 'Igor.Stasenko 9/22/2010 21:22' prior: 34570415!default	^Default ifNil:[Default := self new]! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 3/8/2010 21:47' prior: 34571573!new	| registry |	registry := super new.	WeakArray addWeakDependent: registry.	^registry! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'Igor.Stasenko 5/25/2010 05:31' prior: 34571773!new: n	^ self new! !!WeakRegistry methodsFor: 'adding' stamp: 'Igor.Stasenko 3/8/2010 21:03' prior: 34571881!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."		^self add: anObject executor: anObject executor! !!WeakRegistry methodsFor: 'adding' stamp: 'Igor.Stasenko 5/25/2010 05:30' prior: 34572122!add: anObject executor: anExecutor	self protected: [ | finItem |		finItem := valueDictionary at: anObject ifAbsentPut: [			WeakFinalizerItem new list: list object: anObject ].		finItem add: anExecutor ].	^ anObject! !!WeakRegistry methodsFor: 'enumerating' stamp: 'Igor.Stasenko 5/25/2010 05:11' prior: 34572439!do: aBlock	^self protected: [		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'finalization' stamp: 'Igor.Stasenko 9/22/2010 21:21' prior: 34572605!finalizeValues	"Finalize any values, which happen to stocked in our list, due to some weak references become garbage"		| finalizer |	WeakFinalizationList hasNewFinalization ifFalse: [		self protected: [ valueDictionary finalizeValues ].		^ self ].	self protected: [ finalizer := list swapWithNil ].	"We don't need to protect a following loop from concurrent access,	because at the moment we're finalizing values, 	only we can access this list of finalizers, because valueDictionary already see them	as an unused slots, because they're associated with key == nil"		[ finalizer notNil ] whileTrue: [		| next |		next := finalizer next.		finalizer finalizeValues.		finalizer := next	].! !!WeakRegistry methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/28/2010 05:12' prior: 34573411!initialize	valueDictionary := WeakIdentityKeyDictionary new.	list := WeakFinalizationList new.	sema := Semaphore forMutualExclusion.	self installFinalizer.! !!WeakRegistry methodsFor: 'initialize-release' stamp: 'Igor.Stasenko 5/28/2010 05:11' prior: 34573673!installFinalizer	valueDictionary finalizer: #finalizeValues! !!WeakRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 10/11/2010 15:11' prior: 34573827!keys	^self protected: [ valueDictionary keys ]! !!WeakRegistry methodsFor: 'copying' stamp: 'Igor.Stasenko 5/28/2010 05:16' prior: 34573948!postCopy	"should we prohibit any attempts to copy receiver?"	self protected: [ | oldDict |		sema := Semaphore forMutualExclusion.		oldDict := valueDictionary.		list := WeakFinalizationList new.		valueDictionary := WeakIdentityKeyDictionary new.		self installFinalizer.			oldDict keysAndValuesDo: [:key :value |			valueDictionary at: key put: (value copyWithList: list)		].	]! !!WeakRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:13' prior: 34574427!printElementsOn: aStream	sema ifNil: [^super printElementsOn: aStream].	aStream nextPutAll: '(<this WeakRegistry is locked>)'! !!WeakRegistry methodsFor: 'private' stamp: 'Igor.Stasenko 5/25/2010 05:34' prior: 34574646!protected: aBlock	"Execute aBlock protected by the accessLock"	^ sema		critical: aBlock		ifError: [ :msg :rcvr |		rcvr error: msg ] ! !!WeakRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:21' prior: 34574877!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."		oldObject ifNil: [ ^nil ].	^(self protected: [ valueDictionary removeKey: oldObject ifAbsent: nil ])		ifNil: [ exceptionBlock value ]! !!WeakRegistry methodsFor: 'printing' stamp: 'Igor.Stasenko 5/25/2010 05:16' prior: 34575206!removeAll	"See super"		self protected:[		valueDictionary removeAll.	].! !!WeakRegistry methodsFor: 'accessing' stamp: 'Igor.Stasenko 5/25/2010 05:48' prior: 34575375!size	^ self protected: [valueDictionary slowSize]! !!WeakRegistry methodsFor: 'private' stamp: 'Igor.Stasenko 5/25/2010 05:35' prior: 34575517!species	^Set! !!WeakFinalizerItem methodsFor: 'copying' stamp: 'Igor.Stasenko 10/11/2010 15:06' prior: 34578545!postCopy	executor hasMultipleExecutors ifTrue: [ executor := executor copy ].! !String removeSelector: #hashMappedBy:!Array removeSelector: #hashMappedBy:!Interval removeSelector: #hashMappedBy:!LookupKey removeSelector: #identityHashMappedBy:!LookupKey removeSelector: #hashMappedBy:!WeakKeyAssociation removeSelector: #identityHashMappedBy:!WeakKeyAssociation removeSelector: #hashMappedBy:!"Collections"!!WeakRegistryTest methodsFor: 'tests' stamp: 'Igor.Stasenko 10/11/2010 13:32'!testVileFinalizer	" this test checks that manipulation (or accessing) weak registry 	does not leads to deadlock, when performed from within #finalize implementation"		| reg villian proc locked |		reg := WeakRegistry new.	WeakArray removeWeakDependent: reg.  "to prevent test interference with finalization process"		villian := VileFinalizer new initialize: reg.  "add object with vile finalization to registry"		locked := true. "be pessimistic"	proc := [ reg finalizeValues. locked := false ] newProcess.	villian := nil.		Smalltalk garbageCollect.		proc resume.	100 milliSeconds asDelay wait. "give chance for created process to run "		proc isTerminated ifFalse: [ proc terminate ].	self assert: locked == false.! !!VileFinalizer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 10/11/2010 13:29'!finalize	weakRegistry remove: self ifAbsent: [].! !!VileFinalizer methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 10/11/2010 13:36'!initialize: wr	weakRegistry := wr.	weakRegistry add: self.! !"CollectionsTests"!!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:31'!cull: firstArg	"Activate the receiver, with one or zero arguments."		self numArgs >= 1 ifTrue: [ ^self value: firstArg ].	^self value! !!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:32'!cull: firstArg cull: secondArg	"Activate the receiver, with two or less arguments."		self numArgs >= 2 ifTrue: [ ^self value: firstArg value: secondArg ].		self numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:32'!cull: firstArg cull: secondArg cull: thirdArg	"Activate the receiver, with three or less arguments."		self numArgs >= 2 ifTrue: [ 		self numArgs >= 3 ifTrue: [ ^self value: firstArg value: secondArg value: thirdArg ].		^self value: firstArg value: secondArg ].	self numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!BlockContext methodsFor: 'evaluating' stamp: 'nice 10/11/2010 23:32'!cull: firstArg cull: secondArg cull: thirdArg cull: fourthArg	"Activate the receiver, with four or less arguments."		self numArgs >= 3 ifTrue: [		self numArgs >= 4 ifTrue: [			^self value: firstArg value: secondArg value: thirdArg value: fourthArg ].		^self value: firstArg value: secondArg value: thirdArg ].	self numArgs = 2 ifTrue: [ ^self value: firstArg value: secondArg ].		self numArgs = 1 ifTrue: [ ^self value: firstArg ].	^self value! !!ContextPart methodsFor: 'private-exceptions' stamp: 'nice 10/11/2010 23:25' prior: 34326472!handleSignal: exception	"Sent to handler (on:do:) contexts only.  If my exception class (first arg) handles exception then execute my handle block (second arg), otherwise forward this message to the next handler context.  If none left, execute exception's defaultAction (see nil>>handleSignal:)."	| val |	(((self tempAt: 1) handles: exception) and: [self tempAt: 3]) ifFalse: [		^ self nextHandlerContext handleSignal: exception].	exception privHandlerContext: self contextTag.	self tempAt: 3 put: false.  "disable self while executing handle block"	val := [(self tempAt: 2) cull: exception ]		ensure: [self tempAt: 3 put: true].	self return: val.  "return from self if not otherwise directed in handle block"! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!object: anObject basicAt: index 	"Answer the value of an indexable element in the argument anObject without sending	 it a message. Fail if the argument index is not an Integer or is out of bounds, or if	 anObject is not indexable. This mimics the action of the VM when it indexes an object.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue: [self errorSubscriptBounds: index].	index isNumber		ifTrue: [^self object: anObject basicAt: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!object: anObject basicAt: index put: value 	"Store the last argument 	 value in the indexable element of the argument anObject indicated by index without sending	 anObject a message. Fail if the argument index is not an Integer or is out of bounds, or if	 anObject is not indexable, or if value is an inappropriate value for anObject's indexable slots.	 This mimics the action of the VM when it indexes an object.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger		ifTrue: [(index >= 1 and: [index <= (self objectSize: anObject)])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]].	index isNumber		ifTrue: [^self object: anObject basicAt: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:23'!object: anObject eqeq: anOtherObject 	"Answer whether the first and second arguments are the same object (have the	 same object pointer) without sending a message to the first argument.  This	 mimics the action of the VM when it compares two object pointers.  Used to	 simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 110>	self primitiveFailed! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 4/8/2009 19:27'!object: anObject instVarAt: anIndex	"Primitive. Answer a fixed variable in an object. The numbering of the 	 variables corresponds to the named instance variables. Fail if the index 	 is not an Integer or is not the index of a fixed variable. Essential for the	 debugger. See  Object documentation whatIsAPrimitive."	<primitive: 73>	"Access beyond fixed variables."	^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSize! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 4/8/2009 19:30'!object: anObject instVarAt: anIndex put: aValue 	"Primitive. Store a value into a fixed variable in the argument anObject.	 The numbering of the variables corresponds to the named instance	 variables.  Fail if the index is not an Integer or is not the index of a	 fixed variable.  Answer the value stored as the result. Using this	 message violates the  principle that each object has sovereign control	 over the storing of values into its instance variables. Essential for the	 debugger. See Object documentation whatIsAPrimitive."	<primitive: 74>	"Access beyond fixed fields"	^self object: anObject basicAt: anIndex - (self objectClass: anObject) instSize put: aValue! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/12/2009 21:24'!object: anObject perform: selector withArguments: argArray inClass: lookupClass	"Send the selector, aSymbol, to anObject with arguments in argArray.	 Fail if the number of arguments expected by the selector 	 does not match the size of argArray, or if lookupClass	 cannot be found among the anObject's superclasses.	 Primitive. Essential for the debugger."	<primitive: 100 error: error>	(selector isMemberOf: Symbol) ifFalse:		[^self error: 'selector argument must be a Symbol'].	(argArray isMemberOf: Array) ifFalse:		[^self error: 'argArray must be an Array'].	(selector numArgs = argArray size)		ifFalse: [^self error: 'incorrect number of arguments'].	((self objectClass: anObject) == lookupClass	 or: [(self objectClass: anObject) inheritsFrom: lookupClass]) ifFalse:		[^self error: 'lookupClass is not in anObject''s inheritance chain'].	self primitiveFailed! !!ContextPart methodsFor: 'mirror primitives' stamp: 'eem 5/13/2009 14:21'!objectSize: anObject	"Answer the number of indexable variables in the argument anObject without sending	 it a message. This mimics the action of the VM when it fetches an object's variable size.	 Used to simulate the execution machinery by, for example, the debugger.	 Primitive.  See Object documentation whatIsAPrimitive."	<primitive: 62>	"The number of indexable fields of fixed-length objects is 0"	^0! !!MethodFinder methodsFor: 'initialize' stamp: 'nice 10/1/2010 22:33' prior: 51701804!initialize	"The methods we are allowed to use.  (MethodFinder new initialize) "	Approved := Set new.	AddAndRemove := Set new.	Blocks := Set new.	"These modify an argument and are not used by the MethodFinder: longPrintOn: printOn: storeOn: sentTo: storeOn:base: printOn:base: absPrintExactlyOn:base: absPrintOn:base: absPrintOn:base:digitCount: writeOn: writeScanOn: possibleVariablesFor:continuedFrom: printOn:format:""Object"  	#("in class, instance creation" categoryForUniclasses chooseUniqueClassName initialInstance isSystemDefined newFrom: officialClass readCarefullyFrom:"accessing" at: basicAt: basicSize bindWithTemp: in: size yourself "testing" basicType ifNil: ifNil:ifNotNil: ifNotNil: ifNotNil:ifNil: isColor isFloat isFraction isInMemory isInteger isMorph isNil isNumber isPoint isPseudoContext isText isTransparent isWebBrowser knownName notNil pointsTo: wantsSteps "comparing" = == closeTo: hash identityHash identityHashPrintString ~= ~~ "copying" clone copy shallowCopy "dependents access" canDiscardEdits dependents hasUnacceptedEdits "updating" changed changed: okToChange update: windowIsClosing "printing" fullPrintString isLiteral longPrintString printString storeString stringForReadout stringRepresentation "class membership" class isKindOf: isKindOf:orOf: isMemberOf: respondsTo: xxxClass "error handling" "user interface" addModelMenuItemsTo:forMorph:hand: defaultBackgroundColor defaultLabelForInspector fullScreenSize initialExtent modelWakeUp mouseUpBalk: newTileMorphRepresentative windowActiveOnFirstClick windowReqNewLabel: "system primitives" asOop instVarAt: instVarNamed: "private" "associating" -> "converting" as: asOrderedCollection asString "casing" caseOf: caseOf:otherwise: "binding" bindingOf: "macpal" contentsChanged currentEvent currentHand currentWorld flash instanceVariableValues scriptPerformer "flagging" flag: "translation support" "objects from disk" "finalization" ) do: [:sel | Approved add: sel].	#(at:add: at:modify: at:put: basicAt:put: "NOT instVar:at:""message handling" perform: perform:orSendTo: perform:with: perform:with:with: perform:with:with:with: perform:withArguments: perform:withArguments:inSuperclass: ) do: [:sel | AddAndRemove add: sel]."Boolean, True, False, UndefinedObject"  	#("logical operations" & eqv: not xor: |"controlling" and: ifFalse: ifFalse:ifTrue: ifTrue: ifTrue:ifFalse: or:"copying" "testing" isEmptyOrNil) do: [:sel | Approved add: sel]."Behavior" 	#("initialize-release""accessing" compilerClass decompilerClass evaluatorClass format methodDict parserClass sourceCodeTemplate subclassDefinerClass"testing" instSize instSpec isBits isBytes isFixed isPointers isVariable isWeak isWords"copying""printing" defaultNameStemForInstances printHierarchy"creating class hierarchy""creating method dictionary""instance creation" basicNew basicNew: new new:"accessing class hierarchy" allSubclasses allSubclassesWithLevelDo:startingLevel: allSuperclasses subclasses superclass withAllSubclasses withAllSuperclasses"accessing method dictionary" allSelectors changeRecordsAt: compiledMethodAt: compiledMethodAt:ifAbsent: firstCommentAt: lookupSelector: selectors selectorsDo: selectorsWithArgs: "slow but useful ->" sourceCodeAt: sourceCodeAt:ifAbsent: sourceMethodAt: sourceMethodAt:ifAbsent:"accessing instances and variables" allClassVarNames allInstVarNames allSharedPools classVarNames instVarNames instanceCount sharedPools someInstance subclassInstVarNames"testing class hierarchy" inheritsFrom: kindOfSubclass"testing method dictionary" canUnderstand: classThatUnderstands: hasMethods includesSelector: whichClassIncludesSelector: whichSelectorsAccess: whichSelectorsReferTo: whichSelectorsReferTo:special:byte: whichSelectorsStoreInto:"enumerating""user interface""private" indexIfCompact) do: [:sel | Approved add: sel]."ClassDescription"	#("initialize-release" "accessing" classVersion isMeta name theNonMetaClass"copying" "printing" classVariablesString instanceVariablesString sharedPoolsString"instance variables" checkForInstVarsOK: "method dictionary" "organization" category organization whichCategoryIncludesSelector:"compiling" acceptsLoggingOfCompilation wantsChangeSetLogging"fileIn/Out" definition"private" ) do: [:sel | Approved add: sel]."Class"	#("initialize-release" "accessing" classPool"testing""copying" "class name" "instance variables" "class variables" classVarAt: classVariableAssociationAt:"pool variables" "compiling" "subclass creation" "fileIn/Out" ) do: [:sel | Approved add: sel]. "Metaclass"	#("initialize-release" "accessing" isSystemDefined soleInstance"copying" "instance creation" "instance variables"  "pool variables" "class hierarchy"  "compiling""fileIn/Out"  nonTrivial ) do: [:sel | Approved add: sel]."Context, BlockContext"	#(receiver client method receiver tempAt: "debugger access" pc selector sender shortStack sourceCode tempNames tempsAndValues"controlling"  "printing" "system simulation" "initialize-release" "accessing" hasMethodReturn home numArgs"evaluating" value value:ifError: value:value: value:value:value: value:value:value:value: valueWithArguments:"controlling"  "scheduling"  "instruction decoding"  "printing" "private"  "system simulation" ) do: [:sel | Approved add: sel].	#(value: "<- Association has it as a store" ) do: [:sel | AddAndRemove add: sel]."Message"	#("inclass, instance creation" selector: selector:argument: selector:arguments:"accessing" argument argument: arguments sends:"printing" "sending" ) do: [:sel | Approved add: sel].	#("private" setSelector:arguments:) do: [:sel | AddAndRemove add: sel]."Magnitude"	#("comparing" < <= > >= between:and:"testing" max: min: min:max: ) do: [:sel | Approved add: sel]."Date, Time"	#("in class, instance creation" fromDays: fromSeconds: fromString: newDay:month:year: newDay:year: today	"in class, general inquiries" dateAndTimeNow dayOfWeek: daysInMonth:forYear: daysInYear: firstWeekdayOfMonth:year: indexOfMonth: leapYear: nameOfDay: nameOfMonth:"accessing" day leap monthIndex monthName weekday year"arithmetic" addDays: subtractDate: subtractDays:"comparing""inquiries" dayOfMonth daysInMonth daysInYear daysLeftInYear firstDayOfMonth previous:"converting" asSeconds"printing"  mmddyyyy printFormat: "private" weekdayIndex 	"in class, instance creation" fromSeconds: now 	"in class, general inquiries" dateAndTimeFromSeconds: dateAndTimeNow millisecondClockValue millisecondsToRun: totalSeconds"accessing" hours minutes seconds"arithmetic" addTime: subtractTime:"comparing""printing" intervalString print24 "converting") do: [:sel | Approved add: sel].	#("private" 		 ) do: [:sel | AddAndRemove add: sel]."Number"	#("in class" readFrom:base: "arithmetic" * + - / // \\ abs negated quo: reciprocal rem:"mathematical functions" arcCos arcSin arcTan arcTan: cos exp floorLog: ln log log: raisedTo: raisedToInteger: sin sqrt squared tan"truncation and round off" ceiling detentBy:atMultiplesOf:snap: floor roundTo: roundUpTo: rounded truncateTo: truncated"comparing""testing" even isDivisibleBy: isInfinite isNaN isZero negative odd positive sign strictlyPositive"converting" @ asInteger asNumber asPoint asSmallAngleDegrees degreesToRadians radiansToDegrees"intervals" to: to:by: "printing" printStringBase: storeStringBase: ) do: [:sel | Approved add: sel]."Integer"	#("in class" primesUpTo:"testing" isPowerOfTwo"arithmetic" alignedTo:"comparing""truncation and round off" atRandom normalize"enumerating" timesRepeat:"mathematical functions" degreeCos degreeSin factorial gcd: lcm: take:"bit manipulation" << >> allMask: anyMask: bitAnd: bitClear: bitInvert bitInvert32 bitOr: bitShift: bitXor: lowBit noMask:"converting" asCharacter asColorOfDepth: asFloat asFraction asHexDigit"printing" asStringWithCommas hex hex8 radix:"system primitives" lastDigit replaceFrom:to:with:startingAt:"private" "benchmarks" ) do: [:sel | Approved add: sel]."SmallInteger, LargeNegativeInteger, LargePositiveInteger"	#("arithmetic" "bit manipulation" highBit "testing" "comparing" "copying" "converting" "printing" "system primitives" digitAt: digitLength "private" fromString:radix: ) do: [:sel | Approved add: sel].	#(digitAt:put: ) do: [:sel | AddAndRemove add: sel]."Float"	#("arithmetic""mathematical functions" reciprocalFloorLog: reciprocalLogBase2 timesTwoPower:"comparing" "testing""truncation and round off" exponent fractionPart integerPart significand significandAsInteger"converting" asApproximateFraction asIEEE32BitWord asTrueFraction"copying") do: [:sel | Approved add: sel]."Fraction, Random"	#(denominator numerator reduced next nextValue) do: [:sel | Approved add: sel].	#(setNumerator:denominator:) do: [:sel | AddAndRemove add: sel]."Collection"	#("accessing" anyOne"testing" includes: includesAllOf: includesAnyOf: includesSubstringAnywhere: isEmpty isSequenceable occurrencesOf:"enumerating" collect: collect:thenSelect: count: detect: detect:ifNone: detectMax: detectMin: detectSum: inject:into: reject: select: select:thenCollect: intersection:"converting" asBag asCharacterSet asSet asSortedArray asSortedCollection asSortedCollection:"printing""private" maxSize"arithmetic""math functions" average max median min range sum) do: [:sel | Approved add: sel].	#("adding" add: addAll: addIfNotPresent:"removing" remove: remove:ifAbsent: removeAll: removeAllFoundIn: removeAllSuchThat: remove:ifAbsent:) do: [:sel | AddAndRemove add: sel]."SequenceableCollection"	#("comparing" hasEqualElements:"accessing" allButFirst allButLast at:ifAbsent: atAll: atPin: atRandom: atWrap: fifth first fourth identityIndexOf: identityIndexOf:ifAbsent: indexOf: indexOf:ifAbsent: indexOf:startingAt:ifAbsent: indexOfSubCollection:startingAt: indexOfSubCollection:startingAt:ifAbsent: last second sixth third"removing""copying" , copyAfterLast: copyAt:put: copyFrom:to: copyReplaceAll:with: copyReplaceFrom:to:with: copyUpTo: copyUpToLast: copyWith: copyWithout: copyWithoutAll: forceTo:paddingWith: shuffled sortBy:"enumerating" collectWithIndex: findFirst: findLast: pairsCollect: with:collect: withIndexCollect: polynomialEval:"converting" asArray asDictionary asFloatArray asIntegerArray asStringWithCr asWordArray reversed"private" copyReplaceAll:with:asTokens: ) do: [:sel | Approved add: sel].	#( swap:with:) do: [:sel | AddAndRemove add: sel]."ArrayedCollection, Bag"	#("private" defaultElement "sorting" isSorted"accessing" cumulativeCounts sortedCounts sortedElements "testing" "adding" add:withOccurrences: "removing" "enumerating" 	) do: [:sel | Approved add: sel].	#( mergeSortFrom:to:by: sort sort: add: add:withOccurrences:"private" setDictionary ) do: [:sel | AddAndRemove add: sel]."Other messages that modify the receiver"	#(atAll:put: atAll:putAll: atAllPut: atWrap:put: replaceAll:with: replaceFrom:to:with:  removeFirst removeLast) do: [:sel | AddAndRemove add: sel].	self initialize2."MethodFinder new initialize.MethodFinder new organizationFiltered: Set"! !Magnitude removeSelector: #hashMappedBy:!Object removeSelector: #var:declareC:!Object removeSelector: #inline:!Object removeSelector: #identityHashMappedBy:!Object removeSelector: #hashMappedBy:!SmallInteger removeSelector: #identityHashMappedBy:!"Kernel"!!MessageNode methodsFor: 'private' stamp: 'nice 10/10/2010 17:39' prior: 51646677!checkBlock: node as: nodeName from: encoder maxArgs: maxArgs	"vb: #canBeSpecialArgument for blocks hardcodes 0 arguments as the requirement for special blocks. We work around that here by further checking the number of arguments for blocks.."	node canBeSpecialArgument ifTrue: 		[^node isBlockNode].	^node isBlockNode		ifTrue:			[node numberOfArguments <= maxArgs				ifTrue: [true]				ifFalse: [encoder notify: '<- ', nodeName , ' of ' ,					(MacroSelectors at: special) , ' has too many arguments']]		ifFalse:			[false]! !"Compiler"!Point removeSelector: #hashMappedBy:!Rectangle removeSelector: #hashMappedBy:!"Graphics"!!SystemDictionary commentStamp: 'nice 3/6/2010 21:56' prior: 59439194!I represent a special dictionary used as global namespace for class names :	Smalltalk globals classNames.and for traits too:	Smalltalk globals traitNames.	and a few other globals:	(Smalltalk globals keys reject: [:k | (Smalltalk globals at: k) isBehavior])			collect: [:k | k -> (Smalltalk globals at: k) class].As the above example let you guess, the global namespace of Smalltalk system is accessed through:	Smalltalk globals.!!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:22' prior: 59144143!classNames	"Answer a sorted collection of all class names. Use the return value of #fillCaches to avoid concurrency issues."		^cachedClassNames ifNil: [ self fillCaches at: 1 ]! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:33'!fillCaches	"Fill cachedClassNames and cachedNonClassNames. Return an array with the calculated values."	| classNames nonClassNames |	classNames := OrderedCollection new: self size.	nonClassNames := OrderedCollection new.	self keysAndValuesDo: [ :key :value |		value isInMemory ifTrue: [			"The key == value name test below addresses two separate issues:				1) Obsolete classes, where key = #Foo and value name = 'AnObsoleteFoo'				2) Aliases, i.e., Smalltalk at: #OtherName put: aClass"			((value isKindOf: Class) and: [ key == value name ])				ifTrue: [ classNames add: key ]				ifFalse: [ nonClassNames add: key ] ] ].	classNames sort.	cachedNonClassNames := nonClassNames sort.	cachedClassNames := classNames.	^{ classNames. nonClassNames }! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:23' prior: 34091053!flushClassNameCache	"Smalltalk flushClassNameCache"	"Force recomputation of the cached list of class names and non-class names."	cachedClassNames := cachedNonClassNames := nil! !!SystemDictionary methodsFor: 'as yet unclassified' stamp: 'ul 10/8/2010 21:34'!hasBindingThatBeginsWith: aString	"Use the cached class and non-class names for better performance."	| name searchBlock |	searchBlock := [ :element |		(element beginsWith: aString)			ifTrue: [ 0 ]			ifFalse: [				aString < element					ifTrue: [ -1 ]					ifFalse: [ 1 ] ] ].	name := self classNames 		findBinary: searchBlock		ifNone: nil.	name ifNotNil: [ ^true ].	name := self nonClassNames 		findBinary: searchBlock		ifNone: nil.	^name notNil! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 10/8/2010 21:22'!nonClassNames	"Answer a sorted collection of all non-class names. Use the return value of #fillCaches to avoid concurrency issues."		^cachedNonClassNames ifNil: [ self fillCaches at: 2 ]! !!SystemNavigation methodsFor: 'ui' stamp: 'topa 9/27/2010 11:06' prior: 52734666!showMenuOf: selectorCollection withFirstItem: firstItem ifChosenDo: choiceBlock withCaption: aCaption	"Show a sorted menu of the given selectors, preceded by firstItem, and all abbreviated to 40 characters.  Use aCaption as the menu title, if it is not nil.  Evaluate choiceBlock if a message is chosen."	| index menuLabels sortedList |	sortedList := selectorCollection asSortedCollection.	menuLabels := Array streamContents: 		[:strm | strm nextPut: (firstItem contractTo: 40).		sortedList do: [:sel | strm nextPut: (sel contractTo: 40)]].	index := UIManager default chooseFrom: menuLabels lines: #(1).	index = 1 ifTrue: [choiceBlock value: firstItem].	index > 1 ifTrue: [choiceBlock value: (sortedList at: index - 1)]! !!EventManager methodsFor: 'copying' stamp: 'nice 10/2/2010 00:09'!postCopy	super postCopy.	self release! !!ChangeRecord methodsFor: 'access' stamp: 'eem 9/19/2010 20:00' prior: 33968961!methodClassName	| tokens |	(class isNil	and: [type = #doIt	and: [(tokens := Scanner new scanTokens: self text) size >= 3	and: [(tokens includes: #'.') not "exclude multi-statement doits"	and: [tokens first isSymbol	and: [tokens first isKeyword not	and: [tokens first first canBeGlobalVarInitial	and: [(tokens includes: #instanceVariableNames:)		or: [tokens second == #comment:		or: [tokens third == #comment:]]]]]]]]]) ifTrue:		["Could be a class definition.			Class definitions start with Superclass blahSubclass: #ClassName			Metaclass definitions start with ClassName class instanceVariableNames:"		 (tokens second isSymbol		  and: [tokens second isKeyword		  and: [tokens third isSymbol		  and: [tokens third isKeyword not		  and: [(2 to: tokens size by: 2) allSatisfy: [:i| (tokens at: i) isKeyword]]]]]) ifTrue:			[^tokens third].		 (tokens size = 4		  and: [tokens second = #class		  and: [(tokens third = #instanceVariableNames: or: [tokens third = #comment:])		  and: [tokens last isString]]]) ifTrue:			[^tokens first].		 (tokens size = 3		  and: [tokens second = #comment:		  and: [tokens last isString]]) ifTrue:			[^tokens first]].	^class! !EventManager removeSelector: #copy!"System"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 9/28/2010 17:20'!welcomeToSqueak42	^'Squeak 4.2		Welcome to Squeak - a free, open Smalltalk system.Needs to be updated:Squeak 4.1 combines the license change occuring in the 4.0 release with the development work that has been going on while the relicensing process took place. Here are the highlights of the changes that resulted in Squeak 4.1:User InterfaceWe have adapted the ''face lift'' look originally developed for Newspeak. For those of us who like colored windows (quite a few as it turns out) you can switch between uniform and colored windows in the ''Extras'' menu under ''Window Colors''.The new menu bar makes Squeak much easier to discover than before. The process of transitioning from the world menu is not complete yet, there are still items that can only be accessed from the world menu (i.e., by clicking on the desktop). The search field integrated in the menu bar allows for direct navigation to classes and methods - simply type in a partial class or method name and see what happens.A new set of inexpensive sub-pixel antialiased fonts derived from the DejaVu fonts (''Bitmap DejaVu'' in the font chooser) has been added. True type font support has been upgraded to operate directly on files on disk without the need to load the entire file into memory.A new set of text editors has been added, which allowed us to decouple the Morphic and MVC implementations for improved modularity. Morphic now has regular blinking insertion point cursors instead of the (virtually invisible) static cursor previously.CompilerSqueak 4.1 includes the closure implementation from Cog as a prerequisite for full Cog adoption later. With this implementation Squeak finally has ''full'' closures, allowing classic recursive examples like the following to work:	fac := [:n| n > 1 ifTrue:[n * (fac value: n-1)] ifFalse:[1]].	fac value: 5.Support for literal ByteArray syntax has been added. Byte arrays can now be written as #[1 2 3] instead of #(1 2 3) asByteArray  avoiding the need for conversion.Selectors including minus are now parsed correctly, for example 3 <- 4 is now parsed as (3) <- (4) instead of (3) < (-4). White space is no longer allowed after an unary minus to denote a negative number literal.DevelopmentSyntax highlighting, based on Shout, is now included in all Squeak tools by default. For workspaces, it can be explicitly disabled in the window menu (press the blue button; entry ''syntax highlighting'').Sources and changes files are no longer limited to 32MB max size. ExpandedSourceFileArray provides an implementation for source files of arbitrary length, based on the CompiledMethodTrailer changes.MessageTrace has been added, allowing senders and implementors to be viewed without opening new windows all the time.  It utilizes a new AlternatePluggableListMorphOfMany, which allows quick and easy customization of the list. A quick adoption of DependencyBrowser has been added allowing to browse dependencies between packages.Core LibrariesSets can now store nil just as any other collection. The collection hierachy has been refactored to have both Set and Dictionary a subclass of HashedCollection instead of having Dictionary a subclass of Set. Squeak now uses a better distributed scaledIdentityHash for identity sets and dictionaries.StandardFilestream now performs read-buffering, dramatically speading up some operations like "Object compileAll" (2x improvement) as well as various other operations (scanning change lists etc).A new traits implementation has been added. The implementation is significantly smaller and simpler than the old version and can be unloaded and reloaded without loss of information (i.e., traits flattened during unload are restored during traits reloading).A new extensible number parser hierharchy has been introduced NumberParser and its subclasses provide support for parsing and building numbers from strings and streams.A new general cleanup protocol has been added. The cleanUp protocol takes an optional argument to indicate whether we''re doing an aggressive cleanup (which involves deleting projects, change sets, and possibly other destructive actions) or a more gentle cleanup that''s only supposed to clean out transient caches.SystemDictionary and SmalltalkImage have been refactored. Smalltalk is now an instance of SmalltalkImage, representing a facade for system-wide queries and actions. SmalltalkImage contains a global environment, an instance of SystemDictionary, which the environment used by classes. Thus, SmalltalkImage current == Smalltalk, Object environment == Smalltalk globals.ModularityThe following packages have been made reloadable: ReleaseBuilder, ScriptLoader, 311Deprecated, 39Deprecated, Universes, SMLoader, SMBase, Installer-Core, VersionNumberTests, VersionNumber, Services-Base, PreferenceBrowser, Nebraska, CollectionsTests, GraphicsTests, KernelTests, MorphicTests, MultilingualTests, NetworkTests, ToolsTests, TraitsTests, XML-Parser, Traits, SystemChangeNotification-Tests, FlexibleVocabularies, EToys, Protocols, Tests, SUnitGUI. To unload all of these, execute:	Smalltalk unloadAllKnownPackages.!!]style[(11 54 21 228 14 920 251 2 8 309 376 2 11 206 529 2 14 302 197 1113 10 1 50 479)a2cblue;bFBitmap DejaVu Sans#14,c005005005bFBitmap DejaVu Sans#14,FBitmap DejaVu Sans#14bcred;,FBitmap DejaVu Sans#14,FBitmap DejaVu Sans#14bu,FBitmap DejaVu Sans#14,,FBitmap DejaVu Sans#14,FBitmap DejaVu Sans#14bu,FBitmap DejaVu Sans#14,,FBitmap DejaVu Sans#14,FBitmap DejaVu Sans#14bu,FBitmap DejaVu Sans#14,,FBitmap DejaVu Sans#14,FBitmap DejaVu Sans#14bu,FBitmap DejaVu Sans#14,f1,,bu,,FBitmap DejaVu Sans#14,!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 9/28/2010 17:16' prior: 59548832!welcomeWorkspacesOn: menu	menu addItem:[:item|		item			contents: 'Welcome to Squeak 4.2' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#welcomeToSqueak42. 				'Welcome to Squeak 4.2'. 				(140@140 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'The Squeak User Interface' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#squeakUserInterface. 				'The Squeak User Interface'. 				(160@160 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'Working With Squeak' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#workingWithSqueak. 				'Working With Squeak'. 				(180@180 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'Terse Guide to Squeak' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#terseGuideToSqueak. 				'Terse Guide to Squeak'. 				(180@180 extent: 600@400)			}].	menu addItem:[:item|		item			contents: 'License Information' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#licenseInformation. 				'License Information'. 				(200@200 extent: 500@300)			}].! !TheWorldMainDockingBar removeSelector: #welcomeToSqueak41!"Morphic"!!StrikeFontSet methodsFor: 'displaying' stamp: 'nice 10/2/2010 00:32' prior: 57455894!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta from: fromFont baselineY: baselineY	| destPoint leftX rightX glyphInfo g tag char destY rIndex |	destPoint := aPoint.	rIndex := startIndex.	tag := (aString at: rIndex) leadingChar.	glyphInfo := Array new: 5.	[rIndex <= stopIndex] whileTrue: [		char := aString at: rIndex.		((fromFont hasGlyphOf: char) or: [char leadingChar ~= tag]) ifTrue: [^destPoint].		self glyphInfoOf: char into: glyphInfo.		g := glyphInfo first.		leftX := glyphInfo second.		rightX := glyphInfo third.		(glyphInfo fifth ~= aBitBlt lastFont) ifTrue: [			glyphInfo fifth installOn: aBitBlt.		].		destY := baselineY - glyphInfo fourth. 		aBitBlt			sourceForm: g;			destX: destPoint x;			destY: destY;			sourceOrigin: leftX @ 0;			width: rightX - leftX;			height: self height;			copyBits.		destPoint := destPoint x + (rightX - leftX + kernDelta) @ destPoint y.		rIndex := rIndex + 1.	].	^destPoint.! !!StrikeFontSet methodsFor: 'copying' stamp: 'nice 10/2/2010 00:31'!postCopy	super postCopy.	self reset.	fontArray := fontArray copy! !!MultiByteFileStream class methodsFor: 'accessing' stamp: 'cmm 10/10/2010 19:17'!lineEndDefault	"Answer the default line-ending convention that will be used by default, which was determined at start-up by looking at platform atributes."	^ LineEndDefault! !StrikeFontSet removeSelector: #copy!"Multilingual"!!ElementCategory methodsFor: 'copying' stamp: 'nice 10/1/2010 23:40'!postCopy	"Copy own instance variables."	super postCopy.	self copyFrom: self! !ElementCategory removeSelector: #copy!"Protocols"!!LongTestCaseTest methodsFor: 'as yet unclassified' stamp: 'ul 10/11/2010 02:50'!setUp	preferenceValue := LongTestCase shouldRun! !!LongTestCaseTest methodsFor: 'as yet unclassified' stamp: 'ul 10/11/2010 02:50'!tearDown	LongTestCase shouldRun: preferenceValue! !"SUnit"!!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'ar 8/6/2009 20:24' prior: 54817662!inputPortNumFromUser	"Prompt the user for a MIDI input port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort inputPortNumFromUser"	| portCount dir portList |	portCount := self primPortCount.	portCount = 0 ifTrue: [^ nil].	portList := OrderedCollection new.	0 to: portCount - 1 do:[:i |		dir := self primPortDirectionalityOf: i.		(dir = 1) | (dir = 3) ifTrue:[portList add: i]].	^UIManager default		chooseFrom: (portList collect:[:i| self portDescription: i])		values: portList		title: 'MIDI port for input:' translated! !!PluckedSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:11'!postCopy	super postCopy.	self copyRing! !!ReverbSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:11'!postCopy	"Copy my component sound."	super postCopy.	self copySound! !!AbstractSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:10'!postCopy	"A sound should copy all of the state needed to play itself, allowing two copies of a sound to play at the same time. These semantics require a recursive copy but only down to the level of immutable data. For example, a SampledSound need not copy its sample buffer. Subclasses overriding this method should include a resend to super."	super postCopy.	self copyEnvelopes! !!SequentialSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:12'!postCopy	"Copy my component sounds."	super postCopy.	self copySounds! !!MixedSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:10'!postCopy	"Copy my component sounds."	super postCopy.	self copySounds! !!RepeatingSound methodsFor: 'copying' stamp: 'nice 1/12/2010 20:11'!postCopy	"Copy my component sound."	super postCopy.	self copySound! !!ScorePlayer methodsFor: 'copying' stamp: 'nice 1/12/2010 20:14'!postCopy	"Copy my component sounds."	super postCopy.	self copySounds! !ScorePlayer removeSelector: #copy!RepeatingSound removeSelector: #copy!MixedSound removeSelector: #copy!SequentialSound removeSelector: #copy!AbstractSound removeSelector: #copy!ReverbSound removeSelector: #copy!PluckedSound removeSelector: #copy!"Sound"!!MCMethodDefinitionTest methodsFor: 'mocks' stamp: 'eem 10/9/2010 17:15' prior: 57169526!override ^ 1! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:56' prior: 57036177!assert: aBoolean description: aString resumable: resumableBoolean 	aBoolean ifFalse: 		[failures isNil ifTrue:			[failures := OrderedCollection new].		 failures addLast: (thisContext sender home tempAt: 1) methodReference]! !!DecompilerTestFailuresCollector methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:56'!checkDecompileMethod: oldMethod		[^super checkDecompileMethod: oldMethod]		on: SyntaxErrorNotification		do: [:ex|			self assert: false 				description: 'syntax error'				resumable: true].! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:51'!computeFailures	(DecompilerTests organization listAtCategoryNamed: #tests) do:		[:s|		(s beginsWith: 'testDecompilerInClasses') ifTrue:			[self perform: s]].	^failures! !!DecompilerTestFailuresCollector methodsFor: 'accessing' stamp: 'eem 8/31/2010 14:49'!isFailure: cls sel: selector	^false! !!TestObjectsAsMethods methodsFor: 'running' stamp: 'al 2/9/2009 20:19'!setUp	SystemChangeNotifier uniqueInstance doSilently: [		self class addSelector: #add:with: withMethod: ObjectsAsMethodsExample new.		self class addSelector: #answer42 withMethod: ObjectsAsMethodsExample new.		self class addSelector: #foo withMethod: AbstractObjectsAsMethod new ]! !!TestObjectsAsMethods methodsFor: 'running' stamp: 'al 2/9/2009 20:19'!tearDown	SystemChangeNotifier uniqueInstance doSilently: [		self class removeSelector: #add:with:.		self class removeSelector: #answer42.		self class removeSelector: #foo ]! !!TestObjectsAsMethods methodsFor: 'testing' stamp: 'al 2/9/2009 19:55' prior: 34297927!testAddNumbers	self assert: (self add: 3 with: 4) = 7.	self assert: (self perform: #add:with: withArguments: #(3 4)) = 7.! !!TestObjectsAsMethods methodsFor: 'testing' stamp: 'al 2/9/2009 19:52' prior: 34298456!testAnswer42 	self assert: self answer42 = 42! !!TestObjectsAsMethods methodsFor: 'testing' stamp: 'al 2/9/2009 19:52' prior: 34298812!testDNU 	self should: [self foo] raise: MessageNotUnderstood! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 10/9/2010 17:19' prior: 57036707!checkDecompileMethod: oldMethod		| cls selector oldMethodNode methodNode newMethod oldCodeString newCodeString |	cls := oldMethod methodClass.	selector := oldMethod selector.	oldMethodNode := (cls decompilerClass new withTempNames: oldMethod methodNode schematicTempNamesString)						decompile: selector						in: cls						method: oldMethod.	[oldMethodNode properties includesKey: #warning] whileTrue:		[oldMethodNode properties removeKey: #warning].	oldCodeString := oldMethodNode decompileString.	methodNode := [cls compilerClass new						compile: oldCodeString						in: cls						notifying: nil						ifFail: []]						on: SyntaxErrorNotification						do: [:ex|							ex errorMessage = 'Cannot store into' ifTrue:								[ex return: #badStore].							ex pass].	"Ignore cannot store into block arg errors; they're not our issue."	methodNode ~~ #badStore ifTrue:		[newMethod := methodNode generate.		 newCodeString := ((cls decompilerClass new withTempNames: methodNode schematicTempNamesString)							decompile: selector							in: cls							method: newMethod) decompileString.		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldCodeString to: newCodeString))				openLabel: 'Decompilation Differences for ', cls name,'>>',selector"		 "(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: oldMethod abstractSymbolic to: newMethod abstractSymbolic))				openLabel: 'Bytecode Differences for ', cls name,'>>',selector"		 self assert: oldCodeString = newCodeString			description: cls name asString, ' ', selector asString			resumable: true]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 15:10'!classNames	| base41packageCategories classNames |	"(SystemOrganization categories collect: [:ea| (ea copyUpTo: $-) asString]) asSet asSortedCollection asArray"	base41packageCategories :=		#(	'311Deprecated'			'Balloon'			'Collections' 'CollectionsTests' 'Compiler' 'Compression'			'Etoys' 'Exceptions'			'Files'			'Graphics' 'GraphicsTests'			'Help' 'HelpSystem'			'Installer'			'Kernel' 'KernelTests'			'Monticello' 'MonticelloConfigurations' 'Morphic' 'MorphicExtras' 'MorphicTests' 'Multilingual' 'MultilingualTests'			'Nebraska' 'Network' 'NetworkTests'			'PackageInfo' 'PreferenceBrowser' 'Protocols'			'ReleaseBuilder'			'SMBase' 'SMLoader' 'ST80' 'SUnit' 'SUnitGUI' 'ScriptLoader' 'Services' 'ShoutCore' 'Simulation' 'Sound' 'System' 'SystemChangeNotification'			'Tests' 'ToolBuilder' 'Tools' 'ToolsTests' 'Traits' 'TraitsTests' 'TrueType'			'Universes'			'VersionNumber' 'VersionNumberTests'			'XML') asSet.	classNames := Set new.	SystemOrganization categories do:		[:cat|		(base41packageCategories includes: (cat copyUpTo: $-) asString) ifTrue:			[classNames addAll: (SystemOrganization listAtCategoryNamed: cat)]].	^classNames asSortedCollection! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 15:11' prior: 59054035!decompileClassesSelect: aBlock	(self classNames select: aBlock) do:		[:cn | | cls |		cls := Smalltalk globals at: cn.		cls selectorsAndMethodsDo:			[:selector :meth |			(self isFailure: cls sel: selector) ifFalse:				[self checkDecompileMethod: meth]]]! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 8/31/2010 14:26'!decompileStringForParseTree: aMethodNode	"Renumber the temps in the tree in parse tree order to eliminate that as a source of extraneous difference."	| visited count counter |	visited := IdentitySet new.	count := 0.	counter := [:temp|				(visited includes: temp) ifFalse:					[temp name: 't', (count := count + 1) printString.					 visited add: temp]].	aMethodNode nodesDo:		[:node|		(node == aMethodNode or: [node isBlockNode and: [node optimized not]]) ifTrue:			[node arguments do: counter].		node isTemp ifTrue:			[counter value: node]].		aMethodNode nodesDo:		[:node|		(node == aMethodNode or: [node isBlockNode and: [node optimized not]]) ifTrue:			[node temporaries do: counter.			 node temporaries: (node temporaries asSortedCollection: ParseNode tempSortBlock) asArray]].	^aMethodNode decompileString! !!DecompilerTests methodsFor: 'utilities' stamp: 'eem 10/9/2010 17:40' prior: 34125044!decompilerFailures	"Here is the list of failures: either a syntax error, a hard error or some failure to decompile correctly.	 Collected via		DecompilerTestFailuresCollector new computeFailures collect:			[:mr| { mr classSymbol. mr selector }]) asArray"	^#(	(BrowserCommentTextMorph showPane)		(ClassDescription replaceSilently:to:)		(CodeHolder getSelectorAndSendQuery:to:with:)		(Date printOn:)		(FileDirectory checkForReadability)		(Float printPaddedWith:to:)		(GIFReadWriter nextImageWithPlugin)		(HttpUrl checkAuthorization:retry:)		(MCConfigurationBrowser post)		(MailComposition breakLinesInMessage:)		(MVCToolBuilder setLayout:in:) "same-name block-local temps in optimized blocks"		(ParagraphEditor inOutdent:delta:)		(PNGReadWriter copyPixelsGray:)		(PointTest testNormal) "fraction printing??"		(PointTest testTheta) "fraction printing??"		(ScaledDecimalTest testConvertFromFraction) "local/non-local temps"		(StandardScriptingSystem holderWithAlphabet) "same-name block-local temps in optimized blocks"		(SystemWindow convertAlignment)		(TextEditor inOutdent:delta:)		(TextURL actOnClickFor:)		(TTContourConstruction segmentsDo:) "Worth fixing; these two are mistaken conversion from a whileTrue: to a to:do: but the index is used outside the whileTrue:"		(TTFontReader processHorizontalMetricsTable:length:))! !TestObjectsAsMethods removeSelector: #expectedFailures!DecompilerTests removeSelector: #blockingClasses!"Tests"!!FileStream methodsFor: '*Tools-Changes' stamp: 'di 5/20/1998 23:20'!edit	"Create and schedule an editor on this file."	FileList openEditorOn: self editString: nil.! !"Tools"!!SHTextStyler methodsFor: 'styling' stamp: 'lr 4/8/2010 15:56' prior: 54460750!evaluateWithoutStyling: aBlock	| t |	t := stylingEnabled.	stylingEnabled := false.	^ aBlock ensure: [stylingEnabled := t]! !!Workspace methodsFor: '*ShoutCore' stamp: 'kb 2/22/2010 22:18' prior: 58105925!hasBindingThatBeginsWith: aString 		bindings ifNil: [ ^false ].	bindings keysDo: [ :each |		(each beginsWith: aString) ifTrue: [ ^true ] ].	^false! !!SmalltalkImage methodsFor: '*ShoutCore' stamp: 'ul 9/19/2010 22:19' prior: 34537405!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a key that begins with aString, false otherwise"		^globals hasBindingThatBeginsWith: aString! !!SharedPool class methodsFor: '*ShoutCore' stamp: 'tween 9/13/2004 10:10' prior: 29049304!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a binding that begins with aString, false otherwise"	"First look in classVar dictionary."	(self classPool hasBindingThatBeginsWith: aString) ifTrue:[^true].	"Next look in shared pools."	self sharedPools do:[:pool | 		(pool hasBindingThatBeginsWith: aString) ifTrue: [^true]].	^false! !!Dictionary methodsFor: '*ShoutCore' stamp: 'tween 9/13/2004 10:11' prior: 19706396!hasBindingThatBeginsWith: aString	"Answer true if the receiver has a key that begins with aString, false otherwise"		self keysDo:[:each | 		(each beginsWith: aString)			ifTrue:[^true]].	^false! !!SHParserST80 methodsFor: 'token testing' stamp: 'nice 10/10/2010 21:05' prior: 52361235!isBinary	(currentToken isNil or: [self isName or: [self isKeyword]]) 		ifTrue: [^false].	1 to: currentToken size do: [:i | | c |		c := currentToken at: i.		(self isSelectorCharacter: c) 			ifFalse: [^false]].	^true! !!SHParserST80 methodsFor: 'character testing' stamp: 'nice 10/10/2010 21:05' prior: 52382924!isSelectorCharacter: aCharacter	aCharacter isAlphaNumeric ifTrue: [^false].	aCharacter isSeparator ifTrue:[^false].	('"#$'':().;[]{}^_'  includes: aCharacter) 		ifTrue:[^false].	aCharacter asciiValue = 30 ifTrue: [^false "the doIt char"].	aCharacter asciiValue = 0 ifTrue: [^false].	"Any other char is ok as a binary selector char."	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:47' prior: 33750765!parsePrimitive	self scanNext.	currentTokenFirst isDigit		ifTrue: [ self scanPast: #integer ]		ifFalse: [			self parseStringOrSymbol.			currentToken = 'module:' ifTrue: [				self scanPast: #module.				self parseStringOrSymbol ] ].	currentToken = 'error:' ifTrue: [		self scanPast: #primitive. "there's no rangeType for error"		self isName			ifTrue: [ self scanPast: #patternTempVar ]			ifFalse: [ self parseStringOrSymbol ] ].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 10/12/2010 02:43'!parseStringOrSymbol	currentTokenFirst == $' ifTrue: [ ^self parseString ].	currentTokenFirst == $# ifTrue: [ ^self parseSymbol ].	self error! !!SHParserST80 methodsFor: 'scan' stamp: 'nice 10/10/2010 21:15' prior: 52368160!scanBinary	| c d |	c := self currentChar.	currentTokenSourcePosition := sourcePosition.	currentToken := c asString.	d := self nextChar.	((self isSelectorCharacter: c) or: [c == $:]) ifFalse: [^currentToken].	(c == $: and: [d == $=]) 		ifTrue: [" := assignment"			currentToken := currentToken , d asString.			self nextChar.			^currentToken].	c == $| ifTrue:["| cannot precede a longer token" ^currentToken].	[self isSelectorCharacter: d] 		whileTrue: [			currentToken := currentToken , d asString.			d := self nextChar].	^currentToken! !!SystemDictionary methodsFor: '*ShoutCore' stamp: 'ul 10/8/2010 21:34' prior: 34626250!hasBindingThatBeginsWith: aString	"Use the cached class and non-class names for better performance."	| name searchBlock |	searchBlock := [ :element |		(element beginsWith: aString)			ifTrue: [ 0 ]			ifFalse: [				aString < element					ifTrue: [ -1 ]					ifFalse: [ 1 ] ] ].	name := self classNames 		findBinary: searchBlock		ifNone: nil.	name ifNotNil: [ ^true ].	name := self nonClassNames 		findBinary: searchBlock		ifNone: nil.	^name notNil! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'ul 10/3/2010 01:16' prior: 56431860!styleTable	^styleTable ifNil: [ styleTable := self chooseDefaultStyleTable ]! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'lr 12/18/2009 11:30' prior: 56439258!textAttributesByPixelHeight	^ textAttributesByPixelHeight ifNil: [ textAttributesByPixelHeight := Dictionary new ]! !"ShoutCore"!!HelpOnHelp class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:27' prior: 33773129!pages	^#(introduction HelpHowToHelpTopics HelpAPIDocumentation)! !!CustomHelpHelpBuilder methodsFor: 'private' stamp: 'tbn 9/30/2010 23:31' prior: 33781597!createTopicFrom: aDescription	"Create a topic from a description stored on a class.	aDescription can specify (via #pages) the name of a class and not	only a selector. This allows for hierarchies with 'subtrees in the middle'"		|topic page   pageClasses |	topic := HelpTopic named: aDescription bookName.	topic key: aDescription key.	topic icon: aDescription icon.	pageClasses := Set new.	aDescription pages do: [:pageSelectorOrClass|		page:= (Smalltalk hasClassNamed: pageSelectorOrClass asString)					ifFalse: [aDescription perform: pageSelectorOrClass]					ifTrue: [pageClasses add: (Smalltalk classNamed: pageSelectorOrClass asString).							 (Smalltalk classNamed: pageSelectorOrClass asString) asHelpTopic].		topic addSubtopic: page.	].		((aDescription subclasses asSet)		removeAllFoundIn: pageClasses;		yourself) do: [:subclass | topic subtopics add: subclass asHelpTopic ].	^topic! !!HelpHowToHelpTopicsFromCode class methodsFor: 'accessing' stamp: 'tbn 9/30/2010 23:46' prior: 33769174!pages	^#(overview step1 step2 step3 step4 step5 step6 step7)! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 9/30/2010 23:48'!step6	^HelpTopic		title: 'Step 6 - Add more structure'		contents:	'STEP 6 - ADD MORE STRUCTUREIf you add a new subclass to your custom help class and repeating step 2 to 4 you canprofide new substructures (subbooks) since the help books are mapped to the class hierarchy. Example: MyAppHelp subclass: #MyAppTutorial    	instanceVariableNames: ''''	  classVariableNames: ''''	  poolDictionaries: ''''	  category: ''MyApp-Help'' then implement a #bookName, the pages and a #pages method as before on this new class and reopen the help browser. 		'! !!HelpHowToHelpTopicsFromCode class methodsFor: 'pages' stamp: 'tbn 9/30/2010 23:54'!step7	^HelpTopic		title: 'Step 7 - Tips and Tricks'		contents:	'STEP 7 - TIPS AND TRICKSTip1:          If you implement the #pages method you can also           use the name of a custom help class that should be           integrated between the specific pages:               #pages                   ^(firstPage MyAppTutorial secondPage)Tip2:          You can easily edit the help contents of a page by           using the #edit: message. For our example just evaluate:			MyAppHelp edit: #firstPage				     This will open a workspace with the help contents and 	     when you accept it it will be saved back to the help 	     method defining the topic.		  		'! !"HelpSystem-Core"!!SqueakHelp class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:53'!pages	^#(SqueakProjectHelp SqueakToolsHelp SqueakTutorials)! !!SqueakProjectHelp class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:59' prior: 33803508!bookName 	^'The Project'! !!SqueakTutorials class methodsFor: 'pages' stamp: 'tbn 10/1/2010 00:56'!introduction	"This method was automatically generated. Edit it using:"	"SqueakTutorials edit: #introduction"	^HelpTopic		title: 'Introduction'		contents: 'Here you will some short tutorials on how to use Squeak for daily tasks. Feel free to add your own.!!' readStream nextChunkText! !!SqueakTutorials class methodsFor: 'accessing' stamp: 'tbn 10/1/2010 00:55'!pages	^#(introduction)! !"Help-Squeak-Project"!!FTPClient methodsFor: 'private protocol' stamp: 'eem 10/22/2010 09:34' prior: 54284253!lookForCode: code ifDifferent: handleBlock 	"We are expecting a certain numeric code next.  	However, in the FTP protocol, multiple lines are allowed.  	If the response is multi-line, the fourth character of the first line is a  	$- and the last line repeats the numeric code but the code is followed by 	a space. So it's possible that there are more lines left of the last response that 	we need to throw away. We use peekForAll: so that we don't discard the	next response that is not a continuation line."		"check for multi-line response"	(self lastResponse size > 3			and: [(self lastResponse at: 4) = $-])		ifTrue: "Discard continuation lines."			[ | headToDiscard |			headToDiscard := self lastResponse first: 4.			[[self stream peekForAll: headToDiscard]				whileTrue: [self stream nextLine]]				on: Exception				do: [:ex | ^handleBlock value: nil]].	^ super lookForCode: code ifDifferent: handleBlock! !"Network"!!SparseLargeArray commentStamp: '<historical>' prior: 0!A version of SparseLargeTable that does not populate its bins until a value other than the default is stored.!!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 10/17/2010 03:32' prior: 33557771!compactAllInstances	"Do not use #allInstancesDo: because #compact may create new instances."	self allInstances do: [ :each | each compact ]! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 10/17/2010 03:33' prior: 58681158!rehashAllInstances	"Do not use #allInstancesDo: because #rehash may create new instances."	self allInstances do: [ :each | each rehash ]! !!HashedCollection methodsFor: 'objects from disk' stamp: 'ul 10/17/2010 03:51' prior: 53647479!comeFullyUpOnReload: smartRefStream	"Symbols have new hashes in this image."	self compact! !!Character class methodsFor: 'instance creation' stamp: 'ar 10/25/2010 19:00' prior: 18445366!allByteCharacters	"Answer all the characters that can be encoded in a byte"	^ (0 to: 255) collect: [:v | Character value: v] as: String! !!Character class methodsFor: 'instance creation' stamp: 'ar 10/25/2010 18:54' prior: 18446824!separators	"Answer a collection of the standard ASCII separator characters."	^ #(32 "space"		13 "cr"		9 "tab"		10 "line feed"		12 "form feed")		collect: [:v | Character value: v] as: String! !!ByteArray class methodsFor: 'byte based hash' stamp: 'dtl 10/24/2010 12:40' prior: 17926672!hashBytes: aByteArray startingWith: speciesHash	"Answer the hash of a byte-indexed collection,	using speciesHash as the initial value.	See SmallInteger>>hashMultiply.	The primitive should be renamed at a	suitable point in the future"	| byteArraySize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	<var: #aHash declareC: 'int speciesHash'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	byteArraySize := aByteArray size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: byteArraySize do: [:pos |		hash := hash + (aByteArray basicAt: pos).		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !!SparseLargeArray methodsFor: 'private' stamp: 'eem 11/5/2008 10:36'!analyzeSpaceSaving	| elems tablesTotal nonNilTables lastPage lastChunkSize |	elems := 0.	tablesTotal := self basicSize.	nonNilTables := 0.	lastPage := self basicAt: self basicSize.	(lastChunkSize := size \\ chunkSize) = 0 ifTrue:		[lastChunkSize := chunkSize].	1 to: self basicSize do:		[:i | | page |		(page := self basicAt: i) ifNotNil:			[nonNilTables := nonNilTables + 1.			 1 to: (page == lastPage ifTrue: [lastChunkSize] ifFalse: [chunkSize]) do:				[:j|				(page at: j) ~= defaultValue ifTrue:					[elems := elems + 1]]]].	^String streamContents:		[:strm |		strm nextPutAll: 'total: '; print: size.		strm nextPutAll: ' elements: '; print: elems.		strm nextPutAll: ' tables: '; print: tablesTotal.		strm nextPutAll: ' non-nil: '; print: nonNilTables]! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/1/2008 14:00'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	1 to: self basicSize do:		[:i|		self basicAt: i put: nil].	defaultValue := anObject! !!SparseLargeArray methodsFor: 'initialization' stamp: 'eem 11/1/2008 12:16'!initChunkSize: aChunkSize size: aSize arrayClass: aClass base: b defaultValue: d	chunkSize := aChunkSize.	size := aSize.	base := b.	defaultValue := d.	arrayClass := aClass! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/1/2008 12:53'!noCheckAt: index	^(self basicAt: index - base // chunkSize + 1)		ifNil: [defaultValue]		ifNotNil: [:chunk| chunk at: index - base \\ chunkSize + 1]! !!SparseLargeArray methodsFor: 'accessing' stamp: 'eem 11/2/2008 11:57'!noCheckAt: index put: value	| chunkIndex chunk lastChunkSize |	chunkIndex := index - base // chunkSize + 1.	(chunk := self basicAt: chunkIndex) ifNil:		[value = defaultValue ifTrue:			[^value].		chunk := arrayClass					new: ((chunkIndex == self basicSize						   and: [(lastChunkSize := size \\ chunkSize) > 0])							ifTrue: [lastChunkSize]							ifFalse: [chunkSize])					withAll: defaultValue.		self basicAt: chunkIndex put: chunk].	^chunk at: index - base \\ chunkSize + 1 put: value! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:44' prior: 17936877!compare: string1 with: string2 collated: order	"Return 1, 2 or 3, if string1 is <, =, or > string2, with the collating order of characters given by the order array."	| len1 len2 c1 c2 |	<primitive: 'primitiveCompareString' module: 'MiscPrimitivePlugin'>	<var: #string1 declareC: 'unsigned char *string1'>	<var: #string2 declareC: 'unsigned char *string2'>	<var: #order declareC: 'unsigned char *order'>	len1 := string1 size.	len2 := string2 size.	1 to: (len1 min: len2) do:		[:i |		c1 := order at: (string1 basicAt: i) + 1.		c2 := order at: (string2 basicAt: i) + 1.		c1 = c2 ifFalse: 			[c1 < c2 ifTrue: [^ 1] ifFalse: [^ 3]]].	len1 = len2 ifTrue: [^ 2].	len1 < len2 ifTrue: [^ 1] ifFalse: [^ 3].! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:42' prior: 17937681!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 'primitiveFindFirstInString' module: 'MiscPrimitivePlugin'>	<var: #aString declareC: 'unsigned char *aString'>	<var: #inclusionMap  declareC: 'char *inclusionMap'>	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i := start.	stringSize := aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i := i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:42' prior: 17938263!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 'primitiveIndexOfAsciiInString' module: 'MiscPrimitivePlugin'>	<var: #aCharacter declareC: 'int anInteger'>	<var: #aString declareC: 'unsigned char *aString'>	stringSize := aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!ByteString class methodsFor: 'primitives' stamp: 'dtl 10/24/2010 12:43' prior: 17939383!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 'primitiveTranslateStringWithTable' module: 'MiscPrimitivePlugin'>	<var: #table  declareC: 'unsigned char *table'>	<var: #aString  declareC: 'unsigned char *aString'>	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!ByteString methodsFor: 'comparing' stamp: 'dtl 10/24/2010 12:41' prior: 17933101!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 'primitiveFindSubstring' module: 'MiscPrimitivePlugin'>	<var: #key declareC: 'unsigned char *key'>	<var: #body declareC: 'unsigned char *body'>	<var: #matchTable declareC: 'unsigned char *matchTable'>	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index := 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index := index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!OrderedCollection methodsFor: 'removing' stamp: 'ul 10/17/2010 03:10' prior: 25254364!removeAllSuchThat: aBlock 	"Remove each element of the receiver for which aBlock evaluates to true.	The method in Collection is O(N^2), this is O(N)."	| n |	n := firstIndex.	firstIndex to: lastIndex do: [:index |	    (aBlock value: (array at: index)) ifFalse: [			array at: n put: (array at: index).			n := n + 1]].	array from: n to: lastIndex put: nil.	lastIndex := n - 1! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ul 10/15/2010 08:24' prior: 29056880!next	^monitor critical: [		monitor waitWhile: [ items isEmpty ].		items removeFirst ]! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ul 10/15/2010 08:23' prior: 58758268!nextPut: item	monitor critical: [		items addLast: item.		monitor signal.  ].	^item! !!SharedQueue2 methodsFor: 'accessing' stamp: 'ul 10/15/2010 08:23' prior: 53746061!removeAll	monitor critical: [		items removeAll ].! !!CharacterSet methodsFor: 'conversion' stamp: 'ar 10/25/2010 18:54'!asString	"Convert the receiver into a String"	^String new: self size streamContents:[:s|		self do:[:ch| s nextPut: ch].	].! !!WriteStream methodsFor: 'character writing' stamp: 'eem 10/21/2010 10:22'!ensureCr	"Append a cr character to the receiver IFF there is not one on the end."	self ensureEndsWith: Character cr! !!SharedQueue methodsFor: 'private' stamp: 'ul 10/18/2010 02:35' prior: 29055066!makeRoomAtEnd	| contentsSize |	contentsSize := writePosition - readPosition.	contentsSize * 2 > contentsArray size		ifTrue: [			"grow"			contentsArray := (contentsArray class new: contentsArray size * 2)				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition;				yourself ]		ifFalse: [			(contentsArray size > 10 and: [ contentsSize * 4 <= contentsArray size ])				ifTrue: [					"shrink"					contentsArray := (contentsArray class new: (contentsSize * 2 max: 10))						replaceFrom: 1						to: contentsSize						with: contentsArray						startingAt: readPosition;						yourself ]				ifFalse: [					"just move the elements to the front"					contentsArray						replaceFrom: 1						to: contentsSize						with: contentsArray						startingAt: readPosition.					contentsArray						from: contentsSize + 1						to: contentsArray size						put: nil ] ].	readPosition := 1.	writePosition := contentsSize + 1! !"Collections"!!CharacterTest methodsFor: 'tests - various' stamp: 'ar 10/25/2010 18:59'!testCharacterSeparators	"Regression test"	| result |	self shouldnt:[result := '/', Character separators] raise: Error.	self assert: result size = (Character separators size + 1).	self shouldnt:[result := '/', CharacterSet separators] raise: Error.	self assert: result size = (CharacterSet separators asArray size + 1).! !"CollectionsTests"!!Behavior methodsFor: 'testing' stamp: 'nice 10/26/2010 21:14' prior: 54679200!isWords	"Answer true if the receiver is made of 32-bit instance variables."	^self isBytes not! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 02:13' prior: 51743900!queueDict		^queueDict ifNil: [ queueDict := IdentityDictionary new ]! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 03:40' prior: 24035477!signalAllInQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection removeAllSuchThat: [ :each |			each signal.			true ] ]! !!Monitor methodsFor: 'private' stamp: 'ul 10/17/2010 03:41' prior: 24035935!signalQueue: anOrderedCollection	queuesMutex critical: [		anOrderedCollection isEmpty ifFalse: [			anOrderedCollection removeFirst signal ] ]! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 10/17/2010 03:34' prior: 33660785!compactAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: [ :each |		each compactWithoutBecome ].	instances elementsExchangeIdentityWith: newInstances! !!MethodDictionary class methodsFor: 'initialization' stamp: 'ul 10/17/2010 03:34' prior: 33661097!rehashAllInstances	| instances newInstances |	instances := self allInstances asArray.	newInstances := self allInstances collect: [ :each |		each rehashWithoutBecome ].	instances elementsExchangeIdentityWith: newInstances! !"Kernel"!!VariableNode class methodsFor: 'class initialization' stamp: 'ul 10/24/2010 06:33' prior: 55931192!initialize    "VariableNode initialize.  Decompiler initialize"	| encoder |	encoder := Encoder new.	StdVariables := Dictionary new: 16.	encoder		fillDict: StdVariables		with: VariableNode		mapping: #('self' 'thisContext' 'super' 'nil' 'false' 'true' )		to: (Array with: LdSelf with: LdThisContext with: LdSuper)				, (Array with: LdNil with: LdFalse with: LdTrue).	StdSelectors := Dictionary new: 64.	encoder		fillDict: StdSelectors		with: SelectorNode		mapping: ((1 to: Smalltalk specialSelectorSize) collect: 							[:i | Smalltalk specialSelectorAt: i])		to: (SendPlus to: SendPlus + 31).	StdLiterals := PluggableDictionary new equalBlock: [ :x :y | x literalEqual: y ].	encoder		fillDict: StdLiterals		with: LiteralNode		mapping: #(-1 0 1 2 )		to: (LdMinus1 to: LdMinus1 + 3).	encoder initScopeAndLiteralTables.	NodeNil := encoder encodeVariable: 'nil'.	NodeTrue := encoder encodeVariable: 'true'.	NodeFalse := encoder encodeVariable: 'false'.	NodeSelf := encoder encodeVariable: 'self'.	NodeThisContext := encoder encodeVariable: 'thisContext'.	NodeSuper := encoder encodeVariable: 'super'! !!Encoder methodsFor: 'encoding' stamp: 'ul 10/24/2010 06:34' prior: 51002451!sharableLitIndex: literal	"Special access prevents multiple entries for post-allocated super send special selectors"	1 to: literalStream position do:		[:index|		(literal literalEqual: (literalStream originalContents at: index)) ifTrue:			[^index - 1]].	^self litIndex: literal! !"Compiler"!!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:47' prior: 50388165!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 'primitiveCompressToByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	size := bm size.	i := self encodeInt: size in: ba at: 1.	k := 1.	[k <= size] whileTrue:		[word := bm at: k.		lowByte := word bitAnd: 16rFF.		eqBytes := ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j := k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j := j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i := self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i := i+1]				ifFalse: [i := self encodeInt: j-k+1*4+2 in: ba at: i.						i := self encodeBytesOf: word in: ba at: i].			k := j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i := self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i := i+1.				k := k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j := j+1].				j = size ifTrue: [j := j + 1].				"We have one or more unmatching words, ending at j-1"				i := self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i := self encodeBytesOf: (bm at: m) in: ba at: i].				k := j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n := rawBytes := myBytes := 0.Form allInstancesDo:	[:f | f unhibernate.	b := f bits.	n := n + 1.	rawBytes := rawBytes + (b size*4).	myBytes := myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:46' prior: 50392360!decompress: bm fromByteArray: ba at: index	"Decompress the body of a byteArray encoded by compressToByteArray (qv)...	The format is simply a sequence of run-coded pairs, {N D}*.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent				(could be used to skip from one raster line to the next)			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows (see decodeIntFrom:)...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"		"NOTE:  If fed with garbage, this routine could read past the end of ba, but it should fail before writing past the ned of bm."	| i code n anInt data end k pastEnd |	<primitive: 'primitiveDecompressFromByteArray' module: 'MiscPrimitivePlugin'>	<var: #bm declareC: 'int *bm'>	<var: #ba declareC: 'unsigned char *ba'>	i := index.  "byteArray read index"	end := ba size.	k := 1.  "bitmap write index"	pastEnd := bm size + 1.	[i <= end] whileTrue:		["Decode next run start N"		anInt := ba at: i.  i := i+1.		anInt <= 223 ifFalse:			[anInt <= 254				ifTrue: [anInt := (anInt-224)*256 + (ba at: i).  i := i+1]				ifFalse: [anInt := 0.						1 to: 4 do: [:j | anInt := (anInt bitShift: 8) + (ba at: i).  i := i+1]]].		n := anInt >> 2.		(k + n) > pastEnd ifTrue: [^ self primitiveFail].		code := anInt bitAnd: 3.		code = 0 ifTrue: ["skip"].		code = 1 ifTrue: ["n consecutive words of 4 bytes = the following byte"						data := ba at: i.  i := i+1.						data := data bitOr: (data bitShift: 8).						data := data bitOr: (data bitShift: 16).						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 2 ifTrue: ["n consecutive words = 4 following bytes"						data := 0.						1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].						1 to: n do: [:j | bm at: k put: data.  k := k+1]].		code = 3 ifTrue: ["n consecutive words from the data..."						1 to: n do:							[:m | data := 0.							1 to: 4 do: [:j | data := (data bitShift: 8) bitOr: (ba at: i).  i := i+1].							bm at: k put: data.  k := k+1]]]! !!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:47' prior: 17484959!encodeBytesOf: anInt in: ba at: i	"Copy the integer anInt into byteArray ba at index i, and return the next index"	<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	0 to: 3 do:		[:j | ba at: i+j put: (anInt >> (3-j*8) bitAnd: 16rFF)].	^ i+4! !!Bitmap methodsFor: 'filing' stamp: 'dtl 10/24/2010 12:46' prior: 17485575!encodeInt: anInt in: ba at: i	"Encode the integer anInt in byteArray ba at index i, and return the next index.	The encoding is as follows...		0-223	0-223		224-254	(0-30)*256 + next byte (0-7935)		255		next 4 bytes"			<inline: true>	<var: #ba declareC: 'unsigned char *ba'>	anInt <= 223 ifTrue: [ba at: i put: anInt. ^ i+1].	anInt <= 7935 ifTrue: [ba at: i put: anInt//256+224. ba at: i+1 put: anInt\\256.  ^ i+2].	ba at: i put: 255.	^ self encodeBytesOf: anInt in: ba at: i+1! !"Graphics"!!InstallerMonticello methodsFor: 'basic interface' stamp: 'ul 10/17/2010 03:33' prior: 57637875!basicBrowse	 "Installer ss project: 'Installer'; browse: 'Installer-Core'."	| it |	it := self mcThing.		(it class includesSelector: #browse) ifTrue: [ ^ it browse ].		(it instVarNamed: 'versions') do: [ :each | each browse ].! !!InstallerMonticello methodsFor: 'basic interface' stamp: 'ul 10/17/2010 03:33' prior: 57638577!basicView	 "Installer ss project: 'Installer'; view: 'Installer-Core'. "	| it |		packages isEmptyOrNil ifTrue: [ self mc morphicOpen: nil ].		it := self mcThing. 	(it respondsTo: #open) ifTrue: [ ^ it open ].	"in case an old mc doesnt have #open"		(it instVarNamed: 'versions') do: [ :each | each open ].! !"Installer-Core"!!ObjectFinalizerCollection methodsFor: 'finalization' stamp: 'ul 10/17/2010 03:34' prior: 58228187!finalize	"Finalize all elements in this collection. The elements are expected to be ObjectFinalizers, but can be any object which understands #finalize."	self do: [ :each | each finalize ]! !!SystemNavigation methodsFor: 'query' stamp: 'ul 10/17/2010 03:22' prior: 57401901!allMethodsSelect: aBlock 	"Answer a SortedCollection of each method that, when used as the block  	argument to aBlock, gives a true result."	| aCollection |	aCollection := OrderedCollection new.	Cursor execute		showWhile: [self				allBehaviorsDo: [:class | class						selectorsAndMethodsDo: [:sel :m | (aBlock value: m)								ifTrue: [aCollection										add: (MethodReference new setStandardClass: class methodSymbol: sel)]]]].	^ aCollection sort! !!SystemNavigation methodsFor: 'query' stamp: 'eem 10/22/2010 09:40'!unusedBlocks	"Answer all methods that contain a block that is not used (not	 sent a message, returned, passed as an argument, or assigned)."	"SystemNavigation new unusedBlocks"	"SystemNavigation new		browseMessageList: SystemNavigation new unusedBlocks		name: 'unused blocks'"	^self allSelect:		[:m| | is |		is := InstructionStream on: m.		is scanFor: [:b| b = 143 and: [(m at: is thirdByte * 256 + is fourthByte + is pc + 4) = 135]]]! !!MethodReference methodsFor: 'comparing' stamp: 'RAA 5/28/2001 11:56' prior: 23964865!<= anotherMethodReference	classSymbol < anotherMethodReference classSymbol ifTrue: [^true].	classSymbol > anotherMethodReference classSymbol ifTrue: [^false].	classIsMeta = anotherMethodReference classIsMeta ifFalse: [^classIsMeta not].	^methodSymbol <= anotherMethodReference methodSymbol! !!MethodReference methodsFor: 'comparing' stamp: 'nice 1/1/2010 21:57' prior: 56598213!= anotherMethodReference 	"Answer whether the receiver and the argument represent the 	same object."	^ self species == anotherMethodReference species		and: [self classSymbol = anotherMethodReference classSymbol		and: [self classIsMeta = anotherMethodReference classIsMeta		and: [self methodSymbol = anotherMethodReference methodSymbol]]]! !!MethodReference methodsFor: 'accessing' stamp: 'kph 12/16/2006 10:11' prior: 23964472!asStringOrText	^stringVersion ifNil: [ self stringVersionDefault ]! !!MethodReference methodsFor: 'accessing' stamp: 'ar 12/12/2009 17:43' prior: 53905811!category	"Answers the class category (cached for reuse via MC and other tools)"	^ category ifNil: [category := self actualClass organization categoryOfElement: methodSymbol]! !!MethodReference methodsFor: 'initialize-release' stamp: 'mtf 10/4/2008 00:52' prior: 53751088!category: aSymbol	category := aSymbol! !!MethodReference methodsFor: 'testing' stamp: 'RAA 5/28/2001 08:11' prior: 23965837!classIsMeta	^classIsMeta! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/28/2001 08:10' prior: 23965937!classSymbol	^classSymbol! !!MethodReference methodsFor: 'comparing' stamp: 'dgd 3/8/2003 11:54' prior: 23964618!hash	"Answer a SmallInteger whose value is related to the receiver's  	identity."	^ (self species hash bitXor: self classSymbol hash)		bitXor: self methodSymbol hash! !!MethodReference methodsFor: 'testing' stamp: 'md 8/27/2005 17:17' prior: 53749921!isValid	"Answer whether the receiver represents a current selector or Comment"	| aClass |	methodSymbol isDoIt ifTrue: [^ false].	(aClass := self actualClass) ifNil: [^ false].	^ (aClass includesSelector: methodSymbol) or:		[methodSymbol == #Comment]! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/28/2001 08:10' prior: 23966365!methodSymbol	^methodSymbol! !!MethodReference methodsFor: 'printing' stamp: 'sw 11/5/2001 00:53' prior: 23966466!printOn: aStream	"Print the receiver on a stream"	super printOn: aStream.	aStream nextPutAll: ' ', self actualClass name, ' >> ', methodSymbol! !!MethodReference methodsFor: 'accessing' stamp: 'eem 5/25/2010 17:56' prior: 34259065!selector	^methodSymbol! !!MethodReference methodsFor: 'initialize-release' stamp: 'RAA 5/28/2001 08:06' prior: 53750266!setClass: aClass methodSymbol: methodSym stringVersion: aString 	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!MethodReference methodsFor: 'initialize-release' stamp: 'RAA 5/28/2001 07:34' prior: 23966834!setClassAndSelectorIn: csBlock	^csBlock value: self actualClass value: methodSymbol! !!MethodReference methodsFor: 'initialize-release' stamp: 'RAA 5/28/2001 06:04' prior: 53750551!setClassSymbol: classSym classIsMeta: isMeta methodSymbol: methodSym stringVersion: aString 	classSymbol := classSym.	classIsMeta := isMeta.	methodSymbol := methodSym.	stringVersion := aString.! !!MethodReference methodsFor: 'initialize-release' stamp: 'kph 12/16/2006 10:06' prior: 53750839!setStandardClass: aClass methodSymbol: methodSym	classSymbol := aClass theNonMetaClass name.	classIsMeta := aClass isMeta.	methodSymbol := methodSym.	stringVersion := nil.! !!MethodReference methodsFor: 'accessing' stamp: 'sr 6/4/2004 01:55' prior: 23966684!sourceString	^ (self actualClass sourceCodeAt: self methodSymbol) asString! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/29/2001 14:44' prior: 23967782!stringVersion	^stringVersion! !!MethodReference methodsFor: 'accessing' stamp: 'RAA 5/29/2001 14:44' prior: 53749784!stringVersion: aString	stringVersion := aString! !!MethodReference methodsFor: 'accessing' stamp: 'kph 12/16/2006 10:11' prior: 23965659!stringVersionDefault	^classSymbol, (classIsMeta ifTrue: [ ' class ' ] ifFalse: [' ']), methodSymbol  ! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 10/17/2010 03:33' prior: 33708488!rehashSets	"I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	inSeg := true.	[object := object nextObject.  		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			object isBlock ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				object class == MethodContext ifTrue: [inSeg ifTrue: [					receiverClasses add: object receiver class]].				]. 		object == 0] whileFalse.	hashedCollections do: [ :each | each compact ]. "our purpose"	^ receiverClasses	"our secondary job"! !!ImageSegment methodsFor: 'fileIn/Out' stamp: 'ul 10/17/2010 03:33' prior: 33709776!restoreEndianness	"Fix endianness (byte order) of any objects not already fixed.  Do this by discovering classes that need a startUp message sent to each instance, and sending it.	I have just been brought in and converted to live objects.  Find all Sets and Dictionaries in the newly created objects and rehash them.  Segment is near then end of memory, since is was newly brought in (and a new object created for it).	Also, collect all classes of receivers of blocks which refer to instance variables.  Return them.  Caller will check if they have been reshaped."	| object hashedCollections receiverClasses inSeg noStartUpNeeded startUps cls msg |	object := segment.	hashedCollections := OrderedCollection new.		"have to collect them, because Dictionary makes a copy, and that winds up at the end of memory and gets rehashed and makes another one."	receiverClasses := IdentitySet new.	noStartUpNeeded := IdentitySet new.	"classes that don't have a per-instance startUp message"	startUps := IdentityDictionary new.	"class -> MessageSend of a startUp message"	inSeg := true.	[object := object nextObject.  "all the way to the end of memory to catch remade objects"		object == endMarker ifTrue: [inSeg := false].	"off end"		object isInMemory ifTrue: [			(object isKindOf: HashedCollection) ifTrue: [hashedCollections add: object].			(object isKindOf: ContextPart) ifTrue: [				(inSeg and: [object hasInstVarRef]) ifTrue: [					receiverClasses add: object receiver class]].			inSeg ifTrue: [				(noStartUpNeeded includes: object class) ifFalse: [					cls := object class.					(msg := startUps at: cls ifAbsent: [nil]) ifNil: [						msg := cls startUpFrom: self.	"a Message, if we need to swap bytes this time"						msg ifNil: [noStartUpNeeded add: cls]							ifNotNil: [startUps at: cls put: msg]].					msg ifNotNil: [msg sentTo: object]]]]. 		object == 0] whileFalse.	hashedCollections do: [ :each | each compact ]. "our purpose"	^ receiverClasses	"our secondary job"! !"System"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'tfel 10/13/2010 15:43' prior: 34538652!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."Omnibrowser, including Refactoring engine"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfOmniBrowser''.(Smalltalk at: #ConfigurationOfOmniBrowser) project lastVersion load: #( Dev )."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WAPharoServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 44 11 2 1 8 1 21 2 8 1 28 13 3 1 1 28 7 1 11 1 5 4 3 5 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 28 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000124124,cblack;,c000124124,cblack;,c000000124,cblack;,c124000124,cblack;,c000124124,cblack;,c000124124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000124124,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000124,cblack;,c000000124,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000124124,cblack;,c000000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000124124,cblack;,c000124124,cblack;,c000000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000124124,cblack;,c000000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000124124,cblack;,c000000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c124000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;,c000000124,cblack;!!' readStream nextChunkText! !!SystemWindow methodsFor: 'open/close' stamp: 'eem 10/22/2010 12:08' prior: 58039729!openInWorld: aWorld extent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	^ self anyOpenWindowLikeMe		ifEmpty:			[ self 				position: (RealEstateAgent initialFrameFor: self initialExtent: extent world: aWorld) topLeft ;				extent: extent.			self openAsIsIn: aWorld ]		ifNotEmptyDo:			[ : windows | 			windows anyOne				expand ;				activate ; 				postAcceptBrowseFor: self ]! !"Morphic"!!SampledSound class methodsFor: 'utilities' stamp: 'dtl 10/24/2010 12:39' prior: 28143606!convert8bitSignedFrom: aByteArray to16Bit: aSoundBuffer	"Copy the contents of the given array of signed 8-bit samples into the given array of 16-bit signed samples."	| n s |	<primitive: 'primitiveConvert8BitSigned' module: 'MiscPrimitivePlugin'>	<var: #aByteArray declareC: 'unsigned char *aByteArray'>	<var: #aSoundBuffer declareC: 'unsigned short *aSoundBuffer'>	n := aByteArray size.	1 to: n do: [:i |		s := aByteArray at: i.		s > 127			ifTrue: [aSoundBuffer at: i put: ((s - 256) bitShift: 8)]			ifFalse: [aSoundBuffer at: i put: (s bitShift: 8)]].! !"Sound"!!BitmapBugz methodsFor: 'tests' stamp: 'ar 8/2/2003 19:21' prior: 17491435!testBitmapByteAt	| bm |	bm := Bitmap new: 1.	1 to: 4 do:[:i|		self should:[bm byteAt: i put: 1000] raise: Error.	].! !!BitmapBugz methodsFor: 'tests' stamp: 'ul 10/24/2010 06:02'!testWriteOn	| original binary copy |	original := Bitmap new: 1.	original byteAt: 1 put: 42.	binary := ByteArray streamContents: [ :stream |		original writeOn: stream ].	copy := Bitmap newFromStream: binary readStream.	self assert: original = copy! !"Tests"!LiteralDictionary removeSelector: #scanFor:!LiteralDictionary removeSelector: #literalEquality:and:!Smalltalk removeClassNamed: #LiteralDictionary!"Compiler"!!StandardToolSet class methodsFor: 'completion' stamp: 'damiencassou 7/29/2009 16:12'!codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt	^ aBlock value! !"Tools"!!ToolSet class methodsFor: 'completion' stamp: 'damiencassou 7/29/2009 16:24'!codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt	self default ifNil: [aBlock value. ^ self].	self default codeCompletionAround: aBlock textMorph: aTextMorph keyStroke: evt! !"System"!!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:40'!allowUnderscoreAsAssignment	"Accessor for the system-wide preference"	<preference: 'Allow underscore assignments'		category: 'Compiler'		description: 'When true, underscore can be used as assignment operator'		type: #Boolean>	^AllowUnderscoreAssignments ifNil:[true]! !!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:40'!allowUnderscoreAsAssignment: aBool	"Accessor for the system-wide preference"	AllowUnderscoreAssignments := aBool! !!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:40' prior: 58802893!prefAllowUnderscoreAssignments	"Accessor for the system-wide preference"		self deprecated: 'Use #allowUnderscoreAsAssignment'.	^self allowUnderscoreAsAssignment! !!Scanner class methodsFor: 'preferences' stamp: 'ul 10/28/2010 00:41' prior: 58803242!prefAllowUnderscoreAssignments: aBool	"Accessor for the system-wide preference"		self deprecated: 'Use #allowUnderscoreAsAssignment:'.	self allowUnderscoreAsAssignment: aBool! !!Scanner methodsFor: 'private' stamp: 'ul 10/28/2010 00:41' prior: 58803964!allowUnderscoreAssignments	"Query preference"	^self class allowUnderscoreAsAssignment! !"Compiler"!!TextEditor methodsFor: 'parenblinking' stamp: 'ul 10/27/2010 04:06' prior: 57273086!blinkPrevParen		self blinkPrevParen: sensor keyboardPeek! !!TextEditor methodsFor: 'parenblinking' stamp: 'ul 10/27/2010 04:05'!blinkPrevParen: aCharacter	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph text string.	here := pointBlock stringIndex.	openDelimiter := aCharacter.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 2]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]]! !!TextMorph methodsFor: 'event handling' stamp: 'ul 10/27/2010 04:04' prior: 59156031!keyStroke: evt	"Handle a keystroke event."		self resetBlinkCursor. "don't blink during type-in"	ToolSet 		codeCompletionAround: [			evt keyValue = 13 ifTrue: [ "CR - check for special action"				self crAction ifNotNil: [ :action |					"Note: Code below assumes that this was some					input field reacting on CR. Break the keyboard					focus so that the receiver can be safely deleted."					evt hand newKeyboardFocus: nil.					^action valueWithEnoughArguments: { evt } ] ].			self handleInteraction: [ editor readKeyboard ] fromEvent: evt.			"self updateFromParagraph."			super keyStroke: evt  "sends to keyStroke event handler, if any" ]		textMorph: self		keyStroke: evt! !"Morphic"!!Url class methodsFor: 'class initialization' stamp: 'ul 10/28/2010 04:22' prior: 34429704!initialize	SchemeRegistry := Dictionary new		at: 'browser' put: BrowserUrl;		at: 'file' put: FileUrl;		at: 'ftp' put: FtpUrl;		at: 'http' put: HttpUrl;		at: 'https' put: HttpUrl;		at: 'mailto' put: MailtoUrl;		at: nil put: HttpUrl;		yourself! !"Network"!!WeakRegistry commentStamp: 'ul 9/26/2010 02:51' prior: 34597773!I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.This kind of WeakRegistry is using a new VM feature, which allows a more robust finalization support. In contrast to the old implementation, it doesn't spend linear time checking which elements became garbage.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry methodsFor: 'finalization' stamp: 'ul 10/31/2010 22:05' prior: 34600258!finalizeValues	"Finalize any values, which happen to stocked in our list, due to some weak references become garbage"		| finalizer |	WeakFinalizationList hasNewFinalization ifFalse: [		self protected: [			valueDictionary finalizeValues.			finalizer := executors.			executors := nil ].		finalizer ifNotNil: [			finalizer do: [ :each | each finalizeValues ] ].		^ self ].	finalizer :=  self protected: [ list swapWithNil ].	"We don't need to protect a following loop from concurrent access,	because at the moment we're finalizing values, 	only we can access this list of finalizers, because valueDictionary already see them	as an unused slots, because they're associated with key == nil"		[ finalizer notNil ] whileTrue: [		| next |		next := finalizer next.		finalizer finalizeValues.		finalizer := next ].! !!WeakRegistry methodsFor: 'initialize-release' stamp: 'ul 10/31/2010 21:59' prior: 34601334!installFinalizer	valueDictionary finalizer: [ :executor |		WeakFinalizationList hasNewFinalization 			ifTrue: [ executor finalizeValues ]			ifFalse: [ 				(executors ifNil: [ executors := OrderedCollection new ]) add: executor ] ]! !!ByteString class methodsFor: 'primitives' stamp: 'ul 11/2/2010 03:07' prior: 17938731!stringHash: aString initialHash: speciesHash	| stringSize hash low |	<primitive: 'primitiveStringHash' module: 'MiscPrimitivePlugin'>	<var: #aHash declareC: 'int speciesHash'>	<var: #aString declareC: 'unsigned char *aString'>	stringSize := aString size.	hash := speciesHash bitAnd: 16rFFFFFFF.	1 to: stringSize do: [:pos |		hash := hash + (aString at: pos) asciiValue.		"Begin hashMultiply"		low := hash bitAnd: 16383.		hash := (16r260D * low + ((16r260D * (hash bitShift: -14) + (16r0065 * low) bitAnd: 16383) * 16384)) bitAnd: 16r0FFFFFFF.	].	^ hash! !"Collections"!!Number methodsFor: 'mathematical functions' stamp: 'nice 10/31/2010 22:03' prior: 24880669!degreeCos	"Answer the cosine of the receiver taken as an angle in degrees."		^ (90 - (180 + self \\ 360 - 180) abs) degreesToRadians sin! !!Number methodsFor: 'mathematical functions' stamp: 'nice 10/31/2010 22:01' prior: 24880850!degreeSin	"Answer the sine of the receiver taken as an angle in degrees."		^(90 - self) degreeCos! !!Behavior methodsFor: 'enumerating' stamp: 'topa 10/25/2010 10:24'!withAllSuperAndSubclassesDo: aBlock	self allSuperclassesDo: aBlock.	aBlock value: self.	self allSubclassesDo: aBlock! !!Float methodsFor: 'mathematical functions' stamp: 'nice 11/1/2010 11:56' prior: 20893032!degreeCos	"Take care of exceptional values"		self isFinite ifTrue: [^super degreeCos].	^self degreesToRadians cos! !!Float methodsFor: 'mathematical functions' stamp: 'nice 11/1/2010 11:56' prior: 20893188!degreeSin	"Take care of exceptional values"		self isFinite ifTrue: [^super degreeSin].	^self degreesToRadians sin! !"Kernel"!!StandardFileStream commentStamp: 'ul 12/6/2009 05:13' prior: 59429549!Provides a simple, platform-independent, interface to a file system. The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 swI implement a simple read buffering scheme with the variables defined in PositionableStream (which are unused in me otherwise) in the following way:	collection	<ByteString> or <ByteArray>	This is the buffer.	position	<Integer>	The relative position in the buffer. Greater or equal to zero.	readLimit	<Integer>	The number of bytes buffered. Greater or equal to zero.Read buffering is enabled with #enableReadBuffering, disabled with #disableReadBuffering and it is enabled by default. The buffer is filled when a read attempt of an unbuffered absolute position is requested, or when a negative repositioning is made (with #position: with an argument < than the current absolute position) to an absolute position which is not buffered. In the first case, the buffer is positioned to the given absolute position. In the latter case the repositioning is made to the requested absolute position minus fourth of the buffer size. This means that further small negative repositionings won't result in buffer flushing. This is really useful when filing in code.The read buffer is flushed (#flushReadBuffer) whenever a write attempt is made.The buffer state is valid if and only if collection is not nil and position < readLimit.!!CrLfFileStream class methodsFor: 'instance creation' stamp: 'eem 5/15/2009 09:24'!newForStdio	"Circumvent CrLfFileStream new's retuning an instance of MultiBteFileStream"	^super new! !!CrLfFileStream methodsFor: 'open/close' stamp: 'eem 5/14/2009 11:57'!openOnHandle: aFileID name: streamName forWrite: writeMode	"Initialize the file with the given handle. If writeMode is true then	 allow writing, otherwise put the file in read-only mode."	super openOnHandle: aFileID name: streamName forWrite: writeMode.	lineEndConvention := LineEndDefault! !!DirectoryEntry methodsFor: 'access' stamp: 'bgf 9/9/2010 07:36' prior: 58763686!fullName	"The fully-qualified name.	 Since this method falls into the equality test, make it safe when directory is nil."	^ directory 		ifNotNil: [ directory fullNameFor: self name ] 		ifNil: [ self name ]! !!StandardFileStream class methodsFor: 'error handling' stamp: 'eem 7/24/2009 10:34' prior: 55072939!fileExistsUserHandling: fullFileName	| dir localName choice newName newFullFileName |	dir := FileDirectory forFileName: fullFileName.	localName := FileDirectory localNameFor: fullFileName.	choice := (UIManager default 		chooseFrom: #('overwrite that file' 'append (risky!!!!)' 'choose another name' 'cancel')		title: localName, ' already exists.').	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fullFileName forWrite: true].	choice = 2 ifTrue: [		^ (self new open: fullFileName forWrite: true) setToEnd].	choice = 3 ifTrue: [		newName := UIManager default request: 'Enter a new file name' initialAnswer: fullFileName.		newFullFileName := self fullName: newName.		^ self newFileNamed: newFullFileName].	self error: 'Please close this to abort file opening'! !!StandardFileStream class methodsFor: 'class initialization' stamp: 'eem 5/14/2009 12:12'!flushAndVoidStdioFiles	stdioFiles ifNotNil:		[stdioFiles do:			[:f| f isReadOnly ifFalse: [[f flush] on: Error do: [:ex|"care less"]]].		 stdioFiles := nil]! !!StandardFileStream class methodsFor: 'class initialization' stamp: 'eem 7/4/2010 12:03'!initialize	"StandardFileStream initialize"	StdioHandles := Array new: 3.	Smalltalk		addToStartUpList: self after: SecurityManager; "the intent being before: AutoStart"		addToShutDownList: self after: SecurityManager! !!StandardFileStream class methodsFor: 'private-file creation' stamp: 'eem 5/15/2009 10:36'!newForStdio	"Circumvent CrLfFileStream new's returning an instance of MultiBteFileStream"	^self new! !!StandardFileStream class methodsFor: 'class initialization' stamp: 'eem 10/2/2009 16:41'!shutDown: quitting	quitting ifTrue:		[self withAllSubclassesDo:			[:fileStreamClass| fileStreamClass flushAndVoidStdioFiles]]! !!StandardFileStream class methodsFor: 'private-file creation' stamp: 'ul 9/27/2010 03:54'!standardIOStreamNamed: moniker forWrite: forWrite		| index |	index := #(stdin stdout stderr) identityIndexOf: moniker.	^((stdioFiles ifNil: [ stdioFiles := Array new: 3 ]) at: index)		ifNil: [			stdioFiles				at: index 				put: (					(StdioHandles at: index)						ifNil: [ ^self error: moniker, ' is unavailable' ]						ifNotNil: [ :handle|							self newForStdio 								openOnHandle: handle 								name: moniker								forWrite: forWrite ]) ]! !!StandardFileStream class methodsFor: 'class initialization' stamp: 'eem 7/6/2010 15:00'!startUp: resuming	(resuming and: [self == StandardFileStream]) ifTrue:		[self withAllSubclassesDo:			[:fileStreamClass| fileStreamClass voidStdioFiles].		 [StdioHandles := self stdioHandles]			on: Error			do: [:ex|				StdioHandles isArray ifFalse:					[StdioHandles := Array new: 3]]]! !!StandardFileStream class methodsFor: 'file creation' stamp: 'eem 5/14/2009 11:47'!stderr	^self standardIOStreamNamed: #stderr forWrite: true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'eem 5/14/2009 11:47'!stdin	^self standardIOStreamNamed: #stdin forWrite: false! !!StandardFileStream class methodsFor: 'private-file creation' stamp: 'eem 5/14/2009 10:37'!stdioHandles	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>	self primitiveFailed! !!StandardFileStream class methodsFor: 'file creation' stamp: 'eem 5/14/2009 11:47'!stdout	^self standardIOStreamNamed: #stdout forWrite: true! !!StandardFileStream class methodsFor: 'class initialization' stamp: 'eem 7/6/2010 14:54'!voidStdioFiles	stdioFiles := nil! !!StandardFileStream methodsFor: 'open/close' stamp: 'eem 7/4/2010 12:00'!openOnHandle: aFileID name: streamName forWrite: writeMode	"Initialize the file with the given handle. If writeMode is true then	 allow writing, otherwise put the file in read-only mode.	 N.B. Do _not_ register the stream.  We do not want it to be	 closed implicitly (e.g. on GC).  There may be multiple instances	 accessing the same stream.  The stream is not a file."	fileID := aFileID.	name := streamName.	rwmode := writeMode.	buffer1 := String new: 1.	self enableReadBuffering! !!FileDirectory methodsFor: 'private' stamp: 'ar 9/3/2010 16:20'!directoryEntryForName: aFileName	"Return a single DirectoryEntry for the given (non-path) entry name,	 or nil if the entry could not be found.	 Raises InvalidDirectoryError if this directory's path does not identify a directory."	| entryArray sysPath sysName |	sysPath := pathName asVmPathName.	sysName := aFileName asVmPathName.	"New linear-time primitive."	entryArray := self primLookupEntryIn: sysPath name: sysName.	entryArray == #primFailed ifFalse:[		^ entryArray ifNotNil: [(DirectoryEntry fromArray: entryArray directory: self) convertFromSystemName]	].	"If the new primitive fails, use the old slow method. 	 (This fallback can be changed to signal InvalidDirectoryError once	  VM's with FilePlugin #primitiveDirectoryEntry have been distributed everywhere;	  the new primitive was introduced 6/13/2007."	^self isCaseSensitive ifTrue: [		self entries detect: [:entry | entry name = aFileName ] ifNone: [ nil ]	] ifFalse: [		self entries detect: [:entry | entry name sameAs: aFileName ] ifNone: [ nil ]	]! !"Files"!!WarpBlt methodsFor: 'smoothing' stamp: 'ul 11/2/2010 03:04' prior: 53118452!rgbMap: sourcePixel from: nBitsIn to: nBitsOut	"NOTE: This code is copied verbatim from BitBltSimulation so that it	may be removed from the system"	"Convert the given pixel value with nBitsIn bits for each color component to a pixel value with nBitsOut bits for each color component. Typical values for nBitsIn/nBitsOut are 3, 5, or 8."	| mask d srcPix destPix |	<inline: true>	(d := nBitsOut - nBitsIn) > 0		ifTrue:			["Expand to more bits by zero-fill"			mask := (1 << nBitsIn) - 1.  "Transfer mask"			srcPix := sourcePixel << d.			mask := mask << d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix << d.			^ destPix + (srcPix bitAnd: mask)				 	+ (srcPix << d bitAnd: mask << nBitsOut)]		ifFalse:			["Compress to fewer bits by truncation"			d = 0 ifTrue: [^ sourcePixel].  "no compression"			sourcePixel = 0 ifTrue: [^ sourcePixel].  "always map 0 (transparent) to 0"			d := nBitsIn - nBitsOut.			mask := (1 << nBitsOut) - 1.  "Transfer mask"			srcPix := sourcePixel >> d.			destPix := srcPix bitAnd: mask.			mask := mask << nBitsOut.			srcPix := srcPix >> d.			destPix := destPix + (srcPix bitAnd: mask)					+ (srcPix >> d bitAnd: mask << nBitsOut).			destPix = 0 ifTrue: [^ 1].  "Dont fall into transparent by truncation"			^ destPix]! !"Graphics"!!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:50'!testDegreeCos		self shouldnt: [ 45.0 degreeCos] raise: Error.	"Following tests use approximate equality, because cosine are generally evaluated using inexact Floating point arithmetic"	self assert: (45.0 degreeCos squared - 0.5) abs <= Float epsilon.	self assert: (60.0 degreeCos - 0.5) abs <= Float epsilon.	self assert: (120.0 degreeCos + 0.5) abs <= Float epsilon.	-360.0 to: 360.0 do: [:i |		self assert: (i degreeCos closeTo: i degreesToRadians cos)].		"Following tests use strict equality which is a requested property of degreeCos"	-10.0 to: 10.0 do: [:k |		self assert: (k*360 + 90) degreeCos = 0.		self assert: (k*360 - 90) degreeCos = 0.		self assert: (k*360 + 180) degreeCos + 1 = 0.		self assert: (k*360) degreeCos - 1 = 0.].! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:49'!testDegreeCosForExceptionalValues	self assert: Float nan degreeCos isNaN.	self assert: Float infinity degreeCos isNaN.	self assert: Float infinity negated degreeCos isNaN.! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:51'!testDegreeSin		self shouldnt: [ 45.0 degreeSin] raise: Error.	"Following tests use approximate equality, because sine are generally evaluated using inexact Floating point arithmetic"	self assert: (45.0 degreeSin squared - 0.5) abs <= Float epsilon.	self assert: (30.0 degreeSin - 0.5) abs <= Float epsilon.	self assert: (-30.0 degreeSin + 0.5) abs <= Float epsilon.	-360.0 to: 360.0 do: [:i |		self assert: (i degreeSin closeTo: i degreesToRadians sin)].		"Following tests use strict equality which is a requested property of degreeSin"	-10.0 to: 10.0 do: [:k |		self assert: (k*360 + 90) degreeSin - 1 = 0.		self assert: (k*360 - 90) degreeSin + 1= 0.		self assert: (k*360 + 180) degreeSin = 0.		self assert: (k*360) degreeSin = 0.].! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:49'!testDegreeSinForExceptionalValues	self assert: Float nan degreeSin isNaN.	self assert: Float infinity degreeSin isNaN.	self assert: Float infinity negated degreeSin isNaN.! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:12' prior: 21183970!testDegreeCos	"self run: #testDegreeCos"		self shouldnt: [ (4/3) degreeCos] raise: Error.	-361/3 to: 359/3 do: [:i |		self assert: (i degreeCos closeTo: i degreesToRadians cos)].! !!FractionTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:15' prior: 21184204!testDegreeSin	"self run: #testDegreeSin"		self shouldnt: [ (4/3) degreeSin] raise: Error.	-361/3 to: 359/3 do: [:i |		self assert: (i degreeSin closeTo: i degreesToRadians sin)].! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:50' prior: 22031014!testDegreeCos	"self run: #testDegreeCos"		self shouldnt: [ 45 degreeCos] raise: Error.	"Following tests use approximate equality, because cosine are generally evaluated using inexact Floating point arithmetic"	self assert: (45 degreeCos squared - (1/2)) abs <= Float epsilon.	self assert: (60 degreeCos - (1/2)) abs <= Float epsilon.	self assert: (120 degreeCos + (1/2)) abs <= Float epsilon.	-360 to: 360 do: [:i |		self assert: (i degreeCos closeTo: i degreesToRadians cos)].		"Following tests use strict equality which is a requested property of degreeCos"	-10 to: 10 do: [:k |		self assert: (k*360 + 90) degreeCos = 0.		self assert: (k*360 - 90) degreeCos = 0.		self assert: (k*360 + 180) degreeCos + 1 = 0.		self assert: (k*360) degreeCos - 1 = 0.].! !!IntegerTest methodsFor: 'tests - mathematical functions' stamp: 'nice 10/31/2010 21:39'!testDegreeSin	"self run: #testDegreeSin"		self shouldnt: [ 45 degreeSin] raise: Error.		"Following tests use approximate equality, because sine are generally evaluated using inexact Floating point arithmetic"	self assert: (45 degreeSin squared - (1/2)) abs <= Float epsilon.	self assert: (30 degreeSin - (1/2)) abs <= Float epsilon.	self assert: (-30 degreeSin + (1/2)) abs <= Float epsilon.	-360 to: 360 do: [:i |		self assert: (i degreeSin closeTo: i degreesToRadians sin)].		"Following tests use strict equality which is a requested property of degreeSin"	-10 to: 10 do: [:k |		self assert: (k*360 + 90) degreeSin - 1 = 0.		self assert: (k*360 - 90) degreeSin + 1= 0.		self assert: (k*360 + 180) degreeSin = 0.		self assert: (k*360) degreeSin = 0].! !"KernelTests"!!MultiByteFileStream methodsFor: 'open/close' stamp: 'ul 11/2/2010 03:19'!openOnHandle: aFileID name: streamName forWrite: writeMode	super openOnHandle: aFileID name: streamName forWrite: writeMode.	self converter "Make sure that converter is initialized."! !"Multilingual"!!PluckedSound methodsFor: 'sound generation' stamp: 'ul 11/2/2010 03:08' prior: 26292560!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive:'primitiveMixPluckedSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #ring declareC: 'short int *ring'>	lastIndex := (startIndex + n) - 1.	scaledThisIndex := scaledNextIndex := scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex := scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex := ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average :=			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample := (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex := scaledNextIndex.		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	scaledIndex := scaledNextIndex.	count := count - n.! !!ReverbSound methodsFor: 'private' stamp: 'ul 11/2/2010 03:08' prior: 27762348!applyReverbTo: aSoundBuffer startingAt: startIndex count: n	| delayedLeft delayedRight i tapGain j out |	<primitive: 'primitiveApplyReverb' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #tapDelays declareC: 'int *tapDelays'>	<var: #tapGains declareC: 'int *tapGains'>	<var: #leftBuffer declareC: 'short int *leftBuffer'>	<var: #rightBuffer declareC: 'short int *rightBuffer'>	startIndex to: ((startIndex + n) - 1) do: [:sliceIndex |		delayedLeft := delayedRight := 0.		1 to: tapCount do: [:tapIndex |			i := bufferIndex - (tapDelays at: tapIndex).			i < 1 ifTrue: [i := i + bufferSize].  "wrap"			tapGain := tapGains at: tapIndex.			delayedLeft := delayedLeft + (tapGain * (leftBuffer at: i)).			delayedRight := delayedRight + (tapGain * (rightBuffer at: i))].		"left channel"		j := (2 * sliceIndex) - 1.		out := (aSoundBuffer at: j) + (delayedLeft // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		leftBuffer at: bufferIndex put: out.		"right channel"		j := j + 1.		out := (aSoundBuffer at: j) + (delayedRight // ScaleFactor).		out >  32767 ifTrue: [out :=  32767].  "clipping!!"		out < -32767 ifTrue: [out := -32767].  "clipping!!"		aSoundBuffer at: j put: out.		rightBuffer at: bufferIndex put: out.		bufferIndex := (bufferIndex \\ bufferSize) + 1].! !!SampledSound methodsFor: 'playing' stamp: 'ul 11/2/2010 03:08' prior: 28121341!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex outIndex sampleIndex sample i s overflow |	<primitive:'primitiveMixSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #samples declareC: 'short int *samples'>	lastIndex := (startIndex + n) - 1.	outIndex := startIndex.    "index of next stereo output sample pair"	sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [		sample := ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i := (2 * outIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * outIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]].		scaledIndex := scaledIndex + scaledIncrement.		scaledIndex >= ScaledIndexOverflow ifTrue: [			overflow := scaledIndex >> IncrementFractionBits.			indexHighBits := indexHighBits + overflow.			scaledIndex := scaledIndex - (overflow << IncrementFractionBits)].		sampleIndex := indexHighBits + (scaledIndex >> IncrementFractionBits).		outIndex := outIndex + 1].	count := count - n.! !!FMSound methodsFor: 'sound generation' stamp: 'ul 11/2/2010 03:08' prior: 20344447!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy."	"(FMSound pitch: 440.0 dur: 1.0 loudness: 0.5) play"	| doingFM lastIndex sample offset i s |	<primitive:'primitiveMixFMSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #waveTable declareC: 'short int *waveTable'>	doingFM := (normalizedModulation ~= 0) and: [scaledOffsetIndexIncr ~= 0].	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sample := (scaledVol * (waveTable at: (scaledIndex // ScaleFactor) + 1)) // ScaleFactor.		doingFM			ifTrue: [				offset := normalizedModulation * (waveTable at: (scaledOffsetIndex // ScaleFactor) + 1).				scaledOffsetIndex := (scaledOffsetIndex + scaledOffsetIndexIncr) \\ scaledWaveTableSize.				scaledOffsetIndex < 0					ifTrue: [scaledOffsetIndex := scaledOffsetIndex + scaledWaveTableSize].				scaledIndex := (scaledIndex + scaledIndexIncr + offset) \\ scaledWaveTableSize.				scaledIndex < 0					ifTrue: [scaledIndex := scaledIndex + scaledWaveTableSize]]			ifFalse: [				scaledIndex := (scaledIndex + scaledIndexIncr) \\ scaledWaveTableSize].		leftVol > 0 ifTrue: [			i := (2 * sliceIndex) - 1.			s := (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i := 2 * sliceIndex.			s := (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0]]].	count := count - n.! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:01' prior: 16789722!indexForDeltaFrom: thisSample to: nextSample	"Answer the best index to use for the difference between the given samples."	"Details: Scan stepSizeTable for the first entry >= the absolute value of the difference between sample values. Since indexes are zero-based, the index used during decoding will be the one in the following stepSizeTable entry. Since the index field of a Flash frame header is only six bits, the maximum index value is 63."	"Note: Since there does not appear to be any documentation of how Flash actually computes the indices used in its frame headers, this algorithm was guessed by reverse-engineering the Flash ADPCM decoder."	| diff bestIndex |	<inline: true>	diff := nextSample - thisSample.	diff < 0 ifTrue: [diff := 0 - diff].	bestIndex := 63.	1 to: 62 do: [:j |		bestIndex = 63 ifTrue: [			(stepSizeTable at: j) >= diff ifTrue: [bestIndex := j]]].	^ bestIndex! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'ul 11/2/2010 03:01' prior: 16780460!nextBits: n	"Answer the next n bits of my bit stream as an unsigned integer."	| result remaining shift |	<inline: true>	result := 0.	remaining := n.	[true] whileTrue: [		shift := remaining - bitPosition.		result := result + (currentByte bitShift: shift).		shift > 0			ifTrue: [  "consumed currentByte buffer; fetch next byte"				remaining := remaining - bitPosition.							currentByte := (encodedBytes at: (byteIndex := byteIndex + 1)).				bitPosition := 8]			ifFalse: [  "still some bits left in currentByte buffer"				bitPosition := bitPosition - remaining.				"mask out the consumed bits:"				currentByte := currentByte bitAnd: (255 bitShift: (bitPosition - 8)).				^ result]].! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'ul 11/2/2010 03:01' prior: 16781251!nextBits: n put: anInteger	"Write the next n bits to my bit stream."	| buf bufBits bitsAvailable shift |	<inline: true>	buf := anInteger.	bufBits := n.	[true] whileTrue: [		bitsAvailable := 8 - bitPosition.		shift := bitsAvailable - bufBits.  "either left or right shift"		"append high bits of buf to end of currentByte:"		currentByte := currentByte + (buf bitShift: shift).		shift < 0			ifTrue: [  "currentByte buffer filled; output it"				encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte.				bitPosition := 0.				currentByte := 0.				"clear saved high bits of buf:"				buf := buf bitAnd: (1 bitShift: 0 - shift) - 1.				bufBits := bufBits - bitsAvailable]			ifFalse: [  "still some bits available in currentByte buffer"				bitPosition := bitPosition + bufBits.				^ self]].! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:06' prior: 16792159!privateDecodeMono: count	| delta step predictedDelta bit |	<primitive: 'primitiveDecodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predicted := self nextBits: 16.				predicted > 32767 ifTrue: [predicted := predicted - 65536].				index := self nextBits: 6.				samples at: (sampleIndex := sampleIndex + 1) put: predicted]			ifFalse: [				delta := self nextBits: bitsPerSample.				step := stepSizeTable at: index + 1.				predictedDelta := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta := predictedDelta + step].					step := step bitShift: -1.					bit := bit bitShift: -1].				predictedDelta := predictedDelta + step.				(delta bitAnd: deltaSignMask) > 0					ifTrue: [predicted := predicted - predictedDelta]					ifFalse: [predicted := predicted + predictedDelta].				predicted > 32767					ifTrue: [predicted := 32767]					ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].				index := index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).				index < 0					ifTrue: [index := 0]					ifFalse: [index > 88 ifTrue: [index := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predicted]].! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:07' prior: 16793779!privateDecodeStereo: count	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |	<primitive: 'primitiveDecodeStereo' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	<var: #rightSamples declareC: 'short int *rightSamples'>	<var: #predicted declareC: 'short int *predicted'>	<var: #index declareC: 'short int *index'>	"make local copies of decoder state variables"	predictedLeft := predicted at: 1.	predictedRight := predicted at: 2.	indexLeft := index at: 1.	indexRight := index at: 2.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predictedLeft := self nextBits: 16.				indexLeft := self nextBits: 6.				predictedRight := self nextBits: 16.				indexRight := self nextBits: 6.				predictedLeft > 32767 ifTrue: [predictedLeft := predictedLeft - 65536].				predictedRight > 32767 ifTrue: [predictedRight := predictedRight - 65536].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]			ifFalse: [				deltaLeft := self nextBits: bitsPerSample.				deltaRight := self nextBits: bitsPerSample.				stepLeft := stepSizeTable at: indexLeft + 1.				stepRight := stepSizeTable at: indexRight + 1.				predictedDeltaLeft := predictedDeltaRight := 0.				bit := deltaValueHighBit.				[bit > 0] whileTrue: [					(deltaLeft bitAnd: bit) > 0 ifTrue: [						predictedDeltaLeft := predictedDeltaLeft + stepLeft].					(deltaRight bitAnd: bit) > 0 ifTrue: [						predictedDeltaRight := predictedDeltaRight + stepRight].					stepLeft := stepLeft bitShift: -1.					stepRight := stepRight bitShift: -1.					bit := bit bitShift: -1].				predictedDeltaLeft := predictedDeltaLeft + stepLeft.				predictedDeltaRight := predictedDeltaRight + stepRight.				(deltaLeft bitAnd: deltaSignMask) > 0					ifTrue: [predictedLeft := predictedLeft - predictedDeltaLeft]					ifFalse: [predictedLeft := predictedLeft + predictedDeltaLeft].				(deltaRight bitAnd: deltaSignMask) > 0					ifTrue: [predictedRight := predictedRight - predictedDeltaRight]					ifFalse: [predictedRight := predictedRight + predictedDeltaRight].				predictedLeft > 32767					ifTrue: [predictedLeft := 32767]					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft := -32768]].				predictedRight > 32767					ifTrue: [predictedRight := 32767]					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight := -32768]].				indexLeft := indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).				indexLeft < 0					ifTrue: [indexLeft := 0]					ifFalse: [indexLeft > 88 ifTrue: [indexLeft := 88]].				indexRight := indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).				indexRight < 0					ifTrue: [indexRight := 0]					ifFalse: [indexRight > 88 ifTrue: [indexRight := 88]].				samples at: (sampleIndex := sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]].	"save local copies of decoder state variables"	predicted at: 1 put: predictedLeft.	predicted at: 2 put: predictedRight.	index at: 1 put: indexLeft.	index at: 2 put: indexRight.! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:07' prior: 16797313!privateEncodeMono: count	| step sign diff delta predictedDelta bit p |	<primitive: 'primitiveEncodeMono' module: 'ADPCMCodecPlugin'>	<var: #stepSizeTable declareC: 'short int *stepSizeTable'>	<var: #indexTable declareC: 'short int *indexTable'>	<var: #samples declareC: 'short int *samples'>	<var: #encodedBytes declareC: 'unsigned char *encodedBytes'>	step := stepSizeTable at: 1.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1 ifTrue: [			predicted := samples at: (sampleIndex := sampleIndex + 1).			(p := predicted) < 0 ifTrue: [p := p + 65536].			self nextBits: 16 put: p.			i < count ifTrue: [				index := self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].			self nextBits: 6 put: index.		] ifFalse: [			"compute sign and magnitude of difference from the predicted sample"			sign := 0.			diff := (samples at: (sampleIndex := sampleIndex + 1)) - predicted.			diff < 0 ifTrue: [				sign := deltaSignMask.				diff := 0 - diff].			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:				delta := (4 * diff) / step.				predictedDelta := ((delta + 0.5) * step) / 4;			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."			delta := 0.			predictedDelta := 0.			bit := deltaValueHighBit.			[bit > 0] whileTrue: [				diff >= step ifTrue: [					delta := delta + bit.					predictedDelta := predictedDelta + step.					diff := diff - step].				step := step bitShift: -1.				bit := bit bitShift: -1].			predictedDelta := predictedDelta + step.			"compute and clamp new prediction"			sign > 0				ifTrue: [predicted := predicted - predictedDelta]				ifFalse: [predicted := predicted + predictedDelta].			predicted > 32767				ifTrue: [predicted := 32767]				ifFalse: [predicted < -32768 ifTrue: [predicted := -32768]].			"compute new index and step values"			index := index + (indexTable at: delta + 1).			index < 0				ifTrue: [index := 0]				ifFalse: [index > 88 ifTrue: [index := 88]].			step := stepSizeTable at: index + 1.			"output encoded, signed delta"			self nextBits: bitsPerSample put: (sign bitOr: delta)]].	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"		encodedBytes at: (byteIndex := byteIndex + 1) put: currentByte].! !!ADPCMCodec methodsFor: 'private' stamp: 'ul 11/2/2010 03:06' prior: 16799845!privateEncodeStereo: count	<primitive: 'primitiveEncodeStereo' module: 'ADPCMCodecPlugin'>	<inline: false>	"not yet implemented"	self success: false.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'ul 11/2/2010 03:08' prior: 22773464!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive:'primitiveMixLoopedSampledSound' module:'SoundGenerationPlugin'>	<var: #aSoundBuffer declareC: 'short int *aSoundBuffer'>	<var: #leftSamples declareC: 'short int *leftSamples'>	<var: #rightSamples declareC: 'short int *rightSamples'>	isInStereo := leftSamples ~~ rightSamples.	compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.	compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor.	i := (2 * startIndex) - 1.	lastIndex := (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex := (scaledIndex := scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex := (scaledIndex := scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex := sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count := 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex := sampleIndex]				ifFalse: [nextSampleIndex := ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m := scaledIndex bitAnd: LoopIndexFractionMask.		rightVal := leftVal :=			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal :=				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		rightVol > 0 ifTrue: [			s := (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s :=  32767].  "clipping!!"			s < -32767 ifTrue: [s := -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i := i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol := scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol := scaledVolLimit.					scaledVolIncr := 0].			compositeLeftVol := (leftVol * scaledVol) // ScaleFactor.			compositeRightVol :=  (rightVol * scaledVol) // ScaleFactor]].	count := count - n.! !"Sound"!!PackageDependencyTest methodsFor: 'tests' stamp: 'ul 10/28/2010 04:59' prior: 34417841!testShoutCore	self testPackage: 'ShoutCore' dependsExactlyOn: #(		Collections		Graphics		Kernel		Monticello		System		Compiler		Tools	).! !"Tests"!!Browser methodsFor: 'class functions' stamp: 'ul 11/2/2010 01:20' prior: 58587340!copyClass	| originalClass originalName copysName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	originalClass := self selectedClass.	originalName := originalClass name.	copysName := self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName := copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk hasClassNamed: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	Cursor wait showWhile: [		| newDefinition newMetaDefinition newClass |		newDefinition := originalClass definition			copyReplaceAll: originalName printString			with: copysName printString.		newClass := Compiler evaluate: newDefinition logged: true.		newMetaDefinition := originalClass class definition			copyReplaceAll: originalClass class name			with: newClass class name.		Compiler evaluate: newMetaDefinition logged: true.		newClass copyAllCategoriesFrom: originalClass.		newClass class copyAllCategoriesFrom: originalClass class.		originalClass hasComment ifTrue: [			newClass comment: originalClass comment ] ].	self classListIndex: 0.	self changed: #classList! !"Tools"!!SHParserST80 methodsFor: 'private' stamp: 'ul 10/28/2010 00:42' prior: 33747698!allowUnderscoreAssignments	"Query class + preference"	^(classOrMetaClass ifNotNil: [:c | c allowUnderscoreAssignments])		ifNil: [Scanner allowUnderscoreAsAssignment ]! !"ShoutCore"!!AttributedTextStream methodsFor: 'accessing' stamp: 'nice 12/9/2009 08:26' prior: 53798375!contents	| ans |	currentRun > 0 ifTrue:[		attributeValues nextPut: currentAttributes.		attributeRuns nextPut: currentRun.		currentRun := 0].	ans := Text string: characters contents  runs: 		(RunArray runs: attributeRuns contents values: attributeValues contents).	^ans! !!AttributedTextStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:51'!cr	"Append a carriage return character to the receiver."	self nextPut: Character cr! !!AttributedTextStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:51'!crlf	"Append a carriage return and a line feed to the receiver."	self nextPut: Character cr; nextPut: Character lf! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ls 6/27/1998 15:09' prior: 17080175!currentAttributes	"return the current attributes"	^currentAttributes! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ar 10/16/2001 22:57' prior: 17080323!currentAttributes: newAttributes	"set the current attributes"	(currentRun > 0 and:[currentAttributes ~= newAttributes]) ifTrue:[		attributeRuns nextPut: currentRun.		attributeValues nextPut: currentAttributes.		currentRun := 0.	].	currentAttributes := newAttributes.! !!AttributedTextStream methodsFor: 'initialize-release' stamp: 'ul 11/2/2010 21:57' prior: 17081740!initialize	characters := String new writeStream.	currentAttributes := #().	currentRun := 0.	attributeValues := (Array new: 50) writeStream.	attributeRuns := (Array new: 50) writeStream! !!AttributedTextStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:45'!lf	"Append a line feed character to the receiver."	self nextPut: Character lf! !!AttributedTextStream methodsFor: 'accessing' stamp: 'nice 3/19/2010 19:03' prior: 58759528!nextPut: aChar	currentRun := currentRun + 1.	^characters nextPut: aChar! !!AttributedTextStream methodsFor: 'accessing' stamp: 'nice 3/19/2010 19:12' prior: 58759704!nextPutAll: aString	"add an entire string with the same attributes"	currentRun := currentRun + aString size.	^characters nextPutAll: aString.! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ls 9/10/1998 03:36' prior: 17080674!size	"number of characters in the stream so far"	^characters size! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ul 11/2/2010 21:57'!withAttribute: attribute do: aBlock	^self withAttributes: { attribute } do: aBlock! !!AttributedTextStream methodsFor: 'accessing' stamp: 'ul 11/2/2010 06:42'!withAttributes: attributes do: aBlock	| previousAttributes |	previousAttributes := currentAttributes.	[		self currentAttributes: attributes.		aBlock value ]			ensure: [ self currentAttributes: previousAttributes ]! !!Stream methodsFor: 'printing' stamp: 'ajh 7/31/2001 20:34' prior: 29974993!printOn: stream	super printOn: stream.	stream space.	self contents printOn: stream.! !!WriteStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:50' prior: 33278477!cr	"Append a carriage return character to the receiver."	self nextPut: Character cr! !!WriteStream methodsFor: 'character writing' stamp: 'ul 11/2/2010 21:50' prior: 53778027!crlf	"Append a carriage return and a line feed to the receiver."	self nextPut: Character cr; nextPut: Character lf! !!Symbol methodsFor: 'evaluating' stamp: 'ul 11/2/2010 18:23'!cull: anObject 	^anObject perform: self! !"Collections"!!WeakFinalizersTest methodsFor: 'as yet unclassified' stamp: 'ul 11/2/2010 18:29'!expectedFailures	^WeakFinalizationList hasNewFinalization		ifTrue: [ #() ]		ifFalse: [ #(testNewFinalizationSupported) ]! !"CollectionsTests"!!MCPatchOperation methodsFor: 'accessing' stamp: 'ul 11/6/2010 05:55' prior: 23026321!sourceText	^(self isClassPatch		ifFalse: [ TextDiffBuilder ]		ifTrue: [ ClassDiffBuilder ])			buildDisplayPatchFrom: self fromSource			to: self toSource			inClass: self targetClass			prettyDiffs: (				Preferences diffsWithPrettyPrint and: [					self targetClass notNil and: [					self isClassPatch not ] ])! !!MCClassDefinition methodsFor: 'printing' stamp: 'ul 11/6/2010 05:50' prior: 33812933!definitionAndCommentString	^ String streamContents: [:stream |		self printDefinitionOn: stream.		stream cr; cr.		self printClassSideDefinitionOn: stream.    		stream cr; cr.		self printCommentOn: stream]! !!MCClassDefinition methodsFor: 'printing' stamp: 'ul 11/6/2010 05:49'!printClassSideDefinitionOn: stream		stream		nextPutAll: self className;		nextPutAll: ' class ';		cr; tab;		nextPutAll: 'instanceVariableNames: ';		store: self classInstanceVariablesString! !"Monticello"!!DateAndTime commentStamp: 'brp 5/13/2003 08:07' prior: 59269921!I represent a point in UTC time as defined by ISO 8601. I have zero duration.My implementation uses three SmallIntegers and a Duration:jdn		- julian day number.seconds	- number of seconds since midnight.nanos	- the number of nanoseconds since the second.offset	- duration from UTC.The nanosecond attribute is almost always zero but it defined for full ISO compliance and is suitable for timestamping.!"Kernel"!!BDFFontReader class methodsFor: 'resource download' stamp: 'ul 11/3/2010 06:35' prior: 34450419!downloadFonts  "BDFFontReader downloadFonts"	"Download a standard set of BDF sources from x.org.  	The combined size of these source files is around 1.2M; after conversion 	to .sf2 format they may be deleted."	| heads tails filenames baseUrl basePath |	heads := #( 'charR' 'courR' 'helvR' 'lubR' 'luRS' 'lutRS' 'ncenR' 'timR' ).	tails := #( '08' '10' '12' '14' '18' '24').	filenames := OrderedCollection new.	heads do: [:head |		filenames addAll: (tails collect: [:tail | head , tail , '.bdf'])	].	baseUrl := 'http://cvsweb.xfree86.org/cvsweb/*checkout*/xc/fonts/bdf/75dpi/' asUrl.	basePath := baseUrl path.	filenames do: [:filename |		| document newPath newUrl |		newUrl := baseUrl clone.		newPath := OrderedCollection newFrom: basePath.		newPath addLast: filename.		newUrl path: newPath.		Utilities informUser: 'Fetching ' , filename during: 			[document := newUrl retrieveContents].		MultiByteFileStream newFileNamed: filename do: [ :f |			f 				wantsLineEndConversion: true;				nextPutAll: document content ]	].! !!BDFFontReader methodsFor: 'initialize' stamp: 'ul 11/3/2010 06:21' prior: 17129037!openFileNamed: fileName	file := MultiByteFileStream readOnlyFileNamed: fileName.	file wantsLineEndConversion: true! !BDFFontReader class removeSelector: #new!"Graphics"!!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ul 11/2/2010 18:33' prior: 54624149!buildDisplayPatch	| stream |	stream := AttributedTextStream new.	self 		patchSequenceDoIfMatch: [ :string |			self print: string withAttributes: NormalTextAttributes on: stream ]		ifInsert: [ :string |			self print: string withAttributes: InsertTextAttributes on: stream ]		ifRemove: [ :string |			self print: string withAttributes: RemoveTextAttributes on: stream ].	^stream contents! !!TextDiffBuilder methodsFor: 'private' stamp: 'ul 11/4/2010 22:34' prior: 57398224!print: aString withAttributes: attributes on: stream	stream		currentAttributes: attributes;		nextPutAll: aString.	(aString notEmpty and: [ 		aString last = Character cr or: [			aString endsWith: String crlf ] ]) 				ifFalse: [ stream cr ]! !!DiffElement methodsFor: 'accessing' stamp: 'ul 11/6/2010 02:23' prior: 54622691!string: aString	string := aString.	hash := string hash! !!ClassDiffBuilder methodsFor: 'private' stamp: 'ul 11/6/2010 02:21' prior: 54622968!print: aCharacter withAttributes: attributes on: stream	stream		currentAttributes: attributes;		nextPut: aCharacter! !!ClassDiffBuilder methodsFor: 'private' stamp: 'ul 11/6/2010 02:20' prior: 54623188!split: aString	"Diff by characters."	^aString as: Array! !!MessageTally class methodsFor: 'defaults' stamp: 'jmv 4/30/2010 14:10' prior: 23807737!defaultMaxClassNameSize	"Return the default maximum width of the class name alone"	^50! !!MessageTally class methodsFor: 'defaults' stamp: 'jmv 4/30/2010 14:10' prior: 23807901!defaultMaxClassPlusSelectorSize	"Return the default maximum width of the class plus selector together (not counting the '>>')"	^100! !"System"!!Debugger methodsFor: 'private' stamp: 'ul 11/6/2010 02:02' prior: 58589936!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresentAndInMemory: [ :tally |		tally terminateTimerProcess].	contents := nil. 	interruptedProcess := aProcess.	interruptedController := aController.	contextStackTop := aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex := 1.	externalInterrupt := false.	selectingPC := true.	Smalltalk isMorphic ifTrue:		[errorWasInUIProcess := false]! !!ChangeList methodsFor: 'viewing access' stamp: 'ul 11/5/2010 19:38' prior: 34053961!contentsDiffedFromCurrent	"Answer the contents diffed forward from current (in-memory) method version"	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange := changeList at: listIndex.	 (aChange type == #method	 and: [(aClass := aChange methodClass) notNil	 and: [aClass includesSelector: aChange methodSelector]]) ifTrue:		[^Utilities			methodDiffFor: aChange text			class: aClass			selector: aChange methodSelector			prettyDiffs: self showingPrettyDiffs].	aChange type == #doIt ifTrue:		[| tokens |		 tokens := Scanner new scanTokens: aChange string.		 ((tokens select:				[:substr| #(subclass: variableByteSubclass: variableWordSubclass:							instanceVariableNames: classVariableNames: ) includes: substr])					asSet size >= 3		  and: [(aClass := Smalltalk at: tokens third ifAbsent: []) notNil		  and: [aClass isBehavior]]) ifTrue:			[^ClassDiffBuilder buildDisplayPatchFrom: aClass definition to: aChange string].		(tokens size = 4		 and: [tokens second == #class		 and: [tokens third == #instanceVariableNames:		 and: [(aClass := Smalltalk at: tokens first ifAbsent: []) notNil		 and: [aClass isBehavior]]]]) ifTrue:			[^ClassDiffBuilder buildDisplayPatchFrom: aClass class definition to: aChange string]].	(aChange type == #classComment	and: [(aClass := aChange commentClass) notNil]) ifTrue:		[^ClassDiffBuilder buildDisplayPatchFrom: aClass comment asString to: aChange string].	^(changeList at: listIndex) text! !"Tools"!!URI class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 12:09' prior: 56371778!extractSchemeFrom: aString	| colonIndex slashIndex |	colonIndex := aString indexOf: $: .	^colonIndex > 0		ifTrue: [			slashIndex := aString indexOf: $/ .			(slashIndex = 0				or: [colonIndex < slashIndex])				ifTrue: [aString copyFrom: 1 to: colonIndex-1]				ifFalse: [nil]]		ifFalse: [nil]! !!Socket methodsFor: 'receiving' stamp: 'ul 11/15/2010 12:04' prior: 29447169!receiveDataInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data once.  The answer may be zero (indicating that no data was 	available before the socket closed)."	| bytesRead closed |	bytesRead := 0.	closed := false.	[closed not and: [bytesRead = 0]]		whileTrue: [			self waitForDataIfClosed: [closed := true].			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!Socket methodsFor: 'receiving' stamp: 'ul 11/15/2010 12:04' prior: 29447883!receiveDataSignallingClosedInto: aStringOrByteArray startingAt: aNumber	"Receive data into the given buffer and return the number of bytes received. 	Note the given buffer may be only partially filled by the received data.	Waits for data until something is read or the socket is closed, upon which	we signal."	| bytesRead |	bytesRead := 0.	[bytesRead = 0]		whileTrue: [			self waitForData.			bytesRead := self primSocket: socketHandle				receiveDataInto: aStringOrByteArray				startingAt: aNumber				count: aStringOrByteArray size-aNumber+1].	^bytesRead! !!SocksSocket methodsFor: 'connection open/close' stamp: 'ul 11/15/2010 12:04' prior: 52623107!connectTo: hostAddress port: port	self initializeNetwork.	self shouldUseSocks		ifFalse: [^super connectTo: hostAddress port: port].	super connectTo: socksIP port: socksPort.	self waitForConnectionUntil: Socket standardDeadline.	dstIP := hostAddress.	dstPort := port.	vers = 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SocksSocket methodsFor: 'connection open/close' stamp: 'ul 11/15/2010 12:04' prior: 52627203!connectToHostNamed: hostName port: port	super connectTo: socksIP port: socksPort.	self waitForConnectionUntil: Socket standardDeadline.	dstName := hostName.	dstPort := port.	vers = 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SocksSocket methodsFor: 'socks5' stamp: 'ul 11/15/2010 12:05' prior: 52622423!socks5MethodSelection	"The client connects to the server, and sends a version   identifier/method selection message.	The server selects from one of the methods given in METHODS, and   sends a METHOD selection message."	| requestString response |	requestString := WriteStream on: ByteArray new.	requestString		nextPut: 5;		nextPut: 1;		nextPut: 0.	self sendData: requestString contents.	response := self waitForReply: 2 for: self defaultTimeOutDuration.	(response at: 2) = 16rFF		ifTrue: [self socksError: 'No acceptable methods.']		ifFalse: [method := response at: 2]! !!HierarchicalURI methodsFor: 'private' stamp: 'ul 11/15/2010 11:40' prior: 51342957!relativeFromString: aString	| remainder authorityEnd |	remainder := (aString beginsWith: '//')		ifTrue: [			authorityEnd := aString indexOf: $/ startingAt: 3.			authorityEnd = 0				ifTrue: [authorityEnd := aString size+1].			self extractAuthority: (aString copyFrom: 3 to: authorityEnd-1)]		ifFalse: [aString].	self extractSchemeSpecificPartAndFragment: remainder! !"Network"!!Bag methodsFor: 'math functions' stamp: 'ul 11/7/2010 01:46' prior: 58653637!sum	"Faster than the superclass implementation when you hold many instances of the same value (which you probably do, otherwise you wouldn't be using a Bag)."		| sum first |	first := true.	contents keysAndValuesDo: [ :value :count |		first 			ifTrue: [ sum := value * count. first := false ]			ifFalse: [ sum := sum + (value * count) ] ].	first ifTrue: [ self errorEmptyCollection ].	^sum! !!Collection methodsFor: 'enumerating' stamp: 'ul 11/7/2010 01:48' prior: 34132062!fold: binaryBlock	"Evaluate the block with the first two elements of the receiver,	 then with the result of the first evaluation and the next element,	 and so on.  Answer the result of the final evaluation. If the receiver	 is empty, raise an error. If the receiver has a single element, answer	 that element."	"#('if' 'it' 'is' 'to' 'be' 'it' 'is' 'up' 'to' 'me') fold: [:a :b | a, ' ', b]"	^self reduce: binaryBlock! !!Collection methodsFor: 'enumerating' stamp: 'ul 11/7/2010 01:47' prior: 33808045!reduce: binaryBlock	"Apply the argument, binaryBlock cumulatively to the elements of the receiver.	For sequenceable collections the elements will be used in order, for unordered	collections the order is unspecified."	| first nextValue |	first := true.	self do: [ :each |		first			ifTrue: [ nextValue := each. first := false ]			ifFalse: [ nextValue := binaryBlock value: nextValue value: each ] ].	first ifTrue: [ self errorEmptyCollection ].	^nextValue! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ul 11/15/2010 10:06' prior: 28825822!after: target ifAbsent: exceptionBlock	"Answer the element after target.  Answer the result of evaluation	the exceptionBlock if target is not in the receiver, or if there are 	no elements after it."	| index |	index := self indexOf: target.	^ (index = 0 or: [index = self size])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index + 1]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ul 11/15/2010 10:06' prior: 28831782!before: target ifAbsent: exceptionBlock	"Answer the receiver's element immediately before target. Answer	the result of evaluating the exceptionBlock if target is not an element	of the receiver, or if there are no elements before it."	| index |	index := self indexOf: target.	^ (index = 0 or: [index = 1])		ifTrue: [exceptionBlock value]		ifFalse: [self at: index - 1]! !!OrderedCollection class methodsFor: 'private' stamp: 'cmm 10/25/2010 22:26'!arrayType	^ Array! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'cmm 10/25/2010 22:27' prior: 55056769!new: anInteger 	^ self basicNew setCollection: (self arrayType new: anInteger)! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'cmm 10/25/2010 22:28' prior: 55057317!new: anInteger withAll: anObject	^ self basicNew setContents: (self arrayType new: anInteger withAll: anObject)! !!OrderedCollection methodsFor: 'private' stamp: 'cmm 10/25/2010 22:27' prior: 33805389!growAtFirst	"Add new empty slots to the front of array, while keeping the empty slots at the end."	| newArray newFirstIndex newLastIndex |	newArray := self class arrayType new: (array size * 2 max: 1).	newFirstIndex := newArray size - array size + firstIndex.	newLastIndex := newFirstIndex + lastIndex - firstIndex.	newArray 		replaceFrom: newFirstIndex		to: newLastIndex		with: array		startingAt: firstIndex.	array := newArray.	firstIndex := newFirstIndex.	lastIndex := newLastIndex! !!OrderedCollection methodsFor: 'private' stamp: 'cmm 10/25/2010 22:27' prior: 33805945!growAtLast	"Add new empty slots to the end of array, while keeping the empty slots at the front."	| newArray |	newArray := self class arrayType new: (array size * 2 max: 1).	newArray 		replaceFrom: firstIndex		to: lastIndex		with: array		startingAt: firstIndex.	array := newArray! !!OrderedCollection methodsFor: 'removing' stamp: 'cmm 10/25/2010 22:26' prior: 53203515!removeAll	"remove all the elements from this collection.	Keep same amount of storage"		self setCollection: (self class arrayType new: array size)! !!OrderedCollection methodsFor: 'removing' stamp: 'cmm 10/25/2010 22:26' prior: 25255355!removeFirst: n 	"Remove first n object into an array"	| list |	list := self class arrayType new: n.	1		to: n		do:			[ : i | list				at: i				put: self removeFirst ].	^ list! !!OrderedCollection methodsFor: 'removing' stamp: 'cmm 10/25/2010 22:26' prior: 25255901!removeLast: n 	"Remove last n object into an array with last in last position"	| list |	list := self class arrayType new: n.	n		to: 1		by: -1		do:			[ : i | list				at: i				put: self removeLast ].	^ list! !!WeakOrderedCollection class methodsFor: 'as yet unclassified' stamp: 'cmm 10/25/2010 22:27'!arrayType	^ WeakArray! !!String methodsFor: 'converting' stamp: 'ul 11/15/2010 10:07' prior: 30154479!asIdentifier: shouldBeCapitalized	"Return a legal identifier, with first character in upper case if shouldBeCapitalized is true, else lower case.  This will always return a legal identifier, even for an empty string"	| aString firstChar firstLetterPosition |	aString := self select: [:el | el isAlphaNumeric].	firstLetterPosition := aString findFirst: [:ch | ch isLetter].	aString := firstLetterPosition = 0		ifFalse:			[aString copyFrom: firstLetterPosition to: aString size]		ifTrue:			['a', aString].	firstChar := shouldBeCapitalized ifTrue: [aString first asUppercase] ifFalse: [aString first asLowercase].	^ firstChar asString, (aString copyFrom: 2 to: aString size)"'234Fred987' asIdentifier: false'235Fred987' asIdentifier: true'' asIdentifier: true'()87234' asIdentifier: false'())z>=PPve889  U >' asIdentifier: false"! !!String methodsFor: 'converting' stamp: 'ul 11/15/2010 10:07' prior: 30169521!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	(self size = 0 or: [self first isDigit not]) ifTrue: [^ nil].	firstNonDigit := (self findFirst: [:m | m isDigit not]).	firstNonDigit = 0 ifTrue: [firstNonDigit := self size + 1].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"'234Whoopie' initialIntegerOrNil'wimpy' initialIntegerOrNil'234' initialIntegerOrNil'2N' initialIntegerOrNil'2' initialIntegerOrNil'  89Ten ' initialIntegerOrNil'78 92' initialIntegerOrNil"! !!String methodsFor: 'converting' stamp: 'ul 11/15/2010 10:07' prior: 30171673!sansPeriodSuffix	"Return a copy of the receiver up to, but not including, the first period.  If the receiver's *first* character is a period, then just return the entire receiver. "	| likely |	likely := self copyUpTo: $..	^ likely size = 0		ifTrue:	[self]		ifFalse:	[likely]! !!String methodsFor: 'comparing' stamp: 'ul 11/14/2010 06:02' prior: 30144942!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i := keyStart.	j := textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i := i+1.  j := j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch := true.				matchStart := i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch := false.				matchStart := i].	"Now determine the match string"	matchEnd := self size.	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = matchStart ifTrue: [self error: '** not valid -- use * instead'].		matchEnd := ii-1].	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = matchStart ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd := matchEnd min: ii-1].	matchStr := self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj := text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j := j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'internet' stamp: 'ul 11/15/2010 10:07' prior: 30196438!utf8ToIso	"Only UTF-8 characters that maps to 8-bit ISO-8559-1 values are converted. Others raises an error"	| s i c v c2 v2 |	s := WriteStream on: (String new: self size).		i := 1.	[i <= self size] whileTrue: [		c := self at: i. i:=i+1.		v := c asciiValue.		(v > 128)			ifFalse: [ s nextPut: c ]			ifTrue: [((v bitAnd: 252) = 192)				ifFalse: [self error: 'illegal UTF-8 ISO character']				ifTrue: [					(i > self size) ifTrue: [ self error: 'illegal end-of-string, expected 2nd byte of UTF-8'].					c2 := self at: i. i:=i+1.					v2 := c2 asciiValue.					((v2 bitAnd: 192) = 128) ifFalse: [self error: 'illegal 2nd UTF-8 char']. 					s nextPut: ((v2 bitAnd: 63) bitOr: ((v << 6) bitAnd: 192)) asCharacter]]].	^s contents. ! !!String methodsFor: 'internet' stamp: 'ul 11/7/2010 06:46' prior: 30198828!withoutQuoting	"remove the initial and final quote marks, if present"	"'''h''' withoutQuoting"	| quote |	self size < 2 ifTrue: [ ^self ].	quote := self first.	(quote = self last and: [ quote = $' or: [ quote = $" ] ])		ifTrue: [ ^self copyFrom: 2 to: self size - 1 ]		ifFalse: [ ^self ].! !!Symbol class methodsFor: 'access' stamp: 'ul 11/15/2010 10:07' prior: 33884916!selectorsContaining: aString	"Answer a list of selectors that contain aString within them. Case-insensitive.  Does return symbols that begin with a capital letter."	| size selectorList ascii |	selectorList := OrderedCollection new.	(size := aString size) = 0 ifTrue: [^selectorList].	aString size = 1 ifTrue:		[			ascii := aString first asciiValue.			ascii < 128 ifTrue: [selectorList add: (OneCharacterSymbols at: ascii+1)]		].	(aString first isLetter or: [aString first isDigit]) ifFalse:		[			aString size = 2 ifTrue: 				[Symbol hasInterned: aString ifTrue:					[:s | selectorList add: s]].			^selectorList		].	selectorList := selectorList copyFrom: 2 to: selectorList size.	self allSymbolTablesDo: [:each |		each size >= size ifTrue:			[(each findSubstring: aString in: each startingAt: 1 				matchTable: CaseInsensitiveOrder) > 0						ifTrue: [selectorList add: each]]].	^selectorList reject: [:each | "reject non-selectors, but keep ones that begin with an uppercase"		each numArgs < 0 and: [each asString withFirstCharacterDownshifted numArgs < 0]]."Symbol selectorsContaining: 'scon'"! !!Symbol methodsFor: 'testing' stamp: 'ul 11/15/2010 10:07' prior: 30352814!isInfix	"Answer whether the receiver is an infix message selector."	^ self precedence = 2! !!Symbol methodsFor: 'testing' stamp: 'ul 11/15/2010 10:07' prior: 30352971!isKeyword	"Answer whether the receiver is a message keyword."	^ self precedence = 3! !!Symbol methodsFor: 'testing' stamp: 'ul 11/15/2010 10:07' prior: 30353649!isUnary	"Answer whether the receiver is an unary message selector."	^ self precedence = 1! !"Collections"!!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:06'!testAddIncludesSizeReclaim	| ws o2 o3 |	o2 := 1/2.	o3 := '123' copy.	ws := WeakSet new.	ws add: o2.	ws add: o3.	self assert: ws size = 2.	self assert: (ws includes: o2).	self assert: (ws includes: o3).		"inclusion test does use equality, not identity"	self assert: (ws includes: o3 copy) description: 'WeakSet are not WeakIdentitySet'.		"only one copy is added"	ws add: o3 copy.	self assert: ws size = 2.		"reclame objects so that slots of ws are nilled out"	o2 := o3 := nil.	Smalltalk garbageCollect.	self deny: (ws includes: 1/2).	self deny: (ws includes: '123' copy).		"fast #size is not updated automatically by dead object reclamation	But there is a slowSize trying to tell the truth"	self assert: ws slowSize = 0.! !!WeakSetTest methodsFor: 'testing' stamp: 'ul 11/15/2010 12:15'!testCollisions	| ws o1 o2 o5 on remember forget |	"create a weak set"	ws := WeakSet new: 15.		"select some fractions wanting same place in ws array"	o1 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 1].	o2 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 2].	o5 := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = 5].	on := (2 to: 100) select: [:i | (ws scanFor: 1 / i) = (ws array size - 1)].		"Add some fractions to the weak set, and remember a pointer for a few of them"	remember := OrderedCollection new.	forget := OrderedCollection new.	ws add: (remember add: 1 / o1 first).	ws add: (forget add: 1 / on second).	ws add: (forget add: 1 / o1 second).	ws add: (forget add: 1 / o5 second).	ws add: (forget add: 1 / o2 second).	ws add: (forget add: 1 / o1 third).	ws add: (remember add: 1 / o2 first).	ws add: (forget add: 1 / o5 third).	ws add: (forget add: 1 / on third).	ws add: (remember add: 1 / o2 fourth).	ws add: (remember add: 1 / on first).	ws add: (remember add: 1 / o5 first).		"forget and reclaim all entries but those in remember"	forget := nil.	Smalltalk garbageCollect.		remember do: [:m | self assert: (ws includes: m)].	ws add: 1/on second.	remember do: [:m | self assert: (ws includes: m)].		ws add: (remember add: 1 / o1 fourth).	ws add: (remember add: 1 / on fourth).	remember remove: (ws remove: (1 / o5 first)).	remember remove: (ws remove: (1 / on first)).	remember remove: (ws remove: (1 / o2 first)).	remember remove: (ws remove: (1 / o1 first)).	remember do: [:m | self assert: (ws includes: m)].	ws add: 1/on second.	ws add: 1/o5 second.	remember do: [:m | self assert: (ws includes: m)].	! !!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:20'!testDoDontIterateOnReclaimedObjects	| ws o1 o2 size |	ws := WeakSet new.	2 to: 20 do: [:i | ws add: 1 / i].		o1 := 3.0.	o2 := 4.0.	ws add: o1; add: o2.		"Reclaim memory"	Smalltalk garbageCollect.		size := 0.	ws do: [:each |		size := size + 1.		self deny: each isNil].		self assert: size = 2! !!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:15'!testGrowWhenNecessary	| ws objs initialSize |	objs := (2 to: 20) collect: [:i | 1 / i].	ws := WeakSet new: 5.	initialSize := ws array size.	1 to: objs size do: [:k | ws add: (objs at: k)].	self assert: ws array size > initialSize		description: 'The WeakSet grown because not enough room were preallocated'.! !!WeakSetTest methodsFor: 'testing' stamp: 'nice 5/7/2009 01:11'!testIncludesNil	| ws |	ws := WeakSet new.	self deny: (ws includes: nil).		"After reclamation, should not includes nil: nil counts for nothing"	ws add: 1/2.	ws add: 1/3.	Smalltalk garbageCollect.	self deny: (ws includes: nil).! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:05' prior: 30303969!testFindTokensEscapedBy01	| tokens |	string := 'this, is, "a, test"'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:05' prior: 30304429!testFindTokensEscapedBy03	| tokens |	string := 'this, is, a, test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 4! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:05' prior: 30304673!testFindTokensEscapedBy04	| tokens |	string := 'this, is, a"," test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30305284!testFindTokensEscapedBy06	| tokens |	string := 'this, is, "a, test'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30305570!testFindTokensEscapedBy07	| tokens |	string := 'a:b::c'.	tokens := string findTokens: ':' escapedBy: '"'.	self assert: tokens size = 4.	self assert: tokens first = 'a'.	self assert: tokens second = 'b'.	self assert: tokens third = ''.	self assert: tokens fourth = 'c'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30305940!testFindTokensEscapedBy08	| tokens |	string := 'this, is, ##a, test'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size = 4.	self assert: tokens third = ' a'.	self assert: tokens fourth = ' test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30306260!testFindTokensEscapedBy09	| tokens |	string := 'this, is, ###a, test#'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size = 3.	self assert: tokens third = ' #a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30306550!testFindTokensEscapedBy10	| tokens |	string := 'this, is, ###a, test'.	tokens := string findTokens: ',' escapedBy: '#'.	self assert: tokens size = 3.	self assert: tokens third = ' #a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30306839!testFindTokensEscapedBy11	| tokens |	string := 'this, is, """a, test"'.	tokens := string findTokens: ',' escapedBy: '"'.	self assert: tokens size = 3.	self assert: tokens third = ' "a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30307129!testFindTokensEscapedBy12	| tokens |	string := 'one, two# three; four. five'.	tokens := string findTokens: ',#;.' escapedBy: '"'.	self assert: tokens size = 5.	self assert: tokens third = ' three'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30307425!testFindTokensEscapedBy13	| tokens |	string := 'one, two# three; four. five'.	tokens := string findTokens: ',#;.' escapedBy: nil.	self assert: tokens size = 5.	self assert: tokens third = ' three'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30307721!testFindTokensEscapedBy14	| tokens |	string := 'one, "two# three"; &four. five&'.	tokens := string findTokens: ',#;.' escapedBy: '"&'.	self assert: tokens size = 3.	self assert: tokens second = ' two# three'.	self assert: tokens third = ' four. five'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30308662!testFindTokensEscapedBy21	| tokens |	string := 'this, is, "a, test"'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 3! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30309119!testFindTokensEscapedBy23	| tokens |	string := 'this, is, a, test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 4! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30309361!testFindTokensEscapedBy24	| tokens |	string := 'this, is, a"," test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'testing - tokenizing' stamp: 'ul 11/15/2010 12:06' prior: 30309966!testFindTokensEscapedBy26	| tokens |	string := 'this, is, "a, test'.	tokens := string findTokens: $, escapedBy: $".	self assert: tokens size = 3.	self assert: tokens third = ' a, test'! !!StringTest methodsFor: 'test-comparing' stamp: 'ul 11/16/2010 06:36'!testMatch	#('**' '*#' 'f**' 'f*#' 'f**o' 'f*#o') do: [ :each |		self should: [ each match: 'foo' ] raise: Error ].	#('f*' '*f*' 'f#*' 'f##' '*oo' '#oo' '*o*' '#o#' '#o*' '*o#' 'fo*' 'fo#' '*foo*' '###')		do: [ :each | self assert: (each match: 'foo') ].	#('bar' 'foo#' '#foo' '*foo#' '#foo*' '*bar*') do: [ :each |		self deny: (each match: 'foo') ]! !!StringTest methodsFor: 'testing - internet' stamp: 'ul 11/16/2010 06:29'!testWithoutQuoting	#(		'"foo"' 'foo'		'''foo''' 'foo'		'"foo''' '"foo'''		'''foo"' '''foo"'		'"foo' '"foo'		'foo"' 'foo"'		'foo' 'foo') pairsDo: [ :before :after |			self assert: before withoutQuoting = after ]! !!DictionaryTest methodsFor: 'association tests' stamp: 'ul 11/15/2010 11:38' prior: 19719953!testAssociationsSelect	| answer d |	d := Dictionary new.	d at: (Array with: #hello with: #world)	  put: #fooBar.	d at: Smalltalk put: #'Smalltalk is the key'.	d at: #Smalltalk put: Smalltalk.	answer := d				associationsSelect: [:assoc | assoc key == #Smalltalk						and: [assoc value == Smalltalk]].	self		should: [answer isKindOf: Dictionary].	self		should: [answer size = 1].	self		should: [(answer at: #Smalltalk)				== Smalltalk].	answer := d				associationsSelect: [:assoc | assoc key == #NoSuchKey						and: [assoc value == #NoSuchValue]].	self		should: [answer isKindOf: Dictionary].	self		should: [answer size = 0]! !"CollectionsTests"!!MCMethodDefinition methodsFor: 'installing' stamp: 'ul 11/15/2010 11:53' prior: 54542922!scanForPreviousVersion	| sourceFilesCopy method position |	method := self actualClass compiledMethodAt: selector ifAbsent: [^ nil].	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos tokens preamble methodCategory stamp prevFileIndex |	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		methodCategory = category ifFalse:			[methodCategory = (Smalltalk 									at: #Categorizer 									ifAbsent: [Smalltalk at: #ClassOrganizer]) 										default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: className category: methodCategory meta: classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !!MCDefinition methodsFor: 'accessing' stamp: 'ul 11/7/2010 22:45'!actualClass	^nil! !!ChangeList class methodsFor: '*monticello' stamp: 'ul 11/15/2010 11:34' prior: 54915562!recentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size = 0 ifTrue: [^self recent: end on: origChangesFile].	pos := UIManager default chooseFrom: banners values: positions				title: 'Browse as far back as...'.	pos == nil		ifTrue: [^ self].	^self recent: end - pos on: origChangesFile! !!MCFileRepositoryInspector methodsFor: 'as yet unclassified' stamp: 'ul 11/8/2010 03:14' prior: 33811472!refresh	| packageNames |	packageNames := Set new.	packageList := nil.	versions := repository readableFileNames collect: [ :each | | name |		name := (each copyUpToLast: $.) copyUpTo: $(.		name last isDigit ifFalse: [Array with: name with: '' with: '' with: each]			ifTrue:				[Array					with: (packageNames add: (name copyUpToLast:  $-))		"pkg name"					with: ((name copyAfterLast: $-) copyUpTo: $.)				"user"					with: (((name copyAfterLast: $-) copyAfter: $.) asInteger ifNil: [ 0 ])	"version"					with: each]].	newer := Set new.	inherited := Set new.	loaded := Set new.	(MCWorkingCopy allManagers "		select: [ :each | packageNames includes: each packageName]")		do: [:each | | latest |			each ancestors do: [ :ancestor |				loaded add: ancestor name.				ancestor ancestorsDoWhileTrue: [:heir |					(inherited includes: heir name)						ifTrue: [false]						ifFalse: [inherited add: heir name. true]]].			latest := (versions select: [:v | v first = each package name])					detectMax: [:v | v third].			(latest notNil and: [				each ancestors allSatisfy: [:ancestor | | av |					av := ((ancestor name copyAfterLast: $-) copyAfter: $.) asInteger.					av < latest third or: [						av = latest third and: [((ancestor name copyAfterLast: $-) copyUpTo: $.) ~= latest second]]]])				ifTrue: [newer add: each package name ]].	self changed: #packageList; changed: #versionList! !"Monticello"!!CompiledMethodTrailer methodsFor: 'private' stamp: 'ul 11/15/2010 10:11' prior: 53941140!kindAsByte	| index |	index := self class trailerKinds indexOf: kind.	self assert: (index ~= 0).	^ (index - 1) << 2! !!SmallInteger methodsFor: 'arithmetic' stamp: 'ul 11/15/2010 10:12' prior: 29287428!quo: aNumber 	"Primitive. Divide the receiver by the argument and answer with the 	result. Round the result down towards zero to make it a whole integer. 	Fail if the argument is 0 or is not a SmallInteger. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 13>	aNumber = 0 ifTrue: [^ (ZeroDivide dividend: self) signal].	(aNumber isMemberOf: SmallInteger)		ifFalse: [^ super quo: aNumber].	(aNumber = -1 and: [self = self class minVal])		ifTrue: ["result is aLargeInteger" ^ self negated].	self primitiveFailed! !!Time methodsFor: 'printing' stamp: 'ul 11/15/2010 10:12' prior: 53021679!print24: hr24 showSeconds: showSeconds on: aStream 	"Format is 'hh:mm:ss' or 'h:mm:ss am'  or, if showSeconds is false, 'hh:mm' or 'h:mm am'"	| h m s |	h := self hour. m := self minute. s := self second.	hr24		ifTrue: 			[ h < 10 ifTrue: [ aStream nextPutAll: '0' ].			h printOn: aStream ]		ifFalse:			[ h > 12				ifTrue: [h - 12 printOn: aStream]				ifFalse: 					[h < 1						ifTrue: [ 12 printOn: aStream ]						ifFalse: [ h printOn: aStream ]]].	aStream nextPutAll: (m < 10 ifTrue: [':0'] ifFalse: [':']).	m printOn: aStream.	showSeconds ifTrue:		[ aStream nextPutAll: (s < 10 ifTrue: [':0'] ifFalse: [':']).		self nanoSecond = 0			ifTrue: [s asInteger printOn: aStream]			ifFalse: [(s + (self nanoSecond / NanosInSecond) asFloat) printOn: aStream]].	hr24 ifFalse:		[ aStream nextPutAll: (h < 12 ifTrue: [' am'] ifFalse: [' pm']) ].! !!Object methodsFor: 'tracing' stamp: 'ul 11/15/2010 11:22' prior: 34497264!inboundPointersExcluding: objectsToExclude"Answer a list of all objects in the system that point to me, excluding those in the collection of objectsToExclude. I do my best to avoid creating any temporary objects that point to myself, especially method and block contexts. Adapted from PointerFinder class >> #pointersTo:except:"	| anObj pointers objectsToAlwaysExclude |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	pointers := OrderedCollection new: 1000.	"#allObjectsDo: and #pointsTo: are expanded inline to keep spurious	 method and block contexts out of the results"	anObj := self someObject.	[0 == anObj] whileFalse: [ "We must use #== here, to avoid leaving the loop when anObj is another number that's equal to 0 (e.g. 0.0)."		anObj isInMemory			ifTrue: [((anObj instVarsInclude: self)				or: [anObj class == self])					ifTrue: [pointers add: anObj]].		anObj := anObj nextObject].	objectsToAlwaysExclude := {		pointers collector.		thisContext.		thisContext sender.		thisContext sender sender.		objectsToExclude.	}.	^ pointers removeAllSuchThat: [:ea |		(objectsToAlwaysExclude identityIncludes: ea)			or: [objectsToExclude identityIncludes: ea]]! !!Object methodsFor: 'objects from disk' stamp: 'ul 11/15/2010 10:12' prior: 24984337!saveOnFile	"Ask the user for a filename and save myself on a SmartReferenceStream file.  Writes out the version and class structure.  The file is fileIn-able.  Does not file out the class of the object.  tk 6/26/97 13:48"	| aFileName fileStream |	aFileName := self class name asFileName.	"do better?"	aFileName := UIManager default 				request: 'File name?' translated initialAnswer: aFileName.	aFileName size = 0 ifTrue: [^ Beeper beep].	fileStream := FileStream newFileNamed: aFileName asFileName.	fileStream fileOutClass: nil andObject: self.! !!InstructionStream methodsFor: 'testing' stamp: 'ul 11/15/2010 10:11' prior: 51447148!willReallySend	"Answer whether the next bytecode is a real message-send,	not blockCopy:."	| byte |	byte := self method at: pc.	^byte >= 131	  and: [byte ~= 200	  and: [byte >= 176   "special send or short send"		or: [byte <= 134 "long sends"				and: [| litIndex |				"long form support demands we check the selector"				litIndex := byte = 132							ifTrue: [(self method at: pc + 1) // 32 > 1 ifTrue: [^false].									self method at: pc + 2]							ifFalse: [byte = 134										ifTrue: [(self method at: pc + 1) bitAnd: 2r111111]										ifFalse: [(self method at: pc + 1) bitAnd: 2r11111]].				(self method literalAt: litIndex + 1) ~~ #blockCopy:]]]]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'jmv 3/1/2010 10:23' prior: 58145691!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."		"Note: The following is tricky and depends on the fact that the VM will not switch between processes while executing byte codes (process switches happen only in real sends). The following test is written carefully so that it will result in bytecodes only.	Do not change the following #== for #=, as #== is not a real message send, just a bytecode."	excessSignals == 0 ifTrue: [		"If we come here, then the semaphore was locked when the test executed. 		Evaluate the alternative block and answer its result."		^alternativeBlock value 	].	^self critical: mutuallyExcludedBlock! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'ul 11/6/2010 23:37' prior: 54875749!initializeOffsets	| durationSinceEpoch secondsSinceMidnight nowSecs |	LastTick := 0.	nowSecs := self clock secondsWhenClockTicks.	LastMilliSeconds := self millisecondClockValue.	durationSinceEpoch := Duration		days: SqueakEpoch		hours: 0		minutes: 0		seconds: nowSecs.	DaysSinceEpoch := durationSinceEpoch days.	secondsSinceMidnight := (durationSinceEpoch -		(Duration			days: DaysSinceEpoch			hours: 0			minutes: 0			seconds: 0)) asSeconds.	MilliSecondOffset := secondsSinceMidnight * 1000 - LastMilliSeconds! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'ul 11/6/2010 23:38' prior: 19488364!milliSecondsSinceMidnight	| msm msClock |	"This is usually only during system startup..."	self waitForOffsets.	msClock := self millisecondClockValue.	msClock < LastMilliSeconds ifTrue: [ "rolled over"		MilliSecondOffset := MilliSecondOffset + (SmallInteger maxVal // 2) + 1 ].	LastMilliSeconds := msClock.	[	msm := msClock + MilliSecondOffset.	msm >= 86400000 ] whileTrue: [		"next day"		LastTick := -1.		DaysSinceEpoch := DaysSinceEpoch + 1.		MilliSecondOffset := MilliSecondOffset - 86400000 ].	"day rolled over sanity check"	(LastTick = -1 and: [		(Duration			days: SqueakEpoch			hours: 0			minutes: 0			seconds: self clock totalSeconds) days ~= DaysSinceEpoch ]) ifTrue: [		self initializeOffsets.		^ self milliSecondsSinceMidnight ].	^ msm.! !!DateAndTime class methodsFor: 'ansi protocol' stamp: 'ul 11/6/2010 23:57' prior: 54877942!now 	| nanoTicks msm |	nanoTicks := (msm := self milliSecondsSinceMidnight) * 1000000.	(LastTick < nanoTicks) ifTrue: [		LastTick := nanoTicks.		^ self todayAtMilliSeconds: msm].	LastTickSemaphore critical: [		LastTick :=  LastTick + 1.		^ self todayAtNanoSeconds: LastTick]" [ 10000 timesRepeat: [ self now. ] ] timeToRun / 10000.0 . If calls to DateAndTime-c-#now are within a single millisecond the semaphore code to ensure that (self now <= self now) slows things down considerably by a factor of about 20.The actual speed of a single call to DateAndTime-now in milliseconds is demonstrated by the unguarded method below.[ 100000 timesRepeat: [ self todayAtMilliSeconds: (self milliSecondsSinceMidnight) ] ] timeToRun / 100000.0 .  0.00494 0.00481 0.00492 0.00495  "! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'ul 11/6/2010 23:32' prior: 19495810!startUp: resuming	resuming ifFalse: [ ^ self ].	OffsetsAreValid := false.	[		self initializeOffsets.		OffsetsAreValid := true	] forkAt: Processor userInterruptPriority.! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 10/19/2010 14:14' prior: 19491987!todayAtMilliSeconds: milliSecondsSinceMidnight	"This is usually only during system startup..."	self waitForOffsets.	 ^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (milliSecondsSinceMidnight // 1000) 			nano: (milliSecondsSinceMidnight  \\ 1000 * 1000000  ) 			offset: self localOffset	 " [ 100000 timesRepeat: [ self fromMilliSeconds: self milliSecondsSinceMidnight. ] ] timeToRun."! !!DateAndTime class methodsFor: 'squeak protocol' stamp: 'jmv 10/19/2010 14:14' prior: 19492406!todayAtNanoSeconds: nanoSecondsSinceMidnight	"This is usually only during system startup..."	self waitForOffsets.	^ self basicNew			setJdn: DaysSinceEpoch 			seconds: (nanoSecondsSinceMidnight // 1000000000) 			nano: (nanoSecondsSinceMidnight  \\ 1000000000  ) 			offset: self localOffset ! !!DateAndTime class methodsFor: 'initialize-release' stamp: 'jmv 10/19/2010 14:10'!waitForOffsets	OffsetsAreValid ifFalse: [		[			(Delay forSeconds: 1) wait.			OffsetsAreValid		] whileFalse	]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'ul 11/15/2010 10:09' prior: 54649348!commentsIn: sourceString		| commentStart nextQuotePos someComments aPos |	('*"*' match: sourceString) ifFalse: [^#()].	someComments:= OrderedCollection new.	sourceString size = 0 ifTrue: [^ someComments].	aPos:=1.	nextQuotePos:= 0.	[commentStart := sourceString findString: '"' startingAt: aPos.	nextQuotePos:= self nextQuotePosIn: sourceString startingFrom: commentStart.	(commentStart ~= 0 and: [nextQuotePos >commentStart])] whileTrue: [		commentStart ~= nextQuotePos ifTrue: [			someComments add: ((sourceString copyFrom: commentStart + 1 to: nextQuotePos - 1) copyReplaceAll: '""' with: '"').].	aPos := nextQuotePos+1].	^someComments! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'ul 11/15/2010 10:09' prior: 54680912!inspectAllInstances 	"Inpsect all instances of the receiver.  1/26/96 sw"	| all allSize prefix |	all := self allInstances.	(allSize := all size) = 0 ifTrue: [^ self inform: 'There are no instances of ', self name].	prefix := allSize = 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name)! !!Behavior methodsFor: 'accessing instances and variables' stamp: 'ul 11/15/2010 10:10' prior: 54679803!inspectSubInstances 	"Inspect all instances of the receiver and all its subclasses.  CAUTION - don't do this for something as generic as Object!!  1/26/96 sw"	| all allSize prefix |	all := self allSubInstances.	(allSize := all size) = 0 ifTrue: [^ self inform: 'There are no instances of ', self name, 'or any of its subclasses'].	prefix := allSize = 1		ifTrue: 	['The lone instance']		ifFalse:	['The ', allSize printString, ' instances'].		all asArray inspectWithLabel: (prefix, ' of ', self name, ' & its subclasses')! !!ClassDescription methodsFor: 'instance variables' stamp: 'ul 11/15/2010 10:10' prior: 54707645!instVarIndexFor: instVarName ifAbsent: aBlock	"Answer the index of the named instance variable."	| index |	index := instanceVariables == nil 				ifTrue: [0]				ifFalse: [instanceVariables indexOf: instVarName ifAbsent: [0]].	index = 0 ifTrue: 		[^superclass == nil 			ifTrue: [aBlock value]			ifFalse: [superclass instVarIndexFor: instVarName ifAbsent: aBlock]].	^superclass == nil 			ifTrue: [index]		ifFalse: [index + superclass instSize]! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ul 11/15/2010 10:11' prior: 59131686!moveClassCommentTo: aFileStream fileIndex: newFileIndex	"Called when condensing changes.  If the receiver has a class comment, and if that class comment does not reside in the .sources file, then write it to the given filestream, with the resulting RemoteString being reachable from the source file fileIndex.  Note that any existing backpointer into the .sources file is lost by this process -- a situation that maybe should be fixed someday."	| header aStamp aCommentRemoteStr |	self isMeta ifTrue: [^ self].  "bulletproofing only"	((aCommentRemoteStr := self organization commentRemoteStr) isNil or:		[aCommentRemoteStr sourceFileNumber = 1]) ifTrue: [^ self].	aFileStream cr; nextPut: $!!.	header := String streamContents: [:strm | strm nextPutAll: self name;		nextPutAll: ' commentStamp: '.		(aStamp := self organization commentStamp ifNil: ['<historical>']) storeOn: strm.		strm nextPutAll: ' prior: 0'].	aFileStream nextChunkPut: header.	aFileStream cr.	self organization classComment: (RemoteString newString: self organization classComment onFileNumber: newFileIndex toFile: aFileStream) stamp: aStamp! !!CompiledMethod methodsFor: 'printing' stamp: 'ul 11/15/2010 10:11' prior: 50740160!timeStamp	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	"(CompiledMethod compiledMethodAt: #timeStamp) timeStamp"	| file preamble stamp tokens tokenCount |	self fileIndex = 0 ifTrue: [^ String new].  "no source pointer for this method"	file := SourceFiles at: self fileIndex.	file ifNil: [^ String new].  "sources file not available"	"file does not exist happens in secure mode"	file := [file readOnlyCopy] on: FileDoesNotExistException do:[:ex| nil].	file ifNil: [^ String new].	preamble := self getPreambleFrom: file at: (0 max: self filePosition - 3).		stamp := String new.		tokens := (preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [Scanner new scanTokens: preamble]			ifFalse: [Array new  "ie cant be back ref"].		(((tokenCount := tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount - 3) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"							stamp := tokens at: tokenCount - 2]].		((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount  - 1) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokenCount]].	file close.	^ stamp! !"Kernel"!!Scanner methodsFor: 'multi-character scans' stamp: 'eem 11/16/2010 15:05' prior: 58805264!xUnderscore	self allowUnderscoreAssignments ifTrue:[ | type |		"Figure out if x _foo (no space between _ and foo) 		should be a selector or assignment"		(((type := self typeTableAt: aheadChar) == #xLetter			or:[type == #xDigit or:[type == #xUnderscore]]) 			and:[self allowUnderscoreSelectors]) ifFalse:[				self step.				tokenType := #leftArrow.				^token := #'_'		].	].	self allowUnderscoreSelectors ifTrue:[^self xLetter].	^self xIllegal! !!MessageNode methodsFor: 'printing' stamp: 'ul 11/15/2010 11:53' prior: 51633617!printToDoOn: aStream indent: level	| limitNode |	self printReceiver: receiver on: aStream indent: level.	(arguments last == nil or: [(arguments last isMemberOf: AssignmentNode) not])		ifTrue: [limitNode := arguments first]		ifFalse: [limitNode := arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key = 1]])		ifTrue: [self printKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !!MessageNode methodsFor: 'printing' stamp: 'ul 11/15/2010 11:54' prior: 51665480!printWithClosureAnalysisToDoOn: aStream indent: level	| limitNode |	self printWithClosureAnalysisReceiver: receiver on: aStream indent: level.	limitNode := (arguments last == nil				or: [arguments last isAssignmentNode not])					ifTrue: [arguments first]					ifFalse: [arguments last value].	(selector key = #to:by:do:	 and: [(arguments at: 2) isConstantNumber	 and: [(arguments at: 2) key = 1]])		ifTrue: [self printWithClosureAnalysisKeywords: #to:do:					arguments: (Array with: limitNode with: (arguments at: 3))					on: aStream indent: level]		ifFalse: [self printWithClosureAnalysisKeywords: selector key					arguments: (Array with: limitNode) , arguments allButFirst					on: aStream indent: level]! !"Compiler"!!KedamaPatchType methodsFor: 'tile protocol' stamp: 'ul 11/15/2010 11:50' prior: 22298074!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: #externalName;		target: (aTarget perform: getter) costume renderedMorph;		growable: true;		minimumWidth: 24;		putSelector: nil.	displayer stepTime: 1000.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs = 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	displayer useStringFormat.	^ aTile! !!EToyTextNode methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 11:39' prior: 20081164!addNewChildAfter: anotherOrNilOrZero	| where newNode |	anotherOrNilOrZero = 0 ifTrue: [		newNode := EToyTextNode newNode.		children := {newNode} asOrderedCollection,children.		^newNode	].	where := children indexOf: anotherOrNilOrZero ifAbsent: [children size].	children add: (newNode := EToyTextNode newNode) afterIndex: where.	^newNode! !!UserScript methodsFor: 'versions' stamp: 'ul 11/15/2010 12:09' prior: 53104263!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| result |	formerScriptEditors isEmptyOrNil ifTrue: [^Beeper beep].	result := formerScriptEditors size = 1 		ifTrue: [formerScriptEditors first]		ifFalse: 			[UIManager default 						chooseFrom: (formerScriptEditors collect: [:e | e timeStamp])						values: formerScriptEditors].	result 		ifNotNil: [self revertScriptVersionFrom: anEditor installing: result]! !!EtoysPresenter methodsFor: 'playerList' stamp: 'ul 11/15/2010 11:39' prior: 56695439!browseAllScriptsTextually	"Open a method-list browser on all the scripts in the project"	| aList aMethodList |	(aList := self uniclassesAndCounts) size = 0 ifTrue: [^ self inform: 'there are no scripted players'].	aMethodList := OrderedCollection new.	aList do:		[:aPair | aPair first addMethodReferencesTo: aMethodList].	aMethodList size > 0 ifFalse: [^ self inform: 'there are no scripts in this project!!'].		SystemNavigation new 		browseMessageList: aMethodList 		name: 'All scripts in this project' 		autoSelect: nil"ActiveWorld presenter browseAllScriptsTextually"! !!Object methodsFor: '*Etoys-viewer' stamp: 'ul 11/15/2010 11:55' prior: 56886666!infoFor: anElement inViewer: aViewer	"The user made a gesture asking for info/menu relating to me.  Some of the messages dispatched here are not yet available in this image"	| aMenu elementType |	elementType := self elementTypeFor: anElement vocabulary: aViewer currentVocabulary.	((elementType = #systemSlot) | (elementType == #userSlot))		ifTrue:	[^ self slotInfoButtonHitFor: anElement inViewer: aViewer].	self flag: #deferred.  "Use a traditional MenuMorph, and reinstate the pacify thing"	aMenu := MenuMorph new defaultTarget: aViewer.	#(	('implementors'			browseImplementorsOf:)		('senders'				browseSendersOf:)		('versions'				browseVersionsOf:)		-		('browse full'			browseMethodFull:)		('inheritance'			browseMethodInheritance:)		-		('about this method'		aboutMethod:)) do:			[:pair |				pair = '-'					ifTrue:						[aMenu addLine]					ifFalse:						[aMenu add: pair first target: aViewer selector: pair second argument: anElement]].	aMenu addLine.	aMenu defaultTarget: self.	#(	('destroy script'		removeScript:)		('rename script'		renameScript:)		('pacify script'		pacifyScript:)) do:			[:pair |				aMenu add: pair first target: self selector: pair second argument: anElement].	aMenu addLine.	aMenu  add: 'show categories....' target: aViewer selector: #showCategoriesFor: argument: anElement.	aMenu items size = 0 ifTrue:  "won't happen at the moment a/c the above"		[aMenu add: 'ok' action: nil].  "in case it was a slot -- weird, transitional"	aMenu addTitle: anElement asString, ' (', elementType, ')'.	aMenu popUpInWorld: self currentWorld. ! !!Object methodsFor: '*Etoys-viewer' stamp: 'ul 11/15/2010 11:55' prior: 56896708!uniqueNameForReference	"Answer a nice name by which the receiver can be referred to by other objects.  At present this uses a global References dictionary to hold the database of references, but in due course this will need to acquire some locality"	| aName stem knownClassVars |	(aName := self uniqueNameForReferenceOrNil) ifNotNil: [^ aName].	(stem := self knownName) ifNil:		[stem := self defaultNameStemForInstances asString].	stem := stem select: [:ch | ch isLetter or: [ch isDigit]].	stem size = 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	knownClassVars := ScriptingSystem allKnownClassVariableNames.	aName := Utilities keyLike:  stem satisfying:		[:jinaLake |			| nameSym |			nameSym := jinaLake asSymbol.			 ((References includesKey:  nameSym) not and:				[(Smalltalk includesKey: nameSym) not]) and:						[(knownClassVars includes: nameSym) not]].	References at: (aName := aName asSymbol) put: self.	^ aName! !!Object methodsFor: '*Etoys-viewer' stamp: 'ul 11/15/2010 11:55' prior: 56897794!uniqueNameForReferenceFrom: proposedName	"Answer a satisfactory symbol, similar to the proposedName but obeying the rules, to represent the receiver"	| aName stem |	proposedName = self uniqueNameForReferenceOrNil 		ifTrue: [^ proposedName].  "No change"	stem := proposedName select: [:ch | ch isLetter or: [ch isDigit]].	stem size = 0 ifTrue: [stem := 'A'].	stem first isLetter ifFalse:		[stem := 'A', stem].	stem := stem capitalized.	aName := Utilities keyLike: stem satisfying:		[:jinaLake |			| nameSym okay |			nameSym := jinaLake asSymbol.			okay := true.			(self class bindingOf: nameSym) ifNotNil: [okay := false "don't use it"].			okay].	^ aName asSymbol! !!CategoryViewer methodsFor: 'categories' stamp: 'ul 11/15/2010 11:30' prior: 50578883!chooseCategory	"The mouse went down on my category-list control; pop up a list of category choices"	| aList reply aLinePosition lineList |	aList := scriptedPlayer categoriesForViewer: self.	aLinePosition := aList indexOf: #miscellaneous ifAbsent: [nil].	aList := aList collect:			[:aCatSymbol | self currentVocabulary categoryWordingAt: aCatSymbol].	lineList := aLinePosition ifNil: [#()] ifNotNil: [Array with: aLinePosition].	aList size = 0 ifTrue: [aList add: ScriptingSystem nameForInstanceVariablesCategory translated].	reply := UIManager default 		chooseFrom: aList 		values: aList 		lines: lineList		title: 'category' translated.	reply ifNil: [^ self].	self chooseCategoryWhoseTranslatedWordingIs: reply asSymbol! !!CategoryViewer methodsFor: 'entries' stamp: 'ul 11/15/2010 11:31' prior: 18089413!phraseForCommandFrom: aMethodInterface	"Answer a phrase for the non-slot-like command represented by aMethodInterface - classic tiles"	| aRow resultType cmd names argType argTile selfTile aPhrase balloonTextSelector stat inst aDocString universal tileBearingHelp |	aDocString := aMethodInterface documentation.	aDocString = 'no help available' ifTrue: [aDocString := nil].	names := scriptedPlayer class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := scriptedPlayer isUniversalTiles)		ifTrue:			[aPhrase := scriptedPlayer universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs = 0			ifTrue:				[aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				aPhrase setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new vocabulary: self currentVocabulary.				(self isSpecialPatchReceiver: scriptedPlayer and: cmd) ifTrue: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Patch						argType: argType.				] ifFalse: [					aPhrase setOperator: cmd						type: resultType						rcvrType: #Player						argType: argType.				].				(self isSpecialPatchCase: scriptedPlayer and: cmd) ifTrue: [					argTile := (Vocabulary vocabularyForType: argType) defaultArgumentTileFor: scriptedPlayer.				] ifFalse: [					argTile := ScriptingSystem tileForArgType: argType.				].				(#(bounce: wrap:) includes: cmd) ifTrue:					["help for the embattled bj"					argTile setLiteral: 'silence'; updateLiteralLabel].				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(scriptedPlayer slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(scriptedPlayer belongsToUniClass and: [scriptedPlayer class includesSelector: cmd])		ifTrue:			[aDocString ifNil:				[aDocString := (scriptedPlayer class userScriptForPlayer: scriptedPlayer selector: cmd) documentation].			aDocString ifNil:				[balloonTextSelector := #userScript]].	tileBearingHelp := universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]. 	aDocString		ifNotNil:			[tileBearingHelp setBalloonText: aDocString]		ifNil:			[balloonTextSelector ifNil:				[tileBearingHelp setProperty: #inherentSelector toValue: cmd.				balloonTextSelector := #methodComment].			tileBearingHelp balloonTextSelector: balloonTextSelector].	aPhrase markAsPartsDonor.	cmd == #emptyScript ifTrue:		[aPhrase setProperty: #newPermanentScript toValue: true.		aPhrase setProperty: #newPermanentPlayer toValue: scriptedPlayer.		aPhrase submorphs second setBalloonText: 'drag and drop to add a new script' translated].	universal ifFalse:		[selfTile := self tileForSelf.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile].	aRow := ViewerLine newRow borderWidth: 0; color: self color.	aRow elementSymbol: cmd asSymbol.	aRow addMorphBack: (ScriptingSystem tryButtonFor: aPhrase).	aRow addMorphBack: (Morph new extent: 2@2; beTransparent).	aRow addMorphBack: (self infoButtonFor: cmd).	aRow addMorphBack: aPhrase.	aPhrase on: #mouseEnter send: #addCommandFeedback to: aRow.	aPhrase on: #mouseLeave send: #removeHighlightFeedback to: aRow.	aPhrase on: #mouseLeaveDragging send: #removeHighlightFeedback to: aRow.	(names includes: cmd) ifTrue:		[aPhrase userScriptSelector: cmd.		cmd numArgs = 0 ifTrue:			[aPhrase beTransparent.			aRow addMorphBack: AlignmentMorph newVariableTransparentSpacer.			aRow addMorphBack: (stat := (inst := scriptedPlayer scriptInstantiationForSelector: cmd) statusControlMorph).			inst updateStatusMorph: stat]].	aRow beSticky; disableDragNDrop.	^ aRow! !!StackMorph methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 12:05' prior: 52644824!insertCardOfBackground	"Prompt the user for choice of a background, and insert a new card of that background"	| bgs aBackground |	(bgs := self backgrounds) size = 1 ifTrue:		[self inform: 'At this time, there IS only one kind ofbackground in this stack, so that''swhat you''ll get' translated.		^ self insertCard].	aBackground := UIManager default		chooseFrom: (bgs collect: [:bg | bg externalName])		values: bgs.	aBackground ifNotNil:		[self insertCardOfBackground: aBackground]! !!UniclassScript methodsFor: 'script editor' stamp: 'ul 11/15/2010 12:09' prior: 32723171!instantiatedScriptEditorForPlayer: aPlayer	"Return the current script editor, creating it if necessary"	currentScriptEditor ifNil:		[currentScriptEditor := (self playerClass includesSelector: selector) 			ifTrue:				[Preferences universalTiles					ifFalse:						[self error: 'duplicate selector'].				ScriptEditorMorph new fromExistingMethod: selector forPlayer: aPlayer]			ifFalse:				[ScriptEditorMorph new setMorph: aPlayer costume scriptName: selector].		(defaultStatus == #ticking and: [selector numArgs = 0]) ifTrue:			[aPlayer costume arrangeToStartStepping]].		^ currentScriptEditor! !!UniclassScript methodsFor: 'versions' stamp: 'ul 11/15/2010 12:09' prior: 53077648!revertScriptVersionFrom: anEditor 	"Let user choose which prior tile version to revert to, and revert to it"	| chosenStampAndTileList |	formerScriptingTiles isEmptyOrNil ifTrue: [^Beeper beep].	chosenStampAndTileList := formerScriptingTiles size = 1 		ifTrue: [ formerScriptingTiles first]		ifFalse: 			[UIManager default 						chooseFrom: (formerScriptingTiles collect: [:e | e first])						values: formerScriptingTiles].	chosenStampAndTileList ifNotNil: 			[anEditor reinsertSavedTiles: chosenStampAndTileList second.			isTextuallyCoded := false]! !!ScriptEditorMorph methodsFor: 'buttons' stamp: 'ul 11/15/2010 12:02' prior: 56830327!updateStatus	"Update that status in the receiver's header.  "	(self topEditor == self and: [firstTileRow ~= 1]) ifTrue:		[(submorphs size = 0 or: [(self firstSubmorph findA: ScriptStatusControl) isNil])			ifTrue:				[self replaceRow1].		self updateStatusMorph: (self firstSubmorph findA: ScriptStatusControl)]! !!Inspector methodsFor: '*Etoys-menu commands' stamp: 'ul 11/15/2010 11:44' prior: 58350804!tearOffTile	"Tear off a tile that refers to the receiver's selection, and place it in the mophic hand"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	self currentHand attachMorph: (TileMorph new referTo: objectToRepresent)	! !!Player class methodsFor: 'user-scripted subclasses' stamp: 'ul 11/15/2010 11:58' prior: 26278546!addDocumentationForScriptsTo: aStream	"Add documentation for every script in the receiver to the stream"	self scripts do:		[:aScript |			aScript selector ifNotNil:				[aStream cr; cr.				aStream nextPutAll: self typicalInstanceName, '.'.				self printMethodChunk: aScript selector withPreamble: false on: aStream moveSource: false toFile: nil.				aStream position: (aStream position - 2)]].	self scripts size = 0 ifTrue:		[aStream cr; tab; nextPutAll: 'has no scripts']! !!Player class methodsFor: 'scripts' stamp: 'ul 11/15/2010 11:58' prior: 54920387!namedUnaryTileScriptSelectors	"Answer a list of all the selectors of named unary tile scripts"		scripts ifNil: [^ OrderedCollection new].	^ scripts select: [:aScript | | sel | (sel := aScript selector) notNil and: [sel numArgs = 0]] 		thenCollect: [:aScript | aScript selector]! !!Player class methodsFor: 'housekeeping' stamp: 'ul 11/15/2010 11:58' prior: 57365214!playersWithUnnecessarySubclasses	"Return a list of all players whose scripts dictionaries contain entries with nil selectors"	"Player playersWithUnnecessarySubclasses size"	^ self withAllSubclasses select:		[:p | p class isSystemDefined not and: [p scripts size = 0 and: [p instVarNames size = 0]]] ! !!Player methodsFor: 'slots-user' stamp: 'ul 11/15/2010 11:56' prior: 52155201!addInstanceVariable	"Offer the user the opportunity to add an instance variable, and if he goes through with it, actually add it."	| itsName initialValue typeChosen usedNames initialAnswer setterSelector originalString |	usedNames := self class instVarNames.	initialAnswer := Utilities keyLike: ('var' translated, (usedNames size + 1) asString)  satisfying: [:aKey | (usedNames includes: aKey) not].	originalString := UIManager default request: 'name for new variable: ' translated initialAnswer: initialAnswer.	originalString isEmptyOrNil ifTrue: [^ self].	itsName := ScriptingSystem acceptableSlotNameFrom: originalString forSlotCurrentlyNamed: nil asSlotNameIn: self world: self costume world. 	itsName size = 0 ifTrue: [^ self].		self assureUniClass.	typeChosen := self initialTypeForSlotNamed: itsName.	self slotInfo at: itsName put: (SlotInformation new initialize type: typeChosen).	initialValue := self initialValueForSlotOfType: typeChosen.	self addInstanceVarNamed: itsName withValue: initialValue.	self compileInstVarAccessorsFor: itsName.	setterSelector := Utilities setterSelectorFor: itsName.	((self class allSubInstances copyWithout: self) reject: [:e | e isSequentialStub]) do:		[:anInstance | anInstance perform: setterSelector with: initialValue].	self updateAllViewersAndForceToShow: ScriptingSystem nameForInstanceVariablesCategory! !!Player methodsFor: 'slots-user' stamp: 'ul 11/15/2010 11:56' prior: 52160958!chooseUserSlot	| names result |	(names := self slotNames) size = 1		ifTrue: [^ names first].	result := UIManager default 		chooseFrom: names 		values: names 		title: 'Please choose a variable'.	result isEmptyOrNil ifTrue: [^ nil].	^ result! !!Player methodsFor: 'scripts-kernel' stamp: 'ul 11/15/2010 11:57' prior: 53347049!newTextualScriptorFor: aSelector	"Sprout a scriptor for aSelector, opening up in textual mode.  Rather special-purpose, consult my lone sender"	| aMethodWithInterface aScriptEditor |	(self class includesSelector: aSelector) ifTrue: [self error: 'selector already exists'].	aMethodWithInterface := self class permanentUserScriptFor: aSelector player: self.	aScriptEditor := aMethodWithInterface instantiatedScriptEditorForPlayer: self.	aScriptEditor install.	aScriptEditor showSourceInScriptor.	aMethodWithInterface selector numArgs = 0 ifTrue:		[self class allSubInstancesDo: [:anInst | anInst scriptInstantiationForSelector: aMethodWithInterface selector]].		"The above assures the presence of a ScriptInstantiation for the new selector in all siblings"	self updateAllViewersAndForceToShow: #scripts.	^ aScriptEditor! !!Player methodsFor: 'misc' stamp: 'ul 11/15/2010 11:57' prior: 26104850!offerAlternateViewerMenuFor: aViewer event: evt	"Put up an alternate Viewer menu on behalf of the receiver."	| aMenu aWorld  |	aWorld := aViewer world.	aMenu := MenuMorph new defaultTarget: self.	costumes ifNotNil:		[(costumes size > 1 or: [costumes size = 1 and: [costumes first ~~ costume renderedMorph]])			ifTrue:				[aMenu add: 'forget other costumes' translated target: self selector: #forgetOtherCostumes]].	aMenu add: 'expunge empty scripts' translated target: self action: #expungeEmptyScripts.	aMenu addLine.	aMenu add: 'choose vocabulary...' translated target: aViewer action: #chooseVocabulary.	aMenu balloonTextForLastItem: 'Choose a different vocabulary for this Viewer.' translated.	aMenu add: 'choose limit class...' translated target: aViewer action: #chooseLimitClass.	aMenu balloonTextForLastItem: 'Specify what the limitClass should be for this Viewer -- i.e., the most generic class whose methods and categories should be considered here.' translated.	aMenu add: 'open standard lexicon' translated target: aViewer action: #openLexicon.	aMenu balloonTextForLastItem: 'open a window that shows the code for this object in traditional programmer format' translated.	aMenu add: 'open lexicon with search pane' translated target: aViewer action: #openSearchingProtocolBrowser.	aMenu balloonTextForLastItem: 'open a lexicon that has a type-in pane for search (not recommended!!)' translated.	aMenu addLine.	aMenu add: 'inspect morph' translated target: costume selector: #inspect.	aMenu add: 'inspect player' translated target: self selector: #inspect.	self belongsToUniClass ifTrue:		[aMenu add: 'browse class' translated target: self action: #browsePlayerClass.		aMenu add: 'inspect class' translated target: self class action: #inspect].	aMenu add: 'inspect this Viewer' translated target: aViewer selector: #inspect.	aMenu add: 'inspect this Vocabulary' translated target: aViewer currentVocabulary selector: #inspect.	aMenu addLine.	aMenu add: 'relaunch this Viewer' translated target: aViewer action: #relaunchViewer.	aMenu add: 'attempt repairs' translated target: ActiveWorld action: #attemptCleanup.	aMenu add: 'view morph directly' translated target: aViewer action: #viewMorphDirectly.	aMenu balloonTextForLastItem: 'opens a Viewer directly on the rendered morph.' translated.	(costume renderedMorph isSketchMorph) ifTrue:		[aMenu addLine.		aMenu add: 'impart scripts to...' translated target: self action: #impartSketchScripts].	aMenu popUpEvent: evt in: aWorld! !!Player methodsFor: 'scripts-kernel' stamp: 'ul 11/15/2010 11:57' prior: 54488406!renameScript: oldSelector newSelector: newSelector	"Rename the given script to have the new selector"	| aUserScript anInstantiation |	oldSelector = newSelector ifTrue: [^ self].	oldSelector numArgs = 0		ifTrue:			[self class allSubInstancesDo:				[:aPlayer | | itsCostume aDict |					anInstantiation := aPlayer scriptInstantiationForSelector: oldSelector.					anInstantiation ifNotNil: [						newSelector numArgs = 0							ifTrue:								[anInstantiation changeSelectorTo: newSelector].						aDict := aPlayer costume actorState instantiatedUserScriptsDictionary.						itsCostume := aPlayer costume renderedMorph.						itsCostume renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						self currentWorld renameScriptActionsFor: aPlayer from: oldSelector to: newSelector.						aDict removeKey: oldSelector.						newSelector numArgs  = 0 ifTrue:							[aDict at: newSelector put: anInstantiation.							anInstantiation assureEventHandlerRepresentsStatus]]]]		ifFalse:			[newSelector numArgs = 0 ifTrue:				[self class allSubInstancesDo:					[:aPlayer |						anInstantiation := aPlayer scriptInstantiationForSelector: newSelector.						anInstantiation ifNotNil: [anInstantiation assureEventHandlerRepresentsStatus]]]].	aUserScript := self class userScriptForPlayer: self selector: oldSelector.	aUserScript renameScript: newSelector fromPlayer: self.		"updates all script editors, and inserts the new script in my scripts directory"	self class removeScriptNamed: oldSelector.	((self existingScriptInstantiationForSelector: newSelector) notNil and:		[newSelector numArgs > 0]) ifTrue: [self error: 'ouch'].			self updateAllViewersAndForceToShow: 'scripts'! !!Player methodsFor: 'slots-user' stamp: 'ul 11/16/2010 03:58' prior: 54491322!setPrecisionFor: slotName 	"Set the precision for the given slot name"	| aList reply aGetter places |	aGetter := Utilities getterSelectorFor: slotName.	places := Utilities 				decimalPlacesForFloatPrecision: (self defaultFloatPrecisionFor: aGetter).	aList := #('0' '1' '2' '3' '4' '5' '6').	reply := UIManager default		chooseFrom: aList		values: (aList collect: [:m | m asNumber])		title: ('How many decimal places? (currently {1})' translated						format: {places}).	reply ifNotNil: 			[(self slotInfo includesKey: slotName) 				ifTrue: 					["it's a user slot"					(self slotInfoAt: slotName) 						floatPrecision: (Utilities floatPrecisionForDecimalPlaces: reply).					self class allInstancesDo: 							[:anInst | | val | 							reply = 0 								ifFalse: 									[((val := anInst instVarNamed: slotName asString) isInteger) 										ifTrue: [anInst instVarNamed: slotName asString put: val asFloat]].							anInst updateAllViewers]]				ifFalse: 					["it's specifying a preference for precision on a system-defined numeric slot"					self noteDecimalPlaces: reply forGetter: aGetter.					self updateAllViewers]]! !!Player methodsFor: 'scripts-kernel' stamp: 'ul 11/15/2010 11:58' prior: 26146694!tilesToCall: aMethodInterface	"Answer a phrase for the non-typed command represented by aMethodInterface."	| resultType cmd argType argTile selfTile aPhrase balloonTextSelector aDocString universal |	self class namedTileScriptSelectors.	resultType := aMethodInterface resultType.	cmd := aMethodInterface selector.	(universal := self isUniversalTiles)		ifTrue:			[aPhrase := self universalTilesForInterface: aMethodInterface]		ifFalse: [cmd numArgs = 0			ifTrue:				[aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player]			ifFalse:				["only one arg supported in classic tiles, so if this is fed				with a selector with > 1 arg, results will be very strange"				argType := aMethodInterface typeForArgumentNumber: 1.				aPhrase := PhraseTileMorph new setOperator: cmd					type: resultType					rcvrType: #Player					argType: argType.				argTile := ScriptingSystem tileForArgType: argType.				argTile position: aPhrase lastSubmorph position.				aPhrase lastSubmorph addMorph: argTile]].	(self slotInfo includesKey: cmd)		ifTrue: [balloonTextSelector := #userSlot].	(self belongsToUniClass and: [self class includesSelector: cmd])		ifTrue:			[aDocString := (self class userScriptForPlayer: self selector: cmd) documentation.			aDocString				ifNotNil: [aPhrase submorphs second setBalloonText: aDocString]				ifNil: [balloonTextSelector := #userScript]].	(universal ifTrue: [aPhrase submorphs second] ifFalse: [aPhrase operatorTile]) balloonTextSelector: 			(balloonTextSelector ifNil: [cmd]).	universal ifFalse:		[selfTile := self tileToRefer.		selfTile position: aPhrase firstSubmorph position.		aPhrase firstSubmorph addMorph: selfTile.		aPhrase makeAllTilesGreen.		aPhrase justGrabbedFromViewer: false].	^ aPhrase! !!DataType methodsFor: '*Etoys-tiles' stamp: 'ul 11/15/2010 11:38' prior: 58395550!updatingTileForTarget: aTarget partName: partName getter: getter setter: setter	"Answer, for classic tiles, an updating readout tile for a part with the receiver's type, with the given getter and setter"	| aTile displayer actualSetter |	actualSetter := setter ifNotNil:		[(#(none #nil unused) includes: setter) ifTrue: [nil] ifFalse: [setter]].	aTile := self newReadoutTile.	displayer := UpdatingStringMorph new		getSelector: getter;		target: aTarget;		growable: true;		minimumWidth: 24;		putSelector: actualSetter.	"Note that when typeSymbol = #number, the #target: call above will have dealt with floatPrecision details"	self setFormatForDisplayer: displayer.	aTile addMorphBack: displayer.	(actualSetter notNil and: [self wantsArrowsOnTiles]) ifTrue: [aTile addArrows].		getter numArgs = 0 ifTrue:		[aTile setLiteralInitially: (aTarget perform: getter)].	^ aTile! !"EToys"!!XBMReadWriter methodsFor: 'private' stamp: 'ul 11/15/2010 10:03' prior: 33913983!readHeader	"Set width and height, and position stream at start of bytes"	| number setwidth setheight fieldName |	setwidth := setheight := false.		[((stream atEnd) or: [setwidth and: [setheight]])]		whileFalse: [	  	self skipCComments.		(stream nextMatchAll: '#define ') ifFalse: [^ false].		(stream skipTo: $_) ifFalse: [^ false].		fieldName := String streamContents:			[:source |			[(stream atEnd) or: [ stream peek isSeparator ]]				whileFalse: [ source nextPut: stream next]].	  	(fieldName = 'width') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setwidth := true].	  		width := number.].		(fieldName = 'height') ifTrue: [			stream skipSeparators.			number := Integer readFrom: stream.			(number > 0) ifTrue: [setheight := true].			height := number.			].		].	(setwidth & setheight) ifFalse: [^ false].	^ stream skipTo: ${! !!AbstractFont methodsFor: 'measuring' stamp: 'ul 11/15/2010 11:17' prior: 33526411!approxWidthOfText: aText"Return the width of aText -- quickly, and a little bit dirty. Used by lists morphs containing Text objects to get a quick, fairly accurate measure of the width of a list item."    | w |        (aText isNil or: [aText size = 0 ])        ifTrue:[^0].           w := self        widthOfString: aText asString.     "If the text has no emphasis, just return the string size.  If it is empasized,     just approximate the width by adding about 20% to the width"       (((aText runLengthFor: 1) = aText size)        and: [(aText emphasisAt: 1) = 0 ])            ifTrue:[^w]            ifFalse:[ ^w * 6 // 5 ]. ! !!Quadrangle methodsFor: 'displaying-generic' stamp: 'ul 11/16/2010 04:50' prior: 27454089!displayOn: aDisplayMedium	"Display the border and insideRegion of the receiver."	borderWidth ~= 0 ifTrue: [		aDisplayMedium			border: self region			widthRectangle: borderWidth			rule: Form over			fillColor: borderColor ].	insideColor ifNotNil: [		aDisplayMedium fill: self inside fillColor: insideColor ]! !!Quadrangle methodsFor: 'displaying-generic' stamp: 'ul 11/16/2010 04:50' prior: 52252676!displayOn: aDisplayMedium transformation: aWindowingTransformation clippingBox: aRectangle	"Display the border and region of the receiver so that it is scaled and 	translated with respect to aWindowingTransformation. The displayed 	information should be clipped so that only information with the area 	determined by aRectangle is displayed."	| screenRectangle |	screenRectangle := 		(aWindowingTransformation applyTo: self) intersect: aRectangle.	(borderWidth ~= 0 and: [ insideColor notNil ])		ifTrue: 			[aDisplayMedium fill: screenRectangle fillColor: Color black "borderColor".			aDisplayMedium				fill: (screenRectangle insetBy: borderWidth)				fillColor: insideColor]! !!BitBlt methodsFor: 'private' stamp: 'mt 11/10/2010 16:12' prior: 53186390!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth targetColor |	sourceForm ifNotNil:[lastSourceDepth := sourceForm depth].	sourceForm := aStrikeFont glyphs.	"Ignore any halftone pattern since we use a color map approach here"	halftoneForm := nil.	sourceY := 0.	height := aStrikeFont height.	sourceForm depth = 1 ifTrue: [		self combinationRule: Form paint.		(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse: [			"Set up color map for a different source depth (color font)"			"Uses caching for reasonable efficiency"			colorMap := self cachedFontColormapFrom: sourceForm depth to: destForm depth.			colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).	]	ifFalse: [		(Preferences subPixelRenderFonts and: [ foregroundColor = Color black or: [ Preferences subPixelRenderColorFonts ]]) ifTrue: [			destForm depth > 8 ifTrue: [				"Only force #rgbMul if color is not translucent for better result quality. Alpha values are ignored with #rgbMul."				foregroundColor isTranslucent					ifFalse: [self combinationRule: Form rgbMul].				colorMap := (destForm depth = 32 or: [ (foregroundColor = Color black) not ]) ifTrue: [					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)					See #displayString:from:to:at:strikeFont:kern:"					"Note: In 32bpp we always need the second pass, as the source could have transparent pixels, and we need to add to the alpha channel"					self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]]			ifFalse: [				self combinationRule: 25.		"Paint"				targetColor := foregroundColor = Color black ifFalse: [ foregroundColor ].				colorMap := self colorConvertingMap: targetColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]		]		ifFalse: [			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"			self combinationRule: (destForm depth = 32 ifTrue: [34 "alphaBlendScaled"] ifFalse: [25 "Paint"]).			colorMap := self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: false		]	].! !!Color class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 11:35' prior: 18924012!fromArray: colorDef	colorDef size = 3			ifTrue: [^self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)].	colorDef size = 0			ifTrue: [^Color transparent].	colorDef size = 4			ifTrue: [^(TranslucentColor r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)) alpha: (colorDef at: 4)].	self error: 'Undefined color definition'! !"Graphics"!!InstallerUpdateStream methodsFor: 'updates' stamp: 'ul 11/15/2010 11:44' prior: 57652748!loadUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Installer new loadUpdatesFromDiskToUpdateNumber: 100020 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."		"apparently does not use the updatelist too bad!! and to rewrite - sd 7 March 2008"	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory := self updateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest := SystemVersion current highestUpdate.	currentUpdateNumber := previousHighest.	done := false.	loaded := 0.	[done]		whileFalse: [currentUpdateNumber := currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done := true]				ifFalse: [fileNames := updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size = 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done := stopIfGapFlag]						ifFalse: [ChangeSet								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded := loaded + 1]]].	aMessage := loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !"Installer-Core"!!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:52' prior: 51544057!testDenormalizedPrintString	"Check that an un-normalized instance behaves reasonably."	| i i0 |	i := LargePositiveInteger new: 4.	i basicAt: 2 put: 255.	self assert: i size = 4.	self assert: i printString = '65280'.	"256*255"	self assert: i normalize = 65280.	self assert: (i normalize isMemberOf: SmallInteger).		i0 := LargePositiveInteger new: 0.	self assert: i0 size = 0.	self assert: i0 printString = '0'.	self assert: i0 normalize = 0.	self assert: (i0 normalize isMemberOf: SmallInteger)! !!LargePositiveIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:52' prior: 51543762!testEmptyTemplate	"Check that an uninitialized instance behaves reasonably."	| i |	i := LargePositiveInteger new: 4.	self assert: i size = 4.	self assert: i printString = '0'.	self assert: i normalize = 0.	self assert: (i normalize isMemberOf: SmallInteger)! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'ul 11/16/2010 04:55' prior: 58114788!testIntegerFromString	"This covers parsing in Number>>readFrom:	Trailing decimal points should be ignored."	#(		('123' isInteger 123)		('-123' isInteger -123)		('123.' isFloat 123)		('-123.' isFloat -123)		('123This is not to be read' isInteger 123)		('123s could be confused with a ScaledDecimal' isInteger 123)		('123e could be confused with a Float' isInteger 123)) do: [ :each |			[ :string :typeSelector :numericValue |				| result |				result := string asNumber.				self assert: (result perform: typeSelector).				self assert: result = numericValue ] valueWithArguments: each ]! !!NumberParsingTest methodsFor: 'tests - Integer' stamp: 'ul 11/16/2010 04:53' prior: 58115453!testIntegerReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i = 123.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123sA has unary message sA'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 'sA has unary message sA' = s.		rs := ReadStream on: '123sB has unary message sB'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ])..	s := rs upToEnd.	self assert: 'sB has unary message sB' = s.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52407706!testAsNumber	"Ensure no loss of precision"	| sd |	sd := '1.40s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '1.40s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52404882!testAsNumberNegatedWithoutDecimalPoint	| sd |	sd := '-123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 0.	self assert: '-123s0' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52406201!testAsNumberNegatedWithoutDecimalPoint2	| sd |	sd := '-123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '-123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52405669!testAsNumberWithExtendedScale	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52405935!testAsNumberWithRadix	| sd |	sd := '10r-22.2s5' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 5.	self assert: '-22.20000s5' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52404070!testAsNumberWithSuperfluousDecimalPoint	| sd |	sd := '123.s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52404348!testAsNumberWithoutDecimalPoint	| sd |	sd := '123s0' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 0.	self assert: '123s0' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52404613!testAsNumberWithoutDecimalPoint2	| sd |	sd := '123s2' asNumber.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '123.00s2' = sd printString.! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52406479!testConvertFromFloat	| aFloat sd f2 diff |	aFloat := 11/13 asFloat.	sd := aFloat asScaledDecimal: 2.	self assert: 2 = sd scale.	self assert: '0.84s2' = sd printString.	f2 := sd asFloat.	diff := f2 - aFloat.	self assert: diff < 1.0e-9. "actually, f = f2, but this is not a requirement"! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 57970935!testConvertFromFractionWithScale	| sd |	sd := (13 / 11) asScaledDecimal: 6.	self assert: ScaledDecimal == sd class.	self assert: ('1.181818s6' = sd printString).	self assert: 6 = sd scale! !!ScaledDecimalTest methodsFor: 'tests' stamp: 'ul 11/15/2010 12:02' prior: 52406863!testLiteral	| sd |	sd := 1.40s2.	self assert: ScaledDecimal == sd class.	self assert: sd scale = 2.	self assert: '1.40s2' = sd printString! !!LargeNegativeIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:51' prior: 51538729!testDenormalizedPrintString	"Check that an un-normalized instance behaves reasonably."	| i i0 |	i := LargeNegativeInteger new: 4.	i basicAt: 2 put: 255.	self assert: i size = 4.	self assert: i printString = '-65280'.	"-256*255"	self assert: i normalize = -65280.	self assert: (i normalize isMemberOf: SmallInteger).		i0 := LargeNegativeInteger new: 0.	self assert: i0 size = 0.	self assert: i0 printString = '-0'.	self assert: i0 normalize = 0.	self assert: (i0 normalize isMemberOf: SmallInteger)! !!LargeNegativeIntegerTest methodsFor: 'tests' stamp: 'ul 11/15/2010 11:52' prior: 22502848!testEmptyTemplate	"Check that an uninitialized instance behaves reasonably."	| i |	i := LargeNegativeInteger new: 4.	self assert: i size = 4.	self assert: i printString = '-0'.	self assert: i normalize = 0.	self assert: (i normalize isMemberOf: SmallInteger)! !!MethodContextTest methodsFor: 'private' stamp: 'ul 11/15/2010 11:54' prior: 34253124!privRestartTest	"This tests may loop endlessly if incorrect, so call it from another method testing it does not time out"	|a firstTimeThrough |	firstTimeThrough := true.	a := 10.		self assert: 30 equals: [|b| 		self assert: 10 = a .		self assert: nil == b.		b := a + 20. 		firstTimeThrough ifTrue: [			firstTimeThrough := false.			thisContext restart.].		b] value! !!SqNumberParserTest methodsFor: 'tests - Integer' stamp: 'ul 11/16/2010 04:56' prior: 29672461!testIntegerReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := SqNumberParser parse: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.	rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := SqNumberParser parse: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: '.s could be confused with a ScaledDecimal' = s! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'ul 11/15/2010 11:44' prior: 58116404!testReadFrom	"Ensure remaining characters in a stream are not lost when parsing an integer."	| rs i s |	rs := ReadStream on: '123s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: (i isInteger and: [ i = 123 ]).	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s.		rs := ReadStream on: '123.s could be confused with a ScaledDecimal'.	i := Number readFrom: rs.	self assert: i = 123.0.	s := rs upToEnd.	self assert: 's could be confused with a ScaledDecimal' = s! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'ul 11/15/2010 11:49' prior: 58117018!testStringAsNumber	"This covers parsing in Number>>readFrom:	Trailing decimal points should be ignored."	#(		('123' isInteger 123)		('-123' isInteger -123)		('123.' isFloat 123)		('-123.' isFloat -123)		('123This is not to be read' isInteger 123)		('123s could be confused with a ScaledDecimal' isInteger 123)		('123e could be confused with a Float' isInteger 123)) do: [ :each |			[ :string :typeSelector :numericValue |				| result |				result := string asNumber.				self assert: (result perform: typeSelector).				self assert: result = numericValue ] valueWithArguments: each ]! !"KernelTests"!!SmartRefStream methodsFor: 'read write' stamp: 'ul 11/16/2010 04:41' prior: 56903559!restoreClassInstVars	"Install the values of the class instance variables of UniClasses(i.e. scripts slotInfo).  classInstVars is ((#Player25 scripts slotInfo)...).  Thank you Mark Wai for the bug fix."	| normal trans classPlayer |	self flag: #bobconv.		classPlayer := Smalltalk at: #Player ifAbsent:[^self].	self moreObjects ifFalse: [^ self]. 	"are no UniClasses with class inst vars"	classInstVars := super next.	"Array of arrays"	normal := Object class instSize.	"might give trouble if Player class superclass changes size"	(structures at: #Player ifAbsent: [#()]) = #(0 'dependents' 'costume') ifTrue:		[trans := 1].	"now (0 costume costumes).  Do the conversion of Player class			inst vars in Update 509."	classInstVars do: [:list | | aName newCls rList newName start |		aName := (list at: 1) asSymbol.		rList := list.		newName := renamed at: aName ifAbsent: [aName].		newCls := Smalltalk at: newName				ifAbsent: [self error: 'UniClass definition missing'].		("old conversion" trans = 1 and: [newCls inheritsFrom: classPlayer]) ifTrue: [			"remove costumeDictionary from Player class inst vars"			rList := rList asOrderedCollection.			rList removeAt: 4].	"costumeDictionary's value"		start := list second = 'Update to read classPool' ifTrue: [4] ifFalse: [2].		newCls class instSize = (normal + (rList size) - start + 1) ifFalse:			[self error: 'UniClass superclass class has changed size'].			"Need to install a conversion method mechanism"		start = 4 ifTrue: [newCls instVarAt: normal - 1 "classPool" put: (list at: 3)].		start to: rList size do: [:ii |			newCls instVarAt: normal + ii - start + 1 put: (rList at: ii)]].! !!Preferences class methodsFor: 'fonts' stamp: 'ul 11/11/2010 22:58' prior: 59046696!restoreDefaultFonts	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	"	Preferences restoreDefaultFonts	"	self setDefaultFonts: #(		(setSystemFontTo:			'Bitmap DejaVu Sans'		9)		(setListFontTo:				'Bitmap DejaVu Sans'		9)		(setFlapsFontTo:			Accushi						12)		(setEToysFontTo:			BitstreamVeraSansBold		9)		(setPaintBoxButtonFontTo:	BitstreamVeraSansBold		9)		(setMenuFontTo:			'Bitmap DejaVu Sans'		9)		(setWindowTitleFontTo:		'Bitmap DejaVu Sans Bold'	9)		(setBalloonHelpFontTo:		Accujen						9)		(setCodeFontTo:			'Bitmap DejaVu Sans'		9)		(setButtonFontTo:			'Bitmap DejaVu Sans'	7)	)! !!ReferenceStream methodsFor: 'writing' stamp: 'ul 11/15/2010 12:00' prior: 27612226!isAReferenceType: typeID	"Return true iff typeID is one of the classes that can be written as a reference to an instance elsewhere in the stream."	"too bad we can't put Booleans in an Array literal"	^ (RefTypes at: typeID) = 1		"NOTE: If you get a bounds error here, the file probably has bad bits in it.  The most common cause is a file unpacking program that puts linefeeds after carriage returns."! !!ClassDiffBuilder methodsFor: 'private' stamp: 'ul 11/4/2010 22:33' prior: 34747317!print: aString withAttributes: attributes on: stream	stream		currentAttributes: attributes;		nextPutAll: aString! !!ClassDiffBuilder methodsFor: 'private' stamp: 'ul 11/16/2010 06:08' prior: 34747525!split: aString	"I return an array with aString splitted by whitespace ' and ""."	^Array streamContents: [ :stream |		| input separators |		input := aString readStream.		separators := CharacterSet separators			add: $'; "for variables"			add: $"; "for comments in mc"			yourself.		[ input atEnd ] whileFalse: [			| word separator |			word := input				upToAnyOf: separators				do: [ :matchingSeparator |					separator := matchingSeparator ].			stream nextPut: word.			separator ifNotNil: [				stream nextPut: separator asString ] ] ]! !!DataStream methodsFor: 'write and read' stamp: 'ul 11/15/2010 11:38' prior: 50851754!next	"Answer the next object in the stream."	| type selector anObject isARefType pos internalObject |	type := byteStream next.	type ifNil: [pos := byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		byteStream position = 0 			ifTrue: [self error: 'The file did not exist in this directory'] 			ifFalse: [self error: 'Unexpected end of object file'].		pos.	"so can see it in debugger"		^ nil].	type = 0 ifTrue: [pos := byteStream position.	"absolute!!!!"		byteStream close.	"clean up"		self error: 'Expected start of object, but found 0'.		^ nil].	isARefType := self noteCurrentReference: type.	selector := #(readNil readTrue readFalse readInteger	"<-4"			readStringOld readSymbol readByteArray		"<-7"			readArray readInstance readReference readBitmap	"<-11"			readClass readUser readFloat readRectangle readShortInst 	"<-16"			readString readWordArray readWordArrayForSegment 	"<-19"			readWordLike readMethod "<-21") at: type ifAbsent: [				pos := byteStream position.	"absolute!!!!"				byteStream close. 				self error: 'file is more recent than this system'. ^ nil].	anObject := self perform: selector. "A method that recursively		calls next (readArray, readInstance, objectAt:) must save &		restore the current reference position."	isARefType ifTrue: [self beginReference: anObject].		"After reading the externalObject, internalize it.		 #readReference is a special case. Either:		   (1) We actually have to read the object, recursively calling			   next, which internalizes the object.		   (2) We just read a reference to an object already read and			   thus already interalized.		 Either way, we must not re-internalize the object here."	selector == #readReference ifTrue: [^ anObject].	internalObject := anObject comeFullyUpOnReload: self.	internalObject == String ifTrue:[		"This is a hack to figure out if we're loading a String class 		that really should be a ByteString. Note that these days this		will no longer be necessary since we use #withClassVersion:		for constructing the global thus using a different classVersion		will perfectly do the trick."		((anObject isKindOf: DiskProxy) 			and:[anObject globalObjectName == #String			and:[anObject constructorSelector == #yourself]]) ifTrue:[				internalObject := ByteString]].	^ self maybeBeginReference: internalObject! !!ExternalDropHandler methodsFor: 'accessing' stamp: 'ul 11/15/2010 11:39' prior: 51089682!handle: dropStream in: pasteUp dropEvent: anEvent	| numArgs |	numArgs := action numArgs.	numArgs = 1		ifTrue: [^action value: dropStream].	numArgs = 2		ifTrue: [^action value: dropStream value: pasteUp].	numArgs = 3		ifTrue: [^action value: dropStream value: pasteUp value: anEvent].	self error: 'Wrong number of args for dop action.'! !!ChangeSet class methodsFor: 'scanning' stamp: 'ul 11/15/2010 11:34' prior: 59140590!scanVersionsOf: method class: class meta: meta category: cat selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp changeList file |	changeList := OrderedCollection new.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:[:x | x ifNotNil:[x readOnlyCopy]].	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil] whileTrue:[		preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := [Scanner new scanTokens: preamble] on: Error do:[#()]]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-3) = #stamp: ifTrue:[					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size-2.					prevPos := tokens last.					prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.					prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos.				] ifFalse: ["Old format gives no stamp; prior pointer in two parts"					prevPos := tokens at: tokens size-2.					prevFileIndex := tokens last.				].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]			].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:]) ifTrue:[				(tokens at: tokens size-1) = #stamp: ifTrue: [					"New format gives change stamp and unified prior pointer"					stamp := tokens at: tokens size.			]		]. 		changeList add: (ChangeRecord new file: file position: position type: #method						class: class name category: cat meta: meta stamp: stamp).		position := prevPos.		prevPos notNil ifTrue:[file := sourceFilesCopy at: prevFileIndex].	].	sourceFilesCopy do: [:x | x ifNotNil:[x close]].	^changeList! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'ul 11/15/2010 11:34' prior: 50598870!lookForSlips	"Scan the receiver for changes that the user may regard as slips to be remedied"	| slips nameLine msg |	nameLine := '"', self name, '"'.	(slips := self checkForSlips) size = 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg := slips size = 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(UIManager default  chooseFrom: #('Ignore' 'Browse slips') title: msg) = 2		ifTrue: [self systemNavigation  browseMessageList: slips							name: 'Possible slips in ', name]! !!SystemNavigation methodsFor: 'ui' stamp: 'ul 11/15/2010 12:16' prior: 52731362!confirmRemovalOf: aSelector on: aClass 	"Determine if it is okay to remove the given selector. Answer 1 if it  	should be removed, 2 if it should be removed followed by a senders  	browse, and 3 if it should not be removed."	| count answer caption allCalls |	allCalls := self allCallsOn: aSelector.	(count := allCalls size) = 0		ifTrue: [^ 1].	"no senders -- let the removal happen without warning"	count = 1		ifTrue: [(allCalls first actualClass == aClass					and: [allCalls first methodSymbol == aSelector])				ifTrue: [^ 1]].	"only sender is itself"	caption := 'This message has ' , count printString , ' sender'.	count > 1		ifTrue: [caption := caption copyWith: $s].	answer := UIManager default 		chooseFrom: #('Remove it'				'Remove, then browse senders'				'Don''t remove, but show me those senders'				'Forget it -- do nothing -- sorry I asked') title: caption.	answer = 3		ifTrue: [self				browseMessageList: allCalls				name: 'Senders of ' , aSelector				autoSelect: aSelector keywords first].	answer = 0		ifTrue: [answer := 3].	"If user didn't answer, treat it as cancel"	^ answer min: 3! !!Locale methodsFor: 'private' stamp: 'ul 11/15/2010 11:53' prior: 22727207!fetchISO2Language	"Locale current fetchISO2Language"	| lang isoLang |	lang := self primLanguage.	lang ifNil: [^nil].	lang := lang copyUpTo: 0 asCharacter.	lang size = 2		ifTrue: [^lang].	isoLang := ISOLanguageDefinition iso3LanguageDefinition: lang.	^isoLang		ifNil: [nil]		ifNotNil: [isoLang iso2]! !!Utilities class methodsFor: 'fetching updates' stamp: 'ul 11/15/2010 12:09' prior: 32829238!applyUpdatesFromDiskToUpdateNumber: lastUpdateNumber stopIfGap: stopIfGapFlag 	"To use this mechanism, be sure all updates you want to have considered 	are in a folder named 'updates' which resides in the same directory as  	your image. Having done that, simply evaluate:  	 	Utilities applyUpdatesFromDiskToUpdateNumber: 1234 stopIfGap: false  	 	and all numbered updates <= lastUpdateNumber not yet in the image will 	be loaded in numerical order."	| previousHighest currentUpdateNumber done fileNames aMessage updateDirectory loaded |	updateDirectory := self getUpdateDirectoryOrNil.	updateDirectory ifNil: [^ self].	previousHighest := SystemVersion current highestUpdate.	currentUpdateNumber := previousHighest.	done := false.	loaded := 0.	[done]		whileFalse: [currentUpdateNumber := currentUpdateNumber + 1.			currentUpdateNumber > lastUpdateNumber				ifTrue: [done := true]				ifFalse: [fileNames := updateDirectory fileNamesMatching: currentUpdateNumber printString , '*'.					fileNames size > 1						ifTrue: [^ self inform: 'ambiguity -- two files both start with ' , currentUpdateNumber printString , '(at this point it is probably best to remedythe situation on disk, then try again.)'].					fileNames size = 0						ifTrue: [Transcript cr; show: 'gap in updates from disk for update number '; print: currentUpdateNumber; show: ' found...'.							done := stopIfGapFlag]						ifFalse: [ChangeSet								newChangesFromStream: (updateDirectory readOnlyFileNamed: fileNames first)								named: fileNames first.							SystemVersion current registerUpdate: currentUpdateNumber.							loaded := loaded + 1]]].	aMessage := loaded = 0				ifTrue: ['No new updates found.']				ifFalse: [loaded printString , ' update(s) loaded.'].	self inform: aMessage , 'Highest numbered update is now ' , (currentUpdateNumber - 1) printString , '.'! !!Utilities class methodsFor: 'miscellaneous' stamp: 'ul 11/15/2010 12:16' prior: 33945646!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict := Dictionary new.	report := ReadWriteStream on: ''.	f := FileStream readOnlyFileNamed: fileName1.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f := FileStream readOnlyFileNamed: fileName2.	[f atEnd] whileFalse:		[aString := f nextLine.		items := aString findTokens: ' '.		(items size = 4 or: [items size = 5]) ifTrue:			[className := items first.			newInstCount := items third asNumber.			newSpace := items fourth asNumber.			oldPair := instCountDict at: className ifAbsent: [nil].			oldInstCount := oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace := oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'common requests' stamp: 'ul 11/15/2010 12:16' prior: 33947429!offerCommonRequests	"Offer up the common-requests menu.  If the user chooses one, then evaluate it, and -- provided the value is a number or string -- show it in the Transcript."	"Utilities offerCommonRequests"	| reply result aMenu index normalItemCount strings |	Smalltalk isMorphic ifTrue: [^ self offerCommonRequestsInMorphic].	(CommonRequestStrings == nil or: [CommonRequestStrings isKindOf: Array])		ifTrue:			[self initializeCommonRequestStrings].		strings := CommonRequestStrings contents.	normalItemCount := strings asString lineCount.	aMenu := UIManager default 		chooseFrom: (strings asString lines copyWith: 'edit this menu')		lines: (Array with: normalItemCount).	index := aMenu startUp.	index = 0 ifTrue: [^ self].	reply := aMenu labelString lineNumber: index.	reply size = 0 ifTrue: [^ self].	index > normalItemCount ifTrue:		[^ self editCommonRequestStrings].	result := self evaluate: reply in: nil to: nil.	(result isNumber) | (result isString)		ifTrue:			[Transcript cr; nextPutAll: result printString]! !!Utilities class methodsFor: 'recent method submissions' stamp: 'ul 11/15/2010 12:09' prior: 55270704!revertLastMethodSubmission	| changeRecords lastSubmission theClass theSelector |	"If the most recent method submission was a method change, revert	that change, and if it was a submission of a brand-new method, 	remove that method."	RecentSubmissions isEmptyOrNil ifTrue: [^ Beeper beep].	lastSubmission := RecentSubmissions last.	theClass := lastSubmission actualClass ifNil: [^ Beeper beep].	theSelector := lastSubmission methodSymbol.	changeRecords := theClass changeRecordsAt: theSelector.	changeRecords isEmptyOrNil ifTrue: [^ Beeper beep].	changeRecords size = 1		ifTrue:			["method has no prior version, so reverting in this case means removing"			theClass removeSelector: theSelector]		ifFalse:			[changeRecords second fileIn]."Utilities revertLastMethodSubmission"! !!ImageSegment methodsFor: 'read/write segment' stamp: 'ul 11/15/2010 11:41' prior: 54112741!copySmartRootsExport: rootArray 	"Use SmartRefStream to find the object.  Make them all roots.  Create the segment in memory.  Project should be in first five objects in rootArray."	| newRoots list segSize symbolHolder replacements naughtyBlocks allClasses sizeHint proj dummy |	Smalltalk forgetDoIts.	"self halt."	symbolHolder := Symbol allSymbols.	"Hold onto Symbols with strong pointers, 		so they will be in outPointers"	dummy := ReferenceStream on: (DummyStream on: nil).		"Write to a fake Stream, not a file"	"Collect all objects"	dummy insideASegment: true.	"So Uniclasses will be traced"	dummy rootObject: rootArray.	"inform him about the root"	dummy nextPut: rootArray.	(proj :=dummy project) ifNotNil: [self dependentsSave: dummy].	allClasses := SmartRefStream new uniClassInstVarsRefs: dummy.		"catalog the extra objects in UniClass inst vars.  Put into dummy"	allClasses do: [:cls | 		dummy references at: cls class put: false.	"put Player5 class in roots"		dummy blockers removeKey: cls class ifAbsent: []].	"refs := dummy references."	arrayOfRoots := self smartFillRoots: dummy.	"guaranteed none repeat"	self savePlayerReferences: dummy references.	"for shared References table"	replacements := dummy blockers.	dummy project "recompute it" ifNil: [self error: 'lost the project!!'].	dummy project class == DiskProxy ifTrue: [self error: 'saving the wrong project'].	dummy := nil.	"force GC?"	naughtyBlocks := arrayOfRoots select: [ :each |		(each isKindOf: ContextPart) and: [each hasInstVarRef]	].	"since the caller switched ActiveWorld, put the real one back temporarily"	naughtyBlocks isEmpty ifFalse: [		World becomeActiveDuring: [ | goodToGo |			goodToGo := (UIManager default				chooseFrom: #('keep going' 'stop and take a look')				title:'Some block(s) which reference instance variables are included in this segment. These may fail whenthe segment is loaded if the class has been reshaped.What would you like to do?') = 1.			goodToGo ifFalse: [				naughtyBlocks inspect.				self error: 'Here are the bad blocks'].		].	].	"Creation of the segment happens here"	"try using one-quarter of memory min: four megs to publish (will get bumped later)"	sizeHint := (Smalltalk garbageCollect // 4 // 4) min: 1024*1024.	self copyFromRoots: arrayOfRoots sizeHint: sizeHint areUnique: true.	segSize := segment size.	[(newRoots := self rootsIncludingBlockMethods) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods pointed at from outside"	[(newRoots := self rootsIncludingBlocks) == nil] whileFalse: [		arrayOfRoots := newRoots.		self copyFromRoots: arrayOfRoots sizeHint: segSize areUnique: true].		"with methods, blocks from outPointers"	list := self compactClassesArray.	outPointers := outPointers, ((list select: [:cls | cls ~~ nil]), (Array with: 1717 with: list)).	1 to: outPointers size do: [:ii | 		(outPointers at: ii) isBlock ifTrue: [outPointers at: ii put: nil].		(outPointers at: ii) class == MethodContext ifTrue: [outPointers at: ii put: nil].		"substitute new object in outPointers"		(replacements includesKey: (outPointers at: ii)) ifTrue: [			outPointers at: ii put: (replacements at: (outPointers at: ii))]].	proj ifNotNil: [self dependentsCancel: proj].	symbolHolder.! !"System"!!MenuMorph class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 11:53' prior: 23687737!fromArray: anArray 	"Construct a menu from anArray. The elements of anArray  	must be either:  	* A pair of the form: <label> <selector>  	or	* The 'dash' (or 'minus sign') symbol  	 	Refer to the example at the bottom of the method"	| menu |	menu := self new.	anArray		do: [:anElement |			anElement size = 1				ifTrue: [					anElement == #- ifFalse: [^ self error: 'badly-formed menu constructor'].					menu addLine.				]				ifFalse: [					anElement size = 2 ifFalse: [^ self error: 'badly-formed menu constructor'].					menu add: anElement first action: anElement second.				]		].	^ menu! !!MenuMorph methodsFor: 'control' stamp: 'ul 11/15/2010 11:53' prior: 23656755!wantsToBeDroppedInto: aMorph	"Return true if it's okay to drop the receiver into aMorph.  A single-item MenuMorph is in effect a button rather than a menu, and as such should not be reluctant to be dropped into another object."	^ (aMorph isWorldMorph or: [submorphs size = 1]) or:		[Preferences systemWindowEmbedOK]! !!PolygonMorph methodsFor: 'menu' stamp: 'ul 11/15/2010 11:59' prior: 26632817!unrotatedLength	"If the receiver bears rotation without a transformation morph, answer what its length in the direction it is headed is"	vertices size = 2 ifTrue:		[^ (vertices second - vertices first) r].	^ ((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) height! !!PolygonMorph methodsFor: 'menu' stamp: 'ul 11/15/2010 11:59' prior: 26633194!unrotatedLength: aLength	"If the receiver bears rotation without a transformation morph, answer what its length in the direction it is headed is"	vertices size = 2 ifTrue: [^ self arrowLength: aLength].	self setVertices: ((((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) height: aLength) rotationDegrees: 0) vertices! !!PolygonMorph methodsFor: 'menu' stamp: 'ul 11/15/2010 11:59' prior: 26633624!unrotatedWidth	"If the receiver bears rotation without a transformation morph, answer what its length in the direction it is headed is"		vertices size = 2 ifTrue: [^ self borderWidth].	^ ((PolygonMorph new setVertices: vertices) rotationDegrees: self rotationDegrees negated) width! !!TheWorldMainDockingBar class methodsFor: 'access' stamp: 'cmm 11/16/2010 19:14' prior: 56471596!instance	"Answer the receiver's instance"	^ Instance ifNil: [ Instance := self new ]! !!TheWorldMainDockingBar class methodsFor: 'access' stamp: 'cmm 11/16/2010 19:15'!instance: aTheWorldMainDockingBar	Instance := aTheWorldMainDockingBar.	self updateInstances! !!TheWorldMainDockingBar class methodsFor: 'events' stamp: 'kb 11/19/2009 18:48' prior: 56471449!localeChanged	self updateInstances! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'mt 4/21/2010 09:30:03.495' prior: 58961110!leftBoundary	"Answer the leftmost y position the receiver could be moved."	| splitter morphs |	splitter := self splitterLeft.	morphs := self commonNeighbours: leftOrTop with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect left]				ifFalse: [owner innerBounds left]]		ifNotNil: [splitter right])		 + (self minimumWidthOf: morphs)! !!ProportionalSplitterMorph methodsFor: 'boundaries' stamp: 'mt 4/21/2010 09:30:13.634' prior: 58959557!rightBoundary	"Answer the rightmost x position the receiver could be moved to."	| splitter morphs |	splitter := self splitterRight.	morphs := self commonNeighbours: rightOrBottom with: splitter.	^ (splitter		ifNil: [owner isSystemWindow ifTrue: [owner panelRect right]				ifFalse: [owner innerBounds right]]		ifNotNil: [splitter left])		- (self minimumWidthOf: morphs)! !!UpdatingMenuItemMorph methodsFor: 'world' stamp: 'ul 11/15/2010 12:09' prior: 53668568!updateContents	"Update the receiver's contents"	| newString enablement nArgs |	((wordingProvider isNil) or: [wordingSelector isNil]) ifTrue: [^ self].	nArgs := wordingSelector numArgs.	newString := nArgs = 0		ifTrue:			[wordingProvider perform: wordingSelector]		ifFalse:			[(nArgs = 1 and: [wordingArgument notNil])				ifTrue:					[wordingProvider perform: wordingSelector with: wordingArgument]				ifFalse:					[nArgs == arguments size ifTrue:						[wordingProvider perform: wordingSelector withArguments: arguments]]].	newString = (self contentString ifNil: [ contents ])		ifFalse: [self contents: newString.			MenuIcons decorateMenu: owner ].	enablementSelector ifNotNil:		[(enablement := self enablement) == isEnabled 			ifFalse:	[self isEnabled: enablement]]! !!MorphicAlarmQueue methodsFor: 'adding' stamp: 'ul 11/15/2010 11:55' prior: 58779460!add: aMorphicAlarm	(sequenceNumber := sequenceNumber + 1) = 16r3FFFFFFF ifTrue: [		"Sequence number overflow... reassign sequence numbers starting at 0."		| alarmList |		alarmList := self asArray sort: [:msg1 :msg2 |			 msg1 sequenceNumber < msg2 sequenceNumber		].		alarmList withIndexDo: [:msg :ind | msg sequenceNumber: ind-1].		"The #bitAnd: for the unlikely event that we have > 16r3FFFFFF messages in the queue."		sequenceNumber := alarmList last sequenceNumber + 1 bitAnd: 16r3FFFFFFF.	].	aMorphicAlarm sequenceNumber: sequenceNumber.	super add: aMorphicAlarm.		"If we doubt our sanity..."	false ifTrue: [		self isValidHeap ifFalse: [self error: 'not a valid heap!!!!!!'].	].	^aMorphicAlarm! !!Morph methodsFor: 'menus' stamp: 'ul 11/15/2010 11:54' prior: 51846940!addStandardHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu"	| unlockables |	self isWorldMorph ifTrue:		[^ self addWorldHaloMenuItemsTo: aMenu hand: aHandMorph].	self mustBeBackmost ifFalse:		[aMenu add: 'send to back' translated action: #goBehind.		aMenu add: 'bring to front' translated action: #comeToFront.		self addEmbeddingMenuItemsTo: aMenu hand: aHandMorph.		aMenu addLine].	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addBorderStyleMenuItems: aMenu hand: aHandMorph.	self addDropShadowMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	self addHaloActionsTo: aMenu.	owner isTextMorph ifTrue:[self addTextAnchorMenuItems: aMenu hand: aHandMorph].	aMenu addLine.	self addToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addStackItemsTo: aMenu.	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu			add: ('unlock "{1}"' translated format: unlockables first externalName)			action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!SmalltalkEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 03:40'!blinkPrevParen: aCharacter	"Same as super, but tries to follow the Smalltalk syntax."	| openDelimiter closeDelimiter level string here inside |	string := paragraph text string.	here := pointBlock stringIndex.	openDelimiter := aCharacter.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	inside := nil. "Tricky."	(here > 1 and: [ (string at: here - 1) = $$ ]) ifTrue: [ ^self ]. "Just a character literal."	[ level > 0 and: [ here > 1 ] ] whileTrue: [		| hereChar |		hereChar := string at: (here := here - 1).		inside "Are we inside a comment or string literal?"			ifNotNil: [ "Yes."				hereChar = inside ifTrue: [					(here > 1 and: [ (string at: here - 1) ~= inside ])						ifTrue: [ inside := nil ]						ifFalse: [ here := here - 1 ] ] ]			ifNil: [				(here > 1 and: [ (string at: here - 1) = $$ ]) "Just a character literal."					ifTrue: [ here := here - 1 ]					ifFalse: [						hereChar							caseOf: {								[ closeDelimiter ] -> [									(level := level - 1) = 0 ifTrue: [										^self blinkParenAt: here ] ].								[ openDelimiter ] -> [  level := level + 1 ].								[ $" ] -> [ inside := $" ].								[ $' ] -> [ inside := $' ] }							otherwise: [] ] ] ]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'ul 11/15/2010 11:56' prior: 52117289!addWorldHaloMenuItemsTo: aMenu hand: aHandMorph	"Add standard halo items to the menu, given that the receiver is a World"	| unlockables |	self addFillStyleMenuItems: aMenu hand: aHandMorph.	self addLayoutMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	self addWorldToggleItemsToHaloMenu: aMenu.	aMenu addLine.	self addCopyItemsTo: aMenu.	self addPlayerItemsTo: aMenu.	self addExportMenuItems: aMenu hand: aHandMorph.	self addStackItemsTo: aMenu.	self addMiscExtrasTo: aMenu.	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aMenu hand: aHandMorph].	aMenu addLine.	aMenu defaultTarget: self.	aMenu addLine.	unlockables := self submorphs select:		[:m | m isLocked].	unlockables size = 1 ifTrue:		[aMenu add: ('unlock "{1}"' translated format:{unlockables first externalName})action: #unlockContents].	unlockables size > 1 ifTrue:		[aMenu add: 'unlock all contents' translated action: #unlockContents.		aMenu add: 'unlock...' translated action: #unlockOneSubpart].	aMenu defaultTarget: aHandMorph.! !!PluggableListMorph methodsFor: 'events' stamp: 'ul 11/15/2010 11:59' prior: 26386014!mouseUp: event 	"The mouse came up within the list; take appropriate action"	| row |	row := self rowAtLocation: event position.	"aMorph ifNotNil: [aMorph highlightForMouseDown: false]."	model okToChange		ifFalse: [^ self].	"No change if model is locked"	row = self selectionIndex		ifTrue: [(autoDeselect ifNil: [true]) ifTrue:[row = 0 ifFalse: [self changeModelSelection: 0] ]]		ifFalse: [self changeModelSelection: row].	Cursor normal show! !!BorderedMorph methodsFor: 'geometry' stamp: 'ul 11/15/2010 11:17' prior: 50513085!acquireBorderWidth: aBorderWidth	"Gracefully acquire the new border width, keeping the interior area intact and not seeming to shift"	| delta |	(delta := aBorderWidth- self borderWidth) = 0 ifTrue: [^ self].	self bounds: ((self bounds origin - (delta @ delta)) corner: (self bounds corner + (delta @ delta))).	self borderWidth: aBorderWidth.	self layoutChanged! !!TextEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 03:43' prior: 34696293!blinkPrevParen		self deprecated: 'Use #blinkPrevParen:'.	self blinkPrevParen: sensor keyboardPeek! !!TextEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 02:02' prior: 34696425!blinkPrevParen: aCharacter	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph text string.	here := pointBlock stringIndex.	openDelimiter := aCharacter.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 1]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]]! !!TextEditor methodsFor: 'typing support' stamp: 'ul 11/12/2010 02:05' prior: 34095391!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys openers closers result |	((char == Character cr) and: [morph acceptOnCR])		ifTrue: [			sensor keyboard.  "Gobble cr -- probably unnecessary."			self closeTypeIn.			^ true].	self clearParens.  	char asciiValue = 13 ifTrue: [		sensor controlKeyPressed ifTrue: [			^ self normalCharacter: typeAheadStream ].		sensor leftShiftDown ifTrue: [			^ self lf: typeAheadStream ].		sensor commandKeyPressed ifTrue: [			^ self crlf: typeAheadStream ].		^ self crWithIndent: typeAheadStream ].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue: [				self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [				self perform: (self class cmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue: [			^ self perform: (self class shiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	openers := '([{'.  closers := ')]}'.	result := self normalCharacter: typeAheadStream.	(closers includes: char) ifTrue: [self blinkPrevParen: char].	(self class autoEnclose and: [ openers includes: char ])		ifTrue: 			[ typeAheadStream nextPut: (closers at: (openers indexOf: char)).			self insertTypeAhead: typeAheadStream.			self moveCursor: [ : position | position-1 ] forward: false specialBlock: [ : pos | "no special behavior" ] select: false ].	^ result! !!SystemWindow methodsFor: 'panes' stamp: 'ul 11/15/2010 12:06' prior: 52763230!holdsTranscript	"ugh"	| plug |	^ paneMorphs size = 1 and: [((plug := paneMorphs first) isKindOf: PluggableTextMorph) and: [plug model isKindOf: TranscriptStream]]! !!SystemWindow methodsFor: 'menu' stamp: 'ul 11/15/2010 12:06' prior: 52763478!takeOutOfWindow	"Take the receiver's pane morph out the window and place it, naked, where once the window was"	| aMorph |	paneMorphs size = 1 ifFalse: [^ Beeper beep].	aMorph := paneMorphs first.	owner addMorphFront: aMorph.	self delete! !!SystemWindow methodsFor: 'panes' stamp: 'ul 11/15/2010 12:06' prior: 30794072!titleAndPaneText	"If the receiver represents a workspace, return an Association between the title and that text, else return nil"	(paneMorphs size ~= 1 or: [(paneMorphs first isKindOf: PluggableTextMorph) not])		ifTrue: [^ nil].	^ labelString -> paneMorphs first text! !!ImageMorph methodsFor: 'accessing' stamp: 'ul 11/15/2010 11:40' prior: 21656011!color: aColor        super color: aColor.        (image depth = 1 and: [aColor isColor]) ifTrue: [                image colors: {Color transparent. aColor}.                self changed]! !!ImageMorph methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 11:40' prior: 21657950!wantsRecolorHandle	^ image isNil not		and: [image depth = 1]! !!BalloonCanvas methodsFor: 'drawing' stamp: 'ul 11/15/2010 11:17' prior: 33998403!line: pt1 to: pt2 width: w color: c	"Draw a line from pt1 to: pt2"	(aaLevel = 1 and: [self ifNoTransformWithIn:(pt1 rect: pt2)])		ifTrue:[^super line: pt1 to: pt2 width: w color: c].	^self drawPolygon: (Array with: pt1 with: pt2)		color: c		borderWidth: w		borderColor: c! !!ScrollPane methodsFor: 'scrolling' stamp: 'ul 11/15/2010 12:02' prior: 56609892!hideOrShowScrollBars	| wasHShowing wasVShowing |	wasVShowing := self vIsScrollbarShowing.	wasHShowing := self hIsScrollbarShowing.	self 		vHideOrShowScrollBar; 		hHideOrShowScrollBar; 		resizeScrollBars.	(wasVShowing and: [self vIsScrollbarShowing not]) ifTrue:		["Make sure the delta is 0"		(scroller offset y = 0) 				ifFalse:[ scroller offset: (scroller offset x@0) ]].				(wasHShowing and: [self hIsScrollbarShowing not]) ifTrue:		[(scroller offset x <= 0)				ifFalse:[ scroller offset: (self hMargin negated@scroller offset y)]].! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'ul 11/15/2010 11:58' prior: 52164025!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed. If the button's actionSelector takes any arguments, they are obtained dynamically by sending the argumentSelector to the argumentsProvider"	askBeforeChanging ifTrue: [model okToChange ifFalse: [^ self]].	actionSelector ifNotNil:		[actionSelector numArgs = 0			ifTrue:				[model perform: actionSelector]			ifFalse:				[argumentsProvider ifNotNil:					[arguments := argumentsProvider perform: argumentsSelector].					model perform: actionSelector withArguments: arguments]]! !!SimpleHierarchicalListMorph methodsFor: 'keyboard navigation' stamp: 'ul 11/15/2010 12:03' prior: 29116384!arrowKey: aChar	"Handle a keyboard navigation character. Answer true if handled, false if not."	| keyEvent |	keyEvent := aChar asciiValue.     keyEvent = 31 ifTrue:["down"		self setSelectionIndex: self getSelectionIndex+1.		^true].     keyEvent = 30 ifTrue:["up"		self setSelectionIndex: (self getSelectionIndex-1 max: 1).		^true].     keyEvent = 1  ifTrue: ["home"		self setSelectionIndex: 1.		^true].     keyEvent = 4  ifTrue: ["end"		self setSelectionIndex: scroller submorphs size.		^true].      keyEvent = 11 ifTrue: ["page up"		self setSelectionIndex: (self getSelectionIndex - self numSelectionsInView max: 1).		^true].     keyEvent = 12  ifTrue: ["page down"		self setSelectionIndex: self getSelectionIndex + self numSelectionsInView.		^true].	keyEvent = 29 ifTrue:["right"		selectedMorph ifNotNil:[			(selectedMorph canExpand and:[selectedMorph isExpanded not])				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: self getSelectionIndex+1].		].		^true].	keyEvent = 28 ifTrue:["left"		selectedMorph ifNotNil:[			(selectedMorph isExpanded)				ifTrue:[self toggleExpandedState: selectedMorph]				ifFalse:[self setSelectionIndex: (self getSelectionIndex-1 max: 1)].		].		^true].	^false! !TheWorldMainDockingBar class removeSelector: #new!"Morphic"!!ShiftJISTextConverter methodsFor: 'conversion' stamp: 'ul 11/15/2010 12:03' prior: 53385761!nextPut: aCharacter toStream: aStream 	| value leadingChar aChar |	aStream isBinary ifTrue: [^aCharacter storeBinaryOn: aStream].	aCharacter isTraditionalDomestic ifTrue: [			aChar := aCharacter.		value := aCharacter charCode.	] ifFalse: [		value := aCharacter charCode.		(16rFF61 <= value and: [value <= 16rFF9F]) ifTrue: [			aStream basicNextPut: (self sjisKatakanaFor: value).			^ aStream		].		aChar := JISX0208 charFromUnicode: value.		aChar ifNil: [^ aStream].		value := aChar charCode.	].	leadingChar := aChar leadingChar.	leadingChar = 0 ifTrue: [		aStream basicNextPut: (Character value: value).		^ aStream.	].	leadingChar == self leadingChar ifTrue: [		| upper lower | 		upper := value // 94 + 33.		lower := value \\ 94 + 33.		upper \\ 2 = 1 ifTrue: [			upper := upper + 1 / 2 + 112.			lower := lower + 31		] ifFalse: [			upper := upper / 2 + 112.			lower := lower + 125		].		upper >= 160 ifTrue: [upper := upper + 64].		lower >= 127 ifTrue: [lower := lower + 1].		aStream basicNextPut: (Character value: upper).		aStream basicNextPut: (Character value: lower).		^ aStream	].! !"Multilingual"!!SorterTokenMorph methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 12:05' prior: 29532646!fitContents	submorphs size = 1 ifTrue: [self bounds: (submorphs first bounds insetBy: (-1 @ -1))]! !!SketchEditorMorph methodsFor: 'start & finish' stamp: 'ul 11/15/2010 12:03' prior: 52517190!setRotations: num	"Tell the palette what number of rotations (or background) to show.  "	| key |	key := 'ItTurns'.	"default and value for num > 1"	num = 1 ifTrue: [key := 'JustAsIs'].	num = 18 ifTrue: [key := 'ItTurns'].	num = 99 ifTrue: [key := 'ToAndFro'].	num == #Background ifTrue: [key := 'Background'].	num == #Repeated ifTrue: [key := 'Repeated'].	palette setRotations: (palette contentsAtKey: key).! !!FrameRateMorph methodsFor: 'stepping and presenter' stamp: 'ul 11/15/2010 11:40' prior: 51248054!step	"Compute and display (every half second or so) the current framerate"	| now mSecs mSecsPerFrame framesPerSec newContents |	framesSinceLastDisplay := framesSinceLastDisplay + 1.	now := Time millisecondClockValue.	mSecs := now - lastDisplayTime.	(mSecs > 500 or: [mSecs < 0 "clock wrap-around"]) ifTrue: 		[mSecsPerFrame := mSecs // framesSinceLastDisplay.		framesPerSec := (framesSinceLastDisplay * 1000) // mSecs.		newContents := mSecsPerFrame printString, ' mSecs (', framesPerSec printString, ' frame', (framesPerSec = 1 ifTrue: [''] ifFalse: ['s']), '/sec)'.		self contents: newContents.		lastDisplayTime := now.		framesSinceLastDisplay := 0]! !!FlapTab methodsFor: 'event handling' stamp: 'sw 10/31/2001 15:46' prior: 58866794!mouseMove: evt	| aPosition newReferentThickness adjustedPosition thick |	dragged ifFalse: [(thick := self referentThickness) > 0			ifTrue: [lastReferentThickness := thick]].	((self containsPoint: (aPosition := evt cursorPoint)) and: [dragged not])		ifFalse:			[flapShowing ifFalse: [self showFlap].			adjustedPosition := aPosition - evt hand targetOffset.			(edgeToAdhereTo == #bottom)				ifTrue:					[newReferentThickness := inboard						ifTrue:							[self world height - adjustedPosition y]						ifFalse:							[self world height - adjustedPosition y - self height]].			(edgeToAdhereTo == #left)					ifTrue:						[newReferentThickness :=							inboard								ifTrue:									[adjustedPosition x + self width]								ifFalse:									[adjustedPosition x]].			(edgeToAdhereTo == #right)					ifTrue:						[newReferentThickness :=							inboard								ifTrue:									[self world width - adjustedPosition x]								ifFalse:									[self world width - adjustedPosition x - self width]].			(edgeToAdhereTo == #top)					ifTrue:						[newReferentThickness :=							inboard								ifTrue:									[adjustedPosition y + self height]								ifFalse:									[adjustedPosition y]].					self isCurrentlySolid ifFalse:				[(#(left right) includes: edgeToAdhereTo)					ifFalse:						[self left: adjustedPosition x]					ifTrue:						[self top: adjustedPosition y]].			self applyThickness: newReferentThickness.			dragged := true.			self fitOnScreen.			self computeEdgeFraction]! !!ReferenceMorph methodsFor: 'misc' stamp: 'ul 11/15/2010 12:00' prior: 27597533!fitContents	submorphs size = 1 ifTrue:		[self extent: submorphs first extent + (2 * self borderWidth).		submorphs first position: self position + self borderWidth]! !!PostscriptCanvas class methodsFor: 'font mapping' stamp: 'ul 11/15/2010 11:59' prior: 55329961!postscriptFontInfoForFont: font	| decoded decodedName keys match fontName |	fontName := font textStyleName asString.	decoded := TextStyle decodeStyleName: fontName.	decodedName := decoded second.	keys := self fontMap keys asArray sort: [ :a :b | a size > b size ].	match := keys select: [ :k | decoded first = k or: [ fontName = k ] ].	match do: [ :key | | subD desired mask |		subD := self fontMap at: key.		desired := font emphasis.		mask := 31.		[			desired := desired bitAnd: mask.			subD at: desired ifPresent: [ :answer | ^answer].			mask := mask bitShift: -1.			desired > 0		] whileTrue.	].	"No explicit lookup found; try to convert the style name into the canonical Postscript name.	This name will probably still be wrong."	fontName := String streamContents: [ :s |		s nextPutAll: decodedName.		decoded third do: [ :nm | s nextPut: $-; nextPutAll: nm ].		(font emphasis = 0 and: [ (decoded last includes: 0) not ])			ifTrue: [ s nextPutAll:  '-Regular' ].		(font emphasis = 1 and: [ (decoded first anyMask: 1) not ])			ifTrue: [ s nextPutAll:  '-Bold' ].		(font emphasis = 2 and: [ (decoded first anyMask: 2) not ])			ifTrue: [ s nextPutAll:  '-Italic' ].		(font emphasis = 3 and: [ (decoded first anyMask: 3) not ])			ifTrue: [ s nextPutAll:  '-BoldItalic' ].	].	^ {fontName. 1.0}! !!PostscriptCanvas methodsFor: 'private' stamp: 'ul 11/15/2010 11:59' prior: 26745499!endGStateForMorph: aMorph 	morphLevel = 1		ifTrue: [ target showpage; print: 'grestore'; cr ]! !!PostscriptCanvas methodsFor: 'private' stamp: 'ul 11/15/2010 11:59' prior: 26748758!setupGStateForMorph: aMorph 	morphLevel = 1		ifTrue: [self writePageSetupFor: aMorph]! !!CommandHistory methodsFor: 'called from the ui' stamp: 'ul 11/15/2010 11:35' prior: 50733431!undoTo	"Not yet functional, and not yet sent.  Allow the user to choose a point somewhere in the undo/redo tape, and undo his way to there.   Applicable only if infiniteUndo is set. "	| anIndex commandList reply |	(anIndex := self historyIndexOfLastCommand) = 0 ifTrue: [^ Beeper beep].	commandList := history		copyFrom:	((anIndex - 10) max: 1)		to:			((anIndex + 10) min: history size).	reply := UIManager default chooseFrom: (commandList collect: [:cmd | cmd cmdWording truncateWithElipsisTo: 20]) values: commandList title: 'undo or redo to...'.	reply ifNotNil: [self inform: #deferred]	"ActiveWorld commandHistory undoTo"! !"MorphicExtras"!!PackageInfo methodsFor: 'testing' stamp: 'ul 11/15/2010 11:56' prior: 33728403!changeRecordForOverriddenMethod: aMethodReference	| sourceFilesCopy method position |	method := aMethodReference actualClass compiledMethodAt: aMethodReference methodSymbol.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	[ | file prevPos prevFileIndex chunk stamp methodCategory tokens |	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [chunk := file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(chunk findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: chunk]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size-2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size-2.						prevFileIndex := tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size]].		methodCategory := tokens after: #methodsFor: ifAbsent: ['as yet unclassifed'].		(self includesMethodCategory: methodCategory ofClass: aMethodReference actualClass) ifTrue:			[methodCategory = (Smalltalk at: #Categorizer ifAbsent: [Smalltalk at: #ClassOrganizer]) default ifTrue: [methodCategory := methodCategory, ' '].			^ ChangeRecord new file: file position: position type: #method						class: aMethodReference classSymbol category: methodCategory meta: aMethodReference classIsMeta stamp: stamp].		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].		^ nil]			ensure: [sourceFilesCopy do: [:x | x notNil ifTrue: [x close]]]	! !"PackageInfo-Base"!!Inspector methodsFor: '*Protocols-Tools' stamp: 'ul 11/15/2010 11:43' prior: 57022760!browseFullProtocol	"Open up a protocol-category browser on the value of the receiver's current selection.  If in mvc, an old-style protocol browser is opened instead."	| objectToRepresent |	Smalltalk isMorphic ifFalse: [^ self spawnProtocol].	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	InstanceBrowser new openOnObject: objectToRepresent showingSelector: nil! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'ul 11/15/2010 11:44' prior: 57023264!spawnFullProtocol	"Spawn a window showing full protocol for the receiver's selection"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openFullProtocolForClass: objectToRepresent class! !!Inspector methodsFor: '*Protocols-Tools' stamp: 'ul 11/15/2010 11:44' prior: 57023624!spawnProtocol	"Spawn a protocol on browser on the receiver's selection"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	ProtocolBrowser openSubProtocolForClass: objectToRepresent class! !!Lexicon methodsFor: 'history' stamp: 'ul 11/15/2010 11:52' prior: 56984487!navigateToNextMethod	"Navigate to the 'next' method in the current viewing sequence"	| anIndex aSelector |	self selectorsVisited size = 0 ifTrue: [^ self].	anIndex := (aSelector := self selectedMessageName) notNil ifTrue: [selectorsVisited indexOf: aSelector ifAbsent: [selectorsVisited size]] ifFalse: [1].	self selectedCategoryName == self class viewedCategoryName 		ifTrue:			[self selectWithinCurrentCategory: (selectorsVisited atWrap: (anIndex + 1))]		ifFalse:			[self displaySelector: (selectorsVisited atWrap: (anIndex + 1))]! !!Lexicon methodsFor: 'history' stamp: 'ul 11/15/2010 11:52' prior: 56985111!navigateToPreviousMethod	"Navigate to the 'previous' method in the current viewing sequence"	| anIndex aSelector |	self selectorsVisited size = 0 ifTrue: [^ self].	anIndex := (aSelector := self selectedMessageName) notNil		ifTrue: [selectorsVisited indexOf: aSelector ifAbsent: [selectorsVisited size]]		ifFalse: [selectorsVisited size].	self selectedCategoryName == self class viewedCategoryName 		ifTrue:			[self selectWithinCurrentCategory: (selectorsVisited atWrap: (anIndex - 1))]		ifFalse:			[self displaySelector: (selectorsVisited atWrap: (anIndex - 1))]! !!Lexicon methodsFor: 'search' stamp: 'ul 11/15/2010 11:52' prior: 56987165!obtainNewSearchString	"Put up a box allowing the user to enter a fresh search string"	| fragment |		fragment := UIManager default request: 'type method name or fragment: ' initialAnswer: self currentQueryParameter.	fragment ifNil: [^ self].	(fragment := fragment copyWithout: $ ) size = 0  ifTrue: [^ self].	currentQueryParameter := fragment.	fragment := fragment asLowercase.	currentQuery := #selectorName.	self showQueryResultsCategory.	self messageListIndex: 0! !!Lexicon methodsFor: 'model glue' stamp: 'ul 11/15/2010 11:52' prior: 56989219!okayToAccept	"Answer whether it is okay to accept the receiver's input"	| ok aClass reply |	(ok := super okayToAccept) ifTrue:		[((aClass := self selectedClassOrMetaClass) ~~ targetClass) ifTrue:			[reply := UIManager default chooseFrom: 	{'okay, no problem'. 	'cancel - let me reconsider'. 	'compile into ', targetClass name, ' instead'.	'compile into a new uniclass'} title:'Caution!!  This would beaccepted into class ', aClass name, '.Is that okay?' .			reply = 1 ifTrue: [^ true].			reply ~= 2 ifTrue:				[self notYetImplemented].			^ false]].	^ ok! !!Lexicon methodsFor: 'selection' stamp: 'ul 11/15/2010 11:53' prior: 56995858!selectImplementedMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any.  In this variant, only selectors "	| selector method messages |	(selector := self selectedMessageName) ifNil: [^ self].	method := (self selectedClassOrMetaClass ifNil: [^ self])		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages := method messages) size = 0])		 ifTrue: [^ aBlock value: selector].	(messages size = 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	messages := messages select: [:aSelector | currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass].	self systemNavigation 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!Lexicon methodsFor: 'selection' stamp: 'ul 11/15/2010 11:53' prior: 56999272!selectedMessage	"Answer the source method for the currently selected message."	(categoryList notNil and: [(categoryListIndex isNil or: [categoryListIndex = 0])])		ifTrue:			[^ '---'].	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'here would go the documentation for the protocol category, if any.'].		self showingDecompile ifTrue: [^ self decompiledSourceIntoContents].		self showingDocumentation ifTrue: [^ self commentContents].		currentCompiledMethod := class compiledMethodAt: selector ifAbsent: [nil].		^ self sourceStringPrettifiedAndDiffed asText makeSelectorBoldIn: class]! !!Lexicon methodsFor: 'search' stamp: 'ul 11/15/2010 11:53' prior: 57007055!setMethodListFromSearchString	"Set the method list of the receiver based on matches from the search string"	| fragment aList |	self okToChange ifFalse: [^ self].	fragment := currentQueryParameter.	fragment := fragment asString asLowercase withBlanksTrimmed.	aList := targetClass allSelectors select:		[:aSelector | currentVocabulary includesSelector: aSelector forInstance: self targetObject ofClass: targetClass limitClass: limitClass].	fragment size > 0 ifTrue:		[aList := aList select:			[:aSelector | aSelector includesSubstring: fragment caseSensitive: false]].	aList size = 0 ifTrue:		[^ Beeper beep].	self initListFrom: aList asSortedArray highlighting: targetClass.	messageListIndex :=  messageListIndex min: messageList size.	self changed: #messageList! !"Protocols"!!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 03:44' prior: 53465036!blinkPrevParen	self deprecated: 'Use #blinkPrevParen:'.	self blinkPrevParen: sensor keyboardPeek! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 03:10'!blinkPrevParen: aCharacter	| openDelimiter closeDelimiter level string here hereChar |	string := paragraph text string.	here := startBlock stringIndex.	openDelimiter := aCharacter.	closeDelimiter := '([{' at: (')]}' indexOf: openDelimiter).	level := 1.	[level > 0 and: [here > 1]]		whileTrue:			[hereChar := string at: (here := here - 1).			hereChar = closeDelimiter				ifTrue:					[level := level - 1.					level = 0						ifTrue: [^ self blinkParenAt: here]]				ifFalse:					[hereChar = openDelimiter						ifTrue: [level := level + 1]]].! !!ParagraphEditor methodsFor: 'parenblinking' stamp: 'ul 11/12/2010 03:08' prior: 53545602!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys result |	self clearParens.  	"mikki 1/3/2005 21:31 Preference for auto-indent on return added."	char asciiValue = 13 ifTrue: [		^Preferences autoIndent 			ifTrue: [				sensor controlKeyPressed					ifTrue: [self normalCharacter: typeAheadStream]					ifFalse: [self crWithIndent: typeAheadStream]]			ifFalse: [				sensor controlKeyPressed					ifTrue: [self crWithIndent: typeAheadStream]					ifFalse: [self normalCharacter: typeAheadStream]]].	((honorCommandKeys := Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].			"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1 ifAbsent: [#noop:]) with: typeAheadStream].	result := self perform: #normalCharacter: with: typeAheadStream.		(')]}' includes: char)		ifTrue: [self blinkPrevParen: char ].	^result! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56' prior: 53531869!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply := UIManager default request: 'Find what? ' translated initialAnswer: ''.	reply size = 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText := FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56' prior: 54074587!saveContentsInFile	"Save the receiver's contents string to a file, prompting the user for a file-name.  Suggest a reasonable file-name."	| fileName stringToSave parentWindow labelToUse suggestedName |	stringToSave := paragraph text string.	stringToSave size = 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow := self model dependents						detect: [:dep | dep isKindOf: SystemWindow orOf: StandardSystemView]						ifNone: [nil].	labelToUse := parentWindow		ifNil: 		['Untitled']		ifNotNil: 	[parentWindow label].	suggestedName := nil.	#(('Decompressed contents of: '		'.gz')) do:  "can add more here..."		[:leaderTrailer | | lastIndex |			(labelToUse beginsWith: leaderTrailer first) ifTrue:				[suggestedName := labelToUse copyFrom: leaderTrailer first size + 1 to: labelToUse size.				(labelToUse endsWith: leaderTrailer last)					ifTrue:						[suggestedName := suggestedName copyFrom: 1 to: suggestedName size - leaderTrailer last size]					ifFalse:						[lastIndex := suggestedName lastIndexOf: $. ifAbsent: [0].						(lastIndex = 0 or: [lastIndex = 1]) ifFalse:							[suggestedName := suggestedName copyFrom: 1 to: lastIndex - 1]]]].	suggestedName ifNil:		[suggestedName := labelToUse, '.text'].				fileName := UIManager default request: 'File name?' translated			initialAnswer: suggestedName.	fileName isEmptyOrNil ifFalse:		[(FileStream newFileNamed: fileName) nextPutAll: stringToSave; close]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56' prior: 57889926!selectedSymbol	"Return the currently selected symbol, or nil if none.  Spaces, tabs and returns are ignored"	| aString |	self hasCaret ifTrue: [^ nil].	aString := self selection string.	aString isOctetString ifTrue: [aString := aString asOctetString].	aString := self selection string copyWithoutAll: CharacterSet separators.	aString size = 0 ifTrue: [^ nil].	Symbol hasInterned: aString  ifTrue: [:sym | ^ sym].	^ nil! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:56' prior: 53443150!sendContentsToPrinter	| textToPrint printer parentWindow |	textToPrint := paragraph text.	textToPrint size = 0 ifTrue: [^self inform: 'nothing to print.'].	printer := TextPrinter defaultTextPrinter.	parentWindow := self model dependents 				detect: [:dep | dep isSystemWindow]				ifNone: [nil].	parentWindow isNil 		ifTrue: [printer documentTitle: 'Untitled']		ifFalse: [printer documentTitle: parentWindow label].	printer printText: textToPrint! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'ul 11/15/2010 11:56' prior: 53509281!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString :=  self selection string.	aString size = 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'ul 11/15/2010 11:56' prior: 53499671!swapChars: characterStream 	"Triggered byCmd-Y;.  Swap two characters, either those straddling the insertion point, or the two that comprise the selection.  Suggested by Ted Kaehler.  "	| currentSelection aString chars |	sensor keyboard.		"flush the triggering cmd-key character"	(chars := self selection) size = 0		ifTrue:			[currentSelection := self pointIndex.			self selectMark: currentSelection - 1 point: currentSelection]		ifFalse:			[chars size = 2				ifFalse:					[view flash.  ^ true]				ifTrue:					[currentSelection := self pointIndex - 1]].	aString := self selection string.	self replaceSelectionWith: (Text string: aString reversed emphasis: emphasisHere).	self selectAt: currentSelection + 1.	^ true! !!FormInspectView methodsFor: 'as yet unclassified' stamp: 'ul 11/15/2010 11:40' prior: 21150505!displayView 	"Display the form as a value in an inspector.  8/11/96 sw"	"Defeated form scaling for HS FormInspector.  8/20/96 di"	| scale |	Display fill: self insetDisplayBox fillColor: Color white.	model selectionIndex = 0 ifTrue: [^ self].	scale := self insetDisplayBox extent / model selection extent.	scale := (scale x min: scale y) min: 1.	model selection		displayOn: Display		transformation: (WindowingTransformation			scale: scale asPoint			translation: self insetDisplayBox topLeft - model selection offset)		clippingBox: self insetDisplayBox		rule: self rule		fillColor: self fillColor! !!ListController methodsFor: 'marker adjustment' stamp: 'ul 11/15/2010 11:53' prior: 22690846!markerDelta	| viewList |	viewList := view list.	viewList compositionRectangle height = 0 ifTrue: [		^ (marker top - scrollBar inside top) - scrollBar inside height	].	^ (marker top - scrollBar inside top) -		((viewList clippingRectangle top -				viewList compositionRectangle top) asFloat /			viewList compositionRectangle height asFloat *			scrollBar inside height asFloat) rounded! !!ListController methodsFor: 'menu messages' stamp: 'ul 11/15/2010 11:53' prior: 22691321!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent = 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent = 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent = 1  ifTrue: [nextSelection := 1].  "home"     keyEvent = 4  ifTrue: [nextSelection := max].   "end"     keyEvent = 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent = 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !!ControlManager methodsFor: 'scheduling' stamp: 'ul 11/15/2010 11:35' prior: 34017571!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically := Sensor shiftPressed.	controllers := OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size = 0 ifTrue: [^ self].	listToUse := sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels := String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index := (UIManager default chooseFrom: labels lines).	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!PluggableListView methodsFor: 'model access' stamp: 'ul 11/15/2010 11:59' prior: 26434455!specialKeyPressed: keyEvent	"Process the up and down arrows in a list pane."     | oldSelection nextSelection max min howMany |	(#(1 4 11 12 30 31) includes: keyEvent) ifFalse: [ ^ false ].     oldSelection := self getCurrentSelectionIndex.     nextSelection := oldSelection.     max := self maximumSelection.     min := self minimumSelection.     howMany := self numSelectionsInView.	"get this exactly??"     keyEvent = 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection := 1]].     keyEvent = 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection := max]].     keyEvent = 1  ifTrue: [nextSelection := 1].  "home"     keyEvent = 4  ifTrue: [nextSelection := max].   "end"     keyEvent = 11 ifTrue: [nextSelection := min max: (oldSelection - howMany)].  "page up"     keyEvent = 12  ifTrue: [nextSelection := (oldSelection + howMany) min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				"self controller moveMarker"]].		^true			! !"ST80"!!ExceptionTests methodsFor: 'testing-outer' stamp: 'ul 11/15/2010 11:39' prior: 57133180!testResumableOuter	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex outer. ex return: 5].	self assert: result = 5! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'ul 11/15/2010 11:39' prior: 57133426!testResumablePass	| result |	result := [Notification signal. 4] 		on: Notification 		do: [:ex | ex pass. ex return: 5].	self assert: result = 4! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:26' prior: 21543784!testCharacterHex| result |result := $a hex.self assert: result = '61'.result := $A hex.self assert: result = '41'.! !!HexTest methodsFor: 'as yet unclassified' stamp: 'JPF 6/26/2007 10:44' prior: 21544505!testStringAsHex| result |result := 'abc' asHex.self assert: result = '616263'.! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 12:05' prior: 57234620!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 i p |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)]! !!StandardSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 12:05' prior: 57240606!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf a |	sf := StandardSourceFileArray new.	(0 to: 16r1FFFFFF by: 811) do: [:e | | a2 p i |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	(0 to: 16rFFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	(16r1000000 to: 16r1FFFFFF by: 811) do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)]! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 11:39' prior: 58425049!testChangesFileAddressRange	"Test file position to source pointer address translation for the changes file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	0 to: 16r1FFFFFFF by: 4093 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 2.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 2 andPosition: p.		self assert: a2 = a].	0 to: 16rFFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r2000000 and: 16r2FFFFFF)].	16r1000000 to: 16r1FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r4000000 and: 16r4FFFFFF)].	16r2000000 to: 16r2FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r6000000 and: 16r6FFFFFF)].	16r3000000 to: 16r3FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r8000000 and: 16r8FFFFFF)].	16r4000000 to: 16r4FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rA000000 and: 16rAFFFFFF)].	16r5000000 to: 16r5FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rC000000 and: 16rCFFFFFF)].	16r6000000 to: 16r6FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16rE000000 and: 16rEFFFFFF)].	16r7000000 to: 16r7FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 2 andPosition: e.		self assert: (a between: 16r10000000 and: 16r10FFFFFF)]! !!ExpandedSourceFileArrayTest methodsFor: 'testing' stamp: 'ul 11/15/2010 11:39' prior: 58428011!testSourcesFileAddressRange	"Test file position to source pointer address translation for the sources file"		| sf i p a a2 |	sf := ExpandedSourceFileArray new.	0 to: 16r1FFFFFFF by: 4093 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		i := sf fileIndexFromSourcePointer: a.		self assert: i = 1.		p := sf filePositionFromSourcePointer: a.		self assert: p = e.		a2 := sf sourcePointerFromFileIndex: 1 andPosition: p.		self assert: a2 = a].	0 to: 16rFFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r1000000 and: 16r1FFFFFF)].	16r1000000 to: 16r1FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r3000000 and: 16r3FFFFFF)].	16r2000000 to: 16r2FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r5000000 and: 16r5FFFFFF)].	16r3000000 to: 16r3FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r7000000 and: 16r7FFFFFF)].	16r4000000 to: 16r4FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16r9000000 and: 16r9FFFFFF)].	16r5000000 to: 16r5FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rB000000 and: 16rBFFFFFF)].	16r6000000 to: 16r6FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rD000000 and: 16rDFFFFFF)].	16r7000000 to: 16r7FFFFFF by: 811 do: [:e |		a := sf sourcePointerFromFileIndex: 1 andPosition: e.		self assert: (a between: 16rF000000 and: 16rFFFFFFF)]! !"Tests"!!CustomMenu methodsFor: 'invocation' stamp: 'ul 11/15/2010 11:35' prior: 57746163!invokeOn: targetObject orSendTo: anObject	"Pop up this menu and return the result of sending to the target object the selector corresponding to the menu item selected by the user. Return  nil if no item is selected.  If the chosen selector has arguments, obtain appropriately.  If the recipient does not respond to the resulting message, send it to the alternate object provided"	| aSelector anIndex recipient |	^ (aSelector := self startUp) ifNotNil:		[anIndex := self selection.		recipient := ((targets := self targets) isEmptyOrNil or: [anIndex > targets size])			ifTrue:				[targetObject]			ifFalse:				[targets at: anIndex].		aSelector numArgs = 0			ifTrue:				[recipient perform: aSelector orSendTo: anObject]			ifFalse:				[recipient perform: aSelector withArguments: (self arguments at: anIndex)]]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 12:03' prior: 57753547!fromArray: anArray	"Construct a menu from anArray.  The elements of anArray must be either:	*  A pair of the form: <label> <selector>or	*  The 'dash' (or 'minus sign') symbol	Refer to the example at the bottom of the method"	| labelList lines selections anIndex |	labelList := OrderedCollection new.	lines := OrderedCollection new.	selections := OrderedCollection new.	anIndex := 0.	anArray do:		[:anElement |			anElement size = 1				ifTrue:					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].					lines add: anIndex]				ifFalse:					[anElement size = 2 ifFalse: [self error: 'badly-formed menu constructor'].					anIndex := anIndex + 1.					labelList add: anElement first.					selections add: anElement second]].	^ self labelList: labelList lines: lines selections: selections"(SelectionMenu fromArray:	#(	('first label'		moja)		('second label'	mbili)		-		('third label' 	tatu)		-		('fourth label'	nne)		('fifth label'	tano))) startUp"! !!FileContentsBrowser methodsFor: 'class list' stamp: 'ul 11/15/2010 11:40' prior: 53373368!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern := (UIManager default request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index := classNames size = 1				ifTrue:	[1]				ifFalse:	[(UIManager default chooseFrom: classNames lines: #())].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).	self classListIndex: (self classList indexOf: foundClass name). ! !!StringHolder methodsFor: '*Tools' stamp: 'ul 11/15/2010 12:05' prior: 30246063!messageListSelectorTitle	| selector aString aStamp aSize |	(selector := self selectedMessageName)		ifNil:			[aSize := self messageList size.			^ (aSize = 0 ifTrue: ['no'] ifFalse: [aSize printString]), ' message', (aSize = 1 ifTrue: [''] ifFalse: ['s'])]		ifNotNil:			[Preferences timeStampsInMenuTitles				ifFalse:	[^ nil].			aString := selector truncateWithElipsisTo: 28.			^ (aStamp := self timeStamp) size > 0				ifTrue:					[aString, String cr, aStamp]				ifFalse:					[aString]]! !!StringHolder methodsFor: '*Tools' stamp: 'ul 11/15/2010 12:05' prior: 34559403!withSelectorAndMessagesIn: aCompiledMethod evaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selectorOrNil litGetter messages |	selectorOrNil := aCompiledMethod selector.	messages := Preferences thoroughSenders					ifTrue:						[litGetter := [:set :l|										(l isSymbol and: [l size > 0 and: [l first isLowercase]]) ifTrue:											[set add: l].										l isArray ifTrue:											[l inject: set into: litGetter copy].										set].						aCompiledMethod allLiterals						, (aCompiledMethod pragmas collect: [:pragma| pragma keyword])							inject: aCompiledMethod messages into: litGetter copy]					ifFalse: [aCompiledMethod messages].	(messages isEmpty	"if no messages, use only selector"	or: [messages size = 1 and: [messages includes: selectorOrNil]]) ifTrue:		[^selectorOrNil ifNotNil: [aBlock value: selectorOrNil]].  "If only one item, there is no choice"	self systemNavigation 		showMenuOf: messages		withFirstItem: selectorOrNil		ifChosenDo: [:sel | aBlock value: sel]! !!MessageSet methodsFor: 'filtering' stamp: 'ul 11/15/2010 11:54' prior: 54364441!filterToMessagesInChangesFile	"Filter down only to messages whose source code risides in the Changes file.  This allows one to ignore long-standing methods that live in the .sources file."		self filterFrom:		[:aClass :aSelector | | cm |			aClass notNil and: [aSelector notNil and:				[(self class isPseudoSelector: aSelector) not and:					[(cm := aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex ~= 1]]]]]! !!MessageSet methodsFor: 'filtering' stamp: 'ul 11/15/2010 11:54' prior: 54364976!filterToMessagesInSourcesFile	"Filter down only to messages whose source code resides in the .sources file."		self filterFrom: [:aClass :aSelector | | cm |		(aClass notNil and: [aSelector notNil]) and:			[(self class isPseudoSelector: aSelector) not and:				[(cm := aClass compiledMethodAt: aSelector ifAbsent: [nil]) notNil and:					[cm fileIndex = 1]]]]! !!MessageSet methodsFor: 'message functions' stamp: 'ul 11/15/2010 11:54' prior: 23773938!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName := self selectedMessageName.	confirmation := self systemNavigation  confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self deleteFromMessageList: self selection.	self reformulateList.	confirmation = 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'private' stamp: 'ul 11/15/2010 11:54' prior: 58640718!setFilteredList: newList 	"Establish newList as the new list if appropriate, and adjust the window title accordingly; if the new list is of the same size as the old, warn and do nothing"	newList size = 0 ifTrue:		[ self inform: 'Nothing would be left in the list if you did that'.		^false ].	newList size = messageList size ifTrue:		[ self inform: 'That leaves the list unchanged'.		^false ].	self		 initializeMessageList: newList ;		 adjustWindowTitleAfterFiltering.	^true! !!ChangeList class methodsFor: 'public access' stamp: 'ul 11/15/2010 11:34' prior: 57696350!browseRecentLogOn: origChangesFile startingFrom: initialPos 	"Prompt with a menu of how far back to go when browsing a changes file."	| end banners positions pos chunk i changesFile |	changesFile := origChangesFile readOnlyCopy.	banners := OrderedCollection new.	positions := OrderedCollection new.	end := changesFile size.	changesFile setConverterForCode.	pos := initialPos.	[pos = 0		or: [banners size > 20]]		whileFalse: [changesFile position: pos.			chunk := changesFile nextChunk.			i := chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.			i > 0				ifTrue: [positions addLast: pos.					banners						addLast: (chunk copyFrom: 5 to: i - 2).					pos := Number								readFrom: (chunk copyFrom: i + 13 to: chunk size)]				ifFalse: [pos := 0]].	changesFile close.	banners size = 0 ifTrue: [^ self inform: 'this image has never been savedsince changes were compressed' translated].	pos := UIManager default chooseFrom:  banners values: positions title: 'Browse as far back as...' translated.	pos ifNil: [^ self].	self browseRecent: end - pos on: origChangesFile! !!ChangeList methodsFor: 'menu actions' stamp: 'ul 11/15/2010 11:31' prior: 18162923!browseAllVersionsOfSelections	"Opens a Versions browser on all the currently selected methods, showing each alongside all of their historical versions."	|  oldSelection aList |	oldSelection := self listIndex.	aList := OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				listIndex := i.				self browseVersions.				aList add: i.				]]].	listIndex := oldSelection.	aList size = 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].! !!ChangeList methodsFor: 'menu actions' stamp: 'ul 11/15/2010 11:31' prior: 58447892!browseCurrentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	| aList |	aList := OrderedCollection new.	Cursor read showWhile: [		1 to: changeList size do: [:i |			(listSelections at: i) ifTrue: [				| aClass aChange |				aChange := changeList at: i.				(aChange type = #method					and: [(aClass := aChange methodClass) notNil					and: [aClass includesSelector: aChange methodSelector]])						ifTrue: [							aList add: (								MethodReference new									setStandardClass: aClass  									methodSymbol: aChange methodSelector							)						]]]].	aList size = 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].	ToolSet		browseMessageSet: aList		name: 'Current versions of selected methods in ', file localName		autoSelect: nil! !!ChangeList methodsFor: 'menu actions' stamp: 'ul 11/15/2010 11:34' prior: 18174210!removeNonSelections	"Remove the unselected items from the receiver."	| newChangeList newList |	newChangeList := OrderedCollection new.	newList := OrderedCollection new.	1 to: changeList size do:		[:i | (listSelections at: i) ifTrue:			[newChangeList add: (changeList at: i).			newList add: (list at: i)]].	newChangeList size = 0 ifTrue:		[^ self inform: 'That would remove everything.Why would you want to do that?'].	newChangeList size < changeList size		ifTrue:			[changeList := newChangeList.			list := newList.			listIndex := 0.			listSelections := Array new: list size withAll: false].	self changed: #list	! !!Utilities class methodsFor: '*Tools' stamp: 'ul 11/15/2010 12:09' prior: 32907902!browseRecentSubmissions	"Open up a browser on the most recent methods submitted in the image.  5/96 sw."	"Utilities browseRecentSubmissions"	| recentMessages |	self recentMethodSubmissions size = 0 ifTrue:		[^ self inform: 'There are no recent submissions'].		recentMessages := RecentSubmissions copy reversed.	RecentMessageSet 		openMessageList: recentMessages 		name: 'Recent submissions -- youngest first ' 		autoSelect: nil! !!VersionsBrowser methodsFor: 'misc' stamp: 'ul 11/15/2010 12:10' prior: 32949959!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"Add an annotation detailing the prior versions count.  Specially handled here for the case of a selector no longer in the system, whose prior versions are seen in a versions browser -- in this case, the inherited version of this method will not work."	(aClass includesSelector: aSelector) ifTrue:		[^ super addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream].	aStream nextPutAll: 		((changeList size > 0			ifTrue:				[changeList size = 1					ifTrue:						['Deleted - one prior version']					ifFalse:						['Deleted - ', changeList size printString, ' prior versions']]			ifFalse:				['surprisingly, no prior versions']), self annotationSeparator)! !!VersionsBrowser methodsFor: 'init & update' stamp: 'ul 11/15/2010 12:10' prior: 53967645!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp cat |	selectorOfMethod := selector.	currentCompiledMethod := method.	classOfMethod := meta ifTrue: [class class] ifFalse: [class].	cat := category ifNil: [''].	changeList := OrderedCollection new.	list := OrderedCollection new.	self addedChangeRecord ifNotNil: [ :change |		self addItem: change text: ('{1} (in {2})' translated format: { change stamp. change fileName }) ].	listIndex := 0.	position := method filePosition.	sourceFilesCopy := SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex = 0 ifTrue: [^ nil].	file := sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[preamble := method getPreambleFrom: file at: (0 max: position - 3).		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos := nil.		stamp := ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens := Scanner new scanTokens: preamble]			ifFalse: [tokens := Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size - 3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size - 2.						prevPos := tokens last.						prevFileIndex := sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos := sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos := tokens at: tokens size - 2.						prevFileIndex := tokens last].				cat := tokens at: tokens size - 4.				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos := nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size - 1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp := tokens at: tokens size].				cat := tokens at: tokens size - 2]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector, ' {', cat, '}'.		position := prevPos.		prevPos notNil ifTrue:			[file := sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections := Array new: list size withAll: false! !!MessageNames methodsFor: 'selector list' stamp: 'ul 11/15/2010 11:53' prior: 23706882!messageList	"Answer the receiver's message list, computing it if necessary. The way 	to force a recomputation is to set the messageList to nil"	messageList		ifNil: [messageList := selectorListIndex = 0						ifTrue: [#()]						ifFalse: [self systemNavigation								allImplementorsOf: (selectorList at: selectorListIndex)].			self				messageListIndex: (messageList size > 0						ifTrue: [1]						ifFalse: [0])].	^ messageList! !!CodeHolder methodsFor: 'annotation' stamp: 'ul 11/15/2010 11:35' prior: 18721063!addPriorVersionsCountForSelector: aSelector ofClass: aClass to: aStream	"add an annotation detailing the prior versions count"	| versionsCount |	versionsCount := VersionsBrowser versionCountForSelector: aSelector class: aClass.	aStream nextPutAll: 				((versionsCount > 1					ifTrue:						[versionsCount = 2 ifTrue:							['1 prior version']							ifFalse:								[versionsCount printString, ' prior versions']]					ifFalse:						['no prior versions']), self annotationSeparator)! !!CodeHolder methodsFor: 'annotation' stamp: 'ul 11/15/2010 11:35' prior: 54389240!annotationForSelector: aSelector ofClass: aClass 	"Provide a line of content for an annotation pane, representing  	information about the given selector and class"	| separator aStream requestList |	aSelector == #Comment		ifTrue: [^ self annotationForClassCommentFor: aClass].	aSelector == #Definition		ifTrue: [^ self annotationForClassDefinitionFor: aClass].	aSelector == #Hierarchy		ifTrue: [^ self annotationForHierarchyFor: aClass].	aStream := ReadWriteStream on: ''.	requestList := self annotationRequests.	separator := requestList size > 1				ifTrue: [self annotationSeparator]				ifFalse: [''].	requestList		do: [:aRequest | | aString sendersCount aComment aCategory implementorsCount aList stamp | 			aRequest == #firstComment				ifTrue: [aComment := aClass firstCommentAt: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #masterComment				ifTrue: [aComment := aClass supermostPrecodeCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #documentation				ifTrue: [aComment := aClass precodeCommentOrInheritedCommentFor: aSelector.					aComment isEmptyOrNil						ifFalse: [aStream nextPutAll: aComment , separator]].			aRequest == #timeStamp				ifTrue: [stamp := self timeStamp.					aStream						nextPutAll: (stamp size > 0								ifTrue: [stamp , separator]								ifFalse: ['no timeStamp' , separator])].			aRequest == #messageCategory				ifTrue: [aCategory := aClass organization categoryOfElement: aSelector.					aCategory						ifNotNil: ["woud be nil for a method no longer present,  							e.g. in a recent-submissions browser"							aStream nextPutAll: aCategory , separator]].			aRequest == #sendersCount				ifTrue: [sendersCount := (self systemNavigation allCallsOn: aSelector) size.					sendersCount := sendersCount = 1								ifTrue: ['1 sender']								ifFalse: [sendersCount printString , ' senders'].					aStream nextPutAll: sendersCount , separator].			aRequest == #implementorsCount				ifTrue: [implementorsCount := self systemNavigation numberOfImplementorsOf: aSelector.					implementorsCount := implementorsCount = 1								ifTrue: ['1 implementor']								ifFalse: [implementorsCount printString , ' implementors'].					aStream nextPutAll: implementorsCount , separator].			aRequest == #priorVersionsCount				ifTrue: [self						addPriorVersionsCountForSelector: aSelector						ofClass: aClass						to: aStream].			aRequest == #priorTimeStamp				ifTrue: [stamp := VersionsBrowser								timeStampFor: aSelector								class: aClass								reverseOrdinal: 2.					stamp						ifNotNil: [aStream nextPutAll: 'prior time stamp: ' , stamp , separator]].			aRequest == #recentChangeSet				ifTrue: [aString := ChangesOrganizer mostRecentChangeSetWithChangeForClass: aClass selector: aSelector.					aString size > 0						ifTrue: [aStream nextPutAll: aString , separator]].			aRequest == #allChangeSets				ifTrue: [aList := ChangesOrganizer allChangeSetsWithClass: aClass selector: aSelector.					aList size > 0						ifTrue: [aList size = 1								ifTrue: [aStream nextPutAll: 'only in change set ']								ifFalse: [aStream nextPutAll: 'in change sets: '].							aList								do: [:aChangeSet | aStream nextPutAll: aChangeSet name , ' ']]						ifFalse: [aStream nextPutAll: 'in no change set'].					aStream nextPutAll: separator]].	^ aStream contents! !!CodeHolder methodsFor: 'traits' stamp: 'ul 11/15/2010 11:35' prior: 50669054!showUnreferencedClassVars	"Search for all class variables known to the selected class, and put up a 	list of those that have no references anywhere in the system. The 	search includes superclasses, so that you don't need to navigate your 	way to the class that defines each class variable in order to determine 	whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := self systemNavigation allUnreferencedClassVariablesOf: cls.	aList size = 0		ifTrue: [^ self inform: 'There are no unreferencedclass variables in' , cls name].	aReport := String				streamContents: [:aStream | 					aStream nextPutAll: 'Unreferenced class variable(s) in ' , cls name;						 cr.					aList						do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	UIManager default chooseFrom: aList values: aList 		title: 'Unreferencedclass variables in ' , cls name! !!CodeHolder methodsFor: 'traits' stamp: 'ul 11/15/2010 11:35' prior: 50666304!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	((cls := self selectedClassOrMetaClass) isNil or: [cls isTrait]) ifTrue: [^ self].	aList := cls allUnreferencedInstanceVariables.	aList size = 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport := String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	UIManager default chooseFrom: aList values: aList title: 'Unreferencedinstance variables in ', cls name! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:43' prior: 21869756!chasePointers	| selected  saved |	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	selected := self selection.	saved := self object.	[self object: nil.	(Smalltalk includesKey: #PointerFinder)		ifTrue: [PointerFinder on: selected]		ifFalse: [self inspectPointers]]		ensure: [self object: saved]! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:43' prior: 21873770!inspectElement	| sel selSize countString count nameStrs |	"Create and schedule an Inspector on an element of the receiver's model's currently selected collection."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	((sel := self selection) isKindOf: SequenceableCollection) ifFalse:		[(sel isKindOf: MorphExtension) ifTrue: [^ sel inspectElement].		^ sel inspect].	(selSize := sel size) = 1 ifTrue: [^ sel first inspect].	selSize <= 20 ifTrue:		[nameStrs := (1 to: selSize) asArray collect: [:ii | 			ii printString, '   ', (((sel at: ii) printStringLimitedTo: 25) replaceAll: Character cr with: Character space)].		count := UIManager default chooseFrom: (nameStrs substrings) title: 'which element?'.		count = 0 ifTrue: [^ self].		^ (sel at: count) inspect].	countString := UIManager default request: 'Which element? (1 to ', selSize printString, ')' initialAnswer: '1'.	countString isEmptyOrNil ifTrue: [^ self].	count := Integer readFrom: (ReadStream on: countString).	(count > 0 and: [count <= selSize])		ifTrue: [(sel at: count) inspect]		ifFalse: [Beeper beep]! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:44' prior: 21875853!objectReferencesToSelection	"Open a list inspector on all the objects that point to the value of the selected instance variable, if any.  "	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	self systemNavigation		browseAllObjectReferencesTo: self selection		except: (Array with: self object)		ifNone: [:obj | self changed: #flash].! !!Inspector methodsFor: 'menu commands' stamp: 'ul 11/15/2010 11:44' prior: 21877436!viewerForValue	"Open up a viewer on the value of the receiver's current selection"	| objectToRepresent |	objectToRepresent := self selectionIndex = 0 ifTrue: [object] ifFalse: [self selection].	objectToRepresent beViewed	! !!ChangeSorter class methodsFor: 'browse' stamp: 'ul 11/15/2010 11:35' prior: 18403522!browseChangeSetsWithClass: class selector: selector	"Put up a menu comprising a list of change sets that hold changes for the given class and selector.  If the user selects one, open a single change-sorter onto it"	| hits index |	hits := self allChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ self inform: class name, '.', selector , 'is not in any change set'].	index := hits size = 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSorter new myChangeSet: (hits at: index)) open.! !!ChangeSorter class methodsFor: 'browse' stamp: 'ul 11/15/2010 11:35' prior: 18404241!browseChangeSetsWithSelector: aSelector	"Put up a list of all change sets that contain an addition, deletion, or change of any method with the given selector"	| hits index |	hits := self allChangeSets select: 		[:cs | cs hasAnyChangeForSelector: aSelector].	hits isEmpty ifTrue: [^ self inform: aSelector , 'is not in any change set'].	index := hits size = 1		ifTrue:	[1]		ifFalse:	[(UIManager default chooseFrom: (hits collect: [:cs | cs name])					lines: #())].	index = 0 ifTrue: [^ self].	(ChangeSetBrowser new myChangeSet: (hits at: index)) open"ChangeSorter browseChangeSetsWithSelector: #clearPenTrails"! !!ChangeSorter methodsFor: 'code pane' stamp: 'ul 11/15/2010 11:34' prior: 18375810!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	(class := self selectedClassOrMetaClass) ifNil:		[(myChangeSet preambleString == nil or: [aString size = 0]) ifTrue: [ ^ false].		(aString count: [:char | char == $"]) odd 			ifTrue: [self inform: 'unmatched double quotes in preamble']			ifFalse: [(Scanner new scanTokens: aString) size > 0 ifTrue: [				self inform: 'Part of the preamble is not within double-quotes.To put a double-quote inside a comment, type two double-quotes in a row.(Ignore this warning if you are including a doIt in the preamble.)']].		myChangeSet preambleString: aString.		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"		^ true].	oldSelector := self selectedMessageName.	category := class organization categoryOfElement: oldSelector.	selector := class compile: aString				classified: category				notifying: aController.	selector ifNil: [^ false].	(self messageList includes: selector)		ifTrue: [self currentSelector: selector]		ifFalse: [self currentSelector: oldSelector].	self update.	^ true! !!ChangeSorter methodsFor: 'message list' stamp: 'ul 11/15/2010 11:34' prior: 18391264!removeMessage	"Remove the selected msg from the system. Real work done by the 	parent, a ChangeSorter"	| confirmation sel |	self okToChange		ifFalse: [^ self].	currentSelector		ifNotNil: [confirmation := self systemNavigation   confirmRemovalOf: (sel := self selectedMessageName) on: self selectedClassOrMetaClass.			confirmation = 3				ifTrue: [^ self].			self selectedClassOrMetaClass removeSelector: sel.			self update.			confirmation = 2				ifTrue: [self systemNavigation browseAllCallsOn: sel]]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'ul 11/15/2010 11:34' prior: 18357645!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName := UIManager default request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size = 0]) ifTrue:			[^ Beeper beep].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!Browser methodsFor: 'class list' stamp: 'ul 11/15/2010 11:30' prior: 34065987!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className currentMessageCategoryName currentMessageName |	currentMessageCategoryName := [self selectedMessageCategoryName]										on: Error										do: [:ex| ex return: nil].	currentMessageName := [self selectedMessageName]								on: Error								do: [:ex| ex return: nil].	classListIndex := anInteger.	self setClassOrganizer.	"Try to reselect the category and/or selector if the new class has them."	messageCategoryListIndex := self messageCategoryList										indexOf: currentMessageCategoryName										ifAbsent: [0].	messageListIndex := messageCategoryListIndex = 0							ifTrue: [0]							ifFalse: [self messageList										indexOf: currentMessageName										ifAbsent: [0]].	messageListIndex ~= 0 ifTrue:		[self editSelection: #editMessage] ifFalse:	[messageCategoryListIndex ~= 0 ifTrue:		[self editSelection: #newMessage] ifFalse:	[self classCommentIndicated		ifTrue: []		ifFalse: [self editSelection: (anInteger = 0					ifTrue: [(metaClassIndicated or: [ systemCategoryListIndex = 0 ])						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass])]]].	contents := nil.	self selectedClass isNil		ifFalse: [className := self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classCommentText.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #relabel.	self contentsChanged! !!Browser methodsFor: 'drag and drop' stamp: 'ul 11/8/2010 03:36' prior: 53966802!dropOnMessageCategories: method at: index	| dstClass category copy |	copy := Sensor shiftPressed.	(method isKindOf: CompiledMethod) 		ifFalse:[^self inform: 'Can only drop methods'].	dstClass := self selectedClassOrMetaClass.	(dstClass == method methodClass) ifTrue:[		category := self messageCategoryList at: index.		dstClass organization classify: method selector  under: category.		^true].	copy ifFalse: [		(self confirm: (			'Classes {1} and {2} are unrelated.{3}Are you sure you want to move this method?'				format: { method methodClass. dstClass. Character cr })) 					ifFalse: [ ^false ] ].	dstClass		compile: method getSource		classified: (self messageCategoryList at: index)		withStamp: method timeStamp		notifying: nil.	copy ifFalse: [		method methodClass removeSelector: method selector ].	^true! !!Browser methodsFor: 'class list' stamp: 'ul 11/15/2010 11:30' prior: 58588367!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 : dont fall into debugger in empty case"	| className class recentList |	recentList := RecentClasses select: [:n | Smalltalk hasClassNamed: n].	recentList size = 0 ifTrue: [^ Beeper beep].	className := UIManager default chooseFrom: recentList values: recentList.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self selectCategoryForClass: class.	self classListIndex: (self classListIndexOf: class name)! !!Browser methodsFor: 'message functions' stamp: 'ul 11/15/2010 11:30' prior: 54617628!removeMessage	"If a message is selected, create a Confirmer so the user can verify that  	the currently selected message should be removed from the system. If 	so,  	remove it. If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0		ifTrue: [^ self].	self okToChange		ifFalse: [^ self].	messageName := self selectedMessageName.	confirmation := self systemNavigation   confirmRemovalOf: messageName on: self selectedClassOrMetaClass.	confirmation = 3		ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.	"In case organization not cached"	confirmation = 2		ifTrue: [self systemNavigation browseAllCallsOn: messageName]! !"Tools"!!SHParserST80 methodsFor: 'token testing' stamp: 'ul 11/15/2010 04:06' prior: 52360959!isKeyword	"This method assumes that currentTokenFirst is a non-letter character when currentToken is nil."	^(currentTokenFirst isLetter or: [		currentTokenFirst == $_ and: [			currentToken notNil and: [			currentToken size > 1 and: [			self allowUnderscoreSelectors ] ] ] ]) and: [		currentToken last == $: ]! !!SHParserST80 methodsFor: 'token testing' stamp: 'ul 11/15/2010 04:05' prior: 52361727!isName	"This method assumes that currentTokenFirst is a non-letter character when currentToken is nil."	^(currentTokenFirst isLetter or: [ 		currentTokenFirst == $_ and: [			currentToken notNil and: [			currentToken size > 1 and: [			self allowUnderscoreSelectors ] ] ] ]) and: [		currentToken last isAlphaNumeric or: [			currentToken last == $_ and: [				self allowUnderscoreSelectors ] ] ] ! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 11/15/2010 08:50' prior: 53770730!parseSymbol	| c |	currentToken = '#' 		ifTrue: [			"if token is just the #, then scan whitespace and comments			and then process the next character.			Squeak allows space between the # and the start of the symbol 			e.g. # (),  #  a, #  'sym' "			self rangeType: #symbol.			self scanWhitespace].	c := self currentChar.	self failWhen: (c isNil or: [c isSeparator]).	c == $( 		ifTrue: [			self nextChar.			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.			^self parseArray].	c == $' ifTrue: [^self parseSymbolString].	c == $[ ifTrue: [			self nextChar.			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.			^self parseByteArray].	((self isSelectorCharacter: c) or: [c == $-]) 		ifTrue: [^self parseSymbolSelector].	(c isLetter or: [		c == $: or: [ 		c == $_ and: [self allowUnderscoreSelectors] ] ]) 			ifTrue: [^self parseSymbolIdentifier].	^self parseCharSymbol! !!SHParserST80 methodsFor: 'accessing' stamp: 'ul 11/15/2010 04:14'!ranges	^ranges! !!SHParserST80 methodsFor: 'scan' stamp: 'ul 11/15/2010 03:31' prior: 33754109!scanNext	self scanWhitespace.	currentTokenFirst := self currentChar.	currentTokenFirst 		ifNil: [" end of input "			currentTokenFirst := $ .			currentTokenSourcePosition := nil.			currentToken := nil.			^nil].	currentTokenFirst isDigit ifTrue: [^self scanNumber].	(currentTokenFirst isLetter or: [		currentTokenFirst == $_ and: [ self allowUnderscoreSelectors ] ])			ifTrue: [^self scanIdentifier].	^self scanBinary! !!SystemDictionary methodsFor: '*ShoutCore' stamp: 'ul 11/17/2010 05:20' prior: 34652850!hasBindingThatBeginsWith: aString	"Use the cached class and non-class names for better performance."	| name searchBlock |	searchBlock := [ :element |		(element beginsWith: aString)			ifTrue: [ 0 ]			ifFalse: [				aString < element					ifTrue: [ -1 ]					ifFalse: [ 1 ] ] ].	name := self classNames 		findBinary: searchBlock		ifNone: [ nil ].	name ifNotNil: [ ^true ].	name := self nonClassNames 		findBinary: searchBlock		ifNone: [ nil ].	^name notNil! !"ShoutCore"!!TerseGuideHelp commentStamp: 'dtl 11/26/2010 12:17' prior: 0!TerseGuideHelp contains the Squeak terse guide by Chris Rathman (http://www.angelfire.com/tx4/cus/notes/smalltalk.html), maintained on the swiki at http://wiki.squeak.org/squeak/5699. Copyrights and credit for the original document belong to Chris Rathman.The original document was formatted for printing with a fixed font. Here it is reformatted for display in a help browser, with various updates and corrections to match the current state of the Squeak image. The contents of the help pages may be evaluated as workspace expressions.HelpBrowser openOn: TerseGuideHelp!!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:25'!arithmetic	^HelpTopic		title: 'Arithmetic Expressions' 		contents:'"************************************************************************ * Arithmetic expressions:															* ************************************************************************"| x |x := 6 + 3.								"addition"x := 6 - 3.								"subtraction"x := 6 * 3.								"multiplication"x := 1 + 2 * 3.							"evaluation always left to right (1 + 2) * 3"x := 5 / 3.								"division with fractional result"x := 5.0 / 3.0.							"division with float result"x := 5.0 // 3.0.							"integer divide"x := 5.0 \\ 3.0.							"integer remainder"x := -5.									"unary minus"x := 5 sign.								"numeric sign (1, -1 or 0)"x := 5 negated.							"negate receiver"x := 1.2 integerPart.						"integer part of number (1.0)"x := 1.2 fractionPart.					"fractional part of number (0.2)"x := 5 reciprocal.						"reciprocal function"x := 6 * 3.1.								"auto convert to float"x := 5 squared.							"square function"x := 25 sqrt.							"square root"x := 5 raisedTo: 2.						"power function"x := 5 raisedToInteger: 2.				"power function with integer"x := 5 exp.								"exponential"x := -5 abs.								"absolute value"x := 3.99 rounded.						"round"x := 3.99 truncated.						"truncate"x := 3.99 roundTo: 1.					"round to specified decimal places"x := 3.99 truncateTo: 1.					"truncate to specified decimal places"x := 3.99 floor.							"truncate"x := 3.99 ceiling.						"round up"x := 5 factorial.							"factorial"x := -5 quo: 3.							"integer divide rounded toward zero"x := -5 rem: 3.							"integer remainder rounded toward zero"x := 28 gcd: 12.							"greatest common denominator"x := 28 lcm: 12.							"least common multiple"x := 100 ln.								"natural logarithm"x := 100 log.							"base 10 logarithm"x := 100 log: 10	.						"logarithm with specified base"x := 100 floorLog: 10.					"floor of the log"x := 180 degreesToRadians.			"convert degrees to radians"x := 3.14 radiansToDegrees.			"convert radians to degrees"x := 0.7 sin.								"sine"x := 0.7 cos.							"cosine"x := 0.7 tan.								"tangent"x := 0.7 arcSin.							"arcsine"x := 0.7 arcCos.							"arccosine"x := 0.7 arcTan.							"arctangent"x := 10 max: 20.							"get maximum of two numbers"x := 10 min: 20.							"get minimum of two numbers"x := Float pi.							"pi"x := Float e.								"exp constant"x := Float infinity.						"infinity"x := Float nan.							"not-a-number"x := Random new next; yourself. x next.	"random number stream (0.0 to 1.0)"x := 100 atRandom.						"quick random number"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:46'!array	^HelpTopic		title: 'Array' 		contents:'"************************************************************************ * Array:         Fixed length collection												* * ByteArray:     Array limited to byte elements (0-255)								* * WordArray:     Array limited to word elements (0-2^32)							* ************************************************************************"| b x y sum max |x := #(4 3 2 1).									"constant array"x := Array with: 5 with: 4 with: 3 with: 2.			"create array with up to 4 elements"x := Array new: 4.								"allocate an array with specified size"x												"set array elements"   at: 1 put: 5;   at: 2 put: 4;   at: 3 put: 3;   at: 4 put: 2.b := x isEmpty.									"test if array is empty"y := x size.										"array size"y := x at: 4.										"get array element at index"b := x includes: 3.								"test if element is in array"y := x copyFrom: 2 to: 4.						"subarray"y := x indexOf: 3 ifAbsent: [0].					"first position of element within array"y := x occurrencesOf: 3.						"number of times object in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the array"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum array elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum array elements"sum := x inject: 0 into: [:a :c | a + c].				"sum array elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in array"   ifTrue: [a]   ifFalse: [c]].y := x shuffled.									"randomly shuffle collection"y := x asArray.									"convert to array"y := x asByteArray.								"convert to byte array"y := x asWordArray.								"convert to word array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:10'!assignment	^HelpTopic		title: 'Assignment' 		contents:'"************************************************************************ * Assignment:																		* ************************************************************************"| x y z |x _ 4.									"assignment (Squeak) <-"x := 5.									"assignment"x := y := z := 6.							"compound assignment"x := (y := 6) + 1.x := Object new.						"bind to allocated instance of a class"x := 123 class.							"discover the object class"x := Integer superclass.					"discover the superclass of a class"x := Object allInstances.				"get an array of all instances of a class"x := Integer allSuperclasses.			"get all superclasses of a class"x := 1.2 hash.							"hash value for object"y := x copy.								"copy object"y := x shallowCopy.						"copy object (not overridden)"y := x deepCopy.						"copy object and instance vars"y := x veryDeepCopy.					"complete tree copy using a dictionary"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:31'!association	^HelpTopic		title: 'Association' 		contents:'"************************************************************************ * Associations:																		* ************************************************************************"| x y |x := #myVar->''hello''.y := x key.y := x value.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!bag	^HelpTopic		title: 'Bag' 		contents:'"************************************************************************ * Bag:        like OrderedCollection except elements are in no						* *                particular order														* ************************************************************************"| b x y sum max |x := Bag with: 4 with: 3 with: 2 with: 1.			"create collection with up to 4 elements"x := Bag new.									"allocate collection"x add: 4; add: 3; add: 1; add: 2; yourself.			"add element to collection"x add: 3 withOccurrences: 2.					"add multiple copies to collection"y := x addAll: #(7 8 9).							"add multiple elements to collection"y := x removeAll: #(7 8 9).						"remove multiple elements from collection"y := x remove: 4 ifAbsent: [].					"remove element from collection"b := x isEmpty.									"test if empty"y := x size.										"number of elements"b := x includes: 3.								"test if element is in collection"y := x occurrencesOf: 3.						"number of times object in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:34'!bitwise	^HelpTopic		title: 'Bitwise Manipulation' 		contents:'"************************************************************************ * Bitwise Manipulation:																* ************************************************************************"| b x |x := 16rFF bitAnd: 16r0F.			"and bits"x := 16rF0 bitOr: 16r0F.				"or bits"x := 16rFF bitXor: 16r0F.				"xor bits"x := 16rFF bitInvert.					"invert bits"x := 16r0F bitShift: 4.				"left shift"x := 16rF0 bitShift: -4.				"right shift"x := 16r80 bitAt: 8.					"bit at position (0|1)"x := 16r80 highBit.					"position of highest bit set"b := 16rFF allMask: 16r0F.			"test if all bits set in mask set in receiver"b := 16rFF anyMask: 16r0F.			"test if any bits set in mask set in receiver"b := 16rFF noMask: 16r0F.			"test if all bits set in mask clear in receiver"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/28/2010 19:34'!block	^HelpTopic		title: 'Blocks' 		contents:'"************************************************************************ * Blocks:																			* *    - blocks are objects and may be assigned to a variable						* *    - value is last expression evaluated unless explicit return						* *    - blocks may be nested														* *    - specification [ arguments | | localvars | expressions ]							* *    - ^expression terminates block & method (exits all nested blocks)			* *    - blocks intended for long term storage should not contain ^					* ************************************************************************"| x y z fac |x := [ y := 1. z := 2. ]. x value.						"simple block usage"x := [ :argOne :argTwo |   argOne, '' and '' , argTwo.].	"set up block with argument passing"Transcript show: (x value: ''First'' value: ''Second''); cr.	"use block with argument passing"x := [:e | | v | v := 1. e + v] value: 2.					"localvar in a block"fac := [ :n | n > 1 ifTrue:  [n * (fac value: n-1)] ifFalse: [1]].	"closure on block variable"fac value: 5.											"closure variable scoped to its block"'! !!TerseGuideHelp class methodsFor: 'accessing' stamp: 'dtl 11/25/2010 10:56'!bookName	^'Terse Guide'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:08'!boolean	^HelpTopic		title: 'Boolean' 		contents:'"************************************************************************ * Booleans:																		* ************************************************************************"| b x y |x := 1. y := 2.b := (x = y).								"equals"b := (x ~= y).							"not equals"b := (x == y).							"identical"b := (x ~~ y).							"not identical"b := (x > y).								"greater than"b := (x < y).								"less than"b := (x >= y).							"greater than or equal"b := (x <= y).							"less than or equal"b := b not.								"boolean not"b := (x < 5) & (y > 1).					"boolean and"b := (x < 5) | (y > 1).					"boolean or"b := (x < 5) and: [y > 1].					"boolean and (short-circuit)"b := (x < 5) or: [y > 1].					"boolean or (short-circuit)"b := (x < 5) eqv: (y > 1).					"test if both true or both false"b := (x < 5) xor: (y > 1).					"test if one true and other false"b := 5 between: 3 and: 12.				"between (inclusive)"b := 123 isKindOf: Number.				"test if object is class or subclass of"b := 123 isMemberOf: SmallInteger.		"test if object is type of class"b := 123 respondsTo: #sqrt.			"test if object responds to message"b := x isNil.								"test if object is nil"b := x isZero.							"test if number is zero"b := x positive.							"test if number is positive"b := x strictlyPositive.					"test if number is greater than zero"b := x negative.							"test if number is negative"b := x even.								"test if number is even"b := x odd.								"test if number is odd"b := x isLiteral.							"test if literal constant"b := x isInteger.							"test if object is integer"b := x isFloat.							"test if object is float"b := x isNumber.						"test if object is number"b := $A isUppercase.					"test if upper case character"b := $A isLowercase.					"test if lower case character"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:17'!character	^HelpTopic		title: 'Character' 		contents:'"************************************************************************ * Character:																		* ************************************************************************"| x y b |x := $A.										"character assignment"y := x isLowercase.							"test if lower case"y := x isUppercase.							"test if upper case"y := x isLetter.								"test if letter"y := x isDigit.								"test if digit"y := x isAlphaNumeric.						"test if alphanumeric"y := x isSeparator.							"test if seperator char"y := x isVowel.								"test if vowel"y := x digitValue.							"convert to numeric digit value"y := x asLowercase.						"convert to lower case"y := x asUppercase.						"convert to upper case"y := x asciiValue.							"convert to numeric ascii value"y := x asString.								"convert to string"b := $A <= $B.								"comparison"y := $A max: $B.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:16'!conditionalStatement	^HelpTopic		title: 'Conditional Statement' 		contents:'"************************************************************************ * Conditional Statements:															* ************************************************************************"| x switch result |x := 11.x > 10 ifTrue: [Transcript show: ''ifTrue''; cr].		"if then"x > 10 ifFalse: [Transcript show: ''ifFalse''; cr].	"if else"x > 10											"if then else"   ifTrue: [Transcript show: ''ifTrue''; cr]   ifFalse: [Transcript show: ''ifFalse''; cr].x > 10											"if else then"   ifFalse: [Transcript show: ''ifFalse''; cr]   ifTrue: [Transcript show: ''ifTrue''; cr].Transcript   show:      (x > 10         ifTrue: [''ifTrue'']         ifFalse: [''ifFalse'']);   cr.Transcript										"nested if then else"   show:      (x > 10         ifTrue: [x > 5            ifTrue: [''A'']            ifFalse: [''B'']]         ifFalse: [''C'']);   cr.switch := Dictionary new.						"switch functionality"switch at: $A put: [Transcript show: ''Case A''; cr].switch at: $B put: [Transcript show: ''Case B''; cr].switch at: $C put: [Transcript show: ''Case C''; cr].result := (switch at: $B) value.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:11'!constants	^HelpTopic		title: 'Constants' 		contents:'"************************************************************************ * Constants:																		* ************************************************************************"| b x |b := true.								"true constant"b := false.								"false constant"x := nil.									"nil object constant"x := 1.									"integer constants"x := 3.14.								"float constants"x := 2e-2.								"fractional constants"x := 16r0F.								"hex constant".x := -1.									"negative constants"x := ''Hello''.								"string constant"x := ''I''''m here''.							"single quote escape"x := $A.									"character constant"x := $ .									"character constant (space)"x := #aSymbol.							"symbol constants"x := #(3 2 1).							"array constants"x := #(''abc'' 2 $a).						"mixing of types allowed"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:57'!conversion	^HelpTopic		title: 'Conversion' 		contents:'"************************************************************************ * Conversion:																		* ************************************************************************"| x |x := 3.99 asInteger.				"convert number to integer (truncates in Squeak)"x := 3.99 asFraction.			"convert number to fraction"x := 3 asFloat.					"convert number to float"x := 65 asCharacter.			"convert integer to character"x := $A asciiValue.				"convert character to integer"x := 3.99 printString.			"convert object to string via printOn:"x := 3.99 storeString.			"convert object to string via storeOn:"x := 15 radix: 16.				"convert to string in given base"x := 15 printStringBase: 16.x := 15 storeStringBase: 16.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:19'!date	^HelpTopic		title: 'Date' 		contents:'"************************************************************************ * Date:																				* ************************************************************************"| x y b |x := Date today.								"create date for today"x := Date dateAndTimeNow.					"create date from current time/date"x := Date readFromString: ''01/02/1999''.			"create date from formatted string"x := Date newDay: 12 month: #July year: 1999.	"create date from parts"x := Date fromDays: 36000.						"create date from elapsed days since 1/1/1901"y := Date dayOfWeek: #Monday.				"day of week as int (1-7)"y := Date indexOfMonth: #January.				"month of year as int (1-12)"y := Date daysInMonth: 2 forYear: 1996.			"day of month as int (1-31)"y := Date daysInYear: 1996.						"days in year (365|366)"y := Date nameOfDay: 1.						"weekday name (#Monday,...)"y := Date nameOfMonth: 1.						"month name (#January,...)"y := Date leapYear: 1996.						"1 if leap year; 0 if not leap year"y := x weekday.									"day of week (#Monday,...)"y := x previous: #Monday.						"date for previous day of week"y := x dayOfMonth.								"day of month (1-31)"y := x day.										"day of year (1-366)"y := x firstDayOfMonth.							"day of year for first day of month"y := x monthName.								"month of year (#January,...)"y := x monthIndex.								"month of year (1-12)"y := x daysInMonth.								"days in month (1-31)"y := x year.										"year (19xx)"y := x daysInYear.								"days in year (365|366)"y := x daysLeftInYear.							"days left in year (364|365)"y := x asSeconds.								"seconds elapsed since 1/1/1901"y := x addDays: 10.								"add days to date object"y := x subtractDays: 10.							"subtract days to date object"y := x subtractDate: (Date today).				"subtract date (result in days)"y := x printFormat: #(2 1 3 $/ 1 1).				"print formatted date"b := (x <= Date today).							"comparison"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 13:16'!debugging	^HelpTopic		title: 'Debugging' 		contents:'"************************************************************************ * debugging:																		* ************************************************************************"| a b x |x := Object new.x yourself.								"returns receiver"String browse.							"browse specified class"x inspect.								"open object inspector window"x confirm: ''Is this correct?''.x halt.									"breakpoint to open debugger window"x halt: ''Halt message''.x notify: ''Notify text''.x error: ''Error string''.					"open up error window with title"x shouldNotImplement.					"flag message should not be implemented"x subclassResponsibility.				"flag message as abstract"x errorImproperStore.					"flag an improper store into indexable object"x errorNonIntegerIndex.				"flag only integers should be used as index"x errorSubscriptBounds: 13.			"flag subscript out of bounds"x primitiveFailed.						"system primitive failed"a := ''A1''. b := ''B2''. a become: b.			"switch two objects"Transcript show: a, b; cr.x doesNotUnderstand: (Message selector: #foo).	"flag message is not handled"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:05'!dictionary	^HelpTopic		title: 'Dictionary' 		contents:'"************************************************************************ * Dictionary:																		* * IdentityDictionary:   uses identity test (== rather than =)							* ************************************************************************"| b x y sum max |x := Dictionary new.								"allocate collection"x add: #a->4; add: #b->3; add: #c->1; add: #d->2; yourself.		"add element to collection"x at: #e put: 3.									"set element at index"b := x isEmpty.									"test if empty"y := x size.										"number of elements"y := x at: #a ifAbsent: [].							"retrieve element at index"y := x keyAtValue: 3 ifAbsent: [].					"retrieve key for given value with error block"y := x removeKey: #e ifAbsent: [].				"remove element from collection"b := x includes: 3.								"test if element is in values collection"b := x includesKey: #a.							"test if element is in keys collection"y := x occurrencesOf: 3.						"number of times object in collection"y := x keys.										"set of keys"y := x values.									"bag of values"x do: [:a | Transcript show: a printString; cr].		"iterate over the values collection"x keysDo: [:a | Transcript show: a printString; cr].			"iterate over the keys collection"x associationsDo: [:a | Transcript show: a printString; cr].	"iterate over the associations"x keysAndValuesDo: [:aKey :aValue | Transcript				"iterate over keys and values"   show: aKey printString; space;   show: aValue printString; cr].b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"Smalltalk at: #CMRGlobal put: ''CMR entry''.		"put global in Smalltalk Dictionary"x := Smalltalk at: #CMRGlobal.					"read global from Smalltalk Dictionary"Transcript show: (CMRGlobal printString).		"entries are directly accessible by name"Smalltalk keys do: [ :k |							"print out all classes"   ((Smalltalk at: k) isKindOf: Class)      ifFalse: [Transcript show: k printString; cr]].Smalltalk at: #CMRDictionary put: (Dictionary new).	"set up user defined dictionary"CMRDictionary at: #MyVar1 put: ''hello1''.			"put entry in dictionary"CMRDictionary add: #MyVar2->''hello2''.			"add entry to dictionary use key->value combo"CMRDictionary size.		"dictionary size"CMRDictionary keys do: [ :k |					"print out keys in dictionary"   Transcript show: k printString; cr].CMRDictionary values do: [ :k |					"print out values in dictionary"   Transcript show: k printString; cr].CMRDictionary keysAndValuesDo: [:aKey :aValue |	"print out keys and values"   Transcript      show: aKey printString;      space;      show: aValue printString;      cr].CMRDictionary associationsDo: [:aKeyValue |		"another iterator for printing key values"   Transcript show: aKeyValue printString; cr].Smalltalk removeKey: #CMRGlobal ifAbsent: [].		"remove entry from Smalltalk dictionary"Smalltalk removeKey: #CMRDictionary ifAbsent: [].	"remove user dictionary from Smalltalk dictionary"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:37'!dynamic	^HelpTopic		title: 'Dynamic Message Calling/Compiling' 		contents:'"************************************************************************ * Dynamic Message Calling/Compiling:												* ************************************************************************"| receiver message result argument keyword1 keyword2 argument1 argument2 |"unary message"receiver := 5.message := ''factorial'' asSymbol.result := receiver perform: message.result := Compiler evaluate: ((receiver storeString), '' '', message).result := (Message new setSelector: message arguments: #()) sentTo: receiver."binary message"receiver := 1.message := ''+'' asSymbol.argument := 2.result := receiver perform: message withArguments: (Array with: argument).result := Compiler evaluate: ((receiver storeString), '' '', message, '' '', (argument storeString)).result := (Message new setSelector: message arguments: (Array with: argument)) sentTo: receiver."keyword messages"receiver := 12.keyword1 := ''between:'' asSymbol.keyword2 := ''and:'' asSymbol.argument1 := 10.argument2 := 20.result := receiver   perform: (keyword1, keyword2) asSymbol   withArguments: (Array with: argument1 with: argument2).result := Compiler evaluate:   ((receiver storeString), '' '', keyword1, (argument1 storeString) , '' '', keyword2, (argument2 storeString)).result := (Message   new      setSelector: (keyword1, keyword2) asSymbol      arguments: (Array with: argument1 with: argument2))   sentTo: receiver.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:34'!fileStream	^HelpTopic		title: 'File Stream' 		contents:'"************************************************************************ * FileStream:																		* ************************************************************************"| b x ios |ios := FileStream newFileNamed: ''ios.txt''.ios nextPut: $H; cr.ios nextPutAll: ''Hello File''; cr.''Hello File'' printOn: ios.''Hello File'' storeOn: ios.ios close.ios := FileStream oldFileNamed: ''ios.txt''.[(x := ios nextLine) notNil]   whileTrue: [Transcript show: x; cr].ios position: 3.x := ios position.x := ios next.x := ios peek.b := ios atEnd.ios close.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:33'!internalStream	^HelpTopic		title: 'Internal Stream' 		contents:'"************************************************************************ * Internal Stream:																	* ************************************************************************"| b x ios |ios := ReadStream on: ''Hello read stream''.ios := ReadStream on: ''Hello read stream'' from: 1 to: 5.[(x := ios nextLine) notNil]   whileTrue: [Transcript show: x; cr].ios position: 3.ios position.x := ios next.x := ios peek.x := ios contents.b := ios atEnd.ios := ReadWriteStream on: ''Hello read stream''.ios := ReadWriteStream on: ''Hello read stream'' from: 1 to: 5.ios := ReadWriteStream with: ''Hello read stream''.ios := ReadWriteStream with: ''Hello read stream'' from: 1 to: 10.ios position: 0.[(x := ios nextLine) notNil]   whileTrue: [Transcript show: x; cr].ios position: 6.ios position.ios nextPutAll: ''Chris''.x := ios next.x := ios peek.x := ios contents.b := ios atEnd.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:05'!interval	^HelpTopic		title: 'Interval' 		contents:'"************************************************************************ * Interval:																			* ************************************************************************"| b x y sum max |x := Interval from: 5 to: 10.						"create interval object"x := 5 to: 10.x := Interval from: 5 to: 10 by: 2.				"create interval object with specified increment"x := 5 to: 10 by: 2.b := x isEmpty.									"test if empty"y := x size.										"number of elements"x includes: 9.									"test if element is in collection"x do: [:k | Transcript show: k printString; cr].		"iterate over interval"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 7].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 11:14'!introduction	^HelpTopic		title: 'General' 		contents:'"************************************************************************ * Allowable characters:															* *    - a-z																			* *    - A-Z																			* *    - 0-9																			* *    - .+/\*~<>@%|&?																* *    - blank, tab, cr, ff, lf																* *																					* * Variables:																		* *    - variables must be declared before use										* *    - shared vars must begin with uppercase										* *    - local vars must begin with lowercase											* *    - reserved names: nil, true, false, self, super, and Smalltalk						* *																					* * Variable scope:																	* *    - Global: defined in Dictionary Smalltalk and accessible by all					* *         objects in system															* *    - Special: (reserved) Smalltalk, super, self, true, false, & nil						* *    - Method Temporary: local to a method										* *    - Block Temporary: local to a block												* *    - Pool: variables in a Dictionary object											* *    - Method Parameters: automatic local vars created as a result of 				* *         message call with params													* *    - Block Parameters: automatic local vars created as a result of					* *         value: message call															* *    - Class: shared with all instances of one class & its subclasses				* *    - Class Instance: unique to each instance of a class							* *    - Instance Variables: unique to each instance									* ************************************************************************""Comments are enclosed in quotes""Period (.) is the statement seperator"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:28'!iterationStatement	^HelpTopic		title: 'Iteration Statement' 		contents:'"************************************************************************ * Iteration statements:																* ************************************************************************"| x y |x := 4. y := 1.[x > 0] whileTrue: [x := x - 1. y := y * 2].		"while true loop"[x >= 4] whileFalse: [x := x + 1. y := y * 2].	"while false loop"x timesRepeat: [y := y * 2].					"times repear loop (i := 1 to x)"1 to: x do: [:a | y := y * 2].					"for loop"1 to: x by: 2 do: [:a | y := y / 2].				"for loop with specified increment"#(5 4 3) do: [:a | x := x + a].					"iterate over array elements"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:31'!metaclass	^HelpTopic		title: 'Class / Metaclass' 		contents:'"************************************************************************ * class/meta-class:																	* ************************************************************************"| b x |x := String name.						"class name"x := String category.					"organization category"x := String comment.					"class comment"x := String kindOfSubclass.				"subclass type - subclass: variableSubclass, etc"x := String definition.					"class definition"x := String instVarNames.				"immediate instance variable names"x := String allInstVarNames.				"accumulated instance variable names"x := String classVarNames.				"immediate class variable names"x := String allClassVarNames.			"accumulated class variable names"x := String sharedPools.					"immediate dictionaries used as shared pools"x := String allSharedPools.				"accumulated dictionaries used as shared pools"x := String selectors.					"message selectors for class"x := String sourceCodeAt: #indexOf:.	"source code for specified method"x := String allInstances.					"collection of all instances of class"x := String superclass.					"immediate superclass"x := String allSuperclasses.				"accumulated superclasses"x := String withAllSuperclasses.			"receiver class and accumulated superclasses"x := String subclasses.					"immediate subclasses"x := String allSubclasses.				"accumulated subclasses"x := String withAllSubclasses.			"receiver class and accumulated subclasses"b := String instSize.						"number of named instance variables"b := String isFixed.						"true if no indexed instance variables"b := String isVariable.					"true if has indexed instance variables"b := String isPointers.					"true if index instance vars contain objects"b := String isBits.						"true if index instance vars contain bytes/words"b := String isBytes.						"true if index instance vars contain bytes"b := String isWords.						"true if index instance vars contain words"Object withAllSubclasses size.			"get total number of class entries"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:27'!methodCall	^HelpTopic		title: 'Method Call' 		contents:'"************************************************************************ * Method calls:																		* *    - unary methods are messages with no arguments								* *    - binary methods																* *    - keyword methods are messages with selectors including colons				* *																					* * standard categories/protocols:													* *    - initialize-release    (methods called for new instance)							* *    - accessing             (get/set methods)											* *    - testing               (boolean tests - is)											* *    - comparing             (boolean tests with parameter							* *    - displaying            (gui related methods)										* *    - printing              (methods for printing)										* *    - updating              (receive notification of changes)							* *    - private               (methods private to class)									* *    - instance-creation     (class methods for creating instance)					* ************************************************************************"| x |x := 2 sqrt.									"unary message"x := 2 raisedTo: 10.							"keyword message"x := 194 * 9.								"binary message"Transcript show: (194 * 9) printString; cr.	"combination (chaining)"x := 2 perform: #sqrt.						"indirect method invocation"Transcript									"Cascading - send multiple messages to receiver"   show: ''hello '';   show: ''world'';   cr.x := 3 + 2; * 100.							"result=300. Sends message to same receiver (3)"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 14:00'!misc	^HelpTopic		title: 'Miscellaneous' 		contents:'"************************************************************************ * Misc.																				* ************************************************************************"| x |"Smalltalk condenseChanges."					"compress the change file"x := FillInTheBlank request: ''Prompt Me''.			"prompt user for input"x := UIManager default request: ''Prompt Me''.	"prompt user for input using a flexible UI dispatcher"Utilities openCommandKeyHelp'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!orderedCollection	^HelpTopic		title: 'Ordered Collection' 		contents:'"************************************************************************ * OrderedCollection: acts like an expandable array								* ************************************************************************"| b x y sum max |x := OrderedCollection with: 4 with: 3 with: 2 with: 1.	"create collection with up to 4 elements"x := OrderedCollection new.					"allocate collection"x add: 3; add: 2; add: 1; add: 4; yourself.			"add element to collection"y := x addFirst: 5.								"add element at beginning of collection"y := x removeFirst.								"remove first element in collection"y := x addLast: 6.								"add element at end of collection"y := x removeLast.								"remove last element in collection"y := x addAll: #(7 8 9).							"add multiple elements to collection"y := x removeAll: #(7 8 9).						"remove multiple elements from collection"x at: 2 put: 3.									"set element at index"y := x remove: 5 ifAbsent: [].					"remove element from collection"b := x isEmpty.									"test if empty"y := x size.										"number of elements"y := x at: 2.										"retrieve element at index"y := x first.										"retrieve first element in collection"y := x last.										"retrieve last element in collection"b := x includes: 5.								"test if element is in collection"y := x copyFrom: 2 to: 3.						"subcollection"y := x indexOf: 3 ifAbsent: [0].					"first position of element within collection"y := x occurrencesOf: 3.						"number of times object in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x shuffled.									"randomly shuffle collection"y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'accessing' stamp: 'dtl 11/25/2010 13:41'!pages	^ #( introduction transcript assignment constants boolean arithmetic		bitwise conversion block methodCall conditionalStatement		iterationStatement character symbol string array orderedCollection		sortedCollection bag set interval association dictionary internalStream		fileStream date time point rectangle pen dynamic metaclass debugging		misc )! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:37'!pen	^HelpTopic		title: 'Pen' 		contents:'"************************************************************************ * Pen:																				* ************************************************************************"| myPen |Display restoreAfter: [   Display fillWhite.myPen := Pen new.								"get graphic pen"myPen squareNib: 1.myPen color: (Color blue).						"set pen color"myPen home.									"position pen at center of display"myPen up.										"makes nib unable to draw"myPen down.									"enable the nib to draw"myPen north.									"points direction towards top"myPen turn: -180.								"add specified degrees to direction"myPen direction.								"get current angle of pen"myPen go: 50.									"move pen specified number of pixels"myPen location.									"get the pen position"myPen goto: 200@200.							"move to specified point"myPen place: 250@250.						"move to specified point without drawing"myPen print: ''Hello World'' withFont: (TextStyle default fontAt: 1).Display extent.									"get display width@height"Display width.									"get display width"Display height.									"get display height"].'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:25'!point	^HelpTopic		title: 'Point' 		contents:'"************************************************************************ * Point:																				* ************************************************************************"| x y |x := 200@100.									"obtain a new point"y := x x.											"x coordinate"y := x y.											"y coordinate"x := 200@100 negated.							"negates x and y"x := (-200@ -100) abs.							"absolute value of x and y"x := (200.5@100.5) rounded.					"round x and y"x := (200.5@100.5) truncated.					"truncate x and y"x := 200@100 + 100.							"add scale to both x and y"x := 200@100 - 100.							"subtract scale from both x and y"x := 200@100 * 2.								"multiply x and y by scale"x := 200@100 / 2.								"divide x and y by scale"x := 200@100 // 2.								"divide x and y by scale"x := 200@100 \\ 3.								"remainder of x and y by scale"x := 200@100 + (50@25).						"add points"x := 200@100 - (50@25).						"subtract points"x := 200@100 * (3@4).							"multiply points"x := 200@100 // (3@4).							"divide points"x := 200@100 max: 50@200.					"max x and y"x := 200@100 min: 50@200.					"min x and y"x := 20@5 dotProduct: 10@2.					"sum of product (x1*x2 + y1*y2)"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 13:36'!rectangle	^HelpTopic		title: 'Rectangle' 		contents:'"************************************************************************ * Rectangle:																		* ************************************************************************"Rectangle fromUser.'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!set	^HelpTopic		title: 'Set' 		contents:'"************************************************************************ * Set:           like Bag except duplicates not allowed								* * IdentitySet:   uses identity test (== rather than =)								* ************************************************************************"| b x y sum max |x := Set with: 4 with: 3 with: 2 with: 1.			"create collection with up to 4 elements"x := Set new.									"allocate collection"x add: 4; add: 3; add: 1; add: 2; yourself.			"add element to collection"y := x addAll: #(7 8 9).							"add multiple elements to collection"y := x removeAll: #(7 8 9).						"remove multiple elements from collection"y := x remove: 4 ifAbsent: [].					"remove element from collection"b := x isEmpty.									"test if empty"y := x size.										"number of elements"x includes: 4.									"test if element is in collection"x do: [:a | Transcript show: a printString; cr].		"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].		"test if all elements meet condition"y := x select: [:a | a > 2].							"return collection of elements that pass test"y := x reject: [:a | a < 2].							"return collection of elements that fail test"y := x collect: [:a | a + a].						"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].				"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.		"sum elements"sum := x inject: 0 into: [:a :c | a + c].				"sum elements"max := x inject: 0 into: [:a :c | (a > c)				"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.									"convert to array"y := x asOrderedCollection.						"convert to ordered collection"y := x asSortedCollection.						"convert to sorted collection"y := x asBag.									"convert to bag collection"y := x asSet.									"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:04'!sortedCollection	^HelpTopic		title: 'Sorted Collection' 		contents:'"************************************************************************ * SortedCollection:    like OrderedCollection except order of elements			* *                         determined by sorting criteria									* ************************************************************************"| b x y sum max |x := SortedCollection with: 4 with: 3 with: 2 with: 1.	"create collection with up to 4 elements"x := SortedCollection new.							"allocate collection"x := SortedCollection sortBlock: [:a :c | a > c].		"set sort criteria"x add: 3; add: 2; add: 1; add: 4; yourself.				"add element to collection""y := x addFirst: 5."									"add element at beginning of collection"y := x removeFirst.									"remove first element in collection"y := x addLast: 6.									"add element at end of collection"y := x removeLast.									"remove last element in collection"y := x addAll: #(7 8 9).								"add multiple elements to collection"y := x removeAll: #(7 8 9).							"remove multiple elements from collection"y := x remove: 5 ifAbsent: [].						"remove element from collection"b := x isEmpty.										"test if empty"y := x size.											"number of elements"y := x at: 2.											"retrieve element at index"y := x first.											"retrieve first element in collection"y := x last.											"retrieve last element in collection"b := x includes: 4.									"test if element is in collection"y := x copyFrom: 2 to: 3.							"subcollection"y := x indexOf: 3 ifAbsent: [0].						"first position of element within collection"y := x occurrencesOf: 3.							"number of times object in collection"x do: [:a | Transcript show: a printString; cr].			"iterate over the collection"b := x allSatisfy: [:a | (a >= 1) & (a <= 4)].			"test if all elements meet condition"y := x select: [:a | a > 2].								"return collection of elements that pass test"y := x reject: [:a | a < 2].								"return collection of elements that fail test"y := x collect: [:a | a + a].							"transform each element for new collection"y := x detect: [:a | a > 3] ifNone: [].					"find position of first element that passes test"sum := 0. x do: [:a | sum := sum + a]. sum.			"sum elements"sum := 0. 1 to: (x size) do: [:a | sum := sum + (x at: a)].	"sum elements"sum := x inject: 0 into: [:a :c | a + c].					"sum elements"max := x inject: 0 into: [:a :c | (a > c)					"find max element in collection"   ifTrue: [a]   ifFalse: [c]].y := x asArray.										"convert to array"y := x asOrderedCollection.							"convert to ordered collection"y := x asSortedCollection.							"convert to sorted collection"y := x asBag.										"convert to bag collection"y := x asSet.										"convert to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:03'!string	^HelpTopic		title: 'String' 		contents:'"************************************************************************ * String:																			* ************************************************************************"| b x y |x := ''This is a string''.						"string assignment"x := ''String'', ''Concatenation''.				"string concatenation"b := x isEmpty.								"test if string is empty"y := x size.									"string size"y := x at: 2.									"char at location"y := x copyFrom: 2 to: 4.					"substring"y := x indexOf: $a ifAbsent: [0].				"first position of character within string"x := String new: 4.							"allocate string object"x											"set string elements"   at: 1 put: $a;   at: 2 put: $b;   at: 3 put: $c;   at: 4 put: $e.x := String with: $a with: $b with: $c with: $d.	"set up to 4 elements at a time"x do: [:a | Transcript show: a printString; cr].		"iterate over the string"b := x allSatisfy: [:a | (a >= $a) & (a <= $z)].	"test if all elements meet condition"y := x select: [:a | a > $a].					"return all elements that meet condition"y := x asSymbol.							"convert string to symbol"y := x asArray.								"convert string to array"x := ''ABCD'' asByteArray.					"convert string to byte array"y := x asOrderedCollection.					"convert string to ordered collection"y := x asSortedCollection.					"convert string to sorted collection"y := x asBag.								"convert string to bag collection"y := x asSet.								"convert string to set collection"y := x shuffled.								"randomly shuffle string"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/26/2010 11:02'!symbol	^HelpTopic		title: 'Symbol' 		contents:'"************************************************************************ * Symbol:																			* ************************************************************************"| b x y |x := #Hello.									"symbol assignment"y := ''String'', ''Concatenation''.				"symbol concatenation (result is string)"b := x isEmpty.								"test if symbol is empty"y := x size.									"string size"y := x at: 2.									"char at location"y := x copyFrom: 2 to: 4.					"substring"y := x indexOf: $e ifAbsent: [0].				"first position of character within string"x do: [:a | Transcript show: a printString; cr].	"iterate over the string"b := x allSatisfy: [:a | (a >= $a) & (a <= $z)].	"test if all elements meet condition"y := x select: [:a | a > $a].					"return all elements that meet condition"y := x asString.								"convert symbol to string"y := x asText.								"convert symbol to text"y := x asArray.								"convert symbol to array"y := x asOrderedCollection.					"convert symbol to ordered collection"y := x asSortedCollection.					"convert symbol to sorted collection"y := x asBag.								"convert symbol to bag collection"y := x asSet.								"convert symbol to set collection"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 22:22'!time	^HelpTopic		title: 'Time' 		contents:'"************************************************************************ * Time:																				* ************************************************************************"| x y b |x := Time now.									"create time from current time"x := Time dateAndTimeNow.					"create time from current time/date"x := Time readFromString: ''3:47:26 pm''.			"create time from formatted string"x := Time fromSeconds: (60 * 60 * 4).			"create time from elapsed time from midnight"y := Time millisecondClockValue.				"milliseconds since midnight"y := Time totalSeconds.							"total seconds since 1/1/1901"y := x seconds.									"seconds past minute (0-59)"y := x minutes.									"minutes past hour (0-59)"y := x hours.									"hours past midnight (0-23)"y := x addTime: (Time now).						"add time to time object"y := x subtractTime: (Time now).				"subtract time to time object"y := x asSeconds.								"convert time to seconds"x := Time millisecondsToRun: [					"timing facility"   1 to: 1000 do: [:index | y := 3.14 * index]]."b := (x <= Time now)."							"comparison"'! !!TerseGuideHelp class methodsFor: 'pages' stamp: 'dtl 11/25/2010 21:05'!transcript	^HelpTopic		title: 'Transcript' 		contents:'"************************************************************************ * Transcript:																		* ************************************************************************"Transcript clear.						"clear to transcript window"Transcript show: ''Hello World''.			"output string in transcript window"Transcript nextPutAll: ''Hello World''.		"output string in transcript window"Transcript nextPut: $A.					"output character in transcript window"Transcript space.						"output space character in transcript window"Transcript tab.							"output tab character in transcript window"Transcript cr.							"carriage return / linefeed"''Hello'' printOn: Transcript.				"append print string into the window"''Hello'' storeOn: Transcript.				"append store string into the window"Transcript endEntry.					"flush the output buffer"'! !"Help-Squeak-TerseGuide"!!InterpolatedGradientFillStyle commentStamp: 'gvc 5/18/2007 12:49' prior: 0!Gradient fill style that uses proper alpha-aware interpolation.!!InterpolatedGradientFillStyle methodsFor: 'as yet unclassified' stamp: 'nice 1/5/2010 15:59'!computePixelRampOfSize: length	"Compute the pixel ramp in the receiver."		| bits ramp lastColor lastIndex lastWord |	ramp := colorRamp asSortedCollection:[:a1 :a2| a1 key < a2 key].	bits := Bitmap new: length.	lastColor := ramp first value.	lastWord := lastColor pixelWord32.	lastIndex := 0.	ramp do:[:assoc| | distance nextColor theta nextWord nextIndex step |		nextIndex := (assoc key * length) rounded.		nextColor := assoc value.		nextWord := nextColor pixelWord32.		distance := nextIndex - lastIndex.		distance = 0 ifTrue: [distance := 1].		step := 1.0 / distance.		theta := 0.0.		lastIndex+1 to: nextIndex do: [:i|			theta := theta + step.			bits at: i put: (self interpolatedAlphaMix: theta of: lastWord and: nextWord)].		lastIndex := nextIndex.		lastColor := nextColor.		lastWord := nextWord].	lastIndex+1 to: length do: [:i| bits at: i put: lastWord].	^bits! !!InterpolatedGradientFillStyle methodsFor: 'as yet unclassified' stamp: 'gvc 5/18/2007 12:48'!interpolatedAlphaMix: ratio of: rgba1 and: rgba2	"Answer a proper interpolated value between two RGBA color words.	Theta is 0..1.."	| a1 a2 ra ira rgb1 rgb2 alpha br1 br2 bg1 bg2 bb1 bb2 result |	a1 := rgba1 bitShift: -24. a2 := rgba2 bitShift: -24.	alpha := ratio * (a2 - a1) + a1.	ra := ratio * alpha.	ira := (1.0 - ratio) * alpha.	rgb1 := rgba1 bitAnd: 16rFFFFFF. rgb2 := rgba2 bitAnd: 16rFFFFFF.	br1 := (rgb1 bitAnd: 255). br2 := (rgb2 bitAnd: 255).	bg1 := ((rgb1 bitShift:  -8) bitAnd: 255). bg2 := ((rgb2 bitShift: -8) bitAnd: 255).	bb1 := ((rgb1 bitShift: -16) bitAnd: 255). bb2 := ((rgb2 bitShift: -16) bitAnd: 255).	result :=  (ra * br2 + (ira * br1)) rounded // 255.	result :=  result bitOr: ((ra * bg2 + (ira * bg1)) rounded // 255 bitShift: 8).	result :=  result bitOr: ((ra * bb2 + (ira * bb1)) rounded // 255 bitShift: 16).	^result bitOr: (alpha rounded bitShift: 24)! !"Balloon"!!ConnectionQueue methodsFor: 'private' stamp: 'ul 11/25/2010 21:27' prior: 57418832!listenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	| newConnection |	socket := Socket newTCP.	"We'll accept four simultanous connections at the same time"	socket listenOn: portNumber backlogSize: 4.	"If the listener is not valid then the we cannot use the	BSD style accept() mechanism."	socket isValid ifFalse: [^self oldStyleListenLoop].	[true] whileTrue: [		socket isValid ifFalse: [			"socket has stopped listening for some reason"			socket destroy.			(Delay forMilliseconds: 10) wait.			^self listenLoop ].		newConnection := socket 			waitForAcceptFor: 10			ifTimedOut: [ nil ].		(newConnection notNil and: [newConnection isConnected]) ifTrue: [			accessSema critical: [connections addLast: newConnection.].			newConnection := nil.			self changed].		self pruneStaleConnections]. ! !!ConnectionQueue methodsFor: 'private' stamp: 'ul 11/25/2010 21:20' prior: 50805412!oldStyleListenLoop	"Private!! This loop is run in a separate process. It will establish up to maxQueueLength connections on the given port."	"Details: When out of sockets or queue is full, retry more frequently, since a socket may become available, space may open in the queue, or a previously queued connection may be aborted by the client, making it available for a fresh connection."	"Note: If the machine is disconnected from the network while the server is running, the currently waiting socket will go from 'isWaitingForConnection' to 'unconnected', and attempts to create new sockets will fail. When this happens, delete the broken socket and keep trying to create a socket in case the network connection is re-established. Connecting and disconnecting was tested under PPP on Mac system 8.1. It is not if this will work on other platforms."	[true] whileTrue: [		((socket == nil) and: [connections size < maxQueueLength]) ifTrue: [			"try to create a new socket for listening"			socket := Socket createIfFail: [nil]].		socket == nil			ifTrue: [(Delay forMilliseconds: 100) wait]			ifFalse: [				socket isUnconnected ifTrue: [socket listenOn: portNumber].				socket 					waitForConnectionFor: 10					ifTimedOut: [						socket isConnected							ifTrue: [  "connection established"								accessSema critical: [connections addLast: socket].								socket := nil]							ifFalse: [								socket isWaitingForConnection									ifFalse: [socket destroy. socket := nil]]]].  "broken socket; start over"		self pruneStaleConnections].! !!SocketStream methodsFor: 'private' stamp: 'ar 11/22/2010 23:48'!beSignalingWhile: aBlock	"Temporarily turn a non-signaling SocketStream into a signaling one.	Required for some of operations that will catch ConnectionClosed in 	order to find out that an operation completed"	| signaling |	signaling := shouldSignal.	shouldSignal := true.	^aBlock ensure:[shouldSignal := signaling]! !!SocketStream methodsFor: 'testing' stamp: 'ar 11/23/2010 00:04' prior: 34278787!isDataAvailable	"Answer if more data can be read. It the inbuffer is empty, we read more data.	Note: It is important not to rely on 'socket dataAvailable' here since this will	not work for subclasses such as SecureSocketStream (which can contain	undecrypted contents that has been read from the socket)." 	self isInBufferEmpty ifFalse: [^true].	^self receiveAvailableData < inNextToWrite! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:50' prior: 58221138!next: anInteger into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]] 		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount < anInteger 		ifTrue:[aCollection copyFrom: 1 to:  startIndex + amount-1]		ifFalse:[aCollection]! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:52' prior: 59121626!readInto: aCollection startingAt: startIndex count: anInteger	"Read n objects into the given collection starting at startIndex. 	Return number of elements that have been read."	"Implementation note: This method DOES signal timeout if not 	enough elements are received. It does NOT signal	ConnectionClosed as closing the connection is the only way by	which partial data can be read."	| start amount |	[self beSignalingWhile:[self receiveData: anInteger]]		on: ConnectionClosed do:[:ex| ex return].	"Inlined version of nextInBuffer: to avoid copying the contents"	amount := anInteger min: (inNextToWrite - lastRead - 1).	start := lastRead + 1.	lastRead := lastRead + amount.	aCollection 		replaceFrom: startIndex 		to: startIndex + amount-1 		with: inBuffer 		startingAt: start.	^amount! !!SocketStream methodsFor: 'control' stamp: 'gk 4/14/2005 09:49' prior: 34281209!receiveData: nBytes	"Keep reading the socket until we have nBytes	in the inBuffer or we reach the end. This method	does not return data, but can be used to make sure	data has been read into the buffer from the Socket	before actually reading it from the FastSocketStream.	Mainly used internally. We could also adjust the buffer	to the expected amount of data and avoiding several	incremental grow operations.	NOTE: This method doesn't honor timeouts if shouldSignal	is false!! And frankly, I am not sure how to handle that	case or if I care - I think we should always signal."	[self atEnd not and: [nBytes > self inBufferSize]]		whileTrue: [self receiveData]! !!SocketStream methodsFor: 'stream in' stamp: 'ar 11/22/2010 23:49' prior: 34286649!upToEnd	"Answer all data coming in on the socket until the socket	is closed by the other end, or we get a timeout.	This means this method catches ConnectionClosed by itself."	[[self atEnd] whileFalse: [self beSignalingWhile:[self receiveData]]]		on: ConnectionClosed		do: [:ex | "swallow it"]. 	^self nextAllInBuffer! !!Socket class methodsFor: 'utilities' stamp: 'ul 11/25/2010 21:16' prior: 29467434!deadlineSecs: secs	"Return a deadline time the given number of seconds from now."	self deprecated: 'Using this method may result in clock rollover related bug. Don''t use it.'. 	^ Time millisecondClockValue + (secs * 1000) truncated! !!Socket class methodsFor: 'utilities' stamp: 'ul 11/25/2010 21:09' prior: 55942003!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort := 7.  "7 = echo port, 13 = time port, 19 = character generator port"	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr ifNil: [ ^self inform: 'Could not find an address for ', hostName ].	sock := Socket new.	sock connectNonBlockingTo: serverAddr port: tcpPort.	[sock waitForConnectionFor: 10]		on: ConnectionTimedOut		do: [:ex |			(self confirm: 'Continue to wait for connection to ', hostName, '?')				ifTrue: [ex retry]				ifFalse: [					sock destroy.					^ self]].	sock sendData: 'echo!!'.	startTime := Time millisecondClockValue.	[sock waitForDataFor: 15]		on: ConnectionTimedOut		do: [:ex | (self confirm: 'Packet sent but no echo yet; keep waiting?')			ifTrue: [ex retry]].	echoTime := Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!Socket class methodsFor: 'utilities' stamp: 'ul 11/25/2010 21:34' prior: 55943748!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.org' timeOutSecs: 15"	| serverAddr sockets startTime timeoutMsecs done result unconnectedCount connectedCount waitingCount |	serverAddr := NetNameResolver addressForName: hostName timeout: 10.	serverAddr ifNil: [ 			self inform: 'Could not find an address for ' , hostName.			^ #() ].	sockets := portList		collect: [ :portNum | 			| sock |			sock := Socket new.			[ sock connectTo: serverAddr port: portNum ] 				on: ConnectionTimedOut				do: [ ].			sock ].	startTime := Time millisecondClockValue.	timeoutMsecs := (1000 * timeOutSecs) truncated.	done := false.	[ done ]		whileFalse: [ 			unconnectedCount := 0.			connectedCount := 0.			waitingCount := 0.			sockets				do: [ :s | 					s isUnconnectedOrInvalid						ifTrue: [ unconnectedCount := unconnectedCount + 1 ]						ifFalse: [ 							s isConnected								ifTrue: [ connectedCount := connectedCount + 1 ].							s isWaitingForConnection								ifTrue: [ waitingCount := waitingCount + 1 ] ] ].			waitingCount = 0				ifTrue: [ done := true ].			connectedCount = sockets size				ifTrue: [ done := true ].			(Time millisecondsSince: startTime) >= timeoutMsecs				ifTrue: [ done := true ] ].	result := (sockets select: [ :s | s isConnected ]) collect: [ :s | self nameForWellKnownTCPPort: s remotePort ].	sockets do: [ :s | s destroy ].	^ result! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 11/25/2010 20:59' prior: 52592975!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle := self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle		ifNotNil: [ self register ]		ifNil: [  "socket creation failed"			Smalltalk unregisterExternalObject: semaphore.			Smalltalk unregisterExternalObject: readSemaphore.			Smalltalk unregisterExternalObject: writeSemaphore.			readSemaphore := writeSemaphore := semaphore := nil ]! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 11/25/2010 21:00' prior: 52601391!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle ifNotNil: [		self isValid ifTrue: [ self primSocketDestroy: socketHandle ].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle := nil.		readSemaphore := writeSemaphore := semaphore := nil.		self unregister ]! !!Socket methodsFor: 'initialize-destroy' stamp: 'ul 11/25/2010 21:02' prior: 52598278!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore := false.	semaphore := Semaphore new.	readSemaphore := Semaphore new.	writeSemaphore := Semaphore new.	semaIndex := Smalltalk registerExternalObject: semaphore.	readSemaIndex := Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex := Smalltalk registerExternalObject: writeSemaphore.	socketHandle :=		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle 		ifNotNil: [ self register ]		ifNil: [  "socket creation failed"			Smalltalk unregisterExternalObject: semaphore.			Smalltalk unregisterExternalObject: readSemaphore.			Smalltalk unregisterExternalObject: writeSemaphore.			readSemaphore := writeSemaphore := semaphore := nil ]! !!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21' prior: 29413077!localAddress	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [ ^ByteArray new: 4 ] ].	^self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'ul 11/25/2010 21:21' prior: 29413358!localPort	self isWaitingForConnection ifFalse: [		self			waitForConnectionFor: Socket standardTimeout			ifTimedOut: [ ^0] ].	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'waiting' stamp: 'dc 10/21/2008 08:19' prior: 29456400!waitForAcceptFor: timeout	"Wait and accept an incoming connection. Return nil if it falis"	self waitForConnectionFor: timeout ifTimedOut: [^ nil].	^ self isConnected		ifTrue:[self accept]		! !!Socket methodsFor: 'waiting' stamp: 'nice 4/28/2009 21:26' prior: 52590091!waitForConnectionFor: timeout ifTimedOut: timeoutBlock	"Wait up until the given deadline for a connection to be established. Return true if it is established by the deadline, false if not."	| startTime msecsDelta msecsEllapsed status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	[(status = WaitingForConnection) and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]		whileTrue: [			semaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed.			status := self primSocketConnectionStatus: socketHandle].	status = Connected ifFalse: [^timeoutBlock value].	^ true! !!Socket methodsFor: 'waiting' stamp: 'nice 4/29/2009 21:25' prior: 29458729!waitForDataFor: timeout ifClosed: closedBlock ifTimedOut: timedOutBlock	"Wait for the given nr of seconds for data to arrive."		| startTime msecsDelta |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(Time millisecondsSince: startTime) < msecsDelta] whileTrue: [		(self primSocketReceiveDataAvailable: socketHandle)			ifTrue: [^self].		self isConnected			ifFalse: [^closedBlock value].		self readSemaphore waitTimeoutMSecs: 			(msecsDelta - (Time millisecondsSince: startTime) max: 0).	].	(self primSocketReceiveDataAvailable: socketHandle)		ifFalse: [			self isConnected				ifTrue: [^timedOutBlock value]				ifFalse: [^closedBlock value]].! !!Socket methodsFor: 'waiting' stamp: 'nice 4/28/2009 21:20' prior: 52591349!waitForDisconnectionFor: timeout	"Wait for the given nr of seconds for the connection to be broken.	Return true if it is broken by the deadline, false if not.	The client should know the connection is really going to be closed	(e.g., because he has called 'close' to send a close request to the other end)	before calling this method."	| startTime msecsDelta status |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	status := self primSocketConnectionStatus: socketHandle.	[((status == Connected) or: [(status == ThisEndClosed)]) and:	 [(Time millisecondsSince: startTime) < msecsDelta]] whileTrue: [		self discardReceivedData.		self readSemaphore waitTimeoutMSecs: 			(msecsDelta - (Time millisecondsSince: startTime) max: 0).		status := self primSocketConnectionStatus: socketHandle].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'Pmm 11/20/2010 23:47' prior: 52596609!waitForSendDoneFor: timeout	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| startTime msecsDelta msecsEllapsed sendDone |	startTime := Time millisecondClockValue.	msecsDelta := (timeout * 1000) truncated.	[(sendDone := self primSocketSendDone: socketHandle) not and: [ self isConnected			"Connection end and final data can happen fast, so test in this order"		and: [(msecsEllapsed := Time millisecondsSince: startTime) < msecsDelta]]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: msecsDelta - msecsEllapsed].	^ sendDone! !!SocksSocket methodsFor: 'connection open/close' stamp: 'ul 11/25/2010 21:19' prior: 34752001!connectTo: hostAddress port: port	self initializeNetwork.	self shouldUseSocks		ifFalse: [^super connectTo: hostAddress port: port].	super connectTo: socksIP port: socksPort.	self waitForConnectionFor: Socket standardTimeout.	dstIP := hostAddress.	dstPort := port.	vers = 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !!SocksSocket methodsFor: 'connection open/close' stamp: 'ul 11/25/2010 21:19' prior: 34752448!connectToHostNamed: hostName port: port	super connectTo: socksIP port: socksPort.	self waitForConnectionFor: Socket standardTimeout.	dstName := hostName.	dstPort := port.	vers = 4		ifTrue: [self connectSocks4]		ifFalse: [self connectSocks5]	! !"Network"!!FileStream methodsFor: '*Compression' stamp: 'laza 11/27/2010 18:39' prior: 34431119!viewGZipContents	"View the contents of a gzipped file"	| stringContents |	self binary.	stringContents := self contentsOfEntireFile.	stringContents := Cursor wait showWhile: [(GZipReadStream on: stringContents) upToEnd].	stringContents := stringContents asString withSqueakLineEndings.	UIManager default		edit: stringContents		label: 'Decompressed contents of: ', self localName! !"Compression"!!String commentStamp: '<historical>' prior: 59433627!A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and WideString (that represents an array of  32-bit characters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.Here are a few useful methods to look at...	String match:	String contractTo:String also inherits many useful methods from its hierarchy, such as	SequenceableCollection ,	SequenceableCollection copyReplaceAll:with:!!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 5/10/2010 14:05' prior: 28858607!findBinary: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinary: [ :arg | 11 - arg ]	"	^self findBinary: aBlock do: [ :found | found ] ifNone: [ self errorNotFound: aBlock ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:15'!findBinary: aBlock do: actionBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If found, evaluate actionBlock with the found element as argument	If no matching element is found, evaluate exceptionBlock,	with the 'bounding' elements (or nil) as optional arguments.	Examples:		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 11 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 12 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 0.5 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinary: [ :arg | 25 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ',{a. b} printString) ]	"	^self		findBinaryIndex: aBlock		do: [ :foundIndex | actionBlock value: (self at: foundIndex) ]		ifNone: [ :prevIndex :nextIndex |			exceptionBlock				cull: (prevIndex > 0 ifTrue: [ self at: prevIndex ])				cull: (nextIndex <= self size ifTrue: [ self at: nextIndex ]) ]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:13' prior: 28859157!findBinary: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock,	with the 'bounding' elements (or nil) as optional arguments."		^self findBinary: aBlock do: [ :found | found ] ifNone: exceptionBlock! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'jmv 5/10/2010 14:03' prior: 28857287!findBinaryIndex: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinaryIndex: [ :arg | 11 - arg ]	"	^self findBinaryIndex: aBlock do: [ :found | found ] ifNone: [ self errorNotFound: aBlock]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:15'!findBinaryIndex: aBlock do: actionBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If found, evaluate actionBlock with the index as argument	If no matching element is found, evaluate exceptionBlock,	with the indexes of the 'bounding' elements as optional	arguments. 	Warning: Might give invalid indexes, see	examples below.	Examples:		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 11 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString)]		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 12 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23) d			findBinaryIndex: [ :arg | 0.5 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ', {a. b} printString) ]		#(1 3 5 7 11 15 23)			findBinaryIndex: [ :arg | 25 - arg ]			do: [ :found | found ]			ifNone: [ :a :b | ('between: ',{a. b} printString) ]	"	| index low high |	low := 1.	high := self size.	[		index := high + low // 2.		low > high ] whileFalse: [			| test |			test := aBlock value: (self at: index).			test = 0 				ifTrue: [ ^actionBlock value: index ]				ifFalse: [ test > 0					ifTrue: [ low := index + 1 ]					ifFalse: [ high := index - 1 ] ] ].	^exceptionBlock cull: high cull: low! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ul 11/17/2010 12:13' prior: 28857852!findBinaryIndex: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock,	with the indexes of the 'bounding' elements as optional	arguments.	Warning: Might give invalid indexes."	^self findBinaryIndex: aBlock do: [ :found | found ] ifNone: exceptionBlock! !!String class methodsFor: 'accessing' stamp: 'ul 11/23/2010 08:17'!crLfExchangeTable	^CrLfExchangeTable! !!String class methodsFor: 'initialization' stamp: 'ul 11/23/2010 08:16' prior: 57878036!initialize   "self initialize"	| order |	AsciiOrder := (0 to: 255) as: ByteArray.	CaseInsensitiveOrder := AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder := ByteArray new: 256 withAll: 255.	order := -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order := order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order := order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order := order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asLowercase]).	"a table for translating to upper case"	UppercasingTable := String withAll: (Character allByteCharacters collect: [:c | c asUppercase]).	"a table for testing tokenish (for fast numArgs)"	Tokenish := String withAll: (Character allByteCharacters collect:									[:c | c tokenish ifTrue: [c] ifFalse: [$~]]).	"CR and LF--characters that terminate a line"	CSLineEnders := CharacterSet crlf. 	"separators and non-separators"	CSSeparators := CharacterSet separators.	CSNonSeparators := CSSeparators complement.		"a table for exchanging cr with lf and vica versa"	CrLfExchangeTable := Character allByteCharacters collect: [ :each |		each			caseOf: {				[ Character cr ] -> [ Character lf ].				[ Character lf ] -> [ Character cr ] }			otherwise: [ each ] ]! !!String methodsFor: 'internet' stamp: 'ul 11/22/2010 13:20' prior: 57348684!withInternetLineEndings	"change line endings from CR's and LF's to CRLF's.  This is probably in prepration for sending a string over the Internet"		^self withLineEndings: String crlf! !!String methodsFor: 'internet' stamp: 'ul 11/22/2010 13:19'!withLineEndings: lineEndingString	| stream |	stream := nil.	self lineIndicesDo: [ :start :endWithoutDelimiters :end |		(stream isNil and: [ endWithoutDelimiters ~= end ]) ifTrue: [			(self copyFrom: endWithoutDelimiters + 1 to: end) = lineEndingString ifFalse: [				stream := WriteStream with: self copy.				stream position: start - 1 ] ].		stream ifNotNil: [			stream next: endWithoutDelimiters - start + 1 putAll: self startingAt: start.			endWithoutDelimiters = end ifFalse: [				stream nextPutAll: lineEndingString ] ] ].	^stream		ifNil: [ self ]		ifNotNil: [ 			stream position = self size				ifTrue: [ stream originalContents ]				ifFalse: [ stream contents ] ]! !!String methodsFor: 'internet' stamp: 'ul 11/23/2010 08:19' prior: 57350842!withSqueakLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single CR."	(self includes: Character lf) ifFalse: [ ^self ].	(self includes: Character cr) ifFalse: [		^self translateWith: String crLfExchangeTable ].	^self withLineEndings: String cr! !!String methodsFor: 'internet' stamp: 'ul 11/23/2010 08:20' prior: 57352406!withUnixLineEndings	"Assume the string is textual, and that CR, LF, and CRLF are all valid line endings.	Replace each occurence with a single LF."	(self includes: Character cr) ifFalse: [ ^self ].	(self includes: Character lf) ifFalse: [		^self translateWith: String crLfExchangeTable ].	^self withLineEndings: String lf! !"Collections"!!MCWorkingCopy methodsFor: 'accessing' stamp: 'bp 11/21/2010 18:33' prior: 23206920!description	^ self packageNameWithStar, ' (', (ancestry ancestorStringWithout: self packageName), ')'! !!MCWorkingCopy methodsFor: 'accessing' stamp: 'bp 11/21/2010 17:12'!printOn: stream	super printOn: stream.	stream		nextPut: $(;		nextPutAll: self packageName;		nextPut: $)! !!MCAncestry methodsFor: 'ancestry' stamp: 'bp 11/21/2010 18:33'!ancestorStringWithout: packageName	^ String streamContents:		[:s | self ancestors do: [:ea | s nextPutAll: (ea nameWithout: packageName)] separatedBy: [s nextPutAll: ', ']]! !!MCVersionInfo methodsFor: 'accessing' stamp: 'bp 11/21/2010 19:27'!nameWithout: packageName	| result |	result := self name.	(result beginsWith: packageName , '-') ifTrue: [		result := result copyFrom: packageName size + 2 to: result size].	^result! !"Monticello"!!ScaledDecimal methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28' prior: 52402888!storeOn: aStream 	"SxaledDecimal sometimes have more digits than they print (potentially an infinity).	In this case, do not use printOn: because it would loose some extra digits"		self shouldBePrintedAsLiteral		ifTrue: [self printOn: aStream]		ifFalse: [aStream			nextPut: $(;		 	store: fraction numerator;			nextPut: $/;			store: fraction denominator;			nextPut: $s;			store: scale;			nextPut: $)]! !!Object methodsFor: 'testing' stamp: 'ul 11/23/2010 13:28'!shouldBePrintedAsLiteral	^self isLiteral! !"Kernel"!!Scanner class methodsFor: 'testing' stamp: 'nice 11/19/2010 17:22' prior: 55035195!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type next last |	i := aSymbol size.	i = 0 ifTrue: [^ false].	"TypeTable should have been origined at 0 rather than 1 ..."	ascii := (aSymbol at: 1) asciiValue.	type := TypeTable at: ascii ifAbsent: [^false].	type == #xLetter ifTrue: [		next := last := nil.		[i > 1]				whileTrue: 					[ascii := (aSymbol at: i) asciiValue.					type := TypeTable at: ascii ifAbsent: [^false].					(type == #xLetter or: [type == #xDigit or: [type == #xColon							and: [								next == nil									ifTrue: [last := #xColon. true] 									ifFalse: [last == #xColon and: [next ~~ #xDigit and: [next ~~ #xColon]]]]]])						ifFalse: [^ false].					next := type.					i := i - 1].			^ true].	type == #xBinary ifTrue:		[^(2 to: i) allSatisfy: [:j |			ascii := (aSymbol at: j) asciiValue.			(TypeTable at: ascii ifAbsent: []) == #xBinary]].	type == #verticalBar ifTrue: [^i = 1].	^false! !!LiteralNode methodsFor: 'testing' stamp: 'ul 11/23/2010 13:06'!isLiteralNode	^ true! !!ParseNode methodsFor: 'testing' stamp: 'ul 11/23/2010 13:06'!isLiteralNode	^ false! !ParseNode removeSelector: #isLiteral!LiteralNode removeSelector: #isLiteral!"Compiler"!!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/4/2010 15:10' prior: 21272561!colorPickerFor: target getter: getterSymbol setter: setterSymbol 	^ NewColorPickerMorph useIt		ifTrue:			[ NewColorPickerMorph				on: target				originalColor: (target perform: getterSymbol)				setColorSelector: setterSymbol ]		ifFalse:			[ ColorPickerMorph new				 initializeForPropertiesPanel ;				 target: target ;				 selector: setterSymbol ;				 originalColor: (target perform: getterSymbol) ]! !!GenericPropertiesMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/4/2010 14:26' prior: 21276069!openNearTarget	self openNearMorph: myTarget! !"EToys"!!StandardFileStream class methodsFor: 'class initialization' stamp: 'cmm 11/26/2010 21:44' prior: 34705192!flushAndVoidStdioFiles	stdioFiles ifNotNil:		[stdioFiles do:			[:f| f ifNotNil: [f isReadOnly ifFalse: [[f flush] on: Error do: [:ex|"care less"]]]].		 stdioFiles := nil]! !"Files"!!BitBlt methodsFor: 'private' stamp: 'mt 11/16/2010 20:31' prior: 34826593!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth targetColor |	sourceForm ifNotNil:[lastSourceDepth := sourceForm depth].	sourceForm := aStrikeFont glyphs.	"Ignore any halftone pattern since we use a color map approach here"	halftoneForm := nil.	sourceY := 0.	height := aStrikeFont height.	sourceForm depth = 1 ifTrue: [		self combinationRule: Form paint.		(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse: [			"Set up color map for a different source depth (color font)"			"Uses caching for reasonable efficiency"			colorMap := self cachedFontColormapFrom: sourceForm depth to: destForm depth.			colorMap at: 1 put: (destForm pixelValueFor: backgroundColor)].		colorMap at: 2 put: (destForm pixelValueFor: foregroundColor).	]	ifFalse: [		(Preferences subPixelRenderFonts and: [ foregroundColor = Color black			"Only use rgbMul with opaque colors as alpha values get lost for translucent colors."			or: [ Preferences subPixelRenderColorFonts and: [foregroundColor isOpaque] ]]) ifTrue: [			destForm depth > 8 ifTrue: [				"rgbMul is equivalent to component alpha blend if text is black (only faster, hehe)"				self combinationRule: Form rgbMul.				colorMap := (destForm depth = 32 or: [ (foregroundColor = Color black) not ]) ifTrue: [					"rgbMul / rgbAdd IS component alpha blend for any color of text (neat trick, eh!!)"					"This colorMap is to be used on the second pass with rule 20 (rgbAdd)					See #displayString:from:to:at:strikeFont:kern:"					"Note: In 32bpp we always need the second pass, as the source could have transparent pixels, and we need to add to the alpha channel"					self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]]			ifFalse: [				self combinationRule: Form paint.				targetColor := foregroundColor = Color black ifFalse: [ foregroundColor ].				colorMap := self colorConvertingMap: targetColor from: sourceForm depth to: destForm depth keepSubPixelAA: true]		]		ifFalse: [			"Do not use rule 34 for 16bpp display. TTCFont uses it, but it builds a glyphs cache for each color used!!"			self combinationRule: (destForm depth = 32 ifTrue: [Form blendAlphaScaled] ifFalse: [Form paint]).			colorMap := self colorConvertingMap: foregroundColor from: sourceForm depth to: destForm depth keepSubPixelAA: false		]	].! !!Form class methodsFor: 'mode constants' stamp: 'mt 11/16/2010 20:31'!blendAlphaScaled	"Answer the integer denoting BitBlt's blend-with-alpha-scaled rule."	^ 34! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:43' prior: 51200203!fadeImage: otherImage at: topLeft	indexAndMaskDo: indexAndMaskBlock		"This fade uses halftones as a blending hack.	Zeros in the halftone produce the original image (self), and 	ones in the halftone produce the 'otherImage'.	IndexAndMaskBlock gets evaluated prior to each cycle,	and the resulting boolean determines whether to continue cycling."	| index imageRect maskForm resultForm pix returnPix|	imageRect := otherImage boundingBox.	resultForm := self copy: (topLeft extent: imageRect extent).	maskForm := Form extent: 32@32.	index := 0.	[indexAndMaskBlock value: (index := index+1) value: maskForm]	whileTrue:		[maskForm reverse.		resultForm copyBits: imageRect from: resultForm at: 0@0			clippingBox: imageRect rule: Form over fillColor: maskForm.		maskForm reverse.		resultForm copyBits: imageRect from: otherImage at: 0@0			clippingBox: imageRect rule: Form under fillColor: maskForm.		self copyBits: imageRect from: resultForm at: topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:44' prior: 54025889!fadeImageCoarse: otherImage at: topLeft	"Display fadeImageCoarse: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| d pix|	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask | | j |		i=1 ifTrue: [pix := (1 bitShift: d) - 1.					1 to: 8//d-1 do: [:q | pix := pix bitOr: (pix bitShift: d*4)]]			.		i <= 16 ifTrue:[		j := i-1//4+1.		(0 to: 28 by: 4) do: [:k |			mask bits at: j+k				put: (pix bitOr: (mask bits at: j+k))].		true]		ifFalse: [false]]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:45' prior: 54026518!fadeImageFine: otherImage at: topLeft	"Display fadeImageFine: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	| d pix|	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask | | j ii  |		i=1 ifTrue: [pix := (1 bitShift: d) - 1.					1 to: 8//d-1 do:						[:q | pix := pix bitOr: (pix bitShift: d*4)]].		i <= 16 ifTrue:		[ii := #(0 10 2 8 7 13 5 15 1 11 3 9 6 12 4 14) at: i.		j := ii//4+1.		(0 to: 28 by: 4) do:			[:k | mask bits at: j+k put:				((mask bits at: j+k) bitOr: (pix))].		true]		ifFalse: [false]]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 16:29' prior: 21057448!fadeImageSquares: otherImage at: topLeft 	"Display fadeImageSquares: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40"	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((16-i) asPoint extent: (i*2) asPoint) fillColor: Color black.		i <= 16]! !!Form methodsFor: 'transitions' stamp: 'Jb 11/19/2010 15:53' prior: 51201715!fadeImageVert: otherImage at: topLeft	"Display fadeImageVert: (Form fromDisplay: (10@10 extent: 300@300)) reverse at: 10@10"	| d |	d := self depth.	^ self fadeImage: otherImage at: topLeft indexAndMaskDo:		[:i :mask |		mask fill: ((mask width//2//d-i*d)@0 extent: i*2*d@mask height) fillColor: Color black.		i <= (mask width//d)]! !"Graphics"!!Utilities class methodsFor: 'support windows' stamp: 'ul 11/23/2010 15:27' prior: 59144810!commandKeyMappings	^ (self class firstCommentAt: #commandKeyMappings) translated"Lower-case command keys(use with Cmd key on Mac and Alt key on other platforms)a	Select allb	Browse it (selection is a class name or cursor is over a class-list or message-list)c	Copy selectiond	Do it (selection is a valid expression)e	Exchange selection with prior selectionf	Findg	Find againh	Set selection as search string for find againi	Inspect it (selection is a valid expression, or selection is over an inspect-ilst)j	Again once (do the last text-related operation again)k	Set fontl	Cancelm	Implementors of it (selection is a message selector or cursor is over a class-list or message-list)n	Senders of it (selection is a message selector or cursor is over a class-list or message-list)o	Spawn current methodp	Print it (selection is a valid expression)q	Query symbol (toggle all possible completion for a given prefix)r	Recognizers	Save (i.e. accept)t	Finds a Transcript (when cursor is over the desktop)u	Toggle alignmentv	Pastew	Delete preceding word (over text);  Close-window (over morphic desktop)x	Cut selectiony	Swap charactersz	UndoNote: for Do it, Senders of it, etc., a null selection will be expanded to a word or to the current line in an attempt to do what you want.  Also note that Senders/Implementors of it will find the outermost keyword selector in a large selection, as when you have selected a bracketed expression or an entire line.  Finally note that the same cmd-m and cmd-n (and cmd-v for versions) work in the message pane of most browsers.Upper-case command keys	(use with Shift-Cmd, or Ctrl on Mac	or Shift-Alt on other platforms; sometimes Ctrl works too)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'G	fileIn from it (a file name)H	cursor TopHome:I	Inspect via Object ExplorerJ	Again many (apply the previous text command repeatedly until the end of the text)K	Set styleL	Outdent (move selection one tab-stop left)M	Select current type-inN	References to it (selection is a class name, or cursor is over a class-list or message-list)O	Open single-message browser (in message lists)P	Make project linkR	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing it (in text); show-world-menu (when issued with cursor over desktop)X	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selectionOther special keysBackspace	Backward delete characterDel			Forward delete characterShift-Bksp	Backward delete wordShift-Del	Forward delete wordEsc			Pop up the Desktop Menu\			Send top window to backCursor keysleft, right,up, down	Move cursor left, right, up or downCtrl-left		Move cursor left one wordCtrl-right	Move cursor right one wordHome		Move cursor to begin of line or begin of textEnd			Move cursor to end of line or end of textPgUp, Ctrl-up	Move cursor up one pagePgDown, Ctrl-Dn	Move cursor down one pageNote all these keys can be used together with Shift to define or enlarge the selection. You cannot however shrink that selection again, as in some other systems.Other Cmd-key combinations (not available on all platforms)Return		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)Space		Select the current word as with double clickingEnclose the selection in a kind of bracket.  Each is a toggle.	(not available on all platforms)Ctrl-(	Enclose within ( and ), or remove enclosing ( and )Ctrl-[	Enclose within [ and ], or remove enclosing [ and ]Crtl-{	Enclose within { and }, or remove enclosing { and }Ctrl-<	Enclose within < and >, or remove enclosing < and >Ctrl-'	Enclose within ' and ', or remove enclosing ' and 'Ctrl-""	Enclose within "" and "", or remove enclosing "" and ""Note also that you can double-click just inside any of the above delimiters,or at the beginning or end of a line, to select the text enclosed.Text Emphasis	(not available on all platforms)Cmd-1	type the first method argumentCmd-2	type the second method argumentCmd-3	type the third method argumentCmd-4	type the fourth method argumentCmd-5	for future useCmd-6	color, action-on-click, link to class comment, link to method, url		Brings up a menu.  To remove these properties, select		more than the active part and then use command-0.Cmd-7	boldCmd-8	italicCmd-9	narrow (same as negative kern)Cmd-0	plain text (resets all emphasis)Cmd--	underlined (toggles it)Cmd-=	struck out (toggles it)Shift-Cmd--	(aka :=) negative kern (letters 1 pixel closer)Shift-Cmd-+	positive kern (letters 1 pixel larger spread)	Docking BarCtrl-<n> opens the n-th (where n is between 0 and 7) menu if such exists, otherwise it moves the keyboard focus to the Search Bar. Currently this means:Ctrl-0	Activates Search BarCtrl-1	Squeak menuCtrl-2	Projects menuCtrl-3	Tools menuCtrl-4	Apps menuCtrl-5	Extras menuCtrl-6	Windows menuCtrl-7	Help menu	"! !!Preferences class methodsFor: 'fonts' stamp: 'ul 11/25/2010 23:37' prior: 34842536!restoreDefaultFonts	"Since this is called from menus, we can take the opportunity to prompt for missing font styles."	"	Preferences restoreDefaultFonts	"	self setDefaultFonts: #(		(setSystemFontTo:			'Bitmap DejaVu Sans'		9)		(setListFontTo:				'Bitmap DejaVu Sans'		9)		(setFlapsFontTo:			Accushi						12)		(setEToysFontTo:			BitstreamVeraSansBold		9)		(setPaintBoxButtonFontTo:	BitstreamVeraSansBold		9)		(setMenuFontTo:			'Bitmap DejaVu Sans'		9)		(setWindowTitleFontTo:		'Bitmap DejaVu Sans Bold'	9)		(setBalloonHelpFontTo:		'Bitmap DejaVu Sans'		7)		(setCodeFontTo:			'Bitmap DejaVu Sans'		9)		(setButtonFontTo:			'Bitmap DejaVu Sans'	7)	)! !"System"!!ColorPresenterMorph commentStamp: 'gvc 5/18/2007 13:38' prior: 0!Displays a colour with alpha against a white, hatched and black background.!!BracketMorph commentStamp: 'gvc 5/18/2007 13:48' prior: 0!Morph displaying opposing arrows.!!HSVAColorSelectorMorph commentStamp: 'gvc 5/18/2007 12:55' prior: 0!Colour selector featuring a saturation/volume area, hue selection strip and alpha selection strip.!!HSVColorSelectorMorph commentStamp: 'gvc 5/18/2007 12:55' prior: 0!Colour selector featuring a saturation/volume area and a hue selection strip.!!NewColorPickerMorph commentStamp: 'cmm 12/3/2010 13:36' prior: 0!A NewColorPickerMorph is a new widget for choosing colors in Morphic.  Instantiate a NewColorPickerMorph:	(NewColorPickerMorph		on: objectToHaveItsColorSet		getColorSelector: itsColorGetterSymbol		setColorSelector: itsColorSetterSymbol) openInWorld!!SVColorSelectorMorph commentStamp: 'gvc 8/8/2007 14:36' prior: 0!A colour selector that displays an area with saturation on the x axis and volume on the y axis. Provides interactive selection of colour by mouse. For the moment it is event rather than model based.Setting the color will specify the hue and setting the selectedColor will specify the saturation and volume (may have a different hue to that displayed if not in sync).!!PasteUpMorph commentStamp: '<historical>' prior: 59365649!A morph whose submorphs comprise a paste-up of rectangular subparts which "show through".  Anything called a 'Playfield' is a PasteUpMorph.Facilities commonly needed on pages of graphical presentations and on simulation playfields, such as the painting of new objects, turtle trails, gradient fills, background paintings, parts-bin behavior, collision-detection, etc., are (or will be) provided.A World, the entire Smalltalk screen, is a PasteUpMorph.  A World responds true to isWorld.  Morph subclasses that have specialized menus (BookMorph) build them in the message addBookMenuItemsTo:hand:.  A PasteUpMorph that is a world, builds its menu in HandMorph buildWorldMenu.presenter	A Presenter in charge of stopButton stepButton and goButton, 			mouseOverHalosEnabled soundsEnabled fenceEnabled coloredTilesEnabled.model		<not used>cursor		??padding		??backgroundMorph		A Form that covers the background.turtleTrailsForm			Moving submorphs may leave trails on this form.turtlePen				Draws the trails.lastTurtlePositions		A Dictionary of (aPlayer -> aPoint) so turtle trails can be drawn 						only once each step cycle.  The point is the start of the current stroke.isPartsBin		If true, every object dragged out is copied.autoLineLayout		??indicateCursor		??resizeToFit		??wantsMouseOverHalos		If true, simply moving the cursor over a submorph brings up its halo.worldState		If I am also a World, keeps the hands, damageRecorder, stepList etc.griddingOn		If true, submorphs are on a grid!!PluggableSliderMorph commentStamp: 'gvc 7/16/2007 13:57' prior: 0!A pluggable slider (rather than one that auto-generates access selectors). Needs to be themed...!!BracketSliderMorph commentStamp: 'gvc 5/18/2007 13:39' prior: 0!Abstract superclass for morphs that are used to select a component (R, G, B or A) of a colour.!!AColorSelectorMorph commentStamp: 'gvc 5/18/2007 13:52' prior: 0!ColorComponentSelector showing an alpha gradient over a hatched background.!!HColorSelectorMorph commentStamp: 'gvc 5/18/2007 12:58' prior: 0!ColorComponentSelector showing a hue rainbow palette.!!ColorPresenterMorph class methodsFor: 'graphics constants' stamp: 'gvc 9/18/2006 16:05'!hatchForm	"Answer a form showing a grid hatch pattern."	^HatchForm ifNil: [HatchForm := self newHatchForm]! !!ColorPresenterMorph class methodsFor: 'graphics constants' stamp: 'gvc 9/18/2006 16:24'!newHatchForm	"Answer a new hatch form."		^(Form	extent: 8@8	depth: 1	fromArray: #( 4026531840 4026531840 4026531840 4026531840 251658240 251658240 251658240 251658240)	offset: 0@0)! !!ColorPresenterMorph class methodsFor: 'instance creation' stamp: 'StephaneDucasse 3/3/2010 16:12'!on: anObject color: getSel	"Answer a new instance of the receiver on the given model using	the given selectors as the interface."		"(ColorPresenterMorph on: (BorderedMorph new) color: #color) openInWorld"		^self new		on: anObject 		color: getSel! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:46'!contentMorph	"The outer, containing Morph."	^ contentMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:47'!contentMorph: aMorph	"The outer, containing Morph."	contentMorph := aMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:32'!getColorSelector	"The selector symbol used to retrieve the color from my model."	^ getColorSelector! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 10:33'!getColorSelector: aSymbol	"The selector symbol used to retrieve the color from my model."	getColorSelector := aSymbol! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:34'!initialize	"Initialize the receiver."	super initialize.	self		borderWidth: 0;		changeTableLayout;		labelMorph: self newLabelMorph;		solidLabelMorph: self newLabelMorph;		contentMorph: self newContentMorph;		addMorphBack: self contentMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 11:26'!labelMorph	"The morph that renders the actual color being presented."	^ labelMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 11:27'!labelMorph: aMorph	"The morph that renders the actual color being presented."	labelMorph := aMorph! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:23'!newContentMorph	"Answer a new content morph"	^Morph new		color: Color transparent;		changeTableLayout;		borderStyle: (BorderStyle inset width: 1);		vResizing: #spaceFill;		hResizing: #spaceFill;		addMorph: self newHatchMorph;		yourself! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'cmm 12/3/2010 14:39'!newHatchMorph	"Answer a new morph showing the three backgrounds; white, hatch pattern, and black, against which my labelMorph is displayed."	^ Morph new		 color: Color transparent ;		 changeProportionalLayout ;		 vResizing: #spaceFill ;		 hResizing: #spaceFill ;		 minWidth: 48 ;		 minHeight: 12 ;				addMorph: (Morph new color: Color white)		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 0.3 @ 1)) ;				addMorph: (Morph new fillStyle: (InfiniteForm with: self class hatchForm))		fullFrame: (LayoutFrame fractions: (0.3 @ 0 corner: 0.7 @ 1)) ;				addMorph: self solidLabelMorph		fullFrame: (LayoutFrame fractions: (0.7 @ 0 corner: 1 @ 1)) ;				addMorph: self labelMorph		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1))! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/18/2006 16:20'!newLabelMorph	"Answer a new label morph"	^Morph new! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:45'!on: anObject color: getColSel	"Set the receiver to the given model parameterized by the given message selectors."	self		model: anObject;		getColorSelector: getColSel;		updateColor! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 6/3/2009 18:14'!setColor: aColor	"Update the colour of the labels."	self labelMorph color: aColor.	self solidLabelMorph color: aColor asNontranslucentColor! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'gvc 9/18/2006 16:17'!solidLabelMorph	"Answer the value of solidLabelMorph"	^ solidLabelMorph! !!ColorPresenterMorph methodsFor: 'accessing' stamp: 'gvc 9/18/2006 16:17'!solidLabelMorph: anObject	"Set the value of solidLabelMorph"	solidLabelMorph := anObject! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 9/22/2006 09:34'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == self getColorSelector ifTrue: 		[self updateColor.		^ self]! !!ColorPresenterMorph methodsFor: 'initializing' stamp: 'gvc 7/30/2009 18:36'!updateColor	"Update the color state."	|col|	self getColorSelector ifNotNil: [		col := (self model perform: self getColorSelector) ifNil: [Color transparent].		self setColor: col]! !!StringMorph methodsFor: 'connectors-layout' stamp: 'nk 4/29/2004 22:49' prior: 30271359!minHeight"answer the receiver's minHeight"	^ super minHeight max: self fontToUse height! !!KeyboardEvent methodsFor: 'private' stamp: 'djr 3/30/2010 12:38'!scanCode: ignore	" OB-Tests expects this "! !!KeyboardEvent methodsFor: 'private' stamp: 'djr 3/30/2010 11:55'!setType: aSymbol buttons: anInteger position: pos keyValue: aValue charCode: ignoredUsedInOBTesting hand: aHand stamp: stamp	self setType: aSymbol buttons: anInteger position: pos keyValue: aValue hand: aHand stamp: stamp! !!GradientFillStyle methodsFor: '*Morphic-Balloon' stamp: 'cmm 12/4/2010 15:10' prior: 21291955!changeColorSelector: aSymbol hand: aHand morph: aMorph originalColor: originalColor 	"Change either the firstColor or the lastColor (depending on aSymbol).  Put up a color picker to hande it.  We always use a modal picker so that the user can adjust both colors concurrently."	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: originalColor				setColorSelector: aSymbol) openNear: aMorph fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 initializeModal: false ;				 sourceHand: aHand ;				 target: self ;				 selector: aSymbol ;				 argument: aMorph ;				 originalColor: originalColor ;								putUpFor: aMorph				near: aMorph fullBoundsInWorld ]! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 11/22/2010 22:43' prior: 34688526!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."Omnibrowser, including Refactoring engine"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfOmniBrowser''.((Smalltalk at: #ConfigurationOfOmniBrowser) project perform: #lastVersion) load: #( Dev )."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WAPharoServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 44 11 2 1 8 1 21 2 8 1 28 14 3 1 1 28 7 11 11 2 5 4 3 5 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 28 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000123123,cblack;,c000123123,cblack;,c000000123,cblack;,c123000123,cblack;,c000123123,cblack;,c000123123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000123123,cblack;,c000000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000126,cblack;,c126000126,cblack;,c000000123,cblack;,c000000123,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000000126,cblack;,c000123123,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000123123,cblack;,c000123123,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000123123,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000123123,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;!!' readStream nextChunkText! !!TheWorldMainDockingBar methodsFor: 'submenu - extras' stamp: 'cbr 3/26/2010 00:53' prior: 59029718!extrasMenuOn: aDockingBar 	aDockingBar addItem: [ :it|		it 	contents: 'Extras' translated;			addSubMenu: [:menu|				menu addItem:[:item|					item						contents: 'Recover Changes' translated;						help: 'Recover changes after a crash' translated;						icon: MenuIcons smallHelpIcon;						target: ChangeList;						selector: #browseRecentLog].				menu addLine.				menu addItem:[:item|					item						contents: 'Window Colors' translated;						help: 'Changes the window color scheme' translated;						addSubMenu:[:submenu| self windowColorsOn: submenu]].				menu addItem:[:item|					item						contents: 'Set Author Initials' translated;						help: 'Sets the author initials' translated;						target: Utilities;						selector: #setAuthorInitials].				menu addItem:[:item|					item						contents: 'Restore Display (r)' translated;						help: 'Redraws the entire display' translated;						target: World;						selector: #restoreMorphicDisplay].				menu addItem:[:item|					item						contents: 'Rebuild Menus' translated;						help: 'Rebuilds the menu bar' translated;						target: TheWorldMainDockingBar;						selector: #updateInstances].				menu addLine.				menu addItem:[:item|					item						contents: 'Start Profiler' translated;						help: 'Starts the profiler' translated;						target: self;						selector: #startMessageTally].				menu addItem:[:item|					item						contents: 'Collect Garbage' translated;						help: 'Run the garbage collector and report space usage' translated;						target: Utilities;						selector: #garbageCollectAndReport].				menu addItem:[:item|					item						contents: 'Purge Undo Records' translated;						help: 'Save space by removing all the undo information remembered in all projects' translated;						target: CommandHistory;						selector: #resetAllHistory].				menu addItem:[:item|					item						contents: 'VM statistics' translated;						help: 'Virtual Machine information' translated;						target: self;						selector: #vmStatistics].				menu addLine.				menu addItem:[:item|					item						contents: 'Graphical Imports' translated;						help: 'View the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList' translated;						target: (Imports default);						selector: #viewImages].				menu addItem:[:item|					item						contents: 'Standard Graphics Library' translated;						help: 'Lets you view and change the system''s standard library of graphics' translated;						target: ScriptingSystem;						selector: #inspectFormDictionary].				menu addItem:[:item|					item						contents: 'Annotation Setup' translated;						help: 'Click here to get a little window that will allow you to specify which types of annotations, in which order, you wish to see in the annotation panes of browsers and other tools' translated;						target: Preferences;						selector: #editAnnotations].			] ]! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'mha 12/8/2010 00:21' prior: 33973979!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk classNamed: #HelpBrowser) ifNotNil: 					[:classHelpBrowser|					menu addLine.					menu addItem: [ :item |						item							contents: 'Terse Guide to Squeak' translated;							help: 'concise information about language and environment' translated;							target: classHelpBrowser;							selector: #openOn:;							arguments: { TerseGuideHelp } ].					menu addLine.					menu addItem: [ :item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: classHelpBrowser;							selector: #open ] ].			]].	! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'mha 12/2/2010 10:46' prior: 34635091!welcomeWorkspacesOn: menu	menu addItem:[:item|		item			contents: 'Welcome to Squeak 4.2' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#welcomeToSqueak42. 				'Welcome to Squeak 4.2'. 				(140@140 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'The Squeak User Interface' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#squeakUserInterface. 				'The Squeak User Interface'. 				(160@160 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'Working With Squeak' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#workingWithSqueak. 				'Working With Squeak'. 				(180@180 extent: 500@300)			}].	menu addItem:[:item|		item			contents: 'License Information' translated;			help: 'A Welcome Workspace' translated;			target: self;			selector: #showWelcomeText:label:in:;			arguments: {				#licenseInformation. 				'License Information'. 				(200@200 extent: 500@300)			}].! !!TextMorphEditor methodsFor: 'editing keys' stamp: 'cmm 12/4/2010 15:11' prior: 53541475!chooseColor	| attribute |	attribute := TextColor color: Color black. "default"	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"	NewColorPickerMorph useIt		ifTrue: [ (NewColorPickerMorph on: attribute) openNear: morph fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: morph activeHand ;				 target: attribute ;				 selector: #color: ;				 originalColor: Color black ;								putUpFor: morph				near: morph fullBoundsInWorld ].	^ attribute! !!BracketMorph methodsFor: 'drawing' stamp: 'gvc 9/21/2006 16:16'!drawOn: aCanvas	"Draw triangles at the edges."		|r|	r := self horizontal		ifTrue: [self bounds insetBy: (2@1 corner: 2@1)]		ifFalse: [self bounds insetBy: (1@2 corner: 1@2)].	aCanvas		drawPolygon: (self leftOrTopVertices: self bounds)		fillStyle: self borderColor;		drawPolygon: (self leftOrTopVertices: r)		fillStyle: self fillStyle;		drawPolygon: (self rightOrBottomVertices: self bounds)		fillStyle: self borderColor;		drawPolygon: (self rightOrBottomVertices: r)		fillStyle: self fillStyle! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 15:48'!horizontal	"Answer whether horizontal or vertical."		^self orientation == #horizontal! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:54'!horizontal: aBoolean	"Set whether horizontal or vertical."		^self orientation: (aBoolean ifTrue: [#horizontal] ifFalse: [#vertical])! !!BracketMorph methodsFor: 'initialization' stamp: 'gvc 9/19/2006 15:52'!initialize	"Initialize the receiver."	super initialize.	self		orientation: #horizontal! !!BracketMorph methodsFor: 'geometry' stamp: 'gvc 9/21/2006 15:45'!leftOrTopVertices: r	"Answer the vertices for a left or top bracket in the given rectangle."		^self orientation == #vertical		ifTrue: [{r topLeft - (0@1). r left + (r height // 2 + (r height \\ 2))@(r center y - (r height + 1 \\ 2)).				r left + (r height // 2 + (r height \\ 2))@(r center y). r bottomLeft}]		ifFalse: [{r topLeft. (r center x - (r width + 1 \\ 2))@(r top + (r width // 2 + (r width \\ 2))).				r center x@(r top + (r width // 2 + (r width \\ 2))). r topRight}]! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:51'!orientation	"Answer the value of orientation"	^ orientation! !!BracketMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:52'!orientation: anObject	"Set the value of orientation"	orientation := anObject.	self changed! !!BracketMorph methodsFor: 'geometry' stamp: 'gvc 9/21/2006 16:18'!rightOrBottomVertices: r	"Answer the vertices for a right or bottom bracket in the given rectangle."		^self orientation == #vertical		ifTrue: [{r topRight - (0@1). r right - (r height // 2 + (r height \\ 2))@(r center y - (r height + 1 \\ 2)).				r right - (r height // 2 + (r height \\ 2))@(r center y). r bottomRight}]		ifFalse: [{(r center x)@(r bottom - 1 - (r width // 2 + (r width \\ 2))).				r center x @(r bottom - 1 - (r width // 2 + (r width \\ 2))). r bottomRight. r bottomLeft - (1@0)}]! !!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:43'!aMorph	"The alpha-selector morph."	^ aMorph! !!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:43'!aMorph: anAColorSelectorMorph	"The alpha-selector morph."	aMorph := anAColorSelectorMorph! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 09:58'!alphaSelected: aFloat	"The alpha has changed."	self triggerSelectedColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 09:58'!colorSelected: aColor	"A color has been selected. Set the base color for the alpha channel."	self aMorph color: aColor.	self triggerSelectedColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:44'!defaultColor	"Answer the default color/fill style for the receiver."		^Color transparent! !!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 14:05'!hsvMorph	"Answer the value of hsvMorph"	^ hsvMorph! !!HSVAColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 14:05'!hsvMorph: anObject	"Set the value of hsvMorph"	hsvMorph := anObject! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:47'!initialize	"Initialize the receiver."	super initialize.	self		extent: 180@168;		changeTableLayout;		cellInset: 4;		aMorph: self newAColorMorph;		hsvMorph: self newHSVColorMorph;		addMorphBack: self hsvMorph;		addMorphBack: self aMorph.	self aMorph color: self hsvMorph selectedColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 10:11'!newAColorMorph	"Answer a new alpha color morph."	^AColorSelectorMorph new		model: self;		hResizing: #spaceFill;		vResizing: #rigid;		setValueSelector: #alphaSelected:;		extent: 24@24! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:00'!newHSVColorMorph	"Answer a new hue/saturation/volume color morph."	^HSVColorSelectorMorph new		hResizing: #spaceFill;		vResizing: #spaceFill;		when: #colorSelected send: #colorSelected: to: self! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:18'!selectedColor	"Answer the selected color."	^self hsvMorph selectedColor alpha: self aMorph value! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 11:12'!selectedColor: aColor	"Set the hue and sv components."	self aMorph value: aColor alpha.	self hsvMorph selectedColor: aColor asNontranslucentColor! !!HSVAColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/3/2010 14:24'!triggerSelectedColor	"Trigger the event for the selected colour"	self		triggerEvent: #selectedColor		with: self selectedColor.	self changed: #selectedColor! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:28'!colorSelected: aColor	"A color has been selected. Make the hue match."	"self hMorph value: aColor hue / 360.	self svMorph basicColor: (Color h: aColor hue s: 1.0 v: 1.0)."	self triggerEvent: #colorSelected with: aColor! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:44'!defaultColor	"Answer the default color/fill style for the receiver."		^Color transparent! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 13:30'!hMorph	"Answer the value of hMorph"	^ hMorph! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 13:30'!hMorph: anObject	"Set the value of hMorph"	hMorph := anObject! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:23'!hue: aFloat	"Set the hue in the range 0.0 - 1.0. Update the SV morph and hMorph."	self hMorph value: aFloat.	self svMorph color: (Color h: aFloat * 359.9 s: 1.0 v: 1.0)! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/26/2006 12:25'!initialize	"Initialize the receiver."	super initialize.	self		borderWidth: 0;		changeTableLayout;		cellInset: 4;		listDirection: #leftToRight;		cellPositioning: #topLeft;		svMorph: self newSVColorMorph;		hMorph: self newHColorMorph;		addMorphBack: self svMorph;		addMorphBack: self hMorph;		extent: 192@152;		hue: 0.5! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 12:33'!newHColorMorph	"Answer a new hue color morph."	^HColorSelectorMorph new		model: self;		setValueSelector: #hue:;		hResizing: #rigid;		vResizing: #spaceFill;		extent: 36@36! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 5/18/2007 12:54'!newSVColorMorph	"Answer a new saturation/volume color morph."	^SVColorSelectorMorph new		extent: 152@152;		hResizing: #spaceFill;		vResizing: #spaceFill;		when: #colorSelected send: #colorSelected: to: self! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:41'!selectedColor	"Answer the selected color."	^self svMorph selectedColor! !!HSVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 13:38'!selectedColor: aColor	"Set the hue and sv components."	self hue: aColor hue / 360.	self svMorph selectedColor: aColor! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 12:26'!svMorph	"Answer the value of svMorph"	^ svMorph! !!HSVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 12:26'!svMorph: anObject	"Set the value of svMorph"	svMorph := anObject! !!Morph methodsFor: 'menus' stamp: 'cmm 12/4/2010 15:10' prior: 24287017!changeColor	"Change the color of the receiver -- triggered, e.g. from a menu"	NewColorPickerMorph useIt		ifTrue: [ (NewColorPickerMorph on: self) openNear: self fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #fillStyle: ;				 originalColor: self color ;								putUpFor: self				near: self fullBoundsInWorld ]! !!Morph methodsFor: 'meta-actions' stamp: 'cmm 12/4/2010 15:11' prior: 24307022!changeColorTarget: anObject selector: aSymbol originalColor: aColor hand: aHand 	"Put up a color picker for changing some kind of color.  May be modal or modeless, depending on #modalColorPickers setting"	| desiredLoc |	self flag: #arNote.	"Simplify this due to anObject == self for almost all cases"	desiredLoc := anObject isMorph		ifTrue:			[ Rectangle				center: self position				extent: 20 ]		ifFalse:			[ anObject == self world				ifTrue: [ anObject viewBox bottomLeft + (20 @ -20) extent: 200 ]				ifFalse: [ anObject fullBoundsInWorld ] ].	^ NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: anObject				originalColor: aColor				setColorSelector: aSymbol) openNear: desiredLoc ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: aHand ;				 target: anObject ;				 selector: aSymbol ;				 originalColor: aColor ;								putUpFor: anObject				near: desiredLoc ;				 yourself ]! !!Morph methodsFor: 'drop shadows' stamp: 'cmm 12/4/2010 15:11' prior: 24122702!changeShadowColor	"Change the shadow color of the receiver -- triggered, e.g. from a menu"	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self shadowColor				setColorSelector: #shadowColor:) openNearMorph: self ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #shadowColor: ;				 originalColor: self shadowColor ;								putUpFor: self				near: self fullBoundsInWorld ]! !!Morph methodsFor: 'meta-actions' stamp: 'cmm 12/4/2010 19:27' prior: 51846451!embedInto: evt	"Embed the receiver into some other morph"	|  target morphs |	morphs := self potentialEmbeddingTargets.	target := UIManager default 		chooseFrom: (morphs collect:[:m| m knownName ifNil:[m class name asString]])		values: self potentialEmbeddingTargets		title: ('Place ', self externalName, ' in...').	target ifNil:[^self].	target addMorphFrontFromWorldPosition: self! !!Morph methodsFor: 'testing' stamp: 'nk 9/4/2004 17:38'!isSelectionMorph	^false! !!Morph methodsFor: 'initialization' stamp: 'cmm 12/4/2010 14:25'!openNear: aRectangle 	self		openNear: aRectangle		in: World! !!Morph methodsFor: 'initialization' stamp: 'cmm 12/4/2010 14:21'!openNear: aRectangle in: aWorld	| wb leftOverlap rightOverlap topOverlap bottomOverlap best |	wb := aWorld bounds.	self fullBounds.	leftOverlap := self width - (aRectangle left - wb left).	rightOverlap := self width - (wb right - aRectangle right).	topOverlap := self height - (aRectangle top - wb top).	bottomOverlap := self height - (wb bottom - aRectangle bottom).	best := nil.	{		{leftOverlap. #topRight:. #topLeft}.		{rightOverlap. #topLeft:. #topRight}.		{topOverlap. #bottomLeft:. #topLeft}.		{bottomOverlap. #topLeft:. #bottomLeft}.	} do: [ :tuple |		(best isNil or: [tuple first < best first]) ifTrue: [best := tuple].	].	self perform: best second with: (aRectangle perform: best third).	self bottom: (self bottom min: wb bottom) rounded.	self right: (self right min: wb right) rounded.	self top: (self top max: wb top) rounded.	self left: (self left max: wb left) rounded.	self openInWorld: aWorld.! !!Morph methodsFor: 'initialization' stamp: 'cmm 12/4/2010 14:24'!openNearMorph: aMorph 	self		openNear: aMorph boundsInWorld		in: (aMorph world ifNil: [ World ])! !!Morph methodsFor: 'testing' stamp: 'cmm 12/4/2010 20:24' prior: 56944096!renameTo: aName 	"Set Player name in costume. Update Viewers. Fix all tiles (old style). fix 	References. New tiles: recompile, and recreate open scripts. If coming in 	from disk, and have name conflict, References will already have new 	name."	| aPresenter putInViewer aPasteUp renderer oldKey assoc classes oldName |	oldName := self knownName.	oldName=aName ifTrue: [ ^aName ].	(renderer := self topRendererOrSelf) setNameTo: aName.	putInViewer := false.	((aPresenter := self presenter) isNil or: [renderer player isNil]) 		ifFalse: 			[putInViewer := aPresenter currentlyViewing: renderer player.			putInViewer ifTrue: [renderer player viewerFlapTab hibernate]].	"empty it temporarily"	(aPasteUp := self topPasteUp) 		ifNotNil: [aPasteUp allTileScriptingElements do: [:m | m bringUpToDate]].	"Fix References dictionary. See restoreReferences to know why oldKey is  	already aName, but oldName is the old name."	oldKey := References keyAtIdentityValue: renderer player ifAbsent: [].	oldKey ifNotNil: 			[assoc := References associationAt: oldKey.			oldKey = aName 				ifFalse: 					["normal rename"					assoc key: (renderer player uniqueNameForReferenceFrom: aName).					References rehash]].	putInViewer ifTrue: [aPresenter viewMorph: self].	"recreate my viewer"	oldKey ifNil: [^aName].	"Force strings in tiles to be remade with new name. New tiles only."	Preferences universalTiles ifFalse: [^aName].	classes := (self systemNavigation allCallsOn: assoc) 				collect: [:each | each classSymbol].	classes asSet 		do: [:clsName | (Smalltalk at: clsName) replaceSilently: oldName to: aName].	"replace in text body of all methods. Can be wrong!!"	"Redo the tiles that are showing. This is also done in caller in 	unhibernate. "	aPasteUp ifNotNil: 			[aPasteUp allTileScriptingElements do: 					[:mm | 					"just ScriptEditorMorphs"					nil.					(mm isScriptEditorMorph) 						ifTrue: 							[((mm playerScripted class compiledMethodAt: mm scriptName) 								hasLiteral: assoc) 									ifTrue: 										[mm											hibernate;											unhibernate]]]].	^aName! !!Morph methodsFor: 'dropping/grabbing' stamp: 'cmm 12/4/2010 20:30' prior: 51757585!slideToTrash: evt	"Perhaps slide the receiver across the screen to a trash can and make it disappear into it.  In any case, remove the receiver from the screen."	| aForm trash startPoint endPoint morphToSlide |	((self renderedMorph == Utilities scrapsBook) or: [self renderedMorph isKindOf: TrashCanMorph]) ifTrue:		[self dismissMorph.  ^ self].	Preferences slideDismissalsToTrash ifTrue:		[morphToSlide := self representativeNoTallerThan: 200 norWiderThan: 200 thumbnailHeight: 100.		aForm := morphToSlide imageForm offset: (0@0).		trash := ActiveWorld			findDeepSubmorphThat:				[:aMorph | (aMorph isKindOf: TrashCanMorph) and:					[aMorph topRendererOrSelf owner == ActiveWorld]]			ifAbsent:				[trash := TrashCanMorph new.				trash position: ActiveWorld bottomLeft - (0 @ (trash extent y + 26)).				trash openInWorld.				trash].		endPoint := trash fullBoundsInWorld center.		startPoint := self topRendererOrSelf fullBoundsInWorld center - (aForm extent // 2)].	self dismissMorph.	ActiveWorld displayWorld.	Preferences slideDismissalsToTrash ifTrue:		[aForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15].	Utilities addToTrash: self! !!NewColorPickerMorph class methodsFor: 'create' stamp: 'cmm 12/4/2010 13:48'!on: anObject 	^ self		on: anObject		originalColor: anObject color		setColorSelector: #color:! !!NewColorPickerMorph class methodsFor: 'create' stamp: 'cmm 12/4/2010 13:46'!on: objectToHaveItsColorSet originalColor: originalColor setColorSelector: colorSetterSymbol 	^ self new		setTarget: objectToHaveItsColorSet		originalColor: originalColor		setColorSelector: colorSetterSymbol! !!NewColorPickerMorph class methodsFor: 'accessing' stamp: 'cmm 12/4/2010 15:05'!useIt	<preference: 'Use the new color-picker'		category: 'colors'		description: 'When true, a newly-enhanced color-picker is used.'		type: #Boolean>	^ UseIt ifNil: [ false ]! !!NewColorPickerMorph class methodsFor: 'accessing' stamp: 'cmm 12/4/2010 14:55'!useIt: aBoolean	UseIt := aBoolean! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 12:38'!closeButtonLabel	^ 'Close' translated! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 14:55'!colorExpression	"A Smalltalk which can create this color."	^ self selectedColor printString! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/4/2010 12:27'!colorExpression: aString 	"Set my color by evaluating aString, a Smalltalk expression which results in a Color instance."	| col |	{aString. 	'Color ' , aString}		detect:			[ : each | ([ col := Compiler evaluate: each ]				on: Error				do:					[ : err | nil ]) notNil ]		ifNone: [ nil ].	col ifNotNil: [ self selectedColor: col ]! !!NewColorPickerMorph methodsFor: 'model' stamp: 'cmm 12/3/2010 15:11'!colorSelected: aColor	self targetColor: aColor.	self changed: #colorExpression! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/3/2010 15:00'!initialize	super initialize.	self initializeHsvaMorph! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 11:29'!initializeHsvaMorph	hsvaMorph := HSVAColorSelectorMorph new		 hResizing: #spaceFill ;		 vResizing: #spaceFill ;		 yourself.	hsvaMorph		when: #selectedColor		send: #colorSelected:		to: self! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 12:38'!newBottomRow	^ Morph new		 color: Color transparent ;		 changeTableLayout ;		 listDirection: #leftToRight ;		 hResizing: #spaceFill; vResizing: #shrinkWrap ;		 height: 20 ;		 cellInset: 4 ;		 addMorph: (StringMorph contents: 'Current selection:' translated) ;		 addMorphBack: self newColorPresenterMorph ;		 addMorphBack: self newCloseButton! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 11:45'!newCloseButton	^ (PluggableButtonMorph		on: self		getState: nil		action: #delete		label: #closeButtonLabel)		 vResizing: #spaceFill ;		 yourself! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/3/2010 15:36'!newColorExpressionMorph	| pluggable |	pluggable := (PluggableTextMorph		on: self		text: #colorExpression		accept: #colorExpression:)		 hResizing: #spaceFill ;		 vResizing: #rigid ;		 height: 20 ;		 acceptOnCR: true ;		 retractableOrNot ;		 yourself.	pluggable textMorph autoFit: false.	^ pluggable! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/3/2010 15:34'!newColorPresenterMorph	^ (ColorPresenterMorph		on: hsvaMorph		color: #selectedColor)		 vResizing: #rigid ; height: 20 ;		 hResizing: #spaceFill ;		 yourself! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:53'!selectedColor	"The color selected."	^ hsvaMorph selectedColor! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:53'!selectedColor: aColor	"The color selected."	hsvaMorph selectedColor: aColor! !!NewColorPickerMorph methodsFor: 'model' stamp: 'cmm 12/3/2010 13:39'!setColorSelector	"Answer the value of setColorSelector"	^ setColorSelector! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 13:46'!setTarget: objectToHaveItsColorSet originalColor: aColor setColorSelector: colorSetterSymbol 	target := objectToHaveItsColorSet.	setColorSelector := colorSetterSymbol.	hsvaMorph selectedColor: aColor.	self setup! !!NewColorPickerMorph methodsFor: 'initialize-release' stamp: 'cmm 12/4/2010 11:51'!setup	self		 color: (Color white slightlyDarker alpha: 0.88) ;		 cornerStyle: #rounded ;		 changeTableLayout ;		 hResizing: #rigid ;		 vResizing: #rigid ;		 extent: 240@240 ;		 addMorphBack: hsvaMorph ;		 addMorphBack: self newColorExpressionMorph ;		 addMorphBack: self newBottomRow ;		 layoutInset: 4 ;		 cellInset: 0! !!NewColorPickerMorph methodsFor: 'model' stamp: 'cmm 12/3/2010 13:39'!target	"Answer the object whose color will be controlled."	^ target! !!NewColorPickerMorph methodsFor: 'accessing' stamp: 'cmm 12/3/2010 13:52'!targetColor: aColor 	"The color of my target."	target ifNotNil:		[ target			perform: setColorSelector			with: aColor ]! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 5/23/2007 11:54'!adoptPaneColor: paneColor	"Pass on to the border too."		super adoptPaneColor: paneColor.	self borderStyle baseColor: paneColor twiceDarker! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:15'!basicColor: aColor	"Set the gradient colors."		super color: aColor asNontranslucentColor.	self		fillStyle: self gradient! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 15:13'!blackGradient	"Answer the black gradient. Top to bottom, transparent to black."	^(InterpolatedGradientFillStyle colors: {Color black alpha: 0. Color black})		origin: self innerBounds topLeft;		direction: 0@self innerBounds height! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 11:36'!blackGradientMorph	"Answer the black gradient morph."	^Morph new		hResizing: #spaceFill;		vResizing: #spaceFill;		fillStyle: self blackGradient! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 15:19'!borderWidth: anInteger	"Update the gradients after setting."		super borderWidth: anInteger.	self updateGradients! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 14:15'!color: aColor	"Set the gradient colors."		self		basicColor: aColor;		selectedColor: (Color h: aColor hue s: self selectedColor saturation v: self selectedColor brightness)! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 10:42'!colorAt: aPoint	"Answer the color in the world at the given point."		^self isInWorld		ifTrue: [(Display colorAt: aPoint) asNontranslucentColor ]		ifFalse: [Color black]! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 10:33'!extent: p	"Update the gradient directions."	super extent: p.	self updateGradients! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 10:49'!fillStyle: fillStyle	"If it is a color then override with gradient."		fillStyle isColor		ifTrue: [self color: fillStyle]		ifFalse: [super fillStyle: fillStyle]! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2009 13:52'!gradient	"Answer the base gradient."	|b|	b := self innerBounds.	^(GradientFillStyle colors: {Color white. self color})		origin: b topLeft;		direction: (b width@0)! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/20/2006 12:50'!handlesMouseDown: evt	"Yes for down and move.." 	^true! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 16:33'!handlesMouseOverDragging: evt	"Yes, make the location morph visible when leaving."		^true! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 11:25'!hideLocation	"Hide the location morph and update the display."		self locationMorph visible: false.	World displayWorldSafely.! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 10:22'!initialize	"Initialize the receiver."	super initialize.	self locationMorph: self newLocationMorph.	self		clipSubmorphs: true;		color: Color blue;		borderStyle: (BorderStyle inset width: 1);		addMorphBack: self locationMorph;		addMorphBack: self blackGradientMorph! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/26/2006 12:23'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"		super layoutBounds: aRectangle.	self updateGradients! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 13:37'!locationMorph	"Answer the value of locationMorph"	^ locationMorph! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/20/2006 13:37'!locationMorph: anObject	"Set the value of locationMorph"	locationMorph := anObject! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 3/19/2010 16:21'!mouseDown: evt 	"Handle a mouse down event. Select the color at the mouse position."		evt redButtonPressed		ifFalse: [^super mouseDown: evt].	evt hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9).	self hideLocation.	self selectColorAt: evt position.	^super mouseDown: evt! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 3/19/2010 16:21'!mouseEnterDragging: evt	"Make the location morph invisible when entering."		self hideLocation.	evt hand showTemporaryCursor: (Cursor crossHair copy offset: -9 @ -9).! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 5/23/2007 11:56'!mouseLeaveDragging: evt	"Make the location morph visible when leaving."		evt hand showTemporaryCursor: nil.	self showLocation! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 12:11'!mouseMove: evt 	"Handle a mouse move event. Select the color at the mouse position."		evt redButtonPressed		ifFalse: [^super mouseMove: evt].	self selectColorAt: evt position.	^super mouseMove: evt! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 12:12'!mouseUp: evt 	"Handle a up event. Show the location morph again."		evt hand showTemporaryCursor: nil.	self updateSelectedLocation.	self locationMorph visible: true! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 12:16'!newLocationMorph	"Answer a new morph indicating the location of the selected color."	^ImageMorph new		image: Cursor crossHair withMask asCursorForm! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 12:12'!selectColorAt: aPoint	"Set the color at the given position."		|b p|	b := self innerBounds.	p := (b containsPoint: aPoint)		ifTrue: [aPoint]		ifFalse: [b pointNearestTo: aPoint].	p := p - b topLeft / b extent.	self selectedColor: (Color		h: self color hue		s: p x		v: 1.0 - p y)! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/19/2006 15:08'!selectedColor	"Answer the value of selectedColor"	^selectedColor ifNil: [self color]! !!SVColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/21/2006 14:01'!selectedColor: aColor	"Set the value of selectedColor."	selectedColor := aColor.	self locationMorph visible ifTrue: [self updateSelectedLocation].	self triggerEvent: #colorSelected with: aColor! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 15:25'!selectedLocation	"Answer the location within the receiver of the selected colour	relative to the receiver's top left."	|b c x y|	b := self innerBounds.	c := self selectedColor.	x := c saturation * (b width - 1).	y := 1 - c brightness * (b height - 1).	^(x truncated @ y truncated) + b topLeft! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/22/2006 11:26'!showLocation	"Show the location morph and update the display."		self locationMorph visible: true.	World displayWorldSafely.! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 7/30/2009 13:52'!updateGradients	"Update the gradient directions."	|bgm b|	b := self innerBounds.	bgm := self submorphs last.	bgm bounds: b.	bgm fillStyle		origin: b topLeft;		direction: 0@b height.	self fillStyle		origin: b topLeft;		direction: (b width@0).	self updateSelectedLocation! !!SVColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 12:17'!updateSelectedLocation	"Position the location morph to indicate the selected colour."		self locationMorph		position: (self selectedLocation - (self locationMorph extent // 2 + (self locationMorph extent \\ 2)))! !!MorphicProject methodsFor: 'flaps support' stamp: 'cmm 12/6/2010 15:09' prior: 53592720!cleanseDisabledGlobalFlapIDsList	"Make certain that the items on the disabled-global-flap list are actually global flaps, and if not, get rid of them"	| disabledFlapIDs currentGlobalIDs oldList |	disabledFlapIDs := self parameterAt: #disabledGlobalFlapIDs ifAbsent: [Set new].	currentGlobalIDs := Flaps globalFlapTabsIfAny collect: [:f | f flapID].	oldList := Project current projectParameterAt: #disabledGlobalFlaps ifAbsent: [nil].	oldList ifNotNil:		[disabledFlapIDs := oldList select: [:aFlap | aFlap flapID]].	disabledFlapIDs := disabledFlapIDs select: [:anID | currentGlobalIDs includes: anID].	self projectParameterAt: #disabledGlobalFlapIDs put: disabledFlapIDs.	self removeParameter: #disabledGlobalFlaps.! !!MorphicProject methodsFor: 'docking bars support' stamp: 'cmm 12/6/2010 15:14' prior: 53587585!createOrUpdateMainDockingBar	"Private - create a new main docking bar or update the current one"	| w mainDockingBars |	w := self world.	mainDockingBars := w mainDockingBars.	mainDockingBars isEmpty		ifTrue: ["no docking bar, just create a new one"			self dockingBar createDockingBar openInWorld: w.			^ self].	"update if needed"	mainDockingBars		do: [:each | self dockingBar updateIfNeeded: each]! !!MorphicProject methodsFor: 'docking bars support' stamp: 'cmm 12/6/2010 15:05'!dockingBar	^ self		projectParameterAt: #dockingBar		ifAbsent: [ TheWorldMainDockingBar instance ]! !!MorphicProject methodsFor: 'docking bars support' stamp: 'cmm 12/6/2010 15:26'!dockingBar: aTheWorldMainDockingBar 	self		projectParameterAt: #dockingBar		put: aTheWorldMainDockingBar.	self isCurrentProject ifTrue: [ TheWorldMainDockingBar instance: aTheWorldMainDockingBar ]! !!MorphicProject methodsFor: 'file in/out' stamp: 'cmm 12/6/2010 15:09' prior: 56911214!exportSegmentWithCatagories: catList classes: classList fileName: aFileName directory: aDirectory	"Store my project out on the disk as an *exported* ImageSegment.  All outPointers will be in a form that can be resolved in the target image.  Name it <project name>.extSeg.  What do we do about subProjects, especially if they are out as local image segments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder |	self flag: #toRemove.	self halt.  "unused"	"world == World ifTrue: [^ false]."		"self inform: 'Can''t send the current world out'."	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers. 	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	holder := Project allProjects.	"force them in to outPointers, where DiskProxys are made"	"Just export me, not my previous version"	revertSeg := self parameterAt: #revertToMe.	self projectParameters removeKey: #revertToMe ifAbsent: [].	roots := OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand; addAll: classList; addAll: (classList collect: [:cls | cls class]).	roots := roots reject: [ :x | x isNil].	"early saves may not have active hand or thumbnail"	catList do: [:sysCat | 		(SystemOrganization listAtCategoryNamed: sysCat asSymbol) do: [:symb |			roots add: (Smalltalk at: symb); add: (Smalltalk at: symb) class]].	is := ImageSegment new copySmartRootsExport: roots asArray.		"old way was (is := ImageSegment new copyFromRootsForExport: roots asArray)"	is state = #tooBig ifTrue: [^ false].	str := ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str := str, '\Project''s own world is not in the segment.' withCRs].	str isEmpty ifFalse: [		ans := (UIManager default				 chooseFrom: #('Do not write file' 'Write file anyway' 'Debug')				 title: str).		ans = 1 ifTrue: [			revertSeg ifNotNil: [self projectParameterAt: #revertToMe put: revertSeg].			^ false].		ans = 3 ifTrue: [self halt: 'Segment not written']].	is writeForExportWithSources: aFileName inDirectory: aDirectory.	revertSeg ifNotNil: [self projectParameterAt: #revertToMe put: revertSeg].	holder.	world flapTabs do: [:ft | 			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj isScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!MorphicProject methodsFor: 'file in/out' stamp: 'cmm 12/6/2010 15:11' prior: 56914184!exportSegmentWithChangeSet: aChangeSetOrNil fileName: aFileNamedirectory: aDirectory	"Store my project out on the disk as an *exported*ImageSegment.  All outPointers will be in a form that can be resolvedin the target image.  Name it <project name>.extSeg.  Whatdo we doabout subProjects, especially if they are out as local imagesegments?  Force them to come in?	Player classes are included automatically."	| is str ans revertSeg roots holder collector fd mgr stacks |	"Files out a changeSet first, so that a project can containits own classes"	world ifNil: [^ false].  world presenter ifNil: [^ false].	Utilities emptyScrapsBook.	world currentHand pasteBuffer: nil.	  "don't write the paste buffer."	world currentHand mouseOverHandler initialize.	  "forget about any	references here"		"Display checkCurrentHandForObjectToPaste."	Command initialize.	world clearCommandHistory.	world fullReleaseCachedState; releaseViewers.	world cleanseStepList.	world localFlapTabs size = world flapTabs size ifFalse: [		self error: 'Still holding onto Global flaps'].	world releaseSqueakPages.	holder := Project allProjects.	"force them in to outPointers, where	DiskProxys are made"	"Just export me, not my previous version"	revertSeg := self parameterAt: #revertToMe.	self removeParameter: #revertToMe.	roots := OrderedCollection new.	roots add: self; add: world; add: transcript; add: changeSet; add: thumbnail.	roots add: world activeHand.		"; addAll: classList; addAll: (classList collect: [:cls | cls class])"	roots := roots reject: [ :x | x isNil].	"early saves may not have	active hand or thumbnail"		fd := aDirectory directoryNamed: self resourceDirectoryName.		fd assureExistence.		"Clean up resource references before writing out"		mgr := self resourceManager.		self resourceManager: nil.		ResourceCollector current: ResourceCollector new.		ResourceCollector current localDirectory: fd.		ResourceCollector current baseUrl: self resourceUrl.		ResourceCollector current initializeFrom: mgr.		ProgressNotification signal: '2:findingResources' extra:	'(collecting resources...)' translated.		"Must activate old world because this is run at #armsLength.		Otherwise references to ActiveWorld, ActiveHand, or ActiveEvent		will not be captured correctly if referenced from blocks or user code."		world becomeActiveDuring:[			is := ImageSegment new copySmartRootsExport: roots asArray.			"old way was (is := ImageSegment new	copyFromRootsForExport: roots asArray)"		].		self resourceManager: mgr.		collector := ResourceCollector current.		ResourceCollector current: nil.		ProgressNotification signal: '2:foundResources' extra: ''.		is state = #tooBig ifTrue: [			collector replaceAll.			^ false].	str := ''.	"considered legal to save a project that has never been entered"	(is outPointers includes: world) ifTrue: [		str := str, '\Project''s own world is not in the segment.' translated withCRs].	str isEmpty ifFalse: [		ans := UIManager default chooseFrom: {			'Do not write file' translated.			'Write file anyway' translated.			'Debug' translated.		} title: str.		ans = 1 ifTrue: [			revertSeg ifNotNil: [projectParameters at:	#revertToMe put: revertSeg].			collector replaceAll.			^ false].		ans = 3 ifTrue: [			collector replaceAll.			self halt: 'Segment not written' translated]].		stacks := is findStacks.		is			writeForExportWithSources: aFileName			inDirectory: fd			changeSet: aChangeSetOrNil.		SecurityManager default signFile: aFileName directory: fd.		"Compress all files and update check sums"		collector forgetObsolete.		self storeResourceList: collector in: fd.		self storeHtmlPageIn: fd.		self storeManifestFileIn: fd.		self writeStackText: stacks in: fd registerIn: collector.		"local proj.005.myStack.t"		self compressFilesIn: fd to: aFileName in: aDirectory	resources: collector.				"also deletes the resource directory"		"Now update everything that we know about"		mgr updateResourcesFrom: collector.	revertSeg ifNotNil: [projectParameters at: #revertToMe put: revertSeg].	holder.	collector replaceAll.	world flapTabs do: [:ft |			(ft respondsTo: #unhibernate) ifTrue: [ft unhibernate]].	is arrayOfRoots do: [:obj |		obj isScriptEditorMorph ifTrue: [obj unhibernate]].	^ true! !!SelectionMorph methodsFor: 'testing' stamp: 'nk 9/4/2004 17:38'!isSelectionMorph	^true! !!PasteUpMorph methodsFor: 'world menu' stamp: 'fbs 12/3/2010 23:33' prior: 52133451!connectRemoteUserWithName: nameStringOrNil picture: aFormOrNil andIPAddress: aStringOrNil	"Prompt for the initials to be used to identify the cursor of a remote user, then create a cursor for that user and wait for a connection."	| initials addr h |	initials := nameStringOrNil.	initials isEmptyOrNil ifTrue: [		initials := UIManager default request: 'Enter initials for remote user''s cursor?'.	].	initials isEmpty ifTrue: [^ self].  "abort"	addr := 0.	aStringOrNil isEmptyOrNil ifFalse: [		addr := NetNameResolver addressForName: aStringOrNil timeout: 30	].	addr = 0 ifTrue: [		addr := NetNameResolver promptUserForHostAddress.	].	addr = 0 ifTrue: [^ self].  "abort"	(RemoteHandMorph ensureNetworkConnected) ifFalse: [^ self]. "abort"	h := RemoteHandMorph new userInitials: initials andPicture: aFormOrNil.	self addHand: h.	h changed.	h startListening.	h startTransmittingEventsTo: addr.! !!PasteUpMorph methodsFor: 'layout' stamp: 'cmm 11/18/2010 17:29' prior: 25811722!convertAlignment	self 		clipSubmorphs: true ;		layoutPolicy: nil ;		layoutInset: 0 ;		cellInset: 0 ;		vResizing: #rigid! !!PasteUpMorph methodsFor: 'world state' stamp: 'cmm 12/4/2010 20:55' prior: 25928759!deleteAllHalos	self haloMorphs do:		[ : m | m target isSelectionMorph ifTrue: [ m target delete ] ].	self hands do:		[ : each | each removeHalo ]! !!HaloMorph methodsFor: 'private' stamp: 'nk 9/4/2004 17:38' prior: 21448395!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	(target isSelectionMorph) ifTrue:		[^ target doDup: evt fromHalo: self handle: dupHandle].	self obtainHaloForEvent: evt andRemoveAllHandlesBut: dupHandle.	self setTarget: (target duplicateMorph: evt).	evt hand grabMorph: target.	self step. "update position if necessary"	evt hand addMouseListener: self. "Listen for the drop"! !!AColorSelectorMorph methodsFor: 'accessing' stamp: 'gvc 9/3/2009 13:43'!color: aColor	"Set the gradient colors."		super color: aColor asNontranslucentColor.	self fillStyle: self defaultFillStyle! !!AColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:43'!defaultFillStyle	"Answer the hue gradient."	^(GradientFillStyle colors: {self color alpha: 0. self color})		origin: self topLeft;		direction: (self bounds isWide					ifTrue: [self width@0]					ifFalse: [0@self height])! !!AColorSelectorMorph methodsFor: 'drawing' stamp: 'cmm 12/3/2010 11:28'!drawOn: aCanvas 	"Draw a hatch pattern first."	aCanvas		fillRectangle: self innerBounds		fillStyle: (InfiniteForm with: ColorPresenterMorph hatchForm).	super drawOn: aCanvas! !!AColorSelectorMorph methodsFor: 'visual properties' stamp: 'gvc 9/19/2006 15:46'!fillStyle: fillStyle	"If it is a color then override with gradient."		fillStyle isColor		ifTrue: [self color: fillStyle]		ifFalse: [super fillStyle: fillStyle]! !!AColorSelectorMorph methodsFor: 'initialization' stamp: 'gvc 9/26/2006 11:54'!initialize	"Initialize the receiver."	super initialize.	self		value: 1.0;		color: Color black! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:40'!defaultFillStyle	"Answer the defauolt fill style."	^Color gray! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:40'!extent: aPoint	"Update the gradient directions."	super extent: aPoint.	self updateFillStyle! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 16:05'!fillStyleToUse	"Answer the fillStyle that should be used for the receiver."		^self fillStyle! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 14:06'!gradient	"Answer the gradient."	self subclassResponsibility! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/2/2010 21:26'!initialize	"Initialize the receiver."	super initialize.	self		fillStyle: self defaultFillStyle;		borderStyle: (BorderStyle inset baseColor: self color; width: 1);		sliderColor: Color black;		clipSubmorphs: true! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 15:53'!initializeSlider	"Make the slider raised."		slider :=( BracketMorph newBounds: self totalSliderArea)		horizontal: self bounds isWide;		color: self thumbColor;		borderStyle: (BorderStyle raised baseColor: Color white; width: 1).	sliderShadow := (BracketMorph newBounds: self totalSliderArea)		horizontal: self bounds isWide;		color: self pagingArea color;		borderStyle: (BorderStyle inset baseColor: (Color white alpha: 0.6); width: 1).	slider on: #mouseMove send: #scrollAbsolute: to: self.	slider on: #mouseDown send: #mouseDownInSlider: to: self.	slider on: #mouseUp send: #mouseUpInSlider: to: self.	"(the shadow must have the pagingArea as its owner to highlight properly)"	self pagingArea addMorph: sliderShadow.	sliderShadow hide.	self addMorph: slider.	self computeSlider.! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:41'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"		super layoutBounds: aRectangle.	self updateFillStyle.	slider horizontal: self bounds isWide.	sliderShadow horizontal: self bounds isWide! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/21/2006 11:34'!roomToMove	"Allow to run off the edges a bit."		^self bounds isWide		ifTrue: [self totalSliderArea insetBy: ((self sliderThickness // 2@0) negated corner: (self sliderThickness // 2 + 1)@0)]		ifFalse: [self totalSliderArea insetBy: (0@(self sliderThickness // 2) negated corner: 0@(self sliderThickness // 2 - (self sliderThickness \\ 2) + 1))]! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:29'!sliderColor: newColor	"Set the slider colour."		super sliderColor: (self enabled ifTrue: [Color black] ifFalse: [self sliderShadowColor]).	slider ifNotNil: [slider borderStyle baseColor: Color white]! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 15:43'!sliderShadowColor	"Answer the color for the slider shadow."		^Color black alpha: 0.6! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/26/2006 12:02'!sliderThickness	"Answer the thickness of the slider."		^((self bounds isWide		ifTrue: [self height]		ifFalse: [self width]) // 2 max: 8) // 2 * 2 + 1! !!BracketSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:41'!updateFillStyle	"Update the fill style directions."	|b fs|	fs := self fillStyle.	fs isOrientedFill ifTrue: [		b := self innerBounds.		fs origin: b topLeft.		fs direction: (b isWide			ifTrue: [b width@0]			ifFalse: [0@b height])]! !!HColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/19/2006 14:13'!color: aColor	"Ignore to preserve fill style."	! !!HColorSelectorMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/3/2009 13:44'!defaultFillStyle	"Answer the hue gradient."	^(GradientFillStyle colors: ((0.0 to: 359.9 by: 0.1) collect: [:a | Color h: a s: 1.0 v: 1.0]))		origin: self topLeft;		direction: (self bounds isWide					ifTrue: [self width@0]					ifFalse: [0@self height])! !!PluggableSliderMorph class methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 11:28'!on: anObject getValue: getSel setValue: setSel	"Answer a new instance of the receiver with	the given selectors as the interface."	^self new		on: anObject		getValue: getSel		setValue: setSel! !!PluggableSliderMorph class methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 11:27'!on: anObject getValue: getSel setValue: setSel min: min max: max quantum: quantum	"Answer a new instance of the receiver with	the given selectors as the interface."	^self new		min: min;		max: max;		quantum: quantum;		on: anObject		getValue: getSel		setValue: setSel! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'cmm 12/3/2010 10:15'!adoptPaneColor: paneColor 	"Pass on to the border too."	super adoptPaneColor: paneColor.	paneColor ifNil: [ ^ self ].	self		 fillStyle: self fillStyleToUse ;		 borderStyle:			(BorderStyle inset				 width: 1 ;				 baseColor: self color twiceDarker) ;		 sliderColor:			(self enabled				ifTrue: [ paneColor twiceDarker ]				ifFalse: [ self paneColor twiceDarker paler ])! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:25'!borderStyleToUse	"Answer the borderStyle that should be used for the receiver."		^self enabled		ifTrue: [self theme sliderNormalBorderStyleFor: self]		ifFalse: [self theme sliderDisabledBorderStyleFor: self]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 15:02'!defaultColor	"Answer the default color/fill style for the receiver."		^Color white! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:19'!disable	"Disable the receiver."		self enabled: false! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:19'!enable	"Enable the receiver."		self enabled: true! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/3/2007 15:19'!enabled	"Answer the value of enabled"	^ enabled! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'cmm 12/2/2010 21:25'!enabled: anObject	"Set the value of enabled"	enabled = anObject ifTrue: [^self].	enabled := anObject.	self changed: #enabled.	self		adoptPaneColor: self color;		changed! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:24'!fillStyleToUse	"Answer the fillStyle that should be used for the receiver."		^self enabled		ifTrue: [self theme sliderNormalFillStyleFor: self]		ifFalse: [self theme sliderDisabledFillStyleFor: self]! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 9/8/2009 13:03'!getEnabledSelector	"Answer the value of getEnabledSelector"	^ getEnabledSelector! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 9/10/2009 13:32'!getEnabledSelector: aSymbol	"Set the value of getEnabledSelector"	getEnabledSelector := aSymbol.	self updateEnabled! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:31'!getValueSelector	"Answer the value of getValueSelector"	^ getValueSelector! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:31'!getValueSelector: anObject	"Set the value of getValueSelector"	getValueSelector := anObject! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:27'!handlesMouseDown: evt	"Answer true." 	^true! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 13:14'!initialize	"Initialize the receiver."	min := 0.	max := 1.	super initialize.	self enabled: true! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 15:00'!initializeSlider	"Make the slider raised."		super initializeSlider.	slider borderStyle: (BorderStyle raised baseColor: slider color; width: 1)! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/3/2007 15:14'!layoutBounds: aRectangle	"Set the bounds for laying out children of the receiver.	Note: written so that #layoutBounds can be changed without touching this method"		super layoutBounds: aRectangle.	self computeSlider! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 10:43'!max	"Answer the value of max"	^ max! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:21'!max: anObject	"Set the value of max"	max := anObject.	self setValue: self value! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 10:43'!min	"Answer the value of min"	^ min! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:21'!min: anObject	"Set the value of min"	min := anObject.	self setValue: self value! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/8/2007 15:32'!minHeight	"Answer the receiver's minimum height.	Give it a bit of a chance..."		^8 max: super minHeight! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 10:35'!mouseDown: anEvent	"Set the value directly."		self enabled ifTrue: [		self			scrollPoint: anEvent;			computeSlider].	super mouseDown: anEvent.	self enabled ifFalse: [^self].	anEvent hand newMouseFocus: slider event: anEvent.	slider		mouseEnter: anEvent copy;		mouseDown: anEvent copy! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 10:36'!mouseDownInSlider: event	"Ignore if disabled."		self enabled ifFalse: [^self].	^super mouseDownInSlider: event! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:29'!on: anObject getValue: getSel setValue: setSel	"Use the given selectors as the interface."	self		model: anObject;		getValueSelector: getSel;		setValueSelector: setSel;		updateValue! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:14'!quantum	"Answer the value of quantum"	^ quantum! !!PluggableSliderMorph methodsFor: 'accessing' stamp: 'gvc 8/9/2007 11:20'!quantum: anObject	"Set the value of quantum"	quantum := anObject.	self setValue: self value! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 12/11/2009 07:41'!scaledValue	"Answer the scaled value."	|val|	val := self value * (self max - self min) + self min.	self quantum ifNotNil: [:q |		val := val roundTo: q].	^(val max: self min) min: self max! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 12/11/2009 07:41'!scaledValue: newValue	"Set the scaled value."	|val|	val := newValue.	self quantum ifNotNil: [:q |		val := val roundTo: q].	self value: newValue - self min / (self max - self min)! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/7/2007 10:37'!scrollAbsolute: event	"Ignore if disabled."		self enabled ifFalse: [^self].	^super scrollAbsolute: event! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:28'!scrollPoint: event	"Scroll to the event position."		| r p |	r := self roomToMove.	bounds isWide		ifTrue: [r width = 0 ifTrue: [^ self]]		ifFalse: [r height = 0 ifTrue: [^ self]].	p := event position - (self sliderThickness // 2) adhereTo: r.	self descending		ifFalse:			[self setValue: (bounds isWide 				ifTrue: [(p x - r left) asFloat / r width]				ifFalse: [(p y - r top) asFloat / r height])]		ifTrue:			[self setValue: (bounds isWide				ifTrue: [(r right - p x) asFloat / r width]				ifFalse:	[(r bottom - p y) asFloat / r height])]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'MarcusDenker 12/11/2009 07:41'!setValue: newValue	"Called internally for propagation to model."	|scaled|	value := newValue.	self scaledValue: (scaled := self scaledValue).	self model ifNotNil: [		self setValueSelector ifNotNil: [:sel |			self model perform: sel with: scaled]]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 8/9/2007 11:18'!setValueSelector	"Answer the set selector."		^setValueSelector! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:31'!setValueSelector: aSymbol	"Directly set the selector to make more flexible."		setValueSelector := aSymbol! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 6/20/2007 14:57'!sliderColor: newColor	"Set the slider colour."		super sliderColor: newColor.	slider ifNotNil: [slider borderStyle baseColor: newColor]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:05'!update: aSymbol	"Update the value."		super update: aSymbol.	aSymbol == self getEnabledSelector ifTrue: [		^self updateEnabled].	aSymbol = self getValueSelector ifTrue: [		^self updateValue]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:06'!updateEnabled	"Update the enablement state."	self model ifNotNil: [		self getEnabledSelector ifNotNil: [			self enabled: (self model perform: self getEnabledSelector)]]! !!PluggableSliderMorph methodsFor: 'as yet unclassified' stamp: 'gvc 9/8/2009 13:00'!updateValue	"Update the value."		self model ifNotNil: [		self getValueSelector ifNotNil: [			self scaledValue: (self model perform: self getValueSelector)]]! !!TextEditor methodsFor: 'attributes' stamp: 'cmm 11/29/2010 12:38' prior: 57277228!changeSelectionFontTo: aFont 	| attr |	aFont ifNil: [ ^ self ].	attr := TextFontReference toFont: aFont.	paragraph text		addAttribute: attr		from: self startIndex		to:			(self hasSelection				ifTrue: [ self stopIndex - 1 min: paragraph text size ]				ifFalse: [ paragraph text size ]).	paragraph composeAll.	self recomputeInterval.	morph changed! !!TextEditor methodsFor: 'attributes' stamp: 'cmm 12/1/2010 10:42' prior: 53228352!changeTextFont	"Present a dialog which allows the user to select a font, and if one is chosen, apply it to the current selection.	If there is no selection, or the selection is empty, apply it to the whole morph."	| curFont startIndex |	startIndex := self startIndex.	curFont := (paragraph text fontAt: startIndex withStyle: paragraph textStyle).	morph openModal: (		Cursor wait showWhile: [ 			(FontChooserTool default				withTitle: 'Change the selected text''s font to...' translated				for: self 				setSelector: #changeSelectionFontTo:				getSelector: curFont)			"Do not allow changing the emphasis; we don't know how to deal with			a 'pre-emphasized' font here, so bail."					offerStyleList: false;					open])! !!TextEditor methodsFor: 'editing keys' stamp: 'cmm 12/4/2010 15:11' prior: 52911613!chooseColor	"Make a new Text Color Attribute, let the user pick a color, and return the attribute"	| attribute |	attribute := TextColor color: Color black.	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph on: attribute) openNear: morph fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: morph activeHand ;				 target: attribute ;				 selector: #color: ;				 originalColor: Color black ;								putUpFor: morph				near: morph fullBoundsInWorld ].	^ attribute! !!TextEditor methodsFor: 'accessing' stamp: 'ul 12/5/2010 15:20'!paragraph	^paragraph! !!SystemWindow methodsFor: 'menu' stamp: 'cmm 12/4/2010 15:11' prior: 30780270!changeColor	"Change the color of the receiver -- triggered, e.g. from a menu.  This variant allows the recolor triggered from the window's halo recolor handle to have the same result as choosing change-window-color from the window-title menu"	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self color				setColorSelector: #setWindowColor:) openNear: self fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #setWindowColor: ;				 originalColor: self color ;								putUpFor: self				near: self fullBoundsInWorld ]! !!SystemWindow methodsFor: 'menu' stamp: 'cmm 12/4/2010 15:11' prior: 30783982!setWindowColor	"Allow the user to select a new basic color for the window"	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self paneColorToUse				setColorSelector: #setWindowColor:) openNear: self fullBounds ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #setWindowColor: ;				 originalColor: self paneColorToUse ;								putUpFor: self				near: self fullBounds ]! !TheWorldMainDockingBar removeSelector: #terseGuideToSqueak!"Morphic"!!RemoteHandMorph class methodsFor: 'utilities' stamp: 'fbs 12/4/2010 19:52' prior: 27649090!ensureNetworkConnected	"Try to ensure that an intermittent network connection, such as a dialup or ISDN line, is actually connected. This is necessary to make sure a server is visible in order to accept an incoming connection. If the network connection does not work - the user has given up - return false. Otherwise, return true."	"RemoteHandMorph ensureNetworkConnected"	| address |	Utilities		informUser: 'Ensuring your network connection works...'		during: [			address := (NetNameResolver				addressForName: 'squeak.org'				timeout: 30)].	^ address notNil.! !"MorphicExtras"!!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:14'!listenerAddress	^NetNameResolver localHostAddress! !!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:13'!listenerPort	^42324! !!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:24'!setUp	listenerSocket := Socket newTCP listenOn: self listenerPort backlogSize: 4 interface: self listenerAddress.! !!SocketTest methodsFor: 'setup' stamp: 'ar 11/26/2010 10:24'!tearDown	listenerSocket ifNotNil:[listenerSocket destroy].	clientSocket ifNotNil:[clientSocket destroy].	serverSocket ifNotNil:[serverSocket destroy].! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:17'!testClientConnect	"Tests a client socket connection"	clientSocket := Socket newTCP.	clientSocket connectTo: self listenerAddress port: self listenerPort.	clientSocket waitForConnectionFor: 2.	self assert: clientSocket isConnected.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 11:08'!testDataReceive	"Test data transfer and related methods"	self testDataSending.	"It can take a tad for the status change to be visible"	(Delay forMilliseconds: 200) wait.	self assert: serverSocket dataAvailable.	self assert: (serverSocket receiveData = 'Hello World').	self deny: (serverSocket dataAvailable).! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 11:06'!testDataSending	"Test data transfer and related methods"	self testServerAccept.	clientSocket sendData: 'Hello World'.	clientSocket waitForSendDoneFor: 2.	self assert: clientSocket sendDone.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testLocalAddress	"Tests the various localAddress values for sockets"	self testServerAccept.	self assert: listenerSocket localAddress = self listenerAddress.	self assert: clientSocket localAddress = self listenerAddress.	self assert: serverSocket localAddress = self listenerAddress.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testLocalPort	"Tests the various localPort values for sockets"	self testServerAccept.	self assert: listenerSocket localPort = self listenerPort.	self assert: clientSocket localPort > 0.	self assert: serverSocket localPort > 0.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testRemoteAddress	"Tests the various remoteAddress values for sockets"	self testServerAccept.	self assert: listenerSocket remoteAddress = #[0 0 0 0].	self assert: clientSocket remoteAddress = self listenerAddress.	self assert: serverSocket remoteAddress = self listenerAddress.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testRemotePort	"Tests the various remoteAddress values for sockets"	self testServerAccept.	self assert: listenerSocket remotePort = 0.	self assert: clientSocket remotePort = self listenerPort.	self assert: serverSocket remotePort > 0.! !!SocketTest methodsFor: 'tests' stamp: 'ar 11/26/2010 10:25'!testServerAccept	"Tests a server-side accept"	self testClientConnect.	serverSocket := listenerSocket waitForAcceptFor: 2.	self assert: (serverSocket notNil).	self assert: (serverSocket isConnected).! !"NetworkTests"!!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:45' prior: 31142312!buildWith: aBuilder	| window |	window := aBuilder pluggableWindowSpec new		model: self; label: self label; extent: self extent;		children: (OrderedCollection new 			add: ((self buildCategoriesWith: aBuilder)				frame: self categoriesFrame;				yourself);			add: ((self buildClassesWith: aBuilder)				frame: self classesFrame;				yourself);			add: ((self buildStatusWith: aBuilder)				frame: self statusFrame;				yourself);			add: ((self buildFailureListWith: aBuilder)				frame: self failureListFrame;				yourself);			add: ((self buildErrorListWith: aBuilder)				frame: self errorListFrame;				yourself);			add: ((self buildButtonsWith: aBuilder)				frame: self buttonsFrame;				yourself);			yourself);		yourself.	^ aBuilder build: window.! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:50'!buttonHeight	^Preferences standardButtonFont height + 25! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:45'!buttonsFrame	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 1 offset: self buttonHeight negated;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:48'!categoriesFrame	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.25 offset: 0;		bottomFraction: 1 offset: self buttonHeight negated + 4! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:48'!classesFrame	^LayoutFrame new		leftFraction: 0.25 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.5 offset: 0;		bottomFraction: 1 offset: self buttonHeight negated + 4! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:49'!errorListFrame	^LayoutFrame new		leftFraction: 0.5 offset: 0;		topFraction: 0.5 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: self buttonHeight negated + 4! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:43'!failureListFrame	^LayoutFrame new		leftFraction: 0.5 offset: 0;		topFraction: 0 offset: self statusHeight;		rightFraction: 1 offset: 0;		bottomFraction: 0.5 offset: 0! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:41'!statusFrame	^LayoutFrame new		leftFraction: 0.5 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 0 offset: self statusHeight! !!TestRunner methodsFor: 'building' stamp: 'bp 11/22/2010 20:42'!statusHeight	^Preferences standardCodeFont height * 2 + 5! !"SUnitGUI"!!StandardSystemFontsTest methodsFor: 'testing' stamp: 'ul 11/25/2010 23:38' prior: 34300134!testRestoreDefaultFonts	Preferences restoreFontsAfter: [		Preferences restoreDefaultFonts.		self assert: #standardDefaultTextFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardListFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardFlapFont familyName: 'Accushi' pointSize: 12.		self assert: #standardEToysFont familyName: 'BitstreamVeraSans' pointSize: 9.		self assert: #standardMenuFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #windowTitleFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardBalloonHelpFont familyName: 'Bitmap DejaVu Sans' pointSize: 7.		self assert: #standardCodeFont familyName: 'Bitmap DejaVu Sans' pointSize: 9.		self assert: #standardButtonFont familyName: 'Bitmap DejaVu Sans' pointSize: 7]! !"Tests"!!DebuggerMethodMap commentStamp: '<historical>' prior: 59271692!I am a place-holder for information needed by the Debugger to inspect method activations.  I insulate the debugger from details of code generation such as exact bytecode offsets and temporary variable locations.  I have two concreate subclasses, one for methods compiled using BlueBook blocks and one for methods compiled using Closures.  These classes deal with temporary variable access. My function is to abstract the source map away from actual bytecode pcs to abstract bytecode pcs.To reduce compilation time I try and defer as much computation to access time as possible as instances of me will be created after each compilation.I maintain a WeakIdentityDictionary of method to DebuggerMethodMap to cache maps.  I refer to my method through a WeakArray to keep the map cache functional. If the reference from a DebuggerMethodMap to its method were strong then the method would never be dropped from the cache because the reference from its map would keep it alive.!!StandardFileStream methodsFor: '*Tools-FileList' stamp: 'ul 11/23/2010 10:58'!dirAndFileName	"A temporary solution for supporting project loading via drag and drop."	^{ self directory. self localName }! !!PointerFinder methodsFor: 'application' stamp: 'ul 11/23/2010 13:27' prior: 26584437!follow: anObject from: parentObject	anObject == goal ifTrue: [		parents at: anObject put: parentObject.		^ true].	"Remove this after switching to new CompiledMethod format --bf 2/12/2006"	(anObject class isPointers or: [ anObject isCompiledMethod ]) ifFalse: [ ^false].	(anObject class isWeak or: [		anObject class == self class or: [		anObject isLiteral or: [		parents includesKey: anObject ] ] ])			ifTrue: [ ^false ].	parents at: anObject put: parentObject.	toDoNext add: anObject.	^ false! !!DebuggerMethodMap class methodsFor: 'debugger support' stamp: 'ul 11/15/2010 08:44' prior: 56422496!cacheDebugMap: aDebuggerMethodMap forMethod: aCompiledMethod		^self protected: [ 		MapCache size >= MapCacheEntries ifTrue: [			MapCache slowSize >= MapCacheEntries 				ifFalse: [ MapCache rehash ]				ifTrue: [					| mapsByAge |					mapsByAge := MapCache keys sort: [ :m1 :m2 |						"We are holding strongly on the keys, so #at: is suitable."						(MapCache at: m1) timestamp < (MapCache at: m2) timestamp].					mapsByAge from: 1 to: mapsByAge size - MapCacheEntries do: [ :each |						MapCache removeKey: each ] ] ].		MapCache			at: aCompiledMethod			put: aDebuggerMethodMap ]! !!DebuggerMethodMap class methodsFor: 'instance creation' stamp: 'ul 11/15/2010 08:39' prior: 56421570!forMethod: aMethod "<CompiledMethod>"	"Answer a DebuggerMethodMap suitable for debugging activations of aMethod.	 Answer an existing instance from the cache if it exists, cacheing a new one if required."		^self protected: [ 		MapCache			at: aMethod			ifAbsent: [self						cacheDebugMap:							(self								forMethod: aMethod								methodNode: aMethod methodNode)						forMethod: aMethod] ]! !!DebuggerMethodMap class methodsFor: 'synchronization' stamp: 'ul 11/15/2010 08:38'!protected: aBlock	^(AccessLock ifNil: [ AccessLock := Mutex new ]) critical: aBlock! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'ul 11/15/2010 08:38' prior: 56421246!voidMapCache	self protected: [ 		MapCache := WeakIdentityKeyDictionary new.		MapCacheEntries := 16 ]! !!FileList2 methodsFor: 'initialize-release' stamp: 'ul 11/23/2010 10:46' prior: 57910759!initialize	super initialize.	showDirsInFileList := false.	fileSelectionBlock := [ :entry :myPattern |		entry isDirectory ifTrue: [			showDirsInFileList		] ifFalse: [			myPattern = '*' or: [myPattern match: entry name]		]	].	dirSelectionBlock := [ :dirName | true].! !PointerFinder removeSelector: #isLiteral!"Tools"!!Character methodsFor: 'testing' stamp: '' prior: 18434712!isLiteral	^true! !!Character methodsFor: 'testing' stamp: 'ul 11/23/2010 13:28'!shouldBePrintedAsLiteral	^value between: 33 and: 255! !!Character methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28' prior: 18435556!storeOn: aStream	"Common character literals are preceded by '$', however special need to be encoded differently: for some this might be done by using one of the shortcut constructor methods for the rest we have to create them by ascii-value."	| name |	self shouldBePrintedAsLiteral		ifTrue: [ aStream nextPut: $$; nextPut: self ]		ifFalse: [			name := self class constantNameFor: self.			name notNil				ifTrue: [ aStream nextPutAll: self class name; space; nextPutAll: name ]				ifFalse: [					aStream 						nextPut: $(; nextPutAll: self class name; 						nextPutAll: ' value: '; print: value; nextPut: $) ] ].! !!Array methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28' prior: 53390605!printOn: aStream	self shouldBePrintedAsLiteral ifTrue: [^self printAsLiteralFormOn: aStream].	self class = Array ifTrue: [^self printAsBraceFormOn: aStream].	^super printOn: aStream! !!Array methodsFor: 'testing' stamp: 'ul 11/23/2010 13:28'!shouldBePrintedAsLiteral	^self class == Array and: [ self allSatisfy: [ :each | each shouldBePrintedAsLiteral ] ]! !!Array methodsFor: 'printing' stamp: 'ul 11/23/2010 13:28' prior: 53390856!storeOn: aStream 	"Use the literal form if possible."	self shouldBePrintedAsLiteral		ifTrue: 			[aStream nextPut: $#; nextPut: $(.			self do: 				[:element | 				element storeOn: aStream.				aStream space].			aStream nextPut: $)]		ifFalse: [super storeOn: aStream]! !!Array methodsFor: 'filter streaming' stamp: 'ul 11/23/2010 13:28' prior: 17031079!storeOnStream:aStream		self shouldBePrintedAsLiteral 		ifTrue: [ super storeOnStream:aStream ]		ifFalse:[ aStream writeCollection:self ]! !"Collections"!!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 11/7/2010 05:29' prior: 28797924!critical: mutuallyExcludedBlock ifCurtailed: terminationBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	^self critical: [ mutuallyExcludedBlock ifCurtailed: terminationBlock ]! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 11/7/2010 15:00' prior: 57564818!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	hasError := false.	blockValue := self critical:[		mutuallyExcludedBlock ifError: [ :msg :rcvr |			hasError := true.			errMsg := msg.			errRcvr := rcvr		].	].	hasError ifTrue:[ ^errorBlock value: errMsg value: errRcvr].	^blockValue! !!Semaphore methodsFor: 'mutual exclusion' stamp: 'ul 12/8/2010 03:16' prior: 34785364!critical: mutuallyExcludedBlock ifLocked: alternativeBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, then evaluate 	alternativeBlock and return."	"See the comment of #critical: for the explanation how this pattern works	before changing the code."	| caught |	caught := false.	^[		"We're using #== here instead of #=, because it won't introduce a		suspension point, while #= may do that."		excessSignals == 0			ifTrue: [ alternativeBlock value ]			ifFalse: [				excessSignals := excessSignals - 1.				caught := true.				mutuallyExcludedBlock value ] ]		ensure: [ caught ifTrue: [ self signal ] ]! !!CompiledMethod methodsFor: 'converting' stamp: 'ul 12/8/2010 03:24'!asString	^self printString! !!BlockClosure methodsFor: 'scheduling' stamp: 'ul 12/8/2010 02:47'!newProcessWith: anArray 	"Answer a Process running the code in the receiver. The receiver's block 	arguments are bound to the contents of the argument, anArray. The 	process is not scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self valueWithArguments: anArray.			Processor terminateActive] asContext		priority: Processor activePriority! !!BlockClosure methodsFor: 'evaluating' stamp: 'ul 12/8/2010 02:47'!valueWithExit 	  self value: [ ^nil ]! !"Kernel"!!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 12/8/2010 21:15'!classAndTraitNames	"Answer a sorted collection of all class and trait (not including class-traits) names. The performance of this algorithm is O(n) if the classNames are already cached, otherwise O(n*log(n)) where n is self size."	| classNames traitNames result temporary |	classNames := self classNames.	traitNames := self traitNames.	temporary := Array new: classNames size + traitNames size.	result := temporary shallowCopy.	temporary		replaceFrom: 1		to: classNames size		with: classNames		startingAt: 1;		replaceFrom: classNames size + 1		to: temporary size		with: traitNames		startingAt: 1;		mergeFirst: 1		middle: classNames size		last: temporary size		into: result		by: nil.	^result! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'ul 12/8/2010 21:06' prior: 58583493!traitNames	"Answer a sorted collection of all traits (not including class-traits) names."	^self nonClassNames select: [ :name |		(name beginsWith: 'AnObsolete') not and: [			self 				at: name 				ifPresent: [ :global | global isInMemory and: [ global isTrait ] ]				ifAbsent: [ false ] ] ]! !"System"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'laza 12/8/2010 13:55' prior: 35059629!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."OCompletion provides source code completion as you type"(Installer ss project: ''OCompletion'') install: ''Ocompletion''.(Smalltalk at: #ECToolSet) register.(Smalltalk at: #ToolSet) default: (Smalltalk at: #ECToolSet)."Omnibrowser, including Refactoring engine"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfOmniBrowser''.((Smalltalk at: #ConfigurationOfOmniBrowser) project perform: #lastVersion) load: #( Dev )."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WAPharoServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register.!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 57 12 2 1 8 1 13 2 8 1 13 13 3 1 10 2 8 13 3 1 8 2 8 12 3 1 10 4 44 11 2 1 8 1 21 2 8 1 28 14 3 1 1 28 7 11 11 2 5 4 3 5 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 28 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 2)c000122122,cblack;,c000122122,cblack;,c000000122,cblack;,c122000122,cblack;,c000122122,cblack;,c000122122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000127127,cblack;,c000000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c127000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000000127,cblack;,c000122122,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000122,cblack;,c000000122,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000122122,cblack;,c000000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000122122,cblack;,c000122122,cblack;,c000000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000122122,cblack;,c000000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000122122,cblack;,c000000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c122000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;,c000000122,cblack;!!' readStream nextChunkText! !!SystemProgressMorph class methodsFor: 'instance creation' stamp: 'laza 12/8/2010 12:16' prior: 30742631!close: aBlock	| slot |	slot := aBlock value: SmallInteger maxVal. "This should prevent a redraw"	aBlock receiver freeSlot: slot.	! !!SystemProgressMorph methodsFor: 'private' stamp: 'laza 12/8/2010 12:13' prior: 53325774!freeSlot: number	number > 0 ifFalse: [^self].	lock critical: [| label |		label := labels at: number.		(label isNil or: [label owner isNil]) ifTrue: [^self]. "Has been freed before"		label delete.		(bars at: number) delete.		activeSlots := activeSlots - 1.		activeSlots = 0			ifTrue: [self delete]			ifFalse: [self recenter]]! !SystemProgressMorph removeSelector: #close:!"Morphic"!!ProjectNavigationMorph methodsFor: 'the actions' stamp: 'muOuser 12/2/2010 07:06' prior: 27331455!findAProject	FileList2 		morphicViewProjectLoader2InWorld: World		reallyLoad: true		dirFilterType: #initialDirectoryList! !"MorphicExtras"!!TranscriptStream methodsFor: 'stream extensions' stamp: 'jrd 11/9/2010 14:01'!showln: anObject  "TextCollector compatibility"	self nextPutAll: anObject asString; cr ;  endEntry! !"Collections"!!Semaphore methodsFor: 'communication' stamp: 'ul 12/8/2010 04:30'!waitIfLocked: aBlock	"Use a signal if available, otherwise evaluate aBlock"	excessSignals == 0 ifTrue: [ ^aBlock value ].	excessSignals := excessSignals - 1! !!SmallInteger methodsFor: 'printing' stamp: 'ul 12/8/2010 03:59' prior: 52562540!printOn: stream base: base 	"Append a representation of this number in base b on aStream."	self printOn: stream base: base length: 0 padded: false! !!SmallInteger methodsFor: 'printing' stamp: 'ul 11/30/2010 01:38'!printOn: stream base: base length: minimumLength padded: padWithZeroes	| n numberOfDigits totalLength divisor |	self < 0		ifTrue: [			n := self negated.			totalLength := 1 ]		ifFalse: [			n := self.			totalLength := 0 ].	numberOfDigits := n numberOfDigitsInBase: base.	totalLength := totalLength + numberOfDigits.	padWithZeroes ifFalse: [		[ totalLength < minimumLength ] whileTrue: [			stream space.			totalLength := totalLength + 1 ] ].	n = self ifFalse: [ stream nextPut: $- ].	padWithZeroes ifTrue: [		[ totalLength < minimumLength ] whileTrue: [			stream nextPut: $0.			totalLength := totalLength + 1 ] ].	divisor := (base raisedToInteger: numberOfDigits - 1).	[ divisor > 0 ] whileTrue: [		| digit |		digit := n // divisor.		stream nextPut: ('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' at: digit + 1).		n := n - (digit * divisor).		divisor := divisor // base ]! !!SmallInteger methodsFor: 'printing' stamp: 'ul 12/8/2010 04:00' prior: 52561462!printOn: aStream base: b nDigits: n 	"Append a representation of this number in base b on aStream using nDigits.	self must be positive."	self printOn: aStream base: b length: n padded: true! !!Fraction methodsFor: 'testing' stamp: 'ul 11/29/2010 20:05'!negative	^numerator negative! !!ScaledDecimal methodsFor: 'testing' stamp: 'ul 11/29/2010 20:06'!negative	^fraction negative! !!ScaledDecimal methodsFor: 'printing' stamp: 'ul 11/29/2010 20:06'!printFractionAsDecimalOn: stream 	| aFraction integerPart fractionPart |	fraction negative		ifFalse: [ aFraction := fraction ]		ifTrue: [			aFraction := fraction negated.			stream nextPut: $- ].	integerPart := aFraction truncated.	integerPart printOn: stream.	scale = 0 ifTrue: [ ^self ].	stream nextPut: $..	fractionPart := ((aFraction - integerPart) * (10 raisedToInteger: scale)) truncated.	fractionPart		printOn: stream		base: 10		length: scale		padded: true! !!ScaledDecimal methodsFor: 'printing' stamp: 'ul 11/29/2010 00:19' prior: 28167368!printOn: stream	self		printFractionAsDecimalOn: stream;		printScaleOn: stream! !!ScaledDecimal methodsFor: 'printing' stamp: 'ul 11/29/2010 00:14'!printScaleOn: stream	stream nextPut: $s.	scale printOn: stream! !"Kernel"!!Color class methodsFor: 'instance creation' stamp: 'ul 12/9/2010 02:58' prior: 55002261!fromString: aString	"for HTML color spec: #FFCCAA or white/black"	"Color fromString: '#FFCCAA'.	 Color fromString: 'white'.	 Color fromString: 'orange'"		| aColorHex |	aString isEmptyOrNil ifTrue: [ ^self white ].	aString first = $#		ifTrue: [ aColorHex := aString allButFirst ]		ifFalse: [ aColorHex := aString ].	(aColorHex size = 6 and: [ 		aColorHex allSatisfy: [ :each | '0123456789ABCDEFabcdef' includes: each ] ])			ifTrue: [				| green red blue |				red := (Integer readFrom: (aColorHex first: 2) base: 16) / 255.				green := (Integer readFrom: (aColorHex copyFrom: 3 to: 4) base: 16) / 255.				blue := (Integer readFrom: (aColorHex last: 2) base: 16) / 255.				^self r: red g: green b: blue ].		"try to match aColorHex with known named colors"	^self perform: (ColorNames like: aColorHex asLowercase ifAbsent: [ #white ])! !!Color class methodsFor: 'class initialization' stamp: 'ul 12/9/2010 02:55' prior: 54993082!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames := Set new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TranslucentColor new alpha: 0.0).	self named: #paleBuff put: (Color r: 254 g: 250 b: 235 range: 255).	self named: #paleBlue put: (Color r: 222 g: 249 b: 254 range: 255).	self named: #paleYellow put: (Color r: 255 g: 255 b: 217 range: 255).	self named: #paleGreen put: (Color r: 223 g: 255 b: 213 range: 255).	self named: #paleRed put: (Color r: 255 g: 230 b: 230 range: 255).	self named: #veryPaleRed put: (Color r: 255 g: 242 b: 242 range: 255).	self named: #paleTan put: (Color r: 235 g: 224 b: 199 range: 255).	self named: #paleMagenta put: (Color r: 255 g: 230 b: 255 range: 255).	self named: #paleOrange put: (Color r: 253 g: 237 b: 215 range: 255).	self named: #palePeach put: (Color r: 255 g: 237 b: 213 range: 255).! !!Color class methodsFor: 'class initialization' stamp: 'ul 12/9/2010 02:57' prior: 54986990!named: newName put: aColor	"Add a new color to the list and create an access message and a class variable for it.  The name should start with a lowercase letter.  (The class variable will start with an uppercase letter.)  (Color colorNames) returns a list of all color names.  "	| str cap sym accessor csym |	(aColor isKindOf: self) ifFalse: [^ self error: 'not a Color'].	str := newName asString.	sym := str asSymbol.	cap := str capitalized.	csym := cap asSymbol.	(self class canUnderstand: sym) ifFalse: [		"define access message"		accessor := str, (String with: Character cr with: Character tab), 			'^', cap.		self class compile: accessor			classified: 'named colors'].	(self classPool includesKey: csym) ifFalse: [		self addClassVarName: cap].	ColorNames add: sym.	^ self classPool at: csym put: aColor! !!Color methodsFor: 'other' stamp: 'ul 12/9/2010 02:56' prior: 18882226!name	"Return this color's name, or nil if it has no name. Only returns a name if it exactly matches the named color."	^ColorNames detect: [ :name | (Color perform: name) = self ] ifNone: [ nil ]! !"Graphics"!!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 1/22/2005 19:37' prior: 17982798!fillRectangle: aRectangle fillStyle: aFillStyle borderStyle: aBorderStyle	"Fill the given rectangle."	aFillStyle isTransparent ifFalse:[		self fillRectangle: (aRectangle insetBy: aBorderStyle width) fillStyle: aFillStyle].	aBorderStyle ifNil:[^self].	aBorderStyle width <= 0 ifTrue:[^self].	aBorderStyle frameRectangle: aRectangle on: self! !!Morph methodsFor: 'printing' stamp: 'ul 12/9/2010 03:01' prior: 34400636!colorString: aColor 	aColor ifNil: [ ^'nil' ].	^aColor name		ifNil: [ aColor storeString ]		ifNotNil: [ :colorName | 'Color ', colorName ]! !"Morphic"!!FloatingBookControlsMorph methodsFor: 'stepping and presenter' stamp: 'cmm 12/6/2010 16:19' prior: 20944109!step	owner == self world ifFalse: [^ self].	owner addMorphInLayer: self.	self position: (owner bottomCenter) - ((self width//2)@self height)! !!BookMorph methodsFor: 'other' stamp: 'cmm 12/6/2010 16:28' prior: 50473569!exitFullScreen	| floater |	self isInFullScreenMode ifFalse: [ ^ self ].	self		setProperty: #fullScreenMode		toValue: false.	(self hasProperty: #showWorldMainDockingBarWhenNotFullScreen) ifTrue:		[ MorphicProject current showWorldMainDockingBar: (self valueOfProperty: #showWorldMainDockingBarWhenNotFullScreen).		self removeProperty: #showWorldMainDockingBarWhenNotFullScreen ].	floater := self		valueOfProperty: #floatingPageControls		ifAbsent: [  ].	floater ifNotNil:		[ floater delete.		self removeProperty: #floatingPageControls ].	self position: 0 @ 0.	self adjustCurrentPageForFullScreen! !!BookMorph methodsFor: 'other' stamp: 'cmm 12/6/2010 16:29' prior: 50477087!goFullScreen	| floater |	self isInFullScreenMode ifTrue: [ ^ self ].	self		setProperty: #fullScreenMode		toValue: true.	self		setProperty: #showWorldMainDockingBarWhenNotFullScreen		toValue: Project current showWorldMainDockingBar.	Project current showWorldMainDockingBar: false.	self position: (currentPage topLeft - self topLeft) negated.	self adjustCurrentPageForFullScreen.	floater := self buildFloatingPageControls.	self		setProperty: #floatingPageControls		toValue: floater.	floater openInWorld! !!BookMorph methodsFor: 'menu' stamp: 'cmm 12/4/2010 15:10' prior: 17628612!setPageColor	"Get a color from the user, then set all the pages to that color"	self currentPage ifNil: [ ^ self ].	NewColorPickerMorph useIt		ifTrue:			[ (NewColorPickerMorph				on: self				originalColor: self currentPage color				setColorSelector: #setAllPagesColor:) openNear: self fullBoundsInWorld ]		ifFalse:			[ ColorPickerMorph new				 choseModalityFromPreference ;				 sourceHand: self activeHand ;				 target: self ;				 selector: #setAllPagesColor: ;				 originalColor: self currentPage color ;								putUpFor: self				near: self fullBoundsInWorld ]! !"MorphicExtras"!!Browser methodsFor: 'drag and drop' stamp: 'laza 12/10/2010 10:37' prior: 34944836!dropOnMessageCategories: method at: index	| dstClass category copy |	copy := Sensor shiftPressed.	(method isKindOf: CompiledMethod) 		ifFalse:[^self inform: 'Can only drop methods'].	dstClass := self selectedClassOrMetaClass.	(dstClass == method methodClass) ifTrue:[		category := self messageCategoryList at: index.		category = ClassOrganizer allCategory ifTrue: [^false].		dstClass organization classify: method selector  under: category suppressIfDefault: false.		^true].	copy ifFalse: [		(self confirm: (			'Classes {1} and {2} are unrelated.{3}Are you sure you want to move this method?'				format: { method methodClass. dstClass. Character cr })) 					ifFalse: [ ^false ] ].	dstClass		compile: method getSource		classified: (self messageCategoryList at: index)		withStamp: method timeStamp		notifying: nil.	copy ifFalse: [		method methodClass removeSelector: method selector ].	^true! !!Debugger methodsFor: 'accessing' stamp: 'fbs 12/2/2010 17:38' prior: 19543463!contents 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	^contents ifNil:		[self selectedContext			ifNotNil: [self selectedMessage]			ifNil: [String new]] ! !"Tools"!!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:45' prior: 53993736!flushAllSuchThat: aBlock	"Remove from the queue all objects that satisfy aBlock."		accessProtect critical: [		| newReadPos |		newReadPos := writePosition.		writePosition - 1 to: readPosition by: -1 do: [ :i |			| value |			value := contentsArray at: i.			contentsArray at: i put: nil.			((aBlock value: value) and: [ (readSynch waitIfLocked: [ nil ]) notNil ]) ifFalse: [				newReadPos := newReadPos - 1.				contentsArray at: newReadPos put: value ] ].		readPosition := newReadPos ]! !!SharedQueue methodsFor: 'private' stamp: 'ul 10/19/2010 04:53' prior: 34668029!makeRoomAtEnd	| contentsSize newContentsArray |	contentsSize := writePosition - readPosition.	newContentsArray := contentsSize * 2 > contentsArray size		ifTrue: [ contentsArray class new: contentsArray size * 2 ]		ifFalse: [			(contentsArray size > 10 and: [ contentsSize * 4 <= contentsArray size ])				ifTrue: [ contentsArray class new: (contentsSize * 2 max: 10) ]				ifFalse: [ contentsArray ] ].	newContentsArray		replaceFrom: 1		to: contentsSize		with: contentsArray		startingAt: readPosition.	contentsArray == newContentsArray 		ifFalse: [ contentsArray := newContentsArray ]		ifTrue: [ contentsArray from: contentsSize + 1 to: contentsArray size put: nil ].	readPosition := 1.	writePosition := contentsSize + 1! !!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:31' prior: 53995028!nextOrNil	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone. If no object has been sent, answer <nil>."	readSynch waitIfLocked: [ ^nil ].	^accessProtect		critical: [			| value |			readPosition = writePosition					ifTrue: 						[self error: 'Error in SharedQueue synchronization'.						 value := nil]					ifFalse: 						[value := contentsArray at: readPosition.						 contentsArray at: readPosition put: nil.						 readPosition := readPosition + 1].			value ]! !!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:44' prior: 53995593!nextOrNilSuchThat: aBlock	"Answer the next object that satisfies aBlock, skipping any intermediate objects.	If no object has been sent, answer <nil> and leave me intact.	NOTA BENE:  aBlock MUST NOT contain a non-local return (^)."	^accessProtect critical: [		| value readPos |		value := nil.		readPos := readPosition.		[ readPos < writePosition and: [ value isNil ] ] whileTrue: [			value := contentsArray at: readPos.			readPos := readPos + 1.			(aBlock value: value)				ifFalse: [ value := nil ]				ifTrue: [					readSynch waitIfLocked: [ ^nil ]. "We found the value, but someone else booked it."					readPosition to: readPos - 1 do: [ :j | contentsArray at: j put: nil ].					readPosition := readPos ] ].		value ]."===q := SharedQueue new.1 to: 10 do: [ :i | q nextPut: i].c := OrderedCollection new.[	v := q nextOrNilSuchThat: [ :e | e odd].	v notNil] whileTrue: [	c add: {v. q size}].{c. q} explore==="! !!SharedQueue methodsFor: 'accessing' stamp: 'ul 12/8/2010 04:37' prior: 53996608!peek	"Answer the object that was sent through the receiver first and has not 	yet been received by anyone but do not remove it from the receiver. If 	no object has been sent, return nil"	^readSynch		critical: [			accessProtect critical: [				readPosition >= writePosition ifFalse: [					contentsArray at: readPosition ] ] ]		ifLocked: [ nil ]! !"Collections"!!Behavior methodsFor: 'instance creation' stamp: 'HenrikSperreJohansen 12/10/2010 11:30'!adoptInstance: anInstance	"Change the class of anInstance to me.	Primitive (only found in Cog) should follow the same rules as described in 	primitiveChangeClassTo:"	<primitive: 160 error: ec>	^anInstance primitiveChangeClassTo: self basicNew.! !"Kernel"!!Utilities class methodsFor: 'finding pointers' stamp: 'mtf 8/15/2008 23:54' prior: 55296036!pointersTo: anObject except: objectsToExclude 	"Find all occurrences in the system of pointers to the argument	anObject. Remove objects in the exclusion list from the	results. "	^ anObject inboundPointersExcluding: objectsToExclude! !Utilities class removeSelector: #classFromPattern:withCaption:!"System"!!Utilities class methodsFor: '*ToolBuilder-Kernel' stamp: 'ul 12/12/2010 23:09'!classFromPattern: pattern withCaption: aCaption	"If there is a class or trait whose name exactly given by pattern, return it.	If there is only one class or trait in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores separator characters in the pattern"	^self classOrTraitFrom: Smalltalk environment pattern: pattern label: aCaption"	self classFromPattern: 'CharRecog' withCaption: ''	self classFromPattern: 'rRecog' withCaption: ''	self classFromPattern: 'znak' withCaption: ''	self classFromPattern: 'orph' withCaption: ''	self classFromPattern: 'TCompil' withCaption: ''"! !!Utilities class methodsFor: '*ToolBuilder-Kernel' stamp: 'ul 12/12/2010 22:56'!classOrTraitFrom: environment pattern: pattern label: label	"If there is a class or trait whose name exactly given by pattern, return it.	If there is only one class or trait in the given environment whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores separator characters in the pattern"		| toMatch potentialNames names exactMatch lines reducedIdentifiers selectedIndex |	toMatch := pattern copyWithoutAll: Character separators.	toMatch ifEmpty: [ ^nil ].	"If there's a class or trait named as pattern, then return it."	Symbol hasInterned: pattern ifTrue: [ :symbol |		environment at: symbol ifPresent: [ :maybeClassOrTrait |			((maybeClassOrTrait isKindOf: Class) or: [				maybeClassOrTrait isTrait ])					ifTrue: [ ^maybeClassOrTrait ] ] ].	"No exact match, look for potential matches."	toMatch := pattern asLowercase copyWithout: $..	potentialNames := environment classAndTraitNames.	names := pattern last = $. "This is some old hack, using String>>#match: may be better."		ifTrue: [ potentialNames select: [ :each | each asLowercase = toMatch ] ]		ifFalse: [			potentialNames select: [ :each |				each includesSubstring: toMatch caseSensitive: false ] ].	exactMatch := names detect: [ :each | each asLowercase = toMatch ] ifNone: [ nil ].	lines := OrderedCollection new.	exactMatch ifNotNil: [ lines add: 1 ].	"Also try some fuzzy matching."	reducedIdentifiers := pattern suggestedTypeNames select: [ :each |		potentialNames includes: each ].	reducedIdentifiers ifNotEmpty: [		names addAll: reducedIdentifiers.		lines add: 1 + names size + reducedIdentifiers size ].	"Let the user select if there's more than one possible match. This may give surprising results."	selectedIndex := names size = 1		ifTrue: [ 1 ]		ifFalse: [			exactMatch ifNotNil: [ names addFirst: exactMatch ].			UIManager default chooseFrom: names lines: lines title: label ].	selectedIndex = 0 ifTrue: [ ^nil ].	^environment at: (names at: selectedIndex) asSymbol! !!UIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 21:05'!chooseClassOrTrait	"Let the user choose a Class or Trait"		^self chooseClassOrTrait: 'Class name or fragment?'! !!UIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 21:04'!chooseClassOrTrait: label	"Let the user choose a Class or Trait"		^self chooseClassOrTrait: label from: Smalltalk environment! !!UIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 23:06'!chooseClassOrTrait: label from: environment	"Let the user choose a Class or Trait."		| pattern |	pattern := self request: label.	^Utilities classOrTraitFrom: environment pattern: pattern label: label	! !"ToolBuilder-Kernel"!!MorphicUIManager methodsFor: 'ui requests' stamp: 'ul 12/12/2010 22:00'!chooseClassOrTrait: label from: environment	"Let the user choose a Class or Trait. Use ListChooser in Morphic."		| names index |	names := environment classAndTraitNames.	index := self		chooseFrom: names		lines: #()		title: label.	index = 0 ifTrue: [ ^nil ].	^environment		at: (names at: index)		ifAbsent: [ nil ]! !"ToolBuilder-Morphic"!!PointerFinder class methodsFor: 'utilities' stamp: 'mtf 8/15/2008 23:52' prior: 54923024!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. 	Remove objects in the exclusion list from the results."		^ anObject inboundPointersExcluding: objectsToExclude! !!PointerFinder methodsFor: 'application' stamp: 'mtf 8/15/2008 17:28' prior: 26584998!followObject: anObject	anObject outboundPointersDo: [:ea |		(self follow: ea from: anObject)			ifTrue: [^ true]].	^ false! !!PointerExplorerWrapper methodsFor: 'accessing' stamp: 'mtf 8/19/2008 22:25' prior: 26581721!contents	| objects |	objects := Utilities pointersTo: item except: (Array with: self).	^(objects reject: [:ea | ea class = self class or: [ea class = PointerExplorer]])		collect: [:ea| self class with: ea name: ea identityHash asString model: item]! !!DebuggerMethodMap class methodsFor: 'class initialization' stamp: 'mtf 9/19/2010 19:50'!cleanUp	self initialize! !"Tools"!!SharedQueue methodsFor: 'private' stamp: 'ar 10/4/2006 12:43'!printOn: aStream	super printOn: aStream.	"Print a guesstimate of the size of the queue without aquiring the lock properly"	aStream nextPut: $(.	aStream print: writePosition - readPosition.	aStream nextPut: $).! !"Collections"!!ContextPart methodsFor: 'debugger access' stamp: 'mtf 6/26/2009 17:56' prior: 50833724!errorReportOn: strm	"Write a detailed error report on the stack (above me) on a stream.  For both the error file, and emailing a bug report.  Suppress any errors while getting printStrings.  Limit the length."	| cnt aContext startPos | 	strm print: Date today; space; print: Time now; cr.	strm cr.	strm nextPutAll: 'VM: ';		nextPutAll:  SmalltalkImage current platformName asString;		nextPutAll: ' - ';		nextPutAll: SmalltalkImage current asString;		cr.	strm nextPutAll: 'Image: ';		nextPutAll:  SystemVersion current version asString;		nextPutAll: ' [';		nextPutAll: SmalltalkImage current lastUpdateString asString;		nextPutAll: ']';		cr.	strm cr.	SecurityManager default printStateOn: strm.		"Note: The following is an open-coded version of ContextPart>>stackOfSize: since this method may be called during a low space condition and we might run out of space for allocating the full stack."	cnt := 0.  startPos := strm position.	aContext := self.	[aContext notNil and: [(cnt := cnt + 1) < 20]] whileTrue:		[aContext printDetails: strm.	"variable values"		strm cr.		aContext := aContext sender].	strm cr; nextPutAll: '--- The full stack ---'; cr.	aContext := self.	cnt := 0.	[aContext == nil] whileFalse:		[cnt := cnt + 1.		cnt = 20 ifTrue: [strm nextPutAll: ' - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -'; cr].		strm print: aContext; cr.  "just class>>selector"			strm position > (startPos+40000) ifTrue: [strm nextPutAll: '...etc...'.			^ self]. 	"exit early"		cnt > 60 ifTrue: [strm nextPutAll: '-- and more not shown --'.  ^ self].		aContext := aContext sender].! !!ContextPart methodsFor: 'printing' stamp: 'jrd 5/6/2010 00:41' prior: 50816094!printDetails: strm	"Put my class>>selector and arguments and temporaries on the stream.  Protect against errors during printing."	| str |	self printOn: strm.  	strm cr; tab; nextPutAll: 'Arguments and temporary variables: '; cr.	str := [self tempsAndValuesLimitedTo: 160 indent: 2] ifError: [:err :rcvr | 						'<<error during printing>>'].	strm nextPutAll: str.	strm peekLast == Character cr ifFalse: [strm cr].! !"Kernel"!!TextMorphForEditView methodsFor: 'event handling' stamp: 'ar 5/5/2004 19:11' prior: 31404052!mouseDown: event	event yellowButtonPressed ifTrue: [		(editor yellowButtonDown: event) ifTrue:[^self].		^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !"Morphic"!!Browser methodsFor: 'system category functions' stamp: 'ul 12/12/2010 23:30' prior: 34069012!findClass	"Search for a class by name."	| foundClass |	(multiWindowState notNil	 or: [self okToChange]) ifFalse:		[^self classNotFound].	foundClass := UIManager default chooseClassOrTrait.	foundClass ifNil: [^self classNotFound].	(self selectedClass notNil	 and: [multiWindowState notNil	 "Can only support multi-window if original window has all the right panes."	 and: [multiWindowState prototype isHierarchy not]]) ifTrue:		[(self classList includes: foundClass name)			ifTrue: [multiWindowState copyWindow]			ifFalse: [multiWindowState addNewWindow]]. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !"Tools"!Smalltalk cleanUp: false!----SNAPSHOT----{13 December 2010 . 6:00:39 pm} Squeak4.2-10548-alpha.1.image priorSource: 1012535!Smalltalk cleanUp: false!----SNAPSHOT----{13 December 2010 . 6:01:45 pm} Squeak4.2-10779-alpha.image priorSource: 1621735!----QUIT/NOSAVE----{13 December 2010 . 6:01:50 pm} Squeak4.2-10779-alpha.image priorSource: 1621863!----STARTUP----{31 January 2011 . 10:49:26 am} as /home/cmm/4dst/dev/src/squeak-4.1/basic/Squeak4.2-10779-alpha.image!!UUIDGenerator methodsFor: 'random seed' stamp: 'cmm 12/14/2010 13:44' prior: 57427974!makeUnixSeed	^[FileStream readOnlyFileNamed: '/dev/urandom' do: [:strm |		strm binary.		strm converter: Latin1TextConverter new.		(Integer			byte1: strm next			byte2: strm next			byte3: strm next			byte4: strm next) normalize].	] on: FileStreamException do: [nil]! !"Network"!!String methodsFor: 'displaying' stamp: 'mtf 12/21/2010 22:06' prior: 30186905!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	^ UIManager default 		displayProgress: self		at: aPoint 		from: minVal 		to: maxVal 		during: workBlock! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 12/14/2010 08:20'!normalize	"Unsafely normalize the receiver in-place (become a unit vector). 	 Div-by-Zero raised if len 0."	<primitive: 'primitiveNormalize' module: 'FloatArrayPlugin'>	self /= self length.! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'ar 5/5/2004 17:15'!menu	^nil! !"Collections"!!MCFileBasedRepository methodsFor: 'versions' stamp: 'ar 12/15/2010 18:02'!versionNamed: versionName ifAbsent: aBlock	"Answer the MCVersion corresponding to the given version name"	(self allFileNamesForVersionNamed: versionName) do:[:fileName | 		| version |		version := self versionFromFileNamed: fileName.		version info name = versionName ifTrue: [^version].	].	^aBlock value! !!MCPackageManager class methodsFor: 'class initialization' stamp: 'bp 12/14/2010 07:57'!cleanUp: aggressive	"Remove all PackageInfos that are not associated with an MCPackageManager when aggressively cleaning up"	aggressive ifTrue: [self flushObsoletePackageInfos]! !!MCDictionaryRepository methodsFor: 'versions' stamp: 'ar 12/15/2010 21:59'!allVersionNames	"Answers all the version names in this repository"	^ dict values collect: [:ea | ea info name]	! !!MCDictionaryRepository methodsFor: 'versions' stamp: 'ar 12/15/2010 17:56'!versionNamed: versionName ifAbsent: aBlock	"Answer the MCVersion corresponding to the given version name"	^dict detect:[:any| any info name = versionName] ifNone: aBlock! !!MCRepository class methodsFor: 'instance creation' stamp: 'ar 12/16/2010 09:41'!location: urlOrPath	"Answer an MCRepository for the given url or path. Accepted locations are:		- http, and ftp urls (i.e., http://source.squeak.org/trunk)		- directory paths (i.e., C:\Squeak\packages)		- directory matches (i.e., C:\Squeak\packages\*)	"	^self location: urlOrPath username: '' password: ''! !!MCRepository class methodsFor: 'instance creation' stamp: 'ar 12/16/2010 09:41'!location: urlOrPath username: user password: pass	"Answer an MCRepository for the given url or path. Accepted locations are:		- http, and ftp urls (i.e., http://source.squeak.org/trunk)		- directory paths (i.e., C:\Squeak\packages)		- directory matches (i.e., C:\Squeak\packages\*)	If provided, the supplied user name and password will be used."	| url |	(urlOrPath findString: '://') > 0 ifTrue:[		url := urlOrPath asUrl.		url scheme caseOf: {			['ftp'] -> [^MCFtpRepository 							host: url authority							 directory: url pathString allButFirst							user: user 							password: user].			['http'] -> [^MCHttpRepository 							location: urlOrPath 							user: user 							password: pass].		} otherwise:[^self error: 'Unsupported scheme: ', url scheme].	].	(urlOrPath endsWith: '*') ifTrue:[		^MCSubDirectoryRepository new 				directory: (FileDirectory on: urlOrPath allButLast)].	^MCDirectoryRepository new 			directory: (FileDirectory on: urlOrPath)! !!MCRepository methodsFor: 'versions' stamp: 'ar 12/15/2010 22:43'!allVersionNames	"Answer all the version names in this repository"	^self subclassResponsibility! !!MCRepository methodsFor: 'versions' stamp: 'ar 12/15/2010 17:55'!versionNamed: versionName	"Answer the MCVersion corresponding to the given version name"	^self versionNamed: versionName ifAbsent:[nil]! !!MCRepository methodsFor: 'versions' stamp: 'ar 12/15/2010 17:55'!versionNamed: versionName ifAbsent: aBlock	"Answer the MCVersion corresponding to the given version name"	^aBlock value! !"Monticello"!!Float commentStamp: '<historical>' prior: 59308433!My instances represent IEEE-754 floating-point double-precision numbers.  They have about 16 digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:		8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:	3r20.2 --> 6.66666666666667	8r20.2 --> 16.25If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...	sign		1 bit	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent						in the range -1023 .. +1024				- 16r000:					significand = 0: Float zero					significand ~= 0: Denormalized number (exp = -1024, no hidden '1' bit)				- 16r7FF:					significand = 0: Infinity					significand ~= 0: Not A Number (NaN) representation	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.The single-precision format is...	sign		1 bit	exponent	8 bits, with bias of 127, to represent -126 to +127                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)	mantissa	24 bits, but only 23 are storedThis format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.Thanks to Rich Harmon for asking many questions and to Tim Olson, Bruce Cohen, Rick Zaccone and others for the answers that I have collected here.!!Class methodsFor: 'copying' stamp: 'nice 12/29/2010 10:47' prior: 54807851!copy 	"Answer a copy of the receiver without a list of subclasses."	| newClass |	newClass := self class copy new		superclass: superclass		methodDict: self methodDict copy		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools copy.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Float class methodsFor: 'class initialization' stamp: 'ar 12/13/2010 23:43' prior: 57960123!initialize	"Float initialize"	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288		Pi/2 = 1.57079632679489661923132169163975144		Pi*2 = 6.28318530717958647692528676655900576		Pi/180 = 0.01745329251994329576923690768488612		2.0 ln = 0.69314718055994530941723212145817657		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi := 3.14159265358979323846264338327950288.	Halfpi := Pi / 2.0.	Twopi := Pi * 2.0.	ThreePi := Pi * 3.0.	RadiansPerDegree := Pi / 180.0.	Ln2 := 0.69314718055994530941723212145817657.	Ln10 := 10.0 ln.	Sqrt2 := 1.41421356237309504880168872420969808.	E := 2.718281828459045235360287471353.	Epsilon := 0.000000000001.  "Defines precision of mathematical functions"	MaxVal := 1.7976931348623157e308.	MaxValLn := 709.782712893384.	MinValLogBase2 := -1074.	Infinity := MaxVal * MaxVal.	NegativeInfinity := 0.0 - Infinity.	NaN := Infinity - Infinity.	NegativeZero := 1.0 / Infinity negated.	SignalNaN := true.! !!Float class methodsFor: 'preferences' stamp: 'ar 12/14/2010 00:07'!signalNaN	<preference: 'Signal NaN'		category: 'general' "since there is no math/arithmetic category"		description: 'When enabled, generate NaNError when encountering NaN. When disabled, silently propagate NaN'		type: #Boolean>	^SignalNaN! !!Float class methodsFor: 'preferences' stamp: 'ar 12/13/2010 23:44'!signalNaN: aBool	"Preference accessor"	SignalNaN := aBool.! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:56' prior: 20891130!arcCos	"Answer the angle in radians."	<primitive: 'primitiveArcCos' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^ Halfpi - self arcSin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:56'!arcCosH	<primitive: 'primitiveArcCosH' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:57' prior: 20891272!arcSin	"Answer the angle in radians."	<primitive: 'primitiveArcSin' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi * self]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:57'!arcSinH	<primitive: 'primitiveArcSinH' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:57' prior: 51149106!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveArcTan' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	^self primitiveArcTan! !!Float methodsFor: 'mathematical functions' stamp: 'ul 12/25/2010 04:53' prior: 53406186!arcTan: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive.	Implementation note: use sign in order to catch cases of negativeZero"	<primitive: 'primitiveArcTan2' module: 'FloatMathPlugin'>	self isNaN ifTrue:[		SignalNaN ifTrue:[ NaNError signal ].		^self].	denominator isNaN ifTrue:[		SignalNaN ifTrue: [ NaNError signal ].		^denominator ].	^self = 0.0		ifTrue: [denominator sign >= 0			ifTrue: [ 0 ]			ifFalse: [ self sign >= 0				ifTrue: [ Pi ]				ifFalse: [ Pi negated ]]]		ifFalse: [denominator = 0.0			ifTrue: [self > 0.0				ifTrue: [ Halfpi ]				ifFalse: [ Halfpi negated ]]			ifFalse: [denominator > 0				ifTrue: [ (self / denominator) arcTan ]				ifFalse: [self > 0					ifTrue: [ ((self / denominator) arcTan) + Pi ]					ifFalse: [ ((self / denominator) arcTan) - Pi ]]]]! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:57'!arcTanH	<primitive: 'primitiveArcTanH' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/26/2010 08:03' prior: 20892888!cos	"Answer the cosine of the receiver taken as an angle in radians."	<primitive: 'primitiveCos' module: 'FloatMathPlugin'>	self isFinite ifFalse:[SignalNaN ifTrue:[NaNError signal]. ^NaN].	^ (self + Halfpi) sin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:58'!cosH	"Answer the cosine of the receiver taken as an angle in radians."	<primitive: 'primitiveCosH' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:58' prior: 51136974!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	<primitive: 'primitiveExp' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	"For now, fall back to the Squeak version of exp if FloatMathPlugin is absent"	^self primitiveExp! !!Float methodsFor: 'truncation and round off' stamp: 'ar 12/13/2010 23:58' prior: 20912582!fractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 'primitiveFractionalPart' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self - self truncated asFloat! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:58'!hypot: arg	"hypot(x,y) returns sqrt(x^2+y^2) with error less  than 1 ulps"	<primitive: 'primitiveHypot' module: 'FloatMathPlugin'>	arg isFloat ifFalse:[^self hypot: arg asFloat].	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	arg isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^arg].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:58' prior: 51153381!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveLogN' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	self <= 0.0 ifTrue: [^self error: 'ln is only defined for x > 0.0'].	^self primitiveLn! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:58' prior: 20895474!log	"Answer the base 10 logarithm of the receiver."	<primitive: 'primitiveLog10' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^ self ln / Ln10! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:18'!primitiveArcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta := (self * Halfpi) / (self + 1.0).	"iterate"	eps := Halfpi * Epsilon.	step := theta.	[(step * step) > eps] whileTrue: [		sinTheta := theta sin.		cosTheta := theta cos.		step := (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta := theta - step].	^ theta! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:07'!primitiveExp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base := E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract := self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction := 1.0 + fract.	delta := fract * fract / 2.0.	div := 2.0.	[delta > Epsilon] whileTrue: [		correction := correction + delta.		div := div + 1.0.		delta := delta * fract / div].	correction := correction + delta.	^ base * correction! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:07'!primitiveFractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 52>	^self - self truncated asFloat! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:15'!primitiveLn	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt := self exponent.	n := Ln2 * expt.	mant := self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x := mant - 1.0.	div := 1.0.	pow := delta := sum := x.	x := x negated.  "x <= 0"	eps := Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta.		"pass two: delta is negative"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:08'!primitiveSin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum := delta := self.	self2 := 0.0 - (self * self).	i := 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta.		"twice"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta].	^ sum! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:08'!primitiveSqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	"Newton-Raphson"	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0]				ifFalse: ["v Chg"					^ FloatingPointException signal: 'undefined if less than zero.']].	"first guess is half the exponent"	exp := self exponent // 2.	guess := self timesTwoPower: 0 - exp.	"get eps value"	eps := guess * Epsilon.	eps := eps * eps.	delta := self - (guess * guess) / (guess * 2.0).	[delta * delta > eps]		whileTrue: 			[guess := guess + delta.			delta := self - (guess * guess) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'primitives' stamp: 'ar 3/26/2006 17:08'!primitiveTimesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/26/2010 08:04' prior: 51149699!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveSin' module: 'FloatMathPlugin'>	self isFinite ifFalse:[SignalNaN ifTrue:[NaNError signal]. ^NaN].	^self primitiveSin! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:58'!sinH	<primitive: 'primitiveSinH' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:27' prior: 20897809!sqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	"ar 3/26/2006: sqrt is the ONE primitive that we really don't want to use from FloatMathPlugin - it's several times slower and we use it often enough that this can make a noticable difference"	<primitive: 55> "instead of: <primitive: 'primitiveSqrt' module: 'FloatMathPlugin'>"	^self primitiveSqrt! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:58' prior: 20898571!tan	"Answer the tangent of the receiver taken as an angle in radians."	<primitive: 'primitiveTan' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^ self sin / self cos! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:59'!tanH	<primitive: 'primitiveTanH' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self primitiveFailed! !!Float methodsFor: 'mathematical functions' stamp: 'ar 12/13/2010 23:59' prior: 20898716!timesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 'primitiveTimesTwoPower' module: 'FloatMathPlugin'>	self isNaN ifTrue:[SignalNaN ifTrue:[NaNError signal]. ^self].	^self primitiveTimesTwoPower: anInteger! !!Number methodsFor: 'mathematical functions' stamp: 'ar 3/26/2006 17:23'!hypot: arg	"hypot(x,y) returns sqrt(x^2+y^2) with error less  than 1 ulps"	^self asFloat hypot: arg asFloat! !!Metaclass methodsFor: 'copying' stamp: 'nice 12/29/2010 10:21'!postCopy	"Don't share the reference to the sole instance."	super postCopy.	thisClass := nil.! !!Behavior methodsFor: 'copying' stamp: 'nice 12/29/2010 10:35'!postCopy	super postCopy.	self methodDict: self methodDict copy! !Behavior removeSelector: #copy!Metaclass removeSelector: #copy!ClassDescription removeSelector: #isMeta!"Kernel"!!NaNError commentStamp: 'ar 12/14/2010 00:03' prior: 0!NaNError is signaled by various operations that would either result in or operate on an NaN input.!!NaNError methodsFor: 'testing' stamp: 'ar 12/13/2010 23:36'!isResumable	"NaNError is always resumable"	^true! !!NaNError methodsFor: 'accessing' stamp: 'ar 12/13/2010 23:38'!messageText	"Return an exception's message text."	^messageText ifNil:['This operation would result in NaN ']! !"Exceptions"!!StandardFileStream methodsFor: 'printing' stamp: 'mtf 12/27/2010 15:55'!<< aCollection	aCollection putOn: self! !"Files"!!Color commentStamp: '<historical>' prior: 59245471!This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:	r	amount of red, a Float between 0.0 and 1.0.	g	amount of green, a Float between 0.0 and 1.0.	b	amount of blue, a Float between 0.0 and 1.0.(But, in fact, the three are encoded as values from 0 to 1023 and combined in a single integer, rgb.  The user does not need to know this.)	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.	Here are some fun things to run in when your screen has color:		Pen new mandala: 30 diameter: Display height-100.		Pen new web  "Draw with the mouse, opt-click to end"		Display fillWhite.  Pen new hilberts: 5.		Form toothpaste: 30  "Draw with mouse, opt-click to end"You might also want to try the comment in	Form>class>examples>tinyText...Messages:	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.	+ 	add two colors	- 	subtract two colors	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.	/	divide a color by a factor or an array of three factors.	errorForDepth: d     How close the nearest color at this depth is to this abstract color.  Sum of the squares of the RGB differences, square rooted and normalized to 1.0.  Multiply by 100 to get percent.	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.	saturation	Returns the saturation of the color.  0.0 to 1.0	brightness	Returns the brightness of the color.  0.0 to 1.0	name    Look to see if this Color has a name.	display	Show a swatch of this color tracking the cursor.	lightShades: thisMany		An array of thisMany colors from white to the receiver. 	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. Messages to Class Color.	red: r green: g blue: b		Return a color with the given r, g, and b components.	r: g: b:		Same as above, for fast typing. 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.	pink 	blue	red ...	Many colors have messages that return an instance of Color.	canUnderstand: #brown	  Returns true if #brown is a defined color.	names		An OrderedCollection of the names of the colors.	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array.    colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.(See also comments in these classes: Form, Bitmap, BitBlt, Pattern, MaskedForm.)!!DisplayScreen methodsFor: 'private' stamp: 'jrd 5/23/2009 00:53' prior: 19812362!findAnyDisplayDepth	"Return any display depth that is supported on this system."	^self findAnyDisplayDepthIfNone:[		"Ugh .... now this is a biggie - a system that does not support		any of the Squeak display depths at all."		Smalltalk			logSqueakError:'Fatal error: This system has no support for any display depth at all.'			inContext: thisContext .		Smalltalk quitPrimitive. "There is no way to continue from here"	].! !!Rectangle methodsFor: 'truncation and round off' stamp: 'fbs 12/17/2010 07:24' prior: 27571632!rounded	"Answer a Rectangle whose origin and corner are rounded."	^Rectangle origin: origin rounded extent: self extent rounded! !!WarpBlt methodsFor: 'setup' stamp: 'mtf 8/14/2009 18:21' prior: 53116159!cellSize: s	"Set the number of samples used for averaging"	cellSize := s.	cellSize = 1 ifTrue: [^ self].	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the	destination depth. Note that we need to install the 32->32 color map explicitly because	the VM will substitute a colorMap derived from sourceForm->destForm mapping which	is just plain wrong for <32 source and 32bit dest depth"	(destForm depth = 32 and: [sourceForm notNil] and: [sourceForm depth < 32])		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]		ifFalse:[colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth].! !!StrikeFont methodsFor: 'accessing' stamp: 'bf 2/26/2007 12:39' prior: 30001040!derivativeFonts	derivativeFonts ifNil: [^#()].	^derivativeFonts copyWithout: nil! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 12/8/2002 02:20'!invertPoint: aPoint	^self globalPointToLocal: aPoint! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 12/8/2002 02:20'!invertRect: aRectangle	^self globalBoundsToLocal: aRectangle! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 12/8/2002 02:20'!transformRect: aRectangle	^self localBoundsToGlobal: aRectangle! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 12/8/2002 02:20'!transformedBy: aTransform	^self composedWithGlobal: aTransform! !!BMPReadWriter methodsFor: 'writing' stamp: 'ar 12/21/2010 20:03' prior: 53311263!nextPutImage: aForm	| bhSize rowBytes rgb data colorValues depth image ppw scanLineLen pixline |	depth := aForm depth.	depth := #(1 4 8 32 ) detect: [ :each | each >= depth].	image := aForm asFormOfDepth: depth.	image unhibernate.	bhSize := 14.  "# bytes in file header"	biSize := 40.  "info header size in bytes"	biWidth := image width.	biHeight := image height.	biClrUsed := depth = 32 ifTrue: [0] ifFalse:[1 << depth].  "No. color table entries"	bfOffBits := biSize + bhSize + (4*biClrUsed).	rowBytes := ((depth min: 24) * biWidth + 31 // 32) * 4.	biSizeImage := biHeight * rowBytes.	"Write the file header"	stream position: 0.	stream nextLittleEndianNumber: 2 put: 19778.  "bfType = BM"	stream nextLittleEndianNumber: 4 put: bfOffBits + biSizeImage.  "Entire file size in bytes"	stream nextLittleEndianNumber: 4 put: 0.  "bfReserved"	stream nextLittleEndianNumber: 4 put: bfOffBits.  "Offset of bitmap data from start of hdr (and file)"	"Write the bitmap info header"	stream position: bhSize.	stream nextLittleEndianNumber: 4 put: biSize.  "info header size in bytes"	stream nextLittleEndianNumber: 4 put: image width.  "biWidth"	stream nextLittleEndianNumber: 4 put: image height.  "biHeight"	stream nextLittleEndianNumber: 2 put: 1.  "biPlanes"	stream nextLittleEndianNumber: 2 put: (depth min: 24).  "biBitCount"	stream nextLittleEndianNumber: 4 put: 0.  "biCompression"	stream nextLittleEndianNumber: 4 put: biSizeImage.  "size of image section in bytes"	stream nextLittleEndianNumber: 4 put: 2800.  "biXPelsPerMeter"	stream nextLittleEndianNumber: 4 put: 2800.  "biYPelsPerMeter"	stream nextLittleEndianNumber: 4 put: biClrUsed.	stream nextLittleEndianNumber: 4 put: 0.  "biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues := image colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb := colorValues at: i.			0 to: 24 by: 8 do: [:j | stream nextPut: (rgb >> j bitAnd: 16rFF)]]].	depth < 32 ifTrue: [		"depth = 1, 4 or 8."		data := image bits asByteArray.		ppw := 32 // depth.		scanLineLen := biWidth + ppw - 1 // ppw * 4.  "# of bytes in line"		1 to: biHeight do: [:i |			stream next: scanLineLen putAll: data startingAt: (biHeight-i)*scanLineLen+1.		].	] ifFalse: [		data := image bits.		pixline := ByteArray new: (((biWidth * 3 + 3) // 4) * 4).		1 to: biHeight do:[:i |			self store24BitBmpLine: pixline from: data startingAt: (biHeight-i)*biWidth+1 width: biWidth.			stream nextPutAll: pixline.		].	].	stream position = (bfOffBits + biSizeImage) ifFalse: [self error:'Write failure'].	stream close.! !!BMPReadWriter methodsFor: 'reading' stamp: 'ar 12/21/2010 20:11' prior: 50335663!read24BmpLine: pixelLine into: formBits startingAt: formBitsIndex width: width	"Swizzles the bytes in a 24bpp scanline and fills in the given 32bpp form bits.	Ensures that color black is represented as 16rFF000001 so that Form paint	works properly."	| pixIndex rgb bitsIndex |	<primitive: 'primitiveRead24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := 			(pixelLine at: (pixIndex := pixIndex+1)) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 8) +			((pixelLine at: (pixIndex := pixIndex+1)) bitShift: 16).		rgb = 0 ifTrue:[rgb := 16rFF000001] ifFalse:[rgb := rgb + 16rFF000000].		formBits at: (bitsIndex := bitsIndex+1) put: rgb.	].! !!BMPReadWriter methodsFor: 'writing' stamp: 'ar 12/21/2010 20:12'!store24BitBmpLine: pixelLine from: formBits startingAt: formBitsIndex width: width	"Stores a single scanline containing 32bpp RGBA values in a 24bpp scanline.	Swizzles the bytes as needed."	| pixIndex rgb bitsIndex |	<primitive: 'primitiveWrite24BmpLine' module:'BMPReadWriterPlugin'>	pixIndex := 0. "pre-increment"	bitsIndex := formBitsIndex-1. "pre-increment"	1 to: width do: [:j |		rgb := (formBits at: (bitsIndex := bitsIndex+1)) bitAnd: 16rFFFFFF.		pixelLine at: (pixIndex := pixIndex+1) put: (rgb bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -8) bitAnd: 255).		pixelLine at: (pixIndex := pixIndex+1) put: ((rgb bitShift: -16) bitAnd: 255).	].! !!Point class methodsFor: 'instance creation' stamp: 'jrd 5/26/2010 12:31'!u: xInteger v: yInteger 	"Answer an instance of me with coordinates xInteger and yInteger."	^self new setX: xInteger setY: yInteger! !!Point methodsFor: 'accessing' stamp: 'jrd 5/26/2010 12:32'!u	^x! !!Point methodsFor: 'accessing' stamp: 'jrd 5/26/2010 12:32'!v	^y! !!Color class methodsFor: 'class initialization' stamp: 'mtf 12/28/2010 23:45' prior: 35155317!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames := Set new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TranslucentColor new alpha: 0.0).	self named: #paleBuff put: (Color r: 254 g: 250 b: 235 range: 255).	self named: #paleBlue put: (Color r: 222 g: 249 b: 254 range: 255).	self named: #paleYellow put: (Color r: 255 g: 255 b: 217 range: 255).	self named: #paleGreen put: (Color r: 223 g: 255 b: 213 range: 255).	self named: #paleRed put: (Color r: 255 g: 230 b: 230 range: 255).	self named: #veryPaleRed put: (Color r: 255 g: 242 b: 242 range: 255).	self named: #paleTan put: (Color r: 235 g: 224 b: 199 range: 255).	self named: #paleMagenta put: (Color r: 255 g: 230 b: 255 range: 255).	self named: #paleOrange put: (Color r: 253 g: 237 b: 215 range: 255).	self named: #palePeach put: (Color r: 255 g: 237 b: 213 range: 255).	self named: #pantonePurpleU put: (Color r: 193 g: 81 b: 184 range: 255).! !!Color class methodsFor: 'named colors' stamp: 'jrd 10/16/2010 19:59'!pantonePurpleU	^PantonePurpleU! !!Color methodsFor: 'conversions' stamp: 'nice 12/14/2010 14:55' prior: 50679863!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack := 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val := (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits set to all ones (opaque alpha)"		val := LargePositiveInteger new: 4.		val at: 3 put: ((rgb bitShift: -22) bitAnd: 16rFF).		val at: 2 put: ((rgb bitShift: -12) bitAnd: 16rFF).		val at: 1 put: ((rgb bitShift: -2) bitAnd: 16rFF).		val normalize = 0 ifTrue: [val at: 1 put: 1].  "closest non-transparent black"		val at: 4 put: 16rFF.  "opaque alpha"		^ val normalize].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val := (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val := (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'transformations' stamp: 'bgf 7/22/2006 00:37' prior: 18892656!twiceDarker	"Answer a significantly darker shade of this color."	^ self adjustSaturation: 0.075 brightness: -0.15! !"Graphics"!!BMPReadWriterTest methodsFor: 'reading' stamp: 'ar 12/21/2010 19:50' prior: 17158005!testBmp24Bit	| reader form |	reader := BMPReadWriter new on: (ReadStream on: self bmpData24bit).	form := reader nextImage.	self assert: (form colorAt: 7@1) = Color red.	self assert: (form colorAt: 1@7) = Color green.	self assert: (form colorAt: 7@7) = Color blue.	self assert: (form colorAt: 4@4) = Color white.	self assert: (form pixelValueAt: 1@1) = 16rFF000001.! !!RectangleTest methodsFor: 'tests' stamp: 'fbs 12/17/2010 09:22'!testRoundingAfterHalfPixelTranslationFirstQuadrant	"A rectangle right on the cusp of rounding changes shape if origin and	corner are in differenct quadrants"	"self debug: #testRoundingAfterHalfPixelTranslation"	| a b |	a := 10 asPoint rect: 10 asPoint.	b := a translateBy: 15.		10 timesRepeat: [a := (a translateBy: 0.5) rounded].	10 timesRepeat: [b := (b translateBy: 0.5) rounded].		self assert: a extent = b extent! !"GraphicsTests"!!FloatTest methodsFor: 'test - mathematical functions' stamp: 'ar 12/26/2010 08:02' prior: 34711813!testDegreeCosForExceptionalValues	| signaling |	signaling := Float signalNaN.	[Float signalNaN: false.	self assert: Float nan degreeCos isNaN.	self assert: Float infinity degreeCos isNaN.	self assert: Float infinity negated degreeCos isNaN.	] ensure:[Float signalNaN: signaling].! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'ar 12/26/2010 08:05' prior: 34712917!testDegreeSinForExceptionalValues	| signaling |	signaling := Float signalNaN.	[Float signalNaN: false.	self assert: Float nan degreeSin isNaN.	self assert: Float infinity degreeSin isNaN.	self assert: Float infinity negated degreeSin isNaN.	] ensure:[Float signalNaN: signaling].! !!FloatTest methodsFor: 'NaN behavior' stamp: 'ar 12/14/2010 00:06'!testNonSignalingNaN	"Ensure that NaNs signal when signaling NaNs are enabled"	| setting nan |	setting := Float signalNaN.	nan := Float nan.	[Float signalNaN: false.		self shouldnt:[self assert: nan arcCos isNaN] raise: NaNError.	self shouldnt:[self assert: nan arcCosH isNaN] raise: NaNError.	self shouldnt:[self assert: nan arcSin isNaN] raise: NaNError.	self shouldnt:[self assert: nan arcSinH isNaN] raise: NaNError.	self shouldnt:[self assert: nan arcTan isNaN] raise: NaNError.	self shouldnt:[self assert: (nan arcTan: 1.0) isNaN] raise: NaNError.	self shouldnt:[self assert: (1.0 arcTan: nan) isNaN] raise: NaNError.	self shouldnt:[self assert: (nan arcTan: nan) isNaN] raise: NaNError.	self shouldnt:[self assert: nan arcTanH isNaN] raise: NaNError.	self shouldnt:[self assert: nan cos isNaN] raise: NaNError.	self shouldnt:[self assert: nan cosH isNaN] raise: NaNError.	self shouldnt:[self assert: nan exp isNaN] raise: NaNError.	self shouldnt:[self assert: (nan hypot: 1.0) isNaN] raise: NaNError.	self shouldnt:[self assert: (1.0 hypot: nan) isNaN] raise: NaNError.	self shouldnt:[self assert: (nan hypot: nan) isNaN] raise: NaNError.	self shouldnt:[self assert: nan ln isNaN] raise: NaNError.	self shouldnt:[self assert: nan log isNaN] raise: NaNError.	self shouldnt:[self assert: nan sin isNaN] raise: NaNError.	self shouldnt:[self assert: nan sinH isNaN] raise: NaNError.	self shouldnt:[self assert: nan tan isNaN] raise: NaNError.	self shouldnt:[self assert: nan tanH isNaN] raise: NaNError.	self shouldnt:[self assert: (nan timesTwoPower: 2) isNaN] raise: NaNError.	] ensure:[Float signalNaN: setting].! !!FloatTest methodsFor: 'NaN behavior' stamp: 'ar 12/14/2010 00:00'!testSignalingNaN	"Ensure that NaNs signal when signaling NaNs are enabled"	| setting nan |	setting := Float signalNaN.	nan := Float nan.	[Float signalNaN: true.		self should:[nan arcCos] raise: NaNError.	self should:[nan arcCosH] raise: NaNError.	self should:[nan arcSin] raise: NaNError.	self should:[nan arcSinH] raise: NaNError.	self should:[nan arcTan] raise: NaNError.	self should:[nan arcTan: 1.0] raise: NaNError.	self should:[1.0 arcTan: nan] raise: NaNError.	self should:[nan arcTan: nan] raise: NaNError.	self should:[nan arcTanH] raise: NaNError.	self should:[nan cos] raise: NaNError.	self should:[nan cosH] raise: NaNError.	self should:[nan exp] raise: NaNError.	self should:[nan hypot: 1.0] raise: NaNError.	self should:[1.0 hypot: nan] raise: NaNError.	self should:[nan hypot: nan] raise: NaNError.	self should:[nan ln] raise: NaNError.	self should:[nan log] raise: NaNError.	self should:[nan sin] raise: NaNError.	self should:[nan sinH] raise: NaNError.	self should:[nan tan] raise: NaNError.	self should:[nan tanH] raise: NaNError.	self should:[nan timesTwoPower: 2] raise: NaNError.	] ensure:[Float signalNaN: setting].! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:09'!copysign: x from: y	"Answer a float with the magnitude of x and the sign of y"	| copy word1 |	copy := x clone.	word1 := ((x basicAt: 1) bitAnd: 16r7FFFFFFF) bitOr: ((y asFloat basicAt: 1) bitAnd: 16r80000000).	copy basicAt: 1 put: word1.	^copy! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:16'!fillVector: vector	"Fill a given vector with the currently used random. Make sure we don't create NaNs etc."	| bytes float |	bytes := ByteArray new: 4.	float := FloatArray new: 1.	1 to: vector basicSize do:[:index|		[1 to: 4 do:[:k| bytes at: k put: (random nextInt: 256)-1].		float basicAt: 1 put: (bytes unsignedLongAt: 1 bigEndian: true).		(float at: 1) isNaN] whileTrue.		vector basicAt: index put: (float basicAt: 1).	].	^vector! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:09'!floatTest: aBlock	| bytes out float result hash |	random := Random seed: 253213.	bytes := ByteArray new: 8.	out := WriteStream on: ByteArray new.	float := Float basicNew: 2.	1 to: 10000 do:[:i|		[1 to: 8 do:[:j| bytes at: j put: (random nextInt: 256)-1].		float basicAt: 1 put: (bytes unsignedLongAt: 1 bigEndian: true).		float basicAt: 2 put: (bytes unsignedLongAt: 5 bigEndian: true).		float isNaN] whileTrue.		result := [aBlock value: float] on: Error do:[:ex|			"we convert all errors into NaNs to have a value for testing"			ex return: Float nan.		].		out nextNumber: 4 put: (result basicAt: 1).		out nextNumber: 4 put: (result basicAt: 2).	].	hash := self md5HashMessage: out contents.	result := LargePositiveInteger new: 16.	result replaceFrom: 1 to: 16 with: hash startingAt: 1.	^result normalize! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:16'!hashStream: out	| hash result |	hash := self md5HashMessage: out contents.	result := LargePositiveInteger new: 16.	result replaceFrom: 1 to: 16 with: hash startingAt: 1.	^result normalize! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:16'!hashStreamFrom: aBlock	| out |	out := WriteStream on: (ByteArray new: 80000).	aBlock value: out.	^self hashStream: out! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:16'!md5Digest: aStringOrByteArray	"This creates a little endian hex string to be used with various auth methods	This is the same as htdigest (apache) uses for its md5 digest auth db"	^(self md5HashStream: (ReadStream on: aStringOrByteArray asByteArray)) reversed hex! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:12'!md5Hash: arg	| hash large |	hash := self md5HashMessage: arg.	large := LargePositiveInteger new: 16.	large replaceFrom: 1 to: 16 with: hash startingAt: 1.	^large normalize! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:17'!md5HashMessage: aStringOrByteArray	"TCryptoRandom md5HashMessage: 'foo'"	^ self md5HashStream: (ReadStream on: aStringOrByteArray asByteArray)! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:16'!md5HashStream: aStream	"self md5HashStream: (ReadStream on: 'foo')"	| start buffer bytes sz n words hash |	hash := WordArray 		with: 16r67452301 		with: 16rEFCDAB89 		with: 16r98BADCFE 		with: 16r10325476.	words := WordArray new: 16.	buffer := ByteArray new: 64.	start := aStream position.	[aStream atEnd] whileFalse: [		bytes := aStream nextInto: buffer.		(bytes size < 64 or:[aStream atEnd]) ifTrue:[			sz := bytes size.			buffer replaceFrom: 1 to: sz with: bytes startingAt: 1.			buffer from: sz+1 to: buffer size put: 0.			sz < 56 ifTrue:[				buffer at: sz + 1 put: 128. "trailing bit"			] ifFalse:[				"not enough room for the length, so just pad this one, then..."				sz < 64 ifTrue:[buffer at: sz + 1 put: 128].				1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].				self md5Transform: words hash: hash.				"process one additional block of padding ending with the length"				buffer atAllPut: 0.				sz = 64 ifTrue: [buffer at: 1 put: 128].			].			"Fill in the final 8 bytes with the 64-bit length in bits."			n := (aStream position - start) * 8.			7 to: 0 by: -1 do:[:i| buffer at: (buffer size - i) put: ((n bitShift: 7 - i * -8) bitAnd: 255)].		].		1 to: 16 do:[:i| words at: i put: (buffer unsignedLongAt: i*4-3 bigEndian: false)].		self md5Transform: words hash: hash.	].	bytes := ByteArray new: 16.	bytes unsignedLongAt: 1 put: (hash at: 4) bigEndian: true.	bytes unsignedLongAt: 5 put: (hash at: 3) bigEndian: true.	bytes unsignedLongAt: 9 put: (hash at: 2) bigEndian: true.	bytes unsignedLongAt: 13 put: (hash at: 1) bigEndian: true.	^bytes! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:16'!md5Transform: in hash: hash	"This adds the incoming words to the existing hash"	| a b c d |	<primitive: 'primitiveMD5Transform' module: 'CroquetPlugin'>	a := hash at: 1.	b := hash at: 2.	c := hash at: 3.	d := hash at: 4.	a := self step1: a x: b y: c z: d data: (in at:  1) add: 16rD76AA478 shift: 7.	d := self step1: d x: a y: b z: c data: (in at:  2) add: 16rE8C7B756 shift: 12.	c := self step1: c x: d y: a z: b data: (in at:  3) add: 16r242070DB shift: 17.	b := self step1: b x: c y: d z: a data: (in at:  4) add: 16rC1BDCEEE shift: 22.	a := self step1: a x: b y: c z: d data: (in at:  5) add: 16rF57C0FAF shift:  7.	d := self step1: d x: a y: b z: c data: (in at:  6) add: 16r4787C62A shift: 12.	c := self step1: c x: d y: a z: b data: (in at:  7) add: 16rA8304613 shift: 17.	b := self step1: b x: c y: d z: a data: (in at:  8) add: 16rFD469501 shift: 22.	a := self step1: a x: b y: c z: d data: (in at:  9) add: 16r698098D8 shift:  7.	d := self step1: d x: a y: b z: c data: (in at: 10) add: 16r8B44F7AF shift: 12.	c := self step1: c x: d y: a z: b data: (in at: 11) add: 16rFFFF5BB1 shift: 17.	b := self step1: b x: c y: d z: a data: (in at: 12) add: 16r895CD7BE shift: 22.	a := self step1: a x: b y: c z: d data: (in at: 13) add: 16r6B901122 shift:  7.	d := self step1: d x: a y: b z: c data: (in at: 14) add: 16rFD987193 shift: 12.	c := self step1: c x: d y: a z: b data: (in at: 15) add: 16rA679438E shift: 17.	b := self step1: b x: c y: d z: a data: (in at: 16) add: 16r49B40821 shift: 22.	a := self step2: a x: b y: c z: d data: (in at:  2) add: 16rF61E2562 shift:  5.	d := self step2: d x: a y: b z: c data: (in at:  7) add: 16rC040B340 shift:  9.	c := self step2: c x: d y: a z: b data: (in at: 12) add: 16r265E5A51 shift: 14.	b := self step2: b x: c y: d z: a data: (in at:  1) add: 16rE9B6C7AA shift: 20.	a := self step2: a x: b y: c z: d data: (in at:  6) add: 16rD62F105D shift:  5.	d := self step2: d x: a y: b z: c data: (in at: 11) add: 16r02441453 shift:  9.	c := self step2: c x: d y: a z: b data: (in at: 16) add: 16rD8A1E681 shift: 14.	b := self step2: b x: c y: d z: a data: (in at:  5) add: 16rE7D3FBC8 shift: 20.	a := self step2: a x: b y: c z: d data: (in at: 10) add: 16r21E1CDE6 shift:  5.	d := self step2: d x: a y: b z: c data: (in at: 15) add: 16rC33707D6 shift:  9.	c := self step2: c x: d y: a z: b data: (in at:  4) add: 16rF4D50D87 shift: 14.	b := self step2: b x: c y: d z: a data: (in at:  9) add: 16r455A14ED shift: 20.	a := self step2: a x: b y: c z: d data: (in at: 14) add: 16rA9E3E905 shift:  5.	d := self step2: d x: a y: b z: c data: (in at:  3) add: 16rFCEFA3F8 shift:  9.	c := self step2: c x: d y: a z: b data: (in at:  8) add: 16r676F02D9 shift: 14.	b := self step2: b x: c y: d z: a data: (in at: 13) add: 16r8D2A4C8A shift: 20.	a := self step3: a x: b y: c z: d data: (in at:  6) add: 16rFFFA3942 shift:  4.	d := self step3: d x: a y: b z: c data: (in at:  9) add: 16r8771F681 shift: 11.	c := self step3: c x: d y: a z: b data: (in at: 12) add: 16r6D9D6122 shift: 16.	b := self step3: b x: c y: d z: a data: (in at: 15) add: 16rFDE5380C shift: 23.	a := self step3: a x: b y: c z: d data: (in at:  2) add: 16rA4BEEA44 shift:  4.	d := self step3: d x: a y: b z: c data: (in at:  5) add: 16r4BDECFA9 shift: 11.	c := self step3: c x: d y: a z: b data: (in at:  8) add: 16rF6BB4B60 shift: 16.	b := self step3: b x: c y: d z: a data: (in at: 11) add: 16rBEBFBC70 shift: 23.	a := self step3: a x: b y: c z: d data: (in at: 14) add: 16r289B7EC6 shift:  4.	d := self step3: d x: a y: b z: c data: (in at:  1) add: 16rEAA127FA shift: 11.	c := self step3: c x: d y: a z: b data: (in at:  4) add: 16rD4EF3085 shift: 16.	b := self step3: b x: c y: d z: a data: (in at:  7) add: 16r04881D05 shift: 23.	a := self step3: a x: b y: c z: d data: (in at: 10) add: 16rD9D4D039 shift:  4.	d := self step3: d x: a y: b z: c data: (in at: 13) add: 16rE6DB99E5 shift: 11.	c := self step3: c x: d y: a z: b data: (in at: 16) add: 16r1FA27CF8 shift: 16.	b := self step3: b x: c y: d z: a data: (in at:  3) add: 16rC4AC5665 shift: 23.	a := self step4: a x: b y: c z: d data: (in at:  1) add: 16rF4292244 shift:  6.	d := self step4: d x: a y: b z: c data: (in at:  8) add: 16r432AFF97 shift: 10.	c := self step4: c x: d y: a z: b data: (in at: 15) add: 16rAB9423A7 shift: 15.	b := self step4: b x: c y: d z: a data: (in at:  6) add: 16rFC93A039 shift: 21.	a := self step4: a x: b y: c z: d data: (in at: 13) add: 16r655B59C3 shift:  6.	d := self step4: d x: a y: b z: c data: (in at:  4) add: 16r8F0CCC92 shift: 10.	c := self step4: c x: d y: a z: b data: (in at: 11) add: 16rFFEFF47D shift: 15.	b := self step4: b x: c y: d z: a data: (in at:  2) add: 16r85845DD1 shift: 21.	a := self step4: a x: b y: c z: d data: (in at:  9) add: 16r6FA87E4F shift:  6.	d := self step4: d x: a y: b z: c data: (in at: 16) add: 16rFE2CE6E0 shift: 10.	c := self step4: c x: d y: a z: b data: (in at:  7) add: 16rA3014314 shift: 15.	b := self step4: b x: c y: d z: a data: (in at: 14) add: 16r4E0811A1 shift: 21.	a := self step4: a x: b y: c z: d data: (in at:  5) add: 16rF7537E82 shift:  6.	d := self step4: d x: a y: b z: c data: (in at: 12) add: 16rBD3AF235 shift: 10.	c := self step4: c x: d y: a z: b data: (in at:  3) add: 16r2AD7D2BB shift: 15.	b := self step4: b x: c y: d z: a data: (in at: 10) add: 16rEB86D391 shift: 21.	a := (a + (hash at: 1)) bitAnd: 16rFFFFFFFF. hash at: 1 put: a.	b := (b + (hash at: 2)) bitAnd: 16rFFFFFFFF. hash at: 2 put: b.	c := (c + (hash at: 3)) bitAnd: 16rFFFFFFFF. hash at: 3 put: c.	d := (d + (hash at: 4)) bitAnd: 16rFFFFFFFF. hash at: 4 put: d.	^hash! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:18'!processResult: result stream: out	"Process the result of a computation"	| v |	v := result ifNil:[Float nan].	1 to: v basicSize do:[:idx| out nextNumber: 4 put: (v basicAt: idx)].! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:17'!rotate: value by: amount	"Rotate value left by amount"	| lowMask highMask |	lowMask := (1 bitShift: 32-amount) - 1.	highMask := 16rFFFFFFFF - lowMask.	^((value bitAnd: lowMask) bitShift: amount) + 		((value bitAnd: highMask) bitShift: amount-32)! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:17'!step1: w x: x y: y z: z data: data add: add shift: s	"Step 1 in MD5 transformation"	| f result |	f := z bitXor: (x bitAnd: (y bitXor: z)).	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:17'!step2: w x: x y: y z: z data: data add: add shift: s	"Step 2 in MD5 transformation"	| f result |	f := y bitXor: (z bitAnd: (x bitXor: y)).	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:17'!step3: w x: x y: y z: z data: data add: add shift: s	"Step 3 in MD5 transformation"	| f result |	f := (x bitXor: y) bitXor: z.	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:17'!step4: w x: x y: y z: z data: data add: add shift: s	"Step 4 in MD5 transformation"	| f result |	f := y bitXor: (x bitOr: (z  bitXor: 16rFFFFFFFF)).	result := w + f + data + add.	result := self rotate: result by: s.	^result + x bitAnd: 16rFFFFFFFF! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:13'!testAddArray	| hash |	hash := self vectorVectorTest:[:v1 :v2 | v1 primAddArray: v2].	self assert: hash = 144077765882344459641544075160959206703! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:13'!testAddScalar	| hash |	hash := self vectorScalarTest:[:v1 :s2 | v1 primAddScalar: s2].	self assert: hash = 126267177490805695389975970148750710209! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:09'!testArcCos	| hash |	hash := self floatTest:[:f| f arcCos].	self assert: hash = 320603091210691421897131240956682310429! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:09'!testArcCosH	| hash |	hash := self floatTest:[:f| f arcCosH].	self assert: hash = 6724426144112251941037505276242428134! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:09'!testArcCosHStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				nil.					nil	}.		{	1.0.				'0000000000000000'.	nil	}.		{	2.0.				'3FF5124271980434'.	nil	}.		{	Float infinity.	'7FF0000000000000'.	nil	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA arcCosH hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB arcCosH hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:09'!testArcCosStd	| inputA resultA inputB resultB |	{	"test input value"		"test result plus"		"test result minus"		{	0.0.				'3FF921FB54442D18'.	'3FF921FB54442D18'	}.		{	1.0.				'0000000000000000'.	'400921FB54442D18'	}.		{	2.0.				nil.					nil	}.		{	Float infinity.	nil.					nil	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA arcCos hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB arcCos hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:09'!testArcSin	| hash |	hash := self floatTest:[:f| f arcSin].	self assert: hash = 27372132577303862731837100895783885417! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:09'!testArcSinH	| hash |	hash := self floatTest:[:f| f arcSinH].	self assert: hash = 255911863578190171815115260235896145802! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:09'!testArcSinHStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'3FEC34366179D427'.	'BFEC34366179D427'	}.		{	2.0.				'3FF719218313D087'.	'BFF719218313D087'	}.		{	Float infinity.	'7FF0000000000000'.	'FFF0000000000000'	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA arcSinH hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB arcSinH hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testArcSinStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'3FF921FB54442D18'.	'BFF921FB54442D18'	}.		{	2.0.				nil.					nil	}.		{	Float infinity.	nil.					nil	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA arcSin hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB arcSin hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testArcTan	| hash |	hash := self floatTest:[:f| f arcTan].	self assert: hash = 17311773710959114634056077345168823659! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testArcTan2	| hash |	hash := self floatTest:[:f| f arcTan: f].	self assert: hash = 287068347279655848752274030373495709564! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testArcTanH	| hash |	hash := self floatTest:[:f| f arcTanH].	self assert: hash = 295711907369004359459882231908879164929! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testArcTanHStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'7FF0000000000000'.	'FFF0000000000000'	}.		{	2.0.				nil.					nil	}.		{	Float infinity.	nil.					nil	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA arcTanH hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB arcTanH hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testArcTanStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'3FE921FB54442D18'.	'BFE921FB54442D18'	}.		{	2.0.				'3FF1B6E192EBBE44'.	'BFF1B6E192EBBE44'	}.		{	Float infinity.	'3FF921FB54442D18'.	'BFF921FB54442D18'	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA arcTan hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB arcTan hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testCos	| hash |	hash := self floatTest:[:f| f cos].	self assert: hash = 110207739557966732640546618158077332978! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testCosH	| hash |	hash := self floatTest:[:f| f cosH].	self assert: hash = 139309299067563830037108641802292492276! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testCosHStd	| inputA resultA inputB resultB |	{	"test input value"		"test result plus"		"test result minus"		{	0.0.				'3FF0000000000000'.	'3FF0000000000000'	}.		{	1.0.				'3FF8B07551D9F551'.	'3FF8B07551D9F551'	}.		{	2.0.				'400E18FA0DF2D9BC'.	'400E18FA0DF2D9BC'	}.		{	Float infinity.	'7FF0000000000000'.	'7FF0000000000000'	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA cosH hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB cosH hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testCosStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				'3FF0000000000000'.	'3FF0000000000000'	}.		{	1.0.				'3FE14A280FB5068C'.	'3FE14A280FB5068C'	}.		{	2.0.				'BFDAA22657537205'.	'BFDAA22657537205'	}.		{	Float infinity.	nil.					nil	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA cos hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB cos hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:13'!testDivArray	| hash |	hash := self vectorVectorTest:[:v1 :v2 | v1 primDivArray: v2].	self assert: hash = 80910096946457615204728914361076966320! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:13'!testDivScalar	| hash |	hash := self vectorScalarTest:[:v1 :s2 | v1 primDivScalar: s2].	self assert: hash = 570414977257248905680389076010819095! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:13'!testDot	| hash |	hash := self vectorVectorTest:[:v1 :v2| v1 dot: v2].	self assert: hash = 150216110228183805275896904027737941670.! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testExp	| hash |	hash := self floatTest:[:f| f exp].	self assert: hash = 264681209343177480335132131244505189510! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testExpStd	| inputA resultA inputB resultB |	{	"test input value"		"test result plus"		"test result minus"		{	0.0.				'3FF0000000000000'.	'3FF0000000000000'	}.		{	1.0.				'4005BF0A8B14576A'.	'3FD78B56362CEF38'	}.		{	2.0.				'401D8E64B8D4DDAE'.	'3FC152AAA3BF81CC'	}.		{	Float infinity.	'7FF0000000000000'.	'0000000000000000'	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA exp hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB exp hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testFloatAt	| hash flt |	flt := FloatArray new: 1.	hash := self floatTest:[:f| flt at: 1 put: f. flt at: 1].	self assert: hash = 80498428122197125691266588764018905399! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testFraction	| hash |	hash := self floatTest:[:f| f fractionPart].	self assert: hash = 320444785026869345695277323179170692004! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testFractionStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'0000000000000000'.	'8000000000000000'	}.		{	2.0.				'0000000000000000'.	'8000000000000000'	}.		{	Float infinity.	'0000000000000000'.	'8000000000000000'	}.		{	Float nan.		'0000000000000000'.	'8000000000000000'	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA fractionPart hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB fractionPart hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:10'!testHypot	| hash |	hash := self floatTest:[:f| f hypot: f+1].	self assert: hash = 217113721886532765853628735806816720346! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:14'!testLength	| hash |	hash := self vectorTest:[:v1 | v1 length].	self assert: hash = 207819694258655476491684678225238920813.! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testLog	| hash |	hash := self floatTest:[:f| f abs ln].	self assert: hash = 24389651894375564945708989023746058645! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testLog10	| hash |	hash := self floatTest:[:f| f abs log].	self assert: hash = 135564553959509933253581837789050718785! !!FloatConsistencyTests methodsFor: 'md5' stamp: 'ar 12/14/2010 08:12'!testMD5	"Ensure that MD5 primitive works properly"	self assert: (self md5Hash: 'a') = 16r0CC175B9C0F1B6A831C399E269772661.	self assert: (self md5Hash: 'abc') = 16r900150983CD24FB0D6963F7D28E17F72.	self assert: (self md5Hash: 'message digest') = 16rF96B697D7CB7938D525A2F31AAF161D0.	self assert: (self md5Hash:		'abcdefghijklmnopqrstuvwxyz') = 16rC3FCD3D76192E4007DFB496CCA67E13B.	self assert: (self md5Hash:		'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789') =		16rD174AB98D277D9F5A5611C2C9F419D9F.	self assert: (self md5Hash:		'12345678901234567890123456789012345678901234567890123456789012345678901234567890') = 		16r57EDF4A22BE3C955AC49DA2E2107B67A.! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:14'!testMulArray	| hash |	hash := self vectorVectorTest:[:v1 :v2 | v1 primMulArray: v2].	self assert: hash = 94461360565991184554489439948329954948.! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:14'!testMulScalar	| hash |	hash := self vectorScalarTest:[:v1 :s2 | v1 primMulScalar: s2].	self assert: hash = 96993460842141496093782297636277905186.! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:14'!testNormalize	| hash |	hash := self vectorTest:[:v1 | v1 normalize].	self assert: hash = 65842048927401502845374601234836342571.! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testSin	| hash |	hash := self floatTest:[:f| f sin].	self assert: hash = 290162321010315440569513182938961037473! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testSinH	| hash |	hash := self floatTest:[:f| f sinH].	self assert: hash = 146029709156303766079448006055284064911! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testSinHStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'3FF2CD9FC44EB982'.	'BFF2CD9FC44EB982'	}.		{	2.0.				'400D03CF63B6E1A0'.	'C00D03CF63B6E1A0'	}.		{	Float infinity.	'7FF0000000000000'.	'FFF0000000000000'	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA sinH hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB sinH hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testSinStd	| inputA resultA inputB resultB |	{	"test input value"		"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'3FEAED548F090CEE'.	'BFEAED548F090CEE'	}.		{	2.0.				'3FED18F6EAD1B446'.	'BFED18F6EAD1B446'	}.		{	Float infinity.	nil.					nil	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA sin hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB sin hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testSqrt	| hash |	hash := self floatTest:[:f| f abs sqrt].	self assert: hash = 112236588358122834093969606123302196127! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:14'!testSubArray	| hash |	hash := self vectorVectorTest:[:v1 :v2 | v1 primSubArray: v2].	self assert: hash = 323016603234339452406622037180620109569.! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:14'!testSubScalar	| hash |	hash := self vectorScalarTest:[:v1 :s2 | v1 primSubScalar: s2].	self assert: hash = 21245234269319054796422814018775160740.! !!FloatConsistencyTests methodsFor: 'array tests' stamp: 'ar 12/14/2010 08:14'!testSum	| hash |	hash := self vectorTest:[:v1 | v1 sum].	self assert: hash = 194048354065558535734705735684824571405.! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testTan	| hash |	hash := self floatTest:[:f| f tan].	self assert: hash = 207143885112027702205238433494882679660! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testTanH	| hash |	hash := self floatTest:[:f| f tanH].	self assert: hash = 15738508136206638425252880299326548123! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:11'!testTanHStd	| inputA resultA inputB resultB |	{	"test input value"	"test result plus"		"test result minus""ar 4/19/2006: I have disabled the test for tanh(-0.0) for the time being because it was literally the 'last bit' differing amongst the various VMs before Croquet 1.0 and we were all wiped out by the time we ran into it to the point that I felt that having a different result for tan(-0.0) (-0.0 on some and 0.0 on other platforms with -0.0 being the 'correct' answer) wasn't worth pushing it any further. At some point we'll put it back in (likely before the next release; by then we'll have recovered from this one ;-) and fix it for good.""		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		"		{	1.0.				'3FE85EFAB514F394'.	'BFE85EFAB514F394'	}.		{	2.0.				'3FEED9505E1BC3D4'.	'BFEED9505E1BC3D4'	}.		{	Float infinity.	'3FF0000000000000'.	'BFF0000000000000'	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA tanH hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB tanH hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:12'!testTanStd	| inputA resultA inputB resultB |	{	"test input value"		"test result plus"		"test result minus"		{	0.0.				'0000000000000000'.	'8000000000000000'	}.		{	1.0.				'3FF8EB245CBEE3A6'.	'BFF8EB245CBEE3A6'	}.		{	2.0.				'C0017AF62E0950F8'.	'40017AF62E0950F8'	}.		{	Float infinity.	nil.					nil	}.		{	Float nan.		nil.					nil	}.	} do:[:spec|		inputA := self copysign: spec first from: 1.0.		resultA := [inputA tan hex] on: Error do:[:ex| ex return: nil].		inputB := self copysign: spec first from: -1.0.		resultB := [inputB tan hex] on: Error do:[:ex| ex return: nil].		self assert: spec second = resultA.		self assert: spec third = resultB.	].! !!FloatConsistencyTests methodsFor: 'float tests' stamp: 'ar 12/14/2010 08:12'!testTimesTwoPower	| hash |	hash := self floatTest:[:f| f timesTwoPower: (random nextInt: 200) - 100].	self assert: hash = 278837335583284459890979576373223649870.! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:14'!vectorScalarTest: aBlock	^self hashStreamFrom: [:out| self vectorScalarTest: aBlock on: out]! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:15'!vectorScalarTest: aBlock on: aStream	| arg1 arg2 result |	random := Random seed: 253213.	arg1 := FloatArray new: 3.	arg2 := Float basicNew: 2.	1 to: 10000 do:[:i|		[result := [aBlock value: (self fillVector: arg1)						value: (self fillVector: arg2)] on: Error do:[:ex| ex return: nil].		self processResult: result stream: aStream.		result == nil] whileTrue.	]! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:15'!vectorTest: aBlock	| out arg1 result |	random := Random seed: 253213.	out := WriteStream on: ByteArray new.	arg1 := FloatArray new: 3.	1 to: 10000 do:[:i|		[result := [aBlock value: (self fillVector: arg1)] on: Error do:[:ex| ex return: nil].		self processResult: result stream: out.		result == nil] whileTrue.	].	^self hashStream: out! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:15'!vectorVectorTest: aBlock	^self hashStreamFrom: [:out| self vectorVectorTest: aBlock on: out]! !!FloatConsistencyTests methodsFor: 'misc' stamp: 'ar 12/14/2010 08:16'!vectorVectorTest: aBlock on: aStream	| arg1 arg2 result |	random := Random seed: 253213.	arg1 := FloatArray new: 3.	arg2 := FloatArray new: 3.	1 to: 10000 do:[:i|		[result := [aBlock value: (self fillVector: arg1)						value: (self fillVector: arg2)] on: Error do:[:ex| ex pass].		self processResult: result stream: aStream.		result == nil] whileTrue.	]! !"KernelTests"!!ToolSet class methodsFor: 'debugging' stamp: 'jrd 5/23/2009 00:54' prior: 31813536!debugError: anError	"Handle an otherwise unhandled error"	self default ifNil:[ | ctx |		Smalltalk 			logSqueakError: anError description 			inContext: (ctx := anError signalerContext) .		self inform: (anError description, String cr, ctx shortStack).		^anError return].	^self default debugError: anError! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'mtf 7/1/2009 13:02'!logSqueakError: errMsg inContext: aContext 	"Log the error message and a stack trace to the usual file."	^self logError: errMsg inContext: aContext to: self squeakErrorFileName! !!SmalltalkImage methodsFor: 'image, changes names' stamp: 'mtf 12/16/2010 11:23'!primVmFileName	"Answer the absolute file name of the the Smalltalk virtual machine"	^ self getSystemAttribute: 0! !!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'mtf 12/20/2010 16:23'!squeakErrorFileName	"Answer the file name used to dump error reports"	^ Preferences debugLogTimestamp		ifTrue: ['SqueakDebug-' , Time totalSeconds printString , '.log']		ifFalse: ['SqueakDebug.log'].! !!SmalltalkImage methodsFor: 'command line' stamp: 'mtf 12/16/2010 11:22'!vmFileName	"Answer the absolute file name of the the Smalltalk virtual machine"	"Smalltalk vmFileName"	^ (FilePath pathName: (self primVmFileName) isEncoded: true) asSqueakPathName.! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'nice 12/14/2010 15:10' prior: 50933940!initRandomFromString: aString	"Ask the user to type a long random string and use the result to seed the secure random number generator."	| s k srcIndex |	s := aString.	k := LargePositiveInteger new: (s size min: 64).	srcIndex := 0.	k digitLength to: 1 by: -1 do: [:i |		k digitAt: i put: (s at: (srcIndex := srcIndex + 1)) asciiValue].	k := k normalize + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"	k highBit > 512 ifTrue: [k := k bitShift: k highBit - 512].	self initRandom: k.! !!DigitalSignatureAlgorithm methodsFor: 'initialization' stamp: 'nice 12/14/2010 15:10' prior: 19733109!initRandomFromUser	"Ask the user to type a long random string and use the result to seed the secure random number generator."	| s k srcIndex |	s := UIManager default request: 'Enter a long random string to seed the random generator.'.	k := LargePositiveInteger new: (s size min: 64).	srcIndex := 0.	k digitLength to: 1 by: -1 do: [:i |		k digitAt: i put: (s at: (srcIndex := srcIndex + 1)) asciiValue].	k := k normalize + (Random new next * 16r7FFFFFFF) asInteger.  "a few additional bits randomness"	k highBit > 512 ifTrue: [k := k bitShift: k highBit - 512].	self initRandom: k.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jrd 6/10/2009 12:54'!dumpException: ex	self 		logSqueakError: ex description 		inContext: ex signalerContext .! !"System"!!TheWorldMainDockingBar methodsFor: 'submenu - extras' stamp: 'ar 12/14/2010 07:57' prior: 35063832!extrasMenuOn: aDockingBar 	aDockingBar addItem: [ :it|		it 	contents: 'Extras' translated;			addSubMenu: [:menu|				menu addItem:[:item|					item						contents: 'Recover Changes' translated;						help: 'Recover changes after a crash' translated;						icon: MenuIcons smallHelpIcon;						target: ChangeList;						selector: #browseRecentLog].				menu addLine.				menu addItem:[:item|					item						contents: 'Window Colors' translated;						help: 'Changes the window color scheme' translated;						addSubMenu:[:submenu| self windowColorsOn: submenu]].				menu addItem:[:item|					item						contents: 'Set Author Initials' translated;						help: 'Sets the author initials' translated;						target: Utilities;						selector: #setAuthorInitials].				menu addItem:[:item|					item						contents: 'Restore Display (r)' translated;						help: 'Redraws the entire display' translated;						target: World;						selector: #restoreMorphicDisplay].				menu addItem:[:item|					item						contents: 'Rebuild Menus' translated;						help: 'Rebuilds the menu bar' translated;						target: TheWorldMainDockingBar;						selector: #updateInstances].				menu addItem:[:item|					item						contents: 'Toggle Fullscreen' translated;						help: 'Switches fullscreen mode on and off' translated;						target: Project current;						selector: #toggleFullScreen].				menu addLine.				menu addItem:[:item|					item						contents: 'Start Profiler' translated;						help: 'Starts the profiler' translated;						target: self;						selector: #startMessageTally].				menu addItem:[:item|					item						contents: 'Collect Garbage' translated;						help: 'Run the garbage collector and report space usage' translated;						target: Utilities;						selector: #garbageCollectAndReport].				menu addItem:[:item|					item						contents: 'Purge Undo Records' translated;						help: 'Save space by removing all the undo information remembered in all projects' translated;						target: CommandHistory;						selector: #resetAllHistory].				menu addItem:[:item|					item						contents: 'VM statistics' translated;						help: 'Virtual Machine information' translated;						target: self;						selector: #vmStatistics].				menu addLine.				menu addItem:[:item|					item						contents: 'Graphical Imports' translated;						help: 'View the global repository called ImageImports; you can easily import external graphics into ImageImports via the FileList' translated;						target: (Imports default);						selector: #viewImages].				menu addItem:[:item|					item						contents: 'Standard Graphics Library' translated;						help: 'Lets you view and change the system''s standard library of graphics' translated;						target: ScriptingSystem;						selector: #inspectFormDictionary].				menu addItem:[:item|					item						contents: 'Annotation Setup' translated;						help: 'Click here to get a little window that will allow you to specify which types of annotations, in which order, you wish to see in the annotation panes of browsers and other tools' translated;						target: Preferences;						selector: #editAnnotations].			] ]! !!TextEditor methodsFor: 'events' stamp: 'ar 5/5/2004 19:10'!yellowButtonDown: event	"Process a yellow button event. Answer true if the event was handled, false otherwise."	(paragraph attributesAt: event cursorPoint) do:[:attr|		attr menu ifNotNil:[			attr menu openAt: event cursorPoint.			^true]].	^false! !!WorldState methodsFor: 'update cycle' stamp: 'mtf 12/28/2010 20:41' prior: 54592056!drawWorld: aWorld submorphs: submorphs invalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list. Return a collection of the areas thatwere redrawn."	| rectList n morphs rects validList |	rectList := damageRecorder invalidRectsFullBounds: aWorld viewBox.	"sort by areas to draw largest portions first"	rectList := rectList asArray sort: [:r1 :r2 | r1 area > r2 area].	damageRecorder reset.	n := submorphs size.	morphs := OrderedCollection new: n * 2.	rects := OrderedCollection new: n * 2.	validList := OrderedCollection new: n * 2.	"This is added in case we are drawing to a form that is to be used as a texture, and we want the background to be translucent."	aWorld color isTranslucent ifTrue:		[rectList do: [:r | aCanvas form fill: r fillColor: aWorld color]].	rectList do: 			[:dirtyRect | 			dirtyRect allAreasOutsideList: validList				do: 					[:r | | mm rectToFill remnants c rect i | 					"Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."					rectToFill := r.					i := 1.					[rectToFill isNil or: [i > n]] whileFalse: 							[mm := submorphs at: i.							((mm fullBounds intersects: r) and: [mm visible]) 								ifTrue: 									[morphs addLast: mm.									rects addLast: rectToFill.									remnants := mm areasRemainingToFill: rectToFill.									remnants size = 1 ifTrue: [rectToFill := remnants first].									remnants isEmpty ifTrue: [rectToFill := nil]].							i := i + 1].					"Now paint from bottom to top, but using the reduced rectangles."					rectToFill 						ifNotNil: [aWorld drawOn: (c := aCanvas copyClipRect: rectToFill)].					[morphs isEmpty] whileFalse: 							[(rect := rects removeLast) == rectToFill 								ifFalse: [c := aCanvas copyClipRect: (rectToFill := rect)].							c fullDrawMorph: morphs removeLast].					morphs reset.					rects reset.					validList add: r]].	^validList! !!TextMorphEditor methodsFor: 'events' stamp: 'ar 5/5/2004 19:10'!yellowButtonDown: event	"Process a yellow button event. Answer true if the event was handled, false otherwise."	(paragraph attributesAt: event cursorPoint) do:[:attr|		attr menu ifNotNil:[			attr menu openAt: event cursorPoint.			^true]].	^false! !!HandMorph methodsFor: 'private events' stamp: 'ar 7/12/2006 17:05' prior: 51331949!generateKeyboardEvent: evtBuf	"Generate the appropriate mouse event for the given raw event buffer"	| buttons modifiers type pressType stamp char |	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	pressType := evtBuf fourth.	pressType = EventKeyDown ifTrue: [type := #keyDown].	pressType = EventKeyUp ifTrue: [type := #keyUp].	pressType = EventKeyChar ifTrue: [type := #keystroke].	modifiers := evtBuf fifth.	buttons := (modifiers bitShift: 3) bitOr: (lastMouseEvent buttons bitAnd: 7).	char := self keyboardInterpreter nextCharFrom: Sensor firstEvt: evtBuf.	^ KeyboardEvent new		setType: type		buttons: buttons		position: self position		keyValue: char asciiValue		hand: self		stamp: stamp.! !!HandMorph methodsFor: 'private events' stamp: 'mka 2/21/2009 20:00' prior: 21513969!generateMouseEvent: evtBuf 	"Generate the appropriate mouse event for the given raw event buffer"	| position buttons modifiers type trail stamp oldButtons evtChanged |	evtBuf first = lastEventBuffer first 		ifTrue: 			["Workaround for Mac VM bug, *always* generating 3 events on clicks"			evtChanged := false.			3 to: evtBuf size				do: [:i | (lastEventBuffer at: i) = (evtBuf at: i) ifFalse: [evtChanged := true]].			evtChanged ifFalse: [^nil]].	stamp := evtBuf second.	stamp = 0 ifTrue: [stamp := Time millisecondClockValue].	position := evtBuf third @ evtBuf fourth.	buttons := evtBuf fifth.	modifiers := evtBuf sixth.	type := buttons = 0 		ifTrue:[				lastEventBuffer fifth = 0 							ifTrue: [#mouseMove] 	"this time no button and previously no button .. just mouse move"					ifFalse: [#mouseUp]		"this time no button but previously some button ... therefore button was released"		]		ifFalse:[				buttons = lastEventBuffer fifth						ifTrue: [#mouseMove]		"button states are the same .. now and past .. therfore a mouse movement"						ifFalse: [					"button states are different .. button was pressed or released"							buttons > lastEventBuffer fifth								ifTrue: [#mouseDown]								ifFalse:[#mouseUp].						].		].	buttons := buttons bitOr: (modifiers bitShift: 3).	oldButtons := lastEventBuffer fifth 				bitOr: (lastEventBuffer sixth bitShift: 3).	lastEventBuffer := evtBuf.	type == #mouseMove 		ifTrue: 			[trail := self mouseTrailFrom: evtBuf.			^MouseMoveEvent new 				setType: type				startPoint: (self position)				endPoint: trail last				trail: trail				buttons: buttons				hand: self				stamp: stamp].	^MouseButtonEvent new 		setType: type		position: position		which: (oldButtons bitXor: buttons)		buttons: buttons		hand: self		stamp: stamp! !!NewParagraph methodsFor: 'editing' stamp: 'ar 12/13/2010 23:26'!attributesAt: aPoint	"Answer the attributes at the given point"	^text attributesAt: (self characterBlockAtPoint: aPoint) stringIndex forStyle: textStyle! !"Morphic"!!ReleaseTest methodsFor: 'testing' stamp: 'mtf 12/16/2010 11:36'!testSwapMouseButtonsPreference	"Swap mouse buttons should be enabled"	self assert: Preferences swapMouseButtons! !!Win32VMTest methodsFor: 'tests' stamp: 'mtf 12/16/2010 11:30' prior: 58629382!testWinVM3ButtonMousePreference	"Ensure that 3ButtonMouse preference is enabled, so that the Win32 VM sends mouse clicks the same way other VMs do"	| iniData iniPref exePath |	Smalltalk platformName = 'Win32' ifFalse:[^self].	exePath := Smalltalk vmFileName.	iniData := [		(FileStream readOnlyFileNamed: (exePath copyUpToLast: $.), '.ini')			 contentsOfEntireFile	] on: Error do:[:ex| ex return: ''].	iniPref := false. "default is OFF"	iniData linesDo:[:line|		(line beginsWith: '3ButtonMouse') ifTrue:[			iniPref := (line copyAfter: $=) withBlanksTrimmed ~= '0'.		].	].	self assert: iniPref = true.! !!MCRepositoryTest methodsFor: 'tests' stamp: 'ar 12/16/2010 09:40'!testCreationMethods	"Tests creation via MCRepository>>location:"	| repo |	repo := MCRepository location: 'C:\Squeak\trunk'.	self assert: (repo isKindOf: MCDirectoryRepository).	self assert: (repo description = 'C:\Squeak\trunk').	repo := MCRepository location: FileDirectory default pathName.	self assert: (repo isKindOf: MCDirectoryRepository).	self assert: (repo description = FileDirectory default pathName).	repo := MCRepository location: (FileDirectory default pathName, FileDirectory slash, '*').	self assert: (repo isKindOf: MCSubDirectoryRepository).	"XXXX: MCSubDirectoryRepo prints wrongly on Windows"	self assert: (repo description = (FileDirectory default pathName, '/*')).	repo := MCRepository location: 'http://source.squeak.org/trunk'.	self assert: (repo isKindOf: MCHttpRepository).	self assert: (repo description = 'http://source.squeak.org/trunk').	repo := MCRepository 		location: 'ftp://source.squeak.org/trunk' 		username: 'foo' 		password: 'bar'.	self assert: (repo isKindOf: MCFtpRepository).	self assert: (repo description = 'ftp://foo@source.squeak.org/trunk').! !"Tests"!!Utilities class methodsFor: '*ToolBuilder-Kernel' stamp: 'cmm 12/23/2010 14:16' prior: 35168297!classOrTraitFrom: environment pattern: pattern label: label	"If there is a class or trait whose name exactly given by pattern, return it.	If there is only one class or trait in the given environment whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen.	This method ignores separator characters in the pattern"		| toMatch potentialNames names exactMatch lines reducedIdentifiers selectedIndex |	toMatch := pattern copyWithoutAll: Character separators.	toMatch ifEmpty: [ ^nil ].	"If there's a class or trait named as pattern, then return it."	Symbol hasInterned: pattern ifTrue: [ :symbol |		environment at: symbol ifPresent: [ :maybeClassOrTrait |			((maybeClassOrTrait isKindOf: Class) or: [				maybeClassOrTrait isTrait ])					ifTrue: [ ^maybeClassOrTrait ] ] ].	"No exact match, look for potential matches."	toMatch := pattern asLowercase copyWithout: $..	potentialNames := (environment classAndTraitNames) asOrderedCollection.	names := pattern last = $. "This is some old hack, using String>>#match: may be better."		ifTrue: [ potentialNames select: [ :each | each asLowercase = toMatch ] ]		ifFalse: [			potentialNames select: [ :each |				each includesSubstring: toMatch caseSensitive: false ] ].	exactMatch := names detect: [ :each | each asLowercase = toMatch ] ifNone: [ nil ].	lines := OrderedCollection new.	exactMatch ifNotNil: [ lines add: 1 ].	"Also try some fuzzy matching."	reducedIdentifiers := pattern suggestedTypeNames select: [ :each |		potentialNames includes: each ].	reducedIdentifiers ifNotEmpty: [		names addAll: reducedIdentifiers.		lines add: 1 + names size + reducedIdentifiers size ].	"Let the user select if there's more than one possible match. This may give surprising results."	selectedIndex := names size = 1		ifTrue: [ 1 ]		ifFalse: [			exactMatch ifNotNil: [ names addFirst: exactMatch ].			UIManager default chooseFrom: names lines: lines title: label ].	selectedIndex = 0 ifTrue: [ ^nil ].	^environment at: (names at: selectedIndex) asSymbol! !"ToolBuilder-Kernel"!!Debugger class methodsFor: 'class initialization' stamp: 'mtf 12/20/2010 16:36' prior: 54918959!openContext: aContext label: aString contents: contentsStringOrNil	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logSqueakError: aString inContext: aContext].	ErrorRecursion ifTrue:[		ErrorRecursion := false.		self primitiveError: aString].	ErrorRecursion := true.	self informExistingDebugger: aContext label: aString.	(Debugger context: aContext)		openNotifierContents: contentsStringOrNil		label: aString.	ErrorRecursion := false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'mtf 12/20/2010 16:34' prior: 34553341!openOn: process context: context label: title contents: contentsStringOrNil fullView: bool	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	| controller errorWasInUIProcess debugger |	Smalltalk isMorphic		ifTrue: [errorWasInUIProcess := Project spawnNewProcessIfThisIsUI: process]		ifFalse: [			controller := ScheduledControllers activeControllerProcess == process				ifTrue: [ScheduledControllers activeController].			[			debugger := self new process: process controller: controller context: context.			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logSqueakError: title inContext: context].			] on: Error do: [:ex |				self primitiveError: 					'Orginal error: ', 					title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'			]].	WorldState addDeferredUIMessage: [ 		"schedule debugger in deferred UI message to address redraw		problems after opening a debugger e.g. from the testrunner."		[			debugger := self new process: process controller: nil context: context.			bool				ifTrue: [debugger openFullNoSuspendLabel: title]				ifFalse: [debugger openNotifierContents: contentsStringOrNil label: title].			debugger errorWasInUIProcess: errorWasInUIProcess.			Preferences logDebuggerStackToFile ifTrue: [				Smalltalk logSqueakError: title inContext: context].		] on: Error do: [:ex |			self primitiveError: 				'Orginal error: ', 				title asString, '.	Debugger error: ', 				([ex description] on: Error do: ['a ', ex class printString]), ':'		]	].	process suspend.! !!Debugger methodsFor: 'notifier menu' stamp: 'jrd 5/23/2009 00:53' prior: 19586640!storeLog	Smalltalk logSqueakError: labelString printString inContext: contextStackTop! !"Tools"!ClassTrait removeSelector: #classSide!"Traits"!!HelpBrowserTest methodsFor: 'testing' stamp: 'tbn 12/22/2010 08:48' prior: 33867943!testOpen	|block|	block := [		|browser|		browser := self defaultTestClass open.		World doOneCycleNow. 		browser close ].		self shouldnt: block raise: Error		! !"HelpSystem-Tests"!!SystemReporter commentStamp: 'laza 1/18/2011 12:04' prior: 0!SystemReporter offers a window where information about the system is gathered. This can be easily copied to the clipboard and be attached to a bug report for better identification of the context the bug occured in.To extend the SystemReporter:	- add a method		reportXYZ: aStream	  to the reporting category	- insert a line		add: #XYZ method: #reportXYZ	  to the initialize method!!SystemReporter class methodsFor: 'instance creation' stamp: 'lr 10/8/2005 18:35'!open	^ ToolBuilder open: self new.! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:22'!add: category method: aSymbol	^self categoryList add: (self categories add: category -> aSymbol) key! !!SystemReporter methodsFor: 'building' stamp: 'lr 10/31/2005 15:12'!buildCategoriesWith: aBuilder	^ aBuilder pluggableMultiSelectionListSpec new		model: self;		list: #categoryList;		menu: #categoryMenu:;		getIndex: #categorySelected;		setIndex: #categorySelected:;		getSelectionList: #categoryAt:;		setSelectionList: #categoryAt:put:;		yourself.! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/18/2011 11:46'!buildReportWith: aBuilder	^ aBuilder pluggableTextSpec new		model: self;		menu: #reportMenu:;		getText: #reportText;		yourself.! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/17/2011 12:10'!buildWith: aBuilder	| window |	window := aBuilder pluggableWindowSpec new		model: self; label: self label; extent: self extent;		children: (OrderedCollection new 			add: ((self buildCategoriesWith: aBuilder)				frame: self categoriesFrame;				yourself);			add: ((self buildReportWith: aBuilder)				frame: self reportFrame;				yourself);			yourself);		yourself.	^ aBuilder build: window.! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:19'!categories	^ categories ifNil: [categories := IdentityDictionary new]! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/17/2011 11:56'!categoriesFrame	^LayoutFrame new		leftFraction: 0 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 0.25 offset: 0;		bottomFraction: 1 offset: 0! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/17/2011 12:22'!categoryAt: anIndex	^ categoriesSelected includes: (self categoryList at: anIndex ifAbsent: [ ^ false ]).! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/17/2011 12:37'!categoryAt: anInteger put: aBoolean	categoriesSelected := categoriesSelected		perform: (aBoolean ifTrue: [ #copyWith: ] ifFalse: [ #copyWithout: ])		with: (self categoryList at: anInteger ifAbsent: [ ^ self ]).	self updateReport! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:16'!categoryList	^ categoryList ifNil: [categoryList := OrderedCollection new]! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:57'!categoryMenu: aMenu	^ aMenu		title: 'Categories';		add: 'Select all' action: #selectAllCategories;		add: 'Select none' action: #selectNoCategories;		addLine;		add: 'Refresh' action: #refresh;		yourself.! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:11'!categorySelected	^ 0! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'lr 10/31/2005 15:12'!categorySelected: anInteger	self changed: #categorySelected.! !!SystemReporter methodsFor: 'accessing-report' stamp: 'laza 1/18/2011 11:50'!copyReportToClipboard	Clipboard clipboardText: self reportText.	UIManager default inform: 'Copied Report to Clipboard'! !!SystemReporter methodsFor: 'accessing-ui' stamp: 'lr 10/8/2005 18:39'!extent	^ 640 @ 480! !!SystemReporter methodsFor: 'printing-report' stamp: 'laza 1/18/2011 08:58'!header: aString on: aStream	aStream withAttribute: TextEmphasis bold do: [			aStream nextPutAll: aString; cr.		aString size timesRepeat: [aStream nextPut: $-].		aStream cr]! !!SystemReporter methodsFor: 'initialize-release' stamp: 'laza 1/18/2011 11:56'!initialize	self		add: #Image method: #reportImage;		add: #'Image Parameters' method: #reportImageParameters;		add: #'Image Sources' method: #reportSources;		add: #'VM General' method: #reportVM;		add: #'VM Options' method: #reportVMOptions;		add: #'VM Modules' method: #reportModules.	Smalltalk os platformName = 'Win32' ifTrue: [		self			add: #'VM Configuration' method: #reportINI.		].	self		add: #'OS General' method: #reportOS.	Smalltalk os platformName = 'Win32' ifTrue: [		self			add: #'OS Details' method: #reportOSDetails;			add: #'Hardware Details' method: #reportHardwareDetails;			add: #'GFX Hardware Details' method: #reportGFXDetails.		].	self add: #'Tiny Benchmarks' method: #reportTinyBenchmarks.	categoriesSelected := Set with: #Image with: #'VM General'.	self updateReport! !!SystemReporter methodsFor: 'accessing-ui' stamp: 'laza 1/17/2011 11:47'!label	^ 'System Reporter' ! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:58'!refresh	tinyBenchmarksResult := nil.	self updateReport! !!SystemReporter methodsFor: 'building' stamp: 'laza 1/17/2011 12:14'!reportFrame	^LayoutFrame new		leftFraction: 0.25 offset: 0;		topFraction: 0 offset: 0;		rightFraction: 1 offset: 0;		bottomFraction: 1 offset: 0! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:29'!reportGFXDetails: aStream	self header: 'Graphics Hardware Details' on: aStream.	aStream nextPutAll: (SmalltalkImage current getSystemAttribute: 10003)! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:29'!reportHardwareDetails: aStream	self header: 'Hardware Details' on: aStream.	aStream nextPutAll: (SmalltalkImage current getSystemAttribute: 10001)! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:55'!reportINI: aStream	| exePath iniData iniPath |	self header: 'VM Configuration' on: aStream.	exePath := SmalltalkImage current getSystemAttribute: 0.	iniPath := (exePath copyUpToLast: $.), '.ini'.	aStream nextPutAll: iniPath; cr.	iniData := [		(FileStream readOnlyFileNamed: iniPath)			 contentsOfEntireFile	] on: Error do:[:ex| ex return: ex printString].	aStream		nextPutAll: iniData! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 09:45'!reportImage: aStream	self header: 'Image' on: aStream.	aStream 		nextPutAll: SystemVersion current version; cr;		nextPutAll: SmalltalkImage current lastUpdateString; cr;		nextPutAll: SmalltalkImage current currentChangeSetString; cr;		nextPutAll: (SmalltalkImage current getSystemAttribute: 1); cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:26'!reportImageParameters: aStream	| id value |	self header: 'Image Commandline Parameters' on: aStream.	id := 3.	[value := (SmalltalkImage current getSystemAttribute: id).	value = nil or: [id > 1000]] whileFalse: [		aStream			nextPut: $#;			nextPutAll: id printString;			tab;			nextPutAll: value; cr.		id := id + 1	].	id = 3 ifTrue: [aStream nextPutAll: 'none'; cr]! !!SystemReporter methodsFor: 'accessing-report' stamp: 'laza 1/18/2011 11:49'!reportMenu: aMenu	^ aMenu		title: 'Report';		add: 'Copy to Clipboard' action: #copyReportToClipboard;		yourself.! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:54'!reportModules: aStream	self header: 'Loaded VM Modules' on: aStream.	SmalltalkImage current listLoadedModules asSortedCollection do: [:each | aStream nextPutAll: each; cr].! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:28'!reportOS: aStream	self header: 'Operating System/Hardware' on: aStream.	aStream		nextPutAll: (SmalltalkImage current getSystemAttribute: 1001); space;		nextPutAll: (SmalltalkImage current getSystemAttribute: 1002); space;		nextPutAll: (SmalltalkImage current getSystemAttribute: 1003); cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:29'!reportOSDetails: aStream	self header: 'Operating System Details' on: aStream.	aStream nextPutAll: (SmalltalkImage current getSystemAttribute: 10002)! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:55'!reportSources: aStream	self header: 'Image Sources' on: aStream.	aStream nextPutAll: SourceFiles class printString; cr.	SourceFiles do: [:each |		each ifNotNil: [aStream nextPutAll: each printString; cr]]! !!SystemReporter methodsFor: 'accessing-report' stamp: 'laza 1/18/2011 09:42'!reportText	^ (report isNil or: [categoriesSelected isEmpty])		ifTrue: ['-- Choose any category on the left --']		ifFalse: [report]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:05'!reportTinyBenchmarks: aStream	tinyBenchmarksResult ifNil: [		UIManager inform: 'Running the Benchmarks\will take a few seconds' withCRs.		tinyBenchmarksResult := 0 tinyBenchmarks].	self header: 'Tiny Benchmarks' on: aStream.	aStream nextPutAll: tinyBenchmarksResult! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 09:35'!reportVM: aStream	self header: 'Virtual Machine' on: aStream.	aStream		nextPutAll: (SmalltalkImage current getSystemAttribute: 1004); cr;		nextPutAll: (SmalltalkImage current getSystemAttribute: 0); cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/18/2011 11:27'!reportVMOptions: aStream	| id value |	self header: 'Virtual Machine Commandline Options' on: aStream.	id := -1.	[value := (SmalltalkImage current getSystemAttribute: id).	value = nil or: [id < -1000]] whileFalse: [		aStream			nextPut: $#;			nextPutAll: id negated printString;			tab;			nextPutAll: value; cr.		id := id - 1	].	id = -1 ifTrue: [aStream nextPutAll: 'none'; cr]! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:40'!selectAllCategories	categoriesSelected addAll: categoryList.	self changed: #categorySelected.	self updateReport! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/18/2011 11:40'!selectNoCategories	categoriesSelected removeAll.	self changed: #categorySelected.	self updateReport! !!SystemReporter methodsFor: 'updating' stamp: 'laza 1/18/2011 11:26'!updateReport	report := Text streamContents: [:stream | 		stream 			withAttribute: (TextFontReference toFont: ((TextStyle named: 'BitstreamVeraSansMono') fontOfSize: 16))			do: [				self categoryList do: [:each |					(categoriesSelected includes: each) ifTrue: [						self perform: ((categories at: each), ':') asSymbol with: stream.						stream cr]]]].	self changed: #reportText! !"SystemReporter"!!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:15' prior: 34280642!receiveData	self waitForData.	^self receiveAvailableData! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:09'!signalClosed	self shouldSignal ifFalse: [^ self]. 	ConnectionClosed signal: 'Connection closed while waiting for data.'! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:10'!signalTimeout	self shouldSignal ifFalse: [^ self]. 	ConnectionTimedOut signal: 'Data receive timed out.'! !!SocketStream methodsFor: 'private-socket' stamp: 'mtf 1/15/2011 20:16'!waitForData	"Wait for data. If shouldTimeout, we will time out if nothing arrives, otherwise we wait indefinitely"	self shouldTimeout		ifTrue: [socket waitForDataFor: self timeout			ifClosed: [self signalClosed]			ifTimedOut: [self signalTimeout]]		ifFalse: [socket waitForDataIfClosed: [self signalClosed]]! !!DosFileDirectory class methodsFor: '*network-uri' stamp: 'fbs 12/16/2010 22:44' prior: 19873283!privateFullPathForURI: aURI	| path |	path := aURI path unescapePercents.	"Check for drive notation (a: etc)"	path size > 1		ifTrue: [			((path at: 3) = $:)				ifTrue: [path := path copyFrom: 2 to: path size]				ifFalse: [					"All other cases should be network path names (\\xxx\sdsd etc)"					path := '/' , path]].	^(path copyReplaceAll: '/' with: self slash) unescapePercents! !!FileDirectory methodsFor: '*network-uri' stamp: 'fbs 12/13/2010 20:21' prior: 51119220!uri	"Convert my path into a file:// type url.  Use slash instead of the local delimiter (:), and convert odd characters to %20 notation."	"If slash (/) is not the file system delimiter, encode slashes before converting."	| list |	list := self pathParts.	^(String streamContents: [:strm |		strm nextPutAll: 'file:'.		list do: [:each | strm nextPut: $/; nextPutAll: each encodeForHTTP].		strm nextPut: $/]) asURI! !!BrowserUrl methodsFor: 'downloading' stamp: 'ls 7/26/1998 21:21'!retrieveContentsForBrowser: aBrowser	^aBrowser browserUrlContents: locator! !"Network"!!String methodsFor: 'comparing' stamp: 'ul 1/15/2011 11:48' prior: 30143800!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	^ self startingAt: 1 match: text startingAt: 1"	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' true	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"! !!String methodsFor: 'comparing' stamp: 'ul 1/15/2011 13:54' prior: 34760788!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."		| anyMatch matchStart matchEnd i matchStr j ii jj |	i := keyStart.	j := textStart.		"Process consecutive *s and #s at the beginning."	anyMatch := false.	[ i <= self size and: [		(self at: i)			caseOf: {				[ $* ] -> [ 					anyMatch := true.					i := i + 1.					true ].				[ $# ] -> [					i := i + 1.					j := j + 1.					true ] }			otherwise: [ false ] ] ] whileTrue.	i > self size ifTrue: [		^j - 1 = text size or: [ "We reached the end by matching the character with a #."			anyMatch and: [ j <= text size ] "Or there was a * before the end." ] ].	matchStart := i.	"Now determine the match string"	matchEnd := self size.	(ii := self indexOf: $* startingAt: matchStart) > 0 ifTrue: [ matchEnd := ii-1 ].	(ii := self indexOf: $# startingAt: matchStart) > 0 ifTrue: [ matchEnd := matchEnd min: ii-1 ].	matchStr := self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj := text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j := j+1].	^ false "Failed to find the match string"! !"Collections"!!IntervalTest methodsFor: 'tests' stamp: 'nice 11/15/2010 21:02' prior: 22135472!testPermutationsDo	| i oc |	i := (1.234 to: 4.234).	oc := OrderedCollection new.	i permutationsDo: [:e | oc add: e].	self assert: (oc size = i size factorial).	^ oc! !!StringTest methodsFor: 'test-comparing' stamp: 'ul 1/15/2011 13:30' prior: 34773986!testMatch	#('**' 'f**'  'f**o' 'f*' '*f*' 'f#*' 'f##' '*oo' '#oo' '*o*' '#o#' '#o*' '*o#' 'fo*' 'fo#' '*foo*' '###' '*#'  'f*#' 'f*#o')		do: [ :each | self assert: (each match: 'foo') ].	#('bar' 'foo#' '#foo' '*foo#' '#foo*' '*bar*') do: [ :each |		self deny: (each match: 'foo') ]! !"CollectionsTests"!!MCHttpRepository class methodsFor: 'as yet unclassified' stamp: 'cmm 1/25/2011 13:00' prior: 56368746!creationTemplate	^self creationTemplateLocation: 'http://www.squeaksource.com/ProjectName'		user: 'squeak'		password: 'squeak'! !!MCWorkingCopy class methodsFor: 'class initialization' stamp: 'bp 1/7/2011 22:44'!cleanUp: aggressive	"Remove all PackageInfos that are not associated with an MCWorkingCopy when aggressively cleaning up"	aggressive ifTrue: [self flushObsoletePackageInfos]! !!MCWorkingCopy class methodsFor: 'cleanup' stamp: 'bp 1/7/2011 22:48'!flushObsoletePackageInfos	"Flush any and all PackageInfos that are not associated with an MCWorkingCopy."	| pkgNames |	pkgNames := self allManagers collect:[:wcs| wcs packageName] as: Set.	PackageOrganizer default flushObsoletePackages:[:p|		p class isObsolete or:[(pkgNames includes: p packageName) not].	].! !!MCWorkingCopy methodsFor: 'operations' stamp: 'dtl 1/11/2011 23:30' prior: 23212171!unload	MCPackageLoader unloadPackage: self package.	self unregisterSubpackages.	self unregister.! !!MCPackageManager methodsFor: 'operations' stamp: 'dtl 1/11/2011 23:30'!unregisterSubpackages	(self class registry keys		select: [:p | self packageName , '-*' match: p name])		do: [:k | self class registry removeKey: k]! !MCPackageManager class removeSelector: #flushObsoletePackageInfos!MCPackageManager class removeSelector: #cleanUp:!"Monticello"!!Float commentStamp: '<historical>' prior: 35181570!My instances represent IEEE-754 floating-point double-precision numbers.  They have about 16 digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:		8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:	3r20.2 --> 6.66666666666667	8r20.2 --> 16.25If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...	sign		1 bit	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent						in the range -1023 .. +1024				- 16r000:					significand = 0: Float zero					significand ~= 0: Denormalized number (exp = -1024, no hidden '1' bit)				- 16r7FF:					significand = 0: Infinity					significand ~= 0: Not A Number (NaN) representation	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.The single-precision format is...	sign		1 bit	exponent	8 bits, with bias of 127, to represent -126 to +127                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)	mantissa	24 bits, but only 23 are storedThis format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.Thanks to Rich Harmon for asking many questions and to Tim Olson, Bruce Cohen, Rick Zaccone and others for the answers that I have collected here.!!MethodFinder methodsFor: 'initialize' stamp: 'nice 12/29/2010 14:49' prior: 51720774!testFromTuple: nth	"verify that the methods allowed don't crash the system.  Try N of each of the fundamental types.  up to 4 of each kind." | objects nonRepeating even other aa cnt |objects := #((1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')	(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).objects := objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.	{Point class. SmallInteger class. Association class. Array class}.	"{ 4 blocks }."	{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.	{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.	{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.	{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 		#($a 3 d) asOrderedCollection. #() asOrderedCollection}.	{3 -> true. 5.6 -> $a. #x -> 2. 'abcd' -> false}.	{9 @ 3 extent: 5 @ 4. 0 @ 0 extent: 45 @ 9. -3 @ -7 extent: 2 @ 2. 4 @ 4 extent: 16 @ 16}.	{Color red.  Color blue. Color black. Color gray}}.self test2: objects."rec+0, rec+1, rec+2, rec+3 need to be tested.  " cnt := 0.nth to: 4 do: [:take |	nonRepeating := OrderedCollection new.	objects do: [:each |		nonRepeating addAll: (each copyFrom: 1 to: take)].	"all combinations of take, from nonRepeating"	even := true.	nonRepeating combinations: take atATimeDo: [:tuple |		even ifTrue: [other := tuple clone]			ifFalse: [self load: (aa := Array with: tuple with: 1 with: other with: 7).				(cnt := cnt + 1) \\ 50 = 0 ifTrue: [					Transcript cr; show: aa first printString].				self search: true.				self test2: aa.				self test2: nonRepeating.				"self test2: objects"].		even := even not].	].! !!MethodFinder methodsFor: 'initialize' stamp: 'nice 12/29/2010 16:07' prior: 51713897!testRandom	"verify that the methods allowed don't crash the system.  Pick 3 or 4 from a mixed list of the fundamental types." | objects other aa cnt take tuple fName sss |objects := #((1 4 17 42) ($a $b $c $d) ('one' 'two' 'three' 'four')	(x + rect: new) ((a b 1 4) (c 1 5) ($a 3 d) ()) (4.5 0.0 3.2 100.3)	).objects := objects, {{true. false. true. false}. {Point. SmallInteger. Association. Array}.	{Point class. SmallInteger class. Association class. Array class}.	"{ 4 blocks }."	{Date today. '1 Jan 1950' asDate. '25 Aug 1987' asDate. '1 Jan 2000' asDate}.	{'15:16' asTime. '1:56' asTime. '4:01' asTime. '6:23' asTime}.	{Dictionary new. Dictionary new. Dictionary new. Dictionary new}.	{#(a b 1 4) asOrderedCollection. #(c 1 5) asOrderedCollection. 		#($a 3 d) asOrderedCollection. #() asOrderedCollection}.	{3 -> true. 5.6 -> $a. #x -> 2. 'abcd' -> false}.	{9 @ 3 extent: 5 @ 4. 0 @ 0 extent: 45 @ 9. -3 @ -7 extent: 2 @ 2. 4 @ 4 extent: 16 @ 16}.	{Color red.  Color blue. Color black. Color gray}}.self test2: objects."rec+0, rec+1, rec+2, rec+3 need to be tested.  " fName := (FileDirectory default fileNamesMatching: '*.ran') first.sss := fName splitInteger first.(Collection classPool at: #RandomForPicking) seed: sss.cnt := 0.[take := #(3 4) atRandom.	tuple := (1 to: take) collect: [:ind | (objects atRandom) atRandom].	other := (1 to: take) collect: [:ind | (objects atRandom) atRandom].	self load: (aa := Array with: tuple with: 1 with: other with: 7).	((cnt := cnt + 1) \\ 10 = 0) " | (cnt > Skip)" ifTrue: [		Transcript cr; show: cnt printString; tab; tab; show: aa first printString].	cnt > (Smalltalk at: #StopHere) ifTrue: [self halt].		"stop just before crash"	cnt > (Smalltalk at: #Skip) ifTrue: ["skip this many at start"		self search: true.		self test2: aa first.  self test2: (aa at: 3).		"self test2: objects"		].	true] whileTrue.	! !!Float class methodsFor: 'class initialization' stamp: 'nice 3/15/2008 22:42' prior: 35184301!initialize	"Float initialize"	"Constants from Computer Approximations, pp. 182-183:		Pi = 3.14159265358979323846264338327950288		Pi/2 = 1.57079632679489661923132169163975144		Pi*2 = 6.28318530717958647692528676655900576		Pi/180 = 0.01745329251994329576923690768488612		2.0 ln = 0.69314718055994530941723212145817657		2.0 sqrt = 1.41421356237309504880168872420969808"	Pi := 3.14159265358979323846264338327950288.	Halfpi := Pi / 2.0.	Twopi := Pi * 2.0.	ThreePi := Pi * 3.0.	RadiansPerDegree := Pi / 180.0.	Ln2 := 0.69314718055994530941723212145817657.	Ln10 := 10.0 ln.	Sqrt2 := 1.41421356237309504880168872420969808.	E := 2.718281828459045235360287471353.	Epsilon := 0.000000000001.  "Defines precision of mathematical functions"	MaxVal := 1.7976931348623157e308.	MaxValLn := 709.782712893384.	MinValLogBase2 := -1074.	Infinity := MaxVal * MaxVal.	NegativeInfinity := 0.0 - Infinity.	NaN := Infinity - Infinity.	NegativeZero := 1.0 / Infinity negated.! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35185846!arcCos	"Answer the angle in radians."	^ Halfpi - self arcSin! !!Float methodsFor: 'mathematical functions' stamp: 'jsp 2/25/1999 11:15' prior: 35186356!arcSin	"Answer the angle in radians."	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi * self]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35187040!arcTan	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| theta eps step sinTheta cosTheta |	<primitive: 57>	"Newton-Raphson"	self < 0.0 ifTrue: [ ^ 0.0 - (0.0 - self) arcTan ].	"first guess"	theta := (self * Halfpi) / (self + 1.0).	"iterate"	eps := Halfpi * Epsilon.	step := theta.	[(step * step) > eps] whileTrue: [		sinTheta := theta sin.		cosTheta := theta cos.		step := (sinTheta * cosTheta) - (self * cosTheta * cosTheta).		theta := theta - step].	^ theta! !!Float methodsFor: 'mathematical functions' stamp: 'nice 10/30/2009 22:21' prior: 35187425!arcTan: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive.	Implementation note: use sign in order to catch cases of negativeZero"	^self = 0.0		ifTrue: [denominator sign >= 0			ifTrue: [ 0 ]			ifFalse: [ self sign >= 0				ifTrue: [ Pi ]				ifFalse: [ Pi negated ]]]		ifFalse: [denominator = 0.0			ifTrue: [self > 0.0				ifTrue: [ Halfpi ]				ifFalse: [ Halfpi negated ]]			ifFalse: [denominator > 0				ifTrue: [ (self / denominator) arcTan ]				ifFalse: [self > 0					ifTrue: [ ((self / denominator) arcTan) + Pi ]					ifFalse: [ ((self / denominator) arcTan) - Pi ]]]]! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35188600!cos	"Answer the cosine of the receiver taken as an angle in radians."	^ (self + Halfpi) sin! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35189202!exp	"Answer E raised to the receiver power.	 Optional. See Object documentation whatIsAPrimitive." 	| base fract correction delta div |	<primitive: 59>	"Taylor series"	"check the special cases"	self < 0.0 ifTrue: [^ (self negated exp) reciprocal].	self = 0.0 ifTrue: [^ 1].	self abs > MaxValLn ifTrue: [self error: 'exp overflow'].	"get first approximation by raising e to integer power"	base := E raisedToInteger: (self truncated).	"now compute the correction with a short Taylor series"	"fract will be 0..1, so correction will be 1..E"	"in the worst case, convergance time is logarithmic with 1/Epsilon"	fract := self fractionPart.	fract = 0.0 ifTrue: [ ^ base ].  "no correction required"	correction := 1.0 + fract.	delta := fract * fract / 2.0.	div := 2.0.	[delta > Epsilon] whileTrue: [		correction := correction + delta.		div := div + 1.0.		delta := delta * fract / div].	correction := correction + delta.	^ base * correction! !!Float methodsFor: 'truncation and round off' stamp: '' prior: 35189619!fractionPart	"Primitive. Answer a Float whose value is the difference between the 	receiver and the receiver's asInteger value. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 52>	^self - self truncated asFloat! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35190469!ln	"Answer the natural logarithm of the receiver.	 Optional. See Object documentation whatIsAPrimitive."	| expt n mant x div pow delta sum eps |	<primitive: 58>	"Taylor series"	self <= 0.0 ifTrue: [self error: 'ln is only defined for x > 0.0'].	"get a rough estimate from binary exponent"	expt := self exponent.	n := Ln2 * expt.	mant := self timesTwoPower: 0 - expt.	"compute fine correction from mantinssa in Taylor series"	"mant is in the range [0..2]"	"we unroll the loop to avoid use of abs"	x := mant - 1.0.	div := 1.0.	pow := delta := sum := x.	x := x negated.  "x <= 0"	eps := Epsilon * (n abs + 1.0).	[delta > eps] whileTrue: [		"pass one: delta is positive"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta.		"pass two: delta is negative"		div := div + 1.0.		pow := pow * x.		delta := pow / div.		sum := sum + delta].	^ n + sum	"2.718284 ln 1.0"! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35190878!log	"Answer the base 10 logarithm of the receiver."	^ self ln / Ln10! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35196210!sin	"Answer the sine of the receiver taken as an angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| sum delta self2 i |	<primitive: 56>	"Taylor series"	"normalize to the range [0..Pi/2]"	self < 0.0 ifTrue: [^ (0.0 - ((0.0 - self) sin))].	self > Twopi ifTrue: [^ (self \\ Twopi) sin].	self > Pi ifTrue: [^ (0.0 - (self - Pi) sin)].	self > Halfpi ifTrue: [^ (Pi - self) sin].	"unroll loop to avoid use of abs"	sum := delta := self.	self2 := 0.0 - (self * self).	i := 2.0.	[delta > Epsilon] whileTrue: [		"once"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta.		"twice"		delta := (delta * self2) / (i * (i + 1.0)).		i := i + 2.0.		sum := sum + delta].	^ sum! !!Float methodsFor: 'mathematical functions' stamp: 'RAH 4/25/2000 19:49' prior: 35196793!sqrt	"Answer the square root of the receiver. 	 Optional. See Object documentation whatIsAPrimitive."	| exp guess eps delta |	<primitive: 55>	#Numeric.	"Changed 200/01/19 For ANSI <number> support."	"Newton-Raphson"	self <= 0.0		ifTrue: [self = 0.0				ifTrue: [^ 0.0]				ifFalse: ["v Chg"					^ FloatingPointException signal: 'undefined if less than zero.']].	"first guess is half the exponent"	exp := self exponent // 2.	guess := self timesTwoPower: 0 - exp.	"get eps value"	eps := guess * Epsilon.	eps := eps * eps.	delta := self - (guess * guess) / (guess * 2.0).	[delta * delta > eps]		whileTrue: 			[guess := guess + delta.			delta := self - (guess * guess) / (guess * 2.0)].	^ guess! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35197293!tan	"Answer the tangent of the receiver taken as an angle in radians."	^ self sin / self cos! !!Float methodsFor: 'mathematical functions' stamp: '' prior: 35197825!timesTwoPower: anInteger 	"Primitive. Answer with the receiver multiplied by 2.0 raised	to the power of the argument.	Optional. See Object documentation whatIsAPrimitive."	<primitive: 54>	anInteger < -29 ifTrue: [^ self * (2.0 raisedToInteger: anInteger)].	anInteger < 0 ifTrue: [^ self / (1 bitShift: (0 - anInteger)) asFloat].	anInteger < 30 ifTrue: [^ self * (1 bitShift: anInteger) asFloat].	^ self * (2.0 raisedToInteger: anInteger)! !!ClassDescription methodsFor: 'accessing parallel hierarchy' stamp: 'nice 12/29/2010 12:29' prior: 54703907!isClassSide	^self isMeta! !!Object methodsFor: 'testing' stamp: 'mtf 12/30/2010 23:41'!isPrimitiveCostume"True for primitive costumes in Tweak. Added here because a Tweak override in DisplayScanner was merged into trunk for maintainability"	^false! !Float removeSelector: #tanH!Float removeSelector: #sinH!Float removeSelector: #primitiveTimesTwoPower:!Float removeSelector: #primitiveSqrt!Float removeSelector: #primitiveSin!Float removeSelector: #primitiveLn!Float removeSelector: #primitiveFractionPart!Float removeSelector: #primitiveExp!Float removeSelector: #primitiveArcTan!Float removeSelector: #hypot:!Float removeSelector: #cosH!Float removeSelector: #arcTanH!Float removeSelector: #arcSinH!Float removeSelector: #arcCosH!Float class removeSelector: #signalNaN:!Float class removeSelector: #signalNaN!Number removeSelector: #hypot:!"Kernel"!!VariableNode methodsFor: 'tiles' stamp: 'nice 12/29/2010 15:11' prior: 53110193!variableGetterBlockIn: aContext	| temps tempIndex ivars |	(self type = 4 and: [self key isVariableBinding]) ifTrue: [		^[self key value]	].	aContext ifNil: [^nil].	self isSelfPseudoVariable ifTrue: [^[aContext receiver]].	self type = 1 ifTrue: [		ivars := aContext receiver class allInstVarNames.		tempIndex := ivars indexOf: self name ifAbsent: [^nil].		^[aContext receiver instVarAt: tempIndex]	].	self type = 2 ifTrue: [		temps := aContext tempNames.		tempIndex := temps indexOf: self name ifAbsent: [^nil].		^[aContext tempAt: tempIndex]	].	^nil! !!BytecodeEncoder methodsFor: 'temps' stamp: 'nice 12/29/2010 14:41' prior: 50554879!blockExtentsToTempsMap	"Answer a Dictionary of blockExtent to temp locations for the current method.	 This is used by the debugger to locate temp vars in contexts.  A temp map	 entry is a pair of the temp's name and its index, where an index is either an	 integer for a normal temp or a pair of the index of the indirect temp vector	 containing  the temp and the index of the temp in its indirect temp vector."	| blockExtentsToTempsMap |	blockExtentsToLocals ifNil:		[^nil].	blockExtentsToTempsMap := Dictionary new.	blockExtentsToLocals keysAndValuesDo:		[:blockExtent :locals|		blockExtentsToTempsMap			at: blockExtent			put: (Array streamContents:					[:aStream|					locals withIndexDo:						[:local :index|						local isIndirectTempVector							ifTrue: [local remoteTemps withIndexDo:										[:remoteLocal :innerIndex| aStream nextPut: { remoteLocal key. { index. innerIndex } }]]							ifFalse: [aStream nextPut: { local key. index }]]])].	^blockExtentsToTempsMap! !!MessageNode methodsFor: 'macro transformations' stamp: 'nice 1/12/2011 22:07' prior: 51639357!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:	 and: [initStmt isAssignmentNode	 and: [initStmt variable isTemp]]) ifFalse:		[^nil].	body := arguments last statements.	variable := initStmt variable.	increment := body last toDoIncrement: variable.	(increment == nil	 or: [receiver statements size ~= 1]) ifTrue:		[^nil].	test := receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	(test isMessageNode	 and: [(limit := test toDoLimit: variable) notNil]) ifFalse:		[^nil].	"The block must not overwrite the limit"	(limit isVariableNode and: [body anySatisfy: [:e | e isAssignmentNode and: [e variable = limit]]])		ifTrue: [^nil]. 	toDoBlock := BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	variable scope: -1.	variable beBlockArg.	^MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !"Compiler"!!AlignmentMorph methodsFor: '*Etoys-initialization' stamp: 'nice 12/29/2010 14:38' prior: 58391050!addUpDownArrowsFor: aMorph	"Add a column of up and down arrows that serve to send upArrowHit and downArrowHit to aMorph when they're pressed/held down"	| holder downArrow upArrow |	holder := Morph new extent: 16 @ 16; beTransparent.	downArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'DownArrow').	upArrow := ImageMorph new image: (ScriptingSystem formAtKey: 'UpArrow').	upArrow position: holder bounds topLeft + (2 @ 2).	downArrow align: downArrow bottomLeft				with: holder topLeft + (0 @ TileMorph defaultH) + (2 @ -2).	holder addMorph: upArrow.	holder addMorph: downArrow.	self addMorphBack: holder.	upArrow on: #mouseDown send: #upArrowHit to: aMorph.	upArrow on: #mouseStillDown send: #upArrowHit to: aMorph.	downArrow on: #mouseDown send: #downArrowHit to: aMorph.	downArrow on: #mouseStillDown send: #downArrowHit to: aMorph.! !!ViewerLine methodsFor: 'slot' stamp: 'nice 12/29/2010 15:02' prior: 33018251!addGetterFeedback	"Add feedback during mouseover of a getter"	| aMorph endMorph |	endMorph :=		(#(touchesA: #seesColor: #overlaps:) includes: self elementSymbol)			ifTrue:				[submorphs eighth]			ifFalse:				[submorphs sixth].	aMorph := RectangleMorph new useRoundedCorners bounds: ((submorphs fourth topLeft - (2 @ -1)) corner: (endMorph bottomRight + (2 @ -1))).	aMorph beTransparent; borderWidth: 2; borderColor: (Color r: 1.0 g: 0.355 b: 0.839); lock.	aMorph setProperty: #highlight toValue: true.	ActiveWorld addMorphFront: aMorph"Color fromUser (Color r: 1.0 g: 0.355 b: 0.839)"! !!ScriptEditorMorph methodsFor: 'menu commands' stamp: 'nice 12/29/2010 14:59' prior: 56792956!createThreadShowing	| vertices |	self deleteThreadShowing.	vertices := OrderedCollection new.	self tileRows do: [:row | | b |		row first isTurtleRow ifTrue: [			b := row first bounds.			vertices add: ((b topLeft + (4 @ 0)) + ((0 * 0.1 * b width) @ 0)).			0 to: 9 do: [:i |				vertices add: ((b topLeft + (4 @ 4))+ ((i * 0.1 * b width ) @ 0)).				vertices add: ((b bottomLeft + (4 @ -4)) + ((i * 0.1 * b width) @ 0)).			].				vertices add: ((b bottomLeft + (4 @ 0)) + ((9 * 0.1 * b width) @ 0)).		] ifFalse: [			b := row first bounds.			vertices add: ((b origin x + b corner x) // 2) @ (b origin y).			vertices add: ((b origin x + b corner x) // 2) @ (b origin y + 4).			vertices add: ((b origin x + b corner x) // 2) @ (b corner y - 4).			vertices add: ((b origin x + b corner x) // 2) @ (b corner y).		].	].	threadPolygon := PolygonMorph vertices: vertices color: Color black borderWidth: 2 borderColor: Color black.	threadPolygon makeOpen.	threadPolygon openInWorld.! !!ScriptEditorMorph methodsFor: 'other' stamp: 'nice 12/29/2010 15:00' prior: 56796574!extent: x	| newExtent tw menu |	newExtent := x max: self minWidth @ self minHeight.	(tw := self findA: TwoWayScrollPane) ifNil:		["This was the old behavior"		^ super extent: newExtent].	(self hasProperty: #autoFitContents) ifTrue: [		menu := MenuMorph new defaultTarget: self.		menu addUpdating: #autoFitString target: self action: #autoFitOnOff.		menu addTitle: 'To resize the script, uncheck the box below' translated.		menu popUpEvent: nil in: self world	.		^ self].	"Allow the user to resize to any size"	tw extent: ((newExtent x max: self firstSubmorph width)				@ (newExtent y - self firstSubmorph height)) - (borderWidth * 2) + (-4 @ -4).  "inset?"	^ super extent: newExtent! !!SyntaxMorph class methodsFor: 'as yet unclassified' stamp: 'nice 12/29/2010 16:51' prior: 30532389!standardInset	^ self alansTest1 ifTrue: [1] ifFalse: [-1 @ -1]! !!SyntaxMorph methodsFor: 'drawing' stamp: 'nice 12/29/2010 16:52' prior: 30407760!drawOn: aCanvas	super drawOn: aCanvas.	self isBlockNode ifFalse: [^self].	self alansTest1 ifTrue: [^self].	self immediatelyBelowTheMethodNode ifTrue: [		aCanvas fillRectangle: (self topLeft + (0 @ -1) extent: self width @ 1) color: Color gray	] ifFalse: [		aCanvas fillRectangle: (self topLeft + (1 @ 1) extent: 2 @ (self height-2)) color: Color gray.		aCanvas fillRectangle: (self topLeft + (1 @ 1) extent: 4 @ 1) color: Color gray.		aCanvas fillRectangle: (self bottomLeft + (1 @ -1) extent: 4 @ 1) color: Color gray	].! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'nice 12/29/2010 16:52' prior: 54482041!selectorMenuAsk: listOfLists	"I represent a SelectorNode to be replaced by one of the selectors in one of the category lists.  Each list has pre-built StringMorphs in it."	| menu |	listOfLists isEmpty ifTrue: [^ nil].	listOfLists first addFirst: (self aSimpleStringMorphWith: '( Cancel )').	listOfLists first first color: Color red.	menu := RectangleMorph new.	menu listDirection: #leftToRight; layoutInset: 3; cellInset: 1 @ 0.	menu layoutPolicy: TableLayout new; hResizing: #shrinkWrap; 		vResizing: #shrinkWrap; color: (Color r: 0.767 g: 1.0 b: 0.767);		useRoundedCorners; cellPositioning: #topLeft.	listOfLists do: [:ll | | col |		col := Morph new.	 	col listDirection: #topToBottom; layoutInset: 0; cellInset: 0 @ 0.		col layoutPolicy: TableLayout new; hResizing: #shrinkWrap.		col color: Color transparent; vResizing: #shrinkWrap.		menu addMorphBack: col.		ll do: [:ss | 			col addMorphBack: ss.			ss on: #mouseUp send: #replaceKeyWord:menuItem: to: self]		].	self world addMorph: menu.	menu setConstrainedPosition: (owner localPointToGlobal: self topRight) + (10 @ -30) 			hangOut: false.! !!SyntaxMorph methodsFor: 'alans styles' stamp: 'nice 12/29/2010 16:51' prior: 30403104!standardInset	parseNode class == BlockNode ifTrue: [^ 5 @ 1].		"allow pointing beside a line so can replace it"	^ self alansTest1 ifTrue: [1] ifFalse: [-1]! !"EToys"!!StandardFileStream class methodsFor: 'error handling' stamp: 'mtf 1/20/2011 14:14'!fileDoesNotExistUserHandling: fullFileName ifDebug: debugBlock	| selection newName |	selection := UIManager default chooseFrom: {		'create a new file' translated.		'choose another name' translated.		'debug' translated.		'cancel' translated	} title: (FileDirectory localNameFor: fullFileName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fullFileName forWrite: true].	selection = 2 ifTrue:		[ newName := UIManager default request: 'Enter a new file name'						initialAnswer:  fullFileName.		^ self oldFileNamed:			(self fullName: newName)].	selection = 3 ifTrue: [^ debugBlock value].	self halt! !!StandardFileStream class methodsFor: 'error handling' stamp: 'mtf 1/20/2011 14:12'!fileExistsUserHandling: fullFileName ifDebug: debugBlock	| dir localName choice newName newFullFileName |	dir := FileDirectory forFileName: fullFileName.	localName := FileDirectory localNameFor: fullFileName.	choice := (UIManager default 		chooseFrom: #('overwrite that file' 'append (risky!!!!)' 'choose another name' 'debug' 'cancel')		title: localName, ' already exists.').	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fullFileName forWrite: true].	choice = 2 ifTrue: [		^ (self new open: fullFileName forWrite: true) setToEnd].	choice = 3 ifTrue: [		newName := UIManager default request: 'Enter a new file name' initialAnswer: fullFileName.		newFullFileName := self fullName: newName.		^ self newFileNamed: newFullFileName].	choice = 4 ifTrue: [^ debugBlock value].	self error: 'Please close this to abort file opening'! !!StandardFileStream class methodsFor: 'error handling' stamp: 'mtf 1/20/2011 14:13'!readOnlyFileDoesNotExistUserHandling: fullFileName ifDebug: debugBlock	| dir files choices selection newName fileName |	dir := FileDirectory forFileName: fullFileName.	files := dir fileNames.	fileName := FileDirectory localNameFor: fullFileName.	choices := fileName correctAgainst: files.	choices add: 'Choose another name'.	choices add: 'Debug'.	choices add: 'Cancel'.	selection := UIManager default chooseFrom: choices lines: (Array with: 5)		title: (FileDirectory localNameFor: fullFileName), 'does not exist.'.	selection = choices size ifTrue:["cancel" ^ nil "should we raise another exception here?"].	selection < (choices size - 1) ifTrue: [		newName := (dir pathName , FileDirectory slash , (choices at: selection))].	selection = (choices size - 2) ifTrue: [		newName := UIManager default 							request: 'Enter a new file name' 							initialAnswer: fileName].	selection = (choices size - 1) ifTrue: [^ debugBlock value].	newName = '' ifFalse: [^ self readOnlyFileNamed: (self fullName: newName)].	^ self error: 'Could not open a file'! !!FileDoesNotExistException methodsFor: 'exceptionDescription' stamp: 'mtf 1/20/2011 14:16' prior: 58594890!defaultAction	"The default action taken if the exception is signaled."	^self readOnly		ifTrue: [StandardFileStream readOnlyFileDoesNotExistUserHandling: self fileName			ifDebug: [super defaultAction]]		ifFalse: [StandardFileStream fileDoesNotExistUserHandling: self fileName			ifDebug: [super defaultAction]]! !!DirectoryEntry methodsFor: 'access' stamp: 'cmm 1/25/2011 13:16'!size	"For API compatibility with byte objects (for streaming api)."	^ self fileSize! !!FileExistsException methodsFor: 'exceptionDescription' stamp: 'mtf 1/20/2011 14:17' prior: 58595720!defaultAction	"The default action taken if the exception is signaled."	^ self fileClass fileExistsUserHandling: self fileName ifDebug: [super defaultAction]! !StandardFileStream class removeSelector: #readOnlyFileDoesNotExistUserHandling:!StandardFileStream class removeSelector: #fileExistsUserHandling:!StandardFileStream class removeSelector: #fileDoesNotExistUserHandling:!"Files"!!LayoutFrame commentStamp: '<historical>' prior: 22534882!I define a frame for positioning some morph in a proportional layout.Instance variables:	leftFraction 	topFraction 	rightFraction 	bottomFraction 	<Float>		The fractional distance (between 0 and 1) to place the morph in its owner's bounds	leftOffset 	topOffset 	rightOffset 	bottomOffset 	<Integer>	Fixed pixel offset to apply after fractional positioning (e.g., "10 pixel right of the center of the owner")!!StrikeFont commentStamp: '<historical>' prior: 29998357!I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the glyphs. Characters are mapped to glyphs by using the characterToGyphMap.Subclasses can have non-trivial mapping rules as well as different representations for glyphs sizes (e.g., not using an xTable). If so, these classes should return nil when queried for xTable and/or the characterToGlyphMap. This will cause the CharacterScanner primitive to fail and query the font for the width of a character (so that a more programatical approach can be implemented).For display, fonts need to implement two messages:	#installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColorThis method installs the receiver (a font) on the given DisplayContext (which may be an instance of BitBlt or Canvas (or any of it's subclasses). The font should take the appropriate action to initialize the display context so that further display operations can be optimized.	#displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDeltaThis method is called for each subsequent run of characters in aString which is to be displayed with the (previously installed) settings.!!DisplayScanner methodsFor: 'scanning' stamp: 'mtf 12/30/2010 23:37' prior: 50948236!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	(anchoredMorph isMorph or: [anchoredMorph isPrimitiveCostume]) ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY := lineY.		runX := destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect	].	^ true! !!Form class methodsFor: 'examples' stamp: 'nice 12/29/2010 16:55' prior: 55109751!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors := Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade := Form extent: diam@diam offset: (diam // -2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam // 2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x * diam // 5) displayOn: facade			at: (diam * 2 // 5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball := Form dotOfSize: diam.	color := 8.	[ true ] whileTrue:		[port := BitBlt current toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue := OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20 @ -20].		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter := Sensor cursorPoint.		colr := colors atWrap: (color := color + 5).  "choose increment relatively prime to colors size"		colr2 := colr alphaMixed: 0.3 with: Color white.		[Sensor redButtonPressed or: [queue size > 0]] whileTrue:			[filter := filter * 4 + Sensor cursorPoint  //  5.			point := Sensor redButtonPressed				ifTrue: [filter] ifFalse: [-20 @ -20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q := queue removeFirst) == nil ifTrue: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor redButtonPressed ifTrue: [queue addLast: point]]].! !!Form class methodsFor: 'examples' stamp: 'nice 12/29/2010 16:55' prior: 55106923!xorHack: size  "Display restoreAfter: [Form xorHack: 256]"	"Draw a smiley face or stick figure, and end with option-click.	Thereafter image gets 'processed' as long as you have button down.	If you stop at just the right time, you'll see you figure upside down,	and at the end of a full cycle, you'll see it perfectly restored.	Dude -- this works in color too!!"	| rect form i bb |	rect := 5 @ 5 extent: size @ size.	Display fillWhite: rect; border: (rect expandBy: 2) width: 2.	Display border: (rect topRight - (0 @ 2) extent: rect extent * 2 + 4) width: 2.	Form exampleSketch.	form := Form fromDisplay: rect.	bb := form boundingBox.	i := 0.	[Sensor yellowButtonPressed] whileFalse:		[[Sensor redButtonPressed] whileTrue:			[i := i + 1.			(Array with: 0 @ 1 with: 0 @ -1 with: 1 @ 0 with: -1 @ 0) do:				[:d | form copyBits: bb from: form at: d					clippingBox: bb rule: Form reverse fillColor: nil].			form displayAt: rect topLeft.			i+2\\size < 4 ifTrue: [(Delay forMilliseconds: 300) wait]].		(form magnify: form boundingBox by: 2 @ 2) displayAt: rect topRight + (2 @ 0).		Sensor waitButton].! !!Form methodsFor: 'filling' stamp: 'nice 12/29/2010 14:44' prior: 51186190!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	self depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all := self boundingBox.	smearForm := Form extent: self extent.	smearPort := BitBlt current toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0 @ 0 rule: Form erase.  "Clear any in black"	previousSmear := smearForm deepCopy.	count := 1.	[count = 10 and:   "check for no change every 10 smears"		[count := 1.		previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1 @ 0 rule: Form under.			smearPort copyForm: smearForm to: -1 @ 0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			smearPort copyForm: smearForm to: 0 @ 1 rule: Form under.			smearPort copyForm: smearForm to: 0 @ -1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0 @ 0 rule: Form erase.			count := count + 1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0 @ 0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: 'transitions' stamp: 'nice 12/29/2010 14:46' prior: 51225309!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect |	stepSize := 10.	bb := otherImage boundingBox.	resultForm := self copy: (topLeft extent: bb extent).	maskForm := Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc := starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta := 1 @ 0.					maskLoc := bb topLeft - (corner = 1						ifTrue: [maskForm width @ 0]						ifFalse: [maskForm width @ stepSize])]					ifFalse:					["motion is to the left"					delta := -1 @ 0.					maskLoc := bb topRight - (corner = 2						ifTrue: [0 @ 0]						ifFalse: [0 @ stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta := 0 @ 1.					maskLoc := bb topLeft - (corner = 1						ifTrue: [0 @ maskForm height]						ifFalse: [stepSize @ maskForm height])]					ifFalse:					["motion is upward"					delta := 0 @ -1.					maskLoc := bb bottomLeft - (corner = 3						ifTrue: [stepSize @ 0]						ifFalse: [0 @ 0])]].	"Build a solid triangle in the mask form"	(Pen newOnForm: maskForm) in: [:p |		corner even  "Draw 45-degree line"			ifTrue: [p place: 0 @ 0; turn: 135; go: maskForm width * 3 // 2]			ifFalse: [p place: 0 @ (maskForm height - 1); turn: 45; go: maskForm width * 3 // 2]].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm := (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0 @ 0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel := #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize) + 1 do:		[:i |		"Determine the affected square"		maskRect := (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x * delta x) + (maskLoc y * delta y)) < 0 ifTrue:			[smallRect := 0 @ 0 extent: (maskRect width min: maskRect height) asPoint.			maskRect := smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0 @ 0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc := maskLoc + (delta * stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'ul 1/9/2011 14:19' prior: 33692473!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| base bits bytesLeft word |	bitsPerChannel = 16 ifTrue: [		"Warning: This is extremely slow. Besides we are downsampling to 8 bits!!"		| blitter |		blitter := BitBlt current bitPokerToForm: form.		0 to: width - 1 do: [ :x |			blitter pixelAt: x @ y put: 255 - (thisScanline at: x * 2 + 1) ].			^self ].	"Just copy the bits"	"This Smalltalk version might be easier to understand than the others below."	base := y * form width * bitsPerChannel // 32 + 1.	bits := form bits.	0 to: thisScanline size // 4 - 1 do: [ :i |		| ii |		ii := i * 4.		"This somewhat weird mixture of (#* and #+) with (#bitShift: and #bitOr:) 		is to make use of faster arithmetic bytecodes, but not of slow largeintegers."		word :=			(((thisScanline at: ii + 1) * 256 + 			(thisScanline at: ii + 2) * 256 + 			(thisScanline at: ii + 3)) bitShift: 8) bitOr: 			(thisScanline at: ii + 4).		bits at: base + i put: word ].		(bytesLeft := thisScanline size bitAnd: 3) = 0 ifFalse: [		word := 0.		thisScanline size - bytesLeft + 1 to: thisScanline size do: [ :ii |			word := word * 256 + (thisScanline at: ii) ].		word := word bitShift: 8 * (4 - bytesLeft).		bits at: base + (thisScanline size // 4) put: word ].	"This interesting technique (By Andreas Raab) is faster for very large images, but might be slower for small ones"	"^self copyPixelsGrayWeirdBitBltHack: y ".	"It uses the following method:	PNGReadWriter >> copyPixelsGrayWeirdBitBltHack: y 	""Handle non-interlaced black and white color mode (colorType = 0)	By Andreas Raab""		| source dest cmap |	source := Form extent: 1 @ (thisScanline size // 4) depth: 32 bits: thisScanline.	dest := Form extent: 1 @ (form bits size) depth: 32 bits: form bits.	cmap := Smalltalk isLittleEndian		ifTrue:[ColorMap 					shifts: #(-24 -8 8 24) 					masks: #(16rFF000000 16r00FF0000 16r0000FF00 16r000000FF)].	(BitBlt toForm: dest)		sourceForm: source;		destX: 0 destY: (y * form width*bitsPerChannel//32) width: 1 height: (form width+31*bitsPerChannel//32);		colorMap: cmap;		combinationRule: 3;		copyBits."			"This interesting technique  (By Yoshiki Ohshima) is faster for very large images, but might be slower for small ones"	"form bits copyFromByteArray2: thisScanline to: y * (form width* bitsPerChannel // 32)".	"It uses the following method:	BitMap >> copyFromByteArray2: byteArray to: i	""This method should work with either byte orderings""	| myHack byteHack |	myHack := Form new hackBits: self.	byteHack := Form new hackBits: byteArray.	Smalltalk  isLittleEndian ifTrue: [byteHack swapEndianness].	byteHack displayOn: myHack at:  0@i"! !!Point methodsFor: 'point functions' stamp: 'nice 12/29/2010 15:07' prior: 26561588!eightNeighbors	^ (Array with: self + (1 @ 0)		with: self + (1 @ 1)		with: self + (0 @ 1)		with: self + (-1 @ 1)) ,	(Array with: self + (-1 @ 0)		with: self + (-1 @ -1)		with: self + (0 @ -1)		with: self + (1 @ -1))! !!Point methodsFor: 'point functions' stamp: 'nice 12/29/2010 14:57' prior: 26562214!fourNeighbors	^ Array with: self + (1 @ 0)		with: self + (0 @ 1)		with: self + (-1 @ 0)		with: self + (0 @ -1)! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57' prior: 55128942!initBottomLeft	BottomLeftCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1111111111111111		2r1111111111111111)			offset: 0 @ -16).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57' prior: 55115258!initBottomRight	BottomRightCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16 @ -16).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57' prior: 55122432!initCorner	CornerCursor := 		(Cursor 			extent: 16 @ 16			fromArray: #(		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r1111111111111111		2r1111111111111111)			offset: -16 @ -16).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57' prior: 55123355!initCrossHair	CrossHairCursor :=   		(Cursor			extent: 16 @ 16			fromArray: #(		2r0000000000000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0111111111111100		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000000000000		2r0)			offset: -7 @ -7).		! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57' prior: 55116546!initDown	DownCursor  :=		     (Cursor	extent: 16 @ 16	fromArray: #(		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r1111110000000000		2r111100000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57' prior: 55119891!initMarker	MarkerCursor := 		Cursor			extent: 16 @ 16			fromArray: #(		2r0111000000000000		2r1111100000000000		2r1111100000000000		2r0111000000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)			offset: 0 @ 0.! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:57' prior: 55124683!initMenu 	MenuCursor  :=		        (Cursor	extent: 16 @ 16	fromArray: #(		2r1111111111100000		2r1000000000100000		2r1010011000100000		2r1000000000100000		2r1101001101100000		2r1111111111100000		2r1000000000100000		2r1011001010100000		2r1000000000100000		2r1010110010100000		2r1000000000100000		2r1010010100100000		2r1000000000100000		2r1111111111100000		0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58' prior: 55125683!initMove	MoveCursor := 		Cursor 			extent: 16 @ 16			fromArray: #(		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1100001100001100		2r1111111111111100		2r1111111111111100          0)			offset: 0 @ 0.! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58' prior: 55125152!initNormal	NormalCursor :=   		(Cursor			extent: 16 @ 16			fromArray: #(		2r1000000000000000		2r1100000000000000		2r1110000000000000		2r1111000000000000		2r1111100000000000		2r1111110000000000		2r1111111000000000		2r1111100000000000		2r1111100000000000		2r1001100000000000		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0 @ 0).		! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58' prior: 55118338!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor := CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor := (CursorWithMask extent: 16 @ 16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1 @ -1)		setMaskForm: (Form extent: 16 @ 16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:58' prior: 55121922!initOrigin	OriginCursor :=   		(Cursor			extent: 16 @ 16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55126505!initRead	ReadCursor :=  		(Cursor			extent: 16 @ 16			fromArray: #(		2r0000000000000000		2r0000000000000000		2r0001000000001000		2r0010100000010100		2r0100000000100000		2r1111101111100000		2r1000010000100000		2r1000010000100000		2r1011010110100000		2r0111101111000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55115795!initResizeLeft       ResizeLeftCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000100000010000               2r0001100000011000               2r0011100000011100               2r0111111111111110               2r0011100000011100               2r0001100000011000               2r0000100000010000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000               2r0000000000000000 )       offset: -7 @ -7 ) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55126936!initResizeTop    "Cursor initResizeTop"       ResizeTopCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r000000100000000               2r000001110000000               2r000011111000000               2r000111111100000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000000100000000               2r000111111100000               2r000011111000000               2r000001110000000               2r000000100000000               2r000000000000000)       offset: -7 @ -7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55120761!initResizeTopLeft       ResizeTopLeftCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r0000000000000000               2r0111110000000000               2r0111100000000000               2r0111000000000000               2r0110100000000000               2r0100010000000000               2r0000001000000000               2r0000000100000000               2r0000000010000000               2r0000000001000100               2r0000000000101100               2r0000000000011100               2r0000000000111100               2r0000000001111100               2r0000000000000000               2r0000000000000000)       offset: -7 @ -7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55128165!initResizeTopRight       ResizeTopRightCursor :=               (Cursor extent: 16 @ 16 fromArray: #(               2r0000000000000000               2r0000000001111100               2r0000000000111100               2r0000000000011100               2r0000000000101100               2r0000000001000100               2r0000000010000000               2r0000000100000000               2r0000001000000000               2r0100010000000000               2r0110100000000000               2r0111000000000000               2r0111100000000000               2r0111110000000000               2r0000000000000000               2r0000000000000000)       offset: -7 @ -7) withMask! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55117472!initRightArrow 	RightArrowCursor  :=		      (Cursor	extent: 16 @ 16	fromArray: #(		2r100000000000		2r111000000000		2r1111111110000000		2r111000000000		2r100000000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).		"Cursor initRightArrow"! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55126156!initSquare	SquareCursor := 		(Cursor			extent: 16 @ 16			fromArray: #(		2r0		2r0		2r0		2r0		2r0		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0000001111000000		2r0		2r0		2r0		2r0		2r0		2r0		2r0)	offset: -8 @ -8).	! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 16:59' prior: 55120237!initTopLeft	TopLeftCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000		2r1100000000000000)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00' prior: 55116962!initTopRight	TopRightCursor := 		(Cursor extent: 16 @ 16			fromArray: #(		2r1111111111111111		2r1111111111111111		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011		2r0000000000000011)			offset: -16 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00' prior: 55122945!initUp	UpCursor := 		    (Cursor	extent: 16 @ 16	fromArray: #(		2r11000000000000		2r111100000000000		2r1111110000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r11000000000000		2r0		2r0		2r0		2r0		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00' prior: 55127679!initWait	WaitCursor := 		  (Cursor			extent: 16 @ 16			fromArray: #(		2r1111111111111100		2r1000000000000100		2r0100000000001000		2r0010000000010000		2r0001110011100000		2r0000111111000000		2r0000011110000000		2r0000011110000000		2r0000100101000000		2r0001000100100000		2r0010000110010000		2r0100001111001000		2r1000111111110100		2r1111111111111100		0)			offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00' prior: 55117853!initWrite	WriteCursor := (Cursor	extent: 16 @ 16	fromArray: #(		2r0000000000011000		2r0000000000111100		2r0000000001001000		2r0000000010010000		2r0000000100100000		2r0000001001000100		2r0000010010000100		2r0000100100001100		2r0001001000010000		2r0010010000010000		2r0111100000001000		2r0101000011111000		2r1110000110000000		2r0111111100000000		2r0		2r0)	offset: 0 @ 0).! !!Cursor class methodsFor: 'class initialization' stamp: 'nice 12/29/2010 17:00' prior: 55123861!initXeq	XeqCursor := 		(Cursor			extent: 16 @ 16			fromArray: #(		2r1000000000010000		2r1100000000010000		2r1110000000111000		2r1111000111111111		2r1111100011000110		2r1111110001000100		2r1111111001111100		2r1111000001101100		2r1101100011000110		2r1001100010000010		2r0000110000000000		2r0000110000000000		2r0000011000000000		2r0000011000000000		2r0000001100000000		2r0000001100000000)	offset: 0 @ 0).! !!LayoutFrame class methodsFor: 'accessing' stamp: 'JW 2/1/2001 12:48' prior: 22540651!classVersion	^1 "changed treatment of bottomOffset and rightOffset"! !!LayoutFrame class methodsFor: 'instance creation' stamp: 'ar 2/5/2002 00:07' prior: 22540805!fractions: fractionsOrNil	^self fractions: fractionsOrNil offsets: nil! !!LayoutFrame class methodsFor: 'instance creation' stamp: 'RAA 1/8/2001 21:22' prior: 55891792!fractions: fractionsOrNil offsets: offsetsOrNil	| fractions offsets |	fractions := fractionsOrNil ifNil: [0@0 extent: 0@0].	offsets := offsetsOrNil ifNil: [0@0 extent: 0@0].	^self new		topFraction: fractions top offset: offsets top;		leftFraction: fractions left offset: offsets left;		bottomFraction: fractions bottom offset: offsets bottom;		rightFraction: fractions right offset: offsets right! !!LayoutFrame class methodsFor: 'instance creation' stamp: 'ar 2/5/2002 20:06' prior: 22541450!offsets: offsetsOrNil	^self fractions: nil offsets: offsetsOrNil! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 22535370!bottomFraction	^bottomFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 51548710!bottomFraction: aNumber	bottomFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 51546287!bottomFraction: aNumber offset: anInteger	bottomFraction := aNumber.	bottomOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 22535761!bottomOffset	^bottomOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 51546955!bottomOffset: anInteger	bottomOffset := anInteger! !!LayoutFrame methodsFor: 'objects from disk' stamp: 'JW 2/1/2001 13:33' prior: 22539814!convertToCurrentVersion: varDict refStream: smartRefStrm	| className oldClassVersion |	"JW 2/1/2001"	"Since class version isn't passed in varDict, look it up through smartRefSrm."	className := varDict at: #ClassName.	oldClassVersion := (smartRefStrm structures at: className) first.	(oldClassVersion = 0) ifTrue: [ self negateBottomRightOffsets ].	^super convertToCurrentVersion: varDict refStream: smartRefStrm.! !!LayoutFrame methodsFor: 'layout' stamp: 'JW 2/1/2001 13:04' prior: 51547355!layout: oldBounds in: newBounds	"Return the proportional rectangle insetting the given bounds"	| left right top bottom |	leftFraction ifNotNil:[		left := newBounds left + (newBounds width * leftFraction).		leftOffset ifNotNil:[left := left + leftOffset]].	rightFraction ifNotNil:[		right := newBounds right - (newBounds width * (1.0 - rightFraction)).		rightOffset ifNotNil:[right := right + rightOffset]].	topFraction ifNotNil:[		top := newBounds top + (newBounds height * topFraction).		topOffset ifNotNil:[top := top + topOffset]].	bottomFraction ifNotNil:[		bottom := newBounds bottom - (newBounds height * (1.0 - bottomFraction)).		bottomOffset ifNotNil:[bottom := bottom + bottomOffset]].	left ifNil:[ right 			ifNil:[left := oldBounds left. right := oldBounds right]			ifNotNil:[left := right - oldBounds width]].	right ifNil:[right := left + oldBounds width].	top ifNil:[ bottom 			ifNil:[top := oldBounds top. bottom := oldBounds bottom]			ifNotNil:[top := bottom - oldBounds height]].	bottom ifNil:[bottom := top + oldBounds height].	^(left rounded @ top rounded) corner: (right rounded @ bottom rounded)! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 22535981!leftFraction	^leftFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 51547092!leftFraction: aNumber	leftFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 51546646!leftFraction: aNumber offset: anInteger	leftFraction := aNumber.	leftOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:35' prior: 22536358!leftOffset	^leftOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 51546154!leftOffset: anInteger	leftOffset := anInteger! !!LayoutFrame methodsFor: 'layout' stamp: 'ml 10/4/2009 15:18' prior: 53309406!minExtentFrom: minExtent	"Return the minimal extent the given bounds can be represented in"	| width height left right top bottom |	left := leftFraction ifNil: [0.0].	right := rightFraction ifNil: [1.0].	width := left = right		ifTrue: [0]		ifFalse: [minExtent x / (right - left)].	top := topFraction ifNil: [0.0].	bottom := bottomFraction ifNil: [1.0].	height := bottom = top		ifTrue: [0]		ifFalse: [minExtent y / (bottom - top)].	leftOffset ifNotNil:[width := width + leftOffset].	rightOffset ifNotNil:[width := width + rightOffset].	topOffset ifNotNil:[height := height + topOffset].	bottomOffset ifNotNil:[height := height + bottomOffset].	^width truncated @ height truncated! !!LayoutFrame methodsFor: 'objects from disk' stamp: 'JW 2/1/2001 14:37' prior: 22540313!negateBottomRightOffsets	bottomOffset ifNotNil: [ bottomOffset := bottomOffset negated ].	rightOffset ifNotNil: [ rightOffset := rightOffset negated ].! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 22536570!rightFraction	^rightFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 51548847!rightFraction: aNumber	rightFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 51548982!rightFraction: aNumber offset: anInteger	rightFraction := aNumber.	rightOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 22536954!rightOffset	^rightOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 51547225!rightOffset: anInteger	rightOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 22537170!topFraction	^topFraction! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:36' prior: 51546824!topFraction: aNumber	topFraction := aNumber! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37' prior: 51546471!topFraction: aNumber offset: anInteger	topFraction := aNumber.	topOffset := anInteger! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37' prior: 22537540!topOffset	^topOffset! !!LayoutFrame methodsFor: 'accessing' stamp: 'ar 10/23/2000 19:37' prior: 51548579!topOffset: anInteger	topOffset := anInteger! !!StrikeFont methodsFor: 'displaying' stamp: 'nice 12/29/2010 15:12' prior: 52659288!displayMultiString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta baselineY: baselineY	| leftX rightX glyphInfo char destY form gfont destX destPt |	destX := aPoint x.	glyphInfo := Array new: 5.	startIndex to: stopIndex do:[:charIndex|		char := aString at: charIndex.		(self hasGlyphOf: char) ifTrue: [			self glyphInfoOf: char into: glyphInfo.			form := glyphInfo at: 1.			leftX := glyphInfo at: 2.			rightX := glyphInfo at: 3.			destY := glyphInfo at: 4.			gfont := glyphInfo at: 5.			(gfont == aBitBlt lastFont) ifFalse: [gfont installOn: aBitBlt].			destY := baselineY - destY. 			aBitBlt displayGlyph: form at: destX @ destY left: leftX right: rightX font: self.			destX := destX + (rightX - leftX + kernDelta).		] ifFalse:[			destPt := self fallbackFont displayString: aString on: aBitBlt from: charIndex to: charIndex at: destX @ aPoint y kern: kernDelta from: self baselineY: baselineY.			destPt x = destX ifTrue:[				"In some situations BitBlt doesn't return the advance width from the primitive.				Work around the situation"				destX := destX + (self widthOfString: aString from: charIndex to: charIndex) + kernDelta.			] ifFalse:[destX := destPt x].		].	].	^destX @ aPoint y! !"Graphics"!!PNGReadWriterTest methodsFor: 'tests - grayscale' stamp: 'ar 1/7/2011 16:47'!grayScaleData	^#[137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 217 0 0 0 125 8 0 0 0 0 10 88 153 82 0 0 0 9 112 72 89 115 0 0 46 35 0 0 46 35 1 120 165 63 118 0 0 0 25 116 69 88 116 83 111 102 116 119 97 114 101 0 71 114 97 112 104 105 99 67 111 110 118 101 114 116 101 114 53 93 72 238 0 0 63 7 73 68 65 84 120 156 60 157 231 219 149 229 185 230 215 95 54 31 230 195 124 216 51 31 230 216 199 236 157 61 123 103 103 18 99 108 168 8 8 22 20 5 84 236 141 88 177 196 94 208 152 144 196 96 143 26 11 193 10 22 66 135 183 175 254 244 190 214 156 191 243 126 179 73 132 151 183 172 245 220 247 213 206 235 188 10 189 186 168 170 50 143 202 186 40 139 188 44 170 52 202 202 178 204 147 156 95 233 52 41 202 50 73 179 52 207 146 162 200 244 45 121 154 100 121 158 69 73 170 47 229 250 106 94 132 255 23 117 93 150 117 153 87 188 80 93 232 239 85 173 95 237 172 155 205 102 93 93 181 179 186 174 74 125 87 211 54 101 93 53 115 125 174 206 171 174 109 42 189 72 91 86 85 221 232 59 42 125 196 7 117 147 234 57 170 58 171 91 253 81 232 135 138 162 210 111 101 86 100 85 174 71 200 139 113 214 53 250 177 166 214 227 165 105 89 100 81 166 199 76 227 52 206 245 20 61 189 70 161 151 170 202 76 79 92 214 117 94 242 250 89 158 230 58 103 25 39 89 90 86 58 77 146 37 185 78 158 234 117 245 165 34 142 146 188 214 171 103 133 206 145 233 157 243 84 191 235 98 242 166 173 219 34 43 234 174 210 155 242 152 77 85 119 109 221 116 250 206 170 214 49 244 215 78 103 110 121 250 178 158 207 218 174 110 245 120 85 195 167 187 121 173 215 107 91 253 176 158 94 151 174 63 42 253 209 240 104 109 211 148 89 206 179 54 122 99 93 146 174 175 173 253 88 105 230 7 45 219 34 65 4 149 206 212 107 138 188 41 117 137 105 174 47 148 89 150 85 92 94 85 21 69 82 228 250 190 92 130 42 36 42 164 209 212 69 154 164 121 82 164 113 145 228 250 246 138 179 233 107 117 61 235 114 30 38 65 1 242 70 143 220 116 141 94 37 47 103 8 165 104 91 100 216 112 139 58 171 158 167 229 44 28 70 114 104 234 118 222 116 179 170 208 179 235 154 106 158 76 207 90 242 186 200 151 195 232 7 83 235 130 78 174 255 161 80 69 169 23 214 109 234 100 185 78 44 173 209 195 114 215 89 174 51 84 61 189 99 86 101 72 72 146 202 120 46 233 76 149 102 186 139 148 211 115 176 84 178 214 161 37 43 157 51 207 82 125 119 50 201 16 112 93 205 106 30 85 199 206 234 88 247 33 65 233 141 245 25 190 214 234 127 149 245 76 18 210 81 185 131 70 58 166 3 150 18 170 78 82 233 249 218 118 222 181 237 76 247 208 213 146 147 213 181 46 248 64 103 71 63 83 201 76 79 208 73 157 139 84 111 167 59 47 37 33 174 15 181 211 137 177 25 217 9 151 167 7 229 49 235 166 151 38 21 34 214 15 21 146 130 100 164 31 208 35 235 171 5 191 202 18 77 172 244 123 156 235 50 98 29 75 74 61 149 50 164 121 43 165 242 91 151 153 68 46 115 40 11 61 100 215 205 154 90 234 89 73 104 24 113 37 97 20 133 62 70 21 244 3 216 139 14 134 213 249 200 210 188 86 191 244 149 153 180 176 104 106 148 65 111 169 239 148 21 233 202 56 96 35 49 232 198 179 12 77 146 121 22 165 244 182 233 116 30 9 178 144 141 84 178 0 73 65 191 149 136 70 191 122 210 184 52 139 147 28 51 201 82 20 8 253 66 46 5 158 196 174 67 247 16 69 73 33 169 101 69 154 75 197 36 72 92 71 202 83 202 176 234 22 29 41 75 252 68 105 249 112 227 250 6 233 219 108 214 234 8 57 114 168 202 174 171 155 245 51 52 146 83 45 223 50 111 249 75 163 43 169 103 250 80 26 134 234 97 99 82 96 217 107 37 93 148 118 99 13 58 180 84 94 199 205 107 95 106 137 2 36 145 174 94 14 33 168 32 254 69 223 35 177 198 61 93 126 150 22 153 252 137 196 139 109 234 17 27 29 33 139 211 52 145 73 201 113 72 117 37 194 240 167 156 80 60 73 248 75 102 149 225 29 42 180 64 198 90 97 172 24 67 163 235 211 33 91 108 13 239 49 147 15 233 176 43 188 101 163 47 84 221 124 214 149 109 51 235 100 106 250 99 54 171 176 68 73 64 15 155 164 149 191 201 183 38 125 70 109 80 112 233 111 170 63 229 44 185 159 146 43 45 100 7 56 197 44 79 36 206 90 226 145 177 72 89 80 174 158 180 67 111 161 39 229 170 164 249 109 42 197 228 209 165 80 114 58 73 142 93 224 252 228 82 82 238 165 64 102 114 59 114 200 5 110 85 150 84 117 250 42 214 35 123 208 125 206 26 255 77 162 171 117 92 73 166 225 84 122 74 29 172 226 127 168 161 132 169 195 235 212 157 62 148 104 187 134 215 147 54 54 21 111 41 171 215 31 237 172 138 48 83 124 110 97 207 218 58 34 72 108 58 143 28 98 41 203 180 191 86 28 138 101 38 182 49 93 110 86 53 189 92 58 38 237 66 67 241 162 57 78 3 71 131 138 22 232 164 52 55 145 139 199 7 197 250 77 119 35 227 225 5 244 136 133 148 79 98 148 115 195 157 183 45 110 223 62 166 64 92 62 155 159 164 34 148 200 127 206 229 39 248 172 98 156 162 130 252 94 83 52 243 217 92 26 57 215 247 207 91 206 47 87 215 38 122 193 182 180 33 85 184 100 253 180 254 170 31 181 167 41 43 91 96 101 39 170 183 147 215 196 173 72 251 185 249 26 101 212 35 72 27 243 56 138 226 4 53 226 187 36 224 105 174 120 145 37 82 223 42 74 9 126 153 5 88 96 94 24 97 162 231 212 9 66 160 209 241 116 196 86 10 192 215 10 105 82 91 32 229 172 236 80 54 61 246 220 17 64 122 217 160 146 250 189 241 241 240 169 86 75 125 75 87 215 82 78 226 91 219 149 196 159 188 180 152 245 157 82 233 154 215 199 227 204 136 17 122 115 29 184 80 192 200 4 13 164 38 86 255 146 0 29 167 85 147 16 3 106 69 175 30 232 33 35 74 103 114 228 114 240 120 53 169 109 146 232 176 82 71 137 25 107 174 9 26 224 12 20 87 94 165 198 17 162 153 232 155 222 187 157 149 252 129 7 196 151 128 22 176 2 28 136 92 136 78 52 107 132 65 90 57 206 198 214 37 83 147 228 100 100 122 224 182 155 235 59 116 228 153 67 130 224 134 244 85 119 80 206 192 47 4 121 105 106 133 158 34 163 86 2 150 141 234 137 244 26 188 108 83 88 117 209 196 12 149 233 28 7 132 65 164 99 130 20 41 110 222 255 21 145 62 19 71 177 156 141 148 42 199 137 148 33 92 151 118 153 246 171 165 111 85 81 9 156 129 171 208 155 180 4 96 28 155 222 166 210 89 48 122 65 40 61 54 209 74 15 63 7 103 233 80 64 173 121 55 215 67 87 252 133 255 228 70 90 84 26 219 147 150 251 136 18 134 60 109 91 119 246 163 120 168 146 240 97 12 160 179 128 209 112 34 29 65 84 6 144 241 101 233 10 120 163 136 147 164 234 101 113 44 207 32 215 40 87 152 130 34 164 131 178 47 73 151 184 163 19 19 7 228 63 9 91 141 156 159 180 76 162 43 179 74 223 67 120 174 237 149 195 173 2 147 0 114 82 53 125 66 62 92 242 144 196 90 43 101 39 19 33 38 72 76 18 153 14 83 235 204 157 108 12 209 203 76 137 178 182 86 66 182 34 66 41 29 112 180 152 241 19 104 174 78 135 55 212 71 210 123 124 137 52 6 167 152 33 2 67 87 121 78 157 74 113 77 31 244 112 68 57 64 50 194 210 244 125 58 96 146 130 129 117 68 148 84 33 12 172 5 114 64 82 120 35 194 134 14 32 228 198 235 43 138 42 124 241 129 62 39 237 234 128 55 210 182 57 215 170 131 204 187 74 231 210 17 237 3 106 116 11 143 131 35 153 181 185 173 105 102 137 84 242 42 188 6 202 37 177 128 83 112 171 45 242 105 106 159 53 151 128 117 196 188 201 8 144 168 103 6 12 43 109 186 58 81 139 12 112 110 93 133 7 145 184 120 218 178 72 195 119 18 28 237 153 227 52 18 192 228 82 164 21 122 175 128 35 116 63 13 247 165 3 129 211 137 59 220 150 68 36 76 85 18 214 64 148 210 57 249 46 73 165 33 150 73 104 109 109 4 34 73 148 21 242 227 113 165 168 82 71 105 1 199 147 221 224 33 245 7 86 136 67 234 16 160 30 16 191 163 91 64 126 146 177 4 206 115 0 238 136 223 121 33 128 167 71 111 65 240 160 75 32 178 132 212 83 160 200 171 36 202 35 61 32 185 75 34 239 160 180 64 87 200 121 37 178 56 6 110 228 132 101 66 41 146 210 203 212 120 39 105 84 229 208 133 182 3 191 109 250 14 184 242 0 194 91 8 6 55 160 35 160 160 126 106 108 102 102 191 201 111 51 194 157 62 39 81 181 150 111 199 201 101 41 128 40 2 25 248 223 82 174 67 164 39 238 201 154 117 92 236 204 209 49 195 101 17 115 185 59 20 44 210 1 243 94 66 190 149 26 135 100 83 185 196 60 49 156 207 201 121 192 82 248 16 253 16 225 41 199 145 148 89 139 98 115 90 240 131 28 0 22 66 222 65 94 165 247 84 248 67 193 249 164 110 184 1 63 73 80 115 43 164 149 10 169 117 184 20 158 83 150 6 10 169 192 92 224 21 97 42 190 39 199 17 53 225 201 107 50 59 61 117 137 229 18 45 228 52 133 144 20 130 65 44 96 54 233 56 166 200 183 234 72 121 36 11 82 164 86 72 78 39 49 8 57 75 226 204 40 12 89 145 203 233 120 134 43 117 155 3 52 50 206 156 17 6 101 199 96 52 93 100 5 134 69 48 133 190 75 202 39 157 211 43 37 8 205 38 213 234 68 210 72 169 146 68 164 223 20 150 113 41 85 135 106 99 70 114 153 122 41 125 192 189 8 114 228 160 94 14 69 150 64 120 183 117 206 219 162 227 170 244 134 92 49 41 105 73 220 146 64 157 152 18 10 113 6 25 169 134 174 86 62 73 145 90 170 26 147 85 74 94 184 85 80 175 48 115 138 220 10 231 175 149 35 134 238 68 126 50 96 4 224 31 191 203 3 233 203 149 197 89 32 52 125 34 33 125 226 35 251 228 178 153 227 236 241 129 198 135 5 2 146 189 72 12 122 108 156 167 238 162 5 193 212 101 64 89 216 99 229 240 47 175 18 144 167 36 143 230 131 83 74 46 169 108 34 69 218 18 148 88 149 14 161 149 128 130 110 67 8 17 71 36 76 168 103 232 233 217 21 139 35 66 88 129 246 161 130 66 35 81 106 45 205 184 14 116 217 25 8 24 181 112 206 109 43 176 251 18 212 144 247 81 92 193 121 40 142 203 253 98 8 24 149 164 3 136 212 31 115 100 37 180 33 35 170 13 44 90 112 61 183 47 113 129 25 21 219 106 190 153 108 175 66 43 117 37 138 204 138 103 133 51 64 194 122 3 194 183 104 37 38 204 65 169 14 41 69 5 58 111 200 90 101 243 13 135 16 84 74 242 94 154 70 83 41 153 224 174 66 152 66 27 25 52 180 71 170 80 157 34 95 52 89 65 132 60 162 117 34 85 241 201 198 70 160 67 192 80 232 221 138 12 97 40 109 114 84 131 23 80 202 194 173 235 185 5 24 101 114 252 70 130 141 86 34 7 78 132 146 18 162 9 97 250 90 142 163 209 149 205 103 228 171 115 18 32 126 18 103 137 9 150 173 53 185 17 130 147 57 145 214 1 9 164 63 36 115 60 39 49 187 128 101 128 170 233 89 13 133 185 136 96 105 222 200 145 8 233 199 100 152 113 66 44 48 133 32 177 146 11 224 109 165 21 101 48 138 206 42 210 218 230 116 198 50 40 59 80 18 188 78 30 134 232 80 197 218 8 140 231 227 249 113 223 124 27 126 28 243 151 66 2 95 164 5 51 194 67 9 88 177 116 26 114 109 160 78 91 161 183 2 212 198 215 64 60 60 25 58 91 219 218 201 163 218 25 186 70 50 79 58 41 169 245 146 124 34 165 147 115 7 137 72 144 120 22 78 154 201 205 103 77 6 238 39 115 147 28 11 222 142 160 200 235 150 144 24 128 15 148 131 71 194 244 32 13 74 39 25 206 196 236 240 176 177 106 212 47 16 151 77 189 182 255 111 48 50 19 33 68 50 114 181 22 246 4 136 66 80 112 152 67 111 73 186 115 68 210 226 126 100 221 173 28 67 75 76 151 23 197 205 194 22 161 54 160 141 132 15 205 29 233 103 123 25 30 176 200 98 197 228 24 188 1 200 23 140 148 21 130 16 13 26 11 195 79 229 163 178 209 180 176 113 129 230 17 159 110 188 11 70 0 5 2 217 66 80 51 26 214 221 214 1 18 86 39 246 60 146 3 11 113 239 254 0 39 135 106 182 93 193 201 164 139 29 9 182 78 136 44 91 82 28 41 27 230 70 54 13 80 228 36 40 251 28 0 217 154 74 201 109 236 96 90 195 215 245 199 36 9 228 96 117 175 210 129 36 162 40 117 2 215 40 161 113 58 0 44 22 58 75 129 250 137 188 12 233 3 60 81 137 16 51 91 134 147 78 169 30 22 51 159 145 1 128 222 106 190 143 167 39 135 168 137 98 205 116 239 85 79 101 36 89 65 30 122 208 10 159 210 52 86 183 6 23 211 33 43 57 79 248 72 153 156 238 171 33 151 224 174 248 201 174 53 73 57 7 104 181 164 190 13 164 85 174 27 2 118 64 89 21 169 161 155 41 50 135 182 178 167 80 60 28 77 166 211 136 32 141 167 135 169 130 46 73 227 169 162 91 5 195 209 64 178 146 213 74 143 75 167 219 242 222 194 7 173 179 200 138 136 92 126 251 192 247 37 56 171 10 222 184 134 146 1 204 11 3 30 221 122 233 123 81 81 59 23 37 246 58 142 201 104 112 253 10 103 82 169 162 52 237 104 15 129 163 153 59 9 37 143 173 136 199 40 198 12 113 205 58 184 42 19 29 132 204 138 196 155 4 139 39 41 32 109 164 2 112 102 80 161 189 216 148 175 220 6 24 184 132 54 37 153 46 166 137 208 127 2 167 71 72 36 196 133 15 201 197 214 177 168 1 64 87 25 174 102 11 183 111 122 147 4 28 98 132 100 159 204 155 240 32 205 202 158 188 96 211 223 81 194 198 86 96 63 71 18 214 5 194 10 36 15 221 131 249 3 155 139 142 47 97 183 68 15 169 47 76 38 148 130 226 71 83 140 191 57 158 240 58 210 234 89 227 56 100 176 14 100 201 144 7 148 171 113 185 48 136 68 153 152 73 84 16 131 134 148 161 225 75 20 150 205 71 213 248 56 200 47 185 97 40 54 161 211 26 246 165 197 162 252 172 210 240 108 245 245 173 27 191 138 125 50 194 144 60 136 84 209 20 85 221 44 92 247 243 231 70 144 31 37 140 139 68 225 12 173 38 120 147 254 72 22 196 16 46 162 66 122 120 192 202 55 56 155 145 134 1 45 215 69 89 23 107 207 223 176 115 85 238 47 175 103 38 205 107 59 71 204 196 148 103 174 160 213 202 166 82 9 180 7 0 244 129 132 171 20 194 32 138 204 131 228 78 243 244 137 156 24 84 249 60 141 25 56 130 80 141 86 233 177 113 120 101 25 199 223 108 191 112 239 26 240 3 197 241 27 133 47 206 244 122 111 94 112 197 73 200 76 2 16 110 171 195 65 18 204 2 129 32 87 55 51 149 215 33 100 140 176 128 26 34 103 195 41 203 227 42 223 110 29 105 242 181 23 183 95 116 243 50 38 147 217 228 201 180 81 167 218 209 73 111 47 103 81 196 117 34 239 83 247 10 208 71 20 35 55 243 95 10 209 41 144 172 136 166 33 69 109 170 185 82 178 206 76 115 9 182 152 193 228 192 112 26 203 234 89 102 77 246 187 77 23 127 60 54 231 68 102 43 129 224 14 192 238 243 106 225 154 203 95 24 197 85 238 242 69 99 24 130 43 7 212 115 241 164 168 21 137 102 106 127 84 66 200 154 37 129 123 113 190 38 125 108 241 176 69 211 127 104 235 21 27 126 27 113 160 68 226 33 131 44 200 136 209 125 144 164 11 1 70 18 122 11 161 43 96 46 208 94 207 42 47 105 94 43 73 77 65 201 190 2 232 181 226 87 96 8 220 64 70 66 209 193 8 144 190 128 60 78 238 190 244 218 211 9 158 44 199 247 163 31 80 51 51 25 125 254 246 69 219 15 69 169 158 24 23 14 78 208 171 241 5 32 149 190 255 248 161 81 140 78 55 33 68 146 231 84 14 160 96 65 92 67 73 46 11 53 87 39 239 239 218 120 253 182 111 167 50 197 34 73 130 211 55 133 171 151 108 108 79 96 198 162 49 125 213 40 139 73 139 154 136 150 149 178 182 4 71 15 89 14 35 2 130 130 105 113 236 45 75 123 230 140 32 75 166 13 226 107 185 119 233 245 232 181 45 151 63 221 159 166 208 36 128 49 63 126 200 155 203 241 253 23 221 46 253 169 155 140 124 181 133 0 148 231 110 65 183 60 205 103 55 110 57 146 232 141 112 95 102 26 244 180 209 226 217 180 114 140 34 214 53 104 136 78 145 79 191 121 100 215 3 91 246 156 143 146 130 200 11 66 53 13 170 4 45 181 30 102 148 187 20 176 48 191 60 238 101 148 49 76 10 0 18 115 200 240 148 242 20 197 35 180 70 103 113 205 195 117 54 160 113 199 245 186 174 208 146 138 180 117 146 157 191 123 219 229 135 39 129 144 40 66 230 237 228 25 46 236 203 139 126 249 234 40 130 101 115 242 81 144 102 193 166 225 155 203 236 235 155 54 108 250 42 33 11 42 168 102 248 6 167 7 111 186 119 9 10 3 146 191 115 89 8 179 72 87 246 255 225 185 135 55 189 57 150 112 128 70 102 7 144 110 58 5 76 57 191 144 203 72 2 91 163 120 198 201 148 193 150 185 235 106 105 237 111 50 161 110 242 211 73 115 201 235 155 171 66 95 106 44 220 212 141 2 99 155 37 89 244 206 53 27 119 47 198 105 106 22 73 70 90 231 228 192 84 87 242 201 222 11 47 59 170 80 79 94 82 133 4 8 134 176 194 233 150 201 161 235 183 94 114 215 10 128 61 80 202 96 190 226 187 91 46 221 250 163 169 221 78 239 84 132 66 94 150 199 239 191 240 155 143 182 110 250 122 148 194 157 37 210 58 19 104 101 49 74 114 162 24 209 84 222 20 210 208 12 72 79 209 56 154 2 177 224 186 37 57 61 96 22 145 210 58 247 199 181 99 108 144 179 45 196 47 128 148 90 37 128 106 102 50 170 73 214 238 218 188 237 181 193 36 1 71 75 193 136 137 36 242 200 38 63 117 229 133 247 141 128 153 58 51 214 205 169 244 26 153 98 105 149 47 63 124 227 181 151 125 72 158 26 202 160 72 53 95 124 124 211 133 123 22 19 142 83 134 114 141 19 205 108 97 239 83 111 124 120 249 93 103 38 184 110 249 6 115 134 165 203 119 96 220 52 225 193 20 149 92 133 213 255 122 114 133 201 120 154 249 59 83 164 133 106 146 244 152 155 50 90 162 232 129 235 128 162 0 105 195 95 224 31 100 45 40 227 232 243 27 55 223 248 195 112 164 176 145 81 106 144 189 146 23 204 100 152 249 224 197 255 248 207 63 19 76 32 205 204 75 241 10 181 105 175 116 250 230 237 207 94 181 253 12 41 60 218 46 216 47 115 25 190 120 229 5 219 158 31 82 82 213 17 42 128 101 205 181 79 15 220 185 251 139 231 175 120 117 144 76 34 178 174 18 66 179 54 5 105 194 94 97 41 183 3 195 206 201 44 123 153 15 229 60 58 49 232 143 148 196 160 41 60 92 99 210 15 20 88 57 173 85 92 233 234 80 105 160 2 1 76 171 210 225 51 27 46 219 183 106 34 175 116 226 9 68 151 247 35 134 47 94 243 175 87 159 30 103 169 30 166 4 159 145 35 133 176 53 107 210 239 246 29 124 234 138 87 35 162 83 41 87 71 153 182 152 126 182 231 186 11 175 250 235 4 160 151 162 68 114 60 200 32 61 127 251 109 79 31 221 125 245 151 145 148 76 158 32 78 48 93 42 233 128 61 50 26 157 31 154 216 174 21 103 9 6 73 132 166 40 180 96 179 161 106 219 65 24 193 202 232 67 232 27 199 104 125 98 86 153 190 38 211 20 30 133 61 109 242 244 232 198 159 110 62 210 151 74 67 154 103 20 80 116 54 189 67 89 36 241 187 191 250 143 87 250 134 164 8 174 41 93 24 35 37 17 112 95 126 233 221 207 174 185 250 59 195 3 89 36 111 95 23 199 31 125 240 158 11 183 157 158 164 25 2 212 55 203 219 74 131 147 225 107 219 174 251 234 157 45 15 159 19 236 75 200 147 115 202 96 230 78 37 191 178 205 90 99 68 130 153 220 172 30 160 236 77 166 102 65 148 88 75 29 229 109 192 252 176 21 230 98 156 248 194 90 224 36 205 98 135 202 131 68 50 35 206 75 44 233 224 169 95 92 240 196 210 152 248 87 164 9 71 47 171 180 116 152 173 71 119 252 228 151 71 176 137 44 240 210 5 212 142 3 107 154 76 254 252 220 167 143 108 120 126 144 100 118 247 21 21 232 106 244 210 19 207 254 250 130 189 43 137 107 179 122 137 245 87 138 127 220 189 225 149 19 15 111 253 96 52 74 166 169 162 89 20 25 163 2 132 74 104 27 61 124 221 5 223 32 197 196 150 100 103 248 251 28 115 83 148 48 13 108 202 108 54 15 60 147 233 165 25 156 31 176 138 20 139 44 152 211 225 246 37 240 31 54 255 108 211 199 147 36 115 81 181 180 111 151 119 164 48 155 39 223 95 246 147 251 215 34 197 105 189 101 1 147 236 64 71 200 43 179 19 143 191 119 120 235 85 71 38 161 38 87 154 165 136 190 190 235 233 183 238 185 114 255 48 181 41 37 113 68 140 146 95 28 238 187 106 199 15 159 111 185 247 244 96 26 131 115 19 37 39 25 41 89 217 152 238 111 241 115 77 86 154 96 166 138 172 252 12 213 108 64 96 248 27 101 172 13 73 4 181 161 185 11 39 160 2 165 130 38 216 102 179 138 48 79 28 34 131 169 200 100 242 209 147 23 252 252 154 243 147 169 204 66 226 86 110 87 149 1 224 202 236 199 47 253 228 63 222 29 142 98 87 221 74 126 130 115 163 201 211 100 109 223 83 199 158 188 234 209 21 40 211 34 117 93 190 76 23 31 220 249 194 241 91 47 19 44 137 237 172 115 124 24 229 254 31 175 189 234 189 51 15 111 249 227 202 56 154 140 71 8 33 137 177 174 142 238 17 71 146 22 119 79 252 35 41 149 225 182 61 151 165 229 57 41 79 196 153 50 66 204 75 242 170 195 1 5 176 33 9 205 206 204 8 210 228 236 1 227 67 55 150 217 241 237 23 232 142 227 152 138 163 92 239 36 105 92 106 198 170 179 181 237 255 188 75 113 142 8 78 65 192 49 205 2 107 242 254 59 119 28 56 188 245 198 47 229 14 92 15 199 210 146 201 135 219 239 251 225 171 45 55 156 25 129 202 113 55 210 201 56 137 166 107 79 94 114 235 241 163 55 238 57 58 24 12 35 165 146 17 71 203 168 87 66 184 163 12 148 213 40 11 153 85 163 204 82 247 176 211 40 112 86 45 53 144 153 229 197 47 127 8 141 129 115 135 235 165 236 37 40 15 3 71 89 68 135 110 243 254 43 23 95 188 245 155 113 156 76 35 167 7 19 138 197 181 121 226 34 249 219 47 254 245 21 217 111 156 235 116 229 122 225 23 58 177 76 227 31 174 121 240 187 167 175 216 183 60 70 19 157 175 202 240 207 222 113 245 254 197 63 95 249 235 126 50 213 79 72 11 66 241 36 26 126 118 237 165 239 159 249 253 182 223 174 14 39 209 52 158 68 209 4 142 35 138 29 194 209 241 64 166 181 115 42 165 186 87 98 84 15 20 67 231 132 41 173 174 153 255 215 175 32 48 88 64 43 34 192 158 242 30 204 175 201 97 253 93 254 233 199 235 46 188 228 238 21 105 79 68 70 91 228 49 61 37 68 14 249 224 233 115 255 121 217 241 193 88 89 31 128 82 194 81 140 114 109 32 137 6 175 93 241 193 23 87 109 249 106 154 17 158 225 79 234 34 25 188 178 249 230 19 203 143 93 190 191 63 86 212 167 50 89 38 116 105 68 231 238 217 120 211 15 63 222 122 219 143 253 225 120 162 183 154 68 4 44 26 2 208 123 242 178 218 181 104 210 185 0 9 145 25 57 176 124 25 90 221 172 11 204 206 3 162 66 30 100 54 151 108 204 14 154 173 161 78 214 205 176 81 90 88 210 116 237 185 75 182 220 244 197 112 60 198 253 129 79 147 216 221 28 212 98 243 243 27 255 207 222 21 220 71 138 206 153 67 131 97 86 148 154 124 189 227 177 51 79 109 184 111 109 4 117 155 225 186 229 20 190 218 185 229 245 133 31 182 109 253 106 16 69 58 210 148 34 179 236 41 25 190 117 249 37 239 173 28 220 242 242 162 252 7 84 148 192 33 37 134 24 160 92 186 52 36 221 167 62 89 155 133 49 53 88 244 132 156 115 115 50 78 95 231 62 204 60 208 185 56 198 89 80 75 234 174 157 241 148 66 65 45 124 214 184 95 43 249 102 227 47 46 191 253 244 202 112 10 152 163 250 6 169 144 153 141 44 146 191 254 236 223 63 31 75 88 177 66 29 94 10 13 165 128 93 231 203 143 220 122 226 232 214 77 159 12 162 216 197 255 188 152 149 209 194 195 151 236 57 215 255 120 203 195 11 35 69 64 88 208 24 232 55 30 156 186 237 226 125 103 206 222 189 227 112 127 52 26 15 101 102 113 170 107 146 82 150 248 116 24 5 234 55 164 216 37 153 137 68 8 197 215 67 153 109 125 181 93 135 75 35 184 251 217 250 71 115 39 43 142 214 136 142 155 113 41 221 14 36 125 250 130 93 23 29 232 143 166 81 170 176 104 98 43 11 76 164 174 188 255 240 79 118 158 159 40 115 74 105 74 40 157 64 21 206 250 210 183 119 190 191 252 204 149 119 45 141 35 242 10 185 138 166 140 39 111 93 121 201 231 253 181 231 54 188 186 212 31 74 225 228 41 38 177 44 106 184 246 234 21 91 190 93 250 235 245 143 157 91 29 12 226 152 0 156 36 147 137 18 29 197 107 234 89 53 156 126 25 58 56 208 235 22 200 149 247 202 42 73 73 216 45 168 57 4 81 55 239 130 231 208 159 33 47 158 81 79 233 124 64 247 45 52 208 210 212 54 79 108 190 112 195 150 31 7 241 212 45 34 201 122 118 33 207 75 117 234 248 229 255 249 222 152 34 28 189 131 244 8 1 8 18 184 205 115 15 62 190 116 106 207 85 31 174 77 168 107 197 118 239 217 201 219 46 125 100 185 127 226 214 77 135 87 162 233 116 44 80 35 117 140 198 163 225 209 107 55 236 95 92 120 224 214 79 151 215 250 195 33 159 77 139 108 34 51 20 200 210 67 81 74 67 31 1 208 77 229 74 214 28 86 162 87 187 135 11 228 52 179 167 111 141 115 9 100 182 51 80 213 28 109 12 229 201 218 213 146 121 237 192 145 14 94 187 100 207 166 95 175 78 38 145 2 61 191 0 72 122 202 138 212 124 250 187 127 187 226 4 210 12 188 138 113 50 81 92 199 123 235 142 163 171 191 223 113 255 162 100 146 112 29 50 150 116 237 153 95 109 253 126 52 250 116 243 13 39 198 227 193 249 143 255 188 60 148 119 151 35 92 120 232 23 215 252 184 252 241 182 167 78 175 224 64 38 19 57 204 208 212 18 186 34 64 97 101 1 135 87 112 48 88 40 19 239 61 151 196 91 242 46 8 81 219 89 141 47 108 204 143 210 69 228 120 77 123 4 197 9 138 202 18 42 5 166 52 253 118 203 246 123 182 125 44 119 85 42 19 154 144 92 228 213 204 25 172 92 254 242 158 127 126 104 117 2 69 11 156 112 82 234 118 177 34 93 120 244 173 225 241 221 155 223 25 80 33 113 73 78 247 112 120 243 37 239 245 163 213 87 47 125 122 105 56 89 124 234 254 135 143 15 167 147 241 96 212 127 127 243 198 79 151 206 236 189 233 208 234 104 52 28 77 198 211 241 88 216 49 13 56 94 58 72 89 165 136 115 55 213 240 172 51 170 24 138 252 189 138 250 119 7 94 106 8 205 69 59 91 183 46 253 165 206 93 26 42 155 38 148 133 160 59 45 111 179 248 217 228 153 141 15 109 186 231 156 20 35 151 211 183 17 23 78 19 105 92 139 63 254 213 79 229 33 40 78 22 132 75 224 11 164 103 145 76 222 125 240 252 242 111 54 62 182 52 149 46 186 91 40 75 162 197 59 47 124 116 113 48 88 124 112 203 135 253 193 232 203 235 55 29 92 34 108 77 38 103 238 187 248 145 243 11 7 183 239 61 201 201 16 152 180 81 208 81 74 158 186 185 6 166 129 254 73 10 80 238 245 50 216 71 102 5 127 177 187 112 154 98 130 150 218 86 232 3 50 199 228 146 172 145 100 231 134 27 8 37 129 188 47 175 191 231 241 141 111 203 191 197 164 10 200 132 44 29 29 17 182 63 119 199 191 110 59 43 39 39 111 153 164 120 23 90 91 51 66 194 185 71 62 25 126 116 195 245 95 12 38 130 26 244 173 37 121 180 242 202 69 155 143 174 77 198 95 110 221 113 98 184 182 122 242 215 119 28 95 30 77 117 176 193 27 27 110 56 178 248 221 77 59 222 147 251 24 40 80 227 25 163 201 116 18 87 144 245 109 78 139 100 238 166 9 24 36 90 208 92 124 109 235 158 155 186 240 235 238 206 176 180 66 80 155 149 230 221 148 198 212 129 180 154 81 28 113 79 142 203 156 217 232 209 173 111 222 184 231 184 240 7 6 150 155 61 129 59 42 96 207 147 207 182 252 219 190 53 101 16 83 23 193 83 170 180 166 33 178 232 157 167 207 158 188 127 227 171 43 211 194 29 174 148 73 250 159 93 115 241 193 254 100 184 240 204 246 223 156 239 15 39 75 47 61 118 124 48 26 143 227 225 247 55 111 251 236 204 153 223 236 124 226 244 106 127 50 141 70 19 156 166 180 56 203 220 111 83 153 202 165 205 0 162 63 41 29 223 92 100 105 123 180 213 172 31 166 43 26 23 146 141 24 103 244 192 6 135 79 209 132 206 62 71 66 90 26 104 115 202 162 143 182 220 187 255 170 131 107 227 8 116 231 142 85 20 11 0 46 8 56 122 240 223 127 249 151 149 9 134 228 226 14 122 154 213 181 2 239 169 87 190 94 217 127 203 61 103 229 54 93 180 19 18 159 46 63 186 225 225 51 178 169 191 223 188 243 139 213 201 104 176 242 219 251 190 64 70 107 167 31 221 252 252 217 229 15 30 188 255 232 242 64 193 172 63 210 251 142 232 26 142 147 184 20 26 38 111 183 162 36 161 89 79 127 81 148 129 231 109 122 93 192 27 235 53 72 187 251 22 171 114 240 114 103 17 149 171 64 119 186 111 10 142 78 105 83 246 253 125 55 124 116 251 174 83 131 209 20 182 92 202 79 51 51 77 54 244 89 166 223 108 248 151 29 167 198 66 1 137 15 64 117 202 253 186 121 244 201 111 207 254 117 231 53 95 13 199 194 181 36 78 250 53 121 235 234 173 95 244 229 17 95 185 102 255 210 106 127 109 109 237 232 147 7 5 125 251 11 47 110 188 241 232 217 175 158 218 253 197 218 234 42 142 81 82 67 29 165 143 81 233 126 220 218 13 69 100 193 32 41 74 51 132 2 18 165 158 219 32 131 148 236 249 165 141 174 232 153 12 110 2 7 220 82 247 118 67 134 52 23 106 130 134 141 87 174 122 100 255 246 63 13 198 110 217 42 215 203 112 188 79 165 196 112 241 190 159 255 244 174 197 169 252 51 220 115 110 34 196 41 114 190 244 193 241 211 79 92 245 210 146 188 230 148 171 207 146 233 228 212 174 43 159 95 26 174 46 127 124 253 206 99 107 195 254 100 180 124 126 223 223 198 163 65 255 240 181 151 127 252 247 79 247 237 250 104 113 109 52 28 78 148 192 12 135 195 40 202 81 200 204 94 4 24 66 140 174 113 145 105 225 142 40 41 152 20 176 231 10 187 13 173 51 236 69 124 144 110 173 43 90 45 124 134 27 214 96 85 91 107 107 135 118 231 199 111 219 244 238 141 187 206 142 227 60 52 75 74 34 132 167 2 50 50 153 124 113 217 191 93 250 242 32 49 219 89 165 83 247 155 231 150 218 71 111 158 125 225 234 27 79 141 21 146 4 232 43 0 253 96 223 37 187 143 245 135 171 199 239 216 242 218 217 229 181 213 193 234 202 226 155 167 87 87 7 103 246 94 182 247 216 239 111 219 245 249 234 112 212 31 245 199 138 219 114 31 145 210 78 168 239 60 116 142 184 105 20 232 35 196 69 199 0 142 64 234 86 247 186 208 36 52 183 175 71 25 205 199 183 29 5 116 170 63 202 200 204 138 214 51 183 117 112 3 216 238 248 213 29 7 94 218 250 250 144 34 162 140 171 117 239 50 28 103 146 85 105 180 114 255 133 151 237 56 52 49 0 33 220 66 88 200 10 227 105 178 120 240 199 3 91 183 30 26 42 140 225 230 166 227 120 60 126 243 218 77 159 247 199 253 51 143 111 221 119 236 252 210 226 242 210 234 96 229 219 243 75 253 165 223 94 122 245 171 15 236 124 224 179 197 126 127 50 30 42 148 1 146 227 120 52 34 88 211 95 171 96 38 148 218 208 156 132 213 209 100 225 54 98 136 155 158 3 114 9 151 180 158 149 209 85 51 163 46 58 115 247 221 172 113 231 114 69 35 192 204 102 71 25 45 249 246 186 221 135 182 223 118 86 224 142 195 164 49 181 73 42 218 184 165 104 116 232 242 11 174 220 125 30 84 72 95 232 120 154 187 69 91 158 49 254 234 237 15 110 188 228 15 107 58 83 44 168 9 10 28 28 185 241 138 87 150 87 86 78 61 126 217 238 207 79 156 60 113 236 232 247 95 255 240 227 119 103 206 156 63 122 221 207 110 217 126 219 129 211 194 84 163 225 96 60 148 46 98 106 3 162 25 16 11 113 85 74 34 92 141 115 23 103 90 207 74 176 123 165 92 19 223 104 126 163 233 214 73 2 179 31 102 61 230 193 41 210 218 215 6 100 60 227 98 58 249 198 165 125 155 127 251 219 203 94 93 29 130 157 24 30 72 166 169 187 130 192 59 211 115 123 126 185 101 227 83 11 202 0 244 4 209 63 156 62 12 231 248 240 91 215 93 242 208 121 65 174 225 56 148 196 167 167 118 95 244 208 153 229 149 19 15 94 120 245 155 159 189 246 224 157 183 236 222 189 235 174 187 246 62 241 242 11 55 255 100 195 3 111 28 91 234 15 134 35 37 121 163 254 218 120 48 24 145 250 37 209 216 53 117 104 219 28 218 208 237 122 101 11 214 167 125 21 86 163 236 209 203 54 167 184 111 139 178 95 156 187 24 89 209 48 3 39 231 97 2 138 94 58 170 89 226 178 136 62 190 233 201 143 110 186 238 216 56 210 129 232 39 44 98 1 196 130 56 131 199 127 239 210 141 123 174 126 119 141 188 56 165 23 49 199 123 200 119 230 211 31 223 188 233 87 119 157 24 77 32 166 245 116 121 52 94 122 225 210 107 143 174 44 125 185 227 130 139 239 122 252 230 171 111 252 245 19 143 60 253 194 115 15 221 189 99 219 175 254 229 234 15 206 200 161 140 215 214 228 84 132 181 162 201 136 232 173 251 144 234 235 63 16 170 43 125 238 40 151 19 41 215 203 164 52 4 181 61 124 73 200 52 41 5 147 111 210 79 195 164 64 7 45 84 193 209 227 203 105 5 163 29 165 83 246 152 156 190 247 158 31 158 186 226 217 65 66 3 114 81 21 17 253 62 12 148 48 15 20 157 186 229 130 125 215 221 249 247 126 68 120 203 234 144 10 150 180 206 140 255 178 251 202 93 223 45 15 198 178 20 249 155 73 60 237 191 183 105 211 151 43 11 111 223 178 233 194 203 247 236 121 225 195 99 39 165 134 11 231 207 158 248 225 189 43 174 249 232 252 242 72 183 48 149 91 84 106 174 239 159 166 145 65 139 219 131 201 195 171 208 190 152 211 78 85 67 238 34 188 188 148 164 234 222 220 174 222 193 139 214 108 58 60 220 100 90 207 60 43 64 135 22 53 189 166 89 111 35 208 57 179 209 129 237 47 127 187 227 142 147 180 214 101 201 132 154 91 150 211 213 10 10 204 135 7 54 94 255 210 53 191 91 155 208 161 64 0 111 92 114 148 205 79 142 236 185 242 214 111 22 86 135 195 129 34 147 174 127 184 242 249 142 75 254 124 254 196 254 27 118 188 244 217 39 127 59 118 254 252 185 213 181 254 234 242 210 210 194 177 189 155 223 92 234 175 245 149 208 76 163 161 12 44 50 123 170 200 162 67 197 64 70 122 216 82 170 252 50 95 69 234 218 10 167 71 206 40 221 183 179 158 241 210 127 17 31 29 253 24 52 111 185 245 8 0 60 115 15 237 122 127 122 152 231 72 191 219 115 231 241 131 155 223 30 197 57 144 63 241 252 15 45 64 110 162 158 252 253 186 95 190 113 203 238 99 35 198 50 18 163 30 20 85 193 117 233 211 219 55 238 252 106 89 33 73 104 93 192 75 190 229 204 221 151 191 112 242 240 190 27 94 254 246 244 153 133 133 37 29 107 58 25 172 46 174 46 157 57 112 245 237 63 44 141 198 3 225 227 53 229 209 227 100 74 43 216 20 124 154 80 54 202 169 199 153 52 170 221 225 79 241 154 65 6 58 91 169 114 201 131 200 55 84 240 82 243 134 67 201 75 40 77 157 59 131 118 3 122 217 66 233 149 250 20 149 148 10 254 122 249 153 91 255 114 246 238 157 103 41 39 122 62 42 200 203 175 157 101 131 103 55 220 241 222 77 111 12 77 98 80 48 72 199 163 72 198 22 47 253 254 166 141 55 126 189 60 30 79 198 99 168 128 201 100 180 248 244 198 27 223 125 234 182 59 62 62 187 184 186 34 81 14 87 87 6 171 11 107 253 165 115 135 183 111 255 124 113 117 141 188 69 161 65 18 158 140 99 133 43 178 61 38 46 50 234 121 73 66 243 6 109 45 252 94 186 156 206 76 14 116 180 236 44 36 204 161 29 170 108 12 67 58 154 130 228 227 33 127 40 205 73 186 109 83 164 112 251 249 116 58 236 191 117 211 147 103 126 119 205 1 123 128 40 114 99 2 80 32 75 56 219 248 208 150 43 222 122 100 215 119 163 36 177 69 68 211 165 207 254 50 72 39 253 227 47 110 191 252 214 191 13 38 107 176 25 164 148 227 241 249 131 151 252 108 203 237 119 191 126 114 101 105 121 2 44 92 93 88 94 91 89 91 233 47 159 186 127 203 91 203 171 107 195 113 196 175 120 130 97 37 176 235 73 84 148 145 135 72 242 202 78 153 126 161 130 196 186 116 201 155 17 181 14 92 165 44 102 22 48 48 20 129 219 113 104 118 232 232 108 201 102 238 76 1 47 49 43 39 147 31 175 156 61 127 250 199 207 110 191 225 213 195 119 236 60 29 145 84 226 19 147 20 150 140 234 136 28 229 218 195 87 62 126 112 199 115 67 224 15 149 138 193 55 47 188 177 48 25 158 253 224 254 91 110 121 249 251 1 209 118 50 16 98 159 166 211 197 223 109 248 201 134 167 63 17 236 232 15 250 171 107 203 74 95 86 214 250 107 114 239 139 239 108 185 247 228 26 94 35 77 38 145 98 95 52 113 35 139 116 67 167 44 243 8 228 227 22 203 208 8 226 98 182 103 159 58 26 180 42 133 96 97 125 159 139 185 8 119 236 130 136 221 62 94 121 176 134 249 13 243 247 197 194 239 30 122 236 190 91 111 189 249 150 173 151 252 228 130 171 174 218 121 112 146 72 159 98 15 104 76 152 218 131 109 169 138 248 179 43 55 31 218 185 243 200 96 12 73 160 231 56 116 255 161 181 181 213 191 222 183 235 218 39 143 72 19 117 174 9 97 90 150 179 116 224 226 159 62 116 100 81 112 106 72 200 154 144 50 15 133 134 87 87 23 191 223 117 195 87 171 67 101 10 116 74 49 31 150 102 80 143 144 178 176 228 224 104 88 70 120 202 240 71 83 49 116 81 173 15 120 20 246 250 132 227 38 116 225 174 167 149 117 155 53 1 226 87 101 104 148 161 171 242 232 29 27 46 250 127 255 254 127 255 229 159 254 233 191 253 247 255 245 191 127 186 245 239 145 148 62 142 167 211 152 222 58 65 17 230 210 210 201 249 59 127 181 255 137 235 14 194 171 49 18 26 13 159 188 237 244 185 15 30 221 185 249 186 63 158 94 213 161 164 180 209 212 225 123 225 240 13 23 221 127 122 5 227 194 242 198 163 137 100 54 26 246 151 22 151 150 158 185 250 224 138 169 57 165 221 36 209 137 251 2 40 93 22 122 116 185 92 202 123 84 107 220 93 201 8 34 174 28 90 163 245 36 6 141 81 61 143 58 64 150 50 0 17 58 33 100 147 166 20 168 34 217 111 80 187 73 142 253 233 245 39 111 185 250 231 255 235 127 252 207 127 253 213 5 151 62 188 32 79 32 227 142 165 163 3 186 182 20 63 5 152 6 127 216 124 239 147 183 189 190 16 77 167 19 217 88 50 61 182 249 230 63 220 115 253 230 45 123 143 44 197 241 120 146 226 99 82 196 188 182 240 236 197 183 253 125 165 63 30 14 4 155 36 46 121 192 113 52 28 76 7 171 171 95 221 252 192 74 230 38 1 152 46 1 0 159 164 161 119 86 78 49 46 42 19 191 101 218 216 103 187 223 151 63 24 139 197 156 64 128 202 98 230 110 18 117 63 87 35 112 164 252 187 4 246 210 66 200 28 7 137 43 112 185 204 199 131 213 165 133 19 95 223 127 253 139 223 126 243 236 198 151 22 6 211 68 56 110 58 56 126 232 173 35 43 50 9 161 222 36 62 126 203 213 15 222 249 250 137 254 132 150 187 50 155 78 206 223 126 233 134 11 175 186 235 175 75 99 66 109 42 217 38 19 104 196 209 249 183 183 221 112 116 165 47 104 49 25 9 237 78 7 146 88 191 191 188 170 115 46 61 113 195 17 224 124 145 215 30 91 171 168 221 54 116 56 123 100 216 20 101 78 155 11 99 3 85 154 187 139 35 79 144 9 147 132 116 132 74 76 61 2 89 69 19 65 209 184 249 78 23 5 85 85 132 126 28 106 236 132 120 230 38 226 209 120 178 250 215 123 159 56 179 252 246 13 59 62 59 179 58 146 55 59 251 249 43 15 220 119 251 253 207 60 255 201 154 244 38 94 222 183 97 247 253 47 157 90 29 43 245 74 200 15 167 131 147 191 123 114 255 137 165 129 64 132 76 75 26 28 243 125 73 50 60 124 195 213 159 44 43 88 73 80 80 109 82 195 33 41 216 88 146 253 248 186 131 41 92 114 230 17 27 60 30 56 138 126 11 198 90 100 252 194 54 30 90 129 50 165 23 54 229 144 115 234 142 158 140 104 104 181 171 123 158 157 205 204 181 150 238 153 167 157 222 221 69 238 235 10 173 213 158 133 45 211 241 240 220 83 123 191 93 249 230 158 107 127 253 252 203 251 223 253 226 163 215 31 191 227 225 63 125 243 197 75 47 239 220 246 225 90 50 89 62 112 193 5 79 124 217 7 174 90 143 228 163 229 24 134 66 123 122 126 253 45 151 238 42 20 72 73 135 167 30 184 242 213 101 156 132 12 108 44 185 233 116 67 168 169 162 78 207 221 117 223 42 176 6 27 98 122 135 178 4 85 117 196 147 97 70 89 24 50 209 115 167 21 29 239 161 43 192 117 244 121 141 39 105 40 166 247 4 251 169 245 81 96 234 60 1 76 235 227 204 116 120 75 167 3 52 138 224 153 7 70 210 254 27 123 15 44 173 30 185 246 202 13 23 110 216 188 237 250 91 110 126 242 61 249 133 225 176 127 122 207 29 223 29 255 235 243 87 252 252 15 167 251 83 162 55 158 76 206 2 164 135 203 139 104 15 149 33 226 22 19 221 208 218 254 173 207 158 89 81 106 18 141 6 100 201 20 143 198 160 140 44 238 31 216 253 113 146 149 41 54 47 31 64 207 93 69 197 22 94 84 30 49 165 41 85 142 159 134 59 151 136 77 0 240 27 157 213 193 95 96 74 109 175 243 108 88 19 58 180 61 218 133 3 113 111 162 27 49 195 172 146 34 124 91 101 241 225 219 246 158 26 196 203 31 62 247 236 254 63 190 243 167 231 255 124 114 117 28 195 226 76 6 95 220 122 211 61 187 174 253 213 35 139 46 183 42 163 73 43 143 189 242 172 121 50 244 160 185 18 50 89 153 212 109 218 255 112 251 175 79 174 160 128 107 138 207 50 191 225 96 160 195 73 198 211 233 119 247 255 110 28 187 140 41 71 173 228 43 247 200 76 138 106 234 57 160 105 42 143 78 59 241 162 81 205 115 15 104 38 67 135 204 3 81 186 236 230 61 234 123 157 167 56 2 87 135 70 186 11 154 130 120 87 184 45 189 32 172 149 117 114 250 185 71 143 72 119 70 131 229 229 181 193 154 178 38 249 196 73 10 245 61 237 31 123 251 221 247 174 191 227 251 65 194 120 124 30 90 212 160 63 96 38 115 154 96 98 147 248 46 232 245 191 220 115 231 201 181 137 80 211 100 36 169 10 104 201 187 36 120 211 36 29 190 112 231 137 24 62 19 152 64 183 254 172 174 66 177 180 153 241 159 155 159 138 220 69 150 208 250 71 249 39 140 112 0 179 248 1 134 26 234 30 26 219 120 100 12 102 123 78 185 213 196 41 125 86 133 127 199 183 210 185 27 245 223 124 244 11 37 73 81 66 180 77 200 45 18 70 77 74 74 96 201 100 112 238 209 43 63 234 211 129 1 167 154 58 225 165 171 17 159 22 3 19 241 29 132 37 225 224 251 110 252 114 48 90 89 35 219 142 71 178 177 161 226 22 225 75 222 244 139 91 223 28 151 161 152 223 184 109 133 22 40 188 32 195 51 114 112 46 21 231 73 90 51 40 86 133 81 154 198 51 109 179 48 78 201 228 20 227 231 242 250 30 239 173 240 131 166 114 170 48 143 90 134 118 251 204 237 188 114 149 105 50 254 234 193 215 87 71 82 152 212 21 201 233 120 108 182 150 99 73 60 211 233 59 219 30 56 159 210 192 64 167 173 156 115 76 230 57 153 146 231 40 107 140 201 190 147 88 49 110 120 238 249 45 111 46 172 202 115 192 111 11 200 232 37 113 48 30 185 90 249 205 203 99 221 72 236 13 8 180 236 65 86 184 237 31 158 198 10 144 123 166 95 10 135 76 20 155 169 124 202 185 67 105 23 243 118 30 38 56 116 50 130 25 46 4 185 49 94 180 142 67 26 55 194 249 147 116 38 40 113 156 156 222 187 239 44 205 51 217 24 134 145 208 140 14 41 103 146 238 229 113 188 116 223 174 227 83 119 142 67 240 103 158 166 132 24 201 32 226 61 196 145 11 95 198 147 65 255 243 235 31 63 189 58 149 189 141 99 162 67 18 10 71 66 170 242 54 135 238 62 67 16 102 246 159 172 36 131 30 116 227 82 69 66 92 65 185 145 111 102 177 251 82 116 227 126 126 64 82 86 248 83 84 29 220 19 220 35 138 81 98 9 115 16 158 49 104 133 96 216 49 80 209 236 223 193 119 41 57 74 70 7 159 249 38 34 19 166 29 131 201 114 10 116 12 38 211 149 80 20 163 183 119 189 214 215 57 49 145 146 30 39 230 13 157 115 40 77 4 77 37 74 100 18 193 168 225 241 123 239 57 57 77 39 148 57 198 67 129 24 124 126 74 111 189 244 96 229 217 131 211 130 249 165 48 191 45 51 99 190 21 191 71 168 114 53 136 158 243 210 152 162 76 138 208 95 62 67 237 42 198 37 231 58 52 29 47 82 199 94 29 6 184 124 58 207 168 81 74 161 200 230 225 2 119 225 51 101 93 77 63 126 246 189 137 209 77 146 85 76 97 200 239 197 76 196 178 2 64 6 116 252 214 7 207 143 40 178 23 161 162 238 206 21 119 78 230 17 13 107 82 72 133 228 120 60 92 121 229 230 47 6 2 156 163 17 69 21 253 70 116 198 60 169 103 31 122 113 82 51 32 92 6 42 134 124 178 14 245 48 146 171 218 219 55 90 26 156 220 247 74 167 108 145 182 46 236 177 224 66 113 107 206 152 97 201 48 75 207 3 202 166 171 176 88 152 46 66 67 198 236 142 116 1 101 202 32 8 210 243 143 63 181 138 46 50 1 165 112 171 36 36 249 71 71 46 141 95 131 125 247 28 25 232 1 83 131 6 86 95 84 238 117 214 227 74 120 206 244 19 194 214 120 248 225 13 207 47 147 202 140 224 11 112 45 163 65 52 33 161 77 155 178 255 236 247 40 110 237 150 65 134 111 24 61 84 98 110 230 147 6 163 38 203 103 136 203 195 216 220 61 23 194 112 17 45 47 115 222 184 200 152 130 146 246 246 140 60 244 85 185 20 170 146 153 219 69 60 146 165 231 202 19 151 135 4 41 70 111 62 254 3 57 32 93 43 83 250 32 98 111 1 136 92 121 204 171 248 208 142 131 253 84 40 156 185 218 46 103 174 55 103 246 50 165 197 72 206 67 22 57 142 97 62 70 199 110 127 224 140 132 132 151 176 81 78 24 210 143 232 182 204 226 232 200 71 12 233 40 86 8 21 68 57 131 7 16 84 25 94 221 0 137 222 209 198 149 104 170 201 222 138 224 126 114 156 100 232 71 103 121 135 236 106 142 7 241 230 0 102 78 168 181 178 52 197 249 54 179 192 97 25 77 138 237 199 159 60 246 165 140 41 246 66 3 217 132 110 128 110 8 215 142 10 217 243 234 99 143 156 150 96 220 106 235 5 13 94 164 128 11 41 72 67 226 41 187 70 228 6 167 253 3 123 79 40 40 15 199 208 172 186 163 9 237 216 44 3 33 0 247 63 24 232 118 132 62 90 157 78 114 160 129 139 29 53 10 207 116 185 17 85 205 132 133 228 25 24 175 200 237 217 110 247 147 211 233 91 113 7 56 246 166 103 30 60 204 115 112 232 54 44 26 0 157 229 192 181 86 161 172 206 179 115 251 255 44 231 108 39 231 50 88 20 133 45 29 144 218 50 253 181 3 119 126 62 209 23 233 29 205 232 141 102 130 68 90 154 38 53 205 20 114 249 114 41 10 196 241 248 171 59 222 86 186 61 37 71 35 184 133 153 252 156 41 105 221 228 248 100 68 51 180 119 91 120 200 119 198 61 81 214 106 67 99 94 86 67 134 250 26 60 84 74 202 50 175 152 75 244 228 4 179 187 58 126 237 62 138 30 19 153 244 192 22 235 171 48 144 40 77 240 41 157 185 45 238 164 206 210 193 31 31 59 47 155 215 195 21 217 148 102 28 170 46 85 233 109 40 44 220 56 122 219 75 35 175 28 170 195 128 34 244 25 124 143 247 21 97 136 82 91 23 103 23 159 125 125 5 210 38 139 192 47 137 97 137 46 33 118 219 125 37 245 192 202 25 180 229 233 112 209 117 232 58 244 108 110 59 99 99 202 12 64 203 89 103 124 78 160 189 157 33 170 118 125 237 129 87 248 228 186 208 158 203 203 45 115 29 149 219 239 219 117 60 85 187 67 86 238 3 6 228 147 23 190 153 208 81 147 50 244 95 224 65 88 182 66 81 189 145 186 78 251 191 121 240 71 188 118 32 56 243 164 166 53 17 213 192 107 102 204 54 196 30 180 140 134 135 246 45 142 117 64 0 63 153 117 66 0 137 232 183 144 11 135 8 99 205 0 94 169 52 82 144 237 213 238 158 69 153 230 152 22 133 177 218 29 160 137 110 96 190 78 3 23 97 225 3 166 199 151 107 75 189 87 179 252 198 110 178 116 111 32 91 110 232 30 105 60 79 3 187 151 70 63 190 248 151 254 132 188 253 31 205 212 30 121 138 147 178 158 82 240 155 28 190 231 211 33 20 103 238 5 76 140 52 91 211 117 106 133 98 146 122 216 106 221 192 96 233 181 195 125 114 50 57 123 69 183 17 2 243 196 34 91 127 194 218 145 162 14 109 248 101 24 145 165 87 163 45 220 63 90 121 181 8 141 105 141 107 17 74 91 148 161 48 8 4 150 39 224 49 30 193 228 86 237 91 237 121 40 135 132 71 166 197 208 182 12 57 69 51 97 203 153 94 146 28 6 127 252 195 98 76 154 15 121 168 155 167 249 208 123 124 188 198 168 206 23 158 250 237 148 110 239 2 183 70 71 50 85 100 76 182 72 228 3 98 59 145 172 32 156 29 125 123 77 40 88 41 89 20 58 178 225 237 10 154 82 89 154 192 244 149 151 43 80 120 16 102 162 53 0 84 222 33 11 98 90 209 154 10 6 34 146 175 204 230 44 175 16 232 96 180 166 100 255 146 30 183 157 183 180 64 233 18 122 196 57 111 9 130 234 206 233 195 229 210 220 242 206 80 124 85 198 147 15 159 249 123 146 57 30 115 101 149 187 68 61 95 70 223 74 17 143 63 125 244 164 124 24 17 157 73 43 210 39 32 1 207 152 234 173 42 40 207 36 23 134 154 172 188 127 220 124 84 52 138 137 39 36 45 112 135 144 78 185 123 209 49 212 36 228 192 158 223 244 182 158 86 207 237 6 27 201 45 115 211 77 27 182 170 184 30 225 138 152 199 82 160 228 188 26 66 38 194 238 36 138 243 157 75 47 142 7 222 135 1 149 234 101 53 80 41 147 19 251 191 157 218 99 120 139 153 143 132 49 36 224 82 38 237 206 62 246 190 153 155 184 245 170 175 218 77 53 108 173 162 61 81 6 91 186 205 82 200 170 255 233 209 104 76 150 67 169 94 105 40 40 57 97 36 96 246 143 168 203 242 38 44 184 244 104 171 231 166 152 47 242 14 138 18 228 232 185 201 166 45 3 180 13 51 218 158 154 164 193 29 66 156 241 4 154 179 43 69 106 15 69 209 27 65 56 155 181 198 216 245 140 158 51 79 5 21 43 175 127 52 70 241 229 245 82 130 63 56 82 246 206 98 44 80 119 54 125 251 197 85 58 226 50 134 66 203 176 186 201 179 214 12 197 210 54 236 142 122 157 97 58 58 75 182 66 98 45 149 21 178 26 71 12 104 192 175 21 78 123 89 200 85 132 157 89 112 246 158 202 233 188 212 172 241 42 7 252 67 147 135 78 8 47 164 162 139 124 22 88 27 47 199 130 241 148 131 109 161 76 154 94 153 133 9 194 26 140 70 151 58 108 73 187 14 91 164 236 147 143 222 94 165 119 165 230 238 42 80 137 108 134 22 93 247 80 201 173 253 240 218 41 239 148 242 254 7 65 201 42 148 14 60 238 198 142 165 42 228 107 81 92 144 9 196 68 237 24 170 62 21 60 86 236 206 60 110 217 132 50 93 168 72 113 44 126 16 86 222 233 150 7 109 202 176 185 141 246 95 154 78 67 184 38 223 106 194 64 11 41 170 208 65 90 6 185 21 189 214 227 169 238 244 234 60 85 236 169 69 23 219 4 37 139 248 139 55 206 101 117 236 117 32 180 55 54 30 251 79 128 117 172 66 171 211 193 155 31 202 73 226 166 155 194 32 90 153 162 183 68 192 23 16 107 137 14 185 178 102 212 80 185 29 109 193 116 208 167 76 189 165 80 234 184 10 231 252 6 79 108 54 115 203 160 231 213 88 41 65 63 131 65 145 119 108 208 44 208 58 228 122 50 156 188 19 248 209 120 131 131 199 136 74 123 255 162 23 178 178 202 140 49 38 226 49 223 58 165 75 149 130 226 232 141 111 188 216 164 174 226 76 176 176 212 227 166 158 226 246 44 162 132 244 205 129 1 192 76 81 179 243 24 75 195 212 20 29 183 148 163 40 228 178 212 41 10 235 30 166 161 121 54 54 95 47 71 202 246 135 36 13 121 191 253 60 57 124 9 30 231 102 189 143 201 219 236 8 213 140 194 251 147 140 123 32 32 122 131 233 116 163 50 230 109 7 173 209 215 186 51 236 132 245 231 30 183 178 63 170 24 190 101 60 149 238 85 125 144 150 163 195 31 143 232 93 201 189 80 13 183 145 135 71 160 129 219 115 54 159 45 196 81 70 41 149 78 23 183 12 81 40 241 8 51 181 220 138 181 81 222 195 229 5 83 132 14 87 16 93 174 100 47 161 195 148 19 202 138 110 85 150 92 25 184 230 40 72 85 253 131 4 160 21 120 238 97 89 65 177 210 240 139 134 136 25 44 80 67 219 162 5 207 212 58 115 57 180 114 246 24 250 202 61 136 14 215 221 230 76 235 7 10 162 144 127 254 225 79 203 211 162 114 134 203 234 153 22 251 108 32 140 202 210 211 20 229 143 223 78 99 60 164 27 202 74 15 184 207 156 250 98 43 48 36 13 19 15 53 93 150 85 2 20 113 170 237 213 69 112 138 149 113 90 193 94 33 184 91 82 120 240 95 233 185 38 152 209 46 204 164 207 105 180 228 101 103 221 220 219 103 80 163 58 244 63 192 217 192 196 149 165 35 23 43 49 80 169 30 109 61 245 204 253 58 14 112 102 193 161 31 149 85 39 171 127 62 193 216 138 247 7 225 63 216 56 200 50 149 154 5 63 146 120 21 31 135 57 168 230 118 57 172 229 144 57 123 237 81 102 15 146 149 157 159 145 72 157 69 230 172 89 101 65 143 45 189 34 44 122 10 21 122 57 86 111 126 176 19 116 163 10 108 175 163 15 119 196 176 43 77 249 179 80 174 45 204 244 26 237 123 248 220 51 94 52 239 243 136 115 15 225 151 194 141 16 37 192 145 214 28 95 205 88 185 77 72 230 50 249 82 14 31 35 37 114 23 94 250 182 190 92 18 202 24 207 191 116 140 121 189 198 75 253 128 110 92 48 150 42 189 160 111 159 184 210 146 90 243 151 60 166 189 160 136 153 146 75 205 221 21 97 15 93 202 30 6 193 253 202 61 138 228 255 16 85 168 162 119 216 180 110 136 43 155 64 247 174 239 61 200 145 15 69 36 154 134 194 143 81 207 100 95 68 5 42 238 96 11 76 13 0 215 24 227 243 78 27 183 133 43 193 63 249 254 66 202 221 55 148 236 77 139 32 222 150 201 1 233 173 244 58 62 25 179 70 133 101 73 104 34 28 69 152 147 45 20 251 234 245 46 108 34 181 135 43 20 11 147 180 172 153 129 203 125 88 201 177 240 74 166 138 102 110 118 134 206 24 183 103 89 145 83 106 250 239 165 146 181 71 74 97 7 216 5 225 123 205 74 187 146 198 107 113 32 174 92 126 167 165 133 13 75 76 216 43 243 100 97 3 43 34 67 23 179 35 158 119 215 68 209 210 135 223 2 11 49 161 212 212 159 187 102 138 252 31 155 255 132 246 240 163 172 176 208 87 144 87 90 133 128 132 129 0 229 72 91 193 104 66 87 76 118 57 0 82 179 201 188 200 83 217 65 97 142 204 253 197 101 61 30 187 191 194 1 7 118 183 245 114 57 218 180 189 239 172 50 250 43 129 18 165 1 33 41 169 31 139 20 142 45 61 115 119 232 208 67 213 133 30 30 182 142 102 85 18 120 203 130 118 31 147 149 163 207 222 30 199 244 247 201 19 160 142 142 22 152 91 12 50 212 205 149 140 248 90 67 233 159 54 45 89 120 223 75 234 13 89 122 68 153 79 205 173 84 222 178 231 141 113 8 8 182 142 31 164 83 220 59 127 60 76 8 148 243 182 34 248 252 214 151 239 173 33 110 105 3 88 209 143 227 17 42 151 193 164 125 93 235 105 216 198 209 214 174 198 44 240 220 139 61 122 45 235 99 107 202 177 186 121 111 180 112 65 77 55 113 234 163 243 132 100 234 238 142 19 185 151 173 241 146 4 244 176 203 86 110 12 92 207 100 44 54 93 152 168 46 93 39 197 61 208 109 69 179 3 96 151 173 36 224 196 0 185 117 27 36 45 184 22 215 93 152 134 204 131 109 233 169 9 188 173 255 6 239 4 71 133 17 178 216 150 249 175 178 232 88 160 16 54 174 192 77 208 100 45 77 85 200 103 80 155 16 71 5 94 150 94 135 213 119 156 220 89 106 153 177 118 32 250 219 49 118 241 208 183 205 14 58 219 175 190 143 233 87 175 95 173 216 76 84 186 154 17 86 233 213 161 90 10 31 72 154 219 120 97 72 229 44 208 235 111 172 118 97 7 162 215 12 152 95 45 137 158 77 136 43 4 66 175 22 194 99 80 130 134 172 40 241 232 158 78 84 162 230 13 156 5 227 2 25 200 133 62 149 210 68 150 39 202 189 157 174 109 82 111 102 201 123 208 252 94 31 234 101 193 157 41 57 220 72 252 205 81 120 208 44 108 166 36 33 99 224 140 165 159 53 164 61 121 161 107 189 14 240 235 123 71 96 209 189 197 130 149 13 185 247 137 240 90 56 150 134 26 243 196 137 128 153 33 82 118 122 72 245 25 154 28 216 81 64 179 128 103 91 224 81 27 199 54 250 60 58 239 79 98 239 9 11 58 64 111 149 23 202 177 21 141 166 224 25 177 90 202 27 104 179 210 251 196 8 190 189 218 97 140 230 23 88 34 82 201 212 107 122 250 135 38 158 228 202 195 200 48 173 153 181 55 211 178 10 65 158 51 42 220 225 90 21 102 21 233 76 174 178 200 36 2 226 197 33 241 186 94 19 11 33 66 11 152 183 73 178 66 213 94 61 181 59 240 186 177 22 234 66 154 146 121 199 101 85 203 195 101 52 67 208 148 30 162 190 183 95 145 21 227 196 83 55 66 232 61 176 153 218 228 143 204 98 238 126 23 111 80 170 186 121 221 245 90 198 18 76 160 184 98 19 150 238 214 229 234 15 67 144 36 229 80 183 235 26 201 103 184 142 180 246 48 163 109 0 90 221 160 209 246 229 42 41 142 195 126 81 199 157 102 89 156 53 94 174 56 201 168 107 177 228 64 175 148 24 172 184 235 213 30 168 114 134 86 135 133 205 44 30 80 144 2 112 81 141 48 91 237 249 109 47 178 173 140 110 10 123 80 174 85 103 103 17 2 155 82 230 94 25 197 10 48 22 99 22 189 218 187 98 188 159 179 246 10 77 111 139 136 79 31 119 23 90 88 231 27 20 206 21 153 210 192 74 238 203 83 75 6 114 141 189 150 7 166 58 186 148 109 248 65 188 116 18 54 212 101 249 172 233 6 204 130 161 5 175 235 141 189 38 69 143 132 169 7 79 71 233 194 240 207 191 97 63 181 39 60 60 36 202 5 123 60 135 29 102 45 2 242 216 139 251 48 113 244 133 167 63 16 109 199 36 2 109 126 250 206 8 24 217 241 34 132 157 181 83 163 210 235 60 165 119 94 8 224 29 204 97 71 2 111 233 133 21 165 253 6 182 69 205 141 113 180 136 26 172 179 206 10 208 156 23 193 119 1 184 235 204 108 58 110 114 58 78 217 45 40 144 227 20 145 38 215 2 128 75 189 217 190 124 142 26 57 60 55 130 44 77 225 164 185 171 195 168 107 197 18 31 76 188 45 93 124 34 128 121 109 93 203 96 57 107 127 91 129 189 76 30 196 27 196 193 56 185 159 19 30 186 202 22 71 185 215 16 132 153 16 34 105 94 152 246 200 189 208 160 10 109 174 205 12 220 29 22 175 26 72 179 237 5 143 195 222 152 196 221 108 116 62 48 158 85 26 168 248 56 105 58 244 16 47 252 111 46 248 80 186 220 223 209 87 211 134 86 15 10 145 13 27 118 225 76 185 119 224 9 23 239 132 75 222 36 79 29 222 4 40 231 235 11 32 58 232 137 206 123 0 96 231 228 248 123 82 173 146 105 115 161 84 106 247 137 185 22 37 192 236 80 43 189 202 32 115 249 0 247 165 96 158 197 105 155 67 203 99 244 97 182 167 100 239 150 217 4 207 5 53 8 204 94 204 237 9 146 175 46 62 201 194 50 137 202 251 67 138 144 160 174 227 39 111 30 38 30 235 29 129 50 25 11 249 8 91 238 31 160 93 61 48 52 94 109 237 198 41 111 237 243 30 49 210 225 58 163 143 12 220 152 67 104 0 253 169 194 11 17 55 52 141 84 222 139 206 6 109 38 77 152 148 168 189 171 134 205 198 29 131 182 204 216 215 97 199 10 227 244 60 33 157 85 220 33 220 135 209 69 205 150 129 176 131 206 27 10 194 114 105 111 83 71 225 242 176 108 219 49 158 78 183 170 14 83 200 101 21 150 89 134 101 216 101 216 95 95 229 222 205 236 179 132 106 52 57 40 211 59 16 8 84 249 230 51 182 227 144 19 8 86 133 68 154 164 156 218 179 61 136 139 100 133 43 58 121 234 50 110 150 43 229 34 200 37 174 4 183 173 247 189 16 86 240 25 29 196 120 233 125 203 228 163 88 174 137 71 220 202 172 92 223 175 94 173 47 13 167 109 25 122 19 138 79 226 21 162 73 188 74 157 71 213 5 210 163 203 6 127 38 82 74 150 19 91 141 195 194 207 160 226 97 153 129 225 106 226 253 50 141 123 166 50 91 114 25 86 125 214 204 101 205 106 83 146 173 23 85 17 230 235 30 163 104 14 123 21 21 198 174 35 211 79 45 149 214 139 67 33 164 157 228 116 173 35 97 233 71 118 139 134 151 100 51 248 26 242 32 72 105 111 220 37 89 14 91 84 75 143 38 122 74 188 251 199 166 4 199 112 50 30 15 198 133 81 238 176 152 188 13 171 163 139 117 111 33 32 211 54 115 214 110 172 239 164 241 78 13 92 115 234 29 155 54 86 179 136 238 235 96 232 25 194 216 171 37 5 84 122 142 68 69 72 76 240 139 160 44 105 21 185 125 162 55 165 121 160 50 21 174 104 54 51 181 145 83 76 114 112 72 138 42 44 239 240 203 66 4 80 206 82 240 74 76 191 132 214 7 74 88 28 196 11 52 42 239 208 198 85 48 90 67 92 196 173 212 38 25 140 236 115 147 34 64 25 221 79 199 166 26 178 67 42 106 220 96 190 190 34 143 41 21 105 42 0 43 97 183 40 239 52 235 74 42 74 172 169 134 173 163 107 162 236 176 17 46 32 77 149 4 134 153 201 42 116 85 83 119 246 94 74 232 64 155 9 173 201 25 1 170 78 138 152 98 85 203 102 245 202 139 218 214 219 121 105 179 97 174 40 115 157 133 204 132 109 127 132 8 118 175 73 145 106 30 20 191 148 135 229 235 176 15 214 163 249 204 218 71 247 24 45 23 172 120 245 142 37 238 132 157 178 70 17 124 111 227 125 10 29 170 70 160 90 135 95 82 231 121 195 54 53 8 159 94 101 22 141 14 140 84 50 130 179 171 92 62 179 214 145 155 177 236 49 36 103 180 91 27 165 148 150 55 13 120 113 132 13 250 241 66 22 227 194 61 185 49 205 22 37 11 10 105 143 244 158 9 186 191 160 200 28 31 81 182 6 96 139 125 241 207 39 148 46 244 153 14 197 4 104 221 101 69 52 65 29 238 36 108 227 15 185 115 233 180 138 191 129 106 58 35 72 55 57 250 49 178 162 115 62 215 235 74 70 239 43 23 156 61 61 67 36 170 195 134 10 183 152 120 17 128 119 16 103 46 44 5 217 132 73 243 176 249 205 195 14 70 28 250 153 204 180 56 159 246 238 46 182 201 251 31 73 160 88 94 120 135 55 229 45 55 161 184 104 86 135 206 39 239 97 243 38 80 156 161 103 55 193 177 2 21 149 203 222 66 140 108 162 201 220 35 111 136 54 243 30 255 144 82 101 21 253 246 165 151 137 123 51 24 255 218 131 105 39 18 12 214 145 149 177 249 65 50 53 156 71 25 102 121 45 34 231 40 165 47 203 62 57 198 206 75 183 94 112 153 76 27 103 222 194 88 133 197 141 173 77 53 115 58 24 182 250 192 7 186 216 204 182 201 25 160 132 118 196 182 90 159 145 224 95 206 64 192 69 4 210 149 183 239 2 179 210 186 94 145 187 223 180 206 219 130 117 24 78 119 253 111 77 116 141 167 193 185 58 175 155 39 10 215 174 155 244 188 209 75 2 230 153 216 142 90 172 111 58 229 180 117 238 237 188 214 28 174 60 108 94 1 106 144 39 120 101 99 152 119 242 55 27 127 213 65 154 38 61 136 172 221 204 235 133 89 100 202 29 20 174 7 201 51 100 242 32 243 128 161 13 60 43 211 72 208 84 182 42 255 35 44 1 228 103 94 79 65 201 133 26 86 234 129 58 79 30 153 183 237 116 215 222 49 74 49 187 241 6 143 6 230 146 45 135 222 186 94 8 55 150 254 151 28 152 164 73 242 214 72 184 112 34 206 22 118 167 135 174 62 121 3 39 152 35 118 2 146 224 82 43 179 250 206 51 11 111 151 36 145 168 113 127 158 51 244 130 228 214 11 190 245 227 12 150 206 59 131 147 98 253 223 27 48 59 52 107 232 19 19 96 243 36 153 145 74 229 125 133 246 245 222 247 47 80 229 213 231 94 11 143 198 5 155 205 29 185 230 205 122 225 214 181 9 157 172 14 236 81 109 206 5 127 20 30 49 252 203 56 112 158 138 114 13 72 206 4 111 26 118 54 22 236 56 47 93 41 245 158 41 220 158 94 16 30 135 16 146 103 97 251 46 38 14 165 93 121 235 186 43 69 146 220 188 131 100 104 66 17 189 101 51 118 75 26 7 5 70 141 211 51 182 246 87 228 40 97 107 155 209 55 109 232 153 163 166 55 225 208 141 74 253 162 241 5 0 158 65 41 101 216 170 148 213 115 78 134 239 106 56 67 234 196 146 231 72 157 104 146 99 162 61 165 187 230 50 239 148 225 95 234 160 149 47 108 10 164 173 223 5 142 0 171 93 196 69 134 5 131 83 16 130 198 230 97 69 52 238 177 161 97 65 64 146 102 109 239 3 83 40 118 17 208 91 215 97 165 216 225 211 0 219 3 59 232 70 37 30 154 241 185 48 61 81 135 127 134 36 69 194 173 87 39 58 159 213 101 64 132 209 219 64 195 112 221 3 201 51 214 98 197 104 253 175 72 64 113 22 158 182 229 199 227 116 26 254 101 159 44 155 218 103 133 121 189 154 146 153 209 158 255 161 14 144 66 96 172 255 193 189 85 30 244 207 29 117 72 108 205 223 176 243 25 46 42 252 243 13 30 70 196 255 53 206 184 12 206 11 207 90 114 105 137 140 44 161 202 87 184 241 196 4 115 238 141 227 185 71 117 188 200 216 24 146 89 38 104 34 207 237 120 145 188 78 11 251 93 132 206 134 44 24 74 104 136 208 21 226 116 242 40 13 181 61 52 145 70 96 0 109 70 127 22 222 134 252 43 55 52 10 133 33 10 159 30 39 205 221 101 158 135 4 173 246 191 224 226 109 162 16 35 112 172 144 156 246 247 132 90 151 238 66 53 25 135 31 49 36 64 244 192 152 117 154 42 80 128 94 142 87 194 50 231 25 152 29 136 75 195 149 210 205 50 98 7 80 138 200 91 23 164 92 188 248 255 0 0 0 255 255 3 0 160 117 37 221 91 190 154 158 0 0 0 0 73 69 78 68 174 66 96 130]! !!PNGReadWriterTest methodsFor: 'tests - grayscale' stamp: 'ar 1/7/2011 16:50'!testGrayScale	| form reader |	reader := PNGReadWriter on: self grayScaleData readStream.	form := reader nextImage.	self assert: form extent = (217@125).	self assert: form depth = 8.! !"GraphicsTests"!!Process methodsFor: '*KernelTests-Processes' stamp: 'ar 12/31/2010 09:30'!suspendPrimitivelyOrFail	"Test support. Execute primitive 88, or fail."	<primitive: 88>	^self primitiveFailed! !!ProcessTest methodsFor: 'tests' stamp: 'ar 12/31/2010 10:36'!testAtomicSuspend	"Test atomic suspend of foreign processes"	| list p sema |	sema := Semaphore new.	p := [sema wait] fork.	Processor yield.	self shouldnt: [list := p suspendPrimitivelyOrFail] raise: Error.	self assert: list == sema.! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:49' prior: 35217801!testDegreeCosForExceptionalValues	self assert: Float nan degreeCos isNaN.	self assert: Float infinity degreeCos isNaN.	self assert: Float infinity negated degreeCos isNaN.! !!FloatTest methodsFor: 'test - mathematical functions' stamp: 'nice 10/31/2010 21:49' prior: 35218193!testDegreeSinForExceptionalValues	self assert: Float nan degreeSin isNaN.	self assert: Float infinity degreeSin isNaN.	self assert: Float infinity negated degreeSin isNaN.! !FloatConsistencyTests removeSelector: #vectorVectorTest:on:!FloatConsistencyTests removeSelector: #vectorVectorTest:!FloatConsistencyTests removeSelector: #vectorTest:!FloatConsistencyTests removeSelector: #vectorScalarTest:on:!FloatConsistencyTests removeSelector: #vectorScalarTest:!FloatConsistencyTests removeSelector: #testTimesTwoPower!FloatConsistencyTests removeSelector: #testTanStd!FloatConsistencyTests removeSelector: #testTanHStd!FloatConsistencyTests removeSelector: #testTanH!FloatConsistencyTests removeSelector: #testTan!FloatConsistencyTests removeSelector: #testSum!FloatConsistencyTests removeSelector: #testSubScalar!FloatConsistencyTests removeSelector: #testSubArray!FloatConsistencyTests removeSelector: #testSqrt!FloatConsistencyTests removeSelector: #testSinStd!FloatConsistencyTests removeSelector: #testSinHStd!FloatConsistencyTests removeSelector: #testSinH!FloatConsistencyTests removeSelector: #testSin!FloatConsistencyTests removeSelector: #testNormalize!FloatConsistencyTests removeSelector: #testMulScalar!FloatConsistencyTests removeSelector: #testMulArray!FloatConsistencyTests removeSelector: #testMD5!FloatConsistencyTests removeSelector: #testLog10!FloatConsistencyTests removeSelector: #testLog!FloatConsistencyTests removeSelector: #testLength!FloatConsistencyTests removeSelector: #testHypot!FloatConsistencyTests removeSelector: #testFractionStd!FloatConsistencyTests removeSelector: #testFraction!FloatConsistencyTests removeSelector: #testFloatAt!FloatConsistencyTests removeSelector: #testExpStd!FloatConsistencyTests removeSelector: #testExp!FloatConsistencyTests removeSelector: #testDot!FloatConsistencyTests removeSelector: #testDivScalar!FloatConsistencyTests removeSelector: #testDivArray!FloatConsistencyTests removeSelector: #testCosStd!FloatConsistencyTests removeSelector: #testCosHStd!FloatConsistencyTests removeSelector: #testCosH!FloatConsistencyTests removeSelector: #testCos!FloatConsistencyTests removeSelector: #testArcTanStd!FloatConsistencyTests removeSelector: #testArcTanHStd!FloatConsistencyTests removeSelector: #testArcTanH!FloatConsistencyTests removeSelector: #testArcTan2!FloatConsistencyTests removeSelector: #testArcTan!FloatConsistencyTests removeSelector: #testArcSinStd!FloatConsistencyTests removeSelector: #testArcSinHStd!FloatConsistencyTests removeSelector: #testArcSinH!FloatConsistencyTests removeSelector: #testArcSin!FloatConsistencyTests removeSelector: #testArcCosStd!FloatConsistencyTests removeSelector: #testArcCosHStd!FloatConsistencyTests removeSelector: #testArcCosH!FloatConsistencyTests removeSelector: #testArcCos!FloatConsistencyTests removeSelector: #testAddScalar!FloatConsistencyTests removeSelector: #testAddArray!FloatConsistencyTests removeSelector: #step4:x:y:z:data:add:shift:!FloatConsistencyTests removeSelector: #step3:x:y:z:data:add:shift:!FloatConsistencyTests removeSelector: #step2:x:y:z:data:add:shift:!FloatConsistencyTests removeSelector: #step1:x:y:z:data:add:shift:!FloatConsistencyTests removeSelector: #rotate:by:!FloatConsistencyTests removeSelector: #processResult:stream:!FloatConsistencyTests removeSelector: #md5Transform:hash:!FloatConsistencyTests removeSelector: #md5HashStream:!FloatConsistencyTests removeSelector: #md5HashMessage:!FloatConsistencyTests removeSelector: #md5Hash:!FloatConsistencyTests removeSelector: #md5Digest:!FloatConsistencyTests removeSelector: #hashStreamFrom:!FloatConsistencyTests removeSelector: #hashStream:!FloatConsistencyTests removeSelector: #floatTest:!FloatConsistencyTests removeSelector: #fillVector:!FloatConsistencyTests removeSelector: #copysign:from:!Smalltalk removeClassNamed: #FloatConsistencyTests!FloatTest removeSelector: #testSignalingNaN!FloatTest removeSelector: #testNonSignalingNaN!"KernelTests"!!Preferences commentStamp: '<historical>' prior: 59382373!A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  	To open the control panel:		Preferences openFactoredPanel	To read how to use the panel (and how to make a preference be per-project):		 Preferences giveHelpWithPreferencesAll messages are on the class side.To query a a preference:	Preferences logDebuggerStackToFileor some people prefer the more verbose	Preferences valueOfFlag: #logDebuggerStackToFileYou can make up a new preference any time.  Do not define a new message in Preferences class. Accessor methods are compiled automatically when you add a preference as illustrated below:To add a preference (e.g. in the Postscript of a fileout):	Preferences addPreference: #samplePreference categories: #(general browsing)		default: true balloonHelp: 'This is an example of a preference added by a do-it'		projectLocal: false changeInformee: nil changeSelector: nil.To change a preference programatically:	Preferences disable: #logDebuggerStackToFile.Or to turn it on,	Preferences enable: #logDebuggerStackToFile.!!SmalltalkImage methodsFor: 'miscellaneous' stamp: 'jrd 6/10/2009 12:54'!dumpException: ex	self 		logSqueakError: ex description 		inContext: ex signalerContext .! !!SmalltalkImage methodsFor: 'license' stamp: 'cmm 1/11/2011 18:58' prior: 59192143!license	"This method contains the text of the license agreement for Squeak."	^ 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2011 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !!SmalltalkImage methodsFor: 'shrinking' stamp: 'dtl 1/18/2011 21:39' prior: 34387537!unloadAllKnownPackages	"Unload all packages we know how to unload and reload"	"Prepare unloading"	Smalltalk zapMVCprojects.	Flaps disableGlobalFlaps: false.	StandardScriptingSystem removeUnreferencedPlayers.	Project removeAllButCurrent.	#('Morphic-UserObjects' 'EToy-UserObjects' 'Morphic-Imported' )		do: [:each | SystemOrganization removeSystemCategory: each].	Smalltalk at: #ServiceRegistry ifPresent:[:aClass|		SystemChangeNotifier uniqueInstance			noMoreNotificationsFor: aClass.	].	World removeAllMorphs.	"Go unloading"	#(	'ReleaseBuilder' 'ScriptLoader'		'311Deprecated' '39Deprecated'		'Universes' 'SMLoader' 'SMBase' 'Installer-Core'		'VersionNumberTests' 'VersionNumber'		'Services-Base' 'PreferenceBrowser' 'Nebraska'		'ToolBuilder-MVC' 'ST80'		'CollectionsTests' 'GraphicsTests' 'KernelTests'  'MorphicTests' 		'MultilingualTests' 'NetworkTests' 'ToolsTests' 'TraitsTests'		'SystemChangeNotification-Tests' 'FlexibleVocabularies' 		'EToys' 'Protocols' 'XML-Parser' 'Tests' 'SUnitGUI'		'Help-Squeak' 'HelpSystem' 'SystemReporter'	) do: [:pkgName| 			(MCPackage named: pkgName) unload.			MCMcmUpdater disableUpdatesOfPackage: pkgName.			].	"Traits use custom unload"	Smalltalk at: #Trait ifPresent:[:aClass| aClass unloadTraits].	"Post-unload cleanup"	MCWorkingCopy flushObsoletePackageInfos.	SystemOrganization removeSystemCategory: 'UserObjects'.	Presenter defaultPresenterClass: nil.	World dumpPresenter.	ScheduledControllers := nil.	Preferences removePreference: #allowEtoyUserCustomEvents.	SystemOrganization removeEmptyCategories.	ChangeSet removeChangeSetsNamedSuchThat:[:cs | (cs == ChangeSet current) not].	Undeclared removeUnreferencedKeys.	StandardScriptingSystem initialize.	MCFileBasedRepository flushAllCaches.	MCDefinition clearInstances.	Behavior flushObsoleteSubclasses.	ChangeSet current clear.	ChangeSet current name: 'Unnamed1'.	Smalltalk flushClassNameCache.	Smalltalk at: #Browser ifPresent:[:br| br initialize].	DebuggerMethodMap voidMapCache.	DataStream initialize.	Smalltalk forgetDoIts.	AppRegistry removeObsolete.	FileServices removeObsolete.	Preferences removeObsolete.	TheWorldMenu removeObsolete.	Smalltalk garbageCollect.	Symbol compactSymbolTable.	TheWorldMainDockingBar updateInstances.	MorphicProject defaultFill: (Color gray: 0.9).	World color: (Color gray: 0.9).! !!ReferenceStream methodsFor: 'writing' stamp: 'nk 5/4/2004 14:40' prior: 27614124!project	"Return the project we are writing or nil"	(topCall respondsTo: #isCurrentProject) ifTrue: [^ topCall].	(topCall respondsTo: #do:) ifTrue: [1 to: 5 do: [:ii | 		((topCall at: ii ifAbsent: [ ^nil ]) respondsTo: #isCurrentProject) ifTrue: [^ topCall at: ii]]].	^ nil! !!Preferences class methodsFor: 'accessing' stamp: 'ul 1/10/2011 15:53'!accessDictionaryOfPreferencesIn: aBlock	^(AccessLock ifNil: [ AccessLock := Mutex new ])		critical: [ aBlock value: DictionaryOfPreferences ]! !!Preferences class methodsFor: 'add preferences' stamp: 'ul 1/10/2011 15:59' prior: 55142738!addPreference: aName categories: categoryList default: aValue balloonHelp: helpString projectLocal: localBoolean changeInformee: informeeSymbol changeSelector: aChangeSelector type: aType	"Add or replace a preference as indicated.  Reuses the preexisting Preference object for this symbol, if there is one, so that UI artifacts that interact with it will remain valid."	| aPreference aPrefSymbol |	aPrefSymbol := aName asSymbol.	aPreference := self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences			 at:aPrefSymbol			 ifAbsent: [ Preference new ] ].	aPreference 		 name:aPrefSymbol		 defaultValue:aValue		 helpString:helpString		 localToProject:localBoolean		 categoryList:categoryList		 changeInformee:informeeSymbol		 changeSelector:aChangeSelector		 type: aType.	self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences at: aPrefSymbol put: aPreference ].	self  compileAccessMethodForPreference:aPreference! !!Preferences class methodsFor: 'preference-object access' stamp: 'ul 1/10/2011 15:59' prior: 26930349!allPreferenceObjects	"Answer a list of all the Preference objects registered in the system"	^self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences values ]! !!Preferences class methodsFor: 'preferences panel' stamp: 'ul 1/10/2011 16:01' prior: 55165499!categoryNames	| aSet |	aSet := Set new.	self allPreferenceObjects do: [ :aPreference | 		aSet addAll: (			aPreference categoryList collect: [ :aCategory |				aCategory asSymbol ]) ].	^aSet! !!Preferences class methodsFor: 'accessing' stamp: 'ul 1/10/2011 16:37' prior: 26841184!dictionaryOfPreferences	"The use of this accessor doesn't ensure that the dictionary is not accessed concurrently. Use #accessDictionaryOfPreferencesIn: instead."	^DictionaryOfPreferences! !!Preferences class methodsFor: 'preferences panel' stamp: 'ul 1/10/2011 16:06' prior: 26925756!inspectPreferences	"Open a window on the current preferences dictionary, allowing the user to inspect and change the current preference settings.  This is fallen back upon if Morphic is not present. This is dangerous, the dictionary of preferences should not be accessed concurrently."	"Preferences inspectPreferences"	self dictionaryOfPreferences inspectWithLabel:'Preferences'! !!Preferences class methodsFor: 'window colors' stamp: 'bp 1/8/2011 13:00' prior: 26972061!installPastelWindowColors	"Install the factory-provided default pastel window colors for all tools"	"Preferences installPastelWindowColors"	self installWindowColorsVia: [:aSpec | aSpec pastelColor]! !!Preferences class methodsFor: 'window colors' stamp: 'bp 1/8/2011 12:56' prior: 58954895!installWindowColorsVia: colorSpecBlock	"Install windows colors using colorSpecBlock to deliver the color source for each element; the block is handed a WindowColorSpec object"	"Preferences installBrightWindowColors"		WindowColorRegistry refresh.	self windowColorTable do:		[:aColorSpec | | color |			color := (Color colorFrom: (colorSpecBlock value: aColorSpec)).			self setWindowColorFor: aColorSpec classSymbol to: color].	SystemWindow withAllSubclasses do: [:c | 		c allInstances do: [:w | w refreshWindowColor]].	TheWorldMainDockingBar updateInstances! !!Preferences class methodsFor: 'reacting to change' stamp: 'bp 1/8/2011 12:59' prior: 57735085!noviceModeSettingChanged	"The current value of the noviceMode flag has changed;  	now react"	TheWorldMainDockingBar updateInstances.	PasteUpMorph allSubInstances		select: [:each | each isWorldMorph]		thenDo: [:each | each initializeDesktopCommandKeySelectors].	Smalltalk at: #ParagraphEditor ifPresent: [:aClass| aClass initialize]! !!Preferences class methodsFor: 'dynamic preferences' stamp: 'ul 1/10/2011 16:20' prior: 55145714!prefEvent: anEvent	"Check if this system event defines or removes a preference.	TODO: Queue the event and handle in background process. 	There is zero reason to be so eager here."	| aClass aSelector prefSymbol method |	(anEvent itemKind = SystemChangeNotifier classKind and: [anEvent isRemoved])		ifTrue:[self removePreferencesFor: anEvent item].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue:[		aClass := anEvent itemClass.		aClass isMeta ifFalse:[^self]. "ignore instance methods"		aClass := aClass theNonMetaClass.		aSelector := anEvent itemSelector.		(anEvent isRemoved or:[anEvent isModified]) ifTrue:[			prefSymbol := (aClass name,'>>', aSelector) asSymbol.			self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |				dictionaryOfPreferences removeKey: prefSymbol ifAbsent:[] ] ].		(anEvent isAdded or:[anEvent isModified]) ifTrue:[			method := anEvent item.			method pragmas do:[:pragma| | aPreference aPrefSymbol |				pragma keyword == #preference:category:description:type: ifTrue:[					aPrefSymbol := (aClass name,'>>', method selector) asSymbol.					aPreference := self 						preference: pragma arguments first						category: pragma arguments second 						description: pragma arguments third						type: pragma arguments fourth.					aPreference 						provider: aClass 						getter: method selector 						setter: method selector asMutator.					self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |						dictionaryOfPreferences at: aPrefSymbol put: aPreference ] ] ] ] ].! !!Preferences class methodsFor: 'preference-object access' stamp: 'ul 1/10/2011 16:22' prior: 26930573!preferenceAt: aSymbol 	"Answer the Preference object at the given symbol, or nil if not there"	^self preferenceAt: aSymbol ifAbsent: [ nil ]! !!Preferences class methodsFor: 'preference-object access' stamp: 'ul 1/10/2011 16:21' prior: 26930821!preferenceAt: aSymbol ifAbsent: aBlock 	"Answer the Preference object at the given symbol, or the value of aBlock if not present"	^self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences at: aSymbol ifAbsent: aBlock ]! !!Preferences class methodsFor: 'preferences panel' stamp: 'ul 1/10/2011 16:24' prior: 55142402!preferenceObjectsInCategory: aCategorySymbol 	"Answer a list of Preference objects that reside in the given category."	^self allPreferenceObjects select: [ :aPreference |		aPreference categoryList includes: aCategorySymbol ]! !!Preferences class methodsFor: 'dynamic preferences' stamp: 'ul 1/10/2011 16:24' prior: 55166421!registerForEvents	"Preferences registerForEvents"		SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	SystemChangeNotifier uniqueInstance notify: self ofAllSystemChangesUsing: #prefEvent:.	Smalltalk allClassesDo:[:aClass|		aClass class methodsDo:[:method|			method pragmas do:[:pragma| | aPreference aPrefSymbol |				pragma keyword == #preference:category:description:type: ifTrue:[					aPrefSymbol := (aClass name,'>>', method selector) asSymbol.					aPreference := self 						preference: pragma arguments first						category: pragma arguments second 						description: pragma arguments third						type: pragma arguments fourth.					aPreference 						provider: aClass 						getter: method selector 						setter: method selector asMutator.					self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |						dictionaryOfPreferences at: aPrefSymbol put: aPreference ] ] ] ] ].! !!Preferences class methodsFor: 'initialization' stamp: 'ul 1/10/2011 16:25' prior: 55165795!removePreference: aSymbol 	"Remove all memory of the given preference symbol in my various structures."	| pref |	pref := self  preferenceAt:aSymbol  ifAbsent:[^ self].	pref localToProject 		 ifTrue:			[Project  allInstancesDo:					[:proj | 					proj projectPreferenceFlagDictionary  ifNotNil:							[proj projectPreferenceFlagDictionary  removeKey:aSymbol  ifAbsent:[]]]].	self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences removeKey: aSymbol ifAbsent: [] ].	self class  removeSelector:aSymbol	"Preferences removePreference: #tileToggleInBrowsers"! !!Preferences class methodsFor: 'dynamic preferences' stamp: 'ul 1/10/2011 16:27' prior: 55147626!removePreferencesFor: aClass	"Remove all the preferences registered for the given class"	"Preferences removePreferencesFor: PreferenceExample"	self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		| map |		map := dictionaryOfPreferences select: [ :pref | pref provider == aClass ].		map keysDo: [ :prefName | dictionaryOfPreferences removeKey: prefName ] ]! !!Preferences class methodsFor: 'personalization' stamp: 'ul 1/10/2011 16:27' prior: 26922133!savePersonalPreferences	"Save the current list of Preference settings as the user's personal choices"	self		setParameter:#PersonalDictionaryOfPreferences		to: (			self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |				dictionaryOfPreferences deepCopy ])! !!Preferences class methodsFor: 'standard queries' stamp: 'cmm 1/11/2011 21:10' prior: 0!showBoundsInHalo	^ self		valueOfFlag: #showBoundsInHalo		ifAbsent: [true]! !!Preferences class methodsFor: 'standard queries' stamp: 'cmm 1/10/2011 14:07' prior: 0!showSplitterHandles	^ self		valueOfFlag: #showSplitterHandles		ifAbsent: [false]! !!Preferences class methodsFor: 'personalization' stamp: 'ul 1/10/2011 16:27' prior: 59139888!storePreferencesIn: aFileName 	| stream prefsSnapshot |	#(#Prevailing #PersonalPreferences )  do:[:ea | Parameters  removeKey:ea  ifAbsent:[]].	stream := ReferenceStream fileNamed: aFileName.	stream  nextPut:Parameters.	prefsSnapshot := self accessDictionaryOfPreferencesIn: [ :dictionaryOfPreferences |		dictionaryOfPreferences copy ].	prefsSnapshot keysAndValuesDo: [:key :pref | prefsSnapshot at: key put: pref asPreference].	stream  nextPut: prefsSnapshot.	Smalltalk isMorphic 		 ifTrue:[stream nextPut:World fillStyle]		 ifFalse:[stream nextPut:DesktopColor].	stream close! !!SystemDictionary methodsFor: 'classes and traits' stamp: 'bf 1/11/2011 15:05' prior: 35144455!classAndTraitNames	"Answer a sorted collection of all class and trait (not including class-traits) names. The performance of this algorithm is O(n) if the classNames are already cached, otherwise O(n*log(n)) where n is self size."	| classNames traitNames result temporary |	classNames := self classNames.	traitNames := self traitNames.	traitNames ifEmpty: [^classNames].	temporary := Array new: classNames size + traitNames size.	result := temporary shallowCopy.	temporary		replaceFrom: 1		to: classNames size		with: classNames		startingAt: 1;		replaceFrom: classNames size + 1		to: temporary size		with: traitNames		startingAt: 1;		mergeFirst: 1		middle: classNames size		last: temporary size		into: result		by: nil.	^result! !SystemDictionary removeSelector: #dumpException:!"System"!!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:42' prior: 56658036!importIconNamed: aString	"self importIconNamed: 'appearanceIcon'"	"will create a method appearanceIconContents holding the string representation of the	icon, and a method appearanceIcon to access a form built using that string"		| writer image stream |	writer := GIFReadWriter on: (FileStream fileNamed: './icons/', aString, '.gif').	image := [ writer nextImage]			ensure: [writer close].	"store string representation"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString, 'Contents' ; cr.	stream nextPutAll: (self methodStart: aString).	image storeOn: stream.	stream nextPutAll: self methodEnd.	stream close.	MenuIcons class compile: stream contents classified: 'private - icons' notifying: nil.	"create accessor method"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString ; cr.	stream nextPutAll: (self methodAccessorFor: aString).	MenuIcons class compile: stream contents classified: 'accessing - icons' notifying: nil.	^ stream contents! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 21:15'!importPngIconNamed: aString	"self importIconNamed: 'appearanceIcon'"	"will create a method appearanceIconContents holding the string representation of the	icon, and a method appearanceIcon to access a form built using that string"		| writer image stream |	writer := PNGReadWriter on: (FileStream fileNamed: './icons/', aString, '.png').	image := [ writer nextImage]			ensure: [writer close].	"store string representation"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString, 'Contents' ; cr.	stream nextPutAll: (self methodStart: aString).	image storeOn: stream.	stream nextPutAll: self methodEnd.	stream close.	MenuIcons class compile: stream contents classified: 'private - icons' notifying: nil.	"create accessor method"	stream := ReadWriteStream on: (String new).	stream nextPutAll: aString ; cr.	stream nextPutAll: (self methodAccessorFor: aString).	MenuIcons class compile: stream contents classified: 'accessing - icons' notifying: nil.	^ stream contents! !!MenuIcons class methodsFor: 'menu decoration' stamp: 'MAD 12/30/2010 23:19' prior: 23490348!itemsIcons	"answer a collection of associations wordings -> icon to  	decorate  	the menus all over the image"	| icons |	icons := OrderedCollection new.	"icons add: #('Test Runner' ) -> self smallTrafficIcon."	" 	world menu"	icons add: #('previous project' 'go to previous project') -> self smallProjectBackIcon.	icons add: #('go to next project') -> self smallProjectNextIcon.	icons add: #('select' ) -> self smallSelectIcon.	icons add: #('jump to project...' ) -> self smallProjectJumpIcon.	icons add: #('open...' ) -> self smallOpenIcon.	icons add: #('appearance...' ) -> self smallConfigurationIcon.	icons add: #('help...' ) -> self smallHelpIcon.	icons add: #('windows...' ) -> self smallWindowIcon.	icons add: #('changes...' ) -> self smallChangesIcon.	icons add: #('print PS to file...' ) -> self smallPrintIcon.	icons add: #('debug...' ) -> self smallDebugIcon.	icons add: #('export...' ) -> self smallExportIcon.	icons add: #('save' ) -> self smallSaveIcon.	icons add: #('save project on file...' ) -> self smallProjectSaveIcon.	icons add: #('save as...') -> self smallSaveAsIcon.	icons add: #('save as new version') -> self smallSaveNewIcon.	icons add: #('save and quit' ) -> self smallQuitIcon.	icons add: #('quit') -> self smallQuitNoSaveIcon.	icons add: #('load project from file...' ) -> self smallProjectLoadIcon.	""	icons add: #('do it (d)' ) -> self smallDoItIcon.	icons add: #('inspect it (i)' 'explore it (I)' 'inspect world' 'explore world' 'inspect model' 'inspect morph' 'explore morph' 'inspect owner chain' 'explore' 'inspect' 'explore (I)' 'inspect (i)' 'basic inspect' ) -> self smallInspectItIcon.	icons add: #('print it (p)' ) -> self smallPrintIcon.	icons add: #('debug it' ) -> self smallDebugIcon.	icons add: #('tally it' ) -> self smallTimerIcon.	""	icons add: #('copy (c)' 'copy to paste buffer' 'copy text' ) -> self smallCopyIcon.	icons add: #('paste (v)' 'paste...' ) -> self smallPasteIcon.	icons add: #('cut (x)' ) -> self smallCutIcon.	""	icons add: #('accept (s)' 'yes' 'Yes' ) -> self smallOkIcon.	icons add: #('cancel (l)' 'no' 'No' ) -> self smallCancelIcon.	""	icons add: #('do again (j)' ) -> self smallRedoIcon.	icons add: #('undo (z)' ) -> self smallUndoIcon.	""	icons add: #( 'find class... (f)' 'find method...' ) -> self smallSearchIcon.	icons add: #('find...(f)' 'find again (g)') -> self smallFindIcon.	""	icons add: #('remove' 'remove class (x)' 'delete method from changeset (d)' 'remove method from system (x)' 'delete class from change set (d)' 'remove class from system (x)' 'destroy change set (X)' ) -> self smallDeleteIcon.	icons add: #('add item...' 'new category...' 'new change set... (n)' ) -> self smallNewIcon.	""	icons add: #('new morph...' 'objects (o)' ) -> self smallObjectCatalogIcon.	icons add: #('authoring tools...')  -> self smallAuthoringToolsIcon.	icons add: #('projects...')  -> self smallProjectIcon.	""	icons add: #('make screenshot')  -> self smallScreenshotIcon.		""	icons add: #('leftFlush' ) -> self smallLeftFlushIcon.	icons add: #('rightFlush' ) -> self smallRightFlushIcon.	icons add: #('centered' 'set alignment... (u)' ) -> self smallCenteredIcon.	icons add: #('justified' ) -> self smallJustifiedIcon.	""	icons add: #('set font... (k)' 'list font...' 'set subtitles font' 'change font' 'system fonts...' 'change font...' ) -> self smallFontsIcon.	icons add: #('full screen on') -> self smallFullscreenOnIcon.	icons add: #('full screen off' ) -> self smallFullscreenOffIcon.	""	^ icons! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:51'!methodAccessorFor: iconName	"Template method for an icon accessor method"	^ '	^ Icons		at: #{1}		ifAbsentPut: [ self {1}Contents ]' format: {iconName}! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:36' prior: 23489147!methodEnd	^ ''! !!MenuIcons class methodsFor: 'import/export' stamp: 'MAD 12/19/2010 20:36' prior: 23489244!methodStart: aString	^'^ '! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:58' prior: 23529126!smallAuthoringToolsIcon	^ Icons		at: #smallAuthoringToolsIcon		ifAbsentPut: [ self smallAuthoringToolsIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:58' prior: 23529432!smallAuthoringToolsIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2808846277 4285241285 4285241285 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4104749094 16777215 16777215 16777215 4285241285 4288461528 3765147589 4285241285 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4156465773 4038761825 16777215 16777215 16777215 4285241285 4269385423 4287147474 4272275675 3898314177 16777215 16777215 16777215 16777215 797072384 4273576540 4294437589 4256074563 275795968 16777215 16777215 2892732357 4183986884 4286491090 4288461528 4255103704 3881930943 3064638120 3131747241 3920013734 4104492405 4293443700 4291597568 2693556224 16777215 16777215 16777215 2540345030 3580466371 4268792519 4286622160 4289118684 4270501585 4285635011 4294967295 4291342725 4292591497 4292980025 3953030672 4288257175 16777215 16777215 16777215 16777215 4083520451 3731461315 4285701320 4286227917 4289250269 4219249868 4286878622 4272851774 4292917094 4291794688 4124363449 4288257175 16777215 16777215 16777215 16777215 16777215 3951402422 4268004291 4286228432 4285636298 4272472796 4272064850 4291274851 4292526223 4071986259 4226279912 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4259637483 4268725432 4286293452 4286030796 4273182039 4290882421 4289438090 4256807607 4260689397 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4294901502 4259177190 4288849830 4289112743 4288981159 4288849829 4289375657 4275953373 4277795321 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4294901502 4060020478 4294967295 4294967295 4294967295 4294967295 4294967295 3824020973 4277795321 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4278124286 3003055870 3317805978 3874482915 4274568359 4291740331 4289906910 3102337511 3992582649 4288257175 16777215 16777215 16777215 16777215 16777215 4288257175 4278124286 3671774150 3233788567 4258252210 4292135090 4291940812 4290889933 3269254362 3791321850 4288257175 16777215 16777215 16777215 16777215 16777215 3868826775 4227726845 3923234754 2916008878 4241934256 4293847268 4290693332 4272668629 4190688481 3690790396 3868826775 16777215 16777215 16777215 16777215 16777215 3029965976 3471502058 4191934156 4192131794 4276808165 4294111470 4294177521 4292074211 4258191588 3506174971 3130694807 16777215 16777215 16777215 16777215 16777215 865835926 4070153367 3924421097 4244504061 4277926649 4294704122 4294506744 4294440951 3638484958 4019821720 1620219282 16777215 16777215 16777215 16777215 16777215 33554432 1553505174 3550059671 3952712855 4288257175 4288257175 4288257175 4288257175 3365510294 1653576333 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'dgd 9/25/2004 22:59' prior: 23531672!smallCancelIcon	"Private - Generated method"	^ Icons			at: #'smallCancel'			ifAbsentPut:[ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self smallCancelIconContents readStream) ].! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:40' prior: 23532998!smallCenteredIcon	^ Icons		at: #smallCenteredIcon		ifAbsentPut: [ self smallCenteredIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:40' prior: 23533287!smallCenteredIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4289309097 4289309097 4289309097 4289309097 4294572537 4294572536 4294506743 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4289440683 4289309097 4289309097 4289309097 4289309097 4289309097 4294309365 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572536 4294375157 4294309365 4294309364 4294243571 4294177778 4294111985 4294243571 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294506743 4294440950 4294375157 4294309365 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4294375158 4294309365 4289309097 4289309097 4289309097 4289309097 4294111985 4294046193 4294046193 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294309365 4294309364 4294046193 4294046193 4293980400 4293914607 4294046193 4293980400 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19'!smallChangesIcon	^ Icons		at: #smallChangesIcon		ifAbsentPut: [ self smallChangesIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19'!smallChangesIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 490044345 2671475640 3728440505 4130765241 3845814969 3157949368 1395947704 87254732 16777215 16777215 16777215 2033415863 271610031 16777215 16777215 1345746614 4130962105 4201816526 4288331486 4289908199 4289907942 4288593630 4100561352 4030167480 1479833527 16777215 1714780343 4281563063 255031227 16777215 691173044 4114250680 4288134110 4289186277 4289448678 4290631148 4291288047 4292076787 4292602100 4291288045 4115827136 3224795577 4148724669 4231297207 238518454 16777215 2604301240 4252279246 4286425299 4282351034 4281628855 4231756985 4083652551 4272736226 4292798965 4292930549 4293062134 4254381786 4291879151 4181425337 222000817 16777215 4080630456 4282745533 4265508539 4114316473 1966241975 422804152 1161066169 3443096760 4117469896 4292141808 4293324792 4293587448 4293587448 4198202553 187593913 16777215 4264916919 4214979769 2641535701 3862395320 590575030 16777215 16777215 16777215 1613920439 4281628855 4291813359 4291682544 4293390584 4198202808 171147443 16777215 4231231415 2119404740 729984219 324965577 33587328 16777215 16777215 71336127 3292101303 4204509915 4293652984 4292930549 4293587448 4214980024 154759594 16777215 222000817 16777215 16777215 16777215 16777215 16777215 16777215 2687727799 4281563063 4165830334 4149447104 4149447104 4149447360 4281563063 138444991 16777215 4180899767 4264785847 4264785847 4248008631 4231231415 4214454199 3107157943 490044345 406156725 406156725 406156725 406156725 406156725 473396918 16777215 16777215 4231231415 4293521912 4293521912 4293456120 4255630561 3761732280 271610031 16777215 16777215 16777215 16777215 445231586 964537051 4231231415 204177599 16777215 4231297207 4293587448 4291616752 4291879151 4264785847 1781757623 16777215 16777215 16777215 187593913 3912595640 2373363157 3260780998 4281563063 87254732 16777215 4248271288 4293587448 4293390584 4293456376 4291419116 4115958721 3392765112 909407928 16777215 1781757623 3980361147 4283862726 4265311417 4197940152 16777215 16777215 4248402616 4292798965 4271947742 4293258743 4293062134 4292076530 4271619037 4115892929 4214519992 4282022840 4265245624 4282417339 4283665089 2822470841 16777215 16777215 4265048504 4150630087 3560339896 4099247298 4290630890 4291879409 4291091181 4290368490 4289383143 4287871453 4287476954 4288265438 4114184888 707885494 16777215 16777215 4281563063 2469820856 16777215 1412724406 3996678584 4082995909 4287608282 4288857058 4288923108 4288002782 4235765200 4130962105 1530230966 16777215 16777215 16777215 2721216695 16777471 16777215 16777215 87254732 1395947704 3191569337 3912858808 4197742775 3829103801 2856222137 607287480 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:06' prior: 23534736!smallConfigurationIcon	^ Icons		at: #smallConfigurationIcon		ifAbsentPut: [ self smallConfigurationIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:06' prior: 23535039!smallConfigurationIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1480812686 4282944717 4282944717 1480812686 4282944717 4291155690 4282944717 1480812686 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4291155690 4287805149 4282944717 4285374933 4289250531 4285374933 4282944717 4287805149 4291155690 4282944717 16777215 16777215 16777215 16777215 16777215 4282944717 4287805149 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4287805149 4282944717 16777215 16777215 16777215 16777215 16777215 1480812686 4282944717 4289250531 4287082715 4098460874 4284323793 4098460874 4287476956 4289250531 4282944717 1480812686 16777215 16777215 16777215 16777215 4282944717 4282944717 4285374933 4289250531 4098460874 2923986606 1497524108 2537911972 3998060491 4289250531 4285374933 4282944717 4282944717 16777215 16777215 16777215 4282944717 4291155690 4289250531 4289250531 4284323793 1497524108 16777215 1497524108 4284323793 4289250531 4289250531 4291155690 4282944717 16777215 16777215 16777215 4282944717 4282944717 4285374933 4289250531 4166095308 3445593287 1497524108 3225977527 4098460874 4289250531 4285374933 4282944717 4282944717 16777215 16777215 16777215 16777215 1480812686 4282944717 4291155690 4287082715 4166095308 4284323793 4098460874 4288330975 4289250531 4282944717 1480812686 16777215 16777215 16777215 16777215 16777215 4282944717 4287805149 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4289250531 4287805149 4282944717 16777215 16777215 16777215 16777215 16777215 4282944717 4291155690 4287805149 4282944717 4285374933 4289250531 4285374933 4282944717 4287805149 4291155690 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4282944717 1480812686 4282944717 4291155690 4282944717 1480812686 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282944717 4282944717 4282944717 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19' prior: 23536368!smallCopyIcon	^ Icons		at: #smallCopyIcon		ifAbsentPut: [ self smallCopyIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19' prior: 23536644!smallCopyIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 1335796123 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 2140773783 1403036570 16777215 16777215 16777215 16777215 2107219353 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2147483647 2140773783 16777215 16777215 16777215 16777215 2107219353 2147483647 2146694131 2146694129 2146694129 2146694129 2146694129 2146694129 2146694131 2146694131 2147483647 2140773783 16777215 16777215 16777215 16777215 2107219353 2147483647 2146694131 2144588753 3500845735 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2879299995 2107219353 2147483647 2146694131 2146694131 4254834329 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 2107219353 2147483647 2146694131 2144588753 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294967295 4288257175 2107219353 2147483647 2146694131 2146694129 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4291940816 4294177778 4294967295 4288257175 2107219353 2147483647 2146694129 2144457169 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294967295 4288257175 2107219353 2147483647 2146562545 2146562545 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4294177778 4294177778 4294967295 4288257175 2107219353 2147483647 2146562545 2144325583 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294704123 4294309365 4288257175 2107219353 2147220475 2146430959 2146430959 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4294046193 4294572536 4291743694 4288257175 2107219353 2146825717 2146957301 2146825717 4254834329 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4288520347 4288520347 4288520347 4288520347 4288257175 1352639388 2140904857 2140904857 2140904857 4254768536 4294901501 4294177778 4294177778 4294177778 4294177778 4294704123 4289243814 4294704123 4294572537 4293454312 4288257175 16777215 16777215 16777215 16777215 4221214104 4294704122 4294177778 4294177778 4294177778 4294704123 4294704123 4289243814 4294704123 4293519848 4288257175 3432619159 16777215 16777215 16777215 16777215 4221214104 4294375158 4294572536 4294506743 4294835708 4294769916 4292664540 4289243814 4293454312 4288257175 2140773783 16777215 16777215 16777215 16777215 16777215 2744950939 4288322968 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 3214580887 2140773783 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:35' prior: 23537894!smallCutIcon	^ Icons		at: #smallCutIcon		ifAbsentPut: [ self smallCutIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:35' prior: 23538167!smallCutIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 2086296920 4270888083 4169895821 16777215 16777215 16777215 16777215 3580785006 4271151255 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4288060314 4294440951 3950673018 3178000237 16777215 16777215 16777215 4254110610 4292401881 4018045312 16777215 16777215 16777215 16777215 16777215 16777215 4288257693 4292467931 4293980656 3833232506 16777215 16777215 1851284056 4290165433 4291744465 4288060571 16777215 16777215 16777215 16777215 16777215 16777215 4271217305 4290626241 4294441207 4186343815 3178000237 16777215 4288257693 4292073430 4290297019 4169435271 16777215 16777215 16777215 16777215 16777215 16777215 1700288598 4288323486 4292928482 4294046449 4001268610 3597693552 4290823620 4292204502 4288257693 3177671015 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4220227726 4290757570 4294572537 4271151254 4289441710 4290823106 4290823363 3900144248 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1549162838 4288257693 4293257190 4294309621 4289178795 4290033847 4287994521 1549162838 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3698554484 4290954692 4293651948 4290165433 4288389279 3580785006 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2539610207 4288060314 4291744208 4290625727 4283997890 1549162838 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 4266566084 4283212999 4287417300 4292537599 4292537599 4266631363 2134145207 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 4288667371 4292537599 4292537599 4283213770 3744684890 4285454303 4292537599 4292537599 4292537599 4283212999 2134145207 16777215 16777215 16777215 2134145207 4288667371 4292537599 3945492591 4287941348 4279934652 16777215 458557696 4292537599 4283279307 4118390190 4292537599 4283212999 2134145207 16777215 16777215 4268539848 4292537599 3125100092 16777215 4287941605 4280000187 16777215 16777215 4283212743 4272087534 16777215 3057990715 4292537599 4281899979 16777215 16777215 4280130745 4288734706 16777215 3477099345 4292537599 4281899979 16777215 16777215 4281899979 4290041584 3544143702 16777215 4292537599 4281899979 16777215 16777215 4281899979 4292537599 4288734706 4292537599 4245856928 1549473302 16777215 16777215 1549473302 4269132498 4292537599 4292537599 4292537599 4245727654 16777215 16777215 16777215 4281899979 4280195254 4280130488 1549473302 16777215 16777215 16777215 16777215 2538548780 4281899979 4281899979 4281899979 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 22:48' prior: 23539066!smallDebugIcon	^ Icons		at: #smallDebugIcon		ifAbsentPut: [ self smallDebugIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 22:48' prior: 23539345!smallDebugIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 16777215 16777215 4231297207 4231297207 16777215 2134145207 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2134145207 4231297207 4290304767 4290304767 4231297207 4231297207 4231297207 16777215 4231297207 4231297207 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 4290304767 4231297207 4290304767 4290304767 4290304767 4231297207 2134145207 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 4231297207 4290304767 4290304767 4290304767 4290304767 4290304767 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 2134145207 2134145207 4231297207 4290304767 4290304767 4281694904 4290304767 4290304767 4290304767 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 4231297207 4231297207 4290304767 4290304767 4290304767 4281694904 4290304767 4290304767 4231297207 4231297207 4231297207 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 4290304767 4290304767 4290304767 4281694904 4290304767 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 2134145207 4231297207 4290304767 4290304767 4290304767 4285966811 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 4231297207 4231297207 4231297207 4231297207 2134145207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4231297207 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:49' prior: 23540439!smallDeleteIcon	^ Icons		at: #smallDeleteIcon		ifAbsentPut: [ self smallDeleteIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:49' prior: 23540721!smallDeleteIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1382511397 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 1986424869 16777215 1449488679 4287666543 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4288192890 1147498793 4284837928 4292994782 4287139466 4285493612 4285625199 4285822577 4285954164 4286151542 4286283129 4286480507 4286612094 4286809472 4286941059 4290691515 4292994782 4284837928 4284837928 4292994782 4284112991 4285888370 4286019958 4286283128 4286414715 4286612094 4286809473 4287006852 4287072902 4287270280 4287336074 4289243813 4292994782 4284837928 4284837928 4290955444 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4292994782 4290231460 4284837928 2590339368 4284837928 4288851047 4287338045 4287206716 4287075131 4286877754 4286614585 4286416951 4286022196 4285693233 4285495344 4285363760 4285035308 4284837928 2590207782 16777215 4284837928 4291812235 4290760282 4290760282 4290694233 4289904210 4289970017 4290232690 4289115217 4288325447 4287733059 4287272512 4288324968 4284837928 16777215 16777215 4284837928 4291812235 4290760282 4290760282 4290628441 4291022450 4292731857 4292731857 4292074155 4289575523 4288983124 4288391252 4288324716 4284837928 16777215 16777215 4284837928 4291943566 4290760282 4290760282 4292140202 4291088506 4290627953 4292139948 4292205742 4289509987 4289246047 4288917339 4289574266 4284837928 16777215 16777215 4284837928 4292009105 4290957409 4291220332 4292600262 4292731857 4290365032 4290101861 4290101613 4290956176 4289114972 4288719960 4289903745 4284837928 16777215 16777215 4284837928 4292337822 4291286129 4291286127 4292534726 4291285891 4290430569 4291942578 4290232689 4292468932 4288983643 4288390740 4290100612 4284837928 16777215 16777215 4284837928 4292403360 4291220334 4291154541 4291154294 4292205742 4291614119 4292600263 4292534470 4290035573 4288786006 4288259408 4289772418 4284837928 16777215 16777215 4284837928 4292206493 4291154538 4291022952 4290693989 4290365026 4290036063 4291679916 4289378136 4288983381 4288654161 4288127821 4289705854 4284837928 16777215 117440512 4284837928 4206542989 4292140187 4291943322 4291876761 4291614359 4291416725 4291284884 4291021715 4290890129 4290692752 4290363789 4204569458 4284837928 100663296 16777216 2103470115 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 4284837928 2120049952 33554432)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:27' prior: 23546500!smallFindIcon	^ Icons		at: #smallFindIcon		ifAbsentPut: [ self smallFindIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:27' prior: 23546776!smallFindIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 3500845735 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2879299995 16777215 16777215 16777215 16777215 4254834329 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 16777215 16777215 16777215 16777215 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294177778 4294967295 4288257175 16777215 16777215 16777215 16777215 4254834329 4294967295 4294177778 4291940816 4291940816 4291940816 4291940816 4291940816 4291940816 4294177778 4294967295 4288257175 16777215 16777215 16777215 16777215 4254768536 4294967295 4294177778 4294177778 4294177778 4294177778 4292796125 4287862162 4287862162 4287862162 4287862162 4287927954 16777215 16777215 16777215 16777215 4254834329 4294967295 4294177778 4291940816 4291940816 4290164917 4287862162 4290430675 4289841372 4289578718 4290037208 4287862162 1552255106 16777215 16777215 16777215 4254768536 4294967295 4294177778 4294177778 4292796381 4287862162 4290036947 4288002781 4291288045 4291682288 4289119970 4288461783 4287862162 830636669 16777215 16777215 4254834329 4294967295 4294177778 4291940816 4287862162 4289772744 4287674587 4292996085 4293718521 4293456120 4291944945 4288200674 4255366615 4287862162 16777215 16777215 4254834329 4294967295 4294177778 4294177778 4287862162 4289578459 4289711079 4292864501 4293193462 4293061877 4291419375 4289383143 4270634460 4287862162 16777215 16777215 4254768536 4294901501 4294177778 4294177778 4287862162 4290038751 4289711336 4292338931 4292864758 4292142066 4291813617 4291156462 4253726428 4287862162 16777215 16777215 4221214104 4294704122 4294177778 4294177778 4287862162 4289970895 4287936987 4290565356 4291551216 4291419376 4292273395 4289645027 4221615577 4287862162 16777215 16777215 4221214104 4294967295 4294967295 4294967295 4292401366 4287862162 4289381852 4288463072 4290367719 4290499818 4289447648 4288856541 4287862162 3800664454 16777215 16777215 2744950939 4288322968 4288257175 4288257175 4288257175 4287665037 4287862162 4290630372 4288068314 4287281116 4289052891 4287862162 4289901490 4289901490 3632300413 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2306834557 4287862162 4287862162 4287862162 4287862162 4288585629 4291151300 4289901490 4289901490 4288059028 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4288585629 4291151300 4289901490 4288059028 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 33554432 4288585629 4288585629 4288059028)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'dgd 10/12/2004 20:58' prior: 23548189!smallFontsIcon	"Private - Generated method"	^ Icons			at: #'smallFonts'			ifAbsentPut:[ Form fromBinaryStream: (Base64MimeConverter mimeDecodeToBytes: self smallFontsIconContents readStream) ].! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOffIcon	^ Icons		at: #smallFullscreenOffIcon		ifAbsentPut: [ self smallFullscreenOffIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOffIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 3597627500 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 3597627500 4288322713 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290033079 4290033079 4294045933 4294045933 4294111726 4294111726 4290033079 4290033079 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290098872 4294045933 4294045933 4294111470 4294177519 4294177519 4294177519 4290098872 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290098872 4290362044 4290822852 4294111726 4294111726 4294243312 4294243312 4290559423 4290296251 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4294111726 4290757059 4291612368 4292270298 4294177519 4294178289 4292072919 4291480782 4290691266 4294309105 4290098872 4294966267 4288322713 4288322713 4294966267 4294177519 4294177519 4294243312 4292270298 4292730849 4293125607 4293191400 4292928228 4292270298 4294374898 4294113010 4294374898 4294966267 4288322713 4288322713 4294966267 4294243312 4294243312 4294308849 4294178289 4293059814 4294309105 4294374130 4293191400 4294440435 4294440435 4294440691 4294178803 4294966267 4288322713 4288322713 4294966267 4294440691 4294440691 4294440691 4294506228 4293257193 4294505716 4294572277 4293651951 4294571509 4294376182 4294638070 4294637302 4294966267 4288322713 4288322713 4294966267 4294506484 4294506484 4294571509 4292007126 4292862435 4293454316 4293651951 4293322986 4292533470 4294638070 4294703863 4294637302 4294966267 4288322713 4288322713 4294966267 4290033079 4294572277 4290559423 4291086024 4291941333 4294571509 4294637302 4292401884 4291349196 4290559423 4294703863 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290164665 4290427837 4294376182 4294638070 4294703095 4294768888 4290362044 4290098872 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290033079 4294703863 4294637302 4294441975 4294768888 4294834681 4294834681 4290033079 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4290033079 4290033079 4290033079 4290033079 4294769656 4294769656 4294900474 4294834681 4290033079 4290033079 4290033079 4290033079 4294966267 4288322713 4288322713 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4294966267 4288322713 3647762028 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 4288322713 3698093161)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOnIcon	^ Icons		at: #smallFullscreenOnIcon		ifAbsentPut: [ self smallFullscreenOnIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:13'!smallFullscreenOnIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2576981400 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2576981400 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281563063 4281563063 4294046192 4294046192 4294111985 4294111985 4281563063 4281563063 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281760184 4294046192 4294046192 4294111728 4294177777 4294177777 4294177777 4281760184 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281760184 4282942140 4285175492 4294111985 4294111985 4294243571 4294243571 4283861695 4282679483 4281957047 4281563063 4294967295 4288257175 4288257175 4294967295 4281628855 4294111985 4284912835 4287672272 4289643482 4294177777 4294243827 4289052375 4287080654 4284584386 4294309364 4281825720 4294967295 4288257175 4288257175 4294967295 4294177778 4294177778 4294243570 4289511898 4291023329 4291943399 4292206568 4291286500 4289446362 4294375157 4294309621 4294375157 4294967295 4288257175 4288257175 4294967295 4294243570 4294243571 4294309107 4294243827 4291877862 4294309363 4294374901 4292272104 4294440693 4294440693 4294440949 4294375414 4294967295 4288257175 4288257175 4294967295 4294440949 4294440949 4294440950 4294506486 4292141033 4294506487 4294572536 4292863983 4294572537 4294572793 4294638329 4294638073 4294967295 4288257175 4288257175 4294967295 4294506743 4294506742 4294572280 4288461014 4290892259 4292535020 4292995311 4292009706 4289840862 4294638329 4294704122 4294638330 4294967295 4288257175 4288257175 4294967295 4281628855 4294572536 4283664831 4285701320 4288198101 4294572537 4294638330 4289381084 4286292684 4283599039 4294704122 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281759927 4282219705 4283204797 4294572793 4294638329 4294704123 4294769659 4282942140 4281825720 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281563063 4294704122 4294638330 4294638586 4294769916 4294835452 4294835452 4281563063 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4281563063 4281563063 4281563063 4281563063 4294769915 4294769915 4294901245 4294835709 4281563063 4281563063 4281563063 4281563063 4294967295 4288257175 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288257175 2643827092 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2694091921)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19' prior: 23552339!smallHelpIcon	^ Icons		at: #smallHelpIcon		ifAbsentPut: [ self smallHelpIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19' prior: 23552615!smallHelpIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 672815513 2232900251 3306642333 4061617052 4061617052 3306642333 2232900251 672815513 16777215 16777215 16777215 16777215 16777215 16777215 33587328 2031573916 4113327778 4254773454 4291285987 4293849847 4293849847 4291285987 4254708174 4130104994 2014796699 33587328 16777215 16777215 16777215 33587328 3289865116 4133981369 4293455348 4290102746 4285699261 4282479274 4282479274 4285699261 4290168539 4293520883 4134047161 3289865116 33587328 16777215 16777215 2031573916 4134441147 4293652469 4284844728 4283530415 4291549157 4294178297 4293586676 4289971418 4283925171 4285633726 4293718518 4150890169 2031573916 16777215 672815513 4113459107 4293521140 4284779191 4279720860 4286159552 4294835710 4292732142 4294112760 4294967295 4291286244 4282151596 4286094019 4293586933 4130236322 672815513 2232900251 4271748304 4290102746 4279720860 4279720860 4283793842 4283925171 4281626024 4284845241 4294967295 4294770173 4283334836 4283071922 4290892002 4255234002 2232900251 3306642333 4291417573 4285699261 4279720860 4280574624 4281165988 4281822889 4282348973 4288065743 4294967295 4293718262 4283729335 4283860408 4287869136 4291812328 3307101598 4061617052 4293981175 4282085031 4280311967 4281165988 4281823145 4282414509 4286225605 4294638845 4294901502 4287606223 4284386493 4284518078 4286095046 4294112761 4061748381 4061617052 4293981175 4282216616 4280903075 4281757096 4282348973 4283006130 4293718518 4294967295 4289512155 4284846529 4285109698 4285241284 4286752203 4294178298 4061944989 3306642333 4291417573 4286027967 4281363109 4282151595 4282874544 4284188857 4291878122 4292009707 4285372612 4285438406 4285701320 4285898697 4289183708 4292141036 3307167391 2232900251 4254971088 4290365661 4281757352 4282480557 4283269044 4284254907 4288460756 4288723928 4285569735 4285964490 4286358733 4286555855 4291944429 4255957466 2233031837 672815513 4130236323 4293586933 4285962689 4282874544 4283597493 4285437634 4294967295 4294967295 4286292940 4286424783 4286884818 4289250528 4293981433 4130433443 672815513 16777215 2014796699 4134572988 4293784054 4286554310 4283794871 4285635011 4294967295 4294967295 4286621647 4286884818 4289447393 4294178811 4151876034 2015125149 16777215 16777215 33587328 3289865116 4151415997 4293784054 4291089381 4288197844 4286423754 4286949839 4289381599 4292141550 4294112762 4152270533 3290652832 33587328 16777215 16777215 16777215 33587328 2031573916 4130367396 4272471510 4292075243 4294178554 4294244347 4292403949 4256351709 4130630309 2015256221 33587328 16777215 16777215 16777215 16777215 16777215 16777215 672815513 2232900251 3306970782 4061879709 4061879709 3307233441 2233031837 672815513 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:52' prior: 23554035!smallHomeIcon	^ Icons		at: #smallHomeIcon		ifAbsentPut: [ self smallHomeIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:52' prior: 23554311!smallHomeIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4290904064 2180975120 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4294904335 4290904064 1291782669 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4287978586 4288768873 4294904335 4290904064 1291782669 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4289883499 4288059284 4289440682 4292057497 4294904335 4290904064 1291782669 16777215 16777215 16777215 16777215 16777215 1291782669 4290904064 4294904335 4289955460 4288717214 4291085765 4291677644 4291217093 4292128687 4294904335 4290904064 1291782669 16777215 16777215 16777215 1291782669 4290904064 4294904335 4290158236 4289704110 4291546058 4293190884 4293190884 4293190884 4292861919 4292264385 4294904335 4290904064 1291782669 16777215 1291782669 4290904064 4294904335 4290228141 4289901233 4292993505 4293848814 4293848814 4293848814 4293783021 4293783021 4293717228 4293253336 4294904335 4290904064 1291782669 4290904064 4294904335 4290822334 4289835696 4292927712 4293651435 4293717228 4293717228 4293717228 4293651435 4293519849 4293519849 4293519849 4293716457 4294904335 4290904064 1740701696 4294904335 4293388776 4284967526 4284967526 4284967526 4284967526 4293717228 4287269773 4287138960 4287137928 4287138960 4287138185 4294440951 4294904335 1455489024 16777215 4284967526 4294243572 4284967526 4287665037 4287730830 4287796367 4293717228 4287138959 4286949841 4287137928 4286818512 4287073167 4294375158 4284967526 16777215 16777215 4284967526 4294177779 4284967526 4288059539 4288059539 4288059539 4293717228 4287073166 4285110471 4287137928 4283533503 4286941325 4294309365 4284967526 16777215 16777215 4284967526 4294111986 4284967526 4288191125 4288191125 4288453494 4293717228 4286811028 4281563063 4287137928 4281563063 4286613908 4294309365 4284967526 16777215 16777215 4284967526 4294111986 4284967526 4288191382 4288191382 4288322448 4293717228 4290691267 4291086541 4291217352 4291152333 4289967027 4294309365 4284967526 16777215 16777215 4284967526 4294046193 4284967526 4288257175 4288257175 4288257175 4293717228 4289835441 4289901234 4289901234 4289901234 4289901234 4294309365 4284967526 16777215 16777215 4284967526 4294440951 4286085750 4289178277 4289243814 4289309350 4294309365 4294440951 4294440951 4294440951 4294440951 4294440951 4294769916 4284967526 16777215 16777215 2892392806 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 4284967526 2540137061 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:41' prior: 23558266!smallJustifiedIcon	^ Icons		at: #smallJustifiedIcon		ifAbsentPut: [ self smallJustifiedIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:41' prior: 23558558!smallJustifiedIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294506743 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294375157 4294375157 4294309365 4294309364 4294243571 4294177778 4294111985 4294046193 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294506743 4294440950 4294375157 4294309365 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294046193 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294177778 4294111985 4294046193 4294046193 4293980400 4293914607 4293848814 4293783021 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:38' prior: 23561187!smallLeftFlushIcon	^ Icons		at: #smallLeftFlushIcon		ifAbsentPut: [ self smallLeftFlushIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:38' prior: 23561479!smallLeftFlushIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289309097 4289309097 4289309097 4289309097 4289309097 4294572537 4294572537 4294572536 4294506743 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294440950 4294440950 4294440950 4294440950 4294375157 4294309365 4294309364 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4289440683 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294309365 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572536 4294572536 4294506743 4294440950 4294375157 4294309365 4294309364 4294243571 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294309365 4294309364 4294243571 4294177778 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4289309097 4289309097 4289309097 4289309097 4294243571 4294177778 4294111985 4294046193 4294046193 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294309365 4294309364 4294243571 4294177779 4294111986 4294046193 4294046193 4293980400 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:35' prior: 23568666!smallOkIcon	^ Icons		at: #smallOkIcon		ifAbsentPut: [ self smallOkIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:35' prior: 23568936!smallOkIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 248039624 79675327 33554431 33554431 33554431 33554431 33554431 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 16777215 16777215 16777215 16777215 2438055777 2135606620 16777215 16777215 33554431 33554431 33554431 33554431 33554431 33554431 50331647 50331647 50331647 50331647 61516458 2471741027 4285252467 4284989551 2034219344 16777215 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 2437793121 4285186674 4287618449 4286961290 4284332135 2066328132 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 2437923681 4285055344 4287487120 4287356046 4284397928 4281637445 134225920 33554431 33554431 1147794552 1718086006 33554431 33554431 33554431 33554431 2437792609 4284989551 4287290254 4287159181 4284332135 4231042883 134225920 16777215 196721081 1047000951 3865102958 4286107261 1885067371 33554431 33554431 2437792091 4284923758 4287224460 4287027851 4284266341 4230977347 152844572 61516458 93952409 1198060663 3831679084 4287027080 4287552399 4233345377 1884605796 2336866654 4284857964 4286962059 4286896264 4284069475 4230911554 152844572 33554431 33554431 33554431 169502259 4284334440 4285910139 4287684243 4286961546 4284990064 4285252723 4286764935 4286634375 4284003682 4247426367 152844572 33554431 33554431 33554431 33554431 33554431 186080558 4283676768 4285252979 4287159181 4287027594 4286568581 4286568325 4283806817 4264203071 171134259 50331647 33554431 33554431 33554431 33554431 33554431 33554431 186080535 4283018583 4284595563 4286634118 4286371460 4283741024 4264071742 152844572 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 186074647 4282229325 4284003683 4283544158 4263940413 152844572 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 186074647 4281243715 4213674302 136331296 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 186074647 136331296 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 33554431 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:19' prior: 23569987!smallOpenIcon	^ Icons		at: #smallOpenIcon		ifAbsentPut: [ self smallOpenIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:19' prior: 23570263!smallOpenIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 4167658343 4218055784 4234767207 4234833000 4234833000 4251741802 4251807595 3597825392 359492973 16777215 16777215 16777215 2676854157 3968633996 3968633996 3968633996 4285098855 4294572537 4294638330 4294704123 4294769916 4294769916 4294835709 4289835697 3782111083 242052461 16777215 16777215 4035677067 4292072403 4291940817 4291809231 4284967526 4292993505 4292598747 4292598747 4292598747 4292401368 4292269782 4294901502 4272202915 3563942253 158429553 16777215 4018570886 4291875024 4290690750 4290427578 4284967526 4293125091 4289506732 4289506732 4289506732 4289506732 4292730332 4294901502 4294835709 4272335015 2590863724 16777215 4001464705 4291611851 4290427578 4290295992 4285098855 4293454056 4293256677 4293190884 4293190884 4293190884 4293322470 4293783021 4293585642 4292467161 4050678382 16777215 3967647101 4291414473 4290295992 4290032820 4285098855 4293651435 4289704110 4289506731 4289506731 4289506731 4293190884 4293519849 4293519849 4292467417 4084101228 16777215 3950540920 4291085508 4290098613 4289835441 4285164648 4293914607 4293848814 4293848814 4293783021 4293783021 4293783021 4293783021 4293717228 4292927712 4050546540 16777215 3916591730 4290822336 4282744759 4281957047 4281957047 4281826232 4281759928 4281759928 4281628856 4281628855 4281628855 4281628855 4281563063 4281563063 4281563063 3828906425 3916394351 4290559164 4281628856 4291354096 4291354096 4291354096 4291354096 4291354096 4291354096 4291419632 4291419888 4291419888 4291419888 4291419888 4291025902 4264785848 3882445161 4290295992 4281628855 4291550960 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288463588 4288660965 4290894317 4247943351 3848561764 4290032819 4281759927 4291682288 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288857574 4288660709 4290893805 4214519992 3831389790 4289835441 4281825720 4291288047 4289054438 4288988902 4288988902 4288988902 4288988902 4288988902 4288988902 4288726245 4288331748 4288003810 4290434027 4197742776 3797572186 4289440683 4281957047 4289711337 4288200675 4287938018 4287609569 4287477985 4287346912 4287149791 4286821086 4286689758 4286689758 4286952670 4288725988 4164188600 3764083547 4289309097 4282088119 4288660196 4287412448 4287083999 4287083999 4287083999 4287083999 4287083999 4287083999 4287083999 4287083999 4287215583 4287609312 4147542200 3764017754 4287601320 4282088119 4284193486 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4284259279 4283404487 3644225976 2656459876 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 3996481463 1194293175)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:26' prior: 23572845!smallPasteIcon	^ Icons		at: #smallPasteIcon		ifAbsentPut: [ self smallPasteIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:26' prior: 23573124!smallPasteIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 33554432 3983042920 4286743170 4286743170 4286743170 4286743170 3983042920 33554432 16777215 16777215 16777215 16777215 16777215 1278376377 4281628855 4281628855 4281628855 4286677633 4289377716 4289378230 4289378230 4289377716 4286677633 4281628855 4281628855 4281628855 1278376377 16777215 138420224 4281628855 4289252074 4292537599 4287207318 4286874756 4288652194 4288717730 4288717730 4288586401 4286874756 4287206547 4292537599 4289252074 4281628855 71319552 524958216 4281628855 4292537599 4287207061 4294375158 4293651435 4291940817 4291940817 4291940817 4291940817 4293651435 4294440951 4287206290 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4294309365 4294309365 4294309365 4294309365 4294309365 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4291546572 4291546572 4291546572 4291546572 4294243828 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4294309365 4294309365 4294309365 4294243828 4294112499 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4291546572 4291546572 4291480779 4291480522 4293980656 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294309365 4294243828 4294178035 4294046449 4293980656 4293322983 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294243572 4294112242 4294046449 4293980656 4293257190 4292665053 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4294046706 4293980656 4293915120 4292730846 4291744208 4291678672 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4293980656 4293849327 4293191397 4291743951 4294967295 4294967295 4294967295 4287270798 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287270541 4294967295 4293783791 4293125861 4292138709 4291612622 4294967295 4294967295 4287270798 4292537599 4292537599 4281628855 273694720 524958216 4281628855 4292537599 4287076246 4294178035 4294901502 4294901502 4294901502 4294243828 4294835965 4287270798 4292537599 4292537599 4292537599 4281628855 273694720 138420224 4281628855 4289252074 4292537599 4287142553 4287468177 4287468177 4287468177 4287468177 4287468177 4292537599 4292537599 4292537599 4289252074 4281628855 71319552 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 1/5/2011 20:43'!smallPinIcon	^ Icons		at: #smallPinIcon		ifAbsentPut: [ self smallPinIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 1/5/2011 20:43'!smallPinIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 2550092884 872371541 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 4294923605 4294923605 4294923605 1560237654 16777215 16777215 16777215 16777215 4294923605 16777215 16777215 16777215 16777215 16777215 1560237654 4294923605 4294923605 4294936712 4294936712 4294923605 1560237654 16777215 16777215 16777215 4294923605 4294923605 16777215 16777215 16777215 1560237654 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 872371541 16777215 16777215 1560237654 4294923605 4294923605 1560226346 2113885782 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 4293283149 2550092884 16777215 16777215 16777215 2113885782 4294923605 4294923605 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 2902410822 4294923605 4294923605 4294936712 4294936712 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 16777215 872371541 3187614499 4294923605 4294923605 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 3405717793 4294923605 4294923605 4294923605 4293283149 4291576900 2107979575 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3212409209 4286151033 3405717793 4294923605 4294923605 4291773765 2545302845 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3212409209 4286151033 3212409209 1560237654 3187614499 4294923605 4294923605 1560226346 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3212409209 4286151033 3212409209 16777215 16777215 872371541 2902410822 4294923605 4294923605 16777215 16777215 16777215 16777215 16777215 16777215 2675472504 4286151033 3212409209 16777215 16777215 16777215 16777215 16777215 2113885782 4294923605 4294923605 16777215 16777215 16777215 16777215 2138601592 4286151033 2675472504 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1560237654 4294923605 4294923605 16777215 16777215 16777215 4286151033 2138601592 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:45' prior: 23574372!smallPrintIcon	^ Icons		at: #smallPrintIcon		ifAbsentPut: [ self smallPrintIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:45' prior: 23574651!smallPrintIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2176367288 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 4290296247 2176367288 16777215 16777215 16777215 16777215 16777215 4290296247 4294638330 4294638330 4294638330 4294638330 4294638330 4294638330 4294638330 4294638330 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294638330 4291809231 4291809231 4291809231 4291809231 4291809231 4291809231 4291809231 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294638330 4294243572 4294243572 4294243572 4294309365 4294309365 4294309365 4294309365 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294572537 4291809231 4291809231 4291875024 4291875024 4291875024 4291940817 4291940817 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294572537 4293322470 4293454056 4293519849 4293519849 4293585642 4293651435 4293717228 4294572537 4290296247 16777215 16777215 16777215 16777215 16777215 4290296247 4294506744 4289835441 4289835441 4289835441 4289967027 4293388263 4293388263 4293388263 4294572537 4290296247 16777215 16777215 16777215 2173603982 4287598991 4288125078 4290361785 4290295992 4290361785 4290361785 4290361785 4290361785 4290361785 4290295992 4290295992 4288125078 4287598991 2173603982 16777215 4287598991 4294835709 4294638330 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4294375158 4293651435 4293783021 4287598991 16777215 4287598991 4294835709 4292664540 4294046193 4290559164 4294309365 4293256677 4293519849 4293388263 4293454056 4293322470 4293125091 4289703855 4292335317 4287598991 16777215 4287598991 4294177779 4292269525 4293190884 4293190884 4293190884 4293190884 4293190884 4293125091 4293190884 4293190884 4292927712 4288585116 4291875024 4287598991 16777215 4287598991 4294309365 4291480266 4288190358 4287466635 4287466635 4287203463 4287334792 4287203205 4286940290 4287071877 4287334792 4290756543 4291875024 4287598991 16777215 4287598991 4294309365 4291282887 4291151301 4291151301 4291151301 4291151301 4291151300 4291019715 4290822336 4290953922 4291085508 4291151301 4291940817 4287598991 16777215 4287598991 4293980400 4292861919 4292927712 4292927712 4292861919 4292861919 4292861919 4292861919 4292861919 4292730333 4292861919 4292796126 4292664540 4287598991 16777215 2811269520 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 4287598991 2811269520)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 16:58'!smallProjectBackIcon	^ Icons		at: #smallProjectBackIcon		ifAbsentPut: [ self smallProjectBackIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 16:58'!smallProjectBackIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4293176763 4293176763 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292985039 4293751676 4293751676 4292985039 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292793830 4293496216 4294901760 4294901760 4293496216 4292793830 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292985039 4294901760 4294901760 4294901760 4294901760 4292985039 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290694609 4287727293 4287727293 4290694609 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287595701 4281014002 4281014002 4287661239 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287463852 4280948465 4280948465 4287464110 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290628297 4287595700 4287595700 4290628298 4292537599 4281628855 16777215 16777215 2083747767 4291090666 4284271650 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 3169845236 4278231040 4278231040 3053453311 3053453311 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4284271650 4289589680 4278231040 4278231040 4278231040 4278231040 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281118976 4283491340 4278248192 4278247936 4278246144 4278244352 4278231040 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4281118976 4285526614 4278231040 4278231040 4278231040 4278231040 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3169910772 4278231040 4278231040 3053453311 3053453311 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 16:56' prior: 23575777!smallProjectIcon	^ Icons		at: #smallProjectIcon		ifAbsentPut: [ self smallProjectIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 16:56' prior: 23576062!smallProjectIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4293176763 4293176763 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292985039 4293751676 4293751676 4292985039 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292793830 4293496216 4294901760 4294901760 4293496216 4292793830 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292985039 4294901760 4294901760 4294901760 4294901760 4292985039 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290694609 4287727293 4287727293 4290694609 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287595701 4281014002 4281014002 4287661239 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287463852 4280948465 4280948465 4287464110 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290628297 4287595700 4287595700 4290628298 4292537599 4281628855 16777215 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 16:54'!smallProjectJumpIcon	^ Icons		at: #smallProjectJumpIcon		ifAbsentPut: [ self smallProjectJumpIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 16:54'!smallProjectJumpIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 2083747767 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4293176763 4293176763 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292985039 4293751676 4293751676 4292985039 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292793830 4293496216 4294901760 4294901760 4293496216 4292793830 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292985039 4294901760 4294901760 4294901760 4294901760 4292985039 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290694609 4287727293 4287727293 4290694609 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287595701 4281014002 4281014002 4287661239 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4287463852 4280948465 4280948465 4287464110 4292537599 4281628855 16777215 16777215 4281628855 4292537599 4278239744 4278239744 4278239744 4278239744 4292537599 4292537599 4290628297 4287595700 4287595700 4290628298 4292537599 4281628855 16777215 16777215 2083747767 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4284271650 4291090666 2083747767 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 3053453311 3053453311 4278231040 4278231040 3500729258 16777215 16777215 1275109632 4278231040 1275109632 4278231040 1275109632 4278231040 1275109632 3053453311 4278231040 4278231040 4278231040 4278231040 4278241792 4278231040 3417498546 16777215 4278231040 4278246144 4278231040 4278246144 4278231040 4278246144 4278231040 3053453311 4278231040 4278246144 4278246144 4278246144 4278246144 4278241792 4278231040 16777215 1275109632 4278231040 1275109632 4278231040 1275109632 4278231040 1275109632 3053453311 4278231040 4278231040 4278231040 4278231040 4278241792 4278231040 3417498546 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 3053453311 3053453311 4278231040 4278231040 3500729258 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:23'!smallProjectLoadIcon	^ Icons		at: #smallProjectLoadIcon		ifAbsentPut: [ self smallProjectLoadIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:23'!smallProjectLoadIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4294928966 4294928966 4292537599 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 4281628855 4281628855 4281628855 4292537599 4292537599 4294949256 4294901760 4294901760 4294949256 4292537599 4292537599 4281628855 16777215 16777215 1412725174 4281628855 4281628855 4287412967 4281628855 4288923367 4292537599 4294933841 4294901760 4294901760 4294933841 4292537599 4292537599 4281628855 16777215 1412725174 4281628855 4290304767 4290304767 4290304767 4287412967 4281628855 4278247936 4278247936 4292537599 4292537599 4290947299 4290947299 4292537599 4281628855 16777215 4281628855 4290304767 4287412967 4281628855 4287412967 4281628855 4279353404 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4290304767 4281628855 4281628855 4281628855 4281628855 4278247936 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4281628855 4281628855 16777215 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 14:29'!smallProjectNextIcon	^ Icons		at: #smallProjectNextIcon		ifAbsentPut: [ self smallProjectNextIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 14:29'!smallProjectNextIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 3178078063 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 3178078063 16777215 16777215 4282619024 4292666586 4292666586 4292666586 4292666586 4292666586 4294159759 4294159503 4292666586 4292666586 4292666586 4292666586 4292600791 4282619024 16777215 16777215 4282619024 4292666587 4292337348 4292337348 4292337348 4293637757 4294139970 4294139970 4293571966 4292271812 4292271812 4292337350 4292600791 4282619024 16777215 16777215 4282619025 4292666589 4292337349 4292337349 4292337349 4294079056 4294901760 4294901760 4294079056 4292337349 4292337349 4292271812 4292600790 4282619024 16777215 16777215 4282619025 4292732381 4292337608 4292337608 4292337608 4294901760 4294901760 4294901760 4294901760 4292337350 4292271810 4292271553 4292600791 4282619024 16777215 16777215 4282619025 4292666586 4292337609 4285977428 4285977170 4285911632 4285911631 4292271554 4291084195 4287727293 4287727293 4291084196 4292534996 4282619024 16777215 16777215 4282619025 4292469200 4292140219 4278239744 4278239744 4278239744 4285713988 4292074168 4287595701 4281014002 4281014002 4287661239 4292337610 4282619024 16777215 16777215 4282619025 4292140221 4291942577 4278239744 4278239744 4278239744 4285582397 4291942577 4287463852 4280948465 4280948465 4287464110 4292140221 4282619024 16777215 16777215 4282619026 4292074170 4292074167 4278239744 4278239744 4278239744 4285713987 4292074167 4290886292 4287595700 4287595700 4290886293 4292073912 4282619024 16777215 16777215 4282619026 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4291415968 4284271650 4293915107 4291153049 4282619024 16777215 16777215 3178078063 4282619024 4282619024 4282619024 4282619024 4282619024 4282619024 4291354847 4291354847 4291354847 4278231040 4278231040 4290962394 3178078063 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4278231040 4278231040 4278231040 4278231040 4289589680 4284271650 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4278231040 4278244352 4278246144 4278247936 4278248192 4283491340 4281118976 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 4278231040 4278231040 4278231040 4278231040 4285526614 4281118976 3053453311 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 3053453311 3053453311 3053453311 4278231040 4278231040 3169910772 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281118976 3053453311 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 15:18'!smallProjectSaveIcon	^ Icons		at: #smallProjectSaveIcon		ifAbsentPut: [ self smallProjectSaveIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 15:18'!smallProjectSaveIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4292537599 4294928966 4294928966 4292537599 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4294949256 4294901760 4294901760 4294949256 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4292537599 4292537599 4294933841 4294901760 4294901760 4294933841 4292537599 4292537599 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4278247936 4278247936 4278247936 4292537599 4292537599 4290947299 4290947299 4292537599 4281628855 16777215 4281628855 4281628855 1412725174 16777215 16777215 4281628855 4278247936 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4290304767 4281628855 1412725174 16777215 4281628855 4278247936 4278247936 4278247936 4292537599 4290947299 4282515711 4282515711 4290947299 4281628855 16777215 4281628855 4287412967 4290304767 4281628855 16777215 1278376377 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 4281628855 1278376377 16777215 16777215 4281628855 4290304767 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281628855 4281628855 4290304767 4281628855 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4281628855 4287412967 4290304767 4287412967 4281628855 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4290434020 4281628855 4287412967 4281628855 4284643980 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4290434020 4281628855 4290434020 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4294770683 4294770683 4294770683 4294770683 4294770683 4294770683 4286151288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288 4286151288)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/22/2010 00:16' prior: 23579017!smallQuitIcon	^ Icons		at: #smallQuitIcon		ifAbsentPut: [ self smallQuitIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/22/2010 00:16' prior: 23579293!smallQuitIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 4284901482 4290098613 4288124823 4287401100 4286677377 4286085240 4285558896 4285295724 4294046194 4294112244 4294309366 4294440952 4294440952 4293980658 4287598995 679904902 4284901482 4290493371 4288585374 4287730065 4287137928 4286545791 4286019447 4285756275 4294046194 4294309365 4294572537 4294704124 4294769916 4294638330 4289243563 1066044042 4284901482 4291217094 4289111718 4288387995 4287664272 4287137928 4286677377 4286282619 4294046194 4294309366 4294638330 4288727272 4282685399 4294704123 4289769906 1183484554 4284901482 4291282887 4289572269 4289045925 4288387995 4287730065 4287203721 4286808963 4294046451 4294112502 4285771742 4284261853 4278219466 4292536564 4288260277 1736008038 4284901482 4291414473 4289769648 4289243304 4288716960 4288190616 4287664272 4287203721 4293324017 4282553556 4285444580 4289977081 4281306583 4280321491 4279467214 4278544569 4284901482 4291480266 4289835441 4289374890 4288848546 4288322202 4287795858 4286351764 4279335885 4285707496 4288007672 4288401400 4288861177 4288926713 4289189626 4278348735 4284901482 4291480266 4289967027 4289506476 4288980132 4288519581 4285894306 4278218436 4285182955 4285906421 4283345650 4283542770 4283674098 4283805170 4288335864 4278348992 4284901482 4291480266 4290164406 4289638062 4289177511 4288585374 4278217663 4281832927 4284527603 4280522222 4278946541 4278224107 4278224106 4278224364 4286300406 4278348992 4284901482 4291480266 4290295992 4289835441 4289243304 4288716960 4286944417 4278217920 4280782815 4281638640 4278223849 4278223849 4278223849 4278224106 4284133619 4278348735 4284901482 4291480266 4290295992 4289901234 4289374890 4288914339 4288387995 4287337370 4280057289 4279600088 4281835503 4282689009 4282097645 4282294251 4282425579 4278348735 4284901482 4291480266 4290295992 4290032820 4289572269 4289111718 4288716960 4287927444 4285625720 4283604181 4278220498 4281572332 4278218436 4278482381 4278218435 4079241345 4284901482 4291480266 4290295992 4290295992 4289835441 4289309097 4286743170 4288322460 4292467419 4293454314 4286230746 4278219466 4278218951 4293520107 4288190874 814056837 4284901482 4291480266 4290361785 4290624957 4288124824 4288454561 4291875283 4292533470 4292730592 4292796385 4292862178 4288002776 4283209424 4292665056 4286875272 495223940 4284901482 4291743438 4289177769 4288783012 4291283661 4291612369 4291743954 4291743955 4291809747 4291809747 4291809747 4291809747 4291809747 4291612626 4285690998 176193664 3309849418 4286282878 4284967275 4285033068 4285098861 4285098861 4285098861 4285098861 4285164654 4285164654 4285164654 4285164654 4285164654 4285098861 3326889805 41975936 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:23'!smallQuitNoSaveIcon	^ Icons		at: #smallQuitNoSaveIcon		ifAbsentPut: [ self smallQuitNoSaveIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:23'!smallQuitNoSaveIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 4284967526 4290098613 4288124823 4287401100 4286677377 4286085240 4285558896 4285295724 4294111985 4294243570 4294375157 4294506743 4294506743 4293980912 4287730575 369098751 4284967526 4290493371 4288585374 4287730065 4287137928 4286545791 4286019447 4285756275 4294111985 4294309365 4294572537 4294769915 4294769916 4294638330 4289375144 587202559 4284967526 4291217094 4289111718 4288387995 4287664272 4287137928 4286677377 4286282619 4294111985 4294375157 4294638330 4293435552 4292297797 4294704123 4289835696 654311423 4284967526 4291282887 4289572269 4289045925 4288387995 4287730065 4287203721 4286808963 4294177777 4294374642 4292768627 4292697180 4291428352 4294237146 4290091673 988390307 4284967526 4291414473 4289769648 4289243304 4288716960 4288190616 4287664272 4287203721 4294043878 4292100674 4293160558 4294554547 4292292400 4292026402 4291695379 4173529088 4284967526 4291480266 4289835441 4289374890 4288848546 4288322202 4287795858 4287921276 4291629331 4293423730 4294481302 4294482843 4294550178 4294550435 4294616999 4240637952 4284967526 4291480266 4289967027 4289506476 4288980132 4288519581 4288836982 4291035136 4293618282 4294276470 4294069839 4294070609 4294071124 4294071637 4294482586 4240703488 4284967526 4291480266 4290164406 4289638062 4289177511 4288585374 4290707456 4292818744 4294140000 4293796644 4293724943 4293591040 4293525504 4293656576 4294343547 4240703488 4284967526 4291480266 4290295992 4289835441 4289243304 4288716960 4288775557 4290772992 4292814633 4293932085 4293459968 4293459968 4293459968 4293525504 4294138458 4240637952 4284967526 4291480266 4290295992 4289901234 4289374890 4288914339 4288387995 4288318347 4291370268 4292351255 4293867320 4294001733 4293737276 4293606975 4293607489 4257415168 4284967526 4291480266 4290295992 4290032820 4289572269 4289111718 4288716960 4287927444 4286083697 4292170578 4291952640 4293669684 4291035136 4291625991 4290969600 3368550400 4284967526 4291480266 4290295992 4290295992 4289835441 4289309097 4286743170 4288388250 4292467673 4293520104 4292508538 4291428352 4291231744 4293585897 4288256664 436207615 4284967526 4291480266 4290361785 4290624957 4288125079 4288586140 4291941328 4292665050 4292796637 4292862430 4292928223 4292384661 4291841612 4292731100 4287006852 268435455 4284967526 4291743438 4289243559 4288914593 4291415495 4291678668 4291875534 4291875790 4291875791 4291875791 4291875791 4291875791 4291875791 4291809996 4285822578 100663295 2238541675 4286348923 4285098855 4285164648 4285230441 4285230441 4285230441 4285230441 4285296234 4285296234 4285296234 4285296234 4285296234 4285230441 2255647856 33554431 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:20' prior: 23580511!smallRedoIcon	^ Icons		at: #smallRedoIcon		ifAbsentPut: [ self smallRedoIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:20' prior: 23580787!smallRedoIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282691328 860270336 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282691328 4282691328 1128640256 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282691328 4289526392 4282691328 1094955264 16777215 16777215 16777215 16777215 16777215 16777215 16777215 122271232 1178971904 2655301120 3477384960 4282691328 4282691328 4289526392 4289526392 4282691328 1094955264 16777215 16777215 16777215 16777215 16777215 910339840 2974068224 3298668032 3719096654 4289591414 4289591671 4289919871 4289001324 4285128704 4289526392 4282691328 1094955264 16777215 16777215 16777215 1246081024 3359944448 4256228425 4289722227 4288737880 4288866048 4288866048 4288866048 4288866048 4285128704 4285128704 4289526392 4282691328 998676224 16777215 725725696 3125128960 4289586251 4289853296 4289128704 4288080156 4288866048 4288866048 4290044672 4285128704 4285128704 4285128704 4285260032 4289526392 4282691328 16777215 2655301120 3936735531 4289852778 4289194502 4290044672 4290044672 4291877888 4285586944 4285128704 4285128704 4285128704 4285128704 4286901554 4282691328 1094955264 16777215 3662721792 4289917550 4290701860 4292009728 4288537088 4288931328 4288931328 4288931328 4288931328 4292864000 4285128704 4286901554 4282691328 1094955264 16777215 16777215 4048204032 4289983599 4292141312 4272009984 4282691328 4282691328 4282691328 4282691328 4282691328 4292075264 4286901554 4282691328 1094955264 16777215 16777215 16777215 4282691328 4290964552 4289116160 4047810304 1933946624 809873152 16777215 16777215 4282691328 4286901554 4282691328 1094955264 16777215 16777215 16777215 16777215 4282691328 4256752690 4282691328 1212395008 16777215 16777215 16777215 16777215 4282691328 4282691328 860270336 16777215 16777215 16777215 16777215 16777215 4282691328 4122863670 4265914112 16777215 16777215 16777215 16777215 16777215 4282691328 860270336 16777215 16777215 16777215 16777215 16777215 16777215 3242438144 3333936384 3466506240 1212395008 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581559808 2253699584 2529681430 2359929600 205564416 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 541634304 1782820864 1531162112 491171840 79675136 61516288 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:39' prior: 23583898!smallRightFlushIcon	^ Icons		at: #smallRightFlushIcon		ifAbsentPut: [ self smallRightFlushIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:39' prior: 23584193!smallRightFlushIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 2862522779 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 4288257175 2862522779 16777215 16777215 4288257175 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4289638062 4289440683 4289440683 4289440683 4289440683 4289440683 4289440683 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294440950 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294572537 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4289638062 4289440683 4289440683 4289440683 4289440683 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294440950 4294440950 4294440950 4294375157 4294309365 4294440950 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4294572537 4294572537 4294572537 4294572536 4294506743 4294440950 4294375157 4294309365 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572537 4289440683 4289309097 4289309097 4289309097 4289309097 4289309097 4289309097 4294309364 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572537 4294572536 4294375157 4294309365 4294309364 4294243571 4294177778 4294111985 4294046193 4294177779 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294572536 4294506743 4294440950 4294375157 4294309365 4294309365 4294243572 4294177779 4294177778 4294111985 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294440950 4294375158 4294309365 4294309365 4294309364 4289440683 4289309097 4289309097 4289309097 4293848814 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294375157 4294309365 4294309364 4294243571 4294177779 4293980400 4293914607 4293848814 4293783021 4293980399 4294901502 4288454554 16777215 16777215 4288257175 4294967295 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294901502 4294967295 4288454554 16777215 16777215 2862522779 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 4288454554 2862522780 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/20/2010 18:48' prior: 23585629!smallSaveAsIcon	^ Icons		at: #smallSaveAsIcon		ifAbsentPut: [ self smallSaveAsIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/20/2010 18:48' prior: 23585911!smallSaveAsIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2088343690 2119535780 1866038431 2352512158 3560536991 4281957279 4165041566 3847390612 2237959310 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581744805 2120722634 1569307355 3451508718 4292273651 4291617521 4288990696 4252212658 4249387676 461084520 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4287143846 4285694857 4283662745 4282615725 4282813362 4289252322 4291355120 4283799744 4284120721 4286677886 4286677886 4286677886 4286677886 4287796623 16777215 16777215 4287534739 4294967295 4293126109 4291944164 4286032581 4281957279 4289975786 4288464094 4284256430 4292601323 4294967295 4294967295 4294967295 4287862160 16777215 16777215 4287994512 4294046193 4294046193 4293257444 4286818752 4281957279 4286756567 4288266713 4282416802 4290234575 4294046193 4293980657 4293980657 4287862160 16777215 16777215 4287862160 4293914864 4281957279 4281957279 4281957279 4281957279 4286756567 4284195788 4281957279 4281957279 4281957279 4281957279 4293980400 4287862160 16777215 16777215 4287862160 4293783022 4292073678 4281957279 4288793573 4286230477 4286230477 4286230477 4286361550 4288661474 4281957279 4288854206 4293848558 4287862160 16777215 16777215 4287862160 4294704123 4293519849 4291810762 4281957279 4288793573 4286361550 4286361550 4290040551 4281957279 4288656827 4293519849 4294375158 4287862160 16777215 16777215 4287862160 4294046193 4294704123 4293519849 4291810762 4281957279 4290106858 4288793573 4282154659 4288656827 4293519849 4294704123 4294046193 4287862160 16777215 16777215 4287862160 4293519849 4294046193 4294704123 4294704123 4292271570 4282613922 4281957279 4289182914 4294704123 4294835709 4294046193 4293519849 4287862160 16777215 2158208927 4289901488 4289835952 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 4289901488 2158208927 4286677886 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4278190080 4294967295 4294967295 4286677886 4286677886 4294967295 4290625211 4294967295 4290625212 4294967295 4290625211 4294967295 4290625211 4294967295 4291085763 4294967295 4278190080 4294967295 4294967295 4286677886 4286677886 4294967295 4291085763 4294967295 4291085763 4294967295 4291085763 4294967295 4291085763 4294967295 4291085763 4294967295 4278190080 4294967295 4294967295 4286677886 4286677886 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4278190080 4294967295 4294967295 4286677886 2155971454 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 4286677886 2155971454)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 20:30' prior: 23587331!smallSaveIcon	^ Icons		at: #smallSaveIcon		ifAbsentPut: [ self smallSaveIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 20:30' prior: 23587607!smallSaveIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2089200540 2119802550 1865322161 2351730865 3559886514 4281306802 4164849841 3847723431 2238554017 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581749686 2120857815 1569835238 3451969523 4292602614 4292012277 4289452015 4252872386 4249392559 461679227 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4287999926 4286748316 4284126380 4282227390 4282424771 4289779178 4291749876 4283738575 4284780964 4287862160 4287862160 4287862160 4287862160 4288849568 16777215 16777215 4288587684 4294967295 4293455075 4292404714 4286495186 4281306802 4290436848 4288991207 4284654271 4292930288 4294967295 4294967295 4294967295 4288980641 16777215 16777215 4289047457 4294243572 4294243572 4293586409 4287477965 4281306802 4287218657 4288859618 4282159540 4290892761 4294243572 4294178036 4294178036 4288980641 16777215 16777215 4288980641 4294112243 4281306802 4281306802 4281306802 4281306802 4287218657 4284068825 4281306802 4281306802 4281306802 4281306802 4294177779 4288980641 16777215 16777215 4288980641 4294046193 4292534487 4281306802 4289254892 4286693081 4286693081 4286693081 4286823898 4289188586 4281306802 4289578443 4294111729 4288980641 16777215 16777215 4288980641 4294769916 4293783021 4292337107 4281306802 4289254892 4286823898 4286823898 4290567150 4281306802 4289446856 4293783021 4294506744 4288980641 16777215 16777215 4288980641 4294243572 4294769916 4293783021 4292337107 4281306802 4290567664 4289254892 4281635253 4289446856 4293783021 4294769916 4294243572 4288980641 16777215 16777215 4288980641 4293783021 4294243572 4294769916 4294769916 4292732122 4282422196 4281306802 4289907150 4294769916 4294835709 4294243572 4293783021 4288980641 16777215 16777215 4288980641 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294506744 4294506744 4294111986 4294111986 4293783021 4288980641 16777215 16777215 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 4288980641 16777215 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4288980641 16777215 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4288980641 16777215 16777215 4288980641 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4288980641 16777215 16777215 4288849568 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4288849568 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/20/2010 18:48'!smallSaveNewIcon	^ Icons		at: #smallSaveNewIcon		ifAbsentPut: [ self smallSaveNewIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/20/2010 18:48'!smallSaveNewIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 2089200540 2119802550 1865322161 2351730865 3559886514 4281306802 4164849841 3847723431 2238554017 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1581749686 2120857815 1569835238 3451969523 4292602614 4292012277 4289452015 4252872386 4249392559 461679227 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4287999926 4286748316 4284126380 4282227390 4282424771 4289779178 4291749876 4283738575 4284780964 4287862160 4287862160 4287862160 4287862160 4288849568 16777215 16777215 4288587684 4294967295 4293455075 4292404714 4286495186 4281306802 4290436848 4288991207 4284654271 4292930288 4294967295 4294967295 4294967295 4288980641 16777215 16777215 4289047457 4294243572 4294243572 4293586409 4287477965 4281306802 4287218657 4288859618 4282159540 4290892761 4294243572 4294178036 4294178036 4288980641 16777215 16777215 4288980641 4294112243 4281306802 4281306802 4281306802 4281306802 4287218657 4284068825 4281306802 4281306802 4281306802 4281306802 4294177779 4288980641 16777215 16777215 4288980641 4294046193 4292534487 4281306802 4289254892 4286693081 4286693081 4286693081 4286823898 4289188586 4281306802 4289578443 4294111729 4288980641 16777215 16777215 4288980641 4294769916 4293783021 4292337107 4281306802 4289254892 4286823898 4286823898 4290567150 4281306802 4289446856 4293783021 4294506744 4288980641 16777215 16777215 4288980641 4294243572 4294769916 4293783021 4292337107 4281306802 4290567664 4289254892 4281635253 4289446856 4293717228 4294704123 4294177779 4288980641 16777215 16777215 4288980641 4293783021 4294243572 4294769916 4294769916 4292732122 4282422196 4281306802 4289907150 4294769916 4294901502 4285890304 4294638330 4288980641 16777215 16777215 4288980641 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294440951 4294835709 4285890304 4294508288 4285890304 4293190883 16777216 16777215 4288980641 4292598747 4292598747 4292598747 4292598747 4292467161 4292598747 4292598747 4294243572 4285890304 4289311744 4294508288 4289311744 4285890304 3003121663 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4285890304 4294508288 4294508288 4294508288 4294508288 4294508288 4285890304 16777215 4288980641 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4291085252 4293783021 4285890304 4289311744 4294508288 4289311744 4285890304 3003121663 16777215 4288980641 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4291151301 4293783021 4285890304 4294508288 4285890304 4293190883 16777215 16777215 4288849568 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4287862160 4292796381 4285890304 4292796381 4288849568 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 22:00'!smallScreenshotIcon	^ Icons		at: #smallScreenshotIcon		ifAbsentPut: [ self smallScreenshotIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 22:00'!smallScreenshotIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 1982540587 4283392626 4284446346 4284446346 4284446346 4265561434 1462117926 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282009685 4294967295 4294967295 4294967295 4294967295 4278190079 4282075478 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4282010199 4292209663 4294967295 4294967295 4294967295 4289649663 4282075478 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281483596 4285105307 4288332514 4288859118 4289649151 4285237151 4282207836 16777215 16777215 16777215 16777215 2738567995 4283524727 4283129455 4282339422 4282471266 4282997611 4287410126 16777215 16777215 16777215 4288595688 4281088066 4282207836 4282339422 4283393141 2738567995 4284315017 4291028223 4290371327 4294967295 4294967295 4289649663 4287871704 4288793068 4289123060 4289583358 4289649151 4291553535 4289649151 4291028223 4291815679 4262992929 4284907927 4289649663 4284578703 4289386490 4289649663 4288595688 4291422207 4292472319 4291815679 4289649663 4288464102 4288464102 4287673812 4285500581 4290633983 4262992929 4284512397 4289452028 4284578703 4285830059 4288661482 4291028223 4290043391 4288661482 4288201184 4288201184 4287805142 4289386490 4285895853 4283524727 4289649663 4262992929 4284248967 4289188854 4284578703 4286093489 4289452028 4288135134 4288595688 4284512397 4281351496 4283656571 4287673812 4286159027 4288398052 4284117381 4289649663 4262992929 4284248967 4289188854 4284578703 4286093489 4288595688 4285500581 4281614926 4280429620 4279440147 4279440147 4281483596 4285105307 4285500581 4285171101 4289452028 4262992929 4284248967 4289188854 4284578703 4286685886 4285632423 4282997611 4282405472 4294967295 4289649663 4283393141 4281219910 4284973977 4285171101 4286356407 4289452028 4262795547 4284248967 4289188854 4284578703 4287476176 4285171101 4281746770 4283393141 4289649663 4294047999 4291422207 4284248967 4286159027 4285237151 4285830059 4289386490 4262795547 4284248967 4289188854 4284644497 4286685372 4285171101 4283063661 4279440147 4285961903 4292997631 4292866559 4286817728 4287673812 4285237151 4285961903 4288661482 4262269971 4283854207 4287937498 4288332771 4288003291 4288332514 4284842133 4280693050 4283524727 4284248967 4287410126 4290239999 4288201184 4288464102 4287015107 4286357176 4198056779 2738567995 4283854207 4283392626 4283392626 4262335254 4285171101 4285434531 4283393141 4284315017 4286093489 4284512397 4284051331 4283524727 4283392626 4283392369 2738567995 16777215 16777215 16777215 16777215 1261844022 2218408506 3578481483 4250166386 4283985793 4250166386 3595324751 1849178168 858927666 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 22:28'!smallSearchIcon	^ Icons		at: #smallSearchIcon		ifAbsentPut: [ self smallSearchIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 22:28'!smallSearchIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 2844298120 4118971263 4270032000 4286677886 4102062717 2542571658 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1049398408 4169171584 4275361492 4292993763 4275887841 4292468193 4292796385 4275360979 4152328574 982356365 16777215 16777215 16777215 16777215 16777215 898667920 4269966464 4292993762 4188256462 4051150803 4202607067 4286296026 4050822352 4188584911 4293190884 4253123454 832018322 16777215 16777215 16777215 16777215 4118774141 4292993505 4204180946 4269518811 3989823728 3957780472 4242861558 3736589034 4252741594 4187666386 4293059298 4085153916 16777215 16777215 16777215 1989120396 4206278581 4188782032 4269518810 3890014453 3958108664 4042257914 4243058680 3705071349 3265316323 4269453018 4189701845 4155683760 1871811470 16777215 16777215 4286348921 4292993504 4285571534 4189508073 4225821173 4226149879 4209504247 4293258742 4040549618 3616191967 3850022619 4287476438 4292927711 4286348921 16777215 16777215 4269900670 4292862434 4286230234 3418150637 3453149937 3336103923 3235703028 3856394484 1854058716 2054926555 2340269274 4286230234 4293454056 4269900670 16777215 16777215 4202725756 4293256677 4269846745 3013262819 3049314029 2999902193 2580077294 2762853096 1517990106 1820176348 2189209564 4235700950 4293059298 4185883004 16777215 16777215 3348469650 4224700367 4237407702 3312690387 2340269274 1970974426 1585098972 1920839387 1333702363 1702801116 3211500488 4254447831 4174631890 3231094675 16777215 16777215 1654103191 3801388691 4292403431 4286296026 2558111192 2004528861 1652207325 2172366553 1434169051 2071374035 4286296026 4292468967 3933895800 2122877572 16777215 16777215 16777215 3883761531 3971463351 4291024100 4286296026 3496384451 1987685334 2742594518 3445920446 4286361562 4291811035 4272203427 4120418711 4068179065 426141286 16777215 16777215 781949846 4152328572 3819086754 4292995310 4288790749 4269977817 4286296026 4288856541 4292666346 4252860027 4291151300 4288125334 4253518213 3917052791 813727872 16777215 16777215 781949846 3833430139 3700527759 3802177952 4073573837 4293256677 3634076827 3782703477 1668247407 4286611838 4291085506 4288322970 4258386385 4286546045 16777215 16777215 16777215 16777215 1637391254 3063520407 4118774140 4286546300 3063520407 1637391254 16777215 2256436862 4286546045 4292203988 4292796126 4286546045 16777215 16777215 16777215 16777215 33554432 67108864 83886080 100663296 100663296 117440512 100663296 100663296 1685419381 4269834365 4286546045 1451262077 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/31/2010 17:09'!smallTimerIcon	^ Icons		at: #smallTimerIcon		ifAbsentPut: [ self smallTimerIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/31/2010 17:09'!smallTimerIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 4288526525 4116212343 4116212343 4288526525 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4284515726 4284515726 4284515726 4284515726 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4284515726 4284515726 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 2639020888 4116212343 4284449675 4284515726 4284909712 3377418592 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1414084431 4149767289 4288526525 4291550689 4292208362 4292274155 4291419360 4288525497 4284515981 1414084431 16777215 16777215 16777215 16777215 16777215 1414084431 4267474568 4291090909 4291286488 4291875796 4284534498 4284534498 4293322728 4291877082 4291090909 4284450703 1414084431 16777215 16777215 16777215 16777215 4099434870 4291090909 4290693837 4292798956 4284534498 4284534498 4284534498 4294046451 4293849072 4290693837 4291090909 4099434870 16777215 16777215 16777215 2639020888 4288526525 4291089366 4292730334 4278190080 4284534498 4284534498 4284534498 4294178037 4293914865 4292730334 4291089366 4288526525 2639020888 16777215 16777215 3931463791 4291550689 4290561222 4294046451 4293522164 4278190080 4285054413 4284534498 4294178037 4293980401 4294046451 4290561222 4291550689 4285369491 75530240 16777215 4284450446 4292208362 4291415245 4293980401 4294243573 4294310137 4278190080 4280778896 4293190885 4293914865 4293914608 4294440951 4292076519 4284582032 16777215 16777215 3931463791 4291550689 4290363586 4294243573 4293717229 4293783279 4284966759 4278190080 4293651693 4293454314 4294506745 4294046194 4291550689 4284842635 16777215 16777215 2639020888 4288526525 4290497486 4293651436 4294046193 4293717229 4294506745 4293585900 4293454057 4294111987 4294506744 4292272611 4288526525 4066077045 16777215 16777215 16777215 4116146551 4291090909 4289838785 4293980401 4294309365 4293717229 4293191142 4293783279 4294309366 4293323499 4291090909 4284712333 890442520 16777215 16777215 16777215 1731932739 4284251783 4291090909 4290562765 4291678674 4294309366 4294177780 4294375159 4292600805 4291090909 4284581518 3493280325 1325400064 67108864 16777215 16777215 385875968 2385323570 4216680057 4288526525 4291550689 4292208362 4292274155 4291550689 4288526525 4284514697 3593219383 2147483648 1090519040 16777215 16777215 16777215 16777215 520093696 1509949440 3493476934 4233325429 4284383883 4284450703 4284185988 4064366169 2650800128 2097152000 939524096 33554432 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/21/2010 23:21'!smallTrafficIcon	^ Icons		at: #smallTrafficIcon		ifAbsentPut: [ self smallTrafficIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/21/2010 23:21'!smallTrafficIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 422804152 4281694648 4281694648 4281694648 4281694648 4281694648 4281694648 422804152 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4289448421 4292255918 4293546071 4293546071 4292255918 4289448421 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293546071 4294836738 4294836738 4293546071 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293546071 4294836738 4294836738 4293546071 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4292255918 4293546071 4293546071 4292255918 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4292265390 4293569111 4293569111 4292265390 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293569111 4294872578 4294872578 4293569111 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4293569111 4294872578 4294872578 4293569111 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4292265390 4293569111 4293569111 4292265390 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4287747246 4282960727 4282960727 4287747246 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4282960727 4278370818 4278370818 4282960727 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4291288047 4282960727 4278370818 4278370818 4282960727 4291288047 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4281694648 4289448421 4287747246 4282960727 4282960727 4287747246 4289448421 4281694648 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 808811194 4281694648 4281694648 4281694648 4281694648 4281694648 4281694648 808811194 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:20' prior: 23591390!smallUndoIcon	^ Icons		at: #smallUndoIcon		ifAbsentPut: [ self smallUndoIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:20' prior: 23591666!smallUndoIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 16777215 16777215 16777215 16777215 16777215 16777215 4292129024 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 348959488 4292129024 4292129024 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 295077632 4292129024 4294834103 4292129024 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 295077632 4292129024 4294834103 4294962176 4292129024 4292129024 3889082880 3486232576 2764878080 193694464 16777215 16777215 16777215 16777215 16777215 295077632 4292129024 4294834103 4294633738 4294896384 4294832763 4294832503 4294635126 4177194867 3570184704 3587224576 479367680 16777215 16777215 16777215 177838336 4292129024 4294834103 4294633472 4294699535 4294370304 4294633472 4294370304 4293646336 4294107683 4294635120 4276869437 3838882816 848269056 16777215 16777215 4292129024 4294834103 4294633472 4294765071 4294699535 4294699535 4294633472 4294370304 4293909760 4293909760 4293909760 4294107683 4293515323 3402478080 177838336 16777215 295077632 4292129024 4294832770 4294765071 4294567680 4292988160 4292988160 4292988160 4293909760 4293909760 4293909760 4293448704 4294438002 4174625536 3419123968 16777215 16777215 295077632 4292129024 4294832766 4293185536 4294832766 4294766704 4294766704 4294766704 4294766704 4294764032 4293448704 4293054208 4294042744 4107187200 16777215 16777215 16777215 295077632 4292129024 4294832766 4294832766 4292129024 4292129024 4292129024 4292129024 4292000000 4294175095 4293448960 4294372208 4174361600 16777215 16777215 16777215 16777215 295077632 4292129024 4294832766 4292129024 16777215 16777215 819310336 1355393280 3386159616 4294569333 4294240640 4291867648 16777215 16777215 16777215 16777215 16777215 16777215 4292129024 4292129024 16777215 16777215 16777215 16777215 449753344 4292262912 4277595539 4291932928 16777215 16777215 16777215 16777215 16777215 16777215 16777215 4292129024 16777215 16777215 16777215 16777215 16777215 4275681792 4277134179 4023367168 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 584233984 4242919490 4276277570 2144319232 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1574154752 3002197102 2933044736 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 16777215 1775351296 1775482368 416658688 16777215 16777215)	offset: 0@0)! !!MenuIcons class methodsFor: 'accessing - icons' stamp: 'MAD 12/19/2010 21:20' prior: 23595352!smallWindowIcon	^ Icons		at: #smallWindowIcon		ifAbsentPut: [ self smallWindowIconContents ]! !!MenuIcons class methodsFor: 'private - icons' stamp: 'MAD 12/19/2010 21:20' prior: 23595634!smallWindowIconContents^ (Form	extent: 16@16	depth: 32	fromArray: #( 1556466370 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 1556466370 16777215 16777215 16777215 16777215 4291217859 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4291217859 16777215 16777215 16777215 16777215 4291217859 4294901502 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4294835709 4291217859 16777215 16777215 16777215 16777215 4291217859 4294835708 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4294769916 4291217859 16777215 16777215 16777215 16777215 4291217859 4294704379 4294638330 4294638330 4293388774 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 1556466370 4291217859 4294572537 4294506744 4294441208 4291217859 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4294967295 4291217859 4291217859 4294572537 4294374901 4294309365 4291217859 4294901502 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4279720860 4294835709 4291217859 4291217859 4294309365 4294046193 4294111986 4291217859 4294835708 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4281563063 4294769916 4291217859 4291217859 4294111987 4293914350 4293848814 4291217859 4294704379 4294638330 4294638330 4294638330 4294572793 4294572537 4294572537 4294572537 4294572537 4294572793 4291217859 4291217859 4294046449 4293585643 4293585642 4291217859 4294572537 4294506744 4294441208 4294506488 4294506744 4294506487 4294440951 4294506487 4294506487 4294572537 4291217859 4291217859 4294374901 4294112242 4294177522 4291217859 4294572537 4294374901 4294309365 4294309365 4294309365 4294243829 4294309365 4294309365 4294374901 4294506744 4291217859 1589888702 4291217859 4291217859 4291217859 4291217859 4294309365 4294046193 4294111986 4294111986 4294111986 4294111986 4294111986 4294111986 4294046193 4294243828 4291217859 16777215 16777215 16777215 16777215 4291217859 4294111987 4293914350 4293848814 4293848814 4293848814 4293783021 4293848814 4293848557 4293848558 4294111986 4291217859 16777215 16777215 16777215 16777215 4291217859 4294046449 4293585643 4293585642 4293585898 4293585642 4293585642 4293585642 4293585642 4293585642 4294046193 4291217859 16777215 16777215 16777215 16777215 4291217859 4294374901 4294112242 4294177522 4294111986 4294112243 4294111986 4294111986 4294177522 4294111986 4294111986 4291217859 16777215 16777215 16777215 16777215 1589888702 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 4291217859 1556466370)	offset: 0@0)! !!FormCanvas methodsFor: 'initialization' stamp: 'ar 12/30/2010 18:01' prior: 51234850!reset	origin := 0@0.							"origin of the top-left corner of this cavas"	form ifNil:[		"This code path will never be executed after the changes in setForm:		are installed, so it can be removed in due time."		clipRect := (0@0 corner: 10000@10000).	] ifNotNil:[		clipRect := (0@0 corner: form extent).	"default clipping rectangle"	].	self shadowColor: nil.! !!FormCanvas methodsFor: 'private' stamp: 'ar 12/30/2010 17:49' prior: 51238995!setForm: aForm	form := aForm.	port := self portClass toForm: form.	self reset.! !!TheWorldMainDockingBar class methodsFor: 'class initialization' stamp: 'dtl 1/18/2011 21:37' prior: 58985270!initialize	"self initialize"		Locale addLocalChangedListener: self.	self updateInstances.! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'dtl 1/18/2011 21:50' prior: 35066883!helpMenuOn: aDockingBar	aDockingBar addItem: [ :it |		it	contents: 'Help' translated;			addSubMenu: [ :menu |  'Todo'.				menu addItem:[:item|					item						contents: 'Online Resources' translated;						help: 'Online resources for Squeak' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#squeakOnlineResources. 							'Squeak Online Resources'. 							(140@140 extent: 560@360)						}].				menu addItem:[:item|					item						contents: 'Keyboard Shortcuts' translated;						help: 'Keyboard bindings used in Squeak' translated;						target: Utilities;						selector: #openCommandKeyHelp ].				menu addItem:[:item|					item						contents: 'Font Size Summary' translated;						help: 'Font size summary from the old Squeak 3.10.2 help menu.' translated;						target: TextStyle;						selector: #fontSizeSummary ].				menu addItem:[:item|					item						contents: 'Useful Expressions' translated;						help: 'Useful expressions from the old Squeak 3.10.2 help menu.' translated;						target: Utilities;						selector: #openStandardWorkspace ].				(Smalltalk classNamed: #SystemReporter) ifNotNil: [:classSystemReporter |					menu addItem: [:item |						item							contents: 'About this System' translated;							help: 'SystemReporter status of the image and runtime environment' translated;							target: classSystemReporter;							selector: #open]].				menu addLine.				menu addItem:[:item|					item						contents: 'Extending the system' translated;						help: 'Includes code snippets to evaluate for extending the system' translated;						target: self;						icon: MenuIcons smallHelpIcon;						selector: #showWelcomeText:label:in:;						arguments: {							#extendingTheSystem. 							'How to extend the system'. 							(140@140 extent: 560@360)						}].				menu addLine.				menu addItem:[:item|					item						contents: 'Welcome Workspaces' translated;						help: 'The Welcome Workspaces' translated;						addSubMenu:[:submenu| self welcomeWorkspacesOn: submenu]].				(Smalltalk classNamed: #HelpBrowser) ifNotNil: [:classHelpBrowser |					(Smalltalk classNamed: #TerseGuideHelp) ifNotNil: [:classTerseGuideHelp |						menu addLine.						menu addItem: [:item |							item								contents: 'Terse Guide to Squeak' translated;								help: 'Concise information about language and environment' translated;								target: classHelpBrowser;								selector: #openOn:;								arguments: { classTerseGuideHelp }]].					menu addLine.					menu addItem: [:item |						item							contents: 'Help Browser' translated;							help: 'Integrated Help System' translated;							target: classHelpBrowser;							selector: #open]]]]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 1/1/2011 19:18' prior: 53726274!jumpToProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Jump To Project' translated;			icon: MenuIcons smallProjectJumpIcon;			subMenuUpdater: self			selector: #updateJumpToProjectSubMenu: ]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 12/22/2010 00:13' prior: 53726701!loadProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Load Project' translated;			help: 'Load a project from a file' translated;			icon: MenuIcons smallProjectLoadIcon;			target: self;			selector: #loadProject ]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 12/22/2010 00:14' prior: 53728169!previousProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Previous Project' translated;			help: 'Return to the most-recently-visited project' translated;			icon: MenuIcons smallProjectBackIcon;			target: World;			selector: #goBack ]! !!TheWorldMainDockingBar methodsFor: 'submenu - squeak' stamp: 'MAD 12/22/2010 00:11' prior: 53728910!quitMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Quit' translated;			help: 'Quit out of Squeak' translated;			icon: MenuIcons smallQuitNoSaveIcon;			target: self;			selector: #quitSqueak ]! !!TheWorldMainDockingBar methodsFor: 'submenu - squeak' stamp: 'MAD 12/22/2010 00:11' prior: 53730393!saveAsNewVersionMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Save As New Version' translated;			help: 'Save the current state of Squeak on disk under a version-stamped name' translated;			icon: MenuIcons smallSaveNewIcon;			target: self;			selector: #saveAsNewVersion ]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 12/22/2010 00:12' prior: 53731355!saveProjectMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Save Project' translated;			help: 'Save this project on a file' translated;			icon: MenuIcons smallProjectSaveIcon;			target: World;			selector: #saveOnFile ]! !!TheWorldMainDockingBar methodsFor: 'submenu - projects' stamp: 'MAD 12/22/2010 00:15' prior: 33841630!toggleFullScreenMenuItemOn: menu	menu addItem: [ :item |		item			contents: 'Toggle Full Screen' translated;			help: 'Switch back and forth from full screen mode' translated;			icon: MenuIcons smallFullscreenOnIcon;			target: Project current;			selector: #toggleFullScreen ]! !!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'cmm 1/6/2011 16:25' prior: 34629311!welcomeToSqueak42	^'This is a list of the main achievements that went into the trunk image.Ready for next-generation VMA new virtual-machine, known as "Cog", is about to be released for Squeak.  It''s a complete rewrite from the ground-up, employing a Context-to-Stack mapping design onto which a JIT compiler for Intel-compatible hardware results in, roughly, a 3X, across-the-board performance improvement.  Specific Benchmarks vary much more widely (from 1x to 5x, with some people claiming 10x for specifics.Significant class-library and IDE improvementsMany enhancements, fixes, documentation and performance improvements to the class-library and IDE tools.  A new number parser allows greater flexibility in the expression of numbers.  Finalization enhancements.An efficient window-resizing gesture allows Squeak windows to be quickly and easily manipulated, much like modern "tabletop" technologies.There were also many enhancements to the internal text editor.High-precision ClockSqueak''s internal timer clock has been improved from millisecond to microsecond level precision. A Tidier imageA tidier image and code-base. Introduced a cleanUp protocol, removed the last direct users of CrLfFileStream, j3 support, SyntaxError, and more. Various packages and fonts can now be unloaded, if a smaller image is desired.The last of the underscore assignments have been replaced with ANSI assignments.There was also a significant refactoring and unification of Smalltalk and SmalltalkImage globals. stdio interfaceSqueak now includes an API for accessing the operating system stdio (supported only on newer VM''s). Industrial command-line interfaceThe command-line interface has been improved to properly support relative-path qualification to the input script. Compatible with signature Squeak packagesThis version of the Squeak platform is compatible with several unique packages like Croquet[*], Tweak, Seaside, muO, Magma, and more.  See "Extending the System" under the Help menu for more information.Better DocumentationHelpSystem has been added to the core image to provide a light-weight framework for improved documentation. It can be accessed via Help>>Help Browser. Various bits of documentation, including how to load some important packages, has been added.SUnitAll test cases now have an associated timeout after which the test is considered failed. The purpose of the timeout is to catch issues like infinite loops, unexpected user input etc. in automated test environments. Timeouts can be set on an individual test basis using the <timeout: seconds> tag or for an entire test case by implementing the #defaultTimeout method.GraphicsReading PNG images has been significantly sped up for some common cases. The improvements are in 50-200x range and heavily affect interactive uses of such files.Stricter Rectangles assert screen coordinate orientation. Empty Rectangles no longer #intersect: anything. Support for translucent fonts.MVCSupport for classic MVC has been restored to Squeak.  MVC provides a primitive, but ultra-high-speed user-interface based on classic model-view-controller architecture.!!]style[(73 28 394 48 416 20 100 14 408 15 103 33 115 1 1 41 206 20 247 5 369 8 303 5 170),bu,,bu,,bu,,bu,,bu,,bu,,bu,,bu,,bu,,bu,,bu,,bu,!!' readStream nextChunkText! !!MorphicProject methodsFor: 'utilities' stamp: 'nice 12/29/2010 14:50' prior: 58244003!setAsBackground: aForm	"Set  aForm as a background image."	| thisWorld newColor |	thisWorld := self currentWorld.	newColor := InfiniteForm with: aForm.	aForm rememberCommand:		(Command new cmdWording: 'set background to a picture' translated;			undoTarget: thisWorld selector: #color: argument: thisWorld color;			redoTarget: thisWorld selector: #color: argument: newColor).	thisWorld color: newColor! !!TTSampleStringMorph methodsFor: 'private' stamp: 'nice 12/29/2010 15:02' prior: 52823617!computeTransform	| cy |	cy := bounds origin y + bounds corner y * 0.5.	transform := MatrixTransform2x3 			transformFromLocal: (ttBounds insetBy: borderWidth negated)			toGlobal: bounds.	transform := transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0 @ cy negated).	transform := transform composedWithGlobal:(MatrixTransform2x3 withScale: 1.0 @ -1.0).	transform := transform composedWithGlobal:(MatrixTransform2x3 withOffset: 0 @ cy).	^transform! !!Color methodsFor: '*Morphic' stamp: 'jrd 10/18/2010 13:45'!asMorph	^(RectangleMorph new)		fillStyle: self;		borderWidth: 0;		yourself! !!ScrollPane methodsFor: 'geometry' stamp: 'nice 12/29/2010 15:00' prior: 56612127!vResizeScrollBar	| w topLeft borderHeight innerWidth |	w := self scrollBarThickness.	innerWidth := self flatColoredScrollBarLook 		ifTrue: 			[borderHeight := borderWidth.			0]		ifFalse: 			[borderHeight := 0.			 1].	topLeft := scrollBarOnLeft 				ifTrue: 					[retractableScrollBar 						ifTrue: [bounds topLeft - ((w - borderWidth) @ (0 - borderHeight))]						ifFalse: [bounds topLeft + ((borderWidth - innerWidth) @ borderHeight)]]				ifFalse: 					[retractableScrollBar 						ifTrue: [bounds topRight - (borderWidth @ (0 - borderHeight))]						ifFalse: 							[bounds topRight - ((w + borderWidth - innerWidth) @ (0 - borderHeight))]].				scrollBar 		bounds: (topLeft + ((scrollBarOnLeft ifTrue: [-1] ifFalse: [1]) @ -1) extent: w @ self vScrollBarHeight)	! !!MenuMorph class methodsFor: 'images' stamp: 'MAD 1/2/2011 00:27' prior: 59014755!pushPinImage	"Answer the push-pin image, creating and caching it at this time if it is absent"	^ MenuIcons smallPinIcon! !!MenuMorph methodsFor: 'construction' stamp: 'MAD 1/2/2011 00:38' prior: 59020352!addStayUpIcons	| title closeBox pinBox titleBarArea titleString |	title := submorphs				detect: [:ea | ea hasProperty: #titleString]				ifNone: [self setProperty: #needsTitlebarWidgets toValue: true.					^ self].	closeBox := SystemWindowButton new target: self;				 actionSelector: #delete;				 labelGraphic: self class closeBoxImage;				 color: Color transparent;				 extent: 14 @ 16;				 borderWidth: 0.	pinBox := SystemWindowButton new target: self;				 actionSelector: #stayUp:;				 arguments: {true};				 labelGraphic: self class pushPinImage;				 color: Color transparent;				 extent: 16 @ 16;				 borderWidth: 0.	Preferences noviceMode		ifTrue: [closeBox setBalloonText: 'close this menu'.			pinBox setBalloonText: 'keep this menu up'].	titleBarArea :=  AlignmentMorph newRow vResizing: #shrinkWrap;			 layoutInset: 3;			 color: Preferences menuTitleColor;			 addMorphBack: closeBox;			 addMorphBack: title;			 addMorphBack: pinBox.		title color: Color transparent.	titleString := title 		findDeepSubmorphThat: [:each | each respondsTo: #font: ]		ifAbsent: [StringMorph contents: String empty].	titleString font: Preferences windowTitleFont.	Preferences roundedMenuCorners		ifTrue: [titleBarArea useRoundedCorners].		self addMorphFront: titleBarArea.	titleBarArea setProperty: #titleString toValue: (title valueOfProperty: #titleString).	title removeProperty: #titleString.	self setProperty: #hasTitlebarWidgets toValue: true.	self removeProperty: #needsTitlebarWidgets.	self removeStayUpItems! !!MenuMorph methodsFor: 'keystroke helpers' stamp: 'cmm 1/11/2011 21:08' prior: 58210220!handleFiltering: evt	| matchString |	matchString := self valueOfProperty: #matchString ifAbsentPut: [ String new ].	matchString := evt keyValue = 8 " Character backspace asciiValue "		ifTrue: [			matchString isEmpty 				ifTrue: [ matchString ] 				ifFalse: [ matchString allButLast ] ]		ifFalse: [			matchString copyWith: evt keyCharacter ].	self setProperty: #matchString toValue: matchString.	self displayFiltered: evt! !!MenuMorph methodsFor: 'keystroke helpers' stamp: 'cmm 1/11/2011 21:06'!hideKeyboardHelp	self deleteBalloon! !!MenuMorph methodsFor: 'keyboard control' stamp: 'cmm 1/11/2011 21:07' prior: 58212035!keyStroke: evt 	self hideKeyboardHelp; noteRootMenuHasUsedKeyboard.	self keyStrokeHandlers		detect: [:each | self perform: each with: evt]		ifNone: [self handleFiltering: evt]! !!MenuMorph methodsFor: 'control' stamp: 'cmm 1/11/2011 21:04' prior: 23653647!popUpAt: aPoint forHand: hand in: aWorld allowKeyboard: aBoolean 	"Present this menu at the given point under control of the given 	hand."	| evt |	aWorld submorphs		select: [:each | (each isKindOf: MenuMorph)				and: [each stayUp not]]		thenCollect: [:menu | menu delete].	self items isEmpty		ifTrue: [^ self].	MenuIcons decorateMenu: self.	(self submorphs		select: [:m | m isKindOf: UpdatingMenuItemMorph])		do: [:m | m updateContents].	"precompute width"	self		positionAt: aPoint		relativeTo: (selectedItem				ifNil: [self items first])		inWorld: aWorld.	aWorld addMorphFront: self.	"Acquire focus for valid pop up behavior"	hand newMouseFocus: self.	aBoolean		ifTrue: [hand newKeyboardFocus: self.			self showKeyboardHelp].	evt := hand lastEvent.	(evt isKeyboard			or: [evt isMouse					and: [evt anyButtonPressed not]])		ifTrue: ["Select first item if button not down"			self moveSelectionDown: 1 event: evt			"Select first item if button not down"].	self updateColor.	self changed! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'nice 12/29/2010 14:58' prior: 52216248!adjustBookControls	| inner |	proceedButton ifNil: [^ self].	proceedButton align: proceedButton topLeft with: (inner := self innerBounds) topLeft + (35 @ -4).	debugButton align: debugButton topRight with: inner topRight - (16 @ 4).! !!TTSampleFontMorph methodsFor: 'drawing' stamp: 'nice 12/29/2010 15:02' prior: 52816750!drawCharactersOn: aCanvas	| glyph origin r offset cy m |	0 to: 255 do: [:i |		glyph := font at: i.		origin := font bounds extent * ((i \\ 16) @ (i // 16)).		r := origin extent: font bounds extent.		offset := r center - glyph bounds center.		cy := glyph bounds center y.		m := MatrixTransform2x3 withOffset: 0@cy.		m := m composedWithLocal: (MatrixTransform2x3 withScale: 1 @ -1).		m := m composedWithLocal: (MatrixTransform2x3 withOffset: 0 @ cy negated).		m := m composedWithGlobal: (MatrixTransform2x3 withOffset: offset).		aCanvas asBalloonCanvas preserveStateDuring: [:balloonCanvas |			balloonCanvas transformBy: m.			balloonCanvas drawGeneralBezierShape: glyph contours					color: color					borderWidth: 0					borderColor: Color black.		].	].! !!HaloMorph methodsFor: 'private' stamp: 'cmm 1/10/2011 14:59' prior: 21441072!addHandleAt: aPoint color: aColor icon: iconName on: eventName send: selector to: recipient 	"Add a handle centered at the given point with the given color, 	and set it up to respond to the given event by sending the 	given selector to the given recipient. Return the handle."	| handle |	handle := self createHandleAt: aPoint color: (aColor alpha: 0.8) iconName: iconName.	self addMorph: handle.	handle on: #mouseUp send: #endInteraction to: self.	handle on: eventName send: selector to: recipient.	handle setBalloonText: (target balloonHelpTextForHandle: handle) translated.	^ handle ! !!HaloMorph methodsFor: 'private' stamp: 'cmm 1/10/2011 15:00' prior: 58009011!createHandleAt: aPoint color: aColor iconName: iconName 	| bou handle |	bou := Rectangle center: aPoint extent: self handleSize asPoint.	Preferences alternateHandlesLook		ifTrue: [handle := RectangleMorph newBounds: bou color: aColor.			handle useRoundedCorners.			self setColor: aColor toHandle: handle]		ifFalse: [handle := EllipseMorph newBounds: bou color: aColor].	handle borderWidth: 0;		 wantsYellowButtonMenu: false.	""	iconName isNil		ifFalse: [| form |			form := ScriptingSystem formAtKey: iconName.			form isNil				ifFalse: [| image |					image := ImageMorph new.					image image: form.					image color: aColor makeForegroundColor.					image lock.					handle addMorphCentered: image]].	""	^ handle! !!HaloMorph methodsFor: 'drawing' stamp: 'cmm 1/10/2011 14:58' prior: 21415923!drawOn: aCanvas 	"Draw this morph only if it has no target."	target isNil		ifTrue: [^ super drawOn: aCanvas].	(Preferences showBoundsInHalo			and: [target isWorldMorph not])		ifTrue: [| boundsColor |			boundsColor := Preferences menuSelectionColor						ifNil: [Color blue].			aCanvas				frameAndFillRectangle: self bounds				fillColor: Color transparent				borderWidth: 2				borderColor: 					(boundsColor isTranslucent						ifTrue: [boundsColor]						ifFalse: [boundsColor alpha: 0.8])]! !!BalloonCanvas methodsFor: 'private' stamp: 'nice 12/29/2010 16:10' prior: 53317222!makeRoundRectShape: aRectangle radius: radius	"decompose a rounded rectangle into bezier form"	| ovalDiameter rectExtent segments points endPoint seg idx offset rectOffset |	ovalDiameter := (radius * 2) asPoint min: aRectangle extent.	(ovalDiameter x <= 0 or: [ovalDiameter y <= 0]) ifTrue: [		"degenerates into rectangle - just hand back four lines"		| topLeft topRight bottomLeft bottomRight |		topLeft := aRectangle topLeft.		topRight := aRectangle topRight.		bottomLeft := aRectangle bottomLeft.		bottomRight := aRectangle bottomRight.		points := Array new: 4 * 3.		points at: 1 put: topLeft.		points at: 2 put: topLeft.		points at: 3 put: topRight.		points at: 4 put: topRight.		points at: 5 put: topRight.		points at: 6 put: bottomRight.		points at: 7 put: bottomRight.		points at: 8 put: bottomRight.		points at: 9 put: bottomLeft.		points at: 10 put: bottomLeft.		points at: 11 put: bottomLeft.		points at: 12 put: topLeft.		^points	].	rectExtent := aRectangle extent - ovalDiameter.	rectOffset := aRectangle origin.	segments := Bezier2Segment makeEllipseSegments: (0 @ 0 extent: ovalDiameter).	"patch up the segments to include lines connecting the oval parts.	we need: 8*3 points for the oval parts + 4*3 points for the connecting lines"	points := Array new: 12 * 3.	idx := 0.	"Tweaked offsets to clean up curves. MAD"	endPoint := segments last end + rectOffset + (0 @ -1).	1 to: 8 by: 2 do: [:i |		i = 1 ifTrue: [offset := rectOffset + (rectExtent x @ 0) + (1 @ -1)]. "top, tr"		i = 3 ifTrue: [offset := rectOffset + rectExtent + (1 @ 1)]. "right, br"		i = 5 ifTrue: [offset := rectOffset + (0 @ rectExtent y) + (0 @ 1)]. "bottom, bl"		i = 7 ifTrue: [offset := rectOffset + (0 @ -1)]."left, tl"		seg := segments at: i.		"insert a line segment for the horizontal part of the round rect"		points at: (idx := idx + 1) put: endPoint.		points at: (idx := idx + 1) put: endPoint.		points at: (idx := idx + 1) put: seg start + offset.		"now the first half-arc"		points at: (idx := idx + 1) put: seg start + offset.		points at: (idx := idx + 1) put: seg via + offset.		points at: (idx := idx + 1) put: seg end + offset.		"the second half-arc"		seg := segments at: i + 1.		points at: (idx := idx + 1) put: seg start + offset.		points at: (idx := idx + 1) put: seg via + offset.		points at: (idx := idx + 1) put: seg end + offset.		endPoint := seg end + offset.	].	^points! !!PolygonMorph methodsFor: 'attachments' stamp: 'nice 12/29/2010 14:58' prior: 54574798!nudgeForLabel: aRectangle	"Try to move the label off me. Prefer labels on the top and right."	| i flags nudge |	(self bounds intersects: aRectangle) ifFalse: [^ 0 @ 0 ].	flags := 0.	nudge := 0 @ 0.	i := 1.	aRectangle lineSegmentsDo: [ :rp1 :rp2 | | rectSeg |		rectSeg := LineSegment from: rp1 to: rp2.		self straightLineSegmentsDo: [ :lp1 :lp2 | | polySeg int |			polySeg := LineSegment from: lp1 to: lp2.			int := polySeg intersectionWith: rectSeg.			int ifNotNil: [ flags := flags bitOr: i ].		].		i := i * 2.	].	"Now flags has bitflags for which sides"	nudge := flags caseOf: {"no intersection"		[ 0 ] -> [ 0 @ 0 ]."2 adjacent sides only" 		[ 9 ] -> [ 1 @ 1 ].		[ 3 ] -> [ -1 @ 1 ].		[ 12 ] -> [ 1 @ -1 ].		[ 6 ] -> [ -1 @ -1 ]."2 opposite sides only" 		[ 10 ] -> [ 0 @ -1 ].		[ 5 ] -> [ 1 @ 0 ]."only 1 side" 		[ 8 ] -> [ -1 @ 0 ].		[ 1 ] -> [ 0 @ -1 ].		[ 2 ] -> [ 1 @ 0 ].		[ 4 ] -> [ 0 @ 1 ]."3 sides" 		[ 11 ] -> [ 0 @ 1 ].		[ 13 ] -> [ 1 @ 0 ].		[ 14 ] -> [ 0 @ -1 ].		[ 7 ] -> [ -1 @ 0 ]. "all sides" 		[ 15 ] -> [ 1 @ -1 "move up and to the right" ].	}.	^nudge! !!SystemWindow class methodsFor: 'initializing' stamp: 'cmm 1/10/2011 14:10' prior: 59009527!updatePreferences	"Temporary method to update system-wide preferences"	Preferences setPreference: #defaultWindowColor toValue: (Color veryVeryLightGray muchLighter).	(Preferences preferenceAt: #defaultWindowColor) defaultValue: (Color veryVeryLightGray muchLighter).	Preferences setPreference: #menuAppearance3d toValue: true.	(Preferences preferenceAt: #menuAppearance3d) defaultValue: true.	Preferences setPreference: #menuColorFromWorld toValue: false.	(Preferences preferenceAt: #menuColorFromWorld) defaultValue: false.	Preferences setPreference: #roundedMenuCorners toValue: false.	(Preferences preferenceAt: #roundedMenuCorners) defaultValue: false.	Preferences setParameter: #menuColor to: (Color gray: 0.9).	Preferences setParameter: #menuTitleColor to: (Color transparent).	Preferences setParameter: #menuTitleBorderWidth to: 0.	Preferences setParameter: #defaultWorldColor to: (Color gray: 0.25).	Preferences setPreference: #showSplitterHandles toValue: false.	(Preferences preferenceAt: #showSplitterHandles) defaultValue: true.	Preferences setPreference: #showSharedFlaps toValue: false.	(Preferences preferenceAt: #showSharedFlaps) defaultValue: false.	Preferences installBrightWindowColors.	CornerGripMorph drawCornerResizeHandles: false.	FillInTheBlankMorph roundedDialogCorners: true.	LazyListMorph		listSelectionColor: LazyListMorph listSelectionColor;		listSelectionTextColor: Color black.	PluggableButtonMorph roundedButtonCorners: true.	SystemWindow		clickOnLabelToEdit: false;		doubleClickOnLabelToExpand: true;		moveMenuButtonRight: true;		hideExpandButton: false.! !MenuIcons class removeSelector: #importAllIconNamed:!!MacUnicodeInputInterpreter methodsFor: 'initialization' stamp: 'sn 11/8/2010 00:48' prior: 51592229!initialize	| satisfiesVersion |	satisfiesVersion := self				majorMinorBuildFrom: SmalltalkImage current vmVersion				satisfies: [:major :minor :build | 					major >= 4 or: [					major >= 3 and: [minor >= 8 and: [build >= 7]]]].	satisfiesVersion		ifTrue: [keyValueIndex := 6]		ifFalse: [keyValueIndex := 3]! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'sn 11/8/2010 00:47' prior: 22525992!fileNameConverterClass	^ self systemConverterClass! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'sn 11/8/2010 00:47' prior: 56390675!inputInterpreterClass	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current osVersion.	(platformName = 'Win32' and: [osVersion ~= 'CE'])		ifTrue: [^ (self win32VMUsesUnicode) ifTrue: [UTF32InputInterpreter] ifFalse: [MacRomanInputInterpreter]].	platformName = 'Mac OS'		ifTrue: [^ MacUnicodeInputInterpreter].	platformName = 'unix'		ifTrue: [^ UTF32InputInterpreter].	^ MacUnicodeInputInterpreter! !!Latin1Environment class methodsFor: 'subclass responsibilities' stamp: 'sn 11/8/2010 00:47' prior: 22526767!systemConverterClass	| platformName osVersion |	platformName := SmalltalkImage current platformName.	osVersion := SmalltalkImage current getSystemAttribute: 1002.	(platformName = 'Win32'			and: [osVersion = 'CE'])		ifTrue: [^ MacRomanTextConverter].	platformName = 'Win32'		ifTrue: [^ (self win32VMUsesUnicode) ifTrue: [UTF8TextConverter] ifFalse: [Latin1TextConverter]].	platformName = 'Mac OS'		ifTrue: [^ ('10*' match: SmalltalkImage current osVersion)				ifTrue: [UTF8TextConverter]				ifFalse: [MacRomanTextConverter]].	platformName = 'unix'		ifTrue: [^ UTF8TextConverter].	^ MacRomanTextConverter! !!MultiByteFileStream class methodsFor: 'as yet unclassified' stamp: 'ul 1/20/2011 02:18'!newForStdio	"Use crlf as line end convention on windows, lf on all other platforms. Also make sure that the converter is initialized."		| lineEndConvention |	lineEndConvention := self lineEndDefault.	lineEndConvention == #crlf ifFalse: [		lineEndConvention := #lf ].	^self new		lineEndConvention: lineEndConvention;		initializeConverter;		yourself! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 1/20/2011 01:51' prior: 24652132!bareNext	self deprecated: 'Don''t use this method anymore.'.	^converter nextFromStream: self.! !!MultiByteFileStream methodsFor: 'accessing' stamp: 'ul 1/20/2011 01:42' prior: 53389672!converter	^converter ifNil: [		self initializeConverter.		converter ]! !!MultiByteFileStream methodsFor: 'initialize-release' stamp: 'ul 1/4/2011 07:53'!initializeConverter	self converter: TextConverter defaultSystemConverter! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 12/27/2010 04:46' prior: 57725280!next	| char |	char := converter nextFromStream: self.	"#doConversion is inlined here"	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) ifTrue: [		char == Cr ifTrue: [			| state |			state := converter saveStateOf: self.			(converter nextFromStream: self) ifNotNil: [ :secondChar |				secondChar == Lf ifFalse: [					converter restoreStateOf: self with: state ] ].			^Cr ].		char == Lf ifTrue: [			^Cr ] ].	^char.! !!MultiByteFileStream methodsFor: 'crlf private' stamp: 'ul 12/27/2010 04:43' prior: 51906118!next: n innerFor: aString	aString size = 0 ifTrue: [^ aString].	"if we just read a CR, and the next character is an LF, then skip the LF"	aString last == Cr ifTrue: [		| state |		state := converter saveStateOf: self.		(converter nextFromStream: self) ifNotNil: [ :peekChar |			peekChar == Lf ifFalse: [				converter restoreStateOf: self with: state ] ] ].	^aString withSqueakLineEndings! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 12/20/2010 09:02' prior: 58783307!nextPut: aCharacter	aCharacter isInteger ifTrue: [ ^super nextPut: aCharacter ].	(wantsLineEndConversion == true and: [ lineEndConvention notNil ]) "#doConversion is inlined here"		 ifTrue: [			aCharacter == Cr				ifTrue: [					converter 						nextPutAll: (LineEndStrings at: lineEndConvention)						toStream: self ]				ifFalse: [ 					converter nextPut: aCharacter toStream: self ].			^aCharacter ].	converter nextPut: aCharacter toStream: self.	^aCharacter! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 12/20/2010 09:04' prior: 58783888!nextPutAll: aCollection	(self isBinary or: [aCollection class == ByteArray]) ifTrue: [		^ super nextPutAll: aCollection.	].	converter nextPutAll: aCollection toStream: self.	^aCollection! !!MultiByteFileStream methodsFor: 'private' stamp: 'ul 1/20/2011 01:55' prior: 57452768!setConverterForCode	| currentPosition |	(SourceFiles at: 2)		ifNotNil: [self fullName = (SourceFiles at: 2) fullName ifTrue: [^ self]].	currentPosition := self position.	self position: 0.	self binary.	((self next: 3) = #[ 16rEF 16rBB 16rBF ]) ifTrue: [		self converter: UTF8TextConverter new	] ifFalse: [		self converter: MacRomanTextConverter new.	].	self position: currentPosition.	self text.! !!MultiDisplayScanner methodsFor: 'scanning' stamp: 'mtf 12/30/2010 23:37' prior: 59105188!placeEmbeddedObject: anchoredMorph	anchoredMorph relativeTextAnchorPosition ifNotNil:[		anchoredMorph position: 			anchoredMorph relativeTextAnchorPosition +			(anchoredMorph owner textBounds origin x @ 0)			- (0@morphicOffset y) + (0@lineY).		^true	].	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	(anchoredMorph isMorph or: [anchoredMorph isPrimitiveCostume]) ifTrue: [		anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset	] ifFalse: [		destY := lineY.		baselineY := lineY + anchoredMorph height..		runX := destX.		anchoredMorph 			displayOn: bitBlt destForm 			at: destX - anchoredMorph width @ destY			clippingBox: bitBlt clipRect			rule: Form blend			fillColor: Color white 	].	^ true! !MultiByteFileStream removeSelector: #openOnHandle:name:forWrite:!"Multilingual"!!PianoKeyboardMorph methodsFor: 'simple keyboard' stamp: 'nice 12/29/2010 14:56' prior: 52151548!buildKeyboard	| wtWid bkWid keyRect octavePt nWhite nBlack |	self removeAllMorphs.	wtWid := 8. bkWid := 5.	self extent: 10 @ 10.	1 to: nOctaves + 1 do:		[:i | i <= nOctaves ifTrue: [nWhite := 7.  nBlack := 5]						ifFalse: [nWhite := 1.  nBlack := 0 "High C"].		octavePt := self innerBounds topLeft + ((7 * wtWid * (i - 1) - 1) @ -1).		1 to: nWhite do:			[:j | keyRect := octavePt + (j - 1 * wtWid @ 0) extent: (wtWid + 1) @ 36.			self addMorph: ((RectangleMorph newBounds: keyRect color: whiteKeyColor)								borderWidth: 1;				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i - 1 * 12 + (#(1 3 5 6 8 10 12) at: j))].		1 to: nBlack do:			[:j | keyRect := octavePt + ((#(6 15 29 38 47) at: j) @ 1) extent: bkWid @ 21.			self addMorph: ((Morph newBounds: keyRect color: blackKeyColor)				on: #mouseDown send: #mouseDownPitch:event:noteMorph: to: self								withValue: i - 1 * 12 + (#(2 4 7 9 11) at: j))]].	self submorphsDo:		[:m | m on: #mouseMove send: #mouseMovePitch:event:noteMorph: to: self;				on: #mouseUp send: #mouseUpPitch:event:noteMorph: to: self;				on: #mouseEnterDragging send: #mouseDownPitch:event:noteMorph: to: self;				on: #mouseLeaveDragging send: #mouseUpPitch:event:noteMorph: to: self].	self extent: (self fullBounds extent + borderWidth - 1)! !!FlapTab methodsFor: 'misc' stamp: 'nice 12/29/2010 14:43' prior: 20778748!fitContents	self isCurrentlyTextual ifFalse: [^ super fitContents].	self ifVertical:		[self extent: submorphs first extent + (2 * self borderWidth) + (0 @ 4).		submorphs first position: self position + self borderWidth + (1 @ 4)]	ifHorizontal:		[self extent: submorphs first extent + (2 * self borderWidth) + (8 @ -1).		submorphs first position: self position + self borderWidth + (5 @ 1)]! !!PostscriptDummyWarp methodsFor: 'dummy' stamp: 'nice 12/29/2010 14:58' prior: 52213901!subCanvas:patchRect	subCanvas ifNil:		[ subCanvas := PostscriptCanvas new reset setOrigin:patchRect topLeft clipRect: (-10000 @ -10000 extent: 20000 @ 20000)].	^subCanvas.! !!PaintBoxMorph methodsFor: 'recent colors' stamp: 'nice 12/29/2010 14:54' prior: 52047513!fixUpColorPicker	| chart picker |	chart := ColorChart ifNil: [ColorChart := Cursor wait showWhile: [(ColorPickerMorph colorPaletteForDepth: 16 extent: 120 @ 89)]].	chart getCanvas frameRectangle: chart boundingBox color: Color black.	picker := Form extent: (chart extent + (14 @ 12)) depth: 16.	picker fillWhite.	"top"	picker copy: (0 @ 0 extent: picker width @ 6)			from: (colorMemory image width - picker width) @ 0 			in: colorMemory image rule: Form over.	"bottom"	picker copy: (0 @  (picker height - 6) extent: picker width @ 6) 			from: (colorMemory image width - picker width) @ (colorMemory image height - 7)			in: colorMemory image rule: Form over.	"left"	picker copy: (0 @ 6 corner: 8 @ (picker height - 6))			from: (colorMemory image boundingBox topLeft + (0 @ 6)) 			in: colorMemory image rule: Form over.	"right"	picker copy: (picker width-6 @ 6 corner: picker width @ (picker height - 6))			from: (colorMemory image boundingBox topRight - (6 @ -6)) 			in: colorMemory image rule: Form over.	chart displayOn: picker at: 8 @ 6.	picker getCanvas frameRectangle: picker boundingBox color: Color black.	colorMemory image: picker.! !!PaintBoxMorph methodsFor: 'initialization' stamp: 'nice 12/29/2010 14:53' prior: 52041659!init4	"Just a record of how Ted loaded in the paintbox button images, Feb 98"	| bb im pp newImage pic24Bit picNewBit blt |	"self loadoffImage: 'roundedPalette3.bmp'."	pic24Bit := GIFReadWriter formFromServerFile: 'updates/137roundedPalette3.bmp'.	picNewBit := Form extent: pic24Bit extent depth: 16.	pic24Bit displayOn: picNewBit.	OriginalBounds := picNewBit boundingBox.	AllOffImage := Form extent: OriginalBounds extent depth: 16.	blt := BitBlt current toForm: AllOffImage.	blt sourceForm: picNewBit; combinationRule: Form over;		sourceRect: OriginalBounds; destOrigin: 0 @ 0; copyBits.	AllOffImage mapColor: Color transparent to: Color black.	self image: AllOffImage.	self invalidRect: bounds.	self submorphsDo: [:button | button position: button position + (10 @ 10)].	(im := submorphs at: 28) class == ImageMorph ifTrue: [		im position: im position + (2 @ 0)].	"color picker"	"exercise it once"	(bb := self submorphNamed: #keep:) position: bb position + (0 @ 25).	(bb := self submorphNamed: #toss:) position: bb position + (0 @ 25).	(bb := self submorphNamed: #undo:) position: bb position + (0 @ -25).	(bb := self submorphNamed: #clear:) position: bb position + (0 @ -25).	(bb := self submorphNamed: #undo:) position: bb position + (0 @ -69).	(bb := self submorphNamed: #clear:) position: bb position + (0 @ -69).	self submorphsDo: [:button | 		button class == AlignmentMorph ifTrue: [			button position: button position + (0 @ 25)].		(button printString includesSubString: 'stamp:') ifTrue: [			button position: button position + (0 @ 25)]].	(bb := self submorphNamed: #prevStamp:) position: bb position + (0 @ 25).	(bb := self submorphNamed: #nextStamp:) position: bb position + (0 @ 25).	bb := self submorphNamed: #keep:.	newImage := bb pressedImage copy: (0 @ 4 corner: (bb pressedImage boundingBox extent)).	bb onImage: newImage.  bb pressedImage: newImage.  bb extent: newImage extent.	bb position: bb position + (4 @ 1).	pp := (bb := self submorphNamed: #toss:) pressedImage.	newImage := pp copy: (0 @ 4 corner: (bb pressedImage extent - (3 @ 0))).	bb onImage: newImage.  bb pressedImage: newImage.  	bb extent: newImage extent.	bb position: bb position + (3 @ 1).	pp := (bb := self submorphNamed: #undo:) pressedImage.	newImage := pp copy: (0 @ 0 corner: (bb pressedImage extent - (3 @ 5))).	bb onImage: newImage.  bb pressedImage: newImage.  	bb extent: newImage extent.	bb position: bb position + (3 @ -1).	pp := (bb := self submorphNamed: #clear:) pressedImage.	newImage := pp copy: (0 @ 0 corner: (bb pressedImage extent - (0 @ 5))).	bb onImage: newImage.  bb pressedImage: newImage.  	bb extent: newImage extent.	bb position: bb position + (3 @ -1).	pic24Bit := GIFReadWriter formFromServerFile: 'updates/137pencil.bmp'.	picNewBit := Form extent: pic24Bit extent depth: 16.	pic24Bit displayOn: picNewBit.	newImage := picNewBit as8BitColorForm.	newImage transparentColor: (Color r: 0 g: 0 b: 0).	(bb := self submorphNamed: #erase:) pressedImage: newImage; onImage: newImage;		extent: newImage extent.	bb position: bb position + (-11 @ -1).! !"MorphicExtras"!!FormCanvasTest methodsFor: 'tests' stamp: 'ar 12/30/2010 17:51'!testDefaultClipRect	self assert: (FormCanvas extent: 222@111) clipRect = (0@0 corner: 222@111).	self assert: (FormCanvas extent: 2222@11) clipRect = (0@0 corner: 2222@11).	self assert: (FormCanvas extent: 22222@1) clipRect = (0@0 corner: 22222@1).! !"MorphicTests"!!PackageInfo class methodsFor: 'private' stamp: 'cmm 1/19/2011 17:15'!classFor: packageNameString 	self		allSubclassesDo: [:each | (each packageName isString					and: [each packageName sameAs: packageNameString])				ifTrue: [^ each]]! !!PackageInfo class methodsFor: 'packages access' stamp: 'cmm 1/12/2011 13:52' prior: 25442925!named: aString 	"Answer the PackageInfo with name aString."	| original replacement |	original := PackageOrganizer default				packageNamed: aString				ifAbsent: [].	^ (original isNil			or: [original class					~= (self classFor: aString)])		ifTrue: [replacement := self newNamed: aString.			original				ifNotNil: [replacement copySameFrom: original].			replacement register; yourself]		ifFalse: [original]! !!PackageInfo class methodsFor: 'private' stamp: 'cmm 1/12/2011 12:24'!newNamed: aString 	^ (self classFor: aString) new packageName: aString;		 yourself! !!PackageInfo class methodsFor: 'packages access' stamp: 'cmm 1/11/2011 18:15'!packageName	"Subclasses announce their presence for a particular package by	overriding this method, answering the packageName of the package	they wish to represent. This is useful for the #classFor: factory	method. "	^ nil! !!PackageInfo class methodsFor: 'registration / unregistration' stamp: 'ab 11/14/2002 15:05' prior: 56418948!registerPackage: aString	"for compatibility with old fileOuts"	^ Smalltalk at: #FilePackageManager ifPresent: [:p | p registerPackage: aString]! !!PackageInfo class methodsFor: 'registration / unregistration' stamp: 'avi 11/11/2003 17:19' prior: 25443127!registerPackageName: aString	^ PackageOrganizer default registerPackageNamed: aString! !!PackageInfo methodsFor: 'naming' stamp: 'mist 2/17/2005 12:55' prior: 52030391!name^ self packageName! !!PackageInfo methodsFor: 'naming' stamp: 'cmm 1/11/2011 18:22' prior: 52028024!packageName	^ packageName		ifNil: [packageName := self class packageName						ifNil: [self categoryName]]! !"PackageInfo-Base"!SMDependencyTest removeSelector: #test2!"SMBase"!!SMLoader methodsFor: 'interface' stamp: 'gk 4/12/2010 00:03' prior: 33641710!help	"Present help text. If there is a web server available, offer to open it.	Use the WebBrowser registry if possible, or Scamper if available."	| message browserClass |	message := 'Welcome to the SqueakMap package loader. The names of packages are followed by (installed version -> latest version).If there is no arrow, your installed version of the package is the latest.Installed packages and releases are also in bold.The checkbox menu items at the bottom let you modify which packages you''ll see. Take a look at them - only some packages are shown initially.The options available for a package depend on how it was packaged.If you like a package or have comments on it, please contactthe author or the squeak mailing list.'.	browserClass := Smalltalk at: #WebBrowser ifPresent: [ :registry | registry default ].	browserClass := browserClass ifNil: [ Smalltalk at: #Scamper ifAbsent: [ ^self inform: message ]].	(self confirm: message, 'Would you like to view more detailed help on the SqueakMap swiki page?') 	ifTrue: [ browserClass openOnUrl: 'http://wiki.squeak.org/squeak/2726' asUrl]! !!SMLoader methodsFor: 'initialization' stamp: 'cmm 1/19/2011 14:45' prior: 27933319!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy! !!SMLoaderPlus class methodsFor: 'class initialization' stamp: 'cmm 1/21/2011 13:48'!setDefaultFilters: anOrderedCollection	DefaultFilters := anOrderedCollection! !!SMLoaderPlus methodsFor: 'menus' stamp: 'cmm 1/20/2011 22:34' prior: 33599790!commandSpecs	^ #(('Install' installPackageRelease 'Install the latest version from the server.' (item all))		('Email' emailPackageMaintainers 'Open an editor to send an email to the owner and co-maintainers of this package.' (item all))		('Browse cache' browseCacheDirectory 'Browse cache directory of the selection.' (item all))		('Copy from cache' cachePackageReleaseAndOfferToCopy 'Download selected release into cache first if needed, and then offer to copy it somewhere else.' (item))		('Force download into cache' downloadPackageRelease 'Force a download of the selected release into the cache.' (item))		('Update' loadUpdates 'Update the package index from the servers.' (all))		('Upgrade All' upgradeInstalledPackagesConfirm 'Upgrade all installed packages (confirming each).' (all))		('Upgrade all installed packages' upgradeInstalledPackagesNoConfirm '' (item))		('Upgrade all installed packages confirming each' upgradeInstalledPackagesConfirm '' (item))		('Copy list' listInPasteBuffer 'Puts the list as text into the clipboard.' (all))		('Save filters' saveFiltersAsDefault 'Saves the current filters as default.' (all))		('Help' help 'What is this?' (all)))! !!SMLoaderPlus methodsFor: 'initialization' stamp: 'cmm 1/19/2011 14:45' prior: 33612959!on: aSqueakMap 	"Initialize instance."	map := aSqueakMap.	map synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy! !SMLoaderPlus removeSelector: #askToLoadUpdates!SMLoader removeSelector: #askToLoadUpdates!"SMLoader"!!StandardSystemView methodsFor: 'label access' stamp: 'nice 12/29/2010 15:01' prior: 29889545!closeBoxFrame	^ Rectangle origin: (self labelDisplayBox leftCenter + (10 @ -5)) extent: (11 @ 11)! !!StandardSystemView methodsFor: 'label access' stamp: 'nice 12/29/2010 15:01' prior: 29889718!growBoxFrame	^ Rectangle origin: (self labelDisplayBox rightCenter + (-22 @ -5)) extent: (11 @ 11)! !!ParagraphEditor methodsFor: 'private' stamp: 'nice 11/15/2010 21:17' prior: 53468176!sameColumn: start newLine: lineBlock forward: isForward	"Private - Compute the index in my text	with the line number derived from lineBlock,"	" a one argument block accepting the old line number.	The position inside the line will be preserved as good as possible"	"The boolean isForward is used in the border case to determine if	we should move to the beginning or the end of the line."	| wordStyle column currentLine offsetAtTargetLine targetEOL lines numberOfLines currentLineNumber targetLineNumber |	wordStyle := Preferences wordStyleCursorMovement.	wordStyle		ifTrue: [			lines := paragraph lines.			numberOfLines := paragraph numberOfLines.			currentLineNumber  := paragraph lineIndexOfCharacterIndex: start.			currentLine := lines at: currentLineNumber]		ifFalse: [			lines := self lines.			numberOfLines := lines size.			currentLine := lines				detect:[:lineInterval | lineInterval last >= start]				ifNone:[lines last].			currentLineNumber := currentLine second].	column := start - currentLine first.	targetLineNumber := ((lineBlock value: currentLineNumber) max: 1) min: numberOfLines.	offsetAtTargetLine := (lines at: targetLineNumber) first.	targetEOL := (lines at: targetLineNumber) last + (targetLineNumber = numberOfLines ifTrue:[1]ifFalse:[0]).	targetLineNumber = currentLineNumber	"No movement or movement failed. Move to beginning or end of line."		ifTrue:[^isForward			ifTrue:[targetEOL]			ifFalse:[offsetAtTargetLine]].	^offsetAtTargetLine + column min: targetEOL.! !!GraphicSymbolInstance class methodsFor: 'examples' stamp: 'nice 12/29/2010 16:53' prior: 21324187!example	"Simply evaluate the method and two GraphicSymbolInstances, each	displaying a transformation of the same graphic symbol, will be	presented on the screen. Clears the screen to white."	| gate instance1 instance2 trans1 trans2 line arc f|	Display fillWhite.			"clear the Screen."	f := Form extent: 2 @ 2.	f fillBlack.	gate:= GraphicSymbol new.		"make a logic gate out of lines and arcs."	line:=Line new.  line beginPoint: -20 @ -20.  line endPoint: 0 @ -20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: -20 @ 20.  line endPoint: 0 @ 20. line form: f.	gate add: line.	line:=Line new.  line beginPoint: 0 @ -40.  line endPoint: 0 @ 40. line form: f.	gate add: line.	arc := Arc new. arc center: 0 @ 0 radius: 40 quadrant: 1.	arc form: f.	gate add: arc.	arc := Arc new. arc center: 0 @ 0 radius: 40 quadrant: 4.	arc form: f.	gate add: arc.			"one instance at 1/2 scale."	trans1:=WindowingTransformation identity.		trans1:= trans1 scaleBy: 0.5 @ 0.5.	trans1:= trans1 translateBy: 100 @ 100.			"the other instance at 2 times scale"	trans2:=WindowingTransformation identity.		trans2:= trans2 scaleBy: 2.0 @ 2.0.	trans2:= trans2 translateBy: 200 @ 200.	instance1 := GraphicSymbolInstance new.	instance1 transformation: trans1.	instance1 graphicSymbol: gate.	instance2 := GraphicSymbolInstance new.	instance2 transformation: trans2.	instance2 graphicSymbol: gate.			"display both instances of the logic gate"	instance1 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil.	instance2 displayOn: Display					transformation: WindowingTransformation identity					clippingBox: Display boundingBox					rule: Form under					fillColor: nil	"GraphicSymbolInstance example"! !!StandardSystemController methodsFor: 'borders' stamp: 'nice 12/29/2010 15:01' prior: 29858415!cursorOnBorder 	| cp i box |	view isCollapsed ifTrue: [^ false].	cp := sensor cursorPoint.	((view labelDisplayBox insetBy: (0 @ 2 corner: 0 @ -2)) containsPoint: cp)		ifTrue: [^ false].	(i := view subViews findFirst: [:v | v displayBox containsPoint: cp]) = 0		ifTrue: [box := view windowBox]		ifFalse: [box := (view subViews at: i) insetDisplayBox].	^ ((box insetBy: 3) containsPoint: cp) not		and: [(box expandBy: 4) containsPoint: cp]! !"ST80"!!TestRunner methodsFor: 'accessing' stamp: 'cmm 1/11/2011 10:50'!classesSelected	^ classesSelected! !!TestRunner methodsFor: 'accessing-ui' stamp: 'cmm 1/11/2011 10:50'!postAcceptBrowseFor: aModel	"Nothing to do."! !!TestRunner methodsFor: 'accessing-ui' stamp: 'cmm 1/11/2011 10:50'!representsSameBrowseeAs: anotherModel 	^ self class = anotherModel class	and: [ classesSelected = anotherModel classesSelected ]! !"SUnitGUI"!!MCRepositoryTest methodsFor: 'tests' stamp: 'cmm 1/2/2011 21:38' prior: 35267275!testCreationMethods	"Tests creation via MCRepository>>location:"	| repo |	repo := MCRepository location: FileDirectory default pathName.	self assert: (repo isKindOf: MCDirectoryRepository).	self assert: (repo description = FileDirectory default pathName).	repo := MCRepository location: (FileDirectory default pathName, FileDirectory slash, '*').	self assert: (repo isKindOf: MCSubDirectoryRepository).	"XXXX: MCSubDirectoryRepo prints wrongly on Windows"	self assert: (repo description = (FileDirectory default pathName, '/*')).	repo := MCRepository location: 'http://source.squeak.org/trunk'.	self assert: (repo isKindOf: MCHttpRepository).	self assert: (repo description = 'http://source.squeak.org/trunk').	repo := MCRepository 		location: 'ftp://source.squeak.org/trunk' 		username: 'foo' 		password: 'bar'.	self assert: (repo isKindOf: MCFtpRepository).	self assert: (repo description = 'ftp://foo@source.squeak.org/trunk').! !!MCEmptyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCEmptyPackage'! !!ExceptionTests methodsFor: 'testing-outer' stamp: 'ar 1/8/2011 20:28'!testHandlerFromAction	"A test ensuring that nested exceptions work as expected."	| result |	result := [		[			[self error: 'trigger error'] on: ZeroDivide do: [ :ex | 'inner' ]		] on: Error do: [ :ex | 3 / 0 ]	] on: ZeroDivide do: [ :ex | 'outer' ].	self assert: result = 'outer'.! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:40' prior: 58620495!testMonticello	self testPackage: 'Monticello' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		Network		'PackageInfo-Base'		System		Tests		'ToolBuilder-Kernel'		'ToolBuilder-Morphic'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:41' prior: 58620827!testMorphic	self testPackage: 'Morphic' dependsExactlyOn: #(		Balloon		Collections		Compiler		EToys		Exceptions		Files		Graphics		Kernel		Monticello		MonticelloConfigurations		MorphicExtras		Multilingual		Network		ST80		Sound		System		'ToolBuilder-Kernel'		'ToolBuilder-Morphic'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:41' prior: 34417587!testSUnitGUI	self testPackage: 'SUnitGUI' dependsExactlyOn: #(		Collections		Graphics		Kernel		'PackageInfo-Base'		SUnit		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:42' prior: 58625249!testServices	self testPackage: 'Services-Base' dependsExactlyOn: #(		Collections		Compiler		Exceptions		Graphics		Kernel		Morphic		'PackageInfo-Base'		PreferenceBrowser		System		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:42' prior: 58626010!testSystem	self testPackage: 'System' dependsExactlyOn: #(		Collections		Balloon		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Monticello		MonticelloConfigurations		Morphic		MorphicExtras		Multilingual		Network		'PackageInfo-Base'		Sound		'ToolBuilder-Kernel'		Tools		TrueType	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:42' prior: 58626598!testToolBuilderMVC	self testPackage: 'ToolBuilder-MVC' dependsExactlyOn: #(		Collections		Exceptions		Graphics		ST80		'ToolBuilder-Kernel'		Tools	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:42' prior: 58627103!testToolBuilderSUnit	self testPackage: 'ToolBuilder-SUnit' dependsExactlyOn: #(		Collections		Kernel		'ToolBuilder-Kernel'	).! !!PackageDependencyTest methodsFor: 'tests' stamp: 'bp 10/31/2010 18:43' prior: 58627322!testTools	self testPackage: 'Tools' dependsExactlyOn: #(		Collections		Compiler		Compression		Exceptions		Files		Graphics		Kernel		Morphic		MorphicExtras		Multilingual		Network		'PackageInfo-Base'		ST80		System		'ToolBuilder-Kernel'	).! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'ul 1/12/2011 13:43'!compile: sourceString	text := sourceString.	self class		compileSilently: text		classified: 'generated'		notifying: self! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'ul 1/12/2011 13:50'!compiling: sourceCode shouldRaise: exceptionClass	self should: [ self compile: sourceCode ] raise: exceptionClass! !!CompilerExceptionsTest methodsFor: 'private' stamp: 'ul 1/12/2011 13:48'!removeGeneratedMethods	self class removeCategory: 'generated'! !!CompilerExceptionsTest methodsFor: 'running' stamp: 'ul 1/12/2011 13:49'!setUp	self removeGeneratedMethods! !!CompilerExceptionsTest methodsFor: 'running' stamp: 'ul 1/12/2011 13:49'!tearDown	self removeGeneratedMethods! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:57'!testAmbiguousSelector 	self 		compiling: 'griffle ^1--1'		shouldRaise: AmbiguousSelector;		compiling: 'griffle ^1@-1'		shouldRaise: AmbiguousSelector;		compiling: 'griffle ^1+-1'		shouldRaise: AmbiguousSelector ! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:58' prior: 57124001!testUndeclaredVariable	self 		compiling: 'griffle ^ goo'		shouldRaise: UndeclaredVariable;		compiling: 'griffle ^ [ goo ] value'		shouldRaise: UndeclaredVariable! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:57' prior: 57124213!testUndefinedVariable	self 		compiling: 'griffle | goo | ^ goo'		shouldRaise: UndefinedVariable;		compiling: 'griffle [ | goo | ^ goo ] value'		shouldRaise: UndefinedVariable! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:59' prior: 57124431!testUnknownSelector		self 		compiling: 'griffle self reallyHopeThisIsntImplementedAnywhere'		shouldRaise: UnknownSelector;		compiling: 'griffle [ self reallyHopeThisIsntImplementedAnywhere ] value'		shouldRaise: UnknownSelector! !!CompilerExceptionsTest methodsFor: 'tests' stamp: 'ul 1/12/2011 13:56' prior: 57124674!testUnusedVariable	self 		compiling: 'griffle | goo | ^nil'		shouldRaise: UnusedVariable;		compiling: 'griffle ^[ | goo | ]'		shouldRaise: UnusedVariable! !!CompilerExceptionsTest methodsFor: 'emulating' stamp: 'ul 1/12/2011 13:43' prior: 57124892!text		^text! !!MCMockPackageInfo class methodsFor: 'as yet unclassified' stamp: 'cwp 8/1/2003 20:31'!packageName	^ 'MonticelloMocks'! !!MCDirtyPackageInfo class methodsFor: 'as yet unclassified' stamp: 'ab 7/7/2003 23:21'!packageName	^ 'MCDirtyPackage'! !!MCChangeNotificationTest methodsFor: 'running' stamp: 'cmm 1/19/2011 16:01' prior: 59175945!setUp	super setUp.	workingCopy := MCWorkingCopy forPackage: self mockPackage! !!MorphicUIBugTest methodsFor: 'as yet unclassified' stamp: 'cmm 1/20/2011 10:41'!defaultTimeout	^ 60 "seconds"! !MCMockPackageInfo removeSelector: #packageName!CompilerExceptionsTest removeSelector: #unusedVariableSource!CompilerExceptionsTest removeSelector: #griffle!MCDirtyPackageInfo removeSelector: #packageName!MCEmptyPackageInfo removeSelector: #packageName!"Tests"!!DependencyBrowser class methodsFor: 'class initialization' stamp: 'cmm 1/8/2011 15:40'!initialize	"Initializes the receiver class" 	 TheWorldMenu registerOpenCommand: {'Dependency Browser'. {self. #open}}. ! !!SyntaxError methodsFor: 'accessing' stamp: 'sd 11/20/2005 21:27' prior: 30375974!category: aSymbol	"Record the message category of method being compiled. This is used when the user corrects the error and accepts."	category := aSymbol.! !!SyntaxError methodsFor: 'initialize-release' stamp: 'laza 1/26/2011 13:31'!release	| p |	(debugger isNil or: [		(p := debugger interruptedProcess) isNil or: [			p isTerminated]]) ifTrue: [^self].	p terminate! !!SyntaxError methodsFor: 'accessing' stamp: 'sd 11/20/2005 21:30' prior: 30376208!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class := aClass.	debugger := aDebugger.	selector := aClass parserClass new parseSelector: aString.	types := Scanner classPool at: #TypeTable.	"dictionary"	printables := '!!@#$%&*-_=+<>{}?/\,·£¢§¶ªºÚæÚ¯×¿«»`~`' asSet.	badChar := aString detect: [:aChar | (types at: aChar asciiValue ifAbsent: [#xLetter]) == #xBinary and: [			(printables includes: aChar) not]] ifNone: [nil].	contents := badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString].	category ifNil: [category := aClass organization categoryOfElement: selector].	category ifNil: [category := ClassOrganizer default].	doitFlag := flag! !!ProcessBrowser class methodsFor: 'class initialization' stamp: 'mtf 1/12/2011 19:34'!cleanUp"Remove terminated processes from my suspended list"	self suspendedProcesses keys do: [:ea |		ea isTerminated ifTrue: [self suspendedProcesses removeKey: ea]]! !"Tools"!!ReleaseBuilderTrunk class methodsFor: 'scripts' stamp: 'cmm 1/21/2011 13:53' prior: 58281463!prepareNewBuild "ReleaseBuilderTrunk prepareNewBuild"	"Prepare everything that should be done for a new image build"	SystemVersion setVersion.	MCMcmUpdater defaultUpdateURL: 'http://source.squeak.org/squeak42'.	SMLoaderPlus setDefaultFilters: (OrderedCollection with: #filterSafelyAvailable).	self 		setDisplayExtent: 800@600 ; 		setBackground ;		setPreferences.	"Make DependencyBrowser accessible on the open menu."	DependencyBrowser initialize.	Smalltalk cleanUp: true.	Undeclared removeUnreferencedKeys.	Smalltalk garbageCollect.	3 timesRepeat: 		[ Smalltalk garbageCollect. 		Symbol compactSymbolTable ]! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 1/12/2011 12:15'!setBackground	"World Color"	World fillStyle: ((GradientFillStyle colors: {Color white. Color lightGray. Color blue adjustSaturation: -0.88 brightness: -0.2. Color gray}) radial: true;			 origin: 20 @ 10;			 direction: 550@400;			 normal: nil;			 yourself)! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 1/3/2011 15:54'!setDisplayExtent: extent	DisplayScreen		depth: 32		width: extent x		height: extent y		fullscreen: false.	Display extent = extent ifFalse: [ self error: 'Display extent not set.' ]! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 1/12/2011 13:30'!setPreferences	Preferences 		installBrightWindowColors ;		setPreference: #scrollBarsWithoutMenuButton toValue: true ;		setPreference: #swapMouseButtons toValue: true ;		setPreference: #annotationPanes toValue: true ;		setPreference: #showSplitterHandles toValue: false ;		setPreference: #showBoundsInHalo toValue: true ;		setPreference: #alternateHandlesLook toValue: false ;		setPreference: #roundedMenuCorners toValue: false ;		setPreference: #roundedWindowCorners toValue: false.	PluggableButtonMorph roundedButtonCorners: false.	FillInTheBlankMorph roundedDialogCorners: false.	Workspace shouldStyle: false! !"ReleaseBuilder"!!SHTextStylerST80 class methodsFor: 'style table' stamp: 'ul 1/28/2011 01:00' prior: 56433281!defaultStyleTable	"color can be a valid argument to Color class>>colorFrom: , or nil to	use the editor text color.	Multiple emphases can be specified using an array e.g. #(bold italic).	If emphasis is not specified, #normal will be used.	if pixel height is not specified , then the editor font size will be used.	"								^#(	"(symbol	color		[emphasisSymbolOrArray		[textStyleName [pixelHeight]]])"			(default 								black 		)	(invalid 								red 			)	(excessCode 								red 			)	(comment 								(green muchDarker) 		italic)	(unfinishedComment 					(red muchDarker) 	italic)	(#'$'									(red muchDarker) 	)	(character								(red muchDarker) 	)	(integer									(red muchDarker) 	)	(number								(red muchDarker) 	)		(#-										(red muchDarker) 	)	(symbol									(blue muchDarker)			bold)		(stringSymbol							(blue muchDarker)			bold)		(literalArray							(blue muchDarker)			bold)	(string									(magenta muchDarker)	normal)	(unfinishedString						red			normal		)	(assignment								nil			bold			)	(ansiAssignment 						nil			bold)	(literal									nil			italic)	(keyword								(blue muchDarker)			)	(binary 								(blue muchDarker)			)		(unary									(blue muchDarker)			)	(incompleteKeyword						(gray muchDarker)			underlined)	(incompleteBinary 						(gray muchDarker)			underlined)		(incompleteUnary						(gray muchDarker)			underlined)	(undefinedKeyword						red			)	(undefinedBinary 						red			)		(undefinedUnary						red			)														(patternKeyword 						nil			bold)	(patternBinary 							nil			bold)	(patternUnary							nil			bold)		(#self 									(red muchDarker)	bold)	(#super									(red muchDarker)	bold) 	(#true 									(red muchDarker)	bold)	(#false 									(red muchDarker)	bold)	(#nil 									(red muchDarker)	bold)	(#thisContext 							(red muchDarker)	bold)	(#return								(red muchDarker)	bold)	(patternArg 							(blue muchDarker)			italic)		(methodArg 								(blue muchDarker)			italic)	(blockPatternArg 						(blue muchDarker)			italic)	(blockArg 								(blue muchDarker)			italic)	(argument 								(blue muchDarker)			italic)	(blockArgColon							black		) 	(leftParenthesis							black		) 	(rightParenthesis						black		) 	(leftParenthesis1						(green muchDarker)		) 	(rightParenthesis1						(green muchDarker)		) 	(leftParenthesis2						(magenta muchDarker)		) 	(rightParenthesis2						(magenta muchDarker)		) 	(leftParenthesis3						(red muchDarker)		) 	(rightParenthesis3						(red muchDarker)		) 	(leftParenthesis4						(green darker)		) 	(rightParenthesis4						(green darker)		) 	(leftParenthesis5						(orange darker)		) 	(rightParenthesis5						(orange darker)		) 	(leftParenthesis6						(magenta darker)		) 	(rightParenthesis6						(magenta darker)		) 	(leftParenthesis7						blue		) 	(rightParenthesis7						blue		) 	(blockStart 								black		) 	(blockEnd 								black		) 	(blockStart1								(green muchDarker)			) 	(blockEnd1								(green muchDarker)			) 	(blockStart2								(magenta muchDarker)		) 	(blockEnd2								(magenta muchDarker)		) 	(blockStart3								(red muchDarker)		) 	(blockEnd3								(red muchDarker)		) 	(blockStart4								(green darker)		) 	(blockEnd4								(green darker)		) 	(blockStart5								(orange darker)		) 	(blockEnd5								(orange darker)		) 	(blockStart6								(magenta darker)		) 	(blockEnd6								(magenta darker)		) 	(blockStart7								blue		) 	(blockEnd7								blue		) 																																																			(arrayStart								black		) 	(arrayEnd								black		) 	(arrayStart1							black		) 	(arrayEnd1								black		) 	(byteArrayStart								black		) 	(byteArrayEnd								black		) 	(byteArrayStart1							black		) 	(byteArrayEnd1								black		) 	(leftBrace 								black		) 	(rightBrace 								black		) 	(cascadeSeparator 						black		) 	(statementSeparator 						black		) 	(externalCallType 						black		) 	(externalCallTypePointerIndicator 		black		) 	(primitiveOrExternalCallStart 			black	bold	) 	(primitiveOrExternalCallEnd				black	bold	)	(methodTempBar							gray		) 	(blockTempBar 							gray		)	(blockArgsBar							gray		)	(primitive								(green muchDarker)		bold)	(pragmaKeyword						(green muchDarker)		bold)	(pragmaUnary							(green muchDarker)		bold)	(pragmaBinary							(green muchDarker)		bold)										(externalFunctionCallingConvention		(green muchDarker)		bold) 	(module									(green muchDarker)		bold)	(blockTempVar 							gray		italic)	(blockPatternTempVar					gray		italic)	(instVar 								black		bold)	(workspaceVar							black		bold)	(undefinedIdentifier						red			bold)	(incompleteIdentifier					(gray darker) 	(italic underlined))	(tempVar								(gray darker)	italic)	(patternTempVar						(gray darker)	italic)	(poolConstant							(gray darker)	italic)	(classVar								(gray darker)	bold)	(globalVar								black		bold) )							! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'ul 1/28/2011 01:00' prior: 58643162!subduedStyleTable	"color can be a valid argument to Color class>>colorFrom: , or nil to	use the editor text color.	Multiple emphases can be specified using an array e.g. #(bold italic).	If emphasis is not specified, #normal will be used.	if pixel height is not specified , then the editor font size will be used.	"								^#(	"(symbol	color		[emphasisSymbolOrArray		[textStyleName [pixelHeight]]])"			(default 								black 		)	(invalid 								red 			)	(excessCode 								red 			)	(comment 								(cyan muchDarker) 		)	(unfinishedComment 					(red muchDarker) 	italic)	(#'$'									(red muchDarker) 	)	(character								(red muchDarker) 	)	(integer									(red muchDarker) 	)	(number								(red muchDarker) 	)		(#-										(red muchDarker) 	)	(symbol									(blue muchDarker)			)		(stringSymbol							(blue muchDarker)			)		(literalArray							(blue muchDarker)			)	(string									(magenta muchDarker)	normal			)	(unfinishedString						red			normal			)	(assignment								nil			bold			)	(ansiAssignment 						nil			bold)	(literal									nil			italic)	(keyword								(blue muchDarker)			)	(binary 								(blue muchDarker)			)		(unary									(blue muchDarker)			)	(incompleteKeyword						(gray muchDarker)			underlined)	(incompleteBinary 						(gray muchDarker)			underlined)		(incompleteUnary						(gray muchDarker)			underlined)	(undefinedKeyword						red			)	(undefinedBinary 						red			)		(undefinedUnary						red			)														(patternKeyword 						nil			bold)	(patternBinary 							nil			bold)	(patternUnary							nil			bold)		(#self 									(red muchDarker)	)	(#super									(red muchDarker)	) 	(#true 									(red muchDarker)	)	(#false 									(red muchDarker)	)	(#nil 									(red muchDarker)	)	(#thisContext 							(red muchDarker)	)	(#return								(red muchDarker)	)	(patternArg 							(blue muchDarker)			)		(methodArg 								(blue muchDarker)			)	(blockPatternArg 						(blue muchDarker)			)	(blockArg 								(blue muchDarker)			)	(argument 								(blue muchDarker)			)	(blockArgColon							black		) 	(leftParenthesis							black		) 	(rightParenthesis						black		) 	(leftParenthesis1						(green muchDarker)		) 	(rightParenthesis1						(green muchDarker)		) 	(leftParenthesis2						(magenta muchDarker)		) 	(rightParenthesis2						(magenta muchDarker)		) 	(leftParenthesis3						(red muchDarker)		) 	(rightParenthesis3						(red muchDarker)		) 	(leftParenthesis4						(green darker)		) 	(rightParenthesis4						(green darker)		) 	(leftParenthesis5						(orange darker)		) 	(rightParenthesis5						(orange darker)		) 	(leftParenthesis6						(magenta darker)		) 	(rightParenthesis6						(magenta darker)		) 	(leftParenthesis7						blue		) 	(rightParenthesis7						blue		) 	(blockStart 								black		) 	(blockEnd 								black		) 	(blockStart1								(green muchDarker)			) 	(blockEnd1								(green muchDarker)			) 	(blockStart2								(magenta muchDarker)		) 	(blockEnd2								(magenta muchDarker)		) 	(blockStart3								(red muchDarker)		) 	(blockEnd3								(red muchDarker)		) 	(blockStart4								(green darker)		) 	(blockEnd4								(green darker)		) 	(blockStart5								(orange darker)		) 	(blockEnd5								(orange darker)		) 	(blockStart6								(magenta darker)		) 	(blockEnd6								(magenta darker)		) 	(blockStart7								blue		) 	(blockEnd7								blue		) 																																																			(arrayStart								black		) 	(arrayEnd								black		) 	(arrayStart1							black		) 	(arrayEnd1								black		) 	(byteArrayStart								black		) 	(byteArrayEnd								black		) 	(byteArrayStart1							black		) 	(byteArrayEnd1								black		) 	(leftBrace 								black		) 	(rightBrace 								black		) 	(cascadeSeparator 						black		) 	(statementSeparator 						black		) 	(externalCallType 						black		) 	(externalCallTypePointerIndicator 		black		) 	(primitiveOrExternalCallStart 			black		) 	(primitiveOrExternalCallEnd				black		)	(methodTempBar							gray		) 	(blockTempBar 							gray		)	(blockArgsBar							gray		)	(primitive								(green muchDarker)		bold)	(pragmaKeyword						(green muchDarker)		bold)	(pragmaUnary							(green muchDarker)		bold)	(pragmaBinary							(green muchDarker)		bold)										(externalFunctionCallingConvention		(green muchDarker)		bold) 	(module									(green muchDarker)		bold)	(blockTempVar 							gray		)	(blockPatternTempVar					gray		)	(instVar 								black		)	(workspaceVar							black		)	(undefinedIdentifier						red			)	(incompleteIdentifier					(gray darker) 	(italic underlined))	(tempVar								(gray darker)	)	(patternTempVar						(gray darker)	)	(poolConstant							(gray muchDarker)	)	(classVar								(gray muchDarker)	)	(globalVar								black		) )! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 1/28/2011 00:46' prior: 53770379!parseByteArray	[currentTokenFirst == $]] whileFalse: [		currentTokenFirst isDigit 			ifTrue: [				"do not parse the number, can be time consuming"				self scanPast: #number]			ifFalse: [				self failWhen: currentTokenFirst == $. .				self error]].	self scanPast: #byteArrayEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'ul 1/28/2011 00:54' prior: 34948228!parseSymbol	| c |	currentToken = '#' 		ifTrue: [			"if token is just the #, then scan whitespace and comments			and then process the next character.			Squeak allows space between the # and the start of the symbol 			e.g. # (),  #  a, #  'sym' "			self rangeType: #symbol.			self scanWhitespace].	c := self currentChar.	self failWhen: (c isNil or: [c isSeparator]).	c == $( 		ifTrue: [			self nextChar.			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.			^self parseArray].	c == $' ifTrue: [^self parseSymbolString].	c == $[ ifTrue: [			self nextChar.			self scanPast: #byteArrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.			^self parseByteArray].	((self isSelectorCharacter: c) or: [c == $-]) 		ifTrue: [^self parseSymbolSelector].	(c isLetter or: [		c == $: or: [ 		c == $_ and: [self allowUnderscoreSelectors] ] ]) 			ifTrue: [^self parseSymbolIdentifier].	^self parseCharSymbol! !"ShoutCore"!!SqueakLicenseHelp class methodsFor: 'pages' stamp: 'cmm 1/11/2011 19:22' prior: 33801308!officialLicense	^HelpTopic 		title: 'Official License - 4.0'		contents: 'Copyright (c) The individual, corporate, and institutional contributors who have collectively contributed elements to this software ("The Squeak Community"), 1996-2011 All rights reserved.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Portions of Squeak are covered by the following licenseCopyright (c) Xerox Corp. 1981, 1982 All rights reserved.Copyright (c) Apple Computer, Inc. 1985-1996 All rights reserved.Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at  http://www.apache.org/licenses/LICENSE-2.0Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.'! !"Help-Squeak-Project"!!SystemReporter methodsFor: 'private' stamp: 'laza 1/28/2011 09:57'!enumerate: aBlock on: aStream	self enumerate: aBlock startAt: 0 on: aStream! !!SystemReporter methodsFor: 'private' stamp: 'laza 1/28/2011 10:25'!enumerate: aBlock startAt: first on: aStream	"Utilitymethod to enumerate Options or Parameters from first to 1000"	| idx value |	idx := first.	[value := aBlock value: idx.	value = nil or: [idx > 1000]] whileFalse: [		aStream			nextPut: $#;			nextPutAll: idx printString;			tab;			nextPutAll: value; cr.		idx := idx + 1	].	idx = first ifTrue: [aStream nextPutAll: 'none'; cr]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 10:03' prior: 35279787!reportINI: aStream	| exePath iniData iniPath |	self header: 'VM Configuration' on: aStream.	exePath := Smalltalk vm vmFileName.	iniPath := (exePath copyUpToLast: $.), '.ini'.	aStream nextPutAll: iniPath; cr.	iniData := [		(FileStream readOnlyFileNamed: iniPath)			 contentsOfEntireFile	] on: Error do:[:ex| ex return: ex printString].	aStream		nextPutAll: iniData! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 09:42' prior: 35280257!reportImage: aStream	self header: 'Image' on: aStream.	aStream 		nextPutAll: SystemVersion current version; cr;		nextPutAll: Smalltalk image lastUpdateString; cr;		nextPutAll: Smalltalk image currentChangeSetString; cr;		nextPutAll: Smalltalk image imageName; cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 09:51' prior: 35280635!reportImageParameters: aStream	self header: 'Image Commandline Parameters' on: aStream.	self enumerate: [:idx | Smalltalk image argumentAt: idx] on: aStream.! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 10:07' prior: 35281535!reportOS: aStream	self header: 'Operating System/Hardware' on: aStream.	aStream		nextPutAll: Smalltalk os platformName; space;		nextPutAll: Smalltalk os osVersion; space;		nextPutAll: Smalltalk os platformSubtype; cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 08:58' prior: 35282972!reportVM: aStream	self header: 'Virtual Machine' on: aStream.	aStream		nextPutAll: (Smalltalk vm vmVersion); cr;		nextPutAll: (Smalltalk vm vmFileName); cr.	Smalltalk vm buildDate		ifNotNilDo: [:string | aStream nextPutAll: string; cr].	[Smalltalk vm platformSourceVersion		ifNotNilDo: [:v | aStream nextPutAll: 'platform sources revision ', v; cr]]			on: Warning do: ["unsupported primitive"].	[Smalltalk vm interpreterSourceVersion		ifNotNilDo: [:v | aStream nextPutAll: 'VMMaker versionString ', v; cr]]			on: Warning do: ["unsupported primitive"]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 09:58' prior: 35283252!reportVMOptions: aStream	self header: 'Virtual Machine Commandline Options' on: aStream.	self enumerate: [:idx | Smalltalk vm optionAt: idx] startAt: 1 on: aStream! !"SystemReporter"!!CrLfFileStream commentStamp: 'ul 12/26/2010 03:13' prior: 59265367!This class is now obsolete, use MultiByteFileStream instead.I am the same as a regular file stream, except that when I am in text mode, I will automatically convert line endings between the underlying platform's convention, and Squeak's convention of carriage-return only.  The goal is that Squeak text files can be treated as OS text files, and vice versa.In binary mode, I behave identically to a StandardFileStream.To enable CrLfFileStream as the default file stream class for an entire image, modify FileStream class concreteStream .There are two caveats on programming with CrLfFileStream.First, the choice of text mode versus binary mode affects which characters are visible in Squeak, and no longer just affects whether those characters are returned as Character's or as Integer's.  Thus the choice of mode needs to be made very carefully, and must be based on intent instead of convenience of representation.  The methods asString, asByteArray, asCharacter, and asInteger can be used to convert between character and integer representations.  (Arguably, file streams should accept either strings or characters in nextPut: and nextPutAll:, but that is not the case right now.)Second, arithmetic on positions no longer works, because one character that Squeak sees (carriage return) could map to two characters in the underlying file (carriage return plus line feed, on MS Windows and MS DOS).  Comparison between positions still works.  (This caveat could perhaps be fixed by maintaining a map between Squeak positions and positions in the underlying file, but it is complicated.  Consider, for example, updates to the middle of the file.  Also, consider that text files are rarely updated in the middle of the file, and that general random access to a text file is rarely very useful.  If general random access with specific file counts is desired, then the file is starting to sound like a binary file instead of a text file.)!!FileStream commentStamp: '<historical>' prior: 20679623!I represent a Stream that accesses a FilePage from a File. One use for my instance is to access larger "virtual Strings" than can be stored contiguously in main memory. I restrict the objects stored and retrieved to be Integers or Characters. An end of file pointer terminates reading; it can be extended by writing past it, or the file can be explicitly truncated.	To use the file system for most applications, you typically create a FileStream. This is done by sending a message to a FileDirectory (file:, oldFile:, newFile:, rename:newName:) which creates an instance of me. Accesses to the file are then done via my instance.*** On DOS, files cannot be shortened!!  ***  To overwrite a file with a shorter one, first delete the old file (FileDirectory deleteFilePath: 'Hard Disk:aFolder:dataFolder:foo') or (aFileDirectory deleteFileNamed: 'foo').  Then write your new shorter version.!!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ul 12/26/2010 03:14' prior: 19342098!new	self deprecated: 'This class is now obsolete, use MultiByteFileStream instead.'.	^ (MultiByteFileStream new) wantsLineEndConversion: true; yourself.! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:30'!encodeAndDecodeStdioFiles		<preference: 'Encode and decode the contents of stdio files.'		category: 'Files'		description: 'It true, then the contents of stdin, stdout and stderr are encoded/decoded using the system default text converter.'		type: #Boolean>	^EncodeAndDecodeStdioFiles ifNil: [ true ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:29'!encodeAndDecodeStdioFiles: aBoolean		EncodeAndDecodeStdioFiles := aBoolean.	self updateStdioFiles! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/23/2011 19:03'!flushAndVoidStdioFiles	StdioFiles ifNotNil: [		StdioFiles do: [ :file |			file ifNotNil: [ 				file isReadOnly ifFalse: [					[ file flush ]						on: Error						do: [ :ex | "care less" ] ] ] ].		self voidStdioFiles ]! !!FileStream class methodsFor: 'initialize-release' stamp: 'ul 1/24/2011 03:08' prior: 34448200!initialize	FileServices registerFileReader: self.	EncodeAndDecodeStdioFiles := true.	TheStdioHandles := Array new: 3.	Smalltalk		addToStartUpList: self after: SecurityManager; "the intent being before: AutoStart"		addToShutDownList: self after: SecurityManager! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:50'!newForStdio	"This is a hook for subclasses to initialize themselves properly."	^self new! !!FileStream class methodsFor: 'system startup' stamp: 'ul 1/4/2011 07:35'!shutDown: quitting	quitting ifTrue: [ self flushAndVoidStdioFiles ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:19'!standardIOStreamNamed: moniker forWrite: forWrite		| index |	index := #(stdin stdout stderr) identityIndexOf: moniker.	^((StdioFiles ifNil: [ StdioFiles := Array new: 3 ]) at: index)		ifNil: [			StdioFiles				at: index 				put: (					(TheStdioHandles at: index)						ifNil: [ ^self error: moniker, ' is unavailable' ]						ifNotNil: [ :handle |							self stdioStreamClass newForStdio								openOnHandle: handle								name: moniker								forWrite: forWrite ]) ]! !!FileStream class methodsFor: 'system startup' stamp: 'ul 1/4/2011 07:37'!startUp: resuming		resuming ifTrue: [		self voidStdioFiles.		[ TheStdioHandles := self stdioHandles ]			on: Error			do: [:ex|				TheStdioHandles isArray ifFalse: [					TheStdioHandles := Array new: 3 ] ] ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:04'!stderr	^Stderr ifNil: [ Stderr := self standardIOStreamNamed: #stderr forWrite: true ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:03'!stdin	^Stdin ifNil: [ Stdin := self standardIOStreamNamed: #stdin forWrite: false ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/1/2011 09:16'!stdioHandles	<primitive: 'primitiveFileStdioHandles' module: 'FilePlugin' error: ec>	self primitiveFailed! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/4/2011 07:30'!stdioStreamClass	^self encodeAndDecodeStdioFiles		ifTrue: [ MultiByteFileStream ]		ifFalse: [ StandardFileStream ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:04'!stdout	^Stdout ifNil: [ Stdout := self standardIOStreamNamed: #stdout forWrite: true ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/20/2011 02:16'!updateStdioFiles	"Make sure that all existing stdio files are instances of #stdioStreamClass."	StdioFiles ifNil: [ ^self ].	Stdin := Stdout := Stderr := nil.	StdioFiles := StdioFiles collect: [ :file |		file ifNotNil: [			file class == self stdioStreamClass				ifTrue: [ file ]				ifFalse: [					self stdioStreamClass newForStdio						copyFrom: file;						yourself ] ] ]! !!FileStream class methodsFor: 'stdio' stamp: 'ul 1/23/2011 19:03'!voidStdioFiles	 Stdin := Stdout := Stderr := StdioFiles := nil! !CrLfFileStream removeSelector: #openOnHandle:name:forWrite:!CrLfFileStream class removeSelector: #newForStdio!"Files"!!Stream methodsFor: 'accessing' stamp: 'ul 1/31/2011 01:37'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^self next: anInteger putAll: aCollection startingAt: startIndex! !!HashedCollection class methodsFor: 'initialize-release' stamp: 'ul 1/31/2011 00:05' prior: 58680783!cleanUp: aggressive	"Rehash all instances when cleaning aggressively"	aggressive ifTrue: [ self compactAll ]! !"Collections"!!CompiledMethod commentStamp: 'ul 1/29/2011 13:18' prior: 59252235!My instances are methods suitable for interpretation by the virtual machine.  This is the only class in the system whose instances intermix both indexable pointer fields and indexable integer fields.I'm a subclass of ByteArray to avoid duplicating some of ByteArray's methods, not because a CompiledMethod is-a ByteArray.	The current format of a CompiledMethod is as follows:	header (4 bytes)	literals (4 bytes each)	bytecodes  (variable)	trailer (variable)The header is a 30-bit integer with the following format:(index 0)	9 bits:	main part of primitive number   (#primitive)(index 9)	8 bits:	number of literals (#numLiterals)(index 17)	1 bit:	whether a large frame size is needed (#frameSize)(index 18)	6 bits:	number of temporary variables (#numTemps)(index 24)	4 bits:	number of arguments to the method (#numArgs)(index 28)	1 bit:	high-bit of primitive number (#primitive)(index 29)	1 bit:	flag bit, ignored by the VM  (#flag)The trailer has two variant formats.  In the first variant, the last byte is at least 252 and the last four bytes represent a source pointer into one of the sources files (see #sourcePointer).  In the second variant, the last byte is less than 252, and the last several bytes are a compressed version of the names of the method's temporary variables.  The number of bytes used for this purpose is the value of the last byte in the method.!MethodDictionary class removeSelector: #cleanUp:!"Kernel"!!SyntaxMorph methodsFor: 'pop ups' stamp: 'fbs 12/22/2010 07:25' prior: 30491813!replaceKeyWord: evt menuItem: stringMorph	"Replace my entire message (which may be multi-part) with the one specified.  Preserve all argument tiles, either in the new message or in the world outside the scriptor.  I am a SelectorNode or KeyWordNode."	| menu new news newSel mm newTree newRec newArgs top oldArgNodes share ctrY |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: {' 5'. Character space.}) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	mm := MessageSend receiver: 5 selector: newSel 			arguments: ((Array new: newSel numArgs) atAllPut: 5).	newTree := mm asTilesIn: Object globalNames: false.	newRec := newTree receiverNode.	newArgs := newTree argumentNodes.	ctrY := self fullBoundsInWorld center y.	top := self messageNode.	newRec owner replaceSubmorph: newRec by: top receiverNode.	oldArgNodes := top argumentNodes.	share := newArgs size min: oldArgNodes size.	(newArgs first: share) with: (oldArgNodes first: share) do: [:newNode :oldNode | 		newNode owner replaceSubmorph: newNode by: oldNode].	"later get nodes for objects of the right type for new extra args"	top owner replaceSubmorph: top by: newTree.	"Deposit extra args in the World"	(oldArgNodes copyFrom: share+1 to: oldArgNodes size) do: [:leftOver |		(leftOver parseNode class == LiteralNode and: [leftOver decompile asString = '5']) 			ifFalse: [newTree pasteUpMorph addMorphFront: leftOver.				leftOver position: newTree enclosingPane fullBoundsInWorld right - 20 @ ctrY.				ctrY := ctrY + 26]			ifTrue: [leftOver delete]].	newTree acceptIfInScriptor.! !!SyntaxMorph methodsFor: 'pop ups' stamp: 'fbs 12/22/2010 07:25' prior: 30493761!replaceSel: evt menuItem: stringMorph	"I rep a SelectorNode.  Replace my selector with new one that was just chosen from a menu"	| menu new old newSel ms oa na case news |	(menu := stringMorph owner owner) class == RectangleMorph ifTrue: [		menu delete].	new := stringMorph contents.	new first = $( ifTrue: [^ self].	"Cancel"	new first = $  ifTrue: [^ self].	"nothing"	news := String streamContents: [:strm | "remove fake args"		(new findBetweenSubStrs: {' 5'. Character space.}) do: [:part | strm nextPutAll: part]].	newSel := stringMorph valueOfProperty: #syntacticallyCorrectContents.	newSel ifNil: [newSel := news].	old := (ms := self findA: StringMorph) valueOfProperty: #syntacticallyCorrectContents.	old ifNil: [old := (self findA: StringMorph) contents].	oa := old numArgs.  na := newSel numArgs.  case := 5.	(oa = 1) & (na = 1) ifTrue: [case := 1]. 	(oa = 0) & (na = 0) ifTrue: [case := 2].	(oa = 1) & (na  = 0) ifTrue: [case := 3].	(oa = 0) & (na  = 1) ifTrue: [case := 4].	case <= 4 ifTrue: ["replace the selector"		ms contents: news.	"not multi-part"		ms setProperty: #syntacticallyCorrectContents toValue: newSel].	case = 3 ifTrue: [owner tossOutArg: 1].	case = 4 ifTrue: [self addArg: 1].	"more cases here.  Rebuild the entire MessageNode"		self acceptIfInScriptor.! !"EToys"!!StandardFileStream commentStamp: 'ul 12/6/2009 05:13' prior: 34701785!Provides a simple, platform-independent, interface to a file system. The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 swI implement a simple read buffering scheme with the variables defined in PositionableStream (which are unused in me otherwise) in the following way:	collection	<ByteString> or <ByteArray>	This is the buffer.	position	<Integer>	The relative position in the buffer. Greater or equal to zero.	readLimit	<Integer>	The number of bytes buffered. Greater or equal to zero.Read buffering is enabled with #enableReadBuffering, disabled with #disableReadBuffering and it is enabled by default. The buffer is filled when a read attempt of an unbuffered absolute position is requested, or when a negative repositioning is made (with #position: with an argument < than the current absolute position) to an absolute position which is not buffered. In the first case, the buffer is positioned to the given absolute position. In the latter case the repositioning is made to the requested absolute position minus fourth of the buffer size. This means that further small negative repositionings won't result in buffer flushing. This is really useful when filing in code.The read buffer is flushed (#flushReadBuffer) whenever a write attempt is made.The buffer state is valid if and only if collection is not nil and position < readLimit.!StandardFileStream class removeSelector: #voidStdioFiles!StandardFileStream class removeSelector: #stdout!StandardFileStream class removeSelector: #stdioHandles!StandardFileStream class removeSelector: #stdin!StandardFileStream class removeSelector: #stderr!StandardFileStream class removeSelector: #startUp:!StandardFileStream class removeSelector: #standardIOStreamNamed:forWrite:!StandardFileStream class removeSelector: #shutDown:!StandardFileStream class removeSelector: #newForStdio!StandardFileStream class removeSelector: #initialize!StandardFileStream class removeSelector: #flushAndVoidStdioFiles!"Files"!!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'fbs 12/22/2010 07:23' prior: 23949898!testCompileCharacter	self assertPragma: 'foo: $a' givesKeyword: #foo: arguments: #( $a ).	self assertPragma: 'foo: $ ' givesKeyword: #foo: arguments: { Character space }.! !"KernelTests"!!SystemDictionary methodsFor: 'classes and traits' stamp: 'fbs 1/9/2011 16:56' prior: 58577702!classOrTraitNamed: aString 	"aString is either a class or trait name or a class or trait name followed by ' class' or 'classTrait' respectively.	Answer the class or metaclass it names."	| meta baseName |	(aString endsWith: ' class')		ifTrue: [meta := true.				baseName := aString copyFrom: 1 to: aString size - 6]		ifFalse: [			(aString endsWith: ' classTrait')				ifTrue: [					meta := true.					baseName := aString copyFrom: 1 to: aString size - 11]				ifFalse: [					meta := false.					baseName := aString]].	^self at: baseName asSymbol ifPresent:		[ :global | 		global isBehavior ifTrue:			[ meta				ifFalse: [ global ]				ifTrue: [ global classSide ]]]! !!SmalltalkImage methodsFor: 'private' stamp: 'laza 1/30/2011 04:39' prior: 58613587!getSystemAttribute: attributeID 	"Optional. Answer the string for the system attribute with the given 	integer ID. Answer nil if the given attribute is not defined on this 	platform. On platforms that support invoking programs from command 	lines (e.g., Unix), this mechanism can be used to pass command line 	arguments to programs written in Squeak.	By convention, the first command line argument that is not a VM	configuration option is considered a 'document' to be filed in. Such a	document can add methods and classes, can contain a serialized object,	can include code to be executed, or any combination of these.	Currently defined attributes include: 	-1000	1000th command line argument that specify VM options	...	-1		first command line argument that specify VM options	0		the full path name for currently executing VM			(or, on some platforms, just the path name of the VM's directory) 	1		full path name of this image (better use primImageName instead)	2		a Squeak document to open, if any 	3		first command line argument for Squeak programs	...	1000	1000th command line argument for Squeak programs	1001	this platform's operating system 'Mac OS', 'Win32', 'unix', ...	1002	operating system version	1003	this platform's processor type	1004	vm version	1005	window system name	1006	vm build id	1201	always returns 255 (Mac OS only)	1202	file last error (Mac OS only)	10001	hardware details (Win32 only)	10002	operating system details (Win32 only)	10003	graphics hardware details (Win32 only)	"	<primitive: 149>	^ nil! !"System"!!TextEditor methodsFor: 'typing support' stamp: 'ul 1/28/2011 23:58' prior: 57271438!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit := beginTypeInBlock		ifNil: [self openTypeIn. UndoSelection := self nullText. self stopIndex]		ifNotNil: [self startOfTyping].	self markIndex: startIndex.	startIndex < saveLimit ifTrue: [		newBackovers := self startOfTyping - startIndex.		beginTypeInBlock := self startIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage arguments size > 0 ifTrue: [			UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers] ].	self zapSelectionWith: self nullText.	self unselect! !"Morphic"!!MultiByteFileStreamTest methodsFor: 'testing' stamp: 'ul 1/31/2011 02:47'!testNextPutAllStartingAt	| result |	fileName := 'foonextputallstartingat.txt'.	MultiByteFileStream forceNewFileNamed: fileName do: [ :file |		{ 'abcde' asWideString. 'abcde' } do: [ :string |			file 				next: 1 putAll: string startingAt: 5;				next: 3 putAll: string startingAt: 2;				next: 1 putAll: string startingAt: 1 ] ].	result := StandardFileStream readOnlyFileNamed: fileName do: [ :file |		file binary; contents ].	self assert: #[101 98 99 100 97 101 98 99 100 97] equals: result! !"MultilingualTests"!!SystemDictionaryTest methodsFor: 'testing - classes and traits' stamp: 'fbs 1/9/2011 16:53'!testClassOrTraitNamedReturnsClassForClasses	self assert: Object ==  (Smalltalk globals classOrTraitNamed: 'Object').	self assert: Object ==  (Smalltalk globals classOrTraitNamed: #Object).! !!SystemDictionaryTest methodsFor: 'testing - classes and traits' stamp: 'fbs 1/9/2011 16:53'!testClassOrTraitNamedReturnsNilForGlobals	self assert: nil = (Smalltalk globals classOrTraitNamed: 'Undeclared').	self assert: nil = (Smalltalk globals classOrTraitNamed: #Undeclared).! !"Tests"!!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:10' prior: 58451984!buildClassDepsWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Required Classes' ;		list: #classDeps; 		getIndex: #classDepsIndex; 		setIndex: #classDepsIndex:; 		menu: #classDepsMenu:; 		keyPress: #classDepsKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:13' prior: 58452325!buildClassListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Client classes' ;		list: #classList; 		getIndex: #classListIndex; 		setIndex: #classListIndex:; 		menu: #classListMenu:; 		keyPress: #classListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:14' prior: 58452666!buildMessageListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Client methods' ;		list: #messageList; 		getIndex: #messageListIndex; 		setIndex: #messageListIndex:; 		menu: #messageListMenu:; 		keyPress: #messageListKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:10' prior: 58453019!buildPackageDepsWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Required Packages' ;		list: #packageDeps; 		getIndex: #packageDepsIndex; 		setIndex: #packageDepsIndex:; 		menu: #packageDepsMenu:; 		keyPress: #packageDepsKey:from:.	^listSpec! !!DependencyBrowser methodsFor: 'toolbuilder' stamp: 'cmm 1/29/2011 17:08' prior: 58453372!buildPackageListWith: builder	| listSpec |	listSpec := builder pluggableListSpec new.	listSpec 		model: self;		name: 'Packages' ;		list: #packageList; 		getIndex: #packageListIndex; 		setIndex: #packageListIndex:; 		menu: #packageListMenu:; 		keyPress: #packageListKey:from:.	^listSpec! !!Workspace class methodsFor: 'preferences' stamp: 'cmm 1/10/2011 15:53' prior: 58104679!shouldStyle	<preference: 'Shout styling in Workspace' 		category: 'browsing' 		description: 'After enabled, new workspaces use shout to style their contents.' 		type: #Boolean>	^ ShouldStyle ifNil: [ false ]! !"Tools"!!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 1/30/2011 15:07'!openWelcomeWorkspace	TheWorldMainDockingBar instance		showWelcomeText: #welcomeToSqueak42		label: 'Welcome to Squeak 4.2'		in: (140 @ 140 extent: 500 @ 300)! !!ReleaseBuilderTrunk class methodsFor: 'scripts' stamp: 'ul 1/31/2011 00:04' prior: 35618754!prepareNewBuild	"ReleaseBuilderTrunk prepareNewBuild"	"Prepare everything that should be done for a new image build"	SystemVersion setVersion.	SMLoaderPlus		setDefaultFilters: (OrderedCollection with: #filterSafelyAvailable).	self setDisplayExtent: 800 @ 600;		 setBackground;		 setPreferences;		 switchTo42Repository;		 openWelcomeWorkspace.	"Make DependencyBrowser accessible on the open menu."	DependencyBrowser initialize.	Smalltalk cleanUp: true.	Undeclared removeUnreferencedKeys.	Smalltalk garbageCollect! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 1/30/2011 15:09' prior: 35619803!setDisplayExtent: extent	DisplayScreen		depth: 32		width: extent x		height: extent y		fullscreen: false.	Display extent = extent ifFalse: [ Warning signal: 'Display extent not set to 800@600.' ]! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 1/30/2011 15:04'!switchTo42Repository	| old41Repository |	MCMcmUpdater defaultUpdateURL: 'http://source.squeak.org/squeak42'.	old41Repository := MCRepositoryGroup default repositories				detect: [:each | each description includesSubString: 'squeak41'].	old41Repository		ifNotNil: [MCRepositoryGroup default removeRepository: old41Repository].	MCRepositoryGroup default		addRepository: (MCHttpRepository				location: 'http://source.squeak.org/squeak42'				user: 'squeak'				password: 'squeak')! !"ReleaseBuilder"!!MacUnicodeInputInterpreter methodsFor: 'keyboard' stamp: 'bf 1/31/2011 16:59' prior: 23360062!nextCharFrom: sensor firstEvt: evtBuf 	| keyValue mark |	keyValue := evtBuf at: 6.	mark := self japaneseSpecialMark: keyValue.	mark notNil		ifTrue: [^ mark].	keyValue < 256		ifTrue: [^ (Character value: keyValue) squeakToIso].	"Smalltalk systemLanguage charsetClass charFromUnicode: keyValue."	^ Unicode value: keyValue! !!MultiByteFileStream methodsFor: 'private basic' stamp: 'ul 1/31/2011 02:05'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^super next: anInteger putAll: aCollection startingAt: startIndex! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:08'!next: anInteger putAll: aCollection startingAt: startIndex	(self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [		^super next: anInteger putAll: aCollection startingAt: startIndex ].	^converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !!MultiByteFileStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:07' prior: 35590669!nextPutAll: aCollection	(self isBinary or: [aCollection class == ByteArray]) ifTrue: [		^ super nextPutAll: aCollection.	].	^converter nextPutAll: aCollection toStream: self! !!TextConverter methodsFor: 'conversion' stamp: 'ul 1/31/2011 02:35'!next: anInteger putAll: aString startingAt: startIndex toStream: aStream	"Handle fast conversion if ByteString"		| lastIndex nextIndex |	aString class == ByteString ifFalse: [		startIndex to: startIndex + anInteger - 1 do: [ :index |			self nextPut: (aString at: index) toStream: aStream ].		^aString ].	aStream isBinary ifTrue: [		aStream basicNext: anInteger putAll: aString startingAt: startIndex.		^aString ].	lastIndex := startIndex.	[ (nextIndex := ByteString 		findFirstInString: aString		inSet: latin1Map		startingAt: lastIndex) = 0 or: [ nextIndex > anInteger ] ] whileFalse: [			aStream				basicNext: nextIndex - lastIndex putAll: aString startingAt: lastIndex;				basicNextPutAll: (latin1Encodings at: (aString byteAt: nextIndex) + 1).			lastIndex := nextIndex + 1 ].	aStream basicNext: anInteger - lastIndex + startIndex putAll: aString startingAt: lastIndex.	^aString! !!TextConverter methodsFor: 'conversion' stamp: 'ul 1/31/2011 01:52' prior: 53815861!nextPutAll: aString toStream: aStream	"Handle fast conversion if ByteString"		^self next: aString size putAll: aString startingAt: 1 toStream: aStream! !!MultiByteBinaryOrTextStream methodsFor: 'private basic' stamp: 'ul 1/31/2011 02:04'!basicNext: anInteger putAll: aCollection startingAt: startIndex	^super next: anInteger putAll: aCollection startingAt: startIndex! !!MultiByteBinaryOrTextStream methodsFor: 'public' stamp: 'ul 1/31/2011 02:08'!next: anInteger putAll: aCollection startingAt: startIndex	(self isBinary or: [ aCollection class == ByteArray ]) ifTrue: [		^super next: anInteger putAll: aCollection startingAt: startIndex ].	^self converter next: anInteger putAll: aCollection startingAt: startIndex toStream: self! !MacUnicodeInputInterpreter removeSelector: #majorMinorBuildFrom:satisfies:!MacUnicodeInputInterpreter removeSelector: #keyValueIndex!MacUnicodeInputInterpreter removeSelector: #initialize!"Multilingual"!ReleaseBuilderTrunk prepareNewBuild!----SNAPSHOT----{31 January 2011 . 10:54:26 am} Squeak4.2-10950.image priorSource: 1621863!!MethodDictionary commentStamp: 'nice 2/1/2011 02:47' prior: 59350496!I am a special dictionary holding methods. I am just like a normal Dictionary, except that I am implemented differently.  Each Class has an instance of MethodDictionary to hold the correspondence between selectors (names of methods) and methods themselves.In a normal Dictionary, the instance variable 'array' holds an array of Associations.  Since there are thousands of methods in the system, these Associations waste space.  Each MethodDictionary is a variable object, with the list of keys (selector Symbols) in the variable part of the instance.  The variable 'array' holds the values, which are CompiledMethods.I also maintain the following invariant: (self basicAt: index) isNil = (array at: index) isNil.!----STARTUP----{4 February 2011 . 10:51:53 am} as /home/cmm/4dst/dev/src/squeak-4.1/basic/Squeak4.2-10950.image!!MethodDictionary methodsFor: 'accessing' stamp: 'nice 2/1/2011 02:23' prior: 34496645!includesKey: aSymbol	"This override assumes that instVarsInclude: uses a fast primitive"	aSymbol ifNil: [^ false].	^ self instVarsInclude: aSymbol! !"Kernel"!!StrikeFont commentStamp: '<historical>' prior: 35319515!I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the glyphs. Characters are mapped to glyphs by using the characterToGyphMap.Subclasses can have non-trivial mapping rules as well as different representations for glyphs sizes (e.g., not using an xTable). If so, these classes should return nil when queried for xTable and/or the characterToGlyphMap. This will cause the CharacterScanner primitive to fail and query the font for the width of a character (so that a more programatical approach can be implemented).For display, fonts need to implement two messages:	#installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColorThis method installs the receiver (a font) on the given DisplayContext (which may be an instance of BitBlt or Canvas (or any of it's subclasses). The font should take the appropriate action to initialize the display context so that further display operations can be optimized.	#displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDeltaThis method is called for each subsequent run of characters in aString which is to be displayed with the (previously installed) settings.!!WarpBlt methodsFor: 'setup' stamp: 'nice 2/1/2011 02:38' prior: 35205422!cellSize: s	"Set the number of samples used for averaging"	cellSize := s.	cellSize = 1 ifTrue: [^ self].	"Install the colorMap to used for mapping the averaged RGBA 32bit pixels to the	destination depth. Note that we need to install the 32->32 color map explicitly because	the VM will substitute a colorMap derived from sourceForm->destForm mapping which	is just plain wrong for <32 source and 32bit dest depth"	(destForm depth = 32 and: [sourceForm notNil and: [sourceForm depth < 32]])		ifTrue:[colorMap := ColorMap shifts: #(0 0 0 0) masks:#(16rFF0000 16rFF00 16rFF 16rFF000000) colors: nil]		ifFalse:[colorMap := Color colorMapIfNeededFrom: 32 to: destForm depth].! !"Graphics"!!Installer class methodsFor: 'repositories' stamp: 'mtf 2/3/2011 03:56'!cobalt	^ self monticello http: 'http://croquet-src-01.oit.duke.edu:8886'! !"Installer-Core"!!TheWorldMainDockingBar methodsFor: 'submenu - help' stamp: 'mtf 2/3/2011 18:55' prior: 35145679!extendingTheSystem	^'"Note: Please edit this workspace and add your own contributions.To submit it to the inbox open the Monticello browser and submit it from there.Save the package ''* Morphic'' to the inbox.""Updating your system:The following will set the default update URL to receive development updates. For developers and dare-devils only."MCMcmUpdater defaultUpdateURL: ''http://source.squeak.org/trunk''."Installing new packages: The following expression show how to load many interesting packages into Squeak.""FFI: http://source.squeak.org/FFI.html"(Installer repository: ''http://source.squeak.org/FFI'')	install: ''FFI-Pools'';	install: ''FFI-Kernel'';	install: ''FFI-Tests'';	install: ''FFI-Win32'';	install: ''FFI-MacOS'';	install: ''FFI-Unix''."OCompletion provides source code completion as you type"(Installer ss project: ''OCompletion'') install: ''Ocompletion''.(Smalltalk at: #ECToolSet) register.(Smalltalk at: #ToolSet) default: (Smalltalk at: #ECToolSet)."Omnibrowser, including Refactoring engine"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfOmniBrowser''.((Smalltalk at: #ConfigurationOfOmniBrowser) project perform: #lastVersion) load: #( Dev )."Seaside 2.8 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28''."WAKom startOn: 9090""Seaside 2.8 Examples http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside28Examples''.(Smalltalk at: #ConfigurationOfSeaside28Examples) load."Seaside 3.0 http://www.seaside.st"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfSeaside30''.(Smalltalk at: #ConfigurationOfSeaside30) load.(Smalltalk at: #WAPharoServerAdaptorBrowser) open."Pier CMS: http://www.piercms.com"(Installer ss project: ''MetacelloRepository'') install: ''ConfigurationOfPier2''.(Smalltalk at: #ConfigurationOfPier2) load.(Installer lukas project: ''pier2'') install: ''Pier-Blog''.(Installer lukas project: ''pier2'') install: ''Pier-Book''.(Installer lukas project: ''pier2addons'') install: ''Pier-Setup''.(Smalltalk at: #PRDistribution)  new register."Open Cobalt: http://opencobalt.org (Best to run this from an image in an open cobalt directory)"Installer ss project: ''TweakCore''; install: ''update''.[Installer ss project: ''TweakExtras''; install: ''update'']	on: (Smalltalk at: #CUnsynchronizedModification) do: [:ex | ex resume].Installer cobalt project: ''Tweak'';	answer: ''Would you like to conserve memory at all costs?'' with: true;	answer: ''Password for interactive VNC connections?'' with: ''cobalt'';	answer: ''Would you like to add the RFBServer to the World open menu?'' with: true;	install: ''update''!!]style[(189 2 139 15 17 1 32 3 108 2 40 12 11 1 30 3 8 1 11 3 8 1 12 3 8 1 11 3 8 1 11 3 8 1 11 3 8 1 10 3 57 12 2 1 8 1 13 2 8 1 13 13 3 1 10 2 8 13 3 1 8 2 8 12 3 1 10 4 44 11 2 1 8 1 21 2 8 1 28 14 3 1 1 28 7 11 11 2 5 4 3 5 35 12 2 1 8 1 21 2 8 1 26 2 21 2 44 12 2 1 8 1 21 2 8 1 34 13 3 1 33 2 4 3 35 12 2 1 8 1 21 2 8 1 26 13 3 1 25 2 4 13 3 1 28 2 4 3 34 12 2 1 8 1 21 2 8 1 22 13 3 1 21 2 4 14 5 1 8 1 7 2 8 1 11 13 5 1 8 1 7 2 8 1 11 13 5 1 8 1 13 2 8 1 12 13 3 1 15 3 3 1 8 101 460 1)c000120120,cblack;,c000120120,cblack;,c000000120,cblack;,c120000120,cblack;,c000120120,cblack;,c000120120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000125125,cblack;,c000000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c125000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000000125,cblack;,c000120120,cblack;,c000000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000123,cblack;,c123000123,cblack;,c000000120,cblack;,c000000120,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000000123,cblack;,c000120120,cblack;,c000000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000120120,cblack;,c000120120,cblack;,c000000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000120120,cblack;,c000000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000120120,cblack;,c000000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c120000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,c000000120,cblack;,,cblack;!!' readStream nextChunkText! !"Morphic"!!LocaleTest methodsFor: 'testing' stamp: 'ul 1/31/2011 03:56' prior: 34299166!testIsFontAvailable	"self debug: #testIsFontAvailable"		<timeout: 60> "takes quite a while"	Preferences restoreFontsAfter: [		| currentDefaultTextStyle |		currentDefaultTextStyle := TextStyle default.		[ 			TextStyle setDefault: (TextStyle actualTextStyles at: #Accuny).			(Locale isoLanguage: 'ja') languageEnvironment removeFonts.			self assert: (Locale isoLanguage: 'en') languageEnvironment isFontAvailable.			"Next test should fail after installing Japanese font"			self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable not.			(Locale isoLanguage: 'ja') languageEnvironment installFont.			self assert: (Locale isoLanguage: 'ja') languageEnvironment isFontAvailable ]				ensure: [ TextStyle setDefault: currentDefaultTextStyle ] ].! !LocaleTest removeSelector: #expectedFailures!"Tests"!!DependencyBrowser methodsFor: 'contents' stamp: 'laza 2/3/2011 18:33' prior: 58451455!aboutToStyle: aStyler	"This is a notification that aStyler is about to re-style its text.	Set the classOrMetaClass in aStyler, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	| selectedClass |	selectedClass := self classListSelection ifNil:[^false].	self messageListSelection ifNil:[^false].	aStyler classOrMetaClass: ((self messageListSelection == #Definition) ifFalse:[Smalltalk classNamed: selectedClass]).	^true! !!DependencyBrowser methodsFor: 'contents' stamp: 'laza 2/3/2011 18:30' prior: 58460137!selectedMessage	"Source code for currently selected message"	| className methodName mref |	className := self classListSelection.	methodName := self messageListSelection.	mref := (classDeps at: self classDepsSelection ifAbsent:[#()])		detect:[:mr| mr classSymbol = className 						and:[mr methodSymbol = methodName]]		ifNone:[nil].	mref ifNil:[^self class comment].	mref methodSymbol == #Definition ifTrue:[^mref actualClass definition].	^mref sourceCode! !"Tools"!!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 2/4/2011 10:49'!releaseRepository	^ MCHttpRepository		location: self repositoryUrl , '/squeak42'		user: 'squeak'		password: 'squeak'! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 2/1/2011 18:01'!repositoryUrl 	^ 'http://source.squeak.org'! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 2/4/2011 10:39' prior: 35660717!switchTo42Repository	| old41Repository |	MCMcmUpdater defaultUpdateURL: 'http://source.squeak.org/squeak42'.	old41Repository := MCRepositoryGroup default repositories				detect: [:each | each description includesSubString: 'squeak41'] ifNone: [nil].	old41Repository		ifNotNil: [MCRepositoryGroup default removeRepository: old41Repository].	MCRepositoryGroup default addRepository: self releaseRepository! !!ReleaseBuilderTrunk class methodsFor: 'scripts' stamp: 'cmm 2/1/2011 17:59'!transferCurrentPackages	| trunkRep releaseRep |	trunkRep := self trunkRepository.	releaseRep := self releaseRepository.	MCWorkingCopy allManagers		do: [:eachWorkingCopy | eachWorkingCopy ancestors				do: [:eachVersionInfo | (releaseRep includesVersionNamed: eachVersionInfo name)						ifFalse: [releaseRep								storeVersion: (trunkRep versionFromFileNamed: eachVersionInfo name , '.mcz')]]]! !!ReleaseBuilderTrunk class methodsFor: 'private' stamp: 'cmm 2/4/2011 10:46'!trunkRepository	^ MCHttpRepository		location: self repositoryUrl , '/trunk'		user: 'squeak'		password: 'squeak'! !"ReleaseBuilder"!!SystemReporter commentStamp: 'laza 1/18/2011 12:04' prior: 35274008!SystemReporter offers a window where information about the system is gathered. This can be easily copied to the clipboard and be attached to a bug report for better identification of the context the bug occured in.To extend the SystemReporter:	- add a method		reportXYZ: aStream	  to the reporting category	- insert a line		add: #XYZ method: #reportXYZ	  to the initialize method!!SystemReporter methodsFor: 'initialize-release' stamp: 'laza 2/1/2011 09:05' prior: 35277980!initialize	self		add: #Image method: #reportImage;		add: #'Image Parameters' method: #reportImageParameters;		add: #'Image Sources' method: #reportSources;		add: #'Image Preferences' method: #reportPreferences;		add: #'MC Repositories' method: #reportRepositories;		add: #'MC Working Copies' method: #reportWorkingCopies;		add: #'VM General' method: #reportVM;		add: #'VM Options' method: #reportVMOptions;		add: #'VM Modules' method: #reportModules;		add: #'VM Parameters' method: #reportVMParameters;		add: #'VM Stats' method: #reportVMStats.	Smalltalk os platformName = 'Win32' ifTrue: [		self			add: #'VM Configuration' method: #reportINI.		].	self		add: #'OS General' method: #reportOS.	Smalltalk os platformName = 'Win32' ifTrue: [		self			add: #'OS Details' method: #reportOSDetails;			add: #'Hardware Details' method: #reportHardwareDetails;			add: #'GFX Hardware Details' method: #reportGFXDetails.		].	self		add: #'Tiny Benchmarks' method: #reportTinyBenchmarks;		add: #'SUnit' method: #reportTestRunner;		add: #'Debug Log' method: #reportDebugLog.	categoriesSelected := Set with: #Image with: #'VM General'.	self updateReport! !!SystemReporter methodsFor: 'accessing-categories' stamp: 'laza 1/31/2011 20:59' prior: 35278983!refresh	tinyBenchmarksResult := testRunner := nil.	self updateReport! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 2/1/2011 09:28'!reportDebugLog: aStream	| logFilename logStream contents |	self header: 'Debug Logfile' on: aStream.	logFilename := Smalltalk image squeakErrorFileName.	logStream := nil.	[		[			logStream := FileStream readOnlyFileNamed: logFilename.			aStream nextPutAll: logStream name; cr; cr.			contents := logStream contents.			aStream				nextPutAll: 					((contents isNil or: [contents size = 0])						ifTrue: ['<empty>']						ifFalse: [contents]);				cr		] on: Error do: [:ex |			aStream				nextPutAll: (					ex class = FileDoesNotExistException						ifTrue: [logFilename, ' not found']						ifFalse: [ex description]);				cr		]	] ensure: [		logStream ifNotNil: [logStream close]	]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/30/2011 05:04' prior: 35635345!reportImage: aStream	self header: 'Image' on: aStream.	aStream 		nextPutAll: Smalltalk image imageName; cr;		nextPutAll: SystemVersion current version; cr;		nextPutAll: Smalltalk image lastUpdateString; cr;		nextPutAll: Smalltalk image currentChangeSetString; cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 13:51'!reportPreferences: aStream	| booleanPrefs prefs valuePrefs attribute falseTA trueTA |	prefs := Preferences dictionaryOfPreferences.	booleanPrefs := prefs select: [:each | each type = #Boolean].	valuePrefs := prefs select: [:each | each type = #Number or: [each type = #String]].	trueTA := TextColor black.	falseTA := TextColor gray.	booleanPrefs := booleanPrefs asSortedCollection: [:a :b | a name <= b name].  	self header: 'Boolean Preferences' on: aStream.	booleanPrefs do: [:each |		attribute := each preferenceValue ifTrue: [trueTA] ifFalse: [falseTA].		aStream withAttribute: attribute do: [			aStream			nextPutAll: each name;			tab;  			nextPutAll: each preferenceValue printString;			cr]].	aStream cr.	self header: 'Value Preferences' on: aStream.	valuePrefs do: [:each |		aStream			nextPutAll: each name;			tab;  			nextPutAll: each preferenceValue printString;			cr].! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:14'!reportRepositories: aStream	self header: 'Monticello Repositories' on: aStream.	MCRepositoryGroup default repositories do: [:each | aStream nextPutAll: each description; cr]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/31/2011 21:16'!reportTestRunner: aStream	testRunner ifNil: [| runAllTests |		runAllTests := UIManager confirm: 'Running all Tests\will take long time' withCRs.		runAllTests			ifTrue: [testRunner := TestRunner new runAll]			ifFalse: [				categoriesSelected remove: #SUnit. 				^self changed: #categorySelected]].	self header: 'SUnit Results' on: aStream.	aStream nextPutAll: testRunner statusText; cr; cr.	self header: 'Failed Tests' on: aStream.	testRunner failedList do: [:each | aStream nextPutAll: each; cr].	aStream cr.	self header: 'Errors' on: aStream.	testRunner errorList do: [:each | aStream nextPutAll: each; cr]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/31/2011 21:13' prior: 35282627!reportTinyBenchmarks: aStream	tinyBenchmarksResult ifNil: [		UIManager inform: 'Running the Benchmarks\will take a few seconds' withCRs.		tinyBenchmarksResult := 0 tinyBenchmarks].	self header: 'Tiny Benchmarks' on: aStream.	aStream nextPutAll: tinyBenchmarksResult; cr! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/30/2011 05:05' prior: 35636267!reportVM: aStream	self header: 'Virtual Machine' on: aStream.	aStream		nextPutAll: (Smalltalk vm vmFileName); cr;		nextPutAll: (Smalltalk vm vmVersion); cr.	Smalltalk vm buildDate		ifNotNilDo: [:string | aStream nextPutAll: string; cr].	[Smalltalk vm platformSourceVersion		ifNotNilDo: [:v | aStream nextPutAll: 'platform sources revision ', v; cr]]			on: Warning do: ["unsupported primitive"].	[Smalltalk vm interpreterSourceVersion		ifNotNilDo: [:v | aStream nextPutAll: 'VMMaker versionString ', v; cr]]			on: Warning do: ["unsupported primitive"]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:43'!reportVMParameters: aStream	| vmParameters |	self header: 'Virtual Machine Parameters' on: aStream.	vmParameters := Smalltalk vm getVMParameters.	#(		1	'end of old-space (0-based, read-only)'		2	'end of young-space (read-only)'		3	'end of memory (read-only)'		4	'allocationCount (read-only)'		5	'allocations between GCs (read-write)'		6	'survivor count tenuring threshold (read-write)'		7	'full GCs since startup (read-only)'		8	'total milliseconds in full GCs since startup (read-only)'		9	'incremental GCs since startup (read-only)'		10	'total milliseconds in incremental GCs since startup (read-only)'		11	'tenures of surving objects since startup (read-only)'		12	'specific to the translating VM'		13  'specific to the translating VM'		14  'specific to the translating VM'		15  'specific to the translating VM'		16  'specific to the translating VM'		17  'specific to the translating VM'		18  'specific to the translating VM'		19  'specific to the translating VM'		20  'specific to the translating VM'		21	'root table size (read-only)'		22	'root table overflows since startup (read-only)'		23	'bytes of extra memory to reserve for VM buffers, plugins, etc.'		24	'memory threshold above which shrinking object memory (rw)'		25	'memory headroom when growing object memory (rw)'		26  'interruptChecksEveryNms - force an ioProcessEvents every N milliseconds, in case the image  is not calling getNextEvent often (rw)'		27	'number of times mark loop iterated for current IGC/FGC (read-only) includes ALL marking'		28	'number of times sweep loop iterated  for current IGC/FGC (read-only)'		29	'number of times make forward loop iterated for current IGC/FGC (read-only)'		30	'number of times compact move loop iterated for current IGC/FGC (read-only)'		31	'number of grow memory requests (read-only)'		32	'number of shrink memory requests (read-only)'		33	'number of root table entries used for current IGC/FGC (read-only)'		34	'number of allocations done before current IGC/FGC (read-only)'		35	'number of survivor objects after current IGC/FGC (read-only)'		36  'millisecond clock when current IGC/FGC completed (read-only)'		37  'number of marked objects for Roots of the world, not including Root Table entries for current IGC/FGC (read-only)'		38  'milliseconds taken by current IGC  (read-only)'		39  'Number of finalization signals for Weak Objects pending when current IGC/FGC completed (read-only)'		40  'VM word size - 4 or 8 (read-only)'	) pairsDo: [:idx :desc |		aStream			nextPut: $#;			nextPutAll: idx printString;			tab;			nextPutAll: (vmParameters at: idx) printString;			tab;			nextPutAll: desc;			cr]! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:30'!reportVMStats: aStream	self header: 'Virtual Machine Statistics' on: aStream.	aStream		nextPutAll: Smalltalk vm vmStatisticsReportString! !!SystemReporter methodsFor: 'reporting' stamp: 'laza 1/28/2011 12:08'!reportWorkingCopies: aStream	| list |	self header: 'Monticello Working Copies' on: aStream.	list := MCWorkingCopy allManagers asSortedCollection: [:a :b | a name <= b name]  .	list do: [:each | aStream nextPutAll: each description; cr]! !"SystemReporter"!ReleaseBuilderTrunk prepareNewBuild!----SNAPSHOT----{4 February 2011 . 10:53:13 am} Squeak4.2-10966.image priorSource: 2110117!----QUIT/NOSAVE----{4 February 2011 . 10:53:18 am} Squeak4.2-10966.image priorSource: 2132091!----STARTUP----{4 February 2011 . 1:06:34 pm} as /home/cmm/4dst/dev/src/squeak-4.1/basic/Squeak4.2-10966.image!----QUIT----{4 February 2011 . 1:07 pm} Squeak4.2-10966.image priorSource: 2132091!